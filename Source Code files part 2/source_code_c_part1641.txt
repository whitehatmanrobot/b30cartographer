        break;

        case TYPE_TCPCONN:
            SaveData_TCPCONN( pTable, item, pOid );
            break;

        case TYPE_TCP6CONN:
            SaveData_TCP6CONN( pTable, item, pOid );
            break;

        case TYPE_UDP:
        case TYPE_UDP6:
            SaveData_UDP( pTable, item, pOid );
            break;

        case TYPE_UDPCONN:
            SaveData_UDPCONN( pTable, item, pOid );
            break;

        case TYPE_UDP6LISTENER:
            SaveData_UDP6LISTENER( pTable, item, pOid );
            break;

        }

        SnmpUtilOidCpy( &oidBackup, &(item.name));
        SnmpUtilVarBindFree( &item );
        item.name.idLength = oidBackup.idLength;
        item.name.ids = oidBackup.ids;
    }

    SnmpUtilVarBindFree( &item );

    return ( NO_ERROR );
}


//*****************************************************************************
//
// Name:        SaveData_IF
//
// Description: Saves an element of the data in the interface table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_IF( GenericTable    *pEntry,
                  RFC1157VarBind   item,
                  OIDdef          *pOid )
{
    IfEntry  *pIf = ( IfEntry *)pEntry;
    uchar    *pTmp;
    ulong     i;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_IF_INDEX:
        pIf->Info.if_index = item.value.asnValue.number;
        break;

    case ID_IF_DESC:
        pIf->Info.if_descrlen = item.value.asnValue.string.length;

        for ( i = 0; i < pIf->Info.if_descrlen; i++ )
        {
            pIf->Info.if_descr[i] = item.value.asnValue.string.stream[i];
        }
        break;

    case ID_IF_TYPE:
        pIf->Info.if_type = item.value.asnValue.number;
        break;

    case ID_IF_MTU:
        pIf->Info.if_mtu = item.value.asnValue.number;
        break;

    case ID_IF_SPEED:
        pIf->Info.if_speed = item.value.asnValue.number;
        break;

    case ID_IF_PHYSADDR:
        pIf->Info.if_physaddrlen = item.value.asnValue.string.length;

        for ( i = 0; i < pIf->Info.if_physaddrlen; i++ )
        {
            pIf->Info.if_physaddr[i] = item.value.asnValue.string.stream[i];
        }
        break;

    case ID_IF_ADMINSTATUS:
        pIf->Info.if_adminstatus = item.value.asnValue.number;
        break;

    case ID_IF_OPERSTATUS:
        pIf->Info.if_operstatus = item.value.asnValue.number;
        break;

    case ID_IF_LASTCHANGE:
        pIf->Info.if_lastchange = item.value.asnValue.number;
        break;

    case ID_IF_INOCTETS:
        pIf->Info.if_inoctets = item.value.asnValue.number;
        break;

    case ID_IF_INUCASTPKTS:
        pIf->Info.if_inucastpkts = item.value.asnValue.number;
        break;

    case ID_IF_INNUCASTPKTS:
        pIf->Info.if_innucastpkts = item.value.asnValue.number;
        break;

    case ID_IF_INDISCARDS:
        pIf->Info.if_indiscards = item.value.asnValue.number;
        break;

    case ID_IF_INERRORS:
        pIf->Info.if_inerrors = item.value.asnValue.number;
        break;

    case ID_IF_INUKNOWNPROTOS:
        pIf->Info.if_inunknownprotos = item.value.asnValue.number;
        break;

    case ID_IF_OUTOCTETS:
        pIf->Info.if_outoctets = item.value.asnValue.number;
        break;

    case ID_IF_OUTUCASTPKTS:
        pIf->Info.if_outucastpkts = item.value.asnValue.number;
        break;

    case ID_IF_OUTNUCASTPKTS:
        pIf->Info.if_outnucastpkts = item.value.asnValue.number;
        break;

    case ID_IF_OUTDISCARDS:
        pIf->Info.if_outdiscards = item.value.asnValue.number;
        break;

    case ID_IF_OUTERRORS:
        pIf->Info.if_outerrors = item.value.asnValue.number;
        break;

    case ID_IF_OUTQLEN:
        pIf->Info.if_outqlen = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_IP
//
// Description: Saves an element of the data in the IP table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_IP( GenericTable    *pEntry,
                  RFC1157VarBind   item,
                  OIDdef          *pOid )
{
    IpEntry  *pIp = (IpEntry *)pEntry;
    uchar    *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_IP_FORWARDING:
        pIp->Info.ipsi_forwarding = item.value.asnValue.number;
        break;

    case ID_IP_DEFAULTTTL:
        pIp->Info.ipsi_defaultttl = item.value.asnValue.number;
        break;

    case ID_IP_INRECEIVES:
        pIp->Info.ipsi_inreceives = item.value.asnValue.number;
        break;

    case ID_IP_INHDRERRORS:
        pIp->Info.ipsi_inhdrerrors = item.value.asnValue.number;
        break;

    case ID_IP_INADDRERRORS:
        pIp->Info.ipsi_inaddrerrors = item.value.asnValue.number;
        break;

    case ID_IP_FORWDATAGRAMS:
        pIp->Info.ipsi_forwdatagrams = item.value.asnValue.number;
        break;

    case ID_IP_INUNKNOWNPROTOS:
        pIp->Info.ipsi_inunknownprotos = item.value.asnValue.number;
        break;

    case ID_IP_INDISCARDS:
        pIp->Info.ipsi_indiscards = item.value.asnValue.number;
        break;

    case ID_IP_INDELIVERS:
        pIp->Info.ipsi_indelivers = item.value.asnValue.number;
        break;

    case ID_IP_OUTREQUESTS:
        pIp->Info.ipsi_outrequests = item.value.asnValue.number;
        break;

    case ID_IP_OUTDISCARDS:
        pIp->Info.ipsi_outdiscards = item.value.asnValue.number;
        break;

    case ID_IP_OUTNOROUTES:
        pIp->Info.ipsi_outnoroutes = item.value.asnValue.number;
        break;

    case ID_IP_REASMTIMEOUTS:
        pIp->Info.ipsi_reasmtimeout = item.value.asnValue.number;
        break;

    case ID_IP_REASMREQDS:
        pIp->Info.ipsi_reasmreqds = item.value.asnValue.number;
        break;

    case ID_IP_REASMOKS:
        pIp->Info.ipsi_reasmoks = item.value.asnValue.number;
        break;

    case ID_IP_REASMFAILS:
        pIp->Info.ipsi_reasmfails = item.value.asnValue.number;
        break;

    case ID_IP_FRAGOKS:
        pIp->Info.ipsi_fragoks = item.value.asnValue.number;
        break;

    case ID_IP_FRAGFAILS:
        pIp->Info.ipsi_fragfails = item.value.asnValue.number;
        break;

    case ID_IP_FRAGCREATES:
        pIp->Info.ipsi_fragcreates = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_IPAddr
//
// Description: Saves an element of the data in the IP table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_IPAddr( GenericTable    *pEntry,
                      RFC1157VarBind   item,
                      OIDdef          *pOid )
{
    IpAddrEntry  *pIpAddr = (IpAddrEntry *)pEntry;
    uchar        *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_IPADDR_ADDR:
        pTmp = (uchar *)&(pIpAddr->Info.iae_addr);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_IPADDR_INDEX:
        pIpAddr->Info.iae_index = item.value.asnValue.number;
        break;

    case ID_IPADDR_MASK:
        pTmp = (uchar *)&(pIpAddr->Info.iae_mask);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_IPADDR_BCASTADDR:
        pIpAddr->Info.iae_bcastaddr = item.value.asnValue.number;
        break;

    case ID_IPADDR_REASMSIZE:
        pIpAddr->Info.iae_reasmsize = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_ROUTE
//
// Description: Saves an element of the data in the ROUTE table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_ROUTE( GenericTable    *pEntry,
                     RFC1157VarBind   item,
                     OIDdef          *pOid )
{
    RouteEntry  *pRoute = (RouteEntry *)pEntry;
    uchar       *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_ROUTE_DEST:
        pTmp = (uchar *)&(pRoute->Info.ire_dest);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_ROUTE_IFINDEX:
        pRoute->Info.ire_index = item.value.asnValue.number;
        break;

    case ID_ROUTE_METRIC1:
        pRoute->Info.ire_metric1 = item.value.asnValue.number;
        break;

    case ID_ROUTE_METRIC2:
        pRoute->Info.ire_metric2 = item.value.asnValue.number;
        break;

    case ID_ROUTE_METRIC3:
        pRoute->Info.ire_metric3 = item.value.asnValue.number;
        break;

    case ID_ROUTE_METRIC4:
        pRoute->Info.ire_metric4 = item.value.asnValue.number;
        break;

    case ID_ROUTE_NEXTHOP:
        pTmp = (uchar *)&(pRoute->Info.ire_nexthop);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_ROUTE_TYPE:
        pRoute->Info.ire_type = item.value.asnValue.number;
        break;

    case ID_ROUTE_PROTO:
        pRoute->Info.ire_proto = item.value.asnValue.number;
        break;

    case ID_ROUTE_AGE:
        pRoute->Info.ire_age = item.value.asnValue.number;
        break;

    case ID_ROUTE_MASK:
        pTmp = (uchar *)&(pRoute->Info.ire_mask);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_ROUTE_METRIC5:
        pRoute->Info.ire_metric5 = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_ARP
//
// Description: Saves an element of the data in the ARP table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_ARP( GenericTable    *pEntry,
                   RFC1157VarBind   item,
                   OIDdef          *pOid )
{
    ArpEntry  *pArp = (ArpEntry *)pEntry;
    uchar     *pTmp;
    ulong      i;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_ARP_IFINDEX:
        pArp->Info.inme_index = item.value.asnValue.number;
        break;

    case ID_ARP_PHYSADDR:
        pArp->Info.inme_physaddrlen = item.value.asnValue.string.length;

        for ( i = 0; i < pArp->Info.inme_physaddrlen; i++ )
        {
            pArp->Info.inme_physaddr[i] = item.value.asnValue.string.stream[i];
        }
        break;

    case ID_ARP_NETADDR:
        pTmp = (uchar *)&(pArp->Info.inme_addr);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_ARP_TYPE:
        pArp->Info.inme_type = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_ICMP
//
// Description: Saves an element of the data in the ICMP table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_ICMP( GenericTable    *pEntry,
                    RFC1157VarBind   item,
                    OIDdef          *pOid )
{
    IcmpEntry  *pIcmp = (IcmpEntry *)pEntry;
    uchar      *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_ICMP_INMSGS:
        pIcmp->InInfo.icmps_msgs = item.value.asnValue.number;
        break;

    case ID_ICMP_INERRORS:
        pIcmp->InInfo.icmps_errors = item.value.asnValue.number;
        break;

    case ID_ICMP_INDESTUNREACHES:
        pIcmp->InInfo.icmps_destunreachs = item.value.asnValue.number;
        break;

    case ID_ICMP_INTIMEEXCDS:
        pIcmp->InInfo.icmps_timeexcds = item.value.asnValue.number;
        break;

    case ID_ICMP_INPARMPROBS:
        pIcmp->InInfo.icmps_parmprobs = item.value.asnValue.number;
        break;

    case ID_ICMP_INSRCQUENCHS:
        pIcmp->InInfo.icmps_srcquenchs = item.value.asnValue.number;
        break;

    case ID_ICMP_INREDIRECTS:
        pIcmp->InInfo.icmps_redirects = item.value.asnValue.number;
        break;

    case ID_ICMP_INECHOS:
        pIcmp->InInfo.icmps_echos = item.value.asnValue.number;
        break;

    case ID_ICMP_INECHOREPS:
        pIcmp->InInfo.icmps_echoreps = item.value.asnValue.number;
        break;

    case ID_ICMP_INTIMESTAMPS:
        pIcmp->InInfo.icmps_timestamps = item.value.asnValue.number;
        break;

    case ID_ICMP_INTIMESTAMPREPS:
        pIcmp->InInfo.icmps_timestampreps = item.value.asnValue.number;
        break;

    case ID_ICMP_INADDRMASKS:
        pIcmp->InInfo.icmps_addrmasks = item.value.asnValue.number;
        break;

    case ID_ICMP_INADDRMASKREPS:
        pIcmp->InInfo.icmps_addrmaskreps = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTMSGS:
        pIcmp->OutInfo.icmps_msgs = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTERRORS:
        pIcmp->OutInfo.icmps_errors = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTDESTUNREACHES:
        pIcmp->OutInfo.icmps_destunreachs = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTTIMEEXCDS:
        pIcmp->OutInfo.icmps_timeexcds = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTPARMPROBS:
        pIcmp->OutInfo.icmps_parmprobs = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTSRCQUENCHS:
        pIcmp->OutInfo.icmps_srcquenchs = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTREDIRECTS:
        pIcmp->OutInfo.icmps_redirects = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTECHOS:
        pIcmp->OutInfo.icmps_echos = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTECHOREPS:
        pIcmp->OutInfo.icmps_echoreps = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTTIMESTAMPS:
        pIcmp->OutInfo.icmps_timestamps = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTTIMESTAMPREPS:
        pIcmp->OutInfo.icmps_timestampreps = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTADDRMASKS:
        pIcmp->OutInfo.icmps_addrmasks = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTADDRMASKREPS:
        pIcmp->OutInfo.icmps_addrmaskreps = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_TCP
//
// Description: Saves an element of the data in the TCP table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_TCP( GenericTable    *pEntry,
                   RFC1157VarBind   item,
                   OIDdef          *pOid )
{
    TcpEntry  *pTcp = (TcpEntry *)pEntry;
    uchar     *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_TCP_RTOALGORITHM:
        pTcp->Info.ts_rtoalgorithm = item.value.asnValue.number;
        break;

    case ID_TCP_RTOMIN:
        pTcp->Info.ts_rtomin = item.value.asnValue.number;
        break;

    case ID_TCP_RTOMAX:
        pTcp->Info.ts_rtomax = item.value.asnValue.number;
        break;

    case ID_TCP_MAXCONN:
        pTcp->Info.ts_maxconn = item.value.asnValue.number;
        break;

    case ID_TCP_ACTIVEOPENS:
        pTcp->Info.ts_activeopens = item.value.asnValue.number;
        break;

    case ID_TCP_PASSIVEOPENS:
        pTcp->Info.ts_passiveopens = item.value.asnValue.number;
        break;

    case ID_TCP_ATTEMPTFAILS:
        pTcp->Info.ts_attemptfails = item.value.asnValue.number;
        break;

    case ID_TCP_ESTABRESETS:
        pTcp->Info.ts_estabresets = item.value.asnValue.number;
        break;

    case ID_TCP_CURRESTABS:
        pTcp->Info.ts_currestab = item.value.asnValue.number;
        break;

    case ID_TCP_INSEGS:
        pTcp->Info.ts_insegs = item.value.asnValue.number;
        break;

    case ID_TCP_OUTSEGS:
        pTcp->Info.ts_outsegs = item.value.asnValue.number;
        break;

    case ID_TCP_RETRANSSEGS:
        pTcp->Info.ts_retranssegs = item.value.asnValue.number;
        break;

    case ID_TCP_INERRS:
        pTcp->Info.ts_inerrs = item.value.asnValue.number;
        break;

    case ID_TCP_OUTRSTS:
        pTcp->Info.ts_outrsts = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_TCPCONN
//
// Description: Saves an element of the data in the TCP connection table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_TCPCONN( GenericTable    *pEntry,
                       RFC1157VarBind   item,
                       OIDdef          *pOid )
{
    TcpConnEntry  *pTcp = (TcpConnEntry *)pEntry;
    uchar         *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_TCPCONN_STATE:
        pTcp->Info.tct_state = item.value.asnValue.number;
        break;

    case ID_TCPCONN_LOCALADDR:
        pTmp = (uchar *)&(pTcp->Info.tct_localaddr);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_TCPCONN_LOCALPORT:
        pTcp->Info.tct_localport = item.value.asnValue.number;
        break;

    case ID_TCPCONN_REMOTEADDR:
        pTmp = (uchar *)&(pTcp->Info.tct_remoteaddr);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_TCPCONN_REMOTEPORT:
        pTcp->Info.tct_remoteport = item.value.asnValue.number;
        break;

    }
}

void SaveData_TCP6CONN( GenericTable    *pEntry,
                        RFC1157VarBind   item,
                        OIDdef          *pOid )
{
    Tcp6ConnEntry *pTcp = (Tcp6ConnEntry *)pEntry;
    uchar         *pTmp;
    int            len, i, curr = 10;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_TCPNEWCONN_STATE:

        // skip local address type
        curr++;

        len = item.name.ids[curr++];
        for ( i = 0; i < sizeof(IN6_ADDR); i++ ) 
        {
            pTcp->Info.tct_localaddr.s6_bytes[i] = (BYTE)item.name.ids[curr++];
        }
        if ( len > sizeof(IN6_ADDR) ) 
        {
            pTmp = (uchar*)&pTcp->Info.tct_localscopeid;
            for ( i = 0; i < sizeof(ULONG); i++ ) 
            {
                pTmp[i] = (BYTE)item.name.ids[curr++];
            }
            pTcp->Info.tct_localscopeid = ntohl(pTcp->Info.tct_localscopeid);
        }
        pTcp->Info.tct_localport = item.name.ids[curr++];

        // skip remote address type
        curr++; 

        len = item.name.ids[curr++];
        for ( i = 0; i < sizeof(IN6_ADDR); i++ ) 
        {
            pTcp->Info.tct_remoteaddr.s6_bytes[i] = (BYTE)item.name.ids[curr++];
        }
        if ( len > sizeof(IN6_ADDR) ) {
            pTmp = (uchar*)&pTcp->Info.tct_remotescopeid;
            for ( i = 0; i < sizeof(ULONG); i++ ) 
            {
                pTmp[i] = (BYTE)item.name.ids[curr++];
            }
            pTcp->Info.tct_remotescopeid = ntohl(pTcp->Info.tct_remotescopeid);
        }
        pTcp->Info.tct_remoteport = item.name.ids[curr++];

        pTcp->Info.tct_state = item.value.asnValue.number;
        break;
    }
}


//*****************************************************************************
//
// Name:        SaveData_UDP
//
// Description: Saves an element of the data in the UDP table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_UDP( GenericTable    *pEntry,
                   RFC1157VarBind   item,
                   OIDdef          *pOid )
{
    UdpEntry  *pUdp = (UdpEntry *)pEntry;
    uchar     *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_UDP_INDATAGRAMS:
        pUdp->Info.us_indatagrams = item.value.asnValue.number;
        break;

    case ID_UDP_NOPORTS:
        pUdp->Info.us_noports = item.value.asnValue.number;
        break;

    case ID_UDP_INERRORS:
        pUdp->Info.us_inerrors = item.value.asnValue.number;
        break;

    case ID_UDP_OUTDATAGRAMS:
        pUdp->Info.us_outdatagrams = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_UDPCONN
//
// Description: Saves an element of the data in the UDP connection table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_UDPCONN( GenericTable    *pEntry,
                       RFC1157VarBind   item,
                       OIDdef          *pOid )
{
    UdpConnEntry  *pUdp = (UdpConnEntry *)pEntry;
    uchar         *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_UDPCONN_LOCALADDR:
        pTmp = (uchar *)&(pUdp->Info.ue_localaddr);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_UDPCONN_LOCALPORT:
        pUdp->Info.ue_localport = item.value.asnValue.number;
        break;

    }
}

void SaveData_UDP6LISTENER( GenericTable    *pEntry,
                            RFC1157VarBind   item,
                            OIDdef          *pOid )
{
    Udp6ListenerEntry *pUdp = (Udp6ListenerEntry *)pEntry;
    uchar             *pTmp;
    int                len, i, curr = 10;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_UDPLISTENER_LOCALPORT:
        // skip local address type
        curr++;

        len = item.name.ids[curr++];
        for ( i = 0; i < sizeof(IN6_ADDR); i++ ) 
        {
            pUdp->Info.ule_localaddr.s6_bytes[i] = (BYTE)item.name.ids[curr++];
        }
        if ( len > sizeof(IN6_ADDR) ) {
            pTmp = (uchar*)&pUdp->Info.ule_localscopeid;
            for ( i = 0; i < sizeof(ULONG); i++ ) 
            {
                pTmp[i] = (BYTE)item.name.ids[curr++];
            }
            pUdp->Info.ule_localscopeid = ntohl(pUdp->Info.ule_localscopeid);
        }
        pUdp->Info.ule_localport = item.value.asnValue.number;
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\commands\ipconfig\info.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    info.c

Abstract:

    exports GetNetworkInformation routine

--*/

#include <precomp.h>

//
// seems that if WINS addresses not specified, NetBT reports 127.0.0.0 so if
// this value is returned, we won't display them
//

#define LOCAL_WINS_ADDRESS  0x0000007f  // 127.0.0.0

#define New(Size) LocalAlloc( LPTR, Size)
#define Delete(Ptr) if( NULL != Ptr ) LocalFree( Ptr )

#define CheckBoolError(Internal) if( FALSE == fSuccess ) {\
    (*InternalError) = Internal; Error = GetLastError(); break; }

#define CheckError(Internal) if( NO_ERROR != Error ) {\
    (*InternalError) = Internal; break; }


VOID
FreeIfInfo(
    IN OUT PINTERFACE_NETWORK_INFO IfInfo
    )
{
    if( NULL == IfInfo ) return;
    Delete( IfInfo->FriendlyName );
    Delete( IfInfo->ConnectionName );
    Delete( IfInfo->DhcpClassId );
    Delete( IfInfo->IpAddress );
    Delete( IfInfo->Ipv6Address );
    Delete( IfInfo->IpMask );
    Delete( IfInfo->Router );
    Delete( IfInfo->WinsServer );
    Delete( IfInfo->DnsServer );
    Delete( IfInfo->Ipv6DnsServer );
    Delete( IfInfo );
}

VOID
FreeNetworkInfo(
    IN OUT PNETWORK_INFO NetInfo
    )
{
    DWORD i;

    if( NULL == NetInfo ) return;
    for( i = 0; i < NetInfo->nInterfaces ; i ++ ) {
        FreeIfInfo( NetInfo->IfInfo[i] );
    }

    Delete( NetInfo->SuffixSearchList );
    Delete( NetInfo );
}

DWORD
MapIfType(
    IN OUT PINTERFACE_NETWORK_INFO IfInfo,
    IN ULONG IfType
    )
{
    DWORD i;
    DWORD Map[][2] = {
        IF_TYPE_OTHER, IfTypeOther,
        IF_TYPE_ETHERNET_CSMACD, IfTypeEthernet,
        IF_TYPE_ISO88025_TOKENRING, IfTypeTokenring,
        IF_TYPE_FDDI, IfTypeFddi,
        IF_TYPE_PPP, IfTypePPP,
        IF_TYPE_SOFTWARE_LOOPBACK, IfTypeLoopback,
        IF_TYPE_SLIP, IfTypeSlip,
        IF_TYPE_TUNNEL, IfTypeTunnel,
        IF_TYPE_IEEE1394, IfType1394
    };

    for( i = 0; i < sizeof(Map)/sizeof(Map[0]); i ++ ) {
        if( Map[i][0] == IfType ) {
            IfInfo->IfType = Map[i][1];
            return NO_ERROR;
        }
    }

    return ERROR_NOT_FOUND;
}

LPWSTR
GetProperty(
    IN HDEVINFO hdi,
    IN SP_DEVINFO_DATA *deid,
    IN ULONG Property
    )
{
    BOOL fSuccess;
    ULONG Error, cbSize;
    LPWSTR RetVal;

    cbSize = 0;
    fSuccess = SetupDiGetDeviceRegistryPropertyW(
        hdi, deid, Property, NULL, NULL, 0, &cbSize
        );
    if( fSuccess ) {
        RetVal = LocalAlloc(LPTR, sizeof(WCHAR));
        if( NULL == RetVal ) return NULL;
        (*RetVal) = L'\0';
        return RetVal;
    }

    Error = GetLastError();
    if( ERROR_INSUFFICIENT_BUFFER != Error ) return NULL;

    RetVal = New( cbSize * sizeof(WCHAR) );
    if( NULL == RetVal ) return NULL ;

    fSuccess = SetupDiGetDeviceRegistryPropertyW(
        hdi, deid, Property, NULL, (PVOID)RetVal, cbSize, NULL
        );
    if( FALSE == fSuccess ) {
        Error = GetLastError();
        Delete( RetVal );
        SetLastError(Error);
        return NULL;
    }

    return RetVal;
}

LPWSTR
GetDescriptionFromGuid(
    IN GUID *Guid
    )
{
    WCHAR InstanceIdBuf[1000];
    ULONG BufSizeInWChars = sizeof(InstanceIdBuf)/sizeof(WCHAR);
    HRESULT hr;
    HDEVINFO hdi;
    SP_DEVINFO_DATA deid;
    BOOL fSuccess;
    ULONG Error;
    LPWSTR DescrName = NULL;

    deid.cbSize = sizeof(SP_DEVINFO_DATA);
    hr = HrPnpInstanceIdFromGuid(Guid, InstanceIdBuf, BufSizeInWChars);
    if( !SUCCEEDED(hr) ) {
        SetLastError( HRESULT_CODE(hr) );
        IPCFG_TRACE(IPCFG_TRACE_TCPIP, ("HrPnpInstanceIdFromGuid returns 0x%lx (%d)\n", hr, hr));
        return NULL;
    }

    hdi = SetupDiCreateDeviceInfoList(&GUID_DEVCLASS_NET, NULL);
    if( INVALID_HANDLE_VALUE != hdi ) {
        fSuccess = SetupDiOpenDeviceInfoW(hdi, InstanceIdBuf, NULL, 0, &deid);
        if( fSuccess ) {
            DescrName = GetProperty(hdi, &deid, SPDRP_FRIENDLYNAME);
            if( NULL == DescrName ) {
                Error = GetLastError();
                if( ERROR_SUCCESS != Error ) {
                    DescrName = GetProperty( hdi, &deid, SPDRP_DEVICEDESC );
                    if( NULL == DescrName ) {
                        Error = GetLastError();
                    } else {
                        Error = ERROR_SUCCESS;
                    }
                } else {
                    //
                    // Error already set.
                    //
                }
            } else {
                //
                // We succeeded..
                //
                Error = ERROR_SUCCESS;
            }
        } else {
            Error = GetLastError();
        }
        SetupDiDestroyDeviceInfoList(hdi);
    } else {
        Error = GetLastError();
    }

    SetLastError(Error);
    return (ERROR_SUCCESS == Error)?DescrName:NULL;
}

LPWSTR
GetDescription(
    IN GUID *Guid,
    IN LPWSTR GuidString
    )
{
    LPWSTR RetVal = GetDescriptionFromGuid(Guid);
    WCHAR GuidStringBuf[500];
    GUID GuidStruct;
    ULONG Status;

    if( NULL != RetVal ) return RetVal;

    SetLastError( ERROR_CAN_NOT_COMPLETE );
    if( NULL == GuidString ) return NULL;
    if( wcslen(GuidString)*sizeof(WCHAR) >= sizeof(GuidStringBuf)) {
        return NULL;
    }
    if( GuidString[0] != L'{' ) return NULL;

    wcscpy(GuidStringBuf, &GuidString[1]);
    if( L'}' != GuidStringBuf[wcslen(GuidStringBuf)-1] ) {
        return NULL;
    }

    GuidStringBuf[wcslen(GuidStringBuf)-1] = L'\0';

    Status = UuidFromStringW(GuidStringBuf, &GuidStruct);
    if( RPC_S_OK != Status ) {
        SetLastError( Status );
        return NULL;
    }

    return GetDescriptionFromGuid(&GuidStruct);
}

VOID
GetInterfaceGuidAndDeviceName(
    IN PMIB_IFROW IfRow,
    IN PIP_INTERFACE_INFO InterfaceInfo,
    IN PIP_INTERFACE_NAME_INFO IfNameInfo,
    IN ULONG IfNameCount,
    OUT GUID *IfGuid,
    OUT LPWSTR *IfDeviceName
    )
{
    DWORD i;

    //
    // Search interface name info to get the interface guid for
    // this interface.  Also, search the InterfaceInfo to get the
    // devicename for this interface.
    //

    ZeroMemory( IfGuid, sizeof(*IfGuid) );
    for( i = 0; i < IfNameCount ; i ++ ) {
        if( IfRow->dwIndex != IfNameInfo[i].Index ) continue;
        (*IfGuid) = IfNameInfo[i].InterfaceGuid;
        break;
    }

    (*IfDeviceName) = NULL;
    for( i = 0; i < (DWORD)InterfaceInfo->NumAdapters; i ++ ) {
        if( InterfaceInfo->Adapter[i].Index != IfRow->dwIndex ) continue;
        (*IfDeviceName) = InterfaceInfo->Adapter[i].Name + strlen(
            "\\Device\\Tcpip_" );
        break;
    }
}


DWORD
MapFriendlyAndConnectionNames(
    IN OUT PINTERFACE_NETWORK_INFO IfInfo,
    IN PMIB_IFROW IfRow,
    IN GUID IfGuid,
    IN LPWSTR IfDeviceName
    )
{
    DWORD Size, Error;
    WCHAR ConnName[500];

    //
    // Try to get friendly device name from IfGuid or DeviceName
    // or failing both just use the description provided by tcpip
    //

    IfInfo->FriendlyName = GetDescription( &IfGuid, IfDeviceName );
    IPCFG_TRACE(IPCFG_TRACE_TCPIP, ("GetDescription returns %p for %ws\n", IfInfo->FriendlyName, IfDeviceName));
    if( NULL == IfInfo->FriendlyName ) {

        Size = MultiByteToWideChar(
            CP_ACP, 0, (LPSTR)IfRow->bDescr, IfRow->dwDescrLen, NULL, 0 );
        if( Size == 0 ) return GetLastError();

        Size ++;
        IfInfo->FriendlyName = New( Size * sizeof(WCHAR) );
        if (IfInfo->FriendlyName == NULL) return GetLastError();

        Size = MultiByteToWideChar(
            CP_ACP, 0, (LPSTR)IfRow->bDescr, IfRow->dwDescrLen,
            IfInfo->FriendlyName, Size );
        if( 0 == Size ) return GetLastError();
    }

    IPCFG_TRACE(IPCFG_TRACE_TCPIP, ("\tFriendly Name: %ws\n", IfInfo->FriendlyName));

    //
    // Now get the connection name.  First try with LAN, then RAS
    //


    Size = sizeof(ConnName)/sizeof(WCHAR);
    Error = HrLanConnectionNameFromGuidOrPath(
        NULL, IfDeviceName, ConnName, &Size );

    if( NO_ERROR != Error ) {
        Size = sizeof(ConnName)/sizeof(WCHAR);

        IPCFG_TRACE(IPCFG_TRACE_TCPIP, ("HrLanConnectionNameFromGuidOrPath fails 0x%lx(%d)", Error, Error));

        Error = NhGetInterfaceNameFromGuid(
            &IfGuid, ConnName, &Size, FALSE, FALSE );
        if( NO_ERROR != Error ) {
            ConnName[0] = L'\0';
            IPCFG_TRACE(IPCFG_TRACE_TCPIP, (" NhGetInterfaceNameFromGuid fails 0x%lx(%d)", Error, Error));
            //return Error;
        }
    }

    IPCFG_TRACE(IPCFG_TRACE_TCPIP, ("\tConnection Name: %ws\n", ConnName));

    IfInfo->ConnectionName = New( sizeof(WCHAR)*(1+wcslen(ConnName)));
    if( NULL == IfInfo->ConnectionName ) return GetLastError();

    wcscpy(IfInfo->ConnectionName, ConnName );

    return NO_ERROR;
}

DWORD
GetMediaStatus(
    IN LPWSTR IfDeviceName,
    OUT BOOL *fDisconnected
    )
{
    WCHAR NdisDeviceString[512];
    UNICODE_STRING NdisDevice;
    NIC_STATISTICS NdisStats;

    wcscpy((LPWSTR)NdisDeviceString, (LPWSTR)L"\\Device\\" );
    wcscat((LPWSTR)NdisDeviceString, IfDeviceName );

    ZeroMemory(&NdisStats, sizeof(NdisStats));
    NdisStats.Size = sizeof(NdisStats);

    RtlInitUnicodeString(&NdisDevice, (LPWSTR)NdisDeviceString);

    if( FALSE == NdisQueryStatistics(&NdisDevice, &NdisStats) ) {
        ULONG Error;

        //
        // Could not get statistics.. use default answer.
        //

        Error = GetLastError();
        if( ERROR_NOT_READY == Error ) {
            *fDisconnected = TRUE;
            return NO_ERROR;
        }

        return Error;
    }

    if( NdisStats.MediaState == MEDIA_STATE_DISCONNECTED ) {
        *fDisconnected = TRUE;
    } else {
        *fDisconnected = FALSE;
    }

    return NO_ERROR;
}

BOOL
IsMediaSenseDisabled(
    HKEY RegKey
    )
{
    LPTSTR regValueName = (LPTSTR)(TEXT ("DisableDHCPMediaSense") );
    DWORD regValueData;
    DWORD regValueDataType;
    DWORD regValueDataLen = sizeof(DWORD);
    DWORD Error;

    Error = RegQueryValueEx(
                RegKey,
                regValueName,
                NULL,
                &regValueDataType,
                (LPBYTE)&regValueData,
                &regValueDataLen);

    return (Error == NO_ERROR) &&
           (regValueDataType == REG_DWORD) &&
           (regValueData != 0);
}

DWORD
OpenRegKey(
    IN LPCWSTR Device,
    IN DWORD KeyType,
    IN DWORD AccessType,
    OUT HKEY *phKey
    )
{
    DWORD Access;
    WCHAR KeyLoc[256];
    LPTSTR TcpipParmLoc = (LPTSTR)(TEXT( "SYSTEM\\CurrentControlSet\\Services" )
                                   TEXT( "\\Tcpip\\Parameters" ) );
    LPTSTR TcpipLoc = (LPTSTR)(TEXT( "SYSTEM\\CurrentControlSet\\Services" )
                               TEXT( "\\Tcpip\\Parameters\\Interfaces\\") );
    LPTSTR NbtLoc = (LPTSTR)(TEXT("SYSTEM\\CurrentControlSet\\Services")
                             TEXT("\\Netbt\\Parameters\\Interfaces\\Tcpip_"));

    switch (KeyType)
    {
    case OpenTcpipParmKey:
        wcscpy(KeyLoc, TcpipParmLoc);
        break;
    case OpenTcpipKey:
        wcscpy(KeyLoc, TcpipLoc);
        wcscat(KeyLoc, Device);
        break;
    case OpenNbtKey:
        wcscpy(KeyLoc, NbtLoc);
        wcscat(KeyLoc, Device);
        break;
    }

    Access = KEY_READ;
    if( AccessType & OpenKeyForWrite ) Access |= KEY_WRITE;

    return RegOpenKeyEx(
        HKEY_LOCAL_MACHINE, KeyLoc, 0, Access, phKey );
}

VOID
SecondsToAbsolute(
    OUT FILETIME *SysTime,
    IN LONGLONG SecondsDifference
    )
{
    LONGLONG Diff = SecondsDifference;
    Diff *= 10000; Diff *= 1000;
    GetSystemTimeAsFileTime( SysTime );
    (*((LONGLONG UNALIGNED64 *)SysTime)) -= Diff;
}

DWORD
GetDhcpValues(
    IN PNETWORK_INFO NetInfo,
    IN OUT PINTERFACE_NETWORK_INFO IfInfo,
    IN HKEY hKey
    )
{
    WCHAR ClassId[200];
    LPSTR DhcpServer;
    DWORD Error, Value, Size, Type;
    time_t CurrentTime, Obtained, Expires;

    //
    // First check if dhcp is enabled
    //

    do {
        Size = sizeof(Value);
        Error = RegQueryValueEx(
            hKey, (LPTSTR)TEXT("EnableDHCP"), NULL, &Type,
            (LPBYTE)&Value, &Size );

        if( NO_ERROR != Error ) return Error;
        if( Type != REG_DWORD ) return ERROR_INVALID_DATA;
        IfInfo->EnableDhcp = (Value != 0 );

    } while ( 0 );

    //
    // Now check for class id
    //

    do {
        Size = sizeof(ClassId);
        Error = RegQueryValueExW(
            hKey, (LPWSTR)L"DhcpClassId", NULL, &Type, (LPBYTE)ClassId,
            &Size );

        if( ERROR_FILE_NOT_FOUND == Error ) {
            Error = NO_ERROR;
            Size = 0;
        }
        if( NO_ERROR != Error ) return Error;

        if( Size == 0 ) break;
        if( Type != REG_SZ ) return ERROR_INVALID_DATA;

        Size = sizeof(WCHAR)*(1+wcslen(ClassId));
        IfInfo->DhcpClassId = New( Size );
        if( NULL == IfInfo->DhcpClassId ) return GetLastError();

        wcscpy(IfInfo->DhcpClassId, ClassId );
    } while( 0 );


    //
    // Now check if autoconfiguration is enabled
    //

    if( IfInfo->EnableDhcp ) do {
        Size = sizeof(Value);
        Error = RegQueryValueEx(
            hKey, (LPTSTR)TEXT("IPAutoconfigurationEnabled"),
            NULL, &Type, (LPBYTE)&Value, &Size );

        if( ERROR_FILE_NOT_FOUND == Error ) {
            IfInfo->EnableAutoconfig = NetInfo->GlobalEnableAutoconfig;
        } else if( NO_ERROR != Error ) return Error;
        else if( REG_DWORD != Type ) return ERROR_INVALID_DATA;
        else IfInfo->EnableAutoconfig = (Value != 0 );
    } while ( 0 );

    //
    // Get Dhcp server value
    //

    if( IfInfo->EnableDhcp ) do {
        Size = sizeof(ClassId);
        DhcpServer = (LPSTR)ClassId;

        Error = RegQueryValueExA(
            hKey, "DhcpServer", NULL, &Type,
            (LPBYTE)DhcpServer, &Size );
        if( ERROR_FILE_NOT_FOUND == Error ) break;
        if( NO_ERROR != Error ) return Error;
        if( REG_SZ != Type ) return ERROR_INVALID_DATA;

        IfInfo->DhcpServer = inet_addr(DhcpServer);
    } while( 0 );

    //
    // Now get lease expired and obtained times
    //

    CurrentTime = time(NULL);

    if( IfInfo->EnableDhcp ) do {
        Size = sizeof(Value);
        Error = RegQueryValueEx(
            hKey, (LPTSTR)TEXT("LeaseObtainedTime"),
            NULL, &Type, (LPBYTE)&Value, &Size );

        if( ERROR_FILE_NOT_FOUND == Error ) break;
        if( NO_ERROR != Error ) return Error;
        if( REG_DWORD != Type ) return ERROR_INVALID_DATA;

        Obtained = (time_t)Value;

        SecondsToAbsolute(
            (FILETIME *)(&IfInfo->LeaseObtainedTime),
            ((LONGLONG)CurrentTime) - ((LONGLONG)Obtained) );

    } while ( 0 );

    if( IfInfo->EnableDhcp ) do {
        Size = sizeof(Value);
        Error = RegQueryValueEx(
            hKey, (LPTSTR)TEXT("LeaseTerminatesTime"),
            NULL, &Type, (LPBYTE)&Value, &Size );

        if( ERROR_FILE_NOT_FOUND == Error ) break;
        if( NO_ERROR != Error ) return Error;
        if( REG_DWORD != Type ) return ERROR_INVALID_DATA;

        Expires = (time_t)Value;

        SecondsToAbsolute(
            (FILETIME *)(&IfInfo->LeaseExpiresTime),
            ((LONGLONG)CurrentTime) - ((LONGLONG)Expires) );
    } while ( 0 );

    return NO_ERROR;
}

DWORD
GetDnsValues(
    IN OUT PINTERFACE_NETWORK_INFO IfInfo,
    IN HKEY hKey
    )
{
    CHAR *Servers = NULL, *Str;
    DWORD Error, BufferSize, Size, Type, i, Count, *ThisAddr;

    //
    // First get DnsSuffix for the interface
    //

    Size = sizeof(IfInfo->DnsSuffix)/sizeof(WCHAR);
    Error = RegQueryValueExW(
        hKey, (LPWSTR)L"Domain", NULL, &Type,
        (LPBYTE)IfInfo->DnsSuffix, &Size );
    if( NO_ERROR != Error ) {
        if( ERROR_FILE_NOT_FOUND != Error ) return Error;

        Size = 0;
        Type = REG_SZ;
    }

    if( REG_SZ != Type ) return ERROR_INVALID_DATA;
    if( 0 == Size || 0 == wcslen(IfInfo->DnsSuffix) ) {

        Size = sizeof(IfInfo->DnsSuffix)/sizeof(WCHAR);
        Error = RegQueryValueExW(
            hKey, (LPWSTR)L"DhcpDomain", NULL, &Type,
            (LPBYTE)IfInfo->DnsSuffix, &Size );
        if( NO_ERROR != Error ) {
            if( ERROR_FILE_NOT_FOUND != Error ) return Error;

            Size = 0;
            IfInfo->DnsSuffix[0] = L'\0';
        }
    }

    //
    // Now attempt to read the DnsServers list
    //

    BufferSize = 800;
    do {
        Servers = New( BufferSize );
        if( NULL == Servers) return GetLastError();

        ZeroMemory(Servers, BufferSize);

        Size = BufferSize;
        Error = RegQueryValueExA(
            hKey, (LPSTR)"NameServer", NULL, &Type, (LPBYTE)Servers,
            &Size );

        if( NO_ERROR == Error ) {
            break;
        }

        Delete(Servers);
        Servers = NULL;
        if( ERROR_FILE_NOT_FOUND == Error ) {
            Size = 0;
            Type = REG_SZ;
            break;
        }

        if (Error != ERROR_MORE_DATA) {
            return Error;
        }
        BufferSize *= 2;
    } while(1);

    if( REG_SZ != Type ) return ERROR_INVALID_DATA;
    if( 0 == Size || NULL == Servers || 0 == strlen(Servers) ) {
        if (Servers) Delete(Servers);

        BufferSize = 800;
        do {
            Servers = New( BufferSize );
            if( NULL == Servers) return GetLastError();

            ZeroMemory(Servers, BufferSize);

            Size = BufferSize;
            Error = RegQueryValueExA(
                hKey, (LPSTR)"DhcpNameServer", NULL, &Type,
                (LPBYTE)Servers, &Size );

            if( NO_ERROR == Error ) {
                break;
            }

            Delete(Servers);
            Servers = NULL;
            if( ERROR_FILE_NOT_FOUND == Error ) {
                Size = 0;
                Type = REG_SZ;
                break;
            }

            if (Error != ERROR_MORE_DATA) {
                return Error;
            }
            BufferSize *= 2;
        } while(1);
    }

    //
    // If there are any DNS Servers, convert them to IPaddr
    //

    if( 0 != Size && NULL != Servers && strlen(Servers) ) {
        for( i = 0; i < Size; i ++ ) {
            if( Servers[i] == ' ' || Servers[i] == ','
                || Servers[i] == ';' ) {
                Servers[i] = '\0';
            }
        }
        Servers[Size] = '\0';

        Count = 0; Str = (LPSTR)Servers;
        while( strlen(Str) ) {
            Count ++;
            Str += strlen(Str); Str ++;
        }

        ThisAddr = New( sizeof(IPV4_ADDRESS) * Count );
        if( NULL == ThisAddr ) return GetLastError();
        IfInfo->DnsServer = ThisAddr;

        for (i = 0, Str = (LPSTR)Servers;
             *Str != '\0';
             Str += strlen(Str) + 1)
        {
             IfInfo->DnsServer[i] = inet_addr( Str );
             if (IfInfo->DnsServer[i] != 0)
                 i++;
        }
        IfInfo->nDnsServers = i;
    }

    if (Servers) {
        Delete (Servers);
    }

    return NO_ERROR;
}


DWORD
GetWinsValues(
    IN OUT PINTERFACE_NETWORK_INFO IfInfo,
    IN LPCWSTR DeviceName,
    IN OUT ULONG *NodeType
    )
{
    WCHAR NbtDevice[MAX_PATH];
    UNICODE_STRING NbtDeviceString;
    HANDLE h;
    OBJECT_ATTRIBUTES objAttr;
    IO_STATUS_BLOCK iosb;
    NTSTATUS status;
    tWINS_NODE_INFO NodeInfo;
    DWORD Count;
    INT i;

    wcscpy(NbtDevice, (LPWSTR)L"\\Device\\NetBT_Tcpip_");
    wcscat(NbtDevice, DeviceName);

    RtlInitUnicodeString( &NbtDeviceString, (LPWSTR)NbtDevice );

    InitializeObjectAttributes(
        &objAttr,
        &NbtDeviceString,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        (PSECURITY_DESCRIPTOR)NULL
        );

    status = NtCreateFile(
        &h, SYNCHRONIZE | GENERIC_EXECUTE, &objAttr, &iosb, NULL,
        FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_OPEN_IF,  0, NULL, 0 );

    if (!NT_SUCCESS(status)) {
        DWORD w32error = RtlNtStatusToDosError( status );

        IfInfo->EnableNbtOverTcpip = FALSE;
        (*NodeType) = NodeTypeUnknown;
        return w32error == ERROR_FILE_NOT_FOUND ? NO_ERROR : w32error;
    }

    status = NtDeviceIoControlFile(
        h, NULL, NULL, NULL, &iosb, IOCTL_NETBT_GET_WINS_ADDR,
        NULL, 0, (PVOID)&NodeInfo, sizeof(NodeInfo) );

    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(h, TRUE, NULL);
        if (NT_SUCCESS(status)) {
            status = iosb.Status;
        }
    }

    NtClose(h);

    if (!NT_SUCCESS(status)) {
        return RtlNtStatusToDosError( status );
    }

    //
    // for some reason, NetBT returns the addresses in low-byte order. We have
    // to swap them
    //

    Count = 0;
    for( i = 0; i < 2+MAX_NUM_OTHER_NAME_SERVERS; i ++ ) {
        NodeInfo.AllNameServers[i] = htonl(NodeInfo.AllNameServers[i]);
        if( LOCAL_WINS_ADDRESS == NodeInfo.AllNameServers[i] ||
            INADDR_ANY == NodeInfo.AllNameServers[i] ||
            INADDR_BROADCAST == NodeInfo.AllNameServers[i] ) {
            break;
        }

        Count ++;
    }

    for ( i = IfInfo->nIpAddresses-1; i >= 0; i--)
        if (IfInfo->IpAddress[i] != 0)
            break;

    if (Count > (DWORD)(NodeInfo.NumOtherServers + 2)) {
        Count = (DWORD)(NodeInfo.NumOtherServers + 2);
    }
    if( i != -1 && Count != 0 ) {
        IfInfo->WinsServer = New( sizeof(IPV4_ADDRESS)*Count );
        if( NULL == IfInfo->WinsServer ) return GetLastError();

        IfInfo->nWinsServers = Count;
        for( i = 0; (DWORD)i < Count;  i ++ ) {
            IfInfo->WinsServer[i] = NodeInfo.AllNameServers[i];
        }
    }

    IfInfo->EnableNbtOverTcpip = NodeInfo.NetbiosEnabled;

#define NODE_TYPE_BROADCAST             1
#define NODE_TYPE_PEER_PEER             2
#define NODE_TYPE_MIXED                 4
#define NODE_TYPE_HYBRID                8

    switch( NodeInfo.NodeType ) {
    case NODE_TYPE_BROADCAST : (*NodeType) = NodeTypeBroadcast; break;
    case NODE_TYPE_PEER_PEER : (*NodeType) = NodeTypePeerPeer; break;
    case NODE_TYPE_MIXED : (*NodeType) = NodeTypeMixed; break;
    case NODE_TYPE_HYBRID : (*NodeType) = NodeTypeHybrid ; break;
    default: (*NodeType) = NodeTypeUnknown; break;
    }

    return NO_ERROR;
}

DWORD
GetAddressValues(
    IN OUT PINTERFACE_NETWORK_INFO IfInfo,
    IN PMIB_IPADDRTABLE AddrTable,
    IN ULONG IfIndex
    )
{
    DWORD i, Count;

    if( NULL == AddrTable ) return ERROR_NOT_FOUND;

    Count = 0;
    for( i = 0; i < AddrTable->dwNumEntries ; i ++ ) {
        if( AddrTable->table[i].dwIndex == IfIndex ) {
            Count ++;
        }
    }

    if( 0 == Count ) return NO_ERROR;

    //
    // Allocate space for this
    //

    IfInfo->IpAddress = New( sizeof(IPV4_ADDRESS)*Count );
    if( NULL == IfInfo->IpAddress ) return GetLastError();

    IfInfo->IpMask = New( sizeof(IPV4_ADDRESS)*Count );
    if( NULL == IfInfo->IpMask ) return GetLastError();

    IfInfo->nIpAddresses = IfInfo->nIpMasks = Count;

    //
    // First add the primary addresses
    //

    Count = 0;
    for( i = 0; i < AddrTable->dwNumEntries; i ++ ) {
        if( AddrTable->table[i].dwIndex != IfIndex ) continue;
        if( !(AddrTable->table[i].wType & MIB_IPADDR_PRIMARY)) continue;

        IfInfo->IpAddress[Count] = AddrTable->table[i].dwAddr;
        IfInfo->IpMask[Count] = AddrTable->table[i].dwMask;
        Count ++;
    }

    //
    // Now add just the non-primary addresses
    //


    for( i = 0; i < AddrTable->dwNumEntries; i ++ ) {
        if( AddrTable->table[i].dwIndex != IfIndex ) continue;
        if(AddrTable->table[i].wType & MIB_IPADDR_PRIMARY) continue;

        IfInfo->IpAddress[Count] = AddrTable->table[i].dwAddr;
        IfInfo->IpMask[Count] = AddrTable->table[i].dwMask;
        Count ++;
    }

    return NO_ERROR;
}

DWORD
GetRouteValues(
    IN OUT PINTERFACE_NETWORK_INFO IfInfo,
    IN PMIB_IPFORWARDTABLE RouteTable,
    IN ULONG IfIndex
    )
{
    DWORD i, Count;

    if( NULL == RouteTable ) return ERROR_NOT_FOUND;

    Count = 0;
    for( i = 0; i < RouteTable->dwNumEntries; i ++ ) {
        if( RouteTable->table[i].dwForwardIfIndex == IfIndex &&
            INADDR_ANY == RouteTable->table[i].dwForwardDest &&
            MIB_IPROUTE_TYPE_INVALID !=
            RouteTable->table[i].dwForwardType ) {
            Count ++;
        }
    }

    if( 0 == Count ) return NO_ERROR;

    IfInfo->Router = New( sizeof(IPV4_ADDRESS)*Count);
    if( NULL == IfInfo->Router ) return GetLastError();
    IfInfo->nRouters = Count;

    Count = 0;
    for( i = 0; i < RouteTable->dwNumEntries; i ++ ) {
        if( RouteTable->table[i].dwForwardIfIndex == IfIndex &&
            INADDR_ANY == RouteTable->table[i].dwForwardDest &&
            MIB_IPROUTE_TYPE_INVALID !=
            RouteTable->table[i].dwForwardType ) {

            IfInfo->Router[Count] = RouteTable->table[i].dwForwardNextHop;
            Count ++;
        }
    }

    return NO_ERROR;
}

VOID
IncrementCount(
    IN IPV6_INFO_ROUTE_TABLE *RTE,
    IN PVOID Arg1,
    IN OUT PVOID Count
    )
{
    PIP_ADAPTER_ADDRESSES If = (PIP_ADAPTER_ADDRESSES)Arg1;

    if ((RTE->This.PrefixLength == 0) && 
        (RTE->This.Neighbor.IF.Index == If->Ipv6IfIndex)) {

        (*(ULONG *)Count)++;
    }
}

VOID
AddRouter(
    IN IPV6_INFO_ROUTE_TABLE *RTE,
    IN PVOID Arg1,
    IN OUT PVOID Arg2
    )
{
    PIP_ADAPTER_ADDRESSES If = (PIP_ADAPTER_ADDRESSES)Arg1;
    PINTERFACE_NETWORK_INFO pIfInfo = (PINTERFACE_NETWORK_INFO)Arg2;
    ULONG Index;
    LPSOCKADDR_IN6 Addr;

    if (RTE->This.PrefixLength != 0) {
        return;
    }
    if (RTE->This.Neighbor.IF.Index != If->Ipv6IfIndex) {
        return;
    }

    //
    // We now have a default router to add to the list.
    //
    Index = pIfInfo->nIpv6Routers++;
    Addr = &pIfInfo->Ipv6Router[Index]; 
    Addr->sin6_family = AF_INET6;
    Addr->sin6_addr = RTE->This.Neighbor.Address;
    Addr->sin6_port = 0;
    if (IN6_IS_ADDR_LINKLOCAL(&Addr->sin6_addr)) {
        Addr->sin6_scope_id = If->ZoneIndices[ScopeLevelLink];
    } else if (IN6_IS_ADDR_SITELOCAL(&Addr->sin6_addr)) {
        Addr->sin6_scope_id = If->ZoneIndices[ScopeLevelSite];
    } else {
        Addr->sin6_scope_id = 0;
    }
}

ULONG
ForEachRoute(
    IN VOID (*Func)(IPV6_INFO_ROUTE_TABLE *, PVOID, PVOID), 
    IN PVOID Arg1,
    IN OUT PVOID Arg2
    )
{
    IPV6_QUERY_ROUTE_TABLE Query, NextQuery;
    IPV6_INFO_ROUTE_TABLE RTE;
    ULONG BytesReturned;
    static HANDLE Ipv6Handle = INVALID_HANDLE_VALUE;

    if (Ipv6Handle == INVALID_HANDLE_VALUE) {
        //
        // Open a handle to the IPv6 device on our first invocation.  
        // Keep it open until the process terminates, since we'll
        // terminate once we've generated the output.
        //
        Ipv6Handle = CreateFileW(WIN_IPV6_DEVICE_NAME,
                                 0,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,   // security attributes
                                 OPEN_EXISTING,
                                 0,      // flags & attributes
                                 NULL);  // template file
    }

    NextQuery.Neighbor.IF.Index = 0;

    for (;;) {
        Query = NextQuery;

        if (!DeviceIoControl(Ipv6Handle, IOCTL_IPV6_QUERY_ROUTE_TABLE,
                             &Query, sizeof Query,
                             &RTE, sizeof RTE, &BytesReturned,
                             NULL)) {
            return GetLastError();
        }

        NextQuery = RTE.Next;

        if (Query.Neighbor.IF.Index != 0) {

            RTE.This = Query;
            (*Func)(&RTE, Arg1, Arg2);
        }

        if (NextQuery.Neighbor.IF.Index == 0)
            break;
    }

    return NO_ERROR;
}

VOID
AddIpv6PerInterfaceInfo(
    IN DWORD IfIndex,
    IN PINTERFACE_NETWORK_INFO pIfInfo,
    IN PIP_ADAPTER_ADDRESSES IfList
    )
{
    PIP_ADAPTER_ADDRESSES If;
    PIP_ADAPTER_UNICAST_ADDRESS Addr;
    PIP_ADAPTER_DNS_SERVER_ADDRESS Dns;
    ULONG Count, BytesReturned;
    LPSOCKADDR_IN6 SockAddr;
    IPV6_QUERY_ROUTE_TABLE Query, NextQuery;
    IPV6_INFO_ROUTE_TABLE RTE;

    //
    // Find matching entry in the IPv6 interface list.
    //
    for (If = IfList; If; If = If->Next) {
        if (IfIndex == If->IfIndex) {
            break;
        }
    }

    if ((If == NULL) || (If->Ipv6IfIndex == 0)) {
        return;
    }

    //
    // Append IPv6 unicast addresses.
    //
    Count = 0;
    for (Addr = If->FirstUnicastAddress; Addr; Addr = Addr->Next) {
        if ((Addr->Address.lpSockaddr->sa_family == AF_INET6) &&
            (Addr->DadState >= IpDadStateDeprecated)) {
            Count++;
        }
    }
    pIfInfo->Ipv6Address = New(Count * sizeof(SOCKADDR_IN6));
    if (pIfInfo->Ipv6Address != NULL) {
        Count = 0;
        for (Addr = If->FirstUnicastAddress; Addr; Addr = Addr->Next) {
            if ((Addr->Address.lpSockaddr->sa_family == AF_INET6) &&
                (Addr->DadState >= IpDadStateDeprecated)) {
                CopyMemory(&pIfInfo->Ipv6Address[Count++],
                           Addr->Address.lpSockaddr,
                           sizeof(SOCKADDR_IN6));
            }
        }
        pIfInfo->nIpv6Addresses = Count;
    } else {
        pIfInfo->nIpv6Addresses = 0;
    }

    //
    // Append IPv6 DNS server addresses.
    //
    Count = 0;
    for (Dns = If->FirstDnsServerAddress; Dns; Dns = Dns->Next) {
        if (Dns->Address.lpSockaddr->sa_family == AF_INET6) {
            Count++;
        }
    }
    pIfInfo->Ipv6DnsServer = New(Count * sizeof(SOCKADDR_IN6));
    if (pIfInfo->Ipv6DnsServer != NULL) {
        Count = 0;
        for (Dns = If->FirstDnsServerAddress; Dns; Dns = Dns->Next) {
            if (Dns->Address.lpSockaddr->sa_family == AF_INET6) {
                CopyMemory(&pIfInfo->Ipv6DnsServer[Count++],
                           Dns->Address.lpSockaddr,
                           sizeof(SOCKADDR_IN6));
            }
        }
        pIfInfo->nIpv6DnsServers = Count;
    } else {
        pIfInfo->nIpv6DnsServers = 0;
    }

    //
    // Append IPv6 default router addresses.
    //
    Count = 0;
    ForEachRoute(IncrementCount, If, &Count);

    pIfInfo->nIpv6Routers = 0;
    pIfInfo->Ipv6Router = New(Count * sizeof(SOCKADDR_IN6));

    if (pIfInfo->Ipv6Router != NULL) {
        ForEachRoute(AddRouter, If, pIfInfo);
    }
}

DWORD
GetPerInterfaceInfo(
    IN OUT PNETWORK_INFO NetInfo,
    OUT PINTERFACE_NETWORK_INFO *pIfInfo,
    IN PMIB_IFROW IfRow,
    IN PIP_INTERFACE_INFO InterfaceInfo,
    IN PIP_INTERFACE_NAME_INFO IfNameInfo,
    IN ULONG IfNameCount,
    IN PMIB_IPADDRTABLE AddrTable,
    IN PMIB_IPFORWARDTABLE RouteTable,
    IN PIP_ADAPTER_ADDRESSES IfList,
    IN OUT DWORD *InternalError
    )
{
    DWORD Error, NodeType;
    PINTERFACE_NETWORK_INFO IfInfo = New( sizeof(*IfInfo) );
    GUID IfGuid;
    LPWSTR IfDeviceName;
    HKEY TcpipKey = NULL;
    HKEY TcpipParmKey = NULL;

    if( NULL == IfInfo ) return GetLastError();
    (*pIfInfo) = IfInfo;
    ZeroMemory( &IfGuid, sizeof(IfGuid) );
    IfDeviceName = NULL;

    GetInterfaceGuidAndDeviceName(
        IfRow, InterfaceInfo, IfNameInfo, IfNameCount,
        &IfGuid, &IfDeviceName );

    if( NULL == IfDeviceName ) {
        (*InternalError) = InterfaceUnknownTcpipDevice;
        return ERROR_NOT_FOUND;
    }
    IPCFG_TRACE(IPCFG_TRACE_TCPIP, ("\tDeviceName: %ws\n", IfDeviceName));

    wcscpy(IfInfo->DeviceGuidName, IfDeviceName );

    Error = OpenRegKey(
        IfDeviceName, OpenTcpipKey, OpenKeyForRead, &TcpipKey  );

    if (Error == NO_ERROR)
        Error = OpenRegKey(
        IfDeviceName, OpenTcpipParmKey, OpenKeyForRead, &TcpipParmKey );

    if( NO_ERROR != Error ) {
        (*InternalError) = InterfaceOpenTcpipKeyReadFailure;
    }

    while (Error == NO_ERROR)
    {
        Error = MapIfType( IfInfo, IfRow->dwType);
        CheckError( InterfaceUnknownType );

        IfInfo->PhysicalNameLength = IfRow->dwPhysAddrLen;
        CopyMemory(
            IfInfo->PhysicalName,IfRow->bPhysAddr,
            IfRow->dwPhysAddrLen );

        Error = MapFriendlyAndConnectionNames(
            IfInfo, IfRow, IfGuid, IfDeviceName );
        CheckError( InterfaceUnknownFriendlyName );

        if( IfRow->dwType == IF_TYPE_PPP ||
            IfRow->dwType == IF_TYPE_TUNNEL ||
            IsMediaSenseDisabled(TcpipParmKey)) {
            IfInfo->MediaDisconnected = FALSE;
        } else {
            Error = GetMediaStatus(
                IfDeviceName, &IfInfo->MediaDisconnected );
            CheckError( InterfaceUnknownMediaStatus );
        }

        Error = GetDhcpValues( NetInfo, IfInfo, TcpipKey );
        CheckError( InterfaceDhcpValuesFailure );

        Error = GetDnsValues( IfInfo, TcpipKey );
        CheckError( InterfaceDnsValuesFailure );

        Error = GetAddressValues(
            IfInfo, AddrTable, IfRow->dwIndex );

        CheckError( InterfaceAddressValuesFailure );

        Error = GetRouteValues(
            IfInfo, RouteTable, IfRow->dwIndex );

        CheckError( InterfaceRouteValuesFailure );

        Error = GetWinsValues( IfInfo, IfDeviceName, &NodeType );
        CheckError( InterfaceWinsValuesFailure );

        //
        // Now set the node type as well
        //
        NetInfo->NodeType = NodeType;

        //
        // Now write out if autoconfig is active.  The way this
        // works is to check if dhcp is enabled and dhcpserver
        // address is zero or all ones
        //

        if( IfInfo->EnableDhcp && IfInfo->EnableAutoconfig
            && IfInfo->nIpAddresses
            && IfInfo->IpAddress[0] != INADDR_ANY
            && ( IfInfo->DhcpServer == INADDR_BROADCAST ||
                 IfInfo->DhcpServer == INADDR_ANY ) ) {
            IfInfo->AutoconfigActive = TRUE;
        }

        break;
    }

    if (TcpipKey != NULL)
        RegCloseKey( TcpipKey );

    if (TcpipParmKey != NULL)
        RegCloseKey( TcpipParmKey );

    AddIpv6PerInterfaceInfo( IfRow->dwIndex, IfInfo, IfList );

    return Error;
}

DWORD
GetIpv6OnlyPerInterfaceInfo(
    OUT PINTERFACE_NETWORK_INFO *pIfInfo,
    IN PIP_ADAPTER_ADDRESSES If
    )
{
    DWORD Error = NO_ERROR;
    PINTERFACE_NETWORK_INFO IfInfo;

    IfInfo = New( sizeof(*IfInfo) );
    if( NULL == IfInfo ) return GetLastError();
    (*pIfInfo) = IfInfo;

    ZeroMemory(IfInfo, sizeof(*IfInfo));
    
    MapIfType(IfInfo, If->IfType);

    IfInfo->PhysicalNameLength = If->PhysicalAddressLength;
    CopyMemory(IfInfo->PhysicalName, If->PhysicalAddress, 
               If->PhysicalAddressLength);

    //
    // INTERFACE_NETWORK_INFO has weird field names compared to 
    // IP_ADAPTER_ADDRESSES.  The former puts the description in its
    // "friendly name" field.
    //
    IfInfo->FriendlyName = New((wcslen(If->Description) + 1) * sizeof(WCHAR));
    if( NULL != IfInfo->FriendlyName ) {
        wcscpy(IfInfo->FriendlyName, If->Description);
    }
    IfInfo->ConnectionName = New((wcslen(If->FriendlyName) + 1) * sizeof(WCHAR));
    if( NULL != IfInfo->ConnectionName ) {
        wcscpy(IfInfo->ConnectionName, If->FriendlyName);
    }

    IfInfo->MediaDisconnected = (If->OperStatus == IfOperStatusLowerLayerDown);
    IfInfo->EnableAutoconfig = TRUE;
    wcscpy(IfInfo->DnsSuffix, If->DnsSuffix);

    AddIpv6PerInterfaceInfo(0, IfInfo, If);

    return Error;
}

BOOL
GetGlobalTcpipAutoconfigFlag()
{
    HKEY    hKey;
    BOOL    rtn;
    DWORD   Error;
    DWORD   Type, Value, Size;

    rtn = TRUE;

    Error = OpenRegKey(
        NULL, OpenTcpipParmKey, OpenKeyForRead, &hKey  );

    if (Error != NO_ERROR) {
        return TRUE;
    }
    Error = RegQueryValueEx(
            hKey, (LPTSTR)TEXT("IPAutoconfigurationEnabled"),
            NULL, &Type, (LPBYTE)&Value, &Size );

    if (Error == NO_ERROR && Type == REG_DWORD) {
        rtn = (Value)? TRUE: FALSE;
    }

    RegCloseKey( hKey );
    return rtn;
}

ULONG
CountIpv6OnlyInterfaces(
    IN PIP_ADAPTER_ADDRESSES IfList
    )
{
    PIP_ADAPTER_ADDRESSES If;
    ULONG Count = 0;
    
    for (If = IfList; If; If = If->Next) {
        if ((If->IfIndex == 0) && (If->Ipv6IfIndex != 0) &&
            (If->IfType != IF_TYPE_SOFTWARE_LOOPBACK) &&
            ((If->IfType != IF_TYPE_TUNNEL) || (If->FirstUnicastAddress != NULL))) {
            Count++;
        }
    }

    return Count;
}

DWORD
GetNetworkInformation(
    OUT PNETWORK_INFO *pNetInfo,
    IN OUT DWORD *InternalError
    )
{
    DWORD Size, Length, Error, i, j, k, IfNameCount, IfCount;
    BOOL fSuccess;
    PNETWORK_INFO NetInfo;
    MIB_IPSTATS IpStats;
    FIXED_INFO *FixedInfo;
    PDNS_SEARCH_INFORMATION SearchInfo;
    PMIB_IFTABLE pIfTable;
    PIP_INTERFACE_INFO InterfaceInfo;
    PIP_INTERFACE_NAME_INFO IfNameInfo;
    PMIB_IPADDRTABLE AddrTable;
    PMIB_IPFORWARDTABLE RouteTable;
    PIP_ADAPTER_ADDRESSES IfList, If;
    ULONG BufferLength, Flags;

    //
    // Allocate main structure
    //

    (*InternalError) = NO_ERROR;
    (*pNetInfo) = NetInfo = New( sizeof(NETWORK_INFO ) );

    if( NULL == NetInfo ) return GetLastError();

    Flags = GAA_FLAG_SKIP_ANYCAST | GAA_FLAG_SKIP_MULTICAST;
    GetAdaptersAddresses(AF_UNSPEC, Flags, NULL, NULL, &BufferLength);

    IfList = (PIP_ADAPTER_ADDRESSES)New(BufferLength);
    if( NULL == IfList ) return GetLastError();

    Error = GetAdaptersAddresses(AF_UNSPEC, Flags, NULL, IfList, &BufferLength);
    if( Error != NO_ERROR ) {
        Delete(IfList);
        return Error;
    }

    SearchInfo = NULL;
    pIfTable = NULL;
    InterfaceInfo = NULL;
    IfNameInfo = NULL;
    AddrTable = NULL;
    RouteTable = NULL;

    do {

        //
        // Fill important fields of the main structure
        //

        Length = MaxHostNameSize;
        fSuccess = GetComputerNameExW(
            ComputerNameDnsHostname, NetInfo->HostName, &Length );
        CheckBoolError( GlobalHostNameFailure );

        Length = MaxDomainNameSize;
        fSuccess = GetComputerNameExW(
            ComputerNameDnsDomain, NetInfo->DomainName, &Length );
        if( FALSE == fSuccess ) NetInfo->DomainName[0] = L'\0';

        Error = GetIpStatistics( &IpStats );
        CheckError( GlobalEnableRouterFailure );
        NetInfo->EnableRouting = (
            IpStats.dwForwarding == MIB_IP_FORWARDING );

        //
        // EnableProxy and EnableDnsForNetbios both come from the
        // registry directly?  We will use the GetNetworkParams
        // API for this instead.
        //
        Size = 1000;
        FixedInfo = NULL;
        do {
            Delete(FixedInfo);
            FixedInfo = (PFIXED_INFO)New(Size);
            if (NULL == FixedInfo) {
                Error = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            Length = Size;
            Error = GetNetworkParams( FixedInfo, &Length );
            Size = Length;
        } while (Error == ERROR_BUFFER_OVERFLOW);
        CheckError( GlobalEnableDnsFailure );

        NetInfo->EnableProxy = FixedInfo->EnableProxy;
        NetInfo->EnableDnsForNetbios = FixedInfo->EnableDns;
        Delete(FixedInfo);
        FixedInfo = NULL;

        //
        // Now get the suffix search list from Dns
        //

        SearchInfo = DnsQueryConfigAlloc(
                        DnsConfigSearchInformation,
                        NULL );

        if( NULL != SearchInfo ) {
            Length = 0;

            for( i = 0; i < SearchInfo->cNameCount ; i ++ ) {
                Length += MultiByteToWideChar(
                    CP_UTF8, 0, SearchInfo->aSearchListNames[i],
                    -1, NULL, 0 );
            }

            if( Length != 0 ) {
                Length ++;
                NetInfo->SuffixSearchList = New( sizeof(WCHAR)*Length);
                if( NULL == NetInfo->SuffixSearchList ) {
                    Error = GetLastError(); break;
                }


                Size = Length; Length = 0;
                for( i = 0; i < SearchInfo->cNameCount ; i ++ ) {
                    Length += MultiByteToWideChar(
                        CP_UTF8, 0, SearchInfo->aSearchListNames[i],
                        -1, &NetInfo->SuffixSearchList[Length],
                        Size - Length );
                }
            }
        }

        //
        // Now go for the interface specific stuff.
        //

        Error = NhpAllocateAndGetInterfaceInfoFromStack(
            &IfNameInfo, &IfNameCount, TRUE, GetProcessHeap(),
            HEAP_NO_SERIALIZE );
        CheckError( GlobalIfNameInfoFailure );

#ifdef __IPCFG_ENABLE_LOG__
        IPCFG_TRACE(IPCFG_TRACE_TCPIP, ("NhpAllocateAndGetInterfaceInfoFromStack returns 0x%lx (%d) %d Interfaces\n",
                    Error, Error, IfNameCount));
        for (i = 0; i < IfNameCount; i++) {
            LPWSTR  DeviceGuid, InterfaceGuid;

            DeviceGuid = InterfaceGuid = NULL;
            UuidToStringW(&IfNameInfo[i].DeviceGuid, &DeviceGuid);
            UuidToStringW(&IfNameInfo[i].InterfaceGuid, &InterfaceGuid);
            if (DeviceGuid == NULL || InterfaceGuid == NULL) {
                if (DeviceGuid) RpcStringFree(&DeviceGuid);
                if (InterfaceGuid) RpcStringFree(&InterfaceGuid);
                IPCFG_TRACE(IPCFG_TRACE_TCPIP, ("\t%2d. Index=0x%x DeviceGUID=<fail> InterfaceGUID=<fail>\n",
                        i + 1, IfNameInfo[i].Index));
            } else {
                IPCFG_TRACE(IPCFG_TRACE_TCPIP, ("\t%2d. Index=0x%x\n\t    DeviceGUID=%ws\n\t    InterfaceGUID=%ws\n",
                        i + 1, IfNameInfo[i].Index, DeviceGuid, InterfaceGuid));
                RpcStringFree(&DeviceGuid);
                RpcStringFree(&InterfaceGuid);
            }
        }
#endif

        Size = 1000;
        do {
            Delete( RouteTable );
            RouteTable = New( Size );

            if( NULL == RouteTable ) {
                Error = GetLastError();
            } else {
                Error = GetIpForwardTable(
                    RouteTable, &Size, FALSE );
            }
        } while( ERROR_INSUFFICIENT_BUFFER == Error );
#ifdef __IPCFG_ENABLE_LOG__
        if (RouteTable) {
            IPCFG_TRACE(IPCFG_TRACE_TCPIP, ("GetIpForwardTable returns 0x%lx (%d) %d routing entries\n",
                        Error, Error, RouteTable->dwNumEntries));
            for (i = 0; i < RouteTable->dwNumEntries; i++) {
                IPCFG_TRACE(IPCFG_TRACE_TCPIP, ("\t%2d. Index=0x%x Next Hop=%s ",
                        i + 1, RouteTable->table[i].dwForwardIfIndex,
                        inet_ntoa(*(struct in_addr*)&RouteTable->table[i].dwForwardNextHop)));

                IPCFG_TRACE(IPCFG_TRACE_TCPIP, ("Mask=%s Type=0x%x\n",
                        inet_ntoa(*(struct in_addr*)&RouteTable->table[i].dwForwardMask),
                        RouteTable->table[i].dwForwardType));
            }
        }
#endif

        Size = 1000;
        do {
            Delete( AddrTable );
            AddrTable = New( Size );

            if( NULL == AddrTable ) {
                Error = GetLastError();
            } else {
                Error = GetIpAddrTable( AddrTable, &Size, TRUE );
            }
        } while( ERROR_INSUFFICIENT_BUFFER == Error );

        CheckError( GlobalAddrTableFailure );
#ifdef __IPCFG_ENABLE_LOG__
        IPCFG_TRACE(IPCFG_TRACE_TCPIP, ("GetIpAddrTable returns 0x%lx (%d) %d IP entries\n",
                    Error, Error, AddrTable->dwNumEntries));
        for (i = 0; i < AddrTable->dwNumEntries; i++) {
            IPCFG_TRACE(IPCFG_TRACE_TCPIP, ("\t%2d. Index=0x%x IP=%s",
                    i + 1, AddrTable->table[i].dwIndex,
                    inet_ntoa(*(struct in_addr*)&AddrTable->table[i].dwAddr)));
            IPCFG_TRACE(IPCFG_TRACE_TCPIP, (" mask=%s Type=0x%x\n",
                    inet_ntoa(*(struct in_addr*)&AddrTable->table[i].dwMask),
                    AddrTable->table[i].wType));
        }
#endif

        Size = 1000;
        do {
            Delete( pIfTable );
            pIfTable = New( Size );

            if( NULL == pIfTable ) {
                Error = GetLastError();
            } else {
                Error = GetIfTable( pIfTable, &Size, TRUE );
            }

        } while( ERROR_INSUFFICIENT_BUFFER == Error );

        CheckError( GlobalIfTableFailure );
#ifdef __IPCFG_ENABLE_LOG__
        IPCFG_TRACE(IPCFG_TRACE_TCPIP, ("GetIfTable returns 0x%lx (%d) %d Interfaces\n",
                    Error, Error, pIfTable->dwNumEntries));
        for( i = 0; i < pIfTable->dwNumEntries; i ++ ) {
            IPCFG_TRACE(IPCFG_TRACE_TCPIP, ("\t%2d. IfIndex=0x%x Name=%ws IfType=0x%x\n",
                        i + 1, pIfTable->table[i].dwIndex, pIfTable->table[i].wszName, pIfTable->table[i].dwType));
        }
#endif

        Size = 1000;
        do {
            Delete( InterfaceInfo );
            InterfaceInfo = New( Size );

            if( NULL == InterfaceInfo ) {
                Error = GetLastError();
            } else {
                Error = GetInterfaceInfo( InterfaceInfo, &Size );
            }
        } while( ERROR_INSUFFICIENT_BUFFER == Error );

        CheckError( GlobalIfInfoFailure );
#ifdef __IPCFG_ENABLE_LOG__
        IPCFG_TRACE(IPCFG_TRACE_TCPIP, ("GetInterfaceInfo returns 0x%lx (%d) %d Interfaces\n",
                    Error, Error, InterfaceInfo->NumAdapters));
        for( i = 0; i < (DWORD)InterfaceInfo->NumAdapters; i ++ ) {
            IPCFG_TRACE(IPCFG_TRACE_TCPIP, ("\t%2d. Index=0x%x\n\t    Name=%ws\n",
                        i + 1, InterfaceInfo->Adapter[i].Index, InterfaceInfo->Adapter[i].Name));
        }
#endif

        //
        // Get global AutoConfig settings
        //
        NetInfo->GlobalEnableAutoconfig = GetGlobalTcpipAutoconfigFlag();
        IPCFG_TRACE(IPCFG_TRACE_TCPIP, ("GlobalAutoConfigFlag: %d\n", NetInfo->GlobalEnableAutoconfig));

        //
        // Check for number of interfaces and allocate required
        // space in the IfInfo field
        //

        IfCount = pIfTable->dwNumEntries;
        IfCount += CountIpv6OnlyInterfaces(IfList);
        if( IfCount > 1 ) {
            NetInfo->nInterfaces = IfCount-1;
            NetInfo->IfInfo = New(
                NetInfo->nInterfaces * sizeof(PVOID) );
            if( NULL == NetInfo->IfInfo ) {
                Error = GetLastError(); break;
            }

            //
            // First add interfaces running IPv4.
            //
            j = 0;
            for( i = 0; i < pIfTable->dwNumEntries ; i ++ ) {
                BOOL fFound = FALSE;

                for( k = 0; k <
                     (DWORD)InterfaceInfo->NumAdapters; k ++ ) {

                    if( pIfTable->table[i].dwIndex ==
                        InterfaceInfo->Adapter[k].Index ) {
                        fFound = TRUE;
                        break;
                    }

                }

                if( fFound &&
                    pIfTable->table[i].dwType != IF_TYPE_SOFTWARE_LOOPBACK ) {

                    IPCFG_TRACE(IPCFG_TRACE_TCPIP, ("\n\n************ GetPerInterfaceInfo for "
                                "IfIndex=0x%x Name=%ws IfType=0x%x\n",
                        pIfTable->table[i].dwIndex, pIfTable->table[i].wszName, pIfTable->table[i].dwType));

                    Error = GetPerInterfaceInfo(
                        NetInfo, &NetInfo->IfInfo[j],
                        &pIfTable->table[i], InterfaceInfo,
                        IfNameInfo, IfNameCount, AddrTable,
                        RouteTable, IfList, InternalError );

                    if( NO_ERROR != Error ) break;
                    j ++;
                }
            }

            //
            // Now add any IPv6-only interfaces.
            //
            for (If = IfList; If; If = If->Next) {
                if ((If->IfIndex == 0) && (If->Ipv6IfIndex != 0) &&
                    (If->IfType != IF_TYPE_SOFTWARE_LOOPBACK) &&
                    ((If->IfType != IF_TYPE_TUNNEL) || (If->FirstUnicastAddress != NULL))) {
                    Error = GetIpv6OnlyPerInterfaceInfo(&NetInfo->IfInfo[j], 
                                                        If);
                    if( NO_ERROR != Error ) break;
                    j ++;
                }
            }

            NetInfo->nInterfaces = j;

            if( NO_ERROR != Error ) break;
        }


    } while ( 0 );

    Delete( pIfTable );
    Delete( InterfaceInfo );
    Delete( IfNameInfo );
    Delete( AddrTable );
    Delete( RouteTable );
    Delete( FixedInfo );
    Delete( IfList );

    if ( SearchInfo ) {
        DnsFreeConfigStructure(
            SearchInfo,
            DnsConfigSearchInformation );
    }

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\commands\pathping\makefile.inc ===
$(O)\nlstxt.mc: localmsg.mc
    copy localmsg.mc $@
    $(MC) -v -h $(O) -r $(O) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\commands\netstat\makefile.inc ===
netstat.rc: netstmsg.rc msg00001.bin

netstmsg.h netstmsg.rc msg00001.bin: netstmsg.mc
    mc -v netstmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\commands\ipconfig\precomp.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    precompiled header

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

//
// set compiler warning settings
//

#pragma warning( disable: 4127 )
// allow while( 0 ) etc.

#pragma warning( disable: 4221 )
#pragma warning( disable: 4204 )
// allow initializations for structs with variables

#pragma warning( disable: 4201 )
// allow structs with no names

#pragma warning( disable: 4245 )
// allow initialization time unsigned/signed mismatch

#pragma warning( disable: 4232 )
// allow initialization of structs with fn ptrs from dllimport

#pragma warning( disable: 4214 )
// allow bit fields in structs

#include <winsock2.h>
#include <ws2tcpip.h>
#include <mstcpip.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <align.h>
#include <iphlpapi.h>
#include <tchar.h>
#include <rtutils.h>
#include <windns.h>
#include <dnsapi.h>

//
// set compiler warning settings
//

#pragma warning( disable: 4127 )
// allow while( 0 ) etc.

#pragma warning( disable: 4221 )
#pragma warning( disable: 4204 )
// allow initializations for structs with variables

#pragma warning( disable: 4201 )
// allow structs with no names

#pragma warning( disable: 4245 )
// allow initialization time unsigned/signed mismatch

#pragma warning( disable: 4232 )
// allow initialization of structs with fn ptrs from dllimport

#pragma warning( disable: 4214 )
// allow bit fields in structs

#include <guiddef.h>
#include <devguid.h>
#include <setupapi.h>
#include <netconp.h>
#include <ntddtcp.h>
#include <ntddip.h>
#include <tdistat.h>
#include <tdiinfo.h>
#include <llinfo.h>
#include <ipinfo.h>
#include <ipexport.h>
#include <nbtioctl.h>

#pragma warning( disable: 4200 )
// allow zero sized arrays

#include <nhapi.h>
#include <iphlpstk.h>
#include <ndispnp.h>

#include <ipconfig.h>
#include <ntddip6.h>

#pragma warning(disable:4001)
#pragma warning(disable:4201)
#pragma warning(disable:4214)
#pragma warning(disable:4514)

//
// This structure has global information only
//

#define MaxHostNameSize 256
#define MaxDomainNameSize 256
#define MaxScopeIdSize 256
#define MaxPhysicalNameSize 256
#define MaxDeviceGuidName 256

#ifndef IPV4_ADDRESS_DEFINED
typedef DWORD IPV4_ADDRESS;
#endif

typedef struct _INTERFACE_NETWORK_INFO {
    //
    // General device info
    //
    
    WCHAR DeviceGuidName[MaxDeviceGuidName];
    DWORD IfType;
    CHAR PhysicalName[MaxPhysicalNameSize];
    DWORD PhysicalNameLength;
    LPWSTR FriendlyName;
    LPWSTR ConnectionName;
    BOOL MediaDisconnected;

    //
    // Dhcp specific info
    //
    
    LPWSTR DhcpClassId;
    BOOL EnableDhcp;
    BOOL EnableAutoconfig;
    IPV4_ADDRESS DhcpServer;
    LONGLONG LeaseObtainedTime; // these are actually FILETIMEs but made them...
    LONGLONG LeaseExpiresTime;  // ...LONGLONG to fix alignment pb on W64 (#120397)
    BOOL AutoconfigActive;

    //
    // Dns specific info
    //
    
    IPV4_ADDRESS *DnsServer; // network order
    ULONG nDnsServers;
    SOCKADDR_IN6 *Ipv6DnsServer;
    ULONG nIpv6DnsServers;
    WCHAR DnsSuffix[MaxDomainNameSize];

    //
    // Wins specific Info
    //
    
    IPV4_ADDRESS *WinsServer; // network order
    ULONG nWinsServers;
    BOOL EnableNbtOverTcpip;

    //
    // Ip specific info: first ip is primary addr
    //
    
    IPV4_ADDRESS *IpAddress; // network order
    ULONG nIpAddresses;
    SOCKADDR_IN6 *Ipv6Address;
    ULONG nIpv6Addresses;
    IPV4_ADDRESS *IpMask; // network order
    ULONG nIpMasks;
    IPV4_ADDRESS *Router; // network order
    ULONG nRouters;
    SOCKADDR_IN6 *Ipv6Router;
    ULONG nIpv6Routers;
} INTERFACE_NETWORK_INFO, *PINTERFACE_NETWORK_INFO;

typedef struct _NETWORK_INFO {
    WCHAR HostName[MaxHostNameSize];
    WCHAR DomainName[MaxDomainNameSize];
    WCHAR ScopeId[MaxScopeIdSize];
    ULONG NodeType;
    BOOL EnableRouting;
    BOOL EnableProxy;
    BOOL EnableDnsForNetbios;
    BOOL GlobalEnableAutoconfig;
    LPWSTR SuffixSearchList; // Multi_Sz string
    ULONG nInterfaces;
    PINTERFACE_NETWORK_INFO *IfInfo;
} NETWORK_INFO, *PNETWORK_INFO;

//
// Node Type values
//

enum {
    NodeTypeUnknown = 0,
    NodeTypeBroadcast,
    NodeTypePeerPeer,
    NodeTypeMixed,
    NodeTypeHybrid
};

//
// IfType values
//

enum {
    IfTypeUnknown = 0,
    IfTypeOther,
    IfTypeEthernet,
    IfTypeTokenring,
    IfTypeFddi,
    IfTypeLoopback,
    IfTypePPP,
    IfTypeSlip,
    IfTypeTunnel,
    IfType1394
} IfTypeConstants;

//
// Internal error codes
//

enum {
    GlobalHostNameFailure = 0,
    GlobalDomainNameFailure = 2,
    GlobalEnableRouterFailure = 3,
    GlobalEnableDnsFailure = 4,
    GlobalIfTableFailure = 5,
    GlobalIfInfoFailure = 6,
    GlobalIfNameInfoFailure = 7,
    GlobalAddrTableFailure = 8,
    GlobalRouteTableFailure = 9,
    
    InterfaceUnknownType = 10,
    InterfaceUnknownFriendlyName = 11,
    InterfaceUnknownMediaStatus = 12,
    InterfaceUnknownTcpipDevice = 13,
    InterfaceOpenTcpipKeyReadFailure = 14,
    InterfaceDhcpValuesFailure = 15,
    InterfaceDnsValuesFailure = 16,
    InterfaceWinsValuesFailure = 17,
    InterfaceAddressValuesFailure = 18,
    InterfaceRouteValuesFailure = 19,

    NoSpecificError = 20,
} InternalFailureCodes;


//
// routines exported from info.c
//

enum {
    OpenTcpipParmKey,
    OpenTcpipKey,
    OpenNbtKey
} KeyTypeEnums;

enum {
    OpenKeyForRead = 0x01,
    OpenKeyForWrite = 0x02
} AccessTypeEnums;


DWORD
OpenRegKey(
    IN LPCWSTR Device,
    IN DWORD KeyType,
    IN DWORD AccessType,
    OUT HKEY *phKey
    );

VOID
FreeNetworkInfo(
    IN OUT PNETWORK_INFO NetInfo
    );

DWORD
GetNetworkInformation(
    OUT PNETWORK_INFO *pNetInfo,
    IN OUT DWORD *InternalError
    );

//
// exported by display.c
//

typedef struct _CMD_ARGS {
    LPWSTR All, Renew, Release, FlushDns, Register;
    LPWSTR DisplayDns, ShowClassId, SetClassId;
    LPWSTR Debug, Usage, UsageErr;
} CMD_ARGS, *PCMD_ARGS;

DWORD
GetCommandArgConstants(
    IN OUT PCMD_ARGS Args
    );

DWORD
FormatNetworkInfo(
    IN OUT LPWSTR Buffer,
    IN ULONG BufSize,
    IN PNETWORK_INFO NetInfo,
    IN DWORD Win32Error,
    IN DWORD InternalError,
    IN BOOL fVerbose,
    IN BOOL fDebug
    );

DWORD
DumpMessage(
    IN LPWSTR Buffer,
    IN ULONG BufSize,
    IN ULONG MsgId,
    ...
    );

DWORD
DumpMessageError(
    IN LPWSTR Buffer,
    IN ULONG BufSize,
    IN ULONG MsgId,
    IN ULONG_PTR Error,
    IN PVOID Arg OPTIONAL
    );

DWORD
DumpErrorMessage(
    IN LPWSTR Buffer,
    IN ULONG BufSize,
    IN ULONG InternalError,
    IN ULONG Win32Error
    );

#ifdef __IPCFG_ENABLE_LOG__
extern DWORD    dwTraceFlag;
extern int      TraceFunc(const char* fmt, ...);
#define IPCFG_TRACE_TCPIP       0x01U

#define IPCFG_TRACE(x,y)    \
    if (dwTraceFlag & x) {  \
        TraceFunc   y;      \
    }
#else
#define IPCFG_TRACE(x,y)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\commands\netstat\netstat.h ===
#include <ntspider.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#undef SOCKET
#include "..\common\tcpcmd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\commands\netstat\netstat.c ===
//*****************************************************************************
//
// Name:        netstat.c
//
// Description: Source code for netstat.exe.
//
// History:
//  12/29/93  JayPh     Created.
//  12/01/94  MuraliK   modified to use toupper instead of CharUpper
//
//*****************************************************************************

//*****************************************************************************
//
// Copyright (c) 1993-2000 by Microsoft Corp.  All rights reserved.
//
//*****************************************************************************

//
// Include Files
//

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <snmp.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <icmp6.h>

#include "common2.h"
#include "tcpinfo.h"
#include "ipinfo.h"
#include "llinfo.h"
#include "tcpcmd.h"
#include "netstmsg.h"
#include "mdebug.h"

//#include <iphlpstk.h>
DWORD
AllocateAndGetTcpExTableFromStack(
    OUT PVOID         *ppTcpTable,
    IN  BOOL          bOrder,
    IN  HANDLE        hHeap,
    IN  DWORD         dwFlags,
    IN  DWORD         dwFamily
    );

DWORD
AllocateAndGetUdpExTableFromStack(
    OUT PVOID         *ppUdpTable,
    IN  BOOL          bOrder,
    IN  HANDLE        hHeap,
    IN  DWORD         dwFlags,
    IN  DWORD         dwFamily
    );


//
// Definitions
//

#define PROTO_NONE              0
#define PROTO_TCP               1
#define PROTO_UDP               2
#define PROTO_IP                4
#define PROTO_ICMP              8
#define PROTO_TCP6           0x10
#define PROTO_UDP6           0x20
#define PROTO_IP6            0x40
#define PROTO_ICMP6          0x80

#define MAX_ID_LENGTH           50
#define MAX_RETRY_COUNT         10

//
//  Presently FQDNs are of maximum of 255 characters. Be conservative,
//   and define the maximum size possible as 260
//  MuraliK  ( 12/15/94)
//
#define MAX_HOST_NAME_SIZE        ( 260)
#define MAX_SERVICE_NAME_SIZE     ( 200)

//
//  Private ASSERT macro that doesn't depend on NTDLL (so this can run
//  under Windows 95) -- KeithMo 01/09/95
//

#if DBG
#ifdef ASSERT
#undef ASSERT
#endif  // ASSERT

#define ASSERT(exp) if(!(exp)) MyAssert( #exp, __FILE__, (DWORD)__LINE__ )

void MyAssert( void * exp, void * file, DWORD line )
{
    char output[512];

    wsprintf( output,
              "\n*** Assertion failed: %s\n*** Source file: %s, line %lu\n\n",
              exp,
              file,
              line );

    OutputDebugString( output );
    DebugBreak();
}

#endif  // DBG


//
// Structure Definitions
//


//
// Function Prototypes
//

ulong DoInterface( ulong VerboseFlag );
ulong DoIP( DWORD Type, ulong VerboseFlag );
ulong DoTCP( DWORD Type, ulong VerboseFlag );
ulong DoUDP( DWORD Type, ulong VerboseFlag );
ulong DoICMP( DWORD Type, ulong VerboseFlag );
ulong DoConnections( ulong ProtoFlag,
                     ulong ProtoVal,
                     ulong NumFlag,
                     ulong AllFlag );
ulong DoConnectionsWithOwner( ulong ProtoFlag,
                              ulong ProtoVal,
                              ulong NumFlag,
                              ulong AllFlag );
ulong DoRoutes( void );
void  DisplayInterface( IfEntry *pEntry, ulong VerboseFlag, IfEntry *ListHead );
void  DisplayIP( DWORD Type, IpEntry *pEntry, ulong VerboseFlag, IpEntry *ListHead );
void  DisplayTCP( DWORD Type, TcpEntry *pEntry, ulong VerboseFlag, TcpEntry *ListHead );
void  DisplayUDP( DWORD Type, UdpEntry *pEntry, ulong VerboseFlag, UdpEntry *ListHead );
void  DisplayICMP( IcmpEntry *pEntry, ulong VerboseFlag, IcmpEntry *ListHead );
void  DisplayICMP6( Icmp6Entry *pEntry, ulong VerboseFlag, IcmpEntry *ListHead );
void  DisplayTcpConnEntry( TCPConnTableEntry *pTcp, ulong InfoSize, ulong NumFlag );
void  DisplayTcp6ConnEntry( TCP6ConnTableEntry *pTcp, ulong NumFlag );
void  DisplayUdpConnEntry( UDPEntry *pUdp, ulong InfoSize, ulong NumFlag );
void  DisplayUdp6ListenerEntry( UDP6ListenerEntry *pUdp, BOOL WithOwner, ulong NumFlag );
void  Usage( void );


//
// Global Variables
//

uchar           *PgmName;
extern long      verbose;     // in ../common2/snmpinfo.c

//*****************************************************************************
//
// Name:        main
//
// Description: Entry point for netstat command.
//
// Parameters:  int argc: count of command line tokens.
//              char argv[]: array of pointers to command line tokens.
//
// Returns:     void.
//
// History:
//  12/29/93  JayPh     Created.
//
//*****************************************************************************

void __cdecl main( int argc, char *argv[] )
{
    ulong   VerboseFlag = FALSE;
    ulong   AllFlag = FALSE;
    ulong   EtherFlag = FALSE;
    ulong   NumFlag = FALSE;
    ulong   StatFlag = FALSE;
    ulong   ProtoFlag = FALSE;
    ulong   ProtoVal = PROTO_TCP | PROTO_UDP | PROTO_IP | PROTO_ICMP |
                       PROTO_TCP6 | PROTO_UDP6 | PROTO_IP6 | PROTO_ICMP6;
    ulong   RouteFlag = FALSE;
    ulong   OwnerFlag = FALSE;
    ulong   IntervalVal = 0;
    ulong   LastArgWasProtoFlag = FALSE;
    ulong   ConnectionsShown = FALSE;
    ulong   Result;
    long    i;
    char    *ptr;
    WSADATA WsaData;


    DEBUG_PRINT(( __FILE__ " built " __DATE__ " " __TIME__ "\n" ));
    verbose = 0;    // Default for snmpinfo.c

    // Convert arguments to Oem strings (whatever that means)

    ConvertArgvToOem( argc, argv );

    // Save the name of this program for use in messages later.

    PgmName = argv[0];

    // Initialize the Winsock interface

    Result = WSAStartup( 0x0101, &WsaData );
    if ( Result == SOCKET_ERROR )
    {
        PutMsg( STDERR, MSG_WSASTARTUP, PgmName, GetLastError() );
        exit( 1 );
    }

    // Process command line arguments

    for ( i = 1; i < argc; i++ )
    {
        if ( LastArgWasProtoFlag )
        {
            // Process a protocol argument following the protocol flag

            _strupr( argv[i] );

            if ( strcmp( argv[i], "TCP" ) == 0 )
            {
                ProtoVal = PROTO_TCP;
            }
            else if ( strcmp( argv[i], "TCPV6" ) == 0 )
            {
                ProtoVal = PROTO_TCP6;
            }
            else if ( strcmp( argv[i], "UDP" ) == 0 )
            {
                ProtoVal = PROTO_UDP;
            }
            else if ( strcmp( argv[i], "UDPV6" ) == 0 )
            {
                ProtoVal = PROTO_UDP6;
            }
            else if ( strcmp( argv[i], "IP" ) == 0 )
            {
                ProtoVal = PROTO_IP;
            }
            else if ( strcmp( argv[i], "IPV6" ) == 0 )
            {
                ProtoVal = PROTO_IP6;
            }
            else if ( strcmp( argv[i], "ICMP" ) == 0 )
            {
                ProtoVal = PROTO_ICMP;
            }
            else if ( strcmp( argv[i], "ICMPV6" ) == 0 )
            {
                ProtoVal = PROTO_ICMP6;
            }
            else
            {
                Usage();
            }

            LastArgWasProtoFlag = FALSE;
            continue;
        }

        if ( ( argv[i][0] == '-' ) || ( argv[i][0] == '/' ) )
        {
            // Process flag arguments

            ptr = &argv[i][1];
            while ( *ptr )
            {
                if ( toupper( *ptr ) == 'A' )
                {
                    AllFlag = TRUE;
                }
                else if ( toupper( *ptr ) == 'E' )
                {
                    EtherFlag = TRUE;
                    ProtoVal = PROTO_TCP | PROTO_UDP | PROTO_ICMP | PROTO_IP |
                               PROTO_TCP6 | PROTO_UDP6 | PROTO_ICMP6 | PROTO_IP6;
                }
                else if ( toupper( *ptr ) == 'N' )
                {
                    NumFlag = TRUE;
                }
                else if ( toupper( *ptr ) == 'O' )
                {
                    OwnerFlag = TRUE;
                }
                else if ( toupper( *ptr ) == 'S' )
                {
                    StatFlag = TRUE;
                    ProtoVal = PROTO_TCP | PROTO_UDP | PROTO_IP | PROTO_ICMP |
                               PROTO_TCP6 | PROTO_UDP6 | PROTO_IP6 | PROTO_ICMP6;
                }
                else if ( toupper( *ptr ) == 'P' )
                {
                    ProtoFlag = TRUE;
                    LastArgWasProtoFlag = TRUE;
                }
                else if ( toupper( *ptr ) == 'R' )
                {
                    RouteFlag = TRUE;
                }
                else if ( toupper( *ptr ) == 'V' )
                {
                    VerboseFlag = TRUE;
#ifdef DBG
                    verbose++;
#endif
                }
                else
                {
                    Usage();
                }

                ptr++;
            }
        }
        else if ( IntervalVal == 0 )
        {
            // This must be the interval parameter

            Result = sscanf( argv[i], "%d", &IntervalVal );
            if ( Result != 1 )
            {
                Usage();
            }
        }
        else
        {
            Usage();
        }
    }

    // Initialize the SNMP interface.

    Result = InitSnmp();

    if ( Result != NO_ERROR )
    {
        PutMsg( STDERR, MSG_SNMP_INIT_FAILED, Result );
        exit( 1 );
    }

    // This loop provides the 'repeat every <interval> seconds' functionality.
    // We break out of the loop after one pass if the interval was not
    // specified.

    while ( TRUE )
    {
        // If interface statistics requested, give them

        if ( EtherFlag )
        {
            // Show ethernet statistics

            DoInterface( VerboseFlag );
        }

        // If a specific protocol is requested, provide info for only that
        // protocol.  If no protocol specified, provide info for all protocols.
        // ProtoVal is initialized to all protocols.

        if ( StatFlag )
        {
            // Show protocol statistics

            if ( ProtoVal & PROTO_IP )
            {
                DoIP( TYPE_IP, VerboseFlag );
            }
            if ( ProtoVal & PROTO_IP6 )
            {
                DoIP( TYPE_IP6, VerboseFlag );
            }
            if ( ProtoVal & PROTO_ICMP )
            {
                DoICMP( TYPE_ICMP, VerboseFlag );
            }
            if ( ProtoVal & PROTO_ICMP6 )
            {
                DoICMP( TYPE_ICMP6, VerboseFlag );
            }
            if ( ProtoVal & PROTO_TCP )
            {
                DoTCP( TYPE_TCP, VerboseFlag );
            }
            if ( ProtoVal & PROTO_TCP6 )
            {
                DoTCP( TYPE_TCP6, VerboseFlag );
            }
            if ( ProtoVal & PROTO_UDP )
            {
                DoUDP( TYPE_UDP, VerboseFlag );
            }
            if ( ProtoVal & PROTO_UDP6 )
            {
                DoUDP( TYPE_UDP6, VerboseFlag );
            }
        }

        // If a protocol is specified and that protocol is either TCP or UDP,
        // OR none of (route, statistics, interface ) flags given (this is the
        // default, no flags, case )

        if ( ( ProtoFlag &&
               ( ( ProtoVal & PROTO_TCP ) || ( ProtoVal & PROTO_UDP ) ||
                 ( ProtoVal & PROTO_TCP6 ) || ( ProtoVal & PROTO_UDP6 ) ) ) ||
             ( !EtherFlag && !StatFlag && !RouteFlag ) )
        {
            // Show active connections

            if (OwnerFlag) 
            {
                DoConnectionsWithOwner( ProtoFlag, ProtoVal, NumFlag, AllFlag );
            }
            else
            {
                DoConnections( ProtoFlag, ProtoVal, NumFlag, AllFlag );
            }
            ConnectionsShown = TRUE;
        }

        // Provide route information if requested

        if ( RouteFlag )
        {
            // Show connections and the route table

            DoRoutes();
        }

        // If interval was not supplied on command line then we are done.
        // Otherwise wait for 'interval' seconds and do it again.

        if ( IntervalVal == 0 )
        {
            break;
        }
        else
        {
            DEBUG_PRINT(("Sleeping %d ms\n", IntervalVal ));
            Sleep( IntervalVal * 1000 );
        }
    }
}


//*****************************************************************************
//
// Name:        DoInterface
//
// Description: Display ethernet statistics.
//
// Parameters:  ulong VerboseFlag: indicates whether settings data should be
//                      displayed.
//
// Returns:     ulong: NO_ERROR or some error code.
//
// History:
//  01/21/93  JayPh     Created.
//
//*****************************************************************************

ulong DoInterface( ulong VerboseFlag )
{
    IfEntry            *ListHead;
    IfEntry            *pIfList;
    IfEntry             SumOfEntries;
    ulong               Result;

    // Get the statistics

    ListHead = (IfEntry *)GetTable( TYPE_IF, &Result );
    if ( ListHead == NULL )
    {
        return ( Result );
    }

    // Clear the summation structure

    ZeroMemory( &SumOfEntries, sizeof( IfEntry ) );

    // Traverse the list of interfaces, summing the different fields

    pIfList = CONTAINING_RECORD( ListHead->ListEntry.Flink,
                                 IfEntry,
                                 ListEntry );

    while (pIfList != ListHead)
    {
        SumOfEntries.Info.if_inoctets += pIfList->Info.if_inoctets;
        SumOfEntries.Info.if_inucastpkts += pIfList->Info.if_inucastpkts;
        SumOfEntries.Info.if_innucastpkts += pIfList->Info.if_innucastpkts;
        SumOfEntries.Info.if_indiscards += pIfList->Info.if_indiscards;
        SumOfEntries.Info.if_inerrors += pIfList->Info.if_inerrors;
        SumOfEntries.Info.if_inunknownprotos +=
                                              pIfList->Info.if_inunknownprotos;
        SumOfEntries.Info.if_outoctets += pIfList->Info.if_outoctets;
        SumOfEntries.Info.if_outucastpkts += pIfList->Info.if_outucastpkts;
        SumOfEntries.Info.if_outnucastpkts += pIfList->Info.if_outnucastpkts;
        SumOfEntries.Info.if_outdiscards += pIfList->Info.if_outdiscards;
        SumOfEntries.Info.if_outerrors += pIfList->Info.if_outerrors;

        // Get pointer to next entry in list

        pIfList = CONTAINING_RECORD( pIfList->ListEntry.Flink,
                                     IfEntry,
                                     ListEntry );
    }

    DisplayInterface( &SumOfEntries, VerboseFlag, ListHead );

    // All done with list, free it.

    FreeTable( (GenericTable *)ListHead );

    return ( NO_ERROR );
}


//*****************************************************************************
//
// Name:        DoIP
//
// Description: Display IP statistics.
//
// Parameters:  ulong VerboseFlag: indicates whether settings data should be
//                      displayed.
//
// Returns:     ulong: NO_ERROR or some error code.
//
// History:
//  01/21/93  JayPh     Created.
//
//*****************************************************************************

ulong DoIP( DWORD Type, ulong VerboseFlag )
{
    IpEntry            *ListHead;
    IpEntry            *pIpList;
    ulong               Result;

    // Get the statistics

    ListHead = (IpEntry *)GetTable( Type, &Result );
    if ( ListHead == NULL )
    {
        return ( Result );
    }

    pIpList = CONTAINING_RECORD( ListHead->ListEntry.Flink,
                                 IpEntry,
                                 ListEntry );

    DisplayIP( Type, pIpList, VerboseFlag, ListHead );

    // All done with list, free it.

    FreeTable( (GenericTable *)ListHead );

    return ( NO_ERROR );
}


//*****************************************************************************
//
// Name:        DoTCP
//
// Description: Display TCP statistics.
//
// Parameters:  ulong VerboseFlag: indicates whether settings data should be
//                      displayed.
//
// Returns:     ulong: NO_ERROR or some error code.
//
// History:
//  01/21/93  JayPh     Created.
//
//*****************************************************************************

ulong DoTCP( DWORD Type, ulong VerboseFlag )
{
    TcpEntry           *ListHead;
    TcpEntry           *pTcpList;
    ulong               Result;

    // Get the statistics

    ListHead = (TcpEntry *)GetTable( Type, &Result );
    if ( ListHead == NULL )
    {
        return ( Result );
    }

    pTcpList = CONTAINING_RECORD( ListHead->ListEntry.Flink,
                                  TcpEntry,
                                  ListEntry );

    DisplayTCP( Type, pTcpList, VerboseFlag, ListHead );

    // All done with list, free it.

    FreeTable( (GenericTable *)ListHead );

    return ( NO_ERROR );
}


//*****************************************************************************
//
// Name:        DoUDP
//
// Description: Display UDP statistics.
//
// Parameters:  ulong VerboseFlag: indicates whether settings data should be
//                      displayed.
//
// Returns:     ulong: NO_ERROR or some error code.
//
// History:
//  01/21/93  JayPh     Created.
//
//*****************************************************************************

ulong DoUDP( DWORD Type, ulong VerboseFlag )
{
    UdpEntry           *ListHead;
    UdpEntry           *pUdpList;
    ulong               Result;

    // Get the statistics

    ListHead = (UdpEntry *)GetTable( Type, &Result );
    if ( ListHead == NULL )
    {
        return ( Result );
    }

    pUdpList = CONTAINING_RECORD( ListHead->ListEntry.Flink,
                                  UdpEntry,
                                  ListEntry );

    DisplayUDP( Type, pUdpList, VerboseFlag, ListHead );

    // All done with table, free it.

    FreeTable( (GenericTable *)ListHead );

    return ( NO_ERROR );
}


//*****************************************************************************
//
// Name:        DoICMP
//
// Description: Display ICMP statistics.
//
// Parameters:  ulong VerboseFlag: indicates whether settings data should be
//                      displayed.
//
// Returns:     ulong: NO_ERROR or some error code.
//
// History:
//  01/21/93  JayPh     Created.
//
//*****************************************************************************

ulong DoICMP( DWORD Type, ulong VerboseFlag )
{
    IcmpEntry          *ListHead;
    IcmpEntry          *pIcmpList;
    ulong               Result;

    // Get the statistics

    ListHead = (IcmpEntry *)GetTable( Type, &Result );
    if ( ListHead == NULL )
    {
        return ( Result );
    }

    pIcmpList = CONTAINING_RECORD( ListHead->ListEntry.Flink,
                                   IcmpEntry,
                                   ListEntry );

    if (Type == TYPE_ICMP) {
        DisplayICMP( pIcmpList, VerboseFlag, ListHead );
    } else {
        DisplayICMP6((Icmp6Entry *)pIcmpList, VerboseFlag, ListHead );
    }

    // All done with list, free it.

    FreeTable( (GenericTable *)ListHead );

    return ( NO_ERROR );
}


//*****************************************************************************
//
// Name:        DoConnections
//
// Description: List current connections.
//
// Parameters:  BOOL ProtoFlag: TRUE if a protocol was specified.
//              ulong ProtoVal: which protocol(s) were specified.
//
// Returns:     Win32 error code.
//
// History:
//  01/04/93  JayPh     Created.
//
//*****************************************************************************

ulong DoConnections( ulong ProtoFlag,
                     ulong ProtoVal,
                     ulong NumFlag,
                     ulong AllFlag )
{
    ulong          Result = NO_ERROR;

    PutMsg( STDOUT, MSG_CONN_HDR );

    if ( !ProtoFlag || ( ProtoFlag && ( ProtoVal == PROTO_TCP ) ) )
    {
        TcpConnEntry  *pTcpHead, *pTcp;

        // Get TCP connection table

        pTcpHead = (TcpConnEntry *)GetTable( TYPE_TCPCONN, &Result );
        if ( pTcpHead == NULL )
        {
            return ( Result );
        }

        // Get pointer to first entry in list

        pTcp = CONTAINING_RECORD( pTcpHead->ListEntry.Flink,
                                  TcpConnEntry,
                                  ListEntry );

        while (pTcp != pTcpHead)
        {
            if ( ( pTcp->Info.tct_state !=  TCP_CONN_LISTEN ) ||
                (( pTcp->Info.tct_state ==  TCP_CONN_LISTEN ) && AllFlag) )
            {
                // Display the Tcp connection info

                DisplayTcpConnEntry( &pTcp->Info, sizeof(TCPConnTableEntry), 
                                     NumFlag );
            }

            // Get the next entry in the table

            pTcp = CONTAINING_RECORD( pTcp->ListEntry.Flink,
                                      TcpConnEntry,
                                      ListEntry );
        }

        FreeTable( (GenericTable *)pTcpHead );
    }

    if ( !ProtoFlag || ( ProtoFlag && ( ProtoVal == PROTO_TCP6 ) ) )
    {
        Tcp6ConnEntry *pTcpHead, *pTcp;

        // Get TCP connection table

        pTcpHead = (Tcp6ConnEntry *)GetTable( TYPE_TCP6CONN, &Result );
        if ( pTcpHead == NULL )
        {
            return ( Result );
        }

        // Get pointer to first entry in list

        pTcp = CONTAINING_RECORD( pTcpHead->ListEntry.Flink,
                                  Tcp6ConnEntry,
                                  ListEntry );

        while (pTcp != pTcpHead)
        {
            if ( ( pTcp->Info.tct_state !=  TCP_CONN_LISTEN ) ||
                (( pTcp->Info.tct_state ==  TCP_CONN_LISTEN ) && AllFlag) )
            {
                // Display the Tcp connection info

                DisplayTcp6ConnEntry( &pTcp->Info, NumFlag );
            }

            // Get the next entry in the table

            pTcp = CONTAINING_RECORD( pTcp->ListEntry.Flink,
                                      Tcp6ConnEntry,
                                      ListEntry );
        }

        FreeTable( (GenericTable *)pTcpHead );
    }

    if ( !ProtoFlag || ( ProtoFlag && ( ProtoVal == PROTO_UDP ) ) )
    {
        UdpConnEntry  *pUdpHead, *pUdp;
    
        // Get UDP connection table

        pUdpHead = (UdpConnEntry *)GetTable( TYPE_UDPCONN, &Result );
        if ( pUdpHead == NULL )
        {
            return ( Result );
        }

        // Get pointer to first entry in list

        pUdp = CONTAINING_RECORD( pUdpHead->ListEntry.Flink,
                                  UdpConnEntry,
                                  ListEntry );

        while (pUdp != pUdpHead)
        {
            // Display the Udp connection info

            if (AllFlag) 
            {
                DisplayUdpConnEntry( &pUdp->Info, sizeof(UDPEntry), NumFlag );
            }

            // Get the next entry in the table

            pUdp = CONTAINING_RECORD( pUdp->ListEntry.Flink,
                                      UdpConnEntry,
                                      ListEntry );
        }

        FreeTable( (GenericTable *)pUdpHead );
    }

    if ( !ProtoFlag || ( ProtoFlag && ( ProtoVal == PROTO_UDP6 ) ) )
    {
        Udp6ListenerEntry  *pUdpHead, *pUdp;

        // Get UDP listener table

        pUdpHead = (Udp6ListenerEntry *)GetTable( TYPE_UDP6LISTENER, &Result );
        if ( pUdpHead == NULL )
        {
            return ( Result );
        }

        // Get pointer to first entry in list

        pUdp = CONTAINING_RECORD( pUdpHead->ListEntry.Flink,
                                  Udp6ListenerEntry,
                                  ListEntry );

        while (pUdp != pUdpHead)
        {
            // Display the Udp connection info

            if (AllFlag) 
            {
                DisplayUdp6ListenerEntry( &pUdp->Info, FALSE, NumFlag );
            }

            // Get the next entry in the table

            pUdp = CONTAINING_RECORD( pUdp->ListEntry.Flink,
                                      Udp6ListenerEntry,
                                      ListEntry );
        }

        FreeTable( (GenericTable *)pUdpHead );
    }

    return( Result );
}

//*****************************************************************************
//
// Name:        DoConnectionsWithOwner
//
// Description: List current connections and the process id associated with 
//              each.
//
// Parameters:  same as for DoConnections.
//
// Returns:     Win32 error code.
//
// History:
//  02/11/00  ShaunCo   Created.
//
//*****************************************************************************

ulong DoConnectionsWithOwner( ulong ProtoFlag,
                              ulong ProtoVal,
                              ulong NumFlag,
                              ulong AllFlag )
{
    ulong   Result = NO_ERROR;
    HANDLE  hHeap = GetProcessHeap();
    ulong   i;
    
    PutMsg( STDOUT, MSG_CONN_HDR_EX );

    if ( !ProtoFlag || ( ProtoFlag && ( ProtoVal == PROTO_TCP ) ) )
    {
        TCP_EX_TABLE        *pTcpTable;
        TCPConnTableEntryEx *pTcp;
        
        // Get TCP connection table with onwer PID information
        
        Result = AllocateAndGetTcpExTableFromStack( &pTcpTable, TRUE, 
                                                    hHeap, 0, AF_INET );
                    
        if ( NO_ERROR == Result ) 
        {
            for ( i = 0; i < pTcpTable->dwNumEntries; i++ )
            {
                pTcp = &pTcpTable->table[i];
                
                if ( ( pTcp->tcte_basic.tct_state !=  TCP_CONN_LISTEN ) ||
                    (( pTcp->tcte_basic.tct_state ==  TCP_CONN_LISTEN ) && AllFlag) )
                {
                    // DisplayTcpConnEntry needs the port info in host byte
                    // order.
                    pTcp->tcte_basic.tct_localport = (ulong)ntohs(
                        (ushort)pTcp->tcte_basic.tct_localport);
                    pTcp->tcte_basic.tct_remoteport = (ulong)ntohs(
                        (ushort)pTcp->tcte_basic.tct_remoteport);
                    
                    // Display the Tcp connection info
    
                    DisplayTcpConnEntry( (TCPConnTableEntry*)pTcp, 
                                         sizeof(TCPConnTableEntryEx), 
                                         NumFlag );
                }
            
            }
            
            HeapFree(hHeap, 0, pTcpTable);
        }
    }

    if ( !ProtoFlag || ( ProtoFlag && ( ProtoVal == PROTO_TCP6 ) ) )
    {
        TCP6_EX_TABLE      *pTcpTable;
        TCP6ConnTableEntry *pTcp;
        
        // Get TCP connection table with onwer PID information
        
        Result = AllocateAndGetTcpExTableFromStack( &pTcpTable, TRUE, 
                                                    hHeap, 0, AF_INET6 );
                    
        if ( NO_ERROR == Result ) 
        {
            for ( i = 0; i < pTcpTable->dwNumEntries; i++ )
            {
                pTcp = &pTcpTable->table[i];
                
                if ( ( pTcp->tct_state !=  TCP_CONN_LISTEN ) ||
                    (( pTcp->tct_state ==  TCP_CONN_LISTEN ) && AllFlag) )
                {
                    // DisplayTcpConnEntry needs the port info in host byte
                    // order.
                    pTcp->tct_localport = ntohs(
                        (ushort)pTcp->tct_localport);
                    pTcp->tct_remoteport = ntohs(
                        (ushort)pTcp->tct_remoteport);
                    
                    // Display the Tcp connection info
    
                    DisplayTcp6ConnEntry(pTcp, NumFlag);
                }
            
            }
            
            HeapFree(hHeap, 0, pTcpTable);
        }
    }

    if ( !ProtoFlag || ( ProtoFlag && ( ProtoVal == PROTO_UDP ) ) )
    {
        UDP_EX_TABLE    *pUdpTable;
        UDPEntryEx      *pUdp;
        
        // Get UDP connection table with owner PID information
        
        Result = AllocateAndGetUdpExTableFromStack ( &pUdpTable, TRUE,
                                                     hHeap, 0, AF_INET );
                    
        if (NO_ERROR == Result) 
        {
            for ( i = 0; i < pUdpTable->dwNumEntries; i++ ) 
            {
                pUdp = &pUdpTable->table[i];
                
                if (AllFlag) 
                {
                    // DisplayUdpConnEntry needs the port info in host byte
                    // order.
                    pUdp->uee_basic.ue_localport = (ulong)ntohs(
                        (ushort)pUdp->uee_basic.ue_localport);
                        
                    DisplayUdpConnEntry( (UDPEntry*)pUdp, 
                                         sizeof(UDPEntryEx), 
                                         NumFlag );
                }
            }
            
            HeapFree(hHeap, 0, pUdpTable);
        }
    }

    if ( !ProtoFlag || ( ProtoFlag && ( ProtoVal == PROTO_UDP6 ) ) )
    {
        UDP6_LISTENER_TABLE *pUdpTable;
        UDP6ListenerEntry   *pUdp;
        
        // Get UDP connection table with owner PID information
        
        Result = AllocateAndGetUdpExTableFromStack ( &pUdpTable, TRUE,
                                                     hHeap, 0, AF_INET6 );
                    
        if (NO_ERROR == Result) 
        {
            for ( i = 0; i < pUdpTable->dwNumEntries; i++ ) 
            {
                pUdp = &pUdpTable->table[i];
                
                if (AllFlag) 
                {
                    // DisplayUdp6ListenerEntry needs the port info in host byte
                    // order.
                    pUdp->ule_localport = (ulong)ntohs(
                        (ushort)pUdp->ule_localport);
                        
                    DisplayUdp6ListenerEntry(pUdp, 
                                             TRUE,
                                             NumFlag);
                }
            }
            
            HeapFree(hHeap, 0, pUdpTable);
        }
    }
    
    return( Result );
}

 
//*****************************************************************************
//
// Name:        DoRoutes
//
// Description: Display the route table.  Uses the system() API and route.exe
//              to do the dirty work.
//
// Parameters:  void.
//
// Returns:     ulong: NO_ERROR or some error code.
//
// History:
//  01/27/94  JayPh     Created.
//
//*****************************************************************************

ulong DoRoutes( void )
{
    ulong Result;

    PutMsg( STDOUT, MSG_ROUTE_HDR );

    Result = system( "route print" );

    return ( Result );
}


//*****************************************************************************
//
// Name:        DisplayInterface
//
// Description: Display interface statistics.
//
// Parameters:  IfEntry *pEntry: pointer to summary data entry.
//              ulong VerboseFlag: boolean indicating desire for verbosity.
//              IfEntry *ListHead: pointer to list of entries.  Used if
//                      verbosity desired.
//
// Returns:     void.
//
// History:
//  01/21/94  JayPh     Created.
//
//*****************************************************************************

void DisplayInterface( IfEntry *pEntry, ulong VerboseFlag, IfEntry *ListHead )
{
    char     *TmpStr;
    IfEntry  *pIfList;
    char      PhysAddrStr[32];

    PutMsg( STDOUT, MSG_IF_HDR );

    PutMsg( STDOUT,
            MSG_IF_OCTETS,
            pEntry->Info.if_inoctets,
            pEntry->Info.if_outoctets );

    PutMsg( STDOUT,
            MSG_IF_UCASTPKTS,
            pEntry->Info.if_inucastpkts,
            pEntry->Info.if_outucastpkts );

    PutMsg( STDOUT,
            MSG_IF_NUCASTPKTS,
            pEntry->Info.if_innucastpkts,
            pEntry->Info.if_outnucastpkts );

    PutMsg( STDOUT,
            MSG_IF_DISCARDS,
            pEntry->Info.if_indiscards,
            pEntry->Info.if_outdiscards );

    PutMsg( STDOUT,
            MSG_IF_ERRORS,
            pEntry->Info.if_inerrors,
            pEntry->Info.if_outerrors );

    PutMsg( STDOUT,
            MSG_IF_UNKNOWNPROTOS,
            pEntry->Info.if_inunknownprotos );

    if ( VerboseFlag )
    {
        // Also display configuration info

        // Traverse the list of interfaces, displaying config info

        pIfList = CONTAINING_RECORD( ListHead->ListEntry.Flink,
                                     IfEntry,
                                     ListEntry );

        while ( pIfList != ListHead )
        {
            PutMsg( STDOUT,
                    MSG_IF_INDEX,
                    pIfList->Info.if_index );

            PutMsg( STDOUT,
                    MSG_IF_DESCR,
                    pIfList->Info.if_descr );

            PutMsg( STDOUT,
                    MSG_IF_TYPE,
                    pIfList->Info.if_type );

            PutMsg( STDOUT,
                    MSG_IF_MTU,
                    pIfList->Info.if_mtu );

            PutMsg( STDOUT,
                    MSG_IF_SPEED,
                    pIfList->Info.if_speed );



            sprintf( PhysAddrStr,
                     "%02x-%02X-%02X-%02X-%02X-%02X",
                     pIfList->Info.if_physaddr[0],
                     pIfList->Info.if_physaddr[1],
                     pIfList->Info.if_physaddr[2],
                     pIfList->Info.if_physaddr[3],
                     pIfList->Info.if_physaddr[4],
                     pIfList->Info.if_physaddr[5] );

            PutMsg( STDOUT,
                    MSG_IF_PHYSADDR,
                    PhysAddrStr );

            PutMsg( STDOUT,
                    MSG_IF_ADMINSTATUS,
                    pIfList->Info.if_adminstatus );

            PutMsg( STDOUT,
                    MSG_IF_OPERSTATUS,
                    pIfList->Info.if_operstatus );

            PutMsg( STDOUT,
                    MSG_IF_LASTCHANGE,
                    pIfList->Info.if_lastchange );

            PutMsg( STDOUT,
                    MSG_IF_OUTQLEN,
                    pIfList->Info.if_outqlen );

            // Get pointer to next entry in list

            pIfList = CONTAINING_RECORD( pIfList->ListEntry.Flink,
                                         IfEntry,
                                         ListEntry );
        }
    }
}


//*****************************************************************************
//
// Name:        DisplayIP
//
// Description: Display IP statistics.
//
// Parameters:  IpEntry *pEntry: pointer to summary data entry.
//              ulong VerboseFlag: boolean indicating desire for verbosity.
//              IpEntry *ListHead: pointer to list of entries.  Used if
//                      verbosity desired.
//
// Returns:     void.
//
// History:
//  01/21/94  JayPh     Created.
//
//*****************************************************************************

void DisplayIP( DWORD Type, IpEntry *pEntry, ulong VerboseFlag, IpEntry *ListHead )
{
    char *TypeStr = LoadMsg( (Type==TYPE_IP)? MSG_IPV4 : MSG_IPV6 );

    if (TypeStr) {
        PutMsg( STDOUT, MSG_IP_HDR, TypeStr );
        LocalFree(TypeStr);
    }

    PutMsg( STDOUT,
            MSG_IP_INRECEIVES,
            pEntry->Info.ipsi_inreceives );

    PutMsg( STDOUT,
            MSG_IP_INHDRERRORS,
            pEntry->Info.ipsi_inhdrerrors );

    PutMsg( STDOUT,
            MSG_IP_INADDRERRORS,
            pEntry->Info.ipsi_inaddrerrors );

    PutMsg( STDOUT,
            MSG_IP_FORWDATAGRAMS,
            pEntry->Info.ipsi_forwdatagrams );

    PutMsg( STDOUT,
            MSG_IP_INUNKNOWNPROTOS,
            pEntry->Info.ipsi_inunknownprotos );

    PutMsg( STDOUT,
            MSG_IP_INDISCARDS,
            pEntry->Info.ipsi_indiscards );

    PutMsg( STDOUT,
            MSG_IP_INDELIVERS,
            pEntry->Info.ipsi_indelivers );

    PutMsg( STDOUT,
            MSG_IP_OUTREQUESTS,
            pEntry->Info.ipsi_outrequests );

    PutMsg( STDOUT,
            MSG_IP_ROUTINGDISCARDS,
            pEntry->Info.ipsi_routingdiscards );

    PutMsg( STDOUT,
            MSG_IP_OUTDISCARDS,
            pEntry->Info.ipsi_outdiscards );

    PutMsg( STDOUT,
            MSG_IP_OUTNOROUTES,
            pEntry->Info.ipsi_outnoroutes );

    PutMsg( STDOUT,
            MSG_IP_REASMREQDS,
            pEntry->Info.ipsi_reasmreqds );

    PutMsg( STDOUT,
            MSG_IP_REASMOKS,
            pEntry->Info.ipsi_reasmoks );

    PutMsg( STDOUT,
            MSG_IP_REASMFAILS,
            pEntry->Info.ipsi_reasmfails );

    PutMsg( STDOUT,
            MSG_IP_FRAGOKS,
            pEntry->Info.ipsi_fragoks );

    PutMsg( STDOUT,
            MSG_IP_FRAGFAILS,
            pEntry->Info.ipsi_fragfails );

    PutMsg( STDOUT,
            MSG_IP_FRAGCREATES,
            pEntry->Info.ipsi_fragcreates );

    if ( VerboseFlag )
    {
        PutMsg( STDOUT,
                MSG_IP_FORWARDING,
                pEntry->Info.ipsi_forwarding );

        PutMsg( STDOUT,
                MSG_IP_DEFAULTTTL,
                pEntry->Info.ipsi_defaultttl );

        PutMsg( STDOUT,
                MSG_IP_REASMTIMEOUT,
                pEntry->Info.ipsi_reasmtimeout );
    }
}


//*****************************************************************************
//
// Name:        DisplayTCP
//
// Description: Display TCP statistics.
//
// Parameters:  TcpEntry *pEntry: pointer to data entry.
//              ulong VerboseFlag: boolean indicating desire for verbosity.
//              TcpEntry *ListHead: pointer to list of entries.  Used if
//                      verbosity desired.
//
// Returns:     void.
//
// History:
//  01/26/94  JayPh     Created.
//
//*****************************************************************************

void DisplayTCP( DWORD Type, TcpEntry *pEntry, ulong VerboseFlag, TcpEntry *ListHead )
{
    char *TypeStr = LoadMsg( (Type==TYPE_TCP)? MSG_IPV4 : MSG_IPV6 );

    if (TypeStr) {
        PutMsg( STDOUT, MSG_TCP_HDR, TypeStr );
        LocalFree(TypeStr);
    }

    PutMsg( STDOUT,
            MSG_TCP_ACTIVEOPENS,
            pEntry->Info.ts_activeopens );

    PutMsg( STDOUT,
            MSG_TCP_PASSIVEOPENS,
            pEntry->Info.ts_passiveopens );

    PutMsg( STDOUT,
            MSG_TCP_ATTEMPTFAILS,
            pEntry->Info.ts_attemptfails );

    PutMsg( STDOUT,
            MSG_TCP_ESTABRESETS,
            pEntry->Info.ts_estabresets );

    PutMsg( STDOUT,
            MSG_TCP_CURRESTAB,
            pEntry->Info.ts_currestab );

    PutMsg( STDOUT,
            MSG_TCP_INSEGS,
            pEntry->Info.ts_insegs );

    PutMsg( STDOUT,
            MSG_TCP_OUTSEGS,
            pEntry->Info.ts_outsegs );

    PutMsg( STDOUT,
            MSG_TCP_RETRANSSEGS,
            pEntry->Info.ts_retranssegs );

    if ( VerboseFlag )
    {
        switch ( pEntry->Info.ts_rtoalgorithm )
        {
        case 1:
            PutMsg( STDOUT, MSG_TCP_RTOALGORITHM1 );
            break;

        case 2:
            PutMsg( STDOUT, MSG_TCP_RTOALGORITHM2 );
            break;

        case 3:
            PutMsg( STDOUT, MSG_TCP_RTOALGORITHM3 );
            break;

        case 4:
            PutMsg( STDOUT, MSG_TCP_RTOALGORITHM4 );
            break;

        default:
            PutMsg( STDOUT,
                    MSG_TCP_RTOALGORITHMX,
                    pEntry->Info.ts_rtoalgorithm );
            break;

        }

        PutMsg( STDOUT,
                MSG_TCP_RTOMIN,
                pEntry->Info.ts_rtomin );

        PutMsg( STDOUT,
                MSG_TCP_RTOMAX,
                pEntry->Info.ts_rtomax );

        PutMsg( STDOUT,
                MSG_TCP_MAXCONN,
                pEntry->Info.ts_maxconn );
    }
}


//*****************************************************************************
//
// Name:        DisplayUDP
//
// Description: Display UDP statistics.
//
// Parameters:  UdpEntry *pEntry: pointer to summary data entry.
//              ulong VerboseFlag: boolean indicating desire for verbosity.
//              UdpEntry *ListHead: pointer to list of entries.  Used if
//                      verbosity desired.
//
// Returns:     void.
//
// History:
//  01/21/94  JayPh     Created.
//
//*****************************************************************************

void DisplayUDP( DWORD Type, UdpEntry *pEntry, ulong VerboseFlag, UdpEntry *ListHead )
{
    char *TypeStr = LoadMsg( (Type==TYPE_UDP)? MSG_IPV4 : MSG_IPV6 );

    if (TypeStr) {
        PutMsg( STDOUT, MSG_UDP_HDR, TypeStr );
        LocalFree(TypeStr);
    }

    PutMsg( STDOUT,
            MSG_UDP_INDATAGRAMS,
            pEntry->Info.us_indatagrams );

    PutMsg( STDOUT,
            MSG_UDP_NOPORTS,
            pEntry->Info.us_noports );

    PutMsg( STDOUT,
            MSG_UDP_INERRORS,
            pEntry->Info.us_inerrors );

    PutMsg( STDOUT,
            MSG_UDP_OUTDATAGRAMS,
            pEntry->Info.us_outdatagrams );
}


//*****************************************************************************
//
// Name:        DisplayICMP
//
// Description: Display ICMP statistics.
//
// Parameters:  IcmpEntry *pEntry: pointer to summary data entry.
//              ulong VerboseFlag: boolean indicating desire for verbosity.
//              IcmpEntry *ListHead: pointer to list of entries.  Used if
//                      verbosity desired.
//
// Returns:     void.
//
// History:
//  01/21/94  JayPh     Created.
//
//*****************************************************************************

void DisplayICMP( IcmpEntry *pEntry, ulong VerboseFlag, IcmpEntry *ListHead )
{
    PutMsg( STDOUT, MSG_ICMP_HDR );

    PutMsg( STDOUT,
            MSG_ICMP_MSGS,
            pEntry->InInfo.icmps_msgs,
            pEntry->OutInfo.icmps_msgs );

    PutMsg( STDOUT,
            MSG_ICMP_ERRORS,
            pEntry->InInfo.icmps_errors,
            pEntry->OutInfo.icmps_errors );

    PutMsg( STDOUT,
            MSG_ICMP_DESTUNREACHS,
            pEntry->InInfo.icmps_destunreachs,
            pEntry->OutInfo.icmps_destunreachs );

    PutMsg( STDOUT,
            MSG_ICMP_TIMEEXCDS,
            pEntry->InInfo.icmps_timeexcds,
            pEntry->OutInfo.icmps_timeexcds );

    PutMsg( STDOUT,
            MSG_ICMP_PARMPROBS,
            pEntry->InInfo.icmps_parmprobs,
            pEntry->OutInfo.icmps_parmprobs );

    PutMsg( STDOUT,
            MSG_ICMP_SRCQUENCHS,
            pEntry->InInfo.icmps_srcquenchs,
            pEntry->OutInfo.icmps_srcquenchs );

    PutMsg( STDOUT,
            MSG_ICMP_REDIRECTS,
            pEntry->InInfo.icmps_redirects,
            pEntry->OutInfo.icmps_redirects );

    PutMsg( STDOUT,
            MSG_ICMP_ECHOS,
            pEntry->InInfo.icmps_echos,
            pEntry->OutInfo.icmps_echos );

    PutMsg( STDOUT,
            MSG_ICMP_ECHOREPS,
            pEntry->InInfo.icmps_echoreps,
            pEntry->OutInfo.icmps_echoreps );

    PutMsg( STDOUT,
            MSG_ICMP_TIMESTAMPS,
            pEntry->InInfo.icmps_timestamps,
            pEntry->OutInfo.icmps_timestamps );

    PutMsg( STDOUT,
            MSG_ICMP_TIMESTAMPREPS,
            pEntry->InInfo.icmps_timestampreps,
            pEntry->OutInfo.icmps_timestampreps );

    PutMsg( STDOUT,
            MSG_ICMP_ADDRMASKS,
            pEntry->InInfo.icmps_addrmasks,
            pEntry->OutInfo.icmps_addrmasks );

    PutMsg( STDOUT,
            MSG_ICMP_ADDRMASKREPS,
            pEntry->InInfo.icmps_addrmaskreps,
            pEntry->OutInfo.icmps_addrmaskreps );

}

typedef struct {
    uint Type;
    uint Message;
} ICMP_TYPE_MESSAGE;

//
// List of messages for known ICMPv6 types.  Entries in this list
// must be in order by Type.
//
ICMP_TYPE_MESSAGE Icmp6TypeMessage[] = {
    { ICMPv6_DESTINATION_UNREACHABLE,   MSG_ICMP_DESTUNREACHS },
    { ICMPv6_PACKET_TOO_BIG,            MSG_ICMP_PACKET_TOO_BIGS },
    { ICMPv6_TIME_EXCEEDED,             MSG_ICMP_TIMEEXCDS },
    { ICMPv6_PARAMETER_PROBLEM,         MSG_ICMP_PARMPROBS },
    { ICMPv6_ECHO_REQUEST,              MSG_ICMP_ECHOS },
    { ICMPv6_ECHO_REPLY,                MSG_ICMP_ECHOREPS },
    { ICMPv6_MULTICAST_LISTENER_QUERY,  MSG_ICMP_MLD_QUERY },
    { ICMPv6_MULTICAST_LISTENER_REPORT, MSG_ICMP_MLD_REPORT },
    { ICMPv6_MULTICAST_LISTENER_DONE,   MSG_ICMP_MLD_DONE },
    { ICMPv6_ROUTER_SOLICIT,            MSG_ICMP_ROUTER_SOLICIT },
    { ICMPv6_ROUTER_ADVERT,             MSG_ICMP_ROUTER_ADVERT },
    { ICMPv6_NEIGHBOR_SOLICIT,          MSG_ICMP_NEIGHBOR_SOLICIT },
    { ICMPv6_NEIGHBOR_ADVERT,           MSG_ICMP_NEIGHBOR_ADVERT },
    { ICMPv6_REDIRECT,                  MSG_ICMP_REDIRECTS },
    { ICMPv6_ROUTER_RENUMBERING,        MSG_ICMP_ROUTER_RENUMBERING },
    { 0, 0 }
};

void DisplayICMP6( Icmp6Entry *pEntry, ulong VerboseFlag, IcmpEntry *ListHead )
{
    uint i = 0, Type, Message;

    PutMsg( STDOUT, MSG_ICMP6_HDR );

    PutMsg( STDOUT,
            MSG_ICMP_MSGS,
            pEntry->InInfo.icmps_msgs,
            pEntry->OutInfo.icmps_msgs );

    PutMsg( STDOUT,
            MSG_ICMP_ERRORS,
            pEntry->InInfo.icmps_errors,
            pEntry->OutInfo.icmps_errors );

    for (Type=0; Type<256; Type++) {

        // Figure out message id
        Message = 0;
        if (Type == Icmp6TypeMessage[i].Type) 
        {
            Message = Icmp6TypeMessage[i++].Message;
        } 
        
        // Skip types with 0 packets in and out
        if (!pEntry->InInfo.icmps_typecount[Type] &&
            !pEntry->OutInfo.icmps_typecount[Type])
        {
            continue;
        }
        
        if (Message)
        {
            PutMsg( STDOUT,
                    Message,
                    pEntry->InInfo.icmps_typecount[Type],
                    pEntry->OutInfo.icmps_typecount[Type] );
        } 
        else
        {
            PutMsg( STDOUT,
                    MSG_ICMP6_TYPECOUNT,
                    Type,
                    pEntry->InInfo.icmps_typecount[Type],
                    pEntry->OutInfo.icmps_typecount[Type] );
        }
    }
}


static DWORD
GenerateHostNameServiceString(
   OUT char *       pszBuffer,
   IN OUT int *     lpcbBufLen,
   IN  BOOL         fNumFlag,
   IN  BOOL         fLocalHost,
   IN  BOOL         fDatagram,
   IN  LPSOCKADDR   lpSockaddr,
   IN  ulong        uSockaddrLen
)
/*++
  Description:
     Generates the <hostname>:<service-string> from the address and port
     information supplied. The result is stored in the pszBuffer passed in.
     If fLocalHost == TRUE, then the cached local host name is used to
     improve performance.

  Arguments:
    pszBuffer     Buffer to store the resulting string.
    lpcbBufLen    pointer to integer containing the count of bytes in Buffer
                   and on return contains the number of bytes written.
                   If the buffer is insufficient, then the required bytes is
                   stored here.
    fNumFlag      generates the output using numbers for host and port number.
    fLocalHost    indicates if we want the service string for local host or
                   remote host. Also for local host, this function generates
                   the local host name without FQDN.
    pszProtocol   specifies the protocol used for the service.
    uAddress      unisgned long address of the service.
    uPort         unsinged long port number.

  Returns:
    Win32 error codes. NO_ERROR on success.

  History:
    MuraliK          12/15/94
      Added this function to avoid FQDNs  for local name + abstract the common
       code used multiple times in old code.
      Also this function provides local host name caching.
--*/
{
    char            LocalBuffer[MAX_HOST_NAME_SIZE];    // to hold dummy output
    char            LocalServiceEntry[MAX_SERVICE_NAME_SIZE];
    int             BufferLen;
    char  *         pszHostName = NULL;              // init a pointer.
    char  *         pszServiceName = NULL;
    DWORD           dwError = NO_ERROR;
    struct addrinfo *ai;
    int             Result;
    int             Flags = 0;

    // for caching local host name.  getnameinfo doesn't seem to find the 
    // host name for a local address.
    static char  s_LocalHostName[MAX_HOST_NAME_SIZE];
    static  BOOL s_fLocalHostName = FALSE;


    if ( pszBuffer == NULL) {
        return ( ERROR_INSUFFICIENT_BUFFER);
    }

    *pszBuffer = '\0';         // initialize to null string

    if (fNumFlag) {
        Flags |= NI_NUMERICHOST | NI_NUMERICSERV;
    }
    if (fLocalHost) {
        Flags |= NI_NOFQDN;
    }
    if (fDatagram) {
        Flags |= NI_DGRAM;
    }

    //
    // This complexity shouldn't be required but unlike the hostname string,
    // getnameinfo doesn't automatically include the numeric form 
    // when a service name isn't found.  Instead, it fails.
    //
    if (fLocalHost && !fNumFlag) {
        if ( s_fLocalHostName) {
            pszHostName = s_LocalHostName;   // pull from the cache
        } else {
            Result = gethostname( s_LocalHostName,
                                  sizeof( s_LocalHostName));
            if ( Result == 0) {

                char * pszFirstDot;

                //
                // Cache the copy of local host name now.
                // Limit the host name to first part of host name.
                // NO FQDN
                //
                s_fLocalHostName = TRUE;

                pszFirstDot = strchr( s_LocalHostName, '.');
                if ( pszFirstDot != NULL) {

                    *pszFirstDot = '\0';  // terminate string
                }

                pszHostName = s_LocalHostName;

            }
        } // if ( s_fLocalhost)

    }
    if (!pszHostName) {
        Result = getnameinfo(lpSockaddr, uSockaddrLen,
                             LocalBuffer, sizeof(LocalBuffer),
                             NULL, 0,
                             Flags);
        if (Result != 0) {
            return Result;
        }
        pszHostName = LocalBuffer;
    }
    Result = getnameinfo(lpSockaddr, uSockaddrLen,
                         NULL, 0,
                         LocalServiceEntry, sizeof(LocalServiceEntry),
                         Flags);
    if ((Result == WSANO_DATA) && !fNumFlag) {
        Result = getnameinfo(lpSockaddr, uSockaddrLen,
                             NULL, 0,
                             LocalServiceEntry, sizeof(LocalServiceEntry),
                             Flags | NI_NUMERICSERV);
    }

    if (Result != 0) {
        return Result;
    }
    pszServiceName = LocalServiceEntry;

    // Now pszServiceName has the service name/portnumber

    BufferLen = strlen( pszHostName) + strlen( pszServiceName) + 4;
    // 4 bytes extra for "[]:" and null-character.

    if ( *lpcbBufLen < BufferLen ) {

        dwError = ERROR_INSUFFICIENT_BUFFER;
    } else if ((lpSockaddr->sa_family == AF_INET6) && strchr(pszHostName, ':')) {
        sprintf( pszBuffer, "[%s]:%s", pszHostName, pszServiceName);
    } else {
        sprintf( pszBuffer, "%s:%s", pszHostName, pszServiceName);
    }

    *lpcbBufLen = BufferLen;

    return ( dwError);

} // GenerateHostNameServiceString()

static DWORD
GenerateV4HostNameServiceString(
   OUT char *       pszBuffer,
   IN OUT int *     lpcbBufLen,
   IN  BOOL         fNumFlag,
   IN  BOOL         fLocalHost,
   IN  BOOL         fDatagram,
   IN  ulong        uAddress,
   IN  ulong        uPort
)
{
    SOCKADDR_IN sin;

    ZeroMemory(&sin, sizeof(sin));
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = uAddress;
    sin.sin_port = htons((ushort)uPort);

    return GenerateHostNameServiceString(pszBuffer,
                                         lpcbBufLen,
                                         fNumFlag,
                                         fLocalHost,
                                         fDatagram,
                                         (LPSOCKADDR)&sin,
                                         sizeof(sin));
}

static DWORD
GenerateV6HostNameServiceString(
   OUT char *           pszBuffer,
   IN OUT int *         lpcbBufLen,
   IN  BOOL             fNumFlag,
   IN  BOOL             fLocalHost,
   IN  BOOL             fDatagram,
   IN  struct in6_addr *ipAddress,
   IN  ulong            uScopeId,
   IN  ulong            uPort
)
{
    SOCKADDR_IN6 sin;

    ZeroMemory(&sin, sizeof(sin));
    sin.sin6_family = AF_INET6;
    sin.sin6_addr = *ipAddress;
    sin.sin6_scope_id = uScopeId;
    sin.sin6_port = htons((ushort)uPort);

    return GenerateHostNameServiceString(pszBuffer,
                                         lpcbBufLen,
                                         fNumFlag,
                                         fLocalHost,
                                         fDatagram,
                                         (LPSOCKADDR)&sin,
                                         sizeof(sin));
}

//*****************************************************************************
//
// Name:        DisplayTcpConnEntry
//
// Description: Display information about 1 tcp connection.
//
// Parameters:  TcpConnTableEntry *pTcp: pointer to a tcp connection structure.
//              InfoSize: indicates whether the data is a TCPConnTableEntry or
//                        TCPConnTableEntryEx.
//
// Returns:     void.
//
// History:
//  12/31/93  JayPh     Created.
//  02/01/94  JayPh     Use symbolic names for addresses and ports if available
//  12/15/94  MuraliK   Avoid printing FQDNs for local host.
//
//*****************************************************************************

void DisplayTcpConnEntry( TCPConnTableEntry *pTcp, ulong InfoSize, ulong NumFlag )
{
    char            *TypeStr;
    char            *StateStr;
    char            LocalStr[MAX_HOST_NAME_SIZE + MAX_SERVICE_NAME_SIZE];
    char            RemoteStr[MAX_HOST_NAME_SIZE + MAX_SERVICE_NAME_SIZE];
    DWORD dwErr;
    int BufLen;

    TypeStr = LoadMsg( MSG_CONN_TYPE_TCP );

    if ( TypeStr == NULL )
    {
        return;
    }

    BufLen = sizeof( LocalStr);
    dwErr = GenerateV4HostNameServiceString( LocalStr,
                                             &BufLen,
                                             NumFlag != 0, TRUE, FALSE,
                                             pTcp->tct_localaddr,
                                             pTcp->tct_localport);
    ASSERT( dwErr == NO_ERROR);

    switch ( pTcp->tct_state )
    {
    case TCP_CONN_CLOSED:
        StateStr = LoadMsg( MSG_CONN_STATE_CLOSED );
        break;

    case TCP_CONN_LISTEN:

        // Tcpip generates dummy sequential remote ports for
        // listening connections to avoid getting stuck in snmp.
        // MohsinA, 12-Feb-97.

        pTcp->tct_remoteport = 0;

        StateStr = LoadMsg( MSG_CONN_STATE_LISTENING );
        break;

    case TCP_CONN_SYN_SENT:
        StateStr = LoadMsg( MSG_CONN_STATE_SYNSENT );
        break;

    case TCP_CONN_SYN_RCVD:
        StateStr = LoadMsg( MSG_CONN_STATE_SYNRECV );
        break;

    case TCP_CONN_ESTAB:
        StateStr = LoadMsg( MSG_CONN_STATE_ESTABLISHED );
        break;

    case TCP_CONN_FIN_WAIT1:
        StateStr = LoadMsg( MSG_CONN_STATE_FIN_WAIT_1 );
        break;

    case TCP_CONN_FIN_WAIT2:
        StateStr = LoadMsg( MSG_CONN_STATE_FIN_WAIT_2 );
        break;

    case TCP_CONN_CLOSE_WAIT:
        StateStr = LoadMsg( MSG_CONN_STATE_CLOSE_WAIT );
        break;

    case TCP_CONN_CLOSING:
        StateStr = LoadMsg( MSG_CONN_STATE_CLOSING );
        break;

    case TCP_CONN_LAST_ACK:
        StateStr = LoadMsg( MSG_CONN_STATE_LAST_ACK );
        break;

    case TCP_CONN_TIME_WAIT:
        StateStr = LoadMsg( MSG_CONN_STATE_TIME_WAIT );
        break;

    default:
        StateStr = NULL;
        DEBUG_PRINT(("DisplayTcpConnEntry: State=%d?\n ",
                     pTcp->tct_state ));
    }

    BufLen = sizeof( RemoteStr);
    dwErr = GenerateV4HostNameServiceString( RemoteStr,
                                             &BufLen,
                                             NumFlag != 0, FALSE, FALSE,
                                             pTcp->tct_remoteaddr,
                                             pTcp->tct_remoteport );
    ASSERT( dwErr == NO_ERROR);


    if ( StateStr == NULL )
    {
        DEBUG_PRINT(("DisplayTcpConnEntry: Problem with the message file\n"));
        LocalFree(TypeStr);
        return;
    }

    if (sizeof(TCPConnTableEntryEx) == InfoSize) 
    {
        ulong Pid = ((TCPConnTableEntryEx*)pTcp)->tcte_owningpid;
        
        PutMsg( STDOUT, MSG_CONN_ENTRY_EX, TypeStr, LocalStr, RemoteStr, StateStr, Pid );
    }
    else
    {
        PutMsg( STDOUT, MSG_CONN_ENTRY, TypeStr, LocalStr, RemoteStr, StateStr );
    }
    LocalFree(TypeStr);
    LocalFree(StateStr);

}

//*****************************************************************************
//
// Name:        DisplayTcp6ConnEntry
//
// Description: Display information about 1 tcp connection over IPv6.
//
// Parameters:  TCP6ConnTableEntry *pTcp: pointer to a tcp connection structure.
//
// Returns:     void.
//
// History:
//  24/04/01  DThaler   Created.
//
//*****************************************************************************

void DisplayTcp6ConnEntry( TCP6ConnTableEntry *pTcp, ulong NumFlag )
{
    char            *TypeStr;
    char            *StateStr;
    char            LocalStr[MAX_HOST_NAME_SIZE + MAX_SERVICE_NAME_SIZE];
    char            RemoteStr[MAX_HOST_NAME_SIZE + MAX_SERVICE_NAME_SIZE];
    DWORD dwErr;
    int BufLen;

    TypeStr = LoadMsg( MSG_CONN_TYPE_TCP );

    if ( TypeStr == NULL )
    {
        return;
    }

    BufLen = sizeof( LocalStr);
    dwErr = GenerateV6HostNameServiceString( LocalStr,
                                             &BufLen,
                                             NumFlag != 0, TRUE, FALSE,
                                             &pTcp->tct_localaddr,
                                             pTcp->tct_localscopeid,
                                             pTcp->tct_localport);
    ASSERT( dwErr == NO_ERROR);

    switch ( pTcp->tct_state )
    {
    case TCP_CONN_CLOSED:
        StateStr = LoadMsg( MSG_CONN_STATE_CLOSED );
        break;

    case TCP_CONN_LISTEN:

        // Tcpip generates dummy sequential remote ports for
        // listening connections to avoid getting stuck in snmp.
        // MohsinA, 12-Feb-97.

        pTcp->tct_remoteport = 0;

        StateStr = LoadMsg( MSG_CONN_STATE_LISTENING );
        break;

    case TCP_CONN_SYN_SENT:
        StateStr = LoadMsg( MSG_CONN_STATE_SYNSENT );
        break;

    case TCP_CONN_SYN_RCVD:
        StateStr = LoadMsg( MSG_CONN_STATE_SYNRECV );
        break;

    case TCP_CONN_ESTAB:
        StateStr = LoadMsg( MSG_CONN_STATE_ESTABLISHED );
        break;

    case TCP_CONN_FIN_WAIT1:
        StateStr = LoadMsg( MSG_CONN_STATE_FIN_WAIT_1 );
        break;

    case TCP_CONN_FIN_WAIT2:
        StateStr = LoadMsg( MSG_CONN_STATE_FIN_WAIT_2 );
        break;

    case TCP_CONN_CLOSE_WAIT:
        StateStr = LoadMsg( MSG_CONN_STATE_CLOSE_WAIT );
        break;

    case TCP_CONN_CLOSING:
        StateStr = LoadMsg( MSG_CONN_STATE_CLOSING );
        break;

    case TCP_CONN_LAST_ACK:
        StateStr = LoadMsg( MSG_CONN_STATE_LAST_ACK );
        break;

    case TCP_CONN_TIME_WAIT:
        StateStr = LoadMsg( MSG_CONN_STATE_TIME_WAIT );
        break;

    default:
        StateStr = NULL;
        DEBUG_PRINT(("DisplayTcp6ConnEntry: State=%d?\n ",
                     pTcp->tct_state ));
    }

    BufLen = sizeof( RemoteStr);
    dwErr = GenerateV6HostNameServiceString( RemoteStr,
                                             &BufLen,
                                             NumFlag != 0, FALSE, FALSE,
                                             &pTcp->tct_remoteaddr,
                                             pTcp->tct_remotescopeid,
                                             pTcp->tct_remoteport );
    ASSERT( dwErr == NO_ERROR);


    if ( StateStr == NULL )
    {
        DEBUG_PRINT(("DisplayTcp6ConnEntry: Problem with the message file\n"));
        LocalFree(TypeStr);
        return;
    }

    PutMsg( STDOUT, MSG_CONN_ENTRY_EX, TypeStr, LocalStr, RemoteStr, StateStr, pTcp->tct_owningpid );

    LocalFree(TypeStr);
    LocalFree(StateStr);

}


//*****************************************************************************
//
// Name:        DisplayUdpConnEntry
//
// Description: Display information on 1 udp connection
//
// Parameters:  UDPEntry *pUdp: pointer to udp connection structure.
//              InfoSize: indicates whether the data is a UDPEntry or 
//                        UDPEntryEx.
//
// Returns:     void.
//
// History:
//  12/31/93  JayPh     Created.
//  02/01/94  JayPh     Use symbolic names for addresses and ports if available
//
//*****************************************************************************

void DisplayUdpConnEntry( UDPEntry *pUdp, ulong InfoSize, ulong NumFlag )
{
    char            *TypeStr;
    char            LocalStr[MAX_HOST_NAME_SIZE + MAX_SERVICE_NAME_SIZE];
    char            * RemoteStr;
    int             BufLen;
    DWORD           dwErr;

    TypeStr = LoadMsg( MSG_CONN_TYPE_UDP );

    if ( TypeStr == NULL )
    {
        return;
    }

    BufLen = sizeof( LocalStr);
    dwErr = GenerateV4HostNameServiceString( LocalStr,
                                             &BufLen,
                                             NumFlag != 0, TRUE, TRUE,
                                             pUdp->ue_localaddr,
                                             pUdp->ue_localport);
    ASSERT( dwErr == NO_ERROR);

    RemoteStr = LoadMsg( MSG_CONN_UDP_FORADDR );
    if ( RemoteStr == NULL )
    {
        DEBUG_PRINT(("DisplayUdpConnEntry: no message?\n"));
        LocalFree(TypeStr);
        return;
    }

    if (sizeof(UDPEntryEx) == InfoSize) 
    {
        ulong Pid = ((UDPEntryEx*)pUdp)->uee_owningpid;
        
        PutMsg( STDOUT, MSG_CONN_ENTRY_EX, TypeStr, LocalStr, RemoteStr, "", Pid );
    }
    else
    {
        PutMsg( STDOUT, MSG_CONN_ENTRY, TypeStr, LocalStr, RemoteStr, "" );
    }

    LocalFree(TypeStr);
    LocalFree(RemoteStr);
}

void DisplayUdp6ListenerEntry( UDP6ListenerEntry *pUdp, BOOL WithOwner, ulong NumFlag )
{
    char            *TypeStr;
    char            LocalStr[MAX_HOST_NAME_SIZE + MAX_SERVICE_NAME_SIZE];
    char            * RemoteStr;
    int             BufLen;
    DWORD           dwErr;

    TypeStr = LoadMsg( MSG_CONN_TYPE_UDP );

    if ( TypeStr == NULL )
    {
        return;
    }

    BufLen = sizeof( LocalStr);
    dwErr = GenerateV6HostNameServiceString( LocalStr,
                                             &BufLen,
                                             NumFlag != 0, TRUE, TRUE,
                                             &pUdp->ule_localaddr,
                                             pUdp->ule_localscopeid,
                                             pUdp->ule_localport);
    ASSERT( dwErr == NO_ERROR);

    RemoteStr = LoadMsg( MSG_CONN_UDP_FORADDR );
    if ( RemoteStr == NULL )
    {
        DEBUG_PRINT(("DisplayUdpConnEntry: no message?\n"));
        LocalFree(TypeStr);
        return;
    }

    if (WithOwner)
    {
        ulong Pid = pUdp->ule_owningpid;
        
        PutMsg( STDOUT, MSG_CONN_ENTRY_EX, TypeStr, LocalStr, RemoteStr, "", Pid );
    }
    else
    {
        PutMsg( STDOUT, MSG_CONN_ENTRY, TypeStr, LocalStr, RemoteStr, "" );
    }

    LocalFree(TypeStr);
    LocalFree(RemoteStr);
}


//*****************************************************************************
//
// Name:        Usage
//
// Description: Called when a command line parameter problem is detected, it
//              displays a proper command usage message and exits.
//
//              WARNING: This routine does not return.
//
// Parameters:  char *PgmName: pointer to string contain name of program.
//
// Returns:     Doesn't return.
//
// History:
//  01/04/93  JayPh     Created.
//
//*****************************************************************************

void Usage( void )
{
    PutMsg( STDERR, MSG_USAGE, PgmName );
    exit( 1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\commands\ping\makefile.inc ===
$(O)\nlstxt.mc: localmsg.mc
    copy localmsg.mc $@
    $(MC) -v -h $(O) -r $(O) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\commands\ipconfig\ipconfig.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ipconfig.c

Abstract:

    updated clean version of ipconfig.

--*/

#include <precomp.h>
#include <shellapi.h>
#include <dhcpcapi.h>
#include <locale.h>
#include <dnslib.h>

int InitLogger(const char *fname);
void DoneLogger(void);

DWORD
WriteOutput(
    IN HANDLE hOut,
    IN LPWSTR String
    )
{
    DWORD Error = NO_ERROR, Unused;
    INT   StringLen;

    StringLen = wcslen(String);
    if( GetFileType(hOut) == FILE_TYPE_CHAR )
    {
        if (StringLen < 0)
        {
            Error = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            while (StringLen > 0)
            {
                if (!WriteConsoleW(hOut, String, min(StringLen, 1024), &Unused, 0 ))
                {
                    Error = GetLastError();
                    break;
                }
                String += 1024;
                StringLen -= 1024;
            }
        }

        if( ERROR_INVALID_HANDLE != Error ) return Error;
    }

    //
    // If it is not a console, this is good enough
    //
    
    printf("%ws", String );
    return NO_ERROR;
}

BOOL
StringIsSame(
    IN LPWSTR Str1,
    IN LPWSTR Str2
    )
{
    return CSTR_EQUAL == CompareString(
        LOCALE_USER_DEFAULT, NORM_IGNORECASE |
        NORM_IGNOREKANATYPE | NORM_IGNOREWIDTH,
        Str1, -1, Str2, -2 );
}

DWORD
ParseCommandLine(
    IN OUT PCMD_ARGS Args,
    IN OUT LPWSTR *Argv,
    IN DWORD Argc,
    OUT LPWSTR *AdapterName,
    OUT LPWSTR *ClassId
    )
{
    Argc --; Argv ++;

    if( Argc == 0 ) return NO_ERROR;
        
    if( **Argv != L'/' && **Argv != L'-' ) {
        return ERROR_INVALID_DATA;
    }
        
    (*Argv)++;

    if( StringIsSame(Args->Debug, *Argv) ) {
        LocalFree( Args->Debug );
        Args->Debug = NULL;
        Argv ++;
        Argc --;

        if( **Argv != L'/' && **Argv != L'-' ) {
            return ERROR_INVALID_DATA;
        }
        (*Argv)++;
    }

    if( Argc == 0 ) return NO_ERROR;
    
    if( Argc >= 2 ) (*AdapterName) = Argv[1];
    if( Argc == 3 ) (*ClassId) = Argv[2];

    if( **Argv == L'?' ) {
        return ERROR_INVALID_COMMAND_LINE;
    }

    if( StringIsSame(Args->All, *Argv) ) {
        if( Argc != 1 ) return ERROR_INVALID_DATA;
        LocalFree( Args->All );
        Args->All = NULL;
        return NO_ERROR;
    }

    if( StringIsSame(Args->FlushDns, *Argv) ) {
        if( Argc != 1 ) return ERROR_INVALID_DATA;
        LocalFree( Args->FlushDns );
        Args->FlushDns = NULL;
        return NO_ERROR;
    }

    if( StringIsSame(Args->Register, *Argv) ) {
        if( Argc != 1 ) return ERROR_INVALID_DATA;
        LocalFree( Args->Register );
        Args->Register = NULL;
        return NO_ERROR;
    }

    if( StringIsSame(Args->DisplayDns, *Argv) ) {
        if( Argc != 1 ) return ERROR_INVALID_DATA;
        LocalFree( Args->DisplayDns );
        Args->DisplayDns = NULL;
        return NO_ERROR;
    }

    if( StringIsSame(Args->Renew, *Argv) ) {
        if( Argc > 2 ) return ERROR_INVALID_DATA;
        LocalFree( Args->Renew );
        Args->Renew = NULL;
        return NO_ERROR;
    }

    if( StringIsSame(Args->Release, *Argv) ) {
        if( Argc > 2 ) return ERROR_INVALID_DATA;
        LocalFree( Args->Release );
        Args->Release = NULL;
        return NO_ERROR;
    }

    if( StringIsSame(Args->ShowClassId, *Argv) ) {
        if( Argc != 2 ) return ERROR_INVALID_DATA;
        LocalFree( Args->ShowClassId );
        Args->ShowClassId = NULL;
        return NO_ERROR;
    }
    
    if( StringIsSame(Args->SetClassId, *Argv) ) {
        if( Argc != 3 && Argc != 2 ) return ERROR_INVALID_DATA;
        LocalFree( Args->SetClassId );
        Args->SetClassId = NULL;
        return NO_ERROR;
    }

    return ERROR_INVALID_DATA;
}

BOOL
StringMatch(
    IN LPWSTR Str1,
    IN LPWSTR Str2,
    IN BOOL   fCase
    )
{
    switch( *Str1 ){
    case L'\0' : return ! *Str2 ;
    case L'*'  : return StringMatch( Str1+1, Str2, fCase ) || *Str2 && StringMatch( Str1, Str2+1, fCase );
    case L'?'  : return *Str2 && StringMatch( Str1+1, Str2+1, fCase );
    default   : return (fCase ? *Str1 == *Str2 : toupper(*Str1) == toupper(*Str2)) && StringMatch( Str1+1, Str2+1, fCase );
    }
}

BOOL
InterfaceMatch(
    IN PINTERFACE_NETWORK_INFO IfInfo,
    IN LPWSTR AdapterName
    )
{
    if( NULL == AdapterName ) return TRUE;

    if( IfInfo->ConnectionName != NULL ) {
        return StringMatch( AdapterName, IfInfo->ConnectionName, FALSE );
    }

    return FALSE;
}

DWORD
DoRenew(
    IN LPWSTR Buffer,
    IN ULONG BufSize,
    IN PNETWORK_INFO NetInfo,
    IN LPWSTR AdapterName
    )
{
    DWORD i, FindCount, Error, LastError;
    PINTERFACE_NETWORK_INFO IfInfo;
    BOOL fSucceeded;

    fSucceeded = FALSE;
    FindCount = 0;
    LastError = ERROR_INTERNAL_ERROR;
    
    for( i = 0; i < NetInfo->nInterfaces; i ++ ) {
        IfInfo = NetInfo->IfInfo[i];

        if( !InterfaceMatch(IfInfo, AdapterName) ) continue;

        FindCount ++;

        if( !IfInfo->EnableDhcp || 0 == IfInfo->nIpAddresses ) {
            if( NULL != AdapterName ) {
                DumpMessage(
                    Buffer, BufSize, MSG_OPERATION_ON_NONDHCP,
                    IfInfo->ConnectionName );
            } else FindCount --;
        } else if( IfInfo->MediaDisconnected ) {
            DumpMessage(
                Buffer, BufSize, MSG_MEDIA_SENSE,
                IfInfo->ConnectionName );
        } else {
            Error = DhcpAcquireParameters(IfInfo->DeviceGuidName);
            
            if( NO_ERROR == Error ) {
                fSucceeded = TRUE;
            } else if (ERROR_SEM_TIMEOUT == Error) {
                LastError = Error;
                DumpMessage(
                    Buffer, BufSize, MSG_RENEW_FAILED_UNREACHABLE_DHCP,
                    IfInfo->ConnectionName );
            } else {
                LastError = Error;
                DumpMessageError(
                    Buffer, BufSize, MSG_RENEW_FAILED, Error,
                    IfInfo->ConnectionName );
            }
        }
    }

    if( fSucceeded ) return NO_ERROR;
    if( FindCount == 0 ) {
        DumpMessage( Buffer, BufSize, MSG_NO_MATCH );
    }

    return LastError;
}

DWORD
DoRelease(
    IN LPWSTR Buffer,
    IN ULONG BufSize,
    IN PNETWORK_INFO NetInfo,
    IN LPWSTR AdapterName
    )
{
    DWORD i, FindCount, Error, LastError;
    PINTERFACE_NETWORK_INFO IfInfo;
    BOOL fSucceeded;

    fSucceeded = FALSE;
    FindCount = 0;
    LastError = ERROR_INTERNAL_ERROR;
    
    for( i = 0; i < NetInfo->nInterfaces; i ++ ) {
        IfInfo = NetInfo->IfInfo[i];

        if( !InterfaceMatch(IfInfo, AdapterName) ) continue;

        FindCount ++;

        if( !IfInfo->EnableDhcp || 0 == IfInfo->nIpAddresses ) {
            if( NULL != AdapterName ) {
                DumpMessage(
                    Buffer, BufSize, MSG_OPERATION_ON_NONDHCP,
                    IfInfo->ConnectionName );
            } else FindCount --;
        } else if( IfInfo->MediaDisconnected ) {
            DumpMessage(
                Buffer, BufSize, MSG_MEDIA_SENSE,
                IfInfo->ConnectionName );
        } else if( IfInfo->IpAddress[0] == INADDR_ANY ) {
            DumpMessage(
                Buffer, BufSize, MSG_ZERO_ADDRESS,
                IfInfo->ConnectionName );
        } else {
            Error = DhcpReleaseParameters(IfInfo->DeviceGuidName);
            
            if( NO_ERROR == Error ) {
                fSucceeded = TRUE;
            } else {
                LastError = Error;
                DumpMessageError(
                    Buffer, BufSize, MSG_RELEASE_FAILED, Error,
                    IfInfo->ConnectionName );
            }
        }
    }

    if( fSucceeded ) return NO_ERROR;
    if( FindCount == 0 ) {
        DumpMessage( Buffer, BufSize, MSG_NO_MATCH );
    }

    return LastError;
}

DWORD
DoFlushDns(
    IN LPWSTR Buffer,
    IN ULONG BufSize,
    IN PNETWORK_INFO NetInfo
    )
{
    DWORD Error;
    
    UNREFERENCED_PARAMETER( NetInfo);

    Error = DnsFlushResolverCache();
    if( FALSE == Error ) {
        Error = ERROR_FUNCTION_FAILED;
        DumpMessageError(
            Buffer, BufSize, MSG_FLUSHDNS_FAILED, Error, NULL );
    } else {
        DumpMessage(
            Buffer, BufSize, MSG_FLUSHDNS_SUCCEEDED );
    }
        
    return Error;
}

extern DWORD DhcpStaticRefreshParams(IN LPWSTR Adapter);

DWORD
DoRegisterDns(
    IN LPWSTR Buffer,
    IN ULONG BufSize,
    IN PNETWORK_INFO NetInfo
    )
{
    DWORD Error;
    extern DWORD RegisterIPv6Dns(VOID);
  
    //
    // Since IPv6 call is asynchronous, no error doesn't necessarily
    // mean the success of DNS registration. So ignore it.
    //
    Error = RegisterIPv6Dns();

    Error = DhcpStaticRefreshParams(NULL);
    if( NO_ERROR != Error ) {
        DumpMessageError(
            Buffer, BufSize, MSG_REGISTERDNS_FAILED, Error, NULL );
    } else {
        DumpMessage(
            Buffer, BufSize, MSG_REGISTERDNS_SUCCEEDED );
    }

    UNREFERENCED_PARAMETER( NetInfo );
    return Error;
}


VOID
PrintARecord (
    IN OUT  LPWSTR          Buffer,
    IN      ULONG           BufSize,
    IN      PDNS_RECORD     DnsRecord
    )
{
    WCHAR IpAddr[20];
    
    swprintf(
        IpAddr,
        L"%d.%d.%d.%d",
        ((BYTE *) &DnsRecord->Data.A.IpAddress)[0],
        ((BYTE *) &DnsRecord->Data.A.IpAddress)[1],
        ((BYTE *) &DnsRecord->Data.A.IpAddress)[2],
        ((BYTE *) &DnsRecord->Data.A.IpAddress)[3] );

    DumpMessage( Buffer, BufSize, MSG_DNS_A_RECORD, IpAddr );
}


VOID
PrintSOARecord (
    IN OUT  LPWSTR          Buffer,
    IN      ULONG           BufSize,
    IN      PDNS_RECORD     DnsRecord
    )
{
    WCHAR SerialNo[20], Refresh[20], Retry[20];
    WCHAR Expire[20], Ttl[20];

    swprintf( SerialNo, L"%d", DnsRecord->Data.SOA.dwSerialNo );
    swprintf( Refresh,  L"%d", DnsRecord->Data.SOA.dwRefresh );
    swprintf( Retry,    L"%d", DnsRecord->Data.SOA.dwRetry );
    swprintf( Expire,   L"%d", DnsRecord->Data.SOA.dwExpire );
    swprintf( Ttl,      L"%d", DnsRecord->Data.SOA.dwDefaultTtl );

    DumpMessage(
        Buffer, BufSize, MSG_DNS_SOA_RECORD,
        DnsRecord->Data.SOA.pNamePrimaryServer,
        DnsRecord->Data.SOA.pNameAdministrator,
        SerialNo,
        Refresh,
        Retry,
        Expire,
        Ttl );
}


VOID
PrintPTRRecord (
    IN      ULONG           MsgId,
    IN OUT  LPWSTR          Buffer,
    IN      ULONG           BufSize,
    IN      PDNS_RECORD     DnsRecord
    )
{
    DumpMessage(
        Buffer,
        BufSize,
        MsgId,
        DnsRecord->Data.PTR.pNameHost );
}


VOID
PrintMXRecord (
    IN OUT  LPWSTR          Buffer,
    IN      ULONG           BufSize,
    IN      PDNS_RECORD     DnsRecord
    )
{
    WCHAR Pref[20], Pad[20];

    swprintf( Pref, L"%d", DnsRecord->Data.MX.wPreference );
    swprintf( Pad,  L"%d", DnsRecord->Data.MX.Pad );

    DumpMessage(
        Buffer,
        BufSize,
        MSG_DNS_MX_RECORD,
        DnsRecord->Data.MX.pNameExchange,
        Pref,
        Pad );
}


VOID
PrintAAAARecord(
    IN OUT  PWSTR           Buffer,
    IN      ULONG           BufSize,
    IN      PDNS_RECORD     DnsRecord
    )
{
    WCHAR stringIp6[IP6_ADDRESS_STRING_BUFFER_LENGTH];
    
    Dns_Ip6AddressToString_W(
        stringIp6,
        & DnsRecord->Data.AAAA.Ip6Address );

    DumpMessage(
        Buffer,
        BufSize,
        MSG_DNS_AAAA_RECORD,
        stringIp6 );
}


VOID
PrintSRVRecord (
    IN OUT  LPWSTR      Buffer,
    IN      ULONG       BufSize,
    IN      PDNS_RECORD DnsRecord
    )
{
    WCHAR Priority[20], Weight[20], Port[20];

    swprintf( Priority, L"%d", DnsRecord->Data.SRV.wPriority );
    swprintf( Weight,   L"%d", DnsRecord->Data.SRV.wWeight );
    swprintf( Port,     L"%d", DnsRecord->Data.SRV.wPort );

    DumpMessage(
        Buffer,
        BufSize,
        MSG_DNS_SRV_RECORD,
        DnsRecord->Data.SRV.pNameTarget,
        Priority,
        Weight,
        Port );
}


VOID
PrintATMARecord (
    IN OUT  LPWSTR      Buffer,
    IN      ULONG       BufSize,
    IN      PDNS_RECORD DnsRecord
    )
{
    WCHAR Type[20], Address[300];

    swprintf( Type, L"%d", DnsRecord->Data.ATMA.AddressType );

    if ( DnsRecord->Data.ATMA.Address &&
         DnsRecord->Data.ATMA.AddressType == DNS_ATMA_FORMAT_E164 ) {

        swprintf(
            Address,
            L"%S",
            DnsRecord->Data.ATMA.Address );

    } else {
        DWORD iter;

        for ( iter = 0; iter < DnsRecord->wDataLength; iter++ ) {

            swprintf(
                &Address[iter*2],
                L"%02x",
                DnsRecord->Data.ATMA.Address[iter]
                );
        }
    }

    DumpMessage(
        Buffer, BufSize, MSG_DNS_ATMA_RECORD, Type, Address );
            
}

VOID
PrintDnsRecord(
    IN OUT  LPWSTR      Buffer,
    IN      ULONG       BufSize,
    IN      PDNS_RECORD DnsRecord
    )
{
    WCHAR Type[20], Ttl[20], DataLen[20];
    DWORD MsgId;
    
    if ( ! DnsRecord ) return;

    swprintf( Type,     L"%d",  DnsRecord->wType );
    swprintf( Ttl,      L"%d",  DnsRecord->dwTtl );
    swprintf( DataLen,  L"%d",  DnsRecord->wDataLength );
    
    DumpMessage(
        Buffer, BufSize, MSG_DNS_RECORD_HEADER,
        DnsRecord->pName, (LPWSTR)Type, (LPWSTR)Ttl,
        (LPWSTR)DataLen ); 

    if ( DnsRecord->Flags.S.Section == DNSREC_QUESTION ) {
        MsgId = MSG_DNS_QUESTION_SECTION;
    } else if ( DnsRecord->Flags.S.Section == DNSREC_ANSWER ) {
        MsgId = MSG_DNS_ANSWER_SECTION;
    } else if ( DnsRecord->Flags.S.Section == DNSREC_AUTHORITY ) {
        MsgId = MSG_DNS_AUTHORITY_SECTION;
    } else {
        MsgId = MSG_DNS_ADDITIONAL_SECTION;
    }

    DumpMessage( Buffer, BufSize, MsgId );
    
    switch( DnsRecord->wType )
    {
        case DNS_TYPE_A :
            PrintARecord( Buffer, BufSize, DnsRecord );
            break;

        case DNS_TYPE_SOA :
            PrintSOARecord( Buffer, BufSize, DnsRecord );
            break;

        case DNS_TYPE_PTR :
            PrintPTRRecord(
                MSG_DNS_PTR_RECORD, Buffer, BufSize, DnsRecord );
            break;

        case DNS_TYPE_NS :
            PrintPTRRecord(
                MSG_DNS_NS_RECORD, Buffer, BufSize, DnsRecord );
            break;

        case DNS_TYPE_CNAME :
            PrintPTRRecord(
                MSG_DNS_CNAME_RECORD, Buffer, BufSize, DnsRecord );
            break;

        case DNS_TYPE_MX :
            PrintMXRecord( Buffer, BufSize, DnsRecord );
            break;

        case DNS_TYPE_AAAA :
            PrintAAAARecord( Buffer, BufSize, DnsRecord );
            break;

        case DNS_TYPE_SRV :
            PrintSRVRecord( Buffer, BufSize, DnsRecord );
            break;

        case DNS_TYPE_ATMA :
            PrintATMARecord( Buffer, BufSize, DnsRecord );
            break;

        default :
            break;
    }
}
    
VOID
PrintDnsRecords(
    IN OUT  LPWSTR      Buffer,
    IN      ULONG       BufSize,
    IN      PDNS_RECORD DnsRecord
    )
{
    PDNS_RECORD Tmp = DnsRecord;

    while( Tmp ) {
        PrintDnsRecord( Buffer, BufSize, Tmp );
        Tmp = Tmp->pNext;
    }
}


BOOL
GetDnsCachedData(
    IN OUT  LPWSTR      Buffer,
    IN      ULONG       BufSize,
    IN      LPWSTR      Name,
    IN      WORD        Type
    )
{
    PDNS_RECORD DnsRecord = NULL;
    DNS_STATUS  DnsStatus;

    DnsStatus = DnsQuery_W(
                    Name,
                    Type,
                    DNS_QUERY_CACHE_ONLY,
                    NULL,
                    & DnsRecord,
                    NULL );

    if ( DnsStatus != NO_ERROR ) {

        if ( DnsStatus == DNS_INFO_NO_RECORDS ) {

            WCHAR   wsTypeName[ 20 ];

            Dns_WriteStringForType_W(
                wsTypeName,
                Type );
    
            DumpMessage(
                Buffer,
                BufSize,
                MSG_DNS_ERR_NO_RECORDS,
                Name,
                wsTypeName );

        } else if ( DnsStatus == DNS_ERROR_RCODE_NAME_ERROR ) {
            DumpMessage(
                Buffer, BufSize, MSG_DNS_ERR_NAME_ERROR, Name );

        } else if ( DnsStatus == DNS_ERROR_RECORD_DOES_NOT_EXIST ) {
            //
            // Don't print?
            //
        } else {
            DumpMessage(
                Buffer, BufSize, MSG_DNS_ERR_UNABLE_TO_DISPLAY,
                Name );
        }

        return FALSE;
    }

    if ( DnsRecord ) {
        DumpMessage(
            Buffer, BufSize, MSG_DNS_RECORD_PREAMBLE, Name );
        
        PrintDnsRecords( Buffer, BufSize, DnsRecord );
        DnsRecordListFree( DnsRecord, TRUE );
    }

    return TRUE;
}


VOID
DisplayDnsCacheData(
    IN OUT LPWSTR Buffer,
    IN ULONG BufSize
    )
{
    PDNS_CACHE_TABLE pDNSCacheTable = NULL;
    PDNS_CACHE_TABLE pTempDNSCacheTable = NULL;

    if( !DnsGetCacheDataTable( &pDNSCacheTable ) ) {
        DumpMessage(
            Buffer, BufSize, MSG_DISPLAYDNS_FAILED );
        return;
    }

    pTempDNSCacheTable = pDNSCacheTable;

    while( pTempDNSCacheTable ) {
        PDNS_CACHE_TABLE pNext = pTempDNSCacheTable->pNext;

        if( pTempDNSCacheTable->Type1 != DNS_TYPE_ZERO ) {
            GetDnsCachedData(
                Buffer, BufSize, pTempDNSCacheTable->Name,
                pTempDNSCacheTable->Type1 );
        }

        if( pTempDNSCacheTable->Type2 != DNS_TYPE_ZERO ) {
            GetDnsCachedData(
                Buffer, BufSize, pTempDNSCacheTable->Name,
                pTempDNSCacheTable->Type2 );
        }

        if( pTempDNSCacheTable->Type3 != DNS_TYPE_ZERO ) {
            GetDnsCachedData(
                Buffer, BufSize, pTempDNSCacheTable->Name,
                pTempDNSCacheTable->Type3 );
        }

        if( pTempDNSCacheTable->Name ) {
            LocalFree( pTempDNSCacheTable->Name );
        }
        
        LocalFree( pTempDNSCacheTable );

        pTempDNSCacheTable = pNext;
    }
}


DWORD
DoDisplayDns(
    IN LPWSTR Buffer,
    IN ULONG BufSize,
    IN PNETWORK_INFO NetInfo
    )
{
    UNREFERENCED_PARAMETER( NetInfo);

    DisplayDnsCacheData( Buffer, BufSize );
    return NO_ERROR;
}

DWORD
DoShowClassId(
    IN LPWSTR Buffer,
    IN ULONG BufSize,
    IN PNETWORK_INFO NetInfo,
    IN LPWSTR AdapterName
    )
{
    DWORD i, Error, Size, nClassesPrinted;
    PINTERFACE_NETWORK_INFO IfInfo;
    DHCP_CLASS_INFO *pClasses;
    
    IfInfo = NULL;
    for( i = 0; i < NetInfo->nInterfaces; i ++ ) {
        IfInfo = NetInfo->IfInfo[i];

        if( !InterfaceMatch(IfInfo, AdapterName) ) continue;

        if( !IfInfo->DeviceGuidName ) continue;

        break;
    }

    if( i == NetInfo->nInterfaces ) {
        DumpMessage(
            Buffer, BufSize, MSG_NO_MATCH );
        return ERROR_NOT_FOUND;
    }

    do {
        Size = 0; pClasses = NULL;
        Error = DhcpEnumClasses(
            0, IfInfo->DeviceGuidName, &Size, pClasses
        );

        if( ERROR_MORE_DATA != Error ) {
            if( NO_ERROR == Error ) {
                DumpMessage(
                    Buffer, BufSize, MSG_NO_CLASSES,
                    IfInfo->ConnectionName  );
            }

            break;
        }

        pClasses = LocalAlloc(LMEM_FIXED, Size);
        if( NULL == pClasses ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        Error = DhcpEnumClasses(
            0, IfInfo->DeviceGuidName, &Size, pClasses
        );

        if( NO_ERROR != Error ) {
            LocalFree(pClasses);
            break;
        }

        nClassesPrinted = Size;

        if( nClassesPrinted ) {
            DumpMessage(
                Buffer, BufSize, MSG_CLASSES_LIST_HEADER,
                IfInfo->ConnectionName );

            for( i = 0; i < nClassesPrinted ; i ++ ) {
                DumpMessage(
                    Buffer, BufSize, MSG_CLASSID,
                    pClasses[i].ClassName, pClasses[i].ClassDescr );
            }
        } else {
            DumpMessage(
                Buffer, BufSize, MSG_NO_CLASSES,
                IfInfo->ConnectionName );
        }

        LocalFree(pClasses);
    } while ( 0 );

    if( NO_ERROR != Error ) {
        DumpMessage(
            Buffer, BufSize, MSG_CLASSID_FAILED, Error,
            IfInfo->ConnectionName );
    }            

    return Error;
}

DWORD
DoSetClassId(
    IN LPWSTR Buffer,
    IN ULONG BufSize,
    IN PNETWORK_INFO NetInfo,
    IN LPWSTR AdapterName,
    IN LPWSTR ClassId
    )
{
    DWORD i, Error;
    PINTERFACE_NETWORK_INFO IfInfo;
    HKEY hKey;
    DHCP_PNP_CHANGE Changes;

    IfInfo = NULL;
    for( i = 0; i < NetInfo->nInterfaces; i ++ ) {
        IfInfo = NetInfo->IfInfo[i];

        if( !InterfaceMatch(IfInfo, AdapterName) ) continue;

        if( !IfInfo->DeviceGuidName ) continue;

        break;
    }

    if( i == NetInfo->nInterfaces ) {
        DumpMessage(
            Buffer, BufSize, MSG_NO_MATCH );
        return ERROR_NOT_FOUND;
    }

    Error = OpenRegKey(
        IfInfo->DeviceGuidName, OpenTcpipKey, OpenKeyForWrite,
        &hKey );
    if( NO_ERROR != Error ) {
        DumpErrorMessage(
            Buffer, BufSize, InterfaceOpenTcpipKeyReadFailure,
            Error );
        return Error;
    }


    if( NULL == ClassId ) ClassId = (LPWSTR)L"";
    
    RegSetValueExW(
        hKey, (LPWSTR) L"DhcpClassId", 0, REG_SZ,
        (LPBYTE)ClassId, sizeof(WCHAR)*(1+wcslen(ClassId)) );

    RegCloseKey( hKey );
    
    ZeroMemory(&Changes, sizeof(Changes));
    Changes.ClassIdChanged = TRUE;

    Error = DhcpHandlePnPEvent(
        0, DHCP_CALLER_TCPUI, IfInfo->DeviceGuidName, &Changes,
        NULL );

    if( NO_ERROR != Error ) {
        DumpMessageError(
            Buffer, BufSize, MSG_SETCLASSID_FAILED, Error,
            IfInfo->ConnectionName );
    } else {
        DumpMessage(
            Buffer, BufSize, MSG_SETCLASSID_SUCCEEDED,
            IfInfo->ConnectionName );
    }

    return Error;
}
    
void _cdecl main(void)
{
    WCHAR TmpBuffer[8000];
    WCHAR *Buffer;
    DWORD LocalError, Error, InternalError, BufSize = 512;
    PNETWORK_INFO NetInfo;
    LPWSTR *Argv, CommandLine, AdapterName, ClassId;
    int Argc;
    CMD_ARGS Args;
    BOOL fVerbose;
    BOOL fDebug;
    BOOL fDisplay;
    
    UNREFERENCED_PARAMETER(InternalError);
    UNREFERENCED_PARAMETER(NetInfo);

    //
    // bug 211927: set the locale to the system default
    //
    setlocale ( LC_ALL, "" );

    InitLogger("ipconfig.log");
    
    CommandLine = GetCommandLineW();
    if( NULL == CommandLine ) {
        DbgPrint("GetCommandLineW: 0x%x\n", GetLastError());
        DoneLogger();
        exit(1);
    }

    Argv = CommandLineToArgvW(CommandLine, &Argc );
    if( NULL == Argv ) {
        DbgPrint("CommandLineToArgvW: 0x%x\n", GetLastError());
        DoneLogger();
        exit(1);
    }

    Error = GetCommandArgConstants( &Args );
    if( NO_ERROR != Error ) {
        DbgPrint("GetCommandArgConstants: 0x%lx\n", Error );
        DoneLogger();
        exit(1);
    }

    AdapterName = NULL; ClassId = NULL;

    //
    // The ParseCommandLine routine NULLs out the field in Args
    // that was supplied by teh user... i.e ipconfig /renew would
    // cause Args.Renew to be NULL on return
    //
    
    Error = ParseCommandLine(
        &Args, Argv, Argc, &AdapterName, &ClassId );
    if( ERROR_INVALID_COMMAND_LINE == Error ) {
        WriteOutput( GetStdHandle( STD_OUTPUT_HANDLE), Args.Usage );
        DoneLogger();
        exit(1);
    }
    
    if( NO_ERROR != Error ) {
        WriteOutput( GetStdHandle( STD_OUTPUT_HANDLE), Args.UsageErr );
        WriteOutput( GetStdHandle( STD_OUTPUT_HANDLE), Args.Usage );
        DoneLogger();
        exit(1);
    }

    fVerbose = (Args.All == NULL);
    fDebug = (Args.Debug == NULL);
    fDisplay = FALSE;
    
    NetInfo = NULL;
    
    Error = GetNetworkInformation(
        &NetInfo, &InternalError );

    //
    // Calculate how much space it would take to display a full display..
    //

    do {
        Buffer = LocalAlloc( LPTR, sizeof(WCHAR)*BufSize );
        if( Buffer == NULL ) break;

        LocalError = FormatNetworkInfo(
            Buffer, BufSize, NetInfo,
            Error,InternalError,TRUE,fDebug);

        LocalFree(Buffer);
        BufSize *= 2;
    } while( NO_ERROR != LocalError );

    if( NULL != Buffer ) {
        Buffer = LocalAlloc( LPTR, sizeof(WCHAR)*BufSize );
    }
    
    if( NULL == Buffer ) {
        Buffer = (LPWSTR)TmpBuffer;
        BufSize = sizeof(TmpBuffer)/sizeof(WCHAR);
        Error = ERROR_NOT_ENOUGH_MEMORY;
    } 

    DumpMessage(
        Buffer, BufSize, MSG_TITLE );
        
    if( NO_ERROR != Error || Args.All == NULL ) {
        fDisplay = TRUE;
    } else if( Args.Renew == NULL ) {
        //
        // Attempt to renew
        //

        Error = DoRenew( Buffer, BufSize, NetInfo, AdapterName);
        fDisplay = (NO_ERROR == Error);

        if( fDisplay ) {
            FreeNetworkInfo( NetInfo );
            Error = GetNetworkInformation(
                &NetInfo, &InternalError );
        }
        
    } else if( Args.Release == NULL ) {
        //
        // Attempt to renew
        //

        Error = DoRelease( Buffer, BufSize, NetInfo, AdapterName);
        fDisplay = (NO_ERROR == Error);

        if( fDisplay ) {
            FreeNetworkInfo( NetInfo );
            Error = GetNetworkInformation(
                &NetInfo, &InternalError );
        }
    } else if( Args.FlushDns == NULL ) {

        DoFlushDns( Buffer, BufSize, NetInfo );
    } else if( Args.Register == NULL ) {

        DoRegisterDns( Buffer, BufSize, NetInfo );
    } else if( Args.DisplayDns == NULL ) {

        DoDisplayDns( Buffer, BufSize, NetInfo );
    } else if( Args.ShowClassId == NULL ) {

        DoShowClassId( Buffer, BufSize, NetInfo, AdapterName );
    } else if( Args.SetClassId == NULL ) {

        DoSetClassId( Buffer, BufSize, NetInfo, AdapterName, ClassId );
    } else {
        fDisplay = TRUE;
    }
    
    if( fDisplay ) {
        FormatNetworkInfo(
            Buffer, BufSize, NetInfo,
            Error, InternalError, fVerbose, fDebug );
    }

    Error = WriteOutput( GetStdHandle( STD_OUTPUT_HANDLE), Buffer );
    if (Error != NO_ERROR)
    {
        Buffer[0] = L'\0';
        DumpMessage(Buffer, BufSize, MSG_TITLE );
        DumpErrorMessage(Buffer, BufSize, NoSpecificError, Error);
        WriteOutput( GetStdHandle( STD_OUTPUT_HANDLE ), Buffer );
    }
    
    FreeNetworkInfo(NetInfo);
    GlobalFree( Argv );
    LocalFree( Args.All );
    LocalFree( Args.Renew );
    LocalFree( Args.Release );
    LocalFree( Args.FlushDns );
    LocalFree( Args.Register );
    LocalFree( Args.DisplayDns );
    LocalFree( Args.ShowClassId );
    LocalFree( Args.SetClassId );
    LocalFree( Args.Debug );
    LocalFree( Args.Usage );

    DoneLogger();
    exit(0);
}


DWORD
RegisterIPv6Dns(VOID)
{
    DWORD dwErr = NO_ERROR;
    SC_HANDLE hcm = NULL;
    SC_HANDLE hSvc = NULL;
    SERVICE_STATUS status = {0};
#define SERVICE_CONTROL_6TO4_REGISER_DNS    128
      
    do
    {
        hcm = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
        if (NULL == hcm)
        {
            dwErr = GetLastError();
            IPCFG_TRACE(IPCFG_TRACE_TCPIP, ("OpenSCManager returns 0x%lx (%d)\n", dwErr, dwErr));
            break;
        }

        hSvc = OpenService(hcm, L"6to4", SERVICE_USER_DEFINED_CONTROL);
        if (NULL == hSvc)
        {
            dwErr = GetLastError();
            IPCFG_TRACE(IPCFG_TRACE_TCPIP, ("OpenService returns 0x%lx (%d)\n", dwErr, dwErr));
            break;
        }

        
        if (!ControlService(hSvc, SERVICE_CONTROL_6TO4_REGISER_DNS, &status))
        {
            dwErr = GetLastError();
            IPCFG_TRACE(IPCFG_TRACE_TCPIP, ("ControlService returns 0x%lx (%d)\n", dwErr, dwErr));
            break;
        }
    } while (FALSE);

    if (hSvc)
    {
        CloseServiceHandle(hSvc);
    }

    if (hcm)
    {
        CloseServiceHandle(hcm);
    }

    IPCFG_TRACE(IPCFG_TRACE_TCPIP, ("RegisterIPv6Dns returns 0x%lx (%d)\n", dwErr, dwErr));
    
    return dwErr;
}


#ifdef __IPCFG_ENABLE_LOG__
DWORD    dwTraceFlag = 0xffffffffU;
static FILE *hLogger = NULL;
int
InitLogger(const char *fname)
{
    if (hLogger) {
        fclose(hLogger);
    }
    hLogger = fopen(fname, "w+");
    return (hLogger == NULL)? (-1): 0;
}

void
DoneLogger(void)
{
    if (hLogger) {
        fclose(hLogger);
        hLogger = NULL;
    }
}

int
TraceFunc(const char* fmt, ...)
{
    va_list ap;

    if (hLogger != NULL) {
        va_start(ap, fmt);
        vfprintf(hLogger, fmt, ap);
        va_end(ap);
    }
    return 0;
}
#else
int InitLogger(const char *fname)
{
    UNREFERENCED_PARAMETER(fname);
    return 0;
}

void DoneLogger(void) {}

int TraceFunc(const char* fmt, ...)
{
    UNREFERENCED_PARAMETER(fmt);
    return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\commands\pathping\pathping.c ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    pathping.c

Abstract:

    PathPing utility

Author:

    Dave Thaler

Revision History:

    Who         When          What
    --------    --------      ----------------------------------------------
    rajeshsu    Aug 10, 1999  Added QoS support (802.1p and RSVP)
    dthaler     Mar 31, 2001  Added IPv6 support

Notes:

--*/

#include    <nt.h>
#include    <ntrtl.h>
#include    <nturtl.h>
#define NOGDI
#define NOMINMAX
#include    <windows.h>
#include    <stdio.h>
#include    <stdlib.h>
#include    <ctype.h>
#include    <io.h>
#include    <nls.h>
#include    <winsock2.h>
#include    <ws2tcpip.h>
#include    <ntddip6.h>
#include    "pathqos.h"
#include    "ipexport.h"
#include    "icmpapi.h"
#include    "nlstxt.h"
#include    "pathping.h"

ULONG        g_ulTimeout        = DEFAULT_TIMEOUT;
ULONG        g_ulInterval       = MIN_INTERVAL;
ULONG        g_ulNumQueries     = DEFAULT_NUM_QUERIES;
HANDLE       g_hIcmp            = NULL;
ULONG        g_ulRcvBufSize     = 0x2000;
BOOLEAN      g_bDoReverseLookup = TRUE;
BOOLEAN      g_bDo8021P         = FALSE;
BOOLEAN      g_bDoRSVP          = FALSE;
BOOLEAN      g_bDoRSVPDiag      = FALSE;
SOCKADDR_STORAGE g_ssMyAddr     = {0};
socklen_t        g_slMyAddrLen  = 0;
BOOLEAN          g_bSetAddr     = FALSE;

HOP hop[MAX_HOPS];

#ifdef VXD
# define FAR _far
#endif // VXD

char     SendBuffer[DEFAULT_SEND_SIZE];
char     RcvBuffer[DEFAULT_RECEIVE_SIZE];
WSADATA  WsaData;

struct IPErrorTable {
    IP_STATUS   Error;                      // The IP Error
    DWORD       ErrorNlsID;                 // The corresponding NLS string ID.
} ErrorTable[] =
{
    { IP_BUF_TOO_SMALL,           PATHPING_BUF_TOO_SMALL            },
    { IP_DEST_NET_UNREACHABLE,    PATHPING_DEST_NET_UNREACHABLE     },
    { IP_DEST_HOST_UNREACHABLE,   PATHPING_DEST_HOST_UNREACHABLE    },
    { IP_DEST_PROT_UNREACHABLE,   PATHPING_DEST_PROT_UNREACHABLE    },
    { IP_DEST_PORT_UNREACHABLE,   PATHPING_DEST_PORT_UNREACHABLE    },
    { IP_NO_RESOURCES,            PATHPING_NO_RESOURCES             },
    { IP_BAD_OPTION,              PATHPING_BAD_OPTION               },
    { IP_HW_ERROR,                PATHPING_HW_ERROR                 },
    { IP_PACKET_TOO_BIG,          PATHPING_PACKET_TOO_BIG           },
    { IP_REQ_TIMED_OUT,           PATHPING_REQ_TIMED_OUT            },
    { IP_BAD_REQ,                 PATHPING_BAD_REQ                  },
    { IP_BAD_ROUTE,               PATHPING_BAD_ROUTE                },
    { IP_TTL_EXPIRED_TRANSIT,     PATHPING_TTL_EXPIRED_TRANSIT      },
    { IP_TTL_EXPIRED_REASSEM,     PATHPING_TTL_EXPIRED_REASSEM      },
    { IP_PARAM_PROBLEM,           PATHPING_PARAM_PROBLEM            },
    { IP_SOURCE_QUENCH,           PATHPING_SOURCE_QUENCH            },
    { IP_OPTION_TOO_BIG,          PATHPING_OPTION_TOO_BIG           },
    { IP_BAD_DESTINATION,         PATHPING_BAD_DESTINATION          },
    { IP_NEGOTIATING_IPSEC,       PATHPING_NEGOTIATING_IPSEC        },
    { IP_GENERAL_FAILURE,         PATHPING_GENERAL_FAILURE          }
};

void
print_addr(SOCKADDR *sa, socklen_t salen, BOOLEAN DoReverseLookup)
{
    unsigned char    hostname[NI_MAXHOST];
    int              i;
    BOOLEAN          didReverse = FALSE;

    if (DoReverseLookup) {
        i = getnameinfo(sa, salen, hostname, sizeof(hostname),
                        NULL, 0, NI_NAMEREQD);

        if (i == NO_ERROR) {
            didReverse = TRUE;
            NlsPutMsg(STDOUT, PATHPING_TARGET_NAME, hostname);
        }
    }

    i = getnameinfo(sa, salen, hostname, sizeof(hostname),
                    NULL, 0, NI_NUMERICHOST);

    if (i != NO_ERROR) {
       // This should never happen unless there is a memory problem,
       // in which case the message associated with PATHPING_NO_RESOURCES
       // is reasonable.
       NlsPutMsg(STDOUT, PATHPING_NO_RESOURCES);
       exit (1);
    }

    if (didReverse) {
        NlsPutMsg( STDOUT, PATHPING_BRKT_IP_ADDRESS, hostname );
    } else {
        NlsPutMsg( STDOUT, PATHPING_IP_ADDRESS, hostname );
    }
}

void
print_ip_addr(IPAddr ipv4Addr, BOOLEAN DoReverseLookup)
{
    SOCKADDR_IN sin;

    memset(&sin, 0, sizeof(sin));
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = ipv4Addr;

    print_addr((LPSOCKADDR)&sin, sizeof(sin), DoReverseLookup);
}

void
print_ipv6_addr(USHORT ipv6Addr[8], BOOLEAN DoReverseLookup)
{
    SOCKADDR_IN6 sin;

    memset(&sin, 0, sizeof(sin));
    sin.sin6_family = AF_INET6;
    memcpy(&sin.sin6_addr, ipv6Addr, sizeof(sin.sin6_addr));

    print_addr((LPSOCKADDR)&sin, sizeof(sin), DoReverseLookup);
}

void
print_time(ULONG Time)
{
    if (Time) {
        NlsPutMsg( STDOUT, PATHPING_TIME, Time );
        // printf(" %3lu ms\n", Time);
    }
    else {
        NlsPutMsg( STDOUT, PATHPING_TIME_10MS );
        // printf(" <10 ms\n");
    }
}


BOOLEAN
param(
    ULONG *parameter,
    char **argv,
    int argc,
    int current,
    ULONG min,
    ULONG max
    )
{
    ULONG   temp;
    char    *dummy;

    if (current == (argc - 1) ) {
        NlsPutMsg( STDOUT, PATHPING_NO_OPTION_VALUE, argv[current] );
        // printf( "Value must be supplied for option %s.\n", argv[current]);
        return(FALSE);
    }

    temp = strtoul(argv[current+1], &dummy, 0);
    if (temp < min || temp > max) {
        NlsPutMsg( STDOUT, PATHPING_BAD_OPTION_VALUE, argv[current] );
        // printf( "Bad value for option %s.\n", argv[current]);
        return(FALSE);
    }

    *parameter = temp;

    return(TRUE);
}


BOOLEAN
ResolveTarget(
    IN  DWORD             Family,
    IN  char             *TargetString,
    OUT SOCKADDR_STORAGE *TargetAddress,
    OUT socklen_t        *TargetAddressLen, 
    OUT char             *TargetName,
    IN  DWORD             TargetNameLen,
    IN  BOOLEAN           DoReverseLookup
    )
{
    int              i;
    struct addrinfo  hints, *ai;

    TargetName[0] = '\0';

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = Family;
    hints.ai_flags = AI_NUMERICHOST;
    i = getaddrinfo(TargetString, NULL, &hints, &ai);
    if (i == NO_ERROR) {
        *TargetAddressLen = ai->ai_addrlen;
        memcpy(TargetAddress, ai->ai_addr, ai->ai_addrlen);

        if (DoReverseLookup) {
            getnameinfo(ai->ai_addr, ai->ai_addrlen,
                        TargetName, TargetNameLen,
                        NULL, 0, NI_NAMEREQD);
        }

        freeaddrinfo(ai);
        return(TRUE);
    } else {
        hints.ai_flags = AI_CANONNAME;
        if (getaddrinfo(TargetString, NULL, &hints, &ai) == 0) {
            *TargetAddressLen = ai->ai_addrlen;
            memcpy(TargetAddress, ai->ai_addr, ai->ai_addrlen);
            strcpy(TargetName, 
                   (ai->ai_canonname)? ai->ai_canonname : TargetString);
            freeaddrinfo(ai);
            return(TRUE);
        }
    }
    
    return(FALSE);

}  // ResolveTarget

ULONG g_ulSendsDone = 0;

void
SleepForTotal(
    DWORD dwTotal
    )
{
    DWORD dwStopAt = GetTickCount() + dwTotal;
    int   iLeft    = (int)dwTotal;

    while (iLeft > 0) {
        SleepEx(iLeft, TRUE);
        iLeft = dwStopAt - GetTickCount();
    }
}

VOID
EchoDone(
    IN PVOID            pContext,
    IN PIO_STATUS_BLOCK Ignored1,
    IN ULONG            Ignored2
    )
{
    PAPC_CONTEXT pApc = (PAPC_CONTEXT)pContext;
    ULONG ulNumReplies;
    ULONG i;

    g_ulSendsDone++;
    if (g_ssMyAddr.ss_family == AF_INET) {
        ulNumReplies = IcmpParseReplies(pApc->pReply4, g_ulRcvBufSize);

        for (i=0; i<ulNumReplies; i++) {
            if (pApc->sinAddr.sin_addr.s_addr is pApc->pReply4[i].Address) {
                pApc->ulNumRcvd++;
                pApc->ulRTTtotal += pApc->pReply4[i].RoundTripTime;
                return;
            }
        }
    } else {
        ulNumReplies = Icmp6ParseReplies(pApc->pReply6, g_ulRcvBufSize);

        for (i=0; i<ulNumReplies; i++) {
            if (!memcmp(&pApc->sin6Addr.sin6_addr, 
                        &pApc->pReply6[i].Address.sin6_addr,
                        sizeof(struct in6_addr))) {
                pApc->ulNumRcvd++;
                pApc->ulRTTtotal += pApc->pReply6[i].RoundTripTime;
                return;
            }
        }
    }

}

// now that the hop[] array is filled in, ping each one every g_ulInterval
// seconds
void
ComputeStatistics(
    PIP_OPTION_INFORMATION pOptions
    )
{
    ULONG h, q;
    int lost, rcvd, linklost, nodelost, sent, len;
    ULONG ulHopCount = (ULONG)pOptions->Ttl;

    // Allocate memory for replies
    for (h=1; h<=ulHopCount; h++)
        hop[h].pReply = LocalAlloc(LMEM_FIXED, g_ulRcvBufSize);

    for (q=0; q<g_ulNumQueries; q++) {
       for (h=1; h<=ulHopCount; h++) {
          if (hop[h].saAddr.sa_family == AF_INET) {
             // Send ping to h
             IcmpSendEcho2(g_hIcmp,         // handle to icmp
                           NULL,            // no event
                           EchoDone,        // callback function
                           (LPVOID)&hop[h], // parameter to pass to callback fcn
                           hop[h].sinAddr.sin_addr.s_addr, // destination
                           SendBuffer,
                           DEFAULT_SEND_SIZE,
                           pOptions,
                           hop[h].pReply,
                           g_ulRcvBufSize,
                           g_ulTimeout );
          } else {
             Icmp6SendEcho2(g_hIcmp,        // handle to icmp
                           NULL,            // no event
                           EchoDone,        // callback function
                           (LPVOID)&hop[h], // parameter to pass to callback fcn
                           (LPSOCKADDR_IN6)&g_ssMyAddr,
                           &hop[h].sin6Addr,// destination
                           SendBuffer,
                           DEFAULT_SEND_SIZE,
                           pOptions,
                           hop[h].pReply,
                           g_ulRcvBufSize,
                           g_ulTimeout );
          }
 
          // Wait alertably for 'delay' ms
          SleepForTotal(g_ulInterval);
       }
    }
 
    // Wait alertably until Done count hits max
    while (g_ulSendsDone < ulHopCount * g_ulNumQueries)
        SleepEx(INFINITE, TRUE);

    // Compute per-hop info
    //     hoprcvd is max rcvd of all hops >= h
    hop[ulHopCount].ulHopRcvd = hop[ulHopCount].ulNumRcvd;
    for (h=ulHopCount-1; h>0; h--)
       hop[h].ulHopRcvd = MAX(hop[h].ulNumRcvd, hop[h+1].ulHopRcvd);
    hop[0].ulHopRcvd = g_ulNumQueries;
}


VOID
PrintResults(
    ULONG ulHopCount
    )
{
    ULONG h;
    int sent, rcvd, lost, linklost, nodelost;

    // Now output results                            
    NlsPutMsg(STDOUT, PATHPING_STAT_HEADER, GetLastError());
    // printf("            Source to Here   This Node/Link\n");
    // printf("Hop  RTT    Lost/Sent = Pct  Lost/Sent = Pct  Address\n");
    // printf("  0                                           ");
    print_addr((LPSOCKADDR)&g_ssMyAddr, g_slMyAddrLen, g_bDoReverseLookup);
    NlsPutMsg(STDOUT, PATHPING_CR);
    // printf("\n");

    for (h=1; h<=ulHopCount; h++) {
        sent = g_ulNumQueries;
        rcvd = hop[h].ulNumRcvd;
        lost = sent - rcvd;
   
        linklost = hop[h-1].ulHopRcvd - hop[h].ulHopRcvd;
        nodelost = hop[h].ulHopRcvd - hop[h].ulNumRcvd;

        // Display previous link stats
        // printf( "                             %4d/%4d =%3.0f%%   |\n", 
        //        linklost, sent, 100.0*linklost/sent);
        NlsPutMsg(STDOUT, PATHPING_STAT_LINK, 
         linklost, sent, 100*linklost/sent);

        if (rcvd) 
            NlsPutMsg(STDOUT, PATHPING_HOP_RTT, h, hop[h].ulRTTtotal/rcvd);
        else
            NlsPutMsg(STDOUT, PATHPING_HOP_NO_RTT, h);
 
        // printf("%3d ", h);
        // if (!rcvd)
        //   printf(" ---    ");
#if 0
        // else if (hop[h].ulRTTtotal/rcvd == 0)
        //   printf(" <10ms  ");
#endif
        // else
        //   printf("%4dms  ", hop[h].ulRTTtotal/rcvd);

        // printf("%4d/%4d =%3.0f%%  ", lost,     sent, 100.0*lost/sent);
        // printf("%4d/%4d =%3.0f%%  ", nodelost, sent, 100.0*nodelost/sent);
        NlsPutMsg(STDOUT, PATHPING_STAT_LOSS,
                lost,     sent, 100*lost/sent);
        NlsPutMsg(STDOUT, PATHPING_STAT_LOSS,
                nodelost, sent, 100*nodelost/sent);

        if (!hop[h].saAddr.sa_family) {
            hop[h].saAddr.sa_family = g_ssMyAddr.ss_family;
        }
        print_addr(&hop[h].saAddr, g_slMyAddrLen, g_bDoReverseLookup);
        NlsPutMsg(STDOUT, PATHPING_CR);
        // printf("\n");
    }
}

BOOLEAN
SetFamily(DWORD *Family, DWORD Value, char *arg)
{
    if ((*Family != AF_UNSPEC) && (*Family != Value)) {
        NlsPutMsg(STDOUT, PATHPING_FAMILY, arg, 
            (Value==AF_INET)? "IPv4" : "IPv6");
        return FALSE;
    }

    *Family = Value;
    return TRUE;
}

int __cdecl
main(int argc, char **argv)
{
    SOCKADDR_STORAGE      address, replyAddress;
    socklen_t             addressLen, replyAddressLen;
    USHORT                RcvSize;
    BOOL                  result;
    DWORD                 numberOfReplies;
    DWORD                 status;
    PICMP_ECHO_REPLY      reply4;
    PICMPV6_ECHO_REPLY    reply6;
    char                  hostname[NI_MAXHOST], literal[INET6_ADDRSTRLEN];
    char                 *arg;
    int                   i;
    ULONG                 maximumHops = DEFAULT_MAXIMUM_HOPS;
    BOOLEAN               computeStats = FALSE;
    IP_OPTION_INFORMATION options;
    char                  optionsData[MAX_OPT_SIZE];
    char                 *optionPtr;
    BYTE                  currentIndex;
    IPAddr                tempAddr;
    BYTE                  j;
    BYTE                  SRIndex = 0;
    BOOLEAN               foundAddress = FALSE;
    BOOLEAN               haveReply;
    int                   numRetries = DEFAULT_MAX_RETRIES;
    ULONG                 intvl = MIN_INTERVAL;
    DWORD                 Family = AF_UNSPEC;

    if (WSAStartup( 0x0101, &WsaData)) {
        NlsPutMsg(STDOUT, PATHPING_WSASTARTUP_FAILED, GetLastError());
        return(1);
    }

    options.Ttl = 1;
    options.Tos = DEFAULT_TOS;
    options.Flags = DEFAULT_FLAGS;
    options.OptionsSize = 0;
    options.OptionsData = optionsData;

    if (argc < 2) {
        NlsPutMsg( STDOUT, PATHPING_USAGE, argv[0] );
        goto error_exit;
    }

    //
    // process command line
    //
    for (i=1; i < argc; i++) {
        arg = argv[i];

        if ((arg[0] == '-') || (arg[0] == '/')) {
            switch(arg[1]) {
            case '?':
                NlsPutMsg(STDOUT, PATHPING_USAGE, argv[0]);
                goto error_exit;

            case '4':
                if (!SetFamily(&Family, AF_INET, arg)) {
                    goto error_exit;
                }
                break;

            case '6':
                if (!SetFamily(&Family, AF_INET6, arg)) {
                    goto error_exit;
                }
                break;

            case 'g':   // Loose source routing

                // Only implemented for IPv4 so far
                if (!SetFamily(&Family, AF_INET, arg)) {
                    goto error_exit;
                }

                currentIndex = options.OptionsSize;

                if ((currentIndex + 7) > MAX_OPT_SIZE) {
                    NlsPutMsg(STDOUT, PATHPING_TOO_MANY_OPTIONS);
                    goto error_exit;
                }

                optionPtr = options.OptionsData;
                optionPtr[currentIndex] = (char) IP_OPT_LSRR;
                optionPtr[currentIndex+1] = 3;
                optionPtr[currentIndex + 2] = 4;  // Set initial pointer value
                options.OptionsSize += 3;

                while ( (i < (argc - 2)) && (*argv[i+1] != '-')) {
                    if ((currentIndex + 7) > MAX_OPT_SIZE) {
                        NlsPutMsg(STDOUT, PATHPING_TOO_MANY_OPTIONS);
                        goto error_exit;
                    }

                    arg = argv[++i];
                    tempAddr = inet_addr(arg);

                    if (tempAddr == INADDR_NONE) {
                        NlsPutMsg(
                            STDOUT,
                            PATHPING_BAD_ROUTE_ADDRESS,
                            arg
                            );
                        // printf("Bad route specified for loose source route");
                        goto error_exit;
                    }

                    j = optionPtr[currentIndex+1];
                    *(ULONG UNALIGNED *)&optionPtr[j+currentIndex] = tempAddr;
                    optionPtr[currentIndex+1] += 4;
                    options.OptionsSize += 4;
                }

                SRIndex = optionPtr[currentIndex+1] + currentIndex;
                optionPtr[currentIndex+1] += 4;   // Save space for dest. addr
                options.OptionsSize += 4;
                break;

            case 'h':
                if (!param(&maximumHops, argv, argc, i, 1, 255)) {
                    goto error_exit;
                }
                i++;
                break;

                

            case 'i':
                {
                    unsigned char tmphostname[NI_MAXHOST];

                    arg = argv[++i];
                    if (ResolveTarget(Family,
                                      arg,
                                      &g_ssMyAddr,
                                      &g_slMyAddrLen,
                                      tmphostname,
                                      sizeof(tmphostname),
                                      FALSE)) {
                        g_bSetAddr = TRUE;
                    }
                }
                break;

            case 'n':
                g_bDoReverseLookup = FALSE;
                break;

            case 'p':
                if (!param(&g_ulInterval, argv, argc, i, 1, 0xffffffff)) {
                    goto error_exit;
                }
                i++;
                break;


            case 'q':
                if (!param(&g_ulNumQueries, argv, argc, i, 1, 255)) {
                    goto error_exit;
                }
                i++;
                break;

            case 'R':
                // Only implemented for IPv4 so far
                if (!SetFamily(&Family, AF_INET, arg)) {
                    goto error_exit;
                }

                g_bDoRSVP = TRUE;
                break;

            case 'P':
                // Only implemented for IPv4 so far
                if (!SetFamily(&Family, AF_INET, arg)) {
                    goto error_exit;
                }

                g_bDoRSVPDiag = TRUE;
                break;

            case 'T':
                // Only implemented for IPv4 so far
                if (!SetFamily(&Family, AF_INET, arg)) {
                    goto error_exit;
                }

                g_bDo8021P = TRUE;
                break;

            case 'w':
                if (!param(&g_ulTimeout, argv, argc, i, 1, 0xffffffff)) {
                    goto error_exit;
                }
                i++;
                break;

            default:
                NlsPutMsg(STDOUT, PATHPING_INVALID_SWITCH, argv[i]);
                NlsPutMsg(STDOUT, PATHPING_USAGE);
                goto error_exit;
                break;

            }
        } else {
            foundAddress = TRUE;
            if ( !ResolveTarget(Family,
                                argv[i], 
                                &address, 
                                &addressLen,
                                hostname, 
                                sizeof(hostname),
                                g_bDoReverseLookup) ) 
            {
                NlsPutMsg( STDOUT, PATHPING_MESSAGE_1, argv[i] );
                // printf( "Unable to resolve target name %s.\n", argv[i]);
                goto error_exit;
            }
        }
    }

    if (!foundAddress) {
        NlsPutMsg(STDOUT, PATHPING_NO_ADDRESS);
        NlsPutMsg(STDOUT, PATHPING_USAGE);
        goto error_exit;
    }

    if (SRIndex != 0) {
        *(ULONG UNALIGNED *)&options.OptionsData[SRIndex] = ((LPSOCKADDR_IN)&address)->sin_addr.s_addr;
    }

    Family = address.ss_family;
    if (Family == AF_INET) {
        g_hIcmp = IcmpCreateFile();
    } else {
        g_hIcmp = Icmp6CreateFile();
    }

    if (g_hIcmp == INVALID_HANDLE_VALUE) {
        status = GetLastError();
        NlsPutMsg( STDOUT, PATHPING_MESSAGE_2, status );
        // printf( "Unable to contact IP driver. Error code %d.\n", status);
        goto error_exit;
    }

    getnameinfo((LPSOCKADDR)&address, addressLen, literal, sizeof(literal),
                NULL, 0, NI_NUMERICHOST);

    if (hostname[0]) {
        NlsPutMsg(
            STDOUT,
            PATHPING_HEADER1,
            hostname,
            literal,
            maximumHops
            );
    }
    else {
        NlsPutMsg(
            STDOUT,
            PATHPING_HEADER2,
            literal,
            maximumHops
            );
    }

    // Get local IP address
    if (!g_bSetAddr) 
    {
        SOCKET           s = socket(address.ss_family, SOCK_RAW, 0);
        DWORD BytesReturned;

        WSAIoctl(s, SIO_ROUTING_INTERFACE_QUERY,
                 &address, sizeof address,
                 &g_ssMyAddr, sizeof g_ssMyAddr,
                 &BytesReturned, NULL, NULL);
        g_slMyAddrLen = BytesReturned;

        closesocket(s);

        NlsPutMsg( STDOUT, PATHPING_MESSAGE_4, 0);
        print_addr((LPSOCKADDR)&g_ssMyAddr, g_slMyAddrLen, 
                   g_bDoReverseLookup);
        NlsPutMsg(STDOUT, PATHPING_CR);
    }

    // First we need to find out the path, so we 
    // 
    while((options.Ttl <= maximumHops) && (options.Ttl != 0)) {

        NlsPutMsg( STDOUT, PATHPING_MESSAGE_4, (UINT)options.Ttl );
        // printf("[%3lu]  ", (UINT)SendOpts.Ttl);

        haveReply = FALSE;

        for (i=0; i<numRetries; i++) {

            if (Family == AF_INET) {
                numberOfReplies = IcmpSendEcho2( g_hIcmp,
                                                 0,
                                                 NULL,
                                                 NULL,
                                                 ((LPSOCKADDR_IN)&address)->sin_addr.s_addr,
                                                 SendBuffer,
                                                 DEFAULT_SEND_SIZE,
                                                 &options,
                                                 RcvBuffer,
                                                 DEFAULT_RECEIVE_SIZE,
                                                 g_ulTimeout );

                if (numberOfReplies == 0) {
                    status = GetLastError();
                    reply4 = NULL;
                } else {
                    reply4 = (PICMP_ECHO_REPLY) RcvBuffer;
                    status = reply4->Status;
                }

                if (status == IP_SUCCESS) {
                    print_ip_addr(
                        reply4->Address,
                        g_bDoReverseLookup
                        );
                    NlsPutMsg(STDOUT, PATHPING_CR);
    
                    ZeroMemory(&hop[options.Ttl], sizeof(HOP));
                    hop[options.Ttl].sinAddr.sin_family = AF_INET;
                    hop[options.Ttl].sinAddr.sin_addr.s_addr = reply4->Address;
                    goto loop_end;
                } 

                if (status == IP_TTL_EXPIRED_TRANSIT) {
                    ZeroMemory(&hop[options.Ttl], sizeof(HOP));
                    hop[options.Ttl].sinAddr.sin_family = AF_INET;
                    hop[options.Ttl].sinAddr.sin_addr.s_addr = reply4->Address;
                    break;
                }

                if (status == IP_REQ_TIMED_OUT) {
                    NlsPutMsg(STDOUT, PATHPING_NO_REPLY_TIME);
                    // printf(".");
                    continue;
                }

                if (status < IP_STATUS_BASE) {
                    NlsPutMsg( STDOUT, PATHPING_MESSAGE_7, status );
                    // printf("Transmit error: code %lu\n", status);
                    continue;
                }

                //
                // Fatal error.
                //
                if (reply4 != NULL) {
                    print_ip_addr(
                        reply4->Address,
                        g_bDoReverseLookup
                        );

                    NlsPutMsg( STDOUT, PATHPING_MESSAGE_6 );
                    // printf(" reports: ");
                }
            } else {
                numberOfReplies = Icmp6SendEcho2(g_hIcmp,
                                                 0,
                                                 NULL,
                                                 NULL,
                                                 (LPSOCKADDR_IN6)&g_ssMyAddr,
                                                 (LPSOCKADDR_IN6)&address,
                                                 SendBuffer,
                                                 DEFAULT_SEND_SIZE,
                                                 &options,
                                                 RcvBuffer,
                                                 DEFAULT_RECEIVE_SIZE,
                                                 g_ulTimeout );

                if (numberOfReplies == 0) {
                    status = GetLastError();
                    reply6 = NULL;
                } else {
                    reply6 = (PICMPV6_ECHO_REPLY) RcvBuffer;
                    status = reply6->Status;
                }

                if (status == IP_SUCCESS) {
                    print_ipv6_addr(
                        reply6->Address.sin6_addr,
                        g_bDoReverseLookup
                        );
                    NlsPutMsg(STDOUT, PATHPING_CR);
    
                    ZeroMemory(&hop[options.Ttl], sizeof(HOP));
                    
                    hop[options.Ttl].sin6Addr.sin6_family = AF_INET6;
                    memcpy(&hop[options.Ttl].sin6Addr.sin6_addr.s6_words,
                           reply6->Address.sin6_addr,
                           sizeof(reply6->Address.sin6_addr));
                    hop[options.Ttl].sin6Addr.sin6_scope_id = reply6->Address.sin6_scope_id;
                    goto loop_end;
                } 

                if (status == IP_TTL_EXPIRED_TRANSIT) {
                    ZeroMemory(&hop[options.Ttl], sizeof(HOP));
                    hop[options.Ttl].sin6Addr.sin6_family = AF_INET6;
                    memcpy(&hop[options.Ttl].sin6Addr.sin6_addr.s6_words,
                           reply6->Address.sin6_addr,
                           sizeof(reply6->Address.sin6_addr));
                    hop[options.Ttl].sin6Addr.sin6_scope_id = reply6->Address.sin6_scope_id;
                    break;
                }

                if (status == IP_REQ_TIMED_OUT) {
                    NlsPutMsg(STDOUT, PATHPING_NO_REPLY_TIME);
                    // printf(".");
                    continue;
                }

                if (status < IP_STATUS_BASE) {
                    NlsPutMsg( STDOUT, PATHPING_MESSAGE_7, status );
                    // printf("Transmit error: code %lu\n", status);
                    continue;
                }

                //
                // Fatal error.
                //
                if (reply6 != NULL) {
                    print_ipv6_addr(
                        reply6->Address.sin6_addr,
                        g_bDoReverseLookup
                        );

                    NlsPutMsg( STDOUT, PATHPING_MESSAGE_6 );
                    // printf(" reports: ");
                }
            }

            for (i = 0;
                 ( ErrorTable[i].Error != status &&
                   ErrorTable[i].Error != IP_GENERAL_FAILURE
                 );
                 i++
                );

            NlsPutMsg( STDOUT, ErrorTable[i].ErrorNlsID );
            // printf("%s.\n", ErrorTable[i].ErrorString);

            goto loop_end;
        }
        if (i==numRetries)
            break;

        print_addr(&hop[options.Ttl].saAddr, 
                   g_slMyAddrLen,
                   g_bDoReverseLookup );
        NlsPutMsg(STDOUT, PATHPING_CR);

        options.Ttl++;
    }

loop_end:

    if(g_bDo8021P)
    {
        QoSCheck8021P(((LPSOCKADDR_IN)&address)->sin_addr.s_addr, (ULONG)options.Ttl);
    }

    if(g_bDoRSVP)
    {
        QoSCheckRSVP(1, (ULONG)options.Ttl);
    }

    if(g_bDoRSVPDiag)
    {
        QoSDiagRSVP(1, (ULONG)options.Ttl, TRUE);
    }


    NlsPutMsg(STDOUT, PATHPING_COMPUTING, options.Ttl * g_ulInterval * g_ulNumQueries / 1000);

    // Okay, now that we have the path, we want to go back and
    // compute statistics over numQueries queries sent every intvl
    // seconds.

    ComputeStatistics(&options);

    PrintResults((ULONG)options.Ttl);

    NlsPutMsg( STDOUT, PATHPING_MESSAGE_8 );
    // printf("\nTrace complete.\n");

    IcmpCloseHandle(g_hIcmp);

    WSACleanup();
    return(0);

error_exit:

    WSACleanup();
    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\commands\pathping\pathping.h ===
typedef struct in_addr IPV4_ADDRESS;
typedef struct in6_addr IPV6_ADDRESS;

typedef struct {
   union {
       PVOID              pReply;
       PICMP_ECHO_REPLY   pReply4;       // ICMP reply packet
       PICMPV6_ECHO_REPLY pReply6;
   };
   union {
       SOCKADDR_STORAGE   ssAddr;    // Address of this hop
       SOCKADDR           saAddr;
       SOCKADDR_IN        sinAddr;
       SOCKADDR_IN6       sin6Addr;
   };
   ULONG                  ulNumRcvd;     // number of packets received
   ULONG                  ulHopRcvd;
   ULONG                  ulRTTtotal;    // cumulative RTT 
} HOP;

typedef HOP APC_CONTEXT, *PAPC_CONTEXT;

#define MAX_HOPS 255
#define DEFAULT_NUM_QUERIES         100
#define DEFAULT_MAX_RETRIES         3
#define DEFAULT_MAXIMUM_HOPS        30
#define DEFAULT_TOS                 0
#define DEFAULT_FLAGS               0
#define DEFAULT_SEND_SIZE 64
#define DEFAULT_RECEIVE_SIZE        ( (sizeof(ICMPV6_ECHO_REPLY) + \
                                    DEFAULT_SEND_SIZE) +           \
                                    sizeof(DWORD) +                \
                                    sizeof(IO_STATUS_BLOCK))

#define DEFAULT_TOS          0
#define DEFAULT_TIMEOUT      4000L
#define MIN_INTERVAL         250L
#define MAX_PENDING_REQUESTS 100

#define TRUE            1
#define FALSE           0
#define STDOUT          1
#define is              ==
#define isnot           !=
#define MAX(x,y)  ((x)>(y))? (x) : (y)

extern HOP    hop[MAX_HOPS];
extern ULONG  g_ulTimeout;
extern HANDLE g_hIcmp;
extern ULONG g_ulRcvBufSize;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\commands\tracert\makefile.inc ===
$(O)\nlstxt.mc: localmsg.mc
    copy localmsg.mc $@
    $(MC) -v -h $(O) -r $(O) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\commands\pathping\pathqos.h ===
typedef unsigned char uchar;
typedef unsigned short ushort;
typedef unsigned short  u_int16_t;
typedef unsigned long  u_int32_t;
typedef short    int16_t;

/* RSVP message types */

#define RSVP_PATH   1
#define RSVP_RESV   2
#define RSVP_PATH_ERR   3
#define RSVP_RESV_ERR   4
#define RSVP_PATH_TEAR  5
#define RSVP_RESV_TEAR  6
#define RSVP_CONFIRM    7
#define RSVP_REPORT 8
#define RSVP_MAX_MSGTYPE 8

/*
 *  Define object classes: Class-Num values
 */
#define class_NULL              0
#define class_SESSION           1
#define class_SESSION_GROUP     2
#define class_RSVP_HOP          3
#define class_INTEGRITY         4
#define class_TIME_VALUES       5
#define class_ERROR_SPEC        6
#define class_SCOPE             7
#define class_STYLE             8
#define class_FLOWSPEC          9   // these two are the same
#define class_IS_FLOWSPEC       9  // since we added IS in front of the name
#define class_FILTER_SPEC       10
#define class_SENDER_TEMPLATE   11
#define class_SENDER_TSPEC      12
#define class_ADSPEC            13
#define class_POLICY_DATA       14
#define class_CONFIRM           15
#define class_MAX               15


#define ICMP_ECHO 8
#define ICMP_ECHOREPLY 0

#define ICMP_MIN 8 // minimum 8 byte icmp packet (just header)

/* The IP header */
typedef struct iphdr {
    unsigned char h_len:4;          // length of the header
    unsigned char version:4;        // Version of IP
    unsigned char tos;             // Type of service
    unsigned short total_len;      // total length of the packet
    unsigned short ident;          // unique identifier
    unsigned short frag_and_flags; // flags
    unsigned char  ttl; 
    unsigned char proto;           // protocol (TCP, UDP etc)
    unsigned short checksum;       // IP checksum

    unsigned int sourceIP;
    unsigned int destIP;

}IpHeader;

//
// ICMP header
//
typedef struct _ihdr {
  BYTE i_type;
  BYTE i_code; /* type sub code */
  USHORT i_cksum;
  ULONG Unused;
}IcmpHeader;

#define STATUS_FAILED 0xFFFF
#define DEF_PACKET_SIZE 32
#define MAX_PACKET 1024

typedef struct {
    u_char      rsvp_verflags;  /* version and common flags     */
    u_char      rsvp_type;      /* message type (defined above) */
    u_int16_t   rsvp_cksum;     /* checksum                     */
    u_char      rsvp_snd_TTL;   /* Send TTL                     */
    u_char      rsvp_unused;    /* Reserved octet               */
    int16_t     rsvp_length;    /* Message length in bytes      */
}   common_header;

/*
 *  Standard format of an object header
 */
typedef struct {
    u_int16_t   obj_length; /* Length in bytes */
    u_char      obj_class;  /* Class (values defined below) */
    u_char      obj_ctype;  /* C-Type (values defined below) */
}    Object_header;

void WINAPI QoSCheckRSVP(ULONG begin, ULONG end);
void WINAPI QoSDiagRSVP(ULONG begin, ULONG end, BOOLEAN RouterAlert);
void WINAPI QoSCheck8021P(ULONG DstAddr, ULONG ulhopCount);

/*
 *  ERROR_SPEC object class
 */
#define ctype_ERROR_SPEC_ipv4   1
#define ctype_ERROR_SPEC_ipv6   2

typedef struct {
    struct in_addr  errs_errnode;   /* Error Node Address       */
    u_char      errs_flags; /* Flags:           */
#define ERROR_SPECF_InPlace 0x01    /*   Left resv in place     */
#define ERROR_SPECF_NotGuilty   0x02    /*   This rcvr not guilty   */

    u_char      errs_code;  /* Error Code (def'd below) */
    u_int16_t   errs_value; /* Error Value      */
#define ERR_FORWARD_OK  0x8000      /* Flag: OK to forward state */
#define Error_Usage(x)  (((x)>>12)&3)
#define ERR_Usage_globl 0x00        /* Globally-defined sub-code */
#define ERR_Usage_local 0x10        /* Locally-defined sub-code */
#define ERR_Usage_serv  0x11        /* Service-defined sub-code */
#define ERR_global_mask 0x0fff      /* Sub-code bits in Error Val */

}    Error_Spec_IPv4;


typedef struct {
    Object_header   errs_header;
    union {
        Error_Spec_IPv4 errs_ipv4;
/*      Error_Spec_IPv6 errs_ipv6;   */
    }       errs_u;
}    ERROR_SPEC;

#define errspec4_enode  errs_u.errs_ipv4.errs_errnode
#define errspec4_code   errs_u.errs_ipv4.errs_code
#define errspec4_value  errs_u.errs_ipv4.errs_value
#define errspec4_flags  errs_u.errs_ipv4.errs_flags

typedef struct {
    struct in_addr  sess_destaddr;  /* DestAddress          */

    u_char      sess_protid;    /* Protocol Id          */
    u_char      sess_flags;
#define SESSFLG_E_Police    0x01    /* E_Police: Entry policing flag*/

    u_int16_t   sess_destport;  /* DestPort         */
} Session_IPv4;

typedef struct {
    Object_header   sess_header;
    union {
        Session_IPv4    sess_ipv4;
/*      Session_IPv6    sess_ipv6; */
    }       sess_u;
}    SESSION;

#define sess4_addr  sess_u.sess_ipv4.sess_destaddr
#define sess4_port  sess_u.sess_ipv4.sess_destport
#define sess4_prot  sess_u.sess_ipv4.sess_protid
#define sess4_flgs  sess_u.sess_ipv4.sess_flags
#define sess4_orig_port  sess_u.sess_ipv4.orig_destport
#define sess4_orig_prot  sess_u.sess_ipv4.orig_protid

typedef struct {
    struct in_addr  hop_ipaddr; /* Next/Previous Hop Address */
    u_int32_t   hop_LIH;    /* Logical Interface Handle */
}    Rsvp_Hop_IPv4;

typedef struct {
    Object_header   hop_header;
    union {
        Rsvp_Hop_IPv4   hop_ipv4;
/*      Rsvp_hop_IPv6   hop_ipv6; */
    }       hop_u;
}    RSVP_HOP;

#define hop4_LIH    hop_u.hop_ipv4.hop_LIH
#define hop4_addr   hop_u.hop_ipv4.hop_ipaddr

typedef struct {
    struct in_addr  filt_ipaddr;    /* IPv4 SrcAddress  */
    u_int16_t   filt_unused;
    u_int16_t   filt_port;  /* SrcPort      */
}    Filter_Spec_IPv4;

typedef struct {
    struct in_addr  filt_ipaddr;    /* IPv4 SrcAddress        */
    u_int32_t       filt_gpi;    /* Generalized Port Id        */
}    Filter_Spec_IPv4GPI;


typedef struct {
    Object_header   filt_header;
    union {
        Filter_Spec_IPv4 filt_ipv4;
        Filter_Spec_IPv4GPI    filt_ipv4gpi;
/*        Filter_Spec_IPv6    filt_ipv6;     */
/*        Filter_Spec_IPv6FL    filt_ipv6fl;     */
/*        Filter_Spec_IPv6GPI    filt_ipv6gpi;     */

    }       filt_u;
}    FILTER_SPEC, SENDER_TEMPLATE;

#define filt_srcaddr    filt_u.filt_ipv4.filt_ipaddr
#define filt_srcport    filt_u.filt_ipv4.filt_port
#define filt_srcgpiaddr filt_u.filt_ipv4gpi.filt_ipaddr
#define filt_srcgpi     filt_u.filt_ipv4gpi.filt_gpi
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\commands\ping\ping.c ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    ping.c

Abstract:

    Packet INternet Groper utility for TCP/IP.

Author:

    Numerous TCP/IP folks.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    MohsinA,    21-Oct-96.  INADDR_NONE check to avoid broadcast.
    MohsinA,    13-Nov-96.  Max packet size < 64K.

Notes:

--*/

//:ts=4
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <time.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <snmp.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <ntddip6.h>
#include <winnlsp.h>
#include <iphlpapi.h>

#include "llinfo.h"
#include "tcpcmd.h"
#include "ipexport.h"
#include "icmpapi.h"
#include "nlstxt.h"


#define MAX_BUFFER_SIZE       (sizeof(ICMP_ECHO_REPLY) + 0xfff7 + MAX_OPT_SIZE)
#define DEFAULT_BUFFER_SIZE         (0x2000 - 8)
#define DEFAULT_SEND_SIZE           32
#define DEFAULT_COUNT               4
#define DEFAULT_TTL                 128
#define DEFAULT_TOS                 0
#define DEFAULT_TIMEOUT             4000L
#define MIN_INTERVAL                1000L
#define STDOUT                      1

uchar   SendOptions[MAX_OPT_SIZE];

WSADATA WsaData;

struct IPErrorTable {
    IP_STATUS  Error;                   // The IP Error
    DWORD ErrorNlsID;                   // NLS string ID
} ErrorTable[] =
{
    { IP_BUF_TOO_SMALL,         PING_BUF_TOO_SMALL},
    { IP_DEST_NET_UNREACHABLE,  PING_DEST_NET_UNREACHABLE},
    { IP_DEST_HOST_UNREACHABLE, PING_DEST_HOST_UNREACHABLE},
    { IP_DEST_PROT_UNREACHABLE, PING_DEST_PROT_UNREACHABLE},
    { IP_DEST_PORT_UNREACHABLE, PING_DEST_PORT_UNREACHABLE},
    { IP_NO_RESOURCES,          PING_NO_RESOURCES},
    { IP_BAD_OPTION,            PING_BAD_OPTION},
    { IP_HW_ERROR,              PING_HW_ERROR},
    { IP_PACKET_TOO_BIG,        PING_PACKET_TOO_BIG},
    { IP_REQ_TIMED_OUT,         PING_REQ_TIMED_OUT},
    { IP_BAD_REQ,               PING_BAD_REQ},
    { IP_BAD_ROUTE,             PING_BAD_ROUTE},
    { IP_TTL_EXPIRED_TRANSIT,   PING_TTL_EXPIRED_TRANSIT},
    { IP_TTL_EXPIRED_REASSEM,   PING_TTL_EXPIRED_REASSEM},
    { IP_PARAM_PROBLEM,         PING_PARAM_PROBLEM},
    { IP_SOURCE_QUENCH,         PING_SOURCE_QUENCH},
    { IP_OPTION_TOO_BIG,        PING_OPTION_TOO_BIG},
    { IP_BAD_DESTINATION,       PING_BAD_DESTINATION},
    { IP_NEGOTIATING_IPSEC,     PING_NEGOTIATING_IPSEC},
    { IP_GENERAL_FAILURE,       PING_GENERAL_FAILURE}
};


PWCHAR
GetErrorString(int ErrorCode)
{
    DWORD Status;
    DWORD Length;
    static WCHAR ErrorString[2048]; // a 2K static buffer should suffice

    Length = 2048;
    Status = GetIpErrorString(ErrorCode, ErrorString, &Length);

    if (Status == NO_ERROR) {
        return ErrorString;     // success
    }

    return L"";                 // return a null string
}


unsigned
NlsPutMsg(unsigned Handle, unsigned usMsgNum, ...)
{
    unsigned msglen;
    VOID * vp;
    va_list arglist;
    DWORD StrLen;

    va_start(arglist, usMsgNum);
    if (!(msglen = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                 FORMAT_MESSAGE_FROM_HMODULE,
                                 NULL,
                                 usMsgNum,
                                 0L,    // Default country ID.
                                 (LPTSTR)&vp,
                                 0,
                                 &arglist)))
        return(0);

    // Convert vp to oem
    StrLen=strlen(vp);
    CharToOemBuff((LPCTSTR)vp,(LPSTR)vp,StrLen);

    msglen = _write(Handle, vp, StrLen);
    LocalFree(vp);

    return(msglen);
}

void
PrintUsage(void)
{
    NlsPutMsg( STDOUT, PING_USAGE );

//     printf(
//     "Usage: ping [-s size] [-c count] [-d] [-l TTL] [-o options] [-t TOS]\n"
//     "            [-w timeout] address.\n"
//     "Options:\n"
//     "    -t            Ping the specifed host until interrupted.\n"
//     "    -l size       Send buffer size.\n"
//     "    -n count      Send count.\n"
//     "    -f            Don't fragment.\n"
//     "    -i TTL        Time to live.\n"
//     "    -v TOS        Type of service\n"
//     "    -w timeout    Timeout (in milliseconds)\n"
//     "    -r routes     Record route.\n"
//     "    -s routes     Timestamp route.\n"
//     "    -j ipaddress  Loose source route.\n"
//     "    -k ipaddress  Strict source route.\n"
//     "    -o            IP options:\n"
//     "                      -ol hop list     Loose source route.\n"
//     "                      -ot              Timestamp.\n"
//     "                      -or              Record route\n"
//     );

}

// ========================================================================
// Note: old code would reject "255.255.255.255" string, but not
// other aliases.  However, the caller checks for that address returned,
// so this function doesn't need to check for it.  On the other hand,
// no other broadcast addresses were disallowed (224.0.0.1, subnet
// broadcast, etc).  Why?

BOOLEAN
ResolveTarget(
    int           Family,
    char         *TargetString,
    SOCKADDR     *TargetAddress,
    socklen_t    *TargetAddressLen,
    char         *TargetName,
    int           TargetNameLen,
    BOOLEAN       DoReverseLookup
    )
{
    int              i;
    struct addrinfo  hints, *ai;

    TargetName[0] = '\0';

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = Family;
    hints.ai_flags = AI_NUMERICHOST;
    i = getaddrinfo(TargetString, NULL, &hints, &ai);
    if (i == NO_ERROR) {
        *TargetAddressLen = ai->ai_addrlen;
        memcpy(TargetAddress, ai->ai_addr, ai->ai_addrlen);

        if (DoReverseLookup) {
            getnameinfo(ai->ai_addr, ai->ai_addrlen,
                        TargetName, TargetNameLen,
                        NULL, 0, NI_NAMEREQD);
        }

        freeaddrinfo(ai);
        return(TRUE);
    } else {
        hints.ai_flags = AI_CANONNAME;
        if (getaddrinfo(TargetString, NULL, &hints, &ai) == 0) {
            *TargetAddressLen = ai->ai_addrlen;
            memcpy(TargetAddress, ai->ai_addr, ai->ai_addrlen);
            strcpy(TargetName,
                   (ai->ai_canonname)? ai->ai_canonname : TargetString);
            freeaddrinfo(ai);
            return(TRUE);
        }
    }

    return(FALSE);

} // ResolveTarget

unsigned long
str2ip(char *addr, int *EndOffset)
{
    char    *endptr;
    char    *start = addr;
    int     i;                          // Counter variable.
    unsigned long curaddr = 0;
    unsigned long temp;

    for (i = 0; i < 4; i++) {
        temp = strtoul(addr, &endptr, 10);
        if (temp > 255)
            return 0L;
        if (endptr[0] != '.')
            if (i != 3)
                return 0L;
            else
                if (endptr[0] != '\0' && endptr[0] != ' ')
                return 0L;
        addr = endptr+1;
        curaddr = (curaddr << 8) + temp;
    }

    *EndOffset += (int)(endptr - start);
    return net_long(curaddr);
}

ulong
param(char **argv, int argc, int current, ulong min, ulong max)
{
    ulong   temp;
    char    *dummy;

    if (current == (argc - 1) ) {
        NlsPutMsg( STDOUT, PING_MESSAGE_1, argv[current] );
        // printf( "Value must be supplied for option %s.\n", argv[current]);
        exit(1);
    }

    temp = strtoul(argv[current+1], &dummy, 0);
    if (temp < min || temp > max) {
        NlsPutMsg( STDOUT, PING_MESSAGE_2, argv[current], min, max );
        // printf( "Bad value for option %s. range min..max\n",
        //         argv[current], min, max );
        exit(1);
    }

    return temp;
}

void
ProcessOptions(
    ICMP_ECHO_REPLY *reply,
    BOOLEAN          DoReverseLookup)
{
    UCHAR     *optionPtr;
    UCHAR     *endPtr;
    BOOLEAN    done = FALSE;
    UCHAR      optionLength;
    UCHAR      entryEndPtr;
    UCHAR      entryPtr;
    UCHAR      addressMode;
    int        entryCount = 0;


    optionPtr = reply->Options.OptionsData;
    endPtr = optionPtr + reply->Options.OptionsSize;

    while ((optionPtr < endPtr) && !done) {
        switch (*optionPtr) {
        case IP_OPT_EOL:
            done = TRUE;
            break;

        case IP_OPT_NOP:
            optionPtr++;
            break;

        case IP_OPT_SECURITY:
            optionPtr += 11;
            break;

        case IP_OPT_SID:
            optionPtr += 4;
            break;

        case IP_OPT_RR:
        case IP_OPT_LSRR:
        case IP_OPT_SSRR:
            if ((optionPtr + 3) > endPtr) {
                NlsPutMsg(STDOUT, PING_INVALID_RR_OPTION);
                done = TRUE;
                break;
            }

            optionLength = optionPtr[1];

            if (((optionPtr + optionLength) > endPtr) ||
                (optionLength < 3)
               ) {
                NlsPutMsg(STDOUT, PING_INVALID_RR_OPTION);
                done = TRUE;
                break;
            }

            entryEndPtr = optionPtr[2];

            if (entryEndPtr < 4) {
                NlsPutMsg(STDOUT, PING_INVALID_RR_OPTION);
                optionPtr += optionLength;
                break;
            }

            if (entryEndPtr > (optionLength + 1)) {
                entryEndPtr = optionLength + 1;
            }

            entryPtr = 4;
            entryCount = 0;

            NlsPutMsg(STDOUT, PING_ROUTE_HEADER1);

            while ((entryPtr + 3) < entryEndPtr) {
                struct in_addr  routeAddress;

                if (entryCount) {
                    NlsPutMsg(
                             STDOUT,
                             PING_ROUTE_SEPARATOR
                             );

                    if (entryCount == 1) {
                        NlsPutMsg(STDOUT, PING_CR);
                        NlsPutMsg(
                                 STDOUT,
                                 PING_ROUTE_HEADER2
                                 );
                        entryCount = 0;
                    }
                }

                entryCount++;

                routeAddress.S_un.S_addr =
                *( (IPAddr UNALIGNED *)
                   (optionPtr + entryPtr - 1)
                 );

                if (DoReverseLookup) {
                    struct hostent *hostEntry;

                    hostEntry = gethostbyaddr(
                                             (char *) &routeAddress,
                                             sizeof(routeAddress),
                                             AF_INET
                                             );

                    if (hostEntry != NULL) {
                        NlsPutMsg(
                                 STDOUT,
                                 PING_FULL_ROUTE_ENTRY,
                                 hostEntry->h_name,
                                 inet_ntoa(routeAddress)
                                 );
                    } else {
                        NlsPutMsg(
                                 STDOUT,
                                 PING_ROUTE_ENTRY,
                                 inet_ntoa(routeAddress)
                                 );
                    }
                } else {
                    NlsPutMsg(
                             STDOUT,
                             PING_ROUTE_ENTRY,
                             inet_ntoa(routeAddress)
                             );
                }

                entryPtr += 4;
            }

            NlsPutMsg(STDOUT, PING_CR);

            optionPtr += optionLength;
            break;

        case IP_OPT_TS:
            if ((optionPtr + 4) > endPtr) {
                NlsPutMsg(STDOUT, PING_INVALID_TS_OPTION);
                done = TRUE;
                break;
            }

            optionLength = optionPtr[1];
            entryEndPtr = optionPtr[2];

            if (entryEndPtr < 5) {
                NlsPutMsg(STDOUT, PING_INVALID_TS_OPTION);
                optionPtr += optionLength;
                break;
            }

            addressMode = optionPtr[3] & 1;

            if (entryEndPtr > (optionLength + 1)) {
                entryEndPtr = optionLength + 1;
            }

            entryPtr = 5;
            entryCount = 0;
            NlsPutMsg(STDOUT, PING_TS_HEADER1);

            while ((entryPtr + 3) < entryEndPtr) {
                struct in_addr  routeAddress;
                ULONG           timeStamp;

                if (entryCount) {
                    NlsPutMsg(
                             STDOUT,
                             PING_ROUTE_SEPARATOR
                             );

                    if (entryCount == 1) {
                        NlsPutMsg(STDOUT, PING_CR);
                        NlsPutMsg(STDOUT, PING_TS_HEADER2);
                        entryCount = 0;
                    }
                }

                entryCount++;

                if (addressMode) {
                    if ((entryPtr + 8) > entryEndPtr) {
                        break;
                    }

                    routeAddress.S_un.S_addr =
                    *( (IPAddr UNALIGNED *)
                       (optionPtr + entryPtr - 1)
                     );

                    if (DoReverseLookup) {
                        struct hostent *hostEntry;

                        hostEntry = gethostbyaddr(
                                                 (char *) &routeAddress,
                                                 sizeof(routeAddress),
                                                 AF_INET
                                                 );

                        if (hostEntry != NULL) {
                            NlsPutMsg(
                                     STDOUT,
                                     PING_FULL_TS_ADDRESS,
                                     hostEntry->h_name,
                                     inet_ntoa(routeAddress)
                                     );
                        } else {
                            NlsPutMsg(
                                     STDOUT,
                                     PING_TS_ADDRESS,
                                     inet_ntoa(routeAddress)
                                     );
                        }
                    } else {
                        NlsPutMsg(
                                 STDOUT,
                                 PING_TS_ADDRESS,
                                 inet_ntoa(routeAddress)
                                 );
                    }

                    entryPtr += 4;

                }

                timeStamp = *( (ULONG UNALIGNED *)
                               (optionPtr + entryPtr - 1)
                             );
                timeStamp = net_long(timeStamp);

                NlsPutMsg(
                         STDOUT,
                         PING_TS_TIMESTAMP,
                         timeStamp
                         );

                entryPtr += 4;
            }

            NlsPutMsg(STDOUT, PING_CR);

            optionPtr += optionLength;
            break;

        default:
            if ((optionPtr + 2) > endPtr) {
                done = TRUE;
                break;
            }

            optionPtr += optionPtr[1];
            break;
        }
    }
}

// ========================================================================
// MohsinA, 05-Dec-96.

SOCKADDR_STORAGE address;               // was local to main earlier.
socklen_t        addressLen;
uint    num_send=0, num_recv=0,
time_min=(uint)-1, time_max=0, time_total=0;

void
print_statistics(  )
{
    if (num_send > 0) {
        char literal[INET6_ADDRSTRLEN];

        if (time_min == (uint) -1) {  // all times were off.
            time_min = 0;
        }

        getnameinfo((LPSOCKADDR)&address, addressLen, literal, sizeof(literal),
                    NULL, 0, NI_NUMERICHOST);

        // printf
        //         "Ping statistics for %s:\n"
        //         "Packets: Sent=%ul, received=%ul, lost=%d (%u%% loss),\n"
        //         "Round trip times in milli-seconds: "
        //         "minimum=%dms, maximum=%dms, average=%dms\n" ....

        NlsPutMsg(STDOUT, PING_STATISTICS,
            literal,
            num_send, num_recv, num_send - num_recv,
            (uint) ( 100 * (num_send - num_recv) / num_send ));

        if (num_recv > 0) {
            NlsPutMsg(STDOUT, PING_STATISTICS2,
                 time_min, time_max, time_total / num_recv );
        }
    }
}

// ========================================================================
// MohsinA, 05-Dec-96.
// Press C-c to      print and abort.
// Press C-break to  print and continue.

BOOL
ConsoleControlHandler(DWORD dwCtrlType)
{
    print_statistics();
    switch ( dwCtrlType ) {
    case CTRL_BREAK_EVENT:
        NlsPutMsg( STDOUT, PING_BREAK );
        return TRUE;
        break;
    case CTRL_C_EVENT:
        NlsPutMsg( STDOUT, PING_INTERRUPT );
    default: break;
    }
    return FALSE;
}

uchar
GetDefaultTTL(void)
{
    HKEY registry=0;
    DWORD DefaultTTL=0;
    DWORD key_type;
    DWORD key_size = sizeof(DWORD);
    uchar TTL;
    DWORD Stat;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters",
                     0,
                     KEY_QUERY_VALUE,
                     &registry) == ERROR_SUCCESS) {


        Stat=RegQueryValueEx(registry,
                             "DefaultTTL",
                             0,
                             &key_type,
                             (unsigned char *)&DefaultTTL,
                             &key_size);
    }
    if (DefaultTTL) {
        TTL = (unsigned char)DefaultTTL;
    } else {
        TTL = DEFAULT_TTL;
    }
    if (registry) {
        RegCloseKey(registry);
    }

    return TTL;
}

int
GetSource(int family, char *astr, struct sockaddr *address)
{
    struct addrinfo hints;
    struct addrinfo *result;

    memset(&hints, 0, sizeof hints);
    hints.ai_flags = AI_PASSIVE;
    hints.ai_family = family;

    if (getaddrinfo(astr, NULL, &hints, &result) != 0)
        return FALSE;

    RtlCopyMemory(address, result->ai_addr, result->ai_addrlen);
    return TRUE;
}

BOOLEAN
SetFamily(DWORD *Family, DWORD Value, char *arg)
{
    if ((*Family != AF_UNSPEC) && (*Family != Value)) {
        NlsPutMsg(STDOUT, PING_MESSAGE_11, arg);
        // NlsPutMsg(STDOUT, PING_FAMILY, arg,
        // (Value==AF_INET)? "IPv4" : "IPv6");
        return FALSE;
    }

    *Family = Value;
    return TRUE;
}

// ========================================================================

void
__cdecl
main(int argc, char **argv)
{
    SOCKADDR_STORAGE sourceAddress;
    char    *arg;
    uint    i;
    uint    j;
    int     found_addr = 0;
    BOOLEAN dnsreq = FALSE;
    char    hostname[NI_MAXHOST], literal[INET6_ADDRSTRLEN];
    DWORD   numberOfReplies;
    uint    Count = DEFAULT_COUNT;
    uchar   TTL = 0;
    uchar   *Opt = NULL;                // Pointer to send options
    uint    OptLength = 0;
    int     OptIndex = 0;               // Current index into SendOptions
    int     SRIndex = -1;               // Where to put address, if source routing
    uchar   TOS = DEFAULT_TOS;
    uchar   Flags = 0;
    ulong   Timeout = DEFAULT_TIMEOUT;
    IP_OPTION_INFORMATION SendOpts;
    int     EndOffset;
    ulong   TempAddr;
    uchar   TempCount;
    DWORD   errorCode;
    HANDLE  IcmpHandle;
    int     err;
    // struct in_addr addr;
    BOOL    result;
    PICMP_ECHO_REPLY      reply4;
    PICMPV6_ECHO_REPLY    reply6;
    BOOL    sourceRouting = FALSE;
    char    *SendBuffer, *RcvBuffer;
    uint    RcvSize;
    uint    SendSize = DEFAULT_SEND_SIZE;
    int     Family = AF_UNSPEC;

    //
    // This will ensure the correct language message is displayed when
    // NlsPutMsg is called.
    //
    SetThreadUILanguage(0);

    err = WSAStartup(MAKEWORD(2, 0), &WsaData);

    if (err) {
        NlsPutMsg(STDOUT, PING_WSASTARTUP_FAILED, GetLastError());
        exit(1);
    }

    memset(&sourceAddress, 0, sizeof sourceAddress);

    TTL = GetDefaultTTL();

    if (argc < 2) {
        PrintUsage();
        goto error_exit;
    } else {
        i = 1;
        while (i < (uint) argc) {
            arg = argv[i];
            if ( (arg[0] == '-') || (arg[0] == '/') ) {    // Have an option
                switch (arg[1]) {
                case '?':
                    PrintUsage();
                    exit(0);

                case 'l':
                    // SendSize = (uint)param(argv, argc, i++, 0, 0xfff7);
                    // A ping with packet size >= 64K can crash
                    // some tcpip stacks during re-assembly,
                    // So changed 'max' from 0xfff7 to 65500
                    // - MohsinA, 13-Nov-96.

                    SendSize = (uint)param(argv, argc, i++, 0, 65500 );
                    break;

                case 't':
                    Count = (uint)-1;
                    break;

                case 'n':
                    Count = (uint)param(argv, argc, i++, 1, 0xffffffff);
                    break;

                case 'f':
                    // Only implemented for IPv4.
                    if (!SetFamily(&Family, AF_INET, arg)) {
                        goto error_exit;
                    }
                    Flags = IP_FLAG_DF;
                    break;

                case 'i':
                    // TTL of zero is invalid, MohsinA, 13-Mar-97.
                    TTL = (uchar)param(argv, argc, i++, 1, 0xff);
                    break;

                case 'v':
                    // Only implemented for IPv4.
                    if (!SetFamily(&Family, AF_INET, arg)) {
                        goto error_exit;
                    }
                    TOS = (uchar)param(argv, argc, i++, 0, 0xff);
                    break;

                case 'w':
                    Timeout = param(argv, argc, i++, 0, 0xffffffff);
                    break;

                case 'a':
                    dnsreq = TRUE;
                    break;

                case 'r':               // Record Route
                    // Only implemented for IPv4.
                    if (!SetFamily(&Family, AF_INET, arg)) {
                        goto error_exit;
                    }

                    if ((OptIndex + 3) > MAX_OPT_SIZE) {
                        NlsPutMsg(STDOUT, PING_TOO_MANY_OPTIONS);
                        goto error_exit;
                    }

                    Opt = SendOptions;
                    Opt[OptIndex] = IP_OPT_RR;
                    Opt[OptIndex + 2] = 4;    // Set initial pointer value
                    // min is 1 not zero, MohsinA, 16-4-97.
                    TempCount = (uchar)param(argv, argc, i++, 1, 9);
                    TempCount = (TempCount * sizeof(ulong)) + 3;

                    if ((TempCount + OptIndex) > MAX_OPT_SIZE) {
                        NlsPutMsg(STDOUT, PING_TOO_MANY_OPTIONS);
                        goto error_exit;
                    }

                    Opt[OptIndex+1] = TempCount;
                    OptLength += TempCount;
                    OptIndex += TempCount;
                    break;

                case 's':               // Timestamp
                    // Only implemented for IPv4.
                    if (!SetFamily(&Family, AF_INET, arg)) {
                        goto error_exit;
                    }
                    if ((OptIndex + 4) > MAX_OPT_SIZE) {
                        NlsPutMsg(STDOUT, PING_TOO_MANY_OPTIONS);
                        goto error_exit;
                    }

                    Opt = SendOptions;
                    Opt[OptIndex] = IP_OPT_TS;
                    Opt[OptIndex + 2] = 5;    // Set initial pointer value
                    TempCount = (uchar)param(argv, argc, i++, 1, 4);
                    TempCount = (TempCount * (sizeof(ulong) * 2)) + 4;

                    if ((TempCount + OptIndex) > MAX_OPT_SIZE) {
                        NlsPutMsg(STDOUT, PING_TOO_MANY_OPTIONS);
                        goto error_exit;
                    }

                    Opt[OptIndex+1] = TempCount;
                    Opt[OptIndex+3] = 1;
                    OptLength += TempCount;
                    OptIndex += TempCount;
                    break;

                case 'j':               // Loose source routing
                    // Only implemented for IPv4.
                    if (!SetFamily(&Family, AF_INET, arg)) {
                        goto error_exit;
                    }

                    if (sourceRouting) {
                        NlsPutMsg(STDOUT, PING_BAD_OPTION_COMBO);
                        goto error_exit;
                    }

                    if ((OptIndex + 3) > MAX_OPT_SIZE) {
                        NlsPutMsg(STDOUT, PING_TOO_MANY_OPTIONS);
                        goto error_exit;
                    }

                    Opt = SendOptions;
                    Opt[OptIndex] = IP_OPT_LSRR;
                    Opt[OptIndex+1] = 3;
                    Opt[OptIndex + 2] = 4;    // Set initial pointer value
                    OptLength += 3;
                    while ( (i < (uint)(argc - 2)) && (*argv[i+1] != '-')) {
                        if ((OptIndex + 3) > (MAX_OPT_SIZE - 4)) {
                            NlsPutMsg(STDOUT, PING_TOO_MANY_OPTIONS);
                            goto error_exit;
                        }

                        arg = argv[++i];
                        EndOffset = 0;
                        do {
                            TempAddr = str2ip(arg + EndOffset, &EndOffset);
                            if (!TempAddr) {
                                NlsPutMsg( STDOUT, PING_MESSAGE_4 );
                                // printf("Bad route specified for loose source route");
                                goto error_exit;
                            }
                            j = Opt[OptIndex+1];
                            *(ulong UNALIGNED *)&Opt[j+OptIndex] = TempAddr;
                            Opt[OptIndex+1] += 4;
                            OptLength += 4;
                            while (arg[EndOffset] != '\0' && isspace((unsigned char)arg[EndOffset]))
                                EndOffset++;
                        } while (arg[EndOffset] != '\0');
                    }
                    SRIndex = Opt[OptIndex+1] + OptIndex;
                    Opt[OptIndex+1] += 4;    // Save space for dest. addr
                    OptIndex += Opt[OptIndex+1];
                    OptLength += 4;
                    sourceRouting = TRUE;
                    break;

                case 'k':               // Strict source routing
                    // Only implemented for IPv4.
                    if (!SetFamily(&Family, AF_INET, arg)) {
                        goto error_exit;
                    }

                    if (sourceRouting) {
                        NlsPutMsg(STDOUT, PING_BAD_OPTION_COMBO);
                        goto error_exit;
                    }

                    if ((OptIndex + 3) > MAX_OPT_SIZE) {
                        NlsPutMsg(STDOUT, PING_TOO_MANY_OPTIONS);
                        goto error_exit;
                    }

                    Opt = SendOptions;
                    Opt[OptIndex] = IP_OPT_SSRR;
                    Opt[OptIndex+1] = 3;
                    Opt[OptIndex + 2] = 4;    // Set initial pointer value
                    OptLength += 3;
                    while ( (i < (uint)(argc - 2)) && (*argv[i+1] != '-')) {
                        if ((OptIndex + 3) > (MAX_OPT_SIZE - 4)) {
                            NlsPutMsg(STDOUT, PING_TOO_MANY_OPTIONS);
                            goto error_exit;
                        }

                        arg = argv[++i];
                        EndOffset = 0;
                        do {
                            TempAddr = str2ip(arg + EndOffset, &EndOffset);
                            if (!TempAddr) {
                                NlsPutMsg( STDOUT, PING_MESSAGE_4 );
                                // printf("Bad route specified for loose source route");
                                goto error_exit;
                            }
                            j = Opt[OptIndex+1];
                            *(ulong UNALIGNED *)&Opt[j+OptIndex] = TempAddr;
                            Opt[OptIndex+1] += 4;
                            OptLength += 4;
                            while (arg[EndOffset] != '\0' && isspace((unsigned char)arg[EndOffset]))
                                EndOffset++;
                        } while (arg[EndOffset] != '\0');
                    }
                    SRIndex = Opt[OptIndex+1] + OptIndex;
                    Opt[OptIndex+1] += 4;    // Save space for dest. addr
                    OptIndex += Opt[OptIndex+1];
                    OptLength += 4;
                    sourceRouting = TRUE;
                    break;

                case 'R':
                    // Only implemented for IPv6 so far
                    if (!SetFamily(&Family, AF_INET6, arg)) {
                        goto error_exit;
                    }
                    SendOpts.Flags |= ICMPV6_ECHO_REQUEST_FLAG_REVERSE;
                    break;

                case 'S':
                    // Only implemented for IPv6 so far
                    if (!SetFamily(&Family, AF_INET6, arg)) {
                        goto error_exit;
                    }
    
                    if (!GetSource(Family, argv[++i], (LPSOCKADDR)&sourceAddress)) {
                        NlsPutMsg(STDOUT, PING_MESSAGE_13, argv[i]);
                        // NlsPutMsg(STDOUT, PING_BAD_ADDRESS, argv[i]);
                        goto error_exit;
                    }
                    break;

                case '4':
                    if (!SetFamily(&Family, AF_INET, arg)) {
                        goto error_exit;
                    }
                    break;

                case '6':
                    if (!SetFamily(&Family, AF_INET6, arg)) {
                        goto error_exit;
                    }
                    break;

                default:
                    NlsPutMsg( STDOUT, PING_MESSAGE_11, arg );
                    // printf( "Bad option %s.\n\n", arg);
                    PrintUsage();
                    goto error_exit;
                    break;
                }
                i++;
            } else {                    // Not an option, must be an IP address.
                if (found_addr) {
                    NlsPutMsg( STDOUT, PING_MESSAGE_12, arg );
                    // printf( "Bad parameter %s.\n", arg);
                    goto error_exit;
                }

                // Added check for INADDR_NONE, MohsinA, 21-Oct-96.
                if (ResolveTarget(Family, arg, (LPSOCKADDR)&address,
                                  &addressLen, hostname, sizeof(hostname),
                                  dnsreq) &&
                    ((address.ss_family != AF_INET) || (((LPSOCKADDR_IN)&address)->sin_addr.s_addr != INADDR_NONE))) {
                    found_addr = 1;
                    i++;
                } else {
                    NlsPutMsg( STDOUT, PING_MESSAGE_13, arg );
                    // printf( "Bad IP address %s.\n", arg);
                    // "Unknown host %s.", was Bug 1368.
                    goto error_exit;
                }
            }
        }
    }

    if (!found_addr) {
        NlsPutMsg( STDOUT, PING_MESSAGE_14 );
        // printf("IP address must be specified.\n");
        goto error_exit;
    }

    Family = address.ss_family;
    if (Family == AF_INET) {
        if (SRIndex != -1) {
            *(ulong UNALIGNED *)&SendOptions[SRIndex] = ((LPSOCKADDR_IN)&address)->sin_addr.s_addr;
        }

        IcmpHandle = IcmpCreateFile();
    } else {
        if (sourceAddress.ss_family == AF_UNSPEC) {
            SOCKET s;
            DWORD BytesReturned;

            //
            // A source address was not specified.
            // Get the preferred source address for this destination.
            //
            // If you want each individual echo request
            // to select a source address, use "-S ::".
            //

            s = socket(address.ss_family, 0, 0);
            if (s == INVALID_SOCKET) {
                NlsPutMsg(STDOUT, PING_WSASTARTUP_FAILED, WSAGetLastError());
                // NlsPutMsg(STDOUT, PING_SOCKET_FAILED, WSAGetLastError());
                exit(1);
            }

            (void) WSAIoctl(s, SIO_ROUTING_INTERFACE_QUERY,
                            &address, sizeof address,
                            &sourceAddress, sizeof sourceAddress,
                            &BytesReturned, NULL, NULL);

            closesocket(s);
        }

        IcmpHandle = Icmp6CreateFile();
    }

    if (IcmpHandle == INVALID_HANDLE_VALUE) {
        NlsPutMsg( STDOUT, PING_MESSAGE_15, GetLastError() );

        // printf( "Unable to contact IP driver, error code %d.\n",
        //        GetLastError() );

        goto error_exit;
    }

    SendBuffer = LocalAlloc(LMEM_FIXED, SendSize);

    if (SendBuffer == NULL) {
        NlsPutMsg(STDOUT, PING_NO_MEMORY);
        goto error_exit;
    }

    //
    // Calculate receive buffer size and try to allocate it.
    //
    if (SendSize <= DEFAULT_SEND_SIZE) {
        RcvSize = DEFAULT_BUFFER_SIZE;
    } else {
        RcvSize = MAX_BUFFER_SIZE;
    }

    RcvBuffer = LocalAlloc(LMEM_FIXED, RcvSize);

    if (RcvBuffer == NULL) {
        NlsPutMsg(STDOUT, PING_NO_MEMORY);
        LocalFree(SendBuffer);
        goto error_exit;
    }

    //
    // Initialize the send buffer pattern.
    //
    for (i = 0; i < SendSize; i++) {
        SendBuffer[i] = 'a' + (i % 23);
    }

    //
    // Initialize the send options
    //
    SendOpts.OptionsData = Opt;
    SendOpts.OptionsSize = (uchar)OptLength;
    SendOpts.Ttl = TTL;
    SendOpts.Tos = TOS;
    SendOpts.Flags = Flags;

    getnameinfo((LPSOCKADDR)&address, addressLen, literal, sizeof(literal),
                NULL, 0, NI_NUMERICHOST);

    if (hostname[0]) {
        NlsPutMsg(
                 STDOUT,
                 PING_HEADER1,
                 hostname,
                 literal,
                 SendSize
                 );
        // printf("Pinging Host %s [%s]\n", hostname, literal);
    } else {
        NlsPutMsg(
                 STDOUT,
                 PING_HEADER2,
                 literal,
                 SendSize
                 );
        // printf("Pinging Host [%s]\n", literal);
    }

    if (sourceAddress.ss_family == AF_INET6) {
        getnameinfo((LPSOCKADDR)&sourceAddress, sizeof(SOCKADDR_IN6), literal, 
                    sizeof(literal), NULL, 0, NI_NUMERICHOST);
        // NlsPutMsg(STDOUT, PING_SOURCE_ADDRESS, literal);
    }

    // NlsPutMsg(STDOUT, PING_WITH_DATA, SendSize);

    SetConsoleCtrlHandler( &ConsoleControlHandler, TRUE );

    for (i = 0; i < Count; i++) {
        if (Family == AF_INET) {
            numberOfReplies = IcmpSendEcho2(IcmpHandle,
                                            0,
                                            NULL,
                                            NULL,
                                            ((LPSOCKADDR_IN)&address)->sin_addr.s_addr,
                                            SendBuffer,
                                            (unsigned short) SendSize,
                                            &SendOpts,
                                            RcvBuffer,
                                            RcvSize,
                                            Timeout);
    
            num_send++;
    
            if (numberOfReplies == 0) {
    
                errorCode = GetLastError();
    
                if (errorCode < IP_STATUS_BASE) {
                    NlsPutMsg( STDOUT, PING_MESSAGE_18, errorCode );
                    // printf("PING: transmit failed, error code %lu\n", errorCode);
                } else {
                    for (j = 0; ErrorTable[j].Error != errorCode &&
                        ErrorTable[j].Error != IP_GENERAL_FAILURE;j++)
                        ;
    
                    NlsPutMsg( STDOUT, ErrorTable[j].ErrorNlsID );
                    // printf("PING: %s.\n", ErrorTable[j].ErrorString);
                }
    
                if (i < (Count - 1)) {
                    Sleep(MIN_INTERVAL);
                }
    
            } else {
    
                reply4 = (PICMP_ECHO_REPLY) RcvBuffer;
    
                while (numberOfReplies--) {
                    struct in_addr addr;
    
                    addr.S_un.S_addr = reply4->Address;
    
                    NlsPutMsg(STDOUT, PING_MESSAGE_19, inet_ntoa(addr));
                    // printf(
                    //     "Reply from %s:",
                    //     inet_ntoa(addr),
                    //         );
    
                    if (reply4->Status == IP_SUCCESS) {
    
                        NlsPutMsg( STDOUT, PING_MESSAGE_25, (int) reply4->DataSize);
                        // printf(
                        //     "Echo size=%d ",
                        //         reply4->DataSize
                        //         );
    
                        if (reply4->DataSize != SendSize) {
                            NlsPutMsg( STDOUT, PING_MESSAGE_20, SendSize );
                            // printf("(sent %d) ", SendSize);
                        } else {
                            char *sendptr, *recvptr;
    
                            sendptr = &(SendBuffer[0]);
                            recvptr = (char *) reply4->Data;
    
                            for (j = 0; j < SendSize; j++)
                                if (*sendptr++ != *recvptr++) {
                                    NlsPutMsg( STDOUT, PING_MESSAGE_21, j );
                                    // printf("- MISCOMPARE at offset %d - ", j);
                                    break;
                                }
                        }
    
                        if (reply4->RoundTripTime) {
                            NlsPutMsg( STDOUT, PING_MESSAGE_22, reply4->RoundTripTime );
                            // Collect stats.
    
                            time_total += reply4->RoundTripTime;
                            if ( reply4->RoundTripTime < time_min ) {
                                time_min = reply4->RoundTripTime;
                            }
                            if ( reply4->RoundTripTime > time_max ) {
                                time_max = reply4->RoundTripTime;
                            }
    
                        }
    
                        else {
                            NlsPutMsg( STDOUT, PING_MESSAGE_23 );
                            // printf("time<1ms ");
    
                            time_min = 0;
                        }
    
    
                        // printf("\n time rt=%dms min %d, max %d, total %d\n",
                        //        reply4->RoundTripTime,
                        //        time_min, time_max, time_total );
    
                        NlsPutMsg( STDOUT, PING_MESSAGE_24, (uint)reply4->Options.Ttl );
                        // printf("TTL=%u\n", (uint)reply4->Options.Ttl);
    
                        if (reply4->Options.OptionsSize) {
                            ProcessOptions(reply4, dnsreq);
                        }
                    } else {
                        for (j=0; ErrorTable[j].Error != IP_GENERAL_FAILURE; j++) {
                            if (ErrorTable[j].Error == reply4->Status) {
                                break;
                            }
                        }
    
                        NlsPutMsg( STDOUT, ErrorTable[j].ErrorNlsID);
                    }
    
                    num_recv++;
                    reply4++;
                }
    
                if (i < (Count - 1)) {
                    reply4--;
    
                    if (reply4->RoundTripTime < MIN_INTERVAL) {
                        Sleep(MIN_INTERVAL - reply4->RoundTripTime);
                    }
                }
            }
        } else {
            // AF_INET6
            numberOfReplies = Icmp6SendEcho2(IcmpHandle,
                                             0,
                                             NULL,
                                             NULL,
                                             (LPSOCKADDR_IN6)&sourceAddress,
                                             (LPSOCKADDR_IN6)&address,
                                             SendBuffer,
                                             (unsigned short) SendSize,
                                             &SendOpts,
                                             RcvBuffer,
                                             RcvSize,
                                             Timeout);
    
            num_send++;
    
            if (numberOfReplies == 0) {
    
                errorCode = GetLastError();
    
                if (errorCode < IP_STATUS_BASE) {
                    NlsPutMsg( STDOUT, PING_MESSAGE_18, errorCode );
                    // printf("PING: transmit failed, error code %lu\n", errorCode);
                } else {
                    for (j = 0; ErrorTable[j].Error != errorCode &&
                        ErrorTable[j].Error != IP_GENERAL_FAILURE;j++)
                        ;
    
                    NlsPutMsg( STDOUT, ErrorTable[j].ErrorNlsID );
                    // printf("PING: %s.\n", ErrorTable[j].ErrorString);
                }
    
                if (i < (Count - 1)) {
                    Sleep(MIN_INTERVAL);
                }
    
            } else {
    
                reply6 = (PICMPV6_ECHO_REPLY) RcvBuffer;
    
                while (numberOfReplies--) {

                    getnameinfo((LPSOCKADDR)&address, addressLen, literal, 
                                sizeof(literal), NULL, 0, NI_NUMERICHOST);

                    NlsPutMsg(STDOUT, PING_MESSAGE_19, literal);

                    // printf(
                    //     "Reply from %s:",
                    //     inet_ntoa(addr),
                    //         );
    
                    if (reply6->Status == IP_SUCCESS) {
    
                        if (reply6->RoundTripTime) {
                            NlsPutMsg( STDOUT, PING_MESSAGE_22, reply6->RoundTripTime );
                            // Collect stats.
    
                            time_total += reply6->RoundTripTime;
                            if ( reply6->RoundTripTime < time_min ) {
                                time_min = reply6->RoundTripTime;
                            }
                            if ( reply6->RoundTripTime > time_max ) {
                                time_max = reply6->RoundTripTime;
                            }
    
                        }
    
                        else {
                            NlsPutMsg( STDOUT, PING_MESSAGE_23 );
                            // printf("time<1ms ");
    
                            time_min = 0;
                        }
    
    
                        // printf("\n time rt=%dms min %d, max %d, total %d\n",
                        //        reply6->RoundTripTime,
                        //        time_min, time_max, time_total );
    
                        NlsPutMsg(STDOUT, PING_CR);
    
                    } else {
                        for (j=0; ErrorTable[j].Error != IP_GENERAL_FAILURE; j++) {
                            if (ErrorTable[j].Error == reply6->Status) {
                                break;
                            }
                        }
    
                        NlsPutMsg( STDOUT, ErrorTable[j].ErrorNlsID);
                    }
    
                    num_recv++;
                    reply6++;
                }
    
                if (i < (Count - 1)) {
                    reply6--;
    
                    if (reply6->RoundTripTime < MIN_INTERVAL) {
                        Sleep(MIN_INTERVAL - reply6->RoundTripTime);
                    }
                }
            }
        }
    }

    // MohsinA, 05-Dec-96. DCR # 65503.
    print_statistics();

    result = IcmpCloseHandle(IcmpHandle);

    LocalFree(SendBuffer);
    LocalFree(RcvBuffer);

    WSACleanup();
    exit(0 == num_recv);

error_exit:
    WSACleanup();
    exit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\commands\pathping\pathqos.c ===
#define UNICODE

#include    <nt.h>
#include    <ntrtl.h>
#include    <nturtl.h>
#define NOGDI
#define NOMINMAX
#include    <windows.h>
#include    <stdio.h>
#include    <stdlib.h>
#include    <ctype.h>
#include    <io.h>
#include    <winsock2.h>
#include    <ws2tcpip.h>
#include    <nls.h>
#include    <ntddip6.h>
#include    "pathqos.h"
#include    "ipexport.h"
#include    "icmpapi.h"
#include    "nlstxt.h"
#include    "pathping.h"
#include    <qos.h>
#include    <ntddndis.h>
#include    <traffic.h>

#define ICMP_MSG 1
#define RSVP_MSG 2

u_char  Router_alert[4] = {148, 4, 0, 0};

uchar RsvpPathTearMsg[] = 
{
    0x10, 0x05, 0xB6, 0x38, 0x80, 0x00, 0x00, 0x50, 0x00, 0x0C, 
    0x01, 0x01, 0x0F, 0x19, 0x05, 0x71, 0x11, 0x01, 0x15, 0xB3, 0x00, 0x0C, 0x03, 0x01, 0x0F, 0x19,
    0x08, 0x7F, 0x00, 0x01, 0x00, 0x01, 0x00, 0x0C, 0x0B, 0x01, 0x0F, 0x19, 0x08, 0x7F, 0x00, 0x00,
    0x15, 0xB3, 0x00, 0x24, 0x0C, 0x02, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x00, 0x06, 0x7F, 0x00,
    0x00, 0x05, 0x42, 0x82, 0x63, 0xAB, 0x44, 0xBF, 0x00, 0x00, 0x43, 0x02, 0x63, 0xAB, 0x00, 0x00,
    0x05, 0xF8, 0x00, 0x00, 0x06, 0x5C

};

uchar RsvpPathMsg[] = 
{
    0x10, 0x01, 0x14, 0x04, 0x80, 0x00, 0x00, 0x88, 0x00, 0x0C, 0x01, 0x01, 0x0F, 0x19, 0x08, 0x01, 
    0x11, 0x01, 0x15, 0xB3, 0x00, 0x0C, 0x03, 0x01, 0x0F, 0x19, 0x08, 0x7F, 0x00, 0x01, 0x00, 0x01, 
    0x00, 0x08, 0x05, 0x01, 0x00, 0x00, 0x75, 0x30, 0x00, 0x0C, 0x0B, 0x01, 0x0F, 0x19, 0x08, 0x7F, 
    0x00, 0x00, 0x15, 0xB3, 0x00, 0x24, 0x0C, 0x02, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x00, 0x06, 
    0x7F, 0x00, 0x00, 0x05, 0x42, 0x82, 0x63, 0xAB, 0x44, 0xBF, 0x00, 0x00, 0x43, 0x02, 0x63, 0xAB, 
    0x00, 0x00, 0x05, 0xF8, 0x00, 0x00, 0x06, 0x5C, 0x00, 0x30, 0x0D, 0x02, 0x00, 0x00, 0x00, 0x0A, 
    0x01, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x01, 
    0x48, 0x74, 0x24, 0x00, 0x08, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0x0A, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x05, 0xDC, 0x05, 0x00, 0x00, 0x00  
};

uchar RsvpResvMsg[] = 
{
    // common_header
    0x10, 0x02, 0x4D, 0xF8, 0xFF, 0x00, 0x00, 0x60, 

    // session
    0x00, 0x0C, 0x01, 0x01, 0xAC, 0x1F, 0x7A, 0x15, 0x11, 0x00, 0x15, 0xB3, 

    // rsvp_hop
    0x00, 0x0C, 0x03, 0x01, 0xC0, 0xA8, 0x1F, 0xE5, 0x00, 0x00, 0x00, 0x00, 

    //
    0x00, 0x08, 0x05, 0x01, 0x00, 0x00, 0x75, 0x30, 

    // Style object
    0x00, 0x08, 0x08, 0x01, 0x00, 0x00, 0x00, 0x0A, 

    // flowspec
    0x00, 0x24, 0x09, 0x02, 0x00, 0x00, 0x00, 0x07, 0x05, 0x00, 0x00, 0x06, 
    0x7F, 0x00, 0x00, 0x05, 0x42, 0x82, 0x00, 0x00, 0x44, 0xBF, 0x00, 0x00, 
    0x43, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 

    // filterspec
    0x00, 0x0C, 0x0A, 0x01, 0xAC, 0x1F, 0x47, 0x90, 0x00, 0x00, 0x15, 0xB3
};

// 
// Utility functions 
//

/* 
 *  The response is an IP packet. We must decode the IP header to locate 
 *  the ICMP data 
 */
void decode_msg(char *buf, 
                int bytes,
                struct sockaddr_in *from,
                int code,
                Object_header *orisession)
{
    IpHeader        *orihdr, *iphdr;
    IcmpHeader      *icmphdr;
    unsigned   short iphdrlen;

    iphdr = (IpHeader *)buf;

    iphdrlen = iphdr->h_len * 4 ; // number of 32-bit words *4 = bytes

    if(code == RSVP_MSG)
    {
        common_header *rsvphdr = (common_header *)(buf + iphdrlen); 

        if(rsvphdr->rsvp_type ==  RSVP_RESV_ERR)
        {
            char *newbuf = (PCHAR) rsvphdr + sizeof(common_header);
            ULONG r = ntohs(rsvphdr->rsvp_length) - sizeof(common_header);
            Object_header *Sessobj = 0;

            while(r) {

                Object_header *obj = (Object_header *)(newbuf);
    
                switch(obj->obj_class)
                {
                    case class_SESSION:
                        Sessobj = obj;
                        break;

                    case class_ERROR_SPEC:
                    {
                        ERROR_SPEC *err = (ERROR_SPEC *)obj;
                        
                        //
                        // Now make sure that the session object is the same as what we are sending.
                        //
                        while(r && !Sessobj)
                        {
                            newbuf = (PCHAR)newbuf + ntohs(obj->obj_length);
                            r-=ntohs(obj->obj_length);
                            obj    = (Object_header *)(newbuf);
                            if(obj->obj_class == class_SESSION)
                            {
                                Sessobj = obj;
                                break;
                            }
                        }

                        if(!Sessobj) 
                        { 
                            NlsPutMsg(STDOUT, PATHPING_BOGUSRESVERR_MSG);
                        }
                        else {
                            // Make sure that the session obj is the same as what we passed in
                            if(memcmp(orisession, Sessobj, ntohs(orisession->obj_length)) == 0)
                                NlsPutMsg(STDOUT, PATHPING_RSVPAWARE_MSG);
                            else NlsPutMsg(STDOUT, PATHPING_BOGUSRESVERR_MSG);
                        }
                
                        return;
                    }
                }
    
                newbuf = (PCHAR)newbuf + ntohs(obj->obj_length);
                r -= ntohs(obj->obj_length);
            }

            NlsPutMsg(STDOUT, PATHPING_RSVPAWARE_MSG);

        }
        return;
    }
    else 
    {
        if (bytes  < iphdrlen + ICMP_MIN) 
        {
            NlsPutMsg(STDOUT, PATHPING_ALIGN_IP_ADDRESS, inet_ntoa(from->sin_addr));
            NlsPutMsg(STDOUT, PATHPING_BUF_TOO_SMALL);
        }
    
        icmphdr = (IcmpHeader*)(buf + iphdrlen);
    
        switch(icmphdr->i_type)
        {
            default:
              printf("Unknown type %d \n", icmphdr->i_type);
              break;
        
            case 11:

               if(icmphdr->i_code == 0)
               {
                  //
                  // we have got TTL expired message.
                  //

                  orihdr = (IpHeader *)((PCHAR)icmphdr +sizeof(IcmpHeader));

                  if(orihdr->proto == 46)
                  {
                     NlsPutMsg(STDOUT, PATHPING_QOS_SUCCESS);
                     return;
                  }
               }

               NlsPutMsg(STDOUT, PATHPING_ICMPTYPE11_MSG, icmphdr->i_code);

               break;

            case 3:
    
               if(icmphdr->i_code == 2)
               {
                  //
                  // This router has sent protocol unreachable. Make sure that it is protocol 46
                  // before we print anything.
                  // 
    
                  orihdr = (IpHeader *)((PCHAR)icmphdr + sizeof(IcmpHeader));

                  if(orihdr->proto == 46)
                  {
                     NlsPutMsg(STDOUT, PATHPING_NONRSVPAWARE_MSG);
                     return;
                  }
               }

               NlsPutMsg(STDOUT, PATHPING_ICMPTYPE3_MSG, icmphdr->i_code);

               break;
        }
    }
}

/*
 * Compute TCP/UDP/IP checksum.
 * See p. 7 of RFC-1071.
 *      This RFC indicates that the chksum calculation works equally well for both little
 *      endian machines and big endian machines, hence there are no ifdefs here to
 *      reflect the endian-ness of the machine.
 */
u_int16_t
in_cksum(unsigned char *bp, int n)
{
        unsigned short *sp= (u_int16_t *) bp;
        unsigned long sum = 0;

        /* Sum half-words */
        while (n>1) {
                sum += *sp++;
                n -=2;
        }

        /* Add left-over byte, if any */
        if (n>0)
                sum += *(char *) sp;

        /* Fold 32-bit sum to 16 bits */
        sum = (sum & 0xFFFF) + (sum >> 16);
        sum = ~(sum + (sum >> 16)) & 0xFFFF;
        if (sum == 0xffff)
                sum = 0;

        return ((u_int16_t)sum);
}

void QoSNotifyHandler( HANDLE ClRegCtx, HANDLE ClIfcCtx, ULONG Event, HANDLE SubCode, ULONG BufSize, PVOID Buffer )
{
}

//
// Given destination address, this function returns the source address of the interface.
//

ULONG 
QoSGetSourceAddress(ULONG Destination)
{
    SOCKET s;
    int err;
    DWORD dwBufferSize;
    SOCKADDR_IN remoteaddr, localaddr;
    ULONG Source = 0;

    s = socket( AF_INET, SOCK_DGRAM, IPPROTO_UDP );
    if (INVALID_SOCKET != s)
    {
        memset(&remoteaddr, 0, sizeof(remoteaddr));
        remoteaddr.sin_family = AF_INET;
        remoteaddr.sin_port = 0;
        remoteaddr.sin_addr.S_un.S_addr = Destination;

        err = WSAIoctl(s,
                       SIO_ROUTING_INTERFACE_QUERY,
                       &remoteaddr,
                       sizeof(remoteaddr),
                       &localaddr,
                       sizeof(localaddr),
                       &dwBufferSize,
                       NULL,
                       NULL );
        
        if (0 == err)
           Source = localaddr.sin_addr.S_un.S_addr;
        
        closesocket(s);
    }
    
    return Source;
}


//
// This function tests if 802.1p is misconfigured in the network. Enabling 802.1p causes packets
// to go out with a 4 byte 802.1p tag. If a switch is present between a 802.1p aware network and
// a legacy network (no 802.1p devices), then it should strip the tag before forwarding packets
// on the legacy network. Otherwise, the legacy devices will toss the tagged ethernet packet assuming
// that it is malformed (because of the 4 byte tag).
//


//
// This function creates a besteffort flow with a TCLASS and DCLASS and adds a filter for ping packets
// It then sends pings to the destinations. This causes the ping packets to go out with a 802.1p tag.
// If 802.1p is misconfigured, the router that sees the tagged packet will fail the ping.
//

#define PATHPING_QOS_TRAFFIC_CLASS 7
#define PATHPING_QOS_DS_CLASS      0x28

void
QoSCheck8021P(
    ULONG DstAddr,
    ULONG ulHopCount
    )
{
    PICMP_ECHO_REPLY     reply;
    ULONG                i, numberOfReplies, SrcAddr, h, q;
    int                  lost, rcvd, linklost, nodelost, sent, len;
    TCI_CLIENT_FUNC_LIST ClientHandlerList;
    ULONG                Size = 100 * sizeof(TC_IFC_DESCRIPTOR);
    PTC_IFC_DESCRIPTOR   pTcIfcBuffer = 0;
    ULONG                Status;
    HANDLE               hClientHandle = 0, hInterfaceHandle = 0, hFlowHandle = 0, hFilterHandle = 0;
    PTC_GEN_FLOW         pTcFlowSpec = 0;
    LPQOS_TRAFFIC_CLASS  pTclass;
    LPQOS_DS_CLASS       pDclass;
    char                 SendBuffer[DEFAULT_SEND_SIZE];
    char                 RcvBuffer[DEFAULT_RECEIVE_SIZE];

    NlsPutMsg(STDOUT, PATHPING_LAYER2_CONNECT_MSG);


    memset( &ClientHandlerList, 0, sizeof(ClientHandlerList) );
    ClientHandlerList.ClNotifyHandler = QoSNotifyHandler;

    SrcAddr = QoSGetSourceAddress(DstAddr);

    //
    // Register the TC client.
    //
    Status = TcRegisterClient(CURRENT_TCI_VERSION,
                              NULL,
                              &ClientHandlerList,
                              &hClientHandle);
    
    if(Status != ERROR_SUCCESS)
    {
       NlsPutMsg(STDOUT, PATHPING_TCREGISTERCLIENT_FAILED, Status);
       return ;
    }

    //
    // Enumerate TC interfaces.
    //
    pTcIfcBuffer = (PTC_IFC_DESCRIPTOR) LocalAlloc(LMEM_FIXED, Size);
    
    Status = TcEnumerateInterfaces(
        hClientHandle,
        &Size,
        pTcIfcBuffer);
    
    if(ERROR_INSUFFICIENT_BUFFER == Status)
    {
        LocalFree(pTcIfcBuffer);
    
        pTcIfcBuffer = (PTC_IFC_DESCRIPTOR) LocalAlloc(LMEM_FIXED, Size);

        Status = TcEnumerateInterfaces(hClientHandle,
                                       &Size,
                                       pTcIfcBuffer);
    
        if(Status != ERROR_SUCCESS)
        {
           NlsPutMsg(STDOUT, PATHPING_TCENUMERATEINTERFACES_FAILED, Status);

           goto QoSCleanup;

        }
    }
    else 
    {
       if(Status != ERROR_SUCCESS)
       {
           NlsPutMsg(STDOUT, PATHPING_TCENUMERATEINTERFACES_FAILED, Status);

           goto QoSCleanup;
       }
    }

    if(Size)
    {
        //
        // Based on the IP address, get the TC Interface.
        //

        PTC_IFC_DESCRIPTOR pCurrentIfc;
        ULONG              cIfcRemaining;

        for ( pCurrentIfc = pTcIfcBuffer, cIfcRemaining = Size;
              cIfcRemaining > 0;
              cIfcRemaining -= pCurrentIfc->Length, pCurrentIfc = ((PTC_IFC_DESCRIPTOR)((PBYTE)pCurrentIfc + 
                                                                                        pCurrentIfc->Length))
            )
        {
            PNETWORK_ADDRESS_LIST pAddressList = &pCurrentIfc->AddressListDesc.AddressList;
            PNETWORK_ADDRESS      pCurrentAddress;
            LONG                  iCurrentAddress;

            for ( iCurrentAddress = 0, pCurrentAddress = pAddressList->Address;
                  iCurrentAddress < pAddressList->AddressCount;
                  iCurrentAddress++, pCurrentAddress = ((PNETWORK_ADDRESS)((PBYTE) pCurrentAddress +
                                                                           FIELD_OFFSET(NETWORK_ADDRESS, Address)+
                                                                           pCurrentAddress->AddressLength))
                )
            {

                //
                // Make sure we've got the correct route
                //
                if ( pCurrentAddress!=0 &&
                     pCurrentAddress->AddressType == NDIS_PROTOCOL_ID_TCP_IP &&
                     ((PNETWORK_ADDRESS_IP)pCurrentAddress->Address)->in_addr == SrcAddr
                     )
                {
                   Status = TcOpenInterface(pCurrentIfc->pInterfaceName,
                                            hClientHandle,
                                            NULL,
                                            &hInterfaceHandle);
                   if(Status != ERROR_SUCCESS)
                   {
                      NlsPutMsg(STDOUT, PATHPING_TCOPENINTERFACE_FAILED, Status, pCurrentIfc->pInterfaceName);
                      goto QoSCleanup;
                   }
                   else
                   {
                      pTcFlowSpec = LocalAlloc(LMEM_FIXED, FIELD_OFFSET(TC_GEN_FLOW, TcObjects) + sizeof(QOS_TRAFFIC_CLASS)
                                               + sizeof(QOS_DS_CLASS));

                      if(pTcFlowSpec)
                      {
                         pTcFlowSpec->SendingFlowspec.TokenRate          = QOS_NOT_SPECIFIED;
                         pTcFlowSpec->SendingFlowspec.TokenBucketSize    = QOS_NOT_SPECIFIED;
                         pTcFlowSpec->SendingFlowspec.PeakBandwidth      = QOS_NOT_SPECIFIED;
                         pTcFlowSpec->SendingFlowspec.Latency            = QOS_NOT_SPECIFIED;
                         pTcFlowSpec->SendingFlowspec.DelayVariation     = QOS_NOT_SPECIFIED;
                         pTcFlowSpec->SendingFlowspec.MaxSduSize         = QOS_NOT_SPECIFIED;
                         pTcFlowSpec->SendingFlowspec.MinimumPolicedSize = QOS_NOT_SPECIFIED;
                         pTcFlowSpec->SendingFlowspec.ServiceType        = SERVICETYPE_BESTEFFORT;

                         pTcFlowSpec->ReceivingFlowspec.TokenRate          = QOS_NOT_SPECIFIED;
                         pTcFlowSpec->ReceivingFlowspec.TokenBucketSize    = QOS_NOT_SPECIFIED;
                         pTcFlowSpec->ReceivingFlowspec.PeakBandwidth      = QOS_NOT_SPECIFIED;
                         pTcFlowSpec->ReceivingFlowspec.Latency            = QOS_NOT_SPECIFIED;
                         pTcFlowSpec->ReceivingFlowspec.DelayVariation     = QOS_NOT_SPECIFIED;
                         pTcFlowSpec->ReceivingFlowspec.MaxSduSize         = QOS_NOT_SPECIFIED;
                         pTcFlowSpec->ReceivingFlowspec.MinimumPolicedSize = QOS_NOT_SPECIFIED;
                         pTcFlowSpec->ReceivingFlowspec.ServiceType        = SERVICETYPE_BESTEFFORT;

                         pTcFlowSpec->TcObjectsLength = sizeof(QOS_DS_CLASS) + sizeof(QOS_TRAFFIC_CLASS);

                         pTclass                         = (LPQOS_TRAFFIC_CLASS) (pTcFlowSpec->TcObjects);
                         pTclass->ObjectHdr.ObjectType   = QOS_OBJECT_TRAFFIC_CLASS;
                         pTclass->ObjectHdr.ObjectLength = sizeof(QOS_TRAFFIC_CLASS);
                         pTclass->TrafficClass           = PATHPING_QOS_TRAFFIC_CLASS;

                         pDclass                         = (LPQOS_DS_CLASS)((PCHAR)pTcFlowSpec->TcObjects + 
                                                                            sizeof(QOS_TRAFFIC_CLASS));
                         pDclass->ObjectHdr.ObjectType   = QOS_OBJECT_DS_CLASS;
                         pDclass->ObjectHdr.ObjectLength = sizeof(QOS_DS_CLASS);
                         pDclass->DSField                = PATHPING_QOS_DS_CLASS;

                         Status = TcAddFlow(
                                   hInterfaceHandle,
                                   NULL,
                                   0,
                                   pTcFlowSpec,
                                   &hFlowHandle);

                         if(Status != ERROR_SUCCESS)
                         {
                            NlsPutMsg(STDOUT, PATHPING_TCADDFLOW_FAILED, Status, pCurrentIfc->pInterfaceName);
                            goto QoSCleanup;
                         }
                         else 
                         {
                            TC_GEN_FILTER FilterSpec;
                            IP_PATTERN    IpPattern;
                            IP_PATTERN    IpMask;

                            FilterSpec.AddressType = NDIS_PROTOCOL_ID_TCP_IP;
                            FilterSpec.PatternSize = sizeof(IP_PATTERN);
                            FilterSpec.Pattern     = &IpPattern;
                            FilterSpec.Mask        = &IpMask;


                            memset (&IpPattern, 0,    sizeof(IP_PATTERN) );
                            memset (&IpMask,    0,    sizeof(IP_PATTERN) );
                            IpPattern.SrcAddr    = SrcAddr;
                            IpPattern.DstAddr    = DstAddr;
                            IpPattern.ProtocolId = 1;

                            IpMask.SrcAddr    = -1;
                            IpMask.DstAddr    = 0;
                            IpMask.ProtocolId = -1;

                            Status = TcAddFilter(hFlowHandle,
                                                 &FilterSpec,
                                                 &hFilterHandle);

                            if(Status != ERROR_SUCCESS)
                            {
                               NlsPutMsg(STDOUT, PATHPING_TCADDFILTER_FAILED, Status, pCurrentIfc->pInterfaceName);
                               goto QoSCleanup;
                            }

                            goto SendPings;
                         }
                      }
                      else 
                      {
                         NlsPutMsg(STDOUT, PATHPING_NO_RESOURCES);
                         goto QoSCleanup;
                      }
                   }
                }
            }
        }
        
        NlsPutMsg(STDOUT, PATHPING_NOTRAFFICINTERFACES);
        NlsPutMsg( STDOUT, PATHPING_ALIGN_IP_ADDRESS, inet_ntoa(*(struct in_addr *)&SrcAddr) );
        goto QoSCleanup;
    
    }
    else
    {
        NlsPutMsg(STDOUT, PATHPING_NOTRAFFICINTERFACES);

        goto QoSCleanup;
    }
    
SendPings:
    // Allocate memory for replies
    for (h=1; h<=ulHopCount; h++)
       hop[h].pReply = LocalAlloc(LMEM_FIXED, g_ulRcvBufSize);

    for (h=1; h<=ulHopCount; h++) 
    {
       NlsPutMsg( STDOUT, PATHPING_MESSAGE_4, h);

       NlsPutMsg( STDOUT, PATHPING_ALIGN_IP_ADDRESS, inet_ntoa(*(struct in_addr *)&hop[h].sinAddr.sin_addr.s_addr));

       numberOfReplies = IcmpSendEcho2( g_hIcmp,         // handle to icmp
                                        NULL,            // no event
                                        NULL,            // callback function
                                        NULL,
                                        hop[h].sinAddr.sin_addr.s_addr, // destination
                                        SendBuffer,
                                        DEFAULT_SEND_SIZE,
                                        NULL,
                                        hop[h].pReply,
                                        g_ulRcvBufSize,
                                        g_ulTimeout );

       if(numberOfReplies == 0)
       {
          Status = GetLastError();
          reply  = NULL;
       }
       else 
       {
          reply = hop[h].pReply4;
          Status = reply->Status;
       }

       if(Status == IP_SUCCESS)
       {
            NlsPutMsg(STDOUT, PATHPING_QOS_SUCCESS);
       }
       else 
       {
          if(Status == IP_REQ_TIMED_OUT) {
             NlsPutMsg(STDOUT, PATHPING_QOS_FAILURE);
             
          }
          else {
             if (Status < IP_STATUS_BASE) {
                NlsPutMsg(STDOUT, PATHPING_MESSAGE_7);
             }
             else {
                //
                // Fatal error.
                //
                NlsPutMsg(STDOUT, PATHPING_BAD_REQ);
             }
             
             goto QoSCleanup;
          }
 
       }
    }

QoSCleanup:

    for (h=1; h<=ulHopCount; h++)
    {
       if(hop[h].pReply)
          LocalFree(hop[h].pReply);
    }

    if(hFilterHandle)
    {
       TcDeleteFilter(hFilterHandle);
    }

    if(hFlowHandle)
    {
       TcDeleteFlow(hFlowHandle);
    }

    if(hInterfaceHandle)
    {
       TcCloseInterface(hInterfaceHandle);
    }

    if(hClientHandle)
    {
       TcDeregisterClient(hClientHandle);
    }

    if(pTcIfcBuffer)
       LocalFree(pTcIfcBuffer);

    if(pTcFlowSpec)
       LocalFree(pTcFlowSpec);

}
void QoSCheckRSVP(ULONG begin, ULONG end)
{
   WSADATA  wsaData;
   SOCKET   sockRaw;
   struct   sockaddr_in dest,from;
   struct   hostent * hp;
   int      bread,datasize;
   int      fromlen = sizeof(from);
   char     *buf, *dest_ip;
   char     *icmp_data;
   char     recvbuf[MAX_PACKET];
   unsigned int addr=0;
   USHORT   seq_no = 0;
   ULONG    h, bwrote;
   PULONG   pDestIp;
   SOCKET   sockIcmp;
   HANDLE   hRSVP, hICMP;
   HANDLE   hEvents[2];
   common_header *rsvphdr;
   ULONG    Status;
   Object_header *orisession = 0;

   hICMP = hRSVP = WSA_INVALID_EVENT;
   sockIcmp = sockRaw = INVALID_SOCKET;

   NlsPutMsg(STDOUT, PATHPING_RSVPAWAREHDR_MSG);

   do
   {

      if (WSAStartup(MAKEWORD(2,1),&wsaData) != 0)
      {
         NlsPutMsg(STDOUT, PATHPING_WSASTARTUP_FAILED, GetLastError());
         break;
      }

      if(WSA_INVALID_EVENT == (hRSVP = WSACreateEvent()))
      {
         NlsPutMsg(STDOUT, PATHPING_WSACREATEEVENT_FAILED, WSAGetLastError());
         break;
      }
      
      if(WSA_INVALID_EVENT == (hICMP = WSACreateEvent()))
      {
         NlsPutMsg(STDOUT, PATHPING_WSACREATEEVENT_FAILED, WSAGetLastError());
         break;
      }
   

      //
      // Open a socket for sending RSVP messages.
      //
      
      sockRaw = WSASocket (AF_INET,
                           SOCK_RAW,
                           46,
                           NULL, 0,0);
      
      if (sockRaw == INVALID_SOCKET) 
      {
         NlsPutMsg(STDOUT, PATHPING_WSASOCKET_FAILED, WSAGetLastError());
         break;
      }

      //
      // open a socket for receiving ICMP data
      //
      
      sockIcmp = WSASocket(AF_INET, SOCK_RAW, IPPROTO_ICMP, NULL, 0, 0);
      
      if(INVALID_SOCKET == sockIcmp)
      {
         NlsPutMsg(STDOUT, PATHPING_WSASOCKET_FAILED, WSAGetLastError());
         break;
      }

      if(WSAEventSelect(sockIcmp, hICMP, FD_READ) == SOCKET_ERROR)
      {
         NlsPutMsg(STDOUT, PATHPING_WSAEVENTSELECT_FAILED, WSAGetLastError());
         break;
      }

      if(SOCKET_ERROR == WSAEventSelect(sockRaw,  hRSVP, FD_READ|FD_WRITE))
      {
         NlsPutMsg(STDOUT, PATHPING_WSAEVENTSELECT_FAILED, WSAGetLastError());
         break;
      }

      hEvents[0] = hRSVP;
      hEvents[1] = hICMP;

      memset(&dest,0,sizeof(dest));
      dest.sin_family = AF_INET;

      memset(&from,0,sizeof(from));
      from.sin_family      = AF_INET;

      for(h=begin; h<=end; h++)
      {
          //
          // Bind the ICMP socket. The RSVP socket gets bound implicitly when we do a sendto.
          //
          
          from.sin_addr.s_addr = QoSGetSourceAddress(hop[h].sinAddr.sin_addr.s_addr);
          bind(sockIcmp, (struct sockaddr *)&from, sizeof(from));

          NlsPutMsg( STDOUT, PATHPING_MESSAGE_4, h);
          NlsPutMsg( STDOUT, PATHPING_ALIGN_IP_ADDRESS, inet_ntoa(*(struct in_addr *)&hop[h].sinAddr.sin_addr));

         dest.sin_addr.s_addr = hop[h].sinAddr.sin_addr.s_addr;

         //
         // Now, let's muck around with the RESV message so that it is destined to the dest_ip
         //
         buf = (PCHAR)RsvpResvMsg + sizeof(common_header);
         bwrote = 0;

         while(bwrote != 3)
         {
            
            Object_header *obj = (Object_header *)buf;

            switch(obj->obj_class)
            {
            case class_SESSION:
               orisession = obj; 
               pDestIp = (PULONG)((PCHAR)obj + sizeof(Object_header));
               *pDestIp = dest.sin_addr.s_addr;
               bwrote++;
               break;
               
            case class_RSVP_HOP:

               pDestIp = (PULONG)((PCHAR)obj + sizeof(Object_header));
               *pDestIp = from.sin_addr.s_addr;
               bwrote++;
               break;
            
            case class_FILTER_SPEC:
            
               pDestIp = (PULONG)((PCHAR)obj + sizeof(Object_header));
               *pDestIp = from.sin_addr.s_addr;
               bwrote++;
               break;
            }

            buf = (PCHAR)buf + ntohs(obj->obj_length);
            
         }

         // 
         // Recompute the RSVP checksum
         //
         rsvphdr = (common_header *) RsvpResvMsg;
         rsvphdr->rsvp_cksum = 0;
         rsvphdr->rsvp_cksum = in_cksum(RsvpResvMsg, ntohs(rsvphdr->rsvp_length));
  

         bwrote = sendto(sockRaw, 
                         RsvpResvMsg, 
                         sizeof(RsvpResvMsg), 
                         0, 
                         (struct sockaddr*)&dest, 
                         sizeof(dest));

         if (bwrote == SOCKET_ERROR)
         {
            NlsPutMsg(STDOUT, PATHPING_SENDTO_FAILED, WSAGetLastError());
            break;
         }

         //
         // Wait for ICMP protocol unreachable or a RESV-ERR message.
         //

         Status = WSAWaitForMultipleEvents(2,
                                           hEvents,
                                           FALSE,
                                           g_ulTimeout,
                                           TRUE);

         switch(Status)
         {

         case WSA_WAIT_FAILED:
            NlsPutMsg(STDOUT, PATHPING_WSAWAIT_FAILED,  WSAGetLastError());
            break;
 
         case WSA_WAIT_EVENT_0:

            bread = recvfrom(sockRaw,
                             recvbuf,
                             MAX_PACKET,
                             0,
                             (struct sockaddr*)&from,
                             &fromlen);

            if (bread == SOCKET_ERROR)
            {
               if (WSAGetLastError() == WSAETIMEDOUT) {
                  NlsPutMsg(STDOUT, PATHPING_REQ_TIMED_OUT);
                  continue;
               }
               NlsPutMsg(STDOUT, PATHPING_RECVFROM_FAILED, WSAGetLastError());
               break;
            }

            decode_msg(recvbuf, bread, &from, RSVP_MSG, orisession);
            WSAResetEvent(hRSVP);
            continue;
            
         case WSA_WAIT_EVENT_0+1:

            bread = recvfrom(sockIcmp, 
                             recvbuf, 
                             MAX_PACKET, 
                             0, 
                             (struct sockaddr *)&from, 
                             &fromlen);
            
            if(SOCKET_ERROR == bread) 
            {
               if (WSAGetLastError() == WSAETIMEDOUT) {
                  NlsPutMsg(STDOUT, PATHPING_REQ_TIMED_OUT);
                  continue;
               }
               NlsPutMsg(STDOUT, PATHPING_RECVFROM_FAILED, WSAGetLastError());
               break;
            }
            else 
            {
               decode_msg(recvbuf, bread, &from, ICMP_MSG, 0);
            }
            WSAResetEvent(hICMP);
            continue;

          case WSA_WAIT_TIMEOUT:
            NlsPutMsg(STDOUT, PATHPING_REQ_TIMED_OUT);
            continue;
         }

         break;
      }
   } while(0);

   if(hICMP != WSA_INVALID_EVENT) WSACloseEvent(hICMP);
   if(hRSVP != WSA_INVALID_EVENT) WSACloseEvent(hRSVP);

   WSACleanup();

}

void QoSDiagRSVP(ULONG begin, ULONG end, BOOLEAN RouterAlert)
{

#define RSVPPATH_STARTPORT 5555
   ULONG    port;
   WSADATA  wsaData;
   SOCKET   sockRaw;
   struct   sockaddr_in dest,from;
   struct   hostent * hp;
   int      bread,datasize;
   int      fromlen = sizeof(from);
   char     *buf, *dest_ip;
   char     *icmp_data;
   char     recvbuf[MAX_PACKET];
   unsigned int addr=0;
   USHORT   seq_no = 0;
   ULONG    len, h, bwrote;
   PULONG   pDestIp;
   SOCKET   sockIcmp;
   HANDLE   hICMP;
   HANDLE   hEvents[2];
   common_header *rsvphdr;
   ULONG    Status;
   Object_header *orisession = 0;
   static char szAllSBMMcastAddr[] = "224.0.0.17";

   hICMP = WSA_INVALID_EVENT;
   sockIcmp = sockRaw = INVALID_SOCKET;

   NlsPutMsg(STDOUT, PATHPING_RSVPCONNECT_MSG);

   do
   {

      if (WSAStartup(MAKEWORD(2,1),&wsaData) != 0)
      {
         NlsPutMsg(STDOUT, PATHPING_WSASTARTUP_FAILED, GetLastError());
         break;
      }
      
      if(WSA_INVALID_EVENT == (hICMP = WSACreateEvent()))
      {
         NlsPutMsg(STDOUT, PATHPING_WSACREATEEVENT_FAILED, GetLastError());
         break;
      }
      
      
      //
      // Open a socket for sending RSVP messages.
      //
      
      sockRaw = WSASocket (AF_INET,
                           SOCK_RAW,
                           46,
                           NULL, 0,0);
      
      if (sockRaw == INVALID_SOCKET) 
      {
         NlsPutMsg(STDOUT, PATHPING_WSASOCKET_FAILED, GetLastError());
         break;
      }
      
      //
      // open a socket for receiving ICMP data
      //
      
      sockIcmp = WSASocket(AF_INET, SOCK_RAW, IPPROTO_ICMP, NULL, 0, 0);
      
      if(INVALID_SOCKET == sockIcmp)
      {
         NlsPutMsg(STDOUT, PATHPING_WSASOCKET_FAILED, GetLastError());
         break;
      }

      if(WSAEventSelect(sockIcmp, hICMP, FD_READ) == SOCKET_ERROR)
      {
         NlsPutMsg(STDOUT, PATHPING_WSAEVENTSELECT_FAILED, WSAGetLastError());
         break;
      }

      hEvents[0] = hICMP;

      memset(&dest,0,sizeof(dest));
      dest.sin_family = AF_INET;

      memset(&from,0,sizeof(from));
      from.sin_family      = AF_INET;

      if(RouterAlert)
      {
          //
          // Add The RouterAlert option
          //
          Status = setsockopt( sockRaw,
                               IPPROTO_IP,
                               IP_OPTIONS,
                               (void *)Router_alert,
                               sizeof(Router_alert));
      }
          
      for(h=begin; h<=end; h++)
      {

         // We send out PATH messages with an expired TTL to each of the hops.
         // and wait for ICMP time exceeded message. Note that we have to change
         // the session every time. Otherwise, the first RSVP aware router will not
         // forward the PATH message, but rather trigger the PATH messages off its own
         // timer.

         //
         // Bind the ICMP socket. 
         //
         from.sin_addr.s_addr = QoSGetSourceAddress(hop[h].sinAddr.sin_addr.s_addr);
         bind(sockIcmp, (struct sockaddr *)&from, sizeof(from));

         //
         // Now, let's muck around with the PATH message so that it is destined to the dest_ip
         //
         
         buf = (PCHAR)RsvpPathMsg + sizeof(common_header);
         rsvphdr = (common_header *) RsvpPathMsg;
         rsvphdr->rsvp_snd_TTL = (uchar) h;
         len = ntohs(rsvphdr->rsvp_length) - sizeof(common_header);
         bwrote = 0;
         
         while(len > 0 && bwrote != 3)
         {
            
            Object_header *obj = (Object_header *)buf;
            
            switch(obj->obj_class)
            {
            case class_SESSION:
               {
                  SESSION *x = (SESSION *) obj;
                  // change the session in the message.
                  x->sess4_addr.s_addr =  hop[end].sinAddr.sin_addr.s_addr;

                  if(port == 0)
                  {
                     x->sess4_port = htons(RSVPPATH_STARTPORT);
                     port = RSVPPATH_STARTPORT;
                  }
                  else 
                  {
                     x->sess4_port =  htons((ushort)(ntohs(x->sess4_port) + 1));
                  }
                  bwrote++;
                  break;
               }
               
            case class_RSVP_HOP:
               {
                  RSVP_HOP *pRsvpHop = (RSVP_HOP *) obj;
                  pRsvpHop->hop4_addr = from.sin_addr;
                  bwrote++;
                  break;
               }
            
            case class_SENDER_TEMPLATE:
               {
                  SENDER_TEMPLATE *t = (SENDER_TEMPLATE *) obj;
                  t->filt_srcaddr = from.sin_addr;
                  bwrote++;
                  break;
               }
            }
    
            buf = (PCHAR)buf + ntohs(obj->obj_length);
            len -= ntohs(obj->obj_length);
            
         }
         
         // 
         // Recompute the RSVP checksum
         //
         rsvphdr = (common_header *) RsvpPathMsg;
         rsvphdr->rsvp_cksum = 0;
         rsvphdr->rsvp_cksum = in_cksum(RsvpPathMsg, ntohs(rsvphdr->rsvp_length));
         
         NlsPutMsg( STDOUT, PATHPING_MESSAGE_4, h);
         NlsPutMsg( STDOUT, PATHPING_ALIGN_IP_ADDRESS, inet_ntoa(*(struct in_addr *)&hop[h].sinAddr.sin_addr.s_addr));

         
         Status = setsockopt( sockRaw,
                              IPPROTO_IP,
                              IP_TTL,
                              (char *) &h,
                              sizeof(h) );
         
         dest.sin_addr.s_addr = hop[end].sinAddr.sin_addr.s_addr;
         bwrote = sendto(sockRaw, 
                         RsvpPathMsg, 
                         sizeof(RsvpPathMsg), 
                         0, 
                         (struct sockaddr*)&dest, 
                         sizeof(dest));
         
         if (bwrote == SOCKET_ERROR)
         {
            NlsPutMsg(STDOUT, PATHPING_SENDTO_FAILED, WSAGetLastError());
            break;
         }

         //
         // Wait for ICMP protocol unreachable or a RESV-ERR message.
         //
         
         Status = WSAWaitForMultipleEvents(1,
                                           hEvents,
                                           FALSE,
                                           g_ulTimeout,
                                           TRUE);
         
         switch(Status)
         {
            
         case WSA_WAIT_FAILED:
         
             NlsPutMsg(STDOUT, PATHPING_WSAWAIT_FAILED,  WSAGetLastError());
             break;
             
         case WSA_WAIT_EVENT_0:

             bread = recvfrom(sockIcmp, 
                              recvbuf, 
                              MAX_PACKET, 
                              0, 
                              (struct sockaddr *)&from, 
                              &fromlen);
             
             if(SOCKET_ERROR == bread) 
             {
                if (WSAGetLastError() == WSAETIMEDOUT) {
                   NlsPutMsg(STDOUT, PATHPING_REQ_TIMED_OUT);
                   continue;
                }
                NlsPutMsg(STDOUT, PATHPING_RECVFROM_FAILED, WSAGetLastError());
                break;
             }
             else 
             {
                decode_msg(recvbuf, bread, &from, ICMP_MSG, 0);
             }
             WSAResetEvent(hICMP);
             continue;
             
         case WSA_WAIT_TIMEOUT:
             NlsPutMsg(STDOUT, PATHPING_REQ_TIMED_OUT);
             continue;
         }
          
         break;
      }

      h      = 255;
      Status = setsockopt( sockRaw,
                           IPPROTO_IP,
                           IP_TTL,
                           (char *) &h,
                           sizeof(h) );
      
      for(h=begin; h<=end; h++)
      {
         // send PATH_TEAR for each of the sessions.

         from.sin_addr.s_addr = QoSGetSourceAddress(hop[h].sinAddr.sin_addr.s_addr);
         
         buf = (PCHAR)RsvpPathTearMsg + sizeof(common_header);
         rsvphdr = (common_header *) RsvpPathTearMsg;
         len = ntohs(rsvphdr->rsvp_length) - sizeof(common_header);
         bwrote = 0;
         
         while(len > 0 && bwrote != 3)
         {
            
            Object_header *obj = (Object_header *)buf;
            
            switch(obj->obj_class)
            {
            case class_SESSION:
               {
                  SESSION *x = (SESSION *) obj;
                  // change the session in the message.
                  x->sess4_addr.s_addr =  hop[end].sinAddr.sin_addr.s_addr;
                  if(port == RSVPPATH_STARTPORT)
                  {
                     port = 0;
                     x->sess4_port = htons(RSVPPATH_STARTPORT);
                  }
                  else 
                  {
                     x->sess4_port =  htons((ushort)(ntohs(x->sess4_port) + 1));
                  }
                  bwrote++;
                  break;
               }
               
            case class_RSVP_HOP:
               {
                  RSVP_HOP *pRsvpHop = (RSVP_HOP *) obj;
                  pRsvpHop->hop4_addr = from.sin_addr;
                  bwrote++;
                  break;
               }
            
            case class_SENDER_TEMPLATE:
               {
                  SENDER_TEMPLATE *t = (SENDER_TEMPLATE *) obj;
                  t->filt_srcaddr = from.sin_addr;
                  bwrote++;
                  break;
               }
            }
    
            buf = (PCHAR)buf + ntohs(obj->obj_length);
            len -= ntohs(obj->obj_length);
            
         }
         
         // 
         // Recompute the RSVP checksum
         //
         rsvphdr = (common_header *) RsvpPathTearMsg;
         rsvphdr->rsvp_cksum = 0;
         rsvphdr->rsvp_cksum = in_cksum(RsvpPathTearMsg, ntohs(rsvphdr->rsvp_length));

        
         dest.sin_addr.s_addr = hop[end].sinAddr.sin_addr.s_addr;
         bwrote = sendto(sockRaw, 
                         RsvpPathTearMsg, 
                         sizeof(RsvpPathTearMsg), 
                         0, 
                         (struct sockaddr*)&dest, 
                         sizeof(dest));
         
         if (bwrote == SOCKET_ERROR)
         {
            NlsPutMsg(STDOUT, PATHPING_SENDTO_FAILED, WSAGetLastError());
            break;
         }
         
      }
      
      
      
   } while(0);
   
   if(hICMP != WSA_INVALID_EVENT) WSACloseEvent(hICMP);
   
   WSACleanup();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\commands\tracert\tracert.c ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    tracert.c

Abstract:

    TraceRoute utility for TCP/IP.

Author:

    Numerous TCP/IP folks.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------

Notes:

--*/

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <time.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <snmp.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <ntddip6.h>
#include <winnlsp.h>
#include <iphlpapi.h>

#include "llinfo.h"
#include "tcpcmd.h"
#include "ipexport.h"
#include "icmpapi.h"
#include "nlstxt.h"


#define DEFAULT_MAXIMUM_HOPS        30
#define DEFAULT_TOS                 0
#define DEFAULT_FLAGS               0
#define DEFAULT_SEND_SIZE 64
#define DEFAULT_RECEIVE_SIZE      ( (sizeof(ICMP_ECHO_REPLY) +    \
                                    DEFAULT_SEND_SIZE +           \
                                    MAX_OPT_SIZE))

#define DEFAULT_TOS     0
#define DEFAULT_TIMEOUT 4000L
#define MIN_INTERVAL    1000L

#define STDOUT          1

char     SendBuffer[DEFAULT_SEND_SIZE];
char     RcvBuffer[DEFAULT_RECEIVE_SIZE];
WSADATA  WsaData;


struct IPErrorTable {
    IP_STATUS   Error;                      // The IP Error
    DWORD       ErrorNlsID;                 // The corresponding NLS string ID.
} ErrorTable[] =
{
    { IP_BUF_TOO_SMALL,           TRACERT_BUF_TOO_SMALL            },
    { IP_DEST_NET_UNREACHABLE,    TRACERT_DEST_NET_UNREACHABLE     },
    { IP_DEST_HOST_UNREACHABLE,   TRACERT_DEST_HOST_UNREACHABLE    },
    { IP_DEST_PROT_UNREACHABLE,   TRACERT_DEST_PROT_UNREACHABLE    },
    { IP_DEST_PORT_UNREACHABLE,   TRACERT_DEST_PORT_UNREACHABLE    },
    { IP_NO_RESOURCES,            TRACERT_NO_RESOURCES             },
    { IP_BAD_OPTION,              TRACERT_BAD_OPTION               },
    { IP_HW_ERROR,                TRACERT_HW_ERROR                 },
    { IP_PACKET_TOO_BIG,          TRACERT_PACKET_TOO_BIG           },
    { IP_REQ_TIMED_OUT,           TRACERT_REQ_TIMED_OUT            },
    { IP_BAD_REQ,                 TRACERT_BAD_REQ                  },
    { IP_BAD_ROUTE,               TRACERT_BAD_ROUTE                },
    { IP_TTL_EXPIRED_TRANSIT,     TRACERT_TTL_EXPIRED_TRANSIT      },
    { IP_TTL_EXPIRED_REASSEM,     TRACERT_TTL_EXPIRED_REASSEM      },
    { IP_PARAM_PROBLEM,           TRACERT_PARAM_PROBLEM            },
    { IP_SOURCE_QUENCH,           TRACERT_SOURCE_QUENCH            },
    { IP_OPTION_TOO_BIG,          TRACERT_OPTION_TOO_BIG           },
    { IP_BAD_DESTINATION,         TRACERT_BAD_DESTINATION          },
    { IP_NEGOTIATING_IPSEC,       TRACERT_NEGOTIATING_IPSEC        },
    { IP_GENERAL_FAILURE,         TRACERT_GENERAL_FAILURE          }
};

PWCHAR
GetErrorString(int ErrorCode)
{
    DWORD Status;
    DWORD Length;
    static WCHAR ErrorString[2048]; // a 2K static buffer should suffice

    Length = 2048;
    Status = GetIpErrorString(ErrorCode, ErrorString, &Length);

    if (Status == NO_ERROR) {
        return ErrorString;     // success
    }

    return L"";                 // return a null string
}

unsigned
NlsPutMsg(unsigned Handle, unsigned usMsgNum, ... )
{
    unsigned msglen;
    VOID * vp;
    va_list arglist;

    DWORD StrLen;

    va_start(arglist, usMsgNum);
    if (!(msglen = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
          FORMAT_MESSAGE_FROM_HMODULE,
          NULL,
          usMsgNum,
          0L,       // Default country ID.
          (LPTSTR)&vp,
          0,
          &arglist)))
    return(0);

    // Convert vp to oem
    StrLen=strlen(vp);
    CharToOemBuff((LPCTSTR)vp,(LPSTR)vp,StrLen);

    msglen = _write(Handle, vp, StrLen);
    LocalFree(vp);

    return(msglen);
}


unsigned long
str2ip(char *addr)
{
    char    *endptr;
    int     i;      // Counter variable.
    unsigned long curaddr = 0;
    unsigned long temp;


    for (i = 0; i < 4; i++) {
        temp = strtoul(addr, &endptr, 10);
        if (temp > 255)
            return 0L;
        if (endptr[0] != '.')
            if (i != 3)
                return 0L;
            else
                if (endptr[0] != '\0' && endptr[0] != ' ')
                    return 0L;
        addr = endptr+1;
        curaddr = (curaddr << 8) + temp;
    }

    return net_long(curaddr);
}

void
print_addr(SOCKADDR *sa, socklen_t salen, BOOLEAN DoReverseLookup)
{
    char             hostname[NI_MAXHOST];
    int              i;
    BOOLEAN          didReverse = FALSE;

    if (DoReverseLookup) {
        i = getnameinfo(sa, salen, hostname, sizeof(hostname),
                        NULL, 0, NI_NAMEREQD);

        if (i == NO_ERROR) {
            didReverse = TRUE;
            NlsPutMsg(STDOUT, TRACERT_TARGET_NAME, hostname);
        }
    }

    i = getnameinfo(sa, salen, hostname, sizeof(hostname),
                    NULL, 0, NI_NUMERICHOST);

    if (i != NO_ERROR) {
       // This should never happen unless there is a memory problem,
       // in which case the message associated with TRACERT_NO_RESOURCES
       // is reasonable.
       NlsPutMsg(STDOUT, TRACERT_NO_RESOURCES);
       exit (1);
    }

    if (didReverse) {
        NlsPutMsg( STDOUT, TRACERT_BRKT_IP_ADDRESS, hostname );
    } else {
        NlsPutMsg( STDOUT, TRACERT_IP_ADDRESS, hostname );
    }
}


void
print_ip_addr(IPAddr ipv4Addr, BOOLEAN DoReverseLookup)
{
    SOCKADDR_IN sin;

    memset(&sin, 0, sizeof(sin));
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = ipv4Addr;

    print_addr((LPSOCKADDR)&sin, sizeof(sin), DoReverseLookup);
}


void
print_ipv6_addr(IN6_ADDR *ipv6Addr, BOOLEAN DoReverseLookup)
{
    SOCKADDR_IN6 sin;

    memset(&sin, 0, sizeof(sin));
    sin.sin6_family = AF_INET6;
    memcpy(&sin.sin6_addr, ipv6Addr, sizeof(sin.sin6_addr));

    print_addr((LPSOCKADDR)&sin, sizeof(sin), DoReverseLookup);
}


void
print_time(ulong Time)
{
    if (Time) {
        NlsPutMsg( STDOUT, TRACERT_TIME, Time );
    }
    else {
        NlsPutMsg( STDOUT, TRACERT_TIME_10MS );
    }
}


BOOLEAN
param(
    ulong *parameter,
    char **argv,
    int argc,
    int current,
    ulong min,
    ulong max
    )
{
    ulong   temp;
    char    *dummy;

    if (current == (argc - 1) ) {
        NlsPutMsg( STDOUT, TRACERT_NO_OPTION_VALUE, argv[current] );
        return(FALSE);
    }

    temp = strtoul(argv[current+1], &dummy, 0);
    if (temp < min || temp > max) {
        NlsPutMsg( STDOUT, TRACERT_BAD_OPTION_VALUE, argv[current] );
        return(FALSE);
    }

    *parameter = temp;

    return(TRUE);
}


BOOLEAN
ResolveTarget(
    int           Family,
    char         *TargetString,
    SOCKADDR     *TargetAddress,
    socklen_t    *TargetAddressLen,
    char         *TargetName,
    int           TargetNameLen,
    BOOLEAN       DoReverseLookup
    )
{
    int              i;
    struct addrinfo  hints, *ai;

    TargetName[0] = '\0';

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = Family;
    hints.ai_flags = AI_NUMERICHOST;
    i = getaddrinfo(TargetString, NULL, &hints, &ai);
    if (i == NO_ERROR) {
        *TargetAddressLen = ai->ai_addrlen;
        memcpy(TargetAddress, ai->ai_addr, ai->ai_addrlen);

        if (DoReverseLookup) {
            getnameinfo(ai->ai_addr, ai->ai_addrlen,
                        TargetName, TargetNameLen,
                        NULL, 0, NI_NAMEREQD);
        }

        freeaddrinfo(ai);
        return(TRUE);
    } else {
        hints.ai_flags = AI_CANONNAME;
        if (getaddrinfo(TargetString, NULL, &hints, &ai) == 0) {
            *TargetAddressLen = ai->ai_addrlen;
            memcpy(TargetAddress, ai->ai_addr, ai->ai_addrlen);
            strcpy(TargetName,
                   (ai->ai_canonname)? ai->ai_canonname : TargetString);
            freeaddrinfo(ai);
            return(TRUE);
        }
    }

    return(FALSE);

} // ResolveTarget

int
GetSource(int family, char *astr, struct sockaddr *address)
{
    struct addrinfo hints;
    struct addrinfo *result;

    memset(&hints, 0, sizeof hints);
    hints.ai_flags = AI_PASSIVE;
    hints.ai_family = family;

    if (getaddrinfo(astr, NULL, &hints, &result) != 0)
        return FALSE;

    RtlCopyMemory(address, result->ai_addr, result->ai_addrlen);
    return TRUE;
}

BOOLEAN
SetFamily(DWORD *Family, DWORD Value, char *arg)
{
    if ((*Family != AF_UNSPEC) && (*Family != Value)) {
        NlsPutMsg(STDOUT, TRACERT_INVALID_SWITCH, arg);        
        // NlsPutMsg(STDOUT, TRACERT_FAMILY, arg,
        // (Value==AF_INET)? "IPv4" : "IPv6");
        return FALSE;
    }

    *Family = Value;
    return TRUE;
}

int __cdecl
main(int argc, char **argv)
{
    SOCKADDR_STORAGE      address, sourceAddress;
    socklen_t             addressLen;
    IPAddr                reply4Address;
    IN6_ADDR              reply6Address;
    DWORD                 numberOfReplies;
    HANDLE                IcmpHandle;
    DWORD                 status;
    PICMP_ECHO_REPLY      reply4;
    PICMPV6_ECHO_REPLY    reply6;
    char                  hostname[NI_MAXHOST], literal[INET6_ADDRSTRLEN];
    char                 *arg;
    int                   i;
    ulong                 maximumHops = DEFAULT_MAXIMUM_HOPS;
    BOOLEAN               doReverseLookup = TRUE;
    IP_OPTION_INFORMATION options;
    char                  optionsData[MAX_OPT_SIZE];
    char                 *optionPtr;
    uchar                 currentIndex;
    IPAddr                tempAddr;
    uchar                 j;
    uchar                 SRIndex = 0;
    ulong                 timeout = DEFAULT_TIMEOUT;
    BOOLEAN               foundAddress = FALSE;
    BOOLEAN               haveReply;
    DWORD                 Family = AF_UNSPEC;

    //
    // This will ensure the correct language message is displayed when
    // NlsPutMsg is called.
    //
    SetThreadUILanguage(0);

    if (WSAStartup(MAKEWORD(2, 0), &WsaData)) {
        NlsPutMsg(STDOUT, TRACERT_WSASTARTUP_FAILED, GetLastError());
        return(1);
    }

    memset(&sourceAddress, 0, sizeof sourceAddress);

    options.Ttl = 1;
    options.Tos = DEFAULT_TOS;
    options.Flags = DEFAULT_FLAGS;
    options.OptionsSize = 0;
    options.OptionsData = optionsData;

    if (argc < 2) {
        NlsPutMsg( STDOUT, TRACERT_USAGE, argv[0] );
        goto error_exit;
    }

    //
    // process command line
    //
    for (i=1; i < argc; i++) {
        arg = argv[i];

        if ((arg[0] == '-') || (arg[0] == '/')) {
            switch(arg[1]) {
            case '?':
                NlsPutMsg(STDOUT, TRACERT_USAGE, argv[0]);
                goto error_exit;

            case 'd':
                doReverseLookup = FALSE;
                break;

            case 'h':
                if (!param(&maximumHops, argv, argc, i++, 1, 255)) {
                    goto error_exit;
                }
                break;

            case 'j':   // Loose source routing
                // Only implemented for IPv4 so far
                if (!SetFamily(&Family, AF_INET, arg)) {
                    goto error_exit;
                }

                currentIndex = options.OptionsSize;

                if ((currentIndex + 7) > MAX_OPT_SIZE) {
                    NlsPutMsg(STDOUT, TRACERT_TOO_MANY_OPTIONS);
                    goto error_exit;
                }

                optionPtr = options.OptionsData;
                optionPtr[currentIndex] = (char) IP_OPT_LSRR;
                optionPtr[currentIndex+1] = 3;
                optionPtr[currentIndex+2] = 4;  // Set initial pointer value
                options.OptionsSize += 3;

                while ( (i < (argc - 2)) && (*argv[i+1] != '-')) {
                    if ((currentIndex + 7) > MAX_OPT_SIZE) {
                        NlsPutMsg(STDOUT, TRACERT_TOO_MANY_OPTIONS);
                        goto error_exit;
                    }

                    arg = argv[++i];
                    tempAddr = inet_addr(arg);

                    if (tempAddr == INADDR_NONE) {
                        NlsPutMsg(
                            STDOUT,
                            TRACERT_BAD_ROUTE_ADDRESS,
                            arg
                            );
                        goto error_exit;
                    }

                    j = optionPtr[currentIndex+1];
                    *(ulong UNALIGNED *)&optionPtr[j+currentIndex] = tempAddr;
                    optionPtr[currentIndex+1] += 4;
                    options.OptionsSize += 4;
                }

                SRIndex = optionPtr[currentIndex+1] + currentIndex;
                optionPtr[currentIndex+1] += 4;   // Save space for dest. addr
                options.OptionsSize += 4;
                break;


            case 'w':
                if (!param(&timeout, argv, argc, i++, 1, 0xffffffff)) {
                    goto error_exit;
                }
                break;

            case 'R':
                // Only implemented for IPv6 so far
                if (!SetFamily(&Family, AF_INET6, arg)) {
                    goto error_exit;
                }
                options.Flags |= ICMPV6_ECHO_REQUEST_FLAG_REVERSE;
                break;

            case 'S':
                // Only implemented for IPv6 so far
                if (!SetFamily(&Family, AF_INET6, arg)) {
                    goto error_exit;
                }

                if (!GetSource(Family, argv[++i], (LPSOCKADDR)&sourceAddress)) {
                    NlsPutMsg(STDOUT, TRACERT_BAD_OPTION_VALUE, arg[1]);
                    // NlsPutMsg(STDOUT, TRACERT_BAD_ADDRESS, argv[i]);
                    goto error_exit;
                }
                break;

            case '4':
                if (!SetFamily(&Family, AF_INET, arg)) {
                    goto error_exit;
                }
                break;

            case '6':
                if (!SetFamily(&Family, AF_INET6, arg)) {
                    goto error_exit;
                }
                break;

            default:
                NlsPutMsg(STDOUT, TRACERT_INVALID_SWITCH, argv[i]);
                NlsPutMsg(STDOUT, TRACERT_USAGE);
                goto error_exit;
                break;

            }
        }
        else {
            foundAddress = TRUE;
            if (!ResolveTarget(Family, argv[i], (LPSOCKADDR)&address, 
                               &addressLen, hostname, sizeof(hostname),
                               doReverseLookup)) {
                NlsPutMsg( STDOUT, TRACERT_MESSAGE_1, argv[i] );
                goto error_exit;
            }
        }
    }

    if (!foundAddress) {
        NlsPutMsg(STDOUT, TRACERT_NO_ADDRESS);
        NlsPutMsg(STDOUT, TRACERT_USAGE);
        goto error_exit;
    }

    Family = address.ss_family;
    if (Family == AF_INET) {
        if (SRIndex != 0) {
            *(ulong UNALIGNED *)&options.OptionsData[SRIndex] = ((LPSOCKADDR_IN)&address)->sin_addr.s_addr;
        }

        IcmpHandle = IcmpCreateFile();
    } else {
        if (sourceAddress.ss_family == AF_UNSPEC) {
            SOCKET s;
            DWORD BytesReturned;
    
            //
            // A source address was not specified.
            // Get the preferred source address for this destination.
            //
            // If you want each individual echo request
            // to select a source address, use "-S ::".
            //
    
            s = socket(address.ss_family, 0, 0);
            if (s == INVALID_SOCKET) {
                NlsPutMsg(STDOUT, TRACERT_WSASTARTUP_FAILED, WSAGetLastError());
                // NlsPutMsg(STDOUT, TRACERT_SOCKET_FAILED, WSAGetLastError());
                exit(1);
            }
    
            (void) WSAIoctl(s, SIO_ROUTING_INTERFACE_QUERY,
                            &address, sizeof address,
                            &sourceAddress, sizeof sourceAddress,
                            &BytesReturned, NULL, NULL);
    
            closesocket(s);
        }

        IcmpHandle = Icmp6CreateFile();
    }

    if (IcmpHandle == INVALID_HANDLE_VALUE) {
        status = GetLastError();
        NlsPutMsg( STDOUT, TRACERT_MESSAGE_2, status );
        goto error_exit;
    }

    getnameinfo((LPSOCKADDR)&address, addressLen, literal, sizeof(literal),
                NULL, 0, NI_NUMERICHOST);

    if (hostname[0]) {
        NlsPutMsg(
            STDOUT,
            TRACERT_HEADER1,
            hostname,
            literal,
            maximumHops
            );
    }
    else {
        NlsPutMsg(
            STDOUT,
            TRACERT_HEADER2,
            literal,
            maximumHops
            );
    }


    while((options.Ttl <= maximumHops) && (options.Ttl != 0)) {

        NlsPutMsg( STDOUT, TRACERT_MESSAGE_4, (uint)options.Ttl );

        haveReply = FALSE;

        for (i=0; i<3; i++) {

            BOOLEAN ErrorNotHandled = FALSE;
            
            if (Family == AF_INET) {
                numberOfReplies = IcmpSendEcho2(
                                      IcmpHandle,
                                      0,
                                      NULL,
                                      NULL,
                                      ((LPSOCKADDR_IN)&address)->sin_addr.s_addr,
                                      SendBuffer,
                                      DEFAULT_SEND_SIZE,
                                      &options,
                                      RcvBuffer,
                                      DEFAULT_RECEIVE_SIZE,
                                      timeout
                                      );
    
                if (numberOfReplies == 0) {
                    // We did not get any replies.  This is possibly a timeout,
                    // or an internal error to IP.
                    //
                    status = GetLastError();
                    reply4 = NULL;
                    
                    if (status == IP_REQ_TIMED_OUT) {
                        NlsPutMsg(STDOUT, TRACERT_NO_REPLY_TIME);
                        if (i == 2) {
                            if (haveReply) {
                                print_ip_addr(
                                    reply4Address,
                                    doReverseLookup
                                    );
                                NlsPutMsg(STDOUT, TRACERT_CR);
                            }
                            else {
                                NlsPutMsg( STDOUT, TRACERT_REQ_TIMED_OUT);
                            }
                        }
                    } 
                    else {
                        ErrorNotHandled = TRUE;
                    }
                }
                else {
                    // We got a reply.  It's either for the final destination
                    // (IP_SUCCESS), or because the TTL expired at a node along
                    // the way, or we got an unexpected error response.
                    //
                    reply4 = (PICMP_ECHO_REPLY) RcvBuffer;
                    status = reply4->Status;
    
                    if (status == IP_SUCCESS) {
                        print_time(reply4->RoundTripTime);
        
                        if (i == 2) {
                            print_ip_addr(
                                reply4->Address,
                                doReverseLookup
                                );
                            NlsPutMsg(STDOUT, TRACERT_CR);
                            goto loop_end;
                        }
                        else {
                            haveReply = TRUE;
                            reply4Address = reply4->Address;
                        }
                    }
                    else if (status == IP_TTL_EXPIRED_TRANSIT) {
                        print_time(reply4->RoundTripTime);
    
                        if (i == 2) {
                            print_ip_addr(
                                reply4->Address,
                                doReverseLookup
                                );
                            NlsPutMsg(STDOUT, TRACERT_CR);
    
                            if (reply4->RoundTripTime < MIN_INTERVAL) {
                                Sleep(MIN_INTERVAL - reply4->RoundTripTime);
                            }
                        }
                        else {
                            haveReply = TRUE;
                            reply4Address = reply4->Address;
                        }
                    }
                    else {
                        ErrorNotHandled = TRUE;
                    }
                }

                // If we've not handled the status code by now, it represents
                // an unexpected fatal error and we'll now bail out.
                //
                if (ErrorNotHandled) {
                    if (status < IP_STATUS_BASE) {
                        NlsPutMsg( STDOUT, TRACERT_MESSAGE_7, status );
                    }
                    else {
                        if (reply4 != NULL) {
                            print_ip_addr(
                                reply4->Address,
                                doReverseLookup
                                );
    
                            NlsPutMsg( STDOUT, TRACERT_MESSAGE_6 );
                        }
    
                        for (i = 0;
                             ( ErrorTable[i].Error != status &&
                               ErrorTable[i].Error != IP_GENERAL_FAILURE
                             );
                             i++
                            );
    
                        NlsPutMsg( STDOUT, ErrorTable[i].ErrorNlsID );
                    }
    
                    goto loop_end;
                }
            } 
            else { // AF_INET6
                numberOfReplies = Icmp6SendEcho2(
                                      IcmpHandle,
                                      0,
                                      NULL,
                                      NULL,
                                      (LPSOCKADDR_IN6)&sourceAddress,
                                      (LPSOCKADDR_IN6)&address,
                                      SendBuffer,
                                      DEFAULT_SEND_SIZE,
                                      &options,
                                      RcvBuffer,
                                      DEFAULT_RECEIVE_SIZE,
                                      timeout
                                      );
    
                if (numberOfReplies == 0) {
                    // We did not get any replies.  This is possibly a timeout,
                    // or an internal error to IP.
                    //
                    status = GetLastError();
                    reply6 = NULL;
                    
                    if (status == IP_REQ_TIMED_OUT) {
                        NlsPutMsg(STDOUT, TRACERT_NO_REPLY_TIME);
                        if (i == 2) {
                            if (haveReply) {
                                print_ipv6_addr(
                                    &reply6Address,
                                    doReverseLookup
                                    );
                                NlsPutMsg(STDOUT, TRACERT_CR);
                            }
                            else {
                                NlsPutMsg( STDOUT, TRACERT_REQ_TIMED_OUT);
                            }
                        }
                    } 
                    else {
                        ErrorNotHandled = TRUE;
                    }
                }
                else {
                    // We got a reply.  It's either for the final destination
                    // (IP_SUCCESS), or because the TTL expired at a node along
                    // the way, or we got an unexpected error response.
                    //
                    reply6 = (PICMPV6_ECHO_REPLY) RcvBuffer;
                    status = reply6->Status;
    
                    if (status == IP_SUCCESS) {
                        print_time(reply6->RoundTripTime);
        
                        if (i == 2) {
                            print_ipv6_addr(
                                (IN6_ADDR*)&reply6->Address.sin6_addr,
                                doReverseLookup
                                );
                            NlsPutMsg(STDOUT, TRACERT_CR);
                            goto loop_end;
                        }
                        else {
                            haveReply = TRUE;
                            RtlCopyMemory(&reply6Address,
                                          &reply6->Address.sin6_addr,
                                          sizeof(IN6_ADDR));
                        }
                    }
                    else if (status == IP_HOP_LIMIT_EXCEEDED) {
                        print_time(reply6->RoundTripTime);
    
                        if (i == 2) {
                            print_ipv6_addr(
                                (IN6_ADDR*)&reply6->Address.sin6_addr,
                                doReverseLookup
                                );
                            NlsPutMsg(STDOUT, TRACERT_CR);
    
                            if (reply6->RoundTripTime < MIN_INTERVAL) {
                                Sleep(MIN_INTERVAL - reply6->RoundTripTime);
                            }
                        }
                        else {
                            haveReply = TRUE;
                            RtlCopyMemory(&reply6Address,
                                          &reply6->Address.sin6_addr,
                                          sizeof(IN6_ADDR));
                        }
                    }
                    else {
                        ErrorNotHandled = TRUE;
                    }
                }

                // If we've not handled the status code by now, it represents
                // an unexpected fatal error and we'll now bail out.
                //
                if (ErrorNotHandled) {
                    if (status < IP_STATUS_BASE) {
                        NlsPutMsg( STDOUT, TRACERT_MESSAGE_7, status );
                    }
                    else {
                        if (reply6 != NULL) {
                            print_ipv6_addr(
                                (IN6_ADDR*)&reply6->Address.sin6_addr,
                                doReverseLookup
                                );
    
                            NlsPutMsg( STDOUT, TRACERT_MESSAGE_6 );
                        }
    
                        for (i = 0;
                             ( ErrorTable[i].Error != status &&
                               ErrorTable[i].Error != IP_GENERAL_FAILURE
                             );
                             i++
                            );
    
                        NlsPutMsg( STDOUT, ErrorTable[i].ErrorNlsID );
                    }
    
                    goto loop_end;
                }
            }
        }

        options.Ttl++;
    }

loop_end:

    NlsPutMsg( STDOUT, TRACERT_MESSAGE_8 );

    IcmpCloseHandle(IcmpHandle);

    WSACleanup();
    return(0);

error_exit:

    WSACleanup();
    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\common\fsbpool.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    fsbpool.c

Abstract:

    This file contains the implementation of fixed-size block pool.

Author:

    Shaun Cox (shaunco) 10-Dec-1999

--*/

#include "ntddk.h"
#include "fsbpool.h"

#define FSB_SCAVENGE_PERIOD_IN_SECONDS          30
#define FSB_MINIMUM_PAGE_LIFETIME_IN_SECONDS    20

#if defined (_WIN64)
#define MAX_CACHE_LINE_SIZE 128
#else
#define MAX_CACHE_LINE_SIZE 64
#endif

// The following structures are used in the single allocation that
// a pool handle points to.
//      PoolHandle ---> [FSB_POOL_HEADER + FSB_CPU_POOL_HEADER for cpu 0 +
//                                         FSB_CPU_POOL_HEADER for cpu 1 + ...
//                                         FSB_CPU_POOL_HEADER for cpu N]
//

// FSB_POOL_HEADER is the data common to all CPUs for a given pool.
//
typedef struct _FSB_POOL_HEADER
{
// cache-line -----
    struct _FSB_POOL_HEADER_BASE
    {
        ULONG Tag;
        USHORT CallerBlockSize;     // caller's requested block size
        USHORT AlignedBlockSize;    // ALIGN_UP(CallerBlockSize, PVOID)
        USHORT BlocksPerPage;
        USHORT FreeBlockLinkOffset;
        PFSB_BUILDBLOCK_FUNCTION BuildFunction;
    };
    UCHAR Alignment[MAX_CACHE_LINE_SIZE
            - (sizeof(struct _FSB_POOL_HEADER_BASE) % MAX_CACHE_LINE_SIZE)];
} FSB_POOL_HEADER, *PFSB_POOL_HEADER;

C_ASSERT(sizeof(FSB_POOL_HEADER) % MAX_CACHE_LINE_SIZE == 0);


// FSB_CPU_POOL_HEADER is the data specific to a CPU for a given pool.
//
typedef struct _FSB_CPU_POOL_HEADER
{
// cache-line -----
    struct _FSB_CPU_POOL_HEADER_BASE
    {
        // The doubly-linked list of pages that make up this processor's pool.
        // These pages have one or more free blocks available.
        //
        LIST_ENTRY PageList;

        // The doubly-linked list of pages that are fully in use.  This list
        // is separate from the above list so that we do not spend time walking
        // a very long list during FsbAllocate when many pages are fully used.
        //
        LIST_ENTRY UsedPageList;

        // The next scheduled time (in units of KeQueryTickCount()) for
        // scavenging this pool.  The next scavenge will happen no earlier
        // that this.
        //
        LARGE_INTEGER NextScavengeTick;

        // The number of the processor that owns this pool.
        //
        ULONG OwnerCpu;

        ULONG TotalBlocksAllocated;
        ULONG TotalBlocksFreed;
        ULONG PeakBlocksInUse;
        ULONG TotalPagesAllocated;
        ULONG TotalPagesFreed;
        ULONG PeakPagesInUse;
    };
    UCHAR Alignment[MAX_CACHE_LINE_SIZE
            - (sizeof(struct _FSB_CPU_POOL_HEADER_BASE) % MAX_CACHE_LINE_SIZE)];
} FSB_CPU_POOL_HEADER, *PFSB_CPU_POOL_HEADER;

C_ASSERT(sizeof(FSB_CPU_POOL_HEADER) % MAX_CACHE_LINE_SIZE == 0);


// FSB_PAGE_HEADER is the data at the beginning of each allocated pool page
// that describes the current state of the blocks on the page.
//
typedef struct _FSB_PAGE_HEADER
{
// cache-line -----
    // Back pointer to the owning cpu pool.
    //
    PFSB_CPU_POOL_HEADER Pool;

    // Linkage entry for the list of pages managed by the cpu pool.
    //
    LIST_ENTRY PageLink;

    // Number of blocks built so far on this page.  Blocks are built on
    // demand.  When this number reaches Pool->BlocksPerPage, all blocks on
    // this page have been built.
    //
    USHORT BlocksBuilt;

    // Boolean indicator of whether or not this page is on the cpu pool's
    // used-page list.  This is checked during MdpFree to see if the page
    // should be moved back to the normal page list.
    // (it is a USHORT, instead of BOOLEAN, for proper padding)
    //
    USHORT OnUsedPageList;

    // List of free blocks on this page.
    //
    SLIST_HEADER FreeList;

    // The value of KeQueryTickCount (normalized to units of seconds)
    // which represents the time after which this page can be freed back
    // to the system's pool.  This time is only valid if the depth of
    // FreeList is Pool->BlocksPerPage.  (i.e. this time is only valid if
    // the page is completely unused.)
    //
    LARGE_INTEGER LastUsedTick;

} FSB_PAGE_HEADER, *PFSB_PAGE_HEADER;

// Get a pointer to the overall pool given a pointer to one of
// the per-processor pools within it.
//
__inline
PFSB_POOL_HEADER
PoolFromCpuPool(
    IN PFSB_CPU_POOL_HEADER CpuPool
    )
{
    return (PFSB_POOL_HEADER)(CpuPool - CpuPool->OwnerCpu) - 1;
}

__inline
VOID
ConvertSecondsToTicks(
    IN ULONG Seconds,
    OUT PLARGE_INTEGER Ticks
    )
{
    // If the following assert fires, you need to cast Seconds below to
    // ULONGLONG so that 64 bit multiplication and division are used.
    // The current code assumes less than 430 seconds so that the
    // 32 multiplication below won't overflow.
    //
    ASSERT(Seconds < 430);

    Ticks->HighPart = 0;
    Ticks->LowPart = (Seconds * 10*1000*1000) / KeQueryTimeIncrement();
}

// Build the next block on the specified pool page.
// This can only be called if not all of the blocks have been built yet.
//
PUCHAR
FsbpBuildNextBlock(
    IN const FSB_POOL_HEADER* Pool,
    IN OUT PFSB_PAGE_HEADER Page
    )
{
    PUCHAR Block;

    ASSERT(Page->BlocksBuilt < Pool->BlocksPerPage);
    ASSERT((PAGE_SIZE - sizeof(FSB_PAGE_HEADER)) / Pool->AlignedBlockSize
                == Pool->BlocksPerPage);
    ASSERT(Pool->CallerBlockSize <= Pool->AlignedBlockSize);

    Block = (PUCHAR)(Page + 1) + (Page->BlocksBuilt * Pool->AlignedBlockSize);
    ASSERT(PAGE_ALIGN(Block) == Page);

    if (Pool->BuildFunction) {
        Pool->BuildFunction(Block, Pool->CallerBlockSize);
    }

    Page->BlocksBuilt++;

    return Block;
}

// Allocate a new pool page and insert it at the head of the specified
// CPU pool.  Build the first block on the new page and return a pointer
// to it.
//
PUCHAR
FsbpAllocateNewPageAndBuildOneBlock(
    IN const FSB_POOL_HEADER* Pool,
    IN PFSB_CPU_POOL_HEADER CpuPool
    )
{
    PFSB_PAGE_HEADER Page;
    PUCHAR Block = NULL;
    ULONG PagesInUse;

    ASSERT(Pool);

    Page = ExAllocatePoolWithTagPriority(NonPagedPool, PAGE_SIZE, Pool->Tag,
                                         NormalPoolPriority);
    if (Page)
    {
        ASSERT(Page == PAGE_ALIGN(Page));

        RtlZeroMemory(Page, sizeof(FSB_PAGE_HEADER));
        Page->Pool = CpuPool;
        ExInitializeSListHead(&Page->FreeList);

        // Insert the page at the head of the cpu's pool.
        //
        InsertHeadList(&CpuPool->PageList, &Page->PageLink);
        CpuPool->TotalPagesAllocated++;

        // Update the pool's statistics.
        //
        PagesInUse = CpuPool->TotalPagesAllocated - CpuPool->TotalPagesFreed;
        if (PagesInUse > CpuPool->PeakPagesInUse)
        {
            CpuPool->PeakPagesInUse = PagesInUse;
        }

        Block = FsbpBuildNextBlock(Pool, Page);
        ASSERT(Block);
    }

    return Block;
}

// Free the specified pool page back to the system's pool.
//
VOID
FsbpFreePage(
    IN PFSB_CPU_POOL_HEADER CpuPool,
    IN PFSB_PAGE_HEADER Page
    )
{
    ASSERT(Page == PAGE_ALIGN(Page));
    ASSERT(Page->Pool == CpuPool);

    ExFreePool(Page);
    CpuPool->TotalPagesFreed++;

    ASSERT(CpuPool->TotalPagesFreed <= CpuPool->TotalPagesAllocated);
}

// Reclaim the memory consumed by completely unused pool pages belonging
// to the specified per-processor pool.
//
// Caller IRQL: [DISPATCH_LEVEL]
//
VOID
FsbpScavengePool(
    IN OUT PFSB_CPU_POOL_HEADER CpuPool
    )
{
    PFSB_POOL_HEADER Pool;
    PFSB_PAGE_HEADER Page;
    PLIST_ENTRY Scan;
    PLIST_ENTRY Next;
    LARGE_INTEGER Ticks;
    LARGE_INTEGER TicksDelta;

    // We must not only be at DISPATCH_LEVEL (or higher), we must also
    // be called on the processor that owns the specified pool.
    //
    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);
    ASSERT((ULONG)KeGetCurrentProcessorNumber() == CpuPool->OwnerCpu);

    Pool = PoolFromCpuPool(CpuPool);

    KeQueryTickCount(&Ticks);

    // Compute the next tick value which represents the earliest time
    // that we will scavenge this pool again.
    //
    ConvertSecondsToTicks(FSB_SCAVENGE_PERIOD_IN_SECONDS, &TicksDelta);
    CpuPool->NextScavengeTick.QuadPart = Ticks.QuadPart + TicksDelta.QuadPart;

    // Compute the tick value which represents the last point at which
    // its okay to free a page.
    //
    ConvertSecondsToTicks(FSB_MINIMUM_PAGE_LIFETIME_IN_SECONDS, &TicksDelta);
    Ticks.QuadPart = Ticks.QuadPart - TicksDelta.QuadPart;

    Scan = CpuPool->PageList.Flink;
    while (Scan != &CpuPool->PageList)
    {
        Page = CONTAINING_RECORD(Scan, FSB_PAGE_HEADER, PageLink);
        ASSERT(Page == PAGE_ALIGN(Page));
        ASSERT(CpuPool == Page->Pool);
        ASSERT(!Page->OnUsedPageList);

        // Step to the next link before we possibly unlink this page.
        //
        Next = Scan->Flink;

        if ((Pool->BlocksPerPage == ExQueryDepthSList(&Page->FreeList)) &&
            (Ticks.QuadPart > Page->LastUsedTick.QuadPart))
        {
            RemoveEntryList(Scan);

            FsbpFreePage(CpuPool, Page);
        }

        Scan = Next;
    }

    // Scan the used pages to see if they can be moved back to the normal
    // list.  This can happen if too many frees by non-owning processors
    // are done.  In that case, the pages get orphaned on the used-page
    // list after all of their MDLs have been freed to the page.  Un-orhpan
    // them here.
    //
    Scan = CpuPool->UsedPageList.Flink;
    while (Scan != &CpuPool->UsedPageList)
    {
        Page = CONTAINING_RECORD(Scan, FSB_PAGE_HEADER, PageLink);
        ASSERT(Page == PAGE_ALIGN(Page));
        ASSERT(CpuPool == Page->Pool);
        ASSERT(Page->OnUsedPageList);

        // Step to the next link before we possibly unlink this page.
        //
        Next = Scan->Flink;

        if (0 != ExQueryDepthSList(&Page->FreeList))
        {
            RemoveEntryList(Scan);
            Page->OnUsedPageList = FALSE;
            InsertTailList(&CpuPool->PageList, Scan);
        }

        Scan = Next;
    }
}


// Creates a pool of fixed-size blocks built over non-paged pool.  Each
// block is BlockSize bytes long.  If NULL is not returned,
// FsbDestroyPool should be called at a later time to reclaim the
// resources used by the pool.
//
// Arguments:
//  BlockSize - The size, in bytes, of each block.
//  FreeBlockLinkOffset - The offset, in bytes, from the beginning of a block
//      that represenets a pointer-sized storage location that the pool can
//      use to chain free blocks together.  Most often this will be zero
//      (meaning use the first pointer-size bytes of the block.)
//  Tag - The pool tag to be used internally for calls to
//      ExAllocatePoolWithTag.  This allows callers to track
//      memory consumption for different pools.
//  BuildFunction - An optional pointer to a function which initializes
//      blocks when they are first allocated by the pool.  This allows the
//      caller to perform custom, on-demand initialization of each block.
//
//  Returns the handle used to identify the pool.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
HANDLE
FsbCreatePool(
    IN USHORT BlockSize,
    IN USHORT FreeBlockLinkOffset,
    IN ULONG Tag,
    IN PFSB_BUILDBLOCK_FUNCTION BuildFunction OPTIONAL
    )
{
    SIZE_T Size;
    PFSB_POOL_HEADER Pool;
    PFSB_CPU_POOL_HEADER CpuPool;
#if MILLEN
    CCHAR NumberCpus = 1;
#else // MILLEN
    CCHAR NumberCpus = KeNumberProcessors;
#endif // !MILLEN
    CCHAR i;

    // We need at least a pointer size worth of space to manage free
    // blocks and we don't impose any per-block overhead, so we borrow it
    // from the block itself.
    //
    ASSERT(BlockSize >= FreeBlockLinkOffset + sizeof(PVOID));

    // This implementation shouldn't be used if we are not going to get more
    // than about 8 blocks per page.  Blocks bigger than this should probably
    // be allocated with multiple pages at a time.
    //
    ASSERT(BlockSize < PAGE_SIZE / 8);

    // Compute the size of our pool header allocation.
    //
    Size = sizeof(FSB_POOL_HEADER) + (sizeof(FSB_CPU_POOL_HEADER) * NumberCpus);

    // Allocate the pool header.
    //
    Pool = ExAllocatePoolWithTag(NonPagedPool, Size, ' bsF');

    if (Pool)
    {
        // Initialize the pool header fields.
        //
        RtlZeroMemory(Pool, Size);
        Pool->Tag = Tag;
        Pool->CallerBlockSize = BlockSize;
        Pool->AlignedBlockSize = (USHORT)ALIGN_UP(BlockSize, PVOID);
        Pool->BlocksPerPage = (PAGE_SIZE - sizeof(FSB_PAGE_HEADER))
                                    / Pool->AlignedBlockSize;
        Pool->FreeBlockLinkOffset = FreeBlockLinkOffset;
        Pool->BuildFunction = BuildFunction;

        // Initialize the per-cpu pool headers.
        //
        CpuPool = (PFSB_CPU_POOL_HEADER)(Pool + 1);

        for (i = 0; i < NumberCpus; i++)
        {
            InitializeListHead(&CpuPool[i].PageList);
            InitializeListHead(&CpuPool[i].UsedPageList);
            CpuPool[i].OwnerCpu = i;
        }
    }

    return Pool;
}

// Destroys a pool of fixed-size blocks previously created by a call to
// FsbCreatePool.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being destroyed.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
VOID
FsbDestroyPool(
    IN HANDLE PoolHandle
    )
{
    PFSB_POOL_HEADER Pool;
    PFSB_PAGE_HEADER Page;
    PFSB_CPU_POOL_HEADER CpuPool;
    PLIST_ENTRY Scan;
    PLIST_ENTRY Next;
#if MILLEN
    CCHAR NumberCpus = 1;
#else // MILLEN
    CCHAR NumberCpus = KeNumberProcessors;
#endif // !MILLEN
    CCHAR i;

    Pool = (PFSB_POOL_HEADER)PoolHandle;
    if (!Pool)
    {
        return;
    }

    for (i = 0, CpuPool = (PFSB_CPU_POOL_HEADER)(Pool + 1);
         i < NumberCpus;
         i++, CpuPool++)
    {
        ASSERT(CpuPool->OwnerCpu == (ULONG)i);

        for (Scan = CpuPool->PageList.Flink;
             Scan != &CpuPool->PageList;
             Scan = Next)
        {
            Page = CONTAINING_RECORD(Scan, FSB_PAGE_HEADER, PageLink);
            ASSERT(Page == PAGE_ALIGN(Page));
            ASSERT(CpuPool == Page->Pool);
            ASSERT(!Page->OnUsedPageList);

            ASSERT(Page->BlocksBuilt <= Pool->BlocksPerPage);
            ASSERT(Page->BlocksBuilt == ExQueryDepthSList(&Page->FreeList));

            // Step to the next link before we free this page.
            //
            Next = Scan->Flink;

            RemoveEntryList(Scan);
            FsbpFreePage(CpuPool, Page);
        }

        ASSERT(IsListEmpty(&CpuPool->UsedPageList));
        ASSERT(CpuPool->TotalPagesAllocated == CpuPool->TotalPagesFreed);
        ASSERT(CpuPool->TotalBlocksAllocated == CpuPool->TotalBlocksFreed);
    }
}

// Returns a pointer to a block allocated from a pool.  NULL is returned if
// the request could not be granted.  The returned pointer is guaranteed to
// have 8 byte alignment.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being allocated from.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
PUCHAR
FsbAllocate(
    IN HANDLE PoolHandle
    )
{
    PFSB_POOL_HEADER Pool;
    PFSB_CPU_POOL_HEADER CpuPool;
    PFSB_PAGE_HEADER Page;
    PSINGLE_LIST_ENTRY BlockLink;
    PUCHAR Block = NULL;
    KIRQL OldIrql;
    ULONG Cpu;
    LARGE_INTEGER Ticks;

    ASSERT(PoolHandle);

    Pool = (PFSB_POOL_HEADER)PoolHandle;

    // Raise IRQL before saving the processor number since there is chance
    // it could have changed if we saved it while at passive.
    //
    OldIrql = KeRaiseIrqlToDpcLevel();

    Cpu = KeGetCurrentProcessorNumber();
    CpuPool = (PFSB_CPU_POOL_HEADER)(Pool + 1) + Cpu;

    // See if the minimum time has passed since we last scavenged
    // the pool.  If it has, we'll scavenge again.  Normally, scavenging
    // should only be performed when we free.  However, for the case when
    // the caller constantly frees on a non-owning processor, we'll
    // take this chance to do the scavenging.
    //
    KeQueryTickCount(&Ticks);
    if (Ticks.QuadPart > CpuPool->NextScavengeTick.QuadPart)
    {
        FsbpScavengePool(CpuPool);
    }

    if (!IsListEmpty(&CpuPool->PageList))
    {
        Page = CONTAINING_RECORD(CpuPool->PageList.Flink, FSB_PAGE_HEADER, PageLink);
        ASSERT(Page == PAGE_ALIGN(Page));
        ASSERT(CpuPool == Page->Pool);
        ASSERT(!Page->OnUsedPageList);

        BlockLink = InterlockedPopEntrySList(&Page->FreeList);
        if (BlockLink)
        {
            Block = (PUCHAR)BlockLink - Pool->FreeBlockLinkOffset;
        }
        else
        {
            // If there were no blocks on this page's free list, it had better
            // mean we haven't yet built all of the blocks on the page.
            // (Otherwise, what is a fully used page doing on the page list
            // and not on the used-page list?)
            //
            ASSERT(Page->BlocksBuilt < Pool->BlocksPerPage);

            Block = FsbpBuildNextBlock(Pool, Page);
            ASSERT(Block);
        }

        // Got a block.  Now check to see if it was the last one on a fully
        // built page.  If so, move the page to the used-page list.
        //
        if ((0 == ExQueryDepthSList(&Page->FreeList)) &&
            (Page->BlocksBuilt == Pool->BlocksPerPage))
        {
            PLIST_ENTRY PageLink;
            PageLink = RemoveHeadList(&CpuPool->PageList);
            InsertTailList(&CpuPool->UsedPageList, PageLink);
            Page->OnUsedPageList = TRUE;

            ASSERT(Page == CONTAINING_RECORD(PageLink, FSB_PAGE_HEADER, PageLink));
        }

        ASSERT(Block);
        goto GotABlock;
    }
    else
    {
        // The page list is empty so we have to allocate and add a new page.
        //
        Block = FsbpAllocateNewPageAndBuildOneBlock(Pool, CpuPool);
    }

    // If we are returning an block, update the statistics.
    //
    if (Block)
    {
        ULONG BlocksInUse;
GotABlock:

        CpuPool->TotalBlocksAllocated++;

        BlocksInUse = CpuPool->TotalBlocksAllocated - CpuPool->TotalBlocksFreed;
        if (BlocksInUse > CpuPool->PeakBlocksInUse)
        {
            CpuPool->PeakBlocksInUse = BlocksInUse;
        }

        // Don't give anyone ideas about where this might point.  I don't
        // want anyone trashing my pool because they thought this field
        // was valid for some reason.
        //
        ((PSINGLE_LIST_ENTRY)((PUCHAR)Block + Pool->FreeBlockLinkOffset))->Next = NULL;
    }

    KeLowerIrql(OldIrql);

    return Block;
}

// Free a block back to the pool from which it was allocated.
//
// Arguments:
//  Block - A block returned from a prior call to FsbAllocate.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
VOID
FsbFree(
    IN PUCHAR Block
    )
{
    PFSB_PAGE_HEADER Page;
    PFSB_CPU_POOL_HEADER CpuPool;
    PFSB_POOL_HEADER Pool;
    LARGE_INTEGER Ticks;
    LOGICAL PageIsPossiblyUnused;
    LOGICAL PageIsOnUsedPageList;
    LOGICAL Scavenge = FALSE;

    ASSERT(Block);

    // Get the address of the page that this block lives on.  This is where
    // our page header is stored.
    //
    Page = PAGE_ALIGN(Block);

    // Follow the back pointer in the page header to locate the owning
    // cpu's pool.
    //
    CpuPool = Page->Pool;

    // Locate the pool header.
    //
    Pool = PoolFromCpuPool(CpuPool);

    // See if the minimum time has passed since we last scavenged
    // the pool.  If it has, we'll scavenge again.
    //
    KeQueryTickCount(&Ticks);
    if (Ticks.QuadPart > CpuPool->NextScavengeTick.QuadPart)
    {
        Scavenge = TRUE;
    }

    // If this is the last block to be returned to this page, the page is
    // now unused.  Note that since there is no synchronization beyond
    // InterlockedPush/PopSEntryList between allocate and free, we
    // cannot guarantee that it will remain unused even before the next
    // few instructions are executed.
    //
    PageIsPossiblyUnused = (ExQueryDepthSList(&Page->FreeList)
                                == (Pool->BlocksPerPage - 1));
    if (PageIsPossiblyUnused)
    {
        // Note the tick that this page was last used.  This sets the
        // minimum time that this page will continue to live unless it
        // gets re-used.
        //
        Page->LastUsedTick.QuadPart = Ticks.QuadPart;
    }

    // If this page is on the used-page list, we'll put it back on the normal
    // page list (only after pushing the block back on the page's free list)
    // if, after raising IRQL, we are on the processor that owns this
    // pool.
    //
    PageIsOnUsedPageList = Page->OnUsedPageList;


    InterlockedIncrement(&CpuPool->TotalBlocksFreed);

    // Now return the block to the page's free list.
    //
    InterlockedPushEntrySList(
        &Page->FreeList,
        (PSINGLE_LIST_ENTRY)((PUCHAR)Block + Pool->FreeBlockLinkOffset));

    //
    // Warning: Now that the block is back on the page, one cannot reliably
    // dereference anything through 'Page' anymore.  It may have just been
    // scavenged by its owning processor.  This is not the case if the
    // page was on the used-page list (because scavenging doesn't affect
    // the used-page list).  We saved off the value of Page->OnUsedPageList
    // before returning the block so we would not risk touching Page to get
    // this value only to find that it was false.
    //

    // If we need to move the page from the used-page list to the normal
    // page list, or if we need to scavenge, we need to be at DISPATCH_LEVEL
    // and be executing on the processor that owns this pool.
    // Find out if the CPU we are executing on right now owns this pool.
    // Note that if we are running at PASSIVE_LEVEL, the current CPU may
    // change over the duration of this function call, so this value is
    // not absolute over the life of the function.
    //
    if ((PageIsOnUsedPageList || Scavenge) &&
        ((ULONG)KeGetCurrentProcessorNumber() == CpuPool->OwnerCpu))
    {
        KIRQL OldIrql;

        OldIrql = KeRaiseIrqlToDpcLevel();

        // Now that we are at DISPATCH_LEVEL, perform the work if we are still
        // executing on the processor that owns the pool.
        //
        if ((ULONG)KeGetCurrentProcessorNumber() == CpuPool->OwnerCpu)
        {
            // If the page is still on the used-page list (meaning another
            // MdpFree didn't just sneak by), then put the page on the
            // normal list.  Very important to do this after (not before)
            // returning the MDL to the free list because MdpAllocate expects
            // MDL's to be available from pages on the page list.
            //
            if (PageIsOnUsedPageList && Page->OnUsedPageList)
            {
                RemoveEntryList(&Page->PageLink);
                Page->OnUsedPageList = FALSE;
                InsertTailList(&CpuPool->PageList, &Page->PageLink);
            }

            // Perform the scavenge if we previously noted we needed to do so.
            //
            if (Scavenge)
            {
                FsbpScavengePool(CpuPool);
            }
        }

        KeLowerIrql(OldIrql);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\common\dbgmsg.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    dbgmsg.c

Abstract:

    Contains debug code for dbgcon and vprintf support.

    MILLEN gets vprintf support.
    NT gets dbg conn support.

Author:

    Scott Holden (sholden) 20-Oct-1999

--*/


#include <tcpipbase.h>

#ifdef DEBUG_MSG

// Everything off by default.
uint DbgSettingsLevel = 0x00000000;
uint DbgSettingsZone  = 0x00000000;
PDBGMSG g_pDbgMsg     = DbgPrint;

#if MILLEN


ULONG g_fVprintf  = 0;

VOID
InitVprintf();

ULONG
DbgMsg(
    PCH pszFormat,
    ...
    );

VOID
DebugMsgInit()
{
    InitVprintf();

    if (g_fVprintf) {
        DbgPrint("TCPIP: vprintf is installed\n");
        DbgSettingsLevel = 0x000000ff;
        DbgSettingsZone  = 0x00ffffff;
        g_pDbgMsg        = DbgMsg;
    }
    return;
}

VOID
InitVprintf()
{
  //
  // Check if Vprintf is installed
  //

  _asm {
        mov eax, 0x0452
        mov edi, 0x0
        _emit   0xcd
        _emit   0x20
        _emit   0x46  // VMM Get DDB (Low)
        _emit   0x01  // VMM Get DDB (High)
        _emit   0x01  // VMM VxD ID (Low)
        _emit   0x00  // VMM VxD ID (High)
        mov [g_fVprintf], ecx
  }
}

ULONG
DbgMsg(
    PCH pszFormat,
    ...
    )
{
    _asm {
        lea     esi, pszFormat
        mov     eax, esi
        add     eax,4
        push    eax
        push    [esi]

        _emit   0xcd
        _emit   0x20
        _emit   0x02  // Vprintf function
        _emit   0
        _emit   0x52  // Vprintf VxD ID (Low)
        _emit   0x04  // Vprintf VxD ID (High)
        add     esp, 8
    }

    return 0;
}

#else // MILLEN

VOID
DebugMsgInit()
{
    return;
}

#endif // !MILLEN
#endif // DEBUG_MSG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\common\9x\locks.c ===
/*++
 
  Copyright (c) 1999 Microsoft Corporation
 
  Module Name:    
        
        locks.c
 
  Abstract:       
        
        Millennium locks. See below for details of the WHY you might
        do this.
        
  Author:
  
        Scott Holden (sholden)  2/10/2000
        
  Revision History:
 
 --*/

#include "tcpipbase.h"

//
// The TCP/IP stacks makes a number of assumptions about the receive indication
// path being at DPC. Since Millennium indicates receives up on a global event
// at PASSIVE level, we need to take extra precautions in this path to return
// the thread to the correct IRQL upon releasing a spin lock.
// 
// Since TCP/IP will grab locks and release in a different order and in some
// situations CTEGetLockAtDPC will not save the previous IRQL, there were many
// issues with leaving threads at the wrong IRQL when enabling spin locks.
//
// This implementation solves this issue -- since we are on a uniproc machine.
// When we enter the first lock, we can raise IRQL to DISPATCH to ensure
// that we are not pre-empted. Each additional lock will increment the count.
// When the last lock is released, the old IRQL is restored.
//
//
                     
LONG  gTcpipLock = 0;
KIRQL gTcpipOldIrql;

VOID 
TcpipMillenGetLock(
    CTELock *pLock
    )
{
#if DBG
    KIRQL OldIrql;
#endif // DBG

    ASSERT(gTcpipLock >= 0);

    // First spinlock acquire raises DPC.
    if (gTcpipLock++ == 0) {
        KeRaiseIrql(DISPATCH_LEVEL, &gTcpipOldIrql);
    }

    // Verify that our individual locks are somehow not reentrant.
    // KeAcquireSpinLock will do that for us on Millennium.
    ASSERT((KeAcquireSpinLock(pLock, &OldIrql),OldIrql==DISPATCH_LEVEL) && ((*pLock)&1));

    ASSERT(gTcpipLock >= 1);

    return;
}

VOID 
TcpipMillenFreeLock(
    CTELock *pLock
    )
{
    ASSERT(gTcpipLock >= 1);

    // Verify that our individual locks are somehow not reentrant.
    // KeReleaseSpinLock on Millennium does that and more for us.
    ASSERT(KeGetCurrentIrql()==DISPATCH_LEVEL &&
          (KeReleaseSpinLock(pLock, DISPATCH_LEVEL),TRUE));

    // Last release lowers IRQL to original.
    if (--gTcpipLock == 0) {
        KeLowerIrql(gTcpipOldIrql);
    }

    ASSERT(gTcpipLock >= 0);
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\common\9x\bitmap.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    BitMap.c

Abstract:

    Implementation of the bit map routines for the NT rtl.

    Bit numbers within the bit map are zero based.  The first is numbered
    zero.

    The bit map routines keep track of the number of bits clear or set by
    subtracting or adding the number of bits operated on as bit ranges
    are cleared or set; individual bit states are not tested.
    This means that if a range of bits is set,
    it is assumed that the total range is currently clear.

Author:

    Gary Kimura (GaryKi) & Lou Perazzoli (LouP)     29-Jan-1990

Revision History:

    Stolen from ntoskrnl for compatibility on other platforms. Changed RTL
    to CTE to abstract.
    
--*/

#if MILLEN

#include "oscfg.h"
#include "bitmap.h"

#ifndef MAXULONG
#define MAXULONG    0xffffffff
#endif 

#define RightShiftUlong(E1,E2) ((E2) < 32 ? (E1) >> (E2) : 0)
#define LeftShiftUlong(E1,E2)  ((E2) < 32 ? (E1) << (E2) : 0)

//
//  Macro that tells how many contiguous bits are set (i.e., 1) in
//  a byte
//

#define RtlpBitSetAnywhere( Byte ) RtlpBitsClearAnywhere[ (~(Byte) & 0xFF) ]


//
//  Macro that tells how many contiguous LOW order bits are set
//  (i.e., 1) in a byte
//

#define RtlpBitsSetLow( Byte ) RtlpBitsClearLow[ (~(Byte) & 0xFF) ]


//
//  Macro that tells how many contiguous HIGH order bits are set
//  (i.e., 1) in a byte
//

#define RtlpBitsSetHigh( Byte ) RtlpBitsClearHigh[ (~(Byte) & 0xFF) ]


//
//  Macro that tells how many set bits (i.e., 1) there are in a byte
//

#define RtlpBitsSetTotal( Byte ) RtlpBitsClearTotal[ (~(Byte) & 0xFF) ]


#if DBG
VOID
DumpBitMap (
    PRTL_BITMAP BitMap
    )
{
    ULONG i;
    BOOLEAN AllZeros, AllOnes;

    DbgPrint(" BitMap:%08lx", BitMap);

    KdPrint((" (%08x)", BitMap->SizeOfBitMap));
    KdPrint((" %08lx\n", BitMap->Buffer));

    AllZeros = FALSE;
    AllOnes = FALSE;

    for (i = 0; i < ((BitMap->SizeOfBitMap + 31) / 32); i += 1) {

        if (BitMap->Buffer[i] == 0) {

            if (AllZeros) {

                NOTHING;

            } else {

                DbgPrint("%4d:", i);
                DbgPrint(" %08lx\n", BitMap->Buffer[i]);
            }

            AllZeros = TRUE;
            AllOnes = FALSE;

        } else if (BitMap->Buffer[i] == 0xFFFFFFFF) {

            if (AllOnes) {

                NOTHING;

            } else {

                DbgPrint("%4d:", i);
                DbgPrint(" %08lx\n", BitMap->Buffer[i]);
            }

            AllZeros = FALSE;
            AllOnes = TRUE;

        } else {

            AllZeros = FALSE;
            AllOnes = FALSE;

            DbgPrint("%4d:", i);
            DbgPrint(" %08lx\n", BitMap->Buffer[i]);
        }
    }
}
#endif


//
//  There are three macros to make reading the bytes in a bitmap easier.
//

#define GET_BYTE_DECLARATIONS() \
    PUCHAR _CURRENT_POSITION;

#define GET_BYTE_INITIALIZATION(RTL_BITMAP,BYTE_INDEX) {               \
    _CURRENT_POSITION = &((PUCHAR)((RTL_BITMAP)->Buffer))[BYTE_INDEX]; \
}

#define GET_BYTE(THIS_BYTE)  (         \
    THIS_BYTE = *(_CURRENT_POSITION++) \
)


//
//  Lookup table that tells how many contiguous bits are clear (i.e., 0) in
//  a byte
//

CONST CCHAR RtlpBitsClearAnywhere[] =
         { 8,7,6,6,5,5,5,5,4,4,4,4,4,4,4,4,
           4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
           5,4,3,3,2,2,2,2,3,2,2,2,2,2,2,2,
           4,3,2,2,2,2,2,2,3,2,2,2,2,2,2,2,
           6,5,4,4,3,3,3,3,3,2,2,2,2,2,2,2,
           4,3,2,2,2,1,1,1,3,2,1,1,2,1,1,1,
           5,4,3,3,2,2,2,2,3,2,1,1,2,1,1,1,
           4,3,2,2,2,1,1,1,3,2,1,1,2,1,1,1,
           7,6,5,5,4,4,4,4,3,3,3,3,3,3,3,3,
           4,3,2,2,2,2,2,2,3,2,2,2,2,2,2,2,
           5,4,3,3,2,2,2,2,3,2,1,1,2,1,1,1,
           4,3,2,2,2,1,1,1,3,2,1,1,2,1,1,1,
           6,5,4,4,3,3,3,3,3,2,2,2,2,2,2,2,
           4,3,2,2,2,1,1,1,3,2,1,1,2,1,1,1,
           5,4,3,3,2,2,2,2,3,2,1,1,2,1,1,1,
           4,3,2,2,2,1,1,1,3,2,1,1,2,1,1,0 };

//
//  Lookup table that tells how many contiguous LOW order bits are clear
//  (i.e., 0) in a byte
//

CONST CCHAR RtlpBitsClearLow[] =
          { 8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
            4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0 };

//
//  Lookup table that tells how many contiguous HIGH order bits are clear
//  (i.e., 0) in a byte
//

CONST CCHAR RtlpBitsClearHigh[] =
          { 8,7,6,6,5,5,5,5,4,4,4,4,4,4,4,4,
            3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
            2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
            2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };

//
//  Lookup table that tells how many clear bits (i.e., 0) there are in a byte
//

CONST CCHAR RtlpBitsClearTotal[] =
          { 8,7,7,6,7,6,6,5,7,6,6,5,6,5,5,4,
            7,6,6,5,6,5,5,4,6,5,5,4,5,4,4,3,
            7,6,6,5,6,5,5,4,6,5,5,4,5,4,4,3,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            7,6,6,5,6,5,5,4,6,5,5,4,5,4,4,3,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            5,4,4,3,4,3,3,2,4,3,3,2,3,2,2,1,
            7,6,6,5,6,5,5,4,6,5,5,4,5,4,4,3,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            5,4,4,3,4,3,3,2,4,3,3,2,3,2,2,1,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            5,4,4,3,4,3,3,2,4,3,3,2,3,2,2,1,
            5,4,4,3,4,3,3,2,4,3,3,2,3,2,2,1,
            4,3,3,2,3,2,2,1,3,2,2,1,2,1,1,0 };

//
//  Bit Mask for clearing and setting bits within bytes.  FillMask[i] has the first
//  i bits set to 1.  ZeroMask[i] has the first i bits set to zero.
//

static CONST UCHAR FillMask[] = { 0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF };

static CONST UCHAR ZeroMask[] = { 0xFF, 0xFE, 0xFC, 0xF8, 0xf0, 0xe0, 0xc0, 0x80, 0x00 };


VOID
RtlInitializeBitMap (
    IN PRTL_BITMAP BitMapHeader,
    IN PULONG BitMapBuffer,
    IN ULONG SizeOfBitMap
    )

/*++

Routine Description:

    This procedure initializes a bit map.

Arguments:

    BitMapHeader - Supplies a pointer to the BitMap Header to initialize

    BitMapBuffer - Supplies a pointer to the buffer that is to serve as the
        BitMap.  This must be an a multiple number of longwords in size.

    SizeOfBitMap - Supplies the number of bits required in the Bit Map.

Return Value:

    None.

--*/

{
    //
    //  Initialize the BitMap header.
    //

    BitMapHeader->SizeOfBitMap = SizeOfBitMap;
    BitMapHeader->Buffer = BitMapBuffer;

    //
    //  And return to our caller
    //

    //DbgPrint("InitializeBitMap"); DumpBitMap(BitMapHeader);
    return;
}

VOID
RtlClearBit (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG BitNumber
    )

/*++

Routine Description:

    This procedure clears a single bit in the specified bit map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized bit map.

    BitNumber - Supplies the number of the bit to be cleared in the bit map.

Return Value:

    None.

--*/

{

    PCHAR ByteAddress;
    ULONG ShiftCount;

    ASSERT(BitNumber < BitMapHeader->SizeOfBitMap);

    ByteAddress = (PCHAR)BitMapHeader->Buffer + (BitNumber >> 3);
    ShiftCount = BitNumber & 0x7;
    *ByteAddress &= (CHAR)(~(1 << ShiftCount));
    return;
}

VOID
RtlSetBit (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG BitNumber
    )

/*++

Routine Description:

    This procedure sets a single bit in the specified bit map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized bit map.

    BitNumber - Supplies the number of the bit to be set in the bit map.

Return Value:

    None.

--*/

{

    PCHAR ByteAddress;
    ULONG ShiftCount;

    ASSERT(BitNumber < BitMapHeader->SizeOfBitMap);

    ByteAddress = (PCHAR)BitMapHeader->Buffer + (BitNumber >> 3);
    ShiftCount = BitNumber & 0x7;
    *ByteAddress |= (CHAR)(1 << ShiftCount);
    return;
}

BOOLEAN
RtlTestBit (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG BitNumber
    )

/*++

Routine Description:

    This procedure tests the state of a single bit in the specified bit map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized bit map.

    BitNumber - Supplies the number of the bit to be tested in the bit map.

Return Value:

    The state of the specified bit is returned as the function value.

--*/

{

    PCHAR ByteAddress;
    ULONG ShiftCount;

    ASSERT(BitNumber < BitMapHeader->SizeOfBitMap);

    ByteAddress = (PCHAR)BitMapHeader->Buffer + (BitNumber >> 3);
    ShiftCount = BitNumber & 0x7;
    return (BOOLEAN)((*ByteAddress >> ShiftCount) & 1);
}

VOID
RtlClearAllBits (
    IN PRTL_BITMAP BitMapHeader
    )

/*++

Routine Description:

    This procedure clears all bits in the specified Bit Map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized BitMap

Return Value:

    None.

--*/

{
    //
    //  Clear all the bits
    //

    memset ( BitMapHeader->Buffer,
             0,
             ((BitMapHeader->SizeOfBitMap + 31) / 32) * 4
             );

    //
    //  And return to our caller
    //

    //DbgPrint("ClearAllBits"); DumpBitMap(BitMapHeader);
    return;
}


VOID
RtlSetAllBits (
    IN PRTL_BITMAP BitMapHeader
    )

/*++

Routine Description:

    This procedure sets all bits in the specified Bit Map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized BitMap

Return Value:

    None.

--*/

{
    //
    //  Set all the bits
    //

    memset( BitMapHeader->Buffer,
            0xff,
            ((BitMapHeader->SizeOfBitMap + 31) / 32) * 4
            );

    //
    //  And return to our caller
    //

    //DbgPrint("SetAllBits"); DumpBitMap(BitMapHeader);
    return;
}


ULONG
RtlFindClearBits (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG NumberToFind,
    IN ULONG HintIndex
    )

/*++

Routine Description:

    This procedure searches the specified bit map for the specified
    contiguous region of clear bits.  If a run is not found from the
    hint to the end of the bitmap, we will search again from the
    beginning of the bitmap.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized BitMap.

    NumberToFind - Supplies the size of the contiguous region to find.

    HintIndex - Supplies the index (zero based) of where we should start
        the search from within the bitmap.

Return Value:

    ULONG - Receives the starting index (zero based) of the contiguous
        region of clear bits found.  If not such a region cannot be found
        a -1 (i.e. 0xffffffff) is returned.

--*/

{
    ULONG SizeOfBitMap;
    ULONG SizeInBytes;

    ULONG HintBit;
    ULONG MainLoopIndex;

    GET_BYTE_DECLARATIONS();

    //
    //  To make the loops in our test run faster we'll extract the
    //  fields from the bitmap header
    //

    SizeOfBitMap = BitMapHeader->SizeOfBitMap;
    SizeInBytes = (SizeOfBitMap + 7) / 8;

    //
    //  Set any unused bits in the last byte so we won't count them.  We do
    //  this by first checking if there is any odd bits in the last byte.
    //

    if ((SizeOfBitMap % 8) != 0) {

        //
        //  The last byte has some odd bits so we'll set the high unused
        //  bits in the last byte to 1's
        //

        ((PUCHAR)BitMapHeader->Buffer)[SizeInBytes - 1] |=
                                                    ZeroMask[SizeOfBitMap % 8];
    }

    //
    //  Calculate from the hint index where the hint byte is and set ourselves
    //  up to read the hint on the next call to GET_BYTE.  To make the
    //  algorithm run fast we'll only honor hints down to the byte level of
    //  granularity.  There is a possibility that we'll need to execute
    //  our main logic twice.  Once to test from the hint byte to the end of
    //  the bitmap and the other to test from the start of the bitmap.  First
    //  we need to make sure the Hint Index is within range.
    //

    if (HintIndex >= SizeOfBitMap) {

        HintIndex = 0;
    }

    HintBit = HintIndex % 8;

    for (MainLoopIndex = 0; MainLoopIndex < 2; MainLoopIndex += 1) {

        ULONG StartByteIndex;
        ULONG EndByteIndex;

        UCHAR CurrentByte;

        //
        //  Check for the first time through the main loop, which indicates
        //  that we are going to start our search at our hint byte
        //

        if (MainLoopIndex == 0) {

            StartByteIndex = HintIndex / 8;
            EndByteIndex = SizeInBytes;

        //
        //  This is the second time through the loop, make sure there is
        //  actually something to check before the hint byte
        //

        } else if (HintIndex != 0) {

            //
            //  The end index for the second time around is based on the
            //  number of bits we need to find.  We need to use this inorder
            //  to take the case where the preceding byte to the hint byte
            //  is the start of our run, and the run includes the hint byte
            //  and some following bytes, based on the number of bits needed
            //  The computation is to take the number of bits needed minus
            //  2 divided by 8 and then add 2.  This will take in to account
            //  the worst possible case where we have one bit hanging off
            //  of each end byte, and all intervening bytes are all zero.
            //

            if (NumberToFind < 2) {

                EndByteIndex = HintIndex / 8;

            } else {

                EndByteIndex = (HintIndex / 8) + ((NumberToFind - 2) / 8) + 2;

                //
                //  Make sure we don't overrun the end of the bitmap
                //

                if (EndByteIndex > SizeInBytes) {

                    EndByteIndex = SizeInBytes;
                }
            }

            HintIndex = 0;
            HintBit = 0;
            StartByteIndex = 0;

        //
        //  Otherwise we already did a complete loop through the bitmap
        //  so we should simply return -1 to say nothing was found
        //

        } else {

            return 0xffffffff;
        }

        //
        //  Set ourselves up to get the next byte
        //

        GET_BYTE_INITIALIZATION(BitMapHeader, StartByteIndex);

        //
        //  Get the first byte, and set any bits before the hint bit.
        //

        GET_BYTE( CurrentByte );

        CurrentByte |= FillMask[HintBit];

        //
        //  If the number of bits can only fit in 1 or 2 bytes (i.e., 9 bits or
        //  less) we do the following test case.
        //

        if (NumberToFind <= 9) {

            ULONG CurrentBitIndex;
            UCHAR PreviousByte;

            PreviousByte = 0xff;

            //
            //  Examine all the bytes within our test range searching
            //  for a fit
            //

            CurrentBitIndex = StartByteIndex * 8;

            while (TRUE) {

                //
                //  If this is the first itteration of the loop, mask Current
                //  byte with the real hint.
                //

                //
                //  Check to see if the current byte coupled with the previous
                //  byte will satisfy the requirement. The check uses the high
                //  part of the previous byte and low part of the current byte.
                //

                if (((ULONG)RtlpBitsClearHigh[PreviousByte] +
                           (ULONG)RtlpBitsClearLow[CurrentByte]) >= NumberToFind) {

                    ULONG StartingIndex;

                    //
                    //  It all fits in these two bytes, so we can compute
                    //  the starting index.  This is done by taking the
                    //  index of the current byte (bit 0) and subtracting the
                    //  number of bits its takes to get to the first cleared
                    //  high bit.
                    //

                    StartingIndex = CurrentBitIndex -
                                             (LONG)RtlpBitsClearHigh[PreviousByte];

                    //
                    //  Now make sure the total size isn't beyond the bitmap
                    //

                    if ((StartingIndex + NumberToFind) <= SizeOfBitMap) {

                        return StartingIndex;
                    }
                }

                //
                //  The previous byte does not help, so check the current byte.
                //

                if ((ULONG)RtlpBitsClearAnywhere[CurrentByte] >= NumberToFind) {

                    UCHAR BitMask;
                    ULONG i;

                    //
                    //  It all fits in a single byte, so calculate the bit
                    //  number.  We do this by taking a mask of the appropriate
                    //  size and shifting it over until it fits.  It fits when
                    //  we can bitwise-and the current byte with the bitmask
                    //  and get a zero back.
                    //

                    BitMask = FillMask[ NumberToFind ];
                    for (i = 0; (BitMask & CurrentByte) != 0; i += 1) {

                        BitMask <<= 1;
                    }

                    //
                    //  return to our caller the located bit index, and the
                    //  number that we found.
                    //

                    return CurrentBitIndex + i;
                }

                //
                //  For the next iteration through our loop we need to make
                //  the current byte into the previous byte, and go to the
                //  top of the loop again.
                //

                PreviousByte = CurrentByte;

                //
                //  Increment our Bit Index, and either exit, or get the
                //  next byte.
                //

                CurrentBitIndex += 8;

                if ( CurrentBitIndex < EndByteIndex * 8 ) {

                    GET_BYTE( CurrentByte );

                } else {

                    break;
                }

            } // end loop CurrentBitIndex

        //
        //  The number to find is greater than 9 but if it is less than 15
        //  then we know it can be satisfied with at most 2 bytes, or 3 bytes
        //  if the middle byte (of the 3) is all zeros.
        //

        } else if (NumberToFind < 15) {

            ULONG CurrentBitIndex;

            UCHAR PreviousPreviousByte;
            UCHAR PreviousByte;

            PreviousByte = 0xff;

            //
            //  Examine all the bytes within our test range searching
            //  for a fit
            //

            CurrentBitIndex = StartByteIndex * 8;

            while (TRUE) {

                //
                //  For the next iteration through our loop we need to make
                //  the current byte into the previous byte, the previous
                //  byte into the previous previous byte, and go forward.
                //

                PreviousPreviousByte = PreviousByte;
                PreviousByte = CurrentByte;

                //
                //  Increment our Bit Index, and either exit, or get the
                //  next byte.
                //

                CurrentBitIndex += 8;

                if ( CurrentBitIndex < EndByteIndex * 8 ) {

                    GET_BYTE( CurrentByte );

                } else {

                    break;
                }

                //
                //  if the previous byte is all zeros then maybe the
                //  request can be satisfied using the Previous Previous Byte
                //  Previous Byte, and the Current Byte.
                //

                if ((PreviousByte == 0)
                    
                    &&

                    (((ULONG)RtlpBitsClearHigh[PreviousPreviousByte] + 8 +
                          (ULONG)RtlpBitsClearLow[CurrentByte]) >= NumberToFind)) {

                    ULONG StartingIndex;

                    //
                    //  It all fits in these three bytes, so we can compute
                    //  the starting index.  This is done by taking the
                    //  index of the previous byte (bit 0) and subtracting
                    //  the number of bits its takes to get to the first
                    //  cleared high bit.
                    //

                    StartingIndex = (CurrentBitIndex - 8) -
                                     (LONG)RtlpBitsClearHigh[PreviousPreviousByte];

                    //
                    //  Now make sure the total size isn't beyond the bitmap
                    //

                    if ((StartingIndex + NumberToFind) <= SizeOfBitMap) {

                        return StartingIndex;
                    }
                }

                //
                //  Check to see if the Previous byte and current byte
                //  together satisfy the request.
                //

                if (((ULONG)RtlpBitsClearHigh[PreviousByte] +
                           (ULONG)RtlpBitsClearLow[CurrentByte]) >= NumberToFind) {

                    ULONG StartingIndex;

                    //
                    //  It all fits in these two bytes, so we can compute
                    //  the starting index.  This is done by taking the
                    //  index of the current byte (bit 0) and subtracting the
                    //  number of bits its takes to get to the first cleared
                    //  high bit.
                    //

                    StartingIndex = CurrentBitIndex -
                                             (LONG)RtlpBitsClearHigh[PreviousByte];

                    //
                    //  Now make sure the total size isn't beyond the bitmap
                    //

                    if ((StartingIndex + NumberToFind) <= SizeOfBitMap) {

                        return StartingIndex;
                    }
                }

            } // end loop CurrentBitIndex

        //
        //  The number to find is greater than or equal to 15.  This request
        //  has to have at least one byte of all zeros to be satisfied
        //

        } else {

            ULONG CurrentByteIndex;

            ULONG ZeroBytesNeeded;
            ULONG ZeroBytesFound;

            UCHAR StartOfRunByte;
            LONG StartOfRunIndex;

            //
            //  First precalculate how many zero bytes we're going to need
            //

            ZeroBytesNeeded = (NumberToFind - 7) / 8;

            //
            //  Indicate for the first time through our loop that we haven't
            //  found a zero byte yet, and indicate that the start of the
            //  run is the byte just before the start byte index
            //

            ZeroBytesFound = 0;
            StartOfRunByte = 0xff;
            StartOfRunIndex = StartByteIndex - 1;

            //
            //  Examine all the bytes in our test range searching for a fit
            //

            CurrentByteIndex = StartByteIndex;

            while (TRUE) {

                //
                //  If the number of zero bytes fits our minimum requirements
                //  then we can do the additional test to see if we
                //  actually found a fit
                //

                if ((ZeroBytesFound >= ZeroBytesNeeded)

                        &&

                    ((ULONG)RtlpBitsClearHigh[StartOfRunByte] + ZeroBytesFound*8 +
                     (ULONG)RtlpBitsClearLow[CurrentByte]) >= NumberToFind) {

                    ULONG StartingIndex;

                    //
                    //  It all fits in these bytes, so we can compute
                    //  the starting index.  This is done by taking the
                    //  StartOfRunIndex times 8 and adding the number of bits
                    //  it takes to get to the first cleared high bit.
                    //

                    StartingIndex = (StartOfRunIndex * 8) +
                                     (8 - (LONG)RtlpBitsClearHigh[StartOfRunByte]);

                    //
                    //  Now make sure the total size isn't beyond the bitmap
                    //

                    if ((StartingIndex + NumberToFind) <= SizeOfBitMap) {

                        return StartingIndex;
                    }
                }

                //
                //  Check to see if the byte is zero and increment
                //  the number of zero bytes found
                //

                if (CurrentByte == 0) {

                    ZeroBytesFound += 1;

                //
                //  The byte isn't a zero so we need to start over again
                //  looking for zero bytes.
                //

                } else {

                    ZeroBytesFound = 0;
                    StartOfRunByte = CurrentByte;
                    StartOfRunIndex = CurrentByteIndex;
                }

                //
                //  Increment our Byte Index, and either exit, or get the
                //  next byte.
                //

                CurrentByteIndex += 1;

                if ( CurrentByteIndex < EndByteIndex ) {

                    GET_BYTE( CurrentByte );

                } else {

                    break;
                }

            } // end loop CurrentByteIndex
        }
    }

    //
    //  We never found a fit so we'll return -1
    //

    return 0xffffffff;
}


ULONG
RtlFindSetBits (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG NumberToFind,
    IN ULONG HintIndex
    )

/*++

Routine Description:

    This procedure searches the specified bit map for the specified
    contiguous region of set bits.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized BitMap.

    NumberToFind - Supplies the size of the contiguous region to find.

    HintIndex - Supplies the index (zero based) of where we should start
        the search from within the bitmap.

Return Value:

    ULONG - Receives the starting index (zero based) of the contiguous
        region of set bits found.  If such a region cannot be found then
        a -1 (i.e., 0xffffffff) is returned.

--*/

{
    ULONG SizeOfBitMap;
    ULONG SizeInBytes;

    ULONG HintBit;
    ULONG MainLoopIndex;

    GET_BYTE_DECLARATIONS();

    //
    //  To make the loops in our test run faster we'll extract the
    //  fields from the bitmap header
    //

    SizeOfBitMap = BitMapHeader->SizeOfBitMap;
    SizeInBytes = (SizeOfBitMap + 7) / 8;

    //
    //  Set any unused bits in the last byte so we won't count them.  We do
    //  this by first checking if there is any odd bits in the last byte.
    //

    if ((SizeOfBitMap % 8) != 0) {

        //
        //  The last byte has some odd bits so we'll set the high unused
        //  bits in the last byte to 0's
        //

        ((PUCHAR)BitMapHeader->Buffer)[SizeInBytes - 1] &=
                                                    FillMask[SizeOfBitMap % 8];
    }

    //
    //  Calculate from the hint index where the hint byte is and set ourselves
    //  up to read the hint on the next call to GET_BYTE.  To make the
    //  algorithm run fast we'll only honor hints down to the byte level of
    //  granularity.  There is a possibility that we'll need to execute
    //  our main logic twice.  Once to test from the hint byte to the end of
    //  the bitmap and the other to test from the start of the bitmap.  First
    //  we need to make sure the Hint Index is within range.
    //

    if (HintIndex >= SizeOfBitMap) {

        HintIndex = 0;
    }

    HintBit = HintIndex % 8;

    for (MainLoopIndex = 0; MainLoopIndex < 2; MainLoopIndex += 1) {

        ULONG StartByteIndex;
        ULONG EndByteIndex;

        UCHAR CurrentByte;

        //
        //  Check for the first time through the main loop, which indicates
        //  that we are going to start our search at our hint byte
        //

        if (MainLoopIndex == 0) {

            StartByteIndex = HintIndex / 8;
            EndByteIndex = SizeInBytes;

        //
        //  This is the second time through the loop, make sure there is
        //  actually something to check before the hint byte
        //

        } else if (HintIndex != 0) {

            //
            //  The end index for the second time around is based on the
            //  number of bits we need to find.  We need to use this inorder
            //  to take the case where the preceding byte to the hint byte
            //  is the start of our run, and the run includes the hint byte
            //  and some following bytes, based on the number of bits needed
            //  The computation is to take the number of bits needed minus
            //  2 divided by 8 and then add 2.  This will take in to account
            //  the worst possible case where we have one bit hanging off
            //  of each end byte, and all intervening bytes are all zero.
            //  We only need to add one in the following equation because
            //  HintByte is already counted.
            //

            if (NumberToFind < 2) {

                EndByteIndex = HintIndex / 8;

            } else {

                EndByteIndex = HintIndex / 8 + ((NumberToFind - 2) / 8) + 1;

                //
                //  Make sure we don't overrun the end of the bitmap
                //

                if (EndByteIndex > SizeInBytes) {

                    EndByteIndex = SizeInBytes;
                }
            }

            StartByteIndex = 0;
            HintIndex = 0;
            HintBit = 0;

        //
        //  Otherwise we already did a complete loop through the bitmap
        //  so we should simply return -1 to say nothing was found
        //

        } else {

            return 0xffffffff;
        }

        //
        //  Set ourselves up to get the next byte
        //

        GET_BYTE_INITIALIZATION(BitMapHeader, StartByteIndex);

        //
        //  Get the first byte, and clear any bits before the hint bit.
        //

        GET_BYTE( CurrentByte );

        CurrentByte &= ZeroMask[HintBit];

        //
        //  If the number of bits can only fit in 1 or 2 bytes (i.e., 9 bits or
        //  less) we do the following test case.
        //

        if (NumberToFind <= 9) {

            ULONG CurrentBitIndex;

            UCHAR PreviousByte;

            PreviousByte = 0x00;

            //
            //  Examine all the bytes within our test range searching
            //  for a fit
            //

            CurrentBitIndex = StartByteIndex * 8;

            while (TRUE) {

                //
                //  Check to see if the current byte coupled with the previous
                //  byte will satisfy the requirement. The check uses the high
                //  part of the previous byte and low part of the current byte.
                //

                if (((ULONG)RtlpBitsSetHigh(PreviousByte) +
                             (ULONG)RtlpBitsSetLow(CurrentByte)) >= NumberToFind) {

                    ULONG StartingIndex;

                    //
                    //  It all fits in these two bytes, so we can compute
                    //  the starting index.  This is done by taking the
                    //  index of the current byte (bit 0) and subtracting the
                    //  number of bits its takes to get to the first set
                    //  high bit.
                    //

                    StartingIndex = CurrentBitIndex -
                                               (LONG)RtlpBitsSetHigh(PreviousByte);

                    //
                    //  Now make sure the total size isn't beyond the bitmap
                    //

                    if ((StartingIndex + NumberToFind) <= SizeOfBitMap) {

                        return StartingIndex;
                    }
                }

                //
                //  The previous byte does not help, so check the current byte.
                //

                if ((ULONG)RtlpBitSetAnywhere(CurrentByte) >= NumberToFind) {

                    UCHAR BitMask;
                    ULONG i;

                    //
                    //  It all fits in a single byte, so calculate the bit
                    //  number.  We do this by taking a mask of the appropriate
                    //  size and shifting it over until it fits.  It fits when
                    //  we can bitwise-and the current byte with the bit mask
                    //  and get back the bit mask.
                    //

                    BitMask = FillMask[ NumberToFind ];
                    for (i = 0; (BitMask & CurrentByte) != BitMask; i += 1) {

                        BitMask <<= 1;
                    }

                    //
                    //  return to our caller the located bit index, and the
                    //  number that we found.
                    //

                    return CurrentBitIndex + i;
                }

                //
                //  For the next iteration through our loop we need to make
                //  the current byte into the previous byte, and go to the
                //  top of the loop again.
                //

                PreviousByte = CurrentByte;

                //
                //  Increment our Bit Index, and either exit, or get the
                //  next byte.
                //

                CurrentBitIndex += 8;

                if ( CurrentBitIndex < EndByteIndex * 8 ) {

                    GET_BYTE( CurrentByte );

                } else {

                    break;
                }

            } // end loop CurrentBitIndex

        //
        //  The number to find is greater than 9 but if it is less than 15
        //  then we know it can be satisfied with at most 2 bytes, or 3 bytes
        //  if the middle byte (of the 3) is all ones.
        //

        } else if (NumberToFind < 15) {

            ULONG CurrentBitIndex;

            UCHAR PreviousPreviousByte;
            UCHAR PreviousByte;

            PreviousByte = 0x00;

            //
            //  Examine all the bytes within our test range searching
            //  for a fit
            //

            CurrentBitIndex = StartByteIndex * 8;

            while (TRUE) {

                //
                //  For the next iteration through our loop we need to make
                //  the current byte into the previous byte, the previous
                //  byte into the previous previous byte, and go to the
                //  top of the loop again.
                //

                PreviousPreviousByte = PreviousByte;
                PreviousByte = CurrentByte;

                //
                //  Increment our Bit Index, and either exit, or get the
                //  next byte.
                //

                CurrentBitIndex += 8;

                if ( CurrentBitIndex < EndByteIndex * 8 ) {

                    GET_BYTE( CurrentByte );

                } else {

                    break;
                }

                //
                //  if the previous byte is all ones then maybe the
                //  request can be satisfied using the Previous Previous Byte
                //  Previous Byte, and the Current Byte.
                //

                if ((PreviousByte == 0xff)

                        &&

                    (((ULONG)RtlpBitsSetHigh(PreviousPreviousByte) + 8 +
                            (ULONG)RtlpBitsSetLow(CurrentByte)) >= NumberToFind)) {

                    ULONG StartingIndex;

                    //
                    //  It all fits in these three bytes, so we can compute
                    //  the starting index.  This is done by taking the
                    //  index of the previous byte (bit 0) and subtracting
                    //  the number of bits its takes to get to the first
                    //  set high bit.
                    //

                    StartingIndex = (CurrentBitIndex - 8) -
                                       (LONG)RtlpBitsSetHigh(PreviousPreviousByte);

                    //
                    //  Now make sure the total size isn't beyond the bitmap
                    //

                    if ((StartingIndex + NumberToFind) <= SizeOfBitMap) {

                        return StartingIndex;
                    }
                }

                //
                //  Check to see if the Previous byte and current byte
                //  together satisfy the request.
                //

                if (((ULONG)RtlpBitsSetHigh(PreviousByte) +
                             (ULONG)RtlpBitsSetLow(CurrentByte)) >= NumberToFind) {

                    ULONG StartingIndex;

                    //
                    //  It all fits in these two bytes, so we can compute
                    //  the starting index.  This is done by taking the
                    //  index of the current byte (bit 0) and subtracting the
                    //  number of bits its takes to get to the first set
                    //  high bit.
                    //

                    StartingIndex = CurrentBitIndex -
                                               (LONG)RtlpBitsSetHigh(PreviousByte);

                    //
                    //  Now make sure the total size isn't beyond the bitmap
                    //

                    if ((StartingIndex + NumberToFind) <= SizeOfBitMap) {

                        return StartingIndex;
                    }
                }
            } // end loop CurrentBitIndex

        //
        //  The number to find is greater than or equal to 15.  This request
        //  has to have at least one byte of all ones to be satisfied
        //

        } else {

            ULONG CurrentByteIndex;

            ULONG OneBytesNeeded;
            ULONG OneBytesFound;

            UCHAR StartOfRunByte;
            LONG StartOfRunIndex;

            //
            //  First precalculate how many one bytes we're going to need
            //

            OneBytesNeeded = (NumberToFind - 7) / 8;

            //
            //  Indicate for the first time through our loop that we haven't
            //  found a one byte yet, and indicate that the start of the
            //  run is the byte just before the start byte index
            //

            OneBytesFound = 0;
            StartOfRunByte = 0x00;
            StartOfRunIndex = StartByteIndex - 1;

            //
            //  Examine all the bytes in our test range searching for a fit
            //

            CurrentByteIndex = StartByteIndex;

            while (TRUE) {

                //
                //  If the number of zero bytes fits our minimum requirements
                //  then we can do the additional test to see if we
                //  actually found a fit
                //

                if ((OneBytesFound >= OneBytesNeeded)

                        &&

                    ((ULONG)RtlpBitsSetHigh(StartOfRunByte) + OneBytesFound*8 +
                     (ULONG)RtlpBitsSetLow(CurrentByte)) >= NumberToFind) {

                    ULONG StartingIndex;

                    //
                    //  It all fits in these bytes, so we can compute
                    //  the starting index.  This is done by taking the
                    //  StartOfRunIndex times 8 and adding the number of bits
                    //  it takes to get to the first set high bit.
                    //

                    StartingIndex = (StartOfRunIndex * 8) +
                                       (8 - (LONG)RtlpBitsSetHigh(StartOfRunByte));

                    //
                    //  Now make sure the total size isn't beyond the bitmap
                    //

                    if ((StartingIndex + NumberToFind) <= SizeOfBitMap) {

                        return StartingIndex;
                    }
                }

                //
                //  Check to see if the byte is all ones and increment
                //  the number of one bytes found
                //

                if (CurrentByte == 0xff) {

                    OneBytesFound += 1;

                //
                //  The byte isn't all ones so we need to start over again
                //  looking for one bytes.
                //

                } else {

                    OneBytesFound = 0;
                    StartOfRunByte = CurrentByte;
                    StartOfRunIndex = CurrentByteIndex;
                }

                //
                //  Increment our Byte Index, and either exit, or get the
                //  next byte.
                //

                CurrentByteIndex += 1;

                if ( CurrentByteIndex < EndByteIndex ) {

                    GET_BYTE( CurrentByte );

                } else {

                    break;
                }
            } // end loop CurrentByteIndex
        }
    }

    //
    //  We never found a fit so we'll return -1
    //

    return 0xffffffff;
}


ULONG
RtlFindClearBitsAndSet (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG NumberToFind,
    IN ULONG HintIndex
    )

/*++

Routine Description:

    This procedure searches the specified bit map for the specified
    contiguous region of clear bits, sets the bits and returns the
    number of bits found, and the starting bit number which was clear
    then set.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized BitMap.

    NumberToFind - Supplies the size of the contiguous region to find.

    HintIndex - Supplies the index (zero based) of where we should start
        the search from within the bitmap.

Return Value:

    ULONG - Receives the starting index (zero based) of the contiguous
        region found.  If such a region cannot be located a -1 (i.e.,
        0xffffffff) is returned.

--*/

{
    ULONG StartingIndex;

    //
    //  First look for a run of clear bits that equals the size requested
    //

    StartingIndex = RtlFindClearBits( BitMapHeader,
                                      NumberToFind,
                                      HintIndex );

    //DbgPrint("FindClearBits %08lx, ", NumberToFind);
    //DbgPrint("%08lx", StartingIndex);
    //DumpBitMap(BitMapHeader);

    if (StartingIndex != 0xffffffff) {

        //
        //  We found a large enough run of clear bits so now set them
        //

        RtlSetBits( BitMapHeader, StartingIndex, NumberToFind );
    }

    //
    //  And return to our caller
    //

    return StartingIndex;

}


ULONG
RtlFindSetBitsAndClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG NumberToFind,
    IN ULONG HintIndex
    )

/*++

Routine Description:

    This procedure searches the specified bit map for the specified
    contiguous region of set bits, clears the bits and returns the
    number of bits found and the starting bit number which was set then
    clear.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized BitMap.

    NumberToFind - Supplies the size of the contiguous region to find.

    HintIndex - Supplies the index (zero based) of where we should start
        the search from within the bitmap.

Return Value:

    ULONG - Receives the starting index (zero based) of the contiguous
        region found.  If such a region cannot be located a -1 (i.e.,
        0xffffffff) is returned.


--*/

{
    ULONG StartingIndex;

    //
    //  First look for a run of set bits that equals the size requested
    //

    if ((StartingIndex = RtlFindSetBits( BitMapHeader,
                                         NumberToFind,
                                         HintIndex )) != 0xffffffff) {

        //
        //  We found a large enough run of set bits so now clear them
        //

        RtlClearBits( BitMapHeader, StartingIndex, NumberToFind );
    }

    //
    //  And return to our caller
    //

    return StartingIndex;
}


VOID
RtlClearBits (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG StartingIndex,
    IN ULONG NumberToClear
    )

/*++

Routine Description:

    This procedure clears the specified range of bits within the
    specified bit map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized Bit Map.

    StartingIndex - Supplies the index (zero based) of the first bit to clear.

    NumberToClear - Supplies the number of bits to clear.

Return Value:

    None.

--*/

{
    ULONG BitOffset;
    PULONG CurrentLong;

    //DbgPrint("ClearBits %08lx, ", NumberToClear);
    //DbgPrint("%08lx", StartingIndex);

    ASSERT( StartingIndex + NumberToClear <= BitMapHeader->SizeOfBitMap );

    //
    //  Special case the situation where the number of bits to clear is
    //  zero.  Turn this into a noop.
    //

    if (NumberToClear == 0) {

        return;
    }

    BitOffset = StartingIndex % 32;

    //
    //  Get a pointer to the first longword that needs to be zeroed out
    //

    CurrentLong = &BitMapHeader->Buffer[ StartingIndex / 32 ];

    //
    //  Check if we can only need to clear out one longword.
    //

    if ((BitOffset + NumberToClear) <= 32) {

        //
        //  To build a mask of bits to clear we shift left to get the number
        //  of bits we're clearing and then shift right to put it in position.
        //  We'll typecast the right shift to ULONG to make sure it doesn't
        //  do a sign extend.
        //

        *CurrentLong &= ~LeftShiftUlong(RightShiftUlong(((ULONG)0xFFFFFFFF),(32 - NumberToClear)),
                                                                    BitOffset);

        //
        //  And return to our caller
        //

        //DumpBitMap(BitMapHeader);

        return;
    }

    //
    //  We can clear out to the end of the first longword so we'll
    //  do that right now.
    //

    *CurrentLong &= ~LeftShiftUlong(0xFFFFFFFF, BitOffset);

    //
    //  And indicate what the next longword to clear is and how many
    //  bits are left to clear
    //

    CurrentLong += 1;
    NumberToClear -= 32 - BitOffset;

    //
    //  The bit position is now long aligned, so we can continue
    //  clearing longwords until the number to clear is less than 32
    //

    while (NumberToClear >= 32) {

        *CurrentLong = 0;
        CurrentLong += 1;
        NumberToClear -= 32;
    }

    //
    //  And now we can clear the remaining bits, if there are any, in the
    //  last longword
    //

    if (NumberToClear > 0) {

        *CurrentLong &= LeftShiftUlong(0xFFFFFFFF, NumberToClear);
    }

    //
    //  And return to our caller
    //

    //DumpBitMap(BitMapHeader);

    return;
}

VOID
RtlSetBits (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG StartingIndex,
    IN ULONG NumberToSet
    )

/*++

Routine Description:

    This procedure sets the specified range of bits within the
    specified bit map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialied BitMap.

    StartingIndex - Supplies the index (zero based) of the first bit to set.

    NumberToSet - Supplies the number of bits to set.

Return Value:

    None.

--*/
{
    ULONG BitOffset;
    PULONG CurrentLong;

    //DbgPrint("SetBits %08lx, ", NumberToSet);
    //DbgPrint("%08lx", StartingIndex);

    ASSERT( StartingIndex + NumberToSet <= BitMapHeader->SizeOfBitMap );

    //
    //  Special case the situation where the number of bits to set is
    //  zero.  Turn this into a noop.
    //

    if (NumberToSet == 0) {

        return;
    }

    BitOffset = StartingIndex % 32;

    //
    //  Get a pointer to the first longword that needs to be set
    //

    CurrentLong = &BitMapHeader->Buffer[ StartingIndex / 32 ];

    //
    //  Check if we can only need to set one longword.
    //

    if ((BitOffset + NumberToSet) <= 32) {

        //
        //  To build a mask of bits to set we shift left to get the number
        //  of bits we're setting and then shift right to put it in position.
        //  We'll typecast the right shift to ULONG to make sure it doesn't
        //  do a sign extend.
        //

        *CurrentLong |= LeftShiftUlong(RightShiftUlong(((ULONG)0xFFFFFFFF),(32 - NumberToSet)),
                                                                    BitOffset);

        //
        //  And return to our caller
        //

        //DumpBitMap(BitMapHeader);

        return;
    }

    //
    //  We can set bits out to the end of the first longword so we'll
    //  do that right now.
    //

    *CurrentLong |= LeftShiftUlong(0xFFFFFFFF, BitOffset);

    //
    //  And indicate what the next longword to set is and how many
    //  bits are left to set
    //

    CurrentLong += 1;
    NumberToSet -= 32 - BitOffset;

    //
    //  The bit position is now long aligned, so we can continue
    //  setting longwords until the number to set is less than 32
    //

    while (NumberToSet >= 32) {

        *CurrentLong = 0xffffffff;
        CurrentLong += 1;
        NumberToSet -= 32;
    }

    //
    //  And now we can set the remaining bits, if there are any, in the
    //  last longword
    //

    if (NumberToSet > 0) {

        *CurrentLong |= ~LeftShiftUlong(0xFFFFFFFF, NumberToSet);
    }

    //
    //  And return to our caller
    //

    //DumpBitMap(BitMapHeader);

    return;
}


#if DBG
BOOLEAN NtfsDebugIt = FALSE;
#endif

ULONG
RtlFindClearRuns (
    IN PRTL_BITMAP BitMapHeader,
    PRTL_BITMAP_RUN RunArray,
    ULONG SizeOfRunArray,
    BOOLEAN LocateLongestRuns
    )

/*++

Routine Description:

    This procedure finds N contiguous runs of clear bits
    within the specified bit map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized BitMap.

    RunArray - Receives the bit position, and length of each of the free runs
        that the procedure locates.  The array will be sorted according to
        length.

    SizeOfRunArray - Supplies the maximum number of entries the caller wants
        returned in RunArray

    LocateLongestRuns - Indicates if this routine is to return the longest runs
        it can find or just the first N runs.


Return Value:

    ULONG - Receives the number of runs that the procedure has located and
        returned in RunArray

--*/

{
    ULONG RunIndex;
    ULONG i;
    LONG j;

    ULONG SizeOfBitMap;
    ULONG SizeInBytes;

    ULONG CurrentRunSize;
    ULONG CurrentRunIndex;
    ULONG CurrentByteIndex;
    UCHAR CurrentByte;

    UCHAR BitMask;
    UCHAR TempNumber;

    GET_BYTE_DECLARATIONS();

    //
    //  Reference the bitmap header to make the loop run faster
    //

    SizeOfBitMap = BitMapHeader->SizeOfBitMap;
    SizeInBytes = (SizeOfBitMap + 7) / 8;

    //
    //  Set any unused bits in the last byte so we won't count them.  We do
    //  this by first checking if there is any odd bits in the last byte.
    //

    if ((SizeOfBitMap % 8) != 0) {

        //
        //  The last byte has some odd bits so we'll set the high unused
        //  bits in the last byte to 1's
        //

        ((PUCHAR)BitMapHeader->Buffer)[SizeInBytes - 1] |= ZeroMask[SizeOfBitMap % 8];
    }

    //
    //  Set it up so we can the use GET_BYTE macro
    //

    GET_BYTE_INITIALIZATION( BitMapHeader, 0);

    //
    //  Set our RunIndex and current run variables.  Run Index allays is the index
    //  of the next location to fill in or it could be one beyond the end of the
    //  array.
    //

    RunIndex = 0;
    for (i = 0; i < SizeOfRunArray; i += 1) { RunArray[i].NumberOfBits = 0; }

    CurrentRunSize = 0;
    CurrentRunIndex = 0;

    //
    //  Examine every byte in the BitMap
    //

    for (CurrentByteIndex = 0;
         CurrentByteIndex < SizeInBytes;
         CurrentByteIndex += 1) {

        GET_BYTE( CurrentByte );

#if DBG
        if (NtfsDebugIt) { DbgPrint("%d: %08lx %08lx %08lx %08lx %08lx\n",__LINE__,RunIndex,CurrentRunSize,CurrentRunIndex,CurrentByteIndex,CurrentByte); }
#endif

        //
        //  If the current byte is not all zeros we need to (1) check if
        //  the current run is big enough to be inserted in the output
        //  array, and (2) check if the current byte inside of itself can
        //  be inserted, and (3) start a new current run
        //

        if (CurrentByte != 0x00) {

            //
            //  Compute the final size of the current run
            //

            CurrentRunSize += RtlpBitsClearLow[CurrentByte];

            //
            //  Check if the current run be stored in the output array by either
            //  there being room in the array or the last entry is smaller than
            //  the current entry
            //

            if (CurrentRunSize > 0) {

                if ((RunIndex < SizeOfRunArray) ||
                    (RunArray[RunIndex-1].NumberOfBits < CurrentRunSize)) {

                    //
                    //  If necessary increment the RunIndex and shift over the output
                    //  array until we find the slot where the new run belongs.  We only
                    //  do the shifting if we're returning longest runs.
                    //

                    if (RunIndex < SizeOfRunArray) { RunIndex += 1; }

                    for (j = RunIndex-2; LocateLongestRuns && (j >= 0) && (RunArray[j].NumberOfBits < CurrentRunSize); j -= 1) {

                        RunArray[j+1] = RunArray[j];
                    }

                    RunArray[j+1].NumberOfBits = CurrentRunSize;
                    RunArray[j+1].StartingIndex = CurrentRunIndex;

#if DBG
                    if (NtfsDebugIt) { DbgPrint("%d: %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
                        __LINE__,RunIndex,CurrentRunSize,CurrentRunIndex,CurrentByteIndex,CurrentByte,j,RunArray[j+1].NumberOfBits,RunArray[j+1].StartingIndex); }
#endif

                    //
                    //  Now if the array is full and we are not doing longest runs return
                    //  to our caller
                    //

                    if (!LocateLongestRuns && (RunIndex >= SizeOfRunArray)) {

                        return RunIndex;
                    }
                }
            }

            //
            //  The next run starts with the remaining clear bits in the
            //  current byte.  We set this up before we check inside the
            //  current byte for a longer run, because the latter test
            //  might require extra work.
            //

            CurrentRunSize = RtlpBitsClearHigh[ CurrentByte ];
            CurrentRunIndex = (CurrentByteIndex * 8) + (8 - CurrentRunSize);

            //
            //  Set the low and high bits, otherwise we'll wind up thinking that we have a
            //  small run that needs to get added to the array, but these bits have
            //  just been accounting for
            //

            CurrentByte |= FillMask[RtlpBitsClearLow[CurrentByte]] |
                           ZeroMask[8-RtlpBitsClearHigh[CurrentByte]];

            //
            //  Check if the current byte contains a run inside of it that
            //  should go into the output array.  There may be multiple
            //  runs in the byte that we need to insert.
            //

            while ((CurrentByte != 0xff)

                        &&

                   ((RunIndex < SizeOfRunArray) ||
                    (RunArray[RunIndex-1].NumberOfBits < (ULONG)RtlpBitsClearAnywhere[CurrentByte]))) {

                TempNumber = RtlpBitsClearAnywhere[CurrentByte];

                //
                //  Somewhere in the current byte is a run to be inserted of
                //  size TempNumber.  All we need to do is find the index for this run.
                //

                BitMask = FillMask[ TempNumber ];

                for (i = 0; (BitMask & CurrentByte) != 0; i += 1) {

                    BitMask <<= 1;
                }

                //
                //  If necessary increment the RunIndex and shift over the output
                //  array until we find the slot where the new run belongs.  We only
                //  do the shifting if we're returning longest runs.
                //

                if (RunIndex < SizeOfRunArray) { RunIndex += 1; }

                for (j = RunIndex-2; LocateLongestRuns && (j >= 0) && (RunArray[j].NumberOfBits < TempNumber); j -= 1) {

                    RunArray[j+1] = RunArray[j];
                }

                RunArray[j+1].NumberOfBits = TempNumber;
                RunArray[j+1].StartingIndex = (CurrentByteIndex * 8) + i;

#if DBG
                if (NtfsDebugIt) { DbgPrint("%d: %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
                    __LINE__,RunIndex,CurrentRunSize,CurrentRunIndex,CurrentByteIndex,CurrentByte,j,RunArray[j+1].NumberOfBits,RunArray[j+1].StartingIndex); }
#endif

                //
                //  Now if the array is full and we are not doing longest runs return
                //  to our caller
                //

                if (!LocateLongestRuns && (RunIndex >= SizeOfRunArray)) {

                    return RunIndex;
                }

                //
                //  Mask out the bits and look for another run in the current byte
                //

                CurrentByte |= BitMask;
            }

        //
        //  Otherwise the current byte is all zeros and
        //  we simply continue with the current run
        //

        } else {

            CurrentRunSize += 8;
        }
    }

#if DBG
    if (NtfsDebugIt) { DbgPrint("%d: %08lx %08lx %08lx %08lx %08lx\n",__LINE__,RunIndex,CurrentRunSize,CurrentRunIndex,CurrentByteIndex,CurrentByte); }
#endif

    //
    //  See if we finished looking over the bitmap with an open current
    //  run that should be inserted in the output array
    //

    if (CurrentRunSize > 0) {

        if ((RunIndex < SizeOfRunArray) ||
            (RunArray[RunIndex-1].NumberOfBits < CurrentRunSize)) {

            //
            //  If necessary increment the RunIndex and shift over the output
            //  array until we find the slot where the new run belongs.
            //

            if (RunIndex < SizeOfRunArray) { RunIndex += 1; }

            for (j = RunIndex-2; LocateLongestRuns && (j >= 0) && (RunArray[j].NumberOfBits < CurrentRunSize); j -= 1) {

                RunArray[j+1] = RunArray[j];
            }

            RunArray[j+1].NumberOfBits = CurrentRunSize;
            RunArray[j+1].StartingIndex = CurrentRunIndex;

#if DBG
            if (NtfsDebugIt) { DbgPrint("%d: %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
                __LINE__,RunIndex,CurrentRunSize,CurrentRunIndex,CurrentByteIndex,CurrentByte,j,RunArray[j+1].NumberOfBits,RunArray[j+1].StartingIndex); }
#endif
        }
    }

    //
    //  Return to our caller
    //

    return RunIndex;
}


ULONG
RtlFindLongestRunClear (
    IN PRTL_BITMAP BitMapHeader,
    OUT PULONG StartingIndex
    )

/*++

Routine Description:

    This procedure finds the largest contiguous range of clear bits
    within the specified bit map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized BitMap.

    StartingIndex - Receives the index (zero based) of the first run
        equal to the longest run of clear bits in the BitMap.

Return Value:

    ULONG - Receives the number of bits contained in the largest contiguous
        run of clear bits.

--*/

{
    RTL_BITMAP_RUN RunArray[1];

    //
    //  Locate the longest run in the bitmap.  If there is one then
    //  return that run otherwise return the error condition.
    //

    if (RtlFindClearRuns( BitMapHeader, RunArray, 1, TRUE ) == 1) {

        *StartingIndex = RunArray[0].StartingIndex;
        return RunArray[0].NumberOfBits;
    }

    *StartingIndex = 0;
    return 0;
}


ULONG
RtlFindFirstRunClear (
    IN PRTL_BITMAP BitMapHeader,
    OUT PULONG StartingIndex
    )

/*++

Routine Description:

    This procedure finds the first contiguous range of clear bits
    within the specified bit map.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized BitMap.

    StartingIndex - Receives the index (zero based) of the first run
        equal to the longest run of clear bits in the BitMap.

Return Value:

    ULONG - Receives the number of bits contained in the first contiguous
        run of clear bits.

--*/

{
    return RtlFindNextForwardRunClear(BitMapHeader, 0, StartingIndex);
}


ULONG
RtlNumberOfClearBits (
    IN PRTL_BITMAP BitMapHeader
    )

/*++

Routine Description:

    This procedure counts and returns the number of clears bits within
    the specified bitmap.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized bitmap.

Return Value:

    ULONG - The total number of clear bits in the bitmap

--*/

{
    ULONG SizeOfBitMap;
    ULONG SizeInBytes;

    ULONG i;
    UCHAR CurrentByte;

    ULONG TotalClear;

    GET_BYTE_DECLARATIONS();

    //
    //  Reference the bitmap header to make the loop run faster
    //

    SizeOfBitMap = BitMapHeader->SizeOfBitMap;
    SizeInBytes = (SizeOfBitMap + 7) / 8;

    //
    //  Set any unused bits in the last byte so we don't count them.  We
    //  do this by first checking if there are any odd bits in the last byte
    //

    if ((SizeOfBitMap % 8) != 0) {

        //
        //  The last byte has some odd bits so we'll set the high unused
        //  bits in the last byte to 1's
        //

        ((PUCHAR)BitMapHeader->Buffer)[SizeInBytes - 1] |=
                                                    ZeroMask[SizeOfBitMap % 8];
    }

    //
    //  Set if up so we can use the GET_BYTE macro
    //

    GET_BYTE_INITIALIZATION( BitMapHeader, 0 );

    //
    //  Examine every byte in the bitmap
    //

    TotalClear = 0;
    for (i = 0; i < SizeInBytes; i += 1) {

        GET_BYTE( CurrentByte );

        TotalClear += RtlpBitsClearTotal[CurrentByte];
    }

    return TotalClear;
}


ULONG
RtlNumberOfSetBits (
    IN PRTL_BITMAP BitMapHeader
    )

/*++

Routine Description:

    This procedure counts and returns the number of set bits within
    the specified bitmap.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized bitmap.

Return Value:

    ULONG - The total number of set bits in the bitmap

--*/

{
    ULONG SizeOfBitMap;
    ULONG SizeInBytes;

    ULONG i;
    UCHAR CurrentByte;

    ULONG TotalSet;

    GET_BYTE_DECLARATIONS();

    //
    //  Reference the bitmap header to make the loop run faster
    //

    SizeOfBitMap = BitMapHeader->SizeOfBitMap;
    SizeInBytes = (SizeOfBitMap + 7) / 8;

    //
    //  Clear any unused bits in the last byte so we don't count them.  We
    //  do this by first checking if there are any odd bits in the last byte
    //

    if ((SizeOfBitMap % 8) != 0) {

        //
        //  The last byte has some odd bits so we'll set the high unused
        //  bits in the last byte to 0's
        //

        ((PUCHAR)BitMapHeader->Buffer)[SizeInBytes - 1] &=
                                                    FillMask[SizeOfBitMap % 8];
    }

    //
    //  Set if up so we can use the GET_BYTE macro
    //

    GET_BYTE_INITIALIZATION( BitMapHeader, 0 );

    //
    //  Examine every byte in the bitmap
    //

    TotalSet = 0;
    for (i = 0; i < SizeInBytes; i += 1) {

        GET_BYTE( CurrentByte );

        TotalSet += RtlpBitsSetTotal(CurrentByte);
    }

    return TotalSet;
}


BOOLEAN
RtlAreBitsClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG StartingIndex,
    IN ULONG Length
    )

/*++

Routine Description:

    This procedure determines if the range of specified bits are all clear.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized bitmap.

    StartingIndex - Supplies the starting bit index to examine

    Length - Supplies the number of bits to examine

Return Value:

    BOOLEAN - TRUE if the specified bits in the bitmap are all clear, and
        FALSE if any are set or if the range is outside the bitmap or if
        Length is zero.

--*/

{
    ULONG SizeOfBitMap;
    ULONG SizeInBytes;

    ULONG EndingIndex;

    ULONG StartingByte;
    ULONG EndingByte;

    ULONG StartingOffset;
    ULONG EndingOffset;

    ULONG i;
    UCHAR Byte;

    GET_BYTE_DECLARATIONS();

    //
    //  To make the loops in our test run faster we'll extract the fields
    //  from the bitmap header
    //

    SizeOfBitMap = BitMapHeader->SizeOfBitMap;
    SizeInBytes = (SizeOfBitMap + 7) / 8;

    //
    //  First make sure that the specified range is contained within the
    //  bitmap, and the length is not zero.
    //

    if ((StartingIndex + Length > SizeOfBitMap) || (Length == 0)) {

        return FALSE;
    }

    //
    //  Compute the ending index, starting and ending byte, and the starting
    //  and ending offset within each byte
    //

    EndingIndex = StartingIndex + Length - 1;

    StartingByte = StartingIndex / 8;
    EndingByte = EndingIndex / 8;

    StartingOffset = StartingIndex % 8;
    EndingOffset = EndingIndex % 8;

    //
    //  Set ourselves up to get the next byte
    //

    GET_BYTE_INITIALIZATION( BitMapHeader, StartingByte );

    //
    //  Special case the situation where the starting byte and ending
    //  byte are one in the same
    //

    if (StartingByte == EndingByte) {

        //
        //  Get the single byte we are to look at
        //

        GET_BYTE( Byte );

        //
        //  Now we compute the mask of bits we're after and then AND it with
        //  the byte.  If it is zero then the bits in question are all clear
        //  otherwise at least one of them is set.
        //

        if ((ZeroMask[StartingOffset] & FillMask[EndingOffset+1] & Byte) == 0) {

            return TRUE;

        } else {

            return FALSE;
        }

    } else {

        //
        //  Get the first byte that we're after, and then
        //  compute the mask of bits we're after for the first byte then
        //  AND it with the byte itself.
        //

        GET_BYTE( Byte );

        if ((ZeroMask[StartingOffset] & Byte) != 0) {

            return FALSE;
        }

        //
        //  Now for every whole byte inbetween read in the byte,
        //  and make sure it is all zeros
        //

        for (i = StartingByte+1; i < EndingByte; i += 1) {

            GET_BYTE( Byte );

            if (Byte != 0) {

                return FALSE;
            }
        }

        //
        //  Get the last byte we're after, and then
        //  compute the mask of bits we're after for the last byte then
        //  AND it with the byte itself.
        //

        GET_BYTE( Byte );

        if ((FillMask[EndingOffset+1] & Byte) != 0) {

            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
RtlAreBitsSet (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG StartingIndex,
    IN ULONG Length
    )

/*++

Routine Description:

    This procedure determines if the range of specified bits are all set.

Arguments:

    BitMapHeader - Supplies a pointer to the previously initialized bitmap.

    StartingIndex - Supplies the starting bit index to examine

    Length - Supplies the number of bits to examine

Return Value:

    BOOLEAN - TRUE if the specified bits in the bitmap are all set, and
        FALSE if any are clear or if the range is outside the bitmap or if
        Length is zero.

--*/

{
    ULONG SizeOfBitMap;
    ULONG SizeInBytes;

    ULONG EndingIndex;

    ULONG StartingByte;
    ULONG EndingByte;

    ULONG StartingOffset;
    ULONG EndingOffset;

    ULONG i;
    UCHAR Byte;

    GET_BYTE_DECLARATIONS();

    //
    //  To make the loops in our test run faster we'll extract the fields
    //  from the bitmap header
    //

    SizeOfBitMap = BitMapHeader->SizeOfBitMap;
    SizeInBytes = (SizeOfBitMap + 7) / 8;

    //
    //  First make sure that the specified range is contained within the
    //  bitmap, and the length is not zero.
    //

    if ((StartingIndex + Length > SizeOfBitMap) || (Length == 0)) {

        return FALSE;
    }

    //
    //  Compute the ending index, starting and ending byte, and the starting
    //  and ending offset within each byte
    //

    EndingIndex = StartingIndex + Length - 1;

    StartingByte = StartingIndex / 8;
    EndingByte = EndingIndex / 8;

    StartingOffset = StartingIndex % 8;
    EndingOffset = EndingIndex % 8;

    //
    //  Set ourselves up to get the next byte
    //

    GET_BYTE_INITIALIZATION( BitMapHeader, StartingByte );

    //
    //  Special case the situation where the starting byte and ending
    //  byte are one in the same
    //

    if (StartingByte == EndingByte) {

        //
        //  Get the single byte we are to look at
        //

        GET_BYTE( Byte );

        //
        //  Now we compute the mask of bits we're after and then AND it with
        //  the complement of the byte If it is zero then the bits in question
        //  are all clear otherwise at least one of them is clear.
        //

        if ((ZeroMask[StartingOffset] & FillMask[EndingOffset+1] & ~Byte) == 0) {

            return TRUE;

        } else {

            return FALSE;
        }

    } else {

        //
        //  Get the first byte that we're after, and then
        //  compute the mask of bits we're after for the first byte then
        //  AND it with the complement of the byte itself.
        //

        GET_BYTE( Byte );

        if ((ZeroMask[StartingOffset] & ~Byte) != 0) {

            return FALSE;
        }

        //
        //  Now for every whole byte inbetween read in the byte,
        //  and make sure it is all ones
        //

        for (i = StartingByte+1; i < EndingByte; i += 1) {

            GET_BYTE( Byte );

            if (Byte != 0xff) {

                return FALSE;
            }
        }

        //
        //  Get the last byte we're after, and then
        //  compute the mask of bits we're after for the last byte then
        //  AND it with the complement of the byte itself.
        //

        GET_BYTE( Byte );

        if ((FillMask[EndingOffset+1] & ~Byte) != 0) {

            return FALSE;
        }
    }

    return TRUE;
}

static CONST ULONG FillMaskUlong[] = {
    0x00000000, 0x00000001, 0x00000003, 0x00000007,
    0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f,
    0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff,
    0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff,
    0x0000ffff, 0x0001ffff, 0x0003ffff, 0x0007ffff,
    0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff,
    0x00ffffff, 0x01ffffff, 0x03ffffff, 0x07ffffff,
    0x0fffffff, 0x1fffffff, 0x3fffffff, 0x7fffffff,
    0xffffffff
};


ULONG
RtlFindNextForwardRunClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG FromIndex,
    IN PULONG StartingRunIndex
    )
{
    ULONG Start;
    ULONG End;
    PULONG PHunk, BitMapEnd;
    ULONG Hunk;

    //
    // Take care of the boundary case of the null bitmap
    //

    if (BitMapHeader->SizeOfBitMap == 0) {

        *StartingRunIndex = FromIndex;
        return 0;
    }

    //
    //  Compute the last word address in the bitmap
    //

    BitMapEnd = BitMapHeader->Buffer + ((BitMapHeader->SizeOfBitMap - 1) / 32);

    //
    //  Scan forward for the first clear bit
    //

    Start = FromIndex;

    //
    //  Build pointer to the ULONG word in the bitmap
    //  containing the Start bit
    //

    PHunk = BitMapHeader->Buffer + (Start / 32);

    //
    //  If the first subword is set then we can proceed to
    //  take big steps in the bitmap since we are now ULONG
    //  aligned in the search. Make sure we aren't improperly
    //  looking at the last word in the bitmap.
    //

    if (PHunk != BitMapEnd) {

        //
        //  Read in the bitmap hunk. Set the previous bits in this word.
        //

        Hunk = *PHunk | FillMaskUlong[Start % 32];

        if (Hunk == (ULONG)~0) {

            //
            //  Adjust the pointers forward
            //

            Start += 32 - (Start % 32);
            PHunk++;

            while ( PHunk < BitMapEnd ) {

                //
                //  Stop at first word with unset bits
                //

                if (*PHunk != (ULONG)~0) break;

                PHunk++;
                Start += 32;
            }
        }
    }

    //
    //  Bitwise search forward for the clear bit
    //

    while ((Start < BitMapHeader->SizeOfBitMap) && (RtlCheckBit( BitMapHeader, Start ) == 1)) { Start += 1; }

    //
    //  Scan forward for the first set bit
    //

    End = Start;

    //
    //  If we aren't in the last word of the bitmap we may be
    //  able to keep taking big steps
    //

    if (PHunk != BitMapEnd) {

        //
        //  We know that the clear bit was in the last word we looked at,
        //  so continue from there to find the next set bit, clearing the
        //  previous bits in the word
        //

        Hunk = *PHunk & ~FillMaskUlong[End % 32];

        if (Hunk == (ULONG)0) {

            //
            //  Adjust the pointers forward
            //

            End += 32 - (End % 32);
            PHunk++;

            while ( PHunk < BitMapEnd ) {

                //
                //  Stop at first word with set bits
                //

                if (*PHunk != (ULONG)0) break;

                PHunk++;
                End += 32;
            }
        }
    }

    //
    //  Bitwise search forward for the set bit
    //

    while ((End < BitMapHeader->SizeOfBitMap) && (RtlCheckBit( BitMapHeader, End ) == 0)) { End += 1; }

    //
    //  Compute the index and return the length
    //

    *StartingRunIndex = Start;
    return (End - Start);
}


ULONG
RtlFindLastBackwardRunClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG FromIndex,
    IN PULONG StartingRunIndex
    )
{
    ULONG Start;
    ULONG End;
    PULONG PHunk;
    ULONG Hunk;

    //
    //  Take care of the boundary case of the null bitmap
    //

    if (BitMapHeader->SizeOfBitMap == 0) {

        *StartingRunIndex = FromIndex;
        return 0;
    }

    //
    //  Scan backwards for the first clear bit
    //

    End = FromIndex;

    //
    //  Build pointer to the ULONG word in the bitmap
    //  containing the End bit, then read in the bitmap
    //  hunk. Set the rest of the bits in this word, NOT
    //  inclusive of the FromIndex bit.
    //

    PHunk = BitMapHeader->Buffer + (End / 32);
    Hunk = *PHunk | ~FillMaskUlong[(End % 32) + 1];

    //
    //  If the first subword is set then we can proceed to
    //  take big steps in the bitmap since we are now ULONG
    //  aligned in the search
    //

    if (Hunk == (ULONG)~0) {

        //
        //  Adjust the pointers backwards
        //

        End -= (End % 32) + 1;
        PHunk--;

        while ( PHunk > BitMapHeader->Buffer ) {

            //
            //  Stop at first word with set bits
            //

            if (*PHunk != (ULONG)~0) break;

            PHunk--;
            End -= 32;
        }
    }

    //
    //  Bitwise search backward for the clear bit
    //

    while ((End != MAXULONG) && (RtlCheckBit( BitMapHeader, End ) == 1)) { End -= 1; }

    //
    //  Scan backwards for the first set bit
    //

    Start = End;

    //
    //  We know that the clear bit was in the last word we looked at,
    //  so continue from there to find the next set bit, clearing the
    //  previous bits in the word.
    //

    Hunk = *PHunk & FillMaskUlong[Start % 32];

    //
    //  If the subword is unset then we can proceed in big steps
    //

    if (Hunk == (ULONG)0) {

        //
        //  Adjust the pointers backward
        //

        Start -= (Start % 32) + 1;
        PHunk--;

        while ( PHunk > BitMapHeader->Buffer ) {

            //
            //  Stop at first word with set bits
            //

            if (*PHunk != (ULONG)0) break;

            PHunk--;
            Start -= 32;
        }
    }

    //
    //  Bitwise search backward for the set bit
    //

    while ((Start != MAXULONG) && (RtlCheckBit( BitMapHeader, Start ) == 0)) { Start -= 1; }

    //
    //  Compute the index and return the length
    //

    *StartingRunIndex = Start + 1;
    return (End - Start);
}

#endif // MILLEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\common\sources.inc ===
TARGETNAME=common
TARGETPATH=obj
TARGETTYPE=DRIVER_LIBRARY

C_DEFINES=$(C_DEFINES) -DNT -D_NTDRIVER_
NT_UP=0

INCLUDES=..\;..\..\inc;$(BASE_INC_PATH)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\common\pplasl.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    pplasl.c

Abstract:

    This file contains the implementation of a per-processor lookaside
    list manager.

Author:

    Shaun Cox (shaunco) 25-Oct-1999

--*/

#include "ntddk.h"
#include "pplasl.h"


HANDLE
PplCreatePool(
    IN PALLOCATE_FUNCTION Allocate,
    IN PFREE_FUNCTION Free,
    IN ULONG Flags,
    IN SIZE_T Size,
    IN ULONG Tag,
    IN USHORT Depth
    )
{
    HANDLE PoolHandle;
    SIZE_T PoolSize;
    CCHAR NumberProcessors;
    CCHAR NumberLookasideLists;
    CCHAR i;
    PNPAGED_LOOKASIDE_LIST Lookaside;

#if MILLEN
    NumberProcessors = 1;
#else // MILLEN
    NumberProcessors = KeNumberProcessors;
#endif // !MILLEN

    // Allocate room for 1 lookaside list per processor plus 1 extra
    // lookaside list for overflow.  Only allocate 1 lookaside list if
    // we're on a single processor machine.
    //
    NumberLookasideLists = NumberProcessors;
    if (NumberProcessors > 1)
    {
        NumberLookasideLists++;
    }

    PoolSize = sizeof(NPAGED_LOOKASIDE_LIST) * NumberLookasideLists;

    PoolHandle = ExAllocatePoolWithTagPriority(NonPagedPool, PoolSize, Tag,
                                               NormalPoolPriority);
    if (PoolHandle)
    {
        for (i = 0, Lookaside = (PNPAGED_LOOKASIDE_LIST)PoolHandle;
             i < NumberLookasideLists;
             i++, Lookaside++)
        {
            ExInitializeNPagedLookasideList(
                Lookaside,
                Allocate,
                Free,
                Flags,
                Size,
                Tag,
                Depth);

            // ExInitializeNPagedLookasideList doesn't really set the
            // maximum depth to Depth, so we'll do it here.
            //
            if (Depth != 0) {
                Lookaside->L.MaximumDepth = Depth;
            }
        }
    }

    return PoolHandle;
}

VOID
PplDestroyPool(
    IN HANDLE PoolHandle
    )
{
    CCHAR NumberProcessors;
    CCHAR NumberLookasideLists;
    CCHAR i;
    PNPAGED_LOOKASIDE_LIST Lookaside;

    if (!PoolHandle)
    {
        return;
    }

#if MILLEN
    NumberProcessors = 1;
#else // MILLEN
    NumberProcessors = KeNumberProcessors;
#endif // !MILLEN

    NumberLookasideLists = NumberProcessors;
    if (NumberProcessors > 1)
    {
        NumberLookasideLists++;
    }

    for (i = 0, Lookaside = (PNPAGED_LOOKASIDE_LIST)PoolHandle;
         i < NumberLookasideLists;
         i++, Lookaside++)
    {
        ExDeleteNPagedLookasideList(Lookaside);
    }

    ExFreePool(PoolHandle);
}

PVOID
PplAllocate(
    IN HANDLE PoolHandle,
    OUT LOGICAL *FromList
    )
{
    PNPAGED_LOOKASIDE_LIST Lookaside;
    CCHAR NumberProcessors;
    PVOID Entry;

    // Assume we'll get the item from the lookaside list.
    //
    *FromList = TRUE;

#if MILLEN
    NumberProcessors = 1;
#else // MILLEN
    NumberProcessors = KeNumberProcessors;
#endif // !MILLEN

    if (1 == NumberProcessors)
    {
        goto SingleProcessorCaseOrMissedPerProcessor;
    }

    // Try first for the per-processor lookaside list.
    //
    Lookaside = (PNPAGED_LOOKASIDE_LIST)PoolHandle +
                    KeGetCurrentProcessorNumber() + 1;

    Lookaside->L.TotalAllocates += 1;
    Entry = InterlockedPopEntrySList(&Lookaside->L.ListHead);
    if (!Entry)
    {
        Lookaside->L.AllocateMisses += 1;

SingleProcessorCaseOrMissedPerProcessor:
        // We missed on the per-processor lookaside list, (or we're
        // running on a single processor machine) so try for
        // the overflow lookaside list.
        //
        Lookaside = (PNPAGED_LOOKASIDE_LIST)PoolHandle;

        Lookaside->L.TotalAllocates += 1;
        Entry = InterlockedPopEntrySList(&Lookaside->L.ListHead);
        if (!Entry)
        {
            Lookaside->L.AllocateMisses += 1;
            Entry = (Lookaside->L.Allocate)(
                        Lookaside->L.Type,
                        Lookaside->L.Size,
                        Lookaside->L.Tag);
            *FromList = FALSE;
        }
    }
    return Entry;
}

VOID
PplFree(
    IN HANDLE PoolHandle,
    IN PVOID Entry
    )
{
    PNPAGED_LOOKASIDE_LIST Lookaside;
    CCHAR NumberProcessors;

#if MILLEN
    NumberProcessors = 1;
#else // MILLEN
    NumberProcessors = KeNumberProcessors;
#endif // !MILLEN

    if (1 == NumberProcessors)
    {
        goto SingleProcessorCaseOrMissedPerProcessor;
    }

    // Try first for the per-processor lookaside list.
    //
    Lookaside = (PNPAGED_LOOKASIDE_LIST)PoolHandle +
                    KeGetCurrentProcessorNumber() + 1;

    Lookaside->L.TotalFrees += 1;
    if (ExQueryDepthSList(&Lookaside->L.ListHead) >= Lookaside->L.Depth)
    {
        Lookaside->L.FreeMisses += 1;

SingleProcessorCaseOrMissedPerProcessor:
        // We missed on the per-processor lookaside list, (or we're
        // running on a single processor machine) so try for
        // the overflow lookaside list.
        //
        Lookaside = (PNPAGED_LOOKASIDE_LIST)PoolHandle;

        Lookaside->L.TotalFrees += 1;
        if (ExQueryDepthSList(&Lookaside->L.ListHead) >= Lookaside->L.Depth)
        {
            Lookaside->L.FreeMisses += 1;
            (Lookaside->L.Free)(Entry);
        }
        else
        {
            InterlockedPushEntrySList(
                &Lookaside->L.ListHead,
                (PSINGLE_LIST_ENTRY)Entry);
        }
    }
    else
    {
        InterlockedPushEntrySList(
            &Lookaside->L.ListHead,
            (PSINGLE_LIST_ENTRY)Entry);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\common\9x\mdl2ndis.c ===
/*--Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    mdl2ndis.c

Abstract:

    MDL <--> NDIS_BUFFER conversion

Author:

    Bruce Johnson (bjohnson) 31-Aug-1999

--*/

#include <tcpipbase.h>

#if MILLEN

ULONG g_cConvertedNdisBuffers = 0;
ULONG g_cConvertedMdls        = 0;

TDI_STATUS
ConvertMdlToNdisBuffer(
    PIRP          pIrp,
    PMDL          pMdl,
    PNDIS_BUFFER *ppNdisBuffer
    )
{
    NDIS_STATUS         NdisStatus;
    PVOID               VirtualAddress;
    ULONG               Length;
    PNDIS_BUFFER        pNdisBuffer;
    TDI_STATUS          TdiStatus = TDI_SUCCESS;
#ifdef DEBUG_MSG
    PMDL                pSavedMdl = pMdl;
#endif // DEBUG_MSG

    //
    // Allocate the NDIS_BUFFER chain describing the MDL chain.
    //

    *ppNdisBuffer = NULL;
    pNdisBuffer   = NULL;

    do {
        VirtualAddress = MmGetSystemAddressForMdl(pMdl);
        Length         = MmGetMdlByteCount(pMdl);

        NdisAllocateBuffer(
            &NdisStatus,
            (pNdisBuffer == NULL) ? (&pNdisBuffer) : (&(pNdisBuffer->Next)),
            NULL, //gBufferPool
            VirtualAddress,
            Length
            );

        if (NdisStatus != NDIS_STATUS_SUCCESS) {
            DEBUGMSG(DBG_ERROR,
                (DTEXT("ConvertMdlToNdisBuffer failed to allocate NDIS_BUFFER.\n")));
            break;
        }

        if (*ppNdisBuffer != NULL) {
            pNdisBuffer = pNdisBuffer->Next;
        }
        else {
            *ppNdisBuffer = pNdisBuffer;
        }

        pNdisBuffer->Next = NULL;

        pMdl = pMdl->Next;

    } while (pMdl != NULL);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        PNDIS_BUFFER pNext;

        pNdisBuffer = *ppNdisBuffer;

        while (pNdisBuffer) {
            pNext = pNdisBuffer->Next;
            NdisFreeBuffer(pNdisBuffer);
            pNdisBuffer = pNext;
        }

        *ppNdisBuffer = NULL;
        TdiStatus = TDI_NO_RESOURCES;
        goto done;
    }

    InterlockedIncrement(&g_cConvertedNdisBuffers);

done:

    // Ensure that it is initialized, either way.
    pIrp->Tail.Overlay.DriverContext[0] = *ppNdisBuffer;

    DEBUGMSG(DBG_INFO && DBG_TDI && DBG_VERBOSE,
        (DTEXT("Convert IRP %x MDL %x NDIS_BUFFER %x\n"),
         pIrp, pSavedMdl, *ppNdisBuffer));

    return TdiStatus;
}

TDI_STATUS
FreeMdlToNdisBufferChain(
    PIRP pIrp
    )
{
    PNDIS_BUFFER pNdisBuffer = pIrp->Tail.Overlay.DriverContext[0];
    PNDIS_BUFFER pNext;

    if (pNdisBuffer == NULL) {
        goto done;
    }

    DEBUGMSG(DBG_INFO && DBG_TDI && DBG_VERBOSE,
        (DTEXT("FreeConvert IRP %x NdisBuffer %x\n"), pIrp, pNdisBuffer));

    do {
        pNext = pNdisBuffer->Next;
        NdisFreeBuffer(pNdisBuffer);
        pNdisBuffer = pNext;
    } while (pNdisBuffer);

    pIrp->Tail.Overlay.DriverContext[0] = NULL;
    InterlockedDecrement(&g_cConvertedNdisBuffers);

done:
    return TDI_SUCCESS;
}

TDI_STATUS
ConvertNdisBufferToMdl(
    PNDIS_BUFFER pNdisBuffer,
    PMDL        *ppMdl
    )
{
    NDIS_STATUS  NdisStatus = NDIS_STATUS_SUCCESS;
    TDI_STATUS   TdiStatus  = TDI_SUCCESS;
    PVOID        VirtualAddress;
    ULONG        Length;
    PMDL         pMdl   = NULL;
    PMDL         pLast  = NULL;
#ifdef DEBUG_MSG
    PNDIS_BUFFER pSavedNdisBuffer = pNdisBuffer;
#endif // DEBUG_MSG

    *ppMdl = NULL;

    do {
        NdisQueryBuffer(
            pNdisBuffer,
            &VirtualAddress,
            &Length);

        pMdl = IoAllocateMdl(
            VirtualAddress,
            Length,
            FALSE,
            FALSE,
            NULL);

        if (pMdl == NULL) {
            DEBUGMSG(DBG_ERROR,
                (DTEXT("ConvertNdisBufferToMdl failed to allocate MDL.\n")));
            NdisStatus = NDIS_STATUS_RESOURCES;
            break;
        }

        if (*ppMdl != NULL) {
            pLast->Next = pMdl;
        } else {
            *ppMdl = pMdl;
        }

        pMdl->Next = NULL;
        pLast      = pMdl;

        pNdisBuffer = pNdisBuffer->Next;

    } while (pNdisBuffer != NULL);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        PMDL pNext;

        pMdl = *ppMdl;

        while (pMdl) {
            pNext = pMdl->Next;
            IoFreeMdl(pMdl);
            pMdl = pNext;
        }

        *ppMdl = NULL;
        TdiStatus = TDI_NO_RESOURCES;
        goto done;
    }

    InterlockedIncrement(&g_cConvertedMdls);

done:

    DEBUGMSG(DBG_INFO && DBG_TDI && DBG_VERBOSE,
        (DTEXT("Convert NDIS_BUFFER %x MDL %x\n"),
         pSavedNdisBuffer, *ppMdl));

    return TdiStatus;
}

TDI_STATUS
FreeNdisBufferToMdlChain(
    PMDL pMdl
    )
{
    PMDL pNext;

    DEBUGMSG(DBG_INFO && DBG_TDI && DBG_VERBOSE,
        (DTEXT("FreeConvert MDL %x\n"), pMdl));

    while (pMdl) {
        pNext = pMdl->Next;
        IoFreeMdl(pMdl);
        pMdl = pNext;
    }

    InterlockedDecrement(&g_cConvertedMdls);
    return TDI_SUCCESS;
}

#endif // MILLEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\common\9x\mdlpool9x.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    mdlpool9x.c

Abstract:

    This file contains the implementation of an NDIS_BUFFER pool.

Author:

    Shaun Cox (shaunco) 11-Nov-1999

--*/

#include "ndis.h"
#include "mdlpool.h"


// The pool structure itself is just a look aside list allocated out of
// non-paged pool.
//
// Each entry in the look aside list is an NDIS_BUFFER structure followed
// by the buffer itself.  We initialize the NDIS_BUFFER structure each
// time we allocate from the look aside list.  We need to do this in order
// to properly associate the NDIS_BUFFER with its owning pool.  This is not
// possible to do with a custom allocate routine for the look aside list
// because their is no provision for an extra context parameter to the
// look aside allocate function.
//

// ---- Temporary Definitions until ndis.h is updated for Millennium -----
//

typedef struct _XNDIS_BUFFER {
    struct _NDIS_BUFFER *Next;
    PVOID VirtualAddress;
    PVOID Pool;
    UINT Length;
    UINT Signature;
} XNDIS_BUFFER, *PXNDIS_BUFFER;

__inline
SIZE_T
NDIS_SIZEOF_NDIS_BUFFER(
    VOID
    )
{
    return sizeof(XNDIS_BUFFER);
}

__inline
VOID
NdisInitializeNdisBuffer(
    OUT PNDIS_BUFFER Buffer,
    IN PVOID Pool,
    IN PVOID VirtualAddress,
    IN UINT Length
    )
{
    PXNDIS_BUFFER Internal = (PXNDIS_BUFFER)Buffer;

    Internal->Next = 0;
    Internal->Pool = Pool;
    Internal->VirtualAddress = VirtualAddress;
    Internal->Length = Length;
    Internal->Signature = 0;
}

__inline
PVOID
NdisGetPoolFromNdisBuffer(
    IN PNDIS_BUFFER Buffer
    )
{
    PXNDIS_BUFFER Internal = (PXNDIS_BUFFER)Buffer;

    return Internal->Pool;
}

// ---- End temporary Definitions until ndis.h is updated for Millennium -----



UINT SizeOfNdisBufferStructure;

// Creates a pool of NDIS_BUFFERs built over non-paged pool.  Each
// NDIS_BUFFER describes a buffer that is BufferSize bytes long.
// If NULL is not returned, MdpDestroyPool should be called at a later time
// to reclaim the resources used by the pool.
//
// Arguments:
//  BufferSize - The size, in bytes, of the buffer that each MDL
//      should describe.
//  Tag - The pool tag to be used internally for calls to
//      ExAllocatePoolWithTag.  This allows callers to track
//      memory consumption for different pools.
//
//  Returns the handle used to identify the pool.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
HANDLE
MdpCreatePool(
    IN USHORT BufferSize,
    IN ULONG Tag
    )
{
    PNPAGED_LOOKASIDE_LIST Lookaside;

    ASSERT(BufferSize);

    // Cache the constant value of an NDIS_BUFFER structure size to
    // avoid calling back into NDIS everytime we want a buffer.
    //
    if (0 == SizeOfNdisBufferStructure)
    {
        SizeOfNdisBufferStructure = NDIS_SIZEOF_NDIS_BUFFER();
    }

    ASSERT(SizeOfNdisBufferStructure);

    // Allocate the pool header.  This is a look aside list on Millenium.
    //
    Lookaside = ExAllocatePoolWithTag(
                    NonPagedPool,
                    sizeof(NPAGED_LOOKASIDE_LIST),
                    ' pdM');

    if (Lookaside)
    {
        // The size of the entries allocated by the look aside list are
        // the NDIS_BUFFER structure size plus the buffer size requested by
        // the caller.
        //
        ExInitializeNPagedLookasideList(
            Lookaside,
            NULL,
            NULL,
            0,
            SizeOfNdisBufferStructure + BufferSize,
            Tag,
            0);
    }

    return Lookaside;
}

// Destroys a pool of NDIS_BUFFERs previously created by a call to
// MdpCreatePool.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being destroyed.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
VOID
MdpDestroyPool(
    IN HANDLE PoolHandle
    )
{
    ExDeleteNPagedLookasideList(PoolHandle);
}

// Returns an NDIS_BUFFER allocated from a pool.  NULL is returned if the
// request could not be granted.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being allocated from.
//  Buffer - Address to receive the pointer to the underlying mapped buffer
//      described by the MDL.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
PNDIS_BUFFER
MdpAllocate(
    IN HANDLE PoolHandle,
    OUT PVOID* Buffer
    )
{
    PNPAGED_LOOKASIDE_LIST Lookaside;
    PNDIS_BUFFER NdisBuffer;
    PUCHAR VirtualAddress;

    ASSERT(PoolHandle);

    Lookaside = (PNPAGED_LOOKASIDE_LIST)PoolHandle;

    // Get an item from the look aside list.
    //
    NdisBuffer = ExAllocateFromNPagedLookasideList(Lookaside);

    if (NdisBuffer)
    {
        // (Re)Initialize it to associate it with the pool handle so that
        // we know which look aside list to return it to when it is freed.
        //
        VirtualAddress = (PUCHAR)NdisBuffer + SizeOfNdisBufferStructure;

        NdisInitializeNdisBuffer(
            NdisBuffer,
            PoolHandle,
            VirtualAddress,
            Lookaside->L.Size - SizeOfNdisBufferStructure);

        *Buffer = VirtualAddress;
    }

    return NdisBuffer;
}

// Free an NDIS_BUFFER to the pool from which it was allocated.
//
// Arguments:
//  NdisBuffer - An NDIS_BUFFER returned from a prior call to MdpAllocate.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
VOID
MdpFree(
    IN PNDIS_BUFFER NdisBuffer
    )
{
    PNPAGED_LOOKASIDE_LIST Lookaside;

    // Locate the owning look aside list for this buffer and return it.
    //
    Lookaside = NdisGetPoolFromNdisBuffer(NdisBuffer);
    ASSERT(Lookaside);

    ExFreeToNPagedLookasideList(Lookaside, NdisBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\common\9x\pplasl9x.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    pplasl9x.c

Abstract:

    This file contains the implementation of lookaside
    list manager.

Author:

    Scott Holden (sholden) 14-Apr-2000

--*/

#include "wdm.h"
#include "ndis.h"
#include "cxport.h"
#include "pplasl.h"

// Keep scan period at one second -- this will make TCP/IP more responsive to 
// short bursts.
#define MAXIMUM_SCAN_PERIOD             1
#define MINIMUM_ALLOCATION_THRESHOLD    25
#define MINIMUM_LOOKASIDE_DEPTH         10



LIST_ENTRY PplLookasideListHead;
KSPIN_LOCK PplLookasideLock;
CTETimer PplTimer;
ULONG PplCurrentScanPeriod = 1;

VOID PplTimeout(CTEEvent * Timer, PVOID Context);

BOOLEAN
PplInit(VOID)
{
    InitializeListHead(&PplLookasideListHead);
    CTEInitTimer(&PplTimer);
    KeInitializeSpinLock(&PplLookasideLock);
    CTEStartTimer(&PplTimer, 1000L, PplTimeout, NULL);

    return TRUE;
}

VOID 
PplDeinit(VOID)
{
    CTEStopTimer(&PplTimer);
    return;
}

HANDLE
PplCreatePool(
    IN PALLOCATE_FUNCTION Allocate,
    IN PFREE_FUNCTION Free,
    IN ULONG Flags,
    IN SIZE_T Size,
    IN ULONG Tag,
    IN USHORT Depth
    )
{
    HANDLE PoolHandle;
    SIZE_T PoolSize;
    PNPAGED_LOOKASIDE_LIST Lookaside;

    PoolSize = sizeof(NPAGED_LOOKASIDE_LIST);

    PoolHandle = ExAllocatePoolWithTag(NonPagedPool, PoolSize, Tag);

    if (PoolHandle) {

        Lookaside = (PNPAGED_LOOKASIDE_LIST)PoolHandle;

        ExInitializeSListHead(&Lookaside->L.ListHead);
        Lookaside->L.Depth = MINIMUM_LOOKASIDE_DEPTH;
        Lookaside->L.MaximumDepth = Depth;
        Lookaside->L.TotalAllocates = 0;
        Lookaside->L.AllocateMisses = 0;
        Lookaside->L.TotalFrees = 0;
        Lookaside->L.FreeMisses = 0;
        Lookaside->L.Type = NonPagedPool | Flags;
        Lookaside->L.Tag = Tag;
        Lookaside->L.Size = Size;

        if (Allocate == NULL) {
            Lookaside->L.Allocate = ExAllocatePoolWithTag;
        } else {
            Lookaside->L.Allocate = Allocate;
        }

        if (Free == NULL) {
            Lookaside->L.Free = ExFreePool;
        } else {
            Lookaside->L.Free = Free;
        }

        Lookaside->L.LastTotalAllocates = 0;
        Lookaside->L.LastAllocateMisses = 0;
        
        KeInitializeSpinLock(&Lookaside->Lock);

        //
        // Insert the lookaside list structure the PPL lookaside list.
        //

        ExInterlockedInsertTailList(&PplLookasideListHead,
                                    &Lookaside->L.ListEntry,
                                    &PplLookasideLock);

    }

    return PoolHandle;
}

VOID
PplDestroyPool(
    IN HANDLE PoolHandle
    )
{
    PNPAGED_LOOKASIDE_LIST Lookaside;
    PVOID Entry;
    KIRQL OldIrql;

    if (PoolHandle == NULL) {
        return;
    }

    Lookaside = (PNPAGED_LOOKASIDE_LIST)PoolHandle;

    //
    // Acquire the nonpaged system lookaside list lock and remove the
    // specified lookaside list structure from the list.
    //

    ExAcquireSpinLock(&PplLookasideLock, &OldIrql);
    RemoveEntryList(&Lookaside->L.ListEntry);
    ExReleaseSpinLock(&PplLookasideLock, OldIrql);

    //
    // Remove all pool entries from the specified lookaside structure
    // and free them.
    //

    while ((Entry = ExAllocateFromNPagedLookasideList(Lookaside)) != NULL) {
        (Lookaside->L.Free)(Entry);
    }

    ExFreePool(PoolHandle);

    return;
}

PVOID
PplAllocate(
    IN HANDLE PoolHandle,
    OUT LOGICAL *FromList
    )
{
    PNPAGED_LOOKASIDE_LIST Lookaside;
    PVOID Entry;

    // Assume we'll get the item from the lookaside list.
    //
    *FromList = TRUE;

    Lookaside = (PNPAGED_LOOKASIDE_LIST)PoolHandle;

    Lookaside->L.TotalAllocates += 1;

    Entry = ExInterlockedPopEntrySList(&Lookaside->L.ListHead, &Lookaside->Lock);

    if (Entry == NULL) {
        Lookaside->L.AllocateMisses += 1;
        Entry = (Lookaside->L.Allocate)(Lookaside->L.Type,
                                        Lookaside->L.Size,
                                        Lookaside->L.Tag);
        *FromList = FALSE;
    }

    return Entry;
}

VOID
PplFree(
    IN HANDLE PoolHandle,
    IN PVOID Entry
    )
{
    PNPAGED_LOOKASIDE_LIST Lookaside = (PNPAGED_LOOKASIDE_LIST)PoolHandle;

    Lookaside->L.TotalFrees += 1;
    if (ExQueryDepthSList(&Lookaside->L.ListHead) >= Lookaside->L.Depth) {
        Lookaside->L.FreeMisses += 1;
        (Lookaside->L.Free)(Entry);

    } else {
        ExInterlockedPushEntrySList(&Lookaside->L.ListHead,
                                    (PSINGLE_LIST_ENTRY)Entry,
                                    &Lookaside->Lock);
    }

    return;
}

LOGICAL
PplComputeLookasideDepth (
    IN ULONG Allocates,
    IN ULONG Misses,
    IN USHORT MaximumDepth,
    IN OUT PUSHORT Depth
    )

/*++

Routine Description:

    This function computes the target depth of a lookaside list given the
    total allocations and misses during the last scan period and the current
    depth.

Arguments:

    Allocates - Supplies the total number of allocations during the last
        scan period.

    Misses - Supplies the total number of allocate misses during the last
        scan period.

    MaximumDepth - Supplies the maximum depth the lookaside list is allowed
        to reach.

    Depth - Supplies a pointer to the current lookaside list depth which
        receives the target depth.

Return Value:

    If the target depth is greater than the current depth, then a value of
    TRUE is returned as the function value. Otherwise, a value of FALSE is
    returned.

--*/

{

    LOGICAL Changes;
    ULONG Ratio;
    ULONG Target;

    //
    // If the allocate rate is less than the mimimum threshold, then lower
    // the maximum depth of the lookaside list. Otherwise, if the miss rate
    // is less than .5%, then lower the maximum depth. Otherwise, raise the
    // maximum depth based on the miss rate.
    //

    Changes = FALSE;
    if (Misses >= Allocates) {
        Misses = Allocates;
    }

    if (Allocates == 0) {
        Allocates = 1;
    }

    Ratio = (Misses * 1000) / Allocates;
    Target = *Depth;
    if ((Allocates / PplCurrentScanPeriod) < MINIMUM_ALLOCATION_THRESHOLD) {
        if (Target > (MINIMUM_LOOKASIDE_DEPTH + 10)) {
            Target -= 10;
        } else {
            Target = MINIMUM_LOOKASIDE_DEPTH;
        }

    } else if (Ratio < 5) {
        if (Target > (MINIMUM_LOOKASIDE_DEPTH + 1)) {
            Target -= 1;
        } else {
            Target = MINIMUM_LOOKASIDE_DEPTH;
        }
    } else {
        Changes = TRUE;
        Target += ((Ratio * MaximumDepth) / (1000 * 2)) + 5;
        if (Target > MaximumDepth) {
            Target = MaximumDepth;
        }
    }

    *Depth = (USHORT)Target;
    return Changes;
}

LOGICAL
PplScanLookasideList(
    PNPAGED_LOOKASIDE_LIST Lookaside
    )
{
    LOGICAL Changes;
    ULONG Allocates;
    ULONG Misses;

    Allocates = Lookaside->L.TotalAllocates - Lookaside->L.LastTotalAllocates;
    Lookaside->L.LastTotalAllocates = Lookaside->L.TotalAllocates;
    Misses = Lookaside->L.AllocateMisses - Lookaside->L.LastAllocateMisses;
    Lookaside->L.LastAllocateMisses = Lookaside->L.AllocateMisses;

    Changes = PplComputeLookasideDepth(
        Allocates,
        Misses,
        Lookaside->L.MaximumDepth,
        &Lookaside->L.Depth);

    return Changes;
}

VOID
PplTimeout(
    CTEEvent * Timer, 
    PVOID Context)
{

    LOGICAL Changes;
    KIRQL OldIrql;
    PLIST_ENTRY Entry;
    PNPAGED_LOOKASIDE_LIST Lookaside;

    //
    // Decrement the scan period and check if it is time to dynamically
    // adjust the maximum depth of lookaside lists.
    //

    Changes = FALSE;

    //
    // Scan our Ppl lists.
    //

    ExAcquireSpinLock(&PplLookasideLock, &OldIrql);

    Entry = PplLookasideListHead.Flink;

    while (Entry != &PplLookasideListHead) {
        Lookaside = CONTAINING_RECORD(Entry,
                                      NPAGED_LOOKASIDE_LIST,
                                      L.ListEntry);

        Changes |= PplScanLookasideList(Lookaside);

        Entry = Entry->Flink;
    }

    //
    // If any changes were made to the depth of any lookaside list during
    // this scan period, then lower the scan period to the minimum value.
    // Otherwise, attempt to raise the scan period.
    //

    if (Changes != FALSE) {
        PplCurrentScanPeriod = 1;
    } else {
        if (PplCurrentScanPeriod != MAXIMUM_SCAN_PERIOD) {
            PplCurrentScanPeriod += 1;
        }
    }

    ExReleaseSpinLock(&PplLookasideLock, OldIrql);

    //
    // Restart the timer.
    //

    CTEStartTimer(&PplTimer, PplCurrentScanPeriod * 1000L, PplTimeout, NULL);
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\inc\dbgmsg.h ===
/*++

 Copyright (c) 1998-2000 Microsoft Corporation

 Module Name:    
       
       dbgmsg.h

 Abstract:       
       
       Debug message macros and zones.
       
 Revision History:

--*/

#if DBG
#define DEBUG_MSG 1
#endif // DBG

//
// If DEBUG_MSG is defined, then we have DEBUGMSG turned on in this environment.
//

#ifdef DEBUG_MSG

#define DTEXT(x) x

extern  uint DbgSettingsLevel;
extern  uint DbgSettingsZone;

#define DEBUGZONE(n)   (DbgSettingsZone & (0x00000001<<n))
#define DEBUGLEVEL(n)  (DbgSettingsLevel & (0x00000001<<n))

typedef ULONG (__cdecl *PDBGMSG)(PCH pszFormat, ...);
extern PDBGMSG g_pDbgMsg;
#define DEBUGMSG(dbgs,format) ((dbgs) ? g_pDbgMsg format:0)

extern VOID DebugMsgInit();
#define DEBUGMSGINIT() DebugMsgInit()

#define DBG_INIT                DEBUGZONE(0)
#define DBG_PNP                 DEBUGZONE(1)

#define DBG_REQUEST             DEBUGZONE(4)
#define DBG_INTERFACE           DEBUGZONE(5)
#define DBG_OFFLOAD             DEBUGZONE(6)
#define DBG_REG                 DEBUGZONE(7)
#define DBG_ROUTE               DEBUGZONE(8)

#define DBG_ARP                 DEBUGZONE(9)
#define DBG_IP                  DEBUGZONE(10)
#define DBG_TCP                 DEBUGZONE(11)
#define DBG_UDP                 DEBUGZONE(12)
#define DBG_ICMP                DEBUGZONE(13)
#define DBG_IGMP                DEBUGZONE(14)
#define DBG_RAW                 DEBUGZONE(15)

#define DBG_TDI                 DEBUGZONE(16)
#define DBG_NDIS                DEBUGZONE(17)

#define DBG_SETINFO             DEBUGZONE(18)
#define DBG_QUERYINFO           DEBUGZONE(19)
#define DBG_NOTIFY              DEBUGZONE(20)
#define DBG_DHCP                DEBUGZONE(21)

// These are very verbose!
#define DBG_TX                  DEBUGZONE(29)
#define DBG_RX                  DEBUGZONE(30)
#define DBG_FWD                 DEBUGZONE(31)

#define DBG_TRACE               DEBUGLEVEL(0)
#define DBG_INFO                DEBUGLEVEL(1)
#define DBG_WARN                DEBUGLEVEL(2)
#define DBG_ERROR               DEBUGLEVEL(3)
#define DBG_VERBOSE             DEBUGLEVEL(31)

#else // DEBUG_MSG

//
// No DEBUGMSGs.
//
#define DEBUGMSG(d,f)   (0)
#define DEBUGMSGINIT()  (0)

#endif // DEBUG_MSG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\inc\bitmap.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    BitMap.h

Abstract:

    RTL Bitmap definitions and prototypes.            

Revision History:

    Borrowed from ntoskrnl for compatibility on other platforms (Win9x).
    
--*/

#ifndef _TCPIP_BITMAP_H_
#define _TCPIP_BITMAP_H_

#if MILLEN

//
//  BitMap routines.  The following structure, routines, and macros are
//  for manipulating bitmaps.  The user is responsible for allocating a bitmap
//  structure (which is really a header) and a buffer (which must be longword
//  aligned and multiple longwords in size).
//

typedef struct _RTL_BITMAP {
    ULONG SizeOfBitMap;                     // Number of bits in bit map
    PULONG Buffer;                          // Pointer to the bit map itself
} RTL_BITMAP;
typedef RTL_BITMAP *PRTL_BITMAP;

//
//  The following routine initializes a new bitmap.  It does not alter the
//  data currently in the bitmap.  This routine must be called before
//  any other bitmap routine/macro.


VOID
RtlInitializeBitMap (
    PRTL_BITMAP BitMapHeader,
    PULONG BitMapBuffer,
    ULONG SizeOfBitMap
    );

//
//  The following three routines clear, set, and test the state of a
//  single bit in a bitmap.
//

VOID
RtlClearBit (
    PRTL_BITMAP BitMapHeader,
    ULONG BitNumber
    );

VOID
RtlSetBit (
    PRTL_BITMAP BitMapHeader,
    ULONG BitNumber
    );

BOOLEAN
RtlTestBit (
    PRTL_BITMAP BitMapHeader,
    ULONG BitNumber
    );

//
//  The following two routines either clear or set all of the bits
//  in a bitmap.
//

VOID
RtlClearAllBits (
    PRTL_BITMAP BitMapHeader
    );

VOID
RtlSetAllBits (
    PRTL_BITMAP BitMapHeader
    );

//
//  The following two routines locate a contiguous region of either
//  clear or set bits within the bitmap.  The region will be at least
//  as large as the number specified, and the search of the bitmap will
//  begin at the specified hint index (which is a bit index within the
//  bitmap, zero based).  The return value is the bit index of the located
//  region (zero based) or -1 (i.e., 0xffffffff) if such a region cannot
//  be located
//

ULONG
RtlFindClearBits (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

ULONG
RtlFindSetBits (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

//
//  The following two routines locate a contiguous region of either
//  clear or set bits within the bitmap and either set or clear the bits
//  within the located region.  The region will be as large as the number
//  specified, and the search for the region will begin at the specified
//  hint index (which is a bit index within the bitmap, zero based).  The
//  return value is the bit index of the located region (zero based) or
//  -1 (i.e., 0xffffffff) if such a region cannot be located.  If a region
//  cannot be located then the setting/clearing of the bitmap is not performed.
//

ULONG
RtlFindClearBitsAndSet (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

ULONG
RtlFindSetBitsAndClear (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

//
//  The following two routines clear or set bits within a specified region
//  of the bitmap.  The starting index is zero based.
//

VOID
RtlClearBits (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG NumberToClear
    );

VOID
RtlSetBits (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG NumberToSet
    );

//
//  The following routine locates a set of contiguous regions of clear
//  bits within the bitmap.  The caller specifies whether to return the
//  longest runs or just the first found lcoated.  The following structure is
//  used to denote a contiguous run of bits.  The two routines return an array
//  of this structure, one for each run located.
//

typedef struct _RTL_BITMAP_RUN {

    ULONG StartingIndex;
    ULONG NumberOfBits;

} RTL_BITMAP_RUN;
typedef RTL_BITMAP_RUN *PRTL_BITMAP_RUN;

ULONG
RtlFindClearRuns (
    PRTL_BITMAP BitMapHeader,
    PRTL_BITMAP_RUN RunArray,
    ULONG SizeOfRunArray,
    BOOLEAN LocateLongestRuns
    );

//
//  The following routine locates the longest contiguous region of
//  clear bits within the bitmap.  The returned starting index value
//  denotes the first contiguous region located satisfying our requirements
//  The return value is the length (in bits) of the longest region found.
//

ULONG
RtlFindLongestRunClear (
    PRTL_BITMAP BitMapHeader,
    PULONG StartingIndex
    );

//
//  The following routine locates the first contiguous region of
//  clear bits within the bitmap.  The returned starting index value
//  denotes the first contiguous region located satisfying our requirements
//  The return value is the length (in bits) of the region found.
//

ULONG
RtlFindFirstRunClear (
    PRTL_BITMAP BitMapHeader,
    PULONG StartingIndex
    );

//
//  The following macro returns the value of the bit stored within the
//  bitmap at the specified location.  If the bit is set a value of 1 is
//  returned otherwise a value of 0 is returned.
//
//      ULONG
//      RtlCheckBit (
//          PRTL_BITMAP BitMapHeader,
//          ULONG BitPosition
//          );
//
//
//  To implement CheckBit the macro retrieves the longword containing the
//  bit in question, shifts the longword to get the bit in question into the
//  low order bit position and masks out all other bits.
//

#define RtlCheckBit(BMH,BP) ((((BMH)->Buffer[(BP) / 32]) >> ((BP) % 32)) & 0x1)

//
//  The following two procedures return to the caller the total number of
//  clear or set bits within the specified bitmap.
//

ULONG
RtlNumberOfClearBits (
    PRTL_BITMAP BitMapHeader
    );

ULONG
RtlNumberOfSetBits (
    PRTL_BITMAP BitMapHeader
    );

//
//  The following two procedures return to the caller a boolean value
//  indicating if the specified range of bits are all clear or set.
//

BOOLEAN
RtlAreBitsClear (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG Length
    );

BOOLEAN
RtlAreBitsSet (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG Length
    );

ULONG
RtlFindNextForwardRunClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG FromIndex,
    IN PULONG StartingRunIndex
    );

ULONG
RtlFindLastBackwardRunClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG FromIndex,
    IN PULONG StartingRunIndex
    );

#endif // MILLEN

#endif // !_TCPIP_BITMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\common\nt\mdlpool.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    mdlpool.c

Abstract:

    This file contains the implementation of an MDL buffer pool.

Author:

    Shaun Cox (shaunco) 21-Oct-1999

--*/

#include "ntddk.h"
#include "mdlpool.h"

#define SHOW_DEBUG_OUTPUT 0

#define SCAVENGE_PERIOD_IN_SECONDS          30
#define MINIMUM_PAGE_LIFETIME_IN_SECONDS    20
#define USED_PAGES_SCAVENGE_THRESHOLD       64

#if defined (_WIN64)
#define MAX_CACHE_LINE_SIZE 128
#define BLOCK_TYPE  SLIST_HEADER
#else
#define MAX_CACHE_LINE_SIZE 64
#define BLOCK_TYPE  PVOID
#endif


// The following structures are used in the single allocation that
// a pool handle points to.
//      PoolHandle ---> [POOL_HEADER + CPU_POOL_HEADER for cpu 0 +
//                                     CPU_POOL_HEADER for cpu 1 + ...
//                                     CPU_POOL_HEADER for cpu N]
//

// POOL_HEADER is the data common to all CPUs for a given pool.
//
typedef struct _POOL_HEADER
{
// cache-line -----
    struct _POOL_HEADER_BASE
    {
        ULONG Tag;
        USHORT BufferSize;
        USHORT MdlsPerPage;
    };
    UCHAR Alignment[MAX_CACHE_LINE_SIZE
            - (sizeof(struct _POOL_HEADER_BASE) % MAX_CACHE_LINE_SIZE)];
} POOL_HEADER, *PPOOL_HEADER;

C_ASSERT(sizeof(POOL_HEADER) % MAX_CACHE_LINE_SIZE == 0);


// CPU_POOL_HEADER is the data specific to a CPU for a given pool.
//
typedef struct _CPU_POOL_HEADER
{
// cache-line -----
    struct _CPU_POOL_HEADER_BASE
    {
        // The doubly-linked list of pages that make up this processor's pool.
        // These pages have one or more free MDLs available.
        //
        LIST_ENTRY PageList;

        // The doubly-linked list of pages that are fully in use.  This list
        // is separate from the above list so that we do not spend time walking
        // a very long list during MdpAllocate when many pages are fully used.
        //
        LIST_ENTRY UsedPageList;

        // The next scheduled time (in units of KeQueryTickCount()) for
        // scavenging this pool.  The next scavenge will happen no earlier
        // that this.
        //
        LARGE_INTEGER NextScavengeTick;

        // Count of pages on the used page list.
        // If this becomes greater than USED_PAGES_SCAVENGE_THRESHOLD
        // and we know we missed a page move during a prior MdpFree,
        // we will scavenge during the next MdpAllocate.
        //
        USHORT PagesOnUsedPageList;

        // Set to TRUE during MdpFree if could not move a previously used
        // page back to the normal list because the free was done by a
        // non-owning processor.  Set to FALSE during MdpScavenge.
        //
        BOOLEAN MissedPageMove;

        // The number of the processor that owns this pool.
        //
        UCHAR OwnerCpu;

        ULONG TotalMdlsAllocated;
        ULONG TotalMdlsFreed;
        ULONG PeakMdlsInUse;
        ULONG TotalPagesAllocated;
        ULONG TotalPagesFreed;
        ULONG PeakPagesInUse;
    };
    UCHAR Alignment[MAX_CACHE_LINE_SIZE
            - (sizeof(struct _CPU_POOL_HEADER_BASE) % MAX_CACHE_LINE_SIZE)];
} CPU_POOL_HEADER, *PCPU_POOL_HEADER;

C_ASSERT(sizeof(CPU_POOL_HEADER) % MAX_CACHE_LINE_SIZE == 0);


// PAGE_HEADER is the data at the beginning of each allocated pool page
// that describes the current state of the MDLs on the page.
//
typedef struct _PAGE_HEADER
{
// cache-line -----
    // Back pointer to the owning cpu pool.
    //
    PCPU_POOL_HEADER Pool;

    // Linkage entry for the list of pages managed by the cpu pool.
    //
    LIST_ENTRY PageLink;

    // Number of MDLs built so far on this page.  MDLs are built on
    // demand.  When this number reaches Pool->MdlsPerPage, all MDLs on this
    // page have been built.
    //
    USHORT MdlsBuilt;

    // Boolean indicator of whether or not this page is on the cpu pool's
    // used-page list.  This is checked during MdpFree to see if the page
    // should be moved back to the normal page list.
    // (it is a USHORT, instead of BOOLEAN, for proper padding)
    //
    USHORT OnUsedPageList;

    // List of free MDLs on this page.
    //
    SLIST_HEADER FreeList;

    // The value of KeQueryTickCount (normalized to units of seconds)
    // which represents the time after which this page can be freed back
    // to the system's pool.  This time is only valid if the depth of
    // FreeList is Pool->MdlsPerPage.  (i.e. this time is only valid if
    // the page is completely unused.)
    //
    LARGE_INTEGER LastUsedTick;

} PAGE_HEADER, *PPAGE_HEADER;


// MDLs that we build are always limited to one page and they never
// describe buffers that span a page boundry.
//
#define MDLSIZE sizeof(MDL) + sizeof(PFN_NUMBER)


// Get a pointer to the overall pool given a pointer to one of
// the per-processor pools within it.
//
__inline
PPOOL_HEADER
PoolFromCpuPool(
    IN PCPU_POOL_HEADER CpuPool
    )
{
    return (PPOOL_HEADER)(CpuPool - CpuPool->OwnerCpu) - 1;
}

__inline
VOID
ConvertSecondsToTicks(
    IN ULONG Seconds,
    OUT PLARGE_INTEGER Ticks
    )
{
    // If the following assert fires, you need to cast Seconds below to
    // ULONGLONG so that 64 bit multiplication and division are used.
    // The current code assumes less that 430 seconds so that the
    // 32 multiplication below won't overflow.
    //
    ASSERT(Seconds < 430);

    Ticks->HighPart = 0;
    Ticks->LowPart = (Seconds * 10*1000*1000) / KeQueryTimeIncrement();
}

// Build the next MDL on the specified pool page.
// This can only be called if not all of the MDLs have been built yet.
//
PMDL
MdppBuildNextMdl(
    IN const POOL_HEADER* Pool,
    IN OUT PPAGE_HEADER Page
    )
{
    PMDL Mdl;
    ULONG BlockSize = ALIGN_UP(MDLSIZE + Pool->BufferSize, BLOCK_TYPE);

    ASSERT(Page->MdlsBuilt < Pool->MdlsPerPage);
    ASSERT((PAGE_SIZE - sizeof(PAGE_HEADER)) / BlockSize == Pool->MdlsPerPage);

    Mdl = (PMDL)((PCHAR)(Page + 1) + (Page->MdlsBuilt * BlockSize));
    ASSERT(PAGE_ALIGN(Mdl) == Page);

    MmInitializeMdl(Mdl, (PCHAR)Mdl + MDLSIZE, Pool->BufferSize);
    MmBuildMdlForNonPagedPool(Mdl);

    ASSERT(MDLSIZE == Mdl->Size);
    ASSERT(MmGetMdlBaseVa(Mdl) == Page);
    ASSERT(MmGetMdlByteCount(Mdl) == Pool->BufferSize);

    Page->MdlsBuilt++;

    return Mdl;
}

// Allocate a new pool page and insert it at the head of the specified
// CPU pool.  Build the first MDL on the new page and return a pointer
// to it.
//
PMDL
MdppAllocateNewPageAndBuildOneMdl(
    IN const POOL_HEADER* Pool,
    IN PCPU_POOL_HEADER CpuPool
    )
{
    PPAGE_HEADER Page;
    PMDL Mdl = NULL;
    ULONG PagesInUse;

    ASSERT(Pool);

    Page = ExAllocatePoolWithTagPriority(NonPagedPool, PAGE_SIZE, Pool->Tag,
                                         NormalPoolPriority);
    if (Page)
    {
        ASSERT(Page == PAGE_ALIGN(Page));

        RtlZeroMemory(Page, sizeof(PAGE_HEADER));
        Page->Pool = CpuPool;
        ExInitializeSListHead(&Page->FreeList);

        // Insert the page at the head of the cpu's pool.
        //
        InsertHeadList(&CpuPool->PageList, &Page->PageLink);
        CpuPool->TotalPagesAllocated++;

        // Update the pool's statistics.
        //
        PagesInUse = CpuPool->TotalPagesAllocated - CpuPool->TotalPagesFreed;
        if (PagesInUse > CpuPool->PeakPagesInUse)
        {
            CpuPool->PeakPagesInUse = PagesInUse;
        }

        Mdl = MdppBuildNextMdl(Pool, Page);
        ASSERT(Mdl);

#if SHOW_DEBUG_OUTPUT
        DbgPrint(
            "[%d] %c%c%c%c page allocated : Pages(a%4d,u%4d,p%4d), Mdls(a%6d,u%6d,p%6d)\n",
            CpuPool->OwnerCpu,
            Pool->Tag, Pool->Tag >> 8, Pool->Tag >> 16, Pool->Tag >> 24,
            CpuPool->TotalPagesAllocated,
            CpuPool->TotalPagesAllocated - CpuPool->TotalPagesFreed,
            CpuPool->PeakPagesInUse,
            CpuPool->TotalMdlsAllocated,
            CpuPool->TotalMdlsAllocated - CpuPool->TotalMdlsFreed,
            CpuPool->PeakMdlsInUse);
#endif
    }

    return Mdl;
}

// Free the specified pool page back to the system's pool.
//
VOID
MdppFreePage(
    IN PCPU_POOL_HEADER CpuPool,
    IN PPAGE_HEADER Page
    )
{
#if SHOW_DEBUG_OUTPUT
    ULONG Tag;
#endif

    ASSERT(Page == PAGE_ALIGN(Page));
    ASSERT(Page->Pool == CpuPool);

    ExFreePool (Page);
    CpuPool->TotalPagesFreed++;

    ASSERT(CpuPool->TotalPagesFreed <= CpuPool->TotalPagesAllocated);

#if SHOW_DEBUG_OUTPUT
    Tag = PoolFromCpuPool(CpuPool)->Tag;

    DbgPrint(
        "[%d] %c%c%c%c page freed     : Pages(a%4d,u%4d,p%4d), Mdls(a%6d,u%6d,p%6d)\n",
        CpuPool->OwnerCpu,
        Tag, Tag >> 8, Tag >> 16, Tag >> 24,
        CpuPool->TotalPagesAllocated,
        CpuPool->TotalPagesAllocated - CpuPool->TotalPagesFreed,
        CpuPool->PeakPagesInUse,
        CpuPool->TotalMdlsAllocated,
        CpuPool->TotalMdlsAllocated - CpuPool->TotalMdlsFreed,
        CpuPool->PeakMdlsInUse);
#endif
}


// Reclaim the memory consumed by completely unused pool pages belonging
// to the specified per-processor pool.
//
// Caller IRQL: [DISPATCH_LEVEL]
//
VOID
MdppScavengePool(
    IN OUT PCPU_POOL_HEADER CpuPool
    )
{
    PPOOL_HEADER Pool;
    PPAGE_HEADER Page;
    PLIST_ENTRY Scan;
    PLIST_ENTRY Next;
    LARGE_INTEGER Ticks;
    LARGE_INTEGER TicksDelta;

    // We must not only be at DISPATCH_LEVEL (or higher), we must also
    // be called on the processor that owns the specified pool.
    //
    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);
    ASSERT(KeGetCurrentProcessorNumber() == CpuPool->OwnerCpu);

    Pool = PoolFromCpuPool(CpuPool);

    KeQueryTickCount(&Ticks);

    // Compute the next tick value which represents the earliest time
    // that we will scavenge this pool again.
    //
    ConvertSecondsToTicks(SCAVENGE_PERIOD_IN_SECONDS, &TicksDelta);
    CpuPool->NextScavengeTick.QuadPart = Ticks.QuadPart + TicksDelta.QuadPart;

    // Compute the tick value which represents the last point at which
    // its okay to free a page.
    //
    ConvertSecondsToTicks(MINIMUM_PAGE_LIFETIME_IN_SECONDS, &TicksDelta);
    Ticks.QuadPart = Ticks.QuadPart - TicksDelta.QuadPart;

    for (Scan = CpuPool->PageList.Flink;
         Scan != &CpuPool->PageList;
         Scan = Next)
    {
        Page = CONTAINING_RECORD(Scan, PAGE_HEADER, PageLink);
        ASSERT(Page == PAGE_ALIGN(Page));
        ASSERT(CpuPool == Page->Pool);
        ASSERT(!Page->OnUsedPageList);

        // Step to the next link before we possibly unlink this page.
        //
        Next = Scan->Flink;

        if ((Pool->MdlsPerPage == ExQueryDepthSList(&Page->FreeList)) &&
            (Ticks.QuadPart > Page->LastUsedTick.QuadPart))
        {
            RemoveEntryList(Scan);

            MdppFreePage(CpuPool, Page);
        }
    }

    // Scan the used pages to see if they can be moved back to the normal
    // list.  This can happen if too many frees by non-owning processors
    // are done.  In that case, the pages get orphaned on the used-page
    // list after all of their MDLs have been freed to the page.  Un-orhpan
    // them here.
    //
    for (Scan = CpuPool->UsedPageList.Flink;
         Scan != &CpuPool->UsedPageList;
         Scan = Next)
    {
        Page = CONTAINING_RECORD(Scan, PAGE_HEADER, PageLink);
        ASSERT(Page == PAGE_ALIGN(Page));
        ASSERT(CpuPool == Page->Pool);
        ASSERT(Page->OnUsedPageList);

        // Step to the next link before we possibly unlink this page.
        //
        Next = Scan->Flink;

        if (0 != ExQueryDepthSList(&Page->FreeList))
        {
            RemoveEntryList(Scan);
            Page->OnUsedPageList = FALSE;
            InsertTailList(&CpuPool->PageList, Scan);
            CpuPool->PagesOnUsedPageList--;

#if SHOW_DEBUG_OUTPUT
            DbgPrint(
                "[%d] %c%c%c%c page moved off of used-page list during scavenge\n",
                CpuPool->OwnerCpu,
                Pool->Tag, Pool->Tag >> 8, Pool->Tag >> 16, Pool->Tag >> 24);
#endif
        }
    }

    // Reset our indicator of a missed page move now that we've scavenged.
    //
    CpuPool->MissedPageMove = FALSE;
}


// Creates a pool of MDLs built over non-paged pool.  Each MDL describes
// a buffer that is BufferSize bytes long.  If NULL is not returned,
// MdpDestroyPool should be called at a later time to reclaim the
// resources used by the pool.
//
// Arguments:
//  BufferSize - The size, in bytes, of the buffer that each MDL
//      should describe.
//  Tag - The pool tag to be used internally for calls to
//      ExAllocatePoolWithTag.  This allows callers to track
//      memory consumption for different pools.
//
//  Returns the handle used to identify the pool.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
HANDLE
MdpCreatePool(
    IN USHORT BufferSize,
    IN ULONG Tag
    )
{
    SIZE_T Size;
    PPOOL_HEADER Pool;
    PCPU_POOL_HEADER CpuPool;
    USHORT BlockSize;
    CCHAR NumberCpus = KeNumberProcessors;
    CCHAR i;

    ASSERT(BufferSize);

    // Compute the size of our pool header allocation.
    //
    Size = sizeof(POOL_HEADER) + (sizeof(CPU_POOL_HEADER) * NumberCpus);

    // Allocate the pool header.
    //
    Pool = ExAllocatePoolWithTag(NonPagedPool, Size, ' pdM');

    if (Pool)
    {
        BlockSize = (USHORT)ALIGN_UP(MDLSIZE + BufferSize, BLOCK_TYPE);

        // Initialize the pool header fields.
        //
        RtlZeroMemory(Pool, Size);
        Pool->Tag = Tag;
        Pool->BufferSize = BufferSize;
        Pool->MdlsPerPage = (PAGE_SIZE - sizeof(PAGE_HEADER)) / BlockSize;

        // Initialize the per-cpu pool headers.
        //
        CpuPool = (PCPU_POOL_HEADER)(Pool + 1);

        for (i = 0; i < NumberCpus; i++)
        {
            InitializeListHead(&CpuPool[i].PageList);
            InitializeListHead(&CpuPool[i].UsedPageList);
            CpuPool[i].OwnerCpu = i;
        }
    }

    return Pool;
}

// Destroys a pool of MDLs previously created by a call to MdpCreatePool.
//
// Arguments:
//  Pool - Handle which identifies the pool being destroyed.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
VOID
MdpDestroyPool(
    IN HANDLE PoolHandle
    )
{
    PPOOL_HEADER Pool;
    PPAGE_HEADER Page;
    PCPU_POOL_HEADER CpuPool;
    PLIST_ENTRY Scan;
    PLIST_ENTRY Next;
    CCHAR NumberCpus = KeNumberProcessors;
    CCHAR i;

    ASSERT(PoolHandle);

    Pool = (PPOOL_HEADER)PoolHandle;
    if (!Pool)
    {
        return;
    }

    for (i = 0, CpuPool = (PCPU_POOL_HEADER)(Pool + 1);
         i < NumberCpus;
         i++, CpuPool++)
    {
        ASSERT(CpuPool->OwnerCpu == (ULONG)i);

        for (Scan = CpuPool->PageList.Flink;
             Scan != &CpuPool->PageList;
             Scan = Next)
        {
            Page = CONTAINING_RECORD(Scan, PAGE_HEADER, PageLink);
            ASSERT(Page == PAGE_ALIGN(Page));
            ASSERT(CpuPool == Page->Pool);
            ASSERT(!Page->OnUsedPageList);

            ASSERT(Page->MdlsBuilt <= Pool->MdlsPerPage);
            ASSERT(Page->MdlsBuilt == ExQueryDepthSList(&Page->FreeList));

            // Step to the next link before we free this page.
            //
            Next = Scan->Flink;

            RemoveEntryList(Scan);
            MdppFreePage(CpuPool, Page);
        }

        ASSERT(IsListEmpty(&CpuPool->UsedPageList));
        ASSERT(CpuPool->TotalPagesAllocated == CpuPool->TotalPagesFreed);
        ASSERT(CpuPool->TotalMdlsAllocated == CpuPool->TotalMdlsFreed);
    }
}

// Returns an MDL allocated from a pool.  NULL is returned if the
// request could not be granted.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being allocated from.
//  Buffer - Address to receive the pointer to the underlying mapped buffer
//      described by the MDL.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
PMDL
MdpAllocate(
    IN HANDLE PoolHandle,
    OUT PVOID* Buffer
    )
{
    KIRQL OldIrql;
    PMDL Mdl;

    OldIrql = KeRaiseIrqlToDpcLevel();

    Mdl = MdpAllocateAtDpcLevel(PoolHandle, Buffer);

    KeLowerIrql(OldIrql);

    return Mdl;
}

// Returns an MDL allocated from a pool.  NULL is returned if the
// request could not be granted.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being allocated from.
//  Buffer - Address to receive the pointer to the underlying mapped buffer
//      described by the MDL.
//
// Caller IRQL: [DISPATCH_LEVEL]
//
PMDL
MdpAllocateAtDpcLevel(
    IN HANDLE PoolHandle,
    OUT PVOID* Buffer
    )
{
    PPOOL_HEADER Pool;
    PCPU_POOL_HEADER CpuPool;
    PPAGE_HEADER Page;
    PSINGLE_LIST_ENTRY MdlLink;
    PMDL Mdl = NULL;
    ULONG Cpu;
    LARGE_INTEGER Ticks;

#if DBG
    ASSERT(PoolHandle);
    ASSERT(Buffer);
    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);
#endif
    *Buffer = NULL;

    Pool = (PPOOL_HEADER)PoolHandle;
    Cpu = KeGetCurrentProcessorNumber();
    CpuPool = (PCPU_POOL_HEADER)(Pool + 1) + Cpu;

    // If we know we've had frees by non-owning processors and there
    // are more than USED_PAGES_SCAVENGE_THRESHOLD pages on the used
    // page list, it is time to scavenge.  This is common in situations
    // where the buffer size is very large causing there to be just a few
    // MDLs per page.  Pages get used up quickly and if non-owning frees
    // are prevalent, the used page list can get very big even in
    // the normal scavenge period.
    //
    if (CpuPool->MissedPageMove &&
        (CpuPool->PagesOnUsedPageList > USED_PAGES_SCAVENGE_THRESHOLD))
    {
#if SHOW_DEBUG_OUTPUT
        DbgPrint(
            "[%d] %c%c%c%c Scavenging because of excessive used pages.\n",
            CpuPool->OwnerCpu,
            Pool->Tag, Pool->Tag >> 8, Pool->Tag >> 16, Pool->Tag >> 24);
#endif
        MdppScavengePool(CpuPool);
    }
    else
    {
        // See if the minimum time has passed since we last scavenged
        // the pool.  If it has, we'll scavenge again.  Normally, scavenging
        // should only be performed when we free.  However, for the case when
        // the caller constantly frees on a non-owning processor, we'll
        // take this chance to do the scavenging.
        //
        KeQueryTickCount(&Ticks);
        if (Ticks.QuadPart > CpuPool->NextScavengeTick.QuadPart)
        {
            MdppScavengePool(CpuPool);
        }
    }

    if (!IsListEmpty(&CpuPool->PageList))
    {
        Page = CONTAINING_RECORD(CpuPool->PageList.Flink, PAGE_HEADER, PageLink);
        ASSERT(Page == PAGE_ALIGN(Page));
        ASSERT(CpuPool == Page->Pool);
        ASSERT(!Page->OnUsedPageList);

        MdlLink = InterlockedPopEntrySList(&Page->FreeList);
        if (MdlLink)
        {
            Mdl = CONTAINING_RECORD(MdlLink, MDL, Next);
        }
        else
        {
            // If there were no MDLs on this page's free list, it had better
            // mean we haven't yet built all of the MDLs on the page.
            // (Otherwise, what is a fully used page doing on the page list
            // and not on the used-page list?)
            //
            ASSERT(Page->MdlsBuilt < Pool->MdlsPerPage);

            Mdl = MdppBuildNextMdl(Pool, Page);
            ASSERT(Mdl);
        }

        if ((Page != PAGE_ALIGN(Page)) || (CpuPool != Page->Pool) ||
            Page->OnUsedPageList || (PAGE_ALIGN(Mdl) != Page))
        {
            KeBugCheckEx(BAD_POOL_CALLER, 2, (ULONG_PTR)Mdl,
                (ULONG_PTR)Page, (ULONG_PTR)CpuPool);
        }

        // Got an MDL.  Now check to see if it was the last one on a fully
        // built page.  If so, move the page to the used-page list.
        //
        if ((0 == ExQueryDepthSList(&Page->FreeList)) &&
            (Page->MdlsBuilt == Pool->MdlsPerPage))
        {
            PLIST_ENTRY PageLink;
            PageLink = RemoveHeadList(&CpuPool->PageList);
            InsertTailList(&CpuPool->UsedPageList, PageLink);
            Page->OnUsedPageList = TRUE;
            CpuPool->PagesOnUsedPageList++;

            ASSERT(Page == CONTAINING_RECORD(PageLink, PAGE_HEADER, PageLink));

#if SHOW_DEBUG_OUTPUT
            DbgPrint(
                "[%d] %c%c%c%c page moved to used-page list\n",
                CpuPool->OwnerCpu,
                Pool->Tag, Pool->Tag >> 8, Pool->Tag >> 16, Pool->Tag >> 24);
#endif
        }

        ASSERT(Mdl);
        goto GotAnMdl;
    }
    else
    {
        // The page list is empty so we have to allocate and add a new page.
        //
        Mdl = MdppAllocateNewPageAndBuildOneMdl(Pool, CpuPool);
    }

    // If we are returning an MDL, update the statistics.
    //
    if (Mdl)
    {
        ULONG MdlsInUse;
GotAnMdl:

        CpuPool->TotalMdlsAllocated++;

        MdlsInUse = CpuPool->TotalMdlsAllocated - CpuPool->TotalMdlsFreed;
        if (MdlsInUse > CpuPool->PeakMdlsInUse)
        {
            CpuPool->PeakMdlsInUse = MdlsInUse;
        }

        // Don't give anyone ideas about where this might point.  I don't
        // want anyone trashing my pool because they thought this field
        // was valid for some reason.
        //
        Mdl->Next = NULL;

        // Reset the length of the buffer described by the MDL.  This is
        // a convienence to callers who sometimes adjust this length while
        // using the MDL, but who expect it to be reset on subsequent MDL
        // allocations.
        //
        Mdl->ByteCount = Pool->BufferSize;

        ASSERT(Mdl->MdlFlags & MDL_SOURCE_IS_NONPAGED_POOL);
        *Buffer = Mdl->MappedSystemVa;
    }

    return Mdl;
}

// Free an MDL to the pool from which it was allocated.
//
// Arguments:
//  Mdl - An Mdl returned from a prior call to MdpAllocate.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
VOID
MdpFree(
    IN PMDL Mdl
    )
{
    PPAGE_HEADER Page;
    PCPU_POOL_HEADER CpuPool;
    PPOOL_HEADER Pool;
    LARGE_INTEGER Ticks;
    LOGICAL PageIsPossiblyUnused;
    LOGICAL PageIsOnUsedPageList;
    LOGICAL Scavenge = FALSE;

    ASSERT(Mdl);

    // Get the address of the page that this MDL maps.  This is where
    // our page header is stored.
    //
    Page = PAGE_ALIGN(Mdl);

    // Follow the back pointer in the page header to locate the owning
    // cpu's pool.
    //
    CpuPool = Page->Pool;

    // Locate the pool header.
    //
    Pool = PoolFromCpuPool(CpuPool);

//#if DBG
    // If someone changed the MDL to point to there own buffer,
    // or otherwise corrupted it, we'll stop here and let them know.
    //
    if ((MmGetMdlBaseVa(Mdl) != Page) ||
        (MDLSIZE != Mdl->Size) ||
        ((ULONG_PTR)Mdl->MappedSystemVa != (ULONG_PTR)Mdl + MDLSIZE) ||
        (MmGetMdlVirtualAddress(Mdl) != Mdl->MappedSystemVa))
    {
        KeBugCheckEx(BAD_POOL_CALLER, 3, (ULONG_PTR)Mdl,
            (ULONG_PTR)CpuPool, (ULONG_PTR)Pool);
    }
//#endif

    // See if the minimum time has passed since we last scavenged
    // the pool.  If it has, we'll scavenge again.
    //
    KeQueryTickCount(&Ticks);
    if (Ticks.QuadPart > CpuPool->NextScavengeTick.QuadPart)
    {
        Scavenge = TRUE;
    }

    // If this is the last MDL to be returned to this page, the page is
    // now unused.  Note that since there is no synchronization beyond
    // InterlockedPush/PopSEntryList between allocate and free, we
    // cannot guarantee that it will remain unused even before the next
    // few instructions are executed.
    //
    PageIsPossiblyUnused = (ExQueryDepthSList(&Page->FreeList)
                                == (Pool->MdlsPerPage - 1));
    if (PageIsPossiblyUnused)
    {
        // Note the tick that this page was last used.  This sets the
        // minimum time that this page will continue to live unless it
        // gets re-used.
        //
        Page->LastUsedTick.QuadPart = Ticks.QuadPart;
    }

    // If this page is on the used-page list, we'll put it back on the normal
    // page list (only after pushing the MDL back on the page's free list)
    // if, after raising IRQL, we are on the processor that owns this
    // pool.
    //
    PageIsOnUsedPageList = Page->OnUsedPageList;


    InterlockedIncrement(&CpuPool->TotalMdlsFreed);

    // Now return the MDL to the page's free list.
    //
    InterlockedPushEntrySList(&Page->FreeList, (PSINGLE_LIST_ENTRY)&Mdl->Next);

    //
    // Warning: Now that the MDL is back on the page, one cannot reliably
    // dereference anything through 'Page' anymore.  It may have just been
    // scavenged by its owning processor.  This is not the case if the
    // page was on the used-page list (because scavenging doesn't affect
    // the used-page list).  We saved off the value of Page->OnUsedPageList
    // before returning the MDL so we would not risk touching Page to get
    // this value only to find that it was false.
    //

    // If we need to move the page from the used-page list to the normal
    // page list, or if we need to scavenge, we need to be at DISPATCH_LEVEL
    // and be executing on the processor that owns this pool.
    // Find out if the CPU we are executing on right now owns this pool.
    // Note that if we are running at PASSIVE_LEVEL, the current CPU may
    // change over the duration of this function call, so this value is
    // not absolute over the life of the function.
    //
    if ((PageIsOnUsedPageList || Scavenge) &&
        (KeGetCurrentProcessorNumber() == CpuPool->OwnerCpu))
    {
        KIRQL OldIrql;

        OldIrql = KeRaiseIrqlToDpcLevel();

        // Now that we are at DISPATCH_LEVEL, perform the work if we are still
        // executing on the processor that owns the pool.
        //
        if (KeGetCurrentProcessorNumber() == CpuPool->OwnerCpu)
        {
            // If the page is still on the used-page list (meaning another
            // MdpFree didn't just sneak by), then put the page on the
            // normal list.  Very important to do this after (not before)
            // returning the MDL to the free list because MdpAllocate expects
            // MDL's to be available from pages on the page list.
            //
            if (PageIsOnUsedPageList && Page->OnUsedPageList)
            {
                RemoveEntryList(&Page->PageLink);
                Page->OnUsedPageList = FALSE;
                InsertTailList(&CpuPool->PageList, &Page->PageLink);
                CpuPool->PagesOnUsedPageList--;

                PageIsOnUsedPageList = FALSE;

#if SHOW_DEBUG_OUTPUT
                DbgPrint(
                    "[%d] %c%c%c%c page moved off of used-page list\n",
                    CpuPool->OwnerCpu,
                    Pool->Tag, Pool->Tag >> 8, Pool->Tag >> 16, Pool->Tag >> 24);
#endif
            }

            // Perform the scavenge if we previously noted we needed to do so.
            //
            if (Scavenge)
            {
                MdppScavengePool(CpuPool);
            }
        }

        KeLowerIrql(OldIrql);
    }

    // If we missed being able to put this page back on the normal list.
    // note it.
    //
    if (PageIsOnUsedPageList)
    {
        CpuPool->MissedPageMove = TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\common\9x\timer.c ===
/*++
 
  Copyright (c) 1999 Microsoft Corporation
 
  Module Name:    
        
        timer.c
 
  Abstract:       
        
        Contains CTE timer which uses NDIS_TIMERs. We need to do this so 
        that the timer is fired on a global event rather than timer DPC.
        This is because some of the Millennium TDI clients touch pageable 
        code, etc.
        
  Author:
  
        Scott Holden (sholden)  2/8/2000
        
  Revision History:
 
 --*/

#include <tcpipbase.h>

VOID
CTEpTimerHandler(
    IN PVOID  SS1,
    IN PVOID  DeferredContext,
    IN PVOID  SS2,
    IN PVOID  SS3
    )
{
    CTETimer *Timer;

    UNREFERENCED_PARAMETER(SS1);
    UNREFERENCED_PARAMETER(SS2);
    UNREFERENCED_PARAMETER(SS3);

    Timer = (CTETimer *) DeferredContext;
    (*Timer->t_handler)((CTEEvent *)Timer, Timer->t_arg);
}

void
CTEInitTimer(
    CTETimer    *Timer
    )
/*++

Routine Description:

    Initializes a CTE Timer variable.

Arguments:

    Timer   - Timer variable to initialize.

Return Value:

    None.

--*/

{
    Timer->t_handler = NULL;
    Timer->t_arg = NULL;
    NdisInitializeTimer(&Timer->t_timer, CTEpTimerHandler, Timer);
    return;
}


void *
CTEStartTimer(
    CTETimer      *Timer,
    unsigned long  DueTime,
    CTEEventRtn    Handler,
    void          *Context
    )

/*++

Routine Description:

    Sets a CTE Timer for expiration.

Arguments:

    Timer    - Pointer to a CTE Timer variable.
    DueTime  - Time in milliseconds after which the timer should expire.
    Handler  - Timer expiration handler routine.
    Context  - Argument to pass to the handler.

Return Value:

    0 if the timer could not be set. Nonzero otherwise.

--*/

{
    ASSERT(Handler != NULL);

    Timer->t_handler = Handler;
    Timer->t_arg = Context;

    NdisSetTimer(&Timer->t_timer, DueTime);

	return((void *) 1);
}

//++
//
// int
// CTEStopTimer(
//     IN CTETimer *Timer
//     );
//
// Routine Description:
//
//     Cancels a running CTE timer.
//
// Arguments:
//
//     Timer - Pointer to the CTE Timer to be cancelled.
//
// Return Value:
//
//     0 if the timer could not be cancelled. Nonzero otherwise.
//
// Notes:
//
//     Calling this function on a timer that is not active has no effect.
//     If this routine fails, the timer may be in the process of expiring
//     or may have already expired. In either case, the caller must
//     sychronize with the Handler function as appropriate.
//
//--

int
CTEStopTimer(
    IN CTETimer *Timer
    )
{
    BOOLEAN fTimerCancelled;

    NdisCancelTimer(&Timer->t_timer, &fTimerCancelled);

    return (fTimerCancelled);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\inc\mdl2ndis.h ===
/*++

 Copyright (c) 1999 Microsoft Corporation

 Module Name:    
       
       mdl2ndis.h

 Abstract:       
       
       MDL <--> NDIS_BUFFER conversion.
       
 Author:
 
       Scott Holden (sholden)  11/12/1999
       
 Revision History:

--*/

#if MILLEN

TDI_STATUS
ConvertMdlToNdisBuffer(
    PIRP pIrp,
    PMDL pMdl, 
    PNDIS_BUFFER *ppNdisBuffer
    );

TDI_STATUS
FreeMdlToNdisBufferChain(
    PIRP pIrp
    );

#else // MILLEN
//
// Of course for Windows 2000 an NDIS_BUFFER chain is really an MDL chain.
//

__inline          
TDI_STATUS
ConvertMdlToNdisBuffer(
    PIRP pIrp,
    PMDL pMdl, 
    PNDIS_BUFFER *ppNdisBuffer
    )
{
    *ppNdisBuffer = pMdl;
    return TDI_SUCCESS;
}

__inline          
TDI_STATUS
FreeMdlToNdisBufferChain(
    PIRP pIrp
    )
{
    return TDI_SUCCESS;
}
#endif // !MILLEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\inc\mdlpool.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    mdlpool.h

Abstract:

    This file contains definitions and function prototypes for manipulating
    MDL buffer pools.

Author:

    Shaun Cox (shaunco) 21-Oct-1999

--*/

#pragma once


// Creates a pool of MDLs built over non-paged pool.  Each MDL describes
// a buffer that is BufferSize bytes long.  If NULL is not returned,
// MdpDestroyPool should be called at a later time to reclaim the
// resources used by the pool.
//
// Arguments:
//  BufferSize - The size, in bytes, of the buffer that each MDL
//      should describe.
//  Tag - The pool tag to be used internally for calls to
//      ExAllocatePoolWithTag.  This allows callers to track
//      memory consumption for different pools.
//
//  Returns the handle used to identify the pool.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
HANDLE
MdpCreatePool(
    IN USHORT BufferSize,
    IN ULONG Tag
    );

// Destroys a pool of MDLs previously created by a call to MdpCreatePool.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being destroyed.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
VOID
MdpDestroyPool(
    IN HANDLE PoolHandle
    );

// Returns an MDL allocated from a pool.  NULL is returned if the
// request could not be granted.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being allocated from.
//  Buffer - Address to receive the pointer to the underlying mapped buffer
//      described by the MDL.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
#if MILLEN
PNDIS_BUFFER
#else
PMDL
#endif
MdpAllocate(
    IN HANDLE PoolHandle,
    OUT PVOID* Buffer
    );

// Returns an MDL allocated from a pool.  NULL is returned if the
// request could not be granted.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being allocated from.
//  Buffer - Address to receive the pointer to the underlying mapped buffer
//      described by the MDL.
//
// Caller IRQL: [DISPATCH_LEVEL]
//
#if MILLEN
#define MdpAllocateAtDpcLevel MdpAllocate
#else
PMDL
MdpAllocateAtDpcLevel(
    IN HANDLE PoolHandle,
    OUT PVOID* Buffer
    );
#endif

// Free an MDL to the pool from which it was allocated.
//
// Arguments:
//  Mdl - An Mdl returned from a prior call to MdpAllocate.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
VOID
MdpFree(
    IN PMDL Mdl
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\inc\fsbpool.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    fsbpool.h

Abstract:

    This file contains definitions and function prototypes for manipulating
    fixed-size block pools.

Author:

    Shaun Cox (shaunco) 10-Dec-1999

--*/

#pragma once


typedef
VOID
(__stdcall *PFSB_BUILDBLOCK_FUNCTION) (
    IN PUCHAR Block,
    IN SIZE_T NumberOfBytes
    );


// Creates a pool of fixed-size blocks built over non-paged pool.  Each
// block is BlockSize bytes long.  If NULL is not returned,
// FsbDestroyPool should be called at a later time to reclaim the
// resources used by the pool.
//
// Arguments:
//  BlockSize - The size, in bytes, of each block.
//  FreeBlockLinkOffset - The offset, in bytes, from the beginning of a block
//      that represenets a pointer-sized storage location that the pool can
//      use to chain free blocks together.  Most often this will be zero
//      (meaning use the first pointer-size bytes of the block.)
//  Tag - The pool tag to be used internally for calls to
//      ExAllocatePoolWithTag.  This allows callers to track
//      memory consumption for different pools.
//  BuildFunction - An optional pointer to a function which initializes
//      blocks when they are first allocated by the pool.  This allows the
//      caller to perform custom, on-demand initialization of each block.
//
//  Returns the handle used to identify the pool.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
HANDLE
FsbCreatePool(
    IN USHORT BlockSize,
    IN USHORT FreeBlockLinkOffset,
    IN ULONG Tag,
    IN PFSB_BUILDBLOCK_FUNCTION BuildFunction OPTIONAL
    );

// Destroys a pool of fixed-size blocks previously created by a call to
// FsbCreatePool.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being destroyed.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
VOID
FsbDestroyPool(
    IN HANDLE PoolHandle
    );

// Returns a pointer to a block allocated from a pool.  NULL is returned if
// the request could not be granted.  The returned pointer is guaranteed to
// have 8 byte alignment.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being allocated from.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
PUCHAR
FsbAllocate(
    IN HANDLE PoolHandle
    );

// Free a block back to the pool from which it was allocated.
//
// Arguments:
//  Block - A block returned from a prior call to FsbAllocate.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
VOID
FsbFree(
    IN PUCHAR Block
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\inc\pplasl.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    pplasl.c

Abstract:

    This file contains definitions and function prototypes of a per-processor
    lookaside list manager.

Author:

    Shaun Cox (shaunco) 25-Oct-1999

--*/

#pragma once

#if MILLEN

BOOLEAN
PplInit(
    VOID
    );

VOID
PplDeinit(
    VOID
    );
                
#endif // MILLEN

HANDLE
PplCreatePool(
    IN PALLOCATE_FUNCTION Allocate,
    IN PFREE_FUNCTION Free,
    IN ULONG Flags,
    IN SIZE_T Size,
    IN ULONG Tag,
    IN USHORT Depth
    );

VOID
PplDestroyPool(
    IN HANDLE PoolHandle
    );

PVOID
PplAllocate(
    IN HANDLE PoolHandle,
    OUT LOGICAL *FromList
    );

VOID
PplFree(
    IN HANDLE PoolHandle,
    IN PVOID Entry
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\inc\queue.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */
#ifndef __QUEUE_H__
#define __QUEUE_H__

//** QUEUE.H - TCP/UDP queuing definitons.
//
//	This file contains the definitions for the queue functions used
//	by the TCP/UDP code.
//

//*	Definition of a queue linkage field.
struct Queue {
	struct	Queue	*q_next;
	struct	Queue	*q_prev;
}; /* Queue */

typedef struct Queue Queue;

//* Initialize queue macro.

#define	INITQ(q)   {	(q)->q_next = (q);\
						(q)->q_prev = (q); }

//*	Macro to check for queue empty.
#define	EMPTYQ(q)	((q)->q_next == (q))

//*	Place an element onto the end of the queue.

#define	ENQUEUE(q, e)	{	(q)->q_prev->q_next = (e);\
							(e)->q_prev = (q)->q_prev;\
							(q)->q_prev = (e);\
							(e)->q_next = (q); }

//*	Remove an element from the head of the queue. This macro assumes the queue
//	is not empty. The element is returned as type t, queued through linkage
//	l.

#define	DEQUEUE(q, ptr, t, l)	{\
				Queue	*__tmp__;\
				\
				__tmp__ = (q)->q_next;\
				(q)->q_next = __tmp__->q_next;\
				__tmp__->q_next->q_prev = (q);\
				(ptr) = STRUCT_OF(t, __tmp__, l);\
				}

//*	Peek at an element at the head of the queue. We return a pointer to it
//	without removing anything.

#define	PEEKQ(q, ptr, t, l)	{\
				Queue	*__tmp__;\
				\
				__tmp__ = (q)->q_next;\
				(ptr) = STRUCT_OF(t, __tmp__, l);\
				}

//* Macro to push an element onto the head of a queue.

#define	PUSHQ(q, e)	{	(e)->q_next = (q)->q_next;\
						(q)->q_next->q_prev = (e);\
						(e)->q_prev = (q);\
						(q)->q_next = e; }

//* Macro to remove an element from the middle of a queue.
#define	REMOVEQ(q)	{	(q)->q_next->q_prev = (q)->q_prev;\
						(q)->q_prev->q_next = (q)->q_next; }

//** The following macros define methods for working with queue without
// dequeueing, mostly dealing with Queue structures directly.

//* Macro to define the end of a Q, used in walking a queue sequentially.
#define QEND(q) (q)

//* Macro to get the first on a queue.
#define	QHEAD(q) (q)->q_next

//* Macro to get a structure, given a queue.

#define	QSTRUCT(t, q, l) STRUCT_OF(t, (q), l)

//* Macro to get the next thing on q queue.

#define	QNEXT(q)	(q)->q_next

//* Macro to get the previous thing on q queue.

#define QPREV(q)    (q)->q_prev


__inline
VOID
InterlockedEnqueue(
    IN Queue* Q,
    IN Queue* Item,
    IN CTELock* Lock)
{
    CTELockHandle Handle;
    
    CTEGetLock(Lock, &Handle);
    ENQUEUE(Q, Item);
    CTEFreeLock(Lock, Handle);
}

__inline
VOID
InterlockedEnqueueAtDpcLevel(
    IN Queue* Q,
    IN Queue* Item,
    IN CTELock* Lock)
{
    CTELockHandle Handle;
    
    CTEGetLockAtDPC(Lock, &Handle);
    ENQUEUE(Q, Item);
    CTEFreeLockFromDPC(Lock, Handle);
}

__inline
Queue*
InterlockedDequeueIfNotEmpty(
    IN Queue* Q,
    IN CTELock* Lock)
{
    CTELockHandle Handle;
    Queue* Item = NULL;
    
    if (!EMPTYQ(Q)) {
        CTEGetLock(Lock, &Handle);
        if (!EMPTYQ(Q)) {
            Item = Q->q_next;
            Q->q_next = Item->q_next;
            Item->q_next->q_prev = Q;
        }
        CTEFreeLock(Lock, Handle);
    }
        
    return Item;
}

__inline
Queue*
InterlockedDequeueIfNotEmptyAtIrql(
    IN Queue* Q,
    IN CTELock* Lock,
    IN KIRQL OrigIrql)
{
    CTELockHandle Handle;
    Queue* Item = NULL;
    
    if (!EMPTYQ(Q)) {
        CTEGetLockAtIrql(Lock, OrigIrql, &Handle);
        if (!EMPTYQ(Q)) {
            Item = Q->q_next;
            Q->q_next = Item->q_next;
            Item->q_next->q_prev = Q;
        }
        CTEFreeLockAtIrql(Lock, OrigIrql, Handle);
    }
        
    return Item;
}

__inline
VOID
InterlockedRemoveQueueItem(
    IN Queue* Q,
    IN CTELock* Lock)
{
    CTELockHandle Handle;
    CTEGetLock(Lock, &Handle);
    REMOVEQ(Q);
    CTEFreeLock(Lock, Handle);
}

__inline
VOID
InterlockedRemoveQueueItemAtDpcLevel(
    IN Queue* Q,
    IN CTELock* Lock)
{
    CTELockHandle Handle;
    CTEGetLockAtDPC(Lock, &Handle);
    REMOVEQ(Q);
    CTEFreeLockFromDPC(Lock, Handle);
}


#endif      // __QUEUE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\inc\tcp.h ===
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

#ifndef _TCP_INCLUDED_
#define _TCP_INCLUDED_

//** TCP.H - TCP definitions.
//
// This file contains the definitions of TCP protocol specific options, such
// as the sequence numbers and TCB.
//

#define PROTOCOL_TCP        6
#define MIN_LOCAL_MSS       88
#define MAX_REMOTE_MSS      536

//* Timer stuff. We keep timers as ticks.
#define MS_PER_TICK         100
#define MS_TO_TICKS(m)      ((m) / MS_PER_TICK)
#define MIN_RETRAN_TICKS    3
#define DEL_ACK_TICKS       2
#define MAX_DEL_ACK_TICKS   6

// Define MAX_REXMIT_TO to be number of ticks in 2MSL
#define MAX_REXMIT_TO   ((ushort)FinWait2TO)

#define SWS_TO          MS_TO_TICKS(5000)
#define PUSH_TO         MS_TO_TICKS(500)

typedef ulong TCP_TIME;
#define MAX_CONN_TO_TICKS       0xffff
#define INFINITE_CONN_TO(t)     ((t) == 0)
#define TCP_TIME_TO_TICKS(t)    (((t)/MS_PER_TICK)+1)

//  Sequence numbers are kept as signed 32 bit quantities, with macros
//  defined to do wraparound comparisons on them.

typedef int SeqNum;                     // A sequence number.

//* Macros for comparions on sequence numbers.

#define SEQ_GT(a, b)    ((SeqNum)((a) - (b)) > 0)
#define SEQ_GTE(a, b)   ((SeqNum)((a) - (b)) >= 0)
#define SEQ_LT(a, b)    ((SeqNum)((a) - (b)) < 0)
#define SEQ_LTE(a, b)   ((SeqNum)((a) - (b)) <= 0)
#define SEQ_EQ(a, b)    ((a) == (b))

#define TS_LT(a, b)     (((a) - (b)) < 0)
#define TS_LTE(a, b)    (((a) - (b)) <= 0)
#define TS_GTE(a, b)    (((a) - (b)) >= 0)

#define TCPTIME_LTE(a, b) ((int)((a) - (b)) <= 0)
#define TCPTIME_LT(a, b)  ((int)((a) - (b)) < 0)

#define TIMWAITTABLE 1  //turn on timed wait TCB table changes
#define IRPFIX          1  //turn on quick Irp to Conn find

#if DBG && !MILLEN
#ifndef REFERENCE_DEBUG
#define REFERENCE_DEBUG 1
#endif

#else // DBG && !MILLEN

#ifndef REFERENCE_DEBUG
#define REFERENCE_DEBUG 0
#endif

#endif // DBG && !MILLEN

#if REFERENCE_DEBUG
// Reference history structure.
//

#define MAX_REFERENCE_HISTORY 64

typedef struct _TCP_REFERENCE_HISTORY {
    uchar *File;
    uint Line;
    void *Caller;
    uint Count;
} TCP_REFERENCE_HISTORY;

#endif // REFERENCE_DEBUG

//* The TCB - transport control block structure. This is the
//  structure that contains all of the state for the transport
//  connection, including sequence numbers, flow control information,
//  pending sends and receives, etc.

#define tcb_signature   0x20424354      // 'TCB '
#define twtcb_signature 0x22424354      // 'TCB2'
#define syntcb_signature 0x23424354      // 'TCB3'


typedef struct TWTCB {
#if DBG
    ulong           twtcb_sig;
#endif
    Queue           twtcb_link;
    IPAddr          twtcb_daddr;        // Destination IP address.
    IPAddr          twtcb_saddr;        // Source IP address.
    ushort          twtcb_dport;        // Destination port.
    ushort          twtcb_sport;        // Source port.
    Queue           twtcb_TWQueue;      // Place to hang all the timed_waits
    ushort          twtcb_delta;
    ushort          twtcb_rexmittimer;
    SeqNum          twtcb_senduna;
    SeqNum          twtcb_rcvnext;
    SeqNum          twtcb_sendnext;

#if DBG
    uint            twtcb_flags;
#endif
} TWTCB;



typedef struct SYNTCB {
#if DBG
    ulong               syntcb_sig;        // Debug signature.
#endif
    Queue               syntcb_link;      // Next pointer in TCB table.
    DEFINE_LOCK_STRUCTURE(syntcb_lock)

    // Addressing info.
    IPAddr              syntcb_daddr;      // Destination IP address.
    IPAddr              syntcb_saddr;      // Source IP address.
    ushort              syntcb_dport;      // Destination port.
    ushort              syntcb_sport;      // Source port.

    // State information.
    uchar               syntcb_state;      // State of this TCB.
    uchar               syntcb_rexmitcnt;  // Count of rexmits on this TCB.

    // Highly used receive sequence variables.
    ushort              syntcb_mss;        // MSS for this connection.
    ushort              syntcb_remmss;     // MSS advertised by peer.
    ushort              syntcb_tcpopts;    // rfc 1323 and 2018 options holder
    SeqNum              syntcb_rcvnext;    // Next byte we expect to receive.
    int                 syntcb_rcvwin;     // Receive window we're offering.

    // Send sequence variables.
    SeqNum              syntcb_senduna;    // Sequence number of first unack'd data.
    SeqNum              syntcb_sendnext;   // Sequence number of next byte to send.
    SeqNum              syntcb_sendmax;    // Max value of sendnext this epoch.
    uint                syntcb_sendwin;    // Send window.
    uint                syntcb_flags;      // Flags for this TCB.
    uint                syntcb_refcnt;     // Reference count for TCB.
    ushort              syntcb_rexmit;     // Rexmit value.

    // Retransmit timer information. These are stored as ticks, where by
    // default each tick is 100ms.
    ushort              syntcb_smrtt;      // Smoothed rtt value.
    ushort              syntcb_delta;      // Delta value.
    ushort              syntcb_rexmittimer;// Timer for rexmit.
    uint                syntcb_rtt;        // Current round trip time TS.
    uint                syntcb_defaultwin; // Default rcv. window.

    short               syntcb_sndwinscale;// send window scale
    short               syntcb_rcvwinscale;// receive window scale
    int                 syntcb_tsrecent;   // time stamp recent
    SeqNum              syntcb_lastack;    // ack number in  the last segment sent
    int                 syntcb_tsupdatetime;    // Time when tsrecent was updated
    uint                syntcb_walkcount;
    uint                syntcb_partition;
} SYNTCB;



#if TRACE_EVENT
typedef struct WMIData {
    ulong           wmi_context;        // PID
    ulong           wmi_size;           // num Bytes successfully sent.
    IPAddr          wmi_destaddr;       // Remote IPAddr.
    IPAddr          wmi_srcaddr;        // Local IPAddr.
    ushort          wmi_destport;       // Remote port.
    ushort          wmi_srcport;        // Local Port.
} WMIData;
#endif


// We will have 7 timers in TCP, and integrate all their processing
typedef enum {
    RXMIT_TIMER = 0,
    DELACK_TIMER,
    PUSH_TIMER,
    SWS_TIMER,
    ACD_TIMER,
    CONN_TIMER,
    KA_TIMER,
    NUM_TIMERS
} TCP_TIMER_TYPE;


#define NO_TIMER   NUM_TIMERS


typedef struct TCB {
#if DBG
    ulong               tcb_sig;        // Debug signature.
#endif
    struct TCB          *tcb_next;      // Next pointer in TCB table.
    DEFINE_LOCK_STRUCTURE(tcb_lock)
    uint                tcb_refcnt;     // Reference count for TCB.

    // Addressing info.
    IPAddr              tcb_daddr;      // Destination IP address.
    IPAddr              tcb_saddr;      // Source IP address.
    ushort              tcb_dport;      // Destination port.
    ushort              tcb_sport;      // Source port.
#if TRACE_EVENT
    ulong               tcb_cpcontext;
#endif
    // State information.
    uchar               tcb_state;      // State of this TCB.
    uchar               tcb_rexmitcnt;  // Count of rexmits on this TCB.
    uchar               tcb_pending;    // Pending actions on this TCB.
    uchar               tcb_kacount;    // Count of keep alive probes sent.

    // Highly used receive sequence variables.
    ushort              tcb_mss;        // MSS for this connection.
    ushort              tcb_remmss;     // MSS advertised by peer.
    SeqNum              tcb_rcvnext;    // Next byte we expect to receive.
    int                 tcb_rcvwin;     // Receive window we're offering.

    // Send sequence variables.
    SeqNum              tcb_senduna;    // Sequence number of first unack'd data.
    SeqNum              tcb_sendnext;   // Sequence number of next byte to send.
    SeqNum              tcb_sendmax;    // Max value of sendnext this epoch.
    uint                tcb_sendwin;    // Send window.
    uint                tcb_unacked;    // Total number of bytes of unacked data.
    uint                tcb_maxwin;     // Max send window seen.
    uint                tcb_cwin;       // Congestion window.
    uint                tcb_ssthresh;   // Slow start threshold.
    uint                tcb_phxsum;     // Precomputed pseudo-header xsum.
    struct TCPSendReq   *tcb_cursend;   // Current send in use.
    PNDIS_BUFFER        tcb_sendbuf;    // Current buffer chain being sent.
    uint                tcb_sendofs;    // Offset into start of chain.
    uint                tcb_sendsize;   // Number of bytes unsent in current send.
    Queue               tcb_sendq;      // Queue of send requests.

    // Less highly used receive sequence variables.
    SeqNum              tcb_sendwl1;    // Window update sequence number.
    SeqNum              tcb_sendwl2;    // Window update ack number.
    struct TCPRcvReq    *tcb_currcv;    // Current receive buffer.
    uint                tcb_indicated;  // Bytes of data indicated.
    uint                tcb_flags;      // Flags for this TCB.
    uint                tcb_fastchk;    // Fast receive path check field.
    uint                (*tcb_rcvhndlr)(struct TCB *, uint, struct IPRcvBuf *, uint Size);
    SeqNum              tcb_rttseq;     // Sequence number being measured for RTT.
    ushort              tcb_rexmit;     // Rexmit value.

    // Retransmit timer information. These are stored as ticks, where by
    // default each tick is 100ms.
    ushort              tcb_smrtt;      // Smoothed rtt value.
    ushort              tcb_delta;      // Delta value.
    uchar               tcb_slowcount;  // Count of reasons why we're on the slow path.
    uchar               tcb_closereason;    // Reason we're closing.

    IP_STATUS           tcb_error;      // Last error we heard about from IP.
    uint                tcb_rtt;        // Current round trip time TS.
    uint                tcb_defaultwin; // Default rcv. window.

    struct TCPRAHdr     *tcb_raq;       // Reassembly queue.
    struct TCPRcvReq    *tcb_rcvhead;   // Head of recv. buffer queue.
    struct TCPRcvReq    *tcb_rcvtail;   // Tail of recv. buffer queue.
    uint                tcb_pendingcnt; // Bytes waiting to be received.
    struct IPRcvBuf     *tcb_pendhead;  // Head of pending recv. queue.
    struct IPRcvBuf     *tcb_pendtail;  // Tail of pending recv. queue.

    struct TCPConnReq   *tcb_connreq;   // Connection-type request for
                                        // this connection.
    void                *tcb_conncontext;    // Connection context for this
                                             // connection.

    uint                tcb_bcountlow;  // Low part of byte count.
    uint                tcb_bcounthi;   // High part of bytecount.
    uint                tcb_totaltime;  // Total number of ticks spent
                                        // sending.
    struct  TCB         *tcb_aonext;    // Next pointer on AddrObj.
    struct TCPConn      *tcb_conn;      // Back pointer to conn for TCB.
    Queue               tcb_delayq;     // Queue linkage for delay queue.

    void                *tcb_rcvind;    // Receive indication handler.
    void                *tcb_ricontext; // Receive indication context.
    // Miscellaneous info, for IP.
    IPOptInfo           tcb_opt;        // Option information.
    RouteCacheEntry     *tcb_rce;       // RCE for this connection.
    struct TCPConnReq   *tcb_discwait;  // Disc-Wait req., if there is one.
    struct TCPRcvReq    *tcb_exprcv;    // Head of expedited recv. buffer
                                        // queue.
    struct IPRcvBuf     *tcb_urgpending;    // Urgent data queue.
    uint                tcb_urgcnt;     // Byte count of data on urgent q.
    uint                tcb_urgind;     // Urgent bytes indicated.
    SeqNum              tcb_urgstart;   // Start of urgent data.
    SeqNum              tcb_urgend;     // End of urgent data.
    uint                tcb_walkcount;  // Count of number of people
                                        // 'walking' this TCB.
    Queue               tcb_TWQueue;    // Place to hang all the timed_waits
    ushort              tcb_dup;        // For Fast recovery algorithm

    ushort              tcb_force : 1;  // Force next send after fast send
    ushort              tcb_tcpopts : 3;// rfc 1323 and 2018 options holder
    ushort              tcb_moreflag : 3;

    struct SACKSendBlock *tcb_SackBlock;// Sacks which needs to be sent
    struct SackListEntry *tcb_SackRcvd; // Sacks which needs to be processed

    short               tcb_sndwinscale;// send window scale
    short               tcb_rcvwinscale;// receive window scale
    int                 tcb_tsrecent;   // time stamp recent
    SeqNum              tcb_lastack;    // ack number in  the last segment sent
    int                 tcb_tsupdatetime;    // Time when tsrecent was updated
    void                *tcb_chainedrcvind;    //for chained receives
    void                *tcb_chainedrcvcontext;

#if GPC
    ULONG               tcb_GPCCachedIF;
    ULONG               tcb_GPCCachedLink;
    struct RouteTableEntry *tcb_GPCCachedRTE;

#endif
#if DBG
    uint                tcb_LargeSend;  // Counts the number of outstanding
                                        // large-send transmit-requests
#endif
    uint                tcb_partition;
    uint                tcb_connid;

    // ACK behavior
    uchar               tcb_delackticks;
    uchar               tcb_numdelacks;
    uchar               tcb_rcvdsegs;

    uchar               tcb_bhprobecnt; // BH probe count.

    // Timer wheel parameters
    // The first two are one logical group called wheel state.
    // They indicate which slot in the timer wheel the TCB is in,
    // and it's linkage in the timer slot queue.

    Queue               tcb_timerwheelq;
    ushort              tcb_timerslot : 12;

    // These three variables are another logical group called timer
    // state. They indicate the state of timers active on the TCB,
    // tcb_timertime maintains the time at which the earliest timer
    // will fire, and tcb_timertype maintains the earliest timer's
    // type.
    // To see why this whole thing is important, see comments after
    // the TIMER_WHEEL structure definition.

    ushort              tcb_timertype : 4;
    uint                tcb_timertime;
    uint                tcb_timer[NUM_TIMERS];

#if ACK_DEBUG
#define NUM_ACK_HISTORY_ITEMS 64

    uint                tcb_history_index;
    struct {
        SeqNum  sequence;
        uint    unacked;
    } tcb_ack_history[NUM_ACK_HISTORY_ITEMS];
#endif  // ACK_DEBUG
#if REFERENCE_DEBUG
    uint                tcb_refhistory_index;
    TCP_REFERENCE_HISTORY tcb_refhistory[MAX_REFERENCE_HISTORY];
#endif //REFERENCE_DEBUG


} TCB;


#define TIMER_WHEEL_SIZE     511

#define DUMMY_SLOT     TIMER_WHEEL_SIZE
#define MAX_TIME_VALUE 0xffffffff




// The Timer wheel structure definition has:
// tw_timerslot:  An array of queues, one for each timer slot.
// tw_lock:       A lock protecting the complete timer wheel.
//                (Contention is reduced by having as many timer
//                wheels as partitions in the system).
// tw_starttick:  Indicates the first time tick that has to
//                be looked at.
//                For e.g., if a timer routine looked at all
//                TCBs firing on or before tick 5 in a pass,
//                it would set tw_starttick to 6, and that is
//                the point it would start processing from on
//                the next pass.

typedef struct CACHE_ALIGN _Timer_Wheel {
    Queue      tw_timerslot[TIMER_WHEEL_SIZE];
    uint       tw_starttick;
    CTELock    tw_lock;
} TIMER_WHEEL, *PTIMER_WHEEL;

C_ASSERT(sizeof(TIMER_WHEEL) % MAX_CACHE_LINE_SIZE == 0);
C_ASSERT(__alignof(TIMER_WHEEL) == MAX_CACHE_LINE_SIZE);


// The first two functions operate on timer state (see comments in definition
// of TCB for meaning of timer state). StopTCBTimerR and StartTCBTimerR
// operate on the timer state (tcb_timertype, tcb_timertime, tcb_timer)
// atomically. A call to either of these functions will always leave wheel
// state consistent.

extern void StopTCBTimerR(TCB  *StopTCB, TCP_TIMER_TYPE TimerType);
extern BOOLEAN StartTCBTimerR(TCB *StartTCB, TCP_TIMER_TYPE TimerType, uint TimerValue);

// The following functions operate on the TCB's wheel state (tcb_timerwheelq
// and tcb_timerslot). A call to any of these functions changes the value
// of both the variables in such a way that they are consistent.

extern void InsertIntoTimerWheel(TCB *InsertTCB, ushort Slot);
extern void RemoveFromTimerWheel(TCB *RemoveTCB);
extern void RemoveAndInsertIntoTimerWheel(TCB *RemInsTCB, ushort Slot);

// The job of the inline functions below, is to sort-of act as glue, and they ensure
// that the wheel state and timer state of a TCB are in tandem with each
// other.

// STOP_TCB_TIMER_R modifies the timer state but never
// does anything to the wheel state. This means that the TCB will remain
// where it was in the timer wheel, and the timer routine will eventually
// bring the wheel state in conformance with the timer state.

extern void STOP_TCB_TIMER_R(TCB *Tcb, TCP_TIMER_TYPE Type);

// START_TCB_TIMER_R modifies the timer state and only modifies
// wheel state if the timer that was started was earlier than all the
// other timers on that TCB. This is in accordance with the lazy evaluation
// strategy.
extern void START_TCB_TIMER_R(TCB *Tcb, TCP_TIMER_TYPE Type, uint Value);



#define COMPUTE_SLOT(Time)  ((Time) % TIMER_WHEEL_SIZE)


#define TCB_TIMER_FIRED_R(tcb, type, time)   \
        ((tcb->tcb_timer[type]) && (tcb->tcb_timer[type] == time))

#define TCB_TIMER_RUNNING_R(tcb, type)  (tcb->tcb_timer[type] != 0)

//* Definitions for TCP states.
#define TCB_CLOSED      0               // Closed.
#define TCB_LISTEN      1               // Listening.
#define TCB_SYN_SENT    2               // SYN Sent.
#define TCB_SYN_RCVD    3               // SYN received.
#define TCB_ESTAB       4               // Established.
#define TCB_FIN_WAIT1   5               // FIN-WAIT-1
#define TCB_FIN_WAIT2   6               // FIN-WAIT-2
#define TCB_CLOSE_WAIT  7               // Close waiting.
#define TCB_CLOSING     8               // Closing state.
#define TCB_LAST_ACK    9               // Last ack state.
#define TCB_TIME_WAIT   10              // Time wait state.

#define SYNC_STATE(s)   ((s) > TCB_SYN_RCVD)
#define SYNC_RCVD_STATE(s)  ((s) > TCB_SYN_SENT)
#define GRACEFUL_CLOSED_STATE(s)    ((s) >= TCB_LAST_ACK)
#define DATA_RCV_STATE(s)   ((s) >= TCB_ESTAB && (s) <= TCB_FIN_WAIT2)
#define DATA_SEND_STATE(s)  ((s) == TCB_ESTAB || (s) == TCB_CLOSE_WAIT)

//* Definitions for flags.
#define WINDOW_SET      0x00000001      // Window explictly set.
#define CLIENT_OPTIONS  0x00000002      // Have client IP options on conn.
#define CONN_ACCEPTED   0x00000004      // Connection was accepted.
#define ACTIVE_OPEN     0x00000008      // Connection came from an active
                                        // open.
#define DISC_NOTIFIED   0x00000010      // Client has been notified of a
                                        // disconnect.
#define IN_DELAY_Q      0x00000020      // We're in the delayed action Q.
#define RCV_CMPLTING    0x00000040      // We're completeing rcvs.
#define IN_RCV_IND      0x00000080      // We're calling a rcv. indicate
                                        // handler.
#define NEED_RCV_CMPLT  0x00000100      // We need to have recvs. completed.
#define NEED_ACK        0x00000200      // We need to send an ACK.
#define NEED_OUTPUT     0x00000400      // We need to output.

#define DELAYED_FLAGS   (NEED_RCV_CMPLT | NEED_ACK | NEED_OUTPUT)


#define ACK_DELAYED     0x00000800      // We've delayed sending an ACK.

#define PMTU_BH_PROBE   0x00001000      // We're probing for a PMTU BH.
#define BSD_URGENT      0x00002000      // We're using BSD urgent semantics.
#define IN_DELIV_URG    0x00004000      // We're in the DeliverUrgent routine.
#define URG_VALID       0x00008000      // We've seen urgent data, and
                                        // the urgent data fields are valid.

#define FIN_NEEDED      0x00010000      // We need to send a FIN.
#define NAGLING         0x00020000      // We are using Nagle's algorithm.
#define IN_TCP_SEND     0x00040000      // We're in TCPSend.
#define FLOW_CNTLD      0x00080000      // We've received a zero window
                                        // from our peer.
#define DISC_PENDING    0x00100000      // A disconnect notification is
                                        // pending.
#define TW_PENDING      0x00200000      // We're waiting to finish going
                                        // to TIME-WAIT.
#define FORCE_OUTPUT    0x00400000      // Output is being forced.
#define FORCE_OUT_SHIFT 22              // Shift to get FORCE_OUTPUT into
                                        // low bit.
#define SEND_AFTER_RCV  0x00800000      // We need to send after we get out
                                        // of recv.
#define GC_PENDING      0x01000000      // A graceful close is pending.
#define KEEPALIVE       0x02000000      // Doing keepalives on this TCB.
#define URG_INLINE      0x04000000      // Urgent data to be processed
                                        // inline.

#define SCALE_CWIN      0x08000000      // Increment CWin proportionally to
                                        // amount of data acknowledged.
#define FIN_OUTSTANDING 0x10000000      // We've sent a FIN 'recently', i.e.
                                        // since the last retransmit. When
                                        // this flag is set sendnext ==
                                        // sendmax.

#define FIN_OUTS_SHIFT  28              // Shift to FIN_OUTSTANDING bit into
                                        // low bit.
#define FIN_SENT        0x20000000      // We've sent a FIN that hasn't
                                        // been acknowledged. Once this
                                        // bit has been turned on in
                                        // FIN-WAIT-1 the sequence number
                                        // of the FIN will be sendmax-1.
#define NEED_RST        0x40000000      // We need to send a RST when
                                        // closing.
#define IN_TCB_TABLE    0x80000000      // TCB is in the TCB table.


#define IN_TWTCB_TABLE  0x00000001
#define IN_TWQUEUE      0x00000010
#define SCAVENGER_SEEN  0x00000100
#define TIMEOUT_SEEN    0x00001000
#define SYN_ON_TWTCB    0x00010000
#define IN_FINDTWTCB    0x00100000

#define IN_SYNTCB_TABLE 0x00000001


//* The defintion of the 'slow flags'. If any of these flags are set we'll
//  be forced off of the fast path.

#define TCP_SLOW_FLAGS  (URG_VALID | FLOW_CNTLD | GC_PENDING | \
                            TW_PENDING | DISC_NOTIFIED | IN_DELIV_URG | \
                            FIN_NEEDED | FIN_SENT | FIN_OUTSTANDING | \
                            DISC_PENDING | PMTU_BH_PROBE)

//* Close reasons.
#define TCB_CLOSE_RST       0x80        // Received a RST segment.
#define TCB_CLOSE_ABORTED   0x40        // Had a local abort.
#define TCB_CLOSE_TIMEOUT   0x20        // Connection timed out.
#define TCB_CLOSE_REFUSED   0x10        // Connect attempt was refused.
#define TCB_CLOSE_UNREACH   0x08        // Remote destination unreachable.
#define TCB_CLOSE_SUCCESS   0x01        // Successfull close.

//* TCB Timer macros.
#define START_TCB_TIMER(t, v) (t) = (v)
#define STOP_TCB_TIMER(t) (t) = 0
#define TCB_TIMER_RUNNING(t)    ((t) != 0)

//  Macro to compute retransmit timeout.
#define REXMIT_TO(t)    ((((t)->tcb_smrtt >> 2) + (t)->tcb_delta) >> 1)

//* Definitons for pending actions. We define a PENDING_ACTION macro
//  that can be used to decide whether or not we can proceed with an
//  activity. The only pending action we really care about is DELETE - others
//  are low priority and can be put off.
#define PENDING_ACTION(t)   ((t)->tcb_pending & DEL_PENDING)
#define DEL_PENDING     0x01            // Delete is pending.
#define OPT_PENDING     0x02            // Option set is pending.
#define FREE_PENDING    0x04            // Can be freed


//* Macro to see if a TCB is closing.
#define CLOSING(t)  ((t)->tcb_pending & DEL_PENDING)

//* Structure of a TCP packet header.

struct TCPHeader {
    ushort              tcp_src;        // Source port.
    ushort              tcp_dest;       // Destination port.
    SeqNum              tcp_seq;        // Sequence number.
    SeqNum              tcp_ack;        // Ack number.
    ushort              tcp_flags;      // Flags and data offset.
    ushort              tcp_window;     // Window offered.
    ushort              tcp_xsum;       // Checksum.
    ushort              tcp_urgent;     // Urgent pointer.
};

typedef struct TCPHeader TCPHeader;

//* Definitions for header flags.
#define TCP_FLAG_FIN    0x00000100
#define TCP_FLAG_SYN    0x00000200
#define TCP_FLAG_RST    0x00000400
#define TCP_FLAG_PUSH   0x00000800
#define TCP_FLAG_ACK    0x00001000
#define TCP_FLAG_URG    0x00002000

#define TCP_FLAGS_ALL   (TCP_FLAG_FIN | TCP_FLAG_SYN | TCP_FLAG_RST | \
                         TCP_FLAG_ACK | TCP_FLAG_URG)

//* Flags in the tcb_fastchk field that are not in the TCP header proper.
//  Setting these flags forces us off the fast path.
#define TCP_FLAG_SLOW               0x00000001  // Need to be on slow path.
#define TCP_FLAG_IN_RCV             0x00000002  // In recv. path already.
#define TCP_FLAG_FASTREC            0x00000004  // This is used to mark tcb
#define TCP_FLAG_SEND_AND_DISC      0x00000008
// former tcb_flag2 flags, now in tcb_fastchk
#define TCP_FLAG_ACCEPT_PENDING              0x00000010
#define TCP_FLAG_REQUEUE_FROM_SEND_AND_DISC  0x00000020
#define TCP_FLAG_RST_WHILE_SYN      0x00000040  // Valid RST was received while
                                                // establishing outboud connct.



#define TCP_OFFSET_MASK 0xf0
#define TCP_HDR_SIZE(t) (uint)(((*(uchar *)&(t)->tcp_flags) & TCP_OFFSET_MASK) >> 2)

#define MAKE_TCP_FLAGS(o, f) ((f) | ((o) << 4))

#define TCP_OPT_EOL     0
#define TCP_OPT_NOP     1
#define TCP_OPT_MSS     2
#define MSS_OPT_SIZE    4

#define TCP_SACK_PERMITTED_OPT 4
#define SACK_PERMITTED_OPT_SIZE 2       // SACK "permitted" option size, in SYN segments
#define TCP_FLAG_SACK   0x00000004
#define TCP_OPT_SACK    5               // Sack option

#define ALIGNED_TS_OPT_SIZE 12

#define TCP_OPT_WS      3               // Window scale option
#define TCP_OPT_TS      8               // Time stamp option
#define WS_OPT_SIZE     3
#define TS_OPT_SIZE     10
#define TCP_MAXWIN      65535           // maximum unscaled window size
#define TCP_MAX_WINSHIFT 14             // Maximum shift allowed
#define TCP_FLAG_WS     0x00000001      // Flags in tcb_options for ws and ts
#define TCP_FLAG_TS     0x00000002
#define PAWS_IDLE       24*24*60*60*100 // Paws idle time - 24 days

//* Convenient byte swapped structure for receives.
struct TCPRcvInfo {
    SeqNum              tri_seq;        // Sequence number.
    SeqNum              tri_ack;        // Ack number.
    uint                tri_window;     // Window.
    uint                tri_urgent;     // Urgent pointer.
    uint                tri_flags;      // Flags.
};

typedef struct TCPRcvInfo TCPRcvInfo;



//* General structure, at the start of all command specific request structures.

#define tr_signature    0x20205254      // 'TR  '

struct TCPReq {
#if DBG
    ulong           tr_sig;
#endif
    struct  Queue   tr_q;               // Q linkage.
    CTEReqCmpltRtn  tr_rtn;             // Completion routine.
    PVOID           tr_context;         // User context.
    int             tr_status;          // Final complete status.
};

typedef struct TCPReq TCPReq;
// structures to support SACK

struct SackSeg {
    SeqNum begin;
    SeqNum end;
};
typedef struct SackSeg SackSeg;

// Maximum 4 sack entries can be sent
// so, size sack send block acordingly

struct SACKSendBlock {
    uchar Mask[4];
    SackSeg Block[4];
};
typedef struct SACKSendBlock SACKSendBlock;


// list of received sack entries

struct SackListEntry {
    struct SackListEntry *next;
    SeqNum begin;
    SeqNum end;
};
typedef struct SackListEntry SackListEntry;

struct ReservedPortListEntry {
    struct ReservedPortListEntry *next;
    ushort UpperRange;
    ushort LowerRange;
};
typedef struct ReservedPortListEntry ReservedPortListEntry;


#ifdef POOL_TAGGING

#ifdef ExAllocatePool
#undef ExAllocatePool
#endif

#ifdef CTEAllocMemN
#undef CTEAllocMemN
#endif


#define ExAllocatePool(type, size) ExAllocatePoolWithTag(type, size, 'tPCT')

#ifndef CTEAllocMem
#error "CTEAllocMem is not already defined - will override tagging"
#else
#undef CTEAllocMem
#endif

#ifdef CTEAllocMemBoot
#undef CTEAllocMemBoot
#endif

#if MILLEN
#define CTEAllocMem(size) ExAllocatePoolWithTag(NonPagedPool, size, 'tPCT')
#define CTEAllocMemN(size,tag) ExAllocatePoolWithTag(NonPagedPool, size, tag)
#define CTEAllocMemLow(size,tag) ExAllocatePoolWithTag(NonPagedPool, size, tag)
#define CTEAllocMemBoot(size) ExAllocatePoolWithTag(NonPagedPool, size, 'tPCT')
#else // MILLEN
#define CTEAllocMem(size) ExAllocatePoolWithTagPriority(NonPagedPool, size, 'tPCT', NormalPoolPriority)
#define CTEAllocMemN(size,tag) ExAllocatePoolWithTagPriority(NonPagedPool, size, tag,NormalPoolPriority)
#define CTEAllocMemLow(size,tag) ExAllocatePoolWithTagPriority(NonPagedPool, size, tag,LowPoolPriority)
#define CTEAllocMemBoot(size) ExAllocatePoolWithTag(NonPagedPool, size, 'tPCT')
#endif // !MILLEN


#endif // POOL_TAGGING

#if TRACE_EVENT
#define _WMIKM_
#include "evntrace.h"
#include "wmikm.h"
#include "wmistr.h"

#define EVENT_TRACE_GROUP_TCPIP                0x0600
#define EVENT_TRACE_GROUP_UDPIP                0x0800


typedef VOID (*PTDI_DATA_REQUEST_NOTIFY_ROUTINE)(
                                                IN  ULONG   EventType,
                                                IN  PVOID   DataBlock,
                                                IN  ULONG   Size,
                                                IN  PETHREAD  Thread);

extern PTDI_DATA_REQUEST_NOTIFY_ROUTINE TCPCPHandlerRoutine;


typedef struct _CPTRACE_DATABLOCK {
    IPAddr  saddr;
    IPAddr  daddr;
    ushort  sport;
    ushort  dport;
    uint    size;
    HANDLE  cpcontext;
} CPTRACE_DATABLOCK, *PCPTRACE_BLOCK;
#endif

//
// TCP endpoint context structure allocated for each open of TCP/UDP.
// A pointer to this structure is stored in FileObject->FsContext.
//
typedef struct _TCP_CONTEXT {
    union {
        HANDLE AddressHandle;
        CONNECTION_CONTEXT ConnectionContext;
        HANDLE ControlChannel;
    } Handle;
    ULONG      ReferenceCount;
    BOOLEAN    CancelIrps;
    BOOLEAN    Cleanup;
#if DBG
    LIST_ENTRY PendingIrpList;
    LIST_ENTRY CancelledIrpList;
#endif
    KEVENT     CleanupEvent;
    UINT_PTR   Conn;
    PIRP       Irp;
    DEFINE_LOCK_STRUCTURE(EndpointLock)
} TCP_CONTEXT, *PTCP_CONTEXT;


#define MAJOR_TDI_VERSION 2
#define MINOR_TDI_VERSION 0

extern HANDLE DgHeaderPool;

//* Definition of an AO request structure. There structures are used only for
//  queuing delete and option get/set requests.

#define aor_signature   0x20524F41

typedef struct AORequest {
#if DBG
    ulong               aor_sig;
#endif
    struct AORequest    *aor_next;          // Next pointer in chain.
    uint                aor_id;             // ID for the request.
    uint                aor_length;         // Length of buffer.
    void                *aor_buffer;        // Buffer for this request.
    CTEReqCmpltRtn      aor_rtn;            // Request complete routine for
                                            // this request.
    PVOID               aor_context;        // Request context.
    uint                aor_type;           // Request type.
} AORequest;

//
// Values of aor_type
//
#define AOR_TYPE_GET_OPTIONS      1
#define AOR_TYPE_SET_OPTIONS      2
#define AOR_TYPE_REVALIDATE_MCAST 3
#define AOR_TYPE_DELETE           4

extern AORequest *AORequestBlockPtr;

#include    "tcpdeb.h"

#if REFERENCE_DEBUG
uint
TcpReferenceTCB (
    IN TCB *RefTCB,
    IN uchar *File,
    IN uint Line
    );

uint
TcpDereferenceTCB (
    IN TCB *DerefTCB,
    IN uchar *File,
    IN uint Line
    );

#define REFERENCE_TCB(_a) TcpReferenceTCB((_a), __FILE__, __LINE__)

#define DEREFERENCE_TCB(_a) TcpDereferenceTCB((_a), __FILE__, __LINE__)

#else // REFERENCE_DEBUG

#define REFERENCE_TCB(_a) ++(_a)->tcb_refcnt

#define DEREFERENCE_TCB(_a) --(_a)->tcb_refcnt

#endif // REFERENCE_DEBUG

#endif // _TCP_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\inc\oscfg.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

#ifndef OSCFG_INCLUDED
#define OSCFG_INCLUDED

#define MIN(a,b)    ((a) < (b) ? (a) : (b))
#define MAX(a,b)    ((a) > (b) ? (a) : (b))

// My binary compatible definition for compiling an Millennium tcpip.sys
#if MILLEN
#include "wdm.h"
#define KdPrintEx(_x_)
#else // MILLEN
#include <ntosp.h>
#include <zwapi.h>
#endif // !MILLEN

#define BEGIN_INIT
#define END_INIT


#if defined (_WIN64)
#define MAX_CACHE_LINE_SIZE 128
#else
#define MAX_CACHE_LINE_SIZE 64
#endif

#define CACHE_ALIGN __declspec(align(MAX_CACHE_LINE_SIZE))

typedef struct CACHE_ALIGN _CACHE_LINE_KSPIN_LOCK {
    KSPIN_LOCK Lock;
} CACHE_LINE_KSPIN_LOCK;
C_ASSERT(sizeof(CACHE_LINE_KSPIN_LOCK) % MAX_CACHE_LINE_SIZE == 0);
C_ASSERT(__alignof(CACHE_LINE_KSPIN_LOCK) == MAX_CACHE_LINE_SIZE);

typedef struct CACHE_ALIGN _CACHE_LINE_SLIST_HEADER {
    SLIST_HEADER SListHead;
} CACHE_LINE_SLIST_HEADER;
C_ASSERT(sizeof(CACHE_LINE_SLIST_HEADER) % MAX_CACHE_LINE_SIZE == 0);
C_ASSERT(__alignof(CACHE_LINE_SLIST_HEADER) == MAX_CACHE_LINE_SIZE);

typedef struct CACHE_ALIGN _CACHE_LINE_ULONG {
    ULONG Value;
} CACHE_LINE_ULONG;
C_ASSERT(sizeof(CACHE_LINE_ULONG) % MAX_CACHE_LINE_SIZE == 0);
C_ASSERT(__alignof(CACHE_LINE_ULONG) == MAX_CACHE_LINE_SIZE);

#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define net_short(_x) _byteswap_ushort((USHORT)(_x))
#define net_long(_x)  _byteswap_ulong(_x)
#else
__inline
USHORT
FASTCALL
net_short(
    ULONG NaturalData)
{
    USHORT ShortData = (USHORT)NaturalData;

    return (ShortData << 8) | (ShortData >> 8);
}

// if x is aabbccdd (where aa, bb, cc, dd are hex bytes)
// we want net_long(x) to be ddccbbaa.  A small and fast way to do this is
// to first byteswap it to get bbaaddcc and then swap high and low words.
//
__inline
ULONG
FASTCALL
net_long(
    ULONG NaturalData)
{
    ULONG ByteSwapped;

    ByteSwapped = ((NaturalData & 0x00ff00ff) << 8) |
                  ((NaturalData & 0xff00ff00) >> 8);

    return (ByteSwapped << 16) | (ByteSwapped >> 16);
}
#endif

__inline
BOOLEAN
IsPowerOfTwo(
    ULONG Value
    )
{
    return (Value & (Value - 1)) == 0;
}

// Find the highest power of two that is greater
// than or equal to the Value.
//
__inline
ULONG
ComputeLargerOrEqualPowerOfTwo(
    ULONG Value
    )
{
    ULONG Temp;

    for (Temp = 1; Temp < Value; Temp <<= 1);

    return Temp;
}

// Find the highest power of two, in the form of its shift, that is greater
// than or equal to the Value.
//
__inline
ULONG
ComputeShiftForLargerOrEqualPowerOfTwo(
    ULONG Value
    )
{
    ULONG Shift;
    ULONG Temp;

    for (Temp = 1, Shift = 0; Temp < Value; Temp <<= 1, Shift++);

    return Shift;
}


__inline
VOID
FASTCALL
CTEGetLockAtIrql (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL OrigIrql,
    OUT PKIRQL OldIrql)
{
#if !MILLEN
    if (DISPATCH_LEVEL == OrigIrql) {
        ASSERT(DISPATCH_LEVEL == KeGetCurrentIrql());
        ExAcquireSpinLockAtDpcLevel(SpinLock);
        *OldIrql = DISPATCH_LEVEL;
    } else {
        ExAcquireSpinLock(SpinLock, OldIrql);
    }
#else
    *OldIrql = 0;
#endif
}

__inline
VOID
FASTCALL
CTEFreeLockAtIrql (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL OrigIrql,
    IN KIRQL NewIrql)
{
#if !MILLEN
    if (DISPATCH_LEVEL == OrigIrql) {
        ASSERT(DISPATCH_LEVEL == NewIrql);
        ASSERT(DISPATCH_LEVEL == KeGetCurrentIrql());
        ExReleaseSpinLockFromDpcLevel(SpinLock);
    } else {
        ExReleaseSpinLock(SpinLock, NewIrql);
    }
#endif
}

#endif // OSCFG_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\inc\tcpipbase.h ===
#pragma once

#include "oscfg.h"

#include <ndis.h>
#include <cxport.h>

#include <tdikrnl.h>
#include <tdiinfo.h>
#include <tdistat.h>
#include "tdint.h"  // do we need this header?

#include <ip.h>
#include <ntddip.h>
#include <ipifcons.h>

#include "queue.h"
#include "dbgmsg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\inc\tcpdeb.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** TCPDEB.H - TCP debug definitions.
//
// This file contains the definitions for the debug code.
//

#ifndef NO_TCP_DEFS
#ifdef	DEBUG

extern	void CheckRBList(IPRcvBuf *RBList, uint Size);
extern	void CheckTCBSends(TCB *SendTcb);
extern	void CheckTCBRcv(TCB *RcvTCB);

#else

#define CheckRBList(R, S)
#define CheckTCBSends(T)
#define	CheckTCBRcv(T)
#endif  // DEBUG
#endif  // NO_TCP_DEFS

//
// Additional debugging support for NT
//
#if DBG

extern ULONG TCPDebug;

#define TCP_DEBUG_OPEN           0x00000001
#define TCP_DEBUG_CLOSE          0x00000002
#define TCP_DEBUG_ASSOCIATE      0x00000004
#define TCP_DEBUG_CONNECT        0x00000008
#define TCP_DEBUG_SEND           0x00000010
#define TCP_DEBUG_RECEIVE        0x00000020
#define TCP_DEBUG_INFO           0x00000040
#define TCP_DEBUG_IRP            0x00000080
#define TCP_DEBUG_SEND_DGRAM     0x00000100
#define TCP_DEBUG_RECEIVE_DGRAM  0x00000200
#define TCP_DEBUG_EVENT_HANDLER  0x00000400
#define TCP_DEBUG_CLEANUP        0x00000800
#define TCP_DEBUG_CANCEL         0x00001000
#define TCP_DEBUG_RAW            0x00002000
#define TCP_DEBUG_OPTIONS        0x00004000
#define TCP_DEBUG_1323           0x00008000
#define TCP_DEBUG_SACK           0x00010000
#define TCP_DEBUG_CONUDP         0x00020000
#define TCP_DEBUG_GPC            0x00040000
#define TCP_DEBUG_OFFLOAD        0x00080000






#define TCPTRACE(many_args) DbgPrint many_args

#define IF_TCPDBG(flag)  if (TCPDebug & flag)


#else // DBG


#define TCPTRACE(many_args)
#define IF_TCPDBG(flag)   if (0)


#endif // DBG


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\inc\tcpipbuf.h ===
/*++

 Copyright (c) 1999-2000 Microsoft Corporation

 Module Name:

       tcpipbuf.h

 Abstract:

       This file implements inline wrappers for the NdisBufferVirtualAddress
       and NdisQueryBuffer (which in turn calls MmGetSystemAddressForMdl)
       so that we can test the failure paths and add TCP/IP functionality
       as required.

 Revision History:

--*/

#if DBG

// #define DBG_MAP_BUFFER 1

#if DBG_MAP_BUFFER
// This is to allow us to test failure conditions.
extern ULONG g_cFailSafeMDLQueries;
extern ULONG g_fPerformMDLFailure;
#endif // DBG_MAP_BUFFER

#define TcpipBufferVirtualAddress(pBuffer, Priority) \
    DbgTcpipBufferVirtualAddress(pBuffer, Priority, __FILE__, __LINE__)

#define TcpipQueryBuffer(pBuffer, ppvBuffer, pcbBuffer, Priority) \
    DbgTcpipQueryBuffer(pBuffer, ppvBuffer, pcbBuffer, Priority, __FILE__, __LINE__)

__inline PVOID
DbgTcpipBufferVirtualAddress(
    IN PNDIS_BUFFER pBuffer,
    IN UINT         Priority,
    IN char        *pFileName,
    IN int          cLineNumber
    )
{
    PVOID pvBuffer;

#if DBG_MAP_BUFFER
    if (g_fPerformMDLFailure == TRUE)
    {
        if (InterlockedDecrement(&g_cFailSafeMDLQueries) == 0)
        {
            // Stop failing requests.
            g_fPerformMDLFailure = FALSE;
        }

        DbgPrint("TcpipBufferVirtualAddress FORCED failure - MDL %x: %s @ line %d\n",
            pBuffer, pFileName, cLineNumber);

        return (NULL);
    }
#endif // DBG_MAP_BUFFER

#if MILLEN
    pvBuffer = NdisBufferVirtualAddress(pBuffer);
#else // MILLEN
    pvBuffer = NdisBufferVirtualAddressSafe(pBuffer, Priority);
#endif // !MILLEN

    if (pvBuffer == NULL)
    {
        DbgPrint("TcpipBufferVirtualAddress failure - MDL %x: %s @ line %d\n",
            pBuffer, pFileName, cLineNumber);
    }

    return (pvBuffer);
}

__inline VOID
DbgTcpipQueryBuffer(
    IN	PNDIS_BUFFER pNdisBuffer,
    OUT PVOID *      ppvBuffer OPTIONAL,
    OUT PUINT        pcbBuffer,
    IN  UINT         Priority,
    IN  char        *pFileName,
    IN  int          cLineNumber
    )
{

#if DBG_MAP_BUFFER
    if (g_fPerformMDLFailure == TRUE)
    {
        if (InterlockedDecrement(&g_cFailSafeMDLQueries) == 0)
        {
            // Stop failing requests.
            g_fPerformMDLFailure = FALSE;
        }

        *ppvBuffer = NULL;
        *pcbBuffer = MmGetMdlByteCount(pNdisBuffer);

        DbgPrint("TcpipQueryBuffer FORCED failure - MDL %x: %s @ line %d\n",
            pNdisBuffer, pFileName, cLineNumber);

        return;
    }
#endif // DBG_MAP_BUFFER

#if MILLEN
    NdisQueryBuffer(pNdisBuffer, ppvBuffer, pcbBuffer);
#else // MILLEN
    NdisQueryBufferSafe(pNdisBuffer, ppvBuffer, pcbBuffer, Priority);
#endif // !MILLEN

    if (*ppvBuffer == NULL)
    {
        DbgPrint("TcpipQueryBuffer failure - MDL %x: %s @ line %d\n",
            pNdisBuffer, pFileName, cLineNumber);
    }

    return;
}

#if DBG_MAP_BUFFER

#define IOCTL_IP_DBG_TEST_FAIL_MAP_BUFFER \
            _IP_CTL_CODE(40, METHOD_BUFFERED, FILE_WRITE_ACCESS)

__inline NTSTATUS
DbgTestFailMapBuffers(
    ULONG cFailures
    )
{
    if (g_fPerformMDLFailure == FALSE) {
        DbgPrint("DbgTestFailMapBuffers %d\n", cFailures);
        g_cFailSafeMDLQueries = cFailures;
        g_fPerformMDLFailure = TRUE;
    } else {
        return (STATUS_UNSUCCESSFUL);
    }

    return (STATUS_SUCCESS);
}
#endif // DBG_MAP_BUFFER

#else // DBG

__inline PVOID
TcpipBufferVirtualAddress(
    IN PNDIS_BUFFER pBuffer,
    IN INT          Priority
    )
{
#if MILLEN
    return (NdisBufferVirtualAddress(pBuffer));
#else // MILLEN
    return (NdisBufferVirtualAddressSafe(pBuffer, Priority));
#endif // !MILLEN
}

__inline VOID
TcpipQueryBuffer(
    IN	PNDIS_BUFFER pNdisBuffer,
    OUT PVOID *      ppvBuffer OPTIONAL,
    OUT PUINT        pcbBuffer,
    IN  UINT         Priority
    )
{
#if MILLEN
    NdisQueryBuffer(pNdisBuffer, ppvBuffer, pcbBuffer);
#else // MILLEN
    NdisQueryBufferSafe(pNdisBuffer, ppvBuffer, pcbBuffer, Priority);
#endif // !MILLEN
    return;
}

#endif // !DBG

#if MILLEN

typedef struct _XNDIS_BUFFER {
    struct _NDIS_BUFFER *Next;
    PVOID VirtualAddress;
    PVOID Pool;
    UINT Length;
    UINT Signature;
} XNDIS_BUFFER, *PXNDIS_BUFFER;

__inline VOID
NdisAdjustBuffer(
    IN  PNDIS_BUFFER Mdl,
    IN  PVOID        NewVirtualAddress,
    IN  UINT         NewLength
	)
{
    PXNDIS_BUFFER Buffer = (PXNDIS_BUFFER) Mdl;

    Buffer->VirtualAddress = NewVirtualAddress;
    Buffer->Length         = NewLength;
}
#else // MILLEN
__inline VOID
NdisAdjustBuffer(
    IN  PNDIS_BUFFER Buffer,
    IN  PVOID        NewVirtualAddress,
    IN  UINT         NewLength
	)
{
    PMDL Mdl = (PMDL) Buffer;

    Mdl->MappedSystemVa = NewVirtualAddress;
    Mdl->ByteCount      = NewLength;
    Mdl->ByteOffset     = BYTE_OFFSET(NewVirtualAddress);
}
#endif // !MILLEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\inc\tcpsend.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

//** TCPSEND.H - TCP send protocol definitions.
//
// This file contains the definitions of TCP send protocol things.
//
#pragma once

#define NUM_TCP_BUFFERS     150

#ifdef SEND_DEBUG
#define SEND_TICKS          10
EXTERNAL_LOCK(SendUseLock)
extern struct TCPSendReq    *SendUseList;
#endif

//* Structure of a TCP send request.

#define tsr_signature       0x20525354  // 'TSR '

typedef struct TCPSendReq {
    struct  TCPReq  tsr_req;            // General request structure.
#if DBG
    ulong           tsr_sig;
#endif
    uint            tsr_size;           // Size in bytes of data in send.
    long            tsr_refcnt;         // Reference count for this send.
    ulong           tsr_flags;          // Flags for this send.
    uint            tsr_unasize;        // Number of bytes unacked.
    uint            tsr_offset;         // Offset into first buffer in chain
                                        // of start of unacked data.
    PNDIS_BUFFER    tsr_buffer;         // Pointer to start of unacked buffer
                                        // chain.
    PNDIS_BUFFER    tsr_lastbuf;        // Pointer to last buffer in chain.
                                        // Valid iff we've sent directly from
                                        // the buffer chain w/o doing an
                                        // NdisCopyBuffer.
    uint            tsr_time;           // TCP time this was received.
#ifdef SEND_DEBUG
    struct TCPSendReq *tsr_next;        // Debug next field.
    uint            tsr_timer;          // Timer field.
    uint            tsr_cmplt;          // Who completed it.
#endif
} TCPSendReq;

#define TSR_FLAG_URG            0x01    // Urgent data.
#define TSR_FLAG_SEND_AND_DISC  0x02    // Send and disconnect


//* Structure defining the context received during a send completes.

#define scc_signature   0x20434353      // 'SCC '

typedef struct SendCmpltContext {
#if DBG
    ulong           scc_sig;
#endif
    ulong           scc_SendSize;
    ulong           scc_ByteSent;
    TCB             *scc_LargeSend;
    TCPSendReq      *scc_firstsend;     // First send in this context.
    uint            scc_count;          // Number of sends in count.
    ushort          scc_ubufcount;      // Number of 'user' buffers in send.
    ushort          scc_tbufcount;      // Number of transport buffers in send.
} SendCmpltContext;

extern void InitSendState(struct TCB *NewTCB);
extern void SendSYN(struct TCB *SYNTcb, CTELockHandle);
extern void SendKA(struct TCB *KATCB, CTELockHandle Handle);
extern void SendRSTFromHeader(struct TCPHeader UNALIGNED *TCPH, uint Length,
                              IPAddr Dest, IPAddr Src, IPOptInfo *OptInfo);
extern void SendACK(struct TCB *ACKTcb);
extern void SendRSTFromTCB(struct TCB *RSTTcb, RouteCacheEntry* RCE);
extern void GoToEstab(struct TCB *EstabTCB);
extern void FreeSendReq(TCPSendReq *FreedReq);
extern void FreeTCPHeader(PNDIS_BUFFER FreedBuffer);

extern int  InitTCPSend(void);
extern void UnInitTCPSend(void);

extern void TCPSend(struct TCB *SendTCB, CTELockHandle Handle);
extern TDI_STATUS TdiSend(PTDI_REQUEST Request, ushort Flags, uint SendLength,
                          PNDIS_BUFFER SendBuffer);
extern uint RcvWin(struct TCB *WinTCB);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\kdext\kdexts.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:


Environment:

    User Mode

--*/

#include "precomp.h"
#pragma hdrstop

#include <ntsdexts.h>
//#define NOEXTAPI
#include <wdbgexts.h>
#include <ntverp.h>
//#include <stdexts.h>

//
// globals
//
EXT_API_VERSION        ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
ULONG                  STeip;
ULONG                  STebp;
ULONG                  STesp;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
USHORT                 usProcessorArchitecture;
BOOL                   bDebuggingChecked;

PSZ szProcessorArchitecture[] = {
    "Intel",
    "MIPS",
    "Alpha",
    "PPC"
};
#define cArchitecture (sizeof(szProcessorArchitecture) / sizeof(PSZ))

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ULONG offKeProcessorArchitecture;
    ULONG Result;

    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    bDebuggingChecked = (SavedMajorVersion == 0x0c);
    usProcessorArchitecture = (USHORT)-1;

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\kdext\exts.h ===
/************************************************************************\
*
* MODULE: exts.h
*
* DESCRIPTION: macro driving file for use with stdexts.h and stdexts.c.
*
* Copyright (c) 6/9/1995, Microsoft Corporation
*
* 6/9/1995 SanfordS Created
*
\************************************************************************/

DOIT(   help
        ,"help -v [cmd]                 - Displays this list or gives details on command\n"
        ,"  help      - To dump short help text on all commands.\n"
         "  help -v   - To dump long help text on all commands.\n"
         "  help cmd  - To dump long help on given command.\n"
        ,"v"
        ,CUSTOM)

DOIT(   global
        ,"global - Dumps IPSEC global.\n"
        ,""
        ,""
        ,CUSTOM)

DOIT(   mfl
        ,"mfl - Dumps all masked filters.\n"
        ,""
        ,""
        ,CUSTOM)

DOIT(   tfl
        ,"tfl - Dumps all tunnel filters.\n"
        ,""
        ,""
        ,CUSTOM)

DOIT(   sas
        ,"sas - Dumps all security associations.\n"
        ,""
        ,""
        ,CUSTOM)

DOIT(   tsas
        ,"tsas - Dumps all tunnel security associations.\n"
        ,""
        ,""
        ,CUSTOM)


DOIT(   larvalsas
        ,"larvalsas - Dumps all larval security associations.\n"
        ,""
        ,""
        ,CUSTOM)

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\inc\tdint.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    tdint.h

Abstract:

    This file defines TDI types specific to the NT environment.

Author:

    Mike Massa (mikemas)    August 13, 1993

Revision History:

--*/

#ifndef _TDINT_
#define _TDINT_

#include <tdikrnl.h>

typedef PTDI_IND_DISCONNECT      PDisconnectEvent;
typedef PTDI_IND_ERROR           PErrorEvent;
typedef PTDI_IND_ERROR_EX        PErrorEx;
typedef PTDI_IND_CHAINED_RECEIVE PChainedRcvEvent;

#if MILLEN

typedef struct _EventRcvBuffer {
    PNDIS_BUFFER   erb_buffer;
    uint           erb_size;
    CTEReqCmpltRtn erb_rtn;
    PVOID          erb_context;
    ushort        *erb_flags;
} EventRcvBuffer;

typedef struct _ConnectEventInfo {
    CTEReqCmpltRtn              cei_rtn;
    PVOID                       cei_context;
    PTDI_CONNECTION_INFORMATION cei_acceptinfo;
    PTDI_CONNECTION_INFORMATION cei_conninfo;
} ConnectEventInfo;

typedef TDI_STATUS  (*PRcvEvent)(PVOID EventContext, PVOID ConnectionContext,
                        ulong Flags, uint Indicated, uint Available,
                        uint *Taken, uchar *Data, EventRcvBuffer *Buffer);

typedef TDI_STATUS  (*PRcvDGEvent)(PVOID EventContext, uint AddressLength,
                        PTRANSPORT_ADDRESS Address, uint OptionsLength, PVOID
                        Options,  uint Flags, uint Indicated, uint Available,
                        uint *Taken, uchar *Data, EventRcvBuffer **Buffer);

typedef TDI_STATUS  (*PRcvExpEvent)(PVOID EventContext, PVOID ConnectionContext,
                        ulong Flags, uint Indicated, uint Available,
                        uint *Taken, uchar *Data, EventRcvBuffer *Buffer);

typedef TDI_STATUS  (*PConnectEvent)(PVOID EventContext, uint AddressLength,
                        PTRANSPORT_ADDRESS Address, uint UserDataLength,
                        PVOID UserData, uint OptionsLength, PVOID
                        Options,  PVOID *AcceptingID,
                        ConnectEventInfo *EventInfo);

#else // MILLEN
typedef IRP EventRcvBuffer;
typedef IRP ConnectEventInfo;

typedef PTDI_IND_CONNECT           PConnectEvent;
typedef PTDI_IND_RECEIVE           PRcvEvent;
typedef PTDI_IND_RECEIVE_DATAGRAM  PRcvDGEvent;
typedef PTDI_IND_RECEIVE_EXPEDITED PRcvExpEvent;
#endif // !MILLEN



#endif  // ifndef _TDINT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\kdext\ipsec.c ===
#include "precomp.h"
#pragma hdrstop

#include <wdbgexts.h>
#include "rtkmext.h"
#include "kdmacros.h"

INT                    Item;

HANDLE _hInstance;
HANDLE _hAdditionalReference;
HANDLE _hProcessHeap;

int _Indent = 0;
char IndentBuf[ 80 ]={"\0                                                                      "};

BOOL
dprint_enum_name
(
    ULONG Value,
    PENUM_INFO pEnumInfo
)
{
    while ( pEnumInfo->pszDescription != NULL )
    {
        if ( pEnumInfo->Value == Value )
        {
            dprintf( "%.40s", pEnumInfo->pszDescription );
            return( TRUE );
        }
        pEnumInfo ++;
    }

    dprintf( "Unknown enumeration value." );
    return( FALSE );
}

BOOL
dprint_flag_names
(
    ULONG Value,
    PFLAG_INFO pFlagInfo
)
{
    BOOL bFoundOne = FALSE;

    while ( pFlagInfo->pszDescription != NULL )
    {
        if ( pFlagInfo->Value & Value )
        {
            if ( bFoundOne )
            {
                dprintf( " | " );
            }
            bFoundOne = TRUE;

            dprintf( "%.15s", pFlagInfo->pszDescription );
        }
        pFlagInfo ++;
    }

    return( bFoundOne );
}

VOID
dprint_IP_address
(
    IPAddr Address
)
{
    uchar    IPAddrBuffer[(sizeof(IPAddr) * 4)];
    uint     i;
    uint     IPAddrCharCount;

    //
    // Convert the IP address into a string.
    //
    IPAddrCharCount = 0;

    for (i = 0; i < sizeof(IPAddr); i++) {
        uint    CurrentByte;

        CurrentByte = Address & 0xff;
        if (CurrentByte > 99) {
            IPAddrBuffer[IPAddrCharCount++] = (CurrentByte / 100) + '0';
            CurrentByte %= 100;
            IPAddrBuffer[IPAddrCharCount++] = (CurrentByte / 10) + '0';
            CurrentByte %= 10;
        } else if (CurrentByte > 9) {
            IPAddrBuffer[IPAddrCharCount++] = (CurrentByte / 10) + '0';
            CurrentByte %= 10;
        }

        IPAddrBuffer[IPAddrCharCount++] = CurrentByte + '0';
        if (i != (sizeof(IPAddr) - 1))
            IPAddrBuffer[IPAddrCharCount++] = '.';

        Address >>= 8;
    }
    IPAddrBuffer[IPAddrCharCount] = '\0';

    dprintf( "%s", IPAddrBuffer );
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        IpsecGlobal
#define _objAddr    pIpsecGlobal
#define _objType    IPSEC_GLOBAL

VOID
Iglobal(DWORD   opts, LPSTR args)
{
    ULONG  deviceToDump = 0;
    ULONG  pDevice = 0;
    ULONG  result;
    UCHAR  cmdline[MAX_PATH]="0";
    UCHAR  arg[MAX_PATH]="0";

    IPSEC_GLOBAL    IpsecGlobal;
    PIPSEC_GLOBAL   pIpsecGlobal;

    pDevice    =   GetExpression( "ipsec!g_ipsec" );

    if ( !pDevice ) {
        dprintf("Could not get g_ipsec, Try !reload\n");
        return;
    } else {
        if ( !ReadMemory( pDevice,
                          &IpsecGlobal,
                          sizeof(IPSEC_GLOBAL),
                          &result )) {
            dprintf("%08lx: Could not read device context\n", pDevice);
            return;
        }
    }

    pIpsecGlobal = &IpsecGlobal;

    PrintBool(DriverUnloading);
    PrintBool(BoundToIP);
    PrintBool(SendBoundToIP);

    PrintULong(NumSends);
    PrintULong(NumThreads);
    PrintULong(NumWorkers);
    PrintULong(NumTimers);

    PrintLL(LarvalSAList);
    PrintLock(LarvalListLock);

    PrintLock(SADBLock.SpinLock);
    PrintULong(SADBLock.RefCount);
    PrintLock(SPIListLock.SpinLock);
    PrintULong(SPIListLock.RefCount);

    PrintLL(FilterList[INBOUND_TRANSPORT_FILTER]);
    PrintLL(FilterList[OUTBOUND_TRANSPORT_FILTER]);
    PrintLL(FilterList[INBOUND_TUNNEL_FILTER]);
    PrintLL(FilterList[OUTBOUND_TUNNEL_FILTER]);

    PrintULong(NumPolicies);
    PrintULong(NumTunnelFilters);
    PrintULong(NumMaskedFilters);
    PrintULong(NumOutboundSAs);
    PrintULong(NumMulticastFilters);

    PrintPtr(pSADb);
    PrintULong(NumSA);
    PrintULong(SAHashSize);

    PrintPtr(ppCache);
    PrintULong(CacheSize);

    PrintPtr(IPSecDevice);
    PrintPtr(IPSecDriverObject);

    PrintULong(EnableOffload);
    PrintULong(DefaultSAIdleTime);
    PrintULong(LogInterval);
    PrintULong(EventQueueSize);
    PrintULong(NoDefaultExempt);

    PrintULong(IPSecBufferedEvents);

    PrintPtr(IPSecLogMemory);
    PrintPtr(IPSecLogMemoryLoc);
    PrintPtr(IPSecLogMemoryEnd);

    PrintULong(OperationMode);
    return;
}

FLAG_INFO   FlagsFilter[] =
{
    {   FILTER_FLAGS_PASS_THRU      , "Pass Thru'"     },
    {   FILTER_FLAGS_DROP           , "Drop"      },
    {   0, NULL }
};

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        Filter
#define _objAddr    pFilter
#define _objType    FILTER

VOID
DumpFilter(PFILTER  pFilter, FILTER  Filter)
{
    ULARGE_INTEGER   uliSrcDstAddr;
    ULARGE_INTEGER   uliSrcDstMask;
    ULARGE_INTEGER   uliProtoSrcDstPort;

    uliSrcDstAddr = Filter.uliSrcDstAddr;
    uliSrcDstMask = Filter.uliSrcDstMask;
    uliProtoSrcDstPort = Filter.uliProtoSrcDstPort;

    dprintf("\n--------------------------- FILTER: %lx -------------------------------\n", pFilter);

    PrintLL(MaskedLinkage);
    PrintXULong(Signature);

    PrintFlags(Flags, FlagsFilter);

    PrintFieldName("SrcAddr");
    dprint_IP_address( SRC_ADDR );
    PrintNL();

    PrintFieldName("SrcMask");
    dprint_IP_address( SRC_MASK );
    PrintNL();

    PrintFieldName("DestAddr");
    dprint_IP_address( DEST_ADDR );
    PrintNL();

    PrintFieldName("DestMask");
    dprint_IP_address( DEST_MASK );
    PrintNL();

    PrintUShort(PROTO);

    PrintFieldName("SrcPort");
    dprintf("%-10hu%s", SRC_PORT, EOL);

    PrintFieldName("DestPort");
    dprintf("%-10hu%s", DEST_PORT, EOL);

    PrintIPAddress(TunnelAddr);

    PrintULong(SAChainSize);

    PrintULong(Index);
    PrintGUID(PolicyId);
    PrintGUID(FilterId);
}


VOID
Imfl(DWORD   opts, LPSTR args)
{
    ULONG  deviceToDump = 0;
    ULONG  result;
    UCHAR  cmdline[MAX_PATH]="0";
    UCHAR  arg[MAX_PATH]="0";
    ULONG  pDevice=0;

    IPSEC_GLOBAL    g_ipsec;
    PFILTER         pFilter;
    FILTER          Filter;
    PLIST_ENTRY     pEntry;
    LONG            Index;

    pDevice    =   GetExpression( "ipsec!g_ipsec" );

    if ( !pDevice ) {
        dprintf("Could not get g_ipsec, Try !reload\n");
        return;
    } else {
        if ( !ReadMemory( pDevice,
                          &g_ipsec,
                          sizeof(IPSEC_GLOBAL),
                          &result )) {
            dprintf("%08lx: Could not read device context\n", pDevice);
            return;
        }
    }

    for (Index = MIN_TRANSPORT_FILTER; Index <= MAX_TRANSPORT_FILTER; Index++) {
        pEntry = g_ipsec.FilterList[Index].Flink;
        while (pEntry != (PLIST_ENTRY)(pDevice + FIELD_OFFSET(IPSEC_GLOBAL, FilterList[Index]))) {
            pFilter = CONTAINING_RECORD(pEntry,
                                        FILTER,
                                        MaskedLinkage);

            if ( !ReadMemory( (ULONG)pFilter,
                            &Filter,
                            sizeof(Filter),
                            &result )) {
                dprintf("%08lx: Could not read device context\n", pDevice);
                return;
            }

            DumpFilter(pFilter, Filter);

            pEntry = Filter.MaskedLinkage.Flink;
        }
    }

    return;
}

VOID
Itfl(DWORD   opts, LPSTR args)
{
    ULONG  deviceToDump = 0;
    ULONG  result;
    UCHAR  cmdline[MAX_PATH]="0";
    UCHAR  arg[MAX_PATH]="0";
    ULONG  pDevice=0;

    IPSEC_GLOBAL    g_ipsec;
    PFILTER         pFilter;
    FILTER          Filter;
    PLIST_ENTRY     pEntry;
    LONG            Index;

    pDevice    =   GetExpression( "ipsec!g_ipsec" );

    if ( !pDevice ) {
        dprintf("Could not get g_ipsec, Try !reload\n");
        return;
    } else {

        if ( !ReadMemory( pDevice,
                          &g_ipsec,
                          sizeof(IPSEC_GLOBAL),
                          &result )) {
            dprintf("%08lx: Could not read device context\n", pDevice);
            return;
        }
    }

    for (Index = MIN_TUNNEL_FILTER; Index <= MAX_TUNNEL_FILTER; Index++) {
        pEntry = g_ipsec.FilterList[Index].Flink;
        while (pEntry != (PLIST_ENTRY)(pDevice + FIELD_OFFSET(IPSEC_GLOBAL, FilterList[Index]))) {
            pFilter = CONTAINING_RECORD(pEntry,
                                        FILTER,
                                        MaskedLinkage);

            if ( !ReadMemory( (ULONG)pFilter,
                            &Filter,
                            sizeof(Filter),
                            &result )) {
                dprintf("%08lx: Could not read device context\n", pDevice);
                return;
            }

            DumpFilter(pFilter, Filter);

            pEntry = Filter.MaskedLinkage.Flink;
        }
    }

    return;
}

FLAG_INFO   FlagsSA[] =
{
    {   FLAGS_SA_INITIATOR      ,   "Initiator"         },
    {   FLAGS_SA_OUTBOUND       ,   "Outbound"          },
    {   FLAGS_SA_TUNNEL         ,   "Tunnel"            },
    {   FLAGS_SA_REPLAY         ,   "Replay"            },
    {   FLAGS_SA_REKEY          ,   "Rekey"             },
    {   FLAGS_SA_MANUAL         ,   "Manual"            },
    {   FLAGS_SA_MTU_BUMPED     ,   "MTU_Bumped"        },
    {   FLAGS_SA_PENDING        ,   "Pending"           },
    {   FLAGS_SA_TIMER_STARTED  ,   "Timer_Started"     },
    {   FLAGS_SA_HW_PLUMBED     ,   "HW_Plumbed"        },
    {   FLAGS_SA_HW_PLUMB_FAILED,   "HW_Plumb_failed"   },
    {   FLAGS_SA_HW_CRYPTO_ONLY ,   "HW_Crpto_only"     },
    {   FLAGS_SA_REFERENCED     ,   "SA_referenced"     },
    { 0, NULL }
};

ENUM_INFO   StateSA[] =
{
    {   STATE_SA_CREATED,   "Created"   },
    {   STATE_SA_LARVAL,    "Larval"    },
    {   STATE_SA_ASSOCIATED,"Associated"},
    {   STATE_SA_ACTIVE,    "Active"    },
    {   STATE_SA_ZOMBIE,    "Zombie"    },
    { 0, NULL }
};

ENUM_INFO   OperationSA[] =
{
    {   None,   "None"   },
    {   Auth,   "Auth"   },
    {   Encrypt,"Encrypt"},
    {   Compress,"Compress"},
    { 0, NULL }
};

ENUM_INFO   AHAlgo[] =
{
    {   IPSEC_AH_NONE, "IPSEC_AH_NONE"},
    {   IPSEC_AH_MD5, "IPSEC_AH_MD5"},
    {   IPSEC_AH_SHA, "IPSEC_AH_SHA"},
    {   IPSEC_AH_MAX, "IPSEC_AH_MAX"},
    { 0, NULL }
};

ENUM_INFO   ESPAlgo[] =
{
    {   IPSEC_ESP_NONE,  "IPSEC_ESP_NONE"},
    {   IPSEC_ESP_DES,  "IPSEC_ESP_DES"},
    {   IPSEC_ESP_DES_40,  "IPSEC_ESP_DES_40"},
    {   IPSEC_ESP_3_DES,  "IPSEC_ESP_3_DES"},
    {   IPSEC_ESP_MAX,  "IPSEC_ESP_MAX"},
    { 0, NULL }
};

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        SA
#define _objAddr    pSA
#define _objType    SA_TABLE_ENTRY

VOID
DumpSA(PSA_TABLE_ENTRY  pSA, SA_TABLE_ENTRY  SA)
{
    ULARGE_INTEGER   uliSrcDstAddr;
    ULARGE_INTEGER   uliSrcDstMask;
    ULARGE_INTEGER   uliProtoSrcDstPort;
    LONG   i;

    uliSrcDstAddr = SA.sa_uliSrcDstAddr;
    uliProtoSrcDstPort = SA.sa_uliProtoSrcDstPort;

    dprintf("\n---------------------- Security Association: %lx -----------------------\n", pSA);

    PrintLL(sa_SPILinkage);
    PrintLL(sa_FilterLinkage);
    PrintLL(sa_LarvalLinkage);
    PrintLL(sa_PendingLinkage);

    PrintXULong(sa_AssociatedSA);
    PrintXULong(sa_RekeyLarvalSA);
    PrintXULong(sa_RekeyOriginalSA);

    PrintXULong(sa_Filter);

    PrintXULong(sa_Signature);
    PrintULong(sa_Reference);

    PrintFlags(sa_Flags, FlagsSA);
    PrintEnum(sa_State, StateSA);

    PrintFieldName("SrcAddr");
    dprint_IP_address( SRC_ADDR );
    PrintNL();

    PrintFieldName("DestAddr");
    dprint_IP_address( DEST_ADDR );
    PrintNL();

    PrintUShort(SA_PROTO);

    PrintFieldName("SrcPort");
    dprintf("%-10hu%s", SA_SRC_PORT(&SA), EOL);

    PrintFieldName("DestPort");
    dprintf("%-10hu%s", SA_DEST_PORT(&SA), EOL);

    PrintIPAddress(sa_TunnelAddr);

    PrintXULong(sa_SPI);

    PrintULong(sa_NumOps);

    for (i=0; i<SA.sa_NumOps; i++) {
        PrintXULong(sa_OtherSPIs[i]);
        switch (SA.sa_Operation[i]) {
        case None:
            break;
        case Auth:
            PrintEnum(sa_Algorithm[i].integrityAlgo.algoIdentifier, AHAlgo);
            PrintFieldName("algoKey");
            dprintf("%lx %lx", SA.sa_Algorithm[i].integrityAlgo.algoKey, EOL);
            PrintNL();

            PrintULong(sa_Algorithm[i].integrityAlgo.algoKeylen);

            break;
        case Encrypt:
            PrintEnum(sa_Algorithm[i].integrityAlgo.algoIdentifier, AHAlgo);
            PrintFieldName("algoKey");
            dprintf("%lx %lx", SA.sa_Algorithm[i].integrityAlgo.algoKey, EOL);
            PrintNL();

            PrintULong(sa_Algorithm[i].integrityAlgo.algoKeylen);

            PrintEnum(sa_Algorithm[i].confAlgo.algoIdentifier, ESPAlgo);
            PrintFieldName("algoKey");
            dprintf("%lx %lx", SA.sa_Algorithm[i].confAlgo.algoKey, EOL);
            PrintNL();

            PrintULong(sa_Algorithm[i].confAlgo.algoKeylen);

            break;
        }
    }

    PrintULong(sa_TruncatedLen);
    PrintULong(sa_ReplayStartPoint);
    PrintULong(sa_ReplayLastSeq);
    PrintULong(sa_ReplayBitmap);
    PrintULong(sa_ReplaySendSeq);
    PrintULong(sa_ReplayLen);

    PrintULong(sa_BlockedDataLen);
    PrintXULong(sa_BlockedBuffer);
    PrintULong(sa_ExpiryTime);
}

VOID
Isas(DWORD   opts, LPSTR args)
{
    ULONG  deviceToDump = 0;
    ULONG  result;
    UCHAR  cmdline[MAX_PATH]="0";
    UCHAR  arg[MAX_PATH]="0";
    ULONG  pDevice=0;

    IPSEC_GLOBAL    g_ipsec;
    PFILTER         pFilter;
    FILTER          Filter;
    PLIST_ENTRY     pEntry;
    PLIST_ENTRY     pEntry1;
    PSA_TABLE_ENTRY pSA;
    SA_TABLE_ENTRY  SA;
    SA_TABLE_ENTRY  NextSA;
    LONG            Index, SAIndex;
    LIST_ENTRY      SAChain[256 * sizeof(LIST_ENTRY)];          

    pDevice    =   GetExpression( "ipsec!g_ipsec" );

    if ( !pDevice ) {
        dprintf("Could not get g_ipsec, Try !reload\n");
        return;
    } else {

        if ( !ReadMemory( pDevice,
                          &g_ipsec,
                          sizeof(IPSEC_GLOBAL),
                          &result )) {
            dprintf("%08lx: Could not read device context\n", pDevice);
            return;
        }
    }

    for (Index = MIN_TRANSPORT_FILTER; Index <= MAX_TRANSPORT_FILTER; Index++) {
        pEntry = g_ipsec.FilterList[Index].Flink;
        while (pEntry != (PLIST_ENTRY)(pDevice + FIELD_OFFSET(IPSEC_GLOBAL, FilterList[Index]))) {
            pFilter = CONTAINING_RECORD(pEntry,
                                        FILTER,
                                        MaskedLinkage);

            if ( !ReadMemory(   (ULONG)pFilter,
                            &Filter,
                            sizeof(Filter),
                            &result )) {
                dprintf("%08lx: Could not read filter context\n", pFilter);
                return;
            }

            if ( !ReadMemory(   (ULONG)pFilter + FIELD_OFFSET(FILTER, SAChain[0]),
                            SAChain,
                            Filter.SAChainSize * sizeof(LIST_ENTRY),
                            &result )) {
                dprintf("%08lx: Could not read SAChain context\n", pFilter + FIELD_OFFSET(FILTER, SAChain[0]));
                return;
            }

            DumpFilter(pFilter, Filter);

            for (SAIndex = 0; SAIndex < Filter.SAChainSize; SAIndex++) {
                pEntry1 = SAChain[SAIndex].Flink;

                while (pEntry1 != (PLIST_ENTRY)((PUCHAR)pFilter + FIELD_OFFSET(FILTER, SAChain[SAIndex]))) {
                    pSA = CONTAINING_RECORD(pEntry1,
                                            SA_TABLE_ENTRY,
                                            sa_FilterLinkage);

                    if ( !ReadMemory( (ULONG)pSA,
                                    &SA,
                                    sizeof(SA),
                                    &result )) {
                        dprintf("%08lx: Could not read SA context\n", pSA);
                        return;
                    }

                    DumpSA(pSA, SA);

                    pEntry1 = SA.sa_FilterLinkage.Flink;
                }
            }

            pEntry = Filter.MaskedLinkage.Flink;
        }
    }

    return;
}

VOID
Itsas(DWORD   opts, LPSTR args)
{
    ULONG  deviceToDump = 0;
    ULONG  result;
    UCHAR  cmdline[MAX_PATH]="0";
    UCHAR  arg[MAX_PATH]="0";
    ULONG  pDevice=0;

    IPSEC_GLOBAL    g_ipsec;
    PFILTER         pFilter;
    FILTER          Filter;
    PLIST_ENTRY     pEntry;
    PLIST_ENTRY     pEntry1;
    PSA_TABLE_ENTRY pSA;
    SA_TABLE_ENTRY  SA;
    SA_TABLE_ENTRY  NextSA;
    LONG            Index, SAIndex;
    LIST_ENTRY      SAChain[256 * sizeof(LIST_ENTRY)];          

    pDevice    =   GetExpression( "ipsec!g_ipsec" );

    if ( !pDevice ) {
        dprintf("Could not get g_ipsec, Try !reload\n");
        return;
    } else {

        if ( !ReadMemory( pDevice,
                          &g_ipsec,
                          sizeof(IPSEC_GLOBAL),
                          &result )) {
            dprintf("%08lx: Could not read device context\n", pDevice);
            return;
        }
    }

    for (Index = MIN_TUNNEL_FILTER; Index <= MAX_TUNNEL_FILTER; Index++) {
        pEntry = g_ipsec.FilterList[Index].Flink;
        while (pEntry != (PLIST_ENTRY)(pDevice + FIELD_OFFSET(IPSEC_GLOBAL, FilterList[Index]))) {
            pFilter = CONTAINING_RECORD(pEntry,
                                        FILTER,
                                        MaskedLinkage);

            if ( !ReadMemory(   (ULONG)pFilter,
                            &Filter,
                            sizeof(Filter),
                            &result )) {
                dprintf("%08lx: Could not read filter context\n", pFilter);
                return;
            }

            if ( !ReadMemory(   (ULONG)pFilter + FIELD_OFFSET(FILTER, SAChain[0]),
                            SAChain,
                            Filter.SAChainSize * sizeof(LIST_ENTRY),
                            &result )) {
                dprintf("%08lx: Could not read SAChain context\n", pFilter + FIELD_OFFSET(FILTER, SAChain[0]));
                return;
            }

            DumpFilter(pFilter, Filter);

            for (SAIndex = 0; SAIndex < Filter.SAChainSize; SAIndex++) {
                pEntry1 = SAChain[SAIndex].Flink;

                while (pEntry1 != (PLIST_ENTRY)((PUCHAR)pFilter + FIELD_OFFSET(FILTER, SAChain[SAIndex]))) {
                    pSA = CONTAINING_RECORD(pEntry1,
                                            SA_TABLE_ENTRY,
                                            sa_FilterLinkage);

                    if ( !ReadMemory( (ULONG)pSA,
                                    &SA,
                                    sizeof(SA),
                                    &result )) {
                        dprintf("%08lx: Could not read SA context\n", pSA);
                        return;
                    }

                    DumpSA(pSA, SA);

                    pEntry1 = SA.sa_FilterLinkage.Flink;
                }
            }

            pEntry = Filter.MaskedLinkage.Flink;
        }
    }

    return;
}


VOID
Ilarvalsas(DWORD   opts, LPSTR args)
{
    ULONG  deviceToDump = 0;
    ULONG  result;
    UCHAR  cmdline[MAX_PATH]="0";
    UCHAR  arg[MAX_PATH]="0";
    ULONG  pDevice=0;

    IPSEC_GLOBAL    g_ipsec;
    PFILTER         pFilter;
    FILTER          Filter;
    PLIST_ENTRY     pEntry;
    PLIST_ENTRY     pEntry1;
    PSA_TABLE_ENTRY pSA;
    SA_TABLE_ENTRY  SA;
    SA_TABLE_ENTRY  NextSA;

    pDevice    =   GetExpression( "ipsec!g_ipsec" );

    if ( !pDevice ) {
        dprintf("Could not get g_ipsec, Try !reload\n");
        return;
    } else {

        if ( !ReadMemory( pDevice,
                          &g_ipsec,
                          sizeof(IPSEC_GLOBAL),
                          &result )) {
            dprintf("%08lx: Could not read device context\n", pDevice);
            return;
        }
    }

    pEntry = g_ipsec.LarvalSAList.Flink;
    while (pEntry != (PLIST_ENTRY)(pDevice + FIELD_OFFSET(IPSEC_GLOBAL, LarvalSAList))) {
        pSA = CONTAINING_RECORD(pEntry,
                                SA_TABLE_ENTRY,
                                sa_LarvalLinkage);

        if ( !ReadMemory( (ULONG)pSA,
                          &SA,
                          sizeof(SA),
                          &result )) {
            dprintf("%08lx: Could not read device context\n", pDevice);
            return;
        }

        DumpSA(pSA, SA);

        pEntry = SA.sa_LarvalLinkage.Flink;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\kdext\kdmacros.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdmacros.h

Abstract:

    This file is a common header file for tcpext.dll

Author:

    John Ballard (jballard)

Environment:

    User Mode

--*/

#define ITEMSIZE    25

typedef struct
{
    ULONG Value;
    PCHAR pszDescription;
} ENUM_INFO, *PENUM_INFO, FLAG_INFO, *PFLAG_INFO;

#define EnumString( Value ) { Value, #Value }

extern ENUM_INFO EnumStructureType[];

//#define EOL ( (Item++ & 1) ? "\n":"" )
typedef enum
{
    VERBOSITY_ONE_LINER = 0,
    VERBOSITY_NORMAL,
    VERBOSITY_FULL
} VERBOSITY;

#define PrintStart Item = 0;

extern int _Indent;
extern char IndentBuf[ 80 ];

#define IndentChange( cch ) { IndentBuf[_Indent]=' '; _Indent += ( cch ); IndentBuf[_Indent]='\0';}
#define Indent( cch ) IndentChange( cch )
#define Outdent( cch ) IndentChange( -( cch ) )

#define PrintStartStruct()  { PrintStart; dprintf( "%s{\n", IndentBuf ); Indent( 2 );  }

#define PrintStartNamedStruct( _name )  { PrintStart; dprintf( "%s%s {\n", IndentBuf, _name ); Indent( 2 );  }

static PCHAR pchEol = "\n";
static PCHAR pchBlank = "";
static PCHAR * ppchCurrentEol = &pchEol;
static PCHAR * ppchTempEol = &pchEol;

#define PrintJoin() { ppchCurrentEol = &pchBlank; }

#define EOL (( ppchTempEol = ppchCurrentEol ), ( ppchCurrentEol = &pchEol ), ( *ppchTempEol ))

VOID
dprintSymbolPtr
(
    PVOID Pointer,
    PCHAR EndOfLine
);

VOID
dprint_nchar
(
    PCHAR pch,
    int cch
);

VOID
dprint_hardware_address
(
    PUCHAR Address
);

BOOL
dprint_enum_name
(
    ULONG Value,
    PENUM_INFO pEnumInfo
);


BOOL
dprint_flag_names
(
    ULONG Value,
    PFLAG_INFO pFlagInfo
);

BOOL
dprint_masked_value
(
    ULONG Value,
    ULONG Mask
);

VOID
dprint_addr_list(
    ULONG FirstAddress,
    ULONG OffsetToNextPtr
);

VOID
dprint_IP_address
(
    IPAddr Address
);

ULONG
GetUlongValue (
    PCHAR String
);

/*
#define PrintEnd   \
        dprintf( "%s", EOL ); \
        Item = 0;
*/

#define PrintEnd   \
        Item = 0;

#define PrintNL()   dprintf("\n");

#define PrintEndStruct()  { Outdent( 2 ); PrintEnd; dprintf( "%s}\n", IndentBuf ); }

#define PrintFlushLeft() PrintEnd

#define PRINTBOOL(var)  ( (var) ? "True" : "False")

#define PrintFieldName(_fieldName) \
        if ( strlen(_fieldName) > 35 ) {                                                \
            dprintf("%s%-.25s..%s = ",IndentBuf,_fieldName, &(_fieldName[strlen(_fieldName)-8]));   \
        }else {                                                                         \
            dprintf("%s%-35.35s = ",IndentBuf,_fieldName );                                        \
        }

#define PrintFieldNameAt(_fieldName) \
        if ( strlen(_fieldName) > 35 ) {                                                \
            dprintf("%s%-.25s..%s @ ",IndentBuf,_fieldName, &(_fieldName[strlen(_fieldName)-8]));   \
        }else {                                                                         \
            dprintf("%s%-35.35s @ ",IndentBuf,_fieldName );                                        \
        }

#define PrintListTcpFieldName(_fieldName) \
        if ( strlen(_fieldName) > 40 ) {                                                \
            dprintf("%s%-.30s...%s q_next = ",IndentBuf,_fieldName, &(_fieldName[strlen(_fieldName)-7]));   \
        }else {                                                                        \
            dprintf("%s%-40.40s q_next = ",IndentBuf,_fieldName );                                        \
        }

#define PrintListFieldName(_fieldName) \
        if ( strlen(_fieldName) > 40 ) {                                                \
            dprintf("%s%-.30s...%s FLink = ",IndentBuf,_fieldName, &(_fieldName[strlen(_fieldName)-7]));   \
        }else {                                                                        \
            dprintf("%s%-40.40s FLink = ",IndentBuf,_fieldName );                                        \
        }

#define PrintIndent()   dprintf( "%s", IndentBuf );
/* #define PrintFieldName(_fieldName) \
        dprintf(" %-25.25s = ",_fieldName );*/

#define PrintRawBool( _bValue ) \
            dprintf("%-10s%s", (_obj._bValue) ? "True" : "False", EOL)

#define PrintBool(_field) \
            PrintFieldName(#_field)  \
            dprintf("%-10s%s", (_obj._field) ? "True" : "False", EOL)

#define PrintULong(_field) \
            PrintFieldName(#_field)  \
            dprintf("%-10lu%s", _obj._field, EOL)

#define PrintXULong(_field)     \
            PrintFieldName(#_field)  \
            dprintf("0x%08lx%s", _obj._field, EOL)

#define PrintUShort(_field) \
            PrintFieldName(#_field)  \
            dprintf("%-10hu%s", _obj._field, EOL)

#define PrintHTONUShort(_field) \
            PrintFieldName(#_field)  \
            dprintf("%-10hu%s", htons(_obj._field), EOL)

#define PrintXUShort(_field)     \
            PrintFieldName(#_field)  \
            dprintf("0x%04hx%s", _obj._field, EOL)

#define PrintNChar( _field, count )        \
            PrintFieldName(#_field)  \
            dprint_nchar( ( PCHAR )_obj._field, count ); \
            dprintf("%s", EOL)

#define PrintUChar(_field)        \
            PrintFieldName(#_field)  \
            dprintf("%-10lu%s", (ULONG) _obj._field, EOL)

#define PrintXUChar(_field)        \
            PrintFieldName(#_field)  \
            dprintf("0x%-8lx%s", (ULONG) _obj._field, EOL)

#define PrintPtr(_field)            \
            PrintFieldName(#_field)  \
            dprintf("%-10lx%s", _obj._field, EOL)

#define PrintSymbolPtr( _field )    \
            PrintFieldName(#_field)  \
            dprintSymbolPtr( (( PVOID )_obj._field), EOL );

#define AddressOf( _field ) ((( ULONG )_objAddr) + FIELD_OFFSET( _objType, _field ))

#define PrintAddr(_field)               \
            PrintFieldNameAt(#_field)   \
            dprintf("%-10lx%s", AddressOf( _field ), EOL)

#define PrintL(_field) \
            PrintFieldName(#_field##".Next")  \
            dprintf("%-10lx%s",  _obj._field.Next, EOL )

#define PrintLL(_field)                                     \
            PrintEnd;                                       \
            PrintListFieldName(#_field );                  \
            dprintf("%-10lx",  _obj._field.Flink );         \
            dprintf("Blink = %-10lx",  _obj._field.Blink );         \
            dprintf("%s\n", ( _obj._field.Flink == _obj._field.Blink ) ? " (Empty)" : "" );

#define PrintLLTcp(_field)                                     \
            PrintEnd;                                       \
            PrintListTcpFieldName(#_field );                  \
            dprintf("%-10lx",  _obj._field.q_next );         \
            dprintf("q_prev = %-10lx",  _obj._field.q_prev );         \
            dprintf("%s\n", ( _obj._field.q_next == _obj._field.q_prev ) ? " (Empty)" : "" );

#define PrintIrpQ(_field) \
            PrintEnd;   \
            PrintFieldName(#_field##".Head");                 \
            dprintf("%-10lx",  _obj._field.Head );            \
            PrintFieldName(#_field##".Tail");                 \
            dprintf("%-10lx\n",  _obj._field.Tail );

#define PrintFlags( _field, _pFlagStruct )                  \
            PrintEnd;                                       \
            PrintFieldName(#_field);                        \
            dprintf("0x%08lx (", (ULONG) _obj._field );     \
            dprint_flag_names( (ULONG) _obj._field, _pFlagStruct );  \
            dprintf( ")\n" );

#define PrintFlagsMask( _field, _pFlagStruct, _Mask )       \
            PrintEnd;                                       \
            PrintFieldName(" & " ## #_Mask );               \
            dprintf("0x");                                  \
            dprint_masked_value((ULONG) _obj._field, _Mask );    \
            dprintf("(");                                   \
            dprint_flag_names( (ULONG) _obj._field, _pFlagStruct );  \
            dprintf( ")\n" );

#define PrintEnum( _field, _pEnumStruct )                   \
            PrintEnd;                                       \
            PrintFieldName(#_field);                        \
            dprintf("%lu (", (ULONG) _obj._field );         \
            dprint_enum_name( (ULONG) _obj._field, _pEnumStruct );  \
            dprintf( ")\n" );

#define PrintXEnum( _field, _pEnumStruct )                  \
            PrintEnd;                                       \
            PrintFieldName(#_field);                        \
            dprintf("0x%08lx (", (ULONG) _obj._field );    \
            dprint_enum_name( (ULONG) _obj._field, _pEnumStruct );  \
            dprintf( ")\n" );

#define PrintXEnumMask( _field, _pEnumStruct, _Mask )       \
            PrintEnd;                                       \
            PrintFieldName(" & " ## #_Mask );               \
            dprintf("0x");                                  \
            dprint_masked_value((ULONG) _obj._field, _Mask );    \
            dprintf("(");                                   \
            dprint_enum_name((ULONG) _obj._field & _Mask, _pEnumStruct );  \
            dprintf( ")\n" );


#define PrintHardwareAddress( _field )                      \
            PrintFieldName(#_field);                        \
            dprint_hardware_address( _obj._field.Address ); \
            dprintf( "%s", EOL );

#define PrintIPAddress( _field )                      \
            PrintFieldName(#_field);                        \
            dprint_IP_address( _obj._field ); \
            dprintf( "%s", EOL );

#define PrintGUID( _field )                                 \
            PrintFieldName(#_field);                        \
            dprintf("{%lx.%lx.%lx.%lx}",                    \
                    *(PULONG)(&_obj._field),                \
                    *((PUCHAR)(&_obj._field)+4),            \
                    *((PUCHAR)(&_obj._field)+8),            \
                    *((PUCHAR)(&_obj._field)+12));          \
            dprintf( "%s", EOL );

#define PrintLock(_field) \
            PrintFieldName(#_field)  \
            dprintf("( 0x%08lx ) %-10s%s", (_obj._field), (_obj._field) ? "Locked" : "UnLocked", EOL)

#define PrintTDIAddress( _field )                           \
            PrintFieldName( #_field );                      \
            dprintf( "{ NetworkAddress = %X, NodeAddress = ", _obj._field.NetworkAddress );\
            dprint_hardware_address( _obj._field.NodeAddress );\
            dprintf( ", Socket = %d }%s", _obj._field.Socket, EOL );

#define PrintCTETimer( _field )                             \
            dprintf( "%s", #_field );                       \
            PrintStartStruct();                             \
            DumpCTETimer ( ((ULONG)_objAddr) +FIELD_OFFSET( _objType, _field ), VERBOSITY_NORMAL );\
            PrintEndStruct();

#define PrintCTEEvent( _field )                             \
            dprintf( "%s", #_field );                       \
            PrintStartStruct();                             \
            DumpCTEEvent ( ((ULONG)_objAddr) +FIELD_OFFSET( _objType, _field ), VERBOSITY_NORMAL );\
            PrintEndStruct();

#define PrintKEvent( _field )                             \
            dprintf( "%s", #_field );                       \
            PrintStartStruct();                             \
            DumpKEvent ( ((ULONG)_objAddr) +FIELD_OFFSET( _objType, _field ), VERBOSITY_NORMAL );\
            PrintEndStruct();

#define PrintWorkQueueItem( _field )                        \
            dprintf( "%s", #_field );                       \
            PrintStartStruct();                             \
            DumpWorkQueueItem ( ((ULONG)_objAddr) +FIELD_OFFSET( _objType, _field ), VERBOSITY_NORMAL );\
            PrintEndStruct();


extern  BOOLEAN ChkTarget;
extern  INT     Item;

#define CHECK_SIGNATURE( _field, _signature )   \
    if ( _obj._field != _signature )            \
    {                                           \
        dprintf( "Object at %08X doesn't have signature %s at %08X\n",   \
                 _objAddr,                                              \
                 #_signature,                                           \
                 (( ULONG )_objAddr) + FIELD_OFFSET( _objType, _field ));\
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\kdext\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <ntosp.h>
#include <stdio.h>

#include <tcpipbase.h>

#if GPC
#include <gpcifc.h>
#endif

#include <ipfilter.h>
#include <ipinfo.h>
#include <llinfo.h>
#include <llipif.h>
#include <ffp.h>
#include <ipinit.h>
#include <ipdef.h>

#if FIPS
#include <fipsapi.h>
#endif

#include <des.h>
#include <md5.h>
#include <modes.h>
#include <ntddksec.h>
#include <randlib.h>
#include <rc4.h>
#include <sha.h>
#include <tripldes.h>

#include "ipsec.h"
#include "debug.h"
#include "timer.h"
#include "locks.h"
#include "globals.h"
#include "ah.h"
#include "esp.h"
#include "externs.h"
#include "ahxforms.h"
#include "filter.h"
#include "acquire.h"
#include "intirspn.h"
#include "driver.h"
#include "saapi.h"
#include "ipseceng.h"
#include "gpc.h"
#include "offload.h"
#include "hughes.h"
#include "macros.h"
#include "iperrs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\kdext\rtkmext.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    net\routing\rtext\rtext.h

Abstract:


Revision History:



--*/

#include "precomp.h"
#pragma  hdrstop

#define __FILE_SIG__
#include <ipsec.h>
#include <globals.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\kdext\rtkmext.c ===
#include    "rtkmext.h"

#include "precomp.h"
#pragma hdrstop

#ifndef KERNEL
PSTR pszExtName         = "RTUMEXT";
#else
PSTR pszExtName         = "IPSEC";
#endif

#include <stdexts.h>
#include <stdexts.c>

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\kdext\rtext.c ===
#ifndef KERNEL
PSTR pszExtName         = "RTUMEXT";
#else
PSTR pszExtName         = "IPSEC";
#endif

#include <stdexts.h>
#include <stdexts.c>

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\acquire.h ===
VOID
IPSecCompleteIrp(
    PIRP pIrp,
    NTSTATUS ntStatus
    );

VOID
IPSecInvalidateHandle(
    PIPSEC_ACQUIRE_CONTEXT pIpsecAcquireContext
    );

NTSTATUS
IPSecValidateHandle(
    PIPSEC_ACQUIRE_CONTEXT pIpsecAcquireContext,
    SA_STATE SAState
    );

VOID
IPSecAbortAcquire(
    PIPSEC_ACQUIRE_CONTEXT pIpsecAcquireContext
    );

NTSTATUS
IPSecCheckSetCancelRoutine(
    PIRP pIrp,
    PVOID pCancelRoutine
    );

NTSTATUS
IPSecSubmitAcquire(
    PSA_TABLE_ENTRY pLarvalSA,
    KIRQL OldIrq,
    BOOLEAN PostAcquire
    );

NTSTATUS
IPSecHandleAcquireRequest(
    PIRP pIrp,
    PIPSEC_POST_FOR_ACQUIRE_SA pIpsecPostAcquireSA
    );

VOID
IPSecAcquireIrpCancel(
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp
    );

NTSTATUS
IPSecNotifySAExpiration(
    PSA_TABLE_ENTRY pInboundSA,
    PIPSEC_NOTIFY_EXPIRE pNotifyExpire,
    KIRQL OldIrq,
    BOOLEAN PostAcquire
    );

VOID
IPSecFlushSAExpirations(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\acquire.c ===
#include "precomp.h"


#pragma hdrstop


VOID
IPSecCompleteIrp(
    PIRP pIrp,
    NTSTATUS ntStatus
    )
/*++

Routine Description:

    This Routine handles calling the NT I/O system to complete an I/O.

Arguments:

    pIrp - Irp which needs to be completed.

    ntStatus - The completion status for the Irp.

Return Value:

    None.

--*/
{
    KIRQL kIrql;


#if DBG
    if (!NT_SUCCESS(ntStatus)) {
        IPSEC_DEBUG(ACQUIRE, ("IPSecCompleteIrp: Completion status = %X\n", ntStatus));
    }
#endif

    pIrp->IoStatus.Status = ntStatus;

    //
    // Set the cancel routine for the Irp to NULL or the system may bugcheck
    // with a bug code of CANCEL_STATE_IN_COMPLETED_IRP.
    //

    IoAcquireCancelSpinLock(&kIrql);
    IoSetCancelRoutine(pIrp, NULL);
    IoReleaseCancelSpinLock(kIrql);

    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

    return;
}


VOID
IPSecInvalidateHandle(
    PIPSEC_ACQUIRE_CONTEXT pIpsecAcquireContext
    )
/*++

Routine Description:

    This routine invalidates an acquire handle by freeing the memory location.

Arguments:

    pIpsecAcquireContext - The Acquire context.

Return Value:

    None.

--*/
{
    ASSERT(pIpsecAcquireContext);

    if (pIpsecAcquireContext) {

        ASSERT(pIpsecAcquireContext->pSA);
        ASSERT(
            pIpsecAcquireContext->pSA->sa_AcquireId ==
            pIpsecAcquireContext->AcquireId
            );

        pIpsecAcquireContext->AcquireId = 0;

        IPSecFreeMemory(pIpsecAcquireContext);

    }

    return;
}


NTSTATUS
IPSecValidateHandle(
    PIPSEC_ACQUIRE_CONTEXT pIpsecAcquireContext,
    SA_STATE SAState
    )
/*++

Routine Description:

    This routine validates an acquire handle by matching the unique signature
    in the handle with that in the SA and ensuring that the SA state matches 
    the SA state in the input.
    Called with Larval List Lock held; returns with it.

Arguments:

    pIpsecAcquireContext - The Acquire context.

    SAState - State in which the SA is expected to be in.

Return Value:

    NTSTATUS - Status after the validation.

--*/
{
    PSA_TABLE_ENTRY pSA = NULL;
    BOOL bFound = FALSE;
    PLIST_ENTRY pEntry = NULL;


    if (!pIpsecAcquireContext) {
        return  STATUS_UNSUCCESSFUL;
    }

    //
    // Walk through the larval SA list to see if there is an SA
    // with this context value.
    //

    for (pEntry = g_ipsec.LarvalSAList.Flink;
         pEntry != &g_ipsec.LarvalSAList;
         pEntry = pEntry->Flink) {

        pSA = CONTAINING_RECORD(
                  pEntry,
                  SA_TABLE_ENTRY,
                  sa_LarvalLinkage
                  );

        if (pSA->sa_AcquireCtx == pIpsecAcquireContext) {
            bFound = TRUE;
            break;
        }

    }

    if (bFound) {

        if (!pIpsecAcquireContext->pSA) {
            return  STATUS_UNSUCCESSFUL;
        }

        pSA = pIpsecAcquireContext->pSA;

        if (pSA->sa_AcquireId != pIpsecAcquireContext->AcquireId) {
            return  STATUS_UNSUCCESSFUL;
        }

        if (pSA->sa_Signature == IPSEC_SA_SIGNATURE) {
            if (pSA->sa_State == SAState) {
                return  STATUS_SUCCESS;
            }
        }

    }

    return STATUS_UNSUCCESSFUL;
}


VOID
IPSecAbortAcquire(
    PIPSEC_ACQUIRE_CONTEXT pIpsecAcquireContext
    )
/*++

Routine Description:

    This routine aborts the acquire operation because of insufficient
    resources or invalid parameters.

Arguments:

    pIpsecAcquireContext - The acquire context.

    Called with both the SADB and the LarvalSAList locks held; returns with them.

Return Value:

    None.

--*/
{
    PSA_TABLE_ENTRY pSA = NULL;
    PSA_TABLE_ENTRY pOutboundSA = NULL;
    BOOL bIsTimerStopped = FALSE;
    KIRQL kSPIIrql;


    pSA = pIpsecAcquireContext->pSA;

    ASSERT(pSA->sa_Flags & FLAGS_SA_TIMER_STARTED);

    bIsTimerStopped = IPSecStopTimer(&pSA->sa_Timer);

    if (!bIsTimerStopped) {
        return;
    }

    pSA->sa_Flags &= ~FLAGS_SA_TIMER_STARTED;

    //
    // The larval list is already locked so that this SA does not go away.
    //
    ASSERT((pSA->sa_Flags & FLAGS_SA_OUTBOUND) == 0);

    if (pSA->sa_AcquireCtx) {
        IPSecInvalidateHandle(pSA->sa_AcquireCtx);
        pSA->sa_AcquireCtx = NULL;
    }

    //
    // Remove from the larval list.
    //
    IPSecRemoveEntryList(&pSA->sa_LarvalLinkage);
    IPSEC_DEC_STATISTIC(dwNumPendingKeyOps);

    //
    // Flush all the queued packets for this SA.
    //
    IPSecFlushQueuedPackets(pSA, STATUS_TIMEOUT);

    //
    // Remove the SA from the inbound SA list.
    //
    AcquireWriteLock(&g_ipsec.SPIListLock, &kSPIIrql);
    IPSecRemoveSPIEntry(pSA);
    ReleaseWriteLock(&g_ipsec.SPIListLock, kSPIIrql);

    //
    // Also remove the SA from the filter list.
    //
    if (pSA->sa_Flags & FLAGS_SA_ON_FILTER_LIST) {
        pSA->sa_Flags &= ~FLAGS_SA_ON_FILTER_LIST;
        IPSecRemoveEntryList(&pSA->sa_FilterLinkage);
    }

    if (pSA->sa_RekeyOriginalSA) {
        ASSERT(pSA->sa_Flags & FLAGS_SA_REKEY);
        ASSERT(pSA->sa_RekeyOriginalSA->sa_RekeyLarvalSA == pSA);
        ASSERT(pSA->sa_RekeyOriginalSA->sa_Flags & FLAGS_SA_REKEY_ORI);

        pSA->sa_RekeyOriginalSA->sa_Flags &= ~FLAGS_SA_REKEY_ORI;
        pSA->sa_RekeyOriginalSA->sa_RekeyLarvalSA = NULL;
        pSA->sa_RekeyOriginalSA = NULL;
    }

    //
    // Invalidate the associated cache entry.
    //
    IPSecInvalidateSACacheEntry(pSA);

    pOutboundSA = pSA->sa_AssociatedSA;

    if (pOutboundSA) {
        pSA->sa_AssociatedSA = NULL;
        if (pOutboundSA->sa_Flags & FLAGS_SA_ON_FILTER_LIST) {
            pOutboundSA->sa_Flags &= ~FLAGS_SA_ON_FILTER_LIST;
            IPSecRemoveEntryList(&pOutboundSA->sa_FilterLinkage);
        }

        //
        // Invalidate the associated cache entry.
        //
        IPSecInvalidateSACacheEntry(pOutboundSA);

        IPSEC_DEC_STATISTIC(dwNumActiveAssociations);
        IPSEC_DEC_TUNNELS(pOutboundSA);
        IPSEC_DECREMENT(g_ipsec.NumOutboundSAs);

        IPSEC_DEBUG(REF, ("IPSecAbortAcquire: Outbound SA Dereference.\n"));

        IPSecStopTimerDerefSA(pOutboundSA);
    }

    IPSecDerefSA(pSA);

    return;
}


NTSTATUS
IPSecCheckSetCancelRoutine(
    PIRP pIrp,
    PVOID pCancelRoutine
    )
/*++

Routine Description:

    This Routine sets the cancel routine for an Irp.

Arguments:

    pIrp - Irp for which the cancel routine is to be set.

    pCancelRoutine - Cancel routine to be set in the Irp.

Return Value:

    NTSTATUS - Status for the request.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Check if the irp has been cancelled and if not, then set the
    // irp cancel routine.
    //

    IoAcquireCancelSpinLock(&pIrp->CancelIrql);

    if (pIrp->Cancel) {
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        ntStatus = STATUS_CANCELLED;
    }
    else {
        IoMarkIrpPending(pIrp);
        IoSetCancelRoutine(pIrp, pCancelRoutine);
        ntStatus = STATUS_SUCCESS;
    }

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    return (ntStatus);
}


NTSTATUS
IPSecSubmitAcquire(
    PSA_TABLE_ENTRY pLarvalSA,
    KIRQL OldIrq,
    BOOLEAN PostAcquire
    )
/*++

Routine Description:

    This function is used to submit an Acquire request to the key manager

Arguments:

    pLarvalSA - larval SA that needs to be negotiated

    OldIrq - prev irq - lock released here.

    NOTE: called with AcquireInfo lock held.

Return Value:

    STATUS_PENDING if the buffer is to be held on to , the normal case.

Notes:


--*/

{
    NTSTATUS                status;
    PIRP                    pIrp;

    if (!g_ipsec.AcquireInfo.Irp) {
        //
        // the irp either never made it down here, or it was cancelled,
        // so drop all frames
        //
        IPSEC_DEBUG(ACQUIRE, ("IPSecSubmitAcquire: Irp is NULL, returning\r\n"));
        RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, OldIrq);

        return  STATUS_BAD_NETWORK_PATH;
    } else if (!g_ipsec.AcquireInfo.ResolvingNow) {
        PIPSEC_ACQUIRE_CONTEXT  pAcquireCtx;
        PVOID   pvIoBuffer;

        //
        // Irp is free now - use it
        //
        pIrp = g_ipsec.AcquireInfo.Irp;

        IPSEC_DEBUG(ACQUIRE, ("Using Irp.. : %lx\n", pIrp));

        //
        // Get the Acquire Context and associate with the Larval SA
        //
        pAcquireCtx = IPSecGetAcquireContext();

        if (!pAcquireCtx) {
            IPSEC_DEBUG(ACQUIRE, ("Failed to get acquire ctx\n"));
            RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock,OldIrq);
            return  STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Set ResolvingNow only after memory allocation (282645).
        //
        g_ipsec.AcquireInfo.ResolvingNow = TRUE;

        pAcquireCtx->AcquireId = (ULONG)(ULONG_PTR)pLarvalSA;
        IPSecGenerateRandom((PUCHAR)&pAcquireCtx->AcquireId, sizeof(ULONG));
        pAcquireCtx->pSA = pLarvalSA;
        pLarvalSA->sa_AcquireCtx = pAcquireCtx;
        pLarvalSA->sa_AcquireId = pAcquireCtx->AcquireId;

        //
        // Set up the Irp params
        //
        pvIoBuffer = pIrp->AssociatedIrp.SystemBuffer;

        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->IdentityInfo = NULL;
        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->Context = pAcquireCtx;
        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->PolicyId = pLarvalSA->sa_Filter->PolicyId;

        //
        // Instead of reversing, use the originating filters addresses
        //
        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->SrcAddr = pLarvalSA->SA_DEST_ADDR;
        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->SrcMask = pLarvalSA->SA_DEST_MASK;
        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->DestAddr = pLarvalSA->SA_SRC_ADDR;
        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->DestMask = pLarvalSA->SA_SRC_MASK;
        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->Protocol = pLarvalSA->SA_PROTO;
        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->TunnelFilter = pLarvalSA->sa_Filter->TunnelFilter;
        //
        // the tunnel addr is in the corresp. outbound filter.
        //
        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->TunnelAddr = pLarvalSA->sa_Filter->TunnelAddr;
        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->InboundTunnelAddr = pLarvalSA->sa_TunnelAddr;

        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->SrcPort = SA_DEST_PORT(pLarvalSA);
        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->DestPort = SA_SRC_PORT(pLarvalSA);
        
        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->DestType = 0;
        if (IS_BCAST_DEST(pLarvalSA->sa_DestType)) {
            ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->DestType |= IPSEC_BCAST;
        }
        if (IS_MCAST_DEST(pLarvalSA->sa_DestType)) {
            ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->DestType |= IPSEC_MCAST;
        }
        

        pIrp->IoStatus.Information = sizeof(IPSEC_POST_FOR_ACQUIRE_SA);

        g_ipsec.AcquireInfo.InMe = FALSE;

        pLarvalSA->sa_Flags &= ~FLAGS_SA_PENDING;

        RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock,OldIrq);

        if (PostAcquire) {
            status = STATUS_SUCCESS;
        } else {
            IPSEC_DEBUG(ACQUIRE, ("Completing Irp.. : %lx\n", pIrp));
            IPSecCompleteIrp(pIrp, STATUS_SUCCESS);
            status = STATUS_PENDING;
        }

        IPSEC_DEBUG(ACQUIRE, ("IPSecSubmitAcquire: submitted context: %lx, SA: %lx\n",
                            pAcquireCtx,
                            pLarvalSA));
    } else {
        //
        // The irp is busy negotiating another SA
        // Queue the Larval SA
        //
        InsertTailList( &g_ipsec.AcquireInfo.PendingAcquires,
                        &pLarvalSA->sa_PendingLinkage);

        pLarvalSA->sa_Flags |= FLAGS_SA_PENDING;

        status = STATUS_PENDING;
        RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, OldIrq);

        IPSEC_DEBUG(ACQUIRE, ("IPSecSubmitAcquire: queued SA: %lx\n", pLarvalSA));
    }

    return  status;
}


NTSTATUS
IPSecHandleAcquireRequest(
    PIRP pIrp,
    PIPSEC_POST_FOR_ACQUIRE_SA pIpsecPostAcquireSA
    )
/*++

Routine Description:

    This routine receives an acquire request from the key manager and
    either completes it instantly to submit a new SA negotiation or pends
    it for further negotiations.

Arguments:

    pIrp - The Irp.

    pIpsecPostAcquireSA - Buffer for filling in the policy ID for forcing
                          an SA negotiation.

Return Value:

    STATUS_PENDING - If the buffer is to be held on to, the normal case.

--*/
{
    NTSTATUS        status = STATUS_PENDING;
    KIRQL           OldIrq;
    PVOID           Context;
    BOOLEAN         fIrpCompleted = FALSE;
    PSA_TABLE_ENTRY pLarvalSA;

    ACQUIRE_LOCK(&g_ipsec.AcquireInfo.Lock, &OldIrq);

    if (g_ipsec.AcquireInfo.InMe) {
        IPSEC_DEBUG(ACQUIRE, ("Irp re-submited!: %lx\n", g_ipsec.AcquireInfo.Irp));
        RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, OldIrq);
        return  STATUS_INVALID_PARAMETER;
    }

    g_ipsec.AcquireInfo.Irp = pIrp;

    // ASSERT(g_ipsec.AcquireInfo.ResolvingNow);

    g_ipsec.AcquireInfo.ResolvingNow = FALSE;

    //
    // if there are pending SA negotiations, submit next
    //
    while (TRUE) {
        if (!IsListEmpty(&g_ipsec.AcquireInfo.PendingAcquires)) {
            PLIST_ENTRY     pEntry;

            pEntry = RemoveHeadList(&g_ipsec.AcquireInfo.PendingAcquires);

            pLarvalSA = CONTAINING_RECORD(  pEntry,
                                            SA_TABLE_ENTRY,
                                            sa_PendingLinkage);

            ASSERT(pLarvalSA->sa_State == STATE_SA_LARVAL);
            ASSERT(pLarvalSA->sa_Flags & FLAGS_SA_PENDING);

            pLarvalSA->sa_Flags &= ~FLAGS_SA_PENDING;

            //
            // submit... releases the AcquireInfo lock
            //
            status = IPSecSubmitAcquire(pLarvalSA, OldIrq, TRUE);

            //
            // if it failed then complete the irp now
            //
            if (!NT_SUCCESS(status)) {
                ACQUIRE_LOCK(&g_ipsec.AcquireInfo.Lock, &OldIrq);
            } else {
                ACQUIRE_LOCK(&g_ipsec.AcquireInfo.Lock, &OldIrq);
                fIrpCompleted = TRUE;
                IPSEC_DEBUG(ACQUIRE, ("Acquire Irp completed inline\n"));
                break;
            }
        } else if (!IsListEmpty(&g_ipsec.AcquireInfo.PendingNotifies)) {
            PLIST_ENTRY     pEntry;
            PIPSEC_NOTIFY_EXPIRE pNotifyExpire;

            pEntry = RemoveHeadList(&g_ipsec.AcquireInfo.PendingNotifies);


            pNotifyExpire = CONTAINING_RECORD(  pEntry,
                                                IPSEC_NOTIFY_EXPIRE,
                                                notify_PendingLinkage);

            ASSERT(pNotifyExpire);

            //
            // submit... releases the AcquireInfo lock
            //
            status = IPSecNotifySAExpiration(NULL, pNotifyExpire, OldIrq, TRUE);

            //
            // if it failed then complete the irp now
            //
            if (!NT_SUCCESS(status)) {
                ACQUIRE_LOCK(&g_ipsec.AcquireInfo.Lock, &OldIrq);
            } else {
                ACQUIRE_LOCK(&g_ipsec.AcquireInfo.Lock, &OldIrq);
                fIrpCompleted = TRUE;
                IPSEC_DEBUG(ACQUIRE, ("Acquire Irp completed inline\n"));
                break;
            }


        } else {
            break;
        }
    }

    //
    // We are holding onto the Irp, so set the cancel routine.
    //
    if (!fIrpCompleted) {
        status = IPSecCheckSetCancelRoutine(pIrp, IPSecAcquireIrpCancel);

        if (!NT_SUCCESS(status)) {
            //
            // the irp got cancelled so complete it now
            //
            g_ipsec.AcquireInfo.Irp = NULL;
            RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, OldIrq);

            // IPSecCompleteIrp(pIrp, status);
        } else {
            g_ipsec.AcquireInfo.InMe = TRUE;
            RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, OldIrq);
            status = STATUS_PENDING;
        }
    } else {
        g_ipsec.AcquireInfo.InMe = FALSE;
        RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, OldIrq);
    }

    return  status;
}


VOID
IPSecAcquireIrpCancel(
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp
    )
/*++

Routine Description:

    This is the cancel routine for the Acquire Irp.
    It is called with IoCancelSpinLock held - must release this lock before exit.

Arguments:

    pDeviceObject - Device object for the Irp.

    pIrp - The irp itself.

Return Value:

    None.

--*/
{
    KIRQL kIrql;
    KIRQL kAcquireIrql;


    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    IPSEC_DEBUG(ACQUIRE, ("IPSecAcquireIrpCancel: Acquire Irp cancelled\n"));

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);
    ACQUIRE_LOCK(&g_ipsec.AcquireInfo.Lock, &kAcquireIrql);

    if (g_ipsec.AcquireInfo.Irp && g_ipsec.AcquireInfo.InMe) {

        pIrp->IoStatus.Status = STATUS_CANCELLED;
        g_ipsec.AcquireInfo.Irp = NULL;
        g_ipsec.AcquireInfo.InMe = FALSE;

        //
        // Flush larval SAs.
        //

        IPSecFlushLarvalSAList();

        //
        // Flush SA expiration notifies.
        //

        IPSecFlushSAExpirations();

        RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, kAcquireIrql);
        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

    }
    else {

        RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, kAcquireIrql);
        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    }

    return;
}


NTSTATUS
IPSecNotifySAExpiration(
    PSA_TABLE_ENTRY pInboundSA,
    PIPSEC_NOTIFY_EXPIRE pNotifyExpire,
    KIRQL OldIrq,
    BOOLEAN PostAcquire
    )
/*++

Routine Description:

    Notify Oakley through Acquire that SA has expired.

Arguments:

    SA that is to expire

Return Value:

    None

--*/
{
    PIPSEC_NOTIFY_EXPIRE    pNewNotifyExpire;
    NTSTATUS                status;
    PIRP                    pIrp;

#if DBG
    if ((IPSecDebug & IPSEC_DEBUG_REKEY) && pInboundSA) {
        LARGE_INTEGER   CurrentTime;

        NdisGetCurrentSystemTime(&CurrentTime);
        DbgPrint("NotifySAExpiration: %lx, %lx, %lx, %lx, %lx\n",
                CurrentTime.LowPart,
                pInboundSA->SA_DEST_ADDR,
                pInboundSA->SA_SRC_ADDR,
                pInboundSA->sa_SPI,
                pInboundSA->sa_AssociatedSA? pInboundSA->sa_AssociatedSA->sa_SPI: 0);
    }
#endif

    //
    // Check if there is a need to notify.
    //
    if (pInboundSA &&
        ((pInboundSA->sa_Flags & FLAGS_SA_NOTIFY_PERFORMED) ||
         (pInboundSA->sa_State == STATE_SA_LARVAL))) {
        IPSEC_DEBUG(ACQUIRE, ("IPSecSubmitAcquire: already notified, returning\n"));
        RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, OldIrq);

        return  STATUS_UNSUCCESSFUL;
    }

    //
    // Set the flag so we won't notify again - only set flag in non-queued case.
    //
    if (pInboundSA) {
        pInboundSA->sa_Flags |= FLAGS_SA_NOTIFY_PERFORMED;
    }

    if (!g_ipsec.AcquireInfo.Irp) {
        //
        // the irp either never made it down here, or it was cancelled,
        // so drop all frames
        //
        IPSEC_DEBUG(ACQUIRE, ("IPSecSubmitAcquire: Irp is NULL, returning\r\n"));
        RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, OldIrq);

        return  STATUS_BAD_NETWORK_PATH;
    } else if (!g_ipsec.AcquireInfo.ResolvingNow) {
        PIPSEC_POST_EXPIRE_NOTIFY   pNotify;

        //
        // Irp is free now - use it
        //
        g_ipsec.AcquireInfo.ResolvingNow = TRUE;
        pIrp = g_ipsec.AcquireInfo.Irp;

        IPSEC_DEBUG(ACQUIRE, ("Using Irp.. : %lx\n", pIrp));

        pNotify = (PIPSEC_POST_EXPIRE_NOTIFY)pIrp->AssociatedIrp.SystemBuffer;

        pNotify->IdentityInfo = NULL;
        pNotify->Context = NULL;

        if (pInboundSA) {
            pNotify->SrcAddr = pInboundSA->SA_DEST_ADDR;
            pNotify->SrcMask = pInboundSA->SA_DEST_MASK;
            pNotify->DestAddr = pInboundSA->SA_SRC_ADDR;
            pNotify->DestMask = pInboundSA->SA_SRC_MASK;
            pNotify->Protocol = pInboundSA->SA_PROTO;
            pNotify->SrcPort = SA_DEST_PORT(pInboundSA);
            pNotify->DestPort = SA_SRC_PORT(pInboundSA);
            pNotify->InboundSpi = pInboundSA->sa_SPI;

            RtlCopyMemory(  &pNotify->CookiePair,
                            &pInboundSA->sa_CookiePair,
                            sizeof(IKE_COOKIE_PAIR));

            if (pInboundSA->sa_Flags & FLAGS_SA_DELETE_BY_IOCTL) {
                pNotify->Flags = IPSEC_SA_INTERNAL_IOCTL_DELETE;
            } else {
                pNotify->Flags = 0;
            }

            if (pInboundSA->sa_AssociatedSA) {
                pNotify->OutboundSpi = pInboundSA->sa_AssociatedSA->sa_SPI;

                if (pInboundSA->sa_AssociatedSA->sa_Filter) {
                    pNotify->TunnelAddr = pInboundSA->sa_AssociatedSA->sa_Filter->TunnelAddr;
                    pNotify->InboundTunnelAddr = pInboundSA->sa_TunnelAddr;
                } else {
                    pNotify->TunnelAddr = IPSEC_INVALID_ADDR;
                }
            } else {
                pNotify->OutboundSpi = IPSEC_INVALID_SPI;
                pNotify->TunnelAddr = IPSEC_INVALID_ADDR;
            }
        } else {
            ASSERT(pNotifyExpire);

            if (pNotifyExpire) {
                pNotify->SrcAddr = pNotifyExpire->SA_DEST_ADDR;
                pNotify->SrcMask = pNotifyExpire->SA_DEST_MASK;
                pNotify->DestAddr = pNotifyExpire->SA_SRC_ADDR;
                pNotify->DestMask = pNotifyExpire->SA_SRC_MASK;
                pNotify->Protocol = pNotifyExpire->SA_PROTO;

                pNotify->TunnelAddr = pNotifyExpire->sa_TunnelAddr;
                pNotify->InboundTunnelAddr = pNotifyExpire->sa_TunnelAddr;

                pNotify->SrcPort = SA_DEST_PORT(pNotifyExpire);
                pNotify->DestPort = SA_SRC_PORT(pNotifyExpire);

                pNotify->InboundSpi = pNotifyExpire->InboundSpi;
                pNotify->OutboundSpi = pNotifyExpire->OutboundSpi;

                RtlCopyMemory(  &pNotify->CookiePair,
                                &pNotifyExpire->sa_CookiePair,
                                sizeof(IKE_COOKIE_PAIR));
                pNotify->Flags = pNotifyExpire->Flags;

                IPSecFreeMemory(pNotifyExpire);
            }
        }

        pIrp->IoStatus.Information = sizeof(IPSEC_POST_FOR_ACQUIRE_SA);

        g_ipsec.AcquireInfo.InMe = FALSE;

        RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock,OldIrq);

        if (PostAcquire) {
            IPSEC_DEBUG(ACQUIRE, ("Completing Irp in driver.c.. : %lx\n", pIrp));
            status = STATUS_SUCCESS;
        } else {
            IPSEC_DEBUG(ACQUIRE, ("Completing Irp.. : %lx\n", pIrp));
            IPSecCompleteIrp(pIrp, STATUS_SUCCESS);
            status = STATUS_PENDING;
        }

        IPSEC_DEBUG(ACQUIRE, ("IPSecSubmitAcquire(Notify)\n"));
    } else {
        ASSERT(pInboundSA);

        //
        // The irp is busy negotiating another SA
        // Queue the Larval SA
        //
        if (pNotifyExpire) {
            //
            // Somethings bad.  We've already queued up once, and we still
            // can't send.  Just drop it.
            //
            IPSecFreeMemory(pNotifyExpire);
            RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, OldIrq);
            return STATUS_UNSUCCESSFUL;
        }

        pNewNotifyExpire = IPSecGetNotifyExpire();

        if (!pNewNotifyExpire || !pInboundSA) {
            IPSEC_DEBUG(ACQUIRE, ("Failed to get Notify Memory\n"));
            RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock,OldIrq);
            return  STATUS_INSUFFICIENT_RESOURCES;
        }

        pNewNotifyExpire->sa_uliSrcDstAddr = pInboundSA->sa_uliSrcDstAddr;
        pNewNotifyExpire->sa_uliSrcDstMask = pInboundSA->sa_uliSrcDstMask;
        pNewNotifyExpire->sa_uliProtoSrcDstPort=pInboundSA->sa_uliProtoSrcDstPort;

        pNewNotifyExpire->InboundSpi = pInboundSA->sa_SPI;
        pNewNotifyExpire->sa_InboundTunnelAddr = pInboundSA->sa_TunnelAddr;

        RtlCopyMemory(  &pNewNotifyExpire->sa_CookiePair,
                        &pInboundSA->sa_CookiePair,
                        sizeof(IKE_COOKIE_PAIR));

        if (pInboundSA->sa_Flags & FLAGS_SA_DELETE_BY_IOCTL) {
            pNewNotifyExpire->Flags = IPSEC_SA_INTERNAL_IOCTL_DELETE;
        } else {
            pNewNotifyExpire->Flags = 0;
        }

        if (pInboundSA->sa_AssociatedSA) {
            pNewNotifyExpire->OutboundSpi = pInboundSA->sa_AssociatedSA->sa_SPI;

            if (pInboundSA->sa_AssociatedSA->sa_Filter) {
                pNewNotifyExpire->sa_TunnelAddr = pInboundSA->sa_AssociatedSA->sa_Filter->TunnelAddr;
            } else {
                pNewNotifyExpire->sa_TunnelAddr = IPSEC_INVALID_ADDR;
            }
        } else {
            pNewNotifyExpire->OutboundSpi = IPSEC_INVALID_SPI;
            pNewNotifyExpire->sa_TunnelAddr = IPSEC_INVALID_ADDR;
        }

        InsertTailList( &g_ipsec.AcquireInfo.PendingNotifies,
                        &pNewNotifyExpire->notify_PendingLinkage);

        status = STATUS_PENDING;
        RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, OldIrq);

        IPSEC_DEBUG(ACQUIRE, ("IPSecSubmitAcquire(Notify): queue SA\n"));
    }

    return  status;
}


VOID
IPSecFlushSAExpirations(
    )
/*++

Routine Description:

    When the Acquire Irp is cancelled, this routine is called to flush all the 
    pending SA expiration notifies.

    Called with SADB lock held (first acquisition); returns with it.
    Called with AcquireInfo.Lock held (second acquisition); returns with it.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIPSEC_NOTIFY_EXPIRE pIpsecNotifyExpire = NULL;
    PLIST_ENTRY pListEntry = NULL;


    while (!IsListEmpty(&g_ipsec.AcquireInfo.PendingNotifies)) {

        pListEntry = RemoveHeadList(
                         &g_ipsec.AcquireInfo.PendingNotifies
                         );

        pIpsecNotifyExpire = CONTAINING_RECORD(
                                 pListEntry,
                                 IPSEC_NOTIFY_EXPIRE,
                                 notify_PendingLinkage
                                 );

        IPSecFreeMemory(pIpsecNotifyExpire);

    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\ah.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    ah.h

Abstract:

    Contains AH specific structures

Author:

    Sanjay Anand (SanjayAn) 2-January-1997
    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#ifndef _AH_
#define _AH_


#define MD5DIGESTLEN    16
#define SHADIGESTLEN    20
#define AH_SIZE (sizeof(AH) + MD5DIGESTLEN * sizeof(UCHAR))

//
// State buffers for the individual algorithms
//
typedef struct  _AlgoState {
    union {             // internal algo state
        MD5_CTX             as_md5ctx;
        A_SHA_CTX           as_shactx;
    };
    PSA_TABLE_ENTRY     as_sa;
} ALGO_STATE, *PALGO_STATE;

typedef NTSTATUS
(*PALGO_INIT) (
    PALGO_STATE pEntry,
    ULONG       Index
);

typedef NTSTATUS
(*PALGO_UPDATE) (
    PALGO_STATE   State,
    PUCHAR  Data,
    ULONG   Length
);

typedef NTSTATUS
(*PALGO_FINISH) (
    PALGO_STATE State,
    PUCHAR      Data,
    ULONG       Index
);


//
// Array of function ptrs for the AH authentication algorithms
//
typedef struct _auth_algorithm {
  PALGO_INIT    init;       // ptr to init fn for alg.
  PALGO_UPDATE  update;     // ptr to update fn for alg
  PALGO_FINISH  finish;     // ptr to finish fn for alg
  ULONG OutputLen;          // Length (in u_int8s) of output
					        // data. MUST be a multiple of 4
} AUTH_ALGO, *PAUTH_ALGO;


#define NUM_AUTH_ALGOS (sizeof(auth_algorithms)/sizeof(AUTH_ALGO)-1)


//
// The IPSEC AH payload
//
typedef struct  _AH {
    UCHAR   ah_next;
    UCHAR   ah_len;
    USHORT  ah_reserved;
    tSPI    ah_spi;
    ULONG   ah_replay;
} AH, *PAH;

NTSTATUS
IPSecCreateAH(
    IN      PUCHAR          pIPHeader,
    IN      PVOID           pData,
    IN      PSA_TABLE_ENTRY pSA,
    IN      ULONG           Index,
    OUT     PVOID           *ppNewData,
    OUT     PVOID           *ppSCContext,
    OUT     PULONG          pExtraBytes,
    IN      ULONG           HdrSpace,
    IN      BOOLEAN         fSrcRoute,
    IN      BOOLEAN         fCryptoOnly
    );

NTSTATUS
IPSecVerifyAH(
    IN      PUCHAR          *pIPHeader,
    IN      PVOID           pData,
    IN      PSA_TABLE_ENTRY pSA,
    IN      ULONG           Index,
    OUT     PULONG          pExtraBytes,
    IN      BOOLEAN         fSrcRoute,
    IN      BOOLEAN         fCryptoDone,
    IN      BOOLEAN         fFastRcv
    );

NTSTATUS
IPSecGenerateHash(
    IN      PUCHAR          pIPHeader,
    IN      PVOID           pData,
    IN      PSA_TABLE_ENTRY pSA,
    IN      PUCHAR          pAHData,
    IN      BOOLEAN         fMuteDest,
    IN      BOOLEAN         fIncoming,
    IN      PAUTH_ALGO      pAlgo,
    IN      ULONG           Index
    );

#endif _AH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\debug.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This file contains all the debugging related structures/macros.

Author:

    Sanjay Anand (SanjayAn) 2-January-1997
    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#define IPSEC_DEBUG_LOAD        0x00000001
#define IPSEC_DEBUG_AH          0x00000002
#define IPSEC_DEBUG_IOCTL       0x00000004
#define IPSEC_DEBUG_HUGHES      0x00000008
#define IPSEC_DEBUG_ESP         0x00000010
#define IPSEC_DEBUG_AHEX        0x00000020
#define IPSEC_DEBUG_PATTERN     0x00000040
#define IPSEC_DEBUG_SEND        0x00000080
#define IPSEC_DEBUG_PARSE       0x00000100
#define IPSEC_DEBUG_PMTU        0x00000200
#define IPSEC_DEBUG_ACQUIRE     0x00000400
#define IPSEC_DEBUG_HASH        0x00000800
#define IPSEC_DEBUG_CLEARTEXT   0x00001000
#define IPSEC_DEBUG_TIMER       0x00002000
#define IPSEC_DEBUG_REF         0x00004000
#define IPSEC_DEBUG_SA          0x00008000
#define IPSEC_DEBUG_ALL         0x00010000
#define IPSEC_DEBUG_POOL        0x00020000
#define IPSEC_DEBUG_TUNNEL      0x00040000
#define IPSEC_DEBUG_HW          0x00080000
#define IPSEC_DEBUG_COMP        0x00100000
#define IPSEC_DEBUG_SAAPI       0x00200000
#define IPSEC_DEBUG_CACHE       0x00400000
#define IPSEC_DEBUG_TRANS       0x00800000
#define IPSEC_DEBUG_MDL         0x01000000
#define IPSEC_DEBUG_REKEY       0x02000000
#define IPSEC_DEBUG_GENHASH     0x04000000
#define IPSEC_DEBUG_HWAPI       0x08000000

#if GPC
#define IPSEC_DEBUG_GPC         0x10000000
#endif

#if DBG

#define IPSEC_DEBUG(_Flag, _Print) { \
    if (IPSecDebug & (IPSEC_DEBUG_ ## _Flag)) { \
        DbgPrint ("IPSEC: "); \
        DbgPrint _Print; \
    } \
}

#define IPSEC_PRINT_MDL(_Mdl) { \
    if ((_Mdl) == NULL) {   \
        IPSEC_DEBUG(MDL, ("IPSEC Mdl is NULL\n"));     \
    }   \
    if (IPSecDebug & IPSEC_DEBUG_MDL) { \
        PNDIS_BUFFER pBuf = _Mdl;   \
        while (pBuf != NULL) {  \
            IPSEC_DEBUG(MDL, ("pBuf: %lx, size: %d\n", pBuf, pBuf->ByteCount));     \
            pBuf = NDIS_BUFFER_LINKAGE(pBuf);   \
        }   \
    }   \
}

#define IPSEC_PRINT_CONTEXT(_Context) { \
    PIPSEC_SEND_COMPLETE_CONTEXT pC = (PIPSEC_SEND_COMPLETE_CONTEXT)(_Context);   \
    if (pC == NULL) {   \
        IPSEC_DEBUG(MDL, ("IPSEC Context is NULL\n"));     \
    } else if (IPSecDebug & IPSEC_DEBUG_MDL) { \
        DbgPrint("IPSEC: Context->Flags: %lx\n", pC->Flags);    \
        if (pC->OptMdl) \
            DbgPrint("IPSEC: Context->OptMdl: %lx\n", pC->OptMdl);  \
        if (pC->OriAHMdl) \
            DbgPrint("IPSEC: Context->OriAHMdl: %lx\n", pC->OriAHMdl);  \
        if (pC->OriHUMdl) \
            DbgPrint("IPSEC: Context->OriHUMdl: %lx\n", pC->OriHUMdl);  \
        if (pC->OriTuMdl) \
            DbgPrint("IPSEC: Context->OriTuMdl: %lx\n", pC->OriTuMdl);  \
        if (pC->PrevMdl) \
            DbgPrint("IPSEC: Context->PrevMdl: %lx\n", pC->PrevMdl);    \
        if (pC->PrevTuMdl) \
            DbgPrint("IPSEC: Context->PrevTuMdl: %lx\n", pC->PrevTuMdl);\
        if (pC->AHMdl) \
            DbgPrint("IPSEC: Context->AHMdl: %lx\n", pC->AHMdl);    \
        if (pC->AHTuMdl) \
            DbgPrint("IPSEC: Context->AHTuMdl: %lx\n", pC->AHTuMdl);\
        if (pC->PadMdl) \
            DbgPrint("IPSEC: Context->PadMdl: %lx\n", pC->PadMdl);  \
        if (pC->PadTuMdl) \
            DbgPrint("IPSEC: Context->PadTuMdl: %lx\n", pC->PadTuMdl);  \
        if (pC->HUMdl) \
            DbgPrint("IPSEC: Context->HUMdl: %lx\n", pC->HUMdl);    \
        if (pC->HUTuMdl) \
            DbgPrint("IPSEC: Context->HUTuMdl: %lx\n", pC->HUTuMdl);\
        if (pC->BeforePadMdl) \
            DbgPrint("IPSEC: Context->BeforePadMdl: %lx\n", pC->BeforePadMdl);  \
        if (pC->BeforePadTuMdl) \
            DbgPrint("IPSEC: Context->BeforePadTuMdl: %lx\n", pC->BeforePadTuMdl);  \
        if (pC->HUHdrMdl) \
            DbgPrint("IPSEC: Context->HUHdrMdl: %lx\n", pC->HUHdrMdl);  \
        if (pC->OriAHMdl2) \
            DbgPrint("IPSEC: Context->OriAHMdl2: %lx\n", pC->OriAHMdl2);\
        if (pC->PrevAHMdl2) \
            DbgPrint("IPSEC: Context->PrevAHMdl2: %lx\n", pC->PrevAHMdl2);  \
        if (pC->AHMdl2) \
            DbgPrint("IPSEC: Context->AHMdl2: %lx\n", pC->AHMdl2);  \
    }   \
}

#else

#define IPSEC_DEBUG(_Flag, _Print)

#define IPSEC_PRINT_MDL(_Mdl)

#define IPSEC_PRINT_CONTEXT(_Context)

#endif

//
// Lock order...
//
// SADBLock -> SPILiskLock -> LarvalListLock.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\ahxforms.h ===
NTSTATUS ah_nullinit (PALGO_STATE, ULONG);
NTSTATUS ah_nullupdate (PALGO_STATE, PUCHAR, ULONG);
NTSTATUS ah_nullfinish (PALGO_STATE, PUCHAR, ULONG);

NTSTATUS ah_hmacmd5init (PALGO_STATE, ULONG);
NTSTATUS ah_hmacmd5update (PALGO_STATE, PUCHAR, ULONG);
NTSTATUS ah_hmacmd5finish (PALGO_STATE, PUCHAR, ULONG);

NTSTATUS ah_hmacshainit (PALGO_STATE, ULONG);
NTSTATUS ah_hmacshaupdate (PALGO_STATE, PUCHAR, ULONG);
NTSTATUS ah_hmacshafinish (PALGO_STATE, PUCHAR, ULONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\driver.h ===
//
// Constants used to identify what general structure has been initialized. 
//

#define INIT_SA_DATABASE    0x00000001

#define INIT_MDL_POOLS      0x00000002

#define INIT_CACHE_STRUCT   0x00000004

#define INIT_DEBUG_MEMORY   0x00000008

#define INIT_TIMERS         0x00000010

#define WORK_BUFFER_SIZE  256


#define IPSEC_REG_KEY                       L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\IPSEC"

#define IPSEC_REG_PARAM_ENABLE_OFFLOAD      L"EnableOffload"
#define IPSEC_REG_PARAM_SA_IDLE_TIME        L"SAIdleTime"
#define IPSEC_REG_PARAM_EVENT_QUEUE_SIZE    L"EventQueueSize"
#define IPSEC_REG_PARAM_LOG_INTERVAL        L"LogInterval"
#define IPSEC_REG_PARAM_REKEY_TIME          L"RekeyTime"
#define IPSEC_REG_PARAM_CACHE_SIZE          L"CacheSize"
#define IPSEC_REG_PARAM_SA_HASH_SIZE        L"SAHashSize"
#define IPSEC_REG_PARAM_NO_DEFAULT_EXEMPT   L"NoDefaultExempt"
#define IPSEC_REG_PARAM_ENABLE_DIAGNOSTICS  L"EnableDiagnostics"
#define IPSEC_REG_PARAM_OPERATION_MODE      L"OperationMode"

//
// Enable offload.
//
#define IPSEC_DEFAULT_ENABLE_OFFLOAD    1
#define IPSEC_MIN_ENABLE_OFFLOAD        0
#define IPSEC_MAX_ENABLE_OFFLOAD        1

//
// SA idle time.
//
#define IPSEC_DEFAULT_SA_IDLE_TIME      (5 * 60)
#define IPSEC_MIN_SA_IDLE_TIME          (5 * 60)
#define IPSEC_MAX_SA_IDLE_TIME          (60 * 60)

//
// Log interval.
//
#define IPSEC_DEFAULT_LOG_INTERVAL      (60 * 60)
#define IPSEC_MIN_LOG_INTERVAL          (60)
#define IPSEC_MAX_LOG_INTERVAL          (24 * 60 * 60)

//
// Event queue size.
//
#define IPSEC_DEFAULT_EVENT_QUEUE_SIZE  50
#define IPSEC_MIN_EVENT_QUEUE_SIZE      10
#define IPSEC_MAX_EVENT_QUEUE_SIZE      500

//
// Rekey time.
//
#define IPSEC_DEFAULT_REKEY             600
#define IPSEC_MIN_REKEY                 300
#define IPSEC_MAX_REKEY                 1500

//
// No kerberos exempt.
//
#define IPSEC_DEFAULT_NO_DEFAULT_EXEMPT 0
#define IPSEC_MIN_NO_DEFAULT_EXEMPT     0
#define IPSEC_MAX_NO_DEFAULT_EXEMPT     3

#define IPSEC_DIAGNOSTIC_ENABLE_LOG         0x00000001
#define IPSEC_DIAGNOSTIC_INBOUND            0x00000002
#define IPSEC_DIAGNOSTIC_OUTBOUND           0x00000004

#define IPSEC_DEFAULT_ENABLE_DIAGNOSTICS 0
#define IPSEC_MIN_ENABLE_DIAGNOSTICS     0
#define IPSEC_MAX_ENABLE_DIAGNOSTICS        0x00000007


//
// First level (IP header based) cache size.
//
#define IPSEC_DEFAULT_CACHE_SIZE        64
#define IPSEC_DEFAULT_AS_CACHE_SIZE     1024
#define IPSEC_MIN_CACHE_SIZE            64
#define IPSEC_MAX_CACHE_SIZE            4096

//
// Size of the <SPI, Dest> hash table for inbound SAs.
//
#define IPSEC_DEFAULT_SA_HASH_SIZE      64
#define IPSEC_DEFAULT_AS_SA_HASH_SIZE   1024
#define IPSEC_MIN_SA_HASH_SIZE          64
#define IPSEC_MAX_SA_HASH_SIZE          4096


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
IPSecUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
IPSecDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
IPSecBindToIP(
    );

NTSTATUS
IPSecUnbindFromIP(
    );

NTSTATUS
IPSecUnbindSendFromIP(
    );

NTSTATUS
OpenRegKey(
    PHANDLE          HandlePtr,
    PWCHAR           KeyName
    );

NTSTATUS
GetRegDWORDValue(
    HANDLE           KeyHandle,
    PWCHAR           ValueName,
    PULONG           ValueData
    );

NTSTATUS
GetRegStringValue(
    HANDLE                         KeyHandle,
    PWCHAR                          ValueName,
    PKEY_VALUE_PARTIAL_INFORMATION *ValueData,
    PUSHORT                         ValueSize
    );

NTSTATUS
GetRegMultiSZValue(
    HANDLE           KeyHandle,
    PWCHAR           ValueName,
    PUNICODE_STRING  ValueData
    );

VOID
IPSecReadRegistry(
    );

NTSTATUS
IPSecGeneralInit(
    );

NTSTATUS
IPSecGeneralFree(
    );

NTSTATUS
IPSecFreeConfig(
    );

NTSTATUS
IPSecInitMdlPool(
    );

VOID
IPSecDeinitMdlPool(
    );

NTSTATUS
IPSecQuiesce(
    );

BOOLEAN
AllocateCacheStructures(
    );

VOID
FreeExistingCache(
    );

VOID
FreePatternDbase(
    );

SIZE_T
IPSecCalculateBufferSize(
    IN SIZE_T BufferDataSize
    );

VOID
IPSecInitializeBuffer(
    IN PIPSEC_LA_BUFFER IPSecBuffer,
    IN SIZE_T BufferDataSize
    );

PVOID
IPSecAllocateBufferPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

PIPSEC_LA_BUFFER
IPSecGetBuffer(
    IN CLONG BufferDataSize,
    IN ULONG Tag
    );

VOID
IPSecReturnBuffer (
    IN PIPSEC_LA_BUFFER IPSecBuffer
    );

NTSTATUS
IPSecWriteEvent(
    PDRIVER_OBJECT IPSecDriverObject,
    IN ULONG    EventCode,
    IN NTSTATUS NtStatusCode,
    IN ULONG    OffloadStatus,
    IN ULONG    ExtraStatus1,
    IN ULONG    ExtraStatus2,
    IN PVOID    RawDataBuffer,
    IN USHORT   RawDataLength,
    IN USHORT   NumberOfInsertionStrings,
    ...
    );

VOID
IPSecLogEvents(
    IN  PVOID   Context
    );

VOID
IPSecBufferEvent(
    IN  IPAddr  Addr,
    IN  ULONG   EventCode,
    IN  ULONG   UniqueEventValue,
    IN  BOOLEAN fBufferEvent
    );

NTSTATUS
CopyOutboundPacketToBuffer(
    IN PUCHAR pIPHeader,
    IN PVOID pData,
    OUT PUCHAR * pPacket,
    OUT ULONG * PacketSize
    );

NTSTATUS
CopyInboundPacketToBuffer(
    IN PUCHAR pIPHeader,
    IN PVOID pData,
    OUT PUCHAR * pPacket,
    OUT ULONG * PacketSize
    );

VOID
IPSecBufferPacketDrop(
    IN  PUCHAR              pIPHeader,
    IN  PVOID               pData,
    IN OUT PULONG           pIpsecFlags,
    IN  PIPSEC_DROP_STATUS  pDropStatus
    );

VOID
IPSecQueueLogEvent(
    VOID
    );

#if FIPS
BOOLEAN
IPSecFipsInitialize(
    VOID
    );
#endif

BOOLEAN
IPSecCryptoInitialize(
    VOID
    );

BOOLEAN
IPSecCryptoDeinitialize(
    VOID
    );

NTSTATUS
IPSecRegisterProtocols(
    PIPSEC_REGISTER_PROTOCOL pIpsecRegisterProtocol
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\ah.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    ah.c

Abstract:

    This module contains the code to create/verify Authentication Headers.

Author:

    Sanjay Anand (SanjayAn) 2-January-1997
    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#include    "precomp.h"


//
// This array assumes one-to-one correspondence with the algoIds and
// their order in ipsec.h.
//
#ifndef _TEST_PERF
AUTH_ALGO  auth_algorithms[] = {
{ ah_nullinit, ah_nullupdate, ah_nullfinish, MD5DIGESTLEN},
{ ah_hmacmd5init, ah_hmacmd5update, ah_hmacmd5finish, MD5DIGESTLEN},
{ ah_hmacshainit, ah_hmacshaupdate, ah_hmacshafinish, A_SHA_DIGEST_LEN},
};
#else
AUTH_ALGO  auth_algorithms[] = {
{ ah_nullinit, ah_nullupdate, ah_nullfinish, MD5DIGESTLEN},
{ ah_nullinit, ah_nullupdate, ah_nullfinish, MD5DIGESTLEN},
{ ah_nullinit, ah_nullupdate, ah_nullfinish, A_SHA_DIGEST_LEN},
};
#endif


NTSTATUS
IPSecCreateAH(
    IN      PUCHAR          pIPHeader,
    IN      PVOID           pData,
    IN      PSA_TABLE_ENTRY pSA,
    IN      ULONG           Index,
    OUT     PVOID           *ppNewData,
    OUT     PVOID           *ppSCContext,
    OUT     PULONG          pExtraBytes,
    IN      ULONG           HdrSpace,
    IN      BOOLEAN         fSrcRoute,
    IN      BOOLEAN         fCryptoOnly
    )
/*++

Routine Description:

    Create the AH, given the packet. On the send side.

Arguments:

    pIPHeader - points to start of IP header.

    pData - points to the data after the IP header. PNDIS_BUFFER

    pSA - Sec. Assoc. entry

    ppNewData - the new MDL chain to be used by TCPIP

    ppSCContext - send complete context used to clean up IPSEC headers

    pExtraBytes - the header expansion caused by this IPSEC header

Return Value:

    STATUS_SUCCESS
    Others:
        STATUS_INSUFFICIENT_RESOURCES
        STATUS_UNSUCCESSFUL (error in algo.)

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PNDIS_BUFFER    pAHBuffer;
    PNDIS_BUFFER    pHdrBuf = NULL;
    PNDIS_BUFFER    pOptBuf = NULL;
    AH          UNALIGNED         *pAH;
    IPHeader UNALIGNED * pIPH;
    ULONG       hdrLen;
    PIPSEC_SEND_COMPLETE_CONTEXT pContext;
    PAUTH_ALGO  pAlgo;
    ULONG       ahLen;
    ULONG       ipNext;
    IPHeader UNALIGNED * pIPH2;
    UCHAR       pAHData[MAX_AH_OUTPUT_LEN];
    ULONG       totalBytes = 0;
    ULONG       saveFlags = 0;
    ULONG       Seq;
    USHORT      IPLength;   
    PNDIS_BUFFER    pSaveDataLinkage = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);
    PNDIS_BUFFER    pSaveOptLinkage = NULL;
    BOOLEAN fOuterAH = ((pSA->sa_Flags & FLAGS_SA_TUNNEL) &&
                        (((Index == 1) && !pSA->COMP_ALGO(0)) || (Index == 2)));
    BOOLEAN fTunnel = ((pSA->sa_Flags & FLAGS_SA_TUNNEL) &&
                       ((Index == 0) || ((Index == 1) && pSA->COMP_ALGO(0))));
    BOOLEAN fMuteDest = fSrcRoute && !fTunnel;

    IPSEC_DEBUG(AH, ("Entering IPSecCreateAH\n"));

#if DBG
    IPSEC_DEBUG(MDL, ("Entering IPSecCreateAH\n"));
    IPSEC_PRINT_CONTEXT(*ppSCContext);
    IPSEC_PRINT_MDL(pData);
#endif

    ASSERT(pSA->sa_Operation[Index] == Auth);

    if (pSA->INT_ALGO(Index) > NUM_AUTH_ALGOS) {
        return  STATUS_INVALID_PARAMETER;
    }
    pAlgo = &(auth_algorithms[pSA->INT_ALGO(Index)]);

    ahLen = sizeof(AH) + pSA->sa_TruncatedLen * sizeof(UCHAR);

    //
    // If ESP was done previously, then dont alloc the context since we
    // can use the one alloced in ESP processing
    //
    if (*ppSCContext == NULL) {
        pContext = IPSecAllocateSendCompleteCtx(IPSEC_TAG_AH);

        if (!pContext) {
            IPSEC_DEBUG(AH, ("Failed to alloc. SendCtx\n"));
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        IPSEC_INCREMENT(g_ipsec.NumSends);

        IPSecZeroMemory(pContext, sizeof(IPSEC_SEND_COMPLETE_CONTEXT));

#if DBG
        RtlCopyMemory(pContext->Signature, "ISC1", 4);
#endif
        *ppSCContext = pContext;
    } else {
        //
        // Piggybacking on ESP Context
        //
        pContext = *ppSCContext;
        saveFlags = pContext->Flags;
    }

    //
    // Get buffer for AH since no space reserved in the stack.  Allocate enough for
    // the full hash, but hack the len to only truncated length.
    //
    IPSecAllocateBuffer(&status,
                        &pAHBuffer,
                        (PUCHAR *)&pAH,
                        ahLen+(pAlgo->OutputLen - pSA->sa_TruncatedLen),
                        IPSEC_TAG_AH);

    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(AH, ("Failed to alloc. AH MDL\n"));
        pContext->Flags = saveFlags;
        return status;
    }

    NdisAdjustBufferLength(pAHBuffer, ahLen);

    pIPH = (IPHeader UNALIGNED *)pIPHeader;
    hdrLen = (pIPH->iph_verlen & (UCHAR)~IP_VER_FLAG) << 2;

    if (fTunnel) {
        PNDIS_BUFFER    pSrcOptBuf;
        PUCHAR          pOpt;
        PUCHAR          pSrcOpt;
        ULONG           optLen = 0;

        IPSEC_DEBUG(AH, ("AH Tunnel mode...\n"));

        //
        // Allocate an MDL for the new cleartext IP  header
        //
        IPSecAllocateBuffer(&status,
                            &pHdrBuf,
                            (PUCHAR *)&pIPH2,
                            sizeof(IPHeader),
                            IPSEC_TAG_AH);

        if (!NT_SUCCESS(status)) {
            NTSTATUS    ntstatus;
            IPSEC_DEBUG(AH, ("Failed to alloc. PAD MDL\n"));
            IPSecFreeBuffer(&ntstatus, pAHBuffer);
            pContext->Flags = saveFlags;
            return status;
        }

        *pExtraBytes += ahLen + sizeof(IPHeader);

        //
        // if we are going to fragment, and were tunneling, then, copy over the options, if present.
        // Also, use the original IP header on the outside and the new fabricated on the inside.
        // This is to make sure we free headers appropriately on the send completes.
        //
        //

        //
        // Now hookup the MDLs
        //
        pContext->Flags |= SCF_AH_TU;
        pContext->AHTuMdl = pAHBuffer;
        pContext->PrevTuMdl = (PNDIS_BUFFER)pData;
        pContext->OriTuMdl = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);

        NDIS_BUFFER_LINKAGE(pAHBuffer) = pHdrBuf;

        if (hdrLen > sizeof(IPHeader)) {
            if (HdrSpace < *pExtraBytes) {

                IPSEC_DEBUG(AH, ("Going to frag.\n"));

                pSrcOptBuf = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);
                pSaveOptLinkage = NDIS_BUFFER_LINKAGE(pSrcOptBuf);
                IPSecQueryNdisBuf(pSrcOptBuf, &pSrcOpt, &optLen);
                IPSecAllocateBuffer(&status,
                                    &pOptBuf,
                                    (PUCHAR *)&pOpt,
                                    hdrLen - sizeof(IPHeader),
                                    IPSEC_TAG_AH);

                if (!NT_SUCCESS(status)) {
                    NTSTATUS    ntstatus;
                    IPSEC_DEBUG(AH, ("Failed to alloc. PAD MDL\n"));
                    NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData) = pSaveDataLinkage;
                    IPSecFreeBuffer(&ntstatus, pAHBuffer);
                    IPSecFreeBuffer(&ntstatus, pHdrBuf);
                    pContext->Flags = saveFlags;
                    return status;
                }

                RtlCopyMemory(pOpt, pSrcOpt, hdrLen-sizeof(IPHeader));
                pContext->OptMdl = pOptBuf;

                IPSEC_DEBUG(AH, ("Copying options. S: %lx, D: %lx\n", pSrcOptBuf, pOptBuf));

                //
                // replace the original Opt Mdl with ours.
                //
                NDIS_BUFFER_LINKAGE(pOptBuf) = NDIS_BUFFER_LINKAGE(pSrcOptBuf);
                NDIS_BUFFER_LINKAGE(pHdrBuf) = pOptBuf;

                IPSEC_DEBUG(AH, ("Options; pointed Hdrbuf: %lx to pOptBuf: %lx\n", pHdrBuf, pOptBuf));
                *pExtraBytes += hdrLen-sizeof(IPHeader);

            } else {
                IPSEC_DEBUG(AH, ("Options; pointed Hdrbuf: %lx to link(pData): %lx\n", pHdrBuf, NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData)));

                NDIS_BUFFER_LINKAGE(pHdrBuf) = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);
            }
        } else {
            IPSEC_DEBUG(AH, ("No options; pointed Hdrbuf: %lx to link(pData): %lx\n", pHdrBuf, NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData)));

            NDIS_BUFFER_LINKAGE(pHdrBuf) = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);
        }

        NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData) = pAHBuffer;

        //
        // xsum the new IP header since we expect that to be the case
        // at this stage in tpt mode.
        //
        RtlCopyMemory(pIPH2, pIPH, sizeof(IPHeader));

        //
        // no options in the outer header; reset the len.
        //
        pIPH->iph_verlen = IP_VERSION + (sizeof(IPHeader) >> 2);

        //
        // also reset the frag. params.
        //
        pIPH->iph_offset &= ~(IP_MF_FLAG | IP_OFFSET_MASK);

        ASSERT(pSA->sa_TunnelAddr);

        //
        // Tunnel starts here; replace dest addr to point to Tunnel end if specified
        // else tunnel ends at final dest
        //
        pIPH->iph_dest = pSA->sa_TunnelAddr;

        //
        // The first pended packet on a gateway (proxy negotiating for two subnets)
        // would come via the transmit path. Hence the source address would not be
        // kosher. We need to replace the src address in that case also.
        // We get this from the corresponding inbound SA's tunnel addr.
        //
        pIPH->iph_src = pSA->sa_SrcTunnelAddr;

        pIPH->iph_id = (ushort) TCPIP_GEN_IPID();
        pIPH->iph_xsum = 0;
        pIPH->iph_xsum = ~xsum(pIPH, sizeof(IPHeader));

        //
        // Set up headers so CreateHash works as in Tpt mode.
        //
        pIPHeader = (PUCHAR)pIPH;
        *ppNewData = (PVOID)pData;
        ipNext = ((UNALIGNED IPHeader *)pIPHeader)->iph_protocol;
        pAH->ah_next = (UCHAR)IP_IN_IP;
    } else {
        *pExtraBytes += ahLen;

        if (hdrLen > sizeof(IPHeader)) {
            //
            // Options present - chain AH after options
            //
            if (fOuterAH) {
                pContext->Flags |= SCF_AH_2;
                pContext->OriAHMdl2 = NDIS_BUFFER_LINKAGE(NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData));
                pContext->PrevAHMdl2 = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);
                pAHBuffer->Next = pContext->OriAHMdl2;
            } else {
                pContext->Flags |= SCF_AH;
                pContext->OriAHMdl = NDIS_BUFFER_LINKAGE(NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData));
                pContext->PrevMdl = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);
                pAHBuffer->Next = pContext->OriAHMdl;
            }
            NDIS_BUFFER_LINKAGE(NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData)) = pAHBuffer;
        } else {
            //
            // Chain the AH buffer after IP header
            //
            if (fOuterAH) {
                pContext->Flags |= SCF_AH_2;
                pContext->OriAHMdl2 = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);
                pContext->PrevAHMdl2 = (PNDIS_BUFFER)pData;
                pAHBuffer->Next = pContext->OriAHMdl2;
            } else {
                pContext->Flags |= SCF_AH;
                pContext->OriAHMdl = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);
                pContext->PrevMdl = (PNDIS_BUFFER)pData;
                pAHBuffer->Next = pContext->OriAHMdl;
            }
            NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData) = pAHBuffer;
        }
        if (fOuterAH) {
            pContext->AHMdl2 = pAHBuffer;
        } else {
            pContext->AHMdl = pAHBuffer;
        }

        pAH->ah_next = ((UNALIGNED IPHeader *)pIPHeader)->iph_protocol;
    }

    //
    // Initialize the other fields of the AH header
    //
    pAH->ah_len = (UCHAR)((pSA->sa_TruncatedLen + pSA->sa_ReplayLen) >> 2);
    pAH->ah_reserved = 0;
    pAH->ah_spi = HOST_TO_NET_LONG(pSA->sa_OtherSPIs[Index]);
    Seq = IPSEC_INCREMENT(pSA->sa_ReplaySendSeq[Index]);
    pAH->ah_replay = HOST_TO_NET_LONG(Seq);

    //
    // Update the IP total length to reflect the AH header
    //
    IPLength = NET_SHORT(pIPH->iph_length) + (USHORT)ahLen;
    if (fTunnel) {
        IPLength += sizeof(IPHeader);
    }

    UpdateIPLength(pIPH, NET_SHORT(IPLength));
    UpdateIPProtocol(pIPH, PROTOCOL_AH);

    ADD_TO_LARGE_INTEGER(
        &pSA->sa_Stats.AuthenticatedBytesSent,
        NET_SHORT(pIPH->iph_length));

    ADD_TO_LARGE_INTEGER(
        &g_ipsec.Statistics.uAuthenticatedBytesSent,
        NET_SHORT(pIPH->iph_length));

    //
    // Generate the Hash.
    //
    if (!fCryptoOnly) {
        status = IPSecGenerateHash( pIPHeader,
                                    (PVOID)pData,
                                    pSA,
                                    (PUCHAR)(pAH + 1),
                                    fMuteDest,
                                    FALSE,          // not on recv path
                                    pAlgo,
                                    Index);
        if (!NT_SUCCESS(status)) {
            NTSTATUS    ntstatus;
            IPSEC_DEBUG(AH, ("Failed to hash, pAH: %lx\n", pAH));
            NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData) = pSaveDataLinkage;
            if (pSaveOptLinkage) {
                NDIS_BUFFER_LINKAGE(NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData)) = pSaveOptLinkage;
            }
            IPSecFreeBuffer(&ntstatus, pAHBuffer);
            if (pHdrBuf) {
                IPSecFreeBuffer(&ntstatus, pHdrBuf);
            }
            if (pOptBuf) {
                IPSecFreeBuffer(&ntstatus, pOptBuf);
            }
            pContext->Flags = saveFlags;
            *ppNewData = NULL;
            return status;
        }
    } else {
        //
        // Zero out the hash.
        //
        IPSecZeroMemory((PUCHAR)(pAH + 1), pSA->sa_TruncatedLen);
    }

    //
    // Bump up the bytes transformed count.
    //
    ADD_TO_LARGE_INTEGER(
        &pSA->sa_TotalBytesTransformed,
        NET_SHORT(pIPH->iph_length));

    //
    // Return modified packet.
    //
    IPSEC_DEBUG(AH, ("Exiting IPSecCreateAH, ahLen: %lx, status: %lx\n", ahLen, status));

#if DBG
    IPSEC_DEBUG(MDL, ("Exiting IPSecCreateAH\n"));
    IPSEC_PRINT_CONTEXT(*ppSCContext);
    if (*ppNewData) {
        IPSEC_PRINT_MDL(*ppNewData);
    }
    else {
        IPSEC_PRINT_MDL(pData);
    }
#endif

    return STATUS_SUCCESS;
}


NTSTATUS
IPSecVerifyAH(
    IN      PUCHAR          *pIPHeader,
    IN      PVOID           pData,
    IN      PSA_TABLE_ENTRY pSA,
    IN      ULONG           Index,
    OUT     PULONG          pExtraBytes,
    IN      BOOLEAN         fSrcRoute,
    IN      BOOLEAN         fCryptoDone,
    IN      BOOLEAN         fFastRcv
    )
/*++

Routine Description:

    Verify the AH, given the packet. If AH kosher, strips off the AH from
    pData.

Arguments:

    pIPHeader - points to start of IP header.

    pData - points to the data after the IP header.

    pSA - Sec. Assoc. entry

    pExtraBytes - out param to inform IP on recv path how many bytes IPSEC took off.

Return Value:

    STATUS_SUCCESS
    Others:
        STATUS_UNSUCCESSFUL (packet not kosher - bad AH)
        STATUS_INSUFFICIENT_RESOURCES

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PUCHAR      pPyld;
    ULONG       Len;
    LONG        ahLen;
    LONG        totalLen;
    UCHAR       Buf[MAX_AH_OUTPUT_LEN];
    PUCHAR      pAHData = Buf;
	IPHeader UNALIGNED *pIPH = (IPHeader UNALIGNED *)*pIPHeader;
    ULONG       extraBytes = 0;
    ULONG       hdrLen;
    PAUTH_ALGO  pAlgo;
    USHORT      FilterFlags;
    BOOLEAN fTunnel = ((pSA->sa_Flags & FLAGS_SA_TUNNEL) &&
                       ((Index == 0) ||
                        ((Index == 1) && (pSA->sa_Operation[0] == Compress))));

    IPSEC_DEBUG(AH, ("Entering IPSecVerifyAH\n"));

    ASSERT(pSA->sa_Operation[Index] == Auth);

    if (pSA->INT_ALGO(Index) > NUM_AUTH_ALGOS) {
        return  STATUS_INVALID_PARAMETER;
    }

    hdrLen = (pIPH->iph_verlen & (UCHAR)~IP_VER_FLAG) << 2;

    pAlgo = &(auth_algorithms[pSA->INT_ALGO(Index)]);

    ahLen = sizeof(AH) + pSA->sa_TruncatedLen * sizeof(UCHAR);

    IPSEC_GET_TOTAL_LEN_RCV_BUF(pData, &totalLen);

    //
    // Do we have enough in the buffer?
    //
    if (totalLen < ahLen) {
        return  STATUS_INVALID_PARAMETER;
    }

    //
    // Compare the hash with the AH from packet
    // First buffer has the AH
    //
    IPSecQueryRcvBuf(pData, &pPyld, &Len);

    //
    // Size OK?
    //
    if (((UNALIGNED AH *)pPyld)->ah_len !=
            (UCHAR)((pSA->sa_TruncatedLen + pSA->sa_ReplayLen) >> 2)) {
        IPSEC_DEBUG(AH, ("Failed size check: in: %x, need: %x\n",
                        ((UNALIGNED AH *)pPyld)->ah_len,
                        (UCHAR)((pSA->sa_TruncatedLen + pSA->sa_ReplayLen) >> 2)));
        return  STATUS_INVALID_PARAMETER;
    }

    //
    // Generate the Hash
    //
    if (!fCryptoDone) {
        status = IPSecGenerateHash( *pIPHeader,
                                    pData,
                                    pSA,
                                    pAHData,
                                    fSrcRoute,
                                    TRUE,
                                    pAlgo,
                                    Index); // on recv path

        if (!NT_SUCCESS(status)) {
            IPSEC_DEBUG(AH, ("Failed to hash, pData: %lx\n", pData));
            return status;
        }

        if (!IPSecEqualMemory(  pAHData,
                                pPyld + sizeof(AH),
                                pSA->sa_TruncatedLen)) {

            IPSecBufferEvent(   pIPH->iph_src,
                                EVENT_IPSEC_AUTH_FAILURE,
                                1,
                                TRUE);

            IPSEC_DEBUG(AH, ("Failed to compare, pPyld: %lx, pAHData: %lx\n", pPyld, pAHData));
            IPSEC_DEBUG(GENHASH, ("AHData: %lx-%lx-%lx\n",
                        *(ULONG *)&(pAHData)[0],
                        *(ULONG *)&(pAHData)[4],
                        *(ULONG *)&(pAHData)[8]));
            IPSEC_DEBUG(GENHASH, ("PyldHash: %lx-%lx-%lx\n",
                        *(ULONG *)&((UCHAR *)(pPyld + sizeof(AH)))[0],
                        *(ULONG *)&((UCHAR *)(pPyld + sizeof(AH)))[4],
                        *(ULONG *)&((UCHAR *)(pPyld + sizeof(AH)))[8]));
            IPSEC_INC_STATISTIC(dwNumPacketsNotAuthenticated);

            return IPSEC_INVALID_AH;
        }
    }

    ADD_TO_LARGE_INTEGER(
        &pSA->sa_Stats.AuthenticatedBytesReceived,
        NET_SHORT(pIPH->iph_length));

    ADD_TO_LARGE_INTEGER(
        &g_ipsec.Statistics.uAuthenticatedBytesReceived,
        NET_SHORT(pIPH->iph_length));

    //
    // Check the replay window
    //
    status=IPSecChkReplayWindow(
        NET_TO_HOST_LONG(((UNALIGNED AH *)pPyld)->ah_replay),
        pSA,
        Index); 
    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(AH, ("Replay check failed, pPyld: %lx, pAHData: %lx\n", pPyld, pAHData));
        IPSEC_INC_STATISTIC(dwNumPacketsWithReplayDetection);
        return status;
    }

    IPSEC_DEBUG(AH, ("IP Len: %lx\n", pIPH->iph_length));

    pIPH->iph_length = NET_SHORT(NET_SHORT(pIPH->iph_length) - (USHORT)ahLen);

    IPSEC_DEBUG(AH, ("IP Len: %lx\n", pIPH->iph_length));

    //
    // Restore the protocol from AH header
    //
    pIPH->iph_protocol = ((UNALIGNED AH *)pPyld)->ah_next;

    IPSEC_DEBUG(AH, ("Matched!! Restored protocol %x\n", pIPH->iph_protocol));

    //
    // Remove the AH from the packet
    //
    IPSEC_SET_OFFSET_IN_BUFFER(pData, ahLen);

    //
    // Move the IP header forward for filter/firewall hook, fast path only.
    //
    if (fFastRcv) {
        IPSecMoveMemory(((PUCHAR)pIPH) + ahLen, (PUCHAR)pIPH, hdrLen);
        *pIPHeader=(PUCHAR)pIPH+ahLen;
        pIPH = (IPHeader UNALIGNED *)*pIPHeader;
    }

    extraBytes += ahLen;

    //
    // Bump up the bytes transformed count.
    //
    ADD_TO_LARGE_INTEGER(
        &pSA->sa_TotalBytesTransformed,
        NET_SHORT(pIPH->iph_length));

    if (fTunnel) {
        if (pIPH->iph_protocol != IP_IN_IP) {
            IPSEC_DEBUG(AH, ("BAD protocol in IP: %x\n", pIPH->iph_protocol));
            return STATUS_INVALID_PARAMETER;
        }
    }

    *pExtraBytes += extraBytes;

    IPSEC_DEBUG(AH, ("Exiting IPSecVerifyAH\n"));

    return status;
}


NTSTATUS
IPSecGenerateHash(
    IN      PUCHAR          pIPHeader,
    IN      PVOID           pData,
    IN      PSA_TABLE_ENTRY pSA,
    IN      PUCHAR          pAHData,
    IN      BOOLEAN         fMuteDest,
    IN      BOOLEAN         fIncoming,
    IN      PAUTH_ALGO      pAlgo,
    IN      ULONG           Index
    )
/*++

Routine Description:

Arguments:

    pIPHeader - points to start of IP header.

    pData - points to the entire IP datagram, starting at the IP Header

    pSA - Sec. Assoc. entry

    pAHData - buffer to contain the generated hash

    fIncoming - TRUE if on recv path.

    pAlgo - the auth_algo being used

Return Value:

    STATUS_SUCCESS
    Others:
        STATUS_UNSUCCESSFUL (packet not kosher - bad AH)
        STATUS_INSUFFICIENT_RESOURCES

--*/
{
    ULONG   numBytesPayload;
    ULONG   i;
    PUCHAR  pPayload;
    IPHeader    UNALIGNED   *pIPH = (UNALIGNED IPHeader *)pIPHeader;
    PUCHAR      pOptions;
    PNDIS_BUFFER    pBuf = (PNDIS_BUFFER)pData;
    ULONG       hdrLen;
    ULONG       ahLen;
    NTSTATUS    status;
    ALGO_STATE  State = {0};
    BOOLEAN fTunnel = ( (pSA->sa_Flags & FLAGS_SA_TUNNEL) &&
                        ((Index == 0) ||
                            ((Index == 1) && (pSA->sa_Operation[0] == Compress))));

    //
    // These are saved since they can change enroute
    //
    //
    // Scratch array used for AH calculation
    //
    UCHAR       zero[MAX_IP_OPTION_SIZE];
	UCHAR		savetos;				// Type of service.
	USHORT		saveoffset;				// Flags and fragment offset.
	UCHAR		savettl;				// Time to live.
	USHORT		savexsum;				// Header checksum.
	IPAddr		savedest;				// Dest address.

    IPSEC_DEBUG(AH, ("Entering IPSecGenerateHash\n"));

    ahLen = sizeof(AH) + pSA->sa_TruncatedLen * sizeof(UCHAR);

    State.as_sa = pSA;
    IPSecZeroMemory(zero, sizeof(zero));

    status = pAlgo->init(&State, Index);

    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(AH, ("init failed: %lx\n", status));
    }

    //
    // Save, then zero out fields that can change enroute
    //
    savetos = pIPH->iph_tos;
    saveoffset = pIPH->iph_offset;
    savettl = pIPH->iph_ttl;
    savexsum = pIPH->iph_xsum;

    pIPH->iph_tos = 0;
    pIPH->iph_offset = 0;
    pIPH->iph_ttl = 0;
    pIPH->iph_xsum = 0;

    //
    // Mute dest address as well if source routing
    //
    if (fMuteDest) {
        savedest = pIPH->iph_dest;
        pIPH->iph_dest = 0;
    }

    //
    // Call MD5 to create the header hash
    //
    pAlgo->update(&State, pIPHeader, sizeof(IPHeader));

#if DBG
    if (fIncoming) {
        IPSEC_DEBUG(GENHASH, ("IPHeader to Hash: %lx-%lx-%lx-%lx-%lx\n",
                    *(ULONG *)&(pIPHeader)[0],
                    *(ULONG *)&(pIPHeader)[4],
                    *(ULONG *)&(pIPHeader)[8],
                    *(ULONG *)&(pIPHeader)[12],
                    *(ULONG *)&(pIPHeader)[16]));
    }
#endif

    //
    // Restore the zeroed fields
    //
    pIPH->iph_tos = savetos;
    pIPH->iph_offset = saveoffset;
    pIPH->iph_ttl = savettl;
    pIPH->iph_xsum = savexsum;

    //
    // Restore dest address as well for source routing
    //
    if (fMuteDest) {
        pIPH->iph_dest = savedest;
    }

    //
    // Now, do the options if they exist
    //
    hdrLen = (pIPH->iph_verlen & (UCHAR)~IP_VER_FLAG) << 2;

    if (hdrLen > sizeof(IPHeader)) {
        UCHAR   cLength;
        ULONG   uIndex = 0;
        ULONG   uOptLen = hdrLen - sizeof(IPHeader);

        ASSERT(!fTunnel);

        if (fIncoming) {
            pOptions = (PUCHAR)(pIPH + 1);
        } else {
            //
            // Options are in second MDL... on send side
            //
            pBuf = NDIS_BUFFER_LINKAGE(pBuf);
            IPSecQueryNdisBuf(pBuf, &pOptions, &uOptLen);
        }

        IPSEC_DEBUG(AH, ("Got options: %lx\n", pOptions));

        //
        // Some options may need to be zeroed out...
        //
        while (uIndex < uOptLen) {
            switch (*pOptions) {
            case IP_OPT_EOL:
                pAlgo->update(&State, zero, 1);
                uIndex = uOptLen;
                break;

            //
            // Zeroed for AH calculation
            //
            case IP_OPT_NOP:
                pAlgo->update(&State, zero, 1);
                uIndex++;
                pOptions++;
                break;

            case IP_OPT_LSRR:
            case IP_OPT_SSRR:
            case IP_OPT_RR:
            case IP_OPT_TS:
                cLength = pOptions[IP_OPT_LENGTH];
                pAlgo->update(&State, zero, cLength);
                uIndex += cLength;
                pOptions += cLength;
                break;

            //
            // Assumed invariant; used for AH calc
            //
            case IP_OPT_ROUTER_ALERT:
            case IP_OPT_SECURITY:
            default:
                cLength = pOptions[IP_OPT_LENGTH];
                pAlgo->update(&State, pOptions, cLength);
                uIndex += cLength;
                pOptions += cLength;
                break;
            }
        }
    }

    //
    // Go over the remaining payload, creating the hash
    //
    // NOTE: We differentiate between the send and recv since the
    // buffer formats are different
    //
    if (fIncoming) {
        IPRcvBuf    *pBuf = (IPRcvBuf *)pData;
        ULONG       Len;
        LONG        remainLen;

        UCHAR UNALIGNED   *pPyld;

        //
        // First buffer shd be the AH itself
        //
        IPSecQueryRcvBuf(pBuf, &pPyld, &Len);

        //
        // Do the first portion of the header.
        //
        pAlgo->update(&State, pPyld, sizeof(AH));

#if DBG
    if (fIncoming) {
        IPSEC_DEBUG(GENHASH, ("AHHeader to Hash: %lx-%lx-%lx\n",
                    *(ULONG *)&(pPyld)[0],
                    *(ULONG *)&(pPyld)[4],
                    *(ULONG *)&(pPyld)[8]));
    }
#endif

        //
        // The authentication data should be considered as 0.
        // In our case, the data length is fixed at pSA->sa_TruncatedLen bytes
        //
        pAlgo->update(&State, zero, pSA->sa_TruncatedLen);

        //
        // Jump over the remaining AH: need to take care of situations
        // where ICV is chained (Raid 146275).
        //
        if (((LONG)Len - (LONG)ahLen) >= 0) {
            pPyld += ahLen;
            IPSEC_DEBUG(AH, ("Jumped over IPSEC res: %lx, len: %lx\n", pPyld, Len));

            //
            // Tpt header is right after AH
            //
            pAlgo->update(&State, pPyld, Len - ahLen);
        } else {
            //
            // Need to jump over ICV if it expands over multiple buffers
            //
            remainLen = pSA->sa_TruncatedLen - (Len - sizeof(AH));
            IPSEC_DEBUG(AH, ("Jumped over IPSEC res: %lx, remainlen: %lx\n", pPyld, remainLen));
            while (remainLen > 0 && (pBuf = IPSEC_BUFFER_LINKAGE(pBuf))) {
                IPSecQueryRcvBuf(pBuf, &pPyld, &Len);
                remainLen -= Len;
            }

            //
            // Do the possible partial data after AH
            //
            if (remainLen < 0 && pBuf) {
                pPyld += Len + remainLen;
                pAlgo->update(&State, pPyld, -remainLen);
            }
        }

        //
        // Now do the remaining chain
        //
        while (pBuf = IPSEC_BUFFER_LINKAGE(pBuf)) {
            IPSecQueryRcvBuf(pBuf, &pPyld, &Len);
            pAlgo->update(&State, pPyld, Len);
        }
    } else {
        UCHAR UNALIGNED   *pPyld;
        ULONG   Len;

        //
        // Second (or third if options present) buffer shd be the AH itself
        //
        pBuf = NDIS_BUFFER_LINKAGE(pBuf);
        IPSecQueryNdisBuf(pBuf, &pPyld, &Len);

        //
        // Do the first portion of the header.
        //
        pAlgo->update(&State, pPyld, sizeof(AH));

        //
        // The authentication data should be considered as 0.
        // In our case, the data length is fixed at pSA->sa_TruncatedLen bytes
        //
        pAlgo->update(&State, zero, pSA->sa_TruncatedLen);

        //
        // Skip over the remaining AH section
        //
        pPyld += ahLen;

        IPSEC_DEBUG(AH, ("Jumped over IPSEC Len: %lx, hdrlen: %lx\n", Len, hdrLen));

        pAlgo->update(&State, pPyld, Len - ahLen);

        //
        // Now do the remaining chain
        //
        while (pBuf = NDIS_BUFFER_LINKAGE(pBuf)) {
            IPSecQueryNdisBuf(pBuf, &pPyld, &Len);
            pAlgo->update(&State, pPyld, Len);
        }
    }

    pAlgo->finish(&State, pAHData, Index);

    //
    // Copy out the hash - get the truncated hash out, then zero out the rest
    //
    TRUNCATE(pAHData, pAHData, pSA->sa_TruncatedLen, MD5DIGESTLEN);

    IPSEC_DEBUG(AH, ("Exiting IPSecGenerateMD5\n"));

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\driver.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    driver.c

Abstract:

    This module contains the DriverEntry and other initialization
    code for the IPSEC module of the Tcpip transport.

Author:

    Sanjay Anand (SanjayAn) 2-January-1997
    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#include "precomp.h"


#pragma hdrstop


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, IPSecGeneralInit)
#pragma alloc_text(PAGE, IPSecDispatch)
#pragma alloc_text(PAGE, IPSecBindToIP)
#pragma alloc_text(PAGE, IPSecUnbindFromIP)
#pragma alloc_text(PAGE, IPSecFreeConfig)
#pragma alloc_text(PAGE, IPSecInitMdlPool)
#pragma alloc_text(PAGE, AllocateCacheStructures)
#pragma alloc_text(PAGE, FreeExistingCache)
#pragma alloc_text(PAGE, FreePatternDbase)
#pragma alloc_text(PAGE, OpenRegKey)
#pragma alloc_text(PAGE, GetRegDWORDValue)
#pragma alloc_text(PAGE, IPSecCryptoInitialize)
#pragma alloc_text(PAGE, IPSecCryptoDeinitialize)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine performs initialization of the IPSEC module.
    It creates the device object for the transport
    provider and performs other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

    RegistryPath - The name of IPSEC's node in the registry.

Return Value:

    The function value is the final status from the initialization operation.

--*/
{
    PDEVICE_OBJECT  deviceObject = NULL;
    WCHAR           deviceNameBuffer[] = DD_IPSEC_DEVICE_NAME;
    WCHAR           symbolicLinkBuffer[] = DD_IPSEC_SYM_NAME;
    UNICODE_STRING  symbolicLinkName;
    UNICODE_STRING  deviceNameUnicodeString;
    NTSTATUS        status;
    NTSTATUS        status1;

    //DbgBreakPoint();

    IPSEC_DEBUG(LOAD, ("Entering DriverEntry\n"));

    //
    // Init g_ipsec structure and read reg keys.
    //
    IPSecZeroMemory(&g_ipsec, sizeof(g_ipsec));
    IPSecReadRegistry();

    //
    // Create the device - do we need a device at all?
    //
    // Setup the handlers.
    //
    //
    // Initialize the driver object with this driver's entry points.
    //
    g_ipsec.IPSecDriverObject = DriverObject;

    DriverObject->MajorFunction [IRP_MJ_CREATE] =
    DriverObject->MajorFunction [IRP_MJ_CLOSE] =
    DriverObject->MajorFunction [IRP_MJ_CLEANUP] =
    DriverObject->MajorFunction [IRP_MJ_INTERNAL_DEVICE_CONTROL] =
    DriverObject->MajorFunction [IRP_MJ_DEVICE_CONTROL] = IPSecDispatch;

    DriverObject->DriverUnload = IPSecUnload;

    RtlInitUnicodeString (&deviceNameUnicodeString, deviceNameBuffer);

    status = IoCreateDevice(
                    DriverObject,
                    0,                          // DeviceExtensionSize
                    &deviceNameUnicodeString,   // DeviceName
                    FILE_DEVICE_NETWORK,        // DeviceType
                    FILE_DEVICE_SECURE_OPEN,    // DeviceCharacteristics
                    FALSE,                      // Exclusive
                    &deviceObject);             // *DeviceObject

    if (!NT_SUCCESS (status)) {
        IPSEC_DEBUG(LOAD, ("Failed to create device: %lx\n", status));

        LOG_EVENT(
            DriverObject,
            EVENT_IPSEC_CREATE_DEVICE_FAILED,
            1,
            1,
            &deviceNameUnicodeString.Buffer,
            0,
            NULL);

        goto err;
    }

    deviceObject->Flags |= DO_BUFFERED_IO;

    IPSecDevice = deviceObject;

    RtlInitUnicodeString (&symbolicLinkName, symbolicLinkBuffer);

    status = IoCreateSymbolicLink(&symbolicLinkName, &deviceNameUnicodeString);

    if (!NT_SUCCESS (status)) {
        IPSEC_DEBUG(LOAD, ("Failed to create symbolic link: %lx\n", status));

        LOG_EVENT(
            DriverObject,
            EVENT_IPSEC_CREATE_DEVICE_FAILED,
            2,
            1,
            &deviceNameUnicodeString.Buffer,
            0,
            NULL);

        IoDeleteDevice(DriverObject->DeviceObject);

        goto err;
    }

    //
    // General structs init here.
    // Allocates the SA Table etc.
    //
    status = IPSecGeneralInit();

    if (!NT_SUCCESS (status)) {
        IPSEC_DEBUG(LOAD, ("Failed to init general structs: %lx\n", status));

        //
        // Free the general structs and SA Table etc.
        //
        status1 = IPSecGeneralFree();

        if (!NT_SUCCESS (status1)) {
            IPSEC_DEBUG(LOAD, ("Failed to free config: %lx\n", status1));
        }

        LOG_EVENT(
            DriverObject,
            EVENT_IPSEC_NO_RESOURCES_FOR_INIT,
            1,
            0,
            NULL,
            0,
            NULL);

        IoDeleteSymbolicLink(&symbolicLinkName);

        IoDeleteDevice(DriverObject->DeviceObject);

        goto err;
    }

    //
    // Wait for TCP/IP to load and call IOCTL_IPSEC_SET_TCPIP_STATUS where we
    // would finish the initialization.
    //

    status = STATUS_SUCCESS;

    IPSEC_DEBUG(LOAD, ("Exiting DriverEntry; SUCCESS\n"));

err:
    return status;
}


VOID
IPSecUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Called when the driver is unloaded.

Arguments:

    DriverObject

Return Value:

    None

--*/
{
    UNICODE_STRING  IPSecLinkName;
    KIRQL           OldIrq;
    KIRQL           kIrql;
    NTSTATUS        status;
    INT             class;

    IPSEC_DEBUG(LOAD, ("Entering IPSecUnload\n"));

    //
    // Set IPSEC_DRIVER_UNLOADING bit.
    //
    IPSEC_DRIVER_UNLOADING() = TRUE;

    //
    // Stop the reaper timer.
    //
    IPSecStopTimer(&g_ipsec.ReaperTimer);

    //
    // Stop the EventLog timer.
    //
    IPSecStopTimer(&g_ipsec.EventLogTimer);

    //
    // Complete the Acquire Irp with error status
    //
    if (g_ipsec.AcquireInfo.Irp) {
        IPSEC_DEBUG(ACQUIRE, ("Unload: Completing Irp..\n"));
        if (g_ipsec.AcquireInfo.InMe) {
            IoAcquireCancelSpinLock(&g_ipsec.AcquireInfo.Irp->CancelIrql);
            IPSecAcquireIrpCancel(NULL, g_ipsec.AcquireInfo.Irp);
        }
    }

    //
    // Stop timers for all SAs (of all states)
    //
    IPSecStopSATimers();

    //
    // Wait for all timers to clear before going further
    //
    while (IPSEC_GET_VALUE(g_ipsec.NumTimers) != 0) {
        IPSEC_DELAY_EXECUTION();
    }

    //
    // Cleanup any larval SAs
    //
    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);
    ACQUIRE_LOCK(&g_ipsec.AcquireInfo.Lock, &OldIrq);
    IPSecFlushLarvalSAList();
    IPSecFlushSAExpirations();
    RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, OldIrq);
    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    //
    // Free the SA Table.
    //
    status = IPSecFreeConfig();

    if (!NT_SUCCESS (status)) {
        IPSEC_DEBUG(LOAD, ("Failed to free config: %lx\n", status));
    }

    //
    // Free the MDL pools and run down all buffered packets.
    //
    status = IPSecQuiesce();

    if (!NT_SUCCESS (status)) {
        IPSEC_DEBUG(LOAD, ("Failed to reach quiescent state: %lx\n", status));
    }

    //
    // Destroy timer structures
    //
    ACQUIRE_LOCK(&g_ipsec.TimerLock, &kIrql);

    for (class = 0; class < IPSEC_CLASS_MAX; class++) {
        ASSERT(g_ipsec.TimerList[class].TimerCount == 0);
        IPSecFreeMemory(g_ipsec.TimerList[class].pTimers);
    }

    RELEASE_LOCK(&g_ipsec.TimerLock, kIrql);

    IPSecCryptoDeinitialize();

#if GPC
    IPSecGpcDeinitialize();
#endif

    RtlInitUnicodeString(&IPSecLinkName, DD_IPSEC_SYM_NAME);

    IoDeleteSymbolicLink(&IPSecLinkName);

    IoDeleteDevice(DriverObject->DeviceObject);

    IPSEC_DEBUG(LOAD, ("Exiting IPSecUnload\n"));
}


NTSTATUS
IPSecDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
Routine Description:

    Dispatch Routine for the driver. Gets the current irp stack location, validates
    the parameters and routes the calls

Arguments:

    DeviceObject
    Irp

Return Value:

    Status as returned by the worker functions

--*/
{
    PIO_STACK_LOCATION  irpStack;
    PVOID               pvIoBuffer;
    LONG                inputBufferLength;
    LONG                outputBufferLength;
    ULONG               ioControlCode;
    NTSTATUS            status = STATUS_SUCCESS;
    LONG                dwSize = 0;

    PAGED_CODE();

    IPSEC_DEBUG(IOCTL, ("Entering IPSecDispath\n"));

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the input/output buffer and its length.
    //
    pvIoBuffer         = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    switch (irpStack->MajorFunction) {
        case IRP_MJ_CREATE: {
            IPSEC_DEBUG(IOCTL, ("IRP_MJ_CREATE\n"));
            break;
        }

        case IRP_MJ_CLOSE: {
            IPSEC_DEBUG(IOCTL, ("IRP_MJ_CLOSE\n"));
            break;
        }

        case IRP_MJ_DEVICE_CONTROL: {
            ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;

            IPSEC_DEBUG(IOCTL, ("IRP_MJ_DEVICE_CONTROL: %lx\n", ioControlCode));

            if (ioControlCode != IOCTL_IPSEC_SET_TCPIP_STATUS) {
                if (IPSEC_DRIVER_IS_INACTIVE()) {
                    status = STATUS_INVALID_DEVICE_STATE;
                    break;
                }

                if (!IPSecCryptoInitialize()) {
                    status = STATUS_CRYPTO_SYSTEM_INVALID;
                    break;
                }
            }

            IPSEC_INCREMENT(g_ipsec.NumIoctls);

            switch (ioControlCode) {
                case IOCTL_IPSEC_ADD_FILTER: {
                    PIPSEC_ADD_FILTER   pAddFilter = (PIPSEC_ADD_FILTER)pvIoBuffer;

                    IPSEC_DEBUG(IOCTL, ("IOCTL_IPSEC_ADD_FILTER\n"));

                    dwSize = sizeof(IPSEC_ADD_FILTER);

                    if (inputBufferLength < dwSize) {
                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    //
                    // Check the size of the entry
                    //
                    if (pAddFilter->NumEntries == 0) {
                        status = STATUS_SUCCESS;
                    } else {
                        dwSize = FIELD_OFFSET(IPSEC_ADD_FILTER, pInfo[0]) +
                                    pAddFilter->NumEntries * sizeof(IPSEC_FILTER_INFO);

                        if (dwSize < FIELD_OFFSET(IPSEC_ADD_FILTER, pInfo[0]) ||
                            inputBufferLength < dwSize) {
                            status = STATUS_BUFFER_TOO_SMALL;
                            IPSEC_DEBUG(IOCTL, ("returning: %lx\n", status));
                            break;
                        }
                        status = IPSecAddFilter(pAddFilter);
                    }

                    break;
                }

                case IOCTL_IPSEC_DELETE_FILTER: {
                    PIPSEC_DELETE_FILTER    pDelFilter = (PIPSEC_DELETE_FILTER)pvIoBuffer;

                    IPSEC_DEBUG(IOCTL, ("IOCTL_IPSEC_DELETE_FILTER\n"));

                    dwSize = sizeof(IPSEC_DELETE_FILTER);

                    if (inputBufferLength < dwSize) {
                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    //
                    // Check the size of the entry
                    //
                    if (pDelFilter->NumEntries == 0) {
                        status = STATUS_SUCCESS;
                    } else {
                        dwSize = FIELD_OFFSET(IPSEC_DELETE_FILTER, pInfo[0]) +
                                    pDelFilter->NumEntries * sizeof(IPSEC_FILTER_INFO);

                        if (dwSize < FIELD_OFFSET(IPSEC_DELETE_FILTER, pInfo[0]) ||
                            inputBufferLength < dwSize) {
                            status = STATUS_BUFFER_TOO_SMALL;
                            break;
                        }

                        status = IPSecDeleteFilter(pDelFilter);
                    }

                    break;
                }

                case IOCTL_IPSEC_ENUM_SAS: {

                    IPSEC_DEBUG(IOCTL, ("IOCTL_IPSEC_ENUM_SAS\n"));
                    dwSize = sizeof(IPSEC_ENUM_SAS);

                    //
                    // Output/Input in the same buffer at MdlAddress
                    //
                    status = IPSecEnumSAs(Irp, &dwSize);
                    break;
                }

                case IOCTL_IPSEC_ENUM_FILTERS: {
                    IPSEC_DEBUG(IOCTL, ("IOCTL_IPSEC_ENUM_FILTERS\n"));
                    dwSize = sizeof(IPSEC_ENUM_FILTERS);

                    //
                    // Output/Input in the same buffer at MdlAddress
                    //
                    status = IPSecEnumFilters(Irp, &dwSize);
                    break;
                }

                case IOCTL_IPSEC_QUERY_STATS: {
                    //
                    // The minimum size is without any Keys
                    //
                    IPSEC_DEBUG(IOCTL, ("IOCTL_IPSEC_QUERY_STATS\n"));
                    dwSize = sizeof(IPSEC_QUERY_STATS);

                    if (outputBufferLength < dwSize) {
                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    *((PIPSEC_QUERY_STATS)pvIoBuffer) = g_ipsec.Statistics;

                    status = STATUS_SUCCESS;
                    break;
                }

                case IOCTL_IPSEC_ADD_SA: {
                    //
                    // Adds the SA to the relevant database.
                    // Typically used to add outbound SAs to the DB.
                    //
                    IPSEC_DEBUG(IOCTL, ("IOCTL_IPSEC_ADD_SA\n"));

                    //
                    // The minimum size is without any Keys
                    //
                    dwSize = IPSEC_ADD_SA_NO_KEY_SIZE;

                    if (inputBufferLength < dwSize) {
                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    status = IPSecAddSA((PIPSEC_ADD_SA)pvIoBuffer, inputBufferLength);

                    ASSERT(status != STATUS_PENDING);

                    if (outputBufferLength >= sizeof(NTSTATUS)) {
                        (*(NTSTATUS *)pvIoBuffer) = status;
                        dwSize = sizeof(NTSTATUS);
                    } else {
                        dwSize = 0;
                    }

                    status = STATUS_SUCCESS;
                    break;
                }

                case IOCTL_IPSEC_UPDATE_SA: {
                    //
                    // This completes the negotiation kicked off via the Acquire.
                    //
                    // Adds the SA to the relevant database.
                    // Typically used to complete inbound SA acquisitions.
                    //
                    IPSEC_DEBUG(IOCTL, ("IOCTL_IPSEC_UPDATE_SA\n"));

                    //
                    // The minimum size is without any Keys
                    //
                    dwSize = IPSEC_UPDATE_SA_NO_KEY_SIZE;
                    if (inputBufferLength < dwSize) {
                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    status = IPSecUpdateSA((PIPSEC_UPDATE_SA)pvIoBuffer, inputBufferLength);

                    ASSERT(status != STATUS_PENDING);

                    if (outputBufferLength >= sizeof(NTSTATUS)) {
                        (*(NTSTATUS *)pvIoBuffer)=status;
                        dwSize = sizeof(NTSTATUS);
                    } else {
                        dwSize = 0;
                    }

                    status = STATUS_SUCCESS;
                    break;
                }

                case IOCTL_IPSEC_EXPIRE_SA: {
                    //
                    // Deref the particular SA - delete when ref cnt drops to 0.
                    //
                    IPSEC_DEBUG(IOCTL, ("IOCTL_IPSEC_EXPIRE_SA\n"));

                    dwSize = sizeof(IPSEC_EXPIRE_SA);
                    if (inputBufferLength < dwSize) {
                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    status = IPSecExpireSA((PIPSEC_EXPIRE_SA)pvIoBuffer);
                    break;
                }

                case IOCTL_IPSEC_GET_SPI: {
                    //
                    // returns the SPI for an inbound SA
                    //
                    IPSEC_DEBUG(IOCTL, ("IOCTL_IPSEC_GET_SPI\n"));

                    dwSize = sizeof(IPSEC_GET_SPI);
                    if (outputBufferLength < dwSize) {
                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    status = IPSecGetSPI((PIPSEC_GET_SPI)pvIoBuffer);
                    break;
                }

                case IOCTL_IPSEC_POST_FOR_ACQUIRE_SA: {
                    //
                    // The SAAPI client posts a request that we complete when
                    // an SA needs to be initialized or updated (due to
                    // re-key).
                    // We keep the Irp around until we need an SA to be
                    // negotiated.
                    //
                    IPSEC_DEBUG(IOCTL, ("IPSEC_POST_FOR_ACQUIRE_SA\n"));

                    dwSize = sizeof(IPSEC_POST_FOR_ACQUIRE_SA);
                    if (outputBufferLength < dwSize) {
                        IPSEC_DEBUG(IOCTL, ("IPSEC_POST_FOR_ACQUIRE_SA: bad size: dwSize: %lx, input: %lx\n",
                                          dwSize, inputBufferLength));

                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    Irp->IoStatus.Status = STATUS_PENDING;

                    status = IPSecHandleAcquireRequest( Irp,
                                                        (PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer);

                    if (status == STATUS_PENDING) {
                        IPSEC_DECREMENT(g_ipsec.NumIoctls);
                        return  status;
                    }

                    break;
                }

                case IOCTL_IPSEC_QUERY_EXPORT: {
                    //
                    // Queries whether the driver is built for export. Used by the IPSEC components
                    // to decide what key lengths to use for encryption.
                    //
                    IPSEC_DEBUG(IOCTL, ("IPSEC_QUERY_EXPORT\n"));

                    dwSize = sizeof(IPSEC_QUERY_EXPORT);
                    if (outputBufferLength < dwSize) {
                        IPSEC_DEBUG(IOCTL, ("IPSEC_QUERY_EXPORT: bad size: dwSize: %lx, input: %lx\n",
                                          dwSize, inputBufferLength));
                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    ((PIPSEC_QUERY_EXPORT)pvIoBuffer)->Export = FALSE;

                    status = STATUS_SUCCESS;
                    break;
                }

                case IOCTL_IPSEC_QUERY_SPI: {
                    IPSEC_DEBUG(IOCTL, ("Entered Query SPI\n"));

                    dwSize = sizeof(IPSEC_QUERY_SPI);
                    if (inputBufferLength < dwSize) {
                        IPSEC_DEBUG(IOCTL, ("IPSEC_QUERY_SPI: bad size: dwSize: %lx, input: %lx\n",
                        dwSize, inputBufferLength));
                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    status = IPSecQuerySpi((PIPSEC_QUERY_SPI)pvIoBuffer);
                    break;
                }

                case IOCTL_IPSEC_DELETE_SA: {
                    IPSEC_DEBUG(IOCTL, ("Entered Delete SA\n"));

                    dwSize = sizeof(IPSEC_DELETE_SA);
                    if (inputBufferLength < dwSize) {
                        IPSEC_DEBUG(IOCTL, ("IPSEC_DELETE_SA: bad size: dwSize: %lx, input: %lx\n",
                        dwSize, inputBufferLength));
                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    status = IPSecDeleteSA((PIPSEC_DELETE_SA)pvIoBuffer);
                    break;
                }

                case IOCTL_IPSEC_SET_OPERATION_MODE: {
                    IPSEC_DEBUG(IOCTL, ("Entered Set Operation Mode\n"));

                    dwSize = sizeof(IPSEC_SET_OPERATION_MODE);
                    if (inputBufferLength < dwSize) {
                        IPSEC_DEBUG(IOCTL, ("IPSEC_SET_OPERATION_MODE: bad size: dwSize: %lx, input: %lx\n",
                        dwSize, inputBufferLength));
                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    status = IPSecSetOperationMode((PIPSEC_SET_OPERATION_MODE)pvIoBuffer);
                    break;
                }

                case IOCTL_IPSEC_SET_TCPIP_STATUS: {
                    IPSEC_DEBUG(IOCTL, ("Entered Set Tcpip Status\n"));

                    if (Irp->RequestorMode != KernelMode) {
                        status = STATUS_ACCESS_DENIED;
                        break;
                    }

                    dwSize = sizeof(IPSEC_SET_TCPIP_STATUS);
                    if (inputBufferLength < dwSize) {
                        IPSEC_DEBUG(IOCTL, ("IPSEC_SET_TCPIP_STATUS: bad size: dwSize: %lx, input: %lx\n",
                        dwSize, inputBufferLength));
                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    status = IPSecSetTcpipStatus((PIPSEC_SET_TCPIP_STATUS)pvIoBuffer);

                    break;
                }

                case IOCTL_IPSEC_REGISTER_PROTOCOL: {

                    dwSize = sizeof(IPSEC_REGISTER_PROTOCOL);
                    if (inputBufferLength < dwSize) {
                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    status = IPSecRegisterProtocols(
                                 (PIPSEC_REGISTER_PROTOCOL) pvIoBuffer
                                 );
                    break;
                }

                default: {

                    status = STATUS_INVALID_PARAMETER;
                    break;
                }
            }

            IPSEC_DECREMENT(g_ipsec.NumIoctls);

            break ;
        }

        default: {
            IPSEC_DEBUG(IOCTL, ("IPSEC: unknown IRP_MJ_XXX: %lx\n", irpStack->MajorFunction));
            status = STATUS_INVALID_PARAMETER;
            break;
        }
    }

    ASSERT(status != STATUS_PENDING);
    ASSERT(KeGetCurrentIrql() <= APC_LEVEL);

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = MIN(dwSize, outputBufferLength);

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    IPSEC_DEBUG(IOCTL, ("Exiting IPSecDispath\n"));

    return  status;
}


NTSTATUS
IPSecBindToIP()
/*++

Routine Description:

    This bind exchanges a number of entrypoints with IP so that

        - packets relevant to IPSEC can be handed over from the IP driver.
        - buffered packets can be flushed.
        - SA Table indices can be plumbed.
        - ....

Arguments:

    NONE

Return Value:

    The function value is the final status from the bind operation.

--*/
{
    NTSTATUS   status;
    IPSEC_FUNCTIONS ipsecFns;

    PAGED_CODE();

    IPSEC_DEBUG(LOAD, ("Entering IPSecBindToIP\n"));

    ipsecFns.Version = IP_IPSEC_BIND_VERSION;
    ipsecFns.IPSecHandler = IPSecHandlePacket;
    ipsecFns.IPSecQStatus = IPSecQueryStatus;
    ipsecFns.IPSecSendCmplt = IPSecSendComplete;
    ipsecFns.IPSecNdisStatus = IPSecNdisStatus;
    ipsecFns.IPSecRcvFWPacket = IPSecRcvFWPacket;

    status = TCPIP_SET_IPSEC(&ipsecFns);

    if (status != IP_SUCCESS) {
        IPSEC_DEBUG(LOAD, ("Failed to bind to IP: %lx\n", status));
    } else {
        IPSEC_DRIVER_BOUND() = TRUE;
        IPSEC_DRIVER_SEND_BOUND() = TRUE;
    }

    IPSEC_DEBUG(LOAD, ("Exiting IPSecBindToIP\n"));

    return status;
}


NTSTATUS
IPSecUnbindFromIP()
/*++

Routine Description:

    This unbinds from the Filter Driver

Arguments:

    NONE

Return Value:

    The function value is the final status from the bind operation.

--*/
{
    NTSTATUS    status;
    IPSEC_FUNCTIONS ipsecFns={0};

    PAGED_CODE();

    IPSEC_DEBUG(LOAD, ("Entering IPSecUnbindFromIP\n"));

    ipsecFns.Version = IP_IPSEC_BIND_VERSION;

    status = TCPIP_UNSET_IPSEC(&ipsecFns);

    if (status != IP_SUCCESS) {
        IPSEC_DEBUG(LOAD, ("Failed to bind to IP: %lx\n", status));
    } else {
        IPSEC_DRIVER_BOUND() = FALSE;
    }

    IPSEC_DEBUG(LOAD, ("Exiting IPSecUnbindFromIP\n"));

    return status;
}


NTSTATUS
IPSecUnbindSendFromIP()
/*++

Routine Description:

    Unbinds just the send handler from IP

Arguments:

    NONE

Return Value:

    The function value is the final status from the bind operation.

--*/
{
    NTSTATUS    status;
    IPSEC_FUNCTIONS ipsecFns={0};

    PAGED_CODE();

    IPSEC_DEBUG(LOAD, ("Entering IPSecUnbindSendFromIP\n"));

    ipsecFns.Version = IP_IPSEC_BIND_VERSION;

    status = TCPIP_UNSET_IPSEC_SEND(&ipsecFns);

    if (status != IP_SUCCESS) {
        IPSEC_DEBUG(LOAD, ("Failed to bind to IP: %lx\n", status));
    } else {
        IPSEC_DRIVER_SEND_BOUND() = FALSE;
    }

    IPSEC_DEBUG(LOAD, ("Exiting IPSecUnbindSendFromIP\n"));

    return status;
}


NTSTATUS
OpenRegKey(
    PHANDLE          HandlePtr,
    PWCHAR           KeyName
    )
/*++

Routine Description:

    Opens a Registry key and returns a handle to it.

Arguments:

    HandlePtr - The varible into which to write the opened handle.
    KeyName   - The name of the Registry key to open.

Return Value:

    STATUS_SUCCESS or an appropriate failure code.

--*/
{
    NTSTATUS          Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    UKeyName;

    PAGED_CODE();

    RtlInitUnicodeString(&UKeyName, KeyName);

    memset(&ObjectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));
    InitializeObjectAttributes(&ObjectAttributes,
                               &UKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(HandlePtr,
                       KEY_READ,
                       &ObjectAttributes);

    return Status;
}


NTSTATUS
GetRegDWORDValue(
    HANDLE           KeyHandle,
    PWCHAR           ValueName,
    PULONG           ValueData
    )
/*++

Routine Description:

    Reads a REG_DWORD value from the registry into the supplied variable.

Arguments:

    KeyHandle  - Open handle to the parent key of the value to read.
    ValueName  - The name of the value to read.
    ValueData  - The variable into which to read the data.

Return Value:

    STATUS_SUCCESS or an appropriate failure code.

--*/
{
    NTSTATUS                    status;
    ULONG                       resultLength;
    PKEY_VALUE_FULL_INFORMATION keyValueFullInformation;
    UCHAR                       keybuf[WORK_BUFFER_SIZE];
    UNICODE_STRING              UValueName;

    PAGED_CODE();

    RtlInitUnicodeString(&UValueName, ValueName);

    keyValueFullInformation = (PKEY_VALUE_FULL_INFORMATION)keybuf;
    RtlZeroMemory(keyValueFullInformation, sizeof(keyValueFullInformation));


    status = ZwQueryValueKey(KeyHandle,
                             &UValueName,
                             KeyValueFullInformation,
                             keyValueFullInformation,
                             WORK_BUFFER_SIZE,
                             &resultLength);

    if (NT_SUCCESS(status)) {
        if (keyValueFullInformation->Type != REG_DWORD) {
            status = STATUS_INVALID_PARAMETER_MIX;
        } else {
            *ValueData = *((ULONG UNALIGNED *)((PCHAR)keyValueFullInformation +
                             keyValueFullInformation->DataOffset));
        }
    }

    return status;
}


NTSTATUS
GetRegStringValue(
    HANDLE                         KeyHandle,
    PWCHAR                          ValueName,
    PKEY_VALUE_PARTIAL_INFORMATION *ValueData,
    PUSHORT                         ValueSize
    )

/*++

Routine Description:

    Reads a REG_*_SZ string value from the Registry into the supplied
    key value buffer. If the buffer string buffer is not large enough,
    it is reallocated.

Arguments:

    KeyHandle  - Open handle to the parent key of the value to read.
    ValueName  - The name of the value to read.
    ValueData  - Destination for the read data.
    ValueSize  - Size of the ValueData buffer. Updated on output.

Return Value:

    STATUS_SUCCESS or an appropriate failure code.

--*/
{
    NTSTATUS                    status;
    ULONG                       resultLength;
    UNICODE_STRING              UValueName;


    PAGED_CODE();

    RtlInitUnicodeString(&UValueName, ValueName);

    status = ZwQueryValueKey(
                 KeyHandle,
                 &UValueName,
                 KeyValuePartialInformation,
                 *ValueData,
                 (ULONG) *ValueSize,
                 &resultLength
    			 );

    if ( (status == STATUS_BUFFER_OVERFLOW) ||
         (status == STATUS_BUFFER_TOO_SMALL)
       )
    {
        PVOID temp;

        //
        // Free the old buffer and allocate a new one of the
        // appropriate size.
        //

        ASSERT(resultLength > (ULONG) *ValueSize);

        if (resultLength <= 0xFFFF) {

            temp = IPSecAllocateMemory(resultLength, IPSEC_TAG_IOCTL);

            if (temp != NULL) {

                if (*ValueData != NULL) {
                    IPSecFreeMemory(*ValueData);
                }

                *ValueData = temp;
                *ValueSize = (USHORT) resultLength;

                status = ZwQueryValueKey(KeyHandle,
                                         &UValueName,
                                         KeyValuePartialInformation,
                                         *ValueData,
                                         *ValueSize,
                                         &resultLength
                						 );

                ASSERT( (status != STATUS_BUFFER_OVERFLOW) &&
                        (status != STATUS_BUFFER_TOO_SMALL)
                      );
            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else {
            status = STATUS_BUFFER_TOO_SMALL;
        }
    }

    return  status;
}


NTSTATUS
GetRegMultiSZValue(
    HANDLE           KeyHandle,
    PWCHAR           ValueName,
    PUNICODE_STRING  ValueData
    )

/*++

Routine Description:

    Reads a REG_MULTI_SZ string value from the Registry into the supplied
    Unicode string. If the Unicode string buffer is not large enough,
    it is reallocated.

Arguments:

    KeyHandle  - Open handle to the parent key of the value to read.
    ValueName  - The name of the value to read.
    ValueData  - Destination Unicode string for the value data.

Return Value:

    STATUS_SUCCESS or an appropriate failure code.

--*/
{
    NTSTATUS                       status;
    ULONG                          resultLength;
    PKEY_VALUE_PARTIAL_INFORMATION keyValuePartialInformation;
    UNICODE_STRING                 UValueName;


    PAGED_CODE();

    ValueData->Length = 0;

    status = GetRegStringValue(
                 KeyHandle,
                 ValueName,
                 (PKEY_VALUE_PARTIAL_INFORMATION *) &(ValueData->Buffer),
                 &(ValueData->MaximumLength)
                 );

    if (NT_SUCCESS(status)) {

        keyValuePartialInformation =
            (PKEY_VALUE_PARTIAL_INFORMATION) ValueData->Buffer;

        if (keyValuePartialInformation->Type == REG_MULTI_SZ) {

            ValueData->Length = (USHORT)
                                keyValuePartialInformation->DataLength;

            RtlCopyMemory(
                ValueData->Buffer,
                &(keyValuePartialInformation->Data),
                ValueData->Length
                );
        }
        else {
            status = STATUS_INVALID_PARAMETER_MIX;
        }
    }

    return status;

} // GetRegMultiSZValue


VOID
IPSecReadRegistry()
/*++

Routine Description:

    Reads config info from registry into g_ipsec

Arguments:


Return Value:

    status of the read.

--*/
{
    NTSTATUS        status;
    HANDLE          hRegKey;
    WCHAR           IPSecParametersRegistryKey[] = IPSEC_REG_KEY;
    BOOLEAN         isAs = MmIsThisAnNtAsSystem();

    g_ipsec.EnableOffload = IPSEC_DEFAULT_ENABLE_OFFLOAD;
    g_ipsec.DefaultSAIdleTime = IPSEC_DEFAULT_SA_IDLE_TIME;
    g_ipsec.LogInterval = IPSEC_DEFAULT_LOG_INTERVAL;
    g_ipsec.EventQueueSize = IPSEC_DEFAULT_EVENT_QUEUE_SIZE;
    g_ipsec.RekeyTime = IPSEC_DEFAULT_REKEY;
    g_ipsec.NoDefaultExempt = IPSEC_DEFAULT_NO_DEFAULT_EXEMPT;
    g_ipsec.NoDefaultExempt = DEFAULT_IPSEC_OPERATION_MODE;
    g_ipsec.DiagnosticMode = IPSEC_DEFAULT_ENABLE_DIAGNOSTICS;    

    if (isAs) {
        g_ipsec.CacheSize = IPSEC_DEFAULT_AS_CACHE_SIZE;
        g_ipsec.SAHashSize = IPSEC_DEFAULT_AS_SA_HASH_SIZE;
    } else {
        g_ipsec.CacheSize = IPSEC_DEFAULT_CACHE_SIZE;
        g_ipsec.SAHashSize = IPSEC_DEFAULT_SA_HASH_SIZE;
    }

    status = OpenRegKey(&hRegKey,
                        IPSecParametersRegistryKey);

    if (NT_SUCCESS(status)) {
        //
        // Expected configuration values. We use reasonable defaults if they
        // aren't available for some reason.
        //
        IPSEC_REG_READ_DWORD(   hRegKey,
                                IPSEC_REG_PARAM_ENABLE_OFFLOAD,
                                &g_ipsec.EnableOffload,
                                IPSEC_DEFAULT_ENABLE_OFFLOAD,
                                IPSEC_MAX_ENABLE_OFFLOAD,
                                IPSEC_MIN_ENABLE_OFFLOAD);

        IPSEC_REG_READ_DWORD(   hRegKey,
                                IPSEC_REG_PARAM_SA_IDLE_TIME,
                                &g_ipsec.DefaultSAIdleTime,
                                IPSEC_DEFAULT_SA_IDLE_TIME,
                                IPSEC_MAX_SA_IDLE_TIME,
                                IPSEC_MIN_SA_IDLE_TIME);

        IPSEC_REG_READ_DWORD(   hRegKey,
                                IPSEC_REG_PARAM_EVENT_QUEUE_SIZE,
                                &g_ipsec.EventQueueSize,
                                IPSEC_DEFAULT_EVENT_QUEUE_SIZE,
                                IPSEC_MAX_EVENT_QUEUE_SIZE,
                                IPSEC_MIN_EVENT_QUEUE_SIZE);

        IPSEC_REG_READ_DWORD(   hRegKey,
                                IPSEC_REG_PARAM_LOG_INTERVAL,
                                &g_ipsec.LogInterval,
                                IPSEC_DEFAULT_LOG_INTERVAL,
                                IPSEC_MAX_LOG_INTERVAL,
                                IPSEC_MIN_LOG_INTERVAL);

        IPSEC_REG_READ_DWORD(   hRegKey,
                                IPSEC_REG_PARAM_REKEY_TIME,
                                &g_ipsec.RekeyTime,
                                IPSEC_DEFAULT_REKEY,
                                IPSEC_MAX_REKEY,
                                IPSEC_MIN_REKEY);

        IPSEC_REG_READ_DWORD(   hRegKey,
                                IPSEC_REG_PARAM_CACHE_SIZE,
                                &g_ipsec.CacheSize,
                                isAs? IPSEC_DEFAULT_AS_CACHE_SIZE:
                                      IPSEC_DEFAULT_CACHE_SIZE,
                                IPSEC_MAX_CACHE_SIZE,
                                IPSEC_MIN_CACHE_SIZE);

        IPSEC_REG_READ_DWORD(   hRegKey,
                                IPSEC_REG_PARAM_SA_HASH_SIZE,
                                &g_ipsec.SAHashSize,
                                isAs? IPSEC_DEFAULT_AS_SA_HASH_SIZE:
                                      IPSEC_DEFAULT_SA_HASH_SIZE,
                                IPSEC_MAX_SA_HASH_SIZE,
                                IPSEC_MIN_SA_HASH_SIZE);

        IPSEC_REG_READ_DWORD(   hRegKey,
                                IPSEC_REG_PARAM_NO_DEFAULT_EXEMPT,
                                &g_ipsec.NoDefaultExempt,
                                IPSEC_DEFAULT_NO_DEFAULT_EXEMPT,
                                IPSEC_MAX_NO_DEFAULT_EXEMPT,
                                IPSEC_MIN_NO_DEFAULT_EXEMPT);

        IPSEC_REG_READ_DWORD(   hRegKey,
                                IPSEC_REG_PARAM_ENABLE_DIAGNOSTICS,
                                &g_ipsec.DiagnosticMode,
                                IPSEC_DEFAULT_ENABLE_DIAGNOSTICS,
                                IPSEC_MAX_ENABLE_DIAGNOSTICS,
                                IPSEC_MIN_ENABLE_DIAGNOSTICS);

        IPSEC_REG_READ_DWORD(   hRegKey,
                                IPSEC_REG_PARAM_OPERATION_MODE,
                                &(ULONG)g_ipsec.OperationMode,
                                DEFAULT_IPSEC_OPERATION_MODE,
                                IPSEC_OPERATION_MODE_MAX-1,
                                0);

        ZwClose(hRegKey);
    }

    g_ipsec.CacheHalfSize = g_ipsec.CacheSize / 2;

    //
    // Init SAIdleTime for low memory reaper
    //
    IPSEC_CONVERT_SECS_TO_100NS(g_ipsec.SAIdleTime, g_ipsec.DefaultSAIdleTime);
}


NTSTATUS
IPSecGeneralInit()
/*++

Routine Description:

    General structures are initialized here.

Arguments:

    None

Return Value:


--*/
{
    PSA_TABLE_ENTRY pSA;
    LONG            i;
    NTSTATUS        status = STATUS_SUCCESS;;

    PAGED_CODE();

    IPSEC_DEBUG(LOAD, ("Entering IPSecGeneralInit\n"));

    //
    // init the acquireinfo struct
    //
    InitializeListHead(&g_ipsec.AcquireInfo.PendingAcquires);
    InitializeListHead(&g_ipsec.AcquireInfo.PendingNotifies);
    InitializeListHead(&g_ipsec.LarvalSAList);
    INIT_LOCK(&g_ipsec.LarvalListLock);
    INIT_LOCK(&g_ipsec.AcquireInfo.Lock);

    //
    // Set up the hashes/tables
    //
    InitializeMRSWLock(&g_ipsec.SADBLock);
    InitializeMRSWLock(&g_ipsec.SPIListLock);

    g_ipsec.IPProtInfo.pi_xmitdone = IPSecProtocolSendComplete;
    g_ipsec.IPProtInfo.pi_protocol = PROTOCOL_ESP;

    //
    // init filter linked lists
    //
    for (i = MIN_FILTER; i <= MAX_FILTER; i++) {
        InitializeListHead(&g_ipsec.FilterList[i]);
    }

    //
    // SAs in a hash table, hashed by <SPI, Dest addr>
    //
    g_ipsec.pSADb = IPSecAllocateMemory(g_ipsec.SAHashSize * sizeof(SA_HASH), IPSEC_TAG_INIT);

    if (!g_ipsec.pSADb) {
        IPSEC_DEBUG(LOAD, ("Failed to alloc SADb hash\n"));
        return  STATUS_INSUFFICIENT_RESOURCES;
    }

    IPSecInitFlag |= INIT_SA_DATABASE;

    IPSecZeroMemory(g_ipsec.pSADb, g_ipsec.SAHashSize * sizeof(SA_HASH));

    for (i = 0; i < g_ipsec.SAHashSize; i++) {
        PSA_HASH  Entry = &g_ipsec.pSADb[i];
        InitializeListHead(&Entry->SAList);
    }

    //
    // Initialize the MDL pools.
    //
    status = IPSecInitMdlPool();
    if (!NT_SUCCESS (status)) {
        IPSEC_DEBUG(LOAD, ("Failed to alloc MDL pools\n"));
        return  STATUS_INSUFFICIENT_RESOURCES;
    }

    IPSecInitFlag |= INIT_MDL_POOLS;

    //
    // Initialize the cache structures.
    //
    if (!AllocateCacheStructures()) {
        IPSEC_DEBUG(LOAD, ("Failed to alloc cache structs\n"));
        return  STATUS_INSUFFICIENT_RESOURCES;
    }

    IPSecInitFlag |= INIT_CACHE_STRUCT;

    //
    // Allocate EventQueue memory.
    //
    g_ipsec.IPSecLogMemory = IPSecAllocateMemory( g_ipsec.EventQueueSize * sizeof(IPSEC_EVENT_CTX),
                                            IPSEC_TAG_EVT_QUEUE);

    if (!g_ipsec.IPSecLogMemory) {
        return  STATUS_INSUFFICIENT_RESOURCES;
    }

    IPSecInitFlag |= INIT_DEBUG_MEMORY;

    g_ipsec.IPSecLogMemoryLoc = &g_ipsec.IPSecLogMemory[0];
    g_ipsec.IPSecLogMemoryEnd = &g_ipsec.IPSecLogMemory[g_ipsec.EventQueueSize * sizeof(IPSEC_EVENT_CTX)];

    //
    // Init the timer stuff.
    //
    if (!IPSecInitTimer()) {
        IPSEC_DEBUG(LOAD, ("Failed to init timer\n"));
        return  STATUS_INSUFFICIENT_RESOURCES;
    }

    IPSecInitFlag |= INIT_TIMERS;

#if GPC
    status = IPSecGpcInitialize();
    if (status != STATUS_SUCCESS) {
        IPSEC_DEBUG(LOAD, ("Failed to register GPC clients\n"));
    }
#endif

    //
    // Arm the reaper timer
    //
    IPSEC_DEBUG(LOAD, ("Starting ReaperTimer\n"));
    IPSecStartTimer(&g_ipsec.ReaperTimer,
                    IPSecReaper,
                    IPSEC_REAPER_TIME,
                    (PVOID)NULL);

    //
    // Start EventLog timer
    //
    IPSEC_DEBUG(LOAD, ("Starting EventLogTimer\n"));
    IPSecStartTimer(&g_ipsec.EventLogTimer,
                    IPSecFlushEventLog,
                    g_ipsec.LogInterval,
                    (PVOID)NULL);

    IPSEC_DEBUG(LOAD, ("Exiting IPSecGeneralInit\n"));

    return STATUS_SUCCESS;
}


NTSTATUS
IPSecGeneralFree()
/*++

Routine Description:

    Free general structures if IPSecGeneralInit fails.

Arguments:

    None

Return Value:


--*/
{
    INT index;

    //
    // Free SA database.
    //
    if (IPSecInitFlag & INIT_SA_DATABASE) {
        if (g_ipsec.pSADb) {
            IPSecFreeMemory(g_ipsec.pSADb);
        }
    }

    //
    // Free MDL pool.
    //
    if (IPSecInitFlag & INIT_MDL_POOLS) {
        IPSecDeinitMdlPool();
    }

    //
    // Free cache struct.
    //
    if (IPSecInitFlag & INIT_CACHE_STRUCT) {
        FreeExistingCache();
    }

    //
    // Free EventQueue memory.
    //
    if (IPSecInitFlag & INIT_DEBUG_MEMORY) {
        if (g_ipsec.IPSecLogMemory) {
            IPSecFreeMemory(g_ipsec.IPSecLogMemory);
        }
    }

    //
    // Free timers allocated.
    //
    if (IPSecInitFlag & INIT_TIMERS) {
        for (index = 0; index < IPSEC_CLASS_MAX; index++) {
            IPSecFreeMemory(g_ipsec.TimerList[index].pTimers);
        }
    }

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecFreeConfig()
/*++

Routine Description:

    Free the SA table etc.

Arguments:

    None

Return Value:


--*/
{
    IPSEC_DEBUG(LOAD, ("Entering IPSecFreeConfig\n"));

    PAGED_CODE();

    FreeExistingCache();
    FreePatternDbase();

    if (g_ipsec.IPSecLogMemory) {
        IPSecFreeMemory(g_ipsec.IPSecLogMemory);
    }

    IPSEC_DEBUG(LOAD, ("Exiting IPSecFreeConfig\n"));
    return STATUS_SUCCESS;

}


NTSTATUS
IPSecInitMdlPool()
/*++

Routine Description:

    Create the MDL pool for AH and ESP headers.

Arguments:

    None

Return Value:


--*/
{
    PAGED_CODE();
    IPSEC_DEBUG(LOAD, ("Entering IPSecInitMdlPool\n"));

    g_ipsec.IPSecSmallBufferSize = IPSEC_SMALL_BUFFER_SIZE;
    g_ipsec.IPSecLargeBufferSize = IPSEC_LARGE_BUFFER_SIZE;
    g_ipsec.IPSecSendCompleteCtxSize = sizeof(IPSEC_SEND_COMPLETE_CONTEXT);

    g_ipsec.IPSecSmallBufferListDepth = IPSEC_LIST_DEPTH;
    g_ipsec.IPSecLargeBufferListDepth = IPSEC_LIST_DEPTH;
    g_ipsec.IPSecSendCompleteCtxDepth = IPSEC_LIST_DEPTH;

    g_ipsec.IPSecCacheLineSize = IPSEC_CACHE_LINE_SIZE;

    //
    // Initialize the lookaside lists.
    //

    g_ipsec.IPSecLookasideLists = IPSecAllocateMemory(
                                    sizeof(*g_ipsec.IPSecLookasideLists),
                                    IPSEC_TAG_LOOKASIDE_LISTS);

    if (g_ipsec.IPSecLookasideLists == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the IPSEC buffer lookaside lists.
    //
    ExInitializeNPagedLookasideList(&g_ipsec.IPSecLookasideLists->LargeBufferList,
                                    IPSecAllocateBufferPool,
                                    NULL,
                                    0,
                                    g_ipsec.IPSecLargeBufferSize,
                                    IPSEC_TAG_BUFFER_POOL,
                                    (USHORT)g_ipsec.IPSecLargeBufferListDepth);

    ExInitializeNPagedLookasideList(&g_ipsec.IPSecLookasideLists->SmallBufferList,
                                    IPSecAllocateBufferPool,
                                    NULL,
                                    0,
                                    g_ipsec.IPSecSmallBufferSize,
                                    IPSEC_TAG_BUFFER_POOL,
                                    (USHORT)g_ipsec.IPSecSmallBufferListDepth);

    ExInitializeNPagedLookasideList(&g_ipsec.IPSecLookasideLists->SendCompleteCtxList,
                                    NULL,
                                    NULL,
                                    0,
                                    g_ipsec.IPSecSendCompleteCtxSize,
                                    IPSEC_TAG_SEND_COMPLETE,
                                    (USHORT)g_ipsec.IPSecSendCompleteCtxDepth);

    IPSEC_DEBUG(LOAD, ("Exiting IPSecInitMdlPool\n"));
    return STATUS_SUCCESS;
}


VOID
IPSecDeinitMdlPool()
/*++

Routine Description:

    Free the MDL pool for AH and ESP headers.

Arguments:

    None

Return Value:


--*/
{
    PAGED_CODE();
    IPSEC_DEBUG(LOAD, ("Entering IPSecDeinitMdlPool\n"));

    //
    // Destroy the lookaside lists.
    //

    if (g_ipsec.IPSecLookasideLists != NULL) {
        ExDeleteNPagedLookasideList(&g_ipsec.IPSecLookasideLists->LargeBufferList);
        ExDeleteNPagedLookasideList(&g_ipsec.IPSecLookasideLists->SmallBufferList);
        ExDeleteNPagedLookasideList(&g_ipsec.IPSecLookasideLists->SendCompleteCtxList);

        IPSecFreeMemory(g_ipsec.IPSecLookasideLists);
    }

    IPSEC_DEBUG(LOAD, ("Exiting IPSecDeinitMdlPool\n"));
}


NTSTATUS
IPSecQuiesce()
/*++

Routine Description:

    Destroy MDL pools and run down all driver activity

Arguments:

    None

Return Value:


--*/
{
    IPSEC_DEBUG(LOAD, ("Entering IPSecQuiesce\n"));
    IPSecDeinitMdlPool();
    IPSEC_DEBUG(LOAD, ("Exiting IPSecQuiesce\n"));
    return  STATUS_SUCCESS;
}


BOOLEAN
AllocateCacheStructures()
/*++

Routine Description:

    Allocates the necessary memory for cache (which is an array of pointers to
    cache entries)
    Allocates necessary number of cache entries (but doesnt initialize them)
    Allocates a small number of entries and puts them on the free list (doesnt
    initialize these either)

Arguments:

    None

Return Value:

    True if the function completely succeeds, else FALSE.  If FALSE, it is upto
    the CALLER to do a rollback and clear any allocated memory


--*/
{
    ULONG   i;

    PAGED_CODE();

    g_ipsec.ppCache = IPSecAllocateMemory(g_ipsec.CacheSize * sizeof(PFILTER_CACHE), IPSEC_TAG_INIT);

    if (!g_ipsec.ppCache) {
        IPSEC_DEBUG(LOAD, ("Couldnt allocate memory for Input Cache\n"));
        return FALSE;
    }

    IPSecZeroMemory(g_ipsec.ppCache, g_ipsec.CacheSize * sizeof(PFILTER_CACHE));

    for (i = 0; i < g_ipsec.CacheSize; i++) {
        PFILTER_CACHE  pTemp1;

        pTemp1 = IPSecAllocateMemory(sizeof(FILTER_CACHE), IPSEC_TAG_INIT);

        if (!pTemp1) {
            FreeExistingCache();
            return FALSE;
        }

        IPSecZeroMemory(pTemp1, sizeof(FILTER_CACHE));

        g_ipsec.ppCache[i] = pTemp1;

    }

    return TRUE;
}


VOID
FreeExistingCache()
/*++

Routine Description

    Frees all the cache entries, free entries and cache pointer array

Arguments

    None

Return Value

    None

--*/
{
    ULONG   i;

    PAGED_CODE();

    IPSEC_DEBUG(LOAD, ("Freeing existing cache...\n"));

    IPSecResetCacheTable();

    if (g_ipsec.ppCache) {
        for (i = 0; i < g_ipsec.CacheSize; i++) {
            if (g_ipsec.ppCache[i]) {
                ExFreePool(g_ipsec.ppCache[i]);
            }
        }

        ExFreePool(g_ipsec.ppCache);
        g_ipsec.ppCache = NULL;
    }
}


VOID
FreePatternDbase()
/*++

Routine Description

    Frees all filters and SAs.

Arguments

    None

Return Value

    None

--*/
{
    PLIST_ENTRY     pEntry;
    PFILTER         pFilter;
    PSA_TABLE_ENTRY pSA;
    LONG            i, j;

    PAGED_CODE();

    //
    // Free all masked filters and associated (outbound) SAs
    //
    for (i = MIN_FILTER; i <= MAX_FILTER; i++) {

        while (!IsListEmpty(&g_ipsec.FilterList[i])) {

            pEntry = RemoveHeadList(&g_ipsec.FilterList[i]);

            pFilter = CONTAINING_RECORD(pEntry,
                                        FILTER,
                                        MaskedLinkage);

            IPSEC_DEBUG(LOAD, ("Freeing filter: %lx\n", pFilter));

            //
            // Free each SA under it.
            //
            for (j = 0; j < pFilter->SAChainSize; j++) {

                while (!IsListEmpty(&pFilter->SAChain[j])) {

                    pEntry = RemoveHeadList(&pFilter->SAChain[j]);

                    pSA = CONTAINING_RECORD(pEntry,
                                            SA_TABLE_ENTRY,
                                            sa_FilterLinkage);

                    IPSEC_DEBUG(LOAD, ("Freeing SA: %lx\n", pSA));

                    //
                    // Remove SA from miniport if plumbed
                    //
                    if (pSA->sa_Flags & FLAGS_SA_HW_PLUMBED) {
                        IPSecDelHWSA(pSA);
                    }

                    //
                    // Also remove the inbound SAs from their SPI list
                    // so we dont double free them below.
                    //
                    IPSecRemoveSPIEntry(pSA);

                    //
                    // Stop the timer if armed and deref SA.
                    //
                    IPSecStopTimerDerefSA(pSA);
                }
            }

#if GPC
            IPSecUninstallGpcFilter(pFilter);
#endif

            IPSecFreeFilter(pFilter);
        }
    }

    //
    // Free all SAs under the SPI hashes.
    //
    for (i = 0; i < g_ipsec.SAHashSize; i++) {
        PSA_HASH  pHash = &g_ipsec.pSADb[i];

        while (!IsListEmpty(&pHash->SAList)) {

            pEntry = RemoveHeadList(&pHash->SAList);

            pSA = CONTAINING_RECORD(pEntry,
                                    SA_TABLE_ENTRY,
                                    sa_SPILinkage);

            IPSEC_DEBUG(LOAD, ("Freeing SA: %lx\n", pSA));

            if (pSA->sa_Flags & FLAGS_SA_HW_PLUMBED) {
                IPSecDelHWSA(pSA);
            }

            IPSecStopTimerDerefSA(pSA);
        }
    }

    IPSecFreeMemory(g_ipsec.pSADb);

    IPSEC_DEBUG(LOAD, ("Freed filters/SAs\n"));
}


SIZE_T
IPSecCalculateBufferSize(
    IN SIZE_T BufferDataSize
    )
/*++

Routine Description:

    Determines the size of an AFD buffer structure given the amount of
    data that the buffer contains.

Arguments:

    BufferDataSize - data length of the buffer.

    AddressSize - length of address structure for the buffer.

Return Value:

    Number of bytes needed for an IPSEC_LA_BUFFER structure for data of
    this size.

--*/
{
    SIZE_T mdlSize;
    SIZE_T bufferSize;

    ASSERT(BufferDataSize != 0);

    ASSERT(g_ipsec.IPSecCacheLineSize < 100);

    //
    // Determine the sizes of the various components of an IPSEC_LA_BUFFER
    // structure.  Note that these are all worst-case calculations--
    // actual sizes of the MDL and the buffer may be smaller.
    //
    bufferSize = BufferDataSize + g_ipsec.IPSecCacheLineSize;
    mdlSize = MmSizeOfMdl( (PVOID)(PAGE_SIZE-1), bufferSize );

    return ((sizeof(IPSEC_LA_BUFFER) + mdlSize + bufferSize + 3) & ~3);

}


VOID
IPSecInitializeBuffer(
    IN PIPSEC_LA_BUFFER IPSecBuffer,
    IN SIZE_T BufferDataSize
    )
/*++

Routine Description:

    Initializes an IPSec buffer.  Sets up fields in the actual IPSEC_LA_BUFFER
    structure and initializes the MDL associated with the buffer.  This routine
    assumes that the caller has properly allocated sufficient space for all this.

Arguments:

    IPSecBuffer - points to the IPSEC_LA_BUFFER structure to initialize.

    BufferDataSize - the size of the data buffer that goes along with the
        buffer structure.

Return Value:

    None

--*/
{
    SIZE_T mdlSize;

    //
    // Set up the MDL pointer but don't build it yet.  We have to wait
    // until after the data buffer is built to build the MDL.
    //
    mdlSize = MmSizeOfMdl( (PVOID)(PAGE_SIZE-1), BufferDataSize );
    IPSecBuffer->Mdl = (PMDL)&IPSecBuffer->Data[0];

    IPSEC_DEBUG(POOL, ("IPSecBuffer: %lx, MDL: %lx\n", IPSecBuffer, IPSecBuffer->Mdl));

    //
    // Set up the data buffer pointer and length.  Note that the buffer
    // MUST begin on a cache line boundary so that we can use the fast
    // copy routines like RtlCopyMemory on the buffer.
    //
    IPSecBuffer->Buffer = (PVOID)
        (((ULONG_PTR)((PCHAR)IPSecBuffer->Mdl + mdlSize) +
                g_ipsec.IPSecCacheLineSize - 1 ) & ~((ULONG_PTR)(g_ipsec.IPSecCacheLineSize - 1)));

    IPSecBuffer->BufferLength = (ULONG)BufferDataSize;  // Sundown - FIX

    //
    // Now build the MDL and set up a pointer to the MDL in the IRP.
    //
    MmInitializeMdl( IPSecBuffer->Mdl, IPSecBuffer->Buffer, BufferDataSize );
    MmBuildMdlForNonPagedPool( IPSecBuffer->Mdl );

}


PVOID
IPSecAllocateBufferPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )
/*++

Routine Description:

    Used by the lookaside list allocation function to allocate a new
    IPSec buffer structure.  The returned structure will be fully
    initialized.

Arguments:

    PoolType - passed to ExAllocatePoolWithTag.

    NumberOfBytes - the number of bytes required for the data buffer
        portion of the IPSec buffer.

    Tag - passed to ExAllocatePoolWithTag.

Return Value:

    PVOID - a fully initialized PIPSEC_LA_BUFFER, or NULL if the allocation
            attempt fails.

--*/
{
    PIPSEC_LA_BUFFER IPSecBuffer;
    SIZE_T bytesRequired;

    //
    // The requested length must be the same as one of the standard
    // IPSec buffer sizes.
    //

    ASSERT( NumberOfBytes == g_ipsec.IPSecSmallBufferSize ||
            NumberOfBytes == g_ipsec.IPSecLargeBufferSize );

    //
    // Determine how much data we'll actually need for the buffer.
    //

    bytesRequired = IPSecCalculateBufferSize(NumberOfBytes);

    //
    // Get nonpaged pool for the buffer.
    //

    IPSecBuffer = IPSecAllocateMemory( bytesRequired, Tag );
    if ( IPSecBuffer == NULL ) {
        return NULL;
    }

    //
    // Initialize the buffer and return a pointer to it.
    //

    IPSecInitializeBuffer( IPSecBuffer, NumberOfBytes );

    return IPSecBuffer;


}


PIPSEC_LA_BUFFER
IPSecGetBuffer(
    IN CLONG BufferDataSize,
    IN ULONG Tag
    )
/*++

Routine Description:

    Obtains a buffer of the appropriate size for the caller.  Uses
    the preallocated buffers if possible, or else allocates a new buffer
    structure if required.

Arguments:

    BufferDataSize - the size of the data buffer that goes along with the
        buffer structure.

Return Value:

    PIPSEC_LA_BUFFER - a pointer to an IPSEC_LA_BUFFER structure, or NULL if one
        was not available or could not be allocated.

--*/
{
    PIPSEC_LA_BUFFER IPSecBuffer;
    SIZE_T bufferSize;
    PLIST_ENTRY listEntry;
    PNPAGED_LOOKASIDE_LIST lookasideList;

    //
    // If possible, allocate the buffer from one of the lookaside lists.
    //
    if (BufferDataSize <= g_ipsec.IPSecLargeBufferSize) {

        if ( BufferDataSize <= g_ipsec.IPSecSmallBufferSize ) {

            lookasideList = &g_ipsec.IPSecLookasideLists->SmallBufferList;
            BufferDataSize = g_ipsec.IPSecSmallBufferSize;

        } else {

            lookasideList = &g_ipsec.IPSecLookasideLists->LargeBufferList;
            BufferDataSize = g_ipsec.IPSecLargeBufferSize;

        }

        IPSecBuffer = ExAllocateFromNPagedLookasideList( lookasideList );

        if (!IPSecBuffer) {
            return  NULL;
        }

        IPSecBuffer->Tag = Tag;

        return IPSecBuffer;
    }

    //
    // Couldn't find an appropriate buffer that was preallocated.
    // Allocate one manually.  If the buffer size requested was
    // zero bytes, give them four bytes.  This is because some of
    // the routines like MmSizeOfMdl() cannot handle getting passed
    // in a length of zero.
    //
    // !!! It would be good to ROUND_TO_PAGES for this allocation
    //     if appropriate, then use entire buffer size.
    //
    if ( BufferDataSize == 0 ) {
        BufferDataSize = sizeof(ULONG);
    }

    bufferSize = IPSecCalculateBufferSize(BufferDataSize);

    IPSecBuffer = IPSecAllocateMemory(bufferSize, IPSEC_TAG_BUFFER_POOL);

    if ( IPSecBuffer == NULL ) {
        return NULL;
    }

    //
    // Initialize the IPSec buffer structure and return it.
    //
    IPSecInitializeBuffer(IPSecBuffer, BufferDataSize);

    IPSecBuffer->Tag = Tag;

    return IPSecBuffer;
}


VOID
IPSecReturnBuffer (
    IN PIPSEC_LA_BUFFER IPSecBuffer
    )
/*++

Routine Description:

    Returns an IPSec buffer to the appropriate global list, or frees
    it if necessary.

Arguments:

    IPSecBufferHeader - points to the IPSec_BUFFER_HEADER structure to return or free.

Return Value:

    None

--*/
{
    PNPAGED_LOOKASIDE_LIST lookasideList;

    //
    // If appropriate, return the buffer to one of the IPSec buffer
    // lookaside lists.
    //
    if (IPSecBuffer->BufferLength <= g_ipsec.IPSecLargeBufferSize) {

        if (IPSecBuffer->BufferLength==g_ipsec.IPSecSmallBufferSize) {
            lookasideList = &g_ipsec.IPSecLookasideLists->SmallBufferList;
        } else {
            ASSERT (IPSecBuffer->BufferLength==g_ipsec.IPSecLargeBufferSize);
            lookasideList = &g_ipsec.IPSecLookasideLists->LargeBufferList;
        }

        ExFreeToNPagedLookasideList( lookasideList, IPSecBuffer );

        return;

    }

    IPSecFreeMemory(IPSecBuffer);
}

    
NTSTATUS
IPSecWriteEvent(
    PDRIVER_OBJECT IPSecDriverObject,
    IN ULONG    EventCode,
    IN NTSTATUS NtStatusCode,
    IN ULONG    OffloadStatus,
    IN ULONG    ExtraStatus1,
    IN ULONG    ExtraStatus2,
    IN PVOID    RawDataBuffer,
    IN USHORT   RawDataLength,
    IN USHORT   NumberOfInsertionStrings,
    ...
    )

#define LAST_NAMED_ARGUMENT NumberOfInsertionStrings


/*++

Routine Description:

    This function allocates an I/O error log record, fills it in and writes it
    to the I/O error log.

Arguments:



Return Value:

    None.


--*/
{
    PIO_ERROR_LOG_PACKET    ErrorLogEntry;
    va_list                 ParmPtr;                    // Pointer to stack parms.
    PCHAR                   DumpData;
    LONG                    Length;
    ULONG                   i, SizeOfRawData, RemainingSpace, TotalErrorLogEntryLength;
    ULONG                   SizeOfStringData = 0;
    PWSTR                   StringOffset, InsertionString;

    if (NumberOfInsertionStrings != 0)
    {
        va_start (ParmPtr, LAST_NAMED_ARGUMENT);

        for (i = 0; i < NumberOfInsertionStrings; i += 1)
        {
            InsertionString = va_arg (ParmPtr, PWSTR);
            Length = wcslen (InsertionString);
            while ((Length > 0) && (InsertionString[Length-1] == L' '))
            {
                Length--;
            }

            SizeOfStringData += (Length + 1) * sizeof(WCHAR);
        }
    }

    //
    //  Ideally we want the packet to hold the servername and ExtraInformation.
    //  Usually the ExtraInformation gets truncated.
    //

    TotalErrorLogEntryLength = min (RawDataLength + sizeof(IO_ERROR_LOG_PACKET) + 1 + SizeOfStringData,
                                    ERROR_LOG_MAXIMUM_SIZE);

    RemainingSpace = TotalErrorLogEntryLength - FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData);
    if (RemainingSpace > SizeOfStringData)
    {
        SizeOfRawData = RemainingSpace - SizeOfStringData;
    }
    else
    {
        SizeOfStringData = RemainingSpace;
        SizeOfRawData = 0;
    }

    ErrorLogEntry = IoAllocateErrorLogEntry (IPSecDriverObject, (UCHAR) TotalErrorLogEntryLength);
    if (ErrorLogEntry == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Fill in the error log entry
    //
    ErrorLogEntry->ErrorCode                = EventCode;
    ErrorLogEntry->UniqueErrorValue         = OffloadStatus;
    ErrorLogEntry->FinalStatus              = NtStatusCode;
    ErrorLogEntry->MajorFunctionCode        = 0;
    ErrorLogEntry->RetryCount               = 0;
    ErrorLogEntry->IoControlCode            = 0;
    ErrorLogEntry->DeviceOffset.LowPart     = ExtraStatus1;
    ErrorLogEntry->DeviceOffset.HighPart    = ExtraStatus2;
    ErrorLogEntry->DumpDataSize             = 0;
    ErrorLogEntry->NumberOfStrings          = 0;
    ErrorLogEntry->SequenceNumber           = 0;
    ErrorLogEntry->StringOffset = (USHORT) (ROUND_UP_COUNT (FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData)
                                                            + SizeOfRawData, ALIGN_WORD));


    //
    // Append the dump data.  This information is typically an SMB header.
    //
    if ((RawDataBuffer) && (SizeOfRawData))
    {
        DumpData = (PCHAR) ErrorLogEntry->DumpData;
        Length = min (RawDataLength, (USHORT)SizeOfRawData);
        RtlCopyMemory (DumpData, RawDataBuffer, Length);
        ErrorLogEntry->DumpDataSize = (USHORT)Length;
    }

    //
    // Add the debug informatuion strings
    //
    if (NumberOfInsertionStrings)
    {
        StringOffset = (PWSTR) ((PCHAR)ErrorLogEntry + ErrorLogEntry->StringOffset);

        //
        // Set up ParmPtr to point to first of the caller's parameters.
        //
        va_start(ParmPtr, LAST_NAMED_ARGUMENT);

        for (i = 0 ; i < NumberOfInsertionStrings ; i+= 1)
        {
            InsertionString = va_arg(ParmPtr, PWSTR);
            Length = wcslen(InsertionString);
            while ( (Length > 0) && (InsertionString[Length-1] == L' '))
            {
                Length--;
            }

            if (((Length + 1) * sizeof(WCHAR)) > SizeOfStringData)
            {
                Length = (SizeOfStringData/sizeof(WCHAR)) - 1;
            }

            if (Length > 0)
            {
                RtlCopyMemory (StringOffset, InsertionString, Length*sizeof(WCHAR));
                StringOffset += Length;
                *StringOffset++ = L'\0';

                SizeOfStringData -= (Length + 1) * sizeof(WCHAR);

                ErrorLogEntry->NumberOfStrings += 1;
            }
        }
    }

    IoWriteErrorLogEntry(ErrorLogEntry);

    return(STATUS_SUCCESS);
}


VOID
IPSecLogEvents(
    IN  PVOID   Context
    )
/*++

Routine Description:

    Dumps events from the  circular buffer to the eventlog when the
    circular buffer overflows.

Arguments:

    Context - unused.

Return Value:

    None

--*/
{
    PIPSEC_LOG_EVENT    pLogEvent;
    LONG                LogSize;
    PUCHAR              pLog;

    pLogEvent = (PIPSEC_LOG_EVENT)Context;
    LogSize = 0;
    pLog = (PUCHAR)pLogEvent + FIELD_OFFSET(IPSEC_LOG_EVENT, pLog[0]);

    while (LogSize < pLogEvent->LogSize) {
        PIPSEC_EVENT_CTX    ctx = (PIPSEC_EVENT_CTX)pLog;

        if (ctx->EventCode == EVENT_IPSEC_DROP_PACKET_INBOUND ||
            ctx->EventCode == EVENT_IPSEC_DROP_PACKET_OUTBOUND) {
            WCHAR   IPAddrBufferS[(sizeof(IPAddr) * 4) + 1];
            WCHAR   IPAddrBufferD[(sizeof(IPAddr) * 4) + 1];
            WCHAR   IPProtocolBuffer[(sizeof(IPAddr) * 4) + 1];
            WCHAR   IPSPortBuffer[(sizeof(IPAddr) * 4) + 1];
            WCHAR   IPDPortBuffer[(sizeof(IPAddr) * 4) + 1];
            
            PWCHAR  stringlist[5];
            IPHeader UNALIGNED  *pIPH;            
            USHORT SrcPort=0;
            USHORT DestPort=0;
            ULONG HeaderLen;

            pIPH = (IPHeader UNALIGNED *)ctx->pPacket;
            HeaderLen=(pIPH->iph_verlen & (UCHAR)~IP_VER_FLAG) << 2;
            IPSecIPAddrToUnicodeString( pIPH->iph_src,
                                        IPAddrBufferS);
            IPSecIPAddrToUnicodeString( pIPH->iph_dest,
                                        IPAddrBufferD);
            IPSecCountToUnicodeString ( pIPH->iph_protocol,
                                        IPProtocolBuffer);

            if (pIPH->iph_protocol == PROTOCOL_TCP ||
                pIPH->iph_protocol == PROTOCOL_UDP) {
                RtlCopyMemory(&SrcPort,&ctx->pPacket[HeaderLen],sizeof(USHORT));
                RtlCopyMemory(&DestPort,&ctx->pPacket[HeaderLen+sizeof(USHORT)],sizeof(USHORT));
            }

            IPSecCountToUnicodeString ( NET_SHORT(SrcPort),
                                        IPSPortBuffer);

            IPSecCountToUnicodeString ( NET_SHORT(DestPort),
                                        IPDPortBuffer);

            IPSecWriteEvent(
                g_ipsec.IPSecDriverObject,
                ctx->EventCode,
                ctx->DropStatus.IPSecStatus,
                ctx->DropStatus.OffloadStatus,
                ctx->DropStatus.Flags,
                0,
                ctx->pPacket,
                (USHORT)ctx->PacketSize,
                5,
                IPAddrBufferS,
                IPAddrBufferD,
                IPProtocolBuffer,
                IPSPortBuffer,
                IPDPortBuffer);
                
        } else if (ctx->Addr && ctx->EventCount > 0) {
            WCHAR   IPAddrBuffer[(sizeof(IPAddr) * 4) + 1];
            WCHAR   CountBuffer[MAX_COUNT_STRING_LEN + 1];
            PWCHAR  stringList[2];

            IPSecIPAddrToUnicodeString( ctx->Addr,
                                        IPAddrBuffer);
            IPSecCountToUnicodeString(  ctx->EventCount,
                                        CountBuffer);
            stringList[0] = CountBuffer;
            stringList[1] = IPAddrBuffer;
            LOG_EVENT(
                g_ipsec.IPSecDriverObject,
                ctx->EventCode,
                ctx->UniqueEventValue,
                2,
                stringList,
                0,
                NULL);
        } else if (ctx->Addr) {
            WCHAR   IPAddrBuffer[(sizeof(IPAddr) * 4) + 1];
            PWCHAR  stringList[1];

            IPSecIPAddrToUnicodeString( ctx->Addr,
                                        IPAddrBuffer);
            stringList[0] = IPAddrBuffer;
            LOG_EVENT(
                g_ipsec.IPSecDriverObject,
                ctx->EventCode,
                ctx->UniqueEventValue,
                1,
                stringList,
                0,
                NULL);
        } else {
            LOG_EVENT(
                g_ipsec.IPSecDriverObject,
                ctx->EventCode,
                ctx->UniqueEventValue,
                0,
                NULL,
                0,
                NULL);
        }

        if (ctx->pPacket) {
            IPSecFreeLogBuffer(ctx->pPacket);
            ctx->pPacket=NULL;
        }
        pLog += sizeof(IPSEC_EVENT_CTX);
        LogSize += sizeof(IPSEC_EVENT_CTX);
    }

    IPSecFreeMemory(pLogEvent);

    IPSEC_DECREMENT(g_ipsec.NumWorkers);
}


VOID
IPSecBufferEvent(
    IN  IPAddr  Addr,
    IN  ULONG   EventCode,
    IN  ULONG   UniqueEventValue,
    IN  BOOLEAN fBufferEvent
    )
/*++

Routine Description:

    Buffers events in a circular buffer; dumps them to the eventlog when the
    circular buffer overflows.

Arguments:

    Addr - [OPTIONAL] the source IP addr of the offending peer.

    EventCode         - Identifies the error message.

    UniqueEventValue  - Identifies this instance of a given error message.

Return Value:

    None

--*/
{
    KIRQL   kIrql;

    if (!(g_ipsec.DiagnosticMode & IPSEC_DIAGNOSTIC_ENABLE_LOG)) {
        return;
    }

    ACQUIRE_LOCK(&g_ipsec.EventLogLock, &kIrql);

    if (fBufferEvent) {
        PIPSEC_EVENT_CTX    ctx;

        g_ipsec.IPSecBufferedEvents++;

        ctx = (PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc;
        ctx--;
        while (ctx >= (PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemory) {
            if (ctx->Addr == Addr &&
                ctx->EventCode == EventCode &&
                ctx->UniqueEventValue == UniqueEventValue) {
                //
                // Found a duplicate; update count and exit.
                //
                ctx->EventCount++;
        
                if (g_ipsec.IPSecBufferedEvents >= g_ipsec.EventQueueSize) {
                    goto logit;
                }

                RELEASE_LOCK(&g_ipsec.EventLogLock, kIrql);
                return;
            }
            ctx--;
        }
    }

    ((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->Addr = Addr;
    ((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->EventCode = EventCode;
    ((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->UniqueEventValue = UniqueEventValue;

    ((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->pPacket=NULL;
    ((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->PacketSize=0;
    

    if (fBufferEvent) {
        ((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->EventCount = 1;
    } else {
        ((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->EventCount = 0;
    }

    g_ipsec.IPSecLogMemoryLoc += sizeof(IPSEC_EVENT_CTX);

logit:
    if (!fBufferEvent ||
        g_ipsec.IPSecLogMemoryLoc >= g_ipsec.IPSecLogMemoryEnd ||
        g_ipsec.IPSecBufferedEvents >= g_ipsec.EventQueueSize) {
        //
        // Flush the logs.
        //
        IPSecQueueLogEvent();
    }

    RELEASE_LOCK(&g_ipsec.EventLogLock, kIrql);
}


NTSTATUS
CopyOutboundPacketToBuffer(
    IN PUCHAR pIPHeader,
    IN PVOID pData,
    OUT PUCHAR * pPacket,
    OUT ULONG * PacketSize
    )
{
    PNDIS_BUFFER pTemp;
    ULONG Length;
    ULONG dataLength=0;
    IPHeader UNALIGNED  *pIPH;
    ULONG HeaderLen=0;
    PUCHAR pBuffer;
    ULONG CopyPos=0;
    PUCHAR pPacketData;

    pIPH = (IPHeader UNALIGNED *)pIPHeader;

    pTemp = (PNDIS_BUFFER)pData;

    while (pTemp) {
        pBuffer = NULL;
        Length = 0;

        NdisQueryBufferSafe(pTemp,
                            &pBuffer,
                            &Length,
                            NormalPagePriority);

        if (!pBuffer) {
            return  STATUS_UNSUCCESSFUL;
        }

        dataLength += Length;

        pTemp = NDIS_BUFFER_LINKAGE(pTemp);
    }
    
    HeaderLen=(pIPH->iph_verlen & (UCHAR)~IP_VER_FLAG) << 2;

    dataLength += HeaderLen;

    if (dataLength > IPSEC_LOG_PACKET_SIZE) {
        dataLength = IPSEC_LOG_PACKET_SIZE;
    }

    if (dataLength < sizeof(IPHeader)) {
        // doesn't even have a full ip header
        return  STATUS_UNSUCCESSFUL;
    }
    if ((pIPH->iph_protocol == PROTOCOL_TCP) ||
        (pIPH->iph_protocol == PROTOCOL_UDP)) {
        if (dataLength - HeaderLen < 8) {
            // not enough room for ports
            return STATUS_UNSUCCESSFUL;
        }
    }

    *pPacket = IPSecAllocateLogBuffer(dataLength);
    if (! (*pPacket)) {
        return STATUS_UNSUCCESSFUL;
    }
    *PacketSize=dataLength;

    pTemp = (PNDIS_BUFFER)pData;
    CopyPos=0;

    while (pTemp && CopyPos < dataLength) {
        IPSecQueryNdisBuf(pTemp,&pPacketData,&Length);
        if (CopyPos + Length > dataLength) {
            Length = (dataLength - CopyPos);
        }
        RtlCopyMemory(*pPacket+CopyPos,pPacketData,Length);
        CopyPos += Length;
        pTemp = NDIS_BUFFER_LINKAGE(pTemp);
    }

    return STATUS_SUCCESS;
}


//
// pData is data after IPHeader, IPRcvBuf.
//

NTSTATUS
CopyInboundPacketToBuffer(
    IN PUCHAR pIPHeader,
    IN PVOID pData,
    OUT PUCHAR * pPacket,
    OUT ULONG * PacketSize
    )
{
    IPRcvBuf *pTemp;
    ULONG Length;
    ULONG dataLength=0;
    IPHeader UNALIGNED  *pIPH;
    ULONG HeaderLen=0;
    PUCHAR pBuffer;
    ULONG CopyPos=0;
    PUCHAR pPacketData;

    pIPH = (IPHeader UNALIGNED *)pIPHeader;

    pTemp = (IPRcvBuf*)pData;

    while (pTemp) {
        pBuffer = NULL;
        Length = 0;

        IPSecQueryRcvBuf(pTemp,
                         &pBuffer,
                         &Length);

        if (!pBuffer) {
            return  STATUS_UNSUCCESSFUL;
        }

        dataLength += Length;

        pTemp = IPSEC_BUFFER_LINKAGE(pTemp);
    }
    
    HeaderLen=(pIPH->iph_verlen & (UCHAR)~IP_VER_FLAG) << 2;

    dataLength += HeaderLen;

    if (dataLength > IPSEC_LOG_PACKET_SIZE) {
        dataLength = IPSEC_LOG_PACKET_SIZE;
    }

    // Sanity check length
    if (dataLength < sizeof(IPHeader)) {
        // doesn't even have a full ip header
        return  STATUS_UNSUCCESSFUL;
    }
    if ((pIPH->iph_protocol == PROTOCOL_TCP) ||
        (pIPH->iph_protocol == PROTOCOL_UDP)) {
        if (dataLength - HeaderLen < 8) {
            // not enough room for ports
            return STATUS_UNSUCCESSFUL;
        }
    }

    *pPacket = IPSecAllocateLogBuffer(dataLength);
    if (! (*pPacket)) {
        return STATUS_UNSUCCESSFUL;
    }
    *PacketSize=dataLength;

    pTemp = (IPRcvBuf*)pData;

    RtlCopyMemory(*pPacket,pIPH,HeaderLen);
    CopyPos=HeaderLen;

    while (pTemp && CopyPos < dataLength) {
        IPSecQueryRcvBuf(pTemp,&pPacketData,&Length);
        if (CopyPos + Length > dataLength) {
            Length = (dataLength - CopyPos);
        }
        RtlCopyMemory(*pPacket+CopyPos,pPacketData,Length);
        CopyPos += Length;
        pTemp = IPSEC_BUFFER_LINKAGE(pTemp);
    }

    return STATUS_SUCCESS;
}


VOID
IPSecBufferPacketDrop(
    IN  PUCHAR              pIPHeader,
    IN  PVOID               pData,
    IN OUT PULONG           pIpsecFlags,
    IN  PIPSEC_DROP_STATUS  pDropStatus
    )
/*++

Routine Description:

    Buffers events in a circular buffer; dumps them to the eventlog when the
    circular buffer overflows.

Arguments:

    EventCode         - Identifies the error message.

Return Value:

    None

--*/
{
    KIRQL   kIrql;
    PIPSEC_EVENT_CTX    ctx;
    IPHeader UNALIGNED  *pIPH;
    PNDIS_BUFFER pTemp;
    PUCHAR pPacket=NULL;
    ULONG PacketSize=0;
    ULONG Status;
    BOOL bLockHeld=FALSE;


    pIPH = (IPHeader UNALIGNED *)pIPHeader;

    if (*pIpsecFlags & IPSEC_FLAG_INCOMING) {
        if (!(g_ipsec.DiagnosticMode & IPSEC_DIAGNOSTIC_INBOUND)) {
            // Don't log
            goto out;
        }
        Status=CopyInboundPacketToBuffer(pIPHeader,
                                         pData,
                                         &pPacket,
                                         &PacketSize);
    } else {
        if (!(g_ipsec.DiagnosticMode & IPSEC_DIAGNOSTIC_OUTBOUND)) {
            //Don't log
            goto out;
        }
        Status=CopyOutboundPacketToBuffer(pIPHeader,
                                          pData,
                                          &pPacket,
                                          &PacketSize);
    }
    
    if (Status != STATUS_SUCCESS) {
        goto out;
    }

    ACQUIRE_LOCK(&g_ipsec.EventLogLock, &kIrql);
    bLockHeld=TRUE;

    g_ipsec.IPSecBufferedEvents++;
    
    ctx = (PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc;
    ctx--;

    ((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->Addr=pIPH->iph_src;

    if (*pIpsecFlags & IPSEC_FLAG_INCOMING) {
        ((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->EventCode = EVENT_IPSEC_DROP_PACKET_INBOUND;
    } else {
        ((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->EventCode = EVENT_IPSEC_DROP_PACKET_OUTBOUND;;
    }
    ((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->EventCount = 1;


    ((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->pPacket = pPacket;
    ((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->PacketSize = PacketSize;
    
    if (pDropStatus) {
        RtlCopyMemory(&(((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->DropStatus),
                      pDropStatus,sizeof(IPSEC_DROP_STATUS));
    } else {
        RtlZeroMemory(&(((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->DropStatus),
                      sizeof(IPSEC_DROP_STATUS));
    }

    g_ipsec.IPSecLogMemoryLoc += sizeof(IPSEC_EVENT_CTX);


    if (g_ipsec.IPSecLogMemoryLoc >= g_ipsec.IPSecLogMemoryEnd ||
        g_ipsec.IPSecBufferedEvents >= g_ipsec.EventQueueSize) {
        //
        // Flush the logs.
        //
        IPSecQueueLogEvent();
    }

out:
    if (bLockHeld) {
        RELEASE_LOCK(&g_ipsec.EventLogLock, kIrql);
    }
}


VOID
IPSecQueueLogEvent(
    VOID
    )
/*++

Routine Description:

    Copies the LogMemory to a temporary buffer and schedule an event to
    flush logs.

Arguments:

    None

Return Value:

    None

Notes:

    Called with EventLogLock held.

--*/
{
    PIPSEC_LOG_EVENT    pLogEvent;
    LONG                LogSize;
    PUCHAR              pLog;

    LogSize = (LONG)(g_ipsec.IPSecLogMemoryLoc - g_ipsec.IPSecLogMemory);

    //
    // Reset the log memory so we can record again.
    // 
    g_ipsec.IPSecLogMemoryLoc = g_ipsec.IPSecLogMemory;
    g_ipsec.IPSecBufferedEvents = 0;

    if (LogSize <= 0) {
        ASSERT(FALSE);
        return;
    }

    pLogEvent = IPSecAllocateMemory(LogSize + FIELD_OFFSET(IPSEC_LOG_EVENT, pLog[0]),
                                    IPSEC_TAG_EVT_QUEUE);

    if (!pLogEvent) {
        return;
    }

    pLogEvent->LogSize = LogSize;

    pLog = (PUCHAR)pLogEvent + FIELD_OFFSET(IPSEC_LOG_EVENT, pLog[0]);
    RtlCopyMemory(pLog, g_ipsec.IPSecLogMemory, LogSize);

    //
    // Queue work item to dump these into the eventlog.
    //
    ExInitializeWorkItem(&pLogEvent->LogQueueItem, IPSecLogEvents, pLogEvent);
    ExQueueWorkItem(&pLogEvent->LogQueueItem, DelayedWorkQueue);

    IPSEC_INCREMENT(g_ipsec.NumWorkers);
}


#if FIPS
BOOLEAN
IPSecFipsInitialize(
    VOID
    )
/*++

Routine Description:

	Initialize the FIPS library table.

Arguments:

    Called at PASSIVE level.

Return Value:

    TRUE/FALSE.

--*/
{
    UNICODE_STRING  DeviceName;
    PDEVICE_OBJECT  pFipsDeviceObject = NULL;
    PIRP            pIrp;
    IO_STATUS_BLOCK StatusBlock;
    KEVENT          Event;
    NTSTATUS        status;

    PAGED_CODE();

    //
    // Return success if FIPS already initialized.
    //
    if (IPSEC_DRIVER_INIT_FIPS()) {
        return  TRUE;
    }

    RtlInitUnicodeString(&DeviceName, FIPS_DEVICE_NAME);

    //
    // Get the file and device objects for FIPS.
    //
    status = IoGetDeviceObjectPointer(  &DeviceName,
                                        FILE_ALL_ACCESS,
                                        &g_ipsec.FipsFileObject,
                                        &pFipsDeviceObject);

    if (!NT_SUCCESS(status)) {
        g_ipsec.FipsFileObject = NULL;
        return  FALSE;
    }

    //
    // Build the request to send to FIPS to get library table.
    //
    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

    pIrp = IoBuildDeviceIoControlRequest(   IOCTL_FIPS_GET_FUNCTION_TABLE,
                                            pFipsDeviceObject,
                                            NULL,
                                            0,
                                            &g_ipsec.FipsFunctionTable,
                                            sizeof(FIPS_FUNCTION_TABLE),
                                            FALSE,
                                            &Event,
                                            &StatusBlock);
    
    if (pIrp == NULL) {
        IPSEC_DEBUG(LOAD, ("IoBuildDeviceIoControlRequest IOCTL_FIPS_GET_FUNCTION_TABLE failed.\n"));

        ObDereferenceObject(g_ipsec.FipsFileObject);
        g_ipsec.FipsFileObject = NULL;

        return  FALSE;
    }
    
    status = IoCallDriver(pFipsDeviceObject, pIrp);
    
    if (status == STATUS_PENDING) {
        status = KeWaitForSingleObject( &Event,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);
        if (status == STATUS_SUCCESS) {
            status = StatusBlock.Status;
        }
    }

    if (status != STATUS_SUCCESS) {
        IPSEC_DEBUG(LOAD, ("IoCallDriver: IOCTL_FIPS_GET_FUNCTION_TABLE failed %#x\n", status));

        ObDereferenceObject(g_ipsec.FipsFileObject);
        g_ipsec.FipsFileObject = NULL;

        return  FALSE;
    }
    
    IPSEC_DRIVER_INIT_FIPS() = TRUE;

    return  TRUE;
}
#endif


BOOLEAN
IPSecCryptoInitialize(
    VOID
    )
/*++

Routine Description:

	Initialize RNG and FIPS library table.

Arguments:

    None

Return Value:

    TRUE/FALSE

--*/
{
    PAGED_CODE();

    if (IPSEC_DRIVER_INIT_CRYPTO()) {
        return  TRUE;
    }

#if FIPS
    //
    // Init the FIPS crypto library.
    //
    if (!IPSecFipsInitialize()) {
        return  FALSE;
    }
#endif

    //
    // Init the RC4 key for RNG.
    //
    if (!IPSEC_DRIVER_INIT_RNG()) {
        InitializeRNG(NULL);

        if (!IPSecInitRandom()) {
            ShutdownRNG(NULL);
            return  FALSE;
        }

        IPSEC_DRIVER_INIT_RNG() = TRUE;
    }

    IPSEC_DRIVER_INIT_CRYPTO() = TRUE;

    return  TRUE;
}


BOOLEAN
IPSecCryptoDeinitialize(
    VOID
    )
/*++

Routine Description:

	Deinitialize RNG and dereference FipsFileObject.

Arguments:

    None

Return Value:

    TRUE/FALSE

--*/
{
    PAGED_CODE();

    //
    // Don't forget to shutdown RNG or we will leak memory.
    //
    if (IPSEC_DRIVER_INIT_RNG()) {
        ShutdownRNG(NULL);
    }

#if FIPS
    //
    // Dereference FipsFileObject.
    //
    if (g_ipsec.FipsFileObject) {
        ObDereferenceObject(g_ipsec.FipsFileObject);
    }
#endif

    return  TRUE;
}


NTSTATUS
IPSecRegisterProtocols(
    PIPSEC_REGISTER_PROTOCOL pIpsecRegisterProtocol
    )
{
    if (pIpsecRegisterProtocol->RegisterProtocol == IPSEC_REGISTER_PROTOCOLS) {
        if (!IPSEC_GET_VALUE(gdwInitEsp)) {
            if (TCPIP_REGISTER_PROTOCOL(
                    PROTOCOL_ESP,
                    NULL,
                    NULL,
                    IPSecESPStatus,
                    NULL,
                    NULL,
                    NULL
                    )) {
                IPSEC_SET_VALUE(gdwInitEsp, 1);
            }
            else {
                ASSERT(FALSE);
                return (STATUS_INSUFFICIENT_RESOURCES);
            }
        }
        if (!IPSEC_GET_VALUE(gdwInitAh)) {
            if (TCPIP_REGISTER_PROTOCOL(
                    PROTOCOL_AH,
                    NULL,
                    NULL,
                    IPSecAHStatus,
                    NULL,
                    NULL,
                    NULL
                    )) {
                IPSEC_SET_VALUE(gdwInitAh, 1);
            }
            else {
                ASSERT(FALSE);
                TCPIP_DEREGISTER_PROTOCOL(PROTOCOL_ESP);
                IPSEC_SET_VALUE(gdwInitEsp, 0);
                return (STATUS_INSUFFICIENT_RESOURCES);
            }
        }
    }
    else if (pIpsecRegisterProtocol->RegisterProtocol == IPSEC_DEREGISTER_PROTOCOLS) {
        if (IPSEC_GET_VALUE(gdwInitEsp)) {
            TCPIP_DEREGISTER_PROTOCOL(PROTOCOL_ESP);
            IPSEC_SET_VALUE(gdwInitEsp, 0);
        }
        if (IPSEC_GET_VALUE(gdwInitAh)) {
            TCPIP_DEREGISTER_PROTOCOL(PROTOCOL_AH);
            IPSEC_SET_VALUE(gdwInitAh, 0);
        }
    }
    else {
        return (STATUS_INVALID_PARAMETER);
    }

    return (STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\ahxforms.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    ahxforms.c

Abstract:

    This module contains the code to create various AH transforms

Author:
   
    Sanjay Anand (SanjayAn) 2-January-1997
    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#include    "precomp.h"


#define MAX_LEN_PAD     65


NTSTATUS
ah_nullinit(
    IN  PALGO_STATE pState,
    IN  ULONG       Index
    )
/*++

Routine Description:

    Init the MD5 context for keyed MD5

Arguments:

    pState - state buffer which needs to be passed into the update/finish functions

Return Value:

    STATUS_SUCCESS
    Others:
        STATUS_INSUFFICIENT_RESOURCES
        STATUS_UNSUCCESSFUL (error in algo.)

--*/
{
    return  STATUS_SUCCESS;
}


NTSTATUS
ah_nullupdate(
    IN  PALGO_STATE pState,
    IN  PUCHAR      pData,
    IN  ULONG       Len
    )
/*++

Routine Description:

    Continue MD5 over the data passed in; as a side-effect, updates the bytes
    transformed count in the SA (for key-expiration)

Arguments:

    pState - algo state buffer

    pData  - data to be hashed

    Len    - length of above data

Return Value:

    STATUS_SUCCESS
--*/
{
    return STATUS_SUCCESS;
}


NTSTATUS
ah_nullfinish(
    IN  PALGO_STATE pState,
    OUT PUCHAR      pHash,
    IN  ULONG       Index
    )
/*++

Routine Description:

    Finish the MD5 calculation

Arguments:

    pState - algo state buffer

    pHash  - pointer to final hash data

Return Value:

    STATUS_SUCCESS

--*/
{
    RtlCopyMemory(pHash, "0123456789012345", MD5DIGESTLEN);

    return STATUS_SUCCESS;
}


/*++
    The ah_hmac* family:

    Generates the actual hash using HMAC-MD5 or HMAC-SHA according to RFC 2104
    which works as under:

    We define two fixed and different strings ipad and opad as follows
    (the 'i' and 'o' are mnemonics for inner and outer):

                 ipad = the byte 0x36 repeated B times
                 opad = the byte 0x5C repeated B times.

    To compute HMAC over the data `text' we perform

          H(K XOR opad, H(K XOR ipad, text))
--*/
NTSTATUS
ah_hmacmd5init(
    IN PALGO_STATE  pState,
    IN ULONG        Index
    )
/*++

Routine Description:

    Init the MD5 context for HMAC.

Arguments:

    pState - state buffer which needs to be passed into the update/finish functions

Return Value:

    STATUS_SUCCESS
    Others:
        STATUS_INSUFFICIENT_RESOURCES
        STATUS_UNSUCCESSFUL (error in algo.)

--*/
{
    PSA_TABLE_ENTRY pSA = pState->as_sa;
    PUCHAR      key = pSA->INT_KEY(Index);
    ULONG       key_len = pSA->INT_KEYLEN(Index);
    UCHAR       k_ipad[MAX_LEN_PAD];    /* inner padding - key XORd with ipad */
    UCHAR       tk[MD5DIGESTLEN];
    ULONG       i;

    IPSEC_HMAC_MD5_INIT(&(pState->as_md5ctx),
                        key,
                        key_len);

    IPSEC_DEBUG(AHEX, ("MD5init: %lx-%lx-%lx-%lx-%lx-%lx-%lx-%lx\n",
                       *(ULONG *)&(pState->as_md5ctx).in[0],
                       *(ULONG *)&(pState->as_md5ctx).in[4],
                       *(ULONG *)&(pState->as_md5ctx).in[8],
                       *(ULONG *)&(pState->as_md5ctx).in[12],
                       *(ULONG *)&(pState->as_md5ctx).in[16],
                       *(ULONG *)&(pState->as_md5ctx).in[20],
                       *(ULONG *)&(pState->as_md5ctx).in[24],
                       *(ULONG *)&(pState->as_md5ctx).in[28]));

    return  STATUS_SUCCESS;
}


NTSTATUS
ah_hmacmd5update(
    IN  PALGO_STATE pState,
    IN  PUCHAR      pData,
    IN  ULONG       Len
    )
/*++

Routine Description:

    Continue MD5 over the data passed in; as a side-effect, updates the bytes
    transformed count in the SA (for key-expiration)

Arguments:

    pState - algo state buffer

    pData  - data to be hashed

    Len    - length of above data

Return Value:

    STATUS_SUCCESS

--*/
{
    PSA_TABLE_ENTRY pSA = pState->as_sa;

    IPSEC_HMAC_MD5_UPDATE(&(pState->as_md5ctx), pData, Len);

    IPSEC_DEBUG(AHEX, ("MD5update: %lx-%lx-%lx-%lx-%lx-%lx-%lx-%lx\n",
                            *(ULONG *)&(pState->as_md5ctx).in[0],
                            *(ULONG *)&(pState->as_md5ctx).in[4],
                            *(ULONG *)&(pState->as_md5ctx).in[8],
                            *(ULONG *)&(pState->as_md5ctx).in[12],
                            *(ULONG *)&(pState->as_md5ctx).in[16],
                            *(ULONG *)&(pState->as_md5ctx).in[20],
                            *(ULONG *)&(pState->as_md5ctx).in[24],
                            *(ULONG *)&(pState->as_md5ctx).in[28]));
    return STATUS_SUCCESS;
}


NTSTATUS
ah_hmacmd5finish(
    IN  PALGO_STATE pState,
    OUT PUCHAR      pHash,
    IN  ULONG           Index
    )
/*++

Routine Description:

    Finish the MD5 calculation

Arguments:

    pState - algo state buffer

    pHash  - pointer to final hash data

Return Value:

    STATUS_SUCCESS

--*/
{
    UCHAR       k_opad[MAX_LEN_PAD];    /* outer padding - key XORd with opad */
    UCHAR       tk[MD5DIGESTLEN];
    PSA_TABLE_ENTRY pSA = pState->as_sa;
    PUCHAR      key = pSA->INT_KEY(Index);
    ULONG       key_len = pSA->INT_KEYLEN(Index);
    ULONG       i;

    IPSEC_HMAC_MD5_FINAL(&(pState->as_md5ctx),key,key_len,pHash);

    return STATUS_SUCCESS;

}


NTSTATUS
ah_hmacshainit(
    IN PALGO_STATE           pState,
    IN ULONG        Index
    )
/*++

Routine Description:

    Init the SHA context for HMAC.

Arguments:

    pState - state buffer which needs to be passed into the update/finish functions

Return Value:

    STATUS_SUCCESS
    Others:
        STATUS_INSUFFICIENT_RESOURCES
        STATUS_UNSUCCESSFUL (error in algo.)

--*/
{
    PSA_TABLE_ENTRY pSA = pState->as_sa;
    PUCHAR      key = pSA->INT_KEY(Index);
    ULONG       key_len = pSA->INT_KEYLEN(Index);
    UCHAR       k_ipad[MAX_LEN_PAD];    /* inner padding - key XORd with ipad */
    UCHAR       tk[A_SHA_DIGEST_LEN];
    ULONG       i;

    IPSEC_HMAC_SHA_INIT(&(pState->as_shactx),key,key_len);

    IPSEC_DEBUG(AHEX, ("A_SHA_init: %lx-%lx-%lx-%lx-%lx-%lx-%lx-%lx\n",
                            *(ULONG *)&(pState->as_shactx).HashVal[0],
                            *(ULONG *)&(pState->as_shactx).HashVal[4],
                            *(ULONG *)&(pState->as_shactx).HashVal[8],
                            *(ULONG *)&(pState->as_shactx).HashVal[12],
                            *(ULONG *)&(pState->as_shactx).HashVal[16],
                            *(ULONG *)&(pState->as_shactx).HashVal[20],
                            *(ULONG *)&(pState->as_shactx).HashVal[24],
                            *(ULONG *)&(pState->as_shactx).HashVal[28]));

    return  STATUS_SUCCESS;
}


NTSTATUS
ah_hmacshaupdate(
    IN  PALGO_STATE pState,
    IN  PUCHAR      pData,
    IN  ULONG       Len
    )
/*++

Routine Description:

    Continue A_SHA_ over the data passed in; as a side-effect, updates the bytes
    transformed count in the SA (for key-expiration)

Arguments:

    pState - algo state buffer

    pData  - data to be hashed

    Len    - length of above data

Return Value:

    STATUS_SUCCESS

--*/
{
    PSA_TABLE_ENTRY pSA = pState->as_sa;

    IPSEC_HMAC_SHA_UPDATE(&(pState->as_shactx), pData, Len);

    IPSEC_DEBUG(AHEX, ("A_SHA_update: %lx-%lx-%lx-%lx-%lx-%lx-%lx-%lx\n",
                            *(ULONG *)&(pState->as_shactx).HashVal[0],
                            *(ULONG *)&(pState->as_shactx).HashVal[4],
                            *(ULONG *)&(pState->as_shactx).HashVal[8],
                            *(ULONG *)&(pState->as_shactx).HashVal[12],
                            *(ULONG *)&(pState->as_shactx).HashVal[16],
                            *(ULONG *)&(pState->as_shactx).HashVal[20],
                            *(ULONG *)&(pState->as_shactx).HashVal[24],
                            *(ULONG *)&(pState->as_shactx).HashVal[28]));

    return STATUS_SUCCESS;
}


NTSTATUS
ah_hmacshafinish(
    IN  PALGO_STATE pState,
    OUT PUCHAR      pHash,
    IN  ULONG           Index
    )
/*++

Routine Description:

    Finish the A_SHA_ calculation

Arguments:

    pState - algo state buffer

    pHash  - pointer to final hash data

Return Value:

    STATUS_SUCCESS

--*/
{
    UCHAR       k_opad[MAX_LEN_PAD];    /* outer padding - key XORd with opad */
    UCHAR       tk[A_SHA_DIGEST_LEN];
    PSA_TABLE_ENTRY pSA = pState->as_sa;
    PUCHAR      key = pSA->INT_KEY(Index);
    ULONG       key_len = pSA->INT_KEYLEN(Index);
    ULONG       i;

    IPSEC_HMAC_SHA_FINAL(&(pState->as_shactx),key,key_len, pHash);

    IPSEC_DEBUG(AHEX, ("MD#1: %lx-%lx-%lx-%lx\n",
                            *(ULONG *)&(pState->as_shactx).HashVal[0],
                            *(ULONG *)&(pState->as_shactx).HashVal[4],
                            *(ULONG *)&(pState->as_shactx).HashVal[8],
                            *(ULONG *)&(pState->as_shactx).HashVal[12]));

    return  STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\esp.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    esp.c

Abstract:

    This module contains the code to create/verify the ESP headers.

Author:

    Sanjay Anand (SanjayAn) 2-January-1997
    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#include    "precomp.h"


#ifndef _TEST_PERF
CONFID_ALGO  conf_algorithms[] = {
{ esp_nullinit, esp_nullencrypt, esp_nulldecrypt, DES_BLOCKLEN},
{ esp_desinit, esp_desencrypt, esp_desdecrypt, DES_BLOCKLEN},
{ esp_desinit, esp_desencrypt, esp_desdecrypt, DES_BLOCKLEN},
{ esp_3_desinit, esp_3_desencrypt, esp_3_desdecrypt, DES_BLOCKLEN},
};
#else
CONFID_ALGO  conf_algorithms[] = {
{ esp_nullinit, esp_nullencrypt, esp_nulldecrypt, DES_BLOCKLEN},
{ esp_nullinit, esp_nullencrypt, esp_nulldecrypt, DES_BLOCKLEN},
{ esp_nullinit, esp_nullencrypt, esp_nulldecrypt, DES_BLOCKLEN},
{ esp_nullinit, esp_nullencrypt, esp_nulldecrypt, DES_BLOCKLEN},
};
#endif


VOID
esp_nullinit (
    IN  PVOID   pState,
    IN  PUCHAR  pKey
    )
{
    return;
}


VOID
esp_nullencrypt (
    PVOID   pState,
    PUCHAR  pOut,
    PUCHAR  pIn,
    PUCHAR  pIV
    )
{
    RtlCopyMemory(pOut, pIn, DES_BLOCKLEN);

    return;
}


VOID
esp_nulldecrypt (
    PVOID   pState,
    PUCHAR  pOut,
    PUCHAR  pIn,
    PUCHAR  pIV
    )
{
    return;
}


VOID
esp_desinit (
    IN  PVOID   pState,
    IN  PUCHAR  pKey
    )
{
    DESTable    *Table = &((PCONF_STATE_BUFFER)pState)->desTable;

    IPSEC_DES_KEY(Table, pKey);
}


VOID
esp_desencrypt (
    PVOID   pState,
    PUCHAR  pOut,
    PUCHAR  pIn,
    PUCHAR  pIV
    )
{
    DESTable    *Table = &((PCONF_STATE_BUFFER)pState)->desTable;

    IPSEC_CBC(IPSEC_DES_ALGO,
        pOut,
        pIn,    //  pChunk,
        Table,
        ENCRYPT,
        pIV);
}


VOID
esp_desdecrypt (
    PVOID   pState,
    PUCHAR  pOut,
    PUCHAR  pIn,
    PUCHAR  pIV
    )
{
    DESTable    *Table = &((PCONF_STATE_BUFFER)pState)->desTable;

    IPSEC_CBC(IPSEC_DES_ALGO,
        pOut,
        pIn,    //  pChunk,
        Table,
        DECRYPT,
        pIV);
}


VOID
esp_3_desinit (
    IN  PVOID   pState,
    IN  PUCHAR  pKey
    )
{
    DES3TABLE    *Table = &((PCONF_STATE_BUFFER)pState)->des3Table;

    IPSEC_3DES_KEY(Table, pKey);
}


VOID
esp_3_desencrypt (
    PVOID   pState,
    PUCHAR  pOut,
    PUCHAR  pIn,
    PUCHAR  pIV
    )
{
    DES3TABLE    *Table = &((PCONF_STATE_BUFFER)pState)->des3Table;

    IPSEC_CBC(IPSEC_3DES_ALGO,
        pOut,
        pIn,    //  pChunk,
        Table,
        ENCRYPT,
        pIV);
}


VOID
esp_3_desdecrypt (
    PVOID   pState,
    PUCHAR  pOut,
    PUCHAR  pIn,
    PUCHAR  pIV
    )
{
    DES3TABLE    *Table = &((PCONF_STATE_BUFFER)pState)->des3Table;

    IPSEC_CBC(IPSEC_3DES_ALGO,
        pOut,
        pIn,    //  pChunk,
        Table,
        DECRYPT,
        pIV);
}


IPRcvBuf *
CopyToRcvBuf(
    IN  IPRcvBuf        *DestBuf,
    IN  PUCHAR          SrcBuf,
    IN  ULONG           Size,
    IN  PULONG          StartOffset
    )
/*++

    Copy a flat buffer to an IPRcvBuf chain.

    A utility function to copy a flat buffer to an NDIS buffer chain. We
    assume that the NDIS_BUFFER chain is big enough to hold the copy amount;
    in a debug build we'll  debugcheck if this isn't true. We return a pointer
    to the buffer where we stopped copying, and an offset into that buffer.
    This is useful for copying in pieces into the chain.

  	Input:

        DestBuf     - Destination IPRcvBuf chain.
        SrcBuf      - Src flat buffer.
        Size        - Size in bytes to copy.
        StartOffset - Pointer to start of offset into first buffer in
                        chain. Filled in on return with the offset to
                        copy into next.

  	Returns:

        Pointer to next buffer in chain to copy into.

--*/
{
    UINT        CopySize;
    UCHAR       *DestPtr;
    UINT        DestSize;
    UINT        Offset = *StartOffset;
    UCHAR      *VirtualAddress;
    UINT        Length;

    if (DestBuf == NULL || SrcBuf == NULL) {
        ASSERT(FALSE);
        return  NULL;
    }

    IPSecQueryRcvBuf(DestBuf, &VirtualAddress, &Length);
    ASSERT(Length >= Offset);
    DestPtr = VirtualAddress + Offset;
    DestSize = Length - Offset;

    for (;;) {
        CopySize = MIN(Size, DestSize);
        RtlCopyMemory(DestPtr, SrcBuf, CopySize);

        DestPtr += CopySize;
        SrcBuf += CopySize;

        if ((Size -= CopySize) == 0)
            break;

        if ((DestSize -= CopySize) == 0) {
            DestBuf = IPSEC_BUFFER_LINKAGE(DestBuf);
            
            if (DestBuf == NULL) {
                ASSERT(FALSE);
                break;
            }

            IPSecQueryRcvBuf(DestBuf, &VirtualAddress, &Length);

            DestPtr = VirtualAddress;
            DestSize = Length;
        }
    }

    *StartOffset = (ULONG)(DestPtr - VirtualAddress);

    return  DestBuf;

}


NTSTATUS
IPSecEncryptBuffer(
    IN  PVOID           pData,
    IN  PNDIS_BUFFER    *ppNewMdl,
    IN  PSA_TABLE_ENTRY pSA,
    IN  PNDIS_BUFFER    pPadBuf,
    OUT PULONG          pPadLen,
    IN  ULONG           PayloadType,
    IN  ULONG           Index,
    IN  PUCHAR          feedback
    )
{
    CONF_STATE_BUFFER   Key;
    PCONFID_ALGO        pConfAlgo;
    UCHAR   scratch[MAX_BLOCKLEN];  // scratch buffer for the encrypt
    UCHAR   scratch1[MAX_BLOCKLEN];  // scratch buffer for the encrypt
    PUCHAR  pDest=NULL;
    PNDIS_BUFFER    pEncryptMdl;
    ULONG   len;
    ULONG   blockLen;
    NTSTATUS    status;

    IPSEC_DEBUG(ESP, ("Entering IPSecEncryptBuffer: pData: %lx\n", pData));

    if (pSA->CONF_ALGO(Index) > NUM_CONF_ALGOS) {
        ASSERT(FALSE);
        return  STATUS_INVALID_PARAMETER;
    }

    pConfAlgo = &(conf_algorithms[pSA->CONF_ALGO(Index)]);
    blockLen = pConfAlgo->blocklen;

    //
    // set up the state buffer
    //
    pConfAlgo->init((PVOID)&Key, pSA->CONF_KEY(Index));

    IPSEC_DEBUG(HUGHES, ("pConfAlgo: %lx, blockLen: %lx IV: %lx-%lx\n", pConfAlgo, blockLen, *(PULONG)&feedback[0], *(PULONG)&feedback[4]));

    if (*ppNewMdl == NULL) {
        //
        // We should not encrypt in place: so we alloc a new buffer
        // Count up the total size and allocate the new buffer.
        // use that buffer as the dest of the encrypt.
        //
        IPSEC_GET_TOTAL_LEN(pData, &len);
#if DBG
        if ((len % 8) != 0) {
            DbgPrint("Length not kosher: pData: %lx, len: %d, pPadBuf: %lx, pPadLen: %d\n", pData, len, pPadBuf, pPadLen);
            DbgBreakPoint();
        }
#endif
        IPSecAllocateBuffer(&status, &pEncryptMdl, &pDest, len, IPSEC_TAG_ESP);

        if (!NT_SUCCESS(status)) {
            NTSTATUS    ntstatus;
            //ASSERT(FALSE);
            IPSEC_DEBUG(ESP, ("Failed to alloc. encrypt MDL\n"));
            return status;
        }

        IPSEC_DEBUG(ESP, ("Alloc. MDL: %lx, pDest: %lx, len: %d, pData: %lx\n", pEncryptMdl, pDest, len, pData));
    } else {
        ASSERT(FALSE);
        IPSecQueryNdisBuf(*ppNewMdl, &pDest, &len);
        pEncryptMdl = *ppNewMdl;
    }

    //
    // Now, send 64 bit (8 octet) chunks to CBC. We need to make sure
    // that the data is divided on contiguous 8 byte boundaries across
    // different buffers.
    //
    {
        PNDIS_BUFFER    pBuf = (PNDIS_BUFFER)pData;
        ULONG   bytesDone = 0;
        ULONG   bytesLeft;
        PUCHAR  pChunk;

        while (pBuf) {

            IPSecQueryNdisBuf(pBuf, &pChunk, &bytesLeft);

            pChunk += bytesDone;
            bytesLeft -= bytesDone;

            IPSEC_DEBUG(ESP, ("ESP: pChunk: %lx, bytesLeft: %d, bytesDone: %d\n", pChunk, bytesLeft, bytesDone));

            bytesDone = 0;

            while (bytesLeft >= blockLen) {
                //
                // Create the cipher.
                //
                pConfAlgo->encrypt( (PVOID)&Key,
                                    pDest,
                                    pChunk,
                                    feedback);

                pChunk += blockLen;
                bytesLeft -= blockLen;
                pDest += blockLen;
            }

            //
            // Check here if we need to collate blocks
            //
            if (NDIS_BUFFER_LINKAGE(pBuf) != NULL) {
                PUCHAR  pNextChunk;
                ULONG   nextSize;

                //
                // If some left over from prev. buffer, collate with next
                // block
                //
                if (bytesLeft) {
                    ULONG   offset = bytesLeft; // offset into scratch
                    ULONG   bytesToCollect = blockLen - bytesLeft;  // # of bytes to collect from next few MDLs
                    IPSEC_DEBUG(ESP, ("ESP: pChunk: %lx, bytesLeft: %d\n", pChunk, bytesLeft));

                    ASSERT(bytesLeft < blockLen);

                    //
                    // Copy into a scratch buffer
                    //
                    RtlCopyMemory(  scratch,
                                    pChunk,
                                    bytesLeft);

                    do {
                        ASSERT(NDIS_BUFFER_LINKAGE(pBuf));
                        IPSecQueryNdisBuf(NDIS_BUFFER_LINKAGE(pBuf), &pNextChunk, &nextSize);

                        if (nextSize >= (blockLen - offset)) {
                            RtlCopyMemory(  scratch+offset,
                                            pNextChunk,
                                            blockLen - offset);
                            bytesDone = blockLen - offset;

                            bytesToCollect -= (blockLen - offset);
                            ASSERT(bytesToCollect == 0);
                        } else {
                            IPSEC_DEBUG(ESP, ("special case, offset: %d, bytesLeft: %d, nextSize: %d, pNextChunk: %lx\n",
                                        offset, bytesLeft, nextSize, pNextChunk));

                            RtlCopyMemory(  scratch+offset,
                                            pNextChunk,
                                            nextSize);

                            bytesToCollect -= nextSize;
                            ASSERT(bytesToCollect);

                            offset += nextSize;
                            ASSERT(offset < blockLen);

                            ASSERT(bytesDone == 0);
                            pBuf = NDIS_BUFFER_LINKAGE(pBuf);
                        }
                    } while (bytesToCollect);

                    pConfAlgo->encrypt( (PVOID)&Key,
                                        pDest,
                                        scratch,
                                        feedback);

                    pDest += blockLen;
                }
            } else {
                PUCHAR  pPad;
                ULONG   padLen;
                ULONG   bufLen;

                //
                // End of the chain; pad with length and type to 8 byte boundary
                //
                ASSERT(bytesLeft < blockLen);

                // if ((pSA->sa_eOperation == HUGHES_TRANSPORT) ||
                   //  (pSA->sa_eOperation == HUGHES_TUNNEL)) {

                //
                // since only hughes is done now, this shd be always true.
                //
                if (TRUE) {
                    ASSERT(bytesLeft == 0);

                    //
                    // DONE: break out
                    //
                    break;
                }
            }
            pBuf = NDIS_BUFFER_LINKAGE(pBuf);
        }

        //
        // save IV for next encrypt cycle
        //
        RtlCopyMemory(  pSA->sa_iv[Index],
                        feedback,
                        pSA->sa_ivlen);

        IPSEC_DEBUG(HUGHES, ("IV: %lx-%lx\n", *(PULONG)&feedback[0], *(PULONG)&feedback[4]));
    }
#if DBG
    {
        ULONG   totalLen;

        IPSEC_GET_TOTAL_LEN(pEncryptMdl, &totalLen);
        ASSERT((totalLen % 8) == 0);
        IPSEC_DEBUG(ESP, ("total len: %lx\n", totalLen));
    }
#endif
    IPSEC_DEBUG(ESP, ("Exiting IPSecEncryptBuffer\n"));

    *ppNewMdl = pEncryptMdl;

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecDecryptBuffer(
    IN  PVOID           pData,
    IN  PSA_TABLE_ENTRY pSA,
    OUT PUCHAR          pPadLen,
    OUT PUCHAR          pPayloadType,
    IN  ULONG           Index
    )
{
    CONF_STATE_BUFFER   Key;
    PCONFID_ALGO        pConfAlgo;
    UCHAR   feedback[MAX_BLOCKLEN];
    UCHAR   scratch[MAX_BLOCKLEN];  // scratch buffer for the encrypt
    UCHAR   scratch1[MAX_BLOCKLEN];  // scratch buffer for the encrypt
    LONG    Len;
    UCHAR   padLen;
    UCHAR   payloadType;
    LONG    hdrLen;
	IPHeader UNALIGNED *pIPH;
    ESP UNALIGNED   *pEsp;
    PUCHAR  savePtr;
    LONG    espLen = sizeof(ESP) + pSA->sa_ivlen + pSA->sa_ReplayLen;
    LONG    blockLen;

    if (pSA->CONF_ALGO(Index) > NUM_CONF_ALGOS) {
        return  STATUS_INVALID_PARAMETER;
    }

    pConfAlgo = &(conf_algorithms[pSA->CONF_ALGO(Index)]);
    blockLen = pConfAlgo->blocklen;

    //
    // set up the state buffer
    //
    pConfAlgo->init((PVOID)&Key, pSA->CONF_KEY(Index));

    IPSecQueryRcvBuf(pData, (PUCHAR)&pEsp, &Len);

    //
    // Init the CBC feedback from the IV in the packet
    //
    // Actually if the sa_ivlen is 0, use the pSA one
    //
    if (pSA->sa_ivlen) {
        RtlCopyMemory(  feedback,
                        ((PUCHAR)(pEsp + 1) + pSA->sa_ReplayLen),
                        pSA->sa_ivlen);
        IPSEC_DEBUG(ESP, ("IV: %lx-%lx\n", *(PULONG)&feedback[0], *(PULONG)&feedback[4]));
    } else {
        RtlCopyMemory(  feedback,
                        pSA->sa_iv[Index],
                        DES_BLOCKLEN);
    }

    //
    // Bump the current pointer to after the ESP header
    //
    ((IPRcvBuf *)pData)->ipr_size -= espLen;
    savePtr = ((IPRcvBuf *)pData)->ipr_buffer;

    ((IPRcvBuf *)pData)->ipr_buffer = savePtr + espLen;

    //
    // Now, send 64 bit (8 octet) chunks to CBC. We need to make sure
    // that the data is divided on contiguous 8 byte boundaries across
    // different buffers.
    // NOTE: the algo below assumes that there are a minimum of 8 bytes
    // per buffer in the chain.
    //
    {
        IPRcvBuf    *pBuf = (IPRcvBuf *)pData;
        LONG    bytesDone = 0;
        LONG    bytesLeft;
        LONG    saveBytesLeft;
        PUCHAR  pChunk;
        PUCHAR  pSaveChunk;

        while (pBuf) {

            if (IPSEC_BUFFER_LEN(pBuf) == 0) {
                pBuf = IPSEC_BUFFER_LINKAGE(pBuf);
                continue;
            }

            IPSecQueryRcvBuf(pBuf, &pSaveChunk, &saveBytesLeft);

            bytesLeft = saveBytesLeft - bytesDone;
            pChunk = pSaveChunk + bytesDone;

            IPSEC_DEBUG(ESP, ("ESP: 1.pChunk: %lx, bytesLeft: %d, bytesDone: %d\n", pChunk, bytesLeft, bytesDone));
            bytesDone = 0;

            while (bytesLeft >= blockLen) {

                //
                // Decrypt the cipher.
                //
                pConfAlgo->decrypt( (PVOID)&Key,
                                    pChunk,
                                    pChunk,
                                    feedback);

                pChunk += blockLen;
                bytesLeft -= blockLen;
            }

            IPSEC_DEBUG(ESP, ("ESP: 2.pChunk: %lx, bytesLeft: %d, bytesDone: %d\n", pChunk, bytesLeft, bytesDone));

            //
            // Check here if we need to collate blocks
            //
            if (IPSEC_BUFFER_LINKAGE(pBuf) != NULL) {
                PUCHAR  pNextChunk;
                LONG    nextSize;

                if (IPSEC_BUFFER_LEN(IPSEC_BUFFER_LINKAGE(pBuf)) == 0) {
                    pBuf = IPSEC_BUFFER_LINKAGE(pBuf);
                }

                //
                // If some left over from prev. buffer, collate with next
                // block
                //
                if (bytesLeft) {
                    LONG    offset = bytesLeft;
                    IPSEC_DEBUG(ESP, ("ESP: 3.pChunk: %lx, bytesLeft: %d, bytesDone: %d\n", pChunk, bytesLeft, bytesDone));

                    ASSERT(bytesLeft < blockLen);

                    //
                    // Copy into a scratch buffer
                    //
                    RtlCopyMemory(  scratch,
                                    pChunk,
                                    bytesLeft);

                    IPSecQueryRcvBuf(IPSEC_BUFFER_LINKAGE(pBuf), &pNextChunk, &nextSize);

                    if (nextSize >= (blockLen - bytesLeft)) {
                        //
                        // Copy remaining bytes into scratch
                        //
                        RtlCopyMemory(  scratch+bytesLeft,
                                        pNextChunk,
                                        blockLen - bytesLeft);

                        pConfAlgo->decrypt( (PVOID)&Key,
                                            scratch,
                                            scratch,
                                            feedback);

                        //
                        // Copy cipher back into the payload
                        //
                        RtlCopyMemory(  pChunk,
                                        scratch,
                                        bytesLeft);

                        RtlCopyMemory(  pNextChunk,
                                        scratch+bytesLeft,
                                        blockLen - bytesLeft);

                        bytesDone = blockLen - bytesLeft;
                    } else {
                        //
                        // Ugh! Collect the remaining bytes from the chain and redistribute them
                        // after the decryption.
                        //
                        LONG    bytesToCollect = blockLen - bytesLeft;  // # of bytes to collect from next few MDLs
                        IPRcvBuf    *pFirstBuf = IPSEC_BUFFER_LINKAGE(pBuf); // to know where to start the distribution post decryption

                        do {
                            ASSERT(IPSEC_BUFFER_LINKAGE(pBuf));
                            IPSecQueryRcvBuf(IPSEC_BUFFER_LINKAGE(pBuf), &pNextChunk, &nextSize);

                            if (nextSize >= (blockLen - offset)) {
                                RtlCopyMemory(  scratch+offset,
                                                pNextChunk,
                                                blockLen - offset);
                                bytesDone = blockLen - offset;

                                bytesToCollect -= (blockLen - offset);
                                ASSERT(bytesToCollect == 0);
                            } else {
                                IPSEC_DEBUG(ESP, ("special case, offset: %d, bytesLeft: %d, nextSize: %d, pNextChunk: %lx\n",
                                            offset, bytesLeft, nextSize, pNextChunk));

                                RtlCopyMemory(  scratch+offset,
                                                pNextChunk,
                                                nextSize);

                                bytesToCollect -= nextSize;
                                ASSERT(bytesToCollect);

                                offset += nextSize;
                                ASSERT(offset < blockLen);

                                ASSERT(bytesDone == 0);
                                pBuf = IPSEC_BUFFER_LINKAGE(pBuf);
                            }
                        } while (bytesToCollect);

                        pConfAlgo->decrypt( (PVOID)&Key,
                                            scratch,
                                            scratch,
                                            feedback);
                        //
                        // Now distribute the bytes back to the MDLs
                        //
                        RtlCopyMemory(  pChunk,
                                        scratch,
                                        bytesLeft);

                        pBuf = CopyToRcvBuf(pFirstBuf,
                                            scratch+bytesLeft,
                                            blockLen - bytesLeft,
                                            &bytesDone);
                        continue;

                    }
                }
            } else {
                //
                // end of chain.
                // should never come here with bytes left over since the
                // sender should pad to 8 byte boundary.
                //
                ASSERT(bytesLeft == 0);

                IPSEC_DEBUG(ESP, ("ESP: 4.pChunk: %lx, saveBytesLeft: %d, bytesDone: %d\n", pChunk, saveBytesLeft, bytesDone));

                IPSEC_DEBUG(ESP, ("ESP: HUGHES: will remove pad later\n"));
                break;
            }

            pBuf = (IPRcvBuf *)IPSEC_BUFFER_LINKAGE(pBuf);
        }
    }

    //
    // Restore the first MDL
    //
    ((IPRcvBuf *)pData)->ipr_size += espLen;
    ((IPRcvBuf *)pData)->ipr_buffer = savePtr;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\externs.h ===
extern ULONG IPSecNumResets;

#if DBG
extern ULONG NumAddSA;
extern ULONG NumAddSU;
extern ULONG NumAddFA;
extern ULONG NumDelSA;
extern ULONG NumDelSU;
extern ULONG NumDelFA;
extern ULONG NumReset;
#endif

//
//  Max timeout value (in seconds) for each class.
//
extern ULONG IPSecMaxTimerValue[];

//
//  Size of each timer wheel.
//
extern ULONG IPSecTimerListSize[];

//
//  Interval between ticks, in seconds, for each class.
//
extern ULONG IPSecTimerPeriod[];

#if GPC
extern ULONG DebugGPC;
#endif

extern AUTH_ALGO auth_algorithms[];

extern CONFID_ALGO conf_algorithms[];

#if DBG
extern ULONG IPSecDebug;
#endif

extern UCHAR DefaultPad[];


#if DBG
extern IPAddr DebugSrc;
extern IPAddr DebugDst;
extern UCHAR DebugPro;
extern ULONG DebugPkt;
extern ULONG DebugOff;
extern ULONG DebugQry;
#endif

extern RC4_KEYSTRUCT IPSecRngKey;

extern WORK_QUEUE_ITEM IPSecRngQueueItem;

extern ULONG IPSecRngBytes;

#if DBG
extern ULONG IPSecRngInRekey;
#endif


extern unsigned char weak_keys[][DES_BLOCKLEN];

extern PDEVICE_OBJECT IPSecDevice;

extern ULONG IPSecInitFlag;

extern IPSEC_GLOBAL g_ipsec;

extern LARGE_INTEGER IPSecDelayInterval;

extern DWORD gdwInitEsp;

extern DWORD gdwInitAh;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\filter.h ===
VOID
IPSecPopulateFilter(
    IN  PFILTER         pFilter,
    IN  PIPSEC_FILTER   pIpsecFilter
    );

NTSTATUS
IPSecCreateFilter(
    IN  PIPSEC_FILTER_INFO  pFilterInfo,
    OUT PFILTER             *ppFilter
    );

NTSTATUS
IPSecInsertFilter(
    IN PFILTER             pFilter
    );

NTSTATUS
IPSecRemoveFilter(
    IN PFILTER             pFilter
    );

NTSTATUS
IPSecSearchFilter(
    IN  PFILTER MatchFilter,
    OUT PFILTER *ppFilter
    );

__inline
VOID
IPSecDeleteTempFilters(
    PLIST_ENTRY pTempFilterList
    );

NTSTATUS
IPSecAddFilter(
    IN  PIPSEC_ADD_FILTER   pAddFilter
    );

NTSTATUS
IPSecDeleteFilter(
    IN  PIPSEC_DELETE_FILTER    pDelFilter
    );

VOID
IPSecFillFilterInfo(
    IN  PFILTER             pFilter,
    OUT PIPSEC_FILTER_INFO  pBuf
    );

NTSTATUS
IPSecEnumFilters(
    IN  PIRP    pIrp,
    OUT PULONG  pBytesCopied
    );

//
// PNDIS_BUFFER
// REQUEST_NDIS_BUFFER(
//     IN PREQUEST Request
//     );
//
// Returns the NDIS buffer chain associated with a request.
//

#define REQUEST_NDIS_BUFFER(_Request) \
    ((PNDIS_BUFFER)((_Request)->MdlAddress))

PNDIS_BUFFER
CopyToNdis(
    IN  PNDIS_BUFFER    DestBuf,
    IN  PUCHAR          SrcBuf,
    IN  ULONG           Size,
    IN  PULONG          StartOffset
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\esp.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    ah.h

Abstract:

    Contains ESP specific structures

Author:

    Sanjay Anand (SanjayAn) 11-November-1997
    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#ifndef _ESP_
#define _ESP_


typedef struct _CONF_STATE_BUFFER {
    union {
        DESTable    desTable;
        DES3TABLE   des3Table;
    };
} CONF_STATE_BUFFER, *PCONF_STATE_BUFFER;


typedef VOID
(*PCONF_ALGO_INIT) (
    PVOID   pState,
    PUCHAR  pKey
);

typedef VOID
(*PCONF_ALGO_ENCRYPT) (
    PVOID   pState,
    PUCHAR  pOut,
    PUCHAR  pIn,
    PUCHAR  pIV
);

VOID        esp_nullinit       (PVOID, PUCHAR);
VOID        esp_nullencrypt    (PVOID, PUCHAR, PUCHAR, PUCHAR);
VOID        esp_nulldecrypt    (PVOID, PUCHAR, PUCHAR, PUCHAR);

VOID        esp_desinit        (PVOID, PVOID);
VOID        esp_desencrypt     (PVOID, PUCHAR, PUCHAR, PUCHAR);
VOID        esp_desdecrypt     (PVOID, PUCHAR, PUCHAR, PUCHAR);

VOID        esp_3_desinit      (PVOID, PVOID);
VOID        esp_3_desencrypt   (PVOID, PUCHAR, PUCHAR, PUCHAR);
VOID        esp_3_desdecrypt   (PVOID, PUCHAR, PUCHAR, PUCHAR);


//
// Array of function ptrs for the ESP confidentiality algorithms
//
typedef struct  _confid_algorithm {
  PCONF_ALGO_INIT       init;       // ptr to init fn for alg.
  PCONF_ALGO_ENCRYPT    encrypt;    // ptr to encrypt fn for alg
  PCONF_ALGO_ENCRYPT    decrypt;    // ptr to encrypt fn for alg
  ULONG                 blocklen;   // Length (in u_int8s) of output
                                    // data. MUST be a multiple of 4
} CONFID_ALGO, *PCONFID_ALGO;


#define NUM_CONF_ALGOS (sizeof(conf_algorithms)/sizeof(CONFID_ALGO)-1)


IPRcvBuf *
CopyToRcvBuf(
    IN  IPRcvBuf        *DestBuf,
    IN  PUCHAR          SrcBuf,
    IN  ULONG           Size,
    IN  PULONG          StartOffset
    );

NTSTATUS
IPSecEncryptBuffer(
    IN  PVOID           pData,
    IN  PNDIS_BUFFER    *ppNewMdl,
    IN  PSA_TABLE_ENTRY pSA,
    IN  PNDIS_BUFFER    pPadBuf,
    OUT PULONG          pPadLen,
    IN  ULONG           PayloadType,
    IN  ULONG           Index,
    IN  PUCHAR          feedback
    );

NTSTATUS
IPSecDecryptBuffer(
    IN  PVOID           pData,
    IN  PSA_TABLE_ENTRY pSA,
    OUT PUCHAR          pPadLen,
    OUT PUCHAR          pPayloadType,
    IN  ULONG           Index
    );

#endif _ESP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\filter.c ===
#include "precomp.h"


VOID
IPSecPopulateFilter(
    IN  PFILTER         pFilter,
    IN  PIPSEC_FILTER   pIpsecFilter
    )
/*++

Routine Description

    Populates a Filter block with IpsecFilter info sent in

Arguments


Return Value


--*/
{
    pFilter->SRC_ADDR = pIpsecFilter->SrcAddr;
    pFilter->DEST_ADDR = pIpsecFilter->DestAddr;
    pFilter->SRC_MASK = pIpsecFilter->SrcMask;
    pFilter->DEST_MASK = pIpsecFilter->DestMask;

    pFilter->TunnelFilter = pIpsecFilter->TunnelFilter;
    pFilter->TunnelAddr = pIpsecFilter->TunnelAddr;
    pFilter->Flags = pIpsecFilter->Flags;

    //
    // Now the network ordering stuff - tricky part
    // LP0    LP1 LP2 LP3 HP0 HP1 HP2 HP3
    // Proto  00  00  00  SrcPort DstPort
    //

    //
    // For addresses, ANY_ADDR is given by 0.0.0.0 and the MASK must be 0.0.0.0
    // For proto and ports 0 means any and the mask is generated as follows
    // If the proto is O then LP0 for Mask is 0xff else its 0x00
    // If a port is 0, the corresponding XP0XP1 is 0x0000 else its 0xffff
    //

    //
    // The protocol is in the low byte of the dwProtocol, so we take that out and
    // make a dword out of it
    //

    pFilter->uliProtoSrcDstPort.LowPart =
      MAKELONG(MAKEWORD(LOBYTE(LOWORD(pIpsecFilter->Protocol)),0x00),0x0000);

    pFilter->uliProtoSrcDstMask.LowPart = MAKELONG(MAKEWORD(0xff,0x00),0x0000);

    switch(pIpsecFilter->Protocol) {
        case FILTER_PROTO_ANY: {
            pFilter->uliProtoSrcDstPort.HighPart = 0x00000000;
            pFilter->uliProtoSrcDstMask.LowPart = 0x00000000;
            pFilter->uliProtoSrcDstMask.HighPart = 0x00000000;

            break;
        }
        case FILTER_PROTO_ICMP: {
            WORD wTypeCode = 0x0000;
            WORD wTypeCodeMask = 0x0000;

            pFilter->uliProtoSrcDstPort.HighPart = MAKELONG(wTypeCode,0x0000);
            pFilter->uliProtoSrcDstMask.HighPart = MAKELONG(wTypeCodeMask,0x0000);

            break;
        }
        case FILTER_PROTO_TCP:
        case FILTER_PROTO_UDP: {
            DWORD dwSrcDstPort = 0x00000000;
            DWORD dwSrcDstMask = 0x00000000;

            if(pIpsecFilter->SrcPort != FILTER_TCPUDP_PORT_ANY) {
                dwSrcDstPort |= MAKELONG(NET_TO_HOST_SHORT(pIpsecFilter->SrcPort), 0x0000);
                dwSrcDstMask |= MAKELONG(0xffff, 0x0000);
            }

            if(pIpsecFilter->DestPort != FILTER_TCPUDP_PORT_ANY) {
                dwSrcDstPort |= MAKELONG(0x0000, NET_TO_HOST_SHORT(pIpsecFilter->DestPort));
                dwSrcDstMask |= MAKELONG(0x0000, 0xffff);
            }

            pFilter->uliProtoSrcDstPort.HighPart = dwSrcDstPort;
            pFilter->uliProtoSrcDstMask.HighPart = dwSrcDstMask;

            break;
        }
        default: {
            //
            // All other protocols have no use for the port field
            //
            pFilter->uliProtoSrcDstPort.HighPart = 0x00000000;
            pFilter->uliProtoSrcDstMask.HighPart = 0x00000000;
        }
    }
}


NTSTATUS
IPSecCreateFilter(
    IN  PIPSEC_FILTER_INFO  pFilterInfo,
    OUT PFILTER             *ppFilter
    )
/*++

Routine Description

    Creates a Filter block

Arguments

    PIPSEC_ADD_FILTER

Return Value


--*/
{
    PFILTER         pFilter;
    PIPSEC_FILTER   pIpsecFilter = &pFilterInfo->AssociatedFilter;
    LONG            FilterSize, SAChainSize;
    LONG            NumberOfOnes;
    LONG            i;

    IPSEC_DEBUG(SAAPI, ("Entering CreateFilterBlock\n"));

    if (pFilterInfo->AssociatedFilter.TunnelFilter) {
        SAChainSize = 1;
    } else {
        if (pFilterInfo->AssociatedFilter.Flags & FILTER_FLAGS_INBOUND) {
            NumberOfOnes = CountNumberOfOnes(pFilterInfo->AssociatedFilter.SrcMask);
        } else {
            NumberOfOnes = CountNumberOfOnes(pFilterInfo->AssociatedFilter.DestMask);
        }

        SAChainSize = 1 << (((sizeof(IPMask) * 8) - NumberOfOnes) / SA_CHAIN_WIDTH);
    }

    FilterSize = FIELD_OFFSET(FILTER, SAChain[0]) + SAChainSize * sizeof(LIST_ENTRY);

    pFilter = IPSecAllocateMemory(FilterSize, IPSEC_TAG_FILTER);

    if (!pFilter) {
        IPSEC_DEBUG(SAAPI, ("IPFILTER: Couldnt allocate memory for in filter set\n"));
        *ppFilter = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    IPSecZeroMemory(pFilter, FilterSize);

    pFilter->Signature = IPSEC_FILTER_SIGNATURE;

    pFilter->SAChainSize = SAChainSize;

    for (i = 0; i < SAChainSize; i++) {
        InitializeListHead(&pFilter->SAChain[i]);
    }

    pFilter->PolicyId = pFilterInfo->PolicyId;
    pFilter->FilterId = pFilterInfo->FilterId;

    pFilter->Reference = 1;

    pFilter->Index = pFilterInfo->Index;

    IPSecPopulateFilter(pFilter, pIpsecFilter);

    *ppFilter = pFilter;

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecInsertFilter(
    IN PFILTER             pFilter
    )
/*++

Routine Description

    Inserts a filter into one of the two databases - specific/general pattern
    database.

Arguments

    PFILTER

Return Value


--*/
{
    NTSTATUS    status;
    PFILTER     pTempFilter;
    BOOL        InsertedFilter = FALSE;
    PLIST_ENTRY pEntry, pPrev;
    PLIST_ENTRY pFilterList;

    pFilterList = IPSecResolveFilterList(   IS_TUNNEL_FILTER(pFilter),
                                            IS_OUTBOUND_FILTER(pFilter));

    pEntry = pFilterList->Flink;
    pPrev = pFilterList;

    while (pEntry != pFilterList) {
        pTempFilter = CONTAINING_RECORD(pEntry,
                                        FILTER,
                                        MaskedLinkage);

        if (pFilter->Index > pTempFilter->Index) {
            //
            // found the spot, insert it before pTempFilter
            //
            InsertHeadList(pPrev, &pFilter->MaskedLinkage);
            pFilter->LinkedFilter = TRUE;
            InsertedFilter = TRUE;
            break;
        }

        pPrev = pEntry;
        pEntry = pEntry->Flink;
    }

    if (!InsertedFilter) {
        //
        // didn't find spot, stick it in the end
        //
        InsertTailList(pFilterList, &pFilter->MaskedLinkage);
        pFilter->LinkedFilter = TRUE;
    }

    if (IS_TUNNEL_FILTER(pFilter)) {
        g_ipsec.NumTunnelFilters++;
    } else {
        g_ipsec.NumMaskedFilters++;
    }

    if (IS_MULTICAST_FILTER(pFilter)) {
        IPSEC_INCREMENT(g_ipsec.NumMulticastFilters);
    }
    ++g_ipsec.NumPolicies;

    if (g_ipsec.NumPolicies == 1) {
        TCPIP_SET_IPSEC_STATUS(TRUE);
    }

    IPSEC_DEBUG(SAAPI, ("IPSecInsertFilter: inserted into filter list %lx\n", pFilter));

    IPSecResetCacheTable();

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecRemoveFilter(
    IN PFILTER             pFilter
    )
/*++

Routine Description

    Deletes a filter from one of the two databases - specific/general pattern
    database.
    Runs down the SAs then blows away the memory.

Arguments

    PFILTER

Return Value


--*/
{
    IPSEC_DEBUG(IOCTL, ("In IPSecRemoveFilter!\n"));

    IPSecPurgeFilterSAs(pFilter);

    IPSecResetCacheTable();

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecSearchFilter(
    IN  PFILTER MatchFilter,
    OUT PFILTER *ppFilter
    )
/*++

Routine Description

    Utility routine to search for a filter in the database.

    NOTE: MUST be called with the SADB lock held.

Arguments

    MatchFilter -   the criteria to match

    ppFilter    -   return the filter matched

Return Value


--*/
{
    BOOLEAN         fFound = FALSE;
    PLIST_ENTRY     pEntry;
    PLIST_ENTRY     pFilterList;
    PFILTER         pFilter;
    NTSTATUS        status = STATUS_NOT_FOUND;

    *ppFilter = NULL;

    pFilterList = IPSecResolveFilterList(   IS_TUNNEL_FILTER(MatchFilter),
                                            IS_OUTBOUND_FILTER(MatchFilter));

    //
    // Search in the filter list that the filter corresponds to.
    //
    for (   pEntry = pFilterList->Flink;
            pEntry != pFilterList;
            pEntry = pEntry->Flink) {

        pFilter = CONTAINING_RECORD(pEntry,
                                    FILTER,
                                    MaskedLinkage);

        if ((MatchFilter->uliSrcDstAddr.QuadPart == pFilter->uliSrcDstAddr.QuadPart) &&
            (MatchFilter->uliSrcDstMask.QuadPart == pFilter->uliSrcDstMask.QuadPart) &&
            (MatchFilter->uliProtoSrcDstPort.QuadPart == pFilter->uliProtoSrcDstPort.QuadPart) &&
            (MatchFilter->uliProtoSrcDstMask.QuadPart == pFilter->uliProtoSrcDstMask.QuadPart)) {
            IPSEC_DEBUG(HASH, ("Matched entry: %lx\n", pFilter));

            status = STATUS_SUCCESS;
            *ppFilter = pFilter;
            fFound = TRUE;
            break;
        }
    }

    return status;
}


__inline
VOID
IPSecDeleteTempFilters(
    PLIST_ENTRY pTempFilterList
    )
{
    PLIST_ENTRY pEntry;
    PFILTER     pFilter;

    while (!IsListEmpty(pTempFilterList)) {
        pEntry = RemoveHeadList(pTempFilterList);

        pFilter = CONTAINING_RECORD(pEntry,
                                    FILTER,
                                    MaskedLinkage);

#if GPC
        IPSecUninstallGpcFilter(pFilter);
#endif

        IPSecFreeFilter(pFilter);
    }
}


NTSTATUS
IPSecAddFilter(
    IN  PIPSEC_ADD_FILTER   pAddFilter
    )
/*++

Routine Description

    Called by the Policy Agent, sets up the input policies. A list of
    filters is sent down with associated PolicyIds (GUIDs) that make
    sense to the Key Management layer up above (e.g. ISAKMP).

Arguments

    PIPSEC_ADD_FILTER

Return Value


--*/
{
    PIPSEC_FILTER_INFO  pFilterInfo = pAddFilter->pInfo;
    ULONG               numPolicies = pAddFilter->NumEntries;
    ULONG               i;
    PFILTER             pFilter;
    PFILTER             pTempFilter;
    LIST_ENTRY          TempFilterList;
    PLIST_ENTRY         pEntry;
    NTSTATUS            status;
    KIRQL               kIrql;

#if GPC
    //
    // Temporarily disable GPC while add is pending.  Re-enable when done.
    //
    IPSecDisableGpc();
#endif

    //
    // Pre-allocate memory for filters plumbed.  Return right away if failed.
    //
    InitializeListHead(&TempFilterList);

    for (i = 0; i < numPolicies; i++) {
        status = IPSecCreateFilter(pFilterInfo, &pFilter);

        if (!NT_SUCCESS(status)) {
            IPSEC_DEBUG(SAAPI, ("IPSecCreateFilter failed: %lx\n", status));

            IPSecDeleteTempFilters(&TempFilterList);

#if GPC
            IPSecEnableGpc();
#endif

            return  status;
        }

        InsertTailList(&TempFilterList, &pFilter->MaskedLinkage);

        AcquireReadLock(&g_ipsec.SADBLock, &kIrql);

        status = IPSecSearchFilter(pFilter, &pTempFilter);

        ReleaseReadLock(&g_ipsec.SADBLock, kIrql);

        if (NT_SUCCESS(status)) {
            IPSEC_DEBUG(SAAPI, ("IPSecSearchFilter returns duplicate: %lx\n", status));

            IPSecDeleteTempFilters(&TempFilterList);

#if GPC
            IPSecEnableGpc();
#endif

            return  STATUS_DUPLICATE_OBJECTID;
        }

#if GPC
        status = IPSecInstallGpcFilter(pFilter);

        if (!NT_SUCCESS(status)) {
            IPSEC_DEBUG(SAAPI, ("IPSecInstallGpcFilter failed: %lx\n", status));

            IPSecDeleteTempFilters(&TempFilterList);

            IPSecEnableGpc();

            return  status;
        }
#endif

        pFilterInfo++;
    }

    //
    // Iterate through the filters, adding each to the Filter database
    //
    while (!IsListEmpty(&TempFilterList)) {
        pEntry = RemoveHeadList(&TempFilterList);

        pFilter = CONTAINING_RECORD(pEntry,
                                    FILTER,
                                    MaskedLinkage);

        AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

        status = IPSecInsertFilter(pFilter);

        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

        if (!NT_SUCCESS(status)) {
            IPSEC_DEBUG(SAAPI, ("IPSecInsertFilter failed: %lx\n", status));
            ASSERT(FALSE);
        }
    }

#if GPC
    //
    // Re-enable GPC for fast lookup.
    //
    IPSecEnableGpc();
#endif

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecDeleteFilter(
    IN  PIPSEC_DELETE_FILTER    pDelFilter
    )
/*++

Routine Description

    Called by the Policy Agent to delete a set of filters. we delete
    all associated outbound filters first and expire the inbound ones.

Arguments

    PIPSEC_DELETE_FILTER

Return Value


--*/
{
    PIPSEC_FILTER_INFO  pFilterInfo = pDelFilter->pInfo;
    ULONG               numPolicies = pDelFilter->NumEntries;
    ULONG               i;
    PFILTER             pFilter;
    FILTER              matchFilter = {0};
    NTSTATUS            status = STATUS_SUCCESS;
    KIRQL               kIrql;

#if GPC
    //
    // Temporarily disable GPC while delete is pending.  Re-enable when done.
    //
    IPSecDisableGpc();
#endif

    //
    // iterate through the filters, deleting each from the Filter database
    //
    for (i = 0; i < numPolicies; i++) {
        PIPSEC_FILTER   pIpsecFilter = &pFilterInfo->AssociatedFilter;

        IPSecPopulateFilter(&matchFilter, pIpsecFilter);

        AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

        status = IPSecSearchFilter(&matchFilter, &pFilter);

        if (!NT_SUCCESS(status)) {
            IPSEC_DEBUG(SAAPI, ("IPSecDeletePolicy: Filter not found \n"));
            ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
            break;
        }

        //
        // remove from list
        //
        IPSecRemoveEntryList(&pFilter->MaskedLinkage);
        pFilter->LinkedFilter = FALSE;

        if (IS_TUNNEL_FILTER(pFilter)) {
            g_ipsec.NumTunnelFilters--;
        } else {
            g_ipsec.NumMaskedFilters--;
        }
        --g_ipsec.NumPolicies;

        if (IS_MULTICAST_FILTER(pFilter)) {
            IPSEC_DECREMENT(g_ipsec.NumMulticastFilters);
        }

        if (g_ipsec.NumPolicies == 0) {
            TCPIP_SET_IPSEC_STATUS(FALSE);
        }

        IPSecRemoveFilter(pFilter);

        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

#if GPC
        IPSecUninstallGpcFilter(pFilter);
#endif

        IPSecDerefFilter(pFilter);

        pFilterInfo++;
    }

#if GPC
    //
    // Re-enable GPC for fast lookup.
    //
    IPSecEnableGpc();
#endif

    return status;
}


VOID
IPSecFillFilterInfo(
    IN  PFILTER             pFilter,
    OUT PIPSEC_FILTER_INFO  pBuf
    )
/*++

Routine Description:

    Fill out the FILTER_INFO structure.

Arguments:

    pFilter - filter to be filled in
    pBuf    - where to fill in

Returns:

    None.

--*/
{
    //
    // now fill in the buffer
    //
    pBuf->FilterId = pFilter->FilterId;
    pBuf->PolicyId = pFilter->PolicyId;
    pBuf->Index = pFilter->Index;

    pBuf->AssociatedFilter.SrcAddr = pFilter->SRC_ADDR;
    pBuf->AssociatedFilter.DestAddr = pFilter->DEST_ADDR;
    pBuf->AssociatedFilter.SrcMask = pFilter->SRC_MASK;
    pBuf->AssociatedFilter.DestMask = pFilter->DEST_MASK;

    pBuf->AssociatedFilter.Protocol = pFilter->PROTO;
    pBuf->AssociatedFilter.SrcPort = FI_SRC_PORT(pFilter);
    pBuf->AssociatedFilter.DestPort = FI_DEST_PORT(pFilter);

    pBuf->AssociatedFilter.TunnelAddr = pFilter->TunnelAddr;
    pBuf->AssociatedFilter.TunnelFilter = pFilter->TunnelFilter;

    pBuf->AssociatedFilter.Flags = pFilter->Flags;
}


NTSTATUS
IPSecEnumFilters(
    IN  PIRP    pIrp,
    OUT PULONG  pBytesCopied
    )
/*++

Routine Description:

    Fills in the request to enumerate Filters.

Arguments:

    pIrp            - The actual Irp
    pBytesCopied    - the number of bytes copied.

Returns:

    Status of the operation.

--*/
{
    PNDIS_BUFFER        NdisBuffer = NULL;
    PIPSEC_ENUM_FILTERS pEnum = NULL;
    ULONG               BufferLength = 0;
    KIRQL               kIrql;
    PLIST_ENTRY         pEntry;
    IPSEC_FILTER_INFO   InfoBuff = {0};
    NTSTATUS            status = STATUS_SUCCESS;
    ULONG               BytesCopied = 0;
    ULONG               Offset = 0;
    IPSEC_FILTER_INFO   infoBuff;
    LONG                FilterIndex;
    PFILTER             pFilter;

    //
    // Get at the IO buffer - its in the MDL
    //
    NdisBuffer = REQUEST_NDIS_BUFFER(pIrp);
    if (NdisBuffer == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    NdisQueryBufferSafe(NdisBuffer,
                        (PVOID *)&pEnum,
                        &BufferLength,
                        NormalPagePriority);

    //
    // Make sure NdisQueryBufferSafe succeeds.
    //
    if (!pEnum) {
        IPSEC_DEBUG(IOCTL, ("EnumFilters failed, no resources\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Make sure we have enough room for just the header not
    // including the data.
    //
    if (BufferLength < (UINT)(FIELD_OFFSET(IPSEC_ENUM_FILTERS, pInfo[0]))) {
        IPSEC_DEBUG (IOCTL, ("EnumFilters failed, buffer too small\n"));
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Make sure we are naturally aligned.
    //
    if (((ULONG_PTR)(pEnum)) & (TYPE_ALIGNMENT(IPSEC_ENUM_FILTERS) - 1)) {
        IPSEC_DEBUG (IOCTL, ("EnumFilters failed, alignment\n"));
        return STATUS_DATATYPE_MISALIGNMENT_ERROR;
    }

    pEnum->NumEntries = 0;
    pEnum->NumEntriesPresent = 0;

    AcquireReadLock(&g_ipsec.SADBLock, &kIrql);

    //
    // Now copy over the filter data into the user buffer.
    //
    if (g_ipsec.NumPolicies) {
        //
        // see how many we can fit in the output buffer
        //
        BufferLength -= FIELD_OFFSET(IPSEC_ENUM_FILTERS, pInfo[0]);
        Offset = FIELD_OFFSET(IPSEC_ENUM_FILTERS, pInfo[0]);

        for (   FilterIndex = MIN_FILTER;
                FilterIndex <= MAX_FILTER;
                FilterIndex++) {

            for (   pEntry = g_ipsec.FilterList[FilterIndex].Flink;
                    pEntry != &g_ipsec.FilterList[FilterIndex];
                    pEntry = pEntry->Flink) {

                pFilter = CONTAINING_RECORD(pEntry,
                                            FILTER,
                                            MaskedLinkage);

                pEnum->NumEntriesPresent++;

                if ((INT)(BufferLength - BytesCopied) >= (INT)sizeof(IPSEC_FILTER_INFO)) {
                    IPSecFillFilterInfo(pFilter, &infoBuff);
                    BytesCopied += sizeof(IPSEC_FILTER_INFO);
                    NdisBuffer = CopyToNdis(NdisBuffer, (UCHAR *)&infoBuff, sizeof(IPSEC_FILTER_INFO), &Offset);
                    if (!NdisBuffer) {
                        ReleaseReadLock(&g_ipsec.SADBLock, kIrql);
                        return STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
            }
        }

        pEnum->NumEntries = BytesCopied / sizeof(IPSEC_FILTER_INFO);

        *pBytesCopied = BytesCopied + FIELD_OFFSET(IPSEC_ENUM_FILTERS, pInfo[0]);

        if (pEnum->NumEntries < pEnum->NumEntriesPresent) {
            status = STATUS_BUFFER_OVERFLOW;
        }
    }

    ReleaseReadLock(&g_ipsec.SADBLock, kIrql);

    return status;
}


PNDIS_BUFFER
CopyToNdis(
    IN  PNDIS_BUFFER    DestBuf,
    IN  PUCHAR          SrcBuf,
    IN  ULONG           Size,
    IN  PULONG          StartOffset
    )
/*++

    Copy a flat buffer to an NDIS_BUFFER chain.

    A utility function to copy a flat buffer to an NDIS buffer chain. We
    assume that the NDIS_BUFFER chain is big enough to hold the copy amount;
    in a debug build we'll  debugcheck if this isn't true. We return a pointer
    to the buffer where we stopped copying, and an offset into that buffer.
    This is useful for copying in pieces into the chain.

  	Input:

        DestBuf     - Destination NDIS_BUFFER chain.
        SrcBuf      - Src flat buffer.
        Size        - Size in bytes to copy.
        StartOffset - Pointer to start of offset into first buffer in
                        chain. Filled in on return with the offset to
                        copy into next.

  	Returns:

        Pointer to next buffer in chain to copy into.
--*/
{
    UINT        CopySize;
    UCHAR       *DestPtr;
    UINT        DestSize;
    UINT        Offset = *StartOffset;
    UCHAR      *VirtualAddress = NULL;
    UINT        Length = 0;

    if (DestBuf == NULL || SrcBuf == NULL) {
        IPSEC_DEBUG (IOCTL, ("CopyToNdis failed, DestBuf or SrcBuf is NULL\n"));
        ASSERT(FALSE);
        return  NULL;
    }

    NdisQueryBufferSafe(DestBuf,
                        (PVOID *)&VirtualAddress,
                        &Length,
                        NormalPagePriority);

    if (!VirtualAddress) {
        IPSEC_DEBUG (IOCTL, ("CopyToNdis failed, NdisQueryBuffer returns NULL\n"));
        return  NULL;
    }

    ASSERT(Length >= Offset);
    DestPtr = VirtualAddress + Offset;
    DestSize = Length - Offset;

    for (;;) {
        CopySize = MIN(Size, DestSize);
        RtlCopyMemory(DestPtr, SrcBuf, CopySize);

        DestPtr += CopySize;
        SrcBuf += CopySize;

        if ((Size -= CopySize) == 0)
            break;

        if ((DestSize -= CopySize) == 0) {
            DestBuf = NDIS_BUFFER_LINKAGE(DestBuf);

            if (DestBuf == NULL) {
                ASSERT(FALSE);
                break;
            }

            VirtualAddress = NULL;
            Length = 0;

            NdisQueryBufferSafe(DestBuf,
                                (PVOID *)&VirtualAddress,
                                &Length,
                                NormalPagePriority);

            if (!VirtualAddress) {
                IPSEC_DEBUG (IOCTL, ("CopyToNdis failed, NdisQueryBuffer returns NULL\n"));
                return  NULL;
            }

            DestPtr = VirtualAddress;
            DestSize = Length;
        }
    }

    *StartOffset = (ULONG)(DestPtr - VirtualAddress);

    return DestBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\gpc.c ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    gpc.c

Abstract:

    This module contains the GPC implementation

Author:

    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#include "precomp.h"


#if GPC


NTSTATUS
IPSecGpcInitialize()
{
    NTSTATUS    status;
    INT         cf, i;

    PAGED_CODE();

    //
    // Initialize FilterList for patterns that are not installed in GPC.
    //
    for (i = MIN_FILTER; i <= MAX_FILTER; i++) {
        InitializeListHead(&g_ipsec.GpcFilterList[i]);
    }

    //
    // Start with inactive state for the error path.
    //
    IPSEC_DRIVER_INIT_GPC() = FALSE;
    IPSEC_UNSET_GPC_ACTIVE();

    //
    // GPC registration.
    //
    status = GpcInitialize(&g_ipsec.GpcEntries);

    if (status == STATUS_SUCCESS) {
        for (cf = GPC_CF_IPSEC_MIN; cf <= GPC_CF_IPSEC_MAX; cf++) {
            status = GPC_REGISTER_CLIENT(   cf,
                                            0,
                                            GPC_PRIORITY_IPSEC,
                                            NULL,
                                            NULL,
                                            &g_ipsec.GpcClients[cf]);

            if (status != STATUS_SUCCESS) {
                IPSEC_DEBUG(LOAD, ("GPC failed to register cf %d\n", cf));

                g_ipsec.GpcClients[cf] = NULL;
                IPSecGpcDeinitialize();

                return  status;
            }
        }
    } else {
        IPSEC_DEBUG(LOAD, ("Failed to init GPC structures\n"));
        return  status;
    }

    IPSEC_SET_GPC_ACTIVE();
    IPSEC_DRIVER_INIT_GPC() = TRUE;

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecGpcDeinitialize()
{
    INT cf;

    PAGED_CODE();

    IPSEC_UNSET_GPC_ACTIVE();

    //
    // GPC deregistration.
    //
    for (cf = GPC_CF_IPSEC_MIN; cf <= GPC_CF_IPSEC_MAX; cf++) {
        if (g_ipsec.GpcClients[cf]) {
            GPC_DEREGISTER_CLIENT(g_ipsec.GpcClients[cf]);
        }
    }

    GpcDeinitialize(&g_ipsec.GpcEntries);

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecEnableGpc()
{
    KIRQL   kIrql;

    PAGED_CODE();

    if (IPSEC_DRIVER_INIT_GPC()) {
        AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

        IPSEC_SET_GPC_ACTIVE();

        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
    }

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecDisableGpc()
{
    KIRQL   kIrql;

    PAGED_CODE();

    if (IPSEC_DRIVER_INIT_GPC()) {
        AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

        IPSEC_UNSET_GPC_ACTIVE();

        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
    }

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecInitGpcFilter(
    IN  PFILTER         pFilter,
    IN  PGPC_IP_PATTERN pPattern,
    IN  PGPC_IP_PATTERN pMask
    )
{
    PAGED_CODE();

    RtlZeroMemory(pPattern, sizeof(GPC_IP_PATTERN));
    RtlZeroMemory(pMask, sizeof(GPC_IP_PATTERN));

    pPattern->SrcAddr = pFilter->SRC_ADDR;
    pPattern->DstAddr = pFilter->DEST_ADDR;
    pPattern->ProtocolId = (UCHAR)pFilter->PROTO;
    pPattern->gpcSrcPort = FI_SRC_PORT(pFilter);
    pPattern->gpcDstPort = FI_DEST_PORT(pFilter);

    pMask->SrcAddr = pFilter->SRC_MASK;
    pMask->DstAddr = pFilter->DEST_MASK;
    pMask->ProtocolId = (UCHAR)IPSEC_GPC_MASK_ALL;
    pMask->gpcSrcPort = IPSEC_GPC_MASK_NONE;
    pMask->gpcDstPort = IPSEC_GPC_MASK_NONE;

    switch (pFilter->PROTO) {
        case FILTER_PROTO_ANY:
            if (FI_SRC_PORT(pFilter) != FILTER_TCPUDP_PORT_ANY) {
                RtlFillMemory(  &pMask->gpcSrcPort,
                                sizeof(pMask->gpcSrcPort),
                                IPSEC_GPC_MASK_ALL);
            }
            if (FI_DEST_PORT(pFilter) != FILTER_TCPUDP_PORT_ANY) {
                RtlFillMemory(  &pMask->gpcDstPort,
                                sizeof(pMask->gpcDstPort),
                                IPSEC_GPC_MASK_ALL);
            }
            pMask->ProtocolId = (UCHAR)IPSEC_GPC_MASK_NONE;
            break;

        case FILTER_PROTO_TCP:
        case FILTER_PROTO_UDP:
            if (FI_SRC_PORT(pFilter) != FILTER_TCPUDP_PORT_ANY) {
                RtlFillMemory(  &pMask->gpcSrcPort,
                                sizeof(pMask->gpcSrcPort),
                                IPSEC_GPC_MASK_ALL);
            }
            if (FI_DEST_PORT(pFilter) != FILTER_TCPUDP_PORT_ANY) {
                RtlFillMemory(  &pMask->gpcDstPort,
                                sizeof(pMask->gpcDstPort),
                                IPSEC_GPC_MASK_ALL);
            }
            break;

        default:
            break;
    }

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecInsertGpcPattern(
    IN  PFILTER pFilter
    )
{
    CLASSIFICATION_HANDLE   GpcHandle;
    GPC_IP_PATTERN          GpcPattern;
    GPC_IP_PATTERN          GpcMask;
    ULONG                   GpcPriority;
    INT                     GpcCf;
    NTSTATUS                status;

    PAGED_CODE();

    GpcCf = IPSecResolveGpcCf(IS_OUTBOUND_FILTER(pFilter));

    //
    // Add the filter as a CfInfo
    //
    status = GPC_ADD_CFINFO(g_ipsec.GpcClients[GpcCf],
                            sizeof(PFILTER),
                            (PVOID)&pFilter,
                            (GPC_CLIENT_HANDLE)pFilter,
                            &pFilter->GpcFilter.GpcCfInfoHandle);

    if (status == STATUS_SUCCESS) {
        //
        // Now add the filter as a pattern
        //
        IPSecInitGpcFilter(pFilter, &GpcPattern, &GpcMask);

        if (FI_DEST_PORT(pFilter) == FILTER_TCPUDP_PORT_ANY) {
            GpcPriority = 1;
        } else {
            GpcPriority = 0;
        }

        ASSERT(GpcPriority < GPC_PRIORITY_IPSEC);

        status = GPC_ADD_PATTERN(   g_ipsec.GpcClients[GpcCf],
                                    GPC_PROTOCOL_TEMPLATE_IP,
                                    &GpcPattern,
                                    &GpcMask,
                                    GpcPriority,
                                    pFilter->GpcFilter.GpcCfInfoHandle,
                                    &pFilter->GpcFilter.GpcPatternHandle,
                                    &GpcHandle);

        if (status != STATUS_SUCCESS) {
            IPSEC_DEBUG(GPC, ("GpcAddPattern: failed with status %lx\n", status));

            GPC_REMOVE_CFINFO(  g_ipsec.GpcClients[GpcCf],
                                pFilter->GpcFilter.GpcCfInfoHandle);

            pFilter->GpcFilter.GpcCfInfoHandle = NULL;
            pFilter->GpcFilter.GpcPatternHandle = NULL;
        } else {
            g_ipsec.GpcNumFilters[GpcPriority]++;
        }
    }

    return  status;
}


NTSTATUS
IPSecDeleteGpcPattern(
    IN  PFILTER pFilter
    )
{
    ULONG   GpcPriority;
    INT     GpcCf = IPSecResolveGpcCf(IS_OUTBOUND_FILTER(pFilter));

    PAGED_CODE();

    if (pFilter->GpcFilter.GpcPatternHandle) {
        GPC_REMOVE_PATTERN( g_ipsec.GpcClients[GpcCf],
                            pFilter->GpcFilter.GpcPatternHandle);

        pFilter->GpcFilter.GpcPatternHandle = NULL;

        ASSERT(pFilter->GpcFilter.GpcCfInfoHandle);

        if (pFilter->GpcFilter.GpcCfInfoHandle) {
            GPC_REMOVE_CFINFO(  g_ipsec.GpcClients[GpcCf],
                                pFilter->GpcFilter.GpcCfInfoHandle);

            pFilter->GpcFilter.GpcCfInfoHandle = NULL;
        }

        if (FI_DEST_PORT(pFilter) == FILTER_TCPUDP_PORT_ANY) {
            GpcPriority = 1;
        } else {
            GpcPriority = 0;
        }

        ASSERT(GpcPriority < GPC_PRIORITY_IPSEC);

        g_ipsec.GpcNumFilters[GpcPriority]--;
    }

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecInsertGpcFilter(
    IN PFILTER  pFilter
    )
{
    NTSTATUS    status;
    PFILTER     pTempFilter;
    BOOL        InsertedFilter = FALSE;
    PLIST_ENTRY pEntry, pPrev;
    PLIST_ENTRY pFilterList;
    KIRQL       kIrql;

    PAGED_CODE();

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    pFilterList = IPSecResolveGpcFilterList(IS_TUNNEL_FILTER(pFilter),
                                            IS_OUTBOUND_FILTER(pFilter));

    pEntry = pFilterList->Flink;
    pPrev = pFilterList;

    while (pEntry != pFilterList) {
        pTempFilter = CONTAINING_RECORD(pEntry,
                                        FILTER,
                                        GpcLinkage);
            
        if (pFilter->Index > pTempFilter->Index) {
            //
            // found the spot, insert it before pTempFilter
            //
            InsertHeadList(pPrev, &pFilter->GpcLinkage);
            InsertedFilter = TRUE;
            break;
        }   

        pPrev = pEntry;
        pEntry = pEntry->Flink;
    }

    if (!InsertedFilter) {
        //
        // didn't find spot, stick it in the end
        //
        InsertTailList(pFilterList, &pFilter->GpcLinkage);
    }

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecDeleteGpcFilter(
    IN PFILTER  pFilter
    )
{
    KIRQL   kIrql;

    PAGED_CODE();

    if (!pFilter->GpcLinkage.Flink || !pFilter->GpcLinkage.Blink) {
        return  STATUS_SUCCESS;
    }

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    IPSecRemoveEntryList(&pFilter->GpcLinkage);

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecInstallGpcFilter(
    IN PFILTER  pFilter
    )
{
    PAGED_CODE();

    if (IS_TUNNEL_FILTER(pFilter)) {
        return  STATUS_SUCCESS;
    }

    if (IS_GPC_FILTER(pFilter)) {
        return  IPSecInsertGpcPattern(pFilter);
    } else {
        return  IPSecInsertGpcFilter(pFilter);
    }
}


NTSTATUS
IPSecUninstallGpcFilter(
    IN PFILTER  pFilter
    )
{
    PAGED_CODE();

    if (IS_TUNNEL_FILTER(pFilter)) {
        return  STATUS_SUCCESS;
    }

    if (IS_GPC_FILTER(pFilter)) {
        return  IPSecDeleteGpcPattern(pFilter);
    } else {
        return  IPSecDeleteGpcFilter(pFilter);
    }
}


NTSTATUS
IPSecLookupGpcSA(
    IN  ULARGE_INTEGER          uliSrcDstAddr,
    IN  ULARGE_INTEGER          uliProtoSrcDstPort,
    IN  CLASSIFICATION_HANDLE   GpcHandle,
    OUT PFILTER                 *ppFilter,
    OUT PSA_TABLE_ENTRY         *ppSA,
    OUT PSA_TABLE_ENTRY         *ppNextSA,
    OUT PSA_TABLE_ENTRY         *ppTunnelSA,
    IN  BOOLEAN                 fOutbound
    )
{
    PFILTER                 pFilter;
    PFILTER                 pTempFilter;
    PLIST_ENTRY             pEntry;
    PLIST_ENTRY             pFilterList;
    PLIST_ENTRY             pSAChain;
    PSA_TABLE_ENTRY         pSA;
    REGISTER ULARGE_INTEGER uliPort;
    REGISTER ULARGE_INTEGER uliAddr;
    BOOLEAN                 fFound = FALSE;
    INT                     GpcCf;
    CLASSIFICATION_HANDLE   TempGpcHandle;

    *ppSA = NULL;
    *ppFilter = NULL;
    *ppTunnelSA = NULL;

    //
    // Search in Tunnel filters list first.
    //
    pFilterList = IPSecResolveFilterList(TRUE, fOutbound);

    for (   pEntry = pFilterList->Flink;
            pEntry != pFilterList;
            pEntry = pEntry->Flink) {

        pFilter = CONTAINING_RECORD(pEntry,
                                    FILTER,
                                    MaskedLinkage);

        uliAddr.QuadPart = uliSrcDstAddr.QuadPart & pFilter->uliSrcDstMask.QuadPart;
        uliPort.QuadPart = uliProtoSrcDstPort.QuadPart & pFilter->uliProtoSrcDstMask.QuadPart;

        if ((uliAddr.QuadPart == pFilter->uliSrcDstAddr.QuadPart) &&
            (uliPort.QuadPart == pFilter->uliProtoSrcDstPort.QuadPart)) {
            //
            // Found filter
            //
            fFound = TRUE;
            break;
        }
    }

    if (fFound) {
        //
        // Search for the particular SA now.
        //
        fFound = FALSE;

        pSAChain = IPSecResolveSAChain(pFilter, fOutbound? DEST_ADDR: SRC_ADDR);

        for (   pEntry = pSAChain->Flink;
                pEntry != pSAChain;
                pEntry = pEntry->Flink) {

            pSA = CONTAINING_RECORD(pEntry,
                                    SA_TABLE_ENTRY,
                                    sa_FilterLinkage);

            ASSERT(pSA->sa_Flags & FLAGS_SA_TUNNEL);

            if (pFilter->TunnelAddr != 0) {
                //
                // match the outbound flag also
                //
                ASSERT(fOutbound == (BOOLEAN)((pSA->sa_Flags & FLAGS_SA_OUTBOUND) != 0));
                fFound = TRUE;
                *ppTunnelSA = pSA;
                break;
            }
        }

        if (fFound) {
            fFound = FALSE;
            *ppFilter = pFilter;
        } else {
            //
            // Found a filter entry, but need to negotiate keys.
            //
            *ppFilter = pFilter;
            return  STATUS_PENDING;
        }
    }

#if DBG
    if (fOutbound) {
        ADD_TO_LARGE_INTEGER(&g_ipsec.GpcTotalPassedIn, 1);
    }
#endif

    GpcCf = IPSecResolveGpcCf(fOutbound);

    TempGpcHandle = 0;

    if (GpcHandle == 0) {
#if DBG
        if (fOutbound) {
            ADD_TO_LARGE_INTEGER(&g_ipsec.GpcClassifyNeeded, 1);
        }
#endif

        //
        // Classify directly if no GpcHandle passed in.
        //
        IPSEC_CLASSIFY_PACKET(  GpcCf,
                                uliSrcDstAddr,
                                uliProtoSrcDstPort,
                                &pFilter,
                                &TempGpcHandle);
    } else {
        NTSTATUS    status;

        //
        // Or we use GpcHandle directly to get the filter installed.
        //
        pFilter = NULL;

        status = GPC_GET_CLIENT_CONTEXT(g_ipsec.GpcClients[GpcCf],
                                        GpcHandle,
                                        &pFilter);

        if (status == STATUS_INVALID_HANDLE) {
            //
            // Re-classify if handle is invalid.
            //
            IPSEC_CLASSIFY_PACKET(  GpcCf,
                                    uliSrcDstAddr,
                                    uliProtoSrcDstPort,
                                    &pFilter,
                                    &TempGpcHandle);
        }
    }

#if DBG
    if (IPSecDebug & IPSEC_DEBUG_GPC) {
        PFILTER pDbgFilter = NULL;

        pFilterList = IPSecResolveFilterList(FALSE, fOutbound);

        for (   pEntry = pFilterList->Flink;
                pEntry != pFilterList;
                pEntry = pEntry->Flink) {

            pTempFilter = CONTAINING_RECORD(pEntry,
                                            FILTER,
                                            MaskedLinkage);

            uliAddr.QuadPart = uliSrcDstAddr.QuadPart & pTempFilter->uliSrcDstMask.QuadPart;
            uliPort.QuadPart = uliProtoSrcDstPort.QuadPart & pTempFilter->uliProtoSrcDstMask.QuadPart;

            if ((uliAddr.QuadPart == pTempFilter->uliSrcDstAddr.QuadPart) &&
                (uliPort.QuadPart == pTempFilter->uliProtoSrcDstPort.QuadPart)) {
                pDbgFilter = pTempFilter;
                break;
            }
        }

        if (pFilter != pDbgFilter &&
            (!pDbgFilter || IS_GPC_FILTER(pDbgFilter))) {
            IPSEC_DEBUG(GPC, ("LookupGpcSA: pFilter %lx, pDbgFilter %lx, GpcHandle %lx, TempGpcHandle %lx\n", pFilter, pDbgFilter, GpcHandle, TempGpcHandle));
            IPSEC_DEBUG(GPC, ("LookupGpcSA: Src %lx, Dest %lx, Protocol %d, SPort %lx, DPort %lx\n", SRC_ADDR, DEST_ADDR, PROTO, SRC_PORT, DEST_PORT));

            if (DebugGPC) {
                DbgBreakPoint();
            }
        }
    }
#endif

    //
    // Continue searching the local GPC filter list if not found.
    //
    if (!pFilter) {
        pFilterList = IPSecResolveGpcFilterList(FALSE, fOutbound);

        for (   pEntry = pFilterList->Flink;
                pEntry != pFilterList;
                pEntry = pEntry->Flink) {

            pTempFilter = CONTAINING_RECORD(pEntry,
                                            FILTER,
                                            GpcLinkage);

            uliAddr.QuadPart = uliSrcDstAddr.QuadPart & pTempFilter->uliSrcDstMask.QuadPart;
            uliPort.QuadPart = uliProtoSrcDstPort.QuadPart & pTempFilter->uliProtoSrcDstMask.QuadPart;

            if ((uliAddr.QuadPart == pTempFilter->uliSrcDstAddr.QuadPart) &&
                (uliPort.QuadPart == pTempFilter->uliProtoSrcDstPort.QuadPart)) {
                pFilter = pTempFilter;
                break;
            }
        }
    }


    if (pFilter) {
        //
        // Search for the particular SA now.
        //

        fFound=FALSE;
        pSAChain = IPSecResolveSAChain(pFilter, fOutbound? DEST_ADDR: SRC_ADDR);

        for (   pEntry = pSAChain->Flink;
                pEntry != pSAChain;
                pEntry = pEntry->Flink) {

            pSA = CONTAINING_RECORD(pEntry,
                                    SA_TABLE_ENTRY,
                                    sa_FilterLinkage);


            if (IS_CLASSD(NET_LONG(pSA->SA_SRC_ADDR))
                || IS_CLASSD(NET_LONG(pSA->SA_DEST_ADDR))) {
                uliAddr.QuadPart = uliSrcDstAddr.QuadPart & pSA->sa_uliSrcDstMask.QuadPart;
           
                IPSEC_DEBUG(HASH, ("MCAST: %d %d %d %d", uliAddr.LowPart, uliAddr.HighPart,
                            pSA->sa_uliSrcDstAddr.LowPart,pSA->sa_uliSrcDstAddr.HighPart));

                if (uliAddr.QuadPart == pSA->sa_uliSrcDstAddr.QuadPart) {
                    fFound=TRUE;
                }
            } else if (uliSrcDstAddr.QuadPart == pSA->sa_uliSrcDstAddr.QuadPart) {
                fFound=TRUE;
            }
            if (fFound) {
                IPSEC_DEBUG(HASH, ("Matched entry: %lx\n", pSA));
                ASSERT(fOutbound == (BOOLEAN)((pSA->sa_Flags & FLAGS_SA_OUTBOUND) != 0));
                
                //
                // if there is also a tunnel SA, associate it here.
                //
                if (*ppTunnelSA && fOutbound) {
                    *ppNextSA = *ppTunnelSA;
                    *ppTunnelSA = NULL;
                }
                
                *ppFilter = pFilter;
                *ppSA = pSA;
                return  STATUS_SUCCESS;
            }
        }

        //
        // Found a filter entry, but need to negotiate keys
        // Also, ppTunnelSA is set to the proper tunnel SA we need
        // to hook to this end-2-end SA once it is negotiated.
        //
        *ppFilter = pFilter;

        return  STATUS_PENDING;
    } else {
        //
        // if only tunnel SA found, return that as the SA found.
        //
        if (*ppTunnelSA) {
            *ppSA = *ppTunnelSA;
            *ppTunnelSA = NULL;
            return  STATUS_SUCCESS;
        }
    }

    //
    // no entry found
    //
    return  STATUS_NOT_FOUND;

}


NTSTATUS
IPSecLookupGpcMaskedSA(
    IN  ULARGE_INTEGER  uliSrcDstAddr,
    IN  ULARGE_INTEGER  uliProtoSrcDstPort,
    OUT PFILTER         *ppFilter,
    OUT PSA_TABLE_ENTRY *ppSA,
    IN  BOOLEAN         fOutbound
    )
/*++

Routine Description:

    Looks up the SA given the relevant addresses.

Arguments:

    uliSrcDstAddr - src/dest IP addr
    uliProtoSrcDstPort - protocol, src/dest port
    ppFilter - filter found
    ppSA - SA found
    fOutbound - direction flag

Return Value:

    STATUS_SUCCESS - both filter and SA found
    STATUS_UNSUCCESSFUL - none found
    STATUS_PENDING - filter found, but no SA

Notes:

    Called with SADBLock held.

--*/
{
    REGISTER ULARGE_INTEGER uliPort;
    REGISTER ULARGE_INTEGER uliAddr;
    PFILTER                 pFilter;
    PFILTER                 pTempFilter;
    PLIST_ENTRY             pFilterList;
    PLIST_ENTRY             pSAChain;
    PLIST_ENTRY             pEntry;
    PSA_TABLE_ENTRY         pSA;
    CLASSIFICATION_HANDLE   GpcHandle;
    INT                     GpcCf;

    *ppSA = NULL;
    *ppFilter = NULL;

    GpcCf = IPSecResolveGpcCf(fOutbound);

    GpcHandle = 0;

    IPSEC_CLASSIFY_PACKET(  GpcCf,
                            uliSrcDstAddr,
                            uliProtoSrcDstPort,
                            &pFilter,
                            &GpcHandle);

#if DBG
    if (IPSecDebug & IPSEC_DEBUG_GPC) {
        PFILTER pDbgFilter = NULL;

        pFilterList = IPSecResolveFilterList(FALSE, fOutbound);

        for (   pEntry = pFilterList->Flink;
                pEntry != pFilterList;
                pEntry = pEntry->Flink) {

            pTempFilter = CONTAINING_RECORD(pEntry,
                                            FILTER,
                                            MaskedLinkage);

            uliAddr.QuadPart = uliSrcDstAddr.QuadPart & pTempFilter->uliSrcDstMask.QuadPart;
            uliPort.QuadPart = uliProtoSrcDstPort.QuadPart & pTempFilter->uliProtoSrcDstMask.QuadPart;

            if ((uliAddr.QuadPart == pTempFilter->uliSrcDstAddr.QuadPart) &&
                (uliPort.QuadPart == pTempFilter->uliProtoSrcDstPort.QuadPart)) {
                pDbgFilter = pTempFilter;
                break;
            }
        }

        if (pFilter != pDbgFilter &&
            (!pDbgFilter || IS_GPC_FILTER(pDbgFilter))) {
            IPSEC_DEBUG(GPC, ("LookupMaskedSA: pFilter %lx, pDbgFilter %lx, GpcHandle %lx\n", pFilter, pDbgFilter, GpcHandle));
            IPSEC_DEBUG(GPC, ("LookupMaskedSA: Src %lx, Dest %lx, Protocol %d, SPort %lx, DPort %lx\n", SRC_ADDR, DEST_ADDR, PROTO, SRC_PORT, DEST_PORT));

            if (DebugGPC) {
                DbgBreakPoint();
            }
        }
    }
#endif

    //
    // Continue searching the local GPC filter list if not found.
    //
    if (!pFilter) {
        pFilterList = IPSecResolveGpcFilterList(FALSE, fOutbound);

        for (   pEntry = pFilterList->Flink;
                pEntry != pFilterList;
                pEntry = pEntry->Flink) {

            pTempFilter = CONTAINING_RECORD(pEntry,
                                            FILTER,
                                            GpcLinkage);

            uliAddr.QuadPart = uliSrcDstAddr.QuadPart & pTempFilter->uliSrcDstMask.QuadPart;
            uliPort.QuadPart = uliProtoSrcDstPort.QuadPart & pTempFilter->uliProtoSrcDstMask.QuadPart;

            if ((uliAddr.QuadPart == pTempFilter->uliSrcDstAddr.QuadPart) &&
                (uliPort.QuadPart == pTempFilter->uliProtoSrcDstPort.QuadPart)) {
                pFilter = pTempFilter;
                break;
            }
        }
    }

    if (pFilter) {
        //
        // Search for the particular SA now.
        //
        pSAChain = IPSecResolveSAChain(pFilter, fOutbound? DEST_ADDR: SRC_ADDR);

        for (   pEntry = pSAChain->Flink;
                pEntry != pSAChain;
                pEntry = pEntry->Flink) {

            pSA = CONTAINING_RECORD(pEntry,
                                    SA_TABLE_ENTRY,
                                    sa_FilterLinkage);

            if (uliSrcDstAddr.QuadPart == pSA->sa_uliSrcDstAddr.QuadPart) {
                IPSEC_DEBUG(HASH, ("Matched entry: %lx\n", pSA));
                ASSERT(fOutbound == (BOOLEAN)((pSA->sa_Flags & FLAGS_SA_OUTBOUND) != 0));
                *ppFilter = pFilter;
                *ppSA = pSA;
                return  STATUS_SUCCESS;
            }
        }

        //
        // Found a filter entry, but need to negotiate keys
        //
        *ppFilter = pFilter;
        return  STATUS_PENDING;
    }

    //
    // no entry found
    //
    return  STATUS_NOT_FOUND;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\globals.c ===
#include "precomp.h"


ULONG IPSecNumResets = 0;

#if DBG
ULONG NumAddSA = 0;
ULONG NumAddSU = 0;
ULONG NumAddFA = 0;
ULONG NumDelSA = 0;
ULONG NumDelSU = 0;
ULONG NumDelFA = 0;
ULONG NumReset = 0;
#endif


//
// Max timeout value (in seconds) for each class.
//
ULONG   IPSecMaxTimerValue[IPSEC_CLASS_MAX] = {
            IPSEC_MAX_TIMER_SHORT_DURATION,
            IPSEC_MAX_TIMER_LONG_DURATION,
            IPSEC_MAX_TIMER_SUPER_LONG_DURATION
        };

//
// Size of each timer wheel.
//
ULONG   IPSecTimerListSize[IPSEC_CLASS_MAX] = {
            SECONDS_TO_SHORT_TICKS(IPSEC_MAX_TIMER_SHORT_DURATION),
            SECONDS_TO_LONG_TICKS(IPSEC_MAX_TIMER_LONG_DURATION),
            SECONDS_TO_SUPER_LONG_TICKS(IPSEC_MAX_TIMER_SUPER_LONG_DURATION)
        };

//
// Interval between ticks, in seconds, for each class.
//
ULONG   IPSecTimerPeriod[IPSEC_CLASS_MAX] = {
            IPSEC_SHORT_DURATION_TIMER_PERIOD,
            IPSEC_LONG_DURATION_TIMER_PERIOD,
            IPSEC_SUPER_LONG_DURATION_TIMER_PERIOD
        };

#if GPC
ULONG DebugGPC = 0;
#endif

#if DBG
ULONG IPSecDebug = 0;
#endif

UCHAR DefaultPad[MAX_PAD_LEN] = {1, 2, 3, 4, 5, 6, 7, 8, 9};


#if DBG
IPAddr DebugSrc = 0;
IPAddr DebugDst = 0;
UCHAR DebugPro = 0;
ULONG DebugPkt = 0;
ULONG DebugOff = 0;
ULONG DebugQry = 1;
#endif


RC4_KEYSTRUCT IPSecRngKey;

WORK_QUEUE_ITEM IPSecRngQueueItem;

ULONG IPSecRngBytes = 0;

#if DBG
ULONG IPSecRngInRekey = 0;
#endif

unsigned char weak_keys[][DES_BLOCKLEN] = {
		/* the weak keys */
	{ 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
	{ 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe },
	{ 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f },
	{ 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0 },
		/* the semi-weak keys */
	{ 0x01, 0xfe, 0x01, 0xfe, 0x01, 0xfe, 0x01, 0xfe },
	{ 0x1f, 0xe0, 0x1f, 0xe0, 0x1f, 0xe0, 0x1f, 0xe0 },
	{ 0x01, 0xe0, 0x01, 0xe0, 0x01, 0xe0, 0x01, 0xe0 },
	{ 0x1f, 0xfe, 0x1f, 0xfe, 0x1f, 0xfe, 0x1f, 0xfe },
	{ 0x01, 0x1f, 0x01, 0x1f, 0x01, 0x1f, 0x01, 0x1f },
	{ 0xe0, 0xfe, 0xe0, 0xfe, 0xe0, 0xfe, 0xe0, 0xfe },
	{ 0xfe, 0x01, 0xfe, 0x01, 0xfe, 0x01, 0xfe, 0x01 },
	{ 0xe0, 0x1f, 0xe0, 0x1f, 0xe0, 0x1f, 0xe0, 0x1f },
	{ 0xe0, 0x01, 0xe0, 0x01, 0xe0, 0x01, 0xe0, 0x01 },
	{ 0xfe, 0x1f, 0xfe, 0x1f, 0xfe, 0x1f, 0xfe, 0x1f },
	{ 0x1f, 0x01, 0x1f, 0x01, 0x1f, 0x01, 0x1f, 0x01 },
	{ 0xfe, 0xe0, 0xfe, 0xe0, 0xfe, 0xe0, 0xfe, 0xe0 }
};


PDEVICE_OBJECT IPSecDevice = NULL;

ULONG IPSecInitFlag = 0;

IPSEC_GLOBAL g_ipsec;

LARGE_INTEGER IPSecDelayInterval;

DWORD gdwInitEsp = 0;

DWORD gdwInitAh = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\gpc.h ===
#if GPC


NTSTATUS
IPSecGpcInitialize(
    );

NTSTATUS
IPSecGpcDeinitialize(
    );

NTSTATUS
IPSecEnableGpc(
    );

NTSTATUS
IPSecDisableGpc(
    );

NTSTATUS
IPSecInitGpcFilter(
    IN  PFILTER         pFilter,
    IN  PGPC_IP_PATTERN pPattern,
    IN  PGPC_IP_PATTERN pMask
    );

NTSTATUS
IPSecInsertGpcPattern(
    IN  PFILTER pFilter
    );

NTSTATUS
IPSecDeleteGpcPattern(
    IN  PFILTER pFilter
    );

NTSTATUS
IPSecInsertGpcFilter(
    IN PFILTER  pFilter
    );

NTSTATUS
IPSecDeleteGpcFilter(
    IN PFILTER  pFilter
    );

NTSTATUS
IPSecInstallGpcFilter(
    IN PFILTER  pFilter
    );

NTSTATUS
IPSecUninstallGpcFilter(
    IN PFILTER  pFilter
    );

NTSTATUS
IPSecLookupGpcSA(
    IN  ULARGE_INTEGER          uliSrcDstAddr,
    IN  ULARGE_INTEGER          uliProtoSrcDstPort,
    IN  CLASSIFICATION_HANDLE   GpcHandle,
    OUT PFILTER                 *ppFilter,
    OUT PSA_TABLE_ENTRY         *ppSA,
    OUT PSA_TABLE_ENTRY         *ppNextSA,
    OUT PSA_TABLE_ENTRY         *ppTunnelSA,
    IN  BOOLEAN                 fOutbound
    );

NTSTATUS
IPSecLookupGpcMaskedSA(
    IN  ULARGE_INTEGER  uliSrcDstAddr,
    IN  ULARGE_INTEGER  uliProtoSrcDstPort,
    OUT PFILTER         *ppFilter,
    OUT PSA_TABLE_ENTRY *ppSA,
    IN  BOOLEAN         fOutbound
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\globals.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    globals.h

Abstract:

    This is the main header file for IPSEC. Contains all the globals.

Author:

    Sanjay Anand (SanjayAn) 2-January-1997
    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#ifndef  _GLOBALS_H
#define  _GLOBALS_H


#define MAX_COUNT_STRING_LEN    32

#define MAX_IP_OPTION_SIZE      40



// 64 bytes
#define MAX_KEYLEN_SHA  64
#define MAX_KEYLEN_MD5  64

// 8 bytes
#define MAX_KEYLEN_DES  8
#define MAX_IV_LEN      DES_BLOCKLEN

#define MAX_KEY_LEN     MAX(MAX_KEYLEN_MD5, MAX_KEYLEN_DES)

//
// we set aside SPIs between 256 and 65536 (64K) for hardware offload
//
#define LOWER_BOUND_SPI     256
#define UPPER_BOUND_SPI     ((ULONG) -1)    // MAX_ULONG

#define INVALID_INDEX       0xffffffff

#define RNG_KEY_SIZE        256         // 2048 bits
#define RNG_REKEY_THRESHOLD 65536       // 64K raw bytes 

//
// Constants related to filter lists
//
#define INBOUND_TRANSPORT_FILTER    0
#define OUTBOUND_TRANSPORT_FILTER   1
#define INBOUND_TUNNEL_FILTER       2
#define OUTBOUND_TUNNEL_FILTER      3

#define MIN_FILTER                  INBOUND_TRANSPORT_FILTER
#define MAX_FILTER                  OUTBOUND_TUNNEL_FILTER

#define MIN_TRANSPORT_FILTER        INBOUND_TRANSPORT_FILTER
#define MAX_TRANSPORT_FILTER        OUTBOUND_TRANSPORT_FILTER

#define MIN_TUNNEL_FILTER           INBOUND_TUNNEL_FILTER
#define MAX_TUNNEL_FILTER           OUTBOUND_TUNNEL_FILTER

#define INBOUND_OUTBOUND_INCREMENT  1
#define TRANSPORT_TUNNEL_INCREMENT  2

#define NUM_FILTERS                 (MAX_FILTER - MIN_FILTER + 1) 

//
// Number of extra bytes when we pad - one for padlen and other for payloadtype
//
#define NUM_EXTRA   2

#define ESP_SIZE (sizeof(ESP) + DES_BLOCKLEN * sizeof(UCHAR))

#define TRUNCATED_HASH_LEN  12 // 96 bits
#define REPLAY_WINDOW_SIZE  64

#define MAX_PAD_LEN         (DES_BLOCKLEN + NUM_EXTRA - 1)

#define IPSEC_SMALL_BUFFER_SIZE 50
#define IPSEC_LARGE_BUFFER_SIZE 200

#define IPSEC_CACHE_LINE_SIZE   16

#define IPSEC_LIST_DEPTH    5

typedef ULONG tSPI;

#define MAX_BLOCKLEN    MAX(DES_BLOCKLEN, 0)

#define IPSEC_TAG_INIT              'ISpI'
#define IPSEC_TAG_AH                'TApI'
#define IPSEC_TAG_AH_TU             'UApI'
#define IPSEC_TAG_ESP               'TEpI'
#define IPSEC_TAG_ESP_TU            'UEpI'
#define IPSEC_TAG_HUGHES            'THpI'
#define IPSEC_TAG_HUGHES_TU         'UHpI'
#define IPSEC_TAG_ACQUIRE_CTX       'XApI'
#define IPSEC_TAG_FILTER            'IFpI'
#define IPSEC_TAG_SA                'ASpI'
#define IPSEC_TAG_KEY               'EKpI'
#define IPSEC_TAG_TIMER             'ITpI'
#define IPSEC_TAG_STALL_QUEUE       'QSpI'
#define IPSEC_TAG_LOOKASIDE_LISTS   'ALpI'
#define IPSEC_TAG_BUFFER_POOL       'PBpI'
#define IPSEC_TAG_SEND_COMPLETE     'CSpI'
#define IPSEC_TAG_EVT_QUEUE         'QEpI'
#define IPSEC_TAG_HW                'WHpI'
#define IPSEC_TAG_HW_PKTINFO        'KPpI'
#define IPSEC_TAG_HW_PKTEXT         'XEpI'
#define IPSEC_TAG_HW_ADDSA          'SApI'
#define IPSEC_TAG_HW_DELSA          'SDpI'
#define IPSEC_TAG_HW_PLUMB          'LPpI'
#define IPSEC_TAG_COMP              'OCpI'
#define IPSEC_TAG_REINJECT          'ERpI'
#define IPSEC_TAG_IOCTL             'OIpI'
#define IPSEC_TAG_LOG               'OLpI'


#define IPSEC_LOG_PACKET_SIZE 128 //Size in bytes of stored packet in troubleshoot mode


//
// The IPSEC ESP payload
//
typedef struct  _ESP {
    tSPI   esp_spi;
} ESP, *PESP;

//
// SA Flags - Not mutually exclusive
//
#define FLAGS_SA_INITIATOR          0x00000001  // use Initiator keys? might be deprecated soon
#define FLAGS_SA_OUTBOUND           0x00000002  // outbound SA?
#define FLAGS_SA_TUNNEL             0x00000004  // tunnel mode? sa_TunnelAddr is significant
#define FLAGS_SA_REPLAY             0x00000008  // check for replays? we always generate replay fields
#define FLAGS_SA_REKEY              0x00000010  // is this rekeyed LarvalSA?
#define FLAGS_SA_REKEY_ORI          0x00000020  // did this kick off a rekey?
#define FLAGS_SA_MANUAL             0x00000040  // manual keyed?
#define FLAGS_SA_MTU_BUMPED         0x00000080  // was MTU bumped down on this SA?
#define FLAGS_SA_PENDING            0x00000100  // this is on the pending queue.
#define FLAGS_SA_TIMER_STARTED      0x00000200  // timer started on this SA
#define FLAGS_SA_HW_PLUMBED         0x00000400  // hw acceleration plumbed successfully
#define FLAGS_SA_HW_PLUMB_FAILED    0x00000800  // hw acceleration plumbing failed
#define FLAGS_SA_HW_DELETE_SA       0x00001000  // hw acceleration - this is the pending delete.
#define FLAGS_SA_HW_CRYPTO_ONLY     0x00002000  // hw acceleration - this is a crypto-only provider.
#define FLAGS_SA_HW_RESET           0x00004000  // hw acceleration - this offload SA has been reset
#define FLAGS_SA_HW_DELETE_QUEUED   0x00008000  // hw acceleration - this SA delete is queued so make sure reset doesn't touch it
#define FLAGS_SA_REFERENCED         0x00010000  // is this SA the next of another?
#define FLAGS_SA_NOTIFY_PERFORMED   0x00020000  // For inbound only.  Notification performed
#define FLAGS_SA_ON_FILTER_LIST     0x00040000  // used on inbound SAs to indicate they are on filter lists
#define FLAGS_SA_ON_SPI_HASH        0x00080000  // used on inbound SAs to indicate they are on spi hash lists
#define FLAGS_SA_EXPIRED            0x00100000  // has this SA expired?
#define FLAGS_SA_IDLED_OUT          0x00200000  // has this SA idled out?
#define FLAGS_SA_HIBERNATED         0x00400000  // has this SA been hibernated?
#define FLAGS_SA_DELETE_BY_IOCTL    0x00800000  // sa delete initiated by external source
#define FLAGS_SA_OFFLOADABLE        0x01000000  // is this SA offloadable?
#define FLAGS_SA_PASSTHRU_FILTER    0x02000000  // sa derived from a pass-thru filter
#define FLAGS_SA_DISABLE_IDLE_OUT          0x04000000  // don't idle out
#define FLAGS_SA_DISABLE_ANTI_REPLAY_CHECK 0x08000000  // don't check anti-replay
#define FLAGS_SA_DISABLE_LIFETIME_CHECK    0x10000000  // don't check lifetimes


//
// SA States - Mutually exclusive
//
typedef enum    _SA_STATE   {
    STATE_SA_CREATED =   1,     // when created
    STATE_SA_LARVAL,            // Key negotiation going on - outbound SAs only
    STATE_SA_ASSOCIATED,        // corresp inbound SA created, associated with outbound SA
    STATE_SA_ACTIVE,            // outbound SA completely setup
    STATE_SA_ZOMBIE             // SAs flushed, ready to be deleted
} SA_STATE, *PSA_STATE;

#define IPSEC_SA_SIGNATURE  0x4601
#define IPSEC_FILTER_SIGNATURE  0x4602

#if DBG
#define IPSEC_SA_D_1    'SAD1'
#define IPSEC_SA_D_2    'SAD2'
#define IPSEC_SA_D_3    'SAD3'
#define IPSEC_SA_D_4    'SAD4'
#endif

typedef struct _FILTER  FILTER, *PFILTER;

typedef    struct    _INTERNAL_ALGO_INFO {
    ULONG   algoIdentifier;
    PUCHAR  algoKey;
    ULONG   algoKeylen;
    ULONG   algoRounds;
} INTERNAL_ALGO_INFO, *PINTERNAL_ALGO_INFO;

typedef struct    _INTERNAL_ALGO {
    INTERNAL_ALGO_INFO    integrityAlgo;
    INTERNAL_ALGO_INFO    confAlgo;
    INTERNAL_ALGO_INFO    compAlgo;
} INTERNAL_ALGO, *PINTERNAL_ALGO;

typedef struct  _IPSEC_ACQUIRE_CONTEXT  IPSEC_ACQUIRE_CONTEXT, *PIPSEC_ACQUIRE_CONTEXT;
typedef struct  _FILTER_CACHE           FILTER_CACHE, *PFILTER_CACHE;

//
// Security Association Table (SATable)
//
// Indexed by the following:
//
// Sender maps {Src Addr, Dest Addr, User Context} to the index
//
// Receiver maps {Dest Addr, SPI} to the index
// SPI values are unique when generated manually, so can be used directly
// to index into the SATable for
//
typedef struct  _SATableEntry   {
    LIST_ENTRY      sa_SPILinkage;      // linkage in SPI hash table list
    LIST_ENTRY      sa_FilterLinkage;   // linkage in Filter table list
    LIST_ENTRY      sa_LarvalLinkage;   // linkage in Larval SA list
    LIST_ENTRY      sa_PendingLinkage;  // linkage in pending SA list - waiting for Acquire Irp

    struct  _SATableEntry *sa_AssociatedSA;    // outbound -> inbound link
    struct  _SATableEntry *sa_RekeyLarvalSA;   // points to the Larval SA on a rekey
    struct  _SATableEntry *sa_RekeyOriginalSA; // Rekey Larval SA points to the original SA that kicked off the rekey

    ULONG           sa_Signature;       // contains 4601

    ULONG           sa_AcquireId;       // cross-check with the Acquire Irp context
    PIPSEC_ACQUIRE_CONTEXT  sa_AcquireCtx;  // actual acquire context - used to invalidate the context.

    ULONG           sa_Flags;           // flags as defined above
    SA_STATE        sa_State;           // states as defined above

    ULONG           sa_Reference;       // ref count
    PFILTER         sa_Filter;          // assoc filter entry
    PFILTER_CACHE   sa_FilterCache;     // back pointer to cache entry so we can disable it when an SA goes away

    KSPIN_LOCK      sa_Lock;            // lock to protect the FilterCache ptr.

#if DBG
    ULONG           sa_d1;
#endif

    ULARGE_INTEGER  sa_uliSrcDstAddr;
    ULARGE_INTEGER  sa_uliSrcDstMask;
    ULARGE_INTEGER  sa_uliProtoSrcDstPort;

    IPAddr          sa_TunnelAddr;      // Tunnel dest end IP Addr
    IPAddr          sa_SrcTunnelAddr;   // Tunnel src end IP Addr

    // SPI - host order -   if outbound, SPI for remote,
    //                      else inbound (our) SPI

    tSPI            sa_SPI;                 // Inbound: in the multiple ops case, this is the SPI of the last operation.
                                            // Outbound: order is as specified in the update.

    LONG            sa_NumOps;              // the total number of operations to be done

    tSPI            sa_OtherSPIs[MAX_OPS];  // the other alternate SPIs.

    OPERATION_E     sa_Operation[MAX_OPS];
    INTERNAL_ALGO   sa_Algorithm[MAX_OPS];

    ULONG           sa_ReplayStartPoint;        // corresponds to RP_Key_I/R
    ULONG           sa_ReplayLastSeq[MAX_OPS];  // for replay detection - last seq recd
    ULONGLONG       sa_ReplayBitmap[MAX_OPS];   // for replay detection - 64 packet window
    ULONG           sa_ReplaySendSeq[MAX_OPS];  // for replay detection - next seq # to send
    ULONG           sa_ReplayLen;               // for replay detection - length of replay field - 32 bits

#if DBG
    ULONG           sa_d2;
#endif

    UCHAR           sa_iv[MAX_OPS][DES_BLOCKLEN];      // IV_Key_I/R
    ULONG           sa_ivlen;

    ULONG           sa_TruncatedLen;    // length of final hash after truncation

    LARGE_INTEGER   sa_KeyExpirationTime;   // time till re-key
    LARGE_INTEGER   sa_KeyExpirationBytes;  // max # of KBytes xformed till re-key
    LARGE_INTEGER   sa_TotalBytesTransformed; // running total
    LARGE_INTEGER   sa_KeyExpirationTimeWithPad;
    LARGE_INTEGER   sa_KeyExpirationBytesWithPad;

    LARGE_INTEGER   sa_IdleTime;            // total time this SA can sit idle
    LARGE_INTEGER   sa_LastUsedTime;        // time this SA was used last

#if DBG
    ULONG           sa_d3;
#endif

    LIFETIME        sa_Lifetime;

    ULONG           sa_BlockedDataLen;  // amount of pended data
    PNDIS_BUFFER    sa_BlockedBuffer;   // stall queue of 1 Mdl chain

#if DBG
    ULONG           sa_d4;
#endif

    Interface       *sa_IPIF;

    IPSEC_TIMER     sa_Timer;           // Timer struct for timer queue

    ULONG           sa_ExpiryTime;      // time until this SA expires
    NDIS_HANDLE     sa_OffloadHandle;
    LONG            sa_NumSends;
    WORK_QUEUE_ITEM sa_QueueItem;

    ULONG           sa_IPSecOverhead;
    ULONG           sa_NewMTU;

    DWORD           sa_QMPFSGroup;
    IKE_COOKIE_PAIR sa_CookiePair;
    IPSEC_SA_STATS  sa_Stats;
    UCHAR           sa_DestType;
} SA_TABLE_ENTRY, *PSA_TABLE_ENTRY;

//
// Context used between Key manager and IPSEC. Points to the Larval SA basically.
//
typedef struct  _IPSEC_ACQUIRE_CONTEXT {
    ULONG           AcquireId;      // unique ID to represent this transaction
    PSA_TABLE_ENTRY pSA;            // larval SA should contain this ID
} IPSEC_ACQUIRE_CONTEXT, *PIPSEC_ACQUIRE_CONTEXT;

//
// Packet Classification/Policy Setting is similar to that of the
// Filter Driver. We dont have filters per interface, however.
//
typedef struct _FILTER {
    ULONG           Signature;      // contains 4602
    BOOLEAN         TunnelFilter;
    BOOLEAN         LinkedFilter;   // true if on linked list 
    USHORT          Flags;
    PFILTER_CACHE   FilterCache;    // back pointer to cache entry so we can disable it when filter is deleted
    LIST_ENTRY      MaskedLinkage;
    ULARGE_INTEGER  uliSrcDstAddr;
    ULARGE_INTEGER  uliSrcDstMask;
    ULARGE_INTEGER  uliProtoSrcDstPort;
    ULARGE_INTEGER  uliProtoSrcDstMask;
    IPAddr          TunnelAddr;
    ULONG           Reference;      // ref count
    LONG            SAChainSize;    // number of entries for SA chain hash
    ULONG           Index;          // hinted index
    GUID            PolicyId;       // policy GUID
    GUID            FilterId;       // filter GUID
#if GPC
    union {
        LIST_ENTRY          GpcLinkage;
        struct _GPC_FILTER {
            GPC_HANDLE      GpcCfInfoHandle;
            GPC_HANDLE      GpcPatternHandle;
        } GpcFilter;
    };
#endif
    LIST_ENTRY      SAChain[1];     // chain of SAs associated with this Filter
} FILTER, *PFILTER;

//
// a first level cache, contains IP headers cached for fast lookups
//
typedef struct _FILTER_CACHE {
    ULARGE_INTEGER  uliSrcDstAddr;
    ULARGE_INTEGER  uliProtoSrcDstPort;
    BOOLEAN         FilterEntry;    // if TRUE, the next one is a Filter
    union {
        PSA_TABLE_ENTRY pSAEntry;   // points to the associated SAEntry
        PFILTER         pFilter;    // points to the (drop/PassThru filter)
    };
    PSA_TABLE_ENTRY pNextSAEntry;   // points to the associated NextSAEntry
#if DBG
    ULARGE_INTEGER  CacheHitCount;
#endif
} FILTER_CACHE, *PFILTER_CACHE;

//
// Hash tables for specific SAs
//
typedef struct  _SA_HASH {
    LIST_ENTRY  SAList;
} SA_HASH, *PSA_HASH;

//
// This structure is used to hold on to an Irp from the Key manager.
// The Irp is completed to kick off an SA negotiation.
//
typedef struct _IPSEC_ACQUIRE_INFO {
    PIRP        Irp;     // irp passed down from Key manager
    LIST_ENTRY  PendingAcquires;    // linked list of pending acquire requests
    LIST_ENTRY  PendingNotifies;    // linked list of pending notifications
    KSPIN_LOCK  Lock;
    BOOLEAN     ResolvingNow;       // irp is in user mode doing a resolve
    BOOLEAN     InMe;       // irp is in user mode doing a resolve
} IPSEC_ACQUIRE_INFO, *PIPSEC_ACQUIRE_INFO;

//
// Buffer for lookaside list descriptors. Lookaside list descriptors
// cannot be statically allocated, as they need to ALWAYS be nonpageable,
// even when the entire driver is paged out.
//
typedef struct _IPSEC_LOOKASIDE_LISTS {
    NPAGED_LOOKASIDE_LIST SendCompleteCtxList;
    NPAGED_LOOKASIDE_LIST LargeBufferList;
    NPAGED_LOOKASIDE_LIST SmallBufferList;
} IPSEC_LOOKASIDE_LISTS, *PIPSEC_LOOKASIDE_LISTS;

//
// Data is organized as an MDL followed by the actual buffer being described by
// the mdl.
//
// !!NOTE: In the struct below, Data should be quadaligned since MDLs are always
// quad-aligned.
//
typedef struct _IPSEC_LA_BUFFER {
    ULONG   Tag;            // the actual tag this was used for
    PVOID   Buffer;         // the actual buffer
    ULONG   BufferLength;   // length of the buffer pointed by MDL
    PMDL    Mdl;            // pointer to an MDL describing the buffer
    UCHAR   Data[1];        // the real data starts here
} IPSEC_LA_BUFFER, *PIPSEC_LA_BUFFER;

typedef struct _IPSEC_GLOBAL {
    BOOLEAN     DriverUnloading;    // Is driver being unloaded?
    BOOLEAN     BoundToIP;          // Are we bound to IP yet?
    BOOLEAN     SendBoundToIP;      // Is IPSecHandler bound to IP?
    BOOLEAN     InitCrypto;         // Are crypto routines initialized?
    BOOLEAN     InitRNG;            // Is RNG initialized?
    BOOLEAN     InitTcpip;          // Is TCP/IP loaded?
#if FIPS
    BOOLEAN     InitFips;           // Is Fips driver loaded and function table set?
#endif
#if GPC
    BOOLEAN     InitGpc;            // Is GPC driver loaded and function table set?
#endif

    LONG        NumSends;           // counts the number of pending sends
    LONG        NumThreads;         // counts the number of threads in driver
    LONG        NumWorkers;         // counts the number of worker threads
    LONG        NumTimers;          // counts the number of active timers
    LONG        NumIoctls;          // counts the number of active IOCTLs

    LIST_ENTRY  LarvalSAList;
    KSPIN_LOCK  LarvalListLock;     // protects the larval SA list

    MRSW_LOCK   SADBLock;           // protects the Filter/SA DB
    MRSW_LOCK   SPIListLock;        // protects the SPI list

    //
    // We partition the filters into tunnel/masked and inbound/outbound filters.
    //
    LIST_ENTRY  FilterList[NUM_FILTERS];

    ULONG       NumPolicies;        // number of filters plumbed in the driver
    ULONG       NumTunnelFilters;
    ULONG       NumMaskedFilters;
    ULONG       NumOutboundSAs;
    ULONG       NumMulticastFilters;

    //
    // Inbound <SPI, dest> hash
    //
    PSA_HASH    pSADb;
    LONG        NumSA;
    LONG        SAHashSize;

    PFILTER_CACHE   *ppCache;
    ULONG           CacheSize;
    ULONG           CacheHalfSize;

    //
    // SA negotiate context
    //
    IPSEC_ACQUIRE_INFO  AcquireInfo;

    //
    // timers
    //
    KSPIN_LOCK          TimerLock;
    IPSEC_TIMER_LIST    TimerList[IPSEC_CLASS_MAX];

    IPSEC_TIMER         ReaperTimer;    // reaper thread runs here.

    //
    // Global lookaside lists. These must always be in nonpaged pool,
    // even when the driver is paged out.
    //
    PIPSEC_LOOKASIDE_LISTS IPSecLookasideLists;

    ULONG   IPSecLargeBufferSize;
    ULONG   IPSecLargeBufferListDepth;

    ULONG   IPSecSmallBufferSize;
    ULONG   IPSecSmallBufferListDepth;

    ULONG   IPSecSendCompleteCtxSize;
    ULONG   IPSecSendCompleteCtxDepth;

    ULONG   IPSecCacheLineSize;

    PDEVICE_OBJECT  IPSecDevice;
    PDRIVER_OBJECT  IPSecDriverObject;

    ProtInfo    IPProtInfo;
    IPOptInfo   OptInfo;

    //
    // stats
    //
    IPSEC_QUERY_STATS   Statistics;

    ULONG       EnableOffload;
    ULONG       DefaultSAIdleTime;
    ULONG       LogInterval;
    ULONG       EventQueueSize;
    ULONG       RekeyTime;
    ULONG       NoDefaultExempt;

    KSPIN_LOCK  EventLogLock;   // lock to protect event queue
    IPSEC_TIMER EventLogTimer;
    ULONG       IPSecBufferedEvents;
    PUCHAR      IPSecLogMemory;
    PUCHAR      IPSecLogMemoryLoc;
    PUCHAR      IPSecLogMemoryEnd;

    LARGE_INTEGER   SAIdleTime;

#if DBG
    ULARGE_INTEGER  CacheHitCount;
#endif

    OPERATION_MODE  OperationMode;
    
    ULONG DiagnosticMode;

#if GPC
    GPC_EXPORTED_CALLS  GpcEntries;
    GPC_HANDLE          GpcClients[GPC_CF_MAX];
    ULONG               GpcActive;
    ULONG               GpcNumFilters[GPC_CF_MAX];
    LIST_ENTRY          GpcFilterList[NUM_FILTERS];
#if DBG
    LARGE_INTEGER       GpcTotalPassedIn;
    LARGE_INTEGER       GpcClassifyNeeded;
    LARGE_INTEGER       GpcReClassified;
#endif
#endif

#if FIPS
    PFILE_OBJECT        FipsFileObject;
    FIPS_FUNCTION_TABLE FipsFunctionTable;
#endif

    VOID        (*TcpipFreeBuff)(struct IPRcvBuf *);
    INT         (*TcpipAllocBuff)(struct IPRcvBuf *, UINT);
    UCHAR       (*TcpipGetAddrType)(IPAddr);
    IP_STATUS   (*TcpipGetInfo)(IPInfo *, INT);
    NDIS_STATUS (*TcpipNdisRequest)(PVOID, NDIS_REQUEST_TYPE, NDIS_OID, PVOID, UINT, PUINT);
    PVOID       (*TcpipRegisterProtocol)(UCHAR, PVOID, PVOID, PVOID, PVOID, PVOID, PVOID);
    NTSTATUS    (*TcpipSetIPSecStatus)(BOOLEAN);
    IP_STATUS   (*TcpipIPTransmit)(PVOID, PVOID, PNDIS_BUFFER, UINT, IPAddr, IPAddr, IPOptInfo *, RouteCacheEntry *, UCHAR, PIRP);
    IP_STATUS   (*TcpipSetIPSecPtr)(PIPSEC_FUNCTIONS);
    IP_STATUS   (*TcpipUnSetIPSecPtr)(PIPSEC_FUNCTIONS);
    IP_STATUS   (*TcpipUnSetIPSecSendPtr)(PIPSEC_FUNCTIONS);
    UINT        (*TcpipTCPXsum)(UINT, PVOID, UINT);
    USHORT      (*TcpipGenIpId)();
    PVOID       (*TcpipDeRegisterProtocol)(UCHAR);
} IPSEC_GLOBAL, *PIPSEC_GLOBAL;


//
// Contexts used to store eventlog contexts.
//
#define IPSEC_DROP_STATUS_CRYPTO_DONE      0x00000001
#define IPSEC_DROP_STATUS_NEXT_CRYPTO_DONE 0x00000002
#define IPSEC_DROP_STATUS_SA_DELETE_REQ    0x00000004
#define IPSEC_DROP_STATUS_DONT_LOG         0x00000008

typedef struct _IPSEC_DROP_STATUS {
    ULONG           IPSecStatus;
    ULONG           OffloadStatus;
    ULONG           Flags;
} IPSEC_DROP_STATUS, *PIPSEC_DROP_STATUS;

typedef struct  _IPSEC_EVENT_CTX {
    IPAddr  Addr;
    ULONG   EventCode;
    ULONG   UniqueEventValue;
    ULONG   EventCount;
    PUCHAR  pPacket;
    ULONG   PacketSize;
    IPSEC_DROP_STATUS DropStatus;
} IPSEC_EVENT_CTX, *PIPSEC_EVENT_CTX;

typedef struct _IPSEC_NOTIFY_EXPIRE {
    LIST_ENTRY      notify_PendingLinkage;  // linkage in pending SA list - waiting for Acquire Irp
    ULARGE_INTEGER  sa_uliSrcDstAddr;
    ULARGE_INTEGER  sa_uliSrcDstMask;
    ULARGE_INTEGER  sa_uliProtoSrcDstPort;

    IPAddr          sa_TunnelAddr;  // Tunnel end IP Addr
    IPAddr          sa_InboundTunnelAddr;  // Tunnel end IP Addr
    
    tSPI            InboundSpi;                 // Inbound: in the multiple ops case, this is the SPI of the last operation.
    tSPI            OutboundSpi;

    IKE_COOKIE_PAIR sa_CookiePair;
    DWORD           Flags;
} IPSEC_NOTIFY_EXPIRE, *PIPSEC_NOTIFY_EXPIRE;

typedef IPSEC_ADD_UPDATE_SA IPSEC_ADD_SA, *PIPSEC_ADD_SA;
typedef IPSEC_ADD_UPDATE_SA IPSEC_UPDATE_SA, *PIPSEC_UPDATE_SA;

#define IPSEC_ADD_SA_NO_KEY_SIZE    FIELD_OFFSET(IPSEC_ADD_SA, SAInfo.KeyMat[0])
#define IPSEC_UPDATE_SA_NO_KEY_SIZE FIELD_OFFSET(IPSEC_UPDATE_SA, SAInfo.KeyMat[0])

//
// Contexts used to store SA plumbing contexts.
//
typedef struct _IPSEC_PLUMB_SA {
    Interface       *DestIF;
    PSA_TABLE_ENTRY pSA;
    PUCHAR          Buf;
    ULONG           Len;
    WORK_QUEUE_ITEM PlumbQueueItem;
} IPSEC_PLUMB_SA, *PIPSEC_PLUMB_SA;

//
// Contexts used to log events
//
typedef struct _IPSEC_LOG_EVENT {
    LONG            LogSize;
    WORK_QUEUE_ITEM LogQueueItem;
    UCHAR           pLog[1];
} IPSEC_LOG_EVENT, *PIPSEC_LOG_EVENT;


#endif  _GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\hughes.h ===
NTSTATUS
IPSecHashMdlChain(
    IN  PSA_TABLE_ENTRY pSA,
    IN  PVOID           pBuffer,
    IN  PUCHAR          pHash,
    IN  BOOLEAN         fIncoming,
    IN  AH_ALGO         eAlgo,
    OUT PULONG          pLen,
    IN  ULONG           Index
    );

NTSTATUS
IPSecCreateHughes(
    IN      PUCHAR          pIPHeader,
    IN      PVOID           pData,
    IN      PSA_TABLE_ENTRY pSA,
    IN      ULONG           Index,
    OUT     PVOID           *ppNewData,
    OUT     PVOID           *ppSCContext,
    OUT     PULONG          pExtraBytes,
    IN      ULONG           HdrSpace,
    IN      PNDIS_PACKET    pNdisPacket,
    IN      BOOLEAN         fCryptoOnly
    );

NTSTATUS
IPSecVerifyHughes(
    IN      PUCHAR          *pIPHeader,
    IN      PVOID           pData,
    IN      PSA_TABLE_ENTRY pSA,
    IN      ULONG           Index,
    OUT     PULONG          pExtraBytes,
    IN      BOOLEAN         fCryptoDone,
    IN      BOOLEAN         fFastRcv
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\intirspn.h ===
NTSTATUS
IPSecGetSPI(
    PIPSEC_GET_SPI pIpsecGetSPI
    );

NTSTATUS
IPSecInitiatorGetSPI(
    PIPSEC_GET_SPI pIpsecGetSPI
    );

NTSTATUS
IPSecResponderGetSPI(
    PIPSEC_GET_SPI pIpsecGetSPI
    );

NTSTATUS
IPSecResponderCreateLarvalSA(
    PIPSEC_GET_SPI pIpsecGetSPI,
    ULARGE_INTEGER uliAddr,
    PSA_TABLE_ENTRY * ppSA
    );

NTSTATUS
IPSecInitiatorCreateLarvalSA(
    PFILTER pFilter,
    ULARGE_INTEGER uliAddr,
    PSA_TABLE_ENTRY * ppSA,
    UCHAR DestType
    );

NTSTATUS
IPSecFindSA(
    BOOLEAN bTunnelFilter,
    ULARGE_INTEGER uliSrcDstAddr,
    ULARGE_INTEGER uliProtoSrcDstPort,
    PFILTER * ppFilter,
    PSA_TABLE_ENTRY * ppSA
    );

NTSTATUS
IPSecResponderInsertInboundSA(
    PSA_TABLE_ENTRY pSA,
    PIPSEC_GET_SPI pIpsecGetSPI,
    BOOLEAN bTunnelFilter
    );

NTSTATUS
IPSecInitiatorInsertInboundSA(
    PSA_TABLE_ENTRY pSA,
    BOOLEAN bTunnelFilter
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\hughes.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    hughes.c

Abstract:

    This module contains the code to create/verify the Hughes transform.

Author:

    Sanjay Anand (SanjayAn) 13-March-1997
    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#include "precomp.h"


NTSTATUS
IPSecHashMdlChain(
    IN  PSA_TABLE_ENTRY pSA,
    IN  PVOID           pBuffer,
    IN  PUCHAR          pHash,
    IN  BOOLEAN         fIncoming,
    IN  AH_ALGO         eAlgo,
    OUT PULONG          pLen,
    IN  ULONG           Index
    )
/*++

Routine Description:

    Hash the entire chain using the algo passed in

Arguments:

    pSA - the security association

    pBuffer - chain of MDLs (if fIncoming is FALSE) or RcvBufs (if fIncoming is TRUE)

    pHash - where to put the hash

    fIncoming - TRUE if on recv path

    eAlgo - the algorithm index

    pLen - returns length hashed

Return Value:

    STATUS_SUCCESS
    Others:
        STATUS_INSUFFICIENT_RESOURCES
        STATUS_UNSUCCESSFUL (error in algo.)

--*/
{
    ALGO_STATE  State = {0};
    NTSTATUS    status;
    PAUTH_ALGO  pAlgo=&(auth_algorithms[eAlgo]);
    PUCHAR      pPyld;
    ULONG       Len;

    State.as_sa = pSA;

    status = pAlgo->init(&State, Index);

    if (fIncoming) {
        IPRcvBuf    *pBuf = (IPRcvBuf *)pBuffer;
        while (pBuf) {
            IPSecQueryRcvBuf(pBuf, &pPyld, &Len);
            pAlgo->update(&State, pPyld, Len);
            *pLen += Len;
            pBuf = IPSEC_BUFFER_LINKAGE(pBuf);
        }
    } else {
        PNDIS_BUFFER    pBuf = (PNDIS_BUFFER)pBuffer;
        while (pBuf) {
            IPSecQueryNdisBuf(pBuf, &pPyld, &Len);
            pAlgo->update(&State, pPyld, Len);
            *pLen += Len;
            pBuf = NDIS_BUFFER_LINKAGE(pBuf);
        }
    }

    pAlgo->finish(&State, pHash, Index);

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecCreateHughes(
    IN      PUCHAR          pIPHeader,
    IN      PVOID           pData,
    IN      PSA_TABLE_ENTRY pSA,
    IN      ULONG           Index,
    OUT     PVOID           *ppNewData,
    OUT     PVOID           *ppSCContext,
    OUT     PULONG          pExtraBytes,
    IN      ULONG           HdrSpace,
    IN      PNDIS_PACKET    pNdisPacket,
    IN      BOOLEAN         fCryptoOnly
    )
/*++

Routine Description:

    Create the combined esp-des-* transform, as outlined in
    draft-ietf-ipsec-esp-v2-00, on the send side.

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ----
   |               Security Parameters Index (SPI)                 | ^
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |Auth.
   |                      Sequence Number                          | |Coverage
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | -----
   |                    Payload Data* (variable)                   | |   ^
   ~                                                               ~ |   |
   |                                                               | |   |
   +               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |Confid.
   |               |     Padding (0-255 bytes)                     | |Coverage*
   +-+-+-+-+-+-+-+-+               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |   |
   |                               |  Pad Length   | Next Header   | v   v
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ -------
   |                 Authentication Data (variable)                |
   ~                                                               ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

        * If included in the Payload field, cryptographic synchronization
          data, e.g., an IV, usually is not encrypted per se, although it
          often is referred to as being part of the ciphertext.

    The payload field, as defined in [ESP], is broken down according to
    the following diagram:

      +---------------+---------------+---------------+---------------+
      |                                                               |
      +                   Initialization Vector (IV)                  +
      |                                                               |
      +---------------+---------------+---------------+---------------+
      |                                                               |
      ~              Encrypted Payload (variable length)              ~
      |                                                               |
      +---------------------------------------------------------------+
       1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8

Arguments:

    pIPHeader - points to start of IP header.

    pData - points to the data after the IP header. PNDIS_BUFFER

    pSA - Sec. Assoc. entry

    ppNewData - the new MDL chain to be used by TCPIP

    ppSCContext - send complete context used to clean up IPSEC headers

    pExtraBytes - the header expansion caused by this IPSEC header

Return Value:

    STATUS_SUCCESS
    Others:
        STATUS_INSUFFICIENT_RESOURCES
        STATUS_UNSUCCESSFUL (error in algo.)

--*/
{
    ESP UNALIGNED   *pESP;
    NTSTATUS    status = STATUS_SUCCESS;
    PNDIS_BUFFER    pESPBuffer = NULL;
    PNDIS_BUFFER    pPadBuf = NULL;
    PNDIS_BUFFER    pOptBuf = NULL;
    ULONG   espLen;
    ULONG   padLen;
    ULONG   totalLen = 0;
    IPHeader UNALIGNED * pIPH;
    PIPSEC_SEND_COMPLETE_CONTEXT pContext;
    PNDIS_BUFFER    pNewMdl = NULL;
    PNDIS_BUFFER    pSaveMdl;
    PAUTH_ALGO      pAlgo = &(auth_algorithms[pSA->INT_ALGO(Index)]);
    ULONG   PayloadType;
    ULONG   hdrLen;
    PUCHAR  pPad;
    ULONG   TruncatedLen = (pSA->INT_ALGO(Index) != IPSEC_AH_NONE)? pSA->sa_TruncatedLen: 0;
    BOOLEAN fTunnel = ( (pSA->sa_Flags & FLAGS_SA_TUNNEL) &&
                        ((Index == 0) ||
                            ((Index == 1) && (pSA->sa_Operation[0] == Compress))));
    ULONG   tag = (!fTunnel) ?
                    IPSEC_TAG_HUGHES :
                    IPSEC_TAG_HUGHES_TU;
    IPHeader UNALIGNED * pIPH2;
    PNDIS_BUFFER    pHdrBuf=NULL;
    ULONG       bytesLeft;
    ULONG       hashBytes=0;
    ULONG       saveFlags=0;
    ULONG       Seq;
    USHORT      IPLength;
    PNDIS_BUFFER    pSaveDataLinkage = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);
    PNDIS_BUFFER    pSaveOptLinkage = NULL;
    PNDIS_BUFFER    pSaveBeforePad = NULL;

    IPSEC_DEBUG(HUGHES, ("Entering IPSecCreateHughes\n"));

#if DBG
    IPSEC_DEBUG(MDL, ("Entering IPSecCreateHughes\n"));
    IPSEC_PRINT_CONTEXT(*ppSCContext);
    IPSEC_PRINT_MDL(pData);
#endif

    ASSERT(pSA->sa_Operation[Index] == Encrypt);

    if (*ppSCContext == NULL) {
        pContext = IPSecAllocateSendCompleteCtx(tag);

        if (!pContext) {
            IPSEC_DEBUG(HUGHES, ("Failed to alloc. SendCtx\n"));
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        IPSEC_INCREMENT(g_ipsec.NumSends);

        IPSecZeroMemory(pContext, sizeof(IPSEC_SEND_COMPLETE_CONTEXT));
#if DBG
        RtlCopyMemory(pContext->Signature, "ISC4", 4);
#endif
        //
        // Send complete context
        //
        *ppSCContext = pContext;
    } else {
        pContext = *ppSCContext;
        saveFlags = pContext->Flags;
    }

    //
    // get the pad len -> total length + replay prevention field len + padlen + payloadtype needs to be padded to
    // 8 byte boundary.
    //
    pIPH = (IPHeader UNALIGNED *)pIPHeader;
    hdrLen = (pIPH->iph_verlen & (UCHAR)~IP_VER_FLAG) << 2;

    //
    // Transport mode: payload is after IP header => payloadlen is total len - hdr len
    // Tunnel modes: payload starts at IP header => payloadlen is total len
    //
    totalLen = (!fTunnel) ?
                NET_SHORT(pIPH->iph_length) - hdrLen :
                NET_SHORT(pIPH->iph_length);

    if ((pSA->CONF_ALGO(Index) == IPSEC_ESP_NONE) || fCryptoOnly) {
        if (fTunnel) {
            pContext->Flags |= SCF_NOE_TU;
        } else {
            pContext->Flags |= SCF_NOE_TPT;
        }
    }

    {
        PCONFID_ALGO        pConfAlgo;
        ULONG   blockLen;

        pConfAlgo = &(conf_algorithms[pSA->CONF_ALGO(Index)]);
        blockLen = pConfAlgo->blocklen;

        bytesLeft = (totalLen) % blockLen;

        if (bytesLeft <= blockLen - NUM_EXTRA) {
            //
            // we can now fit the leftover + Pad length + Payload Type in a single
            // chunk
            //
            padLen = blockLen - bytesLeft;
        } else {
            //
            // we pad the bytesleft to next octet boundary, then attach the length/type
            //
            padLen = (blockLen << 1) - bytesLeft;
        }
    }

    //
    // Get buffer for trailing PAD and signature (MD5 signature len)
    //
    IPSecAllocateBuffer(&status,
                        &pPadBuf,
                        &pPad,
                        padLen + pAlgo->OutputLen,
                        tag);

    if (!NT_SUCCESS(status)) {
        NTSTATUS    ntstatus;
        IPSEC_DEBUG(HUGHES, ("Failed to alloc. PAD MDL\n"));
        pContext->Flags = saveFlags;
        return status;
    }

    //
    // the padding should contain 1, 2, 3, 4.... (latest ESP draft - draft-ietf-ipsec-esp-v2-02.txt)
    // for any algo that doesn't specify its own padding - right now all implemented algos go with
    // the default.
    //
    RtlCopyMemory(pPad, DefaultPad, padLen);

    IPSEC_DEBUG(HUGHES, ("IP Len: %lx, pPad: %lx, PadLen: %lx\n", NET_SHORT(pIPH->iph_length), pPad, padLen));

    //
    // Link in the pad buffer at end of the data chain
    //
    {
        PNDIS_BUFFER    temp = pData;
        while (NDIS_BUFFER_LINKAGE(temp)) {
            temp = NDIS_BUFFER_LINKAGE(temp);
        }
        NDIS_BUFFER_LINKAGE(temp) = pPadBuf;
        pSaveBeforePad = temp;
        if (fTunnel) {
            pContext->BeforePadTuMdl = temp;
            pContext->PadTuMdl = pPadBuf;
        } else {
            pContext->BeforePadMdl = temp;
            pContext->PadMdl = pPadBuf;
        }
    }
    NDIS_BUFFER_LINKAGE(pPadBuf) = NULL;

    espLen = sizeof(ESP) + pSA->sa_ivlen + pSA->sa_ReplayLen;

    //
    // Get buffer for Hughes header
    //
    IPSecAllocateBuffer(&status,
                        &pESPBuffer,
                        (PUCHAR *)&pESP,
                        sizeof(ESP) + pSA->sa_ivlen + pSA->sa_ReplayLen,
                        tag);

    if (!NT_SUCCESS(status)) {
        NTSTATUS    ntstatus;
        IPSEC_DEBUG(HUGHES, ("Failed to alloc. ESP MDL\n"));
        NDIS_BUFFER_LINKAGE(pSaveBeforePad) = NULL;
        IPSecFreeBuffer(&ntstatus, pPadBuf);
        pContext->Flags = saveFlags;
        return status;
    }

    if (fTunnel) {
        PNDIS_BUFFER    pSrcOptBuf;
        PUCHAR          pOpt;
        PUCHAR          pSrcOpt;
        ULONG           optLen = 0;

        IPSEC_DEBUG(HUGHES, ("Hughes Tunnel mode...\n"));

        //
        // Allocate an MDL for the new cleartext IP  header
        //
        IPSecAllocateBuffer(&status,
                            &pHdrBuf,
                            (PUCHAR *)&pIPH2,
                            sizeof(IPHeader),
                            IPSEC_TAG_AH);

        if (!NT_SUCCESS(status)) {
            NTSTATUS    ntstatus;
            IPSEC_DEBUG(HUGHES, ("Failed to alloc. PAD MDL\n"));
            NDIS_BUFFER_LINKAGE(pSaveBeforePad) = NULL;
            IPSecFreeBuffer(&ntstatus, pPadBuf);
            IPSecFreeBuffer(&ntstatus, pESPBuffer);
            pContext->Flags = saveFlags;
            return status;
        }

        *pExtraBytes += espLen + padLen + TruncatedLen + sizeof(IPHeader);

        //
        // Now hookup the MDLs
        //
        pContext->Flags |= SCF_HU_TU;
        pContext->HUTuMdl = pESPBuffer;
        pContext->PrevTuMdl = (PNDIS_BUFFER)pData;
        pContext->HUHdrMdl = pHdrBuf;
        pContext->OriTuMdl = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);

        NDIS_BUFFER_LINKAGE(pESPBuffer) = pHdrBuf;

        if (hdrLen > sizeof(IPHeader)) {
            if (HdrSpace < *pExtraBytes) {

                IPSEC_DEBUG(AH, ("Going to frag.\n"));

                pSrcOptBuf = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);
                pSaveOptLinkage = NDIS_BUFFER_LINKAGE(pSrcOptBuf);
                IPSecQueryNdisBuf(pSrcOptBuf, &pSrcOpt, &optLen);
                IPSecAllocateBuffer(&status,
                                    &pOptBuf,
                                    (PUCHAR *)&pOpt,
                                    hdrLen - sizeof(IPHeader),
                                    IPSEC_TAG_AH);

                if (!NT_SUCCESS(status)) {
                    NTSTATUS    ntstatus;
                    IPSEC_DEBUG(AH, ("Failed to alloc. PAD MDL\n"));
                    NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData) = pSaveDataLinkage;
                    NDIS_BUFFER_LINKAGE(pSaveBeforePad) = NULL;
                    IPSecFreeBuffer(&ntstatus, pESPBuffer);
                    if (pHdrBuf) {
                        IPSecFreeBuffer(&ntstatus, pHdrBuf);
                    }
                    IPSecFreeBuffer(&ntstatus, pPadBuf);
                    pContext->Flags = saveFlags;
                    return status;
                }

                RtlCopyMemory(pOpt, pSrcOpt, hdrLen-sizeof(IPHeader));
                pContext->OptMdl = pOptBuf;

                IPSEC_DEBUG(HUGHES, ("Copying options. S: %lx, D: %lx\n", pSrcOptBuf, pOptBuf));

                //
                // replace the original Opt Mdl with ours.
                //
                NDIS_BUFFER_LINKAGE(pOptBuf) = NDIS_BUFFER_LINKAGE(pSrcOptBuf);
                NDIS_BUFFER_LINKAGE(pHdrBuf) = pOptBuf;

                IPSEC_DEBUG(HUGHES, ("Options; pointed Hdrbuf: %lx to pOptBuf: %lx\n", pHdrBuf, pOptBuf));
                *pExtraBytes += hdrLen-sizeof(IPHeader);

            } else {
                NDIS_BUFFER_LINKAGE(pHdrBuf) = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);
            }
        } else {
            NDIS_BUFFER_LINKAGE(pHdrBuf) = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);
        }

        NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData) = pESPBuffer;

        //
        // xsum the new IP header since we expect that to be the case
        // at this stage in tpt mode.
        //
        RtlCopyMemory(pIPH2, pIPH, sizeof(IPHeader));

        //
        // no options in the outer header; reset the len.
        //
        pIPH->iph_verlen = IP_VERSION + (sizeof(IPHeader) >> 2);

        //
        // also reset the frag. params.
        //
        pIPH->iph_offset &= ~(IP_MF_FLAG | IP_OFFSET_MASK);

        ASSERT(pSA->sa_TunnelAddr);

        //
        // Tunnel starts here; replace dest addr to point to Tunnel end if specified
        // else tunnel ends at final dest
        //
        pIPH->iph_dest = pSA->sa_TunnelAddr;

        //
        // The first pended packet on a gateway (proxy negotiating for two subnets)
        // would come via the transmit path. Hence the source address would not be
        // kosher. We need to replace the src address in that case also.
        // We get this from the corresponding inbound SA's tunnel addr.
        //
        pIPH->iph_src = pSA->sa_SrcTunnelAddr;

        pIPH->iph_id = (ushort) TCPIP_GEN_IPID();
        pIPH->iph_xsum = 0;
        pIPH->iph_xsum = ~xsum(pIPH, sizeof(IPHeader));

        //
        // Set up headers so CreateHash works as in Tpt mode.
        //
        pIPHeader = (PUCHAR)pIPH;
        *ppNewData = pData;
        PayloadType = IP_IN_IP;
    } else {
        *pExtraBytes += espLen + padLen + TruncatedLen;

        if (hdrLen > sizeof(IPHeader)) {
            //
            // Options present - chain ESP after options
            //
            pSaveMdl = pContext->OriHUMdl = NDIS_BUFFER_LINKAGE(NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData));
            pContext->PrevMdl = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);

            NDIS_BUFFER_LINKAGE(pESPBuffer) = pContext->OriHUMdl;
            NDIS_BUFFER_LINKAGE(NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData)) = pESPBuffer;
            pContext->Flags |= SCF_HU_TPT;
        } else {
            //
            // Chain the ESP buffer after IP header
            //
            pSaveMdl = pContext->OriHUMdl = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);
            pContext->PrevMdl = (PNDIS_BUFFER)pData;

            NDIS_BUFFER_LINKAGE(pESPBuffer) = pContext->OriHUMdl;
            NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData) = pESPBuffer;
            pContext->Flags |= SCF_HU_TPT;
        }

        //
        // Save the MDL pointer so we can hook it in place on SendComplete
        //
        pContext->HUMdl = pESPBuffer;
        PayloadType = ((UNALIGNED IPHeader *)pIPH)->iph_protocol;
    }

    //
    // Fill in the padlen at start of pad + padlen - NUM_EXTRA
    //
    *(pPad + padLen - NUM_EXTRA) = (UCHAR)padLen - NUM_EXTRA;

    //
    // Set the Payload Type
    //
    *(pPad + padLen + sizeof(UCHAR) - NUM_EXTRA) = (UCHAR)PayloadType;

    //
    // Initialize the other fields of the ESP header
    //
    pESP->esp_spi = HOST_TO_NET_LONG(pSA->sa_OtherSPIs[Index]);

    //
    // Copy the Replay field into the Hughes header
    //
    Seq = IPSEC_INCREMENT(pSA->sa_ReplaySendSeq[Index]);
    *(UNALIGNED ULONG *)(pESP + 1) = HOST_TO_NET_LONG(Seq);

    if ((pSA->CONF_ALGO(Index) != IPSEC_ESP_NONE) && !fCryptoOnly) {
        UCHAR   feedback[MAX_BLOCKLEN];
        KIRQL   kIrql;

        //
        // Pad is included in the chain, so prevent double free by NULL'ing
        // the ref.
        //
        if (fTunnel) {
            pContext->PadTuMdl = NULL;
        } else {
            pContext->PadMdl = NULL;
        }

        //
        // NOTE: The way the IV is supposed to work is that initially, the IV
        // is a random value. The IV is then updated with the residue of the
        // last encryption block of a packet. This is used as the starting IV
        // for the next block. This assures a fairly random IV sample and
        // introduces some notion of IV chaining.
        //
        // The only way for this to work is to make the entire encryption atomic,
        // which would be a performance drag. So, we take a less strict approach here.
        //
        // We just ensure that each packet starts at a random value, and also do the
        // chaining.
        //

        //
        // Copy the IV into the Hughes header
        //
        ACQUIRE_LOCK(&pSA->sa_Lock, &kIrql);
        RtlCopyMemory(  ((PUCHAR)(pESP + 1) + pSA->sa_ReplayLen),
                        pSA->sa_iv[Index],
                        pSA->sa_ivlen);

        //
        // Init the CBC feedback
        //
        RtlCopyMemory(  feedback,
                        pSA->sa_iv[Index],
                        DES_BLOCKLEN);

        IPSecGenerateRandom((PUCHAR)&pSA->sa_iv[Index][0], DES_BLOCKLEN);
        RELEASE_LOCK(&pSA->sa_Lock, kIrql);

        //
        // Encrypt the entire block, starting after the IV (if it exists)
        //

        //
        // Make it appear that pESPMdl points to after Replay field
        //
        NdisBufferLength((PNDIS_BUFFER)pESPBuffer) -= (sizeof(ESP) + pSA->sa_ivlen + pSA->sa_ReplayLen);
        (PUCHAR)((PNDIS_BUFFER)pESPBuffer)->MappedSystemVa += (sizeof(ESP) + pSA->sa_ivlen + pSA->sa_ReplayLen);

        //
        // Remove the Hash bytes since we dont want to encrypt them
        //
        NdisBufferLength((PNDIS_BUFFER)pPadBuf) -= pAlgo->OutputLen;

        ASSERT(NdisBufferLength((PNDIS_BUFFER)pESPBuffer) == 0);

        status = IPSecEncryptBuffer((PVOID)pESPBuffer,
                                    &pNewMdl,
                                    pSA,
                                    pPadBuf,
                                    &padLen,
                                    0,
                                    Index,
                                    feedback);

        if (!NT_SUCCESS(status)) {
            NTSTATUS    ntstatus;
            IPSEC_DEBUG(HUGHES, ("Failed to encrypt, pESP: %lx\n", pESP));

            //
            // Don't forget we need to restore ESP MDL since SystemVa has been
            // changed.  If not, we have trouble later if the same buffer is
            // used during reinject since we use the buffer as a real MDL
            // there.
            //
            NdisBufferLength((PNDIS_BUFFER)pESPBuffer) += (sizeof(ESP) + pSA->sa_ivlen + pSA->sa_ReplayLen);
            (PUCHAR)((PNDIS_BUFFER)pESPBuffer)->MappedSystemVa -= (sizeof(ESP) + pSA->sa_ivlen + pSA->sa_ReplayLen);

            NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData) = pSaveDataLinkage;
            NDIS_BUFFER_LINKAGE(pSaveBeforePad) = NULL;
            if (pSaveOptLinkage) {
                NDIS_BUFFER_LINKAGE(NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData)) = pSaveOptLinkage;
            }
            IPSecFreeBuffer(&ntstatus, pESPBuffer);
            if (pHdrBuf) {
                IPSecFreeBuffer(&ntstatus, pHdrBuf);
            }
            if (pOptBuf) {
                IPSecFreeBuffer(&ntstatus, pOptBuf);
            }
            IPSecFreeBuffer(&ntstatus, pPadBuf);

            pContext->Flags = saveFlags;
            return status;
        }

        NdisBufferLength((PNDIS_BUFFER)pPadBuf) += pAlgo->OutputLen;

        //
        // Restore ESP MDL
        //
        NdisBufferLength((PNDIS_BUFFER)pESPBuffer) += (sizeof(ESP) + pSA->sa_ivlen + pSA->sa_ReplayLen);
        (PUCHAR)((PNDIS_BUFFER)pESPBuffer)->MappedSystemVa -= (sizeof(ESP) + pSA->sa_ivlen + pSA->sa_ReplayLen);
        NDIS_BUFFER_LINKAGE(pESPBuffer) = pNewMdl;

        //
        // HMAC the entire block - starting at the SPI field => start of pESPBuffer
        //
        status = IPSecHashMdlChain( pSA,
                                    (PVOID)pESPBuffer,  // source
                                    pPad,               // dest
                                    FALSE,              // fIncoming
                                    pSA->INT_ALGO(Index),      // algo
                                    &hashBytes,
                                    Index);

        if (!NT_SUCCESS(status)) {
            NTSTATUS    ntstatus;
            IPSEC_DEBUG(HUGHES, ("Failed to hash, pAH: %lx\n", pESP));

            NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData) = pSaveDataLinkage;
            NDIS_BUFFER_LINKAGE(pSaveBeforePad) = NULL;
            if (pSaveOptLinkage) {
                NDIS_BUFFER_LINKAGE(NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData)) = pSaveOptLinkage;
            }
            IPSecFreeBuffer(&ntstatus, pESPBuffer);
            if (pHdrBuf) {
                IPSecFreeBuffer(&ntstatus, pHdrBuf);
            }
            if (pOptBuf) {
                IPSecFreeBuffer(&ntstatus, pOptBuf);
            }
            IPSecFreeBuffer(&ntstatus, pPadBuf);
            IPSecFreeBuffer(&ntstatus, pNewMdl);

            pContext->Flags = saveFlags;
            return status;
        }

        //
        // hook up the pad mdl which contains the final hash (the pad mdl was copied into
        // newMdl returned by EncryptDESCBC). Also, set the length of the Pad mdl to hash len.
        //
        // Remember we need to truncate this to 96 bits, so make it appear
        // as if we have only 96 bits.
        //
        NdisBufferLength(pPadBuf) = TruncatedLen;
        NDIS_BUFFER_LINKAGE(pNewMdl) = pPadBuf;

        pNdisPacket->Private.Tail = pPadBuf;

    } else {
        //
        // HMAC the entire block - starting at the SPI field => start of pESPBuffer
        //
        //
        // Remove the Hash bytes since we dont want to hash them
        //
        if (!fCryptoOnly) {
            NdisBufferLength((PNDIS_BUFFER)pPadBuf) -= pAlgo->OutputLen;
            status = IPSecHashMdlChain( pSA,
                                        (PVOID)pESPBuffer,  // source
                                        (PUCHAR)(pPad + padLen),               // dest
                                        FALSE,              // fIncoming
                                        pSA->INT_ALGO(Index),      // algo
                                        &hashBytes,
                                        Index);

            NdisBufferLength((PNDIS_BUFFER)pPadBuf) += pAlgo->OutputLen;

            if (!NT_SUCCESS(status)) {
                NTSTATUS    ntstatus;
                IPSEC_DEBUG(HUGHES, ("Failed to hash, pAH: %lx\n", pESP));

                NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData) = pSaveDataLinkage;
                NDIS_BUFFER_LINKAGE(pSaveBeforePad) = NULL;
                if (pSaveOptLinkage) {
                    NDIS_BUFFER_LINKAGE(NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData)) = pSaveOptLinkage;
                }
                IPSecFreeBuffer(&ntstatus, pESPBuffer);
                if (pHdrBuf) {
                    IPSecFreeBuffer(&ntstatus, pHdrBuf);
                }
                if (pOptBuf) {
                    IPSecFreeBuffer(&ntstatus, pOptBuf);
                }
                IPSecFreeBuffer(&ntstatus, pPadBuf);
                IPSecFreeBuffer(&ntstatus, pNewMdl);

                pContext->Flags = saveFlags;
                return status;
            }
        } else {
            IPSEC_GET_TOTAL_LEN(pESPBuffer, &hashBytes);
        }

        if (fCryptoOnly) {
            //
            // Zero out the hash.
            //
            IPSecZeroMemory(pPad + padLen, TruncatedLen);
            IPSecZeroMemory((PUCHAR)(pESP + 1) + pSA->sa_ReplayLen, pSA->sa_ivlen);
        }

        NdisBufferLength(pPadBuf) = padLen + TruncatedLen;

        pNdisPacket->Private.Tail = pPadBuf;
    }

    if (pSA->CONF_ALGO(Index) != IPSEC_ESP_NONE) {
        ADD_TO_LARGE_INTEGER(
            &pSA->sa_Stats.ConfidentialBytesSent,
            totalLen);

        ADD_TO_LARGE_INTEGER(
            &g_ipsec.Statistics.uConfidentialBytesSent,
            totalLen);
    }

    if (pSA->INT_ALGO(Index) != IPSEC_AH_NONE) {
        ADD_TO_LARGE_INTEGER(
            &pSA->sa_Stats.AuthenticatedBytesSent,
            hashBytes);

        ADD_TO_LARGE_INTEGER(
            &g_ipsec.Statistics.uAuthenticatedBytesSent,
            hashBytes);
    }

    //
    // Bump up the bytes transformed count.
    //
    ADD_TO_LARGE_INTEGER(
        &pSA->sa_TotalBytesTransformed,
        totalLen);

    //
    // Update the IP header length to reflect the Hughes header
    //
    IPLength = NET_SHORT(pIPH->iph_length) + (USHORT)(espLen + padLen + TruncatedLen);
    if (fTunnel) {
        IPLength += sizeof(IPHeader);
    }

    UpdateIPLength(pIPH, NET_SHORT(IPLength));
    UpdateIPProtocol(pIPH, PROTOCOL_ESP);

    //
    // Return modified packet.
    //
    IPSEC_DEBUG(HUGHES, ("Exiting IPSecCreateHughes, espLen: %lx, padLen: %lx, status: %lx\n", espLen, padLen, status));

#if DBG
    IPSEC_DEBUG(MDL, ("Exiting IPSecCreateHughes\n"));
    IPSEC_PRINT_CONTEXT(*ppSCContext);
    if (*ppNewData) {
        IPSEC_PRINT_MDL(*ppNewData);
    }
    else {
        IPSEC_PRINT_MDL(pData);
    }
#endif

    return STATUS_SUCCESS;
}


NTSTATUS
IPSecVerifyHughes(
    IN      PUCHAR          *pIPHeader,
    IN      PVOID           pData,
    IN      PSA_TABLE_ENTRY pSA,
    IN      ULONG           Index,
    OUT     PULONG          pExtraBytes,
    IN      BOOLEAN         fCryptoDone,
    IN      BOOLEAN         fFastRcv
    )
/*++

Routine Description:

    Verify the combined esp-des-md5 transform, as outlined in
    draft-ietf-ipsec-esp-des-md5, on the send side.

Arguments:

    pIPHeader - points to start of IP header.

    pData - points to the data after the IP header. IPRcvBuf*

    pSA - Sec. Assoc. entry

    pExtraBytes - out param to inform IP on recv path how many bytes IPSEC took off.

Return Value:

    STATUS_SUCCESS
    Others:
        STATUS_INSUFFICIENT_RESOURCES
        STATUS_UNSUCCESSFUL (error in algo.)

--*/
{
    PESP    pESP;
    NTSTATUS    status = STATUS_SUCCESS;
    PNDIS_BUFFER    pESPBuffer;
    PNDIS_BUFFER    pPadBuffer;
    LONG    espLen;
    UCHAR   padLen;
    UCHAR   payloadType;
    ULONG   uTotalLen = 0;
    ULONG   totalLen;
    ULONG   safetyLen;
    ULONG   hdrLen;
    PUCHAR  pHash;
    UCHAR   tempHash[SAFETY_LEN+1];
    ULONG   Len;
    UCHAR   Buf[MAX_AH_OUTPUT_LEN];
    PUCHAR  pAHData = Buf;
    PAUTH_ALGO      pAlgo = &(auth_algorithms[pSA->INT_ALGO(Index)]);
    ULONG   hashBytes = 0;
    IPRcvBuf    *temp = (IPRcvBuf *)pData;
	IPHeader UNALIGNED *pIPH = (IPHeader UNALIGNED *)*pIPHeader;
    ULONG   extraBytes = 0;
    USHORT  FilterFlags;
    BOOLEAN fTunnel = ((pSA->sa_Flags & FLAGS_SA_TUNNEL) &&
                       ((Index == 0) ||
                        ((Index == 1) && (pSA->sa_Operation[0] == Compress))));
    ULONG   TruncatedLen = (pSA->INT_ALGO(Index) != IPSEC_AH_NONE)? pSA->sa_TruncatedLen: 0;
    ULONG uPadLen = 0;
    IPRcvBuf * temp_pre = NULL;
    PUCHAR  data;

    IPSEC_DEBUG(HUGHES, ("Entering IPSecVerifyHughes\n"));

    ASSERT(pSA->sa_Operation[Index] == Encrypt);

    hdrLen = (pIPH->iph_verlen & (UCHAR)~IP_VER_FLAG) << 2;

    //
    // Transport mode: payload is after IP header => payloadlen is total len - hdr len
    // Tunnel mode: payload starts at IP header => payloadlen is total len
    //
    IPSEC_GET_TOTAL_LEN_RCV_BUF(pData, &totalLen);

    //
    // Do we have enough in the buffer?
    //
    Len = sizeof(ESP) + pSA->sa_ivlen + pSA->sa_ReplayLen + TruncatedLen;

    IPSEC_DEBUG(HUGHES, ("VerifyHughes: iph_len %d & hdrLen %d\n", NET_SHORT(pIPH->iph_length), hdrLen));
    IPSEC_DEBUG(HUGHES, ("VerifyHughes: DataLen %d & IPSecLen %d\n", totalLen, Len));

    if (totalLen < Len || totalLen != (NET_SHORT(pIPH->iph_length) - hdrLen)) {
        ASSERT(FALSE);
        return  STATUS_INVALID_PARAMETER;
    }

    //
    // Check for replay first
    // See if the signature matches the hash
    // First get the *&*&* hash - its at the end of the packet...
    //
    //
    // Check the replay window
    //
    IPSecQueryRcvBuf((IPRcvBuf *)pData, &pESP, &espLen);

    IPSEC_DEBUG(HUGHES, ("VerifyHughes: First buffer %lx\n", temp));

    //
    // Travel to the end of the packet and then backup TruncatedLen bytes
    //
    while (IPSEC_BUFFER_LINKAGE(temp)) {
        temp = IPSEC_BUFFER_LINKAGE(temp);
    }

    IPSEC_DEBUG(HUGHES, ("VerifyHughes: Last buffer %lx\n", temp));

    //
    // See if we have at least the full hash and padding in this one. Else go thru'
    // the slow path.
    //
    IPSecQueryRcvBuf(temp, &pHash, &Len);

    IPSEC_DEBUG(HUGHES, ("VerifyHughes: Last buffer length %d\n", Len));

    safetyLen = MAX_PAD_LEN + TruncatedLen + 1;

    IPSEC_DEBUG(HUGHES, ("VerifyHughes: Safety length %d\n", safetyLen));

    if (Len >= safetyLen) {
        //
        // now read the hash out of the buffer
        //
        pHash = pHash + Len - TruncatedLen;

        //
        // also remove the hash from the buffer
        //
        IPSEC_ADJUST_BUFFER_LEN (temp, Len - TruncatedLen);
        extraBytes += TruncatedLen;
        Len -= TruncatedLen;

        IPSEC_DEBUG(HUGHES, ("VerifyHughes: Modified Last buffer length %d\n", Len));

        IPSEC_DEBUG(HUGHES, ("pHash: %lx\n", pHash));
    } else {
        //
        // out of luck; need to grovel the lists for the TRUNC_LEN + MAX_PAD_LEN (SAFETY_LEN) bytes of data.
        // we copy out the last SAFETY_LEN bytes into another buffer and plug that into the list at the end
        // by re-allocing the last RcvBuf. We also zap the lengths of the remaining RcvBufs that contain these
        // special bytes.
        // NOTE: We also remove the hash from the buffer chain.
        //
        ULONG   length;
        ULONG   offset=0;   // offset within the current buffer
        ULONG   off=0;      // offset in the dest buffer (tempHash)
        ULONG   bytesLeft = safetyLen;
        IPRcvBuf    tmpRcvBuf={0};
        LONG    len = NET_SHORT(pIPH->iph_length) - safetyLen - hdrLen;

        temp = (IPRcvBuf *)pData;

        IPSEC_DEBUG(HUGHES, ("VerifyHughes: pData %lx & Len %lx\n", pData, len));

        //
        // first travel to the buffer that points to a chain containing the
        // last SAFETY_LEN bytes by skipping (Total - SAFETY_LEN) bytes.
        //
        while (temp) {
            IPSecQueryRcvBuf(temp, &data, &length);
            len -= length;
            if (len < 0) {
                break;
            }
            temp = IPSEC_BUFFER_LINKAGE(temp);
        }

        if (!temp) {
            return  STATUS_UNSUCCESSFUL;
        }

        //
        // pTemp now points to the last SAFETY_LEN bytes. Note that the last SAFETY_LEN bytes
        // might be in as many buffers and that there might be an offset in the current temp
        // where the last set of bytes starts.
        //
        len = -len;
        offset = length - len;

        IPSEC_DEBUG(HUGHES, ("After skip temp: %lx, Len: %d, offset: %d\n", temp, len, offset));

        do {
            RtlCopyMemory(  tempHash+off,
                            data+offset,
                            len);
            off += len;
            bytesLeft -= len;

            //
            // Also remove the hash bytes from the chain as we traverse it.
            //
            IPSEC_ADJUST_BUFFER_LEN (temp, length - len);

            if (bytesLeft == 0) {
                ASSERT(off == safetyLen);
                break;
            }

            temp = IPSEC_BUFFER_LINKAGE(temp);

            if (!temp) {
                return  STATUS_UNSUCCESSFUL;
            }

            IPSecQueryRcvBuf(temp, &data, &length);
            offset = 0;
            len = length;
        } while (TRUE);

        IPSEC_DEBUG(HUGHES, ("After copy tempHash: %lx\n", tempHash));

        //
        // Now we have an IPRcvBuf chain which has had SAFETY_LEN bytes removed.
        // We reallocate these SAFETY_LEN bytes in the last buffer with help from IP.
        //
        tmpRcvBuf = *temp;

        if (!TCPIP_ALLOC_BUFF(temp, safetyLen)) {
            IPSEC_DEBUG(HUGHES, ("Failed to realloc last 22 bytes\n"));
            return  STATUS_INSUFFICIENT_RESOURCES;
        }

        IPSEC_DEBUG(HUGHES, ("Alloc'ed new temp: %lx\n", temp));

        //
        // Now temp points to the new buffer with SAFETY_LEN number of bytes.
        // Free the Original buffer.
        //
        TCPIP_FREE_BUFF(&tmpRcvBuf);

        //
        // Copy over the bytes into the buffer just allocated.
        //
        IPSEC_ADJUST_BUFFER_LEN (temp, safetyLen);
        IPSecQueryRcvBuf(temp, &data, &Len);
        ASSERT(Len == safetyLen);

        RtlCopyMemory(  data,
                        tempHash,
                        safetyLen);

        //
        // now read the hash out of the buffer
        //
        pHash = data + Len - TruncatedLen;

        //
        // also remove the hash from the buffer
        //
        IPSEC_ADJUST_BUFFER_LEN (temp, Len - TruncatedLen);

        IPSEC_DEBUG(HUGHES, ("Len in temp: %d\n", temp->ipr_size));

        extraBytes += TruncatedLen;
        Len -= TruncatedLen;

        IPSEC_DEBUG(HUGHES, ("pHash: %lx, Len: %d\n", pHash, Len));
    }

    //
    // Hash is generated starting after the IPHeader, ie at start of pData
    //
    if (!fCryptoDone) {
        status = IPSecHashMdlChain( pSA,
                                    (PVOID)pData,       // source
                                    pAHData,            // dest
                                    TRUE,               // fIncoming
                                    pSA->INT_ALGO(Index),           // algo
                                    &hashBytes,
                                    Index);

        if (!NT_SUCCESS(status)) {
            IPSEC_DEBUG(HUGHES, ("Failed to hash, pData: %lx\n", pData));
            return status;
        }

        if (!IPSecEqualMemory(  pAHData,
                                pHash,
                                TruncatedLen * sizeof(UCHAR))) {

            IPSecBufferEvent(   pIPH->iph_src,
                                EVENT_IPSEC_AUTH_FAILURE,
                                2,
                                TRUE);

            IPSEC_DEBUG(HUGHES, ("Failed to compare, pPyld: %lx, pAHData: %lx\n", pHash, pAHData));
            IPSEC_INC_STATISTIC(dwNumPacketsNotAuthenticated);

            return IPSEC_INVALID_ESP;
        }
    } else {
        hashBytes = totalLen - TruncatedLen;
    }

    status=IPSecChkReplayWindow(
        NET_TO_HOST_LONG(*(ULONG UNALIGNED *)(pESP + 1)),
        pSA,
        Index);
    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(HUGHES, ("Replay check failed, pSA: %lx\n", pSA));
        IPSEC_INC_STATISTIC(dwNumPacketsWithReplayDetection);
        return status;
    }

    if (pSA->INT_ALGO(Index) != IPSEC_AH_NONE) {
        ADD_TO_LARGE_INTEGER(
            &pSA->sa_Stats.AuthenticatedBytesReceived,
            hashBytes);

        ADD_TO_LARGE_INTEGER(
            &g_ipsec.Statistics.uAuthenticatedBytesReceived,
            hashBytes);
    }

    espLen = sizeof(ESP) + pSA->sa_ivlen + pSA->sa_ReplayLen;

    if ((pSA->CONF_ALGO(Index) != IPSEC_ESP_NONE) && !fCryptoDone) {
        PCONFID_ALGO    pConfAlgo;
        ULONG           blockLen;

        pConfAlgo = &(conf_algorithms[pSA->CONF_ALGO(Index)]);
        blockLen = pConfAlgo->blocklen;

        //
        // Make sure the data is aligned to 8 byte boundary.
        //
        if ((hashBytes - espLen) % blockLen) {
            IPSEC_DEBUG(ESP, ("ESP data not aligned: hashBytes %d, totalLen %d, espLen %d, blockLen %d\n", hashBytes, totalLen, espLen, blockLen));
            return  STATUS_UNSUCCESSFUL;
        }

        //
        // Decrypt the entire block
        //
        status = IPSecDecryptBuffer(pData,
                                    pSA,
                                    &padLen,
                                    &payloadType,
                                    Index);

        if (!NT_SUCCESS(status)) {
            IPSEC_DEBUG(HUGHES, ("Failed the decrypt\n"));
            return status;
        }
    }

    //
    // Now remove the Pad too since it was not removed in Decrypt
    //
    padLen = *(pHash - (sizeof(UCHAR) << 1));

    payloadType = *(pHash - sizeof(UCHAR));

    IPSEC_DEBUG(HUGHES, ("ESP: PadLen: %d, PayloadType: %lx, pHash: %lx, Len: %d\n", padLen, payloadType, pHash, Len));

    //
    // Entire pad may not be in this buffer.
    //

    uPadLen = padLen + NUM_EXTRA;

    IPSEC_DEBUG(HUGHES, ("Total pad length = %d\n", uPadLen));

    while (Len < uPadLen) {

        IPSEC_ADJUST_BUFFER_LEN (temp, 0);

        IPSEC_DEBUG(HUGHES, ("Buffer: %lx  has a length %d - setting it to 0\n", temp, Len));

        uPadLen -= Len;

        IPSEC_DEBUG(HUGHES, ("Net pad length = %d\n", uPadLen));

        temp_pre = (IPRcvBuf *) pData;

        while (temp_pre->ipr_next != temp) {
            temp_pre = IPSEC_BUFFER_LINKAGE(temp_pre);
            if (!temp_pre) {
                IPSEC_DEBUG(HUGHES, ("Total size of all the buffers is smaller than the esp pad length\n"));
                ASSERT(temp_pre);
                return  STATUS_UNSUCCESSFUL;
            }
        }

        IPSecQueryRcvBuf(temp_pre, &data, &Len);

        temp = temp_pre;
    }

    IPSEC_ADJUST_BUFFER_LEN (temp, Len - uPadLen);

    IPSEC_DEBUG(HUGHES, ("Buffer: %lx  has a length %d - setting it to %d\n", temp, Len, Len - uPadLen));

    extraBytes += (padLen + NUM_EXTRA);

    if (pSA->CONF_ALGO(Index) != IPSEC_ESP_NONE) {
        ADD_TO_LARGE_INTEGER(
            &pSA->sa_Stats.ConfidentialBytesReceived,
            totalLen - (extraBytes + espLen));

        ADD_TO_LARGE_INTEGER(
            &g_ipsec.Statistics.uConfidentialBytesReceived,
            totalLen - (extraBytes + espLen));
    }

    //
    // Bump up the bytes transformed count.
    //
    ADD_TO_LARGE_INTEGER(
        &pSA->sa_TotalBytesTransformed,
        totalLen);

    if (!fTunnel) {
        //
        // Update the IP header length to reflect removal of the ESP header
        //
        IPSEC_DEBUG(HUGHES, ("VerifyHughes: iph_len %d, padLen %d, truncLen %d & espLen %d\n", NET_SHORT(pIPH->iph_length), uPadLen, TruncatedLen, espLen));

        pIPH->iph_length =
                NET_SHORT(
                    NET_SHORT(pIPH->iph_length) -
                    (USHORT)(espLen + uPadLen + TruncatedLen));

        IPSEC_DEBUG(HUGHES, ("VerifyHughes: iph_len %d\n", NET_SHORT(pIPH->iph_length)));

        //
        // set the payload type in the IP header
        //
        pIPH->iph_protocol = payloadType;

        //
        // Remove the ESP header from the packet; pad was removed in Decrypt
        //
        IPSEC_SET_OFFSET_IN_BUFFER(pData, espLen);

        //
        // Move the IP header forward for filter/firewall hook, fast path only.
        //
        if (fFastRcv) {
            IPSEC_DEBUG(HUGHES, ("VerifyHughes: fast receive true - "));
            IPSEC_DEBUG(HUGHES, ("Moving the IP header forward from %lx by espLen %d\n", pIPH, espLen));
            IPSecMoveMemory(((PUCHAR)pIPH) + espLen, (PUCHAR)pIPH, hdrLen);
            *pIPHeader=(PUCHAR)pIPH+espLen;
            pIPH = (IPHeader UNALIGNED *)*pIPHeader;
        }

        extraBytes += espLen;

        //
        // Return modified packet.
        //
        IPSEC_DEBUG(HUGHES, ("Exiting VerifyHughes: extra bytes %d & status: %lx\n", extraBytes, status));

        *pExtraBytes += extraBytes;

#if DBG
        IPSEC_GET_TOTAL_LEN_RCV_BUF(pData, &uTotalLen);
        IPSEC_DEBUG(HUGHES, ("VerifyHughes: iph_length %d & buflen %d\n", NET_SHORT(pIPH->iph_length), uTotalLen));
#endif

        return STATUS_SUCCESS;
    } else {
        //
        // set the payload type in the IP header
        //
        pIPH->iph_protocol = payloadType;

        //
        // Remove the ESP header from the packet
        //
        IPSEC_SET_OFFSET_IN_BUFFER(pData, espLen);

        //
        // Move the IP header forward for filter/firewall hook, fast path only.
        //
        if (fFastRcv) {
            IPSecMoveMemory(((PUCHAR)pIPH) + espLen, (PUCHAR)pIPH, hdrLen);
            *pIPHeader=(PUCHAR)pIPH+espLen;
            pIPH = (IPHeader UNALIGNED *)*pIPHeader;
        }

        extraBytes += espLen;

        //
        // Return modified packet.
        //
        IPSEC_DEBUG(ESP, ("Exiting IPSecVerifyHughes, espLen: %lx, status: %lx\n", espLen, status));

        if (payloadType != IP_IN_IP) {
            IPSEC_INC_STATISTIC(dwNumPacketsNotDecrypted);
            IPSEC_DEBUG(ESP, ("Bad payloadtype: %c\n", payloadType));
            status = STATUS_INVALID_PARAMETER;
        }

        *pExtraBytes += extraBytes;

        //
        // Drop the original packet
        //
        return status;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\ipseceng.h ===
#define IPSEC_ISAKMP_PORT   0xf401  // 500 in NBO
#define IPSEC_KERBEROS_PORT 0x5800  // 88 in NBO
#define IPSEC_LDAP_PORT     0x8501  // 389 in NBO


IPSEC_ACTION
IPSecHandlePacket(
    IN  PUCHAR          pIPHeader,
    IN  PVOID           pData,
    IN  PVOID           IPContext,
    IN  PNDIS_PACKET    Packet,
    IN OUT PULONG       pExtraBytes,
    IN OUT PULONG       pMTU,
    OUT PVOID           *pNewData,
    IN OUT PULONG       pIpsecFlags,
    IN  UCHAR           DestType
    );

IPSEC_ACTION
IPSecSendPacket(
    IN  PUCHAR          pIPHeader,
    IN  PVOID           pData,
    IN  PVOID           IPContext,
    IN  PNDIS_PACKET    Packet,
    IN OUT PULONG       pExtraBytes,
    IN OUT PULONG       pMTU,
    OUT PVOID           *pNewData,
    IN OUT PULONG       pIpsecFlags,
    OUT PIPSEC_DROP_STATUS pDropStatus,
    IN  UCHAR           DestType
    );

IPSEC_ACTION
IPSecRecvPacket(
    IN  PUCHAR          *pIPHeader,
    IN  PVOID           pData,
    IN  PVOID           IPContext,
    IN  PNDIS_PACKET    Packet,
    IN OUT PULONG       pExtraBytes,
    IN OUT PULONG       pIpsecFlags,
    OUT PIPSEC_DROP_STATUS pDropStatus,
    IN  UCHAR           DestType
    );

VOID
IPSecCalcHeaderOverheadFromSA(
    IN  PSA_TABLE_ENTRY pSA,
    OUT PULONG          pOverhead
    );

NTSTATUS
IPSecParsePacket(
    IN  PUCHAR      pIPHeader,
    IN  PVOID       *pData,
    OUT tSPI        *pSPI
    );

PSA_TABLE_ENTRY
IPSecLookupSAInLarval(
    IN  ULARGE_INTEGER  uliSrcDstAddr,
    IN  ULARGE_INTEGER  uliProtoSrcDstPort
    );

NTSTATUS
IPSecClassifyPacket(
    IN  PUCHAR          pHeader,
    IN  PVOID           pData,
    OUT PSA_TABLE_ENTRY *ppSA,
    OUT PSA_TABLE_ENTRY *ppNextSA,
    OUT USHORT          *pFilterFlags,
#if GPC
    IN  CLASSIFICATION_HANDLE   GpcHandle,
#endif
    IN  BOOLEAN         fOutbound,
    IN  BOOLEAN         fFWPacket,
    IN  BOOLEAN         fDoBypassCheck,
    IN  UCHAR           DestType
    );

VOID
IPSecSendComplete(
    IN  PNDIS_PACKET    Packet,
    IN  PVOID           pData,
    IN  PIPSEC_SEND_COMPLETE_CONTEXT  pContext,
    IN  IP_STATUS       Status,                   
    OUT PVOID           *ppNewData
    );

VOID
IPSecProtocolSendComplete (
    IN  PVOID           pContext,
    IN  PNDIS_BUFFER    pMdl,
    IN  IP_STATUS       Status
    );

NTSTATUS
IPSecChkReplayWindow(
    IN  ULONG           Seq,
    IN  PSA_TABLE_ENTRY pSA,
    IN  ULONG           Index
    );

NTSTATUS
IPSecReinjectPacket(
    IN  PVOID                   pData,
    IN  PNDIS_PACKET_EXTENSION  pPktExt
    );

NTSTATUS
IPSecQueuePacket(
    IN  PSA_TABLE_ENTRY pSA,
    IN  PVOID           pDataBuf
    );

VOID
IPSecIPAddrToUnicodeString(
    IN  IPAddr  Addr,
    OUT PWCHAR  UCIPAddrBuffer
    );

VOID
IPSecCountToUnicodeString(
    IN  ULONG   Count,
    OUT PWCHAR  UCCountBuffer
    );

VOID
IPSecESPStatus(
    IN  UCHAR       StatusType,
    IN  IP_STATUS   StatusCode,
    IN  IPAddr      OrigDest,
    IN  IPAddr      OrigSrc,
    IN  IPAddr      Src,
    IN  ULONG       Param,
    IN  PVOID       Data
    );

VOID
IPSecAHStatus(
    IN  UCHAR       StatusType,
    IN  IP_STATUS   StatusCode,
    IN  IPAddr      OrigDest,
    IN  IPAddr      OrigSrc,
    IN  IPAddr      Src,
    IN  ULONG       Param,
    IN  PVOID       Data
    );

VOID
IPSecProcessPMTU(
    IN  IPAddr      OrigDest,
    IN  IPAddr      OrigSrc,
    IN  tSPI        SPI,
    IN  OPERATION_E Operation,
    IN  ULONG       NewMTU
    );

IPSEC_ACTION
IPSecRcvFWPacket(
    IN  PCHAR   pIPHeader,
    IN  PVOID   pData,
    IN  UINT    DataLength,
    IN  UCHAR   DestType
    );


NTSTATUS
IPSecRekeyInboundSA(
    IN  PSA_TABLE_ENTRY pSA
    );

NTSTATUS
IPSecRekeyOutboundSA(
    IN  PSA_TABLE_ENTRY pSA
    );

NTSTATUS
IPSecPuntInboundSA(
    IN  PSA_TABLE_ENTRY pSA
    );

NTSTATUS
IPSecPuntOutboundSA(
    IN  PSA_TABLE_ENTRY pSA
    );

BOOLEAN
IPSecQueryStatus(
    IN  CLASSIFICATION_HANDLE   GpcHandle
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\ipsec.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    ipsec.c

Abstract:

    This module contains the code that handles incoming/outgoing packets.

Author:

    Sanjay Anand (SanjayAn) 2-January-1997
    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#include    "precomp.h"

IPSEC_ACTION
IPSecHandlePacket(
    IN  PUCHAR          pIPHeader,
    IN  PVOID           pData,
    IN  PVOID           IPContext,
    IN  PNDIS_PACKET    Packet,
    IN OUT PULONG       pExtraBytes,
    IN OUT PULONG       pMTU,
    OUT PVOID           *pNewData,
    IN OUT PULONG       pIpsecFlags,
    IN  UCHAR           DestType
    )
/*++

Routine Description:

    Called by the Filter Driver to submit a packet for IPSEC processing.

Arguments:

    pIPHeader - points to start of IP header.

    pData - points to the data after the IP header. On the send side, this is an MDL chain
            On the recv side this is an IPRcvBuf pointer.

    IPContext - contains the destination interface.

    pExtraBytes - IPSEC header expansion value; on coming in, it contains the amount of ipsec
            header space that can fit into the MTU. so, if MTU is 1400, say, and the
            datasize + option size is 1390, this contains 10, meaning that upto
            10 bytes of IPSEC expansion is allowed. This lets IPSEC know when a packet
            would be fragmented, so it can do the right thing on send complete.

    pMTU - passes in the link MTU on send path.

    pNewData - if packet modified, this points to the new data.

    IpsecFlags - flags for SrcRoute, Incoming, Forward and Lookback.

Return Value:

    eFORWARD
    eDROP
    eABSORB

--*/
{
    IPSEC_ACTION    eAction;
    IPSEC_DROP_STATUS DropStatus;
    PIPSEC_DROP_STATUS pDropStatus=NULL;

    IPSEC_DEBUG(PARSE, ("Entering IPSecHandlePacket\n"));

#if DBG
    {
        IPHeader UNALIGNED  *pIPH;

        pIPH = (IPHeader UNALIGNED *)pIPHeader;
        if ((DebugSrc || DebugDst || DebugPro) &&
            (!DebugSrc || pIPH->iph_src == DebugSrc) &&
            (!DebugDst || pIPH->iph_dest == DebugDst) &&
            (!DebugPro || pIPH->iph_protocol == DebugPro)) {
            DbgPrint("Packet from %lx to %lx with protocol %lx length %lx id %lx\n",
                    pIPH->iph_src,
                    pIPH->iph_dest,
                    pIPH->iph_protocol,
                    NET_SHORT(pIPH->iph_length),
                    NET_SHORT(pIPH->iph_id));
            if (DebugPkt) {
                DbgBreakPoint();
            }
        }
    }
#endif

    //
    // Drop all packets if PA sets us so or if the driver is inactive.
    //
    if (IS_DRIVER_BLOCK() || IPSEC_DRIVER_IS_INACTIVE()) {
        eAction=eDROP;
        goto out;
    }

    //
    // Bypass all packets if PA sets us so or no filters are plumbed or the
    // packet is broadcast.  If multicast filter present, process all multicast
    // Once we support any-any tunnels, this check will need to be smarter
    //
    if (IS_DRIVER_BYPASS() || IPSEC_DRIVER_IS_EMPTY() || 
        (IS_BCAST_DEST(DestType) && !IPSEC_MANDBCAST_PROCESS())) {

        *pExtraBytes = 0;
        *pMTU = 0;
        eAction= eFORWARD;
        goto out;
    }

    ASSERT(IS_DRIVER_SECURE());
    ASSERT(IPContext);

    IPSEC_INCREMENT(g_ipsec.NumThreads);

    if (IS_DRIVER_DIAGNOSTIC()) {
        pDropStatus=&DropStatus;
        RtlZeroMemory(pDropStatus,sizeof(IPSEC_DROP_STATUS));
    } 

    if (*pIpsecFlags & IPSEC_FLAG_INCOMING) {
        eAction = IPSecRecvPacket(  &pIPHeader,
                                    pData,
                                    IPContext,
                                    Packet,
                                    pExtraBytes,
                                    pIpsecFlags,
                                    pDropStatus,
                                    DestType);
    } else {
        eAction = IPSecSendPacket(  pIPHeader,
                                    pData,
                                    IPContext,
                                    Packet,
                                    pExtraBytes,
                                    pMTU,
                                    pNewData,
                                    pIpsecFlags,
                                    pDropStatus,
                                    DestType);
    }

    IPSEC_DECREMENT(g_ipsec.NumThreads);

out:
    if (eAction == eDROP) {
        if (IS_DRIVER_DIAGNOSTIC() && 
            (!pDropStatus || (pDropStatus && !(pDropStatus->Flags & IPSEC_DROP_STATUS_DONT_LOG)))) {
            IPSecBufferPacketDrop(
                pIPHeader,
                pData,
                pIpsecFlags,
                pDropStatus);
        }
    }
    return  eAction;
}


IPSEC_ACTION
IPSecSendPacket(
    IN  PUCHAR          pIPHeader,
    IN  PVOID           pData,
    IN  PVOID           IPContext,
    IN  PNDIS_PACKET    Packet,
    IN OUT PULONG       pExtraBytes,
    IN OUT PULONG       pMTU,
    OUT PVOID           *pNewData,
    IN OUT PULONG       pIpsecFlags,
    OUT PIPSEC_DROP_STATUS pDropStatus,
    IN UCHAR            DestType
    )
/*++

Routine Description:

    Called by the Filter Driver to submit a packet for IPSEC processing.

Arguments:

    pIPHeader - points to start of IP header.

    pData - points to the data after the IP header, an MDL chain.

    IPContext - contains the destination interface.

    pExtraBytes - IPSEC header expansion value.

    pMTU - passes in the link MTU on send path.

    pNewData - if packet modified, this points to the new data.

    IpsecFlags - flags for SrcRoute, Incoming, Forward and Lookback.

Return Value:

    eFORWARD
    eDROP
    eABSORB

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;
    IPSEC_ACTION            eRetAction = eFORWARD;
    PSA_TABLE_ENTRY         pSA = NULL;
    PSA_TABLE_ENTRY         pSaveSA = NULL;
    PSA_TABLE_ENTRY         pNextSA = NULL;
    USHORT                  FilterFlags = 0;
    BOOLEAN                 fLifetime = FALSE;
    ULONG                   ipsecHdrSpace = *pExtraBytes;
    ULONG                   ipsecOverhead = 0;
    ULONG                   ipsecMTU = *pMTU;
    ULONG                   newMTU = MAX_LONG;
    ULONG                   dataLength = 0;
    IPHeader UNALIGNED      *pIPH = (IPHeader UNALIGNED *)pIPHeader;
    Interface               *DestIF = (Interface *)IPContext;
    PNDIS_PACKET_EXTENSION  PktExt = NULL;
    PNDIS_IPSEC_PACKET_INFO IPSecPktInfo = NULL;
    BOOLEAN                 fCryptoOnly = FALSE;
    BOOLEAN                 fFWPacket = FALSE;
    BOOLEAN                 fSrcRoute = FALSE;
    BOOLEAN                 fLoopback = FALSE;
    PVOID                   *ppSCContext;
    KIRQL	                kIrql;
    LONG                    Index;
    PNDIS_BUFFER            pTemp;
    ULONG                   Length;
    PUCHAR                  pBuffer;

    IPSEC_DEBUG(PARSE, ("Entering IPSecSendPacket\n"));

    if (*pIpsecFlags & IPSEC_FLAG_FORWARD) {
        fFWPacket = TRUE;
    }
    if (*pIpsecFlags & IPSEC_FLAG_SSRR) {
        fSrcRoute = TRUE;
    }
    if (*pIpsecFlags & IPSEC_FLAG_LOOPBACK) {
        fLoopback = TRUE;
    }

    *pExtraBytes = 0;
    *pMTU = 0;

    if (fLoopback) {
        IPSEC_DEBUG(PARSE, ("IPSecSendPacket: Packet on loopback interface - returning\n"));
        status = STATUS_SUCCESS;
        goto out;
    }

    //
    // Walk through the MDL chain to make sure we have memory locked.
    //
    pTemp = (PNDIS_BUFFER)pData;

    while (pTemp) {
        pBuffer = NULL;
        Length = 0;

        NdisQueryBufferSafe(pTemp,
                            &pBuffer,
                            &Length,
                            NormalPagePriority);

        if (!pBuffer) {
            //
            // QueryBuffer failed, drop the packet.
            //
            status = STATUS_UNSUCCESSFUL;
            goto out;
        }

        dataLength += Length;

        pTemp = NDIS_BUFFER_LINKAGE(pTemp);
    }

    dataLength -= sizeof(IPHeader);

    //
    // Set send complete context in the NDIS packet.
    //
    if (Packet) {
        PacketContext   *pContext;

        pContext = (PacketContext *)Packet->ProtocolReserved;
        ppSCContext = &pContext->pc_common.pc_IpsecCtx;
    } else {
        ASSERT(FALSE);
        status = STATUS_UNSUCCESSFUL;
        goto out;
    }

    status = IPSecClassifyPacket(   pIPHeader,
                                    pData,
                                    &pSA,
                                    &pNextSA,
                                    &FilterFlags,
#if GPC
                                    PtrToUlong(NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, ClassificationHandlePacketInfo)),
#endif

                                    TRUE,   // fOutbound
                                    fFWPacket,
                                    TRUE,   // do bypass check
                                    DestType); 

    if (status == STATUS_PENDING) {
        //
        // Negotiation kicked off; drop the packet silently.
        //
        return  eABSORB;
    } else if (status != STATUS_SUCCESS) {
        status = STATUS_SUCCESS;
        goto out;
    }

    if (FilterFlags) {
        ASSERT(pSA == NULL);

        //
        // This is either a drop or pass thru filter.
        //
        if (FilterFlags & FILTER_FLAGS_DROP) {
            IPSEC_DEBUG(PARSE, ("Drop filter\n"));
            status = STATUS_UNSUCCESSFUL;
        } else if (FilterFlags & FILTER_FLAGS_PASS_THRU) {
            IPSEC_DEBUG(PARSE, ("Pass thru' filter\n"));
            status = STATUS_SUCCESS;
        } else {
            ASSERT(FALSE);
        }

        goto out;
    }

    //
    // Consider only outbound SAs
    //
    ASSERT(pSA);
    ASSERT(pSA->sa_Flags & FLAGS_SA_OUTBOUND);

    //
    // We don't support Source Route with IPSec Tunneling.
    //
    if (fSrcRoute && (pSA->sa_Flags & FLAGS_SA_TUNNEL)) {
        IPSEC_DEBUG(TUNNEL, ("No tunneling source route: pSA: %lx\n", pSA));
        IPSecDerefSANextSA(pSA, pNextSA);
        status = STATUS_UNSUCCESSFUL;
        goto out;
    }

    //
    // Set the last used time.
    //
    NdisGetCurrentSystemTime(&pSA->sa_LastUsedTime);


    if (!(pSA->sa_Flags & FLAGS_SA_DISABLE_LIFETIME_CHECK)) {
        //
        // check if we might expire soon - start rekey operation now.
        //
        IPSEC_CHECK_PADDED_LIFETIME(pSA, fLifetime, pSA->sa_NumOps - 1);
        
        if (fLifetime == FALSE) {
            IPSecRekeyOutboundSA(pSA);
        }
        
        //
        // check the real lifetime - if we have expired, ensure that the
        // re-key was submitted and then cancel the current SAs.
        //
        IPSEC_CHECK_LIFETIME(pSA, fLifetime, pSA->sa_NumOps - 1);
        
        //
        // this time it really expired - we are in trouble since this shd have gone away
        // earlier.
        //
        if (fLifetime == FALSE) {
            IPSecPuntOutboundSA(pSA);
            IPSecDerefSANextSA(pSA, pNextSA);
            status = STATUS_UNSUCCESSFUL;
            goto out;
        }

    }

    //
    // Compute the total IPSec overhead.
    //
    ipsecOverhead = pSA->sa_IPSecOverhead;
    if (pNextSA) {
        ipsecOverhead += pNextSA->sa_IPSecOverhead;
    }

    //
    // Check if total data length exceeds 65535.
    //
    if ((dataLength + ipsecOverhead) > (MAX_IP_DATA_LENGTH - sizeof(IPHeader))) {
        IPSecDerefSANextSA(pSA, pNextSA);
        status = STATUS_UNSUCCESSFUL;
        goto out;
    }

    //
    // If no enough header space, return right away if DF bit is set.  We also
    // have to adjust for PMTU recorded in the SAs.
    //
    if (pIPH->iph_offset & IP_DF_FLAG) {
        //
        // First get MTU recorded from IPSecStatus.
        //
        if (pNextSA) {
            newMTU = MIN(IPSEC_GET_VALUE(pSA->sa_NewMTU),
                         IPSEC_GET_VALUE(pNextSA->sa_NewMTU));
        } else {
            newMTU = IPSEC_GET_VALUE(pSA->sa_NewMTU);
        }

        //
        // Use the smaller of link MTU and new MTU from SA.
        //
        newMTU = MIN(newMTU, ipsecMTU);

        //
        // See if we have enough header space; if not pass back the new smaller
        // MTU minus IPSec overhead to the upper stack.
        //
        if (newMTU < (ipsecOverhead + dataLength)) {
            *pMTU = newMTU - ipsecOverhead;

            IPSecDerefSANextSA(pSA, pNextSA);

            IPSEC_DEBUG(PMTU, ("OldMTU %lx, HdrSpace: %lx, NewMTU: %lx\n", ipsecMTU, ipsecHdrSpace, *pMTU));
            status = STATUS_UNSUCCESSFUL;
            goto out;
        }
    }

    //
    // See if hardware offload can be arranged here.  If successful, we pass the
    // flag to the create routines so they create only the framing, leaving the
    // core crypto to the hardware.
    //
    if (g_ipsec.EnableOffload && ipsecOverhead <= ipsecHdrSpace) {
        IPSecSendOffload(   pIPH,
                            Packet,
                            DestIF,
                            pSA,
                            pNextSA,
                            ppSCContext,
                            &fCryptoOnly);
    }

    //
    // Make sure IPSecPktInfo is NULL if there is no offload for this
    // packet.  This could be set in reinject path which is then
    // forwarded.
    //
    if (!fCryptoOnly) {
        ASSERT(Packet != NULL);

        PktExt = NDIS_PACKET_EXTENSION_FROM_PACKET(Packet);
        PktExt->NdisPacketInfo[IpSecPacketInfo] = NULL;
    }

    if (fCryptoOnly) {
        ADD_TO_LARGE_INTEGER(
            &g_ipsec.Statistics.uOffloadedBytesSent,
            NET_SHORT(pIPH->iph_length));
        if (pDropStatus) {
            pDropStatus->Flags |= IPSEC_DROP_STATUS_CRYPTO_DONE;
        }

    }

    do {
        ADD_TO_LARGE_INTEGER(
            &pSA->sa_Stats.TotalBytesSent,
            NET_SHORT(pIPH->iph_length));

        if (pSA->sa_Flags & FLAGS_SA_TUNNEL) {
            ADD_TO_LARGE_INTEGER(
                &g_ipsec.Statistics.uBytesSentInTunnels,
                NET_SHORT(pIPH->iph_length));
        } else {
            ADD_TO_LARGE_INTEGER(
                &g_ipsec.Statistics.uTransportBytesSent,
                NET_SHORT(pIPH->iph_length));
        }

        if (fCryptoOnly) {
            ADD_TO_LARGE_INTEGER(
                &pSA->sa_Stats.OffloadedBytesSent,
                NET_SHORT(pIPH->iph_length));
        }

        //
        // Multiple ops here - iterate thru the headers. Inner first.
        //
        for (Index = 0; Index < pSA->sa_NumOps; Index++) {
            switch (pSA->sa_Operation[Index]) {
            case Auth:
                status = IPSecCreateAH( pIPHeader,
                                        pData,
                                        pSA,
                                        Index,
                                        pNewData,
                                        ppSCContext,
                                        pExtraBytes,
                                        ipsecHdrSpace,
                                        fSrcRoute,
                                        fCryptoOnly);

                if (!NT_SUCCESS(status)) {
                    IPSEC_DEBUG(PARSE, ("AH failed: pSA: %lx, status: %lx\n",
                                        pSA,
                                        status));
                    IPSecDerefSANextSA(pSA, pNextSA);
                    goto out;
                }

                //
                // Save the new MDL for future operation; also query the new header (if it changed)
                //
                if (*pNewData) {
                    pData = *pNewData;
                    IPSecQueryNdisBuf((PNDIS_BUFFER)pData, &pIPHeader, &Length);
                }

                break;

            case Encrypt:
                status = IPSecCreateHughes( pIPHeader,
                                            pData,
                                            pSA,
                                            Index,
                                            pNewData,
                                            ppSCContext,
                                            pExtraBytes,
                                            ipsecHdrSpace,
                                            Packet,
                                            fCryptoOnly);

                if (!NT_SUCCESS(status)) {
                    IPSEC_DEBUG(PARSE, ("HUGHES failed: pSA: %lx, status: %lx\n",
                                        pSA,
                                        status));
                    IPSecDerefSANextSA(pSA, pNextSA);
                    goto out;
                }

                //
                // Save the new MDL for future operation; also query the new header (if it changed)
                //
                if (*pNewData) {
                    pData = *pNewData;
                    IPSecQueryNdisBuf((PNDIS_BUFFER)pData, &pIPHeader, &Length);
                }

                break;

            case None:
                status = STATUS_SUCCESS;
                break;

            default:
                IPSEC_DEBUG(PARSE, ("No valid operation: %lx\n", pSA->sa_Operation));
                break;
            }
        }

        pSaveSA = pSA;
        pSA = pNextSA;
        if (!pSA) {
            IPSecDerefSA(pSaveSA);
            break;
        }

        pNextSA = NULL;
        IPSecDerefSA(pSaveSA);
    } while (TRUE);

    //
    // Remember if we are going to fragment.
    //
    if (ipsecHdrSpace < *pExtraBytes) {
        IPSEC_DEBUG(PARSE, ("ipsecHdrSpace: FRAG\n"));
        ((IPSEC_SEND_COMPLETE_CONTEXT *)*ppSCContext)->Flags |= SCF_FRAG;
    }

out:
    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(PARSE, ("IPSecSendPacket failed: %lx\n", status));
        eRetAction = eDROP;
    }
    
    if (pDropStatus) {
        pDropStatus->IPSecStatus=status;
    }
    IPSEC_DEBUG(PARSE, ("Exiting IPSecSendPacket; action %lx\n", eRetAction));

    return  eRetAction;
}


IPSEC_ACTION
IPSecRecvPacket(
    IN  PUCHAR          *pIPHeader,
    IN  PVOID           pData,
    IN  PVOID           IPContext,
    IN  PNDIS_PACKET    Packet,
    IN OUT PULONG       pExtraBytes,
    IN OUT PULONG       pIpsecFlags,
    OUT PIPSEC_DROP_STATUS pDropStatus,
    IN  UCHAR           DestType
    )
/*++

Routine Description:

    This is the IPSecRecvHandler.

Arguments:

    pIPHeader - points to start of IP header.

    pData - points to the data after the IP header, an IPRcvBuf pointer.

    IPContext - contains the destination interface.

    pExtraBytes - IPSEC header expansion value.

    IpsecFlags - flags for SrcRoute, Incoming, Forward and Lookback.

Return Value:

    eFORWARD
    eDROP

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;
    IPSEC_ACTION            eRetAction = eFORWARD;
    PSA_TABLE_ENTRY         pSA = NULL;
    PSA_TABLE_ENTRY         pSaveSA = NULL;
    PSA_TABLE_ENTRY         pNextSA = NULL;
    USHORT                  FilterFlags = 0;
    BOOLEAN                 fLifetime = FALSE;
    IPHeader UNALIGNED      *pIPH = (IPHeader UNALIGNED *)*pIPHeader;
    Interface               *DestIF = (Interface *)IPContext;
    PNDIS_PACKET            OrigPacket = NULL;
    PNDIS_PACKET_EXTENSION  PktExt = NULL;
    PNDIS_IPSEC_PACKET_INFO IPSecPktInfo = NULL;
    BOOLEAN                 fCryptoOnly = FALSE;
    BOOLEAN                 fFWPacket = FALSE;
    BOOLEAN                 fSrcRoute = FALSE;
    BOOLEAN                 fLoopback = FALSE;
    BOOLEAN                 fFastRcv = FALSE;
    tSPI                    SPI;
    KIRQL	                kIrql;
    LONG                    Index;

    IPSEC_DEBUG(PARSE, ("Entering IPSecRecvPacket\n"));

    if (*pIpsecFlags & IPSEC_FLAG_FORWARD) {
        fFWPacket = TRUE;
    }
    if (*pIpsecFlags & IPSEC_FLAG_SSRR) {
        fSrcRoute = TRUE;
    }
    if (*pIpsecFlags & IPSEC_FLAG_LOOPBACK) {
        fLoopback = TRUE;
    }
    if (*pIpsecFlags & IPSEC_FLAG_FASTRCV) {
        fFastRcv = TRUE;
    }

    *pExtraBytes = 0;

    if (Packet) {
        OrigPacket = (PNDIS_PACKET)NDIS_GET_ORIGINAL_PACKET(Packet);
        if (OrigPacket) {
            PktExt = NDIS_PACKET_EXTENSION_FROM_PACKET(OrigPacket);
        } else {
            PktExt = NDIS_PACKET_EXTENSION_FROM_PACKET(Packet);
        }
        IPSecPktInfo = PktExt->NdisPacketInfo[IpSecPacketInfo];
    }

#if DBG
    if (DebugOff) {
        if (pIPH->iph_protocol == PROTOCOL_AH ||
            pIPH->iph_protocol == PROTOCOL_ESP) {
                DbgPrint("Packet %lx, OrigPacket %lx, CRYPTO %d, CryptoStatus %d\n",
                    Packet,
                    OrigPacket,
                    IPSecPktInfo? IPSecPktInfo->Receive.CRYPTO_DONE: 0,
                    IPSecPktInfo? IPSecPktInfo->Receive.CryptoStatus: 0);
                if (DebugPkt) {
                    DbgBreakPoint();
                }
        }
    }
#endif

    //
    // If the packet is IPSec protected, set the appropriate flags for firewall/NAT.
    //

    if (pIPH->iph_protocol == PROTOCOL_AH ||
        pIPH->iph_protocol == PROTOCOL_ESP) {
        *pIpsecFlags |= IPSEC_FLAG_TRANSFORMED;
    }

    if (IPSecPktInfo  && pDropStatus) {
        if (IPSecPktInfo->Receive.CRYPTO_DONE) {
            pDropStatus->Flags |= IPSEC_DROP_STATUS_CRYPTO_DONE;
        }
        if (IPSecPktInfo->Receive.NEXT_CRYPTO_DONE) {
            pDropStatus->Flags |= IPSEC_DROP_STATUS_NEXT_CRYPTO_DONE;
        }
        if (IPSecPktInfo->Receive.SA_DELETE_REQ) {
            pDropStatus->Flags |= IPSEC_DROP_STATUS_SA_DELETE_REQ;
        }
        pDropStatus->OffloadStatus=IPSecPktInfo->Receive.CryptoStatus;
    }

    if (IPSecPktInfo &&
        IPSecPktInfo->Receive.CRYPTO_DONE &&
        IPSecPktInfo->Receive.CryptoStatus != CRYPTO_SUCCESS) {
        //
        // Error reported by offload card.  Discard the packet and apply
        // the necessary acountings.
        //
        IPSecBufferOffloadEvent(pIPH, IPSecPktInfo);

        status = STATUS_UNSUCCESSFUL;
        goto out;
    }

    //
    // Walk the packet to determine the SPI
    //
    status = IPSecParsePacket(  *pIPHeader,
                                pData,
                                &SPI);

    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(PARSE, ("IPSecParsePkt no IPSEC headers: %lx\n", status));

        if (fLoopback) {
            IPSEC_DEBUG(PARSE, ("loopback was on, not doing inbound policy check\n"));
            status = STATUS_SUCCESS;
            goto out;
        }

        status = IPSecClassifyPacket(   *pIPHeader,
                                        pData,
                                        &pSA,
                                        &pNextSA,
                                        &FilterFlags,
#if GPC
                                        0,
#endif
                                        FALSE,  // fOutbound
                                        fFWPacket,
                                        TRUE,  // do bypass check
                                        DestType);  
        

        if (status != STATUS_SUCCESS) {
            ASSERT(pSA == NULL);

            //
            // If we didnt find an SA, but found a filter, bad, drop.
            //
            if (status == STATUS_PENDING) {
                if (FilterFlags & FILTER_FLAGS_PASS_THRU) {
                    // Allow this clear text traffic in
                    status = STATUS_SUCCESS;
                } else {
                    IPSEC_DEBUG(PARSE, ("IPSecParsePkt cleartext when filter exists: %lx\n", status));
                    status = IPSEC_NEGOTIATION_PENDING;
                }
            } else {
                status = STATUS_SUCCESS;
            }

            goto out;
        } else {
            if (FilterFlags) {
                ASSERT(pSA == NULL);

                //
                // This is either a drop or pass thru filter.
                //
                if (FilterFlags & FILTER_FLAGS_DROP) {
                    IPSEC_DEBUG(PARSE, ("Drop filter\n"));
                    status = IPSEC_BLOCK;
                } else if (FilterFlags & FILTER_FLAGS_PASS_THRU) {
                    IPSEC_DEBUG(PARSE, ("Pass thru' filter\n"));
                    status = STATUS_SUCCESS;
                } else {
                    ASSERT(FALSE);
                }

                goto out;
            }

            ASSERT(pSA);

            //
            // Set the last used time.
            //
            NdisGetCurrentSystemTime(&pSA->sa_LastUsedTime);

            //
            // We found an SA; we are OK if the SA is set to None
            // or if it is a tunnel SA; we are here because
            // IPSecClassifyPacket finds and SA and returns SUCCESS.
            //
            if (pSA->sa_Operation[0] != None &&
                !(pSA->sa_Flags & FLAGS_SA_TUNNEL) &&
                !(pSA->sa_Flags & FLAGS_SA_PASSTHRU_FILTER)) {
                
                if (g_ipsec.DiagnosticMode & IPSEC_DIAGNOSTIC_INBOUND) {
                    IPSecBufferEvent(   pIPH->iph_src,
                                        EVENT_IPSEC_UNEXPECTED_CLEARTEXT,
                                        2,
                                        TRUE);
                }

#if DBG
                if (IPSecDebug & IPSEC_DEBUG_CLEARTEXT) {
                    PUCHAR          pTpt;
                    ULONG           tptLen;
                    UNALIGNED WORD  *pwPort;

                    IPSecQueryRcvBuf(pData, &pTpt, &tptLen);
                    pwPort = (UNALIGNED WORD *)(pTpt);
                    DbgPrint("Unexpected clear text: src %lx, dest %lx, protocol %lx, sport %lx, dport %lx\n", pIPH->iph_src, pIPH->iph_dest, pIPH->iph_protocol, pwPort[0], pwPort[1]);
                }
#endif

                IPSEC_DEBUG(PARSE, ("Real SA present\n"));
                status = IPSEC_INVALID_CLEARTEXT;
            }

            IPSecDerefSA(pSA);
        }
    } else {
        IPHeader UNALIGNED  *pIPH = (UNALIGNED IPHeader *)*pIPHeader;

        IPSEC_SPI_TO_ENTRY(SPI, &pSA, pIPH->iph_dest);

        //
        // Report Bad SPI event only if there is no matching SA.
        //
        if (!pSA) {
            IPSEC_INC_STATISTIC(dwNumBadSPIPackets);

            IPSecBufferEvent(   pIPH->iph_src,
                                EVENT_IPSEC_BAD_SPI_RECEIVED,
                                1,
                                TRUE);

            IPSEC_DEBUG(PARSE, ("Bad spi: %lx\n", SPI));

            status = IPSEC_BAD_SPI;
            goto out;
        }

        //
        // If larval SA exits, silently discard the packet.
        //
        if (pSA->sa_State != STATE_SA_ACTIVE) {
            IPSecDerefSA(pSA);
            status = STATUS_INVALID_PARAMETER;
            goto out;
        }

        //
        // Set the last used time.
        //
        NdisGetCurrentSystemTime(&pSA->sa_LastUsedTime);

        if (!(pSA->sa_Flags & FLAGS_SA_DISABLE_LIFETIME_CHECK)) {

            //
            // Check if we might expire soon - start rekey operation now.
            //
            IPSEC_CHECK_PADDED_LIFETIME(pSA, fLifetime, 0);
            
            if (fLifetime == FALSE) {
                IPSecRekeyInboundSA(pSA);
            }
            
            //
            // Check the real lifetime - if we have expired, ensure that the
            // rekey was submitted and then cancel the current SAs.
            //
            IPSEC_CHECK_LIFETIME(pSA, fLifetime, 0);
            
            if (fLifetime == FALSE) {
                IPSecPuntInboundSA(pSA);
                IPSecDerefSA(pSA);
                status = STATUS_UNSUCCESSFUL;
                goto out;
            }
        }

        if (pSA->sa_Flags & FLAGS_SA_TUNNEL) {
            ADD_TO_LARGE_INTEGER(
                &g_ipsec.Statistics.uBytesReceivedInTunnels,
                NET_SHORT(pIPH->iph_length));
        } else {
            ADD_TO_LARGE_INTEGER(
                &g_ipsec.Statistics.uTransportBytesReceived,
                NET_SHORT(pIPH->iph_length));
        }

        ADD_TO_LARGE_INTEGER(
            &pSA->sa_Stats.TotalBytesReceived,
            NET_SHORT(pIPH->iph_length));

        //
        // If this was supposed to be handled by hardware, then make sure he
        // either punted it or this was cryptoonly.
        //
        if (IPSecPktInfo != NULL) {
            if (IPSecPktInfo->Receive.CRYPTO_DONE) {
                //
                // Offload has been applied to this packet so
                // record it.  We are here because CryptoStatus
                // equals CRYPTO_SUCCESS.
                //
                ASSERT(IPSecPktInfo->Receive.CryptoStatus == CRYPTO_SUCCESS);
                fCryptoOnly = TRUE;

                ADD_TO_LARGE_INTEGER(
                    &pSA->sa_Stats.OffloadedBytesReceived,
                    NET_SHORT(pIPH->iph_length));

                ADD_TO_LARGE_INTEGER(
                    &g_ipsec.Statistics.uOffloadedBytesReceived,
                    NET_SHORT(pIPH->iph_length));
            }

            if (IPSecPktInfo->Receive.SA_DELETE_REQ) {
                //
                // No more offload on this SA and its corresponding
                // outbound SA.
                //
                AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

                if ((pSA->sa_Flags & FLAGS_SA_HW_PLUMBED) &&
                    (pSA->sa_IPIF == DestIF)) {
                    IPSecDelHWSAAtDpc(pSA);
                }

                if (pSA->sa_AssociatedSA &&
                    (pSA->sa_AssociatedSA->sa_Flags & FLAGS_SA_HW_PLUMBED) &&
                    (pSA->sa_AssociatedSA->sa_IPIF == DestIF)) {
                    IPSecDelHWSAAtDpc(pSA->sa_AssociatedSA);
                }

                ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
            }
        }

        //
        // If SA is not offloaded, try to offload it now.
        //
        if (!fCryptoOnly) {
            IPSecRecvOffload(pIPH, DestIF, pSA);
        }

        //
        // With multiple SAs coming in, we need to iterate through the operations,
        // last first.
        //
        for (Index = pSA->sa_NumOps-1; (LONG)Index >= 0; Index--) {

            //
            // Got to keep resetting pIPH since pIPHeader can change in the
            // IPSecVerifyXXX calls
            //
            pIPH = (UNALIGNED IPHeader *)*pIPHeader;

            switch (pSA->sa_Operation[Index]) {
            case Auth:
                //
                // Verify AH
                //
                if (pIPH->iph_protocol != PROTOCOL_AH) {
                    IPSecBufferEvent(   pIPH->iph_src,
                                        EVENT_IPSEC_BAD_PROTOCOL_RECEIVED,
                                        1,
                                        TRUE);
                    status = STATUS_UNSUCCESSFUL;
                    break;
                }

                status = IPSecVerifyAH( pIPHeader,
                                        pData,
                                        pSA,
                                        Index,
                                        pExtraBytes,
                                        fSrcRoute,
                                        fCryptoOnly,
                                        fFastRcv);

                if (!NT_SUCCESS(status)) {
                    IPSEC_DEBUG(PARSE, ("AH failed: pSA: %lx, status: %lx\n",
                                        pSA,
                                        status));
                    IPSecDerefSA(pSA);
                    goto out;
                }

                break;

            case Encrypt:
                //
                // Hughes ..
                //
                if (pIPH->iph_protocol != PROTOCOL_ESP) {
                    IPSecBufferEvent(   pIPH->iph_src,
                                        EVENT_IPSEC_BAD_PROTOCOL_RECEIVED,
                                        2,
                                        TRUE);
                    status = STATUS_UNSUCCESSFUL;
                    break;
                }

                status = IPSecVerifyHughes( pIPHeader,
                                            pData,
                                            pSA,
                                            Index,
                                            pExtraBytes,
                                            fCryptoOnly,
                                            fFastRcv);

                if (!NT_SUCCESS(status)) {
                    IPSEC_DEBUG(PARSE, ("Hughes failed: pSA: %lx, status: %lx\n",
                                        pSA,
                                        status));
                    IPSecDerefSA(pSA);
                    goto out;
                }

                break;

            case None:
                //
                // None is useful for down-level clients - if the peer is incapable
                // of IPSEC, we might have a system policy to send in clear. in that
                // case, the Operation will be None.
                //
                status = STATUS_SUCCESS;
                break;

            default:
                IPSEC_DEBUG(PARSE, ("Invalid op in SA: %lx, Index: %d\n", pSA, Index));
                ASSERT(FALSE);
                break;
            }
        }

        //
        // If this was a tunnel SA that succeeded in decrypt/auth,
        // drop this packet and re-inject a copy.
        //
        if ((status == STATUS_SUCCESS) &&
            (pSA->sa_Flags & FLAGS_SA_TUNNEL)) {
            IPSecReinjectPacket(pData, fCryptoOnly? PktExt: NULL);
            status = STATUS_INVALID_PARAMETER;
            if (pDropStatus) {
                pDropStatus->Flags |= IPSEC_DROP_STATUS_DONT_LOG;
            }
        }

        IPSecDerefSA(pSA);
    }

out:
    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(PARSE, ("IPSecRecvPacket failed: %lx\n", status));
        eRetAction = eDROP;
    }
    if (pDropStatus) {
        pDropStatus->IPSecStatus=status;
    }

    IPSEC_DEBUG(PARSE, ("Exiting IPSecRecvPacket; action %lx\n", eRetAction));

    return  eRetAction;
}


VOID
IPSecCalcHeaderOverheadFromSA(
    IN  PSA_TABLE_ENTRY pSA,
    OUT PULONG          pOverhead
    )
/*++

Routine Description:

    Called from IP to query the IPSEC header overhead.

Arguments:

    pIPHeader - points to start of IP header.

    pOverhead - number of bytes in IPSEC header.

Return Value:

    None

--*/
{
    LONG    Index;
    ULONG   AHSize = sizeof(AH) + pSA->sa_TruncatedLen;
    ULONG   ESPSize = sizeof(ESP) + pSA->sa_ivlen + pSA->sa_ReplayLen + MAX_PAD_LEN + pSA->sa_TruncatedLen;

    //
    // Take the actual SA to get the exact value.
    //
    *pOverhead = 0;

    for (Index = 0; Index < pSA->sa_NumOps; Index++) {
        switch (pSA->sa_Operation[Index]) {
            case Encrypt:
                *pOverhead += ESPSize;
                IPSEC_DEBUG(PMTU, ("PROTOCOL_ESP: overhead: %lx\n", *pOverhead));
                break;

            case Auth:
                *pOverhead += AHSize;
                IPSEC_DEBUG(PMTU, ("PROTOCOL_AH: overhead: %lx\n", *pOverhead));
                break;

            default:
                IPSEC_DEBUG(PMTU, ("No IPSEC headers\n"));
                break;
        }
    }

    if (pSA->sa_Flags & FLAGS_SA_TUNNEL) {
        *pOverhead += sizeof(IPHeader);
        IPSEC_DEBUG(PMTU, ("TUNNEL: overhead: %lx\n", *pOverhead));
    }
}


NTSTATUS
IPSecParsePacket(
    IN  PUCHAR      pIPHeader,
    IN  PVOID       *pData,
    OUT tSPI        *pSPI
    )
/*++

Routine Description:

    Walk the packet to determine the SPI, this also returns the
    next header that might be also an IPSEC component.

Arguments:

    pIPHeader - points to start of IP header.

    pData - points to the data after the IP header.

    pSPI - to return the SPI value.

Return Value:

--*/
{
	IPHeader UNALIGNED *pIPH = (IPHeader UNALIGNED *)pIPHeader;
    AH      UNALIGNED     *pAH;
    ESP     UNALIGNED     *pEsp;
    NTSTATUS    status = STATUS_NOT_FOUND;
    PUCHAR  pPyld;
    ULONG   Len;

    IPSEC_DEBUG(PARSE, ("Entering IPSecParsePacket\n"));

    IPSecQueryRcvBuf(pData, &pPyld, &Len);

    if (pIPH->iph_protocol == PROTOCOL_AH) {
        pAH = (UNALIGNED AH *)pPyld;
        if (Len >= sizeof(AH)) {
            *pSPI = NET_TO_HOST_LONG(pAH->ah_spi);
            status = STATUS_SUCCESS;
        }
    } else if (pIPH->iph_protocol == PROTOCOL_ESP) {
        pEsp = (UNALIGNED ESP *)pPyld;
        if (Len >= sizeof(ESP)) {
            *pSPI = NET_TO_HOST_LONG(pEsp->esp_spi);
            status = STATUS_SUCCESS;
        }
    }

    IPSEC_DEBUG(PARSE, ("Exiting IPSecParsePacket\n"));

    return status;
}


PSA_TABLE_ENTRY
IPSecLookupSAInLarval(
    IN  ULARGE_INTEGER  uliSrcDstAddr,
    IN  ULARGE_INTEGER  uliProtoSrcDstPort
    )
/*++

Routine Description:

    Search for SA (in larval list) matching the input params.

Arguments:

Return Value:

    Pointer to SA matched else NULL

--*/
{
    PLIST_ENTRY     pEntry;
    KIRQL       	kIrql;
    ULARGE_INTEGER  uliAddr;
    ULARGE_INTEGER  uliPort;
    PSA_TABLE_ENTRY pSA = NULL;

    IPSEC_BUILD_SRC_DEST_ADDR(uliAddr, DEST_ADDR, SRC_ADDR);

    ACQUIRE_LOCK(&g_ipsec.LarvalListLock, &kIrql);

    for (   pEntry = g_ipsec.LarvalSAList.Flink;
            pEntry != &g_ipsec.LarvalSAList;
            pEntry = pEntry->Flink) {

        pSA = CONTAINING_RECORD(pEntry,
                                SA_TABLE_ENTRY,
                                sa_LarvalLinkage);

        //
        // responder inbound has no filter ptr
        //
        if (pSA->sa_Filter) {
            uliPort.QuadPart = uliProtoSrcDstPort.QuadPart & pSA->sa_Filter->uliProtoSrcDstMask.QuadPart;

            if ((uliAddr.QuadPart == pSA->sa_uliSrcDstAddr.QuadPart) &&
                (uliPort.QuadPart == pSA->sa_Filter->uliProtoSrcDstPort.QuadPart)) {
                IPSEC_DEBUG(HASH, ("Matched entry: %lx\n", pSA));

                RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);
                return  pSA;
            }
        } else {
            if (uliAddr.QuadPart == pSA->sa_uliSrcDstAddr.QuadPart) {
                IPSEC_DEBUG(HASH, ("Matched entry: %lx\n", pSA));

                RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);
                return  pSA;
            }
        }
    }

    RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);

    return NULL;
}


NTSTATUS
IPSecClassifyPacket(
    IN  PUCHAR          pHeader,
    IN  PVOID           pData,
    OUT PSA_TABLE_ENTRY *ppSA,
    OUT PSA_TABLE_ENTRY *ppNextSA,
    OUT USHORT          *pFilterFlags,
#if GPC
    IN  CLASSIFICATION_HANDLE   GpcHandle,
#endif
    IN  BOOLEAN         fOutbound,
    IN  BOOLEAN         fFWPacket,
    IN  BOOLEAN         fDoBypassCheck,
    IN  UCHAR           DestType
    )
/*++

Routine Description:

    Classifies the outgoing packet be matching the Src/Dest Address/Ports
    with the filter database to arrive at an IPSEC_CONTEXT which is a set
    of AH/ESP indices into the SA Table.

    Adapted in most part from the Filter Driver.

Arguments:

    pIPHeader - points to start of IP header.

    pData - points to the data after the IP header.

    ppSA - returns the SA if found.

    pFilterFlags - flags of the filter if found returned here.

    fOutbound  - direction flag used in lookups.

    fDoBypassCheck - if TRUE, we bypass port 500 traffic, else we block it.

Return Value:

    Pointer to IPSEC_CONTEXT if packet matched else NULL

--*/
{
    REGISTER UNALIGNED ULARGE_INTEGER   *puliSrcDstAddr;
    REGISTER ULARGE_INTEGER             uliProtoSrcDstPort;
    UNALIGNED WORD                      *pwPort;
    PUCHAR                              pTpt;
    ULONG                               tptLen;
    REGISTER ULARGE_INTEGER             uliAddr;
    REGISTER ULARGE_INTEGER             uliPort;
    KIRQL                               kIrql;
    REGISTER ULONG                      dwIndex;
    REGISTER PFILTER_CACHE              pCache;
    IPHeader UNALIGNED                  *pIPHeader = (IPHeader UNALIGNED *)pHeader;
    PSA_TABLE_ENTRY                     pSA = NULL;
    PSA_TABLE_ENTRY                     pNextSA = NULL;
    PSA_TABLE_ENTRY                     pTunnelSA = NULL;
    PFILTER                             pFilter = NULL;
    NTSTATUS                            status;
    BOOLEAN                             fBypass;
    PNDIS_BUFFER                        pTempBuf;
    WORD                                wTpt[2];

    *ppSA = NULL;
    *ppNextSA = NULL;
    *pFilterFlags = 0;
    wTpt[0] = wTpt[1] = 0;


    //
    // First buffer in pData chain points to start of IP header
    //
    if (fOutbound) {
        if (((pIPHeader->iph_verlen & (UCHAR)~IP_VER_FLAG) << 2) > sizeof(IPHeader)) {
            //
            // Options -> third MDL has Tpt header
            //
            if (!(pTempBuf = IPSEC_NEXT_BUFFER((PNDIS_BUFFER)pData))) {
                ASSERT(FALSE);
                *pFilterFlags |= FILTER_FLAGS_DROP;
                return STATUS_SUCCESS;
            }

            if (!(pTempBuf = IPSEC_NEXT_BUFFER(pTempBuf))) {
                *pFilterFlags |= FILTER_FLAGS_DROP;
                pwPort = (UNALIGNED WORD *) (wTpt);
            }
            else {
                IPSecQueryNdisBuf(pTempBuf, &pTpt, &tptLen);
                pwPort = (UNALIGNED WORD *)(pTpt);
            }

        } else {
            //
            // no options -> second MDL has Tpt header
            //
            if (!(pTempBuf = IPSEC_NEXT_BUFFER((PNDIS_BUFFER)pData))) {
                *pFilterFlags |= FILTER_FLAGS_DROP;
                pwPort = (UNALIGNED WORD *) (wTpt);
            }
            else {
                IPSecQueryNdisBuf(pTempBuf, &pTpt, &tptLen);
                pwPort = (UNALIGNED WORD *)(pTpt);
            }

        }
    } else {
        //
        // inbound side;  tpt starts at pData
        //
        IPSecQueryRcvBuf(pData, &pTpt, &tptLen);
        if (pIPHeader->iph_protocol == PROTOCOL_TCP ||
            pIPHeader->iph_protocol == PROTOCOL_UDP) {
            if (tptLen < sizeof(WORD)*2) {
                pwPort = (UNALIGNED WORD *) (wTpt);
            }
            else {
                pwPort = (UNALIGNED WORD *)(pTpt);
            }
        }
        else {
            pwPort = (UNALIGNED WORD *) (wTpt);
        }
    }

    puliSrcDstAddr = (UNALIGNED ULARGE_INTEGER*)(&(pIPHeader->iph_src));

    IPSEC_DEBUG(PARSE, ("Ports: %d.%d\n", pwPort[0], pwPort[1]));

    IPSEC_BUILD_PROTO_PORT_LI(  uliProtoSrcDstPort,
                                pIPHeader->iph_protocol,
                                pwPort[0],
                                pwPort[1]);

#if DBG
    if (IPSecDebug & (IPSEC_DEBUG_PATTERN)) {
        DbgPrint("Addr Large Int: High= %0#8x Low= %0#8x\n",
                 puliSrcDstAddr->HighPart,
                 puliSrcDstAddr->LowPart);

        DbgPrint("Packet value is Src: %0#8x Dst: %0#8x\n",
                 pIPHeader->iph_src,
                 pIPHeader->iph_dest);

        DbgPrint("Proto/Port:High= %0#8x Low= %0#8x\n",
                 uliProtoSrcDstPort.HighPart,
                 uliProtoSrcDstPort.LowPart);

        DbgPrint("Iph is %x\n",pIPHeader);
        DbgPrint("Addr of src is %x\n",&(pIPHeader->iph_src));
        DbgPrint("Ptr to LI is %x\n",puliSrcDstAddr);
    }
#endif

    //
    // Determine if this is a packet that needs bypass checking
    //
    if (fDoBypassCheck && IPSEC_BYPASS_TRAFFIC() && !IPSEC_FORWARD_PATH()) {
        fBypass = TRUE;
    } else {
        fBypass = FALSE;
    }

    //
    // Sum up the fields and get the cache index. We make sure the sum
    // is assymetric, i.e. a packet from A->B goes to different bucket
    // than one from B->A
    //
    dwIndex = CalcCacheIndex(   pIPHeader->iph_src,
                                pIPHeader->iph_dest,
                                pIPHeader->iph_protocol,
                                pwPort[0],
                                pwPort[1],
                                fOutbound);

    IPSEC_DEBUG(PATTERN, ("Cache Index is %d\n", dwIndex));

    AcquireReadLock(&g_ipsec.SADBLock, &kIrql);

    pCache = g_ipsec.ppCache[dwIndex];

    //
    // Try for a quick cache probe
    //
    if (!(*pFilterFlags & FILTER_FLAGS_DROP) && IS_VALID_CACHE_ENTRY(pCache) &&
        CacheMatch(*puliSrcDstAddr, uliProtoSrcDstPort, pCache)) {
        if (!pCache->FilterEntry) {
            pSA = pCache->pSAEntry;
            pNextSA = pCache->pNextSAEntry;

            ASSERT(pSA->sa_State == STATE_SA_ACTIVE);

            if (fOutbound == (BOOLEAN)((pSA->sa_Flags & FLAGS_SA_OUTBOUND) != 0)) {
                if (fBypass) {
                    if (pNextSA) {
                        IPSecRefSA(pNextSA);
                        *ppSA = pNextSA;
                        status = STATUS_SUCCESS;
                    } else {
                        status = STATUS_UNSUCCESSFUL;
                    }
                } else {
                    if (pNextSA) {
                        IPSecRefSA(pNextSA);
                        *ppNextSA = pNextSA;
                    }
                    IPSecRefSA(pSA);
                    *ppSA = pSA;
                    status = STATUS_SUCCESS;
                }

#if DBG
                ADD_TO_LARGE_INTEGER(&pCache->CacheHitCount, 1);
                ADD_TO_LARGE_INTEGER(&g_ipsec.CacheHitCount, 1);
#endif
                ReleaseReadLock(&g_ipsec.SADBLock, kIrql);
                return status;
            }
        } else if (!fBypass) {
            pFilter = pCache->pFilter;
            ASSERT(IS_EXEMPT_FILTER(pFilter));
            *pFilterFlags = pFilter->Flags;
#if DBG
            ADD_TO_LARGE_INTEGER(&pCache->CacheHitCount, 1);
            ADD_TO_LARGE_INTEGER(&g_ipsec.CacheHitCount, 1);
#endif
            ReleaseReadLock(&g_ipsec.SADBLock, kIrql);
            return STATUS_SUCCESS;
        }
    }

    //
    // check the non-manual filters first.
    //
#if GPC
    if (fBypass || fFWPacket || !IS_GPC_ACTIVE()) {
        status = IPSecLookupSAByAddr(   *puliSrcDstAddr,
                                        uliProtoSrcDstPort,
                                        &pFilter,
                                        &pSA,
                                        &pNextSA,
                                        &pTunnelSA,
                                        fOutbound,
                                        fFWPacket,
                                        fBypass);
    } else {
        status = IPSecLookupGpcSA(  *puliSrcDstAddr,
                                    uliProtoSrcDstPort,
                                    GpcHandle,
                                    &pFilter,
                                    &pSA,
                                    &pNextSA,
                                    &pTunnelSA,
                                    fOutbound);
    }
#else
    status = IPSecLookupSAByAddr(   *puliSrcDstAddr,
                                    uliProtoSrcDstPort,
                                    &pFilter,
                                    &pSA,
                                    &pNextSA,
                                    &pTunnelSA,
                                    fOutbound,
                                    fFWPacket,
                                    fBypass);
#endif

    //
    // Special Processing for zero length payload packets.
    //

    if (*pFilterFlags & FILTER_FLAGS_DROP) {
        if (pFilter) {
            if (IS_EXEMPT_FILTER(pFilter)) {
                *pFilterFlags = pFilter->Flags;
            }
        }
        else {
            *pFilterFlags = FILTER_FLAGS_PASS_THRU;
        }
        ReleaseReadLock(&g_ipsec.SADBLock, kIrql);
        return STATUS_SUCCESS;
    }

    if (status == STATUS_SUCCESS) {
        if (fBypass) {
            if (pNextSA) {
                if (pNextSA->sa_State == STATE_SA_ACTIVE) {
                    IPSecRefSA(pNextSA);
                    *ppSA = pNextSA;
                    status = STATUS_SUCCESS;
                } else {
                    *pFilterFlags = pFilter->Flags;
                    status = STATUS_PENDING;
                }
            } else {
                status = STATUS_UNSUCCESSFUL;
            }

            ReleaseReadLock(&g_ipsec.SADBLock, kIrql);
            return status;
        }

        if (pSA->sa_State != STATE_SA_ACTIVE ||
            (pNextSA && pNextSA->sa_State != STATE_SA_ACTIVE)) {
            IPSEC_DEBUG(PATTERN, ("State is not active: %lx, %lx\n", pSA, pSA->sa_State));
            *pFilterFlags = pFilter->Flags;
            ReleaseReadLock(&g_ipsec.SADBLock, kIrql);
            return STATUS_PENDING;
        } else {
            if (pNextSA) {
                IPSecRefSA(pNextSA);
                *ppNextSA = pNextSA;
            }
            IPSecRefSA(pSA);
            *ppSA = pSA;
            ReleaseReadLockFromDpc(&g_ipsec.SADBLock);

            AcquireWriteLockAtDpc(&g_ipsec.SADBLock);
            if (pSA->sa_State == STATE_SA_ACTIVE &&
                (!pNextSA ||
                 pNextSA->sa_State == STATE_SA_ACTIVE)) {
                CacheUpdate(*puliSrcDstAddr,
                            uliProtoSrcDstPort,
                            pSA,
                            pNextSA,
                            dwIndex,
                            FALSE);
            }
            ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

            return STATUS_SUCCESS;
        }
    } else if (status == STATUS_PENDING) {
        if (IS_EXEMPT_FILTER(pFilter)) {
            IPSEC_DEBUG(PARSE, ("Drop or Pass thru flags: %lx\n", pFilter));
            *pFilterFlags = pFilter->Flags;
            IPSecRefFilter(pFilter);
            ReleaseReadLockFromDpc(&g_ipsec.SADBLock);

            AcquireWriteLockAtDpc(&g_ipsec.SADBLock);
            if (pFilter->LinkedFilter) {
                CacheUpdate(*puliSrcDstAddr,
                            uliProtoSrcDstPort,
                            pFilter,
                            NULL,
                            dwIndex,
                            TRUE);
            }
            ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

            IPSecDerefFilter(pFilter);
            return STATUS_SUCCESS;
        }

        //
        // This is ensure that in a tunnel+tpt mode, the oakley packet for
        // the tpt SA goes thru the tunnel.
        //
        if (pTunnelSA) {
            if (fBypass) {
                if (pTunnelSA->sa_State != STATE_SA_ACTIVE) {
                    IPSEC_DEBUG(PATTERN, ("State is not active: %lx, %lx\n", pTunnelSA, pTunnelSA->sa_State));
                    *pFilterFlags = pFilter->Flags;

                    ReleaseReadLock(&g_ipsec.SADBLock, kIrql);
                    return STATUS_PENDING;
                } else {
                    IPSecRefSA(pTunnelSA);
                    *ppSA = pTunnelSA;

                    //
                    // we dont update the cache since this SA, once it comes up,
                    // it is the one that is looked up first.
                    //
                    ReleaseReadLock(&g_ipsec.SADBLock, kIrql);
                    return STATUS_SUCCESS;
                }
            }
        }

        if (fBypass) {
            ReleaseReadLock(&g_ipsec.SADBLock, kIrql);
            return STATUS_UNSUCCESSFUL;
        }

        //
        // We only negotiate outbound SAs.
        //
        if (!fOutbound) {
            *pFilterFlags = pFilter->Flags;
            ReleaseReadLock(&g_ipsec.SADBLock, kIrql);
            return status;
        }

        //
        // need to negotiate the keys - filter exists.
        //
        IPSEC_DEBUG(PATTERN, ("need to negotiate the keys - filter exists: %lx\n", pFilter));

        ASSERT(pSA == NULL);

        IPSecRefFilter(pFilter);

        ReleaseReadLock(&g_ipsec.SADBLock, kIrql);

        AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

        //
        // If filter is deleted here we want to discard this packet
        //
        if (!pFilter->LinkedFilter) {
            *pFilterFlags = pFilter->Flags;
            IPSecDerefFilter(pFilter);
            ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
            return  STATUS_PENDING;
        }

        status = IPSecNegotiateSA(  pFilter,
                                    *puliSrcDstAddr,
                                    uliProtoSrcDstPort,
                                    MAX_LONG,
                                    &pSA,
                                    DestType);

        IPSecDerefFilter(pFilter);

        //
        // Duplicate is returned if a neg is already on. Tell the caller to
        // hold on to his horses.
        //
        if ((status != STATUS_DUPLICATE_OBJECTID) &&
            !NT_SUCCESS(status)) {
            IPSEC_DEBUG(PATTERN, ("NegotiateSA failed: %lx\n", status));
            *pFilterFlags = pFilter->Flags;

            ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
            return STATUS_PENDING;
        }

        //
        // Pend this packet
        //
        if (pSA) {
            IPSecQueuePacket(pSA, pData);
        }
        IPSEC_DEBUG(PATTERN, ("Packet queued: %lx, %lx\n", pSA, pData));
        *pFilterFlags = pFilter->Flags;
        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
        return STATUS_PENDING;
    } else {
        ReleaseReadLock(&g_ipsec.SADBLock, kIrql);
        return STATUS_UNSUCCESSFUL;
    }
}


VOID
IPSecSendComplete(
    IN  PNDIS_PACKET    Packet,
    IN  PVOID           pData,
    IN  PIPSEC_SEND_COMPLETE_CONTEXT  pContext,
    IN  IP_STATUS       Status,                   
    OUT PVOID           *ppNewData
    )
/*++

Routine Description:

    Called by the stack on a SendComplete - frees up IPSEC's Mdls

Arguments:

    pData - points to the data after the IP header. On the send side, this is an MDL chain
            On the recv side this is an IPRcvBuf pointer.

    pContext - send complete context
    pNewData - if packet modified, this points to the new data.

Return Value:

    STATUS_SUCCESS  =>   Forward - Filter driver passes packet on to IP
    STATUS_PENDING  =>   Drop, IPSEC will re-inject

    Others:
        STATUS_INSUFFICIENT_RESOURCES => Drop
        STATUS_UNSUCCESSFUL (error in algo./bad packet received) => Drop

--*/
{
    NTSTATUS        status;
    PNDIS_BUFFER    pMdl;
    PNDIS_BUFFER    pNextMdl;
    BOOLEAN         fFreeContext = TRUE;

    *ppNewData = pData;

    if (!pContext) {
        return;
    }

#if DBG
    IPSEC_DEBUG(MDL, ("Entering IPSecSendComplete\n"));
    IPSEC_PRINT_CONTEXT(pContext);
    IPSEC_PRINT_MDL(*ppNewData);
#endif

    if (pContext->Flags & SCF_PKTINFO) {
        IPSecFreePktInfo(pContext->PktInfo);

        if (pContext->pSA) {
            KIRQL           kIrql;
            PSA_TABLE_ENTRY pSA;

            AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

            pSA = (PSA_TABLE_ENTRY)pContext->pSA;
            IPSEC_DECREMENT(pSA->sa_NumSends);
            if (pSA->sa_Flags & FLAGS_SA_HW_DELETE_SA) {
                IPSecDelHWSAAtDpc(pSA);
            }
            IPSecDerefSA(pSA);

            pSA = (PSA_TABLE_ENTRY)pContext->pNextSA;
            if (pSA) {
                IPSEC_DECREMENT(pSA->sa_NumSends);
                if (pSA->sa_Flags & FLAGS_SA_HW_DELETE_SA) {
                    IPSecDelHWSAAtDpc(pSA);
                }
                IPSecDerefSA(pSA);
            }

            ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
        }
    }

    if (pContext->Flags & SCF_PKTEXT) {
        IPSecFreePktExt(pContext->PktExt);
    }

    if (pContext->Flags & SCF_AH_2) {

        IPSEC_DEBUG(SEND, ("SendComplete: Outer AH: pContext: %lx\n", pContext));
        pMdl = pContext->AHMdl2;

        ASSERT(pMdl);

        IPSecFreeBuffer(&status, pMdl);

        //
        // return the older chain
        //
        if (pContext->Flags & SCF_FLUSH) {
            NDIS_BUFFER_LINKAGE(pContext->PrevAHMdl2) = pContext->OriAHMdl2;
        } else if (!(pContext->Flags & SCF_FRAG)) {
            NDIS_BUFFER_LINKAGE(pContext->PrevAHMdl2) = pContext->OriAHMdl2;
            // *ppNewData = (PVOID)(pContext->PrevMdl);
        }
        pContext->OriAHMdl2 = NULL;
    }

    if (pContext->Flags & SCF_AH_TU) {
        IPSEC_DEBUG(SEND, ("SendComplete: AH_TU: pContext: %lx\n", pContext));

        //
        // Free the new IP header and the AH buffer and return the old chain
        //
        pMdl = pContext->AHTuMdl;

        ASSERT(pMdl);

        pNextMdl = NDIS_BUFFER_LINKAGE(pMdl);
        IPSecFreeBuffer(&status, pMdl);
        IPSecFreeBuffer(&status, pNextMdl);

        //
        // return the older chain
        //
        if (pContext->Flags & SCF_FLUSH) {
            NDIS_BUFFER_LINKAGE(pContext->PrevTuMdl) = pContext->OriTuMdl;
        } else if (!(pContext->Flags & SCF_FRAG)) {
            NDIS_BUFFER_LINKAGE(pContext->PrevTuMdl) = pContext->OriTuMdl;
        }

        if (pContext->OptMdl) {
            IPSecFreeBuffer(&status, pContext->OptMdl);
        }
    }

    if (pContext->Flags & SCF_HU_TU) {
        IPSEC_DEBUG(SEND, ("SendComplete: HU_TU: pContext: %lx\n", pContext));
        //
        // Free the encrypt chain and return the old chain
        //
        pMdl = pContext->HUTuMdl;
        ASSERT(pMdl);

        //
        // In none case, free the esp header and the IP header.
        //
        if (pContext->Flags & SCF_NOE_TU) {
            IPSecFreeBuffer(&status, pMdl);
            ASSERT(pContext->PadTuMdl);
        } else {
            ASSERT(NDIS_BUFFER_LINKAGE(pMdl));
            while (pMdl) {
                pNextMdl = NDIS_BUFFER_LINKAGE(pMdl);
                IPSecFreeBuffer(&status, pMdl);
                pMdl = pNextMdl;
            }
        }

        //
        // Free the Pad mdl
        //
        if (pContext->PadTuMdl) {
            IPSecFreeBuffer(&status, pContext->PadTuMdl);
        }

        if (pContext->HUHdrMdl) {
            IPSecFreeBuffer(&status, pContext->HUHdrMdl);
        }

        if (pContext->OptMdl) {
            IPSecFreeBuffer(&status, pContext->OptMdl);
        }

        NDIS_BUFFER_LINKAGE(pContext->BeforePadTuMdl) = NULL;

        //
        // return the older chain
        //
        if (pContext->Flags & SCF_FLUSH) {
            NDIS_BUFFER_LINKAGE(pContext->PrevTuMdl) = pContext->OriTuMdl;
        } else if (!(pContext->Flags & SCF_FRAG)) {
            NDIS_BUFFER_LINKAGE(pContext->PrevTuMdl) = pContext->OriTuMdl;
        }
    }

    if (pContext->Flags & SCF_AH) {

        IPSEC_DEBUG(SEND, ("SendComplete: AH: pContext: %lx\n", pContext));
        pMdl = pContext->AHMdl;

        ASSERT(pMdl);

        IPSecFreeBuffer(&status, pMdl);

        //
        // return the older chain
        //
        if (pContext->Flags & SCF_FLUSH) {
            NDIS_BUFFER_LINKAGE(pContext->PrevMdl) = pContext->OriAHMdl;
        } else if (!(pContext->Flags & SCF_FRAG)) {
            NDIS_BUFFER_LINKAGE(pContext->PrevMdl) = pContext->OriAHMdl;
            // *ppNewData = (PVOID)(pContext->PrevMdl);
        }
        pContext->OriAHMdl = NULL;
    }

    if (pContext->Flags & SCF_HU_TPT) {
        IPSEC_DEBUG(SEND, ("SendComplete: HU_TPT: pContext: %lx\n", pContext));

        //
        // Hook the older chain into the first buffer
        //
        if (pContext->Flags & SCF_FLUSH) {
            NDIS_BUFFER_LINKAGE(pContext->PrevMdl) = pContext->OriHUMdl;
        } else if (!(pContext->Flags & SCF_FRAG)) {
            NDIS_BUFFER_LINKAGE(pContext->PrevMdl) = pContext->OriHUMdl;
        }

        //
        // Free the encryption buffer chain
        //
        pMdl = pContext->HUMdl;
        ASSERT(pMdl);

        //
        // In none case, free the esp header.
        //
        if (pContext->Flags & SCF_NOE_TPT) {
            IPSecFreeBuffer(&status, pMdl);
            ASSERT(pContext->PadMdl);
        } else {
            ASSERT(NDIS_BUFFER_LINKAGE(pMdl));
            while (pMdl) {
                pNextMdl = NDIS_BUFFER_LINKAGE(pMdl);
                IPSecFreeBuffer(&status, pMdl);
                pMdl = pNextMdl;
            }
        }

        //
        // Free the Pad mdl and zero the reference to the pad mdl in the
        // previous (payload) mdl.
        //
        if (pContext->PadMdl) {
            IPSecFreeBuffer(&status, pContext->PadMdl);
        }

        NDIS_BUFFER_LINKAGE(pContext->BeforePadMdl) = NULL;
    }

    //
    // these are freed in IPSecProtocolSendComplete now.
    //
    if (Packet && (pContext->Flags & SCF_FLUSH)) {

        IPSEC_DEBUG(SEND, ("SendComplete: FLUSH: pContext: %lx\n", pContext));
        //
        // Free the encrypt chain and return the old chain
        //
        pMdl = pContext->FlushMdl;

        ASSERT(pMdl);

        //
        // We will be called at ProtocolSendComplete, where we free this chain.
        //
        fFreeContext = FALSE;

        //
        // If this was just a reinjected packet and never IPSEC'ed, then we know
        // that all the buffers are in line - call the ProtocolSendComplete here
        // and NULL the returned buffer.
        //
        // The best way to do this is to do the same trick we apply on fragmented
        // packets (see IPTransmit) viz. attaching another header and 0'ing out
        // the IPSEC header. There is obviously a perf hit when attaching another IP
        // header since we alloc new MDLs, etc. Hence, we take the approach of using
        // the header in the IPSEC buffers directly.
        //
        // So, here we see if the packet was fragmented; in which case, we let
        // ProtocolSendComplete do the freeing. Else, we free the buffers ourselves.
        //
        {
            PacketContext   *PContext = (PacketContext *)Packet->ProtocolReserved;

            if (PContext->pc_br == NULL ||
                (PContext->pc_ipsec_flags & IPSEC_FLAG_FLUSH)) {

                //
                // this will also free the context.
                //
                IPSecProtocolSendComplete(pContext, pMdl, IP_SUCCESS);
                *ppNewData = NULL;
            }
        }
    } else if (!Packet && (pContext->Flags & SCF_FLUSH)) {
        //
        // ProtocolSendComplete will be called next in IPFragment.
        //
        fFreeContext = FALSE;
    }

    //
    // If context not needed anymore, free it now.
    //
    if (fFreeContext) {
        IPSecFreeSendCompleteCtx(pContext);
    }

#if DBG
    IPSEC_DEBUG(MDL, ("Exiting IPSecSendComplete\n"));
    IPSEC_PRINT_CONTEXT(pContext);
    IPSEC_PRINT_MDL(*ppNewData);
#endif
}


VOID
IPSecProtocolSendComplete (
    IN  PVOID           pContext,
    IN  PNDIS_BUFFER    pMdl,
    IN  IP_STATUS       Status
    )
/*++

Routine Description:

    Called by the stack on a SendComplete - frees up IPSEC's Mdls.
    This is only called when IPSEC injects packets into the stack.

Arguments:


    pMdl - points to the data after the IP header. On the send side, this is an MDL chain
            On the recv side this is an IPRcvBuf pointer.

Return Value:

    STATUS_SUCCESS  =>   Forward - Filter driver passes packet on to IP
    STATUS_PENDING  =>   Drop, IPSEC will re-inject

    Others:
        STATUS_INSUFFICIENT_RESOURCES => Drop
        STATUS_UNSUCCESSFUL (error in algo./bad packet received) => Drop

--*/
{
    PNDIS_BUFFER    pNextMdl;
    NTSTATUS        status;
    PIPSEC_SEND_COMPLETE_CONTEXT    pSCContext = (PIPSEC_SEND_COMPLETE_CONTEXT)pContext;

    if (!pSCContext->Flags) {
        return;
    }

    ASSERT(pMdl);

    while (pMdl) {
        pNextMdl = NDIS_BUFFER_LINKAGE(pMdl);
        IPSecFreeBuffer(&status, pMdl);
        pMdl = pNextMdl;
    }

    IPSecFreeSendCompleteCtx(pSCContext);

    return;
}


NTSTATUS
IPSecChkReplayWindow(
    IN  ULONG           Seq,
    IN  PSA_TABLE_ENTRY pSA,
    IN  ULONG           Index
    )
/*++

Routine Description:

    Checks if the received packet is in the received window to prevent against
    replay attacks.

    We keep track of the last Sequence number received and ensure that the
    received packets is within the packet window (currently 32 packets).

Arguments:

    Seq - received Sequence number

    pSA - points to the security association

Return Value:

    STATUS_SUCCESS  =>   packet in window
    STATUS_UNSUCCESSFUL => packet rejected

--*/
{
    ULONG   diff;
    ULONG   ReplayWindowSize = REPLAY_WINDOW_SIZE;
    ULONG   lastSeq = pSA->sa_ReplayLastSeq[Index];
    ULONGLONG   bitmap = pSA->sa_ReplayBitmap[Index];
    ULONGLONG   dbgbitmap = bitmap;

    if (pSA->sa_Flags & FLAGS_SA_DISABLE_ANTI_REPLAY_CHECK) {
        return STATUS_SUCCESS;
    }

    if (Seq == pSA->sa_ReplayStartPoint) {
        //
        // first == 0 or wrapped
        //
        IPSEC_DEBUG(SEND, ("Replay: out @1 - Seq: %lx, pSA->sa_ReplayStartPoint: %lx\n",
                            Seq, pSA->sa_ReplayStartPoint));
        return IPSEC_INVALID_REPLAY_WINDOW1;
    }

#if DBG
    IPSEC_DEBUG(SEND, ("Replay: Last Seq.: %lx, Cur Seq.: %lx, window size %d & bit window (in nibbles) %08lx%08lx\n",
    lastSeq, Seq, sizeof(bitmap)*8, (ULONG) (dbgbitmap >> 32), (ULONG) dbgbitmap));
#endif

    //
    // new larger Sequence number
    //
    if (Seq > lastSeq) {
        diff = Seq - lastSeq;
        if (diff < ReplayWindowSize) {
            //
            // In window
            // set bit for this packet
            bitmap = (bitmap << diff) | 1;
        } else {
            //
            // This packet has a "way larger" Seq
            //
            bitmap = 1;
        }
        lastSeq = Seq;
        pSA->sa_ReplayLastSeq[Index] = lastSeq;
        pSA->sa_ReplayBitmap[Index] = bitmap;

        //
        // larger is good
        //
        return STATUS_SUCCESS;
    }

    diff = lastSeq - Seq;
    if (diff >= ReplayWindowSize) {
        //
        // too old or wrapped
        //
        IPSEC_DEBUG(SEND, ("Replay: out @3 - Seq: %lx, lastSeq: %lx\n",
                            Seq, lastSeq));
        return IPSEC_INVALID_REPLAY_WINDOW2;
    }

    if (bitmap & (1l << diff)) {
        //
        // this packet already seen
        //
        IPSEC_DEBUG(SEND, ("Replay: out @4 - Seq: %lx, lastSeq: %lx\n",
                            Seq, lastSeq));
        return IPSEC_DUPE_PACKET;
    }

    //
    // mark as seen
    //
    bitmap |= (1l << diff);

    pSA->sa_ReplayLastSeq[Index] = lastSeq;
    pSA->sa_ReplayBitmap[Index] = bitmap;

    //
    // out of order but good
    //
    return STATUS_SUCCESS;
}


NTSTATUS
IPSecReinjectPacket(
    IN  PVOID                   pData,
    IN  PNDIS_PACKET_EXTENSION  pPktExt
    )
/*++

Routine Description:

    Re-injects packet into the stack's send path - makes a copy
    of the packet then calls into IPTransmit, making sure the SendComplete
    Context is setup properly.

Arguments:

    pData - Points to "un-tunneled" data, starting at the encapsulated IP header

    pPktExt - Points to the NDIS Packet extension structure

Return Value:

    Status of copy/transmit operation

--*/
{
    IPOptInfo       optInfo;
    PNDIS_BUFFER    pOptMdl;
    PNDIS_BUFFER    pHdrMdl;
    PNDIS_BUFFER    pDataMdl;
    ULONG           len;
    ULONG           len1;
    ULONG           hdrLen;
    IPRcvBuf        *pNextData;
    IPHeader UNALIGNED * pIPH;
    IPHeader UNALIGNED * pIPH1;
    ULONG           offset;
    NTSTATUS        status;
    ULONG           tag = IPSEC_TAG_REINJECT;
    PIPSEC_SEND_COMPLETE_CONTEXT        pContext;
    NDIS_PACKET_EXTENSION               PktExt = {0};
    PNDIS_IPSEC_PACKET_INFO             IPSecPktInfo;

    //
    // Allocate context for IPSecSencComplete use
    //
    pContext = IPSecAllocateSendCompleteCtx(tag);

    if (!pContext) {
        IPSEC_DEBUG(ESP, ("Failed to alloc. SendCtx\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    IPSEC_INCREMENT(g_ipsec.NumSends);

    IPSecZeroMemory(pContext, sizeof(IPSEC_SEND_COMPLETE_CONTEXT));

#if DBG
    RtlCopyMemory(pContext->Signature, "ISC5", 4);
#endif

    //
    // Pass along IPSEC_PKT_INFO for transport offload if needed
    //
    if (pPktExt) {
        IPSecPktInfo = pPktExt->NdisPacketInfo[IpSecPacketInfo];

        if (IPSecPktInfo) {
            ASSERT(IPSecPktInfo->Receive.CryptoStatus == CRYPTO_SUCCESS);
            ASSERT(IPSecPktInfo->Receive.CRYPTO_DONE);

            //
            // Only interested in NEXT_CRYPTO_DONE if packet is reinjected.
            //
            if (!(IPSecPktInfo->Receive.NEXT_CRYPTO_DONE)) {
                IPSecPktInfo = NULL;
            }
        }
    } else {
        IPSecPktInfo = NULL;
    }

    if (IPSecPktInfo) {
        //
        // Pass the IPSecPktInfo to IPTransmit.
        //
        pContext->PktExt = IPSecAllocatePktExt(IPSEC_TAG_HW_PKTEXT);

        if (!pContext->PktExt) {
            IPSEC_DEBUG(ESP, ("Failed to alloc. PktInfo\n"));
            IPSecFreeSendCompleteCtx(pContext);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        pContext->Flags |= SCF_PKTEXT;

        RtlCopyMemory(  pContext->PktExt,
                        IPSecPktInfo,
                        sizeof(NDIS_IPSEC_PACKET_INFO));
        PktExt.NdisPacketInfo[IpSecPacketInfo] = (PNDIS_IPSEC_PACKET_INFO)(pContext->PktExt);
    }

    //
    // Re-package into MDLs for the send - these will be released on the
    // SendComplete.
    //
    // FUTURE WORK: right now we copy the data out, this shd be optimized
    // by calling IPRcvPacket and using buffer ownership.
    //
    IPSEC_GET_TOTAL_LEN_RCV_BUF(pData, &len);

    //
    // IPH is at head of pData
    //
    IPSecQueryRcvBuf(pData, (PVOID)&pIPH, &len1);

    //
    // Allocate MDL for the IP header
    //
    hdrLen = (pIPH->iph_verlen & (UCHAR)~IP_VER_FLAG) << 2;

    if (len <= hdrLen) {
        IPSEC_DEBUG(ESP, ("TotLen of the buffers %d <= hdrLen %d\n", len, hdrLen));
        if (pContext->PktExt) {
            IPSecFreeMemory(pContext->PktExt);
        }
        IPSecFreeSendCompleteCtx(pContext);
        return STATUS_INVALID_PARAMETER;
    }

    IPSecAllocateBuffer(&status,
                        &pHdrMdl,
                        (PUCHAR *)&pIPH1,
                        sizeof(IPHeader),
                        tag);

    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(ESP, ("Failed to alloc. header MDL\n"));
        if (pContext->PktExt) {
            IPSecFreeMemory(pContext->PktExt);
        }
        IPSecFreeSendCompleteCtx(pContext);
        return status;
    }

    //
    // Copy over the header
    //
    RtlCopyMemory(pIPH1, pIPH, sizeof(IPHeader));

    len -= hdrLen;
    offset = hdrLen;

    IPSecAllocateBuffer(&status,
                        &pDataMdl,
                        NULL,
                        len,
                        tag);

    if (!NT_SUCCESS(status)) {
        NTSTATUS    ntstatus;

        IPSEC_DEBUG(ESP, ("Failed to alloc. encrypt MDL\n"));
        IPSecFreeBuffer(&ntstatus, pHdrMdl);
        if (pContext->PktExt) {
            IPSecFreeMemory(pContext->PktExt);
        }
        IPSecFreeSendCompleteCtx(pContext);
        return status;
    }

    if (hdrLen > sizeof(IPHeader)) {
        PUCHAR  Options;
        PUCHAR  pOpt;

        //
        // Options present - another Mdl
        //
        IPSecAllocateBuffer(&status,
                            &pOptMdl,
                            &Options,
                            hdrLen - sizeof(IPHeader),
                            tag);

        if (!NT_SUCCESS(status)) {
            NTSTATUS    ntstatus;

            IPSecFreeBuffer(&ntstatus, pHdrMdl);
            IPSecFreeBuffer(&ntstatus, pDataMdl);
            if (pContext->PktExt) {
                IPSecFreeMemory(pContext->PktExt);
            }
            IPSecFreeSendCompleteCtx(pContext);
            IPSEC_DEBUG(ESP, ("Failed to alloc. options MDL\n"));
            return status;
        }

        //
        // Copy over the options - we need to fish for it - could be in next MDL
        //
        if (len1 >= hdrLen) {
            //
            // all in this buffer - jump over IP header
            //
            RtlCopyMemory(Options, (PUCHAR)(pIPH + 1), hdrLen - sizeof(IPHeader));
        } else {
            //
            // next buffer, copy from next
            //
            pData = IPSEC_BUFFER_LINKAGE(pData);
            IPSecQueryRcvBuf(pData, (PVOID)&pOpt, &len1);
            RtlCopyMemory(Options, pOpt, hdrLen - sizeof(IPHeader));
            offset = hdrLen - sizeof(IPHeader);
        }

        //
        // Link in the Options buffer
        //
        NDIS_BUFFER_LINKAGE(pHdrMdl) = pOptMdl;
        NDIS_BUFFER_LINKAGE(pOptMdl) = pDataMdl;
    } else {
        //
        // Link in the Data buffer
        //
        NDIS_BUFFER_LINKAGE(pHdrMdl) = pDataMdl;
    }

    //
    // Now bulk copy the entire data
    //
    IPSEC_COPY_FROM_RCVBUF( pDataMdl,
                            pData,
                            len,
                            offset);

    //
    // Fill up the SendCompleteContext
    //
    pContext->FlushMdl = pHdrMdl;
    pContext->Flags |= SCF_FLUSH;

    //
    // Call IPTransmit with proper Protocol type so it takes this packet
    // at *face* value.
    //
    optInfo = g_ipsec.OptInfo;
    optInfo.ioi_options = (PUCHAR)&PktExt;
    optInfo.ioi_flags |= IP_FLAG_IPSEC;
    status = TCPIP_IP_TRANSMIT( &g_ipsec.IPProtInfo,
                                pContext,
                                pHdrMdl,
                                len,
                                pIPH->iph_dest,
                                pIPH->iph_src,
                                &optInfo,
                                NULL,
                                pIPH->iph_protocol,
                                NULL);

    //
    // IPTransmit may fail to allocate a Packet so it returns
    // IP_NO_RESOURCES.  If this is the case, we need to free the MDL chain.
    // This is taken care of in IPTransmit().
    //
    // Even in the synchronous case, we free the MDL chain in ProtocolSendComplete (called by IPSecSendComplete).
    // So, we dont call anything here.
    //

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecQueuePacket(
    IN  PSA_TABLE_ENTRY pSA,
    IN  PVOID           pDataBuf
    )
/*++

Routine Description:

    Copies the packet into the SAs Stall Queue.

Arguments:

Return Value:

--*/
{
    ULONG   len;
    ULONG   len1;
    PNDIS_BUFFER    pOptMdl;
    PNDIS_BUFFER    pHdrMdl;
    PNDIS_BUFFER    pDataMdl;
    KIRQL   kIrql;
    ULONG   hdrLen;
    IPHeader UNALIGNED * pIPH;
    IPHeader UNALIGNED * pIPH1;
    NTSTATUS    status;
    ULONG       offset;
    ULONG       tag = IPSEC_TAG_STALL_QUEUE;
    PNDIS_BUFFER    pData = (PNDIS_BUFFER)pDataBuf;

    //
    // Queue last packet so if we already have one free it first.
    //
    if (pSA->sa_BlockedBuffer != NULL) {
        IPSecFlushQueuedPackets(pSA, STATUS_ABANDONED);
    }

    ACQUIRE_LOCK(&pSA->sa_Lock, &kIrql);

    //
    // Need a lock here - sa_Lock.
    //
    if (pSA->sa_State == STATE_SA_LARVAL) {

        IPSEC_DEBUG(ACQUIRE, ("Pending packet: %lx\n", pSA));

        //
        // Copy over the Mdl chain to this SAs pend queue.
        //
        IPSEC_GET_TOTAL_LEN(pData, &len);

        //
        // IPH is at head of pData
        //
        IPSecQueryNdisBuf(pData, &pIPH, &len1);

        hdrLen = (pIPH->iph_verlen & (UCHAR)~IP_VER_FLAG) << 2;

        IPSecAllocateBuffer(&status,
                            &pHdrMdl,
                            (PUCHAR *)&pIPH1,
                            sizeof(IPHeader),
                            tag);

        if (!NT_SUCCESS(status)) {
            NTSTATUS    ntstatus;
            IPSEC_DEBUG(ESP, ("Failed to alloc. header MDL\n"));
            RELEASE_LOCK(&pSA->sa_Lock, kIrql);
            return status;
        }

        IPSEC_DEBUG(POOL, ("IPSecQueuePacket: pHdrMdl: %lx, pIPH1: %lx\n", pHdrMdl, pIPH1));

        //
        // Copy over the header
        //
        RtlCopyMemory(pIPH1, pIPH, sizeof(IPHeader));

        len -= hdrLen;
        offset = hdrLen;

        IPSecAllocateBuffer(&status,
                            &pDataMdl,
                            NULL,
                            len,
                            tag);

        if (!NT_SUCCESS(status)) {
            NTSTATUS    ntstatus;
            IPSEC_DEBUG(ESP, ("Failed to alloc. encrypt MDL\n"));
            IPSecFreeBuffer(&status, pHdrMdl);
            RELEASE_LOCK(&pSA->sa_Lock, kIrql);
            return status;
        }

        if (hdrLen > sizeof(IPHeader)) {
            PUCHAR  Options;
            PUCHAR  pOpt;

            //
            // Options present - another Mdl
            //
            IPSecAllocateBuffer(&status,
                                &pOptMdl,
                                &Options,
                                hdrLen - sizeof(IPHeader),
                                tag);

            if (!NT_SUCCESS(status)) {
                IPSecFreeBuffer(&status, pHdrMdl);
                IPSecFreeBuffer(&status, pDataMdl);
                IPSEC_DEBUG(ESP, ("Failed to alloc. options MDL\n"));
                RELEASE_LOCK(&pSA->sa_Lock, kIrql);
                return status;
            }

            //
            // Copy over the options - we need to fish for it - could be in next MDL
            //
            if (len1 >= hdrLen) {
                //
                // all in this buffer - jump over IP header
                //
                RtlCopyMemory(Options, (PUCHAR)(pIPH + 1), hdrLen - sizeof(IPHeader));
            } else {
                //
                // next buffer, copy from next
                //
                pData = NDIS_BUFFER_LINKAGE(pData);
                IPSecQueryNdisBuf(pData, &pOpt, &len1);
                RtlCopyMemory(Options, pOpt, hdrLen - sizeof(IPHeader));
                offset = hdrLen - sizeof(IPHeader);
            }

            //
            // Link in the Options buffer
            //
            NDIS_BUFFER_LINKAGE(pHdrMdl) = pOptMdl;
            NDIS_BUFFER_LINKAGE(pOptMdl) = pDataMdl;
        } else {
            //
            // Link in the Data buffer
            //
            NDIS_BUFFER_LINKAGE(pHdrMdl) = pDataMdl;
        }

        //
        // Now bulk copy the entire data
        //
        IPSEC_COPY_FROM_NDISBUF(pDataMdl,
                                pData,
                                len,
                                offset);

        pSA->sa_BlockedBuffer = pHdrMdl;
        pSA->sa_BlockedDataLen = len;

        IPSEC_DEBUG(ACQUIRE, ("Queued buffer: %lx on SA: %lx, psa->sa_BlockedBuffer: %lx\n", pHdrMdl, pSA, &pSA->sa_BlockedBuffer));
    }

    RELEASE_LOCK(&pSA->sa_Lock, kIrql);

    return  STATUS_SUCCESS;
}


VOID
IPSecIPAddrToUnicodeString(
    IN  IPAddr  Addr,
    OUT PWCHAR  UCIPAddrBuffer
    )
/*++

Routine Description:

    Converts an IP addr into a wchar string

Arguments:

Return Value:

--*/
{
    UINT    IPAddrCharCount=0;
    UINT    i;
    UCHAR   IPAddrBuffer[(sizeof(IPAddr) * 4)];
    UNICODE_STRING   unicodeString;
    ANSI_STRING      ansiString;

    //
	// Convert the IP address into a string.
	//	
	for (i = 0; i < sizeof(IPAddr); i++) {
		UINT    CurrentByte;
		
		CurrentByte = Addr & 0xff;
		if (CurrentByte > 99) {
			IPAddrBuffer[IPAddrCharCount++] = (CurrentByte / 100) + '0';
			CurrentByte %= 100;
			IPAddrBuffer[IPAddrCharCount++] = (CurrentByte / 10) + '0';
			CurrentByte %= 10;
		} else if (CurrentByte > 9) {
			IPAddrBuffer[IPAddrCharCount++] = (CurrentByte / 10) + '0';
			CurrentByte %= 10;
		}
		
		IPAddrBuffer[IPAddrCharCount++] = CurrentByte + '0';
		if (i != (sizeof(IPAddr) - 1))
			IPAddrBuffer[IPAddrCharCount++] = '.';
		
		Addr >>= 8;
	}

	//
	// Unicode the strings.
	//
	*UCIPAddrBuffer = UNICODE_NULL;

	unicodeString.Buffer = UCIPAddrBuffer;
	unicodeString.Length = 0;
	unicodeString.MaximumLength =
        (USHORT)(sizeof(WCHAR) * ((sizeof(IPAddr) * 4) + 1));
	ansiString.Buffer = IPAddrBuffer;
	ansiString.Length = (USHORT)IPAddrCharCount;
	ansiString.MaximumLength = (USHORT)IPAddrCharCount;

	RtlAnsiStringToUnicodeString(   &unicodeString,
	                                &ansiString,
                            	    FALSE);
}


VOID
IPSecCountToUnicodeString(
    IN  ULONG   Count,
    OUT PWCHAR  UCCountBuffer
    )
/*++

Routine Description:

    Converts a count a wchar string

Arguments:

Return Value:

--*/
{
	UNICODE_STRING  unicodeString;

	//
	// Unicode the strings.
	//
	*UCCountBuffer = UNICODE_NULL;

	unicodeString.Buffer = UCCountBuffer;
	unicodeString.Length = 0;
	unicodeString.MaximumLength = (USHORT)sizeof(WCHAR) * (MAX_COUNT_STRING_LEN + 1);

	RtlIntegerToUnicodeString ( Count,
                                10, // Base
	                            &unicodeString);
}


VOID
IPSecESPStatus(
    IN  UCHAR       StatusType,
    IN  IP_STATUS   StatusCode,
    IN  IPAddr      OrigDest,
    IN  IPAddr      OrigSrc,
    IN  IPAddr      Src,
    IN  ULONG       Param,
    IN  PVOID       Data
    )
/*++

Routine Description:

    Handle a status indication for ESP, mostly for PMTU handling.

Arguments:

    StatusType  - Type of status.
    StatusCode  - Code identifying IP_STATUS.
    OrigDest    - If this is NET status, the original dest. of DG that
                  triggered it.
    OrigSrc     - The original src corr. OrigDest.
    Src         - IP address of status originator (could be local or remote).
    Param       - Additional information for status - i.e. the param field of
                  an ICMP message.
    Data        - Data pertaining to status - for NET status, this is the
                  first 8 bytes of the original DG.

Return Value:

--*/
{
    IPSEC_DEBUG(PMTU, ("PMTU for ESP recieved from %lx to %lx\n", OrigSrc, OrigDest));

    if (StatusType == IP_NET_STATUS && StatusCode == IP_SPEC_MTU_CHANGE) {
        IPSecProcessPMTU(   OrigDest,
                            OrigSrc,
                            NET_TO_HOST_LONG(((UNALIGNED ESP *)Data)->esp_spi),
                            Encrypt,
                            Param);
   }
}


VOID
IPSecAHStatus(
    IN  UCHAR       StatusType,
    IN  IP_STATUS   StatusCode,
    IN  IPAddr      OrigDest,
    IN  IPAddr      OrigSrc,
    IN  IPAddr      Src,
    IN  ULONG       Param,
    IN  PVOID       Data
    )
/*++

Routine Description:

    Handle a status indication for AH, mostly for PMTU handling.

Arguments:

    StatusType  - Type of status.
    StatusCode  - Code identifying IP_STATUS.
    OrigDest    - If this is NET status, the original dest. of DG that
                  triggered it.
    OrigSrc     - The original src corr. OrigDest.
    Src         - IP address of status originator (could be local or remote).
    Param       - Additional information for status - i.e. the param field of
                  an ICMP message.
    Data        - Data pertaining to status - for NET status, this is the
                  first 8 bytes of the original DG.

Return Value:

--*/
{
    IPSEC_DEBUG(PMTU, ("PMTU for AH recieved from %lx to %lx\n", OrigSrc, OrigDest));

    if (StatusType == IP_NET_STATUS && StatusCode == IP_SPEC_MTU_CHANGE) {
        IPSecProcessPMTU(   OrigDest,
                            OrigSrc,
                            NET_TO_HOST_LONG(((UNALIGNED AH *)Data)->ah_spi),
                            Auth,
                            Param);
   }
}


VOID
IPSecProcessPMTU(
    IN  IPAddr      OrigDest,
    IN  IPAddr      OrigSrc,
    IN  tSPI        SPI,
    IN  OPERATION_E Operation,
    IN  ULONG       NewMTU
    )
/*++

Routine Description:

    Process PMTU.

Arguments:

    OrigDest    - The original dest. of DG that triggered it.
    OrigSrc     - The original src corr. OrigDest.
    SPI         - SPI of the outer IPSec header.
    Operation   - AH or ESP operation of IPSec.
    NewMTU      - The new MTU indicated by the intermediate gateway.

Return Value:

--*/
{
    PLIST_ENTRY     pFilterEntry;
    PLIST_ENTRY     pSAEntry;
    PFILTER         pFilter;
    PSA_TABLE_ENTRY pSA;
    IPAddr          SADest;
    KIRQL           kIrql;
    LONG            Index;
    LONG            SAIndex;
    BOOLEAN         fFound = FALSE;

    IPSEC_DEBUG(PMTU, ("IPSecProcessPMTU: NewMTU arrived %lx\n", NewMTU));

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    //
    // Search Tunnel and Masked filter list for an outbound SA that matches
    // OrigDest, OrigSrc and SPI.  If such an SA is found, update its NewMTU
    // field so that next packet using the SA propogate a smaller MTU
    // back to TCP/IP stack.  Tunnel filter should be searched first because
    // if in the case transport over tunnel operation, the packet going out
    // will have the Tunnel header.
    //
    for (   Index = OUTBOUND_TUNNEL_FILTER;
            (Index >= OUTBOUND_TRANSPORT_FILTER) && !fFound;
            Index -= TRANSPORT_TUNNEL_INCREMENT) {

        for (   pFilterEntry = g_ipsec.FilterList[Index].Flink;
                !fFound && pFilterEntry != &g_ipsec.FilterList[Index];
                pFilterEntry = pFilterEntry->Flink) {

            pFilter = CONTAINING_RECORD(pFilterEntry,
                                        FILTER,
                                        MaskedLinkage);

            for (   SAIndex = 0;
                    (SAIndex < pFilter->SAChainSize) && !fFound;
                    SAIndex++) {

                for (   pSAEntry = pFilter->SAChain[SAIndex].Flink;
                        pSAEntry != &pFilter->SAChain[SAIndex];
                        pSAEntry = pSAEntry->Flink) {

                    pSA = CONTAINING_RECORD(pSAEntry,
                                            SA_TABLE_ENTRY,
                                            sa_FilterLinkage);

                    if (pSA->sa_Flags & FLAGS_SA_TUNNEL) {
                        SADest = pSA->sa_TunnelAddr;
                    } else {
                        SADest = pSA->SA_DEST_ADDR;
                    }

                    if (SADest == OrigDest &&
                        pSA->sa_SPI == SPI &&
                        pSA->sa_Operation[pSA->sa_NumOps - 1] == Operation) {
                        //
                        // We matched the triple for a unique SA so this must be it.
                        //
                        fFound = TRUE;
                        break;
                    }
                }
            }
        }
    }

    //
    // Update the NewMTU field of the found SA.  We only do this if the new
    // MTU is lower than the current one.
    //
    if (fFound && NewMTU < pSA->sa_NewMTU && NewMTU > sizeof(IPHeader)) {
        IPSEC_SET_VALUE(pSA->sa_NewMTU, NewMTU);
        IPSEC_DEBUG(PMTU, ("NewMTU %lx for pSA %lx\n", NewMTU, pSA));
    }

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
}


IPSEC_ACTION
IPSecRcvFWPacket(
    IN  PCHAR   pIPHeader,
    IN  PVOID   pData,
    IN  UINT    DataLength,
    IN  UCHAR   DestType
    )
/*++

Routine Description:

    To match a inbound tunnel rule for a packet received on the inbound forward path.

Arguments:

    pIPHeader   - the IP header
    pData       - the data portion of the packet
    DataLength  - data length

Return Value:

    eFORWARD
    eDROP

--*/
{
    PSA_TABLE_ENTRY pSA;
    PSA_TABLE_ENTRY pNextSA;
    USHORT          FilterFlags;
    NTSTATUS        status;
    IPSEC_ACTION    action = eFORWARD;
    IPRcvBuf        RcvBuf = {0};

    //
    // We are not interested in non multicast broadcast packets.
    //
    if (IS_BCAST_DEST(DestType) && !IPSEC_MANDBCAST_PROCESS()) {
        return  action;
    }

    //
    // Build a fake IPRcvBuf so we can reuse the classification routine.
    //
    RcvBuf.ipr_buffer = pData;
    RcvBuf.ipr_size = DataLength;

    status = IPSecClassifyPacket(   (PUCHAR)pIPHeader,
                                    &RcvBuf,
                                    &pSA,
                                    &pNextSA,
                                    &FilterFlags,
#if GPC
                                    0,
#endif
                                    FALSE,
                                    TRUE,
                                    TRUE,
                                    DestType);

    if (status != STATUS_SUCCESS) {
        if (status == STATUS_PENDING) {
            //
            // SA is being negotiated - drop.
            //
            action = eDROP;
        } else {
            //
            // No Filter/SA match found - forward.
            //
            //action = eFORWARD;
        }
    } else {
        if (FilterFlags) {
            if (FilterFlags & FILTER_FLAGS_DROP) {
                //
                // Drop filter matched - drop.
                //
                action = eDROP;
            } else if (FilterFlags & FILTER_FLAGS_PASS_THRU) {
                //
                // Pass-thru filter matched - forward.
                //
                //action = eFORWARD;
            } else {
                ASSERT(FALSE);
            }
        } else {
            ASSERT(pSA);
            ASSERT(pSA->sa_Flags & FLAGS_SA_TUNNEL);
            //
            // A real SA is matched - drop.
            //
            action = eDROP;
            IPSecDerefSA(pSA);
        }
    }

    return  action;
}


NTSTATUS
IPSecRekeyInboundSA(
    IN  PSA_TABLE_ENTRY pSA
    )
/*++

Routine Description:

    Rekey a SA because we hit the rekey threshold.

Arguments:


Return Value:


--*/
{
    PSA_TABLE_ENTRY pLarvalSA;
    PSA_TABLE_ENTRY pOutboundSA;
    NTSTATUS        status;
    KIRQL           kIrql;

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    //
    // If SA already expired, no rekey is necessary.
    //
    pOutboundSA = pSA->sa_AssociatedSA;

    if (!pOutboundSA) {
        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
        return  STATUS_UNSUCCESSFUL;
    }

    if (!(pOutboundSA->sa_Flags & FLAGS_SA_REKEY_ORI)) {
        pOutboundSA->sa_Flags |= FLAGS_SA_REKEY_ORI;

        IPSEC_DEBUG(SA, ("SA: %lx expiring soon\n", pOutboundSA));

        //
        // Rekey, but still continue to use this SA until the actual expiry.
        //
        status = IPSecNegotiateSA(  pOutboundSA->sa_Filter,
                                    pOutboundSA->sa_uliSrcDstAddr,
                                    pOutboundSA->sa_uliProtoSrcDstPort,
                                    pOutboundSA->sa_NewMTU,
                                    &pLarvalSA,
                                    pOutboundSA->sa_DestType);

        if (!NT_SUCCESS(status) && status != STATUS_DUPLICATE_OBJECTID) {
            pOutboundSA->sa_Flags &= ~FLAGS_SA_REKEY_ORI;
            status = STATUS_UNSUCCESSFUL;
        }
    }

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    return  status;
}


NTSTATUS
IPSecRekeyOutboundSA(
    IN  PSA_TABLE_ENTRY pSA
    )
/*++

Routine Description:

    Rekey a SA because we hit the rekey threshold.

Arguments:


Return Value:


--*/
{
    PSA_TABLE_ENTRY pLarvalSA;
    NTSTATUS        status;
    KIRQL           kIrql;

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    if (!(pSA->sa_Flags & FLAGS_SA_REKEY_ORI)) {
        pSA->sa_Flags |= FLAGS_SA_REKEY_ORI;

        IPSEC_DEBUG(SA, ("SA: %lx expiring soon\n", pSA));

        //
        // Rekey, but still continue to use this SA until the actual expiry.
        //
        status = IPSecNegotiateSA(  pSA->sa_Filter,
                                    pSA->sa_uliSrcDstAddr,
                                    pSA->sa_uliProtoSrcDstPort,
                                    pSA->sa_NewMTU,
                                    &pLarvalSA,
                                    pSA->sa_DestType);

        if (!NT_SUCCESS(status) && status != STATUS_DUPLICATE_OBJECTID) {
            pSA->sa_Flags &= ~FLAGS_SA_REKEY_ORI;
            status = STATUS_UNSUCCESSFUL;
        }
    }

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    return  status;
}


NTSTATUS
IPSecPuntInboundSA(
    IN  PSA_TABLE_ENTRY pSA
    )
/*++

Routine Description:

    Punt a SA because we have exceeded the rekey threshold.

Arguments:


Return Value:


--*/
{
    PSA_TABLE_ENTRY pOutboundSA;
    KIRQL           kIrql;

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    //
    // If SA already expired, no punt is necessary.
    //
    pOutboundSA = pSA->sa_AssociatedSA;

    if (!pOutboundSA) {
        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
        return  STATUS_SUCCESS;
    }

    if (IPSEC_GET_VALUE(pOutboundSA->sa_Reference) > 1 &&
        !(pOutboundSA->sa_Flags & FLAGS_SA_EXPIRED) &&
        pOutboundSA->sa_State == STATE_SA_ACTIVE) {
        pOutboundSA->sa_Flags |= FLAGS_SA_EXPIRED;

        IPSEC_DEBUG(SA, ("SA: %lx has expired\n", pOutboundSA));

        if (pOutboundSA->sa_Flags & FLAGS_SA_REKEY_ORI) {
            pOutboundSA->sa_Flags &= ~FLAGS_SA_REKEY_ORI;

            if (pOutboundSA->sa_RekeyLarvalSA) {
                if (pOutboundSA->sa_RekeyLarvalSA->sa_RekeyOriginalSA) {
                    pOutboundSA->sa_RekeyLarvalSA->sa_RekeyOriginalSA = NULL;
                }
            }
        }

        //
        // Delete this SA and expire the corresponding inbound SA.
        //
        IPSecDeleteInboundSA(pSA);
    }

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecPuntOutboundSA(
    IN  PSA_TABLE_ENTRY pSA
    )
/*++

Routine Description:

    Punt a SA because we have exceeded the rekey threshold.

Arguments:


Return Value:


--*/
{
    KIRQL   kIrql;

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    if (IPSEC_GET_VALUE(pSA->sa_Reference) > 1 &&
        !(pSA->sa_Flags & FLAGS_SA_EXPIRED) &&
        pSA->sa_State == STATE_SA_ACTIVE &&
        pSA->sa_AssociatedSA != NULL) {
        pSA->sa_Flags |= FLAGS_SA_EXPIRED;

        IPSEC_DEBUG(SA, ("SA: %lx has expired\n", pSA));

        if (pSA->sa_Flags & FLAGS_SA_REKEY_ORI) {
            pSA->sa_Flags &= ~FLAGS_SA_REKEY_ORI;

            if (pSA->sa_RekeyLarvalSA) {
                if (pSA->sa_RekeyLarvalSA->sa_RekeyOriginalSA) {
                    pSA->sa_RekeyLarvalSA->sa_RekeyOriginalSA = NULL;
                }
            }
        }

        //
        // Delete this SA and expire the corresponding inbound SA.
        //
        IPSecExpireInboundSA(pSA->sa_AssociatedSA);
    }

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    return  STATUS_SUCCESS;
}


BOOLEAN
IPSecQueryStatus(
    IN  CLASSIFICATION_HANDLE   GpcHandle
    )
/*++

Routine Description:

    Query IPSec to see if IPSec applies to this flow.  TCP/IP then decides whether
    to take fast or slow path in IPTransmit.

Arguments:

    GpcHandle

Return Value:

    TRUE    - if IPSec applies to this packet; slow path
    FALSE   - if IPSec doesn't apply to this packet; fast path

--*/
{
    PLIST_ENTRY pFilterList;
    PFILTER     pFilter;
    NTSTATUS    status;

#if DBG
    //
    // This should force all traffic going through IPSecHandlePacket.
    //
    if (DebugQry) {
        return  TRUE;
    }
#endif

    if (IS_DRIVER_BYPASS() || IPSEC_DRIVER_IS_EMPTY()) {
        return  FALSE;
    }

    //
    // If no GpcHandle passed in, take slow path.
    //
    if (!GpcHandle) {
        return  TRUE;
    }

    //
    // Search in the tunnel filter list first.
    //
    pFilterList = &g_ipsec.FilterList[OUTBOUND_TUNNEL_FILTER];

    //
    // If any tunnel filters exist, take slow path.
    //
    if (!IsListEmpty(pFilterList)) {
        return  TRUE;
    }

#if GPC
    //
    // Search the local GPC filter list.
    //
    pFilterList = &g_ipsec.GpcFilterList[OUTBOUND_TRANSPORT_FILTER];

    //
    // If any generic filters exist, take slow path.
    //
    if (!IsListEmpty(pFilterList)) {
        return  TRUE;
    }

    pFilter = NULL;

    //
    // Use GpcHandle directly to get the filter installed.
    //
    status = GPC_GET_CLIENT_CONTEXT(g_ipsec.GpcClients[GPC_CF_IPSEC_OUT],
                                    GpcHandle,
                                    &pFilter);

    if (status == STATUS_INVALID_HANDLE) {
        //
        // Handle has expired, take slow path because re-classification will
        // have to be applied to this flow from now on until connection breaks.
        // So why bother performing a re-classification here?
        //
        return  TRUE;
    }

    return  pFilter != NULL;
#else
    return  TRUE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\intirspn.c ===
#include "precomp.h"


#pragma hdrstop


NTSTATUS
IPSecGetSPI(
    PIPSEC_GET_SPI pIpsecGetSPI
    )
/*++

Routine Description:

    This routine returns the SPI.

Arguments:

    pIpsecGetSPI - Pointer to the ipsec get spi structure.

Return Value:

    NTSTATUS - The status code from this routine.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIPSEC_ACQUIRE_CONTEXT pIpsecAcquireCtx = NULL;


    pIpsecAcquireCtx = (PIPSEC_ACQUIRE_CONTEXT) pIpsecGetSPI->Context;

    //
    // If context was passed in, then there's a larval SA already setup.
    // This is the case for the initiator.
    //

    if (pIpsecAcquireCtx) {
        ntStatus = IPSecInitiatorGetSPI(
                       pIpsecGetSPI
                       );
    }
    else {
        ntStatus = IPSecResponderGetSPI(
                       pIpsecGetSPI
                       );
    }

    return (ntStatus);
}


NTSTATUS
IPSecInitiatorGetSPI(
    PIPSEC_GET_SPI pIpsecGetSPI
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIPSEC_ACQUIRE_CONTEXT pIpsecAcquireCtx = NULL;
    KIRQL kIrql;


    pIpsecAcquireCtx = (PIPSEC_ACQUIRE_CONTEXT) pIpsecGetSPI->Context;

    //
    // Sanity check the incoming context to see if it is actually
    // an SA block.
    //

    ACQUIRE_LOCK(&g_ipsec.LarvalListLock, &kIrql);

    if (!NT_SUCCESS(IPSecValidateHandle(pIpsecAcquireCtx, STATE_SA_LARVAL))) {
        ntStatus = STATUS_INVALID_PARAMETER;
        BAIL_ON_LOCK_NTSTATUS_ERROR(ntStatus);
    }

    pIpsecGetSPI->SPI = pIpsecAcquireCtx->pSA->sa_SPI;

    pIpsecAcquireCtx->pSA->sa_Flags |= FLAGS_SA_INITIATOR;

    ntStatus = STATUS_SUCCESS;

lock:

    RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);

    return (ntStatus);
}


NTSTATUS
IPSecResponderGetSPI(
    PIPSEC_GET_SPI pIpsecGetSPI
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    KIRQL kIrql;
    PSA_TABLE_ENTRY pInboundSA = NULL;
    ULARGE_INTEGER uliSrcDstAddr = {0};
    PSA_TABLE_ENTRY pSA = NULL;
    PIPSEC_ACQUIRE_CONTEXT pIpsecAcquireCtx = NULL;


    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    if (pIpsecGetSPI->SPI) {

        if (!(pIpsecGetSPI->InstantiatedFilter.TunnelFilter)) {
            pInboundSA = IPSecLookupSABySPI(
                             pIpsecGetSPI->SPI,
                             pIpsecGetSPI->InstantiatedFilter.DestAddr
                             );
        }
        else {
            pInboundSA = IPSecLookupSABySPI(
                             pIpsecGetSPI->SPI,
                             pIpsecGetSPI->InstantiatedFilter.TunnelAddr
                             );
        }

        if (pInboundSA) {
            ntStatus = STATUS_UNSUCCESSFUL;
            BAIL_ON_LOCK_NTSTATUS_ERROR(ntStatus);
        }

    }

    ntStatus = IPSecResponderCreateLarvalSA(
                   pIpsecGetSPI,
                   uliSrcDstAddr,
                   &pSA
                   );
    BAIL_ON_LOCK_NTSTATUS_ERROR(ntStatus);

    //
    // Get the acquire Context and associate it with the larval SA.
    //

    pIpsecAcquireCtx = IPSecGetAcquireContext();

    if (!pIpsecAcquireCtx) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        BAIL_ON_LOCK_NTSTATUS_ERROR(ntStatus);
    }

    pIpsecAcquireCtx->AcquireId = (ULONG)(ULONG_PTR) pSA;

    IPSecGenerateRandom(
        (PUCHAR)&pIpsecAcquireCtx->AcquireId,
        sizeof(ULONG)
        );

    pIpsecAcquireCtx->pSA = pSA;
    pSA->sa_AcquireId = pIpsecAcquireCtx->AcquireId;

    pIpsecGetSPI->Context = pIpsecAcquireCtx;
    pSA->sa_AcquireCtx = pIpsecAcquireCtx;

    pIpsecGetSPI->SPI = pSA->sa_SPI;

    ntStatus = STATUS_SUCCESS;

lock:

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    return (ntStatus);
}


NTSTATUS
IPSecResponderCreateLarvalSA(
    PIPSEC_GET_SPI pIpsecGetSPI,
    ULARGE_INTEGER uliAddr,
    PSA_TABLE_ENTRY * ppSA
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PSA_TABLE_ENTRY pSA = NULL;
    KIRQL kIrql;


    ntStatus = IPSecCreateSA(&pSA);
    BAIL_ON_NTSTATUS_ERROR(ntStatus);

    pSA->sa_Filter = NULL;
    pSA->sa_State = STATE_SA_LARVAL;

    IPSEC_BUILD_SRC_DEST_ADDR(
        pSA->sa_uliSrcDstAddr,
        pIpsecGetSPI->InstantiatedFilter.SrcAddr,
        pIpsecGetSPI->InstantiatedFilter.DestAddr
        );

    IPSEC_BUILD_SRC_DEST_MASK(
        pSA->sa_uliSrcDstMask,
        pIpsecGetSPI->InstantiatedFilter.SrcMask,
        pIpsecGetSPI->InstantiatedFilter.DestMask
        );

    IPSEC_BUILD_PROTO_PORT_LI(
        pSA->sa_uliProtoSrcDstPort,
        pIpsecGetSPI->InstantiatedFilter.Protocol,
        pIpsecGetSPI->InstantiatedFilter.SrcPort,
        pIpsecGetSPI->InstantiatedFilter.DestPort
        );

    ntStatus = IPSecResponderInsertInboundSA(
                   pSA,
                   pIpsecGetSPI,
                   pIpsecGetSPI->InstantiatedFilter.TunnelFilter
                   );
    BAIL_ON_NTSTATUS_ERROR(ntStatus);

    ACQUIRE_LOCK(&g_ipsec.LarvalListLock, &kIrql);

    InsertTailList(&g_ipsec.LarvalSAList, &pSA->sa_LarvalLinkage);

    IPSEC_INC_STATISTIC(dwNumPendingKeyOps);

    RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);

    ACQUIRE_LOCK(&pSA->sa_Lock, &kIrql);

    IPSecStartSATimer(
        pSA,
        IPSecSAExpired,
        pSA->sa_ExpiryTime
        );

    RELEASE_LOCK(&pSA->sa_Lock, kIrql);

    *ppSA = pSA;

    return (ntStatus);

error:

    if (pSA) {
        IPSecFreeSA(pSA);
    }

    *ppSA = NULL;
    return (ntStatus);
}


NTSTATUS
IPSecInitiatorCreateLarvalSA(
    PFILTER pFilter,
    ULARGE_INTEGER uliAddr,
    PSA_TABLE_ENTRY * ppSA,
    UCHAR DestType
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PSA_TABLE_ENTRY pSA = NULL;
    ULARGE_INTEGER uliSrcDstAddr = {0};
    ULARGE_INTEGER uliSrcDstMask = {0};
    ULARGE_INTEGER uliProtoSrcDstPort = {0};
    KIRQL kIrql;


    ntStatus = IPSecCreateSA(&pSA);
    BAIL_ON_NTSTATUS_ERROR(ntStatus);

    pSA->sa_Filter = pFilter;
    pSA->sa_State = STATE_SA_LARVAL;

    uliSrcDstAddr = uliAddr;
    uliSrcDstMask = pFilter->uliSrcDstMask;
    uliProtoSrcDstPort = pFilter->uliProtoSrcDstPort;

    IPSEC_BUILD_SRC_DEST_ADDR(
        pSA->sa_uliSrcDstAddr,
        DEST_ADDR,
        SRC_ADDR
        );

    IPSEC_BUILD_SRC_DEST_MASK(
        pSA->sa_uliSrcDstMask,
        DEST_MASK,
        SRC_MASK
        );

    IPSEC_BUILD_PROTO_PORT_LI(
        pSA->sa_uliProtoSrcDstPort,
        PROTO,
        DEST_PORT,
        SRC_PORT
        );

    pSA->sa_DestType=DestType;

    ntStatus = IPSecInitiatorInsertInboundSA(
                   pSA,
                   pFilter->TunnelFilter
                   );
    BAIL_ON_NTSTATUS_ERROR(ntStatus);

    ACQUIRE_LOCK(&g_ipsec.LarvalListLock, &kIrql);

    InsertTailList(&g_ipsec.LarvalSAList, &pSA->sa_LarvalLinkage);

    IPSEC_INC_STATISTIC(dwNumPendingKeyOps);

    RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);

    ACQUIRE_LOCK(&pSA->sa_Lock, &kIrql);

    IPSecStartSATimer(
        pSA,
        IPSecSAExpired,
        pSA->sa_ExpiryTime
        );

    RELEASE_LOCK(&pSA->sa_Lock, kIrql);

    *ppSA = pSA;

    return (ntStatus);

error:

    if (pSA) {
        IPSecFreeSA(pSA);
    }

    *ppSA = NULL;
    return (ntStatus);
}


NTSTATUS
IPSecFindSA(
    BOOLEAN bTunnelFilter,
    ULARGE_INTEGER uliSrcDstAddr,
    ULARGE_INTEGER uliProtoSrcDstPort,
    PFILTER * ppFilter,
    PSA_TABLE_ENTRY * ppSA
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;


    if (bTunnelFilter) {
        ntStatus = IPSecLookupTunnelSA(
                       uliSrcDstAddr,
                       uliProtoSrcDstPort,
                       ppFilter,
                       ppSA,
                       FALSE
                       );
    }
    else {

#if GPC

        if (IS_GPC_ACTIVE()) {
            ntStatus = IPSecLookupGpcMaskedSA(
                           uliSrcDstAddr,
                           uliProtoSrcDstPort,
                           ppFilter,
                           ppSA,
                           FALSE
                           );
        }
        else {
            ntStatus = IPSecLookupMaskedSA(
                           uliSrcDstAddr,
                           uliProtoSrcDstPort,
                           ppFilter,
                           ppSA,
                           FALSE
                           );
        }
#else

        ntStatus = IPSecLookupMaskedSA(
                       uliSrcDstAddr,
                       uliProtoSrcDstPort,
                       ppFilter,
                       ppSA,
                       FALSE
                       );

#endif

    }

    return (ntStatus);
}


NTSTATUS
IPSecResponderInsertInboundSA(
    PSA_TABLE_ENTRY pSA,
    PIPSEC_GET_SPI pIpsecGetSPI,
    BOOLEAN bTunnelFilter
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PFILTER pFilter = NULL;
    PSA_TABLE_ENTRY pInboundSA = NULL;
    PLIST_ENTRY pSAChain = NULL;
    KIRQL kIrql;
    tSPI tSpi = 0;
    PSA_HASH pHash = NULL;


    ntStatus = IPSecFindSA(
                   bTunnelFilter,
                   pSA->sa_uliSrcDstAddr,
                   pSA->sa_uliProtoSrcDstPort,
                   &pFilter,
                   &pInboundSA
                   );
    if (!NT_SUCCESS(ntStatus)) {
        IPSecBufferEvent(
            pSA->SA_SRC_ADDR,
            EVENT_IPSEC_NEG_FAILURE,
            1,
            FALSE
            );
        return (ntStatus);
    }

    ASSERT(pFilter);

    if (pIpsecGetSPI->InstantiatedFilter.Protocol != pFilter->PROTO ||
        pIpsecGetSPI->InstantiatedFilter.SrcPort != FI_SRC_PORT(pFilter) ||
        pIpsecGetSPI->InstantiatedFilter.DestPort != FI_DEST_PORT(pFilter)) {
        ntStatus = STATUS_OBJECT_TYPE_MISMATCH;
        return (ntStatus);
    }

    pSAChain = IPSecResolveSAChain(pFilter, pSA->SA_SRC_ADDR);

    InsertHeadList(pSAChain, &pSA->sa_FilterLinkage);

    pSA->sa_Flags |= FLAGS_SA_ON_FILTER_LIST;

    if (pFilter->Flags & FILTER_FLAGS_PASS_THRU) {
        pSA->sa_Flags |= FLAGS_SA_PASSTHRU_FILTER;
    }

    if (pFilter->TunnelFilter) {
        pSA->sa_Flags |= FLAGS_SA_TUNNEL;
        pSA->sa_TunnelAddr = pFilter->TunnelAddr;
    }

    //
    // Flush this filter from the cache table so that the SA instead of the
    // filter is matched on the next lookup.
    //

    if (IS_EXEMPT_FILTER(pFilter)) {
        IPSecInvalidateFilterCacheEntry(pFilter);
    }

    AcquireWriteLock(&g_ipsec.SPIListLock, &kIrql);

    tSpi = pIpsecGetSPI->SPI;

    ntStatus = IPSecAllocateSPI(&tSpi, pSA);

    if (!NT_SUCCESS(ntStatus)) {
        ReleaseWriteLock(&g_ipsec.SPIListLock, kIrql);
        return (ntStatus);
    }

    pSA->sa_SPI = tSpi;

    IPSEC_HASH_SPI(
        (pSA->sa_TunnelAddr) ? pSA->sa_TunnelAddr : pSA->SA_DEST_ADDR,
        tSpi,
        pHash
        );

    InsertHeadList(&pHash->SAList, &pSA->sa_SPILinkage);

    pSA->sa_Flags |= FLAGS_SA_ON_SPI_HASH;

    ReleaseWriteLock(&g_ipsec.SPIListLock, kIrql);

    return (STATUS_SUCCESS);
}


NTSTATUS
IPSecInitiatorInsertInboundSA(
    PSA_TABLE_ENTRY pSA,
    BOOLEAN bTunnelFilter
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PFILTER pFilter = NULL;
    PSA_TABLE_ENTRY pInboundSA = NULL;
    PLIST_ENTRY pSAChain = NULL;
    KIRQL kIrql;
    tSPI tSpi = 0;
    PSA_HASH pHash = NULL;


    ntStatus = IPSecFindSA(
                   bTunnelFilter,
                   pSA->sa_uliSrcDstAddr,
                   pSA->sa_uliProtoSrcDstPort,
                   &pFilter,
                   &pInboundSA
                   );
    if (!NT_SUCCESS(ntStatus)) {
        IPSecBufferEvent(
            pSA->SA_SRC_ADDR,
            EVENT_IPSEC_NEG_FAILURE,
            1,
            FALSE
            );
        return (ntStatus);
    }

    if (ntStatus == STATUS_SUCCESS) {
        if (pInboundSA->sa_State == STATE_SA_LARVAL) {
            ntStatus = STATUS_DUPLICATE_OBJECTID;
            return (ntStatus);
        }
    }

    ASSERT(pFilter);

    pSAChain = IPSecResolveSAChain(pFilter, pSA->SA_SRC_ADDR);

    InsertHeadList(pSAChain, &pSA->sa_FilterLinkage);

    pSA->sa_Flags |= FLAGS_SA_ON_FILTER_LIST;

    if (pFilter->Flags & FILTER_FLAGS_PASS_THRU) {
        pSA->sa_Flags |= FLAGS_SA_PASSTHRU_FILTER;
    }

    if (pFilter->TunnelFilter) {
        pSA->sa_Flags |= FLAGS_SA_TUNNEL;
        pSA->sa_TunnelAddr = pFilter->TunnelAddr;
    }

    //
    // Flush this filter from the cache table so that the SA instead of the
    // filter is matched on the next lookup.
    //

    if (IS_EXEMPT_FILTER(pFilter)) {
        IPSecInvalidateFilterCacheEntry(pFilter);
    }

    AcquireWriteLock(&g_ipsec.SPIListLock, &kIrql);

    tSpi = 0;

    ntStatus = IPSecAllocateSPI(&tSpi, pSA);

    if (!NT_SUCCESS(ntStatus)) {
        ReleaseWriteLock(&g_ipsec.SPIListLock, kIrql);
        return (ntStatus);
    }

    pSA->sa_SPI = tSpi;

    IPSEC_HASH_SPI(
        (pSA->sa_TunnelAddr) ? pSA->sa_TunnelAddr : pSA->SA_DEST_ADDR,
        tSpi,
        pHash
        );

    InsertHeadList(&pHash->SAList, &pSA->sa_SPILinkage);

    pSA->sa_Flags |= FLAGS_SA_ON_SPI_HASH;

    ReleaseWriteLock(&g_ipsec.SPIListLock, kIrql);

    return (STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\macros.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    macros.h

Abstract:

    Contains all the macros.

Author:

    Sanjay Anand (SanjayAn) 2-January-1997
    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#ifndef  _MACROS_H
#define  _MACROS_H

#define REGISTER register

#define EXTENDED_MULTIPLY   RtlExtendedIntegerMultiply

#ifndef MAX
#define MAX(x,y)    ((x) < (y)) ? (y) : (x)
#endif
#ifndef MIN
#define MIN(x,y)    ((x) < (y)) ? (x) : (y)
#endif

#define MAX_IP_DATA_LENGTH  ((USHORT)0xfffff)

#define MAX_AH_OUTPUT_LEN   MAX(MD5DIGESTLEN, A_SHA_DIGEST_LEN)

//
// This macro adds a ULONG to a LARGE_INTEGER.
//

#define ADD_TO_LARGE_INTEGER(_LargeInteger,_Ulong) \
    ExInterlockedAddLargeStatistic((PLARGE_INTEGER)(_LargeInteger),(ULONG)(_Ulong))

#define IPSecEqualMemory(_p1, _p2, _len)  RtlEqualMemory(_p1, _p2, _len)

#define IPSecMoveMemory(_p1, _p2, _len)  RtlMoveMemory(_p1, _p2, _len)

#define IPSecZeroMemory(_p1, _len)  RtlZeroMemory(_p1, _len)

//
// Truncates _src to _numbytes and copies into _dest
// then zeroes out the rest in _dest
//
#define TRUNCATE(_dest, _src, _numbytes, _destlen) {        \
    IPSecZeroMemory ( _dest+_numbytes, _destlen - _numbytes); \
}

//
// Some macros
//
#ifdef  NET_SHORT
#undef  NET_SHORT
#endif
__inline
USHORT
FASTCALL
NET_SHORT(USHORT x)
{
#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
    return _byteswap_ushort(x);
#else
    ASSERT(x <= 0xffff);

    return (x << 8) | (x >> 8);
#endif
}

#define NET_TO_HOST_SHORT(Val)  NET_SHORT(Val)
#define HOST_TO_NET_SHORT(Val)  NET_SHORT(Val)

#ifdef  NET_LONG
#undef  NET_LONG
#endif
__inline
ULONG
FASTCALL
NET_LONG(ULONG x)
{
#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
    return _byteswap_ulong(x);
#else
    REGISTER ULONG  BytesSwapped;

    BytesSwapped = ((x & 0x00ff00ff) << 8) | ((x & 0xff00ff00) >> 8);
    return (BytesSwapped << 16) | (BytesSwapped >> 16);
#endif
}

#define NET_TO_HOST_LONG(Val)   NET_LONG(Val)
#define HOST_TO_NET_LONG(Val)   NET_LONG(Val)

#define IPSEC_100NS_FACTOR      10000000

#define IPSEC_CONVERT_SECS_TO_100NS(_li, _delta) {      \
    (_li).LowPart = _delta;                             \
    (_li) = EXTENDED_MULTIPLY(_li, IPSEC_100NS_FACTOR); \
}

#define IS_CLASSD(i)            (((long)(i) & 0xf0000000) == 0xe0000000)

//
// Check SA against Lifetime information - we try to anticipate in advance if the
// SA is going to expire and start off a re-key so that when it actually does expire,
// we have the new SA setup.
//

//
// IPSEC_EXPIRE_TIME_PAD is the time before expiration when we start re-keying
//
#define IPSEC_EXPIRE_TIME_PAD_I         (75 * IPSEC_100NS_FACTOR)
#define IPSEC_EXPIRE_TIME_PAD_R         (40 * IPSEC_100NS_FACTOR)
#define IPSEC_EXPIRE_TIME_PAD_OAKLEY    (1 * IPSEC_100NS_FACTOR)

//
// IPSEC_INBOUND_KEEPALIVE_TIME is the time an expired inboundSA will be kept
// alive in the driver
//
#define IPSEC_INBOUND_KEEPALIVE_TIME    (60)

//
// IPSEC_MAX_EXPIRE_TIME is the maximum phase-2 lifetime allowed in driver
//
#define IPSEC_MAX_EXPIRE_TIME           (48 * 3600 - 1)

//
// IPSEC_MIN_EXPIRE_TIME is the minimum phase-2 lifetime allowed in driver
//
#define IPSEC_MIN_EXPIRE_TIME           (60)

#define IPSEC_EXPIRE_THRESHOLD_I        (50)
#define IPSEC_EXPIRE_THRESHOLD_R        (75)

//
// skew the initiator and responder with Pads
//
#define IPSEC_DEFAULT_SA_IDLE_TIME_PAD_I  0
#define IPSEC_DEFAULT_SA_IDLE_TIME_PAD_R  30

//
// The # of packets before which we start reneg. because of replay rollover
// 1M bytes / 1500 packets
//
#define IPSEC_EXPIRE_REPLAY_MASK    (0x80000000)
#define MAX_ULONG                   ((ULONG) -1)
#define MAX_LONG                    (0x7fffffff)

//
// Some constants used for POST_EXPIRE_NOTIFY
//
#define IPSEC_INVALID_SPI           0
#define IPSEC_INVALID_ADDR          (-1)

//
// Check the lifetime (kbytes and seconds) and replay rollover.
// FALSE => expired
//
#define IPSEC_CHECK_PADDED_LIFETIME(__pSA, _status, _index) {   \
    LARGE_INTEGER   __curtime;                                  \
    (_status) = TRUE;                                           \
    if (((__pSA)->sa_ReplaySendSeq[0] &                         \
         IPSEC_EXPIRE_REPLAY_MASK) &&                           \
        ((__pSA)->sa_Flags & FLAGS_SA_OUTBOUND)) {              \
        _status = FALSE;                                        \
    } else {                                                    \
        KeQuerySystemTime(&__curtime);                          \
        if (((__pSA)->sa_KeyExpirationTimeWithPad.QuadPart > 0i64) && \
            ((__pSA)->sa_KeyExpirationTimeWithPad.QuadPart < __curtime.QuadPart)) {\
            _status = FALSE;                                    \
        } else if (((__pSA)->sa_KeyExpirationBytesWithPad.QuadPart > 0i64) &&   \
                   ((__pSA)->sa_KeyExpirationBytesWithPad.QuadPart < (__pSA)->sa_TotalBytesTransformed.QuadPart)) {   \
            _status = FALSE;                                    \
        }                                                       \
    }                                                           \
}

#define IPSEC_CHECK_LIFETIME(__pSA, _status, _index) {          \
    LARGE_INTEGER   __curtime;                                  \
    (_status) = TRUE;                                           \
    if ((__pSA)->sa_ReplaySendSeq[_index] == MAX_ULONG) {       \
        _status = FALSE;                                        \
    } else {                                                    \
        KeQuerySystemTime(&__curtime);                          \
        if (((__pSA)->sa_KeyExpirationTime.QuadPart > 0i64) &&  \
            ((__pSA)->sa_KeyExpirationTime.QuadPart < __curtime.QuadPart)) { \
            _status = FALSE;                                    \
        } else if (((__pSA)->sa_KeyExpirationBytes.QuadPart > 0i64) &&   \
                   ((__pSA)->sa_KeyExpirationBytes.QuadPart < (__pSA)->sa_TotalBytesTransformed.QuadPart)) { \
            _status = FALSE;                                    \
        }                                                       \
    }                                                           \
}

#define IPSEC_SA_EXPIRED(__pSA, __fexpired) {           \
    LARGE_INTEGER   __curtime;                          \
    KeQuerySystemTime(&__curtime);                      \
    (__fexpired) = FALSE;                               \
    __curtime.QuadPart -= pSA->sa_LastUsedTime.QuadPart;\
    if (__pSA->sa_IdleTime.QuadPart < __curtime.QuadPart) { \
        __fexpired = TRUE;                              \
    }                                                   \
}

//
// Max tolerated collisions when trying to allocate SPIs.
//
#define MAX_SPI_RETRIES 50

#define IPSEC_SPI_TO_ENTRY(_spi, _entry, _dst) {        \
    KIRQL   kIrql;                                      \
    AcquireReadLock(&g_ipsec.SPIListLock, &kIrql);      \
    *(_entry) = IPSecLookupSABySPIWithLock(_spi, _dst); \
    if (*(_entry)) {                                    \
        IPSecRefSA((*(_entry)));                        \
    }                                                   \
    ReleaseReadLock(&g_ipsec.SPIListLock, kIrql);       \
}

//
// Generic memory allocators
//
#define IPSecAllocatePktInfo(__tag) \
    IPSecAllocateMemory(sizeof(NDIS_IPSEC_PACKET_INFO), __tag)

#define IPSecFreePktInfo(__p) \
    IPSecFreeMemory(__p)

#define IPSecAllocatePktExt(__tag) \
    IPSecAllocateMemory(sizeof(NDIS_IPSEC_PACKET_INFO), __tag)

#define IPSecFreePktExt(__p) \
    IPSecFreeMemory(__p)

#define IPSecAllocateBuffer(_ntstatus, _ppBuf, _ppData, _size, _tag) {  \
    PIPSEC_LA_BUFFER    __labuf;                                        \
    *(_ntstatus) = STATUS_SUCCESS;                                      \
    __labuf = IPSecGetBuffer(_size, _tag);                              \
    if (__labuf) {                                                      \
        if (ARGUMENT_PRESENT(_ppData)) {                                \
            *(PVOID *)(_ppData) = __labuf->Buffer;                      \
        }                                                               \
        *(_ppBuf) = __labuf->Mdl;                                       \
        NdisAdjustBufferLength(__labuf->Mdl, _size);                    \
        NDIS_BUFFER_LINKAGE(__labuf->Mdl) = NULL;                       \
    } else {                                                            \
        *(_ntstatus) = STATUS_INSUFFICIENT_RESOURCES;                   \
    }                                                                   \
}

#define IPSecFreeBuffer(_ntstatus, _pBuf) {                             \
    PIPSEC_LA_BUFFER    __buffer;                                       \
    *(_ntstatus) = STATUS_SUCCESS;                                      \
    __buffer = CONTAINING_RECORD((_pBuf), IPSEC_LA_BUFFER, Data);       \
    IPSecReturnBuffer(__buffer);                                        \
}

#define IPSecAllocateSendCompleteCtx(__tag)                 \
    ExAllocateFromNPagedLookasideList(&g_ipsec.IPSecLookasideLists->SendCompleteCtxList)

#define IPSecFreeSendCompleteCtx(_buffer)                   \
    ExFreeToNPagedLookasideList(&g_ipsec.IPSecLookasideLists->SendCompleteCtxList, _buffer);    \
    IPSEC_DECREMENT(g_ipsec.NumSends);

#define IPSEC_GET_TOTAL_LEN(_pbuf, _plen)       {           \
    PNDIS_BUFFER _ptemp = (PNDIS_BUFFER)(_pbuf);            \
    *(_plen) = 0;                                           \
    while (_ptemp) {                                        \
        *(_plen) += _ptemp->ByteCount;                      \
        _ptemp = NDIS_BUFFER_LINKAGE(_ptemp);               \
    }                                                       \
}

#define IPSEC_GET_TOTAL_LEN_RCV_BUF(_pbuf, _plen)       {   \
    IPRcvBuf *_ptemp = (_pbuf);                             \
    *(_plen) = 0;                                           \
    while (_ptemp) {                                        \
        *(_plen) += _ptemp->ipr_size;                       \
        _ptemp = IPSEC_BUFFER_LINKAGE(_ptemp);              \
    }                                                       \
}

//
// Copy len bytes from RcvBuf chain to mdl (only one MDL)
//
#define IPSEC_COPY_FROM_RCVBUF(_pMdl, _pRcvBuf, _len, _offset) {                    \
    IPRcvBuf    *__pBuf=(_pRcvBuf);                                                 \
    PMDL        __pMdl=(_pMdl);                                                     \
    ULONG       __srclen;                                                           \
    ULONG       __destlen;                                                          \
    ULONG       __totallen=0;                                                       \
    PUCHAR      __pSrc;                                                             \
    PUCHAR      __pDest;                                                            \
    ULONG       __curroffset = (_offset);                                           \
    IPSecQueryNdisBuf(__pMdl, &__pDest, &__destlen);                                \
    while (__pBuf) {                                                                \
        IPSecQueryRcvBuf(__pBuf, &__pSrc, &__srclen);                               \
        if (__srclen > __curroffset) {                                              \
            RtlCopyMemory(__pDest, __pSrc+__curroffset, __srclen-__curroffset);     \
            __pDest += (__srclen - __curroffset);                                   \
            __totallen += (__srclen - __curroffset);                                \
        }                                                                           \
        __curroffset = 0;                                                           \
        __pBuf = IPSEC_BUFFER_LINKAGE(__pBuf);                                      \
    }                                                                               \
    ASSERT(__totallen == __destlen);                                                \
}

//
// Copy len bytes from Ndis Buffer chain to mdl (only one MDL)
//
#define IPSEC_COPY_FROM_NDISBUF(_pMdl, _pRcvBuf, _len, _offset) {                   \
    NDIS_BUFFER *__pBuf=(_pRcvBuf);                                                 \
    PMDL        __pMdl=(_pMdl);                                                     \
    ULONG       __srclen;                                                           \
    ULONG       __destlen;                                                          \
    ULONG       __totallen=0;                                                       \
    PUCHAR      __pSrc;                                                             \
    PUCHAR      __pDest;                                                            \
    ULONG       __curroffset = (_offset);                                           \
    IPSecQueryNdisBuf(__pMdl, &__pDest, &__destlen);                                \
    while (__pBuf) {                                                                \
        IPSecQueryNdisBuf(__pBuf, &__pSrc, &__srclen);                              \
        if (__srclen > __curroffset) {                                              \
            RtlCopyMemory(__pDest, __pSrc+__curroffset, __srclen-__curroffset);     \
            __pDest += (__srclen - __curroffset);                                   \
            __totallen += (__srclen - __curroffset);                                \
        }                                                                           \
        __curroffset = 0;                                                           \
        __pBuf = NDIS_BUFFER_LINKAGE(__pBuf);                                       \
    }                                                                               \
    ASSERT(__totallen == __destlen);                                                \
}

#define IPSecAllocateMemory(_size, _tag)    \
        ExAllocatePoolWithTag (NonPagedPool, _size, _tag)

#define IPSecAllocateMemoryLowPriority(_size, _tag) \
        ExAllocatePoolWithTagPriority (NonPagedPool, _size, _tag, LowPoolPriority)

#define IPSecFreeMemory(_addr)  ExFreePool (_addr)

#define IPSecQueryNdisBuf(_Buffer, _VirtualAddress, _Length)    \
{                                                               \
    PNDIS_BUFFER    __Mdl = (PNDIS_BUFFER) (_Buffer);           \
    if (ARGUMENT_PRESENT(_VirtualAddress)) {                    \
        *(PVOID *)(_VirtualAddress) = (__Mdl)->MappedSystemVa;  \
    }                                                           \
    *(_Length) = (__Mdl)->ByteCount;                            \
}

#define IPSecQueryRcvBuf(_Buffer, _VirtualAddress, _Length) \
{                                                           \
    IPRcvBuf    *__buf = (IPRcvBuf *) (_Buffer);            \
    if (ARGUMENT_PRESENT(_VirtualAddress)) {                \
        *(PVOID *)(_VirtualAddress) = (__buf)->ipr_buffer;  \
    }                                                       \
    *(_Length) = (__buf)->ipr_size;                         \
}

#define IPSEC_ADJUST_BUFFER_LEN(_pBuf, _len)    \
    ((IPRcvBuf *)(_pBuf))->ipr_size = (_len)

#define IPSEC_ADJUST_BUFFER(_pBuf, _offset) \
    ((IPRcvBuf *)(_pBuf))->ipr_buffer += (_offset)

#define IPSEC_ADJUST_BUFFER_RCVOFFSET(_pBuf, _offset)   \
    ((IPRcvBuf *)(_pBuf))->ipr_RcvOffset += (_offset)

#define IPSEC_BUFFER_LINKAGE(_pBuf) \
    ((IPRcvBuf *)(_pBuf))->ipr_next

#define IPSEC_BUFFER_LEN(_pBuf) \
    ((IPRcvBuf *)(_pBuf))->ipr_size

#define IPSEC_BUFFER_OWNER(_pBuf)   \
    (((IPRcvBuf *)(_pBuf))->ipr_owner)

#define IPSEC_SET_OFFSET_IN_BUFFER(_pBuf, _offset)  {               \
    PUCHAR  _p;                                                     \
    LONG    _len;                                                   \
    IPSecQueryRcvBuf((_pBuf), &(_p), &(_len));                      \
    if ((_offset) > 0 && (_offset) < (_len)) {                      \
        if (IPSEC_BUFFER_OWNER(_pBuf) == IPR_OWNER_FIREWALL) {      \
            IPSecMoveMemory((_p), (_p) + (_offset), (_len) - (_offset));\
        } else {                                                    \
            IPSEC_ADJUST_BUFFER((_pBuf), (_offset));                \
            IPSEC_ADJUST_BUFFER_RCVOFFSET((_pBuf), (_offset));      \
        }                                                           \
        IPSEC_ADJUST_BUFFER_LEN((_pBuf), (_len) - (_offset));       \
    } else {                                                        \
        ASSERT(FALSE);                                              \
        return  STATUS_INVALID_PARAMETER;                           \
    }                                                               \
}

#define IPSEC_ADD_VALUE(_val, _inc) InterlockedExchangeAdd((PULONG)&(_val), _inc)

#define IPSEC_INCREMENT(_val)  InterlockedIncrement(&(_val))
#define IPSEC_DECREMENT(_val)  InterlockedDecrement(&(_val))
#define IPSEC_GET_VALUE(_val)  InterlockedExchangeAdd((PULONG)&(_val), 0)
#define IPSEC_SET_VALUE(_target, _val)  \
    InterlockedExchange((PULONG)&(_target), _val)

#define IPSEC_DRIVER_IS_EMPTY()     (g_ipsec.NumPolicies == 0)
#define IPSEC_DRIVER_IS_INACTIVE()  (g_ipsec.DriverUnloading || !g_ipsec.InitTcpip)

#define IPSEC_DRIVER_UNLOADING()    (g_ipsec.DriverUnloading)
#define IPSEC_DRIVER_BOUND()        (g_ipsec.BoundToIP)
#define IPSEC_DRIVER_SEND_BOUND()   (g_ipsec.SendBoundToIP)
#define IPSEC_DRIVER_INIT_CRYPTO()  (g_ipsec.InitCrypto)
#define IPSEC_DRIVER_INIT_RNG()     (g_ipsec.InitRNG)
#define IPSEC_DRIVER_INIT_TCPIP()   (g_ipsec.InitTcpip)
#if FIPS
#define IPSEC_DRIVER_INIT_FIPS()    (g_ipsec.InitFips)
#endif
#if GPC
#define IPSEC_DRIVER_INIT_GPC()     (g_ipsec.InitGpc)
#endif

#if DBG
#define IPSecRemoveEntryList(_x)                        \
{                                                       \
    RemoveEntryList(_x);                                \
    (_x)->Flink = (_x)->Blink = (PLIST_ENTRY)__LINE__;  \
}
#else
#define IPSecRemoveEntryList(_x)    RemoveEntryList(_x)
#endif

//
// macros for filter list management
//
#define IS_TRANSPORT_FILTER(f)  (!(f)->TunnelFilter)
#define IS_TUNNEL_FILTER(f)     ((f)->TunnelFilter)
#define IS_INBOUND_FILTER(f)    ((f)->Flags & FILTER_FLAGS_INBOUND)
#define IS_OUTBOUND_FILTER(f)   ((f)->Flags & FILTER_FLAGS_OUTBOUND)

#define IS_EXEMPT_FILTER(f)     (((f)->Flags & FILTER_FLAGS_DROP) || ((f)->Flags & FILTER_FLAGS_PASS_THRU))

#define IS_MULTICAST_FILTER(f)  (IS_CLASSD(NET_LONG((f)->SRC_ADDR)) || \
                                 IS_CLASSD(NET_LONG((f)->DEST_ADDR)))

__inline
PLIST_ENTRY
IPSecResolveFilterList(
    IN  BOOLEAN     fTunnel,
    IN  BOOLEAN     fOutbound
    )
{
    PLIST_ENTRY pEntry;

    if (fTunnel) {
        if (fOutbound) {
            pEntry = &g_ipsec.FilterList[OUTBOUND_TUNNEL_FILTER];
        } else {
            pEntry = &g_ipsec.FilterList[INBOUND_TUNNEL_FILTER];
        }
    } else {
        if (fOutbound) {
            pEntry = &g_ipsec.FilterList[OUTBOUND_TRANSPORT_FILTER];
        } else {
            pEntry = &g_ipsec.FilterList[INBOUND_TRANSPORT_FILTER];
        }
    }

    return  pEntry;
}

//
// Filter/SA Cache Table
//
#define CacheMatch(uliAddr, uliPort, pInCache)              \
        ((uliAddr).QuadPart == pInCache->uliSrcDstAddr.QuadPart) &&    \
        ((uliPort).QuadPart == pInCache->uliProtoSrcDstPort.QuadPart)

#define IS_VALID_CACHE_ENTRY(_entry)    ((_entry)->pFilter != NULL)

#define INVALIDATE_CACHE_ENTRY(_entry)              \
{                                                   \
    ((PFILTER_CACHE)(_entry))->pSAEntry = NULL;     \
    ((PFILTER_CACHE)(_entry))->pNextSAEntry = NULL; \
}                                                   \

__inline
ULONG
FASTCALL
CalcCacheIndex(
    IN  IPAddr  SrcAddr,
    IN  IPAddr  DestAddr,
    IN  UCHAR   Protocol,
    IN  USHORT  SrcPort,
    IN  USHORT  DestPort,
    IN  BOOLEAN fOutbound
    )
{
    REGISTER ULONG  dwIndex;
    REGISTER ULONG  Address;
    REGISTER USHORT Port;

    Address = SrcAddr ^ DestAddr;
    Port = SrcPort ^ DestPort;

    dwIndex = NET_TO_HOST_LONG(Address);
    dwIndex += Protocol;
    dwIndex += NET_TO_HOST_SHORT(Port);

    dwIndex %= g_ipsec.CacheHalfSize;
    if (fOutbound) {
        dwIndex += g_ipsec.CacheHalfSize;
    }

    return  dwIndex;
}

__inline
VOID
CacheUpdate(
    IN  ULARGE_INTEGER  uliAddr,
    IN  ULARGE_INTEGER  uliPort,
    IN  PVOID           _pCtxt1,
    IN  PVOID           _pCtxt2,
    IN  ULONG           dwId,
    IN  BOOLEAN         fFilter
    )
{
    PFILTER_CACHE   __pCache;
    PFILTER_CACHE   __pTempCache;
    PFILTER         __pFilter;
    PSA_TABLE_ENTRY __pSA;
    PSA_TABLE_ENTRY __pNextSA;

    __pCache = g_ipsec.ppCache[(dwId)];

    if (IS_VALID_CACHE_ENTRY(__pCache)) {
        if (__pCache->FilterEntry) {
            __pCache->pFilter->FilterCache = NULL;
        } else {
            __pCache->pSAEntry->sa_FilterCache = NULL;
            if (__pCache->pNextSAEntry) {
                __pCache->pNextSAEntry->sa_FilterCache = NULL;
                __pCache->pNextSAEntry = NULL;
            }
        }
    }

    if (fFilter) {
        __pFilter = (PFILTER)(_pCtxt1);

        if (__pFilter->FilterCache) {
            INVALIDATE_CACHE_ENTRY(__pFilter->FilterCache);
            __pFilter->FilterCache = NULL;
        }

        __pCache->uliSrcDstAddr = (uliAddr);
        __pCache->uliProtoSrcDstPort = (uliPort);
        __pCache->FilterEntry = TRUE;
        __pCache->pFilter = __pFilter;
        __pFilter->FilterCache = __pCache;
    } else {
        __pSA = (PSA_TABLE_ENTRY)(_pCtxt1);
        __pNextSA = (PSA_TABLE_ENTRY)(_pCtxt2);

        if ((__pTempCache = __pSA->sa_FilterCache)) {
            __pTempCache->pSAEntry->sa_FilterCache = NULL;
            if (__pTempCache->pNextSAEntry) {
                __pTempCache->pNextSAEntry->sa_FilterCache = NULL;
            }
            INVALIDATE_CACHE_ENTRY(__pTempCache);
        }

        if (__pNextSA && (__pTempCache = __pNextSA->sa_FilterCache)) {
            __pTempCache->pSAEntry->sa_FilterCache = NULL;
            if (__pTempCache->pNextSAEntry) {
                __pTempCache->pNextSAEntry->sa_FilterCache = NULL;
            }
            INVALIDATE_CACHE_ENTRY(__pTempCache);
        }

        __pCache->uliSrcDstAddr = (uliAddr);
        __pCache->uliProtoSrcDstPort = (uliPort);
        __pCache->FilterEntry = FALSE;
        __pCache->pSAEntry = __pSA;
        __pSA->sa_FilterCache = __pCache;
        if (__pNextSA) {
            __pCache->pNextSAEntry = __pNextSA;
            __pNextSA->sa_FilterCache = __pCache;
        }
    }
}

__inline
VOID
IPSecInvalidateSACacheEntry(
    IN  PSA_TABLE_ENTRY     pSA
    )
{
    PFILTER_CACHE   pCache;

    pCache = pSA->sa_FilterCache;

    if (pCache) {
        ASSERT(IS_VALID_CACHE_ENTRY(pCache));
        ASSERT(pSA == pCache->pSAEntry || pSA == pCache->pNextSAEntry);
        pCache->pSAEntry->sa_FilterCache = NULL;
        if (pCache->pNextSAEntry) {
            pCache->pNextSAEntry->sa_FilterCache = NULL;
        }
        INVALIDATE_CACHE_ENTRY(pCache);
    }
}

__inline
VOID
IPSecInvalidateFilterCacheEntry(
    IN  PFILTER         pFilter
    )
{
    PFILTER_CACHE   pCache;

    pCache = pFilter->FilterCache;

    if (pCache) {
        ASSERT(IS_VALID_CACHE_ENTRY(pCache));
        ASSERT(IS_EXEMPT_FILTER(pFilter));
        pFilter->FilterCache = NULL;
        INVALIDATE_CACHE_ENTRY(pCache);
    }
}

__inline
VOID
IPSecStartSATimer(
    IN  PSA_TABLE_ENTRY         pSA,
    IN  IPSEC_TIMEOUT_HANDLER   TimeoutHandler,
    IN  ULONG                   SecondsToGo
    )
{
    if (pSA->sa_Flags & FLAGS_SA_TIMER_STARTED) {
        if (IPSecStopTimer(&pSA->sa_Timer)) {
            IPSecStartTimer(&pSA->sa_Timer,
                            TimeoutHandler,
                            SecondsToGo,
                            (PVOID)pSA);
        }
    } else {
        pSA->sa_Flags |= FLAGS_SA_TIMER_STARTED;
        IPSecStartTimer(&pSA->sa_Timer,
                        TimeoutHandler,
                        SecondsToGo,
                        (PVOID)pSA);
    }
}

__inline
VOID
IPSecStopSATimer(
    IN  PSA_TABLE_ENTRY pSA
    )
{
    if (pSA->sa_Flags & FLAGS_SA_TIMER_STARTED) {
        pSA->sa_Flags &= ~FLAGS_SA_TIMER_STARTED;
        IPSecStopTimer(&pSA->sa_Timer);
    }
}

__inline
VOID
IPSecStopTimerDerefSA(
    IN  PSA_TABLE_ENTRY pSA
    )
{
    if (pSA->sa_Flags & FLAGS_SA_TIMER_STARTED) {
        if (IPSecStopTimer(&pSA->sa_Timer)) {
            pSA->sa_Flags &= ~FLAGS_SA_TIMER_STARTED;
            IPSecDerefSA(pSA);
        }
    } else {
        IPSecDerefSA(pSA);
    }
}

__inline
VOID
IPSecDerefSANextSA(
    IN  PSA_TABLE_ENTRY pSA,
    IN  PSA_TABLE_ENTRY pNextSA
    )
{
    if (pNextSA) {
        IPSecDerefSA(pNextSA);
    }
    IPSecDerefSA(pSA);
}

__inline
VOID
IPSecRemoveSPIEntry(
    IN  PSA_TABLE_ENTRY pSA
    )
{
    if (pSA->sa_Flags & FLAGS_SA_ON_SPI_HASH) {
        IPSecRemoveEntryList(&pSA->sa_SPILinkage);
        pSA->sa_Flags &= ~FLAGS_SA_ON_SPI_HASH;
    }
}

//
// Packs the src/dest IP addrs in a large integer
//
#define IPSEC_BUILD_SRC_DEST_ADDR(_li, _src, _dest) {   \
    (_li).LowPart = _src;                               \
    (_li).HighPart = _dest;                             \
}

#define IPSEC_BUILD_SRC_DEST_MASK   IPSEC_BUILD_SRC_DEST_ADDR

//
// Packs the Proto and Src/Dest ports into a large int
//
//
// Ports make sense only for TCP and UDP
//
//
// TCP/UDP header
// 0                 15 16               31
// |----|----|----|----|----|----|----|----|
// |    Source Port    |    Dst Port       |
//
#define IPSEC_BUILD_PROTO_PORT_LI(_li, _proto, _sport, _dport) {    \
    (_li).LowPart =                                                 \
      MAKELONG(MAKEWORD((_proto),0x00),0x0000);                     \
    switch((_li).LowPart) {                                         \
        case 6:                                                     \
        case 17: {                                                  \
            (_li).HighPart =  MAKELONG((_sport),(_dport));          \
            break;                                                  \
        }                                                           \
        default: {                                                  \
            (_li).HighPart = 0x00000000;                            \
            break;                                                  \
        }                                                           \
    }                                                               \
}

#define IPSecRefFilter(__pfilter)   IPSEC_INCREMENT((__pfilter)->Reference)

#define IPSecFreeFilter(__pfilter)  IPSecFreeMemory(__pfilter)

#define IPSecDerefFilter(__pfilter)                     \
{                                                       \
    if (IPSEC_DECREMENT((__pfilter)->Reference) == 0) { \
        IPSecFreeFilter(__pfilter);                     \
    }                                                   \
}

#define IPSecAllocateKeyBuffer(_size)   IPSecAllocateMemory(_size, IPSEC_TAG_KEY)
#define IPSecFreeKeyBuffer(_key)    IPSecFreeMemory(_key)


#define IPSecAllocateLogBuffer(_size)   IPSecAllocateMemory(_size, IPSEC_TAG_LOG)
#define IPSecFreeLogBuffer(_key)    IPSecFreeMemory(_key)


#define IPSecFreeSA(_sa) {                          \
    LONG    _i;                                     \
    for (_i=0; _i<(_sa)->sa_NumOps; _i++) {         \
        if ((_sa)->INT_KEY(_i)) {                   \
            IPSecFreeKeyBuffer((_sa)->INT_KEY(_i)); \
        }                                           \
        if ((_sa)->CONF_KEY(_i)) {                  \
            IPSecFreeKeyBuffer((_sa)->CONF_KEY(_i));\
        }                                           \
    }                                               \
    IPSecFreeMemory(_sa);                           \
}

#define IPSecGetAcquireContext()        IPSecAllocateMemory(sizeof(IPSEC_ACQUIRE_CONTEXT), IPSEC_TAG_ACQUIRE_CTX)
#define IPSecFreeAcquireContext(_ctx)   IPSecFreeMemory(_ctx)

#define IPSecGetNotifyExpire()        IPSecAllocateMemory(sizeof(IPSEC_NOTIFY_EXPIRE), IPSEC_TAG_ACQUIRE_CTX)

//
// Hashes <SPI, Dest>
//
#define IPSEC_HASH_SPI(_dest, _spi, _phash) {                               \
    DWORD   dwIndex;                                                        \
    dwIndex = NET_TO_HOST_LONG(_dest) + (_spi);                             \
    dwIndex %= g_ipsec.SAHashSize;                                          \
    pHash = &g_ipsec.pSADb[dwIndex];                                        \
    IPSEC_DEBUG(ALL, ("SPI: Index: %lx for S: %lx, D: %lx, pHash: %lx\n",   \
                    dwIndex,                                                \
                    (_spi),                                                 \
                    (_dest),                                                \
                    pHash));                                                \
}

//
// Hashes <Src, Dest>
//
#define IPSEC_HASH_ADDR(_src, _dest,_phash) {                               \
    DWORD   dwIndex;                                                        \
    dwIndex = (_src)+(_dest);                                               \
    dwIndex %= g_ipsec.SpFilterHashSize;                                    \
    pHash = &g_ipsec.pSpFilter[dwIndex];                                    \
    IPSEC_DEBUG(ALL, ("ADDR: Index: %lx for S: %lx, D: %lx, pHash: %lx\n",  \
                    dwIndex,                                                \
                    (_src),                                                 \
                    (_dest),                                                \
                    pHash));                                                \
}

#define SRC_ADDR   uliSrcDstAddr.LowPart
#define DEST_ADDR  uliSrcDstAddr.HighPart
#define SRC_MASK   uliSrcDstMask.LowPart
#define DEST_MASK  uliSrcDstMask.HighPart
#define PROTO      uliProtoSrcDstPort.LowPart
#define SRC_PORT   LOWORD(uliProtoSrcDstPort.HighPart)
#define DEST_PORT  HIWORD(uliProtoSrcDstPort.HighPart)

#define FI_SRC_PORT(_filter)    LOWORD((_filter)->uliProtoSrcDstPort.HighPart)
#define FI_DEST_PORT(_filter)   HIWORD((_filter)->uliProtoSrcDstPort.HighPart)

#define SA_SRC_ADDR  sa_uliSrcDstAddr.LowPart
#define SA_DEST_ADDR sa_uliSrcDstAddr.HighPart
#define SA_SRC_MASK  sa_uliSrcDstMask.LowPart
#define SA_DEST_MASK sa_uliSrcDstMask.HighPart
#define SA_PROTO     sa_uliProtoSrcDstPort.LowPart

#define SA_SRC_PORT(_psa)       LOWORD((_psa)->sa_uliProtoSrcDstPort.HighPart)
#define SA_DEST_PORT(_psa)      HIWORD((_psa)->sa_uliProtoSrcDstPort.HighPart)

#define FILTER_PROTO(ProtoId)   MAKELONG(MAKEWORD((ProtoId),0x00),0x00000)
#define FILTER_PROTO_ANY        FILTER_PROTO(0x00)
#define FILTER_PROTO_ICMP       FILTER_PROTO(0x01)
#define FILTER_PROTO_TCP        FILTER_PROTO(0x06)
#define FILTER_PROTO_UDP        FILTER_PROTO(0x11)

#define FILTER_TCPUDP_PORT_ANY  (WORD)0x0000

#define FILTER_ICMP_TYPE_ANY    (BYTE)0xff
#define FILTER_ICMP_CODE_ANY    (BYTE)0xff

#define FILTER_MASK_ALL         (DWORD)0xffffffff
#define FILTER_MASK_NONE        (DWORD)0x00000000

//
// macros to parse the ALGORITHM structure
//
#define INT_ALGO(_i)    sa_Algorithm[_i].integrityAlgo.algoIdentifier
#define INT_KEY(_i)     sa_Algorithm[_i].integrityAlgo.algoKey
#define INT_KEYLEN(_i)  sa_Algorithm[_i].integrityAlgo.algoKeylen
#define INT_ROUNDS(_i)  sa_Algorithm[_i].integrityAlgo.algoRounds

#define CONF_ALGO(_i)   sa_Algorithm[_i].confAlgo.algoIdentifier
#define CONF_KEY(_i)    sa_Algorithm[_i].confAlgo.algoKey
#define CONF_KEYLEN(_i) sa_Algorithm[_i].confAlgo.algoKeylen
#define CONF_ROUNDS(_i) sa_Algorithm[_i].confAlgo.algoRounds

#define COMP_ALGO(_i)   sa_Algorithm[_i].compAlgo.algoIdentifier

#define EXT_INT_ALGO    IntegrityAlgo.algoIdentifier
#define EXT_INT_KEY     IntegrityAlgo.algoKey
#define EXT_INT_KEYLEN  IntegrityAlgo.algoKeylen
#define EXT_INT_ROUNDS  IntegrityAlgo.algoRounds

#define EXT_CONF_ALGO   ConfAlgo.algoIdentifier
#define EXT_CONF_KEY    ConfAlgo.algoKey
#define EXT_CONF_KEYLEN ConfAlgo.algoKeylen
#define EXT_CONF_ROUNDS ConfAlgo.algoRounds

#define EXT_INT_ALGO_EX(_i)    AlgoInfo[_i].IntegrityAlgo.algoIdentifier
#define EXT_INT_KEYLEN_EX(_i)  AlgoInfo[_i].IntegrityAlgo.algoKeylen
#define EXT_INT_ROUNDS_EX(_i)  AlgoInfo[_i].IntegrityAlgo.algoRounds

#define EXT_CONF_ALGO_EX(_i)   AlgoInfo[_i].ConfAlgo.algoIdentifier
#define EXT_CONF_KEYLEN_EX(_i) AlgoInfo[_i].ConfAlgo.algoKeylen
#define EXT_CONF_ROUNDS_EX(_i) AlgoInfo[_i].ConfAlgo.algoRounds

#define IS_AH_SA(_psa)  ((_psa)->sa_Operation[0] == Auth ||     \
                         (_psa)->sa_Operation[1] == Auth ||     \
                         (_psa)->sa_Operation[2] == Auth)
#define IS_ESP_SA(_psa) ((_psa)->sa_Operation[0] == Encrypt ||  \
                         (_psa)->sa_Operation[1] == Encrypt ||  \
                         (_psa)->sa_Operation[2] == Encrypt)

//
// Increment/decrement statistics
//
#define IPSEC_INC_STATISTIC(_stat) \
    (g_ipsec.Statistics.##_stat)++;

#define IPSEC_DEC_STATISTIC(_stat) \
    (g_ipsec.Statistics.##_stat)--;

#define IPSEC_INC_TUNNELS(_pSA) {           \
    if ((_pSA)->sa_Flags & FLAGS_SA_TUNNEL) \
        g_ipsec.Statistics.dwNumActiveTunnels++; \
}

#define IPSEC_DEC_TUNNELS(_pSA) {           \
    if ((_pSA)->sa_Flags & FLAGS_SA_TUNNEL) \
        g_ipsec.Statistics.dwNumActiveTunnels--; \
}

//
// Macro to read a dword from registry and init the variable passed in.
//
#define IPSEC_REG_READ_DWORD(_hRegKey, _param, _var, _def, _max, _min) {    \
    NTSTATUS    __status;                                                   \
    __status = GetRegDWORDValue(_hRegKey,                                   \
                                _param,                                     \
                                (_var));                                    \
                                                                            \
    if (!NT_SUCCESS(__status)) {                                            \
        *(_var) = _def;                                                     \
    } else if (*(_var) > _max) {                                            \
        *(_var) = _max;                                                     \
    } else if (*(_var) <= _min) {                                           \
        *(_var) = _min;                                                     \
    }                                                                       \
}

//
// Macro for computing incremental checksum (RFC 1624)
//
#define UpdateIPLength(_piph, _length)                          \
{                                                               \
    ULONG   _sum;                                               \
    USHORT  _old;                                               \
                                                                \
    _old = NET_SHORT((_piph)->iph_length);                      \
    (_piph)->iph_length = (_length);                            \
    _sum = (~NET_SHORT((_piph)->iph_xsum) & 0xffff) +           \
           (~_old & 0xffff) +                                   \
           NET_SHORT((_piph)->iph_length);                      \
    _sum = (_sum & 0xffff) + (_sum >> 16);                      \
    _sum += (_sum >> 16);                                       \
    (_piph)->iph_xsum = NET_SHORT((USHORT)(~_sum & 0xffff));    \
}

#define UpdateIPProtocol(_piph, _proto)                         \
{                                                               \
    ULONG   _sum;                                               \
    USHORT  _old;                                               \
                                                                \
    _old = NET_SHORT(*(USHORT *)&(_piph)->iph_ttl);             \
    (_piph)->iph_protocol = (_proto);                           \
    _sum = (~NET_SHORT((_piph)->iph_xsum) & 0xffff) +           \
           (~_old & 0xffff) +                                   \
           NET_SHORT(*(USHORT *)&(_piph)->iph_ttl);             \
    _sum = (_sum & 0xffff) + (_sum >> 16);                      \
    _sum += (_sum >> 16);                                       \
    (_piph)->iph_xsum = NET_SHORT((USHORT)(~_sum & 0xffff));    \
}

#define IPSecPrint4Long(_key)               \
    DbgPrint("Key: %lx-%lx-%lx-%lx\n",      \
            *(ULONG *)&(_key)[0],           \
            *(ULONG *)&(_key)[4],           \
            *(ULONG *)&(_key)[8],           \
            *(ULONG *)&(_key)[12]);

#define IPSEC_DELAY_INTERVAL    ((LONGLONG)(-1 * 1000 * 1000))  // 1/10 sec.

#define IPSEC_DELAY_EXECUTION()                                     \
{                                                                   \
    IPSecDelayInterval.QuadPart = IPSEC_DELAY_INTERVAL;             \
    KeDelayExecutionThread(UserMode, FALSE, &IPSecDelayInterval);   \
}

#define IS_DRIVER_BLOCK()   (g_ipsec.OperationMode == IPSEC_BLOCK_MODE)
#define IS_DRIVER_BYPASS()  (g_ipsec.OperationMode == IPSEC_BYPASS_MODE)
#define IS_DRIVER_SECURE()  (g_ipsec.OperationMode == IPSEC_SECURE_MODE)

#define IS_DRIVER_DIAGNOSTIC()  (g_ipsec.DiagnosticMode)

#define LOG_EVENT   NdisWriteEventLogEntry

#define IPSEC_NULL_GUIDS    "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"

#define IPSEC_EQUAL_GUIDS(_A, _B)     \
    ((*(UNALIGNED ULONG *)((PUCHAR)(_A)) == *(UNALIGNED ULONG *)((PUCHAR)(_B))) &&         \
     (*(UNALIGNED ULONG *)(((PUCHAR)(_A))+4) == *(UNALIGNED ULONG *)(((PUCHAR)(_B))+4)) && \
     (*(UNALIGNED ULONG *)(((PUCHAR)(_A))+8) == *(UNALIGNED ULONG *)(((PUCHAR)(_B))+8)) && \
     (*(UNALIGNED ULONG *)(((PUCHAR)(_A))+12) == *(UNALIGNED ULONG *)(((PUCHAR)(_B))+12)))

//
// Get the next non-zero length NDIS buffer.
//
__inline
PNDIS_BUFFER
FASTCALL
IPSEC_NEXT_BUFFER(
    IN  PNDIS_BUFFER    pBuffer
    )
{
    PVOID   *pDummy = NULL;
    ULONG   Length = 0;

    if (!pBuffer) {
        ASSERT(FALSE);
        return  NULL;
    }

    pBuffer = NDIS_BUFFER_LINKAGE(pBuffer);

    while (pBuffer) {
        IPSecQueryNdisBuf(pBuffer, &pDummy, &Length);
        if (Length == 0) {
            pBuffer = NDIS_BUFFER_LINKAGE(pBuffer);
            continue;
        } else {
            return  pBuffer;
        }
    }

    return  NULL;
}

#define SA_CHAIN_WIDTH  4

//
// Count number of 1's in the IP mask
//
__inline
LONG
CountNumberOfOnes(
    IN  IPMask  IpMask
    )
{
    INT     i;
    LONG    NumberOfOnes = 0;
    IPMask  Mask = IpMask;

    for (i = 0; i < sizeof(IPMask) * 8; i++) {
        if ((Mask & 0x1) == 0x1) {
            NumberOfOnes++;
        }

        Mask = Mask >> 1;
    }

    return  NumberOfOnes;
}

__inline
PLIST_ENTRY
FASTCALL
IPSecResolveSAChain(
    IN  PFILTER pFilter,
    IN  IPAddr  IpAddr
    )
{
    PLIST_ENTRY pEntry;
    ULONG       Index;

    if (IS_TUNNEL_FILTER(pFilter)) {
        pEntry = &pFilter->SAChain[0];
    } else {
        Index = NET_TO_HOST_LONG(IpAddr) % pFilter->SAChainSize;
        pEntry = &pFilter->SAChain[Index];
    }

    return  pEntry;
}

#if GPC
#define IPSEC_GPC_MASK_ALL      (0xff)
#define IPSEC_GPC_MASK_NONE     (0x0)

#define GPC_REGISTER_CLIENT     g_ipsec.GpcEntries.GpcRegisterClientHandler
#define GPC_DEREGISTER_CLIENT   g_ipsec.GpcEntries.GpcDeregisterClientHandler
#define GPC_ADD_CFINFO          g_ipsec.GpcEntries.GpcAddCfInfoHandler
#define GPC_REMOVE_CFINFO       g_ipsec.GpcEntries.GpcRemoveCfInfoHandler
#define GPC_ADD_PATTERN         g_ipsec.GpcEntries.GpcAddPatternHandler
#define GPC_REMOVE_PATTERN      g_ipsec.GpcEntries.GpcRemovePatternHandler
#define GPC_CLASSIFY_PATTERN    g_ipsec.GpcEntries.GpcClassifyPatternHandler
#define GPC_GET_CLIENT_CONTEXT  g_ipsec.GpcEntries.GpcGetCfInfoClientContextHandler

#define IPSEC_GPC_ACTIVE        (0x12345678)
#define IPSEC_NUM_GPC_FILTERS() (g_ipsec.NumMaskedFilters)

#define IS_GPC_ACTIVE()         (g_ipsec.GpcActive == IPSEC_GPC_ACTIVE)

#define IPSEC_SET_GPC_ACTIVE()              \
{                                           \
    g_ipsec.GpcActive = IPSEC_GPC_ACTIVE;   \
}

#define IPSEC_UNSET_GPC_ACTIVE()            \
{                                           \
    g_ipsec.GpcActive = 0;                  \
}

__inline
INT
FASTCALL
IPSecResolveGpcCf(
    IN  BOOLEAN fOutbound
    )
{
    return  fOutbound? GPC_CF_IPSEC_OUT: GPC_CF_IPSEC_IN;
}

__inline
PLIST_ENTRY
FASTCALL
IPSecResolveGpcFilterList(
    IN  BOOLEAN     fTunnel,
    IN  BOOLEAN     fOutbound
    )
{
    PLIST_ENTRY pEntry;

    if (fTunnel) {
        if (fOutbound) {
            pEntry = &g_ipsec.GpcFilterList[OUTBOUND_TUNNEL_FILTER];
        } else {
            pEntry = &g_ipsec.GpcFilterList[INBOUND_TUNNEL_FILTER];
        }
    } else {
        if (fOutbound) {
            pEntry = &g_ipsec.GpcFilterList[OUTBOUND_TRANSPORT_FILTER];
        } else {
            pEntry = &g_ipsec.GpcFilterList[INBOUND_TRANSPORT_FILTER];
        }
    }

    return  pEntry;
}

__inline
VOID
IPSEC_CLASSIFY_PACKET(
    IN  INT                     GpcCf,
    IN  ULARGE_INTEGER          uliSrcDstAddr,
    IN  ULARGE_INTEGER          uliProtoSrcDstPort,
    OUT PFILTER                 *ppFilter,
    OUT PCLASSIFICATION_HANDLE  pGpcHandle
    )
{
    GPC_IP_PATTERN  Pattern;

    *ppFilter = NULL;
    *pGpcHandle = 0;

    Pattern.SrcAddr = SRC_ADDR;
    Pattern.DstAddr = DEST_ADDR;
    Pattern.ProtocolId = (UCHAR)PROTO;
    if (PROTO == PROTOCOL_TCP || PROTO == PROTOCOL_UDP) {
        Pattern.gpcSrcPort = SRC_PORT;
        Pattern.gpcDstPort = DEST_PORT;
    } else {
        Pattern.gpcSrcPort = 0;
        Pattern.gpcDstPort = 0;
    }
    Pattern.InterfaceId.InterfaceId = 0;
    Pattern.InterfaceId.LinkId = 0;

    GPC_CLASSIFY_PATTERN(   g_ipsec.GpcClients[GpcCf],
                            GPC_PROTOCOL_TEMPLATE_IP,
                            &Pattern,
                            ppFilter,
                            pGpcHandle,
                            0,
                            NULL,
                            TRUE);
}

#define IS_GPC_FILTER(f)    (g_ipsec.InitGpc &&                 \
                             f->SRC_MASK == FILTER_MASK_ALL &&  \
                             f->DEST_MASK == FILTER_MASK_ALL)
#endif

#if FIPS
#define IPSEC_DES_ALGO      FIPS_CBC_DES
#define IPSEC_3DES_ALGO     FIPS_CBC_3DES
#define IPSEC_SHA_INIT      g_ipsec.FipsFunctionTable.FipsSHAInit
#define IPSEC_SHA_UPDATE    g_ipsec.FipsFunctionTable.FipsSHAUpdate
#define IPSEC_SHA_FINAL     g_ipsec.FipsFunctionTable.FipsSHAFinal
#define IPSEC_DES_KEY       g_ipsec.FipsFunctionTable.FipsDesKey
#define IPSEC_3DES_KEY      g_ipsec.FipsFunctionTable.Fips3Des3Key
#define IPSEC_CBC           g_ipsec.FipsFunctionTable.FipsCBC
#define IPSEC_GEN_RANDOM    g_ipsec.FipsFunctionTable.FIPSGenRandom
#define IPSEC_HMAC_SHA_INIT g_ipsec.FipsFunctionTable.FipsHmacSHAInit
#define IPSEC_HMAC_SHA_UPDATE g_ipsec.FipsFunctionTable.FipsHmacSHAUpdate
#define IPSEC_HMAC_SHA_FINAL g_ipsec.FipsFunctionTable.FipsHmacSHAFinal
#define IPSEC_HMAC_MD5_INIT g_ipsec.FipsFunctionTable.HmacMD5Init
#define IPSEC_HMAC_MD5_UPDATE g_ipsec.FipsFunctionTable.HmacMD5Update
#define IPSEC_HMAC_MD5_FINAL g_ipsec.FipsFunctionTable.HmacMD5Final
#else
#define IPSEC_DES_ALGO      des
#define IPSEC_3DES_ALGO     tripledes
#define IPSEC_SHA_INIT      A_SHAInit
#define IPSEC_SHA_UPDATE    A_SHAUpdate
#define IPSEC_SHA_FINAL     A_SHAFinal
#define IPSEC_DES_KEY       deskey
#define IPSEC_3DES_KEY      tripledes3key
#define IPSEC_CBC(_EncryptionAlgo, _pOut, _pIn, _pKeyTable, _Operation, _pFeedback) \
    CBC(_EncryptionAlgo,    \
        DES_BLOCKLEN,       \
        _pOut,              \
        _pIn,               \
        _pKeyTable,         \
        _Operation,         \
        _pFeedback)
#define IPSEC_GEN_RANDOM(_pBuf, _KeySize)   NewGenRandom(NULL, NULL, _pBuf, _KeySize)
#endif
#define IPSEC_MD5_INIT      MD5Init
#define IPSEC_MD5_UPDATE    MD5Update
#define IPSEC_MD5_FINAL     MD5Final
#define IPSEC_RC4_KEY       rc4_key        
#define IPSEC_RC4           rc4

#define IS_CLASS_D_ADDR(x)  (((x) & 0x000000f0) == 0x000000e0)

#define DEFAULT_IPSEC_OPERATION_MODE    IPSEC_BYPASS_MODE

#define TCPIP_FREE_BUFF         g_ipsec.TcpipFreeBuff
#define TCPIP_ALLOC_BUFF        g_ipsec.TcpipAllocBuff
#define TCPIP_GET_ADDRTYPE      g_ipsec.TcpipGetAddrType
#define TCPIP_GET_INFO          g_ipsec.TcpipGetInfo
#define TCPIP_NDIS_REQUEST      g_ipsec.TcpipNdisRequest
#define TCPIP_REGISTER_PROTOCOL g_ipsec.TcpipRegisterProtocol
#define TCPIP_SET_IPSEC_STATUS  g_ipsec.TcpipSetIPSecStatus
#define TCPIP_IP_TRANSMIT       g_ipsec.TcpipIPTransmit
#define TCPIP_SET_IPSEC         g_ipsec.TcpipSetIPSecPtr
#define TCPIP_UNSET_IPSEC       g_ipsec.TcpipUnSetIPSecPtr
#define TCPIP_UNSET_IPSEC_SEND  g_ipsec.TcpipUnSetIPSecSendPtr
#define TCPIP_TCP_XSUM          g_ipsec.TcpipTCPXsum
#define TCPIP_GEN_IPID          g_ipsec.TcpipGenIpId
#define TCPIP_DEREGISTER_PROTOCOL g_ipsec.TcpipDeRegisterProtocol

#ifdef xsum
#undef xsum
#define xsum(Buffer, Length)    ((USHORT)TCPIP_TCP_XSUM(0, (PUCHAR)(Buffer), (Length)))
#endif


#define SAFETY_LEN  (TRUNCATED_HASH_LEN+MAX_PAD_LEN)


//
// Compares the src/dest ports out of a word with the number input
//
#define IPSEC_COMPARE_SD_PORT(_pport, _port)    \
    (   ((_pport)[0] == (_port)) ||     \
        ((_pport)[1] == (_port)))

#define IPSEC_COMPARE_D_PORT(_pport, _port) ((_pport)[1] == (_port))

//
// Bypass traffic logic for IKE, Kerberos and RSVP
//
#define IPSEC_KERBEROS_TRAFFIC()                            \
    ((pIPHeader->iph_protocol == PROTOCOL_UDP ||            \
      pIPHeader->iph_protocol == PROTOCOL_TCP) &&           \
     IPSEC_COMPARE_SD_PORT(pwPort, IPSEC_KERBEROS_PORT))

#define IPSEC_ISAKMP_TRAFFIC()                              \
    (pIPHeader->iph_protocol == PROTOCOL_UDP &&             \
     IPSEC_COMPARE_D_PORT(pwPort, IPSEC_ISAKMP_PORT))       \

#define IPSEC_RSVP_TRAFFIC()                                \
    (pIPHeader->iph_protocol == PROTOCOL_RSVP)

#define IPSEC_NO_UNICAST_EXEMPT   0x00000001
#define IPSEC_NO_MANDBCAST_EXEMPT 0x00000002

#define IPSEC_NO_DEFAULT_EXEMPT()   (g_ipsec.NoDefaultExempt & IPSEC_NO_UNICAST_EXEMPT)
#define IPSEC_HANDLE_MANDBCAST()   (g_ipsec.NoDefaultExempt & IPSEC_NO_MANDBCAST_EXEMPT)

#define IPSEC_MANDBCAST_PROCESS() (IPSEC_GET_VALUE(g_ipsec.NumMulticastFilters) || \
                                   IPSEC_HANDLE_MANDBCAST())

#define IPSEC_BYPASS_TRAFFIC()                              \
    (IPSEC_ISAKMP_TRAFFIC() ||                              \
     (!IPSEC_NO_DEFAULT_EXEMPT() &&                         \
      (IPSEC_KERBEROS_TRAFFIC() ||                          \
       IPSEC_RSVP_TRAFFIC())))

//
// Forwarding path is either reinject a detunneled forward packet or route
//
#define IPSEC_FORWARD_PATH()    (fFWPacket || (fOutbound && TCPIP_GET_ADDRTYPE(pIPHeader->iph_src) != DEST_LOCAL))


/*++

Routine Description:

    Fills in the DELETE_SA hw request from pSA

Arguments:

    pSA - the SA
    Buf - buffer to set info
    Len - length

Return Value:

    status of the operation

--*/
#define IPSecFillHwDelSA(_pSA, _Buf, _Len) \
    ((POFFLOAD_IPSEC_DELETE_SA)(_Buf))->OffloadHandle = (_pSA)->sa_OffloadHandle;


#endif  _MACROS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\locks.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    locks.h

Abstract:

    Contains all the lock related macros.

Author:

    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#ifndef _LOCKS_H
#define _LOCKS_H

#define IPSEC_READ_LOCK     1
#define IPSEC_WRITE_LOCK    2

#define INIT_LOCK(l)        KeInitializeSpinLock(l)
#define ACQUIRE_LOCK(l, q)  KeAcquireSpinLock(l, q)
#define RELEASE_LOCK(l, q)  KeReleaseSpinLock(l, q)

//
// The Filter/SA database is protected by a single-writer (infrequent) and
// multiple-reader (frequent) locking scheme.
//
typedef struct _MRSW_LOCK
{
    KSPIN_LOCK  SpinLock;
    ULONG       RefCount;
#if DBG
    ULONG       LastLockLine;
    ULONG       LastLockType;
#endif
} MRSW_LOCK, *PMRSW_LOCK;

__inline
VOID
InitializeMRSWLock(
    PMRSW_LOCK  pRWLock
    )
{
    pRWLock->RefCount = 0;
    KeInitializeSpinLock(&pRWLock->SpinLock);
#if DBG
    pRWLock->LastLockLine = 0;
    pRWLock->LastLockType = 0;
#endif
}

__inline
VOID
AcquireReadLock(
    PMRSW_LOCK  pRWLock,
    PKIRQL      pIrql
    )
{
    KeAcquireSpinLock(&pRWLock->SpinLock, pIrql);
    InterlockedIncrement(&pRWLock->RefCount);
    KeReleaseSpinLockFromDpcLevel(&pRWLock->SpinLock);
#if DBG
    pRWLock->LastLockLine = __LINE__;
    pRWLock->LastLockType = 1;
#endif
}

__inline
VOID
ReleaseReadLock(
    PMRSW_LOCK  pRWLock,
    KIRQL       Irql
    )
{
    InterlockedDecrement(&pRWLock->RefCount);
    KeLowerIrql(Irql);
}

__inline
VOID
AcquireReadLockAtDpc(
    PMRSW_LOCK  pRWLock
    )
{
    KeAcquireSpinLockAtDpcLevel(&pRWLock->SpinLock);
    InterlockedIncrement(&pRWLock->RefCount);
    KeReleaseSpinLockFromDpcLevel(&pRWLock->SpinLock);
#if DBG
    pRWLock->LastLockLine = __LINE__;
    pRWLock->LastLockType = IPSEC_READ_LOCK;
#endif
}

__inline
VOID
ReleaseReadLockFromDpc(
    PMRSW_LOCK  pRWLock
    )
{
    InterlockedDecrement(&pRWLock->RefCount);
}

__inline
VOID
AcquireWriteLock(
    PMRSW_LOCK  pRWLock,
    PKIRQL      pIrql
    )
{
    KeAcquireSpinLock(&pRWLock->SpinLock, pIrql);
    while (*((volatile *)&pRWLock->RefCount));
#if DBG
    pRWLock->LastLockLine = __LINE__;
    pRWLock->LastLockType = IPSEC_WRITE_LOCK;
#endif
}

__inline
VOID
ReleaseWriteLock(
    PMRSW_LOCK  pRWLock,
    KIRQL       Irql
    )
{
    KeReleaseSpinLock(&pRWLock->SpinLock, Irql);
}

__inline
VOID
AcquireWriteLockAtDpc(
    PMRSW_LOCK  pRWLock
    )
{
    KeAcquireSpinLockAtDpcLevel(&pRWLock->SpinLock);
    while (*((volatile *)&pRWLock->RefCount));
#if DBG
    pRWLock->LastLockLine = __LINE__;
    pRWLock->LastLockType = IPSEC_WRITE_LOCK;
#endif
}

__inline
VOID
ReleaseWriteLockFromDpc(
    PMRSW_LOCK  pRWLock
    )
{
    KeReleaseSpinLockFromDpcLevel(&pRWLock->SpinLock);
}

#endif  _LOCKS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\saapi.h ===
//
// List of weak and semi-weak DES keys from
// Applied Cryptography: Protocols, Algorithms, and Source Code in C,
// second edition by Bruce Schneier.
//

#define NUM_WEAK_KEYS 16


BOOLEAN
IPSecInitRandom(
    VOID
    );

VOID
IPSecRngRekey(
    IN  PVOID   Context
    );

BOOLEAN
IPSecGenerateRandom(
    IN  PUCHAR  pBuf,
    IN  ULONG   BytesNeeded
    );

VOID
IPSecCleanupOutboundSA(
    IN  PSA_TABLE_ENTRY pInboundSA,
    IN  PSA_TABLE_ENTRY pOutboundSA,
    IN  BOOLEAN         fNoDelete
    );

VOID
IPSecCleanupLarvalSA(
    IN  PSA_TABLE_ENTRY  pSA
    );

VOID
IPSecDeleteLarvalSA(
    IN  PSA_TABLE_ENTRY  pSA
    );

VOID
IPSecDeleteInboundSA(
    IN  PSA_TABLE_ENTRY  pInboundSA
    );

VOID
IPSecExpireInboundSA(
    IN  PSA_TABLE_ENTRY  pInboundSA
    );

NTSTATUS
IPSecCheckInboundSA(
    IN  PSA_STRUCT             pSAStruct,
    IN  PSA_TABLE_ENTRY        pSA
    );

BOOLEAN
IPSecIsWeakDESKey(
    IN  PUCHAR  Key
    );

BOOLEAN
IPSecIsWeak3DESKey(
    IN  PUCHAR  Key
    );

NTSTATUS
IPSecPopulateSA(
    IN  PSA_STRUCT              pSAStruct,
    IN  ULONG                   KeyLen,
    IN  PSA_TABLE_ENTRY         pSA
    );

NTSTATUS
IPSecCreateSA(
    OUT PSA_TABLE_ENTRY         *ppSA
    );

PSA_TABLE_ENTRY
IPSecLookupSABySPI(
    IN  tSPI    SPI,
    IN  IPAddr  DestAddr
    );

PSA_TABLE_ENTRY
IPSecLookupSABySPIWithLock(
    IN  tSPI    SPI,
    IN  IPAddr  DestAddr
    );

NTSTATUS
IPSecLookupSAByAddr(
    IN  ULARGE_INTEGER  uliSrcDstAddr,
    IN  ULARGE_INTEGER  uliProtoSrcDstPort,
    OUT PFILTER         *ppFilter,
    OUT PSA_TABLE_ENTRY *ppSA,
    OUT PSA_TABLE_ENTRY *ppNextSA,
    OUT PSA_TABLE_ENTRY *ppTunnelSA,
    IN  BOOLEAN         fOutbound,
    IN  BOOLEAN         fFWPacket,
    IN  BOOLEAN         fBypass
    );

NTSTATUS
IPSecLookupTunnelSA(
    IN  ULARGE_INTEGER  uliSrcDstAddr,
    IN  ULARGE_INTEGER  uliProtoSrcDstPort,
    OUT PFILTER         *ppFilter,
    OUT PSA_TABLE_ENTRY *ppSA,
    IN  BOOLEAN         fOutbound
    );

NTSTATUS
IPSecLookupMaskedSA(
    IN  ULARGE_INTEGER  uliSrcDstAddr,
    IN  ULARGE_INTEGER  uliProtoSrcDstPort,
    OUT PFILTER         *ppFilter,
    OUT PSA_TABLE_ENTRY *ppSA,
    IN  BOOLEAN         fOutbound
    );

NTSTATUS
IPSecAllocateSPI(
    OUT tSPI            * pSpi,
    IN  PSA_TABLE_ENTRY   pSA
    );

NTSTATUS
IPSecNegotiateSA(
    IN  PFILTER         pFilter,
    IN  ULARGE_INTEGER  uliSrcDstAddr,
    IN  ULARGE_INTEGER  uliProtoSrcDstPort,
    IN  ULONG           NewMTU,
    OUT PSA_TABLE_ENTRY *ppSA,
    IN UCHAR            DestType
    );

VOID
IPSecFlushQueuedPackets(
    IN  PSA_TABLE_ENTRY         pSA,
    IN  NTSTATUS                status
    );

NTSTATUS
IPSecInsertOutboundSA(
    IN  PSA_TABLE_ENTRY         pSA,
    IN  PIPSEC_ACQUIRE_CONTEXT  pAcquireCtx,
    IN  BOOLEAN                 fTunnelFilter
    );

NTSTATUS
IPSecAddSA(
    IN  PIPSEC_ADD_SA   pAddSA,
    IN  ULONG           TotalSize
    );

NTSTATUS
IPSecUpdateSA(
    IN  PIPSEC_UPDATE_SA    pUpdateSA,
    IN  ULONG               TotalSize
    );

VOID
IPSecRefSA(
    IN  PSA_TABLE_ENTRY         pSA
    );

VOID
IPSecDerefSA(
    IN  PSA_TABLE_ENTRY         pSA
    );

VOID
IPSecStopSATimers(
    );

VOID
IPSecFlushLarvalSAList(
    );

NTSTATUS
IPSecDeleteSA(
    IN  PIPSEC_DELETE_SA    pDeleteSA
    );

NTSTATUS
IPSecExpireSA(
    IN  PIPSEC_EXPIRE_SA    pExpireSA
    );

VOID
IPSecSAExpired(
    IN	PIPSEC_TIMER	pTimer,
    IN	PVOID		Context
    );

VOID
IPSecFillSAInfo(
    IN  PSA_TABLE_ENTRY pSA,
    OUT PIPSEC_SA_INFO  pBuf
    );

NTSTATUS
IPSecEnumSAs(
    IN  PIRP    pIrp,
    OUT PULONG  pBytesCopied
    );

VOID
IPSecReaper(
    IN	PIPSEC_TIMER	pTimer,
    IN	PVOID		Context
    );

VOID
IPSecReapIdleSAs(
    );

VOID
IPSecFlushEventLog(
    IN	PIPSEC_TIMER	pTimer,
    IN	PVOID		Context
    );

NTSTATUS
IPSecQuerySpi(
    IN OUT PIPSEC_QUERY_SPI pQuerySpi
    );

NTSTATUS
IPSecSetOperationMode(
    IN PIPSEC_SET_OPERATION_MODE    pSetOperationMode
    );

NTSTATUS
IPSecInitializeTcpip(
    IN PIPSEC_SET_TCPIP_STATUS  pSetTcpipStatus
    );

NTSTATUS
IPSecDeinitializeTcpip(
    VOID
    );

NTSTATUS
IPSecSetTcpipStatus(
    IN PIPSEC_SET_TCPIP_STATUS  pSetTcpipStatus
    );

NTSTATUS
IPSecResetCacheTable(
    VOID
    );

NTSTATUS
IPSecPurgeFilterSAs(
    IN PFILTER             pFilter
    );

NTSTATUS
IPSecSetupSALifetime(
    IN  PSA_TABLE_ENTRY pSA
    );

BOOLEAN
IPSecMatchSATemplate(
    IN  PSA_TABLE_ENTRY pSA,
    IN  PIPSEC_QM_SA    pSATemplate
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\offload.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    offload.c

Abstract:

    This module contains the code that handles offload.

Author:

    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#include    "precomp.h"


VOID
IPSecFillHwAddSA(
    IN  PSA_TABLE_ENTRY pSA,
    IN  PUCHAR          Buf,
    IN  ULONG           Len
    )
/*++

Routine Description:

    Fills in the ADD_SA hw request from pSA

Arguments:

    pSA - the SA
    Buf - buffer to set info
    Len - length

Return Value:

    status of the operation

--*/
{
    POFFLOAD_IPSEC_ADD_SA           pAddSA = (POFFLOAD_IPSEC_ADD_SA)Buf;
    POFFLOAD_SECURITY_ASSOCIATION   pSAInfo;
    LONG    Index;
    ULONG   Offset = 0;

    pAddSA->NumSAs = (SHORT)pSA->sa_NumOps;
    pAddSA->SrcAddr = pSA->SA_SRC_ADDR;
    pAddSA->SrcMask = pSA->SA_SRC_MASK;
    pAddSA->DestAddr = pSA->SA_DEST_ADDR;
    pAddSA->DestMask = pSA->SA_DEST_MASK;
    pAddSA->Protocol = pSA->SA_PROTO;
    pAddSA->SrcPort = SA_SRC_PORT(pSA);
    pAddSA->DestPort = SA_DEST_PORT(pSA);

    if (pSA->sa_Flags & FLAGS_SA_OUTBOUND) {
        pAddSA->Flags |= OFFLOAD_OUTBOUND_SA;
    } else {
        pAddSA->Flags |= OFFLOAD_INBOUND_SA;
    }

    if (pSA->sa_Flags & FLAGS_SA_TUNNEL) {
        pAddSA->DestTunnelAddr = pSA->sa_TunnelAddr;
        pAddSA->SrcTunnelAddr = pSA->sa_SrcTunnelAddr;
    }

    for (Index = 0; Index < pSA->sa_NumOps; Index++) {
        pSAInfo = &pAddSA->SecAssoc[Index];

        pSAInfo->Operation = pSA->sa_Operation[Index];
        pSAInfo->SPI = pSA->sa_OtherSPIs[Index];
        pSAInfo->EXT_INT_ALGO = pSA->INT_ALGO(Index);
        pSAInfo->EXT_INT_KEYLEN = pSA->INT_KEYLEN(Index);
        pSAInfo->EXT_INT_ROUNDS = pSA->INT_ROUNDS(Index);

        pSAInfo->EXT_CONF_ALGO = pSA->CONF_ALGO(Index);
        pSAInfo->EXT_CONF_KEYLEN = pSA->CONF_KEYLEN(Index);
        pSAInfo->EXT_CONF_ROUNDS = pSA->CONF_ROUNDS(Index);

        //
        // now get the keys in
        //
        ASSERT(Len >= sizeof(OFFLOAD_IPSEC_ADD_SA) + pSA->INT_KEYLEN(Index) + pSA->CONF_KEYLEN(Index));

        RtlCopyMemory(  pAddSA->KeyMat + Offset,
                        pSA->CONF_KEY(Index),
                        pSA->CONF_KEYLEN(Index));

        RtlCopyMemory(  pAddSA->KeyMat + Offset + pSA->CONF_KEYLEN(Index),
                        pSA->INT_KEY(Index),
                        pSA->INT_KEYLEN(Index));

        Offset = pSA->INT_KEYLEN(Index) + pSA->CONF_KEYLEN(Index);
        pAddSA->KeyLen += Offset;

        IPSEC_DEBUG(HW, ("pAddSA: %lx, keylen: %lx, KeyMat: %lx\n", pAddSA, pAddSA->KeyLen, pAddSA->KeyMat));
    }
}


NDIS_STATUS
IPSecPlumbHw(
    IN  PVOID           DestIF,
    IN  PVOID           Buf,
    IN  ULONG           Len,
    IN  NDIS_OID        Oid
    )
/*++

Routine Description:

    Plumbs the input outbound and its corresponding inbound SA
    into the hw accelerator.

Arguments:

    DestIF - the IP Interface
    Buf - buffer to set info
    Len - length

Return Value:

    status of the operation

--*/
{
#if DBG
    NTSTATUS    status;

    if (Oid == OID_TCP_TASK_IPSEC_ADD_SA) {
        IPSEC_INCREMENT(NumAddSA);
    }
    if (Oid == OID_TCP_TASK_IPSEC_DELETE_SA) {
        IPSEC_INCREMENT(NumDelSA);
    }

    status = TCPIP_NDIS_REQUEST(DestIF,
                                NdisRequestSetInformation,
                                Oid,
                                Buf,
                                Len,
                                NULL);

    if (status == STATUS_SUCCESS) {
        if (Oid == OID_TCP_TASK_IPSEC_ADD_SA) {
            IPSEC_INCREMENT(NumAddSU);
        }
        if (Oid == OID_TCP_TASK_IPSEC_DELETE_SA) {
            IPSEC_INCREMENT(NumDelSU);
        }
    } else {
        if (Oid == OID_TCP_TASK_IPSEC_ADD_SA) {
            IPSEC_INCREMENT(NumAddFA);
        }
        if (Oid == OID_TCP_TASK_IPSEC_DELETE_SA) {
            IPSEC_INCREMENT(NumDelFA);
        }
    }

    return  status;
#else
    return TCPIP_NDIS_REQUEST(  DestIF,
                                NdisRequestSetInformation,
                                Oid,
                                Buf,
                                Len,
                                NULL);
#endif
}


NTSTATUS
IPSecSendOffload(
    IN  IPHeader UNALIGNED  *pIPHeader,
    IN  PNDIS_PACKET        Packet,
    IN  Interface           *DestIF,
    IN  PSA_TABLE_ENTRY     pSA,
    IN  PSA_TABLE_ENTRY     pNextSA,
    IN  PVOID               *ppSCContext,
    IN  BOOLEAN             *pfCryptoOnly
    )
{
    KIRQL                           kIrql;
    BOOLEAN                         fRefBumped = FALSE;
    NTSTATUS                        status = STATUS_UNSUCCESSFUL;
    PSA_TABLE_ENTRY                 pSaveSA = NULL;
    PIPSEC_SEND_COMPLETE_CONTEXT    pContext = NULL;
    PNDIS_IPSEC_PACKET_INFO         IPSecPktInfo = NULL;
    PNDIS_PACKET_EXTENSION          PktExt = NDIS_PACKET_EXTENSION_FROM_PACKET(Packet);

    IPSEC_DEBUG(HW, ("IPSecSendOffload: DestIF: %lx, DestIF->Flags: %lx\n", DestIF, DestIF->if_OffloadFlags));

    *pfCryptoOnly = FALSE;

    //
    // See if options are supported.
    //
    if (((pIPHeader->iph_verlen & (UCHAR)~IP_VER_FLAG) << 2) > sizeof(IPHeader) &&
        !(DestIF->if_OffloadFlags & IPSEC_OFFLOAD_V4_OPTIONS)) {
        status = STATUS_UNSUCCESSFUL;
        IPSEC_DEBUG(HW, ("Options present - not offloading the packet. HdrLen %d\n",
                    ((pIPHeader->iph_verlen & (UCHAR)~IP_VER_FLAG) << 2)));
        return (status);
    }

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    do {
        if ((pSA->sa_Flags & FLAGS_SA_HW_PLUMBED) &&
            pSA->sa_IPIF == DestIF) {

            if (*ppSCContext == NULL) {
                pContext = IPSecAllocateSendCompleteCtx(IPSEC_TAG_HW);

                if (!pContext) {
                    IPSEC_DEBUG(HW, ("Failed to alloc. SendCtx\n"));
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    IPSecFreePktInfo(IPSecPktInfo);
                    *ppSCContext = NULL;
                    break;
                }

                IPSEC_INCREMENT(g_ipsec.NumSends);

                IPSecZeroMemory(pContext, sizeof(IPSEC_SEND_COMPLETE_CONTEXT));

#if DBG
                RtlCopyMemory(pContext->Signature, "ISC5", 4);
#endif
                *ppSCContext = pContext;
            } else {
                pContext = *ppSCContext;
            }

            if (IPSecPktInfo == NULL) {
                if (IPSecPktInfo = IPSecAllocatePktInfo(IPSEC_TAG_HW_PKTINFO)) {
                    IPSecZeroMemory(IPSecPktInfo, sizeof(NDIS_IPSEC_PACKET_INFO));

                    pContext->Flags |= SCF_PKTINFO;
                    pContext->PktInfo = IPSecPktInfo;
                } else {
                    IPSEC_DEBUG(HW, ("Failed to alloc. PktInfo\n"));
                    status = STATUS_UNSUCCESSFUL;
                    break;
                }
            }

            PktExt->NdisPacketInfo[IpSecPacketInfo] = IPSecPktInfo;

            //
            // if this is the nextOperationSA
            //
            if (fRefBumped) {
                IPSEC_DEBUG(HW, ("Offloading... pSA: %lx, NextOffloadHandle %lx\n", pSA, pSA->sa_OffloadHandle));
                IPSecPktInfo->Transmit.NextOffloadHandle = pSA->sa_OffloadHandle;
            } else {
                IPSEC_DEBUG(HW, ("Offloading... pSA: %lx, OffloadHandle %lx\n", pSA, pSA->sa_OffloadHandle));
                IPSecPktInfo->Transmit.OffloadHandle = pSA->sa_OffloadHandle;
            }

            *pfCryptoOnly = TRUE;

            IPSEC_DEBUG(HW, ("Using Hw for SA->handle: %lx on IF: %lx IPSecPktInfo: %lx *pfCryptoOnly %d\n", pSA->sa_OffloadHandle, DestIF, IPSecPktInfo, *pfCryptoOnly));

            status = STATUS_SUCCESS;
        } else if (!(pSA->sa_Flags & FLAGS_SA_HW_PLUMB_FAILED) && !pSA->sa_IPIF) {
            PUCHAR  outBuf;
            ULONG   outLen;
            LONG    Index;

            pSA->sa_Flags |= FLAGS_SA_HW_PLUMB_FAILED;

            //
            // See if CryptoOnly mode is supported.
            //
            if (!(DestIF->if_OffloadFlags & IPSEC_OFFLOAD_CRYPTO_ONLY)) {
                status = STATUS_UNSUCCESSFUL;
                break;
            }

            //
            // See if transport over tunnel mode is supported.
            //
            if (pNextSA &&
                !(DestIF->if_OffloadFlags & IPSEC_OFFLOAD_TPT_TUNNEL)) {
                status = STATUS_UNSUCCESSFUL;
                break;
            }

            //
            // No need to offload soft SAs.
            //
            if (pSA->sa_Operation[0] == None) {
                status = STATUS_UNSUCCESSFUL;
                break;
            }

            //
            // Tunnel required, but not supported, don't plumb.
            //
            if ((pSA->sa_Flags & FLAGS_SA_TUNNEL) &&
                ((IS_AH_SA(pSA) &&
                  !(DestIF->if_OffloadFlags & IPSEC_OFFLOAD_AH_TUNNEL)) ||
                 (IS_ESP_SA(pSA) &&
                  !(DestIF->if_OffloadFlags & IPSEC_OFFLOAD_ESP_TUNNEL)))) {
                status = STATUS_UNSUCCESSFUL;
                break;
            }

            //
            // AH + ESP required, but not supported, don't plumb.
            //
            if (pSA->sa_NumOps > 1 &&
                !(DestIF->if_OffloadFlags & IPSEC_OFFLOAD_AH_ESP)) {
                status = STATUS_UNSUCCESSFUL;
                break;
            }

            //
            // Check XMT capabilities.
            //
            if ((IS_AH_SA(pSA) &&
                !(DestIF->if_OffloadFlags & IPSEC_OFFLOAD_AH_XMT)) ||
                (IS_ESP_SA(pSA) &&
                !(DestIF->if_OffloadFlags & IPSEC_OFFLOAD_ESP_XMT))) {
                status = STATUS_UNSUCCESSFUL;
                break;
            }

            outLen = sizeof(OFFLOAD_IPSEC_ADD_SA);

            for (Index = 0; Index < pSA->sa_NumOps; Index++) {
                //
                // Check offload capability bits with those in the SA.
                //
                if ((pSA->INT_ALGO(Index) == IPSEC_AH_MD5) &&
                    (!(DestIF->if_OffloadFlags & IPSEC_OFFLOAD_AH_MD5)) ||
                    ((pSA->INT_ALGO(Index) == IPSEC_AH_SHA) &&
                    (!(DestIF->if_OffloadFlags & IPSEC_OFFLOAD_AH_SHA_1))) ||
                    ((pSA->CONF_ALGO(Index) == IPSEC_ESP_NONE) &&
                    (!(DestIF->if_OffloadFlags & IPSEC_OFFLOAD_ESP_NONE))) ||
                    ((pSA->CONF_ALGO(Index) == IPSEC_ESP_DES) &&
                    (!(DestIF->if_OffloadFlags & IPSEC_OFFLOAD_ESP_DES))) ||
                    ((pSA->CONF_ALGO(Index) == IPSEC_ESP_3_DES) &&
                    (!(DestIF->if_OffloadFlags & IPSEC_OFFLOAD_ESP_3_DES)))) {
                    status = STATUS_UNSUCCESSFUL;
                    goto out;
                }

                outLen += pSA->INT_KEYLEN(Index) + pSA->CONF_KEYLEN(Index);
            }

            //
            // This SA can be offloaded.
            //
            pSA->sa_Flags |= FLAGS_SA_OFFLOADABLE;

            IPSEC_DEBUG(HW, ("outLen: %lx\n", outLen));

            outBuf = IPSecAllocateMemory(outLen, IPSEC_TAG_HW_ADDSA);

            if (outBuf) {
                IPSecZeroMemory(outBuf, outLen);

                IPSecFillHwAddSA(pSA, outBuf, outLen);

                //
                // Bump the SA reference count to make sure they won't 
                // go away during the processing of the work item.
                //
                IPSecRefSA(pSA);

                //
                // Plumb the SA by scheduling a work item; the SA will
                // not be used for offload until plumbing succeeds.
                //
                IPSecBufferPlumbSA( DestIF,
                                    pSA,
                                    outBuf,
                                    outLen);

                //
                // Return failure here so the caller does it in software.
                //
                status = STATUS_UNSUCCESSFUL;
                break;
            } else {
                IPSEC_DEBUG(HW, ("Memory: Failed to plumb outboundSA: %lx on IF: %lx\n", pSA, DestIF));
                status = STATUS_UNSUCCESSFUL;
                break;
            }
        } else {
            status = STATUS_UNSUCCESSFUL;
            break;
        }

        if (pNextSA && !fRefBumped) {
            IPSEC_DEBUG(HW, ("RefBumped on SA: %lx\n", pSA));
            pSaveSA = pSA;
            pSA = pNextSA;
            fRefBumped = TRUE;
        } else {
            break;
        }
    } while (TRUE);

out:
    if (status == STATUS_SUCCESS && (*pfCryptoOnly)) {
        ASSERT(pContext);
        ASSERT(pContext->Flags & SCF_PKTINFO);

        if (fRefBumped) {
            IPSecRefSA(pSaveSA);
            IPSecRefSA(pNextSA);
            IPSEC_INCREMENT(pSaveSA->sa_NumSends);
            IPSEC_INCREMENT(pNextSA->sa_NumSends);
            pContext->pSA = pSaveSA;
            pContext->pNextSA = pNextSA;
        } else {
            IPSecRefSA(pSA);
            IPSEC_INCREMENT(pSA->sa_NumSends);
            pContext->pSA = pSA;
        }
    } else {
        if (IPSecPktInfo) {
            ASSERT(pContext);
            ASSERT(pContext->Flags & SCF_PKTINFO);

            IPSecFreePktInfo(pContext->PktInfo);

            pContext->Flags &= ~SCF_PKTINFO;
            pContext->PktInfo = NULL;

            PktExt->NdisPacketInfo[IpSecPacketInfo] = NULL;
        }

        status = STATUS_UNSUCCESSFUL;
        *pfCryptoOnly = FALSE;
    }

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    return  status;
}


NTSTATUS
IPSecRecvOffload(
    IN  IPHeader UNALIGNED  *pIPHeader,
    IN  Interface           *DestIF,
    IN  PSA_TABLE_ENTRY     pSA
    )
{
    KIRQL       kIrql;
    NTSTATUS    status = STATUS_UNSUCCESSFUL;

    IPSEC_DEBUG(HW, ("IPSecRecvOffload: DestIF: %lx, DestIF->Flags: %lx\n", DestIF, DestIF->if_OffloadFlags));

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    if (!(pSA->sa_Flags & FLAGS_SA_HW_PLUMB_FAILED) &&
        !(pSA->sa_Flags & FLAGS_SA_HW_PLUMBED) &&
        !pSA->sa_IPIF) {
        PUCHAR  inBuf;
        ULONG   inLen;
        LONG    Index;

        pSA->sa_Flags |= FLAGS_SA_HW_PLUMB_FAILED;

        //
        // See if CryptoOnly mode is supported.
        //
        if (!(DestIF->if_OffloadFlags & IPSEC_OFFLOAD_CRYPTO_ONLY)) {
            status = STATUS_UNSUCCESSFUL;
            goto out;
        }

        //
        // No need to offload soft SAs.
        //
        if (pSA->sa_Operation[0] == None) {
            status = STATUS_UNSUCCESSFUL;
            goto out;
        }

        //
        // Tunnel required, but not supported, don't plumb.
        //
        if ((pSA->sa_Flags & FLAGS_SA_TUNNEL) &&
            ((IS_AH_SA(pSA) &&
              !(DestIF->if_OffloadFlags & IPSEC_OFFLOAD_AH_TUNNEL)) ||
             (IS_ESP_SA(pSA) &&
              !(DestIF->if_OffloadFlags & IPSEC_OFFLOAD_ESP_TUNNEL)))) {
            status = STATUS_UNSUCCESSFUL;
            goto out;
        }

        //
        // AH + ESP required, but not supported, don't plumb.
        //
        if (pSA->sa_NumOps > 1 &&
            !(DestIF->if_OffloadFlags & IPSEC_OFFLOAD_AH_ESP)) {
            status = STATUS_UNSUCCESSFUL;
            goto out;
        }

        //
        // Check RCV capabilities.
        //
        if ((IS_AH_SA(pSA) &&
            !(DestIF->if_OffloadFlags & IPSEC_OFFLOAD_AH_RCV)) ||
            (IS_ESP_SA(pSA) &&
            !(DestIF->if_OffloadFlags & IPSEC_OFFLOAD_ESP_RCV))) {
            status = STATUS_UNSUCCESSFUL;
            goto out;
        }

        inLen = sizeof(OFFLOAD_IPSEC_ADD_SA);

        for (Index = 0; Index < pSA->sa_NumOps; Index++) {
            //
            // Check offload capability bits with those in the SA
            //
            if ((pSA->INT_ALGO(Index) == IPSEC_AH_MD5) &&
                (!(DestIF->if_OffloadFlags & IPSEC_OFFLOAD_AH_MD5)) ||
                ((pSA->INT_ALGO(Index) == IPSEC_AH_SHA) &&
                (!(DestIF->if_OffloadFlags & IPSEC_OFFLOAD_AH_SHA_1))) ||
                ((pSA->CONF_ALGO(Index) == IPSEC_ESP_NONE) &&
                (!(DestIF->if_OffloadFlags & IPSEC_OFFLOAD_ESP_NONE))) ||
                ((pSA->CONF_ALGO(Index) == IPSEC_ESP_DES) &&
                (!(DestIF->if_OffloadFlags & IPSEC_OFFLOAD_ESP_DES))) ||
                ((pSA->CONF_ALGO(Index) == IPSEC_ESP_3_DES) &&
                (!(DestIF->if_OffloadFlags & IPSEC_OFFLOAD_ESP_3_DES)))) {
                status = STATUS_UNSUCCESSFUL;
                goto out;
            }

            inLen += pSA->INT_KEYLEN(Index) + pSA->CONF_KEYLEN(Index);
        }

        IPSEC_DEBUG(HW, ("inLen: %lx\n", inLen));

        inBuf = IPSecAllocateMemory(inLen, IPSEC_TAG_HW_ADDSA);

        if (inBuf) {
            IPSecZeroMemory(inBuf, inLen);

            IPSecFillHwAddSA(pSA, inBuf, inLen);

            //
            // Bump the SA reference count to make sure they won't 
            // go away during the processing of the work item.
            //
            IPSecRefSA(pSA);

            //
            // Plumb the SA by scheduling a work item; the SA will
            // not be used for offload until plumbing succeeds.
            //
            status = IPSecBufferPlumbSA(DestIF,
                                        pSA,
                                        inBuf,
                                        inLen);

            //
            // Return failure here so the caller does it in software.
            //
            status = STATUS_UNSUCCESSFUL;
            goto out;
        } else {
            IPSEC_DEBUG(HW, ("Memory: Failed to plumb inboundSA: %lx on IF: %lx\n", pSA, DestIF));
            status = STATUS_UNSUCCESSFUL;
            goto out;
        }
    }

out:
    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    return  status;
}


NTSTATUS
IPSecDelHWSA(
    IN  PSA_TABLE_ENTRY pSA
    )
{
    NTSTATUS    status = STATUS_SUCCESS;

    ASSERT(pSA->sa_Flags & FLAGS_SA_HW_PLUMBED);

    pSA->sa_Flags &= ~FLAGS_SA_HW_PLUMBED;
    pSA->sa_Flags |= FLAGS_SA_HW_PLUMB_FAILED;

    if ((pSA->sa_Flags & FLAGS_SA_OUTBOUND) &&
        IPSEC_GET_VALUE(pSA->sa_NumSends) > 0) {
        pSA->sa_Flags |= FLAGS_SA_HW_DELETE_SA;
        return  STATUS_PENDING;
    }

    pSA->sa_Flags &= ~FLAGS_SA_HW_DELETE_SA;
    pSA->sa_Flags |= FLAGS_SA_HW_DELETE_QUEUED;

    ASSERT(pSA->sa_IPIF);

    if (pSA->sa_IPIF) {
        status = IPSecPlumbHw(  pSA->sa_IPIF,
                                &pSA->sa_OffloadHandle,
                                sizeof(OFFLOAD_IPSEC_DELETE_SA),
                                OID_TCP_TASK_IPSEC_DELETE_SA);

        IPSEC_DEBUG(HWAPI, ("DelHWSA %s: %lx, handle: %lx, status: %lx\n",
                    (pSA->sa_Flags & FLAGS_SA_OUTBOUND)? "outbound": "inbound",
                    pSA,
                    pSA->sa_OffloadHandle,
                    status));

        IPSEC_DEC_STATISTIC(dwNumOffloadedSAs);

        IPSecDerefSA(pSA);
    }

    return status;
}


NTSTATUS
IPSecDelHWSAAtDpc(
    IN  PSA_TABLE_ENTRY pSA
    )
{
    ASSERT(pSA->sa_Flags & (FLAGS_SA_HW_PLUMBED | FLAGS_SA_HW_DELETE_SA));

    pSA->sa_Flags &= ~FLAGS_SA_HW_PLUMBED;
    pSA->sa_Flags |= FLAGS_SA_HW_PLUMB_FAILED;

    if ((pSA->sa_Flags & FLAGS_SA_OUTBOUND) &&
        IPSEC_GET_VALUE(pSA->sa_NumSends) > 0) {
        pSA->sa_Flags |= FLAGS_SA_HW_DELETE_SA;
        return  STATUS_PENDING;
    }

    pSA->sa_Flags &= ~FLAGS_SA_HW_DELETE_SA;
    pSA->sa_Flags |= FLAGS_SA_HW_DELETE_QUEUED;

    ASSERT(pSA->sa_IPIF);

    ExInitializeWorkItem(   &pSA->sa_QueueItem,
                            IPSecProcessDeleteSA,
                            (PVOID)pSA);

    ExQueueWorkItem(&pSA->sa_QueueItem, DelayedWorkQueue);
    
    IPSEC_INCREMENT(g_ipsec.NumWorkers);

    return STATUS_SUCCESS;
}


NTSTATUS
IPSecBufferPlumbSA(
    IN  Interface       *DestIF,
    IN  PSA_TABLE_ENTRY pSA,
    IN  PUCHAR          Buf,
    IN  ULONG           Len
    )
{
    PIPSEC_PLUMB_SA pPlumbSA;

    pPlumbSA = IPSecAllocateMemory(sizeof(IPSEC_PLUMB_SA), IPSEC_TAG_HW_PLUMB);
    if (pPlumbSA == NULL) {
        IPSecFreeMemory(Buf);

        if (pSA) {
            IPSecDerefSA(pSA);
        }

        return  STATUS_INSUFFICIENT_RESOURCES;
    }

    pPlumbSA->pSA = pSA;
    pPlumbSA->DestIF = DestIF;
    pPlumbSA->Buf = Buf;
    pPlumbSA->Len = Len;

    ExInitializeWorkItem(   &pPlumbSA->PlumbQueueItem,
                            IPSecProcessPlumbSA,
                            (PVOID)pPlumbSA);

    ExQueueWorkItem(&pPlumbSA->PlumbQueueItem, DelayedWorkQueue);
    
    IPSEC_INCREMENT(g_ipsec.NumWorkers);

    return STATUS_SUCCESS;
}


NTSTATUS
IPSecProcessPlumbSA(
    IN  PVOID   Context
    )
{
    PIPSEC_PLUMB_SA pPlumbSA = (PIPSEC_PLUMB_SA)Context;
    NTSTATUS        status = STATUS_SUCCESS;
    KIRQL           kIrql;
    Interface       *DestIF = pPlumbSA->DestIF;
    PSA_TABLE_ENTRY pSA = pPlumbSA->pSA;
    PUCHAR          Buf = pPlumbSA->Buf;
    ULONG           Len = pPlumbSA->Len;

    //
    // Plumb this SA into the hw if acceleration is enabled
    // on this card and it has not been plumbed already.
    //
    if (pSA) {
        IPSEC_DEBUG(HW, ("About to plumb outbound\n"));

        status = IPSecPlumbHw(  DestIF,
                                Buf,
                                Len,
                                OID_TCP_TASK_IPSEC_ADD_SA);

        IPSEC_DEBUG(HWAPI, ("AddHWSA %s: %lx, handle: %lx, status: %lx\n",
                    (pSA->sa_Flags & FLAGS_SA_OUTBOUND)? "outbound": "inbound",
                    pSA,
                    ((POFFLOAD_IPSEC_ADD_SA)Buf)->OffloadHandle,
                    status));

        AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

        pSA->sa_IPIF = DestIF;

        if (status != STATUS_SUCCESS) {
            IPSEC_DEBUG(HW, ("Failed to plumb SA: %lx on IF: %lx, status: %lx\n", pSA, DestIF, status));
            pSA->sa_Flags |= FLAGS_SA_HW_PLUMB_FAILED;
            IPSecDerefSA(pSA);
        } else {
            pSA->sa_OffloadHandle = ((POFFLOAD_IPSEC_ADD_SA)Buf)->OffloadHandle;

            IPSEC_DEBUG(HW, ("Success plumb SA: %lx, pSA->sa_OffloadHandle %lx\n", pSA, pSA->sa_OffloadHandle));

            pSA->sa_Flags |= FLAGS_SA_HW_PLUMBED;
            pSA->sa_Flags &= ~FLAGS_SA_HW_PLUMB_FAILED;

            IPSEC_INC_STATISTIC(dwNumOffloadedSAs);
        }

        if (status == STATUS_SUCCESS &&
            !(pSA->sa_State == STATE_SA_ACTIVE &&
             (pSA->sa_Flags & FLAGS_SA_ON_FILTER_LIST) &&
             pSA->sa_AssociatedSA)) {
            //
            // SA got deleted before we plumb, call DelHWSA now since
            // HW_PLUMBED wasn't set when the SA was deleted.
            //
            IPSecDelHWSAAtDpc(pSA);
        }

        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
    }

    IPSecFreeMemory(Buf);
    IPSecFreeMemory(pPlumbSA);

    IPSEC_DECREMENT(g_ipsec.NumWorkers);

    return status;
}


NTSTATUS
IPSecProcessDeleteSA(
    IN  PVOID   Context
    )
{
    PSA_TABLE_ENTRY pSA = (PSA_TABLE_ENTRY)Context;
    NTSTATUS        status;

    ASSERT(IPSEC_GET_VALUE(pSA->sa_NumSends) == 0);

    status = IPSecPlumbHw(  pSA->sa_IPIF,
                            &pSA->sa_OffloadHandle,
                            sizeof(OFFLOAD_IPSEC_DELETE_SA),
                            OID_TCP_TASK_IPSEC_DELETE_SA);

    IPSEC_DEBUG(HWAPI, ("ProcessDeleteSA %s: %lx, handle: %lx, status: %lx\n",
                (pSA->sa_Flags & FLAGS_SA_OUTBOUND)? "outbound": "inbound",
                pSA,
                pSA->sa_OffloadHandle,
                status));

    IPSEC_DEC_STATISTIC(dwNumOffloadedSAs);

    IPSecDerefSA(pSA);

    IPSEC_DECREMENT(g_ipsec.NumWorkers);

    return status;
}


NTSTATUS
IPSecNdisStatus(
    IN  PVOID       IPContext,
    IN  UINT        Status
    )
/*++

Routine Description:

    Notify Interface has a NDIS status change.

Arguments:

    IPContext   - This is the Interface notified of status change.

Return Value:

--*/
{
    IPSEC_DEBUG(HWAPI, ("IPSecNdisStatus %lx called for interface %lx\n", Status, IPContext));

    switch (Status) {
        case NDIS_STATUS_NETWORK_UNREACHABLE:
            IPSecDeleteIF(IPContext);
            break;

        case NDIS_STATUS_RESET_START:
            IPSecResetStart(IPContext);
            break;

        case NDIS_STATUS_RESET_END:
            IPSecResetEnd(IPContext);
            break;

        case NDIS_STATUS_INTERFACE_UP:
            IPSecWakeUp(IPContext);
            break;

        default:
            ASSERT(FALSE);
            break;
    }

    return  STATUS_SUCCESS;
}


VOID
IPSecDeleteIF(
    IN  PVOID       IPContext
    )
/*++

Routine Description:

    Notify Interface is deleted so need to clean up SA's that are offloaded
    on the deleted interface.

Arguments:

    IPContext   - This is the Interface being deleted.

Return Value:

--*/
{
    Interface       *DestIF = (Interface *)IPContext;
    PLIST_ENTRY     pFilterEntry;
    PLIST_ENTRY     pSAEntry;
    PFILTER         pFilter;
    PSA_TABLE_ENTRY pSA;
    KIRQL           kIrql;
    LONG            Index;
    LONG            SAIndex;

    IPSEC_DEBUG(HWAPI, ("IPSecDeleteIF called for interface %lx\n", DestIF));

    //
    // Go through all SA's and unmark the offload bits.
    //
    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    for (   Index = MIN_FILTER;
            Index <= MAX_FILTER;
            Index++) {

        for (   pFilterEntry = g_ipsec.FilterList[Index].Flink;
                pFilterEntry != &g_ipsec.FilterList[Index];
                pFilterEntry = pFilterEntry->Flink) {

            pFilter = CONTAINING_RECORD(pFilterEntry,
                                        FILTER,
                                        MaskedLinkage);

            for (   SAIndex = 0;
                    SAIndex < pFilter->SAChainSize;
                    SAIndex++) {

                for (   pSAEntry = pFilter->SAChain[SAIndex].Flink;
                        pSAEntry != &pFilter->SAChain[SAIndex];
                        pSAEntry = pSAEntry->Flink) {

                    pSA = CONTAINING_RECORD(pSAEntry,
                                            SA_TABLE_ENTRY,
                                            sa_FilterLinkage);

                    if ((pSA->sa_Flags & FLAGS_SA_HW_PLUMBED) &&
                        (DestIF == pSA->sa_IPIF)) {

                        pSA->sa_Flags &= ~FLAGS_SA_HW_PLUMBED;
                        pSA->sa_Flags |= FLAGS_SA_HW_PLUMB_FAILED;
                        pSA->sa_Flags &= ~FLAGS_SA_HW_DELETE_SA;

                        IPSEC_DEC_STATISTIC(dwNumOffloadedSAs);

#if DBG
                        NumReset++;
#endif

                        IPSecDerefSA(pSA);
                    }
                }
            }
        }
    }

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
}


VOID
IPSecResetStart(
    IN  PVOID       IPContext
    )
/*++

Routine Description:

    Notify Interface is being reset.

Arguments:

    IPContext   - This is the Interface being reset.

Return Value:

--*/
{
    Interface       *DestIF = (Interface *)IPContext;
    PLIST_ENTRY     pFilterEntry;
    PLIST_ENTRY     pSAEntry;
    PFILTER         pFilter;
    PSA_TABLE_ENTRY pSA;
    KIRQL           kIrql;
    LONG            Index;
    LONG            SAIndex;

    IPSEC_DEBUG(HWAPI, ("IPSecResetStart called for interface %lx\n", DestIF));

    //
    // Go through all SA's and unmark the offload bits.
    //
    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    for (   Index = MIN_FILTER;
            Index <= MAX_FILTER;
            Index++) {

        for (   pFilterEntry = g_ipsec.FilterList[Index].Flink;
                pFilterEntry != &g_ipsec.FilterList[Index];
                pFilterEntry = pFilterEntry->Flink) {

            pFilter = CONTAINING_RECORD(pFilterEntry,
                                        FILTER,
                                        MaskedLinkage);

            for (   SAIndex = 0;
                    SAIndex < pFilter->SAChainSize;
                    SAIndex++) {

                for (   pSAEntry = pFilter->SAChain[SAIndex].Flink;
                        pSAEntry != &pFilter->SAChain[SAIndex];
                        pSAEntry = pSAEntry->Flink) {

                    pSA = CONTAINING_RECORD(pSAEntry,
                                            SA_TABLE_ENTRY,
                                            sa_FilterLinkage);

                    if ((pSA->sa_Flags & FLAGS_SA_HW_PLUMBED) &&
                        (DestIF == pSA->sa_IPIF)) {

                        pSA->sa_Flags &= ~FLAGS_SA_HW_PLUMBED;
                        pSA->sa_Flags |= FLAGS_SA_HW_PLUMB_FAILED;
                        pSA->sa_Flags &= ~FLAGS_SA_HW_DELETE_SA;
                        pSA->sa_Flags |= FLAGS_SA_HW_RESET;

                        IPSEC_DEC_STATISTIC(dwNumOffloadedSAs);

#if DBG
                        NumReset++;
#endif

                        IPSecDerefSA(pSA);
                    }
                }
            }
        }
    }

    IPSecNumResets++;

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
}


VOID
IPSecResetEnd(
    IN  PVOID       IPContext
    )
/*++

Routine Description:

    Notify Interface reset is completed.

Arguments:

    IPContext   - This is the Interface being reset.

Return Value:

--*/
{
    Interface       *DestIF = (Interface *)IPContext;
    PLIST_ENTRY     pFilterEntry;
    PLIST_ENTRY     pSAEntry;
    PFILTER         pFilter;
    PSA_TABLE_ENTRY pSA;
    KIRQL           kIrql;
    LONG            Index;
    LONG            SAIndex;

    IPSEC_DEBUG(HWAPI, ("IPSecResetEnd called for interface %lx\n", DestIF));

    //
    // Go through all SA's and unmark the offload bits.
    //
    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    for (   Index = MIN_FILTER;
            Index <= MAX_FILTER;
            Index++) {

        for (   pFilterEntry = g_ipsec.FilterList[Index].Flink;
                pFilterEntry != &g_ipsec.FilterList[Index];
                pFilterEntry = pFilterEntry->Flink) {

            pFilter = CONTAINING_RECORD(pFilterEntry,
                                        FILTER,
                                        MaskedLinkage);

            for (   SAIndex = 0;
                    SAIndex < pFilter->SAChainSize;
                    SAIndex++) {

                for (   pSAEntry = pFilter->SAChain[SAIndex].Flink;
                        pSAEntry != &pFilter->SAChain[SAIndex];
                        pSAEntry = pSAEntry->Flink) {

                    pSA = CONTAINING_RECORD(pSAEntry,
                                            SA_TABLE_ENTRY,
                                            sa_FilterLinkage);

                    if ((pSA->sa_Flags & FLAGS_SA_HW_PLUMB_FAILED) &&
                        !(pSA->sa_Flags & FLAGS_SA_HW_DELETE_QUEUED) &&
                        (DestIF == pSA->sa_IPIF)) {

                        pSA->sa_Flags &= ~FLAGS_SA_HW_PLUMB_FAILED;
                        pSA->sa_IPIF = NULL;
                    }
                }
            }
        }
    }

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
}


VOID
IPSecWakeUp(
    IN  PVOID       IPContext
    )
/*++

Routine Description:

    Notify Interface has waken up from hibernate.

Arguments:

    IPContext   - This is the Interface that wakes up.

Return Value:

--*/
{
    Interface       *DestIF = (Interface *)IPContext;
    PLIST_ENTRY     pFilterEntry;
    PLIST_ENTRY     pSAEntry;
    PFILTER         pFilter;
    PSA_TABLE_ENTRY pSA;
    KIRQL           kIrql;
    LONG            Index;
    LONG            SAIndex;

    IPSEC_DEBUG(HWAPI, ("IPSecWakeUp called for interface %lx\n", DestIF));

    //
    // Go through all SA's and unmark the offload bits.
    //
    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    for (   Index = MIN_FILTER;
            Index <= MAX_FILTER;
            Index++) {

        for (   pFilterEntry = g_ipsec.FilterList[Index].Flink;
                pFilterEntry != &g_ipsec.FilterList[Index];
                pFilterEntry = pFilterEntry->Flink) {

            pFilter = CONTAINING_RECORD(pFilterEntry,
                                        FILTER,
                                        MaskedLinkage);

            for (   SAIndex = 0;
                    SAIndex < pFilter->SAChainSize;
                    SAIndex++) {

                for (   pSAEntry = pFilter->SAChain[SAIndex].Flink;
                        pSAEntry != &pFilter->SAChain[SAIndex];
                        pSAEntry = pSAEntry->Flink) {

                    pSA = CONTAINING_RECORD(pSAEntry,
                                            SA_TABLE_ENTRY,
                                            sa_FilterLinkage);

                    if ((pSA->sa_Flags & FLAGS_SA_HW_PLUMBED) &&
                        (DestIF == pSA->sa_IPIF)) {

                        pSA->sa_Flags &= ~FLAGS_SA_HW_PLUMBED;
                        pSA->sa_IPIF = NULL;
                        pSA->sa_Flags |= FLAGS_SA_HIBERNATED;

                        IPSEC_DEC_STATISTIC(dwNumOffloadedSAs);

                        IPSecDerefSA(pSA);
                    }
                }
            }
        }
    }

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
}


VOID
IPSecBufferOffloadEvent(
    IN  IPHeader UNALIGNED      *pIPH,
    IN  PNDIS_IPSEC_PACKET_INFO IPSecPktInfo
    )
/*++

Routine Description:

    Log an event for offload failures.

Arguments:

    pIPH            - The IP header of the problem packet.
    IPSecPktInfo    - The per-packet IPSec offload info.

Return Value:

    None

--*/
{
    switch (IPSecPktInfo->Receive.CryptoStatus) {
        case CRYPTO_TRANSPORT_AH_AUTH_FAILED:
            IPSEC_INC_STATISTIC(dwNumPacketsNotAuthenticated);
            IPSecBufferEvent(   pIPH->iph_src,
                                EVENT_IPSEC_AUTH_FAILURE,
                                3,
                                TRUE);
            break;

        case CRYPTO_TRANSPORT_ESP_AUTH_FAILED:
            IPSEC_INC_STATISTIC(dwNumPacketsNotAuthenticated);
            IPSecBufferEvent(   pIPH->iph_src,
                                EVENT_IPSEC_AUTH_FAILURE,
                                4,
                                TRUE);
            break;

        case CRYPTO_TUNNEL_AH_AUTH_FAILED:
            IPSEC_INC_STATISTIC(dwNumPacketsNotAuthenticated);
            IPSecBufferEvent(   pIPH->iph_src,
                                EVENT_IPSEC_AUTH_FAILURE,
                                5,
                                TRUE);
            break;

        case CRYPTO_TUNNEL_ESP_AUTH_FAILED:
            IPSEC_INC_STATISTIC(dwNumPacketsNotAuthenticated);
            IPSecBufferEvent(   pIPH->iph_src,
                                EVENT_IPSEC_AUTH_FAILURE,
                                6,
                                TRUE);
            break;

        case CRYPTO_INVALID_PACKET_SYNTAX:
            IPSecBufferEvent(   pIPH->iph_src,
                                EVENT_IPSEC_BAD_PACKET_SYNTAX,
                                1,
                                TRUE);
            break;

        case CRYPTO_INVALID_PROTOCOL:
            IPSecBufferEvent(   pIPH->iph_src,
                                EVENT_IPSEC_BAD_PROTOCOL_RECEIVED,
                                3,
                                TRUE);
            break;

        case CRYPTO_GENERIC_ERROR:
        default:
            IPSecBufferEvent(   pIPH->iph_src,
                                EVENT_IPSEC_GENERIC_FAILURE,
                                1,
                                TRUE);
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\offload.h ===
VOID
IPSecFillHwAddSA(
    IN  PSA_TABLE_ENTRY pSA,
    IN  PUCHAR          Buf,
    IN  ULONG           Len
    );

NDIS_STATUS
IPSecPlumbHw(
    IN  PVOID           DestIF,
    IN  PVOID           Buf,
    IN  ULONG           Len,
    IN  NDIS_OID        Oid
    );

NTSTATUS
IPSecSendOffload(
    IN  IPHeader UNALIGNED  *pIPHeader,
    IN  PNDIS_PACKET        Packet,
    IN  Interface           *DestIF,
    IN  PSA_TABLE_ENTRY     pSA,
    IN  PSA_TABLE_ENTRY     pNextSA,
    IN  PVOID               *ppSCContext,
    IN  BOOLEAN             *pfCryptoOnly
    );

NTSTATUS
IPSecRecvOffload(
    IN  IPHeader UNALIGNED  *pIPHeader,
    IN  Interface           *DestIF,
    IN  PSA_TABLE_ENTRY     pSA
    );

NTSTATUS
IPSecDelHWSA(
    IN  PSA_TABLE_ENTRY pSA
    );

NTSTATUS
IPSecDelHWSAAtDpc(
    IN  PSA_TABLE_ENTRY pSA
    );

NTSTATUS
IPSecBufferPlumbSA(
    IN  Interface       *DestIF,
    IN  PSA_TABLE_ENTRY pSA,
    IN  PUCHAR          Buf,
    IN  ULONG           Len
    );

NTSTATUS
IPSecProcessPlumbSA(
    IN  PVOID   Context
    );

NTSTATUS
IPSecProcessDeleteSA(
    IN  PVOID   Context
    );

NTSTATUS
IPSecNdisStatus(
    IN  PVOID       IPContext,
    IN  UINT        Status
    );

VOID
IPSecDeleteIF(
    IN  PVOID       IPContext
    );

VOID
IPSecResetStart(
    IN  PVOID       IPContext
    );

VOID
IPSecResetEnd(
    IN  PVOID       IPContext
    );

VOID
IPSecWakeUp(
    IN  PVOID       IPContext
    );

VOID
IPSecBufferOffloadEvent(
    IN  IPHeader UNALIGNED      *pIPH,
    IN  PNDIS_IPSEC_PACKET_INFO IPSecPktInfo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\precomp.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Precompilation header file for IPSEC

Author:

    ChunYe

Revision History:

--*/


#include <ntosp.h>

#include <tcpipbase.h>

#if GPC
#include <gpcifc.h>
#endif

#include <ipfilter.h>
#include <ipinfo.h>
#include <llinfo.h>
#include <llipif.h>
#include <ffp.h>
#include <ipinit.h>
#include <ipdef.h>
#include <ntddtcp.h>

#if FIPS
#include <fipsapi.h>
#endif

#include "windef.h"
#include <zwapi.h>
#include "align.h"

#include <des.h>
#include <md5.h>
#include <modes.h>
#include <ntddksec.h>
#include <randlib.h>
#include <rc4.h>
#include <sha.h>
#include <tripldes.h>

#include "ipsec.h"
#include "debug.h"
#include "timer.h"
#include "locks.h"
#include "globals.h"
#include "ah.h"
#include "esp.h"
#include "externs.h"
#include "ahxforms.h"
#include "filter.h"
#include "acquire.h"
#include "intirspn.h"
#include "driver.h"
#include "saapi.h"
#include "ipseceng.h"
#include "gpc.h"
#include "offload.h"
#include "hughes.h"
#include "macros.h"
#include "iperrs.h"
#include "ipsecshr.h"


#define BAIL_ON_NTSTATUS_ERROR(ntStatus) \
    if (!NT_SUCCESS(ntStatus)) {         \
        goto error;                      \
    }

#define BAIL_ON_LOCK_NTSTATUS_ERROR(ntStatus) \
    if (!NT_SUCCESS(ntStatus)) {              \
        goto lock;                            \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\timer.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    timer.c

Abstract:

    Contains timer management structures.

Author:

    Sanjay Anand (SanjayAn) 26-May-1997
    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#include "precomp.h"


#pragma hdrstop


BOOLEAN
IPSecInitTimer()
/*++

Routine Description:

    Initialize the timer structures.

Arguments:

    None

Return Value:

    None

--*/
{
    PIPSEC_TIMER_LIST   pTimerList;
    LONG                i;

    INIT_LOCK(&g_ipsec.TimerLock);

    //
    // Allocate timer structures
    //
    for (i = 0; i < IPSEC_CLASS_MAX; i++) {
        pTimerList = &(g_ipsec.TimerList[i]);
#if DBG
        pTimerList->atl_sig = atl_signature;
#endif

        pTimerList->pTimers = IPSecAllocateMemory(
                                sizeof(IPSEC_TIMER) * IPSecTimerListSize[i],
                                IPSEC_TAG_TIMER);

        if (pTimerList->pTimers == NULL_PIPSEC_TIMER) {
            while (--i >= 0) {
                pTimerList = &(g_ipsec.TimerList[i]);
                IPSecFreeMemory(pTimerList->pTimers);
            }

            return FALSE;
        }
    }

    //
    // Initialize timer wheels.
    //
    for (i = 0; i < IPSEC_CLASS_MAX; i++) {
        pTimerList = &(g_ipsec.TimerList[i]);

        IPSecZeroMemory(pTimerList->pTimers,
                        sizeof(IPSEC_TIMER) * IPSecTimerListSize[i]);

        pTimerList->MaxTimer = IPSecMaxTimerValue[i];
        pTimerList->TimerPeriod = IPSecTimerPeriod[i];
        pTimerList->TimerListSize = IPSecTimerListSize[i];

        IPSEC_INIT_SYSTEM_TIMER(
                    &(pTimerList->NdisTimer),
                    IPSecTickHandler,
                    (PVOID)pTimerList);
    }

    return TRUE;
}


VOID
IPSecStartTimer(
    IN  PIPSEC_TIMER            pTimer,
    IN  IPSEC_TIMEOUT_HANDLER   TimeoutHandler,
    IN  ULONG                   SecondsToGo,
    IN  PVOID                   Context
    )
/*++

Routine Description:

    Start an IPSEC timer. Based on the length (SecondsToGo) of the
    timer, we decide on whether to insert it in the short duration
    timer list or in the long duration timer list in the Interface
    structure.

    NOTE: the caller is assumed to either hold a lock to the structure
    that contains the timer, or ensure that it is safe to access the
    timer structure.

Arguments:

    pTimer          - Pointer to IPSEC Timer structure
    TimeoutHandler  - Handler function to be called if this timer expires
    SecondsToGo     - When does this timer go off?
    Context         - To be passed to timeout handler if this timer expires

Return Value:

    None

--*/
{
    PIPSEC_TIMER_LIST   pTimerList;         // List to which this timer goes
    PIPSEC_TIMER        pTimerListHead;     // Head of above list
    ULONG               Index;              // Into timer wheel
    ULONG               TicksToGo = 1;
    KIRQL               kIrql;
    INT                 i;

    IPSEC_DEBUG(TIMER,
                ("StartTimer: Secs %d, Handler 0x%x, Ctxt 0x%x, pTimer 0x%x\n",
                SecondsToGo, TimeoutHandler, Context, pTimer));

    if (IPSEC_IS_TIMER_ACTIVE(pTimer)) {
        IPSEC_DEBUG(TIMER,
                    ("Start timer: pTimer 0x%x: is active (list 0x%x, hnd 0x%x), stopping it\n",
                    pTimer, pTimer->pTimerList, pTimer->TimeoutHandler));

        if (!IPSecStopTimer(pTimer)) {
            IPSEC_DEBUG(TIMER, ("Couldnt stop prev timer - bail\n"));
            return;
        }
    }

    ACQUIRE_LOCK(&g_ipsec.TimerLock, &kIrql);

    ASSERT(!IPSEC_IS_TIMER_ACTIVE(pTimer));

    //
    // Find the list to which this timer should go, and the
    // offset (TicksToGo)
    //
    for (i = 0; i < IPSEC_CLASS_MAX; i++) {
        pTimerList = &(g_ipsec.TimerList[i]);
        if (SecondsToGo < pTimerList->MaxTimer) {
            //
            // Found it.
            //
            TicksToGo = SecondsToGo / (pTimerList->TimerPeriod);
            break;
        }
    }
    
    //
    // Find the position in the list for this timer
    //
    Index = pTimerList->CurrentTick + TicksToGo;
    if (Index >= pTimerList->TimerListSize) {
        Index -= pTimerList->TimerListSize;
    }

    ASSERT(Index < pTimerList->TimerListSize);

    pTimerListHead = &(pTimerList->pTimers[Index]);

    //
    // Fill in the timer
    //
    pTimer->pTimerList = pTimerList;
    pTimer->LastRefreshTime = pTimerList->CurrentTick;
    pTimer->Duration = TicksToGo;
    pTimer->TimeoutHandler = TimeoutHandler;
    pTimer->Context = Context;

    //
    // Insert this timer in the "ticking" list
    //
    pTimer->pPrevTimer = pTimerListHead;
    pTimer->pNextTimer = pTimerListHead->pNextTimer;
    if (pTimer->pNextTimer != NULL_PIPSEC_TIMER) {
        pTimer->pNextTimer->pPrevTimer = pTimer;
    }

    pTimerListHead->pNextTimer = pTimer;

    //
    // Start off the system tick timer if necessary.
    //
    pTimerList->TimerCount++;
    if (pTimerList->TimerCount == 1) {
        IPSEC_DEBUG(TIMER,
                    ("StartTimer: Starting system timer 0x%x, class %d\n",
                    &(pTimerList->NdisTimer), i));

        IPSEC_START_SYSTEM_TIMER(&(pTimerList->NdisTimer), pTimerList->TimerPeriod);
    }

    RELEASE_LOCK(&g_ipsec.TimerLock, kIrql);

    //
    // We're done
    //
    IPSEC_DEBUG(TIMER,
                ("Started timer 0x%x, Secs %d, Index %d, Head 0x%x\n",
                pTimer,                
                SecondsToGo,
                Index,
                pTimerListHead));

    IPSEC_INCREMENT(g_ipsec.NumTimers);

    return;
}


BOOLEAN
IPSecStopTimer(
    IN  PIPSEC_TIMER    pTimer
    )
/*++

Routine Description:

    Stop an IPSEC timer, if it is running. We remove this timer from
    the active timer list and mark it so that we know it's not running.

    NOTE: the caller is assumed to either hold a lock to the structure
    that contains the timer, or ensure that it is safe to access the
    timer structure.

    SIDE EFFECT: If we happen to stop the last timer (of this "duration") on
    the Interface, we also stop the appropriate Tick function.

Arguments:

    pTimer  - Pointer to IPSEC Timer structure

Return Value:

    TRUE if the timer was running, FALSE otherwise.

--*/
{
    PIPSEC_TIMER_LIST   pTimerList; // Timer List to which this timer belongs
    BOOLEAN             WasRunning;
    KIRQL               kIrql;

    IPSEC_DEBUG(TIMER,
                ("Stopping Timer 0x%x, List 0x%x, Prev 0x%x, Next 0x%x\n",
                pTimer,
                pTimer->pTimerList,
                pTimer->pPrevTimer,
                pTimer->pNextTimer));

    ACQUIRE_LOCK(&g_ipsec.TimerLock, &kIrql);

    if (IPSEC_IS_TIMER_ACTIVE(pTimer)) {
        WasRunning = TRUE;

        //
        // Unlink timer from the list
        //
        ASSERT(pTimer->pPrevTimer); // the list head always exists

        if (pTimer->pPrevTimer) {
            pTimer->pPrevTimer->pNextTimer = pTimer->pNextTimer;
        }

        if (pTimer->pNextTimer) {
            pTimer->pNextTimer->pPrevTimer = pTimer->pPrevTimer;
        }

        pTimer->pNextTimer = pTimer->pPrevTimer = NULL_PIPSEC_TIMER;

        //
        // Update timer count on Interface, for this class of timers
        //
        pTimerList = pTimer->pTimerList;
        pTimerList->TimerCount--;

        //
        // If all timers of this class are gone, stop the system tick timer
        // for this class
        //
        if (pTimerList->TimerCount == 0) {
            IPSEC_DEBUG(TIMER, ("Stopping system timer 0x%x, List 0x%x\n",
                        &(pTimerList->NdisTimer),
                        pTimerList));

            pTimerList->CurrentTick = 0;
            IPSEC_STOP_SYSTEM_TIMER(&(pTimerList->NdisTimer));
        }

        //
        // Mark stopped timer as not active
        //
        pTimer->pTimerList = (PIPSEC_TIMER_LIST)NULL;

        IPSEC_DECREMENT(g_ipsec.NumTimers);
    } else {
        WasRunning = FALSE;
    }

    RELEASE_LOCK(&g_ipsec.TimerLock, kIrql);

    return  WasRunning;
}


VOID
IPSecTickHandler(
    IN  PVOID   SystemSpecific1,
    IN  PVOID   Context,
    IN  PVOID   SystemSpecific2,
    IN  PVOID   SystemSpecific3
    )
/*++

Routine Description:

    This is the handler we register with the system for processing each
    Timer List. This is called every "tick" seconds, where "tick" is
    determined by the granularity of the timer type.

Arguments:

    Context             - Actually a pointer to a Timer List structure
    SystemSpecific[1-3] - Not used

Return Value:

    None

--*/
{
    PIPSEC_TIMER_LIST   pTimerList;
    PIPSEC_TIMER        pExpiredTimer;      // Start of list of expired timers
    PIPSEC_TIMER        pNextTimer;         // for walking above list
    PIPSEC_TIMER        pTimer;             // temp, for walking timer list
    PIPSEC_TIMER        pPrevExpiredTimer;  // for creating expired timer list
    ULONG               Index;              // into the timer wheel
    ULONG               NewIndex;           // for refreshed timers
    KIRQL               kIrql;

    pTimerList = (PIPSEC_TIMER_LIST)Context;

    IPSEC_DEBUG(TIMER, ("Tick: List 0x%x, Count %d\n",
                pTimerList, pTimerList->TimerCount));

    pExpiredTimer = NULL_PIPSEC_TIMER;

    ACQUIRE_LOCK(&g_ipsec.TimerLock, &kIrql);

    if (TRUE) {
        //
        // Pick up the list of timers scheduled to have expired at the
        // current tick. Some of these might have been refreshed.
        //
        Index = pTimerList->CurrentTick;
        pExpiredTimer = (pTimerList->pTimers[Index]).pNextTimer;
        (pTimerList->pTimers[Index]).pNextTimer = NULL_PIPSEC_TIMER;

        //
        // Go through the list of timers scheduled to expire at this tick.
        // Prepare a list of expired timers, using the pNextExpiredTimer
        // link to chain them together.
        //
        // Some timers may have been refreshed, in which case we reinsert
        // them in the active timer list.
        //
        pPrevExpiredTimer = NULL_PIPSEC_TIMER;

        for (pTimer = pExpiredTimer;
             pTimer != NULL_PIPSEC_TIMER;
             pTimer = pNextTimer) {
            //
            // Save a pointer to the next timer, for the next iteration.
            //
            pNextTimer = pTimer->pNextTimer;

            IPSEC_DEBUG(TIMER,
                        ("Tick Handler: looking at timer 0x%x, next 0x%x\n",
                        pTimer, pNextTimer));

            //
            // Find out when this timer should actually expire.
            //
            NewIndex = pTimer->LastRefreshTime + pTimer->Duration;
            if (NewIndex >= pTimerList->TimerListSize) {
                NewIndex -= pTimerList->TimerListSize;
            }

            //
            // Check if we are currently at the point of expiry.
            //
            if (NewIndex != Index) {
                //
                // This timer still has some way to go, so put it back.
                //
                IPSEC_DEBUG(TIMER,
                            ("Tick: Reinserting Timer 0x%x: Hnd 0x%x, Durn %d, Ind %d, NewInd %d\n",
                            pTimer, pTimer->TimeoutHandler, pTimer->Duration, Index, NewIndex));

                //
                // Remove it from the expired timer list. Note that we only
                // need to update the forward (pNextExpiredTimer) links.
                //
                if (pPrevExpiredTimer == NULL_PIPSEC_TIMER) {
                    pExpiredTimer = pNextTimer;
                } else {
                    pPrevExpiredTimer->pNextExpiredTimer = pNextTimer;
                }

                //
                // And insert it back into the running timer list.
                //
                pTimer->pNextTimer = (pTimerList->pTimers[NewIndex]).pNextTimer;
                if (pTimer->pNextTimer != NULL_PIPSEC_TIMER) {
                    pTimer->pNextTimer->pPrevTimer = pTimer;
                }

                pTimer->pPrevTimer = &(pTimerList->pTimers[NewIndex]);
                (pTimerList->pTimers[NewIndex]).pNextTimer = pTimer;
            } else {
                //
                // This one has expired. Keep it in the expired timer list.
                //
                pTimer->pNextExpiredTimer = pNextTimer;
                if (pPrevExpiredTimer == NULL_PIPSEC_TIMER) {
                    pExpiredTimer = pTimer;
                }
                pPrevExpiredTimer = pTimer;

                //
                // Mark it as inactive.
                //
                ASSERT(pTimer->pTimerList == pTimerList);
                pTimer->pTimerList = (PIPSEC_TIMER_LIST)NULL;

                //
                // Update the active timer count.
                //
                pTimerList->TimerCount--;
            }
        }

        //
        // Update current tick index in readiness for the next tick.
        //
        if (++Index == pTimerList->TimerListSize) {
            pTimerList->CurrentTick = 0;
        } else {
            pTimerList->CurrentTick = Index;
        }

        if (pTimerList->TimerCount > 0) {
            //
            // Re-arm the tick handler
            //
            IPSEC_DEBUG(TIMER, ("Tick[%d]: Starting system timer 0x%x\n",
                        pTimerList->CurrentTick, &(pTimerList->NdisTimer)));
            
            IPSEC_START_SYSTEM_TIMER(&(pTimerList->NdisTimer), pTimerList->TimerPeriod);
        } else {
            pTimerList->CurrentTick = 0;
        }

    }

    RELEASE_LOCK(&g_ipsec.TimerLock, kIrql);

    //
    // Now pExpiredTimer is a list of expired timers.
    // Walk through the list and call the timeout handlers
    // for each timer.
    //
    while (pExpiredTimer != NULL_PIPSEC_TIMER) {
        pNextTimer = pExpiredTimer->pNextExpiredTimer;

        IPSEC_DEBUG(TIMER,
                    ("Expired timer 0x%x: handler 0x%x, next 0x%x\n",
                    pExpiredTimer, pExpiredTimer->TimeoutHandler, pNextTimer));

        (*(pExpiredTimer->TimeoutHandler))( pExpiredTimer,
                                            pExpiredTimer->Context);

        IPSEC_DECREMENT(g_ipsec.NumTimers);

        pExpiredTimer = pNextTimer;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\timer.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    timer.h

Abstract:

    Contains timer management structures.

Author:

    Sanjay Anand (SanjayAn) 26-May-1997
    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#ifndef  _TIMER_H
#define  _TIMER_H

#if DBG
#define atl_signature		'LTA '
#endif // DBG

/*++
ULONG
SECONDS_TO_LONG_TICKS(
	IN	ULONG				Seconds
)
Convert from seconds to "long duration timer ticks"
--*/
#define SECONDS_TO_SUPER_LONG_TICKS(Seconds)		((Seconds)/3600)

/*++
ULONG
SECONDS_TO_LONG_TICKS(
	IN	ULONG				Seconds
)
Convert from seconds to "long duration timer ticks"
--*/
#define SECONDS_TO_LONG_TICKS(Seconds)		((Seconds)/60)

/*++
ULONG
SECONDS_TO_SHORT_TICKS(
	IN	ULONG				Seconds
)
Convert from seconds to "short duration timer ticks"
--*/
#define SECONDS_TO_SHORT_TICKS(Seconds)		(Seconds)

/*++
VOID
IPSEC_INIT_SYSTEM_TIMER(
	IN	PNDIS_TIMER			pTimer,
	IN	PNDIS_TIMER_FUNCTON	pFunc,
	IN	PVOID				Context
)
--*/
#define IPSEC_INIT_SYSTEM_TIMER(pTimer, pFunc, Context)	\
			NdisInitializeTimer(pTimer, (PNDIS_TIMER_FUNCTION)(pFunc), (PVOID)Context)

/*++
VOID
IPSEC_START_SYSTEM_TIMER(
	IN	PNDIS_TIMER			pTimer,
	IN	UINT				PeriodInSeconds
)
--*/
#define IPSEC_START_SYSTEM_TIMER(pTimer, PeriodInSeconds)	\
			NdisSetTimer(pTimer, (UINT)(PeriodInSeconds * 1000))

/*++
VOID
IPSEC_STOP_SYSTEM_TIMER(
	IN	PNDIS_TIMER			pTimer
)
--*/
#define IPSEC_STOP_SYSTEM_TIMER(pTimer)						\
			{												\
				BOOLEAN		WasCancelled;					\
				NdisCancelTimer(pTimer, &WasCancelled);		\
			}

/*++
BOOLEAN
IPSEC_IS_TIMER_ACTIVE(
	IN	PIPSEC_TIMER		pArpTimer
)
--*/
#define IPSEC_IS_TIMER_ACTIVE(pTmr)	((pTmr)->pTimerList != (PIPSEC_TIMER_LIST)NULL)

/*++
ULONG
IPSEC_GET_TIMER_DURATION(
	IN	PIPSEC_TIMER		pTimer
)
--*/
#define IPSEC_GET_TIMER_DURATION(pTmr)	((pTmr)->Duration)

//
// Timer management using Timing Wheels (adapted from IPSEC)
//

struct _IPSEC_TIMER ;
struct _IPSEC_TIMER_LIST ;

//
//  Timeout Handler prototype
//
typedef
VOID
(*IPSEC_TIMEOUT_HANDLER) (
	IN	struct _IPSEC_TIMER *	pTimer,
	IN	PVOID			Context
);

//
//  An IPSEC_TIMER structure is used to keep track of each timer
//  in the IPSEC module.
//
typedef struct _IPSEC_TIMER {
	struct _IPSEC_TIMER *			pNextTimer;
	struct _IPSEC_TIMER *			pPrevTimer;
	struct _IPSEC_TIMER *			pNextExpiredTimer;	// Used to chain expired timers
	struct _IPSEC_TIMER_LIST *		pTimerList;			// NULL iff this timer is inactive
	ULONG							Duration;			// In seconds
	ULONG							LastRefreshTime;
	IPSEC_TIMEOUT_HANDLER			TimeoutHandler;
	PVOID							Context;			// To be passed to timeout handler
} IPSEC_TIMER, *PIPSEC_TIMER;

//
//  NULL pointer to IPSEC Timer
//
#define NULL_PIPSEC_TIMER	((PIPSEC_TIMER)NULL)

//
//  Control structure for a timer wheel. This contains all information
//  about the class of timers that it implements.
//
typedef struct _IPSEC_TIMER_LIST {
#if DBG
	ULONG							atl_sig;
#endif // DBG
	PIPSEC_TIMER					pTimers;		// List of timers
	ULONG							TimerListSize;	// Length of above
	ULONG							CurrentTick;	// Index into above
	ULONG							TimerCount;		// Number of running timers
	ULONG							MaxTimer;		// Max timeout value for this
	NDIS_TIMER						NdisTimer;		// System support
	UINT							TimerPeriod;	// Interval between ticks
	PVOID							ListContext;	// Used as a back pointer to the
													// Interface structure
} IPSEC_TIMER_LIST, *PIPSEC_TIMER_LIST;

//
//  Timer Classes
//
typedef enum {
	IPSEC_CLASS_SHORT_DURATION,
 	IPSEC_CLASS_LONG_DURATION,
    IPSEC_CLASS_SUPER_LONG_DURATION,
	IPSEC_CLASS_MAX
} IPSEC_TIMER_CLASS;

//
//  Timer configuration.
//
#define IPSEC_MAX_TIMER_SHORT_DURATION          (60)        // 60 seconds
#define IPSEC_MAX_TIMER_LONG_DURATION           (60*60)     // 1 hour in secs
#define IPSEC_MAX_TIMER_SUPER_LONG_DURATION     (48*3600)   // 48 hours in secs

#define IPSEC_SHORT_DURATION_TIMER_PERIOD       (1)         // 1 second
#define IPSEC_LONG_DURATION_TIMER_PERIOD        (1*60)      // 1 minute
#define IPSEC_SUPER_LONG_DURATION_TIMER_PERIOD  (1*3600)    // 1 hour

#define IPSEC_SA_EXPIRY_TIME                    (1*60)      // 1 minute in secs
#define IPSEC_REAPER_TIME                       (60)        // 60 secs


BOOLEAN
IPSecInitTimer(
    );

VOID
IPSecStartTimer(
    IN  PIPSEC_TIMER            pTimer,
    IN  IPSEC_TIMEOUT_HANDLER   TimeoutHandler,
    IN  ULONG                   SecondsToGo,
    IN  PVOID                   Context
    );

BOOLEAN
IPSecStopTimer(
    IN  PIPSEC_TIMER    pTimer
    );

VOID
IPSecTickHandler(
    IN  PVOID   SystemSpecific1,
    IN  PVOID   Context,
    IN  PVOID   SystemSpecific2,
    IN  PVOID   SystemSpecific3
    );

#endif  _TIMER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipsec\sys\saapi.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    saapi.c

Abstract:

    This module contains the SAAPI implementation

Author:

    Sanjay Anand (SanjayAn) 12-May-1997
    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#include "precomp.h"


#pragma hdrstop


#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, IPSecInitRandom)
#endif


BOOLEAN
IPSecInitRandom(
    VOID
    )
/*++

Routine Description:

	Initialize the IPSecRngKey by calling into ksecdd to get 2048 bits of random
    and create the RC4 key.

Arguments:

    Called at PASSIVE level.

Return Value:

    TRUE/FALSE

--*/
{
    UCHAR   pBuf[RNG_KEY_SIZE];

    PAGED_CODE();

    if (IPSEC_GEN_RANDOM(pBuf, RNG_KEY_SIZE) == FALSE) {
        IPSEC_DEBUG(LOAD, ("IPSEC_GEN_RANDOM failure.\n"));
        return  FALSE;
    }

    //
    // Generate the key control structure.
    //
    IPSEC_RC4_KEY(&IPSecRngKey, RNG_KEY_SIZE, pBuf);

    return  TRUE;
}


VOID
IPSecRngRekey(
    IN  PVOID   Context
    )
/*++

Routine Description:

	Initialize the IPSecRngKey by calling into ksecdd to get 2048 bits of random
    and create the RC4 key.

Arguments:

    Called at PASSIVE level.

Return Value:

    None.

--*/
{
    IPSecInitRandom();

    IPSEC_DECREMENT(g_ipsec.NumWorkers);

#if DBG
    IPSecRngInRekey = 0;
#endif

    IPSEC_SET_VALUE(IPSecRngBytes, 0);
}


BOOLEAN
IPSecGenerateRandom(
    IN  PUCHAR  pBuf,
    IN  ULONG   BytesNeeded
    )
/*++

Routine Description:

	Generate a positive pseudo-random number between Lower and Upper bounds;
    simple linear congruential algorithm. ANSI C "rand()" function. Courtesy JameelH.

Arguments:

	LowerBound, UpperBound - range of random number.

Return Value:

	a random number.

--*/
{
    ULONG   RngBytes;

    IPSEC_RC4(&IPSecRngKey, BytesNeeded, pBuf);

    //
    // Rekey if we have exceeded the threshold.
    //
    RngBytes = IPSEC_ADD_VALUE(IPSecRngBytes, BytesNeeded);
    if (RngBytes <= RNG_REKEY_THRESHOLD &&
        (RngBytes + BytesNeeded) > RNG_REKEY_THRESHOLD) {
        //
        // Create a worker thread to perform the rekey since it has to be done
        // as paged code.
        //
#if DBG
        ASSERT(IPSecRngInRekey == 0);
        IPSecRngInRekey = 1;
#endif

        ExInitializeWorkItem(   &IPSecRngQueueItem,
                                IPSecRngRekey,
                                NULL);

        ExQueueWorkItem(&IPSecRngQueueItem, DelayedWorkQueue);

        IPSEC_INCREMENT(g_ipsec.NumWorkers);
    }

    return  TRUE;
}


VOID
IPSecCleanupOutboundSA(
    IN  PSA_TABLE_ENTRY pInboundSA,
    IN  PSA_TABLE_ENTRY pOutboundSA,
    IN  BOOLEAN         fNoDelete
    )
/*++

Routine Description:

    Deletes an outbound SA.

    Called with SADB lock held, returns with it.

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    KIRQL   kIrql;

    IPSEC_DEBUG(ACQUIRE, ("Deleting assoc (outbound) SA: %lx\n", pOutboundSA));

    pInboundSA->sa_AssociatedSA = NULL;

    //
    // de-link from the Filter lists
    //
    if (pOutboundSA->sa_Flags & FLAGS_SA_ON_FILTER_LIST) {
        pOutboundSA->sa_Flags &= ~FLAGS_SA_ON_FILTER_LIST;
        IPSecRemoveEntryList(&pOutboundSA->sa_FilterLinkage);
    }

    //
    // So, we dont delete the Rekeyoriginal SA again.
    //
    if (pOutboundSA->sa_Flags & FLAGS_SA_REKEY_ORI) {
        pOutboundSA->sa_Flags &= ~FLAGS_SA_REKEY_ORI;
        if (pOutboundSA->sa_RekeyLarvalSA) {
            ASSERT(pOutboundSA->sa_RekeyLarvalSA->sa_Flags & FLAGS_SA_REKEY);
            pOutboundSA->sa_RekeyLarvalSA->sa_RekeyOriginalSA = NULL;
        }
    }

    //
    // invalidate the associated cache entry
    //
    IPSecInvalidateSACacheEntry(pOutboundSA);

    pOutboundSA->sa_State = STATE_SA_ZOMBIE;
    pOutboundSA->sa_AssociatedSA = NULL;

    if (pOutboundSA->sa_Flags & FLAGS_SA_HW_PLUMBED) {
        IPSecDelHWSAAtDpc(pOutboundSA);
    }

    IPSEC_DEBUG(REF, ("Out Deref IPSecCleanupOutboundSA\n"));
    IPSecStopTimerDerefSA(pOutboundSA);

    IPSEC_INC_STATISTIC(dwNumKeyDeletions);
}


VOID
IPSecCleanupLarvalSA(
    IN  PSA_TABLE_ENTRY  pSA
    )
/*++

Routine Description:

    Delete the LarvalSA.

    Called with Outbound Lock held, returns with it.

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    PSA_TABLE_ENTRY pOutboundSA;
    KIRQL           kIrql1;
    KIRQL           kIrql2;

    //
    // Also remove from Pending list if queued there.
    //
    ACQUIRE_LOCK(&g_ipsec.AcquireInfo.Lock, &kIrql1);
    if (pSA->sa_Flags & FLAGS_SA_PENDING) {
        ASSERT(pSA->sa_State == STATE_SA_LARVAL);
        IPSEC_DEBUG(ACQUIRE, ("IPSecSAExpired: Removed from pending too: %lx\n", pSA));
        IPSecRemoveEntryList(&pSA->sa_PendingLinkage);
        pSA->sa_Flags &= ~FLAGS_SA_PENDING;
    }
    RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, kIrql1);

    //
    // Flush all the queued packets
    //
    IPSecFlushQueuedPackets(pSA, STATUS_TIMEOUT);

    //
    // remove from inbound sa list
    //
    AcquireWriteLock(&g_ipsec.SPIListLock, &kIrql1);
    IPSecRemoveSPIEntry(pSA);
    ReleaseWriteLock(&g_ipsec.SPIListLock, kIrql1);

    //
    // invalidate the associated cache entry
    //
    ACQUIRE_LOCK(&pSA->sa_Lock, &kIrql2);
    if (pSA->sa_AcquireCtx) {
        IPSecInvalidateHandle(pSA->sa_AcquireCtx);
        pSA->sa_AcquireCtx = NULL;
    }
    RELEASE_LOCK(&pSA->sa_Lock, kIrql2);

    IPSecInvalidateSACacheEntry(pSA);

    if (pSA->sa_Flags & FLAGS_SA_ON_FILTER_LIST) {
        pSA->sa_Flags &= ~FLAGS_SA_ON_FILTER_LIST;
        IPSecRemoveEntryList(&pSA->sa_FilterLinkage);
    }

    if (pSA->sa_RekeyOriginalSA) {
        ASSERT(pSA->sa_Flags & FLAGS_SA_REKEY);
        ASSERT(pSA->sa_RekeyOriginalSA->sa_RekeyLarvalSA == pSA);
        ASSERT(pSA->sa_RekeyOriginalSA->sa_Flags & FLAGS_SA_REKEY_ORI);

        pSA->sa_RekeyOriginalSA->sa_Flags &= ~FLAGS_SA_REKEY_ORI;
        pSA->sa_RekeyOriginalSA->sa_RekeyLarvalSA = NULL;
        pSA->sa_RekeyOriginalSA = NULL;
    }

    if (pOutboundSA = pSA->sa_AssociatedSA) {

        IPSEC_DEC_STATISTIC(dwNumActiveAssociations);
        IPSEC_DEC_TUNNELS(pOutboundSA);
        IPSEC_DECREMENT(g_ipsec.NumOutboundSAs);

        IPSecCleanupOutboundSA(pSA, pOutboundSA, FALSE);
    }

    IPSEC_DEBUG(REF, ("In Deref DeleteLarvalSA\n"));
    IPSecStopTimerDerefSA(pSA);
}


VOID
IPSecDeleteLarvalSA(
    IN  PSA_TABLE_ENTRY  pSA
    )
/*++

Routine Description:

    Delete the LarvalSA.

    Called with Outbound Lock held, returns with it.

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    KIRQL   kIrql;

    ASSERT((pSA->sa_Flags & FLAGS_SA_OUTBOUND) == 0);

    //
    // Remove from larval list
    //
    ACQUIRE_LOCK(&g_ipsec.LarvalListLock, &kIrql);
    IPSecRemoveEntryList(&pSA->sa_LarvalLinkage);
    IPSEC_DEC_STATISTIC(dwNumPendingKeyOps);
    RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);

    //
    // Cleanup the rest of larval SA
    //
    IPSecCleanupLarvalSA(pSA);
}


VOID
IPSecDeleteInboundSA(
    IN  PSA_TABLE_ENTRY  pInboundSA
    )
/*++

Routine Description:

    Deletes the corresponding outbound SA, and then deletes itself.

    Called with Outbound Lock held, returns with it.

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    PSA_TABLE_ENTRY pOutboundSA;
    PSA_TABLE_ENTRY pSA;
    KIRQL           kIrql;
    PLIST_ENTRY     pEntry;
    PFILTER         pFilter;

    ACQUIRE_LOCK(&g_ipsec.AcquireInfo.Lock, &kIrql);
    IPSecNotifySAExpiration(pInboundSA, NULL, kIrql, FALSE);

    if (pOutboundSA = pInboundSA->sa_AssociatedSA) {

        IPSEC_DEC_STATISTIC(dwNumActiveAssociations);
        IPSEC_DEC_TUNNELS(pOutboundSA);
        IPSEC_DECREMENT(g_ipsec.NumOutboundSAs);

        IPSecCleanupOutboundSA(pInboundSA, pOutboundSA, FALSE);
    }

    IPSEC_DEBUG(ACQUIRE, ("Deleting inbound SA: %lx\n", pInboundSA));

    //
    // remove from inbound sa list
    //
    AcquireWriteLock(&g_ipsec.SPIListLock, &kIrql);
    IPSecRemoveSPIEntry(pInboundSA);
    ReleaseWriteLock(&g_ipsec.SPIListLock, kIrql);

    //
    // invalidate the associated cache entry
    //
    IPSecInvalidateSACacheEntry(pInboundSA);

    //
    // also remove from the filter list
    //
    if (pInboundSA->sa_Flags & FLAGS_SA_ON_FILTER_LIST) {
        pInboundSA->sa_Flags &= ~FLAGS_SA_ON_FILTER_LIST;
        IPSecRemoveEntryList(&pInboundSA->sa_FilterLinkage);
    }

    if (pInboundSA->sa_Flags & FLAGS_SA_HW_PLUMBED) {
        IPSecDelHWSAAtDpc(pInboundSA);
    }

    ASSERT(pInboundSA->sa_AssociatedSA == NULL);

    IPSEC_DEBUG(REF, ("In Deref DeleteInboundSA\n"));
    IPSecStopTimerDerefSA(pInboundSA);
}


VOID
IPSecExpireInboundSA(
    IN  PSA_TABLE_ENTRY  pInboundSA
    )
/*++

Routine Description:

    Deletes the corresponding outbound SA, and places itself (inbound) on timer
    Queue for later.

    NOTE: Called with SADB lock held.
Arguments:


Return Value:

    The final status from the operation.

--*/
{
    PSA_TABLE_ENTRY pOutboundSA;
    KIRQL           OldIrq;
    KIRQL           kIrql;

    if (pInboundSA->sa_Flags & FLAGS_SA_HW_PLUMBED) {
        IPSecDelHWSAAtDpc(pInboundSA);
    }

    ACQUIRE_LOCK(&g_ipsec.AcquireInfo.Lock, &OldIrq);
    IPSecNotifySAExpiration(pInboundSA, NULL, OldIrq, FALSE);

    if (pOutboundSA = pInboundSA->sa_AssociatedSA) {

        IPSEC_DEC_STATISTIC(dwNumActiveAssociations);
        IPSEC_DEC_TUNNELS(pOutboundSA);
        IPSEC_DECREMENT(g_ipsec.NumOutboundSAs);

        IPSecCleanupOutboundSA(pInboundSA, pOutboundSA, TRUE);
    }

    IPSEC_DEBUG(ACQUIRE, ("Queueing inbound SA: %lx\n", pInboundSA));

    //
    // Place this on the timer Q so it gets cleared when the next interval hits.
    //
    ACQUIRE_LOCK(&pInboundSA->sa_Lock, &kIrql);

    if (pInboundSA->sa_AcquireCtx) {
        IPSecInvalidateHandle(pInboundSA->sa_AcquireCtx);
        pInboundSA->sa_AcquireCtx = NULL;
    }

    IPSecStartSATimer(  pInboundSA,
                        IPSecSAExpired,
                        IPSEC_INBOUND_KEEPALIVE_TIME);

    RELEASE_LOCK(&pInboundSA->sa_Lock, kIrql);
}


NTSTATUS
IPSecCheckInboundSA(
    IN  PSA_STRUCT             pSAStruct,
    IN  PSA_TABLE_ENTRY        pSA
    )
/*++

Routine Description:

    Ensures that the SA being updated is actually the SA we initially
    kicked off negotiation for.

Arguments:

    pSAInfo - information about the SA

    pSA - SA to be populated.

Return Value:

    STATUS_PENDING if the buffer is to be held on to, the normal case.

Notes:


--*/
{
    LARGE_INTEGER   uliSrcDstAddr;
    LARGE_INTEGER   uliSrcDstMask;
    LARGE_INTEGER   uliProtoSrcDstPort;
    PSECURITY_ASSOCIATION   pSAInfo = &pSAStruct->SecAssoc[pSAStruct->NumSAs - 1];


    IPSEC_BUILD_SRC_DEST_ADDR(  uliSrcDstAddr,
                                pSAStruct->InstantiatedFilter.SrcAddr,
                                pSAStruct->InstantiatedFilter.DestAddr);

    IPSEC_BUILD_SRC_DEST_MASK(  uliSrcDstMask,
                                pSAStruct->InstantiatedFilter.SrcMask,
                                pSAStruct->InstantiatedFilter.DestMask);

    IPSEC_BUILD_PROTO_PORT_LI(  uliProtoSrcDstPort,
                                pSAStruct->InstantiatedFilter.Protocol,
                                pSAStruct->InstantiatedFilter.SrcPort,
                                pSAStruct->InstantiatedFilter.DestPort);

    IPSEC_DEBUG(ACQUIRE, ("IPSecCheckInboundSA: S: %lx-%lx, D: %lx-%lx\n",
                SRC_ADDR, SRC_MASK, DEST_ADDR, DEST_MASK));
    IPSEC_DEBUG(ACQUIRE, ("IPSecCheckInboundSA: SA->S: %lx-%lx, SA->D: %lx-%lx\n",
                pSA->SA_SRC_ADDR, pSA->SA_SRC_MASK, pSA->SA_DEST_ADDR, pSA->SA_DEST_MASK));

    if ((pSA->sa_TunnelAddr != 0) || (pSA->sa_Flags & FLAGS_SA_TUNNEL)) {
        if (((SRC_ADDR & pSA->SA_SRC_MASK) ==
             (pSA->SA_SRC_ADDR & pSA->SA_SRC_MASK)) &&
            ((DEST_ADDR & pSA->SA_DEST_MASK) ==
             (pSA->SA_DEST_ADDR & pSA->SA_DEST_MASK)) &&
            (pSA->sa_SPI == pSAInfo->SPI)) {
            return STATUS_SUCCESS;
        }
    } else {
        if ((uliSrcDstAddr.QuadPart == pSA->sa_uliSrcDstAddr.QuadPart) &&
            (pSA->sa_SPI == pSAInfo->SPI)) {
            return STATUS_SUCCESS;
        }
    }

    return  STATUS_FAIL_CHECK;
}


BOOLEAN
IPSecIsWeakDESKey(
    IN  PUCHAR  Key
    )
/*++

Routine Description:

    Checks for weak DES keys

Arguments:

    Key - the key to be checked.

Return Value:

    TRUE/FALSE

Notes:

--*/
{
    ULONG   j;

    for (j = 0; j < NUM_WEAK_KEYS; j++) {
        if (IPSecEqualMemory(Key, weak_keys[j], DES_BLOCKLEN)) {
            return  TRUE;
        }
    }

    return  FALSE;
}


BOOLEAN
IPSecIsWeak3DESKey(
    IN  PUCHAR  Key
    )
/*++

Routine Description:

    Checks for weak Triple DES keys

Arguments:

    Key - the key to be checked.

Return Value:

    TRUE/FALSE

Notes:

--*/
{
    if (IPSecEqualMemory(Key, Key + DES_BLOCKLEN, DES_BLOCKLEN) ||
        IPSecEqualMemory(Key + DES_BLOCKLEN, Key + 2 * DES_BLOCKLEN, DES_BLOCKLEN)) {
        return  TRUE;
    }

    return  FALSE;
}


NTSTATUS
IPSecPopulateSA(
    IN  PSA_STRUCT              pSAStruct,
    IN  ULONG                   KeyLen,
    IN  PSA_TABLE_ENTRY         pSA
    )
/*++

Routine Description:

    Populates an SA with info passed in the SECURITY_ASSOCIATION block

Arguments:

    pSAInfo - information about the SA

    KeyLen - the length of the composite key (we do the slicing/dicing here)

    pSA - SA to be populated.

Return Value:

    STATUS_PENDING if the buffer is to be held on to, the normal case.

Notes:


--*/
{
    PSECURITY_ASSOCIATION    pSAInfo = &pSAStruct->SecAssoc[0];
    ULONG   Index;
    ULONG   len = 0;

    IPSEC_BUILD_SRC_DEST_ADDR(  pSA->sa_uliSrcDstAddr,
                                pSAStruct->InstantiatedFilter.SrcAddr,
                                pSAStruct->InstantiatedFilter.DestAddr);

    IPSEC_BUILD_SRC_DEST_MASK(  pSA->sa_uliSrcDstMask,
                                pSAStruct->InstantiatedFilter.SrcMask,
                                pSAStruct->InstantiatedFilter.DestMask);

    IPSEC_BUILD_PROTO_PORT_LI(  pSA->sa_uliProtoSrcDstPort,
                                pSAStruct->InstantiatedFilter.Protocol,
                                pSAStruct->InstantiatedFilter.SrcPort,
                                pSAStruct->InstantiatedFilter.DestPort);

    if ((pSAStruct->NumSAs < 1) ||
        (pSAStruct->NumSAs > MAX_SAS)) {
        IPSEC_DEBUG(SAAPI, ("Invalid NumOps count: %d\n", pSAStruct->NumSAs));
        return  STATUS_INVALID_PARAMETER;
    }

    //
    // If inbound SA, ensure that the last SPI is the one we returned.
    //
    if (!(pSA->sa_Flags & FLAGS_SA_OUTBOUND)) {
        if (pSA->sa_SPI != pSAStruct->SecAssoc[pSAStruct->NumSAs - 1].SPI) {
            IPSEC_DEBUG(SAAPI, ("SPI in invalid location: SPI: %lx, in loc: %lx\n",
                pSA->sa_SPI,
                pSAStruct->SecAssoc[pSAStruct->NumSAs - 1].SPI));
            return  STATUS_INVALID_PARAMETER;
        }
    }

    if (pSAStruct->Flags & IPSEC_SA_TUNNEL) {
        IPSEC_DEBUG(TUNNEL, ("SA %lx tunneled to %lx\n", pSA, pSAStruct->TunnelAddr));
        pSA->sa_TunnelAddr = pSAStruct->TunnelAddr;
        pSA->sa_Flags |= FLAGS_SA_TUNNEL;
    }

    if (pSAStruct->Flags & IPSEC_SA_DISABLE_IDLE_OUT) {
        pSA->sa_Flags |= FLAGS_SA_DISABLE_IDLE_OUT;
    }

    if (pSAStruct->Flags & IPSEC_SA_DISABLE_ANTI_REPLAY_CHECK) {
        pSA->sa_Flags |= FLAGS_SA_DISABLE_ANTI_REPLAY_CHECK;
    }

    if (pSAStruct->Flags & IPSEC_SA_DISABLE_LIFETIME_CHECK) {
        pSA->sa_Flags |= FLAGS_SA_DISABLE_LIFETIME_CHECK;
    }

    pSA->sa_NumOps = pSAStruct->NumSAs;
    pSA->sa_Lifetime = pSAStruct->Lifetime;
    pSA->sa_TruncatedLen = TRUNCATED_HASH_LEN;
    pSA->sa_ReplayLen = sizeof(ULONG);

    pSA->sa_QMPFSGroup = pSAStruct->dwQMPFSGroup;
    RtlCopyMemory(  &pSA->sa_CookiePair,
                    &pSAStruct->CookiePair,
                    sizeof(IKE_COOKIE_PAIR));

    for (Index = 0; Index < pSAStruct->NumSAs; Index++) {
        pSAInfo = &pSAStruct->SecAssoc[Index];
        pSA->sa_OtherSPIs[Index] = pSAInfo->SPI;
        pSA->sa_Operation[Index] = pSAInfo->Operation;
        pSA->sa_ReplaySendSeq[Index] = pSA->sa_ReplayStartPoint;
        pSA->sa_ReplayLastSeq[Index] = pSA->sa_ReplayStartPoint + 1;

        //
        // Now parse the Algorithm info..
        //
        switch (pSA->sa_Operation[Index]) {
            case None:
                IPSEC_DEBUG(ACQUIRE, ("NULL operation.\n"));
                if (pSA->sa_NumOps > 1) {
                    IPSEC_DEBUG(SAAPI, ("Invalid NumOps count; none specified, but more ops than 1\n"));
                    return  STATUS_INVALID_PARAMETER;
                }
                break;

            case Auth: {
                pSA->INT_ALGO(Index) = pSAInfo->EXT_INT_ALGO;

                if (pSA->INT_ALGO(Index) >= IPSEC_AH_MAX) {
                    IPSEC_DEBUG(SAAPI, ("Invalid int algo: %d %d\n", pSA->INT_ALGO(Index), IPSEC_AH_MAX));
                    return  STATUS_INVALID_PARAMETER;
                }

                pSA->INT_KEYLEN(Index) = pSAInfo->EXT_INT_KEYLEN;
                pSA->INT_ROUNDS(Index) = pSAInfo->EXT_INT_ROUNDS;

                //
                // Make sure the right key len was passed in
                //
                if (KeyLen > 0 && pSAInfo->EXT_INT_KEYLEN == (KeyLen - len)) {
                    IPSEC_DEBUG(SAAPI, ("Key len more than reserved, allocing new keys\n"));

                    if (!(pSA->INT_KEY(Index) = IPSecAllocateKeyBuffer(KeyLen))) {
                        return  STATUS_INSUFFICIENT_RESOURCES;
                    }

                    RtlCopyMemory(  pSA->INT_KEY(Index),
                                    (UCHAR UNALIGNED *)(pSAStruct->KeyMat + len),
                                    pSAInfo->EXT_INT_KEYLEN);
                } else {
                    //
                    // bogus - reject
                    //
                    IPSEC_DEBUG(SAAPI, ("AH: Key len is bogus - extra bytes: %d, keylen in struct: %d.\n",
                                            KeyLen-len,
                                            pSAInfo->EXT_INT_KEYLEN));

                    return  STATUS_INVALID_PARAMETER;
                }

                len = pSAInfo->EXT_INT_KEYLEN;

                break;
            }

            case Encrypt: {
                pSA->INT_ALGO(Index) = pSAInfo->EXT_INT_ALGO;

                if (pSA->INT_ALGO(Index) >= IPSEC_AH_MAX) {
                    IPSEC_DEBUG(SAAPI, ("Invalid int algo: %d %d\n", pSA->INT_ALGO(Index), IPSEC_AH_MAX));
                    return  STATUS_INVALID_PARAMETER;
                }

                if (pSA->INT_ALGO(Index) == IPSEC_AH_NONE) {
                    IPSEC_DEBUG(SAAPI, ("None Auth algo\n"));
                    //pSA->sa_TruncatedLen = 0;
                }

                pSA->INT_KEYLEN(Index) = pSAInfo->EXT_INT_KEYLEN;
                pSA->INT_ROUNDS(Index) = pSAInfo->EXT_INT_ROUNDS;

                pSA->CONF_ALGO(Index) = pSAInfo->EXT_CONF_ALGO;

                if (pSA->CONF_ALGO(Index) >= IPSEC_ESP_MAX) {
                    IPSEC_DEBUG(SAAPI, ("Invalid conf algo: %d %d\n", pSA->CONF_ALGO(Index), IPSEC_ESP_MAX));
                    return  STATUS_INVALID_PARAMETER;
                }

                if ((pSA->CONF_ALGO(Index) == IPSEC_ESP_DES) ||
                    (pSA->CONF_ALGO(Index) == IPSEC_ESP_3_DES) ||
                    (pSA->CONF_ALGO(Index) == IPSEC_ESP_NONE)) {
                    LARGE_INTEGER   Li;

                    NdisGetCurrentSystemTime(&Li);
                    pSA->sa_ivlen = DES_BLOCKLEN;

                    *(UNALIGNED ULONG *)&pSA->sa_iv[Index][0] = Li.LowPart;
                    *(UNALIGNED ULONG *)&pSA->sa_iv[Index][4] = Li.HighPart;
                    IPSecGenerateRandom((PUCHAR)&pSA->sa_iv[Index][0], DES_BLOCKLEN);

                    IPSEC_DEBUG(SAAPI, ("IV: %lx-%lx\n", *(PULONG)&pSA->sa_iv[Index][0], *(PULONG)&pSA->sa_iv[Index][4]));

                    pSA->CONF_KEYLEN(Index) = pSAInfo->EXT_CONF_KEYLEN;
                    pSA->CONF_ROUNDS(Index) = pSAInfo->EXT_CONF_ROUNDS;

                    //
                    // Make sure the right key len was passed in
                    //
                    if ((KeyLen-len == pSAStruct->KeyLen) &&
                        (pSAInfo->EXT_INT_KEYLEN + pSAInfo->EXT_CONF_KEYLEN <= KeyLen-len)) {

                        //
                        // confKeyMatLen is the amount of conf key material that came down.
                        // this is the reduced (weakened) length for export.
                        // it is expanded to the real length later.
                        //
                        ULONG   confKeyMatLen = pSAInfo->EXT_CONF_KEYLEN;
                        ULONG   realConfKeyLen = 0;

                        realConfKeyLen = confKeyMatLen;

                        if (pSA->CONF_ALGO(Index) == IPSEC_ESP_DES) {
                            if (pSAInfo->EXT_CONF_KEYLEN != DES_BLOCKLEN) {
                                ASSERT(FALSE);
                                IPSEC_DEBUG(SAAPI, ("Bad DES key length: pSAInfo->EXT_CONF_KEYLEN: %lx, conf: %lx, DES_BLOCKLEN: %lx\n",
                                                            pSAInfo->EXT_CONF_KEYLEN, confKeyMatLen, DES_BLOCKLEN));

                                return  STATUS_INVALID_PARAMETER;
                            }
                        } else if (pSA->CONF_ALGO(Index) == IPSEC_ESP_3_DES) {
                            if (pSAInfo->EXT_CONF_KEYLEN != 3 * DES_BLOCKLEN) {
                                ASSERT(FALSE);
                                IPSEC_DEBUG(SAAPI, ("Bad 3DES key length\n"));
                                return  STATUS_INVALID_PARAMETER;
                            }
                        }

                        IPSEC_DEBUG(SAAPI, ("Key len more than reserved, allocing new keys\n"));
                        if (pSAInfo->EXT_INT_KEYLEN > 0 &&
                            !(pSA->INT_KEY(Index) = IPSecAllocateKeyBuffer(pSAInfo->EXT_INT_KEYLEN))) {
                            return  STATUS_INSUFFICIENT_RESOURCES;
                        }

                        if (realConfKeyLen > 0 &&
                            !(pSA->CONF_KEY(Index) = IPSecAllocateKeyBuffer(realConfKeyLen))) {
                            if (pSA->INT_KEY(Index)) {
                                IPSecFreeKeyBuffer(pSA->INT_KEY(Index));
                                pSA->INT_KEY(Index) = NULL;
                            }
                            return  STATUS_INSUFFICIENT_RESOURCES;
                        }

                        if (pSA->CONF_KEY(Index) && confKeyMatLen) {
                            RtlCopyMemory(  pSA->CONF_KEY(Index),
                                            pSAStruct->KeyMat,
                                            confKeyMatLen);

                            if (confKeyMatLen < realConfKeyLen) {
                                if (pSA->INT_KEY(Index)) {
                                    IPSecFreeKeyBuffer(pSA->INT_KEY(Index));
                                    pSA->INT_KEY(Index) = NULL;
                                }
                                if (pSA->CONF_KEY(Index)) {
                                    IPSecFreeKeyBuffer(pSA->CONF_KEY(Index));
                                    pSA->CONF_KEY(Index) = NULL;
                                }
                                return  STATUS_INVALID_PARAMETER;
                            }

                            if ((pSA->CONF_ALGO(Index) == IPSEC_ESP_DES &&
                                 IPSecIsWeakDESKey(pSA->CONF_KEY(Index))) ||
                                (pSA->CONF_ALGO(Index) == IPSEC_ESP_3_DES &&
                                 IPSecIsWeak3DESKey(pSA->CONF_KEY(Index)))) {
                                PSA_TABLE_ENTRY pLarvalSA;

                                IPSEC_DEBUG(SAAPI, ("Got a weak key!!: %lx\n", pSA->CONF_KEY(Index)));
                                //
                                // if initiator, re-start a new negotiation and throw away this one
                                //
                                if (pSA->sa_Flags & FLAGS_SA_INITIATOR) {
                                    IPSecNegotiateSA(   pSA->sa_Filter,
                                                        pSA->sa_uliSrcDstAddr,
                                                        pSA->sa_uliProtoSrcDstPort,
                                                        pSA->sa_NewMTU,
                                                        &pLarvalSA,
                                                        pSA->sa_DestType);
                                    IPSecQueuePacket(pLarvalSA, pSA->sa_BlockedBuffer);
                                }

                                return  STATUS_INVALID_PARAMETER;
                            }
                        } else {
                            if (pSA->CONF_ALGO(Index) != IPSEC_ESP_NONE) {
                                IPSEC_DEBUG(SAAPI, ("Algo: %lx with no keymat!!: %lx\n", pSA->CONF_ALGO(Index)));
                                ASSERT(FALSE);
                                return  STATUS_INVALID_PARAMETER;
                            }
                            pSA->sa_ivlen = 0;
                        }

                        if (pSAInfo->EXT_INT_KEYLEN > 0) {
                            RtlCopyMemory(  pSA->INT_KEY(Index),
                                            (UCHAR UNALIGNED *)(pSAStruct->KeyMat + pSAInfo->EXT_CONF_KEYLEN),
                                            pSAInfo->EXT_INT_KEYLEN);
                        }

                        len = pSAInfo->EXT_CONF_KEYLEN + pSAInfo->EXT_INT_KEYLEN;
                    } else {
                        //
                        // bogus - reject
                        //
                        IPSEC_DEBUG(SAAPI, ("ESP: Key len is bogus - extra bytes: %lx, keylen in struct: %lx.\n",
                                                KeyLen-len,
                                                pSAInfo->EXT_INT_KEYLEN + pSAInfo->EXT_CONF_KEYLEN));

                        return  STATUS_INVALID_PARAMETER;
                    }
                }

                break;
            }

            default:
                IPSEC_DEBUG(SAAPI, ("IPSecPopulateSA: Bad operation\n"));
                break;
        }
    }
    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecCreateSA(
    OUT PSA_TABLE_ENTRY         *ppSA
    )
/*++

Routine Description:

    Creates a Security Association block.

Arguments:

    ppSA - returns the SA pointer

Return Value:

    STATUS_PENDING if the buffer is to be held on to, the normal case.

Notes:


--*/
{
    PSA_TABLE_ENTRY  pSA;

    IPSEC_DEBUG(SAAPI, ("Entering IPSecCreateSA\n"));

    pSA = IPSecAllocateMemory(sizeof(SA_TABLE_ENTRY), IPSEC_TAG_SA);

    if (!pSA) {
        return  STATUS_INSUFFICIENT_RESOURCES;
    }

    IPSecZeroMemory(pSA, sizeof(SA_TABLE_ENTRY));
    pSA->sa_Signature = IPSEC_SA_SIGNATURE;
    pSA->sa_NewMTU = MAX_LONG;

#if DBG
    pSA->sa_d1 = IPSEC_SA_D_1;
    pSA->sa_d2 = IPSEC_SA_D_2;
    pSA->sa_d3 = IPSEC_SA_D_3;
    pSA->sa_d4 = IPSEC_SA_D_4;
#endif

    INIT_LOCK(&pSA->sa_Lock);

    InitializeListHead(&pSA->sa_SPILinkage);
    InitializeListHead(&pSA->sa_FilterLinkage);
    InitializeListHead(&pSA->sa_LarvalLinkage);
    InitializeListHead(&pSA->sa_PendingLinkage);

    pSA->sa_Reference = 1;
    pSA->sa_State = STATE_SA_CREATED;
    pSA->sa_ExpiryTime = IPSEC_SA_EXPIRY_TIME;

    *ppSA = pSA;
    return  STATUS_SUCCESS;
}


PSA_TABLE_ENTRY
IPSecLookupSABySPI(
    IN  tSPI    SPI,
    IN  IPAddr  DestAddr
    )
/*++

Routine Description:

    Looks up the SA given the SPI and Filter variables.

Arguments:


Return Value:


Notes:

--*/
{
    KIRQL           kIrql;
    PSA_TABLE_ENTRY pSA;

    AcquireReadLock(&g_ipsec.SPIListLock, &kIrql);
    pSA = IPSecLookupSABySPIWithLock(SPI, DestAddr);
    ReleaseReadLock(&g_ipsec.SPIListLock, kIrql);
    return pSA;
}


PSA_TABLE_ENTRY
IPSecLookupSABySPIWithLock(
    IN  tSPI    SPI,
    IN  IPAddr  DestAddr
    )
/*++

Routine Description:

    Looks up the SA given the SPI and Filter variables.

    NOTE: Always call with the SPIListLock held.

Arguments:


Return Value:


Notes:

--*/
{
    PSA_HASH        pHash;
    PLIST_ENTRY     pEntry;
    PSA_TABLE_ENTRY pSA;

    //
    // get to hash bucket
    //
    IPSEC_HASH_SPI(DestAddr, SPI, pHash);

    //
    // search for specific entry in collision chain
    //
    for (   pEntry = pHash->SAList.Flink;
            pEntry != &pHash->SAList;
            pEntry = pEntry->Flink) {

        pSA = CONTAINING_RECORD(pEntry,
                                SA_TABLE_ENTRY,
                                sa_SPILinkage);

        if (pSA->sa_TunnelAddr) {
            if ((DestAddr == pSA->sa_TunnelAddr) &&
                (pSA->sa_SPI == SPI)) {
                IPSEC_DEBUG(HASH, ("Matched Tunnel entry: %lx\n", pSA));

                return  pSA;
            }
        } else {
            if ((DestAddr == pSA->SA_DEST_ADDR) &&
                (pSA->sa_SPI == SPI)) {

                IPSEC_DEBUG(HASH, ("Matched entry: %lx\n", pSA));
                return  pSA;
            }
        }
    }

    //
    // no entry found
    //
    return NULL;
}


NTSTATUS
IPSecLookupSAByAddr(
    IN  ULARGE_INTEGER  uliSrcDstAddr,
    IN  ULARGE_INTEGER  uliProtoSrcDstPort,
    OUT PFILTER         *ppFilter,
    OUT PSA_TABLE_ENTRY *ppSA,
    OUT PSA_TABLE_ENTRY *ppNextSA,
    OUT PSA_TABLE_ENTRY *ppTunnelSA,
    IN  BOOLEAN         fOutbound,
    IN  BOOLEAN         fFWPacket,
    IN  BOOLEAN         fBypass
    )
/*++

Routine Description:

    Looks up the SA given the relevant addresses.

Arguments:

    uliSrcDstAddr - src/dest IP addr
    uliProtoSrcDstPort - protocol, src/dest port
    ppFilter - filter found
    ppSA - SA found
    ppTunnelSA - tunnel SA found
    fOutbound - direction flag

Return Value:

    STATUS_SUCCESS - both filter and SA found
    STATUS_UNSUCCESSFUL - none found
    STATUS_PENDING - filter found, but no SA

Notes:

    Called with SADBLock held.

--*/
{
    PFILTER                 pFilter;
    PLIST_ENTRY             pEntry;
    PLIST_ENTRY             pFilterList;
    PLIST_ENTRY             pSAChain;
    PSA_TABLE_ENTRY         pSA;
    REGISTER ULARGE_INTEGER uliPort;
    REGISTER ULARGE_INTEGER uliAddr;
    BOOLEAN                 fFound = FALSE;

    *ppSA = NULL;
    *ppFilter = NULL;
    *ppTunnelSA = NULL;

    //
    // Search in Tunnel filters list
    //
    pFilterList = IPSecResolveFilterList(TRUE, fOutbound);

    for (   pEntry = pFilterList->Flink;
            pEntry != pFilterList;
            pEntry = pEntry->Flink) {

        pFilter = CONTAINING_RECORD(pEntry,
                                    FILTER,
                                    MaskedLinkage);

        if (fBypass && IS_EXEMPT_FILTER(pFilter)) {
            //
            // Don't search block/pass-thru filters for host bypass traffic
            //
            continue;
        }

        uliAddr.QuadPart = uliSrcDstAddr.QuadPart & pFilter->uliSrcDstMask.QuadPart;
        uliPort.QuadPart = uliProtoSrcDstPort.QuadPart & pFilter->uliProtoSrcDstMask.QuadPart;

        if ((uliAddr.QuadPart == pFilter->uliSrcDstAddr.QuadPart) &&
            (uliPort.QuadPart == pFilter->uliProtoSrcDstPort.QuadPart)) {
            IPSEC_DEBUG(HASH, ("Matched entry: %lx\n", pFilter));

            fFound = TRUE;
            break;
        }
    }

    if (fFound) {
        fFound = FALSE;
        //
        // Search for the particular SA now.
        //
        pSAChain = IPSecResolveSAChain(pFilter, fOutbound? DEST_ADDR: SRC_ADDR);

        for (   pEntry = pSAChain->Flink;
                pEntry != pSAChain;
                pEntry = pEntry->Flink) {

            pSA = CONTAINING_RECORD(pEntry,
                                    SA_TABLE_ENTRY,
                                    sa_FilterLinkage);

            ASSERT(pSA->sa_Flags & FLAGS_SA_TUNNEL);

            if (pFilter->TunnelAddr != 0) {
                //
                // match the outbound flag also
                //
                IPSEC_DEBUG(HASH, ("Matched specific tunnel entry: %lx\n", pSA));
                ASSERT(fOutbound == (BOOLEAN)((pSA->sa_Flags & FLAGS_SA_OUTBOUND) != 0));
                fFound = TRUE;
                *ppTunnelSA = pSA;
                break;
            }
        }

        if (fFound) {
            fFound = FALSE;
            *ppFilter = pFilter;
        } else {
            //
            // Found a filter entry, but need to negotiate keys
            //
            *ppFilter = pFilter;
            return  STATUS_PENDING;
        }
    }

    //
    // Search in Masked filters list
    //
    pFilterList = IPSecResolveFilterList(FALSE, fOutbound);

    for (   pEntry = pFilterList->Flink;
            pEntry != pFilterList;
            pEntry = pEntry->Flink) {

        pFilter = CONTAINING_RECORD(pEntry,
                                    FILTER,
                                    MaskedLinkage);

        if (fFWPacket && !IS_EXEMPT_FILTER(pFilter)) {
            //
            // Search only block/pass-thru filters in forward path
            //
            continue;
        }

        if (fBypass && IS_EXEMPT_FILTER(pFilter)) {
            //
            // Don't search block/pass-thru filters for host bypass traffic
            //
            continue;
        }

        uliAddr.QuadPart = uliSrcDstAddr.QuadPart & pFilter->uliSrcDstMask.QuadPart;
        uliPort.QuadPart = uliProtoSrcDstPort.QuadPart & pFilter->uliProtoSrcDstMask.QuadPart;

        if ((uliAddr.QuadPart == pFilter->uliSrcDstAddr.QuadPart) &&
            (uliPort.QuadPart == pFilter->uliProtoSrcDstPort.QuadPart)) {
            IPSEC_DEBUG(HASH, ("Matched entry: %lx\n", pFilter));

            fFound = TRUE;
            break;
        }
    }

    if (fFound) {
        //
        // Search for the particular SA now.
        //
        fFound=FALSE;
        pSAChain = IPSecResolveSAChain(pFilter, fOutbound? DEST_ADDR: SRC_ADDR);

        for (   pEntry = pSAChain->Flink;
                pEntry != pSAChain;
                pEntry = pEntry->Flink) {

            pSA = CONTAINING_RECORD(pEntry,
                                    SA_TABLE_ENTRY,
                                    sa_FilterLinkage);
            
            if (IS_CLASSD(NET_LONG(pSA->SA_SRC_ADDR))
                || IS_CLASSD(NET_LONG(pSA->SA_DEST_ADDR))) {
                uliAddr.QuadPart = uliSrcDstAddr.QuadPart & pSA->sa_uliSrcDstMask.QuadPart;
                
                IPSEC_DEBUG(HASH, ("MCAST: %d %d %d %d", uliAddr.LowPart, uliAddr.HighPart,
                            pSA->sa_uliSrcDstAddr.LowPart,pSA->sa_uliSrcDstAddr.HighPart));

                if (uliAddr.QuadPart == pSA->sa_uliSrcDstAddr.QuadPart) {
                    fFound=TRUE;
                }
            } else if (uliSrcDstAddr.QuadPart == pSA->sa_uliSrcDstAddr.QuadPart) {
                fFound=TRUE;
            }
            if (fFound) {
                IPSEC_DEBUG(HASH, ("Matched entry: %lx\n", pSA));
                ASSERT(fOutbound == (BOOLEAN)((pSA->sa_Flags & FLAGS_SA_OUTBOUND) != 0));

                //
                // if there is also a tunnel SA, associate it here.
                //
                if (*ppTunnelSA && fOutbound) {
                    *ppNextSA = *ppTunnelSA;
                    IPSEC_DEBUG(SAAPI, ("linked next sa: %lx, next: %lx", pSA, *ppTunnelSA));
                    *ppTunnelSA = NULL;
                }

                *ppFilter = pFilter;
                *ppSA = pSA;
                return  STATUS_SUCCESS;
            }
        }

        //
        // Found a filter entry, but need to negotiate keys
        //
        // Also, ppTunnelSA is set to the proper tunnel SA we need
        // to hook to this end-2-end SA once it is negotiated.
        //
        *ppFilter = pFilter;

        return  STATUS_PENDING;
    } else {
        //
        // if only tunnel SA found, return that as the SA
        // found.
        //
        if (*ppTunnelSA) {
            *ppSA = *ppTunnelSA;
            *ppTunnelSA = NULL;
            return  STATUS_SUCCESS;
        }
    }

    //
    // no entry found
    //
    return  STATUS_NOT_FOUND;
}


NTSTATUS
IPSecLookupTunnelSA(
    IN  ULARGE_INTEGER  uliSrcDstAddr,
    IN  ULARGE_INTEGER  uliProtoSrcDstPort,
    OUT PFILTER         *ppFilter,
    OUT PSA_TABLE_ENTRY *ppSA,
    IN  BOOLEAN         fOutbound
    )
/*++

Routine Description:

    Looks up the SA given the relevant addresses.

Arguments:

    uliSrcDstAddr - src/dest IP addr
    uliProtoSrcDstPort - protocol, src/dest port
    ppFilter - filter found
    ppSA - SA found
    fOutbound - direction flag

Return Value:

    STATUS_SUCCESS - both filter and SA found
    STATUS_UNSUCCESSFUL - none found
    STATUS_PENDING - filter found, but no SA

Notes:

    Called with SADBLock held.

--*/
{
    PFILTER                 pFilter;
    PLIST_ENTRY             pEntry;
    PLIST_ENTRY             pFilterList;
    PLIST_ENTRY             pSAChain;
    PSA_TABLE_ENTRY         pSA;
    REGISTER ULARGE_INTEGER uliPort;
    REGISTER ULARGE_INTEGER uliAddr;
    BOOLEAN                 fFound = FALSE;

    *ppSA = NULL;
    *ppFilter = NULL;

    //
    // Search in Tunnel filters list
    //
    pFilterList = IPSecResolveFilterList(TRUE, fOutbound);

    for (   pEntry = pFilterList->Flink;
            pEntry != pFilterList;
            pEntry = pEntry->Flink) {

        pFilter = CONTAINING_RECORD(pEntry,
                                    FILTER,
                                    MaskedLinkage);

        uliAddr.QuadPart = uliSrcDstAddr.QuadPart & pFilter->uliSrcDstMask.QuadPart;
        uliPort.QuadPart = uliProtoSrcDstPort.QuadPart & pFilter->uliProtoSrcDstMask.QuadPart;

        if ((uliAddr.QuadPart == pFilter->uliSrcDstAddr.QuadPart) &&
            (uliPort.QuadPart == pFilter->uliProtoSrcDstPort.QuadPart)) {

            IPSEC_DEBUG(HASH, ("Matched entry: %lx\n", pFilter));
            fFound = TRUE;
            break;
        }
    }

    if (fFound) {
        //
        // Search for the particular SA now.
        //
        pSAChain = IPSecResolveSAChain(pFilter, fOutbound? DEST_ADDR: SRC_ADDR);

        for (   pEntry = pSAChain->Flink;
                pEntry != pSAChain;
                pEntry = pEntry->Flink) {

            pSA = CONTAINING_RECORD(pEntry,
                                    SA_TABLE_ENTRY,
                                    sa_FilterLinkage);

            ASSERT(pSA->sa_Flags & FLAGS_SA_TUNNEL);

            if (pFilter->TunnelAddr != 0) {
                //
                // match the outbound flag also
                //
                IPSEC_DEBUG(HASH, ("Matched specific tunnel entry: %lx\n", pSA));
                ASSERT(fOutbound == (BOOLEAN)((pSA->sa_Flags & FLAGS_SA_OUTBOUND) != 0));
                *ppFilter = pFilter;
                *ppSA = pSA;
                return  STATUS_SUCCESS;
            }
        }

        //
        // Found a filter entry, but need to negotiate keys
        //
        *ppFilter = pFilter;
        return  STATUS_PENDING;
    }

    //
    // no entry found
    //
    return  STATUS_NOT_FOUND;
}


NTSTATUS
IPSecLookupMaskedSA(
    IN  ULARGE_INTEGER  uliSrcDstAddr,
    IN  ULARGE_INTEGER  uliProtoSrcDstPort,
    OUT PFILTER         *ppFilter,
    OUT PSA_TABLE_ENTRY *ppSA,
    IN  BOOLEAN         fOutbound
    )
/*++

Routine Description:

    Looks up the SA given the relevant addresses.

Arguments:

    uliSrcDstAddr - src/dest IP addr
    uliProtoSrcDstPort - protocol, src/dest port
    ppFilter - filter found
    ppSA - SA found
    fOutbound - direction flag

Return Value:

    STATUS_SUCCESS - both filter and SA found
    STATUS_UNSUCCESSFUL - none found
    STATUS_PENDING - filter found, but no SA

Notes:

    Called with SADBLock held.

--*/
{
    PFILTER                 pFilter;
    PLIST_ENTRY             pEntry;
    PLIST_ENTRY             pFilterList;
    PLIST_ENTRY             pSAChain;
    PSA_TABLE_ENTRY         pSA;
    REGISTER ULARGE_INTEGER uliPort;
    REGISTER ULARGE_INTEGER uliAddr;
    BOOLEAN                 fFound = FALSE;

    *ppSA = NULL;
    *ppFilter = NULL;

    //
    // Search in Masked filters list
    //
    pFilterList = IPSecResolveFilterList(FALSE, fOutbound);

    for (   pEntry = pFilterList->Flink;
            pEntry != pFilterList;
            pEntry = pEntry->Flink) {

        pFilter = CONTAINING_RECORD(pEntry,
                                    FILTER,
                                    MaskedLinkage);

        uliAddr.QuadPart = uliSrcDstAddr.QuadPart & pFilter->uliSrcDstMask.QuadPart;
        uliPort.QuadPart = uliProtoSrcDstPort.QuadPart & pFilter->uliProtoSrcDstMask.QuadPart;

        if ((uliAddr.QuadPart == pFilter->uliSrcDstAddr.QuadPart) &&
            (uliPort.QuadPart == pFilter->uliProtoSrcDstPort.QuadPart)) {

            IPSEC_DEBUG(HASH, ("Matched entry: %lx\n", pFilter));
            fFound = TRUE;
            break;
        }
    }

    if (fFound) {
        //
        // Search for the particular SA now.
        //
        pSAChain = IPSecResolveSAChain(pFilter, fOutbound? DEST_ADDR: SRC_ADDR);

        for (   pEntry = pSAChain->Flink;
                pEntry != pSAChain;
                pEntry = pEntry->Flink) {

            pSA = CONTAINING_RECORD(pEntry,
                                    SA_TABLE_ENTRY,
                                    sa_FilterLinkage);

            if (uliSrcDstAddr.QuadPart == pSA->sa_uliSrcDstAddr.QuadPart) {
                IPSEC_DEBUG(HASH, ("Matched entry: %lx\n", pSA));
                ASSERT(fOutbound == (BOOLEAN)((pSA->sa_Flags & FLAGS_SA_OUTBOUND) != 0));
                *ppFilter = pFilter;
                *ppSA = pSA;
                return  STATUS_SUCCESS;
            }
        }

        //
        // Found a filter entry, but need to negotiate keys
        //
        *ppFilter = pFilter;
        return  STATUS_PENDING;
    }

    //
    // no entry found
    //
    return  STATUS_NOT_FOUND;
}


NTSTATUS
IPSecAllocateSPI(
    OUT tSPI            * pSpi,
    IN  PSA_TABLE_ENTRY   pSA
    )
/*++

Routine Description:

    Allocates an SPI for an incoming SA - guards against collisions

Arguments:

    pSpi - the SPI allocated is filled in here

    pSA - SA for which SPI is needed

Return Value:


Notes:

--*/
{
    ULONG   rand;
    ULONG   numRetries = 0;
    IPAddr  DestAddr;

    if (pSA->sa_TunnelAddr) {
        DestAddr = pSA->sa_TunnelAddr;
    } else {
        DestAddr = pSA->SA_DEST_ADDR;
    }

    //
    // if SPI passed in, use that spi else allocate one.
    //
    if (*pSpi) {
        if (IPSecLookupSABySPIWithLock(
                                *pSpi,
                                DestAddr)) {
            return STATUS_UNSUCCESSFUL;
        } else {
            return STATUS_SUCCESS;
        }
    } else {
        rand = (ULONG)(ULONG_PTR)pSA;
        IPSecGenerateRandom((PUCHAR)&rand, sizeof(ULONG));
        rand = LOWER_BOUND_SPI + rand % (UPPER_BOUND_SPI - LOWER_BOUND_SPI);

        while (numRetries++ < MAX_SPI_RETRIES) {

            if (!IPSecLookupSABySPIWithLock(
                                    (tSPI)rand,
                                    DestAddr)) {
                *pSpi = (tSPI)rand;
                return STATUS_SUCCESS;
            }

            rand++;

            //
            // Collision, retry
            //
            IPSEC_DEBUG(ACQUIRE, ("IPSecAllocateSPI: collision for: %lx\n", rand));
        }
    }

    return STATUS_UNSUCCESSFUL;
}


NTSTATUS
IPSecNegotiateSA(
    IN  PFILTER         pFilter,
    IN  ULARGE_INTEGER  uliSrcDstAddr,
    IN  ULARGE_INTEGER  uliProtoSrcDstPort,
    IN  ULONG           NewMTU,
    OUT PSA_TABLE_ENTRY *ppSA,
    IN  UCHAR           DestType
    )
/*++

Routine Description:

    Allocates a Larval Inbound SA block then kicks off key manager to negotiate
    the algorithms/keys.

    Called with SADB lock held, returns with it.

Arguments:

    pFilter - the filter and policy that matched this packet.

    ppSA - returns the SA created here.

Return Value:

    STATUS_PENDING if the buffer is to be held on to, the normal case.

Notes:


--*/
{
    KIRQL	        kIrql;
    KIRQL	        OldIrq;
    NTSTATUS        status;
    PSA_TABLE_ENTRY pSA;

    //
    // Make sure we dont already have this SA under negotiation
    // walk the LarvalSA list to see if we can find another SA.
    //
    pSA = IPSecLookupSAInLarval(uliSrcDstAddr, uliProtoSrcDstPort);
    if (pSA != NULL) {
        IPSEC_DEBUG(PATTERN, ("Found in Larval: %lx\n", pSA));
        *ppSA = pSA;
        return  STATUS_DUPLICATE_OBJECTID;
    }

    IPSEC_DEBUG(ACQUIRE, ("IPSecNegotiateSA: SA: %lx, DA: %lx, P: %lx, SP: %lx, DP: %lx\n", SRC_ADDR, DEST_ADDR, PROTO, SRC_PORT, DEST_PORT));

    //
    // Initiator
    //
    status = IPSecInitiatorCreateLarvalSA(
                 pFilter, 
                 uliSrcDstAddr,
                 ppSA,
                 DestType
                 );

    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(SAAPI, ("IPSecNegotiateSA: IPSecCreateSA failed: %lx\n", status));
        return status;
    }

    //
    // Save the NewMTU value if this SA has been PMTU'd.
    //
    (*ppSA)->sa_NewMTU = NewMTU;

    //
    // If this is a tunnel filter to be negotiated, save off the tunnel addr in the
    // SA.
    //
    if (pFilter->TunnelFilter) {
        IPSEC_DEBUG(TUNNEL, ("Negotiating tunnel SA: %lx\n", (*ppSA)));
        // (*ppSA)->sa_TunnelAddr = pFilter->TunnelAddr;
    }

    //
    // Now send this up to the Key Manager to negotiate the keys
    //
    ACQUIRE_LOCK(&g_ipsec.AcquireInfo.Lock, &OldIrq);
    status = IPSecSubmitAcquire(*ppSA, OldIrq, FALSE);

    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(SAAPI, ("IPSecNegotiateSA: IPSecSubmitAcquire failed: %lx\n", status));

        ACQUIRE_LOCK(&g_ipsec.LarvalListLock, &kIrql);
        IPSecRemoveEntryList(&(*ppSA)->sa_LarvalLinkage);
        IPSEC_DEC_STATISTIC(dwNumPendingKeyOps);
        RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);

        AcquireWriteLock(&g_ipsec.SPIListLock, &kIrql);
        IPSecRemoveSPIEntry(*ppSA);
        ReleaseWriteLock(&g_ipsec.SPIListLock, kIrql);

        //
        // also remove from the filter list
        //
        if ((*ppSA)->sa_Flags & FLAGS_SA_ON_FILTER_LIST) {
            (*ppSA)->sa_Flags &= ~FLAGS_SA_ON_FILTER_LIST;
            IPSecRemoveEntryList(&(*ppSA)->sa_FilterLinkage);
            (*ppSA)->sa_Filter = NULL;
        }

        if ((*ppSA)->sa_RekeyOriginalSA) {
            ASSERT((*ppSA)->sa_Flags & FLAGS_SA_REKEY);
            ASSERT((*ppSA)->sa_RekeyOriginalSA->sa_RekeyLarvalSA == (*ppSA));
            ASSERT((*ppSA)->sa_RekeyOriginalSA->sa_Flags & FLAGS_SA_REKEY_ORI);

            (*ppSA)->sa_RekeyOriginalSA->sa_Flags &= ~FLAGS_SA_REKEY_ORI;
            (*ppSA)->sa_RekeyOriginalSA->sa_RekeyLarvalSA = NULL;
            (*ppSA)->sa_RekeyOriginalSA = NULL;
        }

        (*ppSA)->sa_Flags &= ~FLAGS_SA_TIMER_STARTED;
        IPSecStopTimer(&(*ppSA)->sa_Timer);
        IPSecDerefSA(*ppSA);
        return status;
    }

    return status;
}


VOID
IPSecFlushQueuedPackets(
    IN  PSA_TABLE_ENTRY         pSA,
    IN  NTSTATUS                status
    )
/*++

Routine Description:

    Flushes queued packets now that the keys are known

Arguments:


Return Value:


Notes:

--*/
{
    PIPSEC_SEND_COMPLETE_CONTEXT pContext;
    IPOptInfo       optInfo;
    ULONG           len;
    PNDIS_BUFFER    pHdrMdl;
    ULONG           dataLen;
    IPHeader UNALIGNED * pIPH;
    KIRQL	        kIrql;

    //
    // We need to acquire a lock here because this routine can be called in
    // parallel with one in SA delete and the other in SA update (normal).
    //
    ACQUIRE_LOCK(&pSA->sa_Lock, &kIrql);
    pHdrMdl = pSA->sa_BlockedBuffer;
    dataLen = pSA->sa_BlockedDataLen;

    pSA->sa_BlockedBuffer = NULL;
    pSA->sa_BlockedDataLen = 0;
    RELEASE_LOCK(&pSA->sa_Lock, kIrql);

    if (!pHdrMdl) {
        IPSEC_DEBUG(ACQUIRE, ("FlushQueuedPackets: pHdrMdl == NULL\n"));
        return;
    }

    if (status == STATUS_SUCCESS) {
        ASSERT(pSA->sa_State == STATE_SA_ACTIVE);
        ASSERT((pSA->sa_Flags & FLAGS_SA_OUTBOUND) == 0);
        ASSERT(pHdrMdl);

        pContext = IPSecAllocateSendCompleteCtx(IPSEC_TAG_ESP);

        if (!pContext) {
            PNDIS_BUFFER    pNextMdl;
            PNDIS_BUFFER    pMdl = pHdrMdl;
            NTSTATUS        status;

            IPSEC_DEBUG(ESP, ("Failed to alloc. SendCtx\n"));

            ASSERT(pMdl);

            while (pMdl) {
                pNextMdl = NDIS_BUFFER_LINKAGE(pMdl);
                IPSecFreeBuffer(&status, pMdl);
                pMdl = pNextMdl;
            }

            return;
        }

        IPSEC_INCREMENT(g_ipsec.NumSends);

        IPSecZeroMemory(pContext, sizeof(IPSEC_SEND_COMPLETE_CONTEXT));

#if DBG
        RtlCopyMemory(pContext->Signature, "ISC6", 4);
#endif

        pContext->FlushMdl = pHdrMdl;
        pContext->Flags |= SCF_FLUSH;

        IPSecQueryNdisBuf(pHdrMdl, (PVOID)&pIPH, &len);

        //
        // Call IPTransmit with proper Protocol type so it takes this packet
        // at *face* value.
        //
        optInfo = g_ipsec.OptInfo;
        optInfo.ioi_flags |= IP_FLAG_IPSEC;
        status = TCPIP_IP_TRANSMIT( &g_ipsec.IPProtInfo,
                                    pContext,
                                    pHdrMdl,
                                    dataLen,
                                    pIPH->iph_dest,
                                    pIPH->iph_src,
                                    &optInfo,
                                    NULL,
                                    pIPH->iph_protocol,
                                    NULL);

        //
        // Even in the synchronous case, we free the MDL chain in ProtocolSendComplete
        // (called by IPSecSendComplete). So, we dont call anything here.
        // See IPSecReinjectPacket.
        //
    } else {
        PNDIS_BUFFER    pNextMdl;
        PNDIS_BUFFER    pMdl = pHdrMdl;
        NTSTATUS        status;

        ASSERT(pMdl);

        while (pMdl) {
            pNextMdl = NDIS_BUFFER_LINKAGE(pMdl);
            IPSecFreeBuffer(&status, pMdl);
            pMdl = pNextMdl;
        }
    }

    return;
}


NTSTATUS
IPSecInsertOutboundSA(
    IN  PSA_TABLE_ENTRY         pSA,
    IN  PIPSEC_ACQUIRE_CONTEXT  pAcquireCtx,
    IN  BOOLEAN                 fTunnelFilter
    )
/*++

Routine Description:

    Adds an SA into the database, typically called to add outbound SAs as a
    result of successful negotiation of keys corresponding to the inbound SA
    specified in the context that comes down.

    NOTE: Called with SADB lock held.

Arguments:

    pSA - SA to be inserted

    pAcquireContext - The Acquire context

Return Value:


Notes:

--*/
{
    PSA_TABLE_ENTRY pInboundSA = pAcquireCtx->pSA;
    PSA_TABLE_ENTRY pAssociatedSA;
    KIRQL	        kIrql;
    KIRQL	        kIrql1;
    NTSTATUS        status;
    PFILTER         pFilter;
    PSA_TABLE_ENTRY pOutboundSA = NULL;
    PSA_TABLE_ENTRY pTunnelSA = NULL;
    PLIST_ENTRY     pSAChain;

    ASSERT(pSA->sa_Flags & FLAGS_SA_OUTBOUND);
    ASSERT((pInboundSA->sa_Flags & FLAGS_SA_OUTBOUND) == 0);
    ASSERT(pInboundSA->sa_State == STATE_SA_LARVAL);

    //
    // Potential dangling pointer, always go through the lookup path.
    //
    if (fTunnelFilter) {
        status = IPSecLookupTunnelSA(   pSA->sa_uliSrcDstAddr,
                                        pSA->sa_uliProtoSrcDstPort,
                                        &pFilter,
                                        &pOutboundSA,
                                        TRUE);
    } else {
#if GPC
        if (IS_GPC_ACTIVE()) {
            status = IPSecLookupGpcMaskedSA(pSA->sa_uliSrcDstAddr,
                                            pSA->sa_uliProtoSrcDstPort,
                                            &pFilter,
                                            &pOutboundSA,
                                            TRUE);
        } else {
            status = IPSecLookupMaskedSA(   pSA->sa_uliSrcDstAddr,
                                            pSA->sa_uliProtoSrcDstPort,
                                            &pFilter,
                                            &pOutboundSA,
                                            TRUE);
        }
#else
        status = IPSecLookupMaskedSA(   pSA->sa_uliSrcDstAddr,
                                        pSA->sa_uliProtoSrcDstPort,
                                        &pFilter,
                                        &pOutboundSA,
                                        TRUE);
#endif
    }

    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(ACQUIRE, ("IPSecInsertOutboundSA: IPSecLookupSAByAddr failed: %lx\n", status));
        return status;
    }

    pSAChain = IPSecResolveSAChain(pFilter, pSA->SA_DEST_ADDR);

    if (status == STATUS_SUCCESS) {
        //
        // re-negotiate case: delete the outbound; expire the inbound; add the new one.
        //
        IPSEC_DEBUG(ACQUIRE, ("IPSecInsertOutboundSA: found another: %lx\n", pOutboundSA));
        ASSERT(pOutboundSA);
        ASSERT(pOutboundSA->sa_Flags & FLAGS_SA_OUTBOUND);

        pSA->sa_Filter = pFilter;
        pSA->sa_Flags |= FLAGS_SA_ON_FILTER_LIST;
        InsertHeadList(pSAChain, &pSA->sa_FilterLinkage);

        IPSEC_INC_STATISTIC(dwNumReKeys);

        pAssociatedSA = pOutboundSA->sa_AssociatedSA;
        if (pAssociatedSA &&
            ((pOutboundSA->sa_Flags & FLAGS_SA_REKEY_ORI) ||
             !(pInboundSA->sa_Filter))) {
            IPSecExpireInboundSA(pAssociatedSA);
        }
    } else {
        //
        // pending => this will be the add.
        //
        ASSERT(pOutboundSA == NULL);
        pSA->sa_Filter = pFilter;
        pSA->sa_Flags |= FLAGS_SA_ON_FILTER_LIST;
        InsertHeadList(pSAChain, &pSA->sa_FilterLinkage);
    }

    if (pFilter->TunnelAddr != 0) {
        pSA->sa_Flags |= FLAGS_SA_TUNNEL;
        pSA->sa_TunnelAddr = pFilter->TunnelAddr;
    }

    //
    // Initiator if the original SA had a filter pointer.
    //
    if (pInboundSA->sa_Filter) {
        pSA->sa_Flags |= FLAGS_SA_INITIATOR;
    }

    //
    // Flush this filter from cache table so we match the SA next.
    //
    if (IS_EXEMPT_FILTER(pFilter)) {
        IPSecInvalidateFilterCacheEntry(pFilter);
    }

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecAddSA(
    IN  PIPSEC_ADD_SA   pAddSA,
    IN  ULONG           TotalSize
    )
/*++

Routine Description:

    Adds an SA into the database, typically called to add outbound SAs as a
    result of successful negotiation of keys corresponding to the inbound SA
    specified in the context that comes down.

Arguments:

    pAddSA - Add SA context and info.

    TotalSize - the total size of the input buffer.

Return Value:


Notes:


--*/
{
    NTSTATUS        status = STATUS_SUCCESS;
    PSA_STRUCT      saInfo = &pAddSA->SAInfo;
    PSA_TABLE_ENTRY pSA;
    ULONG           keyLen = 0;
    PSA_TABLE_ENTRY pInboundSA;
    KIRQL	        kIrql;
    KIRQL	        kIrql1;
    PIPSEC_ACQUIRE_CONTEXT  pAcquireContext = (PIPSEC_ACQUIRE_CONTEXT)(saInfo->Context);

    //
    // Lock the larval list so this SA does not go away.
    //
    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql1);
    ACQUIRE_LOCK(&g_ipsec.LarvalListLock, &kIrql);

    //
    // Sanity check the incoming context to see if it is actually
    // an SA block
    //
    if (!NT_SUCCESS(IPSecValidateHandle(pAcquireContext, STATE_SA_LARVAL))) {
        IPSEC_DEBUG(SAAPI, ("IPSecAddSA: invalid context: %lx\n", pAcquireContext));
        RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);
        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql1);
        return  STATUS_INVALID_PARAMETER;
    }

    //
    // figure out the key length and pass that in
    //
    keyLen = TotalSize - IPSEC_ADD_SA_NO_KEY_SIZE;
    IPSEC_DEBUG(SAAPI, ("IPSecAddSA: keyLen: %d\n", keyLen));

    //
    // create SA block
    //
    status = IPSecCreateSA(&pSA);

    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(SAAPI, ("IPSecAddSA: IPSecCreateSA failed: %lx\n", status));
        IPSecAbortAcquire(pAcquireContext);
        RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);
        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql1);
        return status;
    }

    pSA->sa_Flags |= FLAGS_SA_OUTBOUND;

    //
    // Populate with the info in AddSA
    //
    status = IPSecPopulateSA(saInfo, keyLen, pSA);

    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(SAAPI, ("IPSecAddSA: IPSecPopulateSA failed: %lx\n", status));
        // IPSecPopulateSA will not free the outbound SA so we have to do it.
        IPSecFreeSA(pSA);
        IPSecAbortAcquire(pAcquireContext);
        RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);
        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql1);
        return status;
    }

    //
    // Stash the outermost spi
    //
    pSA->sa_SPI = pSA->sa_OtherSPIs[pSA->sa_NumOps-1];

    //
    // insert into proper tables
    //
    status = IPSecInsertOutboundSA(pSA, pAcquireContext, (BOOLEAN)((pSA->sa_Flags & FLAGS_SA_TUNNEL) != 0));

    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(SAAPI, ("IPSecAddSA: IPSecInsertOutboundSA failed: %lx\n", status));
        IPSecFreeSA(pSA);
        IPSecAbortAcquire(pAcquireContext);
        RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);
        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql1);
        return status;
    }

    pInboundSA = pAcquireContext->pSA;

    //
    // Associate the inbound and outbound SAs
    //
    pSA->sa_AssociatedSA = pInboundSA;
    pInboundSA->sa_AssociatedSA = pSA;
    pInboundSA->sa_State = STATE_SA_ASSOCIATED;

    //
    // Initialize IPSec overhead for the outbound SA.
    //
    IPSecCalcHeaderOverheadFromSA(pSA, &pSA->sa_IPSecOverhead);

    // Copy the NewMTU value over to the new SA.
    //
    pSA->sa_NewMTU = pInboundSA->sa_NewMTU;

    //
    // Adjust SA lifetime to the maximum/minimum allowed in driver
    //
    if (pSA->sa_Lifetime.KeyExpirationTime > IPSEC_MAX_EXPIRE_TIME) {
        pSA->sa_Lifetime.KeyExpirationTime = IPSEC_MAX_EXPIRE_TIME;
    }

    if (pSA->sa_Lifetime.KeyExpirationTime &&
        pSA->sa_Lifetime.KeyExpirationTime < IPSEC_MIN_EXPIRE_TIME) {
        pSA->sa_Lifetime.KeyExpirationTime = IPSEC_MIN_EXPIRE_TIME;
    }

    //
    // Setup lifetime characteristics
    //
    IPSecSetupSALifetime(pSA);

    //
    // Init the LastUsedTime
    //
    NdisGetCurrentSystemTime(&pSA->sa_LastUsedTime);

    //
    // outbound is ready to go!
    //
    pSA->sa_State = STATE_SA_ACTIVE;

    IPSEC_DEBUG(SA, ("IPSecAddSA: SA: %lx, S:%lx, D:%lx, O: %c\n",
                pSA,
                pSA->SA_SRC_ADDR,
                pSA->SA_DEST_ADDR,
                (pSA->sa_Operation[0] == Auth) ?
                    'A' : (pSA->sa_Operation[0] == Encrypt) ?
                        'E' : 'N'));

    IPSEC_INC_STATISTIC(dwNumActiveAssociations);
    IPSEC_INC_TUNNELS(pSA);
    IPSEC_INCREMENT(g_ipsec.NumOutboundSAs);
    IPSEC_INC_STATISTIC(dwNumKeyAdditions);

    if (pSA->sa_Operation[0] != None) {
        RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);
        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql1);
    } else {
        //
        // The key manager doesnt call update for None;
        // call it ourselves.
        //
        IPSEC_UPDATE_SA   updSA;

        ASSERT(pInboundSA->sa_Flags & FLAGS_SA_TIMER_STARTED);
        IPSEC_DEBUG(SA, ("Calling update on InboundSA: %lx\n", pInboundSA));

        RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);
        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql1);

        //
        // Reverse the addresses/ports here (by copying from the InboundSA)
        //
        updSA.SAInfo.Context = pAddSA->SAInfo.Context;
        updSA.SAInfo.NumSAs = pAddSA->SAInfo.NumSAs;
        updSA.SAInfo.Flags = pAddSA->SAInfo.Flags;
        updSA.SAInfo.TunnelAddr = pAddSA->SAInfo.TunnelAddr;
        updSA.SAInfo.Lifetime = pAddSA->SAInfo.Lifetime;
        updSA.SAInfo.InstantiatedFilter = pAddSA->SAInfo.InstantiatedFilter;
        updSA.SAInfo.SecAssoc[0] = pAddSA->SAInfo.SecAssoc[0];

        updSA.SAInfo.SecAssoc[0].SPI = pInboundSA->sa_SPI;
        updSA.SAInfo.InstantiatedFilter.SrcAddr = pInboundSA->SA_SRC_ADDR;
        updSA.SAInfo.InstantiatedFilter.DestAddr = pInboundSA->SA_DEST_ADDR;

        updSA.SAInfo.InstantiatedFilter.Protocol = pInboundSA->SA_PROTO;
        updSA.SAInfo.InstantiatedFilter.SrcPort = SA_SRC_PORT(pInboundSA);
        updSA.SAInfo.InstantiatedFilter.DestPort = SA_DEST_PORT(pInboundSA);

        status = IPSecUpdateSA(&updSA, TotalSize);
    }

    return status;
}


NTSTATUS
IPSecUpdateSA(
    IN  PIPSEC_UPDATE_SA    pUpdateSA,
    IN  ULONG               TotalSize
    )
/*++

Routine Description:

    Updates an inbound SA for which negotiation was kicked off via AcquireSA with
    the relevant keys/algorithms etc.

    By the time this routine is called, the SA should be ASSOCIATED with an outbound
    SA.

Arguments:

    pUpdateSA - Update SA context and info.

    TotalSize - the total size of the input buffer.

Return Value:


Notes:


--*/
{
    NTSTATUS        status = STATUS_SUCCESS;
    PSA_STRUCT      saInfo = &pUpdateSA->SAInfo;
    PSA_TABLE_ENTRY pSA;
    PSA_TABLE_ENTRY pOutboundSA;
    PSA_HASH        pHash;
    ULONG           keyLen = 0;
    KIRQL	        kIrql;
    KIRQL	        kIrql1;
    KIRQL	        kIrql2;
    PIPSEC_ACQUIRE_CONTEXT  pAcquireContext = (PIPSEC_ACQUIRE_CONTEXT)(saInfo->Context);

    IPSEC_DEBUG(SAAPI, ("IPSecUpdateSA\n"));

    //
    // Lock the larval list so this SA does not go away.
    //
    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql1);
    ACQUIRE_LOCK(&g_ipsec.LarvalListLock, &kIrql);

    //
    // Sanity check the incoming context to see if it is actually
    // an SA block
    //
    if (!NT_SUCCESS(IPSecValidateHandle(pAcquireContext, STATE_SA_ASSOCIATED))) {
        IPSEC_DEBUG(SAAPI, ("IPSecUpdSA: invalid context: %lx\n", pAcquireContext));
        RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);
        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql1);
        return  STATUS_INVALID_PARAMETER;
    }

    pSA = pAcquireContext->pSA;

    ASSERT((pSA->sa_Flags & FLAGS_SA_OUTBOUND) == 0);
    ASSERT(pSA->sa_State == STATE_SA_ASSOCIATED);

    //
    // figure out the key length and pass that in
    //
    keyLen = TotalSize - IPSEC_UPDATE_SA_NO_KEY_SIZE;

    IPSEC_DEBUG(SAAPI, ("IPSecUpdSA: keyLen: %d\n", keyLen));

    //
    // sanity check the info passed in against the initial SA
    //
    if (pSA->sa_Filter) {
        status = IPSecCheckInboundSA(saInfo, pSA);

        if (!NT_SUCCESS(status) ||
            !pSA->sa_AssociatedSA) {
            IPSEC_DEBUG(SAAPI, ("IPSecUpdSA: IPSecCheckInboundSA failed: %lx\n", status));
            IPSecAbortAcquire(pAcquireContext);
            RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);
            ReleaseWriteLock(&g_ipsec.SADBLock, kIrql1);
            return status;
        }
    }

    //
    // Populate the SA block
    //
    status = IPSecPopulateSA(saInfo, keyLen, pSA);

    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(SAAPI, ("IPSecUpdSA: IPSecPopulateSA failed: %lx\n", status));
        // No need to free inbound SA since IPSecAbortAcquire will do it.
        IPSecAbortAcquire(pAcquireContext);
        RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);
        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql1);
        return status;
    }

    //
    // Set the source Tunnel IP address in outbound SA
    //
    if (pOutboundSA = pSA->sa_AssociatedSA) {
        //
        // See if we have well-associated SAs
        //
        ASSERT(pSA == pSA->sa_AssociatedSA->sa_AssociatedSA);

        if (pSA->sa_Flags & FLAGS_SA_TUNNEL) {
            pOutboundSA->sa_SrcTunnelAddr = pSA->sa_TunnelAddr;
        }
        if (pOutboundSA->sa_Flags & FLAGS_SA_TUNNEL) {
            pSA->sa_SrcTunnelAddr = pOutboundSA->sa_TunnelAddr;
        }
    }

    //
    // Expire the original SA that kicked off this rekey
    //
    if (pSA->sa_Flags & FLAGS_SA_REKEY) {
        PSA_TABLE_ENTRY pOriSA;

        if (pOriSA = pSA->sa_RekeyOriginalSA) {
            KIRQL   kIrql;

            pSA->sa_RekeyOriginalSA = NULL;
            IPSEC_DEBUG(SA, ("Deleting original SA: pSA: %lx\n", pOriSA));

            if (pOriSA->sa_AssociatedSA) {
                IPSecExpireInboundSA(pOriSA->sa_AssociatedSA);
            }
            IPSEC_INC_STATISTIC(dwNumReKeys);
        }
    }

    //
    // inbound is ready to go!
    //
    pSA->sa_State = STATE_SA_ACTIVE;

    IPSEC_DEBUG(SA, ("IPSecUpdateSA: SA: %lx, S:%lx, D:%lx, O: %c\n",
                pSA,
                pSA->SA_SRC_ADDR,
                pSA->SA_DEST_ADDR,
                (pSA->sa_Operation[0] == Auth) ?
                    'A' : (pSA->sa_Operation[0] == Encrypt) ?
                        'E' : 'N'));

    //
    // Remove from larval list
    //
    IPSecRemoveEntryList(&pSA->sa_LarvalLinkage);
    IPSEC_DEC_STATISTIC(dwNumPendingKeyOps);

    RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);

    ASSERT(pSA->sa_Flags & FLAGS_SA_TIMER_STARTED);

    //
    // Bump the SA count for flush SA use; this is necessary because we flush
    // SA after releasing the lock because classification routine needs
    // it and the SA can be deleted right after we release the lock.
    //
    IPSecRefSA(pSA);

    //
    // Free the Acquire Context
    //
    ACQUIRE_LOCK(&pSA->sa_Lock, &kIrql);

    if (pSA->sa_AcquireCtx) {
        IPSecInvalidateHandle(pSA->sa_AcquireCtx);
        pSA->sa_AcquireCtx = NULL;
    }

    //
    // Adjust SA lifetime to the maximum/minimum allowed in driver
    //
    if (pSA->sa_Lifetime.KeyExpirationTime > IPSEC_MAX_EXPIRE_TIME) {
        pSA->sa_Lifetime.KeyExpirationTime = IPSEC_MAX_EXPIRE_TIME;
    }

    if (pSA->sa_Lifetime.KeyExpirationTime &&
        pSA->sa_Lifetime.KeyExpirationTime < IPSEC_MIN_EXPIRE_TIME) {
        pSA->sa_Lifetime.KeyExpirationTime = IPSEC_MIN_EXPIRE_TIME;
    }

   //
    // Setup lifetime characteristics
    //
    IPSecSetupSALifetime(pSA);

    //
    // Init the LastUsedTime
    //
    NdisGetCurrentSystemTime(&pSA->sa_LastUsedTime);


    if ((pSA->sa_Flags & FLAGS_SA_DISABLE_LIFETIME_CHECK)) {

        if (!IPSecStopTimer(&(pSA->sa_Timer))) {
            IPSEC_DEBUG(TIMER, ("Update: couldnt stop timer: %lx\n", pSA));
        }
        pSA->sa_Flags &= ~FLAGS_SA_TIMER_STARTED;
    } else {

        //
        // Reschedules the timer on this new value.
        //
        if (pSA->sa_Lifetime.KeyExpirationTime) {
            if (IPSecStopTimer(&pSA->sa_Timer)) {
                IPSecStartTimer(&pSA->sa_Timer,
                                IPSecSAExpired,
                                pSA->sa_Lifetime.KeyExpirationTime,              // expire in key expiration secs
                                (PVOID)pSA);
            }
        } else {
            ASSERT(FALSE);
            if (!IPSecStopTimer(&(pSA->sa_Timer))) {
                IPSEC_DEBUG(TIMER, ("Update: couldnt stop timer: %lx\n", pSA));
            }
            pSA->sa_Flags &= ~FLAGS_SA_TIMER_STARTED;
        }

    }
    RELEASE_LOCK(&pSA->sa_Lock, kIrql);

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql1);

    //
    // Flush all the queued packets
    //
    IPSecFlushQueuedPackets(pSA, STATUS_SUCCESS);
    IPSecDerefSA(pSA);

    return  status;
}


VOID
IPSecRefSA(
    IN  PSA_TABLE_ENTRY         pSA
    )
/*++

Routine Description:

    Reference the SA passed in

Arguments:

    pSA - SA to be refed

Return Value:

    The final status from the operation.

--*/
{
    if (IPSEC_INCREMENT(pSA->sa_Reference) == 1) {
        ASSERT(FALSE);
    }
}


VOID
IPSecDerefSA(
    IN  PSA_TABLE_ENTRY         pSA
    )
/*++

Routine Description:

    Dereference the SA passed in; if refcount drops to 0, free the block.

Arguments:

    pSA - SA to be derefed

Return Value:

    The final status from the operation.

--*/
{
    ULONG   val;

    if ((val = IPSEC_DECREMENT(pSA->sa_Reference)) == 0) {
        //
        // last reference - destroy SA
        //
        IPSEC_DEBUG(REF, ("Freeing SA: %lx\n", pSA));

#if DBG
        if ((pSA->sa_Flags & FLAGS_SA_HW_PLUMBED)) {
            DbgPrint("Freeing SA: %lx with offload on\n", pSA);
            DbgBreakPoint();
        }

        if (IPSEC_GET_VALUE(pSA->sa_NumSends) != 0) {
            DbgPrint("Freeing SA: %lx with numsends > 0\n", pSA);
            DbgBreakPoint();
        }

        if ((pSA->sa_Flags & FLAGS_SA_TIMER_STARTED)) {
            DbgPrint("Freeing SA: %lx with timer on\n", pSA);
            DbgBreakPoint();
        }

        if (pSA->sa_Signature != IPSEC_SA_SIGNATURE) {
            DbgPrint("Signature doesnt match for SA: %lx\n", pSA);
            DbgBreakPoint();
        }

        if (!IPSEC_DRIVER_IS_INACTIVE() &&
            (pSA->sa_Flags & FLAGS_SA_ON_FILTER_LIST)) {
            DbgPrint("Freeing SA: %lx while still on filter list\n", pSA);
            DbgBreakPoint();
        }
#endif

        pSA->sa_Signature = IPSEC_SA_SIGNATURE + 1;

        IPSecFreeSA(pSA);
    }

    ASSERT((LONG)val >= 0);
}


VOID
IPSecStopSATimers()
/*++

Routine Description:

    Stop all timers active on Larval SA list and Filter list.

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    PLIST_ENTRY     pFilterEntry;
    PLIST_ENTRY     pSAEntry;
    PFILTER         pFilter;
    PSA_TABLE_ENTRY pSA;
    KIRQL           kIrql;
    LONG            Index;
    LONG            SAIndex;

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    //
    // Go through all SA's and stop its timers
    //
    for (   Index = MIN_FILTER;
            Index <= MAX_FILTER;
            Index++) {

        for (   pFilterEntry = g_ipsec.FilterList[Index].Flink;
                pFilterEntry != &g_ipsec.FilterList[Index];
                pFilterEntry = pFilterEntry->Flink) {

            pFilter = CONTAINING_RECORD(pFilterEntry,
                                        FILTER,
                                        MaskedLinkage);

            for (   SAIndex = 0;
                    SAIndex < pFilter->SAChainSize;
                    SAIndex++) {

                for (   pSAEntry = pFilter->SAChain[SAIndex].Flink;
                        pSAEntry != &pFilter->SAChain[SAIndex];
                        pSAEntry = pSAEntry->Flink) {

                    pSA = CONTAINING_RECORD(pSAEntry,
                                            SA_TABLE_ENTRY,
                                            sa_FilterLinkage);

                    IPSecStopSATimer(pSA);
                }
            }
        }
    }

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
}


VOID
IPSecFlushLarvalSAList()
/*++

Routine Description:

    When the Acquire Irp is cancelled, this is called to flush all Larval SAs

    Called with SADB lock held (first); returns with it.
    Called with AcquireInfo.Lock held; returns with it.

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    KIRQL           OldIrq;
    KIRQL           OldIrq1;
    KIRQL           kIrql;
    PSA_TABLE_ENTRY pLarvalSA;
    LIST_ENTRY      FreeList;

    InitializeListHead(&FreeList);

    while (TRUE) {
        if (!IsListEmpty(&g_ipsec.AcquireInfo.PendingAcquires)) {
            PLIST_ENTRY     pEntry;

            pEntry = RemoveHeadList(&g_ipsec.AcquireInfo.PendingAcquires);

            pLarvalSA = CONTAINING_RECORD(  pEntry,
                                            SA_TABLE_ENTRY,
                                            sa_PendingLinkage);
            ASSERT(pLarvalSA->sa_State == STATE_SA_LARVAL);
            ASSERT(pLarvalSA->sa_Flags & FLAGS_SA_PENDING);

            pLarvalSA->sa_Flags &= ~FLAGS_SA_PENDING;

            //
            // Insert into another list, which we walk without the lock
            //
            InsertTailList(&FreeList, &pLarvalSA->sa_PendingLinkage);

            //
            // also remove from Larval list
            //
            ACQUIRE_LOCK(&g_ipsec.LarvalListLock, &OldIrq1);
            IPSecRemoveEntryList(&pLarvalSA->sa_LarvalLinkage);
            IPSEC_DEC_STATISTIC(dwNumPendingKeyOps);
            RELEASE_LOCK(&g_ipsec.LarvalListLock, OldIrq1);
        } else {
            break;
        }
    }

    //
    // get the remaining Larval SAs
    //
    ACQUIRE_LOCK(&g_ipsec.LarvalListLock, &OldIrq);
    while (TRUE) {
        if (!IsListEmpty(&g_ipsec.LarvalSAList)) {
            PLIST_ENTRY     pEntry;

            pEntry = RemoveHeadList(&g_ipsec.LarvalSAList);

            pLarvalSA = CONTAINING_RECORD(  pEntry,
                                            SA_TABLE_ENTRY,
                                            sa_LarvalLinkage);

            //
            // Insert into another list, which we walk without the lock
            //
            InsertTailList(&FreeList, &pLarvalSA->sa_PendingLinkage);

        } else {
            break;
        }
    }
    RELEASE_LOCK(&g_ipsec.LarvalListLock, OldIrq);

    while (TRUE) {
        if (!IsListEmpty(&FreeList)) {
            PLIST_ENTRY     pEntry;

            pEntry = RemoveHeadList(&FreeList);

            pLarvalSA = CONTAINING_RECORD(  pEntry,
                                            SA_TABLE_ENTRY,
                                            sa_PendingLinkage);

            AcquireWriteLock(&g_ipsec.SPIListLock, &kIrql);
            IPSecRemoveSPIEntry(pLarvalSA);
            ReleaseWriteLock(&g_ipsec.SPIListLock, kIrql);

            //
            // Flush all the queued packets
            //
            IPSecFlushQueuedPackets(pLarvalSA, STATUS_TIMEOUT);

            //
            // also remove from the filter list
            //
            if (pLarvalSA->sa_Flags & FLAGS_SA_ON_FILTER_LIST) {
                pLarvalSA->sa_Flags &= ~FLAGS_SA_ON_FILTER_LIST;
                IPSecRemoveEntryList(&pLarvalSA->sa_FilterLinkage);
            }

            if (pLarvalSA->sa_RekeyOriginalSA) {
                ASSERT(pLarvalSA->sa_Flags & FLAGS_SA_REKEY);
                ASSERT(pLarvalSA->sa_RekeyOriginalSA->sa_RekeyLarvalSA == pLarvalSA);
                ASSERT(pLarvalSA->sa_RekeyOriginalSA->sa_Flags & FLAGS_SA_REKEY_ORI);

                pLarvalSA->sa_RekeyOriginalSA->sa_Flags &= ~FLAGS_SA_REKEY_ORI;
                pLarvalSA->sa_RekeyOriginalSA->sa_RekeyLarvalSA = NULL;
                pLarvalSA->sa_RekeyOriginalSA = NULL;
            }

            //
            // release acquire context and invalidate the associated cache entry
            //
            ACQUIRE_LOCK(&pLarvalSA->sa_Lock, &kIrql);
            if (pLarvalSA->sa_AcquireCtx) {
                IPSecInvalidateHandle(pLarvalSA->sa_AcquireCtx);
                pLarvalSA->sa_AcquireCtx = NULL;
            }
            RELEASE_LOCK(&pLarvalSA->sa_Lock, kIrql);

            IPSecInvalidateSACacheEntry(pLarvalSA);

            IPSecStopTimerDerefSA(pLarvalSA);
        } else {
            break;
        }
    }

    return;
}


NTSTATUS
IPSecDeleteSA(
    IN  PIPSEC_DELETE_SA    pDeleteSA
    )
/*++

Routine Description:

    Delete the SA matching the particulars passed in.  Both inbound and
    outbound SAs are deleted.  No timer set for inbound SA.

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    PFILTER         pFilter;
    PSA_TABLE_ENTRY pSA, pInboundSA;
    PLIST_ENTRY     pEntry, pSAEntry;
    KIRQL           kIrql;
    LONG            Index;
    LONG            SAIndex;

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    //
    // Walk through the outbound SAs and delete matched ones.
    //
    for (   Index = OUTBOUND_TRANSPORT_FILTER;
            Index <= OUTBOUND_TUNNEL_FILTER;
            Index += TRANSPORT_TUNNEL_INCREMENT) {

        for (   pEntry = g_ipsec.FilterList[Index].Flink;
                pEntry != &g_ipsec.FilterList[Index];
                pEntry = pEntry->Flink) {

            pFilter = CONTAINING_RECORD(pEntry,
                                        FILTER,
                                        MaskedLinkage);

            for (   SAIndex = 0;
                    SAIndex < pFilter->SAChainSize;
                    SAIndex++) {

                pSAEntry = pFilter->SAChain[SAIndex].Flink;

                while (pSAEntry != &pFilter->SAChain[SAIndex]) {

                    pSA = CONTAINING_RECORD(pSAEntry,
                                            SA_TABLE_ENTRY,
                                            sa_FilterLinkage);

                    pSAEntry = pSAEntry->Flink;

                    if (IPSecMatchSATemplate(pSA, &pDeleteSA->SATemplate)) {
                        ASSERT(pSA->sa_State == STATE_SA_ACTIVE);
                        ASSERT(pSA->sa_Flags & FLAGS_SA_OUTBOUND);
                        ASSERT(pSA->sa_AssociatedSA);

                        pInboundSA = pSA->sa_AssociatedSA;
                        if (pInboundSA) {
                            IPSecDeleteInboundSA(pInboundSA);
                        }
                    }
                }
            }
        }
    }

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecExpireSA(
    IN  PIPSEC_EXPIRE_SA    pExpireSA
    )
/*++

Routine Description:

    Expires the SA matching the particulars passed in.
    Applied to Inbound SAs - we place the SA in the timer queue
    for the next time the timer hits. Also, we delete the
    corresponding outbound SA so no further packets match that
    SA.

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    PSA_TABLE_ENTRY pInboundSA;
    KIRQL           kIrql;
    NTSTATUS        status;

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    pInboundSA = IPSecLookupSABySPI(pExpireSA->DelInfo.SPI,
                                    pExpireSA->DelInfo.DestAddr);

    if (pInboundSA) {
        ASSERT((pInboundSA->sa_Flags & FLAGS_SA_OUTBOUND) == 0);

        if (pInboundSA->sa_State == STATE_SA_ACTIVE) {
            IPSEC_DEBUG(ACQUIRE, ("Expiring SA: %lx\n", pInboundSA));

            if (pInboundSA->sa_Flags & FLAGS_SA_ON_FILTER_LIST) {
                pInboundSA->sa_Flags &= ~FLAGS_SA_ON_FILTER_LIST;
                IPSecRemoveEntryList(&pInboundSA->sa_FilterLinkage);
            }

            pInboundSA->sa_Flags |= FLAGS_SA_DELETE_BY_IOCTL;

            IPSecExpireInboundSA(pInboundSA);
        }

        status = STATUS_SUCCESS;
    } else {
        IPSEC_DEBUG(ACQUIRE, ("Expire for a non-existent SA: %lx\n", pExpireSA));

        status = STATUS_NO_MATCH;
    }

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    return  status;
}


VOID
IPSecSAExpired(
    IN	PIPSEC_TIMER	pTimer,
    IN	PVOID		Context
    )
/*++

Routine Description:

     Called when an SA has expired or when a Larval SA has timed out.

Arguments:

    pTimer - the timer struct

    Context - SA ptr

Return Value:

    STATUS_PENDING if the buffer is to be held on to, the normal case.

Notes:


--*/
{
    PSA_TABLE_ENTRY pSA = (PSA_TABLE_ENTRY)Context;
    PSA_TABLE_ENTRY pOutboundSA;
    KIRQL       	kIrql;
    KIRQL       	kIrql1;
    KIRQL       	kIrql2;
    KIRQL           OldIrq;

    IPSEC_DEBUG(TIMER, ("IPSecSAExpired: pSA: %lx state: %lx\n", pSA, pSA->sa_State));

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql1);
    ACQUIRE_LOCK(&g_ipsec.LarvalListLock, &kIrql);

    switch (pSA->sa_State) {
    case   STATE_SA_CREATED:
        ASSERT(FALSE);
        break;

    case   STATE_SA_LARVAL:
    case   STATE_SA_ASSOCIATED:
        //
        // Lock the larval list so this SA does not go away.
        //
        ASSERT((pSA->sa_Flags & FLAGS_SA_OUTBOUND) == 0);

        //
        // Remove from larval list
        //
        IPSecRemoveEntryList(&pSA->sa_LarvalLinkage);
        IPSEC_DEC_STATISTIC(dwNumPendingKeyOps);

        //
        // Also remove from Pending list if queued there.
        //
        ACQUIRE_LOCK(&g_ipsec.AcquireInfo.Lock, &kIrql1);
        if (pSA->sa_Flags & FLAGS_SA_PENDING) {
            ASSERT(pSA->sa_State == STATE_SA_LARVAL);
            IPSEC_DEBUG(ACQUIRE, ("IPSecSAExpired: Removed from pending too: %lx\n", pSA));
            IPSecRemoveEntryList(&pSA->sa_PendingLinkage);
            pSA->sa_Flags &= ~FLAGS_SA_PENDING;
        }
        RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, kIrql1);

        //
        // Flush all the queued packets
        //
        IPSecFlushQueuedPackets(pSA, STATUS_TIMEOUT);

        //
        // remove from inbound sa list
        //
        AcquireWriteLock(&g_ipsec.SPIListLock, &kIrql1);
        IPSecRemoveSPIEntry(pSA);
        ReleaseWriteLock(&g_ipsec.SPIListLock, kIrql1);

        //
        // also remove from the filter list
        //
        if (pSA->sa_Flags & FLAGS_SA_ON_FILTER_LIST) {
            pSA->sa_Flags &= ~FLAGS_SA_ON_FILTER_LIST;
            IPSecRemoveEntryList(&pSA->sa_FilterLinkage);
        }

        //
        // invalidate the associated cache entry
        //
        ACQUIRE_LOCK(&pSA->sa_Lock, &kIrql2);
        if (pSA->sa_AcquireCtx) {
            IPSecInvalidateHandle(pSA->sa_AcquireCtx);
            pSA->sa_AcquireCtx = NULL;
        }
        RELEASE_LOCK(&pSA->sa_Lock, kIrql2);

        IPSecInvalidateSACacheEntry(pSA);

        pSA->sa_Flags &= ~FLAGS_SA_TIMER_STARTED;

        if (pSA->sa_RekeyOriginalSA) {
            ASSERT(pSA->sa_Flags & FLAGS_SA_REKEY);
            ASSERT(pSA->sa_RekeyOriginalSA->sa_RekeyLarvalSA == pSA);
            ASSERT(pSA->sa_RekeyOriginalSA->sa_Flags & FLAGS_SA_REKEY_ORI);

            pSA->sa_RekeyOriginalSA->sa_Flags &= ~FLAGS_SA_REKEY_ORI;
            pSA->sa_RekeyOriginalSA->sa_RekeyLarvalSA = NULL;
            pSA->sa_RekeyOriginalSA = NULL;
        }

        if (pOutboundSA = pSA->sa_AssociatedSA) {

            IPSEC_DEC_STATISTIC(dwNumActiveAssociations);
            IPSEC_DEC_TUNNELS(pOutboundSA);
            IPSEC_DECREMENT(g_ipsec.NumOutboundSAs);

            IPSecCleanupOutboundSA(pSA, pOutboundSA, FALSE);
        }

        IPSEC_DEBUG(REF, ("Timer in Deref\n"));
        IPSecDerefSA(pSA);

        break;

    case   STATE_SA_ZOMBIE:
        ASSERT(FALSE);
        break;

    case   STATE_SA_ACTIVE:
        //
        // Inbound SA being expired; outbound was deleted immediately
        //
        ASSERT((pSA->sa_Flags & FLAGS_SA_OUTBOUND) == 0);

        ACQUIRE_LOCK(&g_ipsec.AcquireInfo.Lock, &OldIrq);
        IPSecNotifySAExpiration(pSA, NULL, OldIrq, FALSE);

        //
        // remove from inbound sa list
        //
        AcquireWriteLock(&g_ipsec.SPIListLock, &kIrql1);
        IPSecRemoveSPIEntry(pSA);
        ReleaseWriteLock(&g_ipsec.SPIListLock, kIrql1);

        //
        // also remove from the filter list
        //
        if (pSA->sa_Flags & FLAGS_SA_ON_FILTER_LIST) {
            pSA->sa_Flags &= ~FLAGS_SA_ON_FILTER_LIST;
            IPSecRemoveEntryList(&pSA->sa_FilterLinkage);
        }

        //
        // invalidate the associated cache entry
        //
        IPSecInvalidateSACacheEntry(pSA);

        pSA->sa_Flags &= ~FLAGS_SA_TIMER_STARTED;

        if (pOutboundSA = pSA->sa_AssociatedSA) {

            IPSEC_DEC_STATISTIC(dwNumActiveAssociations);
            IPSEC_DEC_TUNNELS(pOutboundSA);
            IPSEC_DECREMENT(g_ipsec.NumOutboundSAs);

            IPSecCleanupOutboundSA(pSA, pOutboundSA, FALSE);
        }

        if (pSA->sa_Flags & FLAGS_SA_HW_PLUMBED) {
            IPSecDelHWSAAtDpc(pSA);
        }

        ASSERT(pSA->sa_AssociatedSA == NULL);
        IPSEC_DEBUG(REF, ("Timer#2 in Deref\n"));
        IPSecDerefSA(pSA);

        break;

    default:
        ASSERT(FALSE);
    }

    RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);
    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql1);
}


VOID
IPSecFillSAInfo(
    IN  PSA_TABLE_ENTRY pSA,
    OUT PIPSEC_SA_INFO  pBuf
    )
/*++

Routine Description:

    Fill out the SA_INFO structure.

Arguments:

    pSA     - SA to be filled in
    pBuf    - where to fill in

Returns:

    None.

--*/
{
    LONG            Index;
    PSA_TABLE_ENTRY pAssociatedSA = pSA->sa_AssociatedSA;

    RtlZeroMemory(pBuf, sizeof(IPSEC_SA_INFO));

    pBuf->PolicyId = pSA->sa_Filter->PolicyId;
    pBuf->FilterId = pSA->sa_Filter->FilterId;
    pBuf->Lifetime = pSA->sa_Lifetime;
    pBuf->InboundTunnelAddr = pSA->sa_SrcTunnelAddr;
    pBuf->NumOps = pSA->sa_NumOps;

    pBuf->dwQMPFSGroup = pSA->sa_QMPFSGroup;
    RtlCopyMemory(  &pBuf->CookiePair,
                    &pSA->sa_CookiePair,
                    sizeof(IKE_COOKIE_PAIR));

    for (Index = 0; Index < pSA->sa_NumOps; Index++) {
        pBuf->Operation[Index] = pSA->sa_Operation[Index];

        pBuf->EXT_INT_ALGO_EX(Index) = pSA->INT_ALGO(Index);
        pBuf->EXT_INT_KEYLEN_EX(Index) = pSA->INT_KEYLEN(Index);
        pBuf->EXT_INT_ROUNDS_EX(Index) = pSA->INT_ROUNDS(Index);

        pBuf->EXT_CONF_ALGO_EX(Index) = pSA->CONF_ALGO(Index);
        pBuf->EXT_CONF_KEYLEN_EX(Index) = pSA->CONF_KEYLEN(Index);
        pBuf->EXT_CONF_ROUNDS_EX(Index) = pSA->CONF_ROUNDS(Index);

        if (pAssociatedSA) {
            pBuf->InboundSPI[Index] = pAssociatedSA->sa_OtherSPIs[Index];
        }
        pBuf->OutboundSPI[Index] = pSA->sa_OtherSPIs[Index];
    }

    pBuf->AssociatedFilter.SrcAddr = pSA->SA_SRC_ADDR & pSA->SA_SRC_MASK;
    pBuf->AssociatedFilter.SrcMask = pSA->SA_SRC_MASK;
    pBuf->AssociatedFilter.DestAddr = pSA->SA_DEST_ADDR & pSA->SA_DEST_MASK;
    pBuf->AssociatedFilter.DestMask = pSA->SA_DEST_MASK;
    pBuf->AssociatedFilter.Protocol = pSA->SA_PROTO;
    pBuf->AssociatedFilter.SrcPort = SA_SRC_PORT(pSA);
    pBuf->AssociatedFilter.DestPort = SA_DEST_PORT(pSA);
    pBuf->AssociatedFilter.TunnelAddr = pSA->sa_TunnelAddr;
    pBuf->AssociatedFilter.TunnelFilter = (pSA->sa_Flags & FLAGS_SA_TUNNEL) != 0;

    if (pSA->sa_Flags & FLAGS_SA_OUTBOUND) {
        pBuf->AssociatedFilter.Flags = FILTER_FLAGS_OUTBOUND;
    } else {
        pBuf->AssociatedFilter.Flags = FILTER_FLAGS_INBOUND;
    }

    if (pSA->sa_Flags & FLAGS_SA_INITIATOR) {
        pBuf->EnumFlags |= SA_ENUM_FLAGS_INITIATOR;
    }
    if (pSA->sa_Flags & FLAGS_SA_MTU_BUMPED) {
        pBuf->EnumFlags |= SA_ENUM_FLAGS_MTU_BUMPED;
    }
    if (pSA->sa_Flags & FLAGS_SA_HW_PLUMBED) {
        pBuf->EnumFlags |= SA_ENUM_FLAGS_OFFLOADED;
    }
    if (pSA->sa_Flags & FLAGS_SA_HW_PLUMB_FAILED) {
        pBuf->EnumFlags |= SA_ENUM_FLAGS_OFFLOAD_FAILED;
    }
    if (pSA->sa_Flags & FLAGS_SA_OFFLOADABLE) {
        pBuf->EnumFlags |= SA_ENUM_FLAGS_OFFLOADABLE;
    }
    if (pSA->sa_Flags & FLAGS_SA_REKEY_ORI) {
        pBuf->EnumFlags |= SA_ENUM_FLAGS_IN_REKEY;
    }

    pBuf->Stats.ConfidentialBytesSent = pSA->sa_Stats.ConfidentialBytesSent;
    pBuf->Stats.AuthenticatedBytesSent = pSA->sa_Stats.AuthenticatedBytesSent;
    pBuf->Stats.TotalBytesSent = pSA->sa_Stats.TotalBytesSent;
    pBuf->Stats.OffloadedBytesSent = pSA->sa_Stats.OffloadedBytesSent;

    if (pAssociatedSA) {
        pBuf->Stats.ConfidentialBytesReceived =
            pAssociatedSA->sa_Stats.ConfidentialBytesReceived;
        pBuf->Stats.AuthenticatedBytesReceived =
            pAssociatedSA->sa_Stats.AuthenticatedBytesReceived;
        pBuf->Stats.TotalBytesReceived =
            pAssociatedSA->sa_Stats.TotalBytesReceived;
        pBuf->Stats.OffloadedBytesReceived =
            pAssociatedSA->sa_Stats.OffloadedBytesReceived;
    }
}


NTSTATUS
IPSecEnumSAs(
    IN  PIRP    pIrp,
    OUT PULONG  pBytesCopied
    )
/*++

Routine Description:

    Fills in the request to enumerate SAs.

Arguments:

    pIrp            - The actual Irp
    pBytesCopied    - the number of bytes copied.

Returns:

    Status of the operation.

--*/
{
    PNDIS_BUFFER    NdisBuffer = NULL;
    PIPSEC_ENUM_SAS pEnum = NULL;
    ULONG           BufferLength = 0;
    KIRQL           kIrql;
    PLIST_ENTRY     pEntry;
    PLIST_ENTRY     pSAEntry;
    IPSEC_SA_INFO   infoBuff = {0};
    NTSTATUS        status = STATUS_SUCCESS;
    ULONG           BytesCopied = 0;
    ULONG           Offset = 0;
    PFILTER         pFilter;
    PSA_TABLE_ENTRY pSA;
    LONG            Index;
    LONG            FilterIndex;
    LONG            SAIndex;

    //
    // Get at the IO buffer - its in the MDL
    //
    NdisBuffer = REQUEST_NDIS_BUFFER(pIrp);
    if (NdisBuffer == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    NdisQueryBufferSafe(NdisBuffer,
                        (PVOID *)&pEnum,
                        &BufferLength,
                        NormalPagePriority);

    //
    // Make sure NdisQueryBufferSafe succeeds.
    //
    if (!pEnum) {
        IPSEC_DEBUG (IOCTL, ("EnumSAs failed, no resources\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Make sure we have enough room for just the header not
    // including the data.
    //
    if (BufferLength < (UINT)(FIELD_OFFSET(IPSEC_ENUM_SAS, pInfo[0]))) {
        IPSEC_DEBUG (IOCTL, ("EnumSAs failed, buffer too small\n"));
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Make sure we are naturally aligned.
    //
    if (((ULONG_PTR)(pEnum)) & (TYPE_ALIGNMENT(IPSEC_ENUM_SAS) - 1)) {
        IPSEC_DEBUG (IOCTL, ("EnumSAs failed, alignment\n"));
        return STATUS_DATATYPE_MISALIGNMENT_ERROR;
    }

    pEnum->NumEntries = 0;
    pEnum->NumEntriesPresent = 0;

    //
    // Now copy over the SA data into the user buffer and fit as many as possible.
    //
    BufferLength -= FIELD_OFFSET(IPSEC_ENUM_SAS, pInfo[0]);
    Offset = FIELD_OFFSET(IPSEC_ENUM_SAS, pInfo[0]);

    Index = pEnum->Index;   // where to start?

    AcquireReadLock(&g_ipsec.SADBLock, &kIrql);

    for (   FilterIndex = MIN_FILTER;
            FilterIndex <= MAX_FILTER;
            FilterIndex++) {

        for (   pEntry = g_ipsec.FilterList[FilterIndex].Flink;
                pEntry != &g_ipsec.FilterList[FilterIndex];
                pEntry = pEntry->Flink) {

            pFilter = CONTAINING_RECORD(pEntry,
                                        FILTER,
                                        MaskedLinkage);

            for (   SAIndex = 0;
                    SAIndex < pFilter->SAChainSize;
                    SAIndex ++) {

                for (   pSAEntry = pFilter->SAChain[SAIndex].Flink;
                        pSAEntry != &pFilter->SAChain[SAIndex];
                        pSAEntry = pSAEntry->Flink) {

                    pSA = CONTAINING_RECORD(pSAEntry,
                                            SA_TABLE_ENTRY,
                                            sa_FilterLinkage);

                    //
                    // Only interested in outbound or multicast SAs.
                    //
                    if (!(pSA->sa_Flags & FLAGS_SA_OUTBOUND)) {
                        continue;
                    }

                    //
                    // Dump only SAs that match the template.
                    //
                    if (IPSecMatchSATemplate(pSA, &pEnum->SATemplate)) {
                        if (Index > 0) {
                            Index--;    // Skip number of Index SAs.
                            continue;
                        }

                        pEnum->NumEntriesPresent++;

                        if ((INT)(BufferLength - BytesCopied) >= (INT)sizeof(IPSEC_SA_INFO)) {
                            IPSecFillSAInfo(pSA, &infoBuff);
                            BytesCopied += sizeof(IPSEC_SA_INFO);
                            NdisBuffer = CopyToNdis(NdisBuffer, (UCHAR *)&infoBuff, sizeof(IPSEC_SA_INFO), &Offset);
                            if (!NdisBuffer) {
                                ReleaseReadLock(&g_ipsec.SADBLock, kIrql);
                                return STATUS_INSUFFICIENT_RESOURCES;
                            }
                        }
                    }
                }
            }
        }
    }

    ReleaseReadLock(&g_ipsec.SADBLock, kIrql);

    pEnum->NumEntries = BytesCopied / sizeof(IPSEC_SA_INFO);

    *pBytesCopied = BytesCopied + FIELD_OFFSET(IPSEC_ENUM_SAS, pInfo[0]);

    if (pEnum->NumEntries < pEnum->NumEntriesPresent) {
        status = STATUS_BUFFER_OVERFLOW;
    }

    return status;
}


VOID
IPSecReaper(
    IN	PIPSEC_TIMER	pTimer,
    IN	PVOID		Context
    )
/*++

Routine Description:

    Called every 5 mins; reaps the (active) SA list

Arguments:

    pTimer - the timer struct

    Context - NULL

Return Value:

    STATUS_PENDING if the buffer is to be held on to, the normal case.

Notes:


--*/
{
    KIRQL	kIrql;

    IPSEC_DEBUG(TIMER, ("Entering IPSecReaper\n"));

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    //
    // walk the outbound SAs and delete/expire them if they have been
    // idle for sometime (lets say 5 mins for now).
    //
    IPSecReapIdleSAs();

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    IPSEC_DEBUG(TIMER, ("Exiting IPSecReaper\n"));
    if (!IPSEC_DRIVER_IS_INACTIVE()) {
        IPSecStartTimer(&g_ipsec.ReaperTimer,
                        IPSecReaper,
                        IPSEC_REAPER_TIME,
                        (PVOID)NULL);
    }
}


VOID
IPSecReapIdleSAs()
/*++

Routine Description:

    Called to reap the idle SA list

Arguments:


Return Value:


--*/
{
    PSA_TABLE_ENTRY pSA;
    PFILTER         pFilter;
    PLIST_ENTRY     pEntry;
    PLIST_ENTRY     pSAEntry;
    BOOLEAN         fExpired;
    LONG            Index;
    LONG            SAIndex;

    IPSEC_DEBUG(TIMER, ("Entering IPSecReapIdleSAs\n"));

    //
    // Walk the inbound SAs and delete/expire them if they have been
    // idle for sometime (lets say 5 mins for now).
    //
    for (   Index = INBOUND_TRANSPORT_FILTER;
            Index <= INBOUND_TUNNEL_FILTER;
            Index += TRANSPORT_TUNNEL_INCREMENT) {

        for (   pEntry = g_ipsec.FilterList[Index].Flink;
                pEntry != &g_ipsec.FilterList[Index];
                pEntry = pEntry->Flink) {

            pFilter = CONTAINING_RECORD(pEntry,
                                        FILTER,
                                        MaskedLinkage);

            for (   SAIndex = 0;
                    SAIndex < pFilter->SAChainSize;
                    SAIndex++) {

                pSAEntry = pFilter->SAChain[SAIndex].Flink;

                while (pSAEntry != &pFilter->SAChain[SAIndex]) {

                    pSA = CONTAINING_RECORD(pSAEntry,
                                            SA_TABLE_ENTRY,
                                            sa_FilterLinkage);

                    ASSERT(!(pSA->sa_Flags & FLAGS_SA_OUTBOUND));

                    pSAEntry = pSAEntry->Flink;

                    if (!(pSA->sa_Flags & FLAGS_SA_IDLED_OUT) &&
                        (pSA->sa_State == STATE_SA_ACTIVE) &&
                        !(pSA->sa_Flags & FLAGS_SA_DISABLE_IDLE_OUT)) {

                        IPSEC_SA_EXPIRED(pSA, fExpired);
                        if (fExpired) {
                            pSA->sa_Flags |= FLAGS_SA_IDLED_OUT;
                            IPSecExpireInboundSA(pSA);
                        }
                    }
                }
            }
        }
    }

    IPSEC_DEBUG(TIMER, ("Exiting IPSecReapIdleSAs\n"));
}


VOID
IPSecFlushEventLog(
    IN	PIPSEC_TIMER	pTimer,
    IN	PVOID		Context
    )
/*++

Routine Description:

    Called every LogInterval seconds; flush all events currently logged.

Arguments:

    pTimer - the timer struct

    Context - NULL

Return Value:


Notes:


--*/
{
    KIRQL   kIrql;

    IPSEC_DEBUG(TIMER, ("Entering IPSecFlushEventLog\n"));

    ACQUIRE_LOCK(&g_ipsec.EventLogLock, &kIrql);

    if (g_ipsec.IPSecLogMemoryLoc > g_ipsec.IPSecLogMemory) {
        //
        // Flush the logs.
        //
        IPSecQueueLogEvent();
    }

    RELEASE_LOCK(&g_ipsec.EventLogLock, kIrql);

    if (!IPSEC_DRIVER_IS_INACTIVE()) {
        IPSecStartTimer(&g_ipsec.EventLogTimer,
                        IPSecFlushEventLog,
                        g_ipsec.LogInterval,
                        (PVOID)NULL);
    }
}


NTSTATUS
IPSecQuerySpi(
    IN OUT PIPSEC_QUERY_SPI pQuerySpi
    )
/*++

Routine Description:

    Queries IPSEC for spis corresponding to given filter

Arguments:


Return Value:


Notes:


--*/
{
    NTSTATUS    status;

    ULARGE_INTEGER  uliSrcDstAddr;
    ULARGE_INTEGER  uliProtoSrcDstPort;
    PFILTER         pFilter = NULL;
    PSA_TABLE_ENTRY pSA = NULL;
    PSA_TABLE_ENTRY pNextSA = NULL;
    PSA_TABLE_ENTRY pTunnelSA = NULL;
    KIRQL           kIrql;

    pQuerySpi->Spi          = 0;
    pQuerySpi->OtherSpi     = 0;
    pQuerySpi->Operation    = 0;

    IPSEC_DEBUG(ACQUIRE, ("IPSecQuerySPI: Src %08x.%04x Dst %08x.%04x Protocol %d",
                          pQuerySpi->Filter.SrcAddr,
                          pQuerySpi->Filter.SrcPort,
                          pQuerySpi->Filter.DestAddr,
                          pQuerySpi->Filter.DestPort,
                          pQuerySpi->Filter.Protocol));

    IPSEC_BUILD_SRC_DEST_ADDR(  uliSrcDstAddr,
                                pQuerySpi->Filter.SrcAddr,
                                pQuerySpi->Filter.DestAddr);

    IPSEC_BUILD_PROTO_PORT_LI(  uliProtoSrcDstPort,
                                pQuerySpi->Filter.Protocol,
                                pQuerySpi->Filter.SrcPort,
                                pQuerySpi->Filter.DestPort);


    AcquireReadLock(&g_ipsec.SADBLock, &kIrql);

    //
    // search for SA
    //
    status = IPSecLookupSAByAddr(   uliSrcDstAddr,
                                    uliProtoSrcDstPort,
                                    &pFilter,
                                    &pSA,
                                    &pNextSA,
                                    &pTunnelSA,
                                    FALSE,
                                    FALSE,
                                    FALSE);

    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(ACQUIRE, ("IPSecQuerySPI: IPSecLookupSAByAddr failed: %lx\n", status));
        ReleaseReadLock(&g_ipsec.SADBLock, kIrql);
        return status;
    }

    if (status == STATUS_SUCCESS) {
        ASSERT(pSA);
    } else {
        ReleaseReadLock(&g_ipsec.SADBLock, kIrql);
        return STATUS_SUCCESS;
    }

    pQuerySpi->Spi = pSA->sa_SPI;

    if (pSA->sa_AssociatedSA) {
        pQuerySpi->OtherSpi = pSA->sa_AssociatedSA->sa_SPI;
    }

    pQuerySpi->Operation = pSA->sa_Operation[pSA->sa_NumOps-1];

    ReleaseReadLock(&g_ipsec.SADBLock, kIrql);

    return STATUS_SUCCESS;
}


NTSTATUS
IPSecSetOperationMode(
    IN PIPSEC_SET_OPERATION_MODE    pSetOperationMode
    )
/*++

Routine Description:

    Set the driver operation mode.

Arguments:



Return Value:



Notes:


--*/
{
    g_ipsec.OperationMode = pSetOperationMode->OperationMode;
   
    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecInitializeTcpip(
    IN PIPSEC_SET_TCPIP_STATUS  pSetTcpipStatus
    )
/*++

Routine Description:

    Initialize TCP/IP.

Arguments:



Return Value:



Notes:


--*/
{
    IPInfo  Info;

    if (IPSEC_DRIVER_INIT_TCPIP()) {
        return  STATUS_SUCCESS;
    }

    //
    // Store all TCP/IP function pointers for future use.  There is no check
    // for NULL pointer here because the function pointer can also be stale
    // address.  We trust TCP/IP to pass in the values corretly.
    //
    TCPIP_FREE_BUFF = pSetTcpipStatus->TcpipFreeBuff;
    TCPIP_ALLOC_BUFF = pSetTcpipStatus->TcpipAllocBuff;
    TCPIP_GET_INFO = pSetTcpipStatus->TcpipGetInfo;
    TCPIP_NDIS_REQUEST = pSetTcpipStatus->TcpipNdisRequest;
    TCPIP_SET_IPSEC_STATUS = pSetTcpipStatus->TcpipSetIPSecStatus;
    TCPIP_SET_IPSEC = pSetTcpipStatus->TcpipSetIPSecPtr;
    TCPIP_UNSET_IPSEC = pSetTcpipStatus->TcpipUnSetIPSecPtr;
    TCPIP_UNSET_IPSEC_SEND = pSetTcpipStatus->TcpipUnSetIPSecSendPtr;
    TCPIP_TCP_XSUM = pSetTcpipStatus->TcpipTCPXsum;

    //
    // Initialize IPInfo for reinjecting packets to TCP/IP.
    //
    if (TCPIP_GET_INFO(&Info, sizeof(IPInfo)) != IP_SUCCESS) {
        ASSERT(FALSE);
        return  STATUS_BUFFER_TOO_SMALL;
    }

    Info.ipi_initopts(&g_ipsec.OptInfo);

    //
    // The followings come from IPInfo.
    //
    TCPIP_REGISTER_PROTOCOL = Info.ipi_protreg;
    TCPIP_DEREGISTER_PROTOCOL = Info.ipi_protdereg;
    TCPIP_IP_TRANSMIT = Info.ipi_xmit;
    TCPIP_GET_ADDRTYPE = Info.ipi_getaddrtype;
    TCPIP_GEN_IPID = Info.ipi_getipid;

    //
    // Don't register IPSecStatus function for AH and ESP protocol here.
    // Registration occurs with filter addition.
    //

    //
    // Everything is ready to go, bind to IP so we will intercept traffic.
    //
    IPSecBindToIP();

    IPSEC_DRIVER_INIT_TCPIP() = TRUE;

    return STATUS_SUCCESS;
}


NTSTATUS
IPSecDeinitializeTcpip(
    VOID
    )
/*++

Routine Description:

    Deinitialize TCP/IP.

Arguments:



Return Value:



Notes:


--*/
{
    if (!IPSEC_DRIVER_INIT_TCPIP()) {
        return  STATUS_SUCCESS;
    }

    IPSEC_DRIVER_INIT_TCPIP() = FALSE;

    //
    // Unbind IPSecHandlerPtr from TCP/IP and wait for all transmits, pending
    // sends, worker threads and iotcls to complete.
    //
    IPSecUnbindSendFromIP();

    //
    // Wait for all threads (transmits) to finish.
    //
    while (IPSEC_GET_VALUE(g_ipsec.NumThreads) != 0) {
        IPSEC_DELAY_EXECUTION();
    }

    //
    // Wait for all pending IOCTLs to finish.  Note this current IOCTL also
    // takes one count.
    //
    while (IPSEC_GET_VALUE(g_ipsec.NumIoctls) != 1) {
        IPSEC_DELAY_EXECUTION();
    }

    //
    // Wait for all worker threads (logs or plumbs) to finish.
    //
    while (IPSEC_GET_VALUE(g_ipsec.NumWorkers) != 0) {
        IPSEC_DELAY_EXECUTION();
    }

    //
    // Wait for all send completes to go through.
    //
    while (IPSEC_GET_VALUE(g_ipsec.NumSends) != 0) {
        IPSEC_DELAY_EXECUTION();
    }

    //
    // Reset IPSecStatus functions in TCP/IP to NULL.
    //
    if (IPSEC_GET_VALUE(gdwInitEsp)) {
        TCPIP_DEREGISTER_PROTOCOL(PROTOCOL_ESP);
        IPSEC_SET_VALUE(gdwInitEsp, 0);
    }
    if (IPSEC_GET_VALUE(gdwInitAh)) {
        TCPIP_DEREGISTER_PROTOCOL(PROTOCOL_AH);
        IPSEC_SET_VALUE(gdwInitAh, 0);
    }

    //
    // Unbind the rest of IPSec routines from TCP/IP.
    //
    IPSecUnbindFromIP();

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecSetTcpipStatus(
    IN PIPSEC_SET_TCPIP_STATUS  pSetTcpipStatus
    )
/*++

Routine Description:

    Set the TCP/IP driver status indicating whether can register with it.

Arguments:



Return Value:



Notes:


--*/
{
    PAGED_CODE();

    if (pSetTcpipStatus->TcpipStatus) {
        return  IPSecInitializeTcpip(pSetTcpipStatus);
    } else {
        return  IPSecDeinitializeTcpip();
    }
}


NTSTATUS
IPSecResetCacheTable(
    VOID
    )
/*++

Routine Description:

    Invalidate all cache entries and its associated SA or Filter.

Arguments:


Return Value:


Notes:


--*/
{
    PFILTER_CACHE   pCache;
    ULONG           i;

    for (i = 0; i < g_ipsec.CacheSize; i ++) {
        pCache = g_ipsec.ppCache[i];
        if (pCache && IS_VALID_CACHE_ENTRY(pCache)) {
            if (pCache->FilterEntry) {
                pCache->pFilter->FilterCache = NULL;
            } else {
                pCache->pSAEntry->sa_FilterCache = NULL;
                if (pCache->pNextSAEntry) {
                    pCache->pNextSAEntry->sa_FilterCache = NULL;
                }
            }
            INVALIDATE_CACHE_ENTRY(pCache);
        }
    }

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecPurgeFilterSAs(
    IN PFILTER             pFilter
    )
/*++

Routine Description

    Delete all SAs that are related to this filter.

Locks

    Called with SADB held.

Arguments

    pFilter - filter of interest

Return Value

    STATUS_SUCCESS

--*/
{
    PLIST_ENTRY     pEntry;
    PSA_TABLE_ENTRY pSA;
    KIRQL           kIrql;
    LONG            Index;

    //
    // Expire each inbound SA and delete outbound SA
    //
    for (Index = 0; Index < pFilter->SAChainSize; Index ++) {
        pEntry = pFilter->SAChain[Index].Flink;

        while (pEntry != &pFilter->SAChain[Index]) {

            pSA = CONTAINING_RECORD(pEntry,
                                    SA_TABLE_ENTRY,
                                    sa_FilterLinkage);

            pEntry = pEntry->Flink;

            if (pSA->sa_State == STATE_SA_ACTIVE) {
                IPSEC_DEBUG(ACQUIRE, ("Destroying active SA: %lx\n", pSA));
                //
                // Filter is going away, SA must be deleted now
                //
                if (!(pSA->sa_Flags & FLAGS_SA_OUTBOUND)) {
                    //ASSERT(pSA->sa_AssociatedSA);
                    IPSecDeleteInboundSA(pSA);
                } else {
                    ASSERT(pSA->sa_AssociatedSA);
                    if (pSA->sa_AssociatedSA->sa_State == STATE_SA_ASSOCIATED) {
                        IPSecDeleteLarvalSA(pSA->sa_AssociatedSA);
                    } else {
                        IPSecDeleteInboundSA(pSA->sa_AssociatedSA);
                    }
                }
            } else {
                IPSEC_DEBUG(ACQUIRE, ("Destroying larval SA: %lx\n", pSA));
                //
                // SA undergoing negotiation - just invalidate the context.
                // the timer will take care of the rest
                //
                if (pSA->sa_AssociatedSA) {
                    if (pSA->sa_AssociatedSA->sa_AcquireCtx) {
                        IPSecInvalidateHandle(pSA->sa_AssociatedSA->sa_AcquireCtx);
                        pSA->sa_AssociatedSA->sa_AcquireCtx = NULL;
                    }
                }

                IPSecDeleteLarvalSA(pSA);
            }
        }
    }

    //
    // Also need to remove all those larval SAs whose sa_Filter is pointing
    // to the filter being deleted.
    //
    ACQUIRE_LOCK(&g_ipsec.LarvalListLock, &kIrql);

    pEntry = g_ipsec.LarvalSAList.Flink;
    while (pEntry != &g_ipsec.LarvalSAList) {
        pSA = CONTAINING_RECORD(pEntry,
                                SA_TABLE_ENTRY,
                                sa_LarvalLinkage);
        pEntry = pEntry->Flink;

        if (pSA->sa_Filter == pFilter) {
            IPSecRemoveEntryList(&pSA->sa_LarvalLinkage);
            IPSEC_DEC_STATISTIC(dwNumPendingKeyOps);
            IPSecCleanupLarvalSA(pSA);
        }
    }

    RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecSetupSALifetime(
    IN  PSA_TABLE_ENTRY pSA
    )
/*++

Routine Description:

    Setup the SA lifetime characteristics for rekey and idle timeout.

Arguments:


Return Value:


--*/
{
    LARGE_INTEGER   CurrentTime;
    LARGE_INTEGER   Delta = {0};
    LARGE_INTEGER   Pad = {(pSA->sa_Flags & FLAGS_SA_INITIATOR)?
                            IPSEC_EXPIRE_TIME_PAD_I :
                            IPSEC_EXPIRE_TIME_PAD_R,
                            0};

    //
    // pSA->sa_Lifetime.KeyExpirationTime is in seconds.
    //
    if (pSA->sa_Lifetime.KeyExpirationTime) {
        IPSEC_CONVERT_SECS_TO_100NS(Delta, pSA->sa_Lifetime.KeyExpirationTime);

        NdisGetCurrentSystemTime(&CurrentTime);

        pSA->sa_KeyExpirationTime.QuadPart = (CurrentTime.QuadPart + Delta.QuadPart);

        pSA->sa_KeyExpirationTimeWithPad.QuadPart = pSA->sa_KeyExpirationTime.QuadPart - Pad.QuadPart;

        if (!(pSA->sa_KeyExpirationTimeWithPad.QuadPart > 0i64)) {
            pSA->sa_KeyExpirationTimeWithPad.QuadPart = 0i64;
        }
    }

    //
    // pSA->sa_Lifetime.KeyExpirationBytes is in Kbytes.
    //
    if (pSA->sa_Lifetime.KeyExpirationBytes) {
        pSA->sa_KeyExpirationBytes.LowPart = pSA->sa_Lifetime.KeyExpirationBytes;
        pSA->sa_KeyExpirationBytes = EXTENDED_MULTIPLY(pSA->sa_KeyExpirationBytes, 1024);

        if (pSA->sa_Flags & FLAGS_SA_INITIATOR) {
            pSA->sa_KeyExpirationBytesWithPad.LowPart = pSA->sa_Lifetime.KeyExpirationBytes * IPSEC_EXPIRE_THRESHOLD_I / 100;
        } else {
            pSA->sa_KeyExpirationBytesWithPad.LowPart = pSA->sa_Lifetime.KeyExpirationBytes * IPSEC_EXPIRE_THRESHOLD_R / 100;
        }

        pSA->sa_KeyExpirationBytesWithPad = EXTENDED_MULTIPLY(pSA->sa_KeyExpirationBytesWithPad, 1024);
    }

    //
    // Also setup the idle timeout characteristics.
    //
    if (pSA->sa_Flags & FLAGS_SA_INITIATOR) {
        IPSEC_CONVERT_SECS_TO_100NS(pSA->sa_IdleTime,
                                    (g_ipsec.DefaultSAIdleTime + IPSEC_DEFAULT_SA_IDLE_TIME_PAD_I));
    } else {
        IPSEC_CONVERT_SECS_TO_100NS(pSA->sa_IdleTime,
                                    (g_ipsec.DefaultSAIdleTime + IPSEC_DEFAULT_SA_IDLE_TIME_PAD_R));
    }

    return  STATUS_SUCCESS;
}

DWORD ConvertAddr(IPAddr Addr, IPAddr Mask, ADDR* OutAddr)
{

    if (Mask == 0xffffffff) {
        OutAddr->AddrType=IP_ADDR_UNIQUE;
    } else {
        OutAddr->AddrType=IP_ADDR_SUBNET;
    }
    
    OutAddr->uSubNetMask=Mask;
    OutAddr->uIpAddr=Addr;

    return STATUS_SUCCESS;

}

DWORD ConvertSAToIPSecQMSA(PIPSEC_QM_SA pOutSA,
                           PSA_TABLE_ENTRY pInSA)
/*++

Routine Description:

    Convert SA_TABLE_ENTRY to IPSEC_QM_SA

Arguments:


Return Value:


--*/
{
    int i;

    memcpy(&pOutSA->gQMPolicyID,&pInSA->sa_Filter->PolicyId,sizeof(GUID));
    memcpy(&pOutSA->gQMFilterID,&pInSA->sa_Filter->FilterId,sizeof(GUID));
    
    memcpy(&pOutSA->MMSpi.Initiator,&pInSA->sa_CookiePair.Initiator,sizeof(IKE_COOKIE));
    memcpy(&pOutSA->MMSpi.Responder,&pInSA->sa_CookiePair.Responder,sizeof(IKE_COOKIE));

    ConvertAddr(pInSA->SA_SRC_ADDR,pInSA->SA_SRC_MASK,&pOutSA->IpsecQMFilter.SrcAddr);
    ConvertAddr(pInSA->SA_DEST_ADDR,pInSA->SA_DEST_MASK,&pOutSA->IpsecQMFilter.DesAddr);

    pOutSA->IpsecQMFilter.Protocol.ProtocolType=PROTOCOL_UNIQUE;
    pOutSA->IpsecQMFilter.Protocol.dwProtocol=pInSA->SA_PROTO;

    pOutSA->IpsecQMFilter.SrcPort.PortType=PORT_UNIQUE;
    pOutSA->IpsecQMFilter.SrcPort.wPort=NET_SHORT(SA_SRC_PORT(pInSA));

    pOutSA->IpsecQMFilter.DesPort.PortType=PORT_UNIQUE;
    pOutSA->IpsecQMFilter.DesPort.wPort=NET_SHORT(SA_DEST_PORT(pInSA));

    if (pInSA->sa_Flags & FLAGS_SA_TUNNEL) {
        pOutSA->IpsecQMFilter.QMFilterType = QM_TUNNEL_FILTER;
        ConvertAddr(pInSA->sa_SrcTunnelAddr,0xffffffff,&pOutSA->IpsecQMFilter.MyTunnelEndpt);
        ConvertAddr(pInSA->sa_TunnelAddr,0xffffffff,&pOutSA->IpsecQMFilter.PeerTunnelEndpt);
        
    } else {
        pOutSA->IpsecQMFilter.QMFilterType = QM_TRANSPORT_FILTER;
    }

    pOutSA->SelectedQMOffer.dwPFSGroup=pInSA->sa_QMPFSGroup;
    if (pOutSA->SelectedQMOffer.dwPFSGroup) {
        pOutSA->SelectedQMOffer.bPFSRequired=TRUE;
    }
    pOutSA->SelectedQMOffer.Lifetime.uKeyExpirationTime=pInSA->sa_Lifetime.KeyExpirationTime;
    pOutSA->SelectedQMOffer.Lifetime.uKeyExpirationKBytes=pInSA->sa_Lifetime.KeyExpirationBytes;
    
    pOutSA->SelectedQMOffer.dwNumAlgos=pInSA->sa_NumOps;

    for (i=0; i < pInSA->sa_NumOps;i++) {
        pOutSA->SelectedQMOffer.Algos[i].Operation=pInSA->sa_Operation[i];
        if (pInSA->sa_AssociatedSA) {            
            pOutSA->SelectedQMOffer.Algos[i].MySpi= pInSA->sa_AssociatedSA->sa_OtherSPIs[i];
        }        
        pOutSA->SelectedQMOffer.Algos[i].PeerSpi= pInSA->sa_OtherSPIs[i];
        
        switch(pOutSA->SelectedQMOffer.Algos[i].Operation) {
        case AUTHENTICATION:            
            pOutSA->SelectedQMOffer.Algos[i].uAlgoIdentifier=pInSA->INT_ALGO(i);            
            pOutSA->SelectedQMOffer.Algos[i].uAlgoKeyLen=pInSA->INT_KEYLEN(i);
            pOutSA->SelectedQMOffer.Algos[i].uAlgoRounds=pInSA->INT_ROUNDS(i);
            break;
        case ENCRYPTION:
            pOutSA->SelectedQMOffer.Algos[i].uAlgoIdentifier=pInSA->CONF_ALGO(i);            
            pOutSA->SelectedQMOffer.Algos[i].uAlgoKeyLen=pInSA->CONF_KEYLEN(i);
            pOutSA->SelectedQMOffer.Algos[i].uAlgoRounds=pInSA->CONF_ROUNDS(i);

            pOutSA->SelectedQMOffer.Algos[i].uSecAlgoIdentifier=pInSA->INT_ALGO(i);            
            pOutSA->SelectedQMOffer.Algos[i].uSecAlgoKeyLen=pInSA->INT_KEYLEN(i);
            break;
        default:
            break;
        }
    }
    return STATUS_SUCCESS;

    

}

BOOLEAN
IPSecMatchSATemplate(
    IN  PSA_TABLE_ENTRY pSA,
    IN  PIPSEC_QM_SA    pSATemplate
    )
/*++

Routine Description:

    Try to see if the SA passed in matches the template.

Arguments:

    pSA         - SA of interest
    pSATemplate - SA template

Return Value:

    TRUE/FALSE

--*/
{
    LARGE_INTEGER   ZeroLI = {0};
    ADDR            ZeroADDR = {0};
    PROTOCOL        ZeroPROTOCOL = {0};
    PORT            ZeroPORT = {0};

    IPSEC_QM_SA CurSA;
    memset(&CurSA,0,sizeof(IPSEC_QM_SA));
    
    ConvertSAToIPSecQMSA(&CurSA,pSA);
    
    return((BOOLEAN)MatchQMSATemplate(pSATemplate,&CurSA));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipv4\arp.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

       ARP.C - LAN arp module.

Abstract:

  This file implements arp framing for IP layer on the upper edge
  and interfaces with ndis driver on the lower edge.

Author:


[Environment:]

    kernel mode only

[Notes:]

    optional-notes

Revision History:

--*/

#include "precomp.h"

//***   arp.c - ARP routines.
//
//  This file containes all of the ARP related routines, including
//  table lookup, registration, etc.
//
//  ARP is architected to support multiple protocols, but for now
//  it in only implemented to take one protocol (IP). This is done
//  for simplicity and ease of implementation. In the future we may
//  split ARP out into a seperate driver.


#include "arp.h"
#include "arpdef.h"
#include "iproute.h"
#include "iprtdef.h"
#include "arpinfo.h"
#include "tcpipbuf.h"
#include "mdlpool.h"
#include "ipifcons.h"

#define NDIS_MAJOR_VERSION 0x4
#define NDIS_MINOR_VERSION 0

#ifndef NDIS_API
#define NDIS_API
#endif

#define PPP_HW_ADDR     "DEST"
#define PPP_HW_ADDR_LEN 4

#if DBG
uint fakereset = 0;
#endif

extern void IPReset(void *Context);

UINT cUniAdapters = 0;

extern uint EnableBcastArpReply;

static ulong ARPLookahead = LOOKAHEAD_SIZE;

static const uchar ENetBcst[] = "\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x00\x08\x06";
static const uchar TRBcst[] = "\x10\x40\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x00\x82\x70";
static const uchar FDDIBcst[] = "\x57\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x00";
static const uchar ARCBcst[] = "\x00\x00\xd5";

ulong TRFunctionalMcast = 0;
//canonical or non-canonical?
static uchar TRMcst[] = "\x10\x40\xc0\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x82\x70";
//#define TR_MCAST_FUNCTIONAL_ADDRESS 0xc00000040000
//canonical form
#define TR_MCAST_FUNCTIONAL_ADDRESS 0x030000200000
static uchar TRNetMcst[] = "\x00\x04\x00\x00";

static const uchar ENetMcst[] = "\x01\x00\x5E\x00\x00\x00";
static const uchar FDDIMcst[] = "\x57\x01\x00\x5E\x00\x00\x00";
static const uchar ARPSNAP[] = "\xAA\xAA\x03\x00\x00\x00\x08\x06";

static const uchar ENetPtrnMsk[] = "\x00\x30";
static const uchar ENetSNAPPtrnMsk[] = "\x00\xC0\x3f";
//static const uchar TRPtrnMsk[] = "\x03\x00";
//static const uchar TRSNAPPtrnMsk[] = "\x03\xC0\x3f";

static const uchar TRPtrnMsk[] = "\x00\x00";    //NO AC/FC bits need to be checked
static const uchar TRSNAPPtrnMsk[] = "\x00\xC0\x3f";

static const uchar FDDIPtrnMsk[] = "\x01\x00";
static const uchar FDDISNAPPtrnMsk[] = "\x01\x70\x1f";
static const uchar ARCPtrnMsk[] = "\x01";
static const uchar ARPPtrnMsk[] = "\x80\x00\x00\x0F";
static const uchar ARCARPPtrnMsk[] = "\x80\xC0\x03";

NDIS_STATUS __stdcall DoWakeupPattern(void *Context,
                                      PNET_PM_WAKEUP_PATTERN_DESC PtrnDesc, ushort protoid,
                                      BOOLEAN AddPattern);

NDIS_STATUS ARPWakeupPattern(ARPInterface *Interface, IPAddr Address,
                             BOOLEAN AddPattern);

NDIS_STATUS AddrNotifyLink(ARPInterface *Interface);

static WCHAR ARPName[] = TCP_NAME;

NDIS_HANDLE ARPHandle;                  // Our NDIS protocol handle.

uint ArpCacheLife;
extern uint ArpMinValidCacheLife;
uint sArpAlwaysSourceRoute;             // True if we always send ARP requests
uint ArpRetryCount;                     // retries for arp request with source
                                        // route info on token ring.
uint sIPAlwaysSourceRoute;
extern uchar TrRii;
extern PDRIVER_OBJECT IPDriverObject;
extern DisableTaskOffload;

extern NDIS_STATUS __stdcall IPPnPEvent(void *, PNET_PNP_EVENT PnPEvent);
extern NDIS_STATUS GetIPConfigValue(NDIS_HANDLE Handle, PUNICODE_STRING IPConfig);
extern VOID IPUnload(IN PDRIVER_OBJECT DriverObject);

extern BOOLEAN CopyToNdisSafe(
                             PNDIS_BUFFER DestBuf,
                             PNDIS_BUFFER *ppNextBuf,
                             uchar *SrcBuf,
                             uint Size,
                             uint *StartOffset);

extern void NDIS_API ARPSendComplete(NDIS_HANDLE, PNDIS_PACKET, NDIS_STATUS);
extern void IPULUnloadNotify(void);

extern void NotifyOfUnload(void);

extern uint OpenIFConfig(PNDIS_STRING ConfigName, NDIS_HANDLE * Handle);
extern int IsLLInterfaceValueNull(NDIS_HANDLE Handle);
extern void CloseIFConfig(NDIS_HANDLE Handle);

BOOLEAN QueryAndSetOffload(ARPInterface *ai);


ARPTableEntry *CreateARPTableEntry(ARPInterface *Interface, IPAddr Destination,
                                   CTELockHandle *Handle, void *UserArp);

NDIS_STATUS NDIS_API
ARPRcvIndicationNew(NDIS_HANDLE Handle, NDIS_HANDLE Context, void *Header,
                    uint HeaderSize, void *Data, uint Size, uint TotalSize,
                    PNDIS_BUFFER pNdisBuffer, PINT pClientCnt);

void
CompleteIPSetNTEAddrRequestDelayed(CTEEvent *WorkerThreadEvent, PVOID Context);

// Tables for bitswapping.

const uchar SwapTableLo[] =
{
    0,                                  // 0
    0x08,                               // 1
    0x04,                               // 2
    0x0c,                               // 3
    0x02,                               // 4
    0x0a,                               // 5,
    0x06,                               // 6,
    0x0e,                               // 7,
    0x01,                               // 8,
    0x09,                               // 9,
    0x05,                               // 10,
    0x0d,                               // 11,
    0x03,                               // 12,
    0x0b,                               // 13,
    0x07,                               // 14,
    0x0f                                // 15
};

const uchar SwapTableHi[] =
{
    0,                                  // 0
    0x80,                               // 1
    0x40,                               // 2
    0xc0,                               // 3
    0x20,                               // 4
    0xa0,                               // 5,
    0x60,                               // 6,
    0xe0,                               // 7,
    0x10,                               // 8,
    0x90,                               // 9,
    0x50,                               // 10,
    0xd0,                               // 11,
    0x30,                               // 12,
    0xb0,                               // 13,
    0x70,                               // 14,
    0xf0                                // 15
};

// Table of source route maximum I-field lengths for token ring.
const ushort IFieldSize[] =
{
    516,
    1500,
    2052,
    4472,
    8191
};

#define LF_BIT_SHIFT    4
#define MAX_LF_BITS     4

//
// Disposable init or paged code.
//
void FreeARPInterface(ARPInterface * Interface);
void ARPOpen(void *Context);
void NotifyConflictProc(CTEEvent * Event, void *Context);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ARPInit)
#pragma alloc_text(PAGE, ARPOpen)
#pragma alloc_text(PAGELK, ARPRegister)
#pragma alloc_text(PAGE, NotifyConflictProc)
#endif // ALLOC_PRAGMA


LIST_ENTRY ArpInterfaceList;
CACHE_LINE_KSPIN_LOCK ArpInterfaceListLock;
HANDLE ArpEnetHeaderPool;
HANDLE ArpAuxHeaderPool;
#define BUFSIZE_ENET_HEADER_POOL sizeof(ENetHeader) + sizeof(ARPHeader)
#define BUFSIZE_AUX_HEADER_POOL ARP_MAX_MEDIA_TR + (2 * sizeof(ARPHeader))


//
// Support Structs for DoNDISRequest (BLOCKING & NON-BLOCKING)
//
typedef struct _RequestBlock {
    NDIS_REQUEST Request;               // Request structure we'll use
    ULONG Blocking;                     // ? Is this Request Blocking ?
    CTEBlockStruc Block;                // Structure for blocking on. No longer use
    // ai_block since multiple requests can
    // occur simultaneously.
    // ai_block is now only used for blocking on
    // opening and closing the NDIS adapter.
    ULONG RefCount;                     // Reference count (only used for blocking).
    // Reference counting is required for Windows ME since KeWaitForSingleObject
    // can fail (when the event is NOT set) and we need to protect the memory
    // until completion.
} RequestBlock;


// This prototype enables DoNDISRequest to compile without errors
void NDIS_API
ARPRequestComplete(NDIS_HANDLE Handle, PNDIS_REQUEST pRequest,
                   NDIS_STATUS Status);

//* FillARPControlBlock
//
//  A utility routine to transfer a physical address into an ARPControlBlock,
//  taking into account different MAC address formats.
//
//  Entry:
//      Interface   - the ARPInterface which identifies the media
//      Entry       - the ARP entry containing the MAC address
//      ArpContB    - the control-block to be filled
//
__inline
NDIS_STATUS
FillARPControlBlock(ARPInterface* Interface, ARPTableEntry* Entry,
                    ARPControlBlock* ArpContB)
{
    ENetHeader *EHdr;
    TRHeader *TRHdr;
    FDDIHeader *FHdr;
    ARCNetHeader *AHdr;
    uint Size;
    NDIS_STATUS Status;

    if (Interface->ai_media == NdisMediumArcnet878_2) {
        if (!ArpContB->PhyAddrLen) {
            return NDIS_STATUS_BUFFER_OVERFLOW;
        }
        Status = NDIS_STATUS_SUCCESS;
    } else if (ArpContB->PhyAddrLen < ARP_802_ADDR_LENGTH) {
        Size = ArpContB->PhyAddrLen;
        Status = NDIS_STATUS_BUFFER_OVERFLOW;
    } else {
        Size = ARP_802_ADDR_LENGTH;
        Status = NDIS_STATUS_SUCCESS;
    }

    switch (Interface->ai_media) {
    case NdisMedium802_3:
        EHdr = (ENetHeader *) Entry->ate_addr;
        RtlCopyMemory(ArpContB->PhyAddr, EHdr->eh_daddr, Size);
        ArpContB->PhyAddrLen = Size;
        break;
    case NdisMedium802_5:
        TRHdr = (TRHeader *) Entry->ate_addr;
        RtlCopyMemory(ArpContB->PhyAddr, TRHdr->tr_daddr, Size);
        ArpContB->PhyAddrLen = Size;
        break;
    case NdisMediumFddi:
        FHdr = (FDDIHeader *) Entry->ate_addr;
        RtlCopyMemory(ArpContB->PhyAddr, FHdr->fh_daddr, Size);
        ArpContB->PhyAddrLen = Size;
        break;
    case NdisMediumArcnet878_2:
        AHdr = (ARCNetHeader *) Entry->ate_addr;
        ArpContB->PhyAddr[0] = AHdr->ah_daddr;
        ArpContB->PhyAddrLen = 1;
        break;
    default:
        ASSERT(0);
    }
    return Status;
}

//* DoNDISRequest - Submit a (NON) BLOCKING request to an NDIS driver
//
//  This is a utility routine to submit a general request to an NDIS
//  driver. The caller specifes the request code (OID), a buffer and
//  a length. This routine allocates a request structure, fills it in, &
//  submits the request.
//
//  If the call is non-blocking, any memory allocated is deallocated
//  in ARPRequestComplete. Also as this callback is shared by both
//  DoNDISRequest blocking and non-blocking, we suffix the request
//  with a ULONG that tells ARPRequestComplete if this request is a
//  blocking request or not. If the request is non blocking, then the
//  ARPRequestComplete reclaims the memory allocated on the heap
//
//  Important:
//    Allocate Info, which points to the Information Buffer passed to
//    NdisRequest, on the HEAP, if this request does not block. This
//    memory is automatically deallocated by ARPRequestComplete
//
//  If the call is blocking, the request memory can be allocated on the
//  STACK. When we complete the request, the request on the stack
//  will automatically get unwound.
//
//  Entry:
//      Adapter - A pointer to the ARPInterface adapter structure.
//      Request - Type of request to be done (Set or Query)
//      OID     - Value to be set/queried.
//      Info     - A pointer to the info buffer
//      Length  - Length of data in the buffer
//      Needed  - On return, filled in with bytes needed in buffer
//      Blocking - Whether NdisRequest is completed synchronously
//
//  Exit:
//      Status - BLOCKING req - SUCCESS or some NDIS error code
//              NON-BLOCKING - SUCCESS, PENDING or some error
//
NDIS_STATUS
DoNDISRequest(ARPInterface * Adapter, NDIS_REQUEST_TYPE RT, NDIS_OID OID,
              VOID * Info, UINT Length, UINT * Needed, BOOLEAN Blocking)
{
    RequestBlock *pReqBlock;
    NDIS_STATUS Status;

    DEBUGMSG(DBG_TRACE && DBG_ARP && DBG_REQUEST,
         (DTEXT("+DoNDISRequest(%x, %x, %x, %x, %d, %x, %x\n"),
          Adapter, RT, OID, Info, Length, Needed, Blocking));

    if (Adapter->ai_state == INTERFACE_DOWN || Adapter->ai_handle == NULL) {
        return NDIS_STATUS_ADAPTER_NOT_READY;
    }

    //Check if we need to do Task_offload query.
    //To prevent recursion, TASK_OFFLOAD_EX is a special local
    //define, which is used only from setpower code

    if ((OID == OID_TCP_TASK_OFFLOAD_EX) &&
        (Length != sizeof(NDIS_TASK_OFFLOAD_HEADER))) {

        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"DoNdisReq: querying h/w offload capabilities\n"));
        if (QueryAndSetOffload(Adapter)) {

            *(uint *)Info = Adapter->ai_OffloadFlags;

            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"DoNdisReq: new h/w offload capabilities %x\n",Adapter->ai_OffloadFlags));
            return NDIS_STATUS_SUCCESS;
        }
        return NDIS_STATUS_FAILURE;
    }

    // Both blocking and non-blocking requests are allocated from NPP. The
    // blocking case is to protect against wait failure.
    pReqBlock = CTEAllocMemN(sizeof(RequestBlock), 'NiCT');
    if (pReqBlock == NULL) {
        return NDIS_STATUS_RESOURCES;
    }

    if (Blocking) {
        // Initialize the structure to block on
        CTEInitBlockStruc(&pReqBlock->Block);

        // Reference count is initialize to two. One for the completion in
        // ARPRequestComplete and one for when the CTEBlock completes.
        // N.B. This ensures that we don't touch freed memory if
        // the CTEBlock fails on Windows ME.
        pReqBlock->RefCount = 2;

        DEBUGMSG(DBG_INFO && DBG_ARP && DBG_REQUEST,
             (DTEXT("DoNDISRequset block: pReqBlock %x OID %x\n"),
              pReqBlock, OID));
    } else {
        DEBUGMSG(DBG_INFO && DBG_ARP &&  DBG_REQUEST,
             (DTEXT("DoNDISRequest async: pReqBlock %x OID %x\n"),
              pReqBlock, OID));
    }

    // Now fill the request's info buffer (same for BLOCKING & NON-BLOCKING)
    pReqBlock->Block.cbs_status = NDIS_STATUS_SUCCESS;
    pReqBlock->Request.RequestType = RT;
    if (RT == NdisRequestSetInformation) {
        pReqBlock->Request.DATA.SET_INFORMATION.Oid = OID;
        pReqBlock->Request.DATA.SET_INFORMATION.InformationBuffer = Info;
        pReqBlock->Request.DATA.SET_INFORMATION.InformationBufferLength = Length;
    } else {
        pReqBlock->Request.DATA.QUERY_INFORMATION.Oid = OID;
        pReqBlock->Request.DATA.QUERY_INFORMATION.InformationBuffer = Info;
        pReqBlock->Request.DATA.QUERY_INFORMATION.InformationBufferLength = Length;
    }

    pReqBlock->Blocking = Blocking;

    // Submit the request.
    if (Adapter->ai_handle != NULL) {

#if MILLEN
        // On Millennium, the AOL adapter returns with registers trashed.
        // We will work around by saving and restoring registers.
        //

        _asm {
            push esi
            push edi
            push ebx
        }
#endif // MILLEN

        NdisRequest(&Status, Adapter->ai_handle, &pReqBlock->Request);

#if MILLEN
        _asm {
            pop ebx
            pop edi
            pop esi
        }
#endif // MILLEN
} else {

        Status = NDIS_STATUS_FAILURE;
    }

    if (Blocking) {
        if (Status == NDIS_STATUS_PENDING) {


            Status = (NDIS_STATUS) CTEBlock(&pReqBlock->Block);

#if MILLEN
            // If Status == -1, it means the wait failed -- due to system reasons.
            // Put in a reasonable failure.
            if (Status == -1) {
                Status = NDIS_STATUS_FAILURE;
            }
#endif // MILLEN

        } else {
            // Since we aren't blocking, remove refcount for ARPRequestComplete.
            InterlockedDecrement(&pReqBlock->RefCount);
        }

        if (Needed != NULL)
            *Needed = pReqBlock->Request.DATA.QUERY_INFORMATION.BytesNeeded;

        if (InterlockedDecrement(&pReqBlock->RefCount) == 0) {
            CTEFreeMem(pReqBlock);
        }

    } else {
        if (Status != NDIS_STATUS_PENDING) {
            if (Needed != NULL)
                *Needed = pReqBlock->Request.DATA.QUERY_INFORMATION.BytesNeeded;

            ARPRequestComplete(Adapter->ai_handle, &pReqBlock->Request, Status);
        }
    }

    DEBUGMSG(DBG_TRACE && DBG_ARP && DBG_REQUEST,
         (DTEXT("-DoNDISRequest [%x]\n"), Status));

    return Status;
}

//* FreeARPBuffer - Free a header and buffer descriptor pair.
//
//  Called when we're done with a buffer. We'll free the buffer and the
//  buffer descriptor pack to the interface.
//
//  Entry:  Interface   - Interface buffer/bd came frome.
//          Buffer      - NDIS_BUFFER to be freed.
//
//  Returns: Nothing.
//
__inline
VOID
FreeARPBuffer(ARPInterface *Interface, PNDIS_BUFFER Buffer)
{
    MdpFree(Buffer);
}

//* GetARPBuffer - Get a buffer and descriptor
//
//  Returns a pointer to an NDIS_BUFFER and a pointer to a buffer
//      of the specified size.
//
//  Entry:  Interface   - Pointer to ARPInterface structure to allocate buffer from.
//          BufPtr      - Pointer to where to return buf address.
//          Size        - Size in bytes of buffer needed.
//
//  Returns: Pointer to NDIS_BUFFER if successfull, NULL if not
//
PNDIS_BUFFER
GetARPBufferAtDpcLevel(ARPInterface *Interface, uchar **BufPtr, uchar Size)
{
    PNDIS_BUFFER Mdl = NULL;

#if DBG
    *BufPtr = NULL;
#endif

    if (Size <= BUFSIZE_ENET_HEADER_POOL) {
        Mdl = MdpAllocateAtDpcLevel(ArpEnetHeaderPool, BufPtr);
    } else if (Size <= BUFSIZE_AUX_HEADER_POOL) {
        Mdl = MdpAllocateAtDpcLevel(ArpAuxHeaderPool, BufPtr);
    }

    if (Mdl) {
        NdisAdjustBufferLength(Mdl, Size);
    }

    return Mdl;
}

#if MILLEN
#define GetARPBuffer GetARPBufferAtDpcLevel
#else
__inline
PNDIS_BUFFER
GetARPBuffer(ARPInterface *Interface, uchar **BufPtr, uchar Size)
{
    KIRQL OldIrql;
    PNDIS_BUFFER Mdl;

    OldIrql = KeRaiseIrqlToDpcLevel();

    Mdl = GetARPBufferAtDpcLevel(Interface, BufPtr, Size);

    KeLowerIrql(OldIrql);

    return Mdl;
}
#endif


//* BitSwap - Bit swap two strings.
//
//  A routine to bitswap two strings.
//
//  Input:   Dest   - Destination of swap.
//           Src    - Src string to be swapped.
//           Length - Length in bytes to swap.
//
//  Returns: Nothing.
//
void
BitSwap(uchar * Dest, uchar * Src, uint Length)
{
    uint i;
    uchar Temp, TempSrc;

    for (i = 0; i < Length; i++, Dest++, Src++) {
        TempSrc = *Src;
        Temp = SwapTableLo[TempSrc >> 4] | SwapTableHi[TempSrc & 0x0f];
        *Dest = Temp;
    }
}

//* SendARPPacket - Build a header, and send a packet.
//
//  A utility routine to build and ARP header and send a packet. We assume
//  the media specific header has been built.
//
//  Entry:  Interface   - Interface for NDIS drive.
//          Packet      - Pointer to packet to be sent
//          Header      - Pointer to header to fill in.
//          Opcode      - Opcode for packet.
//          Address     - Source HW address.
//          SrcAddr     - Address to use as our source h/w address.
//          Destination - Destination IP address.
//          Src         - Source IP address.
//          HWType      - Hardware type.
//          CheckIF     - TRUE iff we are to check the I/F status before
//                        sending.
//
//  Returns: NDIS_STATUS of send.
//
NDIS_STATUS
SendARPPacket(ARPInterface * Interface, PNDIS_PACKET Packet, ARPHeader * Header, ushort Opcode,
              uchar * Address, uchar * SrcAddr, IPAddr Destination, IPAddr Src,
              ushort HWType, uint CheckIF)
{
    NDIS_STATUS Status;
    PNDIS_BUFFER Buffer;
    uint PacketDone;
    uchar *AddrPtr;

    Header->ah_hw = HWType;
    Header->ah_pro = net_short(ARP_ETYPE_IP);
    Header->ah_hlen = Interface->ai_addrlen;
    Header->ah_plen = sizeof(IPAddr);
    Header->ah_opcode = Opcode;
    AddrPtr = Header->ah_shaddr;

    if (SrcAddr == NULL)
        SrcAddr = Interface->ai_addr;

    RtlCopyMemory(AddrPtr, SrcAddr, Interface->ai_addrlen);

    AddrPtr += Interface->ai_addrlen;
    *(IPAddr UNALIGNED *) AddrPtr = Src;
    AddrPtr += sizeof(IPAddr);

    if (Address != (uchar *) NULL)
        RtlCopyMemory(AddrPtr, Address, Interface->ai_addrlen);
    else
        RtlZeroMemory(AddrPtr, Interface->ai_addrlen);

    AddrPtr += Interface->ai_addrlen;
    *(IPAddr UNALIGNED *) AddrPtr = Destination;

    PacketDone = FALSE;

    if (!CheckIF || Interface->ai_state == INTERFACE_UP) {

        Interface->ai_qlen++;
        NdisSend(&Status, Interface->ai_handle, Packet);

        if (Status != NDIS_STATUS_PENDING) {
            PacketDone = TRUE;
            Interface->ai_qlen--;

            if (Status == NDIS_STATUS_SUCCESS)
                Interface->ai_outoctets += Packet->Private.TotalLength;
            else {
                if (Status == NDIS_STATUS_RESOURCES)
                    Interface->ai_outdiscards++;
                else
                    Interface->ai_outerrors++;
            }
        }
    } else {
        PacketDone = TRUE;
        Status = NDIS_STATUS_ADAPTER_NOT_READY;
    }

    if (PacketDone) {
        NdisUnchainBufferAtFront(Packet, &Buffer);
        FreeARPBuffer(Interface, Buffer);
        NdisFreePacket(Packet);
    }
    return Status;
}

//* SendARPRequest - Send an ARP packet
//
//  Called when we need to ARP an IP address, or respond to a request. We'll send out
//  the packet, and the receiving routines will process the response.
//
//  Entry:  Interface   - Interface to send the request on.
//          Destination - The IP address to be ARPed.
//          Type        - Either RESOLVING_GLOBAL or RESOLVING_LOCAL
//                      SrcAddr         - NULL if we're sending from ourselves, the value
//                                                      to use otherwise.
//                      CheckIF         - Flag passed through to SendARPPacket().
//
//  Returns:    Status of attempt to send ARP request.
//
NDIS_STATUS
SendARPRequest(ARPInterface * Interface, IPAddr Destination, uchar Type,
               uchar * SrcAddr, uint CheckIF)
{
    uchar *MHeader;                     // Pointer to media header.
    PNDIS_BUFFER Buffer;                // NDIS buffer descriptor.
    uchar MHeaderSize;                  // Size of media header.
    const uchar *MAddr;                 // Pointer to media address structure.
    uint SAddrOffset;                   // Offset into media address of source address.
    uchar SRFlag = 0;                   // Source routing flag.
    uchar SNAPLength = 0;
    const uchar *SNAPAddr;              // Address of SNAP header.
    PNDIS_PACKET Packet;                // Packet for sending.
    NDIS_STATUS Status;
    ushort HWType;
    IPAddr Src;
    CTELockHandle Handle;
    ARPIPAddr *Addr;

    // First, get a source address we can use.
    CTEGetLock(&Interface->ai_lock, &Handle);
    Addr = &Interface->ai_ipaddr;
    Src = NULL_IP_ADDR;
    do {
        if (!IP_ADDR_EQUAL(Addr->aia_addr, NULL_IP_ADDR)) {
            //
            // This is a valid address. See if it is the same as the
            // target address - i.e. arp'ing for ourselves. If it is,
            // we want to use that as our source address.
            //
            if (IP_ADDR_EQUAL(Addr->aia_addr, Destination)) {
                Src = Addr->aia_addr;
                break;
            }
            // See if the target is on this subnet.
            if (IP_ADDR_EQUAL(
                             Addr->aia_addr & Addr->aia_mask,
                             Destination & Addr->aia_mask
                             )) {
                //
                // See if we've already found a suitable candidate on the
                // same subnet. If we haven't, we'll use this one.
                //
                if (!IP_ADDR_EQUAL(
                                  Addr->aia_addr & Addr->aia_mask,
                                  Src & Addr->aia_mask
                                  )) {
                    Src = Addr->aia_addr;
                }
            } else {
                // He's not on our subnet. If we haven't already found a valid
                // address save this one in case we don't find a match for the
                // subnet.
                if (IP_ADDR_EQUAL(Src, NULL_IP_ADDR)) {
                    Src = Addr->aia_addr;
                }
            }
        }
        Addr = Addr->aia_next;

    } while (Addr != NULL);

    CTEFreeLock(&Interface->ai_lock, Handle);

    // If we didn't find a source address, give up.
    if (IP_ADDR_EQUAL(Src, NULL_IP_ADDR))
        return NDIS_STATUS_SUCCESS;

    NdisAllocatePacket(&Status, &Packet, Interface->ai_ppool);
    if (Status != NDIS_STATUS_SUCCESS) {
        Interface->ai_outdiscards++;
        return Status;
    }
    ((PacketContext *) Packet->ProtocolReserved)->pc_common.pc_owner = PACKET_OWNER_LINK;
    (Interface->ai_outpcount[AI_NONUCAST_INDEX])++;

    // Figure out what type of media this is, and do the appropriate thing.
    switch (Interface->ai_media) {
    case NdisMedium802_3:
        MHeaderSize = ARP_MAX_MEDIA_ENET;
        MAddr = ENetBcst;
        if (Interface->ai_snapsize == 0) {
            SNAPAddr = (uchar *) NULL;
            HWType = net_short(ARP_HW_ENET);
        } else {
            SNAPLength = sizeof(SNAPHeader);
            SNAPAddr = ARPSNAP;
            HWType = net_short(ARP_HW_802);
        }

        SAddrOffset = offsetof(struct ENetHeader, eh_saddr);
        break;
    case NdisMedium802_5:
        // Token ring. We have logic for dealing with the second transmit
        // of an arp request.
        MAddr = TRBcst;
        SAddrOffset = offsetof(struct TRHeader, tr_saddr);
        SNAPLength = sizeof(SNAPHeader);
        SNAPAddr = ARPSNAP;
        MHeaderSize = sizeof(TRHeader);
        HWType = net_short(ARP_HW_802);
        if (Type == ARP_RESOLVING_GLOBAL) {
            MHeaderSize += sizeof(RC);
            SRFlag = TR_RII;
        }
        break;
    case NdisMediumFddi:
        MHeaderSize = sizeof(FDDIHeader);
        MAddr = FDDIBcst;
        SNAPAddr = ARPSNAP;
        SNAPLength = sizeof(SNAPHeader);
        SAddrOffset = offsetof(struct FDDIHeader, fh_saddr);
        HWType = net_short(ARP_HW_ENET);
        break;
    case NdisMediumArcnet878_2:
        MHeaderSize = ARP_MAX_MEDIA_ARC;
        MAddr = ARCBcst;
        SNAPAddr = (uchar *) NULL;
        SAddrOffset = offsetof(struct ARCNetHeader, ah_saddr);
        HWType = net_short(ARP_HW_ARCNET);
        break;
    default:
        ASSERT(0);
        Interface->ai_outerrors++;
        return NDIS_STATUS_UNSUPPORTED_MEDIA;
    }

    if ((Buffer = GetARPBuffer(Interface, &MHeader,
                               (uchar) (sizeof(ARPHeader) + MHeaderSize + SNAPLength))) == (PNDIS_BUFFER) NULL) {
        NdisFreePacket(Packet);
        Interface->ai_outdiscards++;
        return NDIS_STATUS_RESOURCES;
    }
    if (Interface->ai_media == NdisMediumArcnet878_2) {
        NdisAdjustBufferLength(Buffer, NdisBufferLength(Buffer) - ARCNET_ARPHEADER_ADJUSTMENT);
    }

    // Copy broadcast address into packet.
    RtlCopyMemory(MHeader, MAddr, MHeaderSize);
    // Fill in source address.
    if (SrcAddr == NULL) {
        SrcAddr = Interface->ai_addr;
    }
    if (Interface->ai_media == NdisMedium802_3 && Interface->ai_snapsize != 0) {
        ENetHeader *Hdr = (ENetHeader *) MHeader;

        // Using SNAP on ethernet. Adjust the etype to a length.
        Hdr->eh_type = net_short(sizeof(ARPHeader) + sizeof(SNAPHeader));
    }
    RtlCopyMemory(&MHeader[SAddrOffset], SrcAddr, Interface->ai_addrlen);
    if ((Interface->ai_media == NdisMedium802_5) && (Type == ARP_RESOLVING_GLOBAL)) {
        // Turn on source routing.
        MHeader[SAddrOffset] |= SRFlag;
        MHeader[SAddrOffset + Interface->ai_addrlen] |= TrRii;
    }
    // Copy in SNAP header, if any.
    RtlCopyMemory(&MHeader[MHeaderSize], SNAPAddr, SNAPLength);

    // Media header is filled in. Now do ARP packet itself.
    NdisChainBufferAtFront(Packet, Buffer);
    return SendARPPacket(Interface, Packet, (ARPHeader *) & MHeader[MHeaderSize + SNAPLength],
                         net_short(ARP_REQUEST), (uchar *) NULL, SrcAddr, Destination, Src,
                         HWType, CheckIF);
}

//* SendARPReply - Reply to an ARP request.
//
//  Called by our receive packet handler when we need to reply. We build a packet
//  and buffer and call SendARPPacket to send it.
//
//  Entry:  Interface   - Pointer to interface to reply on.
//          Destination - IPAddress to reply to.
//          Src         - Source address to reply from.
//          HWAddress   - Hardware address to reply to.
//          SourceRoute - Source Routing information, if any.
//          SourceRouteSize - Size in bytes of soure routing.
//                      UseSNAP         - Whether or not to use SNAP for this reply.
//
//  Returns: Nothing.
//
void
SendARPReply(ARPInterface * Interface, IPAddr Destination, IPAddr Src, uchar * HWAddress,
             RC UNALIGNED * SourceRoute, uint SourceRouteSize, uint UseSNAP)
{
    PNDIS_PACKET Packet;                // Buffer and packet to be used.
    PNDIS_BUFFER Buffer;
    uchar *Header;                      // Pointer to media header.
    NDIS_STATUS Status;
    uchar Size = 0;                     // Size of media header buffer.
    ushort HWType;
    ENetHeader *EH;
    FDDIHeader *FH;
    ARCNetHeader *AH;
    TRHeader *TRH;

    // Allocate a packet for this.
    NdisAllocatePacket(&Status, &Packet, Interface->ai_ppool);
    if (Status != NDIS_STATUS_SUCCESS) {
        Interface->ai_outdiscards++;
        return;
    }
    ((PacketContext *) Packet->ProtocolReserved)->pc_common.pc_owner = PACKET_OWNER_LINK;
    (Interface->ai_outpcount[AI_UCAST_INDEX])++;

    Size = Interface->ai_hdrsize;

    if (UseSNAP)
        Size += Interface->ai_snapsize;

    if (Interface->ai_media == NdisMedium802_5)
        Size += (uchar) SourceRouteSize;

    if ((Buffer = GetARPBuffer(Interface, &Header, (uchar) (Size + sizeof(ARPHeader)))) ==
        (PNDIS_BUFFER) NULL) {
        Interface->ai_outdiscards++;
        NdisFreePacket(Packet);
        return;
    }
    // Decide how to build the header based on the media type.
    switch (Interface->ai_media) {
    case NdisMedium802_3:
        EH = (ENetHeader *) Header;
        RtlCopyMemory(EH->eh_daddr, HWAddress, ARP_802_ADDR_LENGTH);
        RtlCopyMemory(EH->eh_saddr, Interface->ai_addr, ARP_802_ADDR_LENGTH);
        if (!UseSNAP) {
            EH->eh_type = net_short(ARP_ETYPE_ARP);
            HWType = net_short(ARP_HW_ENET);
        } else {
            // Using SNAP on ethernet.
            EH->eh_type = net_short(sizeof(ARPHeader) + sizeof(SNAPHeader));
            HWType = net_short(ARP_HW_802);
            RtlCopyMemory(Header + sizeof(ENetHeader), ARPSNAP,
                       sizeof(SNAPHeader));
        }
        break;
    case NdisMedium802_5:
        TRH = (TRHeader *) Header;
        TRH->tr_ac = ARP_AC;
        TRH->tr_fc = ARP_FC;
        RtlCopyMemory(TRH->tr_daddr, HWAddress, ARP_802_ADDR_LENGTH);
        RtlCopyMemory(TRH->tr_saddr, Interface->ai_addr, ARP_802_ADDR_LENGTH);
        if (SourceRouteSize) {          // If we have source route info, deal with
            // it.

            RtlCopyMemory(Header + sizeof(TRHeader), SourceRoute,
                       SourceRouteSize);
            // Convert to directed  response.
            ((RC *) & Header[sizeof(TRHeader)])->rc_blen &= RC_LENMASK;

            ((RC *) & Header[sizeof(TRHeader)])->rc_dlf ^= RC_DIR;
            TRH->tr_saddr[0] |= TR_RII;
        }
        RtlCopyMemory(Header + sizeof(TRHeader) + SourceRouteSize, ARPSNAP,
                   sizeof(SNAPHeader));
        HWType = net_short(ARP_HW_802);
        break;
    case NdisMediumFddi:
        FH = (FDDIHeader *) Header;
        FH->fh_pri = ARP_FDDI_PRI;
        RtlCopyMemory(FH->fh_daddr, HWAddress, ARP_802_ADDR_LENGTH);
        RtlCopyMemory(FH->fh_saddr, Interface->ai_addr, ARP_802_ADDR_LENGTH);
        RtlCopyMemory(Header + sizeof(FDDIHeader), ARPSNAP, sizeof(SNAPHeader));
        HWType = net_short(ARP_HW_ENET);
        break;
    case NdisMediumArcnet878_2:
        AH = (ARCNetHeader *) Header;
        AH->ah_saddr = Interface->ai_addr[0];
        AH->ah_daddr = *HWAddress;
        AH->ah_prot = ARP_ARCPROT_ARP;
        NdisAdjustBufferLength(Buffer, NdisBufferLength(Buffer) - ARCNET_ARPHEADER_ADJUSTMENT);
        HWType = net_short(ARP_HW_ARCNET);
        break;
    default:
        ASSERT(0);
        Interface->ai_outerrors++;
        FreeARPBuffer(Interface, Buffer);
        NdisFreePacket(Packet);
        return;
    }

    NdisChainBufferAtFront(Packet, Buffer);
    SendARPPacket(Interface, Packet, (ARPHeader *) (Header + Size), net_short(ARP_RESPONSE),
                  HWAddress, NULL, Destination, Src, HWType, TRUE);
}

//* ARPRemoveRCE - Remove an RCE from the ATE list.
//
//  This funtion removes a specified RCE from a given ATE. It assumes the ate_lock
//  is held by the caller.
//
//  Entry:  ATE     - ATE from which RCE is to be removed.
//          RCE     - RCE to be removed.
//
//  Returns:   Nothing
//
void
ARPRemoveRCE(ARPTableEntry * ATE, RouteCacheEntry * RCE)
{
    ARPContext *CurrentAC;              // Current ARP Context being checked.
#if DBG
    uint Found = FALSE;
#endif

    CurrentAC = (ARPContext *) (((char *)&ATE->ate_rce) -
                                offsetof(struct ARPContext, ac_next));

    while (CurrentAC->ac_next != (RouteCacheEntry *) NULL)
        if (CurrentAC->ac_next == RCE) {
            ARPContext *DummyAC = (ARPContext *) RCE->rce_context;
            CurrentAC->ac_next = DummyAC->ac_next;
            DummyAC->ac_ate = (ARPTableEntry *) NULL;
#if DBG
            Found = TRUE;
#endif
            break;
        } else
            CurrentAC = (ARPContext *) CurrentAC->ac_next->rce_context;

    ASSERT(Found);
}

//* ARPLookup - Look up an entry in the ARP table.
//
//  Called to look up an entry in an interface's ARP table. If we find it, we'll
//  lock the entry and return a pointer to it, otherwise we return NULL. We
//  assume that the caller has the ARP table locked when we are called.
//
//  The ARP table entry is structured as a hash table of pointers to
//  ARPTableEntrys.After hashing on the IP address, a linear search is done to
//  lookup the entry.
//
//  If we find the entry, we lock it for the caller. If we don't find
//  the entry, we leave the ARP table locked so that the caller may atomically
//  insert a new entry without worrying about a duplicate being inserted between
//  the time the table was checked and the time the caller went to insert the
//  entry.
//
//  Entry:  Interface   - The interface to be searched upon.
//          Address     - The IP address we're looking up.
//          Handle      - Pointer to lock handle to be used to lock entry.
//
//  Returns: Pointer to ARPTableEntry if found, or NULL if not.
//
ARPTableEntry *
ARPLookup(ARPInterface * Interface, IPAddr Address, CTELockHandle * Handle)
{
    int i = ARP_HASH(Address);          // Index into hash table.
    ARPTableEntry *Current;             // Current ARP Table entry being
    // examined.

    Current = (*Interface->ai_ARPTbl)[i];

    while (Current != (ARPTableEntry *) NULL) {
        CTEGetLockAtDPC(&Current->ate_lock, Handle);
        if (IP_ADDR_EQUAL(Current->ate_dest, Address)) {    // Found a match.
            *Handle = DISPATCH_LEVEL;
            return Current;
        }
        CTEFreeLockFromDPC(&Current->ate_lock, *Handle);
        Current = Current->ate_next;
    }
    // If we got here, we didn't find the entry. Leave the table locked and
    // return the handle.
    return(ARPTableEntry *) NULL;
}

//*     IsBCastOnIF- See it an address is a broadcast address on an interface.
//
//      Called to see if a particular address is a broadcast address on an
//      interface. We'll check the global, net, and subnet broadcasts. We assume
//      the caller holds the lock on the interface.
//
//      Entry:  Interface               - Interface to check.
//              Addr                    - Address to check.
//
//      Returns: TRUE if it it a broadcast, FALSE otherwise.
//
uint
IsBCastOnIF(ARPInterface * Interface, IPAddr Addr)
{
    IPAddr BCast;
    IPMask Mask;
    ARPIPAddr *ARPAddr;
    IPAddr LocalAddr;

    // First get the interface broadcast address.
    BCast = Interface->ai_bcast;

    // First check for global broadcast.
    if (IP_ADDR_EQUAL(BCast, Addr) || CLASSD_ADDR(Addr))
        return TRUE;

    // Now walk the local addresses, and check for net/subnet bcast on each
    // one.
    ARPAddr = &Interface->ai_ipaddr;
    do {
        // See if this one is valid.
        LocalAddr = ARPAddr->aia_addr;
        if (!IP_ADDR_EQUAL(LocalAddr, NULL_IP_ADDR)) {
            // He's valid.
            Mask = ARPAddr->aia_mask;

            // First check for subnet bcast.
            if (IP_ADDR_EQUAL((LocalAddr & Mask) | (BCast & ~Mask), Addr))
                return TRUE;

            // Now check all nets broadcast.
            Mask = IPNetMask(LocalAddr);
            if (IP_ADDR_EQUAL((LocalAddr & Mask) | (BCast & ~Mask), Addr))
                return TRUE;
        }
        ARPAddr = ARPAddr->aia_next;

    } while (ARPAddr != NULL);

    // If we're here, it's not a broadcast.
    return FALSE;

}

//* ARPSendBCast - See if this is a bcast or mcast frame, and send it.
//
//   Called when we have a packet to send and we want to see if it's a broadcast
//   or multicast frame on this interface. We'll search the local addresses and
//   see if we can determine if it is. If it is, we'll send it here. Otherwise
//   we return FALSE, and the caller will try to resolve the address.
//
//   Entry:  Interface       - A pointer to an AI structure.
//           Dest            - Destination of datagram.
//           Packet          - Packet to be sent.
//           Status          - Place to return status of send attempt.
//
//    Returns: TRUE if is was a bcast or mcast send, FALSE otherwise.
//
uint
ARPSendBCast(ARPInterface * Interface, IPAddr Dest, PNDIS_PACKET Packet,
             PNDIS_STATUS Status)
{
    uint IsBCast;
    CTELockHandle Handle;
    PNDIS_BUFFER ARPBuffer;             // ARP Header buffer.
    uchar *BufAddr;                     // Address of NDIS buffer
    NDIS_STATUS MyStatus;
    ENetHeader *Hdr;
    FDDIHeader *FHdr;
    TRHeader *TRHdr;
    SNAPHeader UNALIGNED *SNAPPtr;
    RC UNALIGNED *RCPtr;
    ARCNetHeader *AHdr;
    uint DataLength;

    // Get the lock, and see if it's a broadcast.
    CTEGetLock(&Interface->ai_lock, &Handle);
    IsBCast = IsBCastOnIF(Interface, Dest);
    CTEFreeLock(&Interface->ai_lock, Handle);

    if (IsBCast) {
        if (Interface->ai_state == INTERFACE_UP) {
            uchar Size;

            Size = Interface->ai_hdrsize + Interface->ai_snapsize;
            if (Interface->ai_media == NdisMedium802_5)
                Size += sizeof(RC);
            ARPBuffer = GetARPBuffer(Interface, &BufAddr, Size);
            if (ARPBuffer != NULL) {
                uint UNALIGNED *Temp;
                // Got the buffer we need.
                switch (Interface->ai_media) {
                case NdisMedium802_3:

                    Hdr = (ENetHeader *) BufAddr;
                    if (!CLASSD_ADDR(Dest))
                        RtlCopyMemory(Hdr, ENetBcst, ARP_802_ADDR_LENGTH);
                    else {
                        RtlCopyMemory(Hdr, ENetMcst, ARP_802_ADDR_LENGTH);
                        Temp = (uint UNALIGNED *) & Hdr->eh_daddr[2];
                        *Temp |= (Dest & ARP_MCAST_MASK);
                    }

                    RtlCopyMemory(Hdr->eh_saddr, Interface->ai_addr,
                               ARP_802_ADDR_LENGTH);

                    if (Interface->ai_snapsize == 0) {
                        // No snap on this interface, so just use ETypr.
                        Hdr->eh_type = net_short(ARP_ETYPE_IP);
                    } else {
                        ushort ShortDataLength;

                        // We're using SNAP. Find the size of the packet.
                        NdisQueryPacket(Packet, NULL, NULL, NULL,
                                        &DataLength);
                        ShortDataLength = (ushort) (DataLength +
                                                    sizeof(SNAPHeader));
                        Hdr->eh_type = net_short(ShortDataLength);
                        SNAPPtr = (SNAPHeader UNALIGNED *)
                                  (BufAddr + sizeof(ENetHeader));
                        RtlCopyMemory(SNAPPtr, ARPSNAP, sizeof(SNAPHeader));
                        SNAPPtr->sh_etype = net_short(ARP_ETYPE_IP);
                    }

                    break;

                case NdisMedium802_5:

                    // This is token ring. We'll have to mess around with
                    // source routing.


                    // for multicast - see RFC 1469.
                    // Handle RFC 1469.

                    if (!CLASSD_ADDR(Dest) || (!TRFunctionalMcast)) {

                        TRHdr = (TRHeader *) BufAddr;

                        RtlCopyMemory(TRHdr, TRBcst, offsetof(TRHeader, tr_saddr));
                        RtlCopyMemory(TRHdr->tr_saddr, Interface->ai_addr,
                                   ARP_802_ADDR_LENGTH);
                    } else {

                        TRHdr = (TRHeader *) BufAddr;

                        RtlCopyMemory(TRHdr, TRMcst, offsetof(TRHeader, tr_saddr));
                        RtlCopyMemory(TRHdr->tr_saddr, Interface->ai_addr,
                                   ARP_802_ADDR_LENGTH);
                    }

                    if (sIPAlwaysSourceRoute) {
                        TRHdr->tr_saddr[0] |= TR_RII;

                        RCPtr = (RC UNALIGNED *) ((uchar *) TRHdr + sizeof(TRHeader));
                        RCPtr->rc_blen = TrRii | RC_LEN;
                        RCPtr->rc_dlf = RC_BCST_LEN;
                        SNAPPtr = (SNAPHeader UNALIGNED *) ((uchar *) RCPtr + sizeof(RC));
                    } else {

                        //
                        // Adjust the size of the buffer to account for the
                        // fact that we don't have the RC field.
                        //
                        NdisAdjustBufferLength(ARPBuffer, (Size - sizeof(RC)));
                        SNAPPtr = (SNAPHeader UNALIGNED *) ((uchar *) TRHdr + sizeof(TRHeader));
                    }
                    RtlCopyMemory(SNAPPtr, ARPSNAP, sizeof(SNAPHeader));
                    SNAPPtr->sh_etype = net_short(ARP_ETYPE_IP);

                    break;
                case NdisMediumFddi:
                    FHdr = (FDDIHeader *) BufAddr;

                    if (!CLASSD_ADDR(Dest))
                        RtlCopyMemory(FHdr, FDDIBcst,
                                   offsetof(FDDIHeader, fh_saddr));
                    else {
                        RtlCopyMemory(FHdr, FDDIMcst,
                                   offsetof(FDDIHeader, fh_saddr));
                        Temp = (uint UNALIGNED *) & FHdr->fh_daddr[2];
                        *Temp |= (Dest & ARP_MCAST_MASK);
                    }

                    RtlCopyMemory(FHdr->fh_saddr, Interface->ai_addr,
                               ARP_802_ADDR_LENGTH);

                    SNAPPtr = (SNAPHeader UNALIGNED *) (BufAddr + sizeof(FDDIHeader));
                    RtlCopyMemory(SNAPPtr, ARPSNAP, sizeof(SNAPHeader));
                    SNAPPtr->sh_etype = net_short(ARP_ETYPE_IP);

                    break;
                case NdisMediumArcnet878_2:
                    AHdr = (ARCNetHeader *) BufAddr;
                    AHdr->ah_saddr = Interface->ai_addr[0];
                    AHdr->ah_daddr = 0;
                    AHdr->ah_prot = ARP_ARCPROT_IP;
                    break;
                default:
                    ASSERT(0);
                    *Status = NDIS_STATUS_UNSUPPORTED_MEDIA;
                    FreeARPBuffer(Interface, ARPBuffer);
                    return FALSE;

                }

                (Interface->ai_outpcount[AI_NONUCAST_INDEX])++;
                Interface->ai_qlen++;
                NdisChainBufferAtFront(Packet, ARPBuffer);
                NdisSend(&MyStatus, Interface->ai_handle, Packet);

                *Status = MyStatus;

                if (MyStatus != NDIS_STATUS_PENDING) {    // Send finished
                    // immediately.

                    if (MyStatus == NDIS_STATUS_SUCCESS) {
                        Interface->ai_outoctets += Packet->Private.TotalLength;
                    } else {
                        if (MyStatus == NDIS_STATUS_RESOURCES)
                            Interface->ai_outdiscards++;
                        else
                            Interface->ai_outerrors++;
                    }

                    Interface->ai_qlen--;
                    NdisUnchainBufferAtFront(Packet, &ARPBuffer);
                    FreeARPBuffer(Interface, ARPBuffer);
                }
            } else
                *Status = NDIS_STATUS_RESOURCES;
        } else
            *Status = NDIS_STATUS_ADAPTER_NOT_READY;

        return TRUE;

    } else
        return FALSE;
}

//* ARPResolveIP - resolves IP address
//
//  Called by IP layer when it needs to find physical address of the host
//  given the interface and dest IP address
//  Entry:  Interface   - A pointer to the AI structure.
//          ArpControlBlock      - A pointer to the BufDesc chain to be sent.
//
//  Returns: Status.
//

NDIS_STATUS
ARPResolveIP(void *Context, IPAddr Destination, void *ArpControlBlock)
{
    ARPInterface *ai = (ARPInterface *) Context;    // Set up as AI pointer.
    ARPControlBlock *ArpContB = (ARPControlBlock *) ArpControlBlock;

    ARPTableEntry *entry;               // Pointer to ARP tbl. entry
    CTELockHandle lhandle, tlhandle;    // Lock handle
    NDIS_STATUS Status;
    uchar ate_state;

    CTEGetLock(&ai->ai_ARPTblLock, &tlhandle);

    // Check if we already got the mapping.

    if ((entry = ARPLookup(ai, Destination, &lhandle)) != NULL) {

        // Found a matching entry. ARPLookup returns with the ATE lock held.

        if (entry->ate_state != ARP_GOOD) {
            Status = NDIS_STATUS_FAILURE;
        } else {
            Status = FillARPControlBlock(ai, entry, ArpContB);
        }

        CTEFreeLockFromDPC(&entry->ate_lock, lhandle);
        CTEFreeLock(&ai->ai_ARPTblLock, tlhandle);
        return Status;
    }
    // We need to send arp request.

    CTEFreeLock(&ai->ai_ARPTblLock, tlhandle);

    entry = CreateARPTableEntry(ai, Destination, &lhandle, ArpContB);

    if (entry != NULL) {
        if (entry->ate_state <= ARP_RESOLVING) {    // Newly created entry.

            // Someone else could have raced in and created the entry between
            // the time we free the lock and the time we called
            // CreateARPTableEntry(). We check this by looking at the packet
            // on the entry. If there is no old packet we'll ARP. If there is,
            // we'll call ARPSendData to figure out what to do.

            if (entry->ate_packet == NULL) {

                ate_state = entry->ate_state;

                CTEFreeLock(&entry->ate_lock, lhandle);

                SendARPRequest(ai, Destination, ate_state, NULL, TRUE);

                // We don't know the state of the entry - we've freed the lock
                // and yielded, and it could conceivably have timed out by now,
                // or SendARPRequest could have failed, etc. We could take the
                // lock, check the status from SendARPRequest, see if it's
                // still the same packet, and then make a decision on the
                // return value, but it's easiest just to return pending. If
                // SendARPRequest failed, the entry will time out anyway.

                return NDIS_STATUS_PENDING;

            } else {
                CTEFreeLock(&entry->ate_lock, lhandle);
                return NDIS_STATUS_PENDING;
            }
        } else if (entry->ate_state == ARP_GOOD) {    // Yow! A valid entry.

            Status = FillARPControlBlock(ai, entry, ArpContB);

            //remove ArpContB from ate_resolveonly queue.

            if (entry->ate_resolveonly) {
                ARPControlBlock *TmpArpContB, *PrvArpContB = NULL;
                TmpArpContB = entry->ate_resolveonly;

                while (TmpArpContB && (ArpContB != TmpArpContB)) {
                    PrvArpContB = TmpArpContB;
                    TmpArpContB = TmpArpContB->next;
                }
                if (TmpArpContB == ArpContB) {
                    if (PrvArpContB) {
                        PrvArpContB->next = ArpContB->next;
                    } else {
                        entry->ate_resolveonly = NULL;
                    }
                }
            }

            CTEFreeLock(&entry->ate_lock, lhandle);
            return Status;

        } else {                    // An invalid entry!
            CTEFreeLock(&entry->ate_lock, lhandle);
            return NDIS_STATUS_RESOURCES;
        }
    } else {                             // Couldn't create an entry.
        return NDIS_STATUS_RESOURCES;
    }
}

//* ARPSendData - Send a frame to a specific destination address.
//
//  Called when we need to send a frame to a particular address, after the
//  ATE has been looked up. We take in an ATE and a packet, validate the state of the
//  ATE, and either send or ARP for the address if it's not done resolving. We assume
//  the lock on the ATE is held where we're called, and we'll free it before returning.
//
//  Entry:  Interface   - A pointer to the AI structure.
//          Packet      - A pointer to the BufDesc chain to be sent.
//          entry       - A pointer to the ATE for the send.
//          lhandle     - Pointer to a lock handle for the ATE.
//
//  Returns: Status of the transmit - success, an error, or pending.
//
NDIS_STATUS
ARPSendData(ARPInterface * Interface, PNDIS_PACKET Packet, ARPTableEntry * entry,
            CTELockHandle lhandle)
{
    PNDIS_BUFFER ARPBuffer = NULL;      // ARP Header buffer.
    uchar *BufAddr;                     // Address of NDIS buffer
    NDIS_STATUS Status;                 // Status of send.

#if BACK_FILL
    PMDL TmpMdl = NULL;
#endif

    if (Interface->ai_state == INTERFACE_UP) {

        if (entry->ate_state == ARP_GOOD) {    // Entry is valid

            entry->ate_useticks = ArpCacheLife;

#if BACK_FILL
            if (Interface->ai_media == NdisMedium802_3) {

                NdisQueryPacket(Packet, NULL, NULL, &TmpMdl, NULL);

                if (TmpMdl->MdlFlags & MDL_NETWORK_HEADER) {

                    (ULONG_PTR) TmpMdl->MappedSystemVa -= entry->ate_addrlength;
                    TmpMdl->ByteOffset -= entry->ate_addrlength;
                    TmpMdl->ByteCount += entry->ate_addrlength;
                    ARPBuffer = (PNDIS_BUFFER) TmpMdl;
                    BufAddr = TmpMdl->MappedSystemVa;
                } else {
                    TmpMdl = NULL;
                }
            }
            if (ARPBuffer == (PNDIS_BUFFER) NULL) {

                ARPBuffer = GetARPBufferAtDpcLevel(Interface, &BufAddr,
                                                   entry->ate_addrlength);
            }
#else
            ARPBuffer = GetARPBufferAtDpcLevel(Interface, &BufAddr,
                                               entry->ate_addrlength);
#endif
            if (ARPBuffer != (PNDIS_BUFFER) NULL) {
                // Everything's in good shape, copy header and send packet.

                (Interface->ai_outpcount[AI_UCAST_INDEX])++;
                Interface->ai_qlen++;
                RtlCopyMemory(BufAddr, entry->ate_addr, entry->ate_addrlength);

                // If we're on Ethernet, see if we're using SNAP here.
                if (Interface->ai_media == NdisMedium802_3 &&
                    entry->ate_addrlength != sizeof(ENetHeader)) {
                    ENetHeader *Header;
                    uint DataSize;
                    ushort ShortDataSize;

                    // We're apparently using SNAP on Ethernet. Query the
                    // packet for the size, and set the length properly.
                    NdisQueryPacket(Packet, NULL, NULL, NULL, &DataSize);

#if BACK_FILL
                    if (!TmpMdl) {
                        ShortDataSize = (ushort) (DataSize + sizeof(SNAPHeader));
                    } else {
                        ShortDataSize = (ushort) (DataSize - entry->ate_addrlength + sizeof(SNAPHeader));
                    }
#else // BACK_FILL
                    ShortDataSize = (ushort) (DataSize + sizeof(SNAPHeader));
#endif // !BACK_FILL
                    Header = (ENetHeader *) BufAddr;
                    Header->eh_type = net_short(ShortDataSize);

                    // In case backfill is enabled, we need to remember that
                    // a SNAP header was appended to the Ethernet header
                    // so we can restore the correct offsets in the MDL.
                    ((PacketContext*)
                     Packet->ProtocolReserved)->pc_common.pc_flags |=
                    PACKET_FLAG_SNAP;
                } else
                    ((PacketContext*)
                     Packet->ProtocolReserved)->pc_common.pc_flags &=
                    ~PACKET_FLAG_SNAP;
                CTEFreeLock(&entry->ate_lock, lhandle);

#if BACK_FILL
                if (TmpMdl == NULL) {
                    NdisChainBufferAtFront(Packet, ARPBuffer);
                }
#else
                NdisChainBufferAtFront(Packet, ARPBuffer);
#endif

                NdisSend(&Status, Interface->ai_handle, Packet);
                if (Status != NDIS_STATUS_PENDING) {    // Send finished
                    // immediately.

                    if (Status == NDIS_STATUS_SUCCESS) {
                        Interface->ai_outoctets += Packet->Private.TotalLength;
                    } else {
                        if (Status == NDIS_STATUS_RESOURCES)
                            Interface->ai_outdiscards++;
                        else
                            Interface->ai_outerrors++;
                    }

                    Interface->ai_qlen--;

#if BACK_FILL
                    if (TmpMdl == NULL) {
                        NdisUnchainBufferAtFront(Packet, &ARPBuffer);
                        FreeARPBuffer(Interface, ARPBuffer);
                    } else {
                        uint HdrSize;
                        HdrSize = sizeof(ENetHeader);

                        if (((PacketContext *)
                             Packet->ProtocolReserved)->pc_common.pc_flags &
                            PACKET_FLAG_SNAP)
                            HdrSize += Interface->ai_snapsize;

                        (ULONG_PTR) TmpMdl->MappedSystemVa += HdrSize;
                        TmpMdl->ByteOffset += HdrSize;
                        TmpMdl->ByteCount -= HdrSize;
                    }
#else
                    NdisUnchainBufferAtFront(Packet, &ARPBuffer);
                    FreeARPBuffer(Interface, ARPBuffer);
#endif

                }
                return Status;
            } else {                    // No buffer, free lock and return.

                CTEFreeLock(&entry->ate_lock, lhandle);
                Interface->ai_outdiscards++;
                return NDIS_STATUS_RESOURCES;
            }
        }
        // The IP addresses match, but the state of the ARP entry indicates
        // it's not valid. If the address is marked as resolving, we'll replace
        // the current cached packet with this one. If it's been more than
        // ARP_FLOOD_RATE ms. since we last sent an ARP request, we'll send
        // another one now.
        if (entry->ate_state <= ARP_RESOLVING) {
            PNDIS_PACKET OldPacket = entry->ate_packet;
            ulong Now = CTESystemUpTime();
            entry->ate_packet = Packet;
            if ((Now - entry->ate_valid) > ARP_FLOOD_RATE) {
                IPAddr Dest = entry->ate_dest;

                entry->ate_valid = Now;
                entry->ate_state = ARP_RESOLVING_GLOBAL;    // We've done this
                // at least once.

                CTEFreeLock(&entry->ate_lock, lhandle);
                SendARPRequest(Interface, Dest, ARP_RESOLVING_GLOBAL,
                               NULL, TRUE);    // Send a request.

            } else
                CTEFreeLock(&entry->ate_lock, lhandle);

            if (OldPacket)
                IPSendComplete(Interface->ai_context, OldPacket,
                               NDIS_STATUS_SUCCESS);

            return NDIS_STATUS_PENDING;
        } else {
            ASSERT(0);
            CTEFreeLock(&entry->ate_lock, lhandle);
            Interface->ai_outerrors++;
            return NDIS_STATUS_INVALID_PACKET;
        }
    } else {
        // Adapter is down. Just return the error.
        CTEFreeLock(&entry->ate_lock, lhandle);
        return NDIS_STATUS_ADAPTER_NOT_READY;
    }
}

//* CreateARPTableEntry - Create a new entry in the ARP table.
//
//  A function to put an entry into the ARP table. We allocate memory if we
//  need to.
//
//  The first thing to do is get the lock on the ARP table, and see if the
//  entry already exists. If it does, we're done. Otherwise we need to
//  allocate memory and create a new entry.
//
//  Entry:  Interface - Interface for ARP table.
//          Destination - Destination address to be mapped.
//          Handle - Pointer to lock handle for entry.
//
//  Returns: Pointer to newly created entry.
//
ARPTableEntry *
CreateARPTableEntry(ARPInterface * Interface, IPAddr Destination,
                    CTELockHandle * Handle, void *UserArp)
{
    ARPTableEntry *NewEntry, *Entry;
    CTELockHandle TableHandle;
    int i = ARP_HASH(Destination);
    int Size;

    // First look for it, and if we don't find it return try to create one.
    CTEGetLock(&Interface->ai_ARPTblLock, &TableHandle);
    if ((Entry = ARPLookup(Interface, Destination, Handle)) != NULL) {
        CTEFreeLockFromDPC(&Interface->ai_ARPTblLock, *Handle);
        *Handle = TableHandle;

        // if we are using arp api entry, turn off the
        // userarp flag so that handle arp need not free it.
        if (!UserArp && Entry->ate_userarp) {
            Entry->ate_userarp = 0;
        }

        if (UserArp) {
            if (Entry->ate_resolveonly) {
                // chain the current request at the end of the new
                // before using the new request as the head.
                //
                ((ARPControlBlock *)UserArp)->next = Entry->ate_resolveonly;
            }
            // link the new request.
            //
            Entry->ate_resolveonly = (ARPControlBlock *)UserArp;
        }

        return Entry;
    }
    // Allocate memory for the entry. If we can't, fail the request.
    Size = sizeof(ARPTableEntry) - 1 +
           (Interface->ai_media == NdisMedium802_5 ?
            ARP_MAX_MEDIA_TR : (Interface->ai_hdrsize +
                                Interface->ai_snapsize));

    if ((NewEntry = CTEAllocMemN(Size, 'QiCT')) == (ARPTableEntry *) NULL) {
        CTEFreeLock(&Interface->ai_ARPTblLock, TableHandle);
        return (ARPTableEntry *) NULL;
    }

    RtlZeroMemory(NewEntry, Size);
    NewEntry->ate_dest = Destination;
    if (Interface->ai_media != NdisMedium802_5 || sArpAlwaysSourceRoute) {
        NewEntry->ate_state = ARP_RESOLVING_GLOBAL;
    } else {
        NewEntry->ate_state = ARP_RESOLVING_LOCAL;
    }

    if (UserArp) {
        NewEntry->ate_userarp = 1;
    }

    NewEntry->ate_resolveonly = (ARPControlBlock *)UserArp;
    NewEntry->ate_valid = CTESystemUpTime();
    NewEntry->ate_useticks = ArpCacheLife;
    CTEInitLock(&NewEntry->ate_lock);

    // Entry does not exist. Insert the new entry into the table at the
    // appropriate spot.
    //
    NewEntry->ate_next = (*Interface->ai_ARPTbl)[i];
    (*Interface->ai_ARPTbl)[i] = NewEntry;
    Interface->ai_count++;
    CTEGetLockAtDPC(&NewEntry->ate_lock, Handle);
    CTEFreeLockFromDPC(&Interface->ai_ARPTblLock, *Handle);
    *Handle = TableHandle;
    return NewEntry;
}

//* ARPTransmit - Send a frame.
//
//  The main ARP transmit routine, called by the upper layer. This routine
//  takes as input a buf desc chain, RCE, and size. We validate the cached
//  information in the RCE. If it is valid, we use it to send the frame.
//  Otherwise we do a table lookup. If we find it in the table, we'll update
//  the RCE and continue. Otherwise we'll queue the packet and start an ARP
//  resolution.
//
//  Entry:  Context     - A pointer to the AI structure.
//          Packet      - A pointer to the BufDesc chain to be sent.
//          Destination - IP address of destination we're trying to reach,
//          RCE         - A pointer to an RCE which may have cached information.
//
//  Returns: Status of the transmit - success, an error, or pending.
//
NDIS_STATUS
__stdcall
ARPTransmit(void *Context, PNDIS_PACKET * PacketArray, uint NumberOfPackets,
            IPAddr Destination, RouteCacheEntry * RCE, void *LinkCtxt)
{
    ARPInterface *ai = (ARPInterface *) Context;    // Set up as AI pointer.
    ARPContext *ac;                     // ARP context pointer.
    ARPTableEntry *entry;               // Pointer to ARP tbl. entry
    CTELockHandle lhandle;              // Lock handle
    CTELockHandle tlhandle;             // Lock handle for ARP table.
    NDIS_STATUS Status;
    PNDIS_PACKET Packet = *PacketArray;

    //
    // For now, we get only one packet...
    //
    ASSERT(NumberOfPackets == 1);

    DEBUGMSG(DBG_TRACE && DBG_ARP && DBG_TX,
             (DTEXT("+ARPTransmit(%x, %x, %d, %x, %x, %x)\n"),
              Context, PacketArray, NumberOfPackets,
              Destination, RCE, LinkCtxt));

    if (ai->ai_state != INTERFACE_UP) {
        return NDIS_STATUS_ADAPTER_NOT_READY;
    }

    CTEGetLock(&ai->ai_ARPTblLock, &tlhandle);
    if (RCE != (RouteCacheEntry *) NULL) {    // Have a valid RCE.

        ac = (ARPContext *) RCE->rce_context;    // Get pointer to context

        entry = ac->ac_ate;
        if (entry != (ARPTableEntry *) NULL) {    // Have a valid ATE.

            CTEGetLockAtDPC(&entry->ate_lock, &lhandle);    // Lock this structure

            if (IP_ADDR_EQUAL(entry->ate_dest, Destination)) {
                uint refresh,status;
                uchar state = entry->ate_state;

                refresh= entry->ate_refresh;

                CTEFreeLockFromDPC(&ai->ai_ARPTblLock, lhandle);
                status = ARPSendData(ai, Packet, entry, tlhandle);    // Send the data
                if (refresh) {
                    SendARPRequest(ai, Destination, state, NULL, TRUE);
                }
                return status;
            }

            // We have an RCE that identifies the wrong ATE. We'll free it from
            // this list and try and find an ATE that is valid.
            ARPRemoveRCE(entry, RCE);
            CTEFreeLockFromDPC(&entry->ate_lock, lhandle);
            // Fall through to 'no valid entry' code.
        }
    }

    // Here we have no valid ATE, either because the RCE is NULL or the ATE
    // specified by the RCE was invalid. We'll try and find one in the table. If
    // we find one, we'll fill in this RCE and send the packet. Otherwise we'll
    // try to create one. At this point we hold the lock on the ARP table.

    if ((entry = ARPLookup(ai, Destination, &lhandle)) != (ARPTableEntry *) NULL) {
        // Found a matching entry. ARPLookup returns with the ATE lock held.
        if (RCE != (RouteCacheEntry *) NULL) {
            ac->ac_next = entry->ate_rce;    // Fill in context for next time.
            entry->ate_rce = RCE;
            ac->ac_ate = entry;
        }

        DEBUGMSG(DBG_INFO && DBG_ARP && DBG_TX,
                 (DTEXT("ARPTx: ATE %x - calling ARPSendData\n"), entry));

        CTEFreeLockFromDPC(&ai->ai_ARPTblLock, lhandle);
        return ARPSendData(ai, Packet, entry, tlhandle);
    }

    // No valid entry in the ARP table. First we'll see if we're sending to a
    // broadcast address or multicast address. If not, we'll try to create
    // an entry in the table and get an ARP resolution going. ARPLookup returns
    // with the table lock held when it fails, we'll free it here.
    CTEFreeLock(&ai->ai_ARPTblLock, tlhandle);

    if (ARPSendBCast(ai, Destination, Packet, &Status)) {
        return Status;
    }

    entry = CreateARPTableEntry(ai, Destination, &lhandle, 0);
    if (entry != NULL) {
        if (entry->ate_state <= ARP_RESOLVING) {    // Newly created entry.

            uchar state = entry->ate_state;

            DEBUGMSG(DBG_INFO && DBG_ARP && DBG_TX,
                     (DTEXT("ARPTx: Created ATE %x\n"), entry));

            // Someone else could have raced in and created the entry between
            // the time we free the lock and the time we called
            // CreateARPTableEntry(). We check this by looking at the packet
            // on the entry. If there is no old packet we'll ARP. If there is,
            // we'll call ARPSendData to figure out what to do.

            if (entry->ate_packet == NULL) {
                entry->ate_packet = Packet;

                DEBUGMSG(DBG_INFO && DBG_ARP && DBG_TX,
                         (DTEXT("ARPTx: ATE %x - calling SendARPRequest\n"), entry));

                CTEFreeLock(&entry->ate_lock, lhandle);
                SendARPRequest(ai, Destination, state, NULL, TRUE);
                // We don't know the state of the entry - we've freed the lock
                // and yielded, and it could conceivably have timed out by now,
                // or SendARPRequest could have failed, etc. We could take the
                // lock, check the status from SendARPRequest, see if it's
                // still the same packet, and then make a decision on the
                // return value, but it's easiest just to return pending. If
                // SendARPRequest failed, the entry will time out anyway.
                return NDIS_STATUS_PENDING;
            } else {
                return ARPSendData(ai, Packet, entry, lhandle);
            }
        } else if (entry->ate_state == ARP_GOOD) {   // Yow! A valid entry.
            return ARPSendData(ai, Packet, entry, lhandle);
        } else {                        // An invalid entry!
            CTEFreeLock(&entry->ate_lock, lhandle);
            return NDIS_STATUS_RESOURCES;
        }
    } else {                            // Couldn't create an entry.
        DEBUGMSG(DBG_ERROR && DBG_ARP,
                 (DTEXT("ARPTx: Failed to create ATE.\n")));
        return NDIS_STATUS_RESOURCES;
    }
}

//* RemoveARPTableEntry - Delete an entry from the ARP table.
//
//  This is a simple utility function to delete an entry from the ATP table. We
//  assume locks are held on both the table and the entry.
//
//  Entry:  Previous    - The entry immediately before the one to be deleted.
//          Entry       - The entry to be deleted.
//
//  Returns: Nothing.
//
void
RemoveARPTableEntry(ARPTableEntry * Previous, ARPTableEntry * Entry)
{
    RouteCacheEntry *RCE;               // Pointer to route cache entry
    ARPContext *AC;

    RCE = Entry->ate_rce;
    // Loop through and invalidate all RCEs on this ATE.
    while (RCE != (RouteCacheEntry *) NULL) {
        AC = (ARPContext *) RCE->rce_context;
        AC->ac_ate = (ARPTableEntry *) NULL;
        RCE = AC->ac_next;
    }

    // Splice this guy out of the list.
    Previous->ate_next = Entry->ate_next;
}

//* ARPFlushATE - removes ARP Table entry for given dest address
//
//  Called by IP layer when it needs to flush the link layer address from arp
//  cache
//  Entry:  Interface   - A pointer to the AI structure.
//          Destination - Destination Address whose Xlation needs to be removed
//
//  Returns: TRUE if the entry was found and flushed, FALSE otherwise
//

BOOLEAN
ARPFlushATE(void *Context, IPAddr Address)
{
    ARPInterface *ai = (ARPInterface *) Context;
    ARPTableEntry *entry;
    CTELockHandle lhandle, tlhandle;
    ARPTable *Table;
    ARPTableEntry *Current, *Previous;
    int i = ARP_HASH(Address);
    PNDIS_PACKET OldPacket = NULL;

    CTEGetLock(&ai->ai_ARPTblLock, &tlhandle);
    Table = ai->ai_ARPTbl;

    Current = (*Table)[i];
    Previous = (ARPTableEntry *) ((uchar *) & ((*Table)[i]) - offsetof(struct ARPTableEntry, ate_next));

    while (Current != (ARPTableEntry *) NULL) {
        CTEGetLock(&Current->ate_lock, &lhandle);
        if (IP_ADDR_EQUAL(Current->ate_dest, Address)) {    // Found a match.

            if (Current->ate_resolveonly) {
                ARPControlBlock *ArpContB, *TmpArpContB;

                ArpContB = Current->ate_resolveonly;

                while (ArpContB) {
                    ArpRtn rtn;
                    rtn = (ArpRtn) ArpContB->CompletionRtn;
                    ArpContB->status = STATUS_UNSUCCESSFUL;
                    TmpArpContB = ArpContB->next;
                    (*rtn) (ArpContB, STATUS_UNSUCCESSFUL);
                    ArpContB = TmpArpContB;
                }

                Current->ate_resolveonly = NULL;
            }

            RemoveARPTableEntry(Previous, Current);

            CTEFreeLock(&Current->ate_lock, lhandle);

            OldPacket = Current->ate_packet;

            CTEFreeLock(&ai->ai_ARPTblLock, tlhandle);

            if (OldPacket) {
                IPSendComplete(ai->ai_context, OldPacket, NDIS_STATUS_SUCCESS);
            }
            CTEFreeMem(Current);
            return TRUE;
        }
        CTEFreeLock(&Current->ate_lock, lhandle);
        Previous = Current;
        Current = Current->ate_next;
    }

    CTEFreeLock(&ai->ai_ARPTblLock, tlhandle);
    return FALSE;

}

//* ARPFlushAllATE - removes all ARP Table entries.
//
//  Entry:  Interface   - A pointer to the AI structure.
//
//  Returns: None
//

void
ARPFlushAllATE(void *Context)
{
    ARPInterface *ai = (ARPInterface *) Context;
    CTELockHandle tlhandle;
    ARPTable *Table;
    int i;
    ARPTableEntry *ATE;
    PNDIS_PACKET PList = (PNDIS_PACKET) NULL;

    CTEGetLock(&ai->ai_ARPTblLock, &tlhandle);
    Table = ai->ai_ARPTbl;

    if (Table != NULL) {
        for (i = 0; i < ARP_TABLE_SIZE; i++) {
            while ((*Table)[i] != NULL) {
                ATE = (*Table)[i];
                if (ATE->ate_resolveonly) {
                    ARPControlBlock *ArpContB, *TmpArpContB;

                    ArpContB = ATE->ate_resolveonly;

                    while (ArpContB) {
                        ArpRtn rtn;
                        rtn = (ArpRtn) ArpContB->CompletionRtn;
                        ArpContB->status = STATUS_UNSUCCESSFUL;
                        TmpArpContB = ArpContB->next;
                        (*rtn) (ArpContB, STATUS_UNSUCCESSFUL);
                        ArpContB = TmpArpContB;
                    }

                    ATE->ate_resolveonly = NULL;

                }
                RemoveARPTableEntry(STRUCT_OF(ARPTableEntry, &((*Table)[i]), ate_next),
                                    ATE);

                if (ATE->ate_packet) {
                    ((PacketContext *) ATE->ate_packet->ProtocolReserved)->pc_common.pc_link = PList;
                    PList = ATE->ate_packet;
                }
                CTEFreeMem(ATE);
            }
        }
    }
    CTEFreeLock(&ai->ai_ARPTblLock, tlhandle);

    while (PList != (PNDIS_PACKET) NULL) {
        PNDIS_PACKET Packet = PList;

        PList = ((PacketContext *) Packet->ProtocolReserved)->pc_common.pc_link;
        IPSendComplete(ai->ai_context, Packet, NDIS_STATUS_SUCCESS);
    }

}

//* ARPXferData - Transfer data on behalf on an upper later protocol.
//
//  This routine is called by the upper layer when it needs to transfer data
//  from an NDIS driver. We just map his call down.
//
//  Entry:  Context     - Context value we gave to IP (really a pointer to an AI).
//          MACContext  - Context value MAC gave us on a receive.
//          MyOffset    - Packet offset we gave to the protocol earlier.
//          ByteOffset  - Byte offset into packet protocol wants transferred.
//          BytesWanted - Number of bytes to transfer.
//          Packet      - Pointer to packet to be used for transferring.
//          Transferred - Pointer to where to return bytes transferred.
//
//  Returns: NDIS_STATUS of command.
//
NDIS_STATUS
__stdcall
ARPXferData(void *Context, NDIS_HANDLE MACContext, uint MyOffset,
            uint ByteOffset, uint BytesWanted, PNDIS_PACKET Packet, uint * Transferred)
{
    ARPInterface *Interface = (ARPInterface *) Context;
    NDIS_STATUS Status;

    NdisTransferData(&Status, Interface->ai_handle, MACContext, ByteOffset + MyOffset,
                     BytesWanted, Packet, Transferred);

    return Status;
}

//* ARPClose - Close an adapter.
//
//  Called by IP when it wants to close an adapter, presumably due to an error condition.
//  We'll close the adapter, but we won't free any memory.
//
//  Entry:  Context     - Context value we gave him earlier.
//
//  Returns: Nothing.
//
void
__stdcall
ARPClose(void *Context)
{
    ARPInterface *Interface = (ARPInterface *) Context;
    NDIS_STATUS Status;
    CTELockHandle LockHandle;
    NDIS_HANDLE Handle;

    Interface->ai_operstate = IF_OPER_STATUS_NON_OPERATIONAL;
    Interface->ai_lastchange = GetTimeTicks();
    Interface->ai_state = INTERFACE_DOWN;
    CTEInitBlockStruc(&Interface->ai_block);

    CTEGetLock(&Interface->ai_lock, &LockHandle);
    if (Interface->ai_handle != (NDIS_HANDLE) NULL) {
        Handle = Interface->ai_handle;
        CTEFreeLock(&Interface->ai_lock, LockHandle);

        NdisCloseAdapter(&Status, Handle);

        if (Status == NDIS_STATUS_PENDING) {
            Status = CTEBlock(&Interface->ai_block);
        }
        Interface->ai_handle = NULL;
    } else {
        CTEFreeLock(&Interface->ai_lock, LockHandle);
    }
}

//* ARPInvalidate - Notification that an RCE is invalid.
//
//  Called by IP when an RCE is closed or otherwise invalidated. We look up
//  the ATE for the specified RCE, and then remove the RCE from the ATE list.
//
//  Entry:  Context     - Context value we gave him earlier.
//          RCE         - RCE to be invalidated
//
//  Returns: Nothing.
//
void
__stdcall
ARPInvalidate(void *Context, RouteCacheEntry *RCE)
{
    ARPInterface *Interface = (ARPInterface *) Context;
    ARPTableEntry *ATE;
    CTELockHandle Handle, ATEHandle;
    ARPContext *AC = (ARPContext *) RCE->rce_context;

    CTEGetLock(&Interface->ai_ARPTblLock, &Handle);

#if DBG
    if (!(RCE->rce_flags & RCE_CONNECTED)) {

        ARPTableEntry *tmpATE;

        ATE = ARPLookup(Interface, RCE->rce_dest, &ATEHandle);

        if (ATE != NULL) {
            tmpATE = ATE;
            while (ATE) {
                if (ATE->ate_rce == RCE) {
                    DbgBreakPoint();
                }
                ATE = ATE->ate_next;
            }
            CTEFreeLockFromDPC(&Interface->ai_ARPTblLock, ATEHandle);
            CTEFreeLock(&tmpATE->ate_lock, Handle);

            return;
        }
    }
#endif

    if ((ATE = AC->ac_ate) == (ARPTableEntry *) NULL) {
        CTEFreeLock(&Interface->ai_ARPTblLock, Handle);    // No matching ATE.

        return;
    }
    CTEGetLockAtDPC(&ATE->ate_lock, &ATEHandle);
    ARPRemoveRCE(ATE, RCE);
    RtlZeroMemory(RCE->rce_context, RCE_CONTEXT_SIZE);
    CTEFreeLockFromDPC(&Interface->ai_ARPTblLock, ATEHandle);
    CTEFreeLock(&ATE->ate_lock, Handle);
}

//*     ARPSetMCastList - Set the multicast address list for the adapter.
//
//      Called to try and set the multicast reception list for the adapter.
//      We allocate a buffer big enough to hold the new address list, and format
//      the address list into the buffer. Then we submit the NDIS request to set
//      the list. If we can't set the list because the multicast address list is
//      full we'll put the card into all multicast mode.
//
//      Input:  Interface               - Interface on which to set list.
//
//      Returns: NDIS_STATUS of attempt.
//
NDIS_STATUS
ARPSetMCastList(ARPInterface * Interface)
{
    CTELockHandle Handle;
    uchar *MCastBuffer, *CurrentPtr;
    uint MCastSize;
    NDIS_STATUS Status;
    uint i;
    ARPMCastAddr *AddrPtr;
    IPAddr UNALIGNED *Temp;

    CTEGetLock(&Interface->ai_lock, &Handle);
    MCastSize = Interface->ai_mcastcnt * ARP_802_ADDR_LENGTH;
    if (MCastSize != 0)
        MCastBuffer = CTEAllocMemN(MCastSize, 'RiCT');
    else
        MCastBuffer = NULL;

    if (MCastBuffer != NULL || MCastSize == 0) {
        // Got the buffer. Loop through, building the list.
        AddrPtr = Interface->ai_mcast;

        CurrentPtr = MCastBuffer;

        for (i = 0; i < Interface->ai_mcastcnt; i++) {
            ASSERT(AddrPtr != NULL);

            if (Interface->ai_media == NdisMedium802_3) {

                RtlCopyMemory(CurrentPtr, ENetMcst, ARP_802_ADDR_LENGTH);
                Temp = (IPAddr UNALIGNED *) (CurrentPtr + 2);
                *Temp |= AddrPtr->ama_addr;
            } else if ((Interface->ai_media == NdisMedium802_5) & TRFunctionalMcast) {
                RtlCopyMemory(CurrentPtr, TRNetMcst, ARP_802_ADDR_LENGTH - 2);
                MCastSize = 4;
            } else if (Interface->ai_media == NdisMediumFddi) {
                RtlCopyMemory(CurrentPtr, ((FDDIHeader *) FDDIMcst)->fh_daddr,
                           ARP_802_ADDR_LENGTH);
                Temp = (IPAddr UNALIGNED *) (CurrentPtr + 2);
                *Temp |= AddrPtr->ama_addr;
            } else
                ASSERT(0);

            CurrentPtr += ARP_802_ADDR_LENGTH;
            AddrPtr = AddrPtr->ama_next;
        }

        CTEFreeLock(&Interface->ai_lock, Handle);

        // We're built the list. Now give it to the driver to handle.
        if (Interface->ai_media == NdisMedium802_3) {
            Status = DoNDISRequest(Interface, NdisRequestSetInformation,
                                   OID_802_3_MULTICAST_LIST, MCastBuffer, MCastSize, NULL, TRUE);
        } else if ((Interface->ai_media == NdisMedium802_5) & TRFunctionalMcast) {
            if (!(Interface->ai_pfilter & NDIS_PACKET_TYPE_FUNCTIONAL)) {
                Interface->ai_pfilter |= NDIS_PACKET_TYPE_FUNCTIONAL;
                Status = DoNDISRequest(Interface, NdisRequestSetInformation,
                                       OID_GEN_CURRENT_PACKET_FILTER,
                                       &Interface->ai_pfilter,
                                       sizeof(uint), NULL, TRUE);
            }
            Status = DoNDISRequest(Interface, NdisRequestSetInformation,
                                   OID_802_5_CURRENT_FUNCTIONAL, MCastBuffer, MCastSize, NULL,
                                   TRUE);

            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                      "SetMcast after OID-- TR mcast address on %x status %x\n",
                      Interface, Status));

        } else if (Interface->ai_media == NdisMediumFddi) {
            Status = DoNDISRequest(Interface, NdisRequestSetInformation,
                                   OID_FDDI_LONG_MULTICAST_LIST, MCastBuffer, MCastSize, NULL,
                                   TRUE);
        } else
            ASSERT(0);

        if (MCastBuffer != NULL) {
            CTEFreeMem(MCastBuffer);
        }
        if (Status == NDIS_STATUS_MULTICAST_FULL) {
            // Multicast list is full. Try to set the filter to all multicasts.
            Interface->ai_pfilter |= NDIS_PACKET_TYPE_ALL_MULTICAST;

            Status = DoNDISRequest(Interface, NdisRequestSetInformation,
                                   OID_GEN_CURRENT_PACKET_FILTER, &Interface->ai_pfilter,
                                   sizeof(uint), NULL, TRUE);
        }
    } else {
        CTEFreeLock(&Interface->ai_lock, Handle);
        Status = NDIS_STATUS_RESOURCES;
    }

    return Status;

}

//*     ARPFindMCast - Find a multicast address structure on our list.
//
//      Called as a utility to find a multicast address structure. If we find
//      it, we return a pointer to it and it's predecessor. Otherwise we return
//      NULL. We assume the caller holds the lock on the interface already.
//
//      Input:  Interface               - Interface to search.
//              Addr                    - Addr to find.
//              Prev                    - Where to return previous pointer.
//
//      Returns: Pointer if we find one, NULL otherwise.
//
ARPMCastAddr *
ARPFindMCast(ARPInterface * Interface, IPAddr Addr, ARPMCastAddr ** Prev)
{
    ARPMCastAddr *AddrPtr, *PrevPtr;

    PrevPtr = STRUCT_OF(ARPMCastAddr, &Interface->ai_mcast, ama_next);
    AddrPtr = PrevPtr->ama_next;
    while (AddrPtr != NULL) {
        if (IP_ADDR_EQUAL(AddrPtr->ama_addr, Addr))
            break;
        else {
            PrevPtr = AddrPtr;
            AddrPtr = PrevPtr->ama_next;
        }
    }

    *Prev = PrevPtr;
    return AddrPtr;
}

//*     ARPDelMCast - Delete a multicast address.
//
//      Called when we want to delete a multicast address. We look for a matching
//      (masked) address. If we find one, we'll dec. the reference count and if
//      it goes to 0 we'll pull him from the list and reset the multicast list.
//
//      Input:  Interface                       - Interface on which to act.
//                      Addr                            - Address to be deleted.
//
//      Returns: TRUE if it worked, FALSE otherwise.
//
uint
ARPDelMCast(ARPInterface * Interface, IPAddr Addr)
{
    ARPMCastAddr *AddrPtr, *PrevPtr;
    CTELockHandle Handle;
    uint Status = TRUE;

    // When we support TR (RFC 1469) fully we'll need to change this.
    if (Interface->ai_media == NdisMedium802_3 ||
        Interface->ai_media == NdisMediumFddi ||
        (Interface->ai_media == NdisMedium802_5 && TRFunctionalMcast)) {
        // This is an interface that supports mcast addresses.
        Addr &= ARP_MCAST_MASK;

        CTEGetLock(&Interface->ai_lock, &Handle);
        AddrPtr = ARPFindMCast(Interface, Addr, &PrevPtr);
        if (AddrPtr != NULL) {
            // We found one. Dec. his refcnt, and if it's 0 delete him.
            (AddrPtr->ama_refcnt)--;
            if (AddrPtr->ama_refcnt == 0) {
                // He's done.
                PrevPtr->ama_next = AddrPtr->ama_next;
                (Interface->ai_mcastcnt)--;
                CTEFreeLock(&Interface->ai_lock, Handle);
                CTEFreeMem(AddrPtr);
                ARPSetMCastList(Interface);
                CTEGetLock(&Interface->ai_lock, &Handle);
            }
        } else
            Status = FALSE;

        CTEFreeLock(&Interface->ai_lock, Handle);
    }

    return Status;
}
//*     ARPAddMCast - Add a multicast address.
//
//      Called when we want to start receiving a multicast address. We'll mask
//      the address and look it up in our address list. If we find it, we'll just
//      bump the reference count. Otherwise we'll try to create one and put him
//      on the list. In that case we'll need to set the multicast address list for
//      the adapter.
//
//      Input:  Interface               - Interface to set on.
//              Addr                    - Address to set.
//
//      Returns: TRUE if we succeed, FALSE if we fail.
//
uint
ARPAddMCast(ARPInterface * Interface, IPAddr Addr)
{
    ARPMCastAddr *AddrPtr, *PrevPtr;
    CTELockHandle Handle;
    uint Status = TRUE;

    if (Interface->ai_state != INTERFACE_UP)
        return FALSE;

    // Currently we don't do anything with token ring, since we send
    // all mcasts as TR broadcasts. When we comply with RFC 1469 we'll need to
    // fix this.
    if ((Interface->ai_media == NdisMedium802_3) ||
        (Interface->ai_media == NdisMediumFddi) ||
        ((Interface->ai_media == NdisMedium802_5) && TRFunctionalMcast)) {

        Addr &= ARP_MCAST_MASK;

        CTEGetLock(&Interface->ai_lock, &Handle);
        AddrPtr = ARPFindMCast(Interface, Addr, &PrevPtr);
        if (AddrPtr != NULL) {
            // We found one, just bump refcnt.
            (AddrPtr->ama_refcnt)++;
        } else {
            // Didn't find one. Allocate space for one, link him in, and
            // try to set the list.
            AddrPtr = CTEAllocMemN(sizeof(ARPMCastAddr), 'SiCT');
            if (AddrPtr != NULL) {
                // Got one. Link him in.
                AddrPtr->ama_addr = Addr;
                AddrPtr->ama_refcnt = 1;
                AddrPtr->ama_next = Interface->ai_mcast;
                Interface->ai_mcast = AddrPtr;
                (Interface->ai_mcastcnt)++;
                CTEFreeLock(&Interface->ai_lock, Handle);

                // Now try to set the list.
                if (ARPSetMCastList(Interface) != NDIS_STATUS_SUCCESS) {
                    // Couldn't set the list. Call the delete routine to delete
                    // the address we just tried to set.
                    Status = ARPDelMCast(Interface, Addr);
                    ASSERT(Status);
                    Status = FALSE;
                }
                CTEGetLock(&Interface->ai_lock, &Handle);
            } else
                Status = FALSE;         // Couldn't get memory.

        }

        // We've done out best. Free the lock and return.
        CTEFreeLock(&Interface->ai_lock, Handle);
    }
    return Status;
}

//* ARPAddAddr - Add an address to the ARP table.
//
//  This routine is called by IP to add an address as a local address, or
//      or specify the broadcast address for this interface.
//
//  Entry:  Context  - Context we gave IP earlier (really an ARPInterface ptr)
//          Type        - Type of address (local, p-arp, multicast, or
//                                                      broadcast).
//          Address     - Broadcast IP address to be added.
//                      Mask            - Mask for address.
//
//  Returns: 0 if we failed, non-zero otherwise
//
uint
__stdcall
ARPAddAddr(void *Context, uint Type, IPAddr Address, IPMask Mask, void *Context2)
{
    ARPInterface *Interface = (ARPInterface *) Context;
    CTELockHandle Handle;

    if (Type != LLIP_ADDR_LOCAL && Type != LLIP_ADDR_PARP) {
        // Not a local address, must be broadcast or multicast.

        if (Type == LLIP_ADDR_BCAST) {
            Interface->ai_bcast = Address;
            return TRUE;
        } else if (Type == LLIP_ADDR_MCAST) {
            return ARPAddMCast(Interface, Address);
        } else
            return FALSE;
    } else {                            // This is a local address.

        CTEGetLock(&Interface->ai_lock, &Handle);
        if (Type != LLIP_ADDR_PARP) {
            uint RetStatus = FALSE;
            uint ArpForSelf = FALSE;

            if (IP_ADDR_EQUAL(Interface->ai_ipaddr.aia_addr, 0)) {
                Interface->ai_ipaddr.aia_addr = Address;
                Interface->ai_ipaddr.aia_mask = Mask;
                Interface->ai_ipaddr.aia_age = ArpRetryCount;
                if (Interface->ai_state == INTERFACE_UP) {
                    // When ArpRetryCount is 0, we'll return immediately
                    // below, so don't save completion context
                    Interface->ai_ipaddr.aia_context = (ArpRetryCount > 0)?
                        Context2 : NULL;
                    ArpForSelf = TRUE;
                } else {
                    Interface->ai_ipaddr.aia_context = NULL;
                }
                RetStatus = TRUE;
            } else {
                ARPIPAddr *NewAddr;

                NewAddr = CTEAllocMemNBoot(sizeof(ARPIPAddr), 'TiCT');
                if (NewAddr != (ARPIPAddr *) NULL) {
                    NewAddr->aia_addr = Address;
                    NewAddr->aia_mask = Mask;
                    NewAddr->aia_age = ArpRetryCount;
                    NewAddr->aia_next = Interface->ai_ipaddr.aia_next;
                    if (Interface->ai_state == INTERFACE_UP) {
                        // When ArpRetryCount is 0, we'll return immediately
                        // below, so don't save completion context
                        NewAddr->aia_context = (ArpRetryCount > 0)?
                            Context2 : NULL;
                        ArpForSelf = TRUE;
                    } else {
                        NewAddr->aia_context = NULL;
                    }

                    Interface->ai_ipaddr.aia_next = NewAddr;
                    RetStatus = TRUE;
                }
            }

            if (RetStatus) {
                Interface->ai_ipaddrcnt++;
                if (Interface->ai_telladdrchng) {
                    CTEFreeLock(&Interface->ai_lock, Handle);
                    AddrNotifyLink(Interface);
                } else {
                    CTEFreeLock(&Interface->ai_lock, Handle);
                }

            } else {
                CTEFreeLock(&Interface->ai_lock, Handle);
            }

            // add wakeup pattern for this address, if the address is in
            // conflict ip will turn around and delete the address thus
            // deleting the wakeup pattern.

            ARPWakeupPattern(Interface, Address, TRUE);

            // ARP for the address we've added, to see it it already exists.
            if (RetStatus == TRUE && ArpForSelf == TRUE) {
                if (ArpRetryCount) {

                    SendARPRequest(Interface, Address, ARP_RESOLVING_GLOBAL,
                                   NULL, TRUE);
                    return IP_PENDING;
                } else {
                    return TRUE;
                }
            }
            return RetStatus;
        } else if (Type == LLIP_ADDR_PARP) {
            ARPPArpAddr *NewPArp, *TmpPArp;

            // He's adding a proxy arp address.
            // Don't allow to add duplicate proxy arp entries
            TmpPArp = Interface->ai_parpaddr;
            while (TmpPArp) {
                if (IP_ADDR_EQUAL(TmpPArp->apa_addr, Address) && IP_ADDR_EQUAL(TmpPArp->apa_mask, Mask)) {
                    CTEFreeLock(&Interface->ai_lock, Handle);
                    return FALSE;
                }
                TmpPArp = TmpPArp->apa_next;
            }

            NewPArp = CTEAllocMemN(sizeof(ARPPArpAddr), 'UiCT');
            if (NewPArp != NULL) {
                NewPArp->apa_addr = Address;
                NewPArp->apa_mask = Mask;
                NewPArp->apa_next = Interface->ai_parpaddr;
                Interface->ai_parpaddr = NewPArp;
                Interface->ai_parpcount++;
                CTEFreeLock(&Interface->ai_lock, Handle);

                return TRUE;
            }
            CTEFreeLock(&Interface->ai_lock, Handle);

        }
        return FALSE;
    }

}

//* ARPDeleteAddr - Delete a local or proxy address.
//
//      Called to delete a local or proxy address.
//
//  Entry:  Context    - An ARPInterface pointer.
//          Type       - Type of address (local or p-arp).
//          Address    - IP address to be deleted.
//          Mask       - Mask for address. Used only for deleting proxy-ARP
//                                                      entries.
//
//  Returns: 0 if we failed, non-zero otherwise
//
uint
__stdcall
ARPDeleteAddr(void *Context, uint Type, IPAddr Address, IPMask Mask)
{
    ARPInterface *Interface = (ARPInterface *) Context;
    CTELockHandle Handle;
    ARPIPAddr *DelAddr, *PrevAddr;
    ARPPArpAddr *DelPAddr, *PrevPAddr;

    if (Type == LLIP_ADDR_LOCAL) {

        CTEGetLock(&Interface->ai_lock, &Handle);

        if (IP_ADDR_EQUAL(Interface->ai_ipaddr.aia_addr, Address)) {

            SetAddrControl *SAC;
            AddAddrNotifyEvent *DelayedEvent;
            IPAddr IpAddress;
            ARPIPAddr *Addr;

            Addr = &Interface->ai_ipaddr;
            IpAddress = Addr->aia_addr;

            Interface->ai_ipaddr.aia_addr = NULL_IP_ADDR;
            Interface->ai_ipaddrcnt--;
            if (Interface->ai_telladdrchng) {
                CTEFreeLock(&Interface->ai_lock, Handle);
                AddrNotifyLink(Interface);
                CTEGetLock(&Interface->ai_lock, &Handle);
            }
            // if the address is deleted before the add completes, complete the add here
            // Doing this will complete the irp and also decrements the refcount on the interface

            if (Addr->aia_context != NULL) {
                SAC = (SetAddrControl *) Addr->aia_context;
                Addr->aia_context = NULL;
                CTEFreeLock(&Interface->ai_lock, Handle);

                // We cannot call completion routine at timer DPC
                // because completion routine will need to notify
                // TDI clients and that could take long time.
                DelayedEvent = CTEAllocMemNBoot(sizeof(AddAddrNotifyEvent), 'ViCT');
                if (DelayedEvent) {
                    DelayedEvent->SAC = SAC;
                    DelayedEvent->Address = IpAddress;
                    DelayedEvent->Status = IP_SUCCESS;
                    CTEInitEvent(&DelayedEvent->Event, CompleteIPSetNTEAddrRequestDelayed);
                    CTEScheduleDelayedEvent(&DelayedEvent->Event, DelayedEvent);
                } else {
                    ASSERT(FALSE);
                    return FALSE;
                }
            } else {
                CTEFreeLock(&Interface->ai_lock, Handle);
            }

            ARPWakeupPattern(Interface, Address, FALSE);

            return TRUE;
        } else {
            PrevAddr = STRUCT_OF(ARPIPAddr, &Interface->ai_ipaddr, aia_next);
            DelAddr = PrevAddr->aia_next;
            while (DelAddr != NULL)
                if (IP_ADDR_EQUAL(DelAddr->aia_addr, Address))
                    break;
                else {
                    PrevAddr = DelAddr;
                    DelAddr = DelAddr->aia_next;
                }

            if (DelAddr != NULL) {
                PrevAddr->aia_next = DelAddr->aia_next;
                CTEFreeMem(DelAddr);
                Interface->ai_ipaddrcnt--;

                if (Interface->ai_telladdrchng) {
                    CTEFreeLock(&Interface->ai_lock, Handle);
                    AddrNotifyLink(Interface);
                } else {
                    CTEFreeLock(&Interface->ai_lock, Handle);
                }
                ARPWakeupPattern(Interface, Address, FALSE);
            } else {
                CTEFreeLock(&Interface->ai_lock, Handle);
            }

            return(DelAddr != NULL);
        }

    } else if (Type == LLIP_ADDR_PARP) {
        CTEGetLock(&Interface->ai_lock, &Handle);
        PrevPAddr = STRUCT_OF(ARPPArpAddr, &Interface->ai_parpaddr, apa_next);
        DelPAddr = PrevPAddr->apa_next;
        while (DelPAddr != NULL)
            if (IP_ADDR_EQUAL(DelPAddr->apa_addr, Address) &&
                DelPAddr->apa_mask == Mask)
                break;
            else {
                PrevPAddr = DelPAddr;
                DelPAddr = DelPAddr->apa_next;
            }

        if (DelPAddr != NULL) {
            PrevPAddr->apa_next = DelPAddr->apa_next;
            Interface->ai_parpcount--;
            CTEFreeMem(DelPAddr);
        }
        CTEFreeLock(&Interface->ai_lock, Handle);
        return(DelPAddr != NULL);
    } else if (Type == LLIP_ADDR_MCAST)
        return ARPDelMCast(Interface, Address);
    else
        return FALSE;
}

//*AddrNotifyLink - Notify link layer of Network Address changes
//
//      Called when address are added/deleted on an interface
//
//  Entry: Interface - ARPinterface pointer
//
//  returns: NDIS_STATUS.Also sets ai_telladdrchng if status is failure
//  when this happens caller can check and see if next addr notification
//  need to be done or not.
//

NDIS_STATUS
AddrNotifyLink(ARPInterface * Interface)
{
    PNETWORK_ADDRESS_LIST AddressList;
    NETWORK_ADDRESS UNALIGNED *Address;
    int i = 0, size, count;
    ARPIPAddr *addrlist;
    NDIS_STATUS status = NDIS_STATUS_FAILURE;
    CTELockHandle Handle;

    CTEGetLock(&Interface->ai_lock, &Handle);

    size = Interface->ai_ipaddrcnt * (sizeof(NETWORK_ADDRESS_IP) +
                                      FIELD_OFFSET(NETWORK_ADDRESS, Address)) +
           FIELD_OFFSET(NETWORK_ADDRESS_LIST, Address);

    AddressList = CTEAllocMemN(size, 'WiCT');

    if (AddressList) {
        addrlist = &Interface->ai_ipaddr;
        count = Interface->ai_ipaddrcnt;

        AddressList->AddressType = NDIS_PROTOCOL_ID_TCP_IP;
        while (addrlist && count) {

            NETWORK_ADDRESS_IP UNALIGNED *tmpIPAddr;
            uchar *Address0;

            Address0 = (uchar *) & AddressList->Address[0];

            Address = (PNETWORK_ADDRESS) (Address0 + i * (FIELD_OFFSET(NETWORK_ADDRESS, Address) + sizeof(NETWORK_ADDRESS_IP)));

            tmpIPAddr = (PNETWORK_ADDRESS_IP) & Address->Address[0];

            Address->AddressLength = sizeof(NETWORK_ADDRESS_IP);
            Address->AddressType = NDIS_PROTOCOL_ID_TCP_IP;

            RtlCopyMemory(&tmpIPAddr->in_addr, &addrlist->aia_addr, sizeof(IPAddr));
            count--;
            addrlist = addrlist->aia_next;
            i++;

        }

        CTEFreeLock(&Interface->ai_lock, Handle);

        AddressList->AddressCount = i;
        status = DoNDISRequest(Interface,
                               NdisRequestSetInformation,
                               OID_GEN_NETWORK_LAYER_ADDRESSES,
                               AddressList,
                               size,
                               NULL, TRUE);
        if (status != NDIS_STATUS_SUCCESS) {
            CTEGetLock(&Interface->ai_lock, &Handle);
            Interface->ai_telladdrchng = 0;
            CTEFreeLock(&Interface->ai_lock, Handle);
        }
        CTEFreeMem(AddressList);

    } else {
        CTEFreeLock(&Interface->ai_lock, Handle);
        status = NDIS_STATUS_RESOURCES;
    }
    return status;
}


#if !MILLEN

//* ARPCancelPackets
//
//  Entry:  Context   - Pointer to the ARPInterface
//          ID        - Pattern that need to be passed down to ndis
//
//  Returns: Nothing
//

VOID
__stdcall
ARPCancelPackets(void *Context, void *ID)
{
    ARPInterface *Interface = (ARPInterface *) Context;

    NdisCancelSendPackets(Interface->ai_handle,ID);

}
#endif

//* DoWakeupPattern - Adds and removes wakeup pattern.
//
//  Entry:  Context   - Pointer to the ARPInterface
//          PtrnDesc    - Pattern buffer(s) of high level protocol
//          protoid     - the proto type used in ethernet or snap type fields.
//          AddPattern  - TRUE if pattern is to be added, FALSE if it is to be removed.
//
//  Returns: Nothing.
//
NDIS_STATUS
__stdcall
DoWakeupPattern(void *Context, PNET_PM_WAKEUP_PATTERN_DESC PtrnDesc, ushort protoid, BOOLEAN AddPattern)
{
    ARPInterface *Interface = (ARPInterface *) Context;
    uint PtrnLen;
    uint PtrnBufferLen;
    uint MaskLen;
    PNET_PM_WAKEUP_PATTERN_DESC CurPtrnDesc;
    uchar *NextMask, *NextPtrn;
    const uchar *MMask;
    uint MMaskLength;
    uchar NextMaskBit;
    uchar *Buffer;
    PNDIS_PM_PACKET_PATTERN PtrnBuffer;
    NDIS_STATUS Status;

    //
    //  First find the total length of the pattern.
    //  Pattern starts right at MacHeader.
    //

    //  First add the media portion of the header.
    //
    PtrnLen = Interface->ai_hdrsize + Interface->ai_snapsize;

    //  now add the high level proto pattern size.
    CurPtrnDesc = PtrnDesc;
    while (CurPtrnDesc != (PNET_PM_WAKEUP_PATTERN_DESC) NULL) {
        PtrnLen += CurPtrnDesc->PtrnLen;
        CurPtrnDesc = CurPtrnDesc->Next;
    }

    //  length of the mask: every byte of pattern requires
    //  one bit of the mask.
    MaskLen = GetWakeupPatternMaskLength(PtrnLen);


    //  total length of the pattern buffer to be given to ndis.
    PtrnBufferLen = sizeof(NDIS_PM_PACKET_PATTERN) + PtrnLen + MaskLen;
    if ((Buffer = CTEAllocMemN(PtrnBufferLen, 'XiCT')) == (uchar *) NULL) {
        return NDIS_STATUS_RESOURCES;
    }
    RtlZeroMemory(Buffer, PtrnBufferLen);

    PtrnBuffer = (PNDIS_PM_PACKET_PATTERN) Buffer;
    PtrnBuffer->PatternSize = PtrnLen;
    NextMask = Buffer + sizeof(NDIS_PM_PACKET_PATTERN);
    NextPtrn = NextMask + MaskLen;
    PtrnBuffer->MaskSize = MaskLen;
    PtrnBuffer->PatternOffset =
    (ULONG) ((ULONG_PTR) NextPtrn - (ULONG_PTR) PtrnBuffer);

    // Figure out what type of media this is, and do the appropriate thing.
    switch (Interface->ai_media) {
    case NdisMedium802_3:
        if (Interface->ai_snapsize == 0) {
            ENetHeader UNALIGNED *Hdr = (ENetHeader UNALIGNED *) NextPtrn;
            Hdr->eh_type = net_short(protoid);
            MMask = ENetPtrnMsk;
        } else {
            MMask = ENetSNAPPtrnMsk;
        }

        break;
    case NdisMedium802_5:
        if (Interface->ai_snapsize == 0) {
            MMask = TRPtrnMsk;
        } else {
            MMask = TRSNAPPtrnMsk;
        }
        break;
    case NdisMediumFddi:
        if (Interface->ai_snapsize == 0) {
            MMask = FDDIPtrnMsk;
        } else {
            MMask = FDDISNAPPtrnMsk;
        }
        break;
    case NdisMediumArcnet878_2:
        MMask = ARCPtrnMsk;
        break;
    default:
        ASSERT(0);
        Interface->ai_outerrors++;
        CTEFreeMem(Buffer);
        return NDIS_STATUS_UNSUPPORTED_MEDIA;
    }

    NextPtrn += Interface->ai_hdrsize;

    // Copy in SNAP header, if any.
    if (Interface->ai_snapsize) {
        SNAPHeader UNALIGNED *SNAPPtr = (SNAPHeader UNALIGNED *) NextPtrn;

        RtlCopyMemory(SNAPPtr, ARPSNAP, Interface->ai_snapsize);
        SNAPPtr->sh_etype = net_short(protoid);
        NextPtrn += Interface->ai_snapsize;

    }
    //
    MMaskLength = (Interface->ai_snapsize + Interface->ai_hdrsize - 1) / 8 + 1;
    // copy the mask for media part
    RtlCopyMemory(NextMask, MMask, MMaskLength);

    NextMaskBit = (Interface->ai_hdrsize + Interface->ai_snapsize) % 8;
    NextMask = NextMask + (Interface->ai_hdrsize + Interface->ai_snapsize) / 8;

    //  copy the pattern and mask of high level proto.
    CurPtrnDesc = PtrnDesc;
    while (CurPtrnDesc) {
        uint CopyBits = CurPtrnDesc->PtrnLen;
        uchar *SrcMask = CurPtrnDesc->Mask;
        uchar SrcMaskBit = 0;
        RtlCopyMemory(NextPtrn, CurPtrnDesc->Ptrn, CurPtrnDesc->PtrnLen);
        NextPtrn += CurPtrnDesc->PtrnLen;
        while (CopyBits--) {
            *NextMask |= ((*SrcMask & (0x1 << SrcMaskBit)) ? (0x1 << NextMaskBit) : 0);
            if ((NextMaskBit = ((NextMaskBit + 1) % 8)) == 0) {
                NextMask++;
            }
            if ((SrcMaskBit = ((SrcMaskBit + 1) % 8)) == 0) {
                SrcMask++;
            }
        }
        CurPtrnDesc = CurPtrnDesc->Next;
    }

    //  now tell ndis to set or remove the pattern.
    Status = DoNDISRequest(
                          Interface,
                          NdisRequestSetInformation,
                          AddPattern ? OID_PNP_ADD_WAKE_UP_PATTERN : OID_PNP_REMOVE_WAKE_UP_PATTERN,
                          PtrnBuffer,
                          PtrnBufferLen,
                          NULL, TRUE);

    CTEFreeMem(Buffer);

    return Status;
}

//* ARPWakeupPattern - add or remove ARP wakeup pattern.
//
//  Entry:  Interface   - Pointer to the ARPInterface
//          Addr        - IPAddr for which we need to set ARP pattern filter.
//
//  Returns: Nothing.
//
NDIS_STATUS
ARPWakeupPattern(ARPInterface * Interface, IPAddr Addr, BOOLEAN AddPattern)
{
    PNET_PM_WAKEUP_PATTERN_DESC PtrnDesc;
    uint PtrnLen;
    uint MaskLen;
    const uchar *PtrnMask;
    NDIS_STATUS Status;

    //
    // create high level proto (ARP here) pattern descriptor.
    //

    // len of pattern.
    PtrnLen = sizeof(ARPHeader);

    // adjust for Arcnet.
    if (Interface->ai_media == NdisMediumArcnet878_2) {
        PtrnLen -= ARCNET_ARPHEADER_ADJUSTMENT;
        PtrnMask = ARCARPPtrnMsk;
    } else {
        PtrnMask = ARPPtrnMsk;
    }

    // masklen = 1 bit per every byte of pattern.
    MaskLen = GetWakeupPatternMaskLength(PtrnLen);

    if ((PtrnDesc = CTEAllocMemN(sizeof(NET_PM_WAKEUP_PATTERN_DESC) + PtrnLen + MaskLen, 'YiCT')) != (PNET_PM_WAKEUP_PATTERN_DESC) NULL) {
        ARPHeader UNALIGNED *Hdr;
        uchar *IPAddrPtr;

        RtlZeroMemory(PtrnDesc, sizeof(NET_PM_WAKEUP_PATTERN_DESC) + PtrnLen + MaskLen);

        // set the ptrn and mask pointers in the buffer.
        PtrnDesc->PtrnLen = (USHORT) PtrnLen;
        PtrnDesc->Ptrn = (uchar *) PtrnDesc + sizeof(NET_PM_WAKEUP_PATTERN_DESC);
        PtrnDesc->Mask = (uchar *) PtrnDesc + sizeof(NET_PM_WAKEUP_PATTERN_DESC) + PtrnLen;

        // we need to wakeup on ARP request for our IPAddr.
        // so set the opcode and dest ip addr fields of ARP.
        Hdr = (ARPHeader UNALIGNED *) PtrnDesc->Ptrn;
        Hdr->ah_opcode = net_short(ARP_REQUEST);

        IPAddrPtr = Hdr->ah_shaddr + Interface->ai_addrlen + sizeof(IPAddr) + Interface->ai_addrlen;
        *(IPAddr UNALIGNED *) IPAddrPtr = Addr;

        RtlCopyMemory(PtrnDesc->Mask, PtrnMask, MaskLen);

        // give it to ndis.
        Status = DoWakeupPattern(
                                Interface,
                                PtrnDesc,
                                ARP_ETYPE_ARP,
                                AddPattern);

        // free the ptrn desc.
        CTEFreeMem(PtrnDesc);

        //now add wakeup pattren for directed mac address
        {
            uint PtrnBufferLen;
            PNDIS_PM_PACKET_PATTERN PtrnBuffer;
            uchar *Buffer;

            PtrnLen = ARP_802_ADDR_LENGTH;    //eth dest address

            MaskLen = 1;                //1 byte, needs 6 bits, 1 bit/byte

            PtrnBufferLen = sizeof(NDIS_PM_PACKET_PATTERN) + PtrnLen + MaskLen;

            if (Buffer = CTEAllocMem(PtrnBufferLen)) {

                RtlZeroMemory(Buffer, PtrnBufferLen);
                PtrnBuffer = (PNDIS_PM_PACKET_PATTERN) Buffer;
                PtrnBuffer->PatternSize = PtrnLen;
                PtrnBuffer->MaskSize = MaskLen;
                PtrnBuffer->PatternOffset = sizeof(NDIS_PM_PACKET_PATTERN) + 1;

                *(Buffer + sizeof(NDIS_PM_PACKET_PATTERN)) = 0x3F;

                RtlCopyMemory(Buffer + sizeof(NDIS_PM_PACKET_PATTERN) + 1, Interface->ai_addr, ARP_802_ADDR_LENGTH);

                Status = DoNDISRequest(
                                      Interface,
                                      NdisRequestSetInformation,
                                      AddPattern ? OID_PNP_ADD_WAKE_UP_PATTERN : OID_PNP_REMOVE_WAKE_UP_PATTERN,
                                      PtrnBuffer,
                                      PtrnBufferLen,
                                      NULL, TRUE);

                CTEFreeMem(Buffer);
            }
        }

        return Status;
    }
    return IP_NO_RESOURCES;
}

//** CompleteIPSetNTEAddrRequestDelayed -
//
//  calls CompleteIPSetNTEAddrRequest on a delayed worker thread
//
//  Entry:
//      Context - pointer to the control block
//  Exit:
//      None.
//
void
CompleteIPSetNTEAddrRequestDelayed(CTEEvent * WorkerThreadEvent, PVOID Context)
{
    AddAddrNotifyEvent *DelayedEvent;
    SetAddrControl *SAC;
    SetAddrRtn Rtn;
    IPAddr Address;
    IP_STATUS Status;

    DelayedEvent = (AddAddrNotifyEvent *) Context;
    SAC = DelayedEvent->SAC;            // the client context block;

    Address = DelayedEvent->Address;    // The address for which SetNTEAddr was called for.

    Status = DelayedEvent->Status;

    // Free the worker thread event.
    CTEFreeMem(Context);

    IPAddAddrComplete(Address, SAC, Status);
}

#if FFP_SUPPORT

//* ARPReclaimRequestMem - Post processing upon request completion
//
//    Called upon completion of NDIS requests that originate at ARP
//
//    Input:    pRequestInfo    - Points to request IP sends ARP
//
//    Returns:  None
//
void
ARPReclaimRequestMem(PVOID pRequestInfo)
{
    // Decrement ref count, and reclaim memory if it drops to zero
    if (InterlockedDecrement(&((ReqInfoBlock *) pRequestInfo)->RequestRefs) == 0) {
        // TCPTRACE(("ARPReclaimRequestMem: Freeing mem at pReqInfo = %08X\n",
        //            pRequestInfo));
        CTEFreeMem(pRequestInfo);
    }
}

#endif // if FFP_SUPPORT

//* ARPTimeout - ARP timeout routine.
//
//  This is the timeout routine that is called periodically. We scan the ARP table, looking
//  for invalid entries that can be removed.
//
//  Entry:  Timer   - Pointer to the timer that just fired.
//          Context - Pointer to the interface to be timed out.
//
//  Returns: Nothing.
//
void
ARPTimeout(CTEEvent * Timer, void *Context)
{
    ARPInterface *Interface = (ARPInterface *) Context;    // Our interface.
    ARPTable *Table;
    ARPTableEntry *Current, *Previous;
    int i;                              // Index variable.
    ulong Now = CTESystemUpTime(), ValidTime;
    CTELockHandle tblhandle, entryhandle;
    uchar Deleted;
    PNDIS_PACKET PList = (PNDIS_PACKET) NULL;
    ARPIPAddr *Addr;

    // Walk down the list of addresses, decrementing the age.
    CTEGetLock(&Interface->ai_lock, &tblhandle);

    if (Interface->ai_conflict && !(--Interface->ai_delay)) {
        ARPNotifyStruct *NotifyStruct = Interface->ai_conflict;
        CTEScheduleDelayedEvent(&NotifyStruct->ans_event, NotifyStruct);
        Interface->ai_conflict = NULL;
    }

    Addr = &Interface->ai_ipaddr;

    do {
        if (Addr->aia_age != ARPADDR_OLD_LOCAL) {
            (Addr->aia_age)--;
            if (Addr->aia_age == ARPADDR_OLD_LOCAL) {
                if (Addr->aia_context != NULL) {
                    SetAddrControl *SAC;
                    AddAddrNotifyEvent *DelayedEvent;
                    IPAddr IpAddress;

                    SAC = (SetAddrControl *) Addr->aia_context;
                    Addr->aia_context = NULL;
                    IpAddress = Addr->aia_addr;
                    CTEFreeLock(&Interface->ai_lock, tblhandle);

                    // We cannot call completion routine at timer DPC
                    // because completion routine will need to notify
                    // TDI clients and that could take long time.
                    DelayedEvent = CTEAllocMemNBoot(sizeof(AddAddrNotifyEvent), 'ZiCT');
                    if (DelayedEvent) {
                        DelayedEvent->SAC = SAC;
                        DelayedEvent->Address = IpAddress;
                        DelayedEvent->Status = IP_SUCCESS;
                        CTEInitEvent(&DelayedEvent->Event, CompleteIPSetNTEAddrRequestDelayed);
                        CTEScheduleDelayedEvent(&DelayedEvent->Event, DelayedEvent);
                    }

                    CTEGetLock(&Interface->ai_lock, &tblhandle);
                }
            } else {
                CTEFreeLock(&Interface->ai_lock, tblhandle);
                SendARPRequest(Interface, Addr->aia_addr, ARP_RESOLVING_GLOBAL,
                               NULL, TRUE);
                CTEGetLock(&Interface->ai_lock, &tblhandle);
            }
        }
        Addr = Addr->aia_next;
    } while (Addr != NULL);

    CTEFreeLock(&Interface->ai_lock, tblhandle);

    // Loop through the ARP table for this interface, and delete stale entries.
    CTEGetLock(&Interface->ai_ARPTblLock, &tblhandle);
    Table = Interface->ai_ARPTbl;
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
        Previous = (ARPTableEntry *) ((uchar *) & ((*Table)[i]) - offsetof(struct ARPTableEntry, ate_next));
        Current = (*Table)[i];
        while (Current != (ARPTableEntry *) NULL) {
            CTEGetLock(&Current->ate_lock, &entryhandle);
            Deleted = 0;

            //Delete the entry if it was used for api purpose

            if (Current->ate_resolveonly) {

                ARPControlBlock *ArpContB, *tmpArpContB;
                PNDIS_PACKET Packet = Current->ate_packet;

                ArpContB = Current->ate_resolveonly;
                ASSERT(Current->ate_resolveonly != NULL);
                while (ArpContB) {
                    ArpRtn rtn;
                    //Complete the pending request
                    rtn = (ArpRtn) ArpContB->CompletionRtn;
                    ArpContB->status = 0;
                    tmpArpContB = ArpContB->next;
                    (*rtn) (ArpContB, STATUS_UNSUCCESSFUL);
                    ArpContB = tmpArpContB;
                }
                Current->ate_resolveonly = NULL;

                if (Packet != (PNDIS_PACKET) NULL) {
                    ((PacketContext *) Packet->ProtocolReserved)->pc_common.pc_link = PList;
                    PList = Packet;
                }
                RemoveARPTableEntry(Previous, Current);
                Interface->ai_count--;
                Deleted = 1;
                goto doneapi;
            }

            if (Current->ate_state == ARP_GOOD) {
                //
                // The ARP entry is valid for ARP_VALID_TIMEOUT by default.
                // If a cache life greater than ARP_VALID_TIMEOUT has been
                // configured, we'll make the entry valid for that time.
                //
                ValidTime = ArpCacheLife * ARP_TIMER_TIME;

                if (ValidTime < (ArpMinValidCacheLife * 1000)) {
                    ValidTime = (ArpMinValidCacheLife * 1000);
                }
            } else {
                ValidTime = ARP_RESOLVE_TIMEOUT;
            }

            if (Current->ate_valid != ALWAYS_VALID &&
                (((Now - Current->ate_valid) > ValidTime) ||
                 (Current->ate_state == ARP_GOOD &&
                  !(--(Current->ate_useticks))))) {

                if (Current->ate_state != ARP_RESOLVING_LOCAL) {
                    // Really need to delete this guy.
                    PNDIS_PACKET Packet = Current->ate_packet;

                    if (((Now - Current->ate_valid) > ValidTime) && Current->ate_refresh) {

                        DEBUGMSG(DBG_INFO && DBG_ARP,
                             (DTEXT("ARPTimeout: Expiring ATE %x\n"), Current));

                        if (Packet != (PNDIS_PACKET) NULL) {
                            ((PacketContext *) Packet->ProtocolReserved)->pc_common.pc_link
                            = PList;
                            PList = Packet;
                        }
                        RemoveARPTableEntry(Previous, Current);
                        Interface->ai_count--;
                        Deleted = 1;
                    } else {
                        //Just try to validate this again.

                        Current->ate_valid = Now + ARP_REFRESH_TIME;
                        Current->ate_refresh=TRUE;

                    }

                } else {
                    IPAddr Dest = Current->ate_dest;
                    // This entry is only resoving locally, presumably this is
                    // token ring. We'll need to transmit a 'global' resolution
                    // now.
                    ASSERT(Interface->ai_media == NdisMedium802_5);

                    Now = CTESystemUpTime();
                    Current->ate_valid = Now;
                    Current->ate_state = ARP_RESOLVING_GLOBAL;
                    CTEFreeLock(&Current->ate_lock, entryhandle);
                    CTEFreeLock(&Interface->ai_ARPTblLock, tblhandle);
                    // Send a global request.
                    SendARPRequest(Interface, Dest, ARP_RESOLVING_GLOBAL,
                                   NULL, TRUE);
                    CTEGetLock(&Interface->ai_ARPTblLock, &tblhandle);

                    // Since we've freed the locks, we need to start over from
                    // the start of this chain.
                    Previous = STRUCT_OF(ARPTableEntry, &((*Table)[i]),
                                         ate_next);
                    Current = (*Table)[i];
                    continue;
                }
            }

            doneapi:

            // If we deleted the entry, leave the previous pointer alone,
            // advance the current pointer, and free the memory. Otherwise
            // move both pointers forward. We can free the entry lock now
            // because the next pointers are protected by the table lock, and
            // we've removed it from the list so nobody else should
            // find it anyway.
            CTEFreeLock(&Current->ate_lock, entryhandle);
            if (Deleted) {
                ARPTableEntry *Temp = Current;
                Current = Current->ate_next;
                CTEFreeMem(Temp);
            } else {
                Previous = Current;
                Current = Current->ate_next;
            }
        }
    }

    CTEFreeLock(&Interface->ai_ARPTblLock, tblhandle);

    while (PList != (PNDIS_PACKET) NULL) {
        PNDIS_PACKET Packet = PList;

        PList = ((PacketContext *) Packet->ProtocolReserved)->pc_common.pc_link;
        IPSendComplete(Interface->ai_context, Packet, NDIS_STATUS_SUCCESS);
    }

    //
    // Dont requeue if interface is going down and we need to stop the timer
    //
    if (Interface->ai_stoptimer) {
        // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ARP interface %lx is down - dont requeue the timer - signal the waiter\n", Interface));
        Interface->ai_timerstarted = FALSE;
        CTESignal(&Interface->ai_timerblock, NDIS_STATUS_SUCCESS);
    } else {
        CTEStartTimer(&Interface->ai_timer, ARP_TIMER_TIME, ARPTimeout, Interface);
    }

#if FFP_SUPPORT

    // Flush Processing - This can be done after starting the timer

    CTEGetLock(&Interface->ai_lock, &tblhandle);

    // If FFP supported on this interface & it is time to do a flush
    if ((Interface->ai_ffpversion) &&
        (++Interface->ai_ffplastflush >= FFP_ARP_FLUSH_INTERVAL)) {
        ReqInfoBlock *pRequestInfo;
        FFPFlushParams *pFlushInfo;

        TCPTRACE(("ARPTimeout: Sending a FFP flush to ARPInterface %08X\n",
                  Interface));

        // Allocate the request block - For General and Request Specific Parts
        pRequestInfo = CTEAllocMemN(sizeof(ReqInfoBlock) + sizeof(FFPFlushParams), '0ICT');

        // TCPTRACE(("ARPTimeout: Allocated mem at pReqInfo = %08X\n",
        //                pRequestInfo));

        if (pRequestInfo != NULL) {
            // Prepare the params for the request [Part common to all requests]
            pRequestInfo->RequestType = OID_FFP_FLUSH;
            pRequestInfo->ReqCompleteCallback = ARPReclaimRequestMem;

            // Prepare the params for the request [Part specific to this request]
            pRequestInfo->RequestLength = sizeof(FFPFlushParams);

            // Flush all caches that FFP keeps - just a safe reset of FFP state
            pFlushInfo = (FFPFlushParams *) pRequestInfo->RequestInfo;

            pFlushInfo->NdisProtocolType = NDIS_PROTOCOL_ID_TCP_IP;

            // Assign the ref count to 1 => Used for just a single request
            pRequestInfo->RequestRefs = 1;

            DoNDISRequest(Interface, NdisRequestSetInformation, OID_FFP_FLUSH,
                          pFlushInfo, sizeof(FFPFlushParams), NULL, FALSE);

            // Reset the number of timer ticks since the last FFP request
            Interface->ai_ffplastflush = 0;
        } else {
            TCPTRACE(("Error: Unable to allocate memory for NdisRequest\n"));
        }
    }

#if DBG
    if (fakereset) {
        NDIS_STATUS Status;

        NdisReset(&Status, Interface->ai_handle);
        KdPrint(("fakereset: %x\n", Status));
    }
#endif

    CTEFreeLock(&Interface->ai_lock, tblhandle);

#endif // if FFP_SUPPORT
}

//*     IsLocalAddr - Return info. about local status of address.
//
//      Called when we need info. about whether or not a particular address is
//      local. We return info about whether or not it is, and if it is how old
//      it is.
//
//  Entry:  Interface   - Pointer to interface structure to be searched.
//          Address     - Address in question.
//
//  Returns: ARPADDR_*, for how old it is.
//
//
uint
IsLocalAddr(ARPInterface * Interface, IPAddr Address)
{
    CTELockHandle Handle;
    ARPIPAddr *CurrentAddr;
    uint Age;

    // If we are asking about the null ip address, we don't want to consider
    // it as a true local address.
    //
    if (IP_ADDR_EQUAL(Address, NULL_IP_ADDR)) {
        return ARPADDR_NOT_LOCAL;
    }

    CTEGetLock(&Interface->ai_lock, &Handle);

    CurrentAddr = &Interface->ai_ipaddr;
    Age = ARPADDR_NOT_LOCAL;

    do {
        if (CurrentAddr->aia_addr == Address) {
            Age = CurrentAddr->aia_age;
            break;
        }
        CurrentAddr = CurrentAddr->aia_next;
    } while (CurrentAddr != NULL);

    CTEFreeLock(&Interface->ai_lock, Handle);
    return Age;
}

//* ARPLocalAddr - Determine whether or not a given address if local.
//
//  This routine is called when we receive an incoming packet and need to
//  determine whether or not it's local. We look up the provided address on
//  the specified interface.
//
//  Entry:  Interface   - Pointer to interface structure to be searched.
//          Address     - Address in question.
//
//  Returns: TRUE if it is a local address, FALSE if it's not.
//
uchar
ARPLocalAddr(ARPInterface * Interface, IPAddr Address)
{
    CTELockHandle Handle;
    ARPPArpAddr *CurrentPArp;
    IPMask Mask, NetMask;
    IPAddr MatchAddress;

    // First, see if he's a local (not-proxy) address.
    if (IsLocalAddr(Interface, Address) != ARPADDR_NOT_LOCAL)
        return TRUE;

    CTEGetLock(&Interface->ai_lock, &Handle);

    // Didn't find him in out local address list. See if he exists on our
    // proxy ARP list.
    for (CurrentPArp = Interface->ai_parpaddr; CurrentPArp != NULL;
        CurrentPArp = CurrentPArp->apa_next) {
        // See if this guy matches.
        Mask = CurrentPArp->apa_mask;
        MatchAddress = Address & Mask;
        if (IP_ADDR_EQUAL(CurrentPArp->apa_addr, MatchAddress)) {
            // He matches. We need to make a few more checks to make sure
            // we don't reply to a broadcast address.
            if (Mask == HOST_MASK) {
                // We're matching the whole address, so it's OK.
                CTEFreeLock(&Interface->ai_lock, Handle);
                return TRUE;
            }
            // See if the non-mask part it all-zeros. Since the mask presumably
            // covers a subnet, this trick will prevent us from replying to
            // a zero host part.
            if (IP_ADDR_EQUAL(MatchAddress, Address))
                continue;

            // See if the host part is all ones.
            if (IP_ADDR_EQUAL(Address, MatchAddress | (IP_LOCAL_BCST & ~Mask)))
                continue;

            // If the mask we were given is not the net mask for this address,
            // we'll need to repeat the above checks.
            NetMask = IPNetMask(Address);
            if (NetMask != Mask) {

                MatchAddress = Address & NetMask;
                if (IP_ADDR_EQUAL(MatchAddress, Address))
                    continue;

                if (IP_ADDR_EQUAL(Address, MatchAddress |
                                  (IP_LOCAL_BCST & ~NetMask)))
                    continue;
            }
            // If we get to this point we've passed all the tests, so it's
            // local.
            CTEFreeLock(&Interface->ai_lock, Handle);
            return TRUE;
        }
    }

    CTEFreeLock(&Interface->ai_lock, Handle);
    return FALSE;

}

//*     NotifyConflictProc - Notify the user of an address conflict.
//
//      Called when we need to notify the user of an address conflict. The
//      exact mechanism is system dependent, but generally involves a popup.
//
//      Input:  Event                   - Event that fired.
//                      Context                 - Pointer to ARPNotifyStructure.
//
//      Returns: Nothing.
//
void
NotifyConflictProc(CTEEvent * Event, void *Context)
{
#if MILLEN
    //
    // Call into VIP to VIP_NotifyConflicProc. This will schedule an Appy
    // event, etc. This is a little sleazy, but we do an INT 20, give the
    // appropriate index into service table and VIP VxD ID.
    //
    // void VIP_NotifyConflictProc(CTEEvent *Event, void *Context);
    //  Event is unused.
    //

     _asm {
         push    Context
         push    Context

         _emit   0xcd
         _emit   0x20
         _emit   0x15  // VIP_NotifyConflictProc (Low)
         _emit   0x00  // VIP_NotifyConflictProc (High)
         _emit   0x89  // VIP VxD ID (Low)
         _emit   0x04  // VIP VxD ID (High)
         add esp,8
     }

#else // MILLEN
    ARPNotifyStruct *NotifyStruct = (ARPNotifyStruct *) Context;
    PWCHAR stringList[2];
    uchar IPAddrBuffer[(sizeof(IPAddr) * 4)];
    uchar HWAddrBuffer[(ARP_802_ADDR_LENGTH * 3)];
    WCHAR unicodeIPAddrBuffer[((sizeof(IPAddr) * 4) + 1)];
    WCHAR unicodeHWAddrBuffer[(ARP_802_ADDR_LENGTH * 3)];
    uint i;
    uint IPAddrCharCount;
    UNICODE_STRING unicodeString;
    ANSI_STRING ansiString;

    PAGED_CODE();

    //
    // Convert the IP address into a string.
    //
    IPAddrCharCount = 0;

    for (i = 0; i < sizeof(IPAddr); i++) {
        uint CurrentByte;

        CurrentByte = NotifyStruct->ans_addr & 0xff;
        if (CurrentByte > 99) {
            IPAddrBuffer[IPAddrCharCount++] = (CurrentByte / 100) + '0';
            CurrentByte %= 100;
            IPAddrBuffer[IPAddrCharCount++] = (CurrentByte / 10) + '0';
            CurrentByte %= 10;
        } else if (CurrentByte > 9) {
            IPAddrBuffer[IPAddrCharCount++] = (CurrentByte / 10) + '0';
            CurrentByte %= 10;
        }
        IPAddrBuffer[IPAddrCharCount++] = CurrentByte + '0';
        if (i != (sizeof(IPAddr) - 1))
            IPAddrBuffer[IPAddrCharCount++] = '.';

        NotifyStruct->ans_addr >>= 8;
    }

    //
    // Convert the hardware address into a string.
    //
    for (i = 0; i < NotifyStruct->ans_hwaddrlen; i++) {
        uchar CurrentHalf;

        CurrentHalf = NotifyStruct->ans_hwaddr[i] >> 4;
        HWAddrBuffer[i * 3] = (uchar) (CurrentHalf < 10 ? CurrentHalf + '0' :
                                       (CurrentHalf - 10) + 'A');
        CurrentHalf = NotifyStruct->ans_hwaddr[i] & 0x0f;
        HWAddrBuffer[(i * 3) + 1] = (uchar) (CurrentHalf < 10 ? CurrentHalf + '0' :
                                             (CurrentHalf - 10) + 'A');
        if (i != (NotifyStruct->ans_hwaddrlen - 1))
            HWAddrBuffer[(i * 3) + 2] = ':';
    }

    //
    // Unicode the strings.
    //
    *unicodeIPAddrBuffer = *unicodeHWAddrBuffer = UNICODE_NULL;

    unicodeString.Buffer = unicodeIPAddrBuffer;
    unicodeString.Length = 0;
    unicodeString.MaximumLength = sizeof(WCHAR) * ((sizeof(IPAddr) * 4) + 1);
    ansiString.Buffer = IPAddrBuffer;
    ansiString.Length = (USHORT) IPAddrCharCount;
    ansiString.MaximumLength = (USHORT) IPAddrCharCount;

    RtlAnsiStringToUnicodeString(
                                &unicodeString,
                                &ansiString,
                                FALSE
                                );

    stringList[0] = unicodeIPAddrBuffer;

    unicodeString.Buffer = unicodeHWAddrBuffer;
    unicodeString.Length = 0;
    unicodeString.MaximumLength = sizeof(WCHAR) * (ARP_802_ADDR_LENGTH * 3);
    ansiString.Buffer = HWAddrBuffer;
    ansiString.Length = (NotifyStruct->ans_hwaddrlen * 3) - 1;
    ansiString.MaximumLength = NotifyStruct->ans_hwaddrlen * 3;

    RtlAnsiStringToUnicodeString(
                                &unicodeString,
                                &ansiString,
                                FALSE
                                );

    stringList[1] = unicodeHWAddrBuffer;

    //
    // Kick off a popup and log an event.
    //
    if (NotifyStruct->ans_shutoff) {
        CTELogEvent(
                   IPDriverObject,
                   EVENT_TCPIP_ADDRESS_CONFLICT1,
                   0,
                   2,
                   stringList,
                   0,
                   NULL
                   );

        IoRaiseInformationalHardError(
                                     STATUS_IP_ADDRESS_CONFLICT1,
                                     NULL,
                                     NULL
                                     );
    } else {
        CTELogEvent(
                   IPDriverObject,
                   EVENT_TCPIP_ADDRESS_CONFLICT2,
                   0,
                   2,
                   stringList,
                   0,
                   NULL
                   );

        IoRaiseInformationalHardError(
                                     STATUS_IP_ADDRESS_CONFLICT2,
                                     NULL,
                                     NULL
                                     );
    }
    CTEFreeMem(NotifyStruct);
#endif // !MILLEN

    return;
}

//*     DebugConflictProc - Prints some debugging info in case of addr conflicts
//      Prints the ip and hw addr of the guy causing the conflict
//      Context                 - Pointer to ARPNotifyStructure.
//
//      Returns: Nothing.
//
void
DebugConflictProc(void *Context, BOOLEAN Bugcheck)
{
    ARPNotifyStruct *NotifyStruct = (ARPNotifyStruct *) Context;
    uchar IPAddrBuffer[(sizeof(IPAddr) * 4)];
    uchar HWAddrBuffer[(ARP_802_ADDR_LENGTH * 3)];
    uint i;
    uint IPAddrCharCount;
    IPAddr ans_addr;

    //
    // Save the IP address in case we need it later, then convert into
    // a string.
    //
    ans_addr = NotifyStruct->ans_addr;

    IPAddrCharCount = 0;

    for (i = 0; i < sizeof(IPAddr); i++) {
        uint CurrentByte;

        CurrentByte = NotifyStruct->ans_addr & 0xff;
        if (CurrentByte > 99) {
            IPAddrBuffer[IPAddrCharCount++] = (CurrentByte / 100) + '0';
            CurrentByte %= 100;
            IPAddrBuffer[IPAddrCharCount++] = (CurrentByte / 10) + '0';
            CurrentByte %= 10;
        } else if (CurrentByte > 9) {
            IPAddrBuffer[IPAddrCharCount++] = (CurrentByte / 10) + '0';
            CurrentByte %= 10;
        }
        IPAddrBuffer[IPAddrCharCount++] = CurrentByte + '0';
        if (i != (sizeof(IPAddr) - 1))
            IPAddrBuffer[IPAddrCharCount++] = '.';

        NotifyStruct->ans_addr >>= 8;
    }

    IPAddrBuffer[IPAddrCharCount] = '\0';

    //
    // Convert the hardware address into a string.
    //
    for (i = 0; i < NotifyStruct->ans_hwaddrlen; i++) {
        uchar CurrentHalf;

        CurrentHalf = NotifyStruct->ans_hwaddr[i] >> 4;
        HWAddrBuffer[i * 3] = (uchar) (CurrentHalf < 10 ? CurrentHalf + '0' :
                                       (CurrentHalf - 10) + 'A');
        CurrentHalf = NotifyStruct->ans_hwaddr[i] & 0x0f;
        HWAddrBuffer[(i * 3) + 1] = (uchar) (CurrentHalf < 10 ? CurrentHalf + '0' :
                                             (CurrentHalf - 10) + 'A');
        if (i != (NotifyStruct->ans_hwaddrlen - 1))
            HWAddrBuffer[(i * 3) + 2] = ':';
    }

    HWAddrBuffer[((NotifyStruct->ans_hwaddrlen * 3) - 1)] = '\0';

    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
               "TCPIP: Address Conflict: IPAddr %s HWAddr %s \n",
               IPAddrBuffer, HWAddrBuffer));

    //
    // If told to bugcheck, then do so.
    //

    if (Bugcheck) {
        ULONG addressBytes[3];
        uint currentAddressByte, currentAddressShift;

        //
        // Copy hardware address bytes to the DWORDs, as much as possible.
        //

        addressBytes[0] = 0;
        addressBytes[1] = 0;
        addressBytes[2] = 0;

        currentAddressByte = 0;
        currentAddressShift = 24;
        for (i = 0; i < NotifyStruct->ans_hwaddrlen; i++) {
            addressBytes[currentAddressByte] |=
            NotifyStruct->ans_hwaddr[i] << currentAddressShift;
            if (currentAddressShift == 0) {
                if (currentAddressByte == 2) {
                    break;
                }
                ++currentAddressByte;
                currentAddressShift = 24;
            } else {
                currentAddressShift -= 8;
            }
        }

        KeBugCheckEx(NETWORK_BOOT_DUPLICATE_ADDRESS,
                     ans_addr,
                     addressBytes[0],
                     addressBytes[1],
                     addressBytes[2]);
    }
    return;
}

//* HandleARPPacket - Process an incoming ARP packet.
//
//  This is the main routine to process an incoming ARP packet. We look at
//  all ARP frames, and update our cache entry for the source address if one
//  exists. Else, if we are the target we create an entry if one doesn't
//  exist. Finally, we'll handle the opcode, responding if this is a request
//  or sending pending packets if this is a response.
//
//  Entry:  Interface   - Pointer to interface structure for this adapter.
//          Header      - Pointer to header buffer.
//          HeaderSize  - Size of header buffer.
//          ARPHdr      - ARP packet header.
//          ARPHdrSize  - Size of ARP header.
//          ProtOffset  - Offset into original data field of arp header.
//                                       Will be non-zero if we're using SNAP.
//
//  Returns: An NDIS_STATUS value to be returned to the NDIS driver.
//
NDIS_STATUS
HandleARPPacket(ARPInterface * Interface, void *Header, uint HeaderSize,
                ARPHeader UNALIGNED * ARPHdr, uint ARPHdrSize, uint ProtOffset)
{
    ARPTableEntry *Entry;               // Entry in ARP table
    CTELockHandle LHandle, TableHandle;
    RC UNALIGNED *SourceRoute = (RC UNALIGNED *) NULL;    // Pointer to Source Route info, if any.
    uint SourceRouteSize = 0;
    ulong Now = CTESystemUpTime();
    uchar LocalAddr;
    uint LocalAddrAge;
    uchar *SHAddr, *DHAddr;
    IPAddr UNALIGNED *SPAddr, *DPAddr;
    ENetHeader *ENetHdr;
    TRHeader *TRHdr;
    FDDIHeader *FHdr;
    ARCNetHeader *AHdr;
    ushort MaxMTU;
    uint UseSNAP;
    SetAddrControl *SAC=NULL;
    ARPIPAddr *CurrentAddr;
    AddAddrNotifyEvent *DelayedEvent;
    uint NUCast;

    DEBUGMSG(DBG_TRACE && DBG_ARP && DBG_RX,
             (DTEXT("+HandleARPPacket(%x, %x, %d, %x, %d, %d)\n"),
              Interface, Header, HeaderSize, ARPHdr, ARPHdrSize, ProtOffset));

    // Validate the opcode
    //
    if ((ARPHdr->ah_opcode != net_short(ARP_REQUEST)) &&
        (ARPHdr->ah_opcode != net_short(ARP_RESPONSE))) {
        return NDIS_STATUS_NOT_RECOGNIZED;
    }

    // We examine all ARP frames. If we find the source address in the ARP table, we'll
    // update the hardware address and set the state to valid. If we're the
    // target and he's not in the table, we'll add him. Otherwise if we're the
    // target and this is a response we'll send any pending packets to him.
    if (Interface->ai_media != NdisMediumArcnet878_2) {
        if (ARPHdrSize < sizeof(ARPHeader))
            return NDIS_STATUS_NOT_RECOGNIZED;    // Frame is too small.

        if (ARPHdr->ah_hw != net_short(ARP_HW_ENET) &&
            ARPHdr->ah_hw != net_short(ARP_HW_802))
            return NDIS_STATUS_NOT_RECOGNIZED;    // Wrong HW type

        if (ARPHdr->ah_hlen != ARP_802_ADDR_LENGTH)
            return NDIS_STATUS_NOT_RECOGNIZED;    // Wrong address length.

        if (Interface->ai_media == NdisMedium802_3 && Interface->ai_snapsize == 0)
            UseSNAP = FALSE;
        else
            UseSNAP = (ProtOffset != 0);

        // Figure out SR size on TR.
        if (Interface->ai_media == NdisMedium802_5) {
            // Check for source route information. SR is present if the header
            // size is greater than the standard TR header size. If the SR is
            // only an RC field, we ignore it because it came from the same
            // ring which is the same as no SR.

            if ((HeaderSize - sizeof(TRHeader)) > sizeof(RC)) {
                SourceRouteSize = HeaderSize - sizeof(TRHeader);
                SourceRoute = (RC UNALIGNED *) ((uchar *) Header +
                                                sizeof(TRHeader));
            }
        }
        SHAddr = ARPHdr->ah_shaddr;
        SPAddr = (IPAddr UNALIGNED *) & ARPHdr->ah_spaddr;
        DHAddr = ARPHdr->ah_dhaddr;
        DPAddr = (IPAddr UNALIGNED *) & ARPHdr->ah_dpaddr;

    } else {
        if (ARPHdrSize < (sizeof(ARPHeader) - ARCNET_ARPHEADER_ADJUSTMENT))
            return NDIS_STATUS_NOT_RECOGNIZED;    // Frame is too small.

        if (ARPHdr->ah_hw != net_short(ARP_HW_ARCNET))
            return NDIS_STATUS_NOT_RECOGNIZED;    // Wrong HW type

        if (ARPHdr->ah_hlen != 1)
            return NDIS_STATUS_NOT_RECOGNIZED;    // Wrong address length.

        UseSNAP = FALSE;
        SHAddr = ARPHdr->ah_shaddr;
        SPAddr = (IPAddr UNALIGNED *) (SHAddr + 1);
        DHAddr = (uchar *) SPAddr + sizeof(IPAddr);
        DPAddr = (IPAddr UNALIGNED *) (DHAddr + 1);
    }

    if (ARPHdr->ah_pro != net_short(ARP_ETYPE_IP))
        return NDIS_STATUS_NOT_RECOGNIZED;    // Unsupported protocol type.

    if (ARPHdr->ah_plen != sizeof(IPAddr))
        return NDIS_STATUS_NOT_RECOGNIZED;

    LocalAddrAge = ARPADDR_NOT_LOCAL;

    // First, let's see if we have an address conflict.
    //
    LocalAddrAge = IsLocalAddr(Interface, *SPAddr);

    if (LocalAddrAge != ARPADDR_NOT_LOCAL) {
        // The source IP address is one of ours. See if the source h/w address
        // is ours also.
        if (ARPHdr->ah_hlen != Interface->ai_addrlen ||
            CTEMemCmp(SHAddr, Interface->ai_addr, Interface->ai_addrlen) != 0) {

            uint Shutoff;
            ARPNotifyStruct *NotifyStruct;

            // This isn't from us; we must have an address conflict somewhere.
            // We always log an error about this. If what triggered this is a
            // response and the address in conflict is young, we'll turn off
            // the interface.
            if (LocalAddrAge != ARPADDR_OLD_LOCAL &&
                ARPHdr->ah_opcode == net_short(ARP_RESPONSE)) {
                // Send an arp request with the owner's address to reset the
                // caches.

                CTEGetLock(&Interface->ai_lock, &LHandle);
                // now find the address that is in conflict and get the
                // corresponding client context.
                CurrentAddr = &Interface->ai_ipaddr;

                do {
                    if (CurrentAddr->aia_addr == *SPAddr) {
                        SAC = (SetAddrControl *) CurrentAddr->aia_context;
                        CurrentAddr->aia_context = NULL;
                        break;
                    }
                    CurrentAddr = CurrentAddr->aia_next;
                } while (CurrentAddr != NULL);

                ASSERT(CurrentAddr);
                CTEFreeLock(&Interface->ai_lock, LHandle);

                SendARPRequest(Interface, *SPAddr, ARP_RESOLVING_GLOBAL,
                               SHAddr, FALSE);    // Send a request.

                Shutoff = TRUE;
                // Display the debug information for remote boot/install.
                // This code should be kept.
                {
                    ARPNotifyStruct *DebugNotifyStruct;

                    DebugNotifyStruct = CTEAllocMemN(offsetof(ARPNotifyStruct, ans_hwaddr) +
                                                     ARPHdr->ah_hlen, '1ICT');
                    if (DebugNotifyStruct != NULL) {
                        BOOLEAN bugcheck;
                        DebugNotifyStruct->ans_addr = *SPAddr;
                        DebugNotifyStruct->ans_shutoff = Shutoff;
                        DebugNotifyStruct->ans_hwaddrlen = (uint) ARPHdr->ah_hlen;
                        RtlCopyMemory(DebugNotifyStruct->ans_hwaddr, SHAddr,
                                   ARPHdr->ah_hlen);
                        if (SAC == NULL) {
                            bugcheck = FALSE;
                        } else {
                            bugcheck = SAC->bugcheck_on_duplicate;
                        }
                        DebugConflictProc(DebugNotifyStruct, bugcheck);
                        CTEFreeMem(DebugNotifyStruct);
                    }
                }

                // We cannot call completion routine at this time
                // because completion routine calls back into arp to
                // reset the address and that may go down into ndis.
                DelayedEvent = CTEAllocMemN(sizeof(AddAddrNotifyEvent), '2ICT');
                if (DelayedEvent) {
                    DelayedEvent->SAC = SAC;
                    DelayedEvent->Address = *SPAddr;
                    DelayedEvent->Status = IP_DUPLICATE_ADDRESS;
                    CTEInitEvent(&DelayedEvent->Event, CompleteIPSetNTEAddrRequestDelayed);
                    CTEScheduleDelayedEvent(&DelayedEvent->Event, DelayedEvent);
                } else {
                    ASSERT(FALSE);
                }
                if ((SAC != NULL) && !SAC->StaticAddr) {
                    // this is a dhcp adapter.
                    // don't display a warning dialog in this case - DHCP will
                    // alert the user
                    //

                    goto no_dialog;
                }
            } else {
                if (ARPHdr->ah_opcode == net_short(ARP_REQUEST) &&
                    (IsLocalAddr(Interface, *DPAddr) == ARPADDR_OLD_LOCAL)) {
                    // Send a response for gratuitous ARP.
                    SendARPReply(Interface, *SPAddr, *DPAddr, SHAddr,
                                 SourceRoute, SourceRouteSize, UseSNAP);
                    Shutoff = FALSE;
                } else if (LocalAddrAge != ARPADDR_OLD_LOCAL) {
                    // our address is still young. we dont need to put the
                    // warning popup as it will be done by the code that
                    // checks for arp response in above if portion of the code.
                    goto no_dialog;
                }
                // Else. We have an old local address and received an ARP for
                //       a third address. Fall through and indicate address
                //       conflict.
            }

            // Now allocate a structure, and schedule an event to notify
            // the user.
            NotifyStruct = CTEAllocMemN(offsetof(ARPNotifyStruct, ans_hwaddr) +
                                        ARPHdr->ah_hlen, '3ICT');
            if (NotifyStruct != NULL) {
                NotifyStruct->ans_addr = *SPAddr;
                NotifyStruct->ans_shutoff = Shutoff;
                NotifyStruct->ans_hwaddrlen = (uint) ARPHdr->ah_hlen;
                RtlCopyMemory(NotifyStruct->ans_hwaddr, SHAddr,
                           ARPHdr->ah_hlen);
                CTEInitEvent(&NotifyStruct->ans_event, NotifyConflictProc);
                if (Shutoff) {
                    // Delay notification for few seconds.
                    Interface->ai_conflict = NotifyStruct;
                #if MILLEN
                    Interface->ai_delay = 5;
                #else
                    Interface->ai_delay = 90;    // delay 3 seconds.
                #endif
                } else
                    CTEScheduleDelayedEvent(&NotifyStruct->ans_event, NotifyStruct);
            }
            no_dialog:
            ;

        }
        return NDIS_STATUS_NOT_RECOGNIZED;
    }
    if (!EnableBcastArpReply) {

        // Check for bogus arp entry
        NUCast = ((*(SHAddr) &
                   Interface->ai_bcastmask) == Interface->ai_bcastval) ?
                 AI_NONUCAST_INDEX : AI_UCAST_INDEX;

        if (NUCast == AI_NONUCAST_INDEX) {
            return NDIS_STATUS_NOT_RECOGNIZED;
        }
    }

    CTEGetLock(&Interface->ai_ARPTblLock, &TableHandle);

    MaxMTU = Interface->ai_mtu;

    LocalAddr = ARPLocalAddr(Interface, *DPAddr);

    // If the sender's address is not remote (i.e. multicast, broadcast,
    // local, or just invalid), We don't want to create an entry for it or
    // bother looking it up.
    //
    if ((DEST_REMOTE == GetAddrType(*SPAddr))) {

        Entry = ARPLookup(Interface, *SPAddr, &LHandle);
        if (Entry == (ARPTableEntry *) NULL) {

            // Didn't find him, create one if it's for us. The call to ARPLookup
            // returned with the ARPTblLock held, so we need to free it.

            CTEFreeLock(&Interface->ai_ARPTblLock, TableHandle);

            if (LocalAddr) {
                // If this was an ARP request, we need to create a new
                // entry for the source info.  If this was a reply, it was
                // unsolicited and we don't create an entry.
                //
                if (ARPHdr->ah_opcode != net_short(ARP_RESPONSE)) {
                    Entry = CreateARPTableEntry(Interface, *SPAddr, &LHandle, 0);
                }
            } else {
                return NDIS_STATUS_NOT_RECOGNIZED;    // Not in our table, and not for us.
            }
        } else {

            //if this is for userarp, make sure that it is out of the table
            //while we still have the arp table lock.

            if (Entry->ate_userarp) {

               ARPTable *Table;
               ARPTableEntry *PrevATE, *CurrentATE;
               uint Index = ARP_HASH(*SPAddr);
               CTELockHandle EntryHandle;

               Table = Interface->ai_ARPTbl;

               PrevATE = STRUCT_OF(ARPTableEntry, &((*Table)[Index]), ate_next);
               CurrentATE = PrevATE;

               while (CurrentATE != (ARPTableEntry *) NULL) {
                  if (CurrentATE == Entry) {
                     break;
                  }
                  PrevATE = CurrentATE;
                  CurrentATE = CurrentATE->ate_next;
               }
               if (CurrentATE != NULL) {
                  RemoveARPTableEntry(PrevATE, CurrentATE);
                  Interface->ai_count--;
               }
            }

            CTEFreeLockFromDPC(&Interface->ai_ARPTblLock, LHandle);
            LHandle = TableHandle;
        }
    } else { // Source address was invalid for an Arp table entry.
        CTEFreeLock(&Interface->ai_ARPTblLock, TableHandle);
        Entry = NULL;
    }

    // At this point, entry should be valid and we hold the lock on the entry
    // in LHandle or entry is NULL.

    if (Entry != (ARPTableEntry *) NULL) {
        PNDIS_PACKET Packet;            // Packet to be sent.

        DEBUGMSG(DBG_INFO && DBG_ARP && DBG_RX,
                 (DTEXT("HandleARPPacket: resolving addr for ATE %x\n"), Entry));

        Entry->ate_refresh = FALSE;

        // If the entry is already static, we'll want to leave it as static.
        if (Entry->ate_valid != ALWAYS_VALID) {

            // OK, we have an entry to use, and hold the lock on it. Fill in the
            // required fields.
            switch (Interface->ai_media) {
            case NdisMedium802_3:

                // This is an Ethernet.
                ENetHdr = (ENetHeader *) Entry->ate_addr;

                RtlCopyMemory(ENetHdr->eh_daddr, SHAddr, ARP_802_ADDR_LENGTH);
                RtlCopyMemory(ENetHdr->eh_saddr, Interface->ai_addr,
                           ARP_802_ADDR_LENGTH);
                ENetHdr->eh_type = net_short(ARP_ETYPE_IP);

                // If we're using SNAP on this entry, copy in the SNAP header.
                if (UseSNAP) {
                    RtlCopyMemory(&Entry->ate_addr[sizeof(ENetHeader)], ARPSNAP,
                               sizeof(SNAPHeader));
                    Entry->ate_addrlength = (uchar) (sizeof(ENetHeader) +
                                                     sizeof(SNAPHeader));
                    *(ushort UNALIGNED *) & Entry->ate_addr[Entry->ate_addrlength - 2] =
                    net_short(ARP_ETYPE_IP);
                } else
                    Entry->ate_addrlength = sizeof(ENetHeader);

                Entry->ate_state = ARP_GOOD;
                Entry->ate_valid = Now;     // Mark last time he was
                // valid.

                Entry->ate_useticks = ArpCacheLife;

                break;

            case NdisMedium802_5:

                // This is TR.
                // For token ring we have to deal with source routing. There's
                // a special case to handle multiple responses for an all-routes
                // request - if the entry is currently good and we knew it was
                // valid recently, we won't update the entry.

                if (Entry->ate_state != ARP_GOOD ||
                    (Now - Entry->ate_valid) > ARP_RESOLVE_TIMEOUT) {

                    TRHdr = (TRHeader *) Entry->ate_addr;

                    // We need to update a TR entry.
                    TRHdr->tr_ac = ARP_AC;
                    TRHdr->tr_fc = ARP_FC;
                    RtlCopyMemory(TRHdr->tr_daddr, SHAddr, ARP_802_ADDR_LENGTH);
                    RtlCopyMemory(TRHdr->tr_saddr, Interface->ai_addr,
                               ARP_802_ADDR_LENGTH);
                    if (SourceRoute != (RC UNALIGNED *) NULL) {
                        uchar MaxIFieldBits;

                        // We have source routing information.
                        RtlCopyMemory(&Entry->ate_addr[sizeof(TRHeader)],
                                   SourceRoute, SourceRouteSize);
                        MaxIFieldBits = (SourceRoute->rc_dlf & RC_LF_MASK) >>
                                        LF_BIT_SHIFT;
                        MaxIFieldBits = MIN(MaxIFieldBits, MAX_LF_BITS);
                        MaxMTU = IFieldSize[MaxIFieldBits];

                        // The new MTU we've computed is the max I-field size,
                        // which doesn't include source routing info but
                        // does include SNAP info. Subtract off the SNAP size.
                        MaxMTU -= sizeof(SNAPHeader);

                        TRHdr->tr_saddr[0] |= TR_RII;
                        (*(RC UNALIGNED *) & Entry->ate_addr[sizeof(TRHeader)]).rc_dlf ^=
                        RC_DIR;
                        // Make sure it's non-broadcast.
                        (*(RC UNALIGNED *) & Entry->ate_addr[sizeof(TRHeader)]).rc_blen &=
                        RC_LENMASK;

                    }
                    RtlCopyMemory(&Entry->ate_addr[sizeof(TRHeader) + SourceRouteSize],
                               ARPSNAP, sizeof(SNAPHeader));
                    Entry->ate_state = ARP_GOOD;
                    Entry->ate_valid = Now;
                    Entry->ate_useticks = ArpCacheLife;
                    Entry->ate_addrlength = (uchar) (sizeof(TRHeader) +
                                                     SourceRouteSize + sizeof(SNAPHeader));
                    *(ushort *) & Entry->ate_addr[Entry->ate_addrlength - 2] =
                    net_short(ARP_ETYPE_IP);
                }
                break;
            case NdisMediumFddi:
                FHdr = (FDDIHeader *) Entry->ate_addr;

                FHdr->fh_pri = ARP_FDDI_PRI;
                RtlCopyMemory(FHdr->fh_daddr, SHAddr, ARP_802_ADDR_LENGTH);
                RtlCopyMemory(FHdr->fh_saddr, Interface->ai_addr,
                           ARP_802_ADDR_LENGTH);
                RtlCopyMemory(&Entry->ate_addr[sizeof(FDDIHeader)], ARPSNAP,
                           sizeof(SNAPHeader));
                Entry->ate_addrlength = (uchar) (sizeof(FDDIHeader) +
                                                 sizeof(SNAPHeader));
                *(ushort UNALIGNED *) & Entry->ate_addr[Entry->ate_addrlength - 2] =
                net_short(ARP_ETYPE_IP);
                Entry->ate_state = ARP_GOOD;
                Entry->ate_valid = Now;     // Mark last time he was
                // valid.

                Entry->ate_useticks = ArpCacheLife;
                break;
            case NdisMediumArcnet878_2:
                AHdr = (ARCNetHeader *) Entry->ate_addr;
                AHdr->ah_saddr = Interface->ai_addr[0];
                AHdr->ah_daddr = *SHAddr;
                AHdr->ah_prot = ARP_ARCPROT_IP;
                Entry->ate_addrlength = sizeof(ARCNetHeader);
                Entry->ate_state = ARP_GOOD;
                Entry->ate_valid = Now;     // Mark last time he was
                // valid.

                break;
            default:
                ASSERT(0);
                break;
            }
        }

        if (Entry->ate_resolveonly) {

            CTELockHandle EntryHandle;
            uint Index = ARP_HASH(*SPAddr);
            ARPTableEntry *PrevATE, *CurrentATE;
            ARPTable *Table;
            ARPControlBlock *ArpContB, *TmpArpContB;

            ArpContB = Entry->ate_resolveonly;
            ASSERT(Entry->ate_resolveonly != NULL);

            while (ArpContB) {

                ArpRtn rtn;

                rtn = (ArpRtn) ArpContB->CompletionRtn;

                ArpContB->status = FillARPControlBlock(Interface, Entry,
                                                       ArpContB);
                TmpArpContB = ArpContB->next;
                (*rtn) (ArpContB, STATUS_SUCCESS);
                ArpContB = TmpArpContB;
            }

            Entry->ate_resolveonly = NULL;

            if (Entry->ate_userarp) {

                PNDIS_PACKET OldPacket = NULL;

                OldPacket = Entry->ate_packet;
                CTEFreeLock(&Entry->ate_lock, LHandle);
                CTEFreeMem(Entry);

                if (OldPacket) {
                    IPSendComplete(Interface->ai_context, OldPacket,
                                   NDIS_STATUS_SUCCESS);
                }
            } else {
                CTEFreeLock(&Entry->ate_lock, LHandle);
            }
            return NDIS_STATUS_SUCCESS;
        }

        // At this point we've updated the entry, and we still hold the lock
        // on it. If we have a packet that was pending to be sent, send it now.
        // Otherwise just free the lock.

        Packet = Entry->ate_packet;

        if (Packet != NULL) {
            // We have a packet to send.
            ASSERT(Entry->ate_state == ARP_GOOD);

            Entry->ate_packet = NULL;

            DEBUGMSG(DBG_INFO && DBG_ARP && DBG_TX,
                     (DTEXT("ARPHandlePacket: Sending packet %x after resolving ATE %x\n"),
                      Packet, Entry));

            if (ARPSendData(Interface, Packet, Entry, LHandle) != NDIS_STATUS_PENDING) {
                IPSendComplete(Interface->ai_context, Packet, NDIS_STATUS_SUCCESS);
            }
        } else {
            CTEFreeLock(&Entry->ate_lock, LHandle);
        }
    }
    // See if the MTU is less than our local one. This should only happen
    // in the case of token ring source routing.
    if (MaxMTU < Interface->ai_mtu) {
        LLIPAddrMTUChange LAM;

        LAM.lam_mtu = MaxMTU;
        LAM.lam_addr = *SPAddr;

        // It is less. Notify IP.
        ASSERT(Interface->ai_media == NdisMedium802_5);
        IPStatus(Interface->ai_context, LLIP_STATUS_ADDR_MTU_CHANGE,
                 &LAM, sizeof(LLIPAddrMTUChange), NULL);

    }
    // At this point we've updated the entry (if we had one), and we've freed
    // all locks. If it's for a local address and it's a request, reply to
    // it.
    if (LocalAddr) {                    // It's for us.

        if (ARPHdr->ah_opcode == net_short(ARP_REQUEST)) {
            // It's a request, and we need to respond.
            SendARPReply(Interface, *SPAddr, *DPAddr,
                         SHAddr, SourceRoute, SourceRouteSize, UseSNAP);
        }
    }
    return NDIS_STATUS_SUCCESS;
}

//* InitAdapter - Initialize an adapter.
//
//  Called when an adapter is open to finish initialization. We set
//  up our lookahead size and packet filter, and we're ready to go.
//
//  Entry:
//      adapter - Pointer to an adapter structure for the adapter to be
//                  initialized.
//
//  Exit: Nothing
//
void
InitAdapter(ARPInterface * Adapter)
{
    NDIS_STATUS Status;
    CTELockHandle Handle;
    ARPIPAddr *Addr, *OldAddr;

    if ((Status = DoNDISRequest(Adapter, NdisRequestSetInformation,
                                OID_GEN_CURRENT_LOOKAHEAD, &ARPLookahead, sizeof(ARPLookahead),
                                NULL, TRUE)) != NDIS_STATUS_SUCCESS) {
        Adapter->ai_state = INTERFACE_DOWN;
        return;
    }
    if ((Status = DoNDISRequest(Adapter, NdisRequestSetInformation,
                                OID_GEN_CURRENT_PACKET_FILTER, &Adapter->ai_pfilter, sizeof(uint),
                                NULL, TRUE)) == NDIS_STATUS_SUCCESS) {
        uint MediaStatus;

        Adapter->ai_adminstate = IF_STATUS_UP;

        Adapter->ai_operstate = IF_OPER_STATUS_OPERATIONAL;
        Adapter->ai_lastchange = GetTimeTicks();

        if ((Status = DoNDISRequest(Adapter, NdisRequestQueryInformation,
                                OID_GEN_MEDIA_CONNECT_STATUS, &MediaStatus, sizeof(MediaStatus),
                                NULL, TRUE)) == NDIS_STATUS_SUCCESS) {
            if (MediaStatus == NdisMediaStateDisconnected) {
                Adapter->ai_operstate = IF_OPER_STATUS_NON_OPERATIONAL;
                Adapter->ai_lastchange = GetTimeTicks();
            }
        }

        Adapter->ai_state = INTERFACE_UP;

        // Now walk through any addresses we have and ARP for them , only when ArpRetryCount != 0.
        if (ArpRetryCount) {
            CTEGetLock(&Adapter->ai_lock, &Handle);
            OldAddr = NULL;
            Addr = &Adapter->ai_ipaddr;
            do {
                if (!IP_ADDR_EQUAL(Addr->aia_addr, NULL_IP_ADDR)) {
                   IPAddr Address = Addr->aia_addr;

                   Addr->aia_age = ArpRetryCount;
                   CTEFreeLock(&Adapter->ai_lock, Handle);
                   OldAddr = Addr;
                   SendARPRequest(Adapter, Address, ARP_RESOLVING_GLOBAL,
                                  NULL, TRUE);
                   CTEGetLock(&Adapter->ai_lock, &Handle);
                }
                Addr = &Adapter->ai_ipaddr;
                while (Addr != OldAddr && Addr != NULL) {
                    Addr = Addr->aia_next;
                }
                if (Addr != NULL) {
                    Addr = Addr->aia_next;
                }
            } while (Addr != NULL);

            CTEFreeLock(&Adapter->ai_lock, Handle);
        }

    } else {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_ERROR_LEVEL,
                  "**InitAdapter setting FAILED\n"));

        Adapter->ai_state = INTERFACE_DOWN;
    }
}

//** ARPOAComplete - ARP Open adapter complete handler.
//
//  This routine is called by the NDIS driver when an open adapter
//  call completes. Presumably somebody is blocked waiting for this, so
//  we'll wake him up now.
//
//  Entry:
//      Handle - The binding handle we specified (really a pointer to an AI).
//      Status - Final status of command.
//      ErrorStatus - Final error status.
//
//  Exit: Nothing.
//
void NDIS_API
ARPOAComplete(NDIS_HANDLE Handle, NDIS_STATUS Status, NDIS_STATUS ErrorStatus)
{
    ARPInterface *ai = (ARPInterface *) Handle;    // For compiler.

    CTESignal(&ai->ai_block, (uint) Status);    // Wake him up, and return status.

}

//** ARPCAComplete - ARP close adapter complete handler.
//
//  This routine is called by the NDIS driver when a close adapter
//  call completes.
//
//  Entry:
//      Handle - The binding handle we specified (really a pointer to an AI).
//      Status - Final status of command.
//
//  Exit: Nothing.
//
void NDIS_API
ARPCAComplete(NDIS_HANDLE Handle, NDIS_STATUS Status)
{
    ARPInterface *ai = (ARPInterface *) Handle;    // For compiler.

    CTESignal(&ai->ai_block, (uint) Status);    // Wake him up, and return status.

}

//** ARPSendComplete - ARP send complete handler.
//
//  This routine is called by the NDIS driver when a send completes.
//  This is a pretty time critical operation, we need to get through here
//  quickly. We'll strip our buffer off and put it back, and call the upper
//  later send complete handler.
//
//  Entry:
//      Handle - The binding handle we specified (really a pointer to an AI).
//      Packet - A pointer to the packet that was sent.
//      Status - Final status of command.
//
//  Exit: Nothing.
//
void NDIS_API
ARPSendComplete(NDIS_HANDLE Handle, PNDIS_PACKET Packet, NDIS_STATUS Status)
{
    ARPInterface *Interface = (ARPInterface *) Handle;
    PacketContext *PC = (PacketContext *) Packet->ProtocolReserved;
    PNDIS_BUFFER Buffer;
    uint DataLength;

    Interface->ai_qlen--;

    if (Status == NDIS_STATUS_SUCCESS) {
        DataLength = Packet->Private.TotalLength;
        if (!(Packet->Private.ValidCounts)) {
            NdisQueryPacket(Packet, NULL, NULL, NULL,&DataLength);
        }
        Interface->ai_outoctets += DataLength;
    } else {
        if (Status == NDIS_STATUS_RESOURCES)
            Interface->ai_outdiscards++;
        else
            Interface->ai_outerrors++;
    }

#if BACK_FILL
    // Get first buffer on packet.
    if (Interface->ai_media == NdisMedium802_3) {

        PMDL TmpMdl = NULL;
        uint HdrSize;

        NdisQueryPacket(Packet, NULL, NULL, &TmpMdl, NULL);
        if (TmpMdl->MdlFlags & MDL_NETWORK_HEADER) {
            HdrSize = sizeof(ENetHeader);
            if (((PacketContext*)
                 Packet->ProtocolReserved)->pc_common.pc_flags &
                PACKET_FLAG_SNAP)
                HdrSize += Interface->ai_snapsize;
            (ULONG_PTR) TmpMdl->MappedSystemVa += HdrSize;
            TmpMdl->ByteOffset += HdrSize;
            TmpMdl->ByteCount -= HdrSize;
        } else {
            NdisUnchainBufferAtFront(Packet, &Buffer);
            FreeARPBuffer(Interface, Buffer);    // Free it up.

        }

    } else {
        NdisUnchainBufferAtFront(Packet, &Buffer);
        FreeARPBuffer(Interface, Buffer);    // Free it up.

    }

#else
    // Get first buffer on packet.
    NdisUnchainBufferAtFront(Packet, &Buffer);

    ASSERT(Buffer);

    FreeARPBuffer(Interface, Buffer);   // Free it up.

#endif

    if (PC->pc_common.pc_owner != PACKET_OWNER_LINK) {    // We don't own this one.

        IPSendComplete(Interface->ai_context, Packet, Status);
        return;
    }
    // This packet belongs to us, so free it.
    NdisFreePacket(Packet);

}

//** ARPTDComplete - ARP transfer data complete handler.
//
//  This routine is called by the NDIS driver when a transfer data
//  call completes. Since we never transfer data ourselves, this must be
//  from the upper layer. We'll just call his routine and let him deal
//  with it.
//
//  Entry:
//      Handle - The binding handle we specified (really a pointer to an AI).
//      Packet - A pointer to the packet used for the TD.
//      Status - Final status of command.
//      BytesCopied - Count of bytes copied.
//
//  Exit: Nothing.
//
void NDIS_API
ARPTDComplete(NDIS_HANDLE Handle, PNDIS_PACKET Packet, NDIS_STATUS Status,
              uint BytesCopied)
{
    ARPInterface *ai = (ARPInterface *) Handle;

    IPTDComplete(ai->ai_context, Packet, Status, BytesCopied);

}

//** ARPResetComplete - ARP reset complete handler.
//
//  This routine is called by the NDIS driver when a reset completes.
//
//  Entry:
//      Handle - The binding handle we specified (really a pointer to an AI).
//      Status - Final status of command.
//
//  Exit: Nothing.
//
void NDIS_API
ARPResetComplete(NDIS_HANDLE Handle, NDIS_STATUS Status)
{
    ARPInterface *ai = (ARPInterface *) Handle;

    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ArpResetComplete on %x\n", ai->ai_context));
    IPReset(ai->ai_context);
}

//** ARPRequestComplete - ARP request complete handler.
//
//  This routine is called by the NDIS driver when a general request
//  completes. If ARP blocks on a request, we'll just give a wake up
//  to whoever's blocked on this request. Else if it is a non-blocking
//  request, we extract the request complete callback fn in the request
//  call it, and then deallocate the request block (that is on the heap)
//
//  Entry:
//      Handle - The binding handle we specified (really a pointer to an AI).
//      Request - A pointer to the request that completed.
//      Status - Final status of command.
//
//  Exit: Nothing.
//
void NDIS_API
ARPRequestComplete(NDIS_HANDLE Handle, PNDIS_REQUEST pRequest,
                   NDIS_STATUS Status)
{
    ARPInterface *ai = (ARPInterface *) Handle;
    RequestBlock *rb = STRUCT_OF(RequestBlock, pRequest, Request);

    DEBUGMSG(DBG_TRACE && DBG_ARP && DBG_REQUEST,
         (DTEXT("+ARPRequestComplete(%x, %x, %x) RequestBlock %x\n"),
          Handle, pRequest, Status, rb));

    if (rb->Blocking) {
        // Request through BLOCKING DoNDISRequest

        // Signal the blocked guy here
        CTESignal(&rb->Block, (uint) Status);

        if (InterlockedDecrement(&rb->RefCount) == 0) {
            CTEFreeMem(rb);
        }
    } else {
        ReqInfoBlock *rib;
        RCCALL reqcallback;

        // Request through NON-BLOCKING DoNDISRequest

        // Extract the callback fn pointer & params
        if (pRequest->RequestType == NdisRequestSetInformation)
            rib = STRUCT_OF(ReqInfoBlock,
                            pRequest->DATA.SET_INFORMATION.InformationBuffer,
                            RequestInfo);
        else
            rib = STRUCT_OF(ReqInfoBlock,
                            pRequest->DATA.QUERY_INFORMATION.InformationBuffer,
                            RequestInfo);

        reqcallback = rib->ReqCompleteCallback;
        if (reqcallback)
            reqcallback(rib);

        // Free ARP memory associated with request
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ARPRequestComplete: Freeing mem at pRequest = %08X\n", rb));
        CTEFreeMem(rb);
    }

    DEBUGMSG(DBG_TRACE && DBG_ARP && DBG_REQUEST,
         (DTEXT("-ARPRequestComplete [%x]\n"), Status));
}

//** ARPRcv - ARP receive data handler.
//
//  This routine is called when data arrives from the NDIS driver.
//
//  Entry:
//      Handle - The binding handle we specified (really a pointer to an AI).
//      Context - NDIS context to be used for TD.
//      Header - Pointer to header
//      HeaderSize - Size of header
//      Data - Pointer to buffer of received data
//      Size - Byte count of data in buffer.
//      TotalSize - Byte count of total packet size.
//
//  Exit: Status indicating whether or not we took the packet.
//
NDIS_STATUS NDIS_API
ARPRcv(NDIS_HANDLE Handle, NDIS_HANDLE Context, void *Header, uint HeaderSize,
       void *Data, uint Size, uint TotalSize)
{
    ARPInterface *Interface = Handle;
    NDIS_STATUS status;
    PINT OrigPacket = NULL;

    //get the original packet (if any)
    //this is required to make task offload work
    //note: We shall hack the pClientCount Field
    //to point to the packet as a short term solution
    //to avoid changing all atm - ip interface changes

    if (Interface->ai_OffloadFlags) {
        OrigPacket = (PINT) NdisGetReceivedPacket(Interface->ai_handle, Context);
    }

    //Call the new interface with null mdl and context pointers

    status = ARPRcvIndicationNew(Handle, Context, Header, HeaderSize,
                                 Data, Size, TotalSize, NULL, OrigPacket);

    return status;
}

//** ARPRcvPacket - ARP receive data handler.
//
//  This routine is called when data arrives from the NDIS driver.
//
//  Entry:
//      Handle - The binding handle we specified (really a pointer to an AI).
//      Packet - Contains the incoming frame
//
//  Returns number of upper layer folks latching on to this frame
//
//
INT
ARPRcvPacket(NDIS_HANDLE Handle, PNDIS_PACKET Packet)
{
    UINT HeaderBufferSize = NDIS_GET_PACKET_HEADER_SIZE(Packet);
    UINT firstbufferLength, bufferLength, LookAheadBufferSize;
    PNDIS_BUFFER pFirstBuffer;
    PUCHAR headerBuffer;
    NTSTATUS ntStatus;
    INT ClientCnt = 0;

    //
    // Query the number of buffers, the first MDL's descriptor and the packet length
    //

    NdisGetFirstBufferFromPacket(Packet,    // packet
                                 &pFirstBuffer,    // first buffer descriptor
                                 &headerBuffer,    // ptr to the start of packet
                                 &firstbufferLength,    // length of the header+lookahead
                                 &bufferLength);    // length of the bytes in the buffers

    //
    // ReceiveContext is the packet itself
    //


    LookAheadBufferSize = firstbufferLength - HeaderBufferSize;

    ntStatus = ARPRcvIndicationNew(Handle, Packet, headerBuffer,
                                   HeaderBufferSize,
                                   headerBuffer + HeaderBufferSize,    // LookaheadBuffer
                                   LookAheadBufferSize,    // LookaheadBufferSize
                                   bufferLength - HeaderBufferSize,    // PacketSize - since
                                   // the whole packet is
                                   // indicated
                                   pFirstBuffer,    // pMdl
                                   &ClientCnt    // tdi client count
                                  );

    return ClientCnt;
}

//** ARPRcvIndicationNew - ARP receive data handler.
//
//  This routine is called when data arrives from the NDIS driver.
//
//  Entry:
//      Handle - The binding handle we specified (really a pointer to an AI).
//      Context - NDIS context to be used for TD.
//      Header - Pointer to header
//      HeaderSize - Size of header
//      Data - Pointer to buffer of received data
//      Size - Byte count of data in buffer.
//      TotalSize - Byte count of total packet size.
//      pMdl - NDIS_BUFFER of incoming frame
//      pClientCnt address to return the clinet counts
//
//  Exit: Status indicating whether or not we took the packet.
//
NDIS_STATUS NDIS_API
ARPRcvIndicationNew(NDIS_HANDLE Handle, NDIS_HANDLE Context, void *Header,
                    uint HeaderSize, void *Data, uint Size, uint TotalSize,
                    PNDIS_BUFFER pNdisBuffer, PINT pClientCnt)
{
    ARPInterface *Interface = Handle;   // Interface for this driver.
    ENetHeader UNALIGNED *EHdr = (ENetHeader UNALIGNED *) Header;
    SNAPHeader UNALIGNED *SNAPHdr;
    ushort type;                        // Protocol type
    uint ProtOffset;                    // Offset in Data to non-media info.
    uint NUCast;                        // TRUE if the frame is not a unicast frame.

    if (Interface->ai_state == INTERFACE_UP &&
        HeaderSize >= (uint) Interface->ai_hdrsize) {

        Interface->ai_inoctets += TotalSize;

        NUCast = ((*((uchar UNALIGNED *) EHdr + Interface->ai_bcastoff) &
                   Interface->ai_bcastmask) == Interface->ai_bcastval) ?
                 AI_NONUCAST_INDEX : AI_UCAST_INDEX;

        if ((Interface->ai_promiscuous) && (!NUCast)) {    // AI_UCAST_INDEX = 0

            switch (Interface->ai_media) {
            case NdisMedium802_3:{
                    // Enet
                    if (Interface->ai_addrlen != ARP_802_ADDR_LENGTH ||
                        CTEMemCmp(EHdr->eh_daddr, Interface->ai_addr, ARP_802_ADDR_LENGTH) != 0) {
                        NUCast = AI_PROMIS_INDEX;
                    }
                    break;
                }
            case NdisMedium802_5:{
                    // token ring
                    TRHeader UNALIGNED *THdr = (TRHeader UNALIGNED *) Header;
                    if (Interface->ai_addrlen != ARP_802_ADDR_LENGTH ||
                        CTEMemCmp(THdr->tr_daddr, Interface->ai_addr, ARP_802_ADDR_LENGTH) != 0) {
                        NUCast = AI_PROMIS_INDEX;
                    }
                    break;
                }
            case NdisMediumFddi:{
                    // FDDI
                    FDDIHeader UNALIGNED *FHdr = (FDDIHeader UNALIGNED *) Header;
                    if (Interface->ai_addrlen != ARP_802_ADDR_LENGTH ||
                        CTEMemCmp(FHdr->fh_daddr, Interface->ai_addr, ARP_802_ADDR_LENGTH) != 0) {
                        NUCast = AI_PROMIS_INDEX;
                    }
                    break;
                }
            case NdisMediumArcnet878_2:{
                    // ArcNet
                    DEBUGMSG(DBG_TRACE && DBG_ARP && DBG_RX,
                             (DTEXT("-ARPRcvIndicationNew [NOT_RECOGNIZED]\n")));

                    return NDIS_STATUS_NOT_RECOGNIZED;
                    break;
                }
            default:
                ASSERT(0);
                Interface->ai_outerrors++;
                DEBUGMSG(DBG_TRACE && DBG_ARP && DBG_RX,
                         (DTEXT("-ARPRcvIndicationNew [UNSUPPORTED_MEDIA]\n")));
                return NDIS_STATUS_UNSUPPORTED_MEDIA;
            }
        }

        if ((Interface->ai_media == NdisMedium802_3) &&
            (type = net_short(EHdr->eh_type)) >= MIN_ETYPE) {
            ProtOffset = 0;
        } else if (Interface->ai_media != NdisMediumArcnet878_2) {
            SNAPHdr = (SNAPHeader UNALIGNED *) Data;

            if (Size >= sizeof(SNAPHeader) &&
                SNAPHdr->sh_dsap == SNAP_SAP &&
                SNAPHdr->sh_ssap == SNAP_SAP &&
                SNAPHdr->sh_ctl == SNAP_UI) {
                type = net_short(SNAPHdr->sh_etype);
                ProtOffset = sizeof(SNAPHeader);
            } else {
                //handle XID/TEST here.
                Interface->ai_uknprotos++;
                return NDIS_STATUS_NOT_RECOGNIZED;
            }
        } else {
            ARCNetHeader UNALIGNED *AH = (ARCNetHeader UNALIGNED *) Header;

            ProtOffset = 0;
            if (AH->ah_prot == ARP_ARCPROT_IP)
                type = ARP_ETYPE_IP;
            else if (AH->ah_prot == ARP_ARCPROT_ARP)
                type = ARP_ETYPE_ARP;
            else
                type = 0;
        }

        if (type == ARP_ETYPE_IP) {

            (Interface->ai_inpcount[NUCast])++;

            ASSERT (KeGetCurrentIrql() <= DISPATCH_LEVEL);

            IPRcvPacket(Interface->ai_context, (uchar *) Data + ProtOffset,
                        Size - ProtOffset, TotalSize - ProtOffset, Context, ProtOffset,
                        NUCast, HeaderSize, pNdisBuffer, pClientCnt, NULL);
            return NDIS_STATUS_SUCCESS;
        } else {
            if (type == ARP_ETYPE_ARP) {
                (Interface->ai_inpcount[NUCast])++;
                return HandleARPPacket(Interface, Header, HeaderSize,
                                       (ARPHeader *) ((uchar *) Data + ProtOffset), Size - ProtOffset,
                                       ProtOffset);
            } else {
                Interface->ai_uknprotos++;
                return NDIS_STATUS_NOT_RECOGNIZED;
            }
        }
    } else {
        // Interface is marked as down.
        return NDIS_STATUS_NOT_RECOGNIZED;
    }
}

//** ARPRcvComplete - ARP receive complete handler.
//
//  This routine is called by the NDIS driver after some number of
//  receives. In some sense, it indicates 'idle time'.
//
//  Entry:
//      Handle - The binding handle we specified (really a pointer to an AI).
//
//  Exit: Nothing.
//
void NDIS_API
ARPRcvComplete(NDIS_HANDLE Handle)
{
    IPRcvComplete();

}

//** ARPStatus - ARP status handler.
//
//  Called by the NDIS driver when some sort of status change occurs.
//  We take action depending on the type of status.
//
//  Entry:
//      Handle - The binding handle we specified (really a pointer to an AI).
//      GStatus - General type of status that caused the call.
//      Status - Pointer to a buffer of status specific information.
//      StatusSize - Size of the status buffer.
//
//  Exit: Nothing.
//
void NDIS_API
ARPStatus(NDIS_HANDLE Handle, NDIS_STATUS GStatus, void *Status, uint
          StatusSize)
{
    ARPInterface *ai = (ARPInterface *) Handle;

    //
    // ndis calls this sometimes even before ip interface is created.
    //
    if ((ai->ai_context) && (ai->ai_state == INTERFACE_UP)) {

        IPStatus(ai->ai_context, GStatus, Status, StatusSize, NULL);

        switch (GStatus) {

        //reflect media connect/disconnect status in
        //operstate for query purpose

        case NDIS_STATUS_MEDIA_CONNECT:

            ai->ai_operstate = IF_OPER_STATUS_OPERATIONAL;
            ai->ai_lastchange = GetTimeTicks();
            break;

        case NDIS_STATUS_MEDIA_DISCONNECT:

            ai->ai_operstate = IF_OPER_STATUS_NON_OPERATIONAL;
            ai->ai_lastchange = GetTimeTicks();
            break;

        default:
            break;
        }
    }
}

//** ARPStatusComplete - ARP status complete handler.
//
//  A routine called by the NDIS driver so that we can do postprocessing
//  after a status event.
//
//  Entry:
//      Handle - The binding handle we specified (really a pointer to an AI).
//
//  Exit: Nothing.
//
void NDIS_API
ARPStatusComplete(NDIS_HANDLE Handle)
{

}

//** ARPPnPEvent - ARP PnPEvent handler.
//
//  Called by the NDIS driver when PnP or PM events occurs.
//
//  Entry:
//      Handle - The binding handle we specified (really a pointer to an AI).
//      NetPnPEvent - This is a pointer to a NET_PNP_EVENT that describes
//                    the PnP indication.
//
//  Exit:
//      Just call into IP and return status.
//
NDIS_STATUS
ARPPnPEvent(NDIS_HANDLE Handle, PNET_PNP_EVENT NetPnPEvent)
{
    ARPInterface *ai = (ARPInterface *) Handle;

    //
    // ndis can calls this sometimes even before ip interface is created.
    //
    if (ai && !ai->ai_context) {
        return STATUS_SUCCESS;
    } else {

        return IPPnPEvent(ai ? ai->ai_context : NULL, NetPnPEvent);
    }

}

//** ARPSetNdisRequest - ARP Ndisrequest handler.
//
//  Called by the upper driver to set the packet filter for the interface.
//
//      Entry:
//      Context     - Context value we gave to IP (really a pointer to an AI).
//      OID         - Object ID to set/unset
//      On          - Set_if, clear_if or clear_card
//
//  Exit:
//      returns status.
//
NDIS_STATUS
__stdcall
ARPSetNdisRequest(void *Context, NDIS_OID OID, uint On)
{
    int Status;

    ARPInterface *Interface = (ARPInterface *) Context;
    if (On == SET_IF) {
        Interface->ai_pfilter |= OID;
        if (OID == NDIS_PACKET_TYPE_PROMISCUOUS) {
            Interface->ai_promiscuous = 1;
        }
        Status = DoNDISRequest(Interface, NdisRequestSetInformation,
                               OID_GEN_CURRENT_PACKET_FILTER, &Interface->ai_pfilter,
                               sizeof(uint), NULL, TRUE);
    } else {                            // turn off

        Interface->ai_pfilter &= ~(OID);

        if (OID == NDIS_PACKET_TYPE_PROMISCUOUS) {
            Interface->ai_promiscuous = 0;
        }
        Status = DoNDISRequest(Interface, NdisRequestSetInformation,
                               OID_GEN_CURRENT_PACKET_FILTER, &Interface->ai_pfilter,
                               sizeof(uint), NULL, TRUE);
    }
    return Status;
}

//** ARPPnPComplete - ARP PnP complete handler.
//
//  Called by the upper driver to do the post processing of pnp event.
//
//      Entry:
//      Context     - Context value we gave to IP (really a pointer to an AI).
//      Status      - Status code of the pnp operation.
//      NetPnPEvent - This is a pointer to a NET_PNP_EVENT that describes
//                    the PnP indication.
//
//  Exit:
//      returns nothing.
//
void
__stdcall
ARPPnPComplete(void *Context, NDIS_STATUS Status, PNET_PNP_EVENT NetPnPEvent)
{
    ARPInterface *Interface = (ARPInterface *) Context;
    NdisCompletePnPEvent(Status, (Interface ? Interface->ai_handle : NULL), NetPnPEvent);
}

extern void NDIS_API ARPBindAdapter(PNDIS_STATUS RetStatus,
                                    NDIS_HANDLE BindContext,
                                    PNDIS_STRING AdapterName,
                                    PVOID SS1, PVOID SS2);
extern void NDIS_API ARPUnbindAdapter(PNDIS_STATUS RetStatus,
                                      NDIS_HANDLE ProtBindContext,
                                      NDIS_HANDLE UnbindContext);
extern void NDIS_API ARPUnloadProtocol(void);

extern void ArpUnload(PDRIVER_OBJECT);

//* ARPReadNext - Read the next entry in the ARP table.
//
//  Called by the GetInfo code to read the next ATE in the table. We assume
//  the context passed in is valid, and the caller has the ARP TableLock.
//
//  Input:  Context     - Pointer to a IPNMEContext.
//          Interface   - Pointer to interface for table to read on.
//          Buffer      - Pointer to an IPNetToMediaEntry structure.
//
//  Returns: TRUE if more data is available to be read, FALSE is not.
//
uint
ARPReadNext(void *Context, ARPInterface * Interface, void *Buffer)
{
    IPNMEContext *NMContext = (IPNMEContext *) Context;
    IPNetToMediaEntry *IPNMEntry = (IPNetToMediaEntry *) Buffer;
    CTELockHandle Handle;
    ARPTableEntry *CurrentATE;
    uint i;
    ARPTable *Table = Interface->ai_ARPTbl;
    uint AddrOffset;

    CurrentATE = NMContext->inc_entry;

    // Fill in the buffer.
    CTEGetLock(&CurrentATE->ate_lock, &Handle);
    IPNMEntry->inme_index = Interface->ai_index;
    IPNMEntry->inme_physaddrlen = Interface->ai_addrlen;

    switch (Interface->ai_media) {
    case NdisMedium802_3:
        AddrOffset = 0;
        break;
    case NdisMedium802_5:
        AddrOffset = offsetof(struct TRHeader, tr_daddr);
        break;
    case NdisMediumFddi:
        AddrOffset = offsetof(struct FDDIHeader, fh_daddr);
        break;
    case NdisMediumArcnet878_2:
        AddrOffset = offsetof(struct ARCNetHeader, ah_daddr);
        break;
    default:
        AddrOffset = 0;
        break;
    }

    RtlCopyMemory(IPNMEntry->inme_physaddr, &CurrentATE->ate_addr[AddrOffset],
               Interface->ai_addrlen);
    IPNMEntry->inme_addr = CurrentATE->ate_dest;

    if (CurrentATE->ate_state == ARP_GOOD)
        IPNMEntry->inme_type = (CurrentATE->ate_valid == ALWAYS_VALID ?
                                INME_TYPE_STATIC : INME_TYPE_DYNAMIC);
    else
        IPNMEntry->inme_type = INME_TYPE_INVALID;
    CTEFreeLock(&CurrentATE->ate_lock, Handle);

    // We've filled it in. Now update the context.
    if (CurrentATE->ate_next != NULL) {
        NMContext->inc_entry = CurrentATE->ate_next;
        return TRUE;
    } else {
        // The next ATE is NULL. Loop through the ARP Table looking for a new
        // one.
        i = NMContext->inc_index + 1;
        while (i < ARP_TABLE_SIZE) {
            if ((*Table)[i] != NULL) {
                NMContext->inc_entry = (*Table)[i];
                NMContext->inc_index = i;
                return TRUE;
                break;
            } else
                i++;
        }

        NMContext->inc_index = 0;
        NMContext->inc_entry = NULL;
        return FALSE;
    }

}

//* ARPValidateContext - Validate the context for reading an ARP table.
//
//  Called to start reading an ARP table sequentially. We take in
//  a context, and if the values are 0 we return information about the
//  first route in the table. Otherwise we make sure that the context value
//  is valid, and if it is we return TRUE.
//  We assume the caller holds the ARPInterface lock.
//
//  Input:  Context     - Pointer to a RouteEntryContext.
//          Interface   - Pointer to an interface
//          Valid       - Where to return information about context being
//                          valid.
//
//  Returns: TRUE if more data to be read in table, FALSE if not. *Valid set
//      to TRUE if input context is valid
//
uint
ARPValidateContext(void *Context, ARPInterface * Interface, uint * Valid)
{
    IPNMEContext *NMContext = (IPNMEContext *) Context;
    uint i;
    ARPTableEntry *TargetATE;
    ARPTableEntry *CurrentATE;
    ARPTable *Table = Interface->ai_ARPTbl;

    i = NMContext->inc_index;
    TargetATE = NMContext->inc_entry;

    // If the context values are 0 and NULL, we're starting from the beginning.
    if (i == 0 && TargetATE == NULL) {
        *Valid = TRUE;
        do {
            if ((CurrentATE = (*Table)[i]) != NULL) {
                break;
            }
            i++;
        } while (i < ARP_TABLE_SIZE);

        if (CurrentATE != NULL) {
            NMContext->inc_index = i;
            NMContext->inc_entry = CurrentATE;
            return TRUE;
        } else
            return FALSE;

    } else {

        // We've been given a context. We just need to make sure that it's
        // valid.

        if (i < ARP_TABLE_SIZE) {
            CurrentATE = (*Table)[i];
            while (CurrentATE != NULL) {
                if (CurrentATE == TargetATE) {
                    *Valid = TRUE;
                    return TRUE;
                    break;
                } else {
                    CurrentATE = CurrentATE->ate_next;
                }
            }

        }
        // If we get here, we didn't find the matching ATE.
        *Valid = FALSE;
        return FALSE;

    }

}

#define IFE_FIXED_SIZE  offsetof(struct IFEntry, if_descr)

//* ARPQueryInfo - ARP query information handler.
//
//  Called to query information about the ARP table or statistics about the
//  actual interface.
//
//  Input:  IFContext       - Interface context (pointer to an ARPInterface).
//          ID              - TDIObjectID for object.
//          Buffer          - Buffer to put data into.
//          Size            - Pointer to size of buffer. On return, filled with
//                              bytes copied.
//          Context         - Pointer to context block.
//
//  Returns: Status of attempt to query information.
//
int
__stdcall
ARPQueryInfo(void *IFContext, TDIObjectID * ID, PNDIS_BUFFER Buffer, uint * Size,
             void *Context)
{
    ARPInterface *AI = (ARPInterface *) IFContext;
    uint Offset = 0;
    uint BufferSize = *Size;
    CTELockHandle Handle;
    uint ContextValid, DataLeft;
    uint BytesCopied = 0;
    uchar InfoBuff[sizeof(IFEntry)];
    uint Entity;
    uint Instance;
    BOOLEAN fStatus;

     DEBUGMSG(DBG_TRACE && DBG_QUERYINFO,
         (DTEXT("+ARPQueryInfo(%x, %x, %x, %x, %x)\n"),
         IFContext, ID, Buffer, Size, Context));

    Entity = ID->toi_entity.tei_entity;
    Instance = ID->toi_entity.tei_instance;

    // TCPTRACE(("ARPQueryInfo: AI %lx, Instance %lx, ai_atinst %lx, ai_ifinst %lx\n",
    //    AI, Instance, AI->ai_atinst, AI->ai_ifinst ));

    // First, make sure it's possibly an ID we can handle.
    if ((Entity != AT_ENTITY || Instance != AI->ai_atinst) &&
        (Entity != IF_ENTITY || Instance != AI->ai_ifinst)) {
        return TDI_INVALID_REQUEST;
    }
    *Size = 0;                          // In case of an error.

    if (ID->toi_type != INFO_TYPE_PROVIDER)
        return TDI_INVALID_PARAMETER;

    if (ID->toi_class == INFO_CLASS_GENERIC) {
        if (ID->toi_id == ENTITY_TYPE_ID) {
            // He's trying to see what type we are.
            if (BufferSize >= sizeof(uint)) {
                *(uint *) & InfoBuff[0] = (Entity == AT_ENTITY) ? AT_ARP :
                                          IF_MIB;
                fStatus = CopyToNdisSafe(Buffer, NULL, InfoBuff, sizeof(uint), &Offset);

                if (fStatus == FALSE) {
                    return TDI_NO_RESOURCES;
                }
                *Size = sizeof(uint);
                return TDI_SUCCESS;
            } else
                return TDI_BUFFER_TOO_SMALL;
        }
        return TDI_INVALID_PARAMETER;
    }
    // Might be able to handle this.
    if (Entity == AT_ENTITY) {
        // It's an address translation object. It could be a MIB object or
        // an implementation specific object (the generic objects were handled
        // above).

        if (ID->toi_class == INFO_CLASS_IMPLEMENTATION) {
            ARPPArpAddr *PArpAddr;

            // It's an implementation specific ID. The only ones we handle
            // are the PARP_COUNT_ID and the PARP_ENTRY ID.

            if (ID->toi_id == AT_ARP_PARP_COUNT_ID) {
                // He wants to know the count. Just return that to him.
                if (BufferSize >= sizeof(uint)) {

                    CTEGetLock(&AI->ai_lock, &Handle);

                    fStatus = CopyToNdisSafe(Buffer, NULL, (uchar *) & AI->ai_parpcount,
                                             sizeof(uint), &Offset);

                    CTEFreeLock(&AI->ai_lock, Handle);

                    if (fStatus == FALSE) {
                        return TDI_NO_RESOURCES;
                    }
                    *Size = sizeof(uint);
                    return TDI_SUCCESS;
                } else
                    return TDI_BUFFER_TOO_SMALL;
            }
            if (ID->toi_id != AT_ARP_PARP_ENTRY_ID)
                return TDI_INVALID_PARAMETER;

            // It's for Proxy ARP entries. The context should be either NULL
            // or a pointer to the next one to be read.
            CTEGetLock(&AI->ai_lock, &Handle);

            PArpAddr = *(ARPPArpAddr **) Context;

            if (PArpAddr != NULL) {
                ARPPArpAddr *CurrentPARP;

                // Loop through the P-ARP addresses on the interface, and
                // see if we can find this one.
                CurrentPARP = AI->ai_parpaddr;
                while (CurrentPARP != NULL) {
                    if (CurrentPARP == PArpAddr)
                        break;
                    else
                        CurrentPARP = CurrentPARP->apa_next;
                }

                // If we found a match, PARPAddr points to where to begin
                // reading. Otherwise, fail the request.
                if (CurrentPARP == NULL) {
                    // Didn't find a match, so fail the request.
                    CTEFreeLock(&AI->ai_lock, Handle);
                    return TDI_INVALID_PARAMETER;
                }
            } else
                PArpAddr = AI->ai_parpaddr;

            // PARPAddr points to the next entry to put in the buffer, if
            // there is one.
            while (PArpAddr != NULL) {
                if ((int)(BufferSize - BytesCopied) >=
                    (int)sizeof(ProxyArpEntry)) {
                    ProxyArpEntry *TempPArp;

                    TempPArp = (ProxyArpEntry *) InfoBuff;
                    TempPArp->pae_status = PAE_STATUS_VALID;
                    TempPArp->pae_addr = PArpAddr->apa_addr;
                    TempPArp->pae_mask = PArpAddr->apa_mask;
                    BytesCopied += sizeof(ProxyArpEntry);
                    fStatus = CopyToNdisSafe(Buffer, &Buffer, (uchar *) TempPArp,
                                             sizeof(ProxyArpEntry), &Offset);

                    if (fStatus == FALSE) {
                        CTEFreeLock(&AI->ai_lock, Handle);
                        return TDI_NO_RESOURCES;
                    }
                    PArpAddr = PArpAddr->apa_next;
                } else
                    break;
            }

            // We're done copying. Free the lock and return the correct
            // status.
            CTEFreeLock(&AI->ai_lock, Handle);
            *Size = BytesCopied;
            **(ARPPArpAddr ***) & Context = PArpAddr;
            return(PArpAddr == NULL) ? TDI_SUCCESS : TDI_BUFFER_OVERFLOW;
        }
        if (ID->toi_id == AT_MIB_ADDRXLAT_INFO_ID) {
            AddrXlatInfo *AXI;

            // It's for the count. Just return the number of entries in the
            // table.
            if (BufferSize >= sizeof(AddrXlatInfo)) {
                *Size = sizeof(AddrXlatInfo);
                AXI = (AddrXlatInfo *) InfoBuff;
                AXI->axi_count = AI->ai_count;
                AXI->axi_index = AI->ai_index;
                fStatus = CopyToNdisSafe(Buffer, NULL, (uchar *) AXI, sizeof(AddrXlatInfo),
                                         &Offset);

                if (fStatus == FALSE) {
                    return TDI_NO_RESOURCES;
                }
                *Size = sizeof(AddrXlatInfo);
                return TDI_SUCCESS;
            } else
                return TDI_BUFFER_TOO_SMALL;
        }
        if (ID->toi_id == AT_MIB_ADDRXLAT_ENTRY_ID) {
            // He's trying to read the table.
            // Make sure we have a valid context.
            CTEGetLock(&AI->ai_ARPTblLock, &Handle);
            DataLeft = ARPValidateContext(Context, AI, &ContextValid);

            // If the context is valid, we'll continue trying to read.
            if (!ContextValid) {
                CTEFreeLock(&AI->ai_ARPTblLock, Handle);
                return TDI_INVALID_PARAMETER;
            }
            while (DataLeft) {
                // The invariant here is that there is data in the table to
                // read. We may or may not have room for it. So DataLeft
                // is TRUE, and BufferSize - BytesCopied is the room left
                // in the buffer.
                if ((int)(BufferSize - BytesCopied) >=
                    (int)sizeof(IPNetToMediaEntry)) {
                    DataLeft = ARPReadNext(Context, AI, InfoBuff);
                    BytesCopied += sizeof(IPNetToMediaEntry);
                    fStatus = CopyToNdisSafe(Buffer, &Buffer, InfoBuff,
                                             sizeof(IPNetToMediaEntry), &Offset);

                    if (fStatus == FALSE) {
                        CTEFreeLock(&AI->ai_ARPTblLock, Handle);
                        return(TDI_NO_RESOURCES);
                    }
                } else
                    break;

            }

            *Size = BytesCopied;

            CTEFreeLock(&AI->ai_ARPTblLock, Handle);
            return(!DataLeft ? TDI_SUCCESS : TDI_BUFFER_OVERFLOW);
        }
        return TDI_INVALID_PARAMETER;
    }
    if (ID->toi_class != INFO_CLASS_PROTOCOL)
        return TDI_INVALID_PARAMETER;

    // He must be asking for interface level information. See if we support
    // what he's asking for.
    if (ID->toi_id == IF_MIB_STATS_ID) {
        IFEntry *IFE = (IFEntry *) InfoBuff;
        uint speed;

        // He's asking for statistics. Make sure his buffer is at least big
        // enough to hold the fixed part.

        if (BufferSize < IFE_FIXED_SIZE) {
            return TDI_BUFFER_TOO_SMALL;
        }
        // He's got enough to hold the fixed part. Build the IFEntry structure,
        // and copy it to his buffer.
        IFE->if_index = AI->ai_index;
        switch (AI->ai_media) {
        case NdisMedium802_3:
            IFE->if_type = IF_TYPE_ETHERNET_CSMACD;
            break;
        case NdisMedium802_5:
            IFE->if_type = IF_TYPE_ISO88025_TOKENRING;
            break;
        case NdisMediumFddi:
            IFE->if_type = IF_TYPE_FDDI;
            break;
        case NdisMediumArcnet878_2:
        default:
            IFE->if_type = IF_TYPE_OTHER;
            break;
        }
        IFE->if_mtu = AI->ai_mtu;

        // Some adapters support dynamic speed settings and causes this
        // query to return a different speed from the Networks Connection
        // folder. Therefore, we will requery the speed of the
        // interface. Should we update the ai_speed? Anf if so, do we update
        // if_speed as well?

        IFE->if_speed = AI->ai_speed;

        if (AI->ai_operstate == IF_OPER_STATUS_OPERATIONAL){

            if (DoNDISRequest(
                         AI,
                         NdisRequestQueryInformation,
                         OID_GEN_LINK_SPEED,
                         &speed,
                         sizeof(speed),
                         NULL,
                         TRUE) == NDIS_STATUS_SUCCESS) {
                // Update to real value we want to return.
                speed *= 100L;
                IFE->if_speed = speed;

            } else {
                // Should we fail, or just update with known speed.
                IFE->if_speed = AI->ai_speed;
            }
        }

        IFE->if_physaddrlen = AI->ai_addrlen;
        RtlCopyMemory(IFE->if_physaddr, AI->ai_addr, AI->ai_addrlen);
        IFE->if_adminstatus = (uint) AI->ai_adminstate;
        IFE->if_operstatus = (uint) AI->ai_operstate;
        IFE->if_lastchange = AI->ai_lastchange;
        IFE->if_inoctets = AI->ai_inoctets;
        IFE->if_inucastpkts = AI->ai_inpcount[AI_UCAST_INDEX];
        IFE->if_innucastpkts = AI->ai_inpcount[AI_NONUCAST_INDEX];
        IFE->if_indiscards = AI->ai_indiscards;
        IFE->if_inerrors = AI->ai_inerrors;
        IFE->if_inunknownprotos = AI->ai_uknprotos;
        IFE->if_outoctets = AI->ai_outoctets;
        IFE->if_outucastpkts = AI->ai_outpcount[AI_UCAST_INDEX];
        IFE->if_outnucastpkts = AI->ai_outpcount[AI_NONUCAST_INDEX];
        IFE->if_outdiscards = AI->ai_outdiscards;
        IFE->if_outerrors = AI->ai_outerrors;
        IFE->if_outqlen = AI->ai_qlen;
        IFE->if_descrlen = AI->ai_desclen;
#if FFP_SUPPORT
        // If FFP enabled on this interface, adjust IF stats for FFP'd packets
        if (AI->ai_ffpversion) {
            FFPAdapterStats IFStatsInfo =
            {
                NDIS_PROTOCOL_ID_TCP_IP,
                0, 0, 0, 0, 0, 0, 0, 0
            };

            // Update ARP SNMP vars to account for FFP'd packets
            if (DoNDISRequest(AI, NdisRequestQueryInformation, OID_FFP_ADAPTER_STATS,
                              &IFStatsInfo, sizeof(FFPAdapterStats), NULL, TRUE)
                == NDIS_STATUS_SUCCESS) {
                // Compensate 'inoctets' for packets not seen due to FFP
                IFE->if_inoctets += IFStatsInfo.InOctetsForwarded;
                IFE->if_inoctets += IFStatsInfo.InOctetsDiscarded;

                // Compensate 'inucastpkts' for packets not seen due to FFP
                // Assume all FFP fwded/dropped pkts came in as Eth Unicasts
                // A check to see if it is a ucast or an mcast would slow FFP
                IFE->if_inucastpkts += IFStatsInfo.InPacketsForwarded;
                IFE->if_inucastpkts += IFStatsInfo.InPacketsDiscarded;

                // Compensate 'outoctets' for packets not seen due to FFP
                IFE->if_outoctets += IFStatsInfo.OutOctetsForwarded;

                // Compensate 'outucastpkts' for packets not seen due to FFP
                // Assume all FFP fwded are sent as Ethernet Unicasts
                // A check to see if it is a ucast or an mcast would slow FFP
                IFE->if_outucastpkts += IFStatsInfo.OutPacketsForwarded;
            }
        }
#endif // if FFP_SUPPORT
        fStatus = CopyToNdisSafe(Buffer, &Buffer, (uchar *) IFE, IFE_FIXED_SIZE, &Offset);

        if (fStatus == FALSE) {
            return TDI_NO_RESOURCES;
        }
        // See if he has room for the descriptor string.
        if (BufferSize >= (IFE_FIXED_SIZE + AI->ai_desclen)) {
            // He has room. Copy it.
            if (AI->ai_desclen != 0) {
                fStatus = CopyToNdisSafe(Buffer, NULL, AI->ai_desc, AI->ai_desclen, &Offset);
            }
            if (fStatus == FALSE) {
                return TDI_NO_RESOURCES;
            }
            *Size = IFE_FIXED_SIZE + AI->ai_desclen;
            return TDI_SUCCESS;
        } else {
            // Not enough room to copy the desc. string.
            *Size = IFE_FIXED_SIZE;
            return TDI_BUFFER_OVERFLOW;
        }

    } else if (ID->toi_id == IF_FRIENDLY_NAME_ID) {
        uint Status;
        PNDIS_BUFFER NextBuffer;
        NDIS_STRING NdisString;

        // This is a query for the adapter's friendly name.
        // We'll convert this to an OID_GEN_FRIENDLY_NAME query for NDIS,
        // and transfer the resulting UNICODE_STRING to the caller's buffer
        // as a nul-terminated Unicode string.

        if (NdisQueryAdapterInstanceName(&NdisString, AI->ai_handle) ==
            NDIS_STATUS_SUCCESS) {

            // Verify that the buffer is large enough for the string we just
            // retrieved and, if so, attempt to copy the string to the
            // caller's buffer. If that succeeds, nul-terminate the resulting
            // string.

            if (BufferSize >= (NdisString.Length + 1) * sizeof(WCHAR)) {
                fStatus = CopyToNdisSafe(Buffer, &NextBuffer,
                                         (uchar *)NdisString.Buffer,
                                         NdisString.Length, &Offset);
                if (fStatus) {
                    WCHAR Nul = L'\0';
                    fStatus = CopyToNdisSafe(Buffer, &NextBuffer, (uchar *)&Nul,
                                             sizeof(Nul), &Offset);
                    if (fStatus) {
                        *Size = NdisString.Length + sizeof(Nul);
                        Status = TDI_SUCCESS;
                    } else
                        Status = TDI_NO_RESOURCES;
                } else
                    Status = TDI_NO_RESOURCES;
            } else
                Status = TDI_BUFFER_OVERFLOW;
            NdisFreeString(NdisString);
            return Status;
        } else
            return TDI_NO_RESOURCES;
    }
    return TDI_INVALID_PARAMETER;

}

//* ARPSetInfo - ARP set information handler.
//
//  The ARP set information handler. We support setting of an I/F admin
//  status, and setting/deleting of ARP table entries.
//
//  Input:  Context         - Pointer to I/F to set on.
//          ID              - The object ID
//          Buffer          - Pointer to buffer containing value to set.
//          Size            - Size in bytes of Buffer.
//
//  Returns: Status of attempt to set information.
//
int
__stdcall
ARPSetInfo(void *Context, TDIObjectID * ID, void *Buffer, uint Size)
{
    ARPInterface *Interface = (ARPInterface *) Context;
    CTELockHandle Handle, EntryHandle;
    int Status;
    IFEntry *IFE = (IFEntry *) Buffer;
    IPNetToMediaEntry *IPNME;
    ARPTableEntry *PrevATE, *CurrentATE;
    ARPTable *Table;
    ENetHeader *Header;
    uint Entity, Instance;
    PNDIS_PACKET Packet;

    Entity = ID->toi_entity.tei_entity;
    Instance = ID->toi_entity.tei_instance;

    // First, make sure it's possibly an ID we can handle.
    if ((Entity != AT_ENTITY || Instance != Interface->ai_atinst) &&
        (Entity != IF_ENTITY || Instance != Interface->ai_ifinst)) {
        return TDI_INVALID_REQUEST;
    }
    if (ID->toi_type != INFO_TYPE_PROVIDER) {
        return TDI_INVALID_PARAMETER;
    }
    // Might be able to handle this.
    if (Entity == IF_ENTITY) {

        // It's for the I/F level, see if it's for the statistics.
        if (ID->toi_class != INFO_CLASS_PROTOCOL)
            return TDI_INVALID_PARAMETER;

        if (ID->toi_id == IF_MIB_STATS_ID) {
            // It's for the stats. Make sure it's a valid size.
            if (Size >= IFE_FIXED_SIZE) {
                // It's a valid size. See what he wants to do.
                CTEGetLock(&Interface->ai_lock, &Handle);
                switch (IFE->if_adminstatus) {
                case IF_STATUS_UP:
                    // He's marking it up. If the operational state is
                    // alse up, mark the whole interface as up.
                    Interface->ai_adminstate = IF_STATUS_UP;
                    if (Interface->ai_operstate == IF_OPER_STATUS_OPERATIONAL)
                        Interface->ai_state = INTERFACE_UP;
                    Status = TDI_SUCCESS;
                    break;
                case IF_STATUS_DOWN:
                    // He's taking it down. Mark both the admin state and
                    // the interface state down.
                    Interface->ai_adminstate = IF_STATUS_DOWN;
                    Interface->ai_state = INTERFACE_DOWN;
                    Status = TDI_SUCCESS;
                    break;
                case IF_STATUS_TESTING:
                    // He's trying to cause up to do testing, which we
                    // don't support. Just return success.
                    Status = TDI_SUCCESS;
                    break;
                default:
                    Status = TDI_INVALID_PARAMETER;
                    break;
                }
                CTEFreeLock(&Interface->ai_lock, Handle);
                return Status;
            } else
                return TDI_INVALID_PARAMETER;
        } else {
            return TDI_INVALID_PARAMETER;
        }
    }
    // Not for the interface level. See if it's an implementation or protocol
    // class.
    if (ID->toi_class == INFO_CLASS_IMPLEMENTATION) {
        ProxyArpEntry *PArpEntry;
        ARPIPAddr *Addr;
        IPAddr AddAddr;
        IPMask Mask;

        // It's for the implementation. It should be the proxy-ARP ID.
        if (ID->toi_id != AT_ARP_PARP_ENTRY_ID || Size < sizeof(ProxyArpEntry))
            return TDI_INVALID_PARAMETER;

        PArpEntry = (ProxyArpEntry *) Buffer;
        AddAddr = PArpEntry->pae_addr;
        Mask = PArpEntry->pae_mask;

        // See if he's trying to add or delete a proxy arp entry.
        if (PArpEntry->pae_status == PAE_STATUS_VALID) {
            // We're trying to add an entry. We won't allow an entry
            // to be added that we believe to be invalid or conflicting
            // with our local addresses.

            if (!IP_ADDR_EQUAL(AddAddr & Mask, AddAddr) ||
                IP_ADDR_EQUAL(AddAddr, NULL_IP_ADDR) ||
                IP_ADDR_EQUAL(AddAddr, IP_LOCAL_BCST) ||
                CLASSD_ADDR(AddAddr))
                return TDI_INVALID_PARAMETER;

            // Walk through the list of addresses on the interface, and see
            // if they would match the AddAddr. If so, fail the request.
            CTEGetLock(&Interface->ai_lock, &Handle);

            if (IsBCastOnIF(Interface, AddAddr & Mask)) {
                CTEFreeLock(&Interface->ai_lock, Handle);
                return TDI_INVALID_PARAMETER;
            }
            Addr = &Interface->ai_ipaddr;
            do {
                if (!IP_ADDR_EQUAL(Addr->aia_addr, NULL_IP_ADDR)) {
                    if (IP_ADDR_EQUAL(Addr->aia_addr & Mask, AddAddr))
                        break;
                }
                Addr = Addr->aia_next;
            } while (Addr != NULL);

            CTEFreeLock(&Interface->ai_lock, Handle);
            if (Addr != NULL)
                return TDI_INVALID_PARAMETER;

            // At this point, we believe we're ok. Try to add the address.
            if (ARPAddAddr(Interface, LLIP_ADDR_PARP, AddAddr, Mask, NULL))
                return TDI_SUCCESS;
            else
                return TDI_NO_RESOURCES;
        } else {
            if (PArpEntry->pae_status == PAE_STATUS_INVALID) {
                // He's trying to delete a proxy ARP address.
                if (ARPDeleteAddr(Interface, LLIP_ADDR_PARP, AddAddr, Mask))
                    return TDI_SUCCESS;
            }
            return TDI_INVALID_PARAMETER;
        }
    }

    if (ID->toi_class != INFO_CLASS_PROTOCOL) {
        return TDI_INVALID_PARAMETER;
    }

    if (ID->toi_id == AT_MIB_ADDRXLAT_ENTRY_ID &&
        Size >= sizeof(IPNetToMediaEntry)) {
        // He does want to set an ARP table entry. See if he's trying to
        // create or delete one.

        IPNME = (IPNetToMediaEntry *) Buffer;
        if (IPNME->inme_type == INME_TYPE_INVALID) {
            uint Index = ARP_HASH(IPNME->inme_addr);

            // We're trying to delete an entry. See if we can find it,
            // and then delete it.
            CTEGetLock(&Interface->ai_ARPTblLock, &Handle);
            Table = Interface->ai_ARPTbl;
            PrevATE = STRUCT_OF(ARPTableEntry, &((*Table)[Index]), ate_next);
            CurrentATE = (*Table)[Index];
            while (CurrentATE != (ARPTableEntry *) NULL) {
                if (CurrentATE->ate_dest == IPNME->inme_addr) {
                    // Found him. Break out of the loop.
                    break;
                } else {
                    PrevATE = CurrentATE;
                    CurrentATE = CurrentATE->ate_next;
                }
            }

            if (CurrentATE != NULL) {
                CTEGetLock(&CurrentATE->ate_lock, &EntryHandle);


                if (CurrentATE->ate_resolveonly) {
                    ARPControlBlock *ArpContB, *TmpArpContB;

                    ArpContB = CurrentATE->ate_resolveonly;

                    while (ArpContB) {
                        ArpRtn rtn;
                        rtn = (ArpRtn) ArpContB->CompletionRtn;
                        ArpContB->status = STATUS_UNSUCCESSFUL;
                        TmpArpContB = ArpContB->next;
                        (*rtn) (ArpContB, STATUS_UNSUCCESSFUL);
                        ArpContB = TmpArpContB;
                    }

                    CurrentATE->ate_resolveonly = NULL;
                }


                RemoveARPTableEntry(PrevATE, CurrentATE);
                Interface->ai_count--;
                CTEFreeLockFromDPC(&CurrentATE->ate_lock, EntryHandle);
                CTEFreeLock(&Interface->ai_ARPTblLock, Handle);

                if (CurrentATE->ate_packet != NULL) {
                    IPSendComplete(Interface->ai_context,
                                   CurrentATE->ate_packet, NDIS_STATUS_SUCCESS);
                }

                CTEFreeMem(CurrentATE);
                return TDI_SUCCESS;
            } else
                Status = TDI_INVALID_PARAMETER;

            CTEFreeLock(&Interface->ai_ARPTblLock, Handle);
            return Status;
        }
        // We're not trying to delete. See if we're trying to create.
        if (IPNME->inme_type != INME_TYPE_DYNAMIC &&
            IPNME->inme_type != INME_TYPE_STATIC) {
            // Not creating, return an error.
            return TDI_INVALID_PARAMETER;
        }
        // Make sure he's trying to create a valid address.
        if (IPNME->inme_physaddrlen != Interface->ai_addrlen)
            return TDI_INVALID_PARAMETER;

        // We're trying to create an entry. Call CreateARPTableEntry to create
        // one, and fill it in.
        CurrentATE = CreateARPTableEntry(Interface, IPNME->inme_addr, &Handle, 0);
        if (CurrentATE == NULL) {
            return TDI_NO_RESOURCES;
        }
        // We've created or found an entry. Fill it in.
        Header = (ENetHeader *) CurrentATE->ate_addr;

        switch (Interface->ai_media) {
        case NdisMedium802_5:
            {
                TRHeader *Temp = (TRHeader *) Header;

                // Fill in the TR specific parts, and set the length to the
                // size of a TR header.

                Temp->tr_ac = ARP_AC;
                Temp->tr_fc = ARP_FC;
                RtlCopyMemory(&Temp->tr_saddr[ARP_802_ADDR_LENGTH], ARPSNAP,
                           sizeof(SNAPHeader));

                Header = (ENetHeader *) & Temp->tr_daddr;
                CurrentATE->ate_addrlength = sizeof(TRHeader) +
                                             sizeof(SNAPHeader);
            }
            break;
        case NdisMedium802_3:
            CurrentATE->ate_addrlength = sizeof(ENetHeader);
            break;
        case NdisMediumFddi:
            {
                FDDIHeader *Temp = (FDDIHeader *) Header;

                Temp->fh_pri = ARP_FDDI_PRI;
                RtlCopyMemory(&Temp->fh_saddr[ARP_802_ADDR_LENGTH], ARPSNAP,
                           sizeof(SNAPHeader));
                Header = (ENetHeader *) & Temp->fh_daddr;
                CurrentATE->ate_addrlength = sizeof(FDDIHeader) +
                                             sizeof(SNAPHeader);
            }
            break;
        case NdisMediumArcnet878_2:
            {
                ARCNetHeader *Temp = (ARCNetHeader *) Header;

                Temp->ah_saddr = Interface->ai_addr[0];
                Temp->ah_daddr = IPNME->inme_physaddr[0];
                Temp->ah_prot = ARP_ARCPROT_IP;
                CurrentATE->ate_addrlength = sizeof(ARCNetHeader);
            }
            break;
        default:
            ASSERT(0);
            break;
        }

        // Copy in the source and destination addresses.

        if (Interface->ai_media != NdisMediumArcnet878_2) {
            RtlCopyMemory(Header->eh_daddr, IPNME->inme_physaddr,
                       ARP_802_ADDR_LENGTH);
            RtlCopyMemory(Header->eh_saddr, Interface->ai_addr,
                       ARP_802_ADDR_LENGTH);

            // Now fill in the Ethertype.
            *(ushort *) & CurrentATE->ate_addr[CurrentATE->ate_addrlength - 2] =
            net_short(ARP_ETYPE_IP);
        }
        // If he's creating a static entry, mark it as always valid. Otherwise
        // mark him as valid now.
        if (IPNME->inme_type == INME_TYPE_STATIC)
            CurrentATE->ate_valid = ALWAYS_VALID;
        else
            CurrentATE->ate_valid = CTESystemUpTime();

        CurrentATE->ate_state = ARP_GOOD;

        Packet = CurrentATE->ate_packet;
        CurrentATE->ate_packet = NULL;

        CTEFreeLock(&CurrentATE->ate_lock, Handle);

        if (Packet) {
            IPSendComplete(Interface->ai_context, Packet, NDIS_STATUS_SUCCESS);
        }

        return TDI_SUCCESS;
    }
    return TDI_INVALID_PARAMETER;
}

#pragma BEGIN_INIT
//** ARPInit - Initialize the ARP module.
//
//  This functions intializes all of the ARP module, including allocating
//  the ARP table and any other necessary data structures.
//
//  Entry: nothing.
//
//  Exit: Returns 0 if we fail to init., !0 if we succeed.
//
int
ARPInit()
{
    NDIS_STATUS Status;                 // Status for NDIS calls.
    NDIS_PROTOCOL_CHARACTERISTICS Characteristics;

    DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("+ARPInit()\n")));

    RtlZeroMemory(&Characteristics, sizeof(NDIS_PROTOCOL_CHARACTERISTICS));
    Characteristics.MajorNdisVersion = NDIS_MAJOR_VERSION;
    Characteristics.MinorNdisVersion = NDIS_MINOR_VERSION;
    Characteristics.OpenAdapterCompleteHandler = ARPOAComplete;
    Characteristics.CloseAdapterCompleteHandler = ARPCAComplete;
    Characteristics.SendCompleteHandler = ARPSendComplete;
    Characteristics.TransferDataCompleteHandler = ARPTDComplete;
    Characteristics.ResetCompleteHandler = ARPResetComplete;
    Characteristics.RequestCompleteHandler = ARPRequestComplete;
    Characteristics.ReceiveHandler = ARPRcv,
    Characteristics.ReceiveCompleteHandler = ARPRcvComplete;
    Characteristics.StatusHandler = ARPStatus;
    Characteristics.StatusCompleteHandler = ARPStatusComplete;

    //
    // Re-direct to IP since IP now binds to NDIS.
    //
    Characteristics.BindAdapterHandler = IPBindAdapter;    // ARPBindAdapter;
    Characteristics.UnbindAdapterHandler = ARPUnbindAdapter;
    Characteristics.PnPEventHandler = ARPPnPEvent;

#if MILLEN
    Characteristics.UnloadHandler = ARPUnloadProtocol;
#endif // MILLEN

    RtlInitUnicodeString(&(Characteristics.Name), ARPName);

    Characteristics.ReceivePacketHandler = ARPRcvPacket;

    DEBUGMSG(DBG_INFO && DBG_INIT,
             (DTEXT("ARPInit: Calling NdisRegisterProtocol %d:%d %ws\n"),
              NDIS_MAJOR_VERSION, NDIS_MINOR_VERSION, ARPName));

    NdisRegisterProtocol(&Status, &ARPHandle, (NDIS_PROTOCOL_CHARACTERISTICS *)
                         & Characteristics, sizeof(Characteristics));

    DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-ARPInit [%x]\n"), Status));

    if (Status == NDIS_STATUS_SUCCESS) {
        return(1);
    } else {
        return(0);
    }
}

//* FreeARPInterface - Free an ARP interface
//
//  Called in the event of some sort of initialization failure. We free all
//  the memory associated with an ARP interface.
//
//  Entry:  Interface   - Pointer to interface structure to be freed.
//
//  Returns: Nothing.
//
void
FreeARPInterface(ARPInterface *Interface)
{
    NDIS_STATUS Status;
    ARPTable *Table;                    // ARP table.
    uint i;                             // Index variable.
    ARPTableEntry *ATE;
    CTELockHandle LockHandle;
    NDIS_HANDLE Handle;
    PNDIS_BUFFER tmpBuffer;
    PSINGLE_LIST_ENTRY pBufLink;

    if (Interface->ai_timerstarted &&
        !CTEStopTimer(&Interface->ai_timer)) {
        // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Could not stop ai_timer - waiting for event\n"));

        (VOID) CTEBlock(&Interface->ai_timerblock);
        KeClearEvent(&Interface->ai_timerblock.cbs_event);
    }

// If we're bound to the adapter, close it now.
    CTEInitBlockStruc(&Interface->ai_block);

    CTEGetLock(&Interface->ai_lock, &LockHandle);
    if (Interface->ai_handle != (NDIS_HANDLE) NULL) {
        Handle = Interface->ai_handle;
        Interface->ai_handle = NULL;
        CTEFreeLock(&Interface->ai_lock, LockHandle);

        NdisCloseAdapter(&Status, Handle);

        if (Status == NDIS_STATUS_PENDING)
            Status = CTEBlock(&Interface->ai_block);
    } else {
        CTEFreeLock(&Interface->ai_lock, LockHandle);
    }

    // First free any outstanding ARP table entries.
    Table = Interface->ai_ARPTbl;
    if (Table != NULL) {
        for (i = 0; i < ARP_TABLE_SIZE; i++) {
            while ((*Table)[i] != NULL) {
                ATE = (*Table)[i];

                if (ATE->ate_resolveonly) {
                    ARPControlBlock *ArpContB, *TmpArpContB;

                    ArpContB = ATE->ate_resolveonly;

                    while (ArpContB) {
                        ArpRtn rtn;
                        rtn = (ArpRtn) ArpContB->CompletionRtn;
                        ArpContB->status = STATUS_UNSUCCESSFUL;
                        TmpArpContB = ArpContB->next;
                        (*rtn) (ArpContB, STATUS_UNSUCCESSFUL);
                        ArpContB = TmpArpContB;
                    }

                    ATE->ate_resolveonly = NULL;

                }

                RemoveARPTableEntry(STRUCT_OF(ARPTableEntry, &((*Table)[i]),
                                              ate_next), ATE);

                if (ATE->ate_packet) {
                    IPSendComplete(Interface->ai_context, ATE->ate_packet,
                                   NDIS_STATUS_SUCCESS);
                }
                CTEFreeMem(ATE);
            }
        }
        CTEFreeMem(Table);
    }
    Interface->ai_ARPTbl = NULL;

    if (Interface->ai_ppool != (NDIS_HANDLE) NULL)
        NdisFreePacketPool(Interface->ai_ppool);

    if (Interface->ai_devicename.Buffer != NULL) {
        CTEFreeMem(Interface->ai_devicename.Buffer);
    }

    if (Interface->ai_desc) {
        CTEFreeMem(Interface->ai_desc);
    }
    // Free the interface itself.
    CTEFreeMem(Interface);
}

//** ARPOpen - Open an adapter for reception.
//
//  This routine is called when the upper layer is done initializing and wishes to
//  begin receiveing packets. The adapter is actually 'open', we just call InitAdapter
//  to set the packet filter and lookahead size.
//
//  Input:  Context     - Interface pointer we gave to IP earlier.
//
//  Returns: Nothing
//
void
__stdcall
ARPOpen(void *Context)
{
    ARPInterface *Interface = (ARPInterface *) Context;
    InitAdapter(Interface);             // Set the packet filter - we'll begin receiving.
}

//*     ARPGetEList - Get the entity list.
//
//      Called at init time to get an entity list. We fill our stuff in, and
//      then call the interfaces below us to allow them to do the same.
//
//      Input:  EntityList              - Pointer to entity list to be filled in.
//                      Count                   - Pointer to number of entries in the list.
//
//      Returns Status of attempt to get the info.
//
int
__stdcall
ARPGetEList(void *Context, TDIEntityID * EList, uint * Count)
{
    ARPInterface *Interface = (ARPInterface *) Context;
    uint MyATBase;
    uint MyIFBase;
    uint i;
    TDIEntityID *ATEntity, *IFEntity;
    TDIEntityID *EntityList;

    // Walk down the list, looking for existing AT or IF entities, and
    // adjust our base instance accordingly.
    // if we are already on the list then do nothing.
    // if we are going away, mark our entry invalid.

    EntityList = EList;
    MyATBase = 0;
    MyIFBase = 0;
    ATEntity = NULL;
    IFEntity = NULL;
    for (i = 0; i < *Count; i++, EntityList++) {
        if (EntityList->tei_entity == AT_ENTITY) {
            // if we are already on the list remember our entity item
            // o/w find an instance # for us.
            if (EntityList->tei_instance == Interface->ai_atinst &&
                EntityList->tei_instance != INVALID_ENTITY_INSTANCE) {
                ATEntity = EntityList;
                // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ARPGetElist - Found our interface %lx at_atinst %lx\n",Interface, Interface->ai_atinst));
            } else {
                MyATBase = MAX(MyATBase, EntityList->tei_instance + 1);
            }
        } else {
            if (EntityList->tei_entity == IF_ENTITY)
                // if we are already on the list remember our entity item
                // o/w find an instance # for us.
                if (EntityList->tei_instance == Interface->ai_ifinst &&
                    EntityList->tei_instance != INVALID_ENTITY_INSTANCE) {
                    IFEntity = EntityList;
                    // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ARPGetElist - Found our interface %lx ai_ifinst %lx\n",Interface, Interface->ai_ifinst));
                } else {
                    MyIFBase = MAX(MyIFBase, EntityList->tei_instance + 1);
                }
        }
        if (ATEntity && IFEntity) {
            break;
        }
    }

    if (ATEntity) {
        // we are already on the list.
        // are we going away?
        if (Interface->ai_state & INTERFACE_DOWN) {
            // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ARPGetElist - our interface %lx atinst %lx going away \n",Interface, Interface->ai_atinst));
            ATEntity->tei_instance = INVALID_ENTITY_INSTANCE;
        }
    } else {
        // we are not on the list.
        // insert ourself iff we are not going away.
        if (!(Interface->ai_state & INTERFACE_DOWN)) {
            // make sure we have the room for it.
            if (*Count >= MAX_TDI_ENTITIES) {
                return FALSE;
            }
            Interface->ai_atinst = MyATBase;
            ATEntity = &EList[*Count];
            ATEntity->tei_entity = AT_ENTITY;
            ATEntity->tei_instance = MyATBase;
            (*Count)++;
            // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ARPGetElist - adding interface %lx atinst %lx \n",Interface, Interface->ai_atinst));
        }
    }

    if (IFEntity) {
        // we are already on the list.
        // are we going away?
        if (Interface->ai_state & INTERFACE_DOWN) {
            // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ARPGetElist - our interface %lx ifinst %lx going away \n",Interface, Interface->ai_ifinst));
            IFEntity->tei_instance = INVALID_ENTITY_INSTANCE;
        }
    } else {
        // we are not on the list.
        // insert ourself iff we are not going away.
        if (!(Interface->ai_state & INTERFACE_DOWN)) {
            // make sure we have the room for it.
            if (*Count >= MAX_TDI_ENTITIES) {
                return FALSE;
            }
            Interface->ai_ifinst = MyIFBase;
            IFEntity = &EList[*Count];
            IFEntity->tei_entity = IF_ENTITY;
            IFEntity->tei_instance = MyIFBase;
            (*Count)++;
            // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ARPGetElist - adding interface %lx ifinst %lx \n",Interface, Interface->ai_ifinst));
        }
    }

    // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ARPGetEList: arp interface %lx, ai_atinst %lx, ai_ifinst %lx, total %lx\n",
    //       Interface, Interface->ai_atinst, Interface->ai_ifinst, *Count));

    return TRUE;
}

extern uint UseEtherSNAP(PNDIS_STRING Name);
extern void GetAlwaysSourceRoute(uint * pArpAlwaysSourceRoute, uint * pIPAlwaysSourceRoute);
extern uint GetArpCacheLife(void);
extern uint GetArpRetryCount(void);

//** InitTaskOffloadHeader - Initializes the task offload header wrt version
//                           and encapsulation, etc.
//
//    All task offload header structure members are initialized.
//
//  Input:
//      ai                  - ARPInterface for which we are initializing
//                            the task offload header.
//      TaskOffloadHeader   - Pointer to task offload header to initialize.
//  Returns:
//      None.
//
VOID
InitTaskOffloadHeader(ARPInterface *ai,
                      PNDIS_TASK_OFFLOAD_HEADER TaskOffloadHeader)
{
    TaskOffloadHeader->Version = NDIS_TASK_OFFLOAD_VERSION;
    TaskOffloadHeader->Size    = sizeof(NDIS_TASK_OFFLOAD_HEADER);

    TaskOffloadHeader->EncapsulationFormat.Flags.FixedHeaderSize = 1;
    TaskOffloadHeader->EncapsulationFormat.EncapsulationHeaderSize = ai->ai_hdrsize;
    TaskOffloadHeader->OffsetFirstTask = 0;


    if (ai->ai_media == NdisMedium802_3) {

        if (ai->ai_snapsize) {
            TaskOffloadHeader->EncapsulationFormat.Encapsulation = LLC_SNAP_ROUTED_Encapsulation;
            TaskOffloadHeader->EncapsulationFormat.EncapsulationHeaderSize += ai->ai_snapsize;
        } else {
            TaskOffloadHeader->EncapsulationFormat.Encapsulation = IEEE_802_3_Encapsulation;
        }
    } else if (ai->ai_media == NdisMedium802_5) {

        TaskOffloadHeader->EncapsulationFormat.Encapsulation = IEEE_802_5_Encapsulation;
    } else {

        TaskOffloadHeader->EncapsulationFormat.Encapsulation = UNSPECIFIED_Encapsulation;
    }

    return;
}

//**SetOffload - Set offload capabilities
//
//
//    All task offload header structure members are initialized.
//
//  Input:
//      ai                  - ARPInterface for which we are initializing
//                            the task offload header.
//      TaskOffloadHeader   - Pointer to task offload header to initialize.
//      Bufsize             - length of task offload buffer allocated by teh caller
//
//  Returns:
//      TRUE                - successfully set the offload capability
//      FALSE               - failure case
//
BOOLEAN
SetOffload(ARPInterface *ai,PNDIS_TASK_OFFLOAD_HEADER TaskOffloadHeader,uint BufSize)
{
    PNDIS_TASK_OFFLOAD tmpoffload;
    PNDIS_TASK_OFFLOAD TaskOffload, NextTaskOffLoad, LastTaskOffload;
    NDIS_TASK_IPSEC ipsecCaps;
    uint TotalLength;
    NDIS_STATUS Status;
    uint PrevOffLoad=ai->ai_OffloadFlags;

    //Parse the buffer for Checksum and tcplargesend offload capabilities

    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Something to Offload. offload buffer size %x\n", BufSize));
    ASSERT(TaskOffloadHeader->OffsetFirstTask == sizeof(NDIS_TASK_OFFLOAD_HEADER));

    TaskOffload = tmpoffload = (NDIS_TASK_OFFLOAD *) ((uchar *) TaskOffloadHeader + TaskOffloadHeader->OffsetFirstTask);

    if (BufSize >= (TaskOffloadHeader->OffsetFirstTask + sizeof(NDIS_TASK_OFFLOAD))) {

        while (tmpoffload) {

            if (tmpoffload->Task == TcpIpChecksumNdisTask) {
                //Okay we this adapter supports checksum offload
                //check if tcp and/or  ip chksums bits are present

                PNDIS_TASK_TCP_IP_CHECKSUM ChecksumInfo;

                ChecksumInfo = (PNDIS_TASK_TCP_IP_CHECKSUM) & tmpoffload->TaskBuffer[0];

                //if (ChecksumInfo->V4Transmit.V4Checksum) {

                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"V4 Checksum offload\n"));

                if (ChecksumInfo->V4Transmit.TcpChecksum) {
                    ai->ai_OffloadFlags |= TCP_XMT_CHECKSUM_OFFLOAD;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL," Tcp Checksum offload\n"));
                }
                if (ChecksumInfo->V4Transmit.IpChecksum) {
                    ai->ai_OffloadFlags |= IP_XMT_CHECKSUM_OFFLOAD;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL," IP xmt Checksum offload\n"));
                }
                if (ChecksumInfo->V4Receive.TcpChecksum) {
                    ai->ai_OffloadFlags |= TCP_RCV_CHECKSUM_OFFLOAD;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL," Tcp Rcv Checksum offload\n"));
                }
                if (ChecksumInfo->V4Receive.IpChecksum) {
                    ai->ai_OffloadFlags |= IP_RCV_CHECKSUM_OFFLOAD;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL," IP rcv  Checksum offload\n"));
                }
                if (ChecksumInfo->V4Transmit.IpOptionsSupported) {
                    ai->ai_OffloadFlags |= IP_CHECKSUM_OPT_OFFLOAD;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL," IP Checksum xmt options offload\n"));
                }

                if (ChecksumInfo->V4Transmit.TcpOptionsSupported) {
                    ai->ai_OffloadFlags |= TCP_CHECKSUM_OPT_OFFLOAD;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL," TCP Checksum xmt options offload\n"));
                }


            } else if ((tmpoffload->Task == TcpLargeSendNdisTask) && (ai->ai_snapsize == 0)) {

                PNDIS_TASK_TCP_LARGE_SEND TcpLargeSend, in_LargeSend = (PNDIS_TASK_TCP_LARGE_SEND) & tmpoffload->TaskBuffer[0];

                ai->ai_OffloadFlags |= TCP_LARGE_SEND_OFFLOAD;

                TcpLargeSend = &ai->ai_TcpLargeSend;
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL," Tcp large send!! \n"));


                TcpLargeSend->MaxOffLoadSize = in_LargeSend->MaxOffLoadSize;
                TcpLargeSend->MinSegmentCount = in_LargeSend->MinSegmentCount;

                // no tcp or ip options when doing large send
                // Need to reevaluate this as we turn on Time stamp option.

                if (in_LargeSend->TcpOptions) {

                    ai->ai_OffloadFlags |= TCP_LARGE_SEND_TCPOPT_OFFLOAD;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL," TCP largesend  options offload\n"));
                }

                if (in_LargeSend->IpOptions) {
                    ai->ai_OffloadFlags |= TCP_LARGE_SEND_IPOPT_OFFLOAD;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL," IP largesend  options offload\n"));
                }


            } else if (tmpoffload->Task == IpSecNdisTask) {
                PNDIS_TASK_IPSEC pIPSecCaps = (PNDIS_TASK_IPSEC) & tmpoffload->TaskBuffer[0];

                //
                // Save off the capabilities for setting them later.
                //
                ipsecCaps = *pIPSecCaps;

                //
                // CryptoOnly is assumed if we have IpSecNdisTask
                //
                ai->ai_OffloadFlags |= IPSEC_OFFLOAD_CRYPTO_ONLY;

                //
                // Do Support first
                //

                if (pIPSecCaps->Supported.AH_ESP_COMBINED) {
                    ai->ai_OffloadFlags |= IPSEC_OFFLOAD_AH_ESP;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"AH_ESP\n"));
                }
                if (pIPSecCaps->Supported.TRANSPORT_TUNNEL_COMBINED) {
                    ai->ai_OffloadFlags |= IPSEC_OFFLOAD_TPT_TUNNEL;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"TPT_TUNNEL\n"));
                }
                if (pIPSecCaps->Supported.V4_OPTIONS) {
                    ai->ai_OffloadFlags |= IPSEC_OFFLOAD_V4_OPTIONS;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"V4_OPTIONS\n"));
                }
                if (pIPSecCaps->Supported.RESERVED) {
                    pIPSecCaps->Supported.RESERVED = 0;
                    //ai->ai_OffloadFlags |= IPSEC_OFFLOAD_QUERY_SPI;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"QUERY_SPI\n"));
                }
                //
                // Do V4AH next
                //

                if (pIPSecCaps->V4AH.MD5) {
                    ai->ai_OffloadFlags |= IPSEC_OFFLOAD_AH_MD5;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"MD5\n"));
                }
                if (pIPSecCaps->V4AH.SHA_1) {
                    ai->ai_OffloadFlags |= IPSEC_OFFLOAD_AH_SHA_1;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"SHA\n"));
                }
                if (pIPSecCaps->V4AH.Transport) {
                    ai->ai_OffloadFlags |= IPSEC_OFFLOAD_AH_TPT;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"AH_TRANSPORT\n"));
                }
                if (pIPSecCaps->V4AH.Tunnel) {
                    ai->ai_OffloadFlags |= IPSEC_OFFLOAD_AH_TUNNEL;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"AH_TUNNEL\n"));
                }
                if (pIPSecCaps->V4AH.Send) {
                    ai->ai_OffloadFlags |= IPSEC_OFFLOAD_AH_XMT;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"AH_XMT\n"));
                }
                if (pIPSecCaps->V4AH.Receive) {
                    ai->ai_OffloadFlags |= IPSEC_OFFLOAD_AH_RCV;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"AH_RCV\n"));
                }
                //
                // Do V4ESP next
                //

                if (pIPSecCaps->V4ESP.DES) {
                    ai->ai_OffloadFlags |= IPSEC_OFFLOAD_ESP_DES;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ESP_DES\n"));
                }
                if (pIPSecCaps->V4ESP.RESERVED) {
                    pIPSecCaps->V4ESP.RESERVED = 0;
                    //ai->ai_OffloadFlags |= IPSEC_OFFLOAD_ESP_DES_40;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ESP_DES_40\n"));
                }
                if (pIPSecCaps->V4ESP.TRIPLE_DES) {
                    ai->ai_OffloadFlags |= IPSEC_OFFLOAD_ESP_3_DES;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ESP_3_DES\n"));
                }
                if (pIPSecCaps->V4ESP.NULL_ESP) {
                    ai->ai_OffloadFlags |= IPSEC_OFFLOAD_ESP_NONE;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ESP_NONE\n"));
                }
                if (pIPSecCaps->V4ESP.Transport) {
                    ai->ai_OffloadFlags |= IPSEC_OFFLOAD_ESP_TPT;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ESP_TRANSPORT\n"));
                }
                if (pIPSecCaps->V4ESP.Tunnel) {
                    ai->ai_OffloadFlags |= IPSEC_OFFLOAD_ESP_TUNNEL;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ESP_TUNNEL\n"));
                }
                if (pIPSecCaps->V4ESP.Send) {
                    ai->ai_OffloadFlags |= IPSEC_OFFLOAD_ESP_XMT;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ESP_XMT\n"));
                }
                if (pIPSecCaps->V4ESP.Receive) {
                    ai->ai_OffloadFlags |= IPSEC_OFFLOAD_ESP_RCV;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ESP_RCV\n"));
                }
            }
            // Point to the next offload structure

            if (tmpoffload->OffsetNextTask) {

                tmpoffload = (PNDIS_TASK_OFFLOAD)
                             ((PUCHAR) tmpoffload + tmpoffload->OffsetNextTask);

            } else {
                tmpoffload = NULL;
            }

        }                               //while

    } else {                            //if BufSize is not okay

        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"response of task offload does not have sufficient space even for 1 offload task!!\n"));

        return FALSE;

    }

    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ARP: Previous  H/W capabilities: %lx\n", PrevOffLoad));
    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ARP: Supported H/W capabilities: %lx\n", ai->ai_OffloadFlags));
    //Enable the capabilities by setting them.

    if (PrevOffLoad) {
        \
        ai->ai_OffloadFlags &= PrevOffLoad;
    }
    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ARP: Enabling H/W capabilities: %lx\n", ai->ai_OffloadFlags));

    TaskOffload->Task = 0;
    TaskOffload->OffsetNextTask = 0;

    NextTaskOffLoad = LastTaskOffload = TaskOffload;

    TotalLength = sizeof(NDIS_TASK_OFFLOAD_HEADER);

    if ((ai->ai_OffloadFlags & TCP_XMT_CHECKSUM_OFFLOAD) ||
        (ai->ai_OffloadFlags & IP_XMT_CHECKSUM_OFFLOAD) ||
        (ai->ai_OffloadFlags & TCP_RCV_CHECKSUM_OFFLOAD) ||
        (ai->ai_OffloadFlags & IP_RCV_CHECKSUM_OFFLOAD)) {

        PNDIS_TASK_TCP_IP_CHECKSUM ChksumBuf = (PNDIS_TASK_TCP_IP_CHECKSUM) & NextTaskOffLoad->TaskBuffer[0];

        NextTaskOffLoad->Task = TcpIpChecksumNdisTask;
        NextTaskOffLoad->TaskBufferLength = sizeof(NDIS_TASK_TCP_IP_CHECKSUM);

        NextTaskOffLoad->OffsetNextTask = FIELD_OFFSET(NDIS_TASK_OFFLOAD, TaskBuffer) +
                                          NextTaskOffLoad->TaskBufferLength;

        TotalLength += NextTaskOffLoad->OffsetNextTask;

        RtlZeroMemory(ChksumBuf, sizeof(NDIS_TASK_TCP_IP_CHECKSUM));

        if (ai->ai_OffloadFlags & TCP_XMT_CHECKSUM_OFFLOAD) {
            ChksumBuf->V4Transmit.TcpChecksum = 1;
            //ChksumBuf->V4Transmit.V4Checksum = 1;
        }
        if (ai->ai_OffloadFlags & IP_XMT_CHECKSUM_OFFLOAD) {
            ChksumBuf->V4Transmit.IpChecksum = 1;
            //ChksumBuf->V4Transmit.V4Checksum = 1;
        }
        if (ai->ai_OffloadFlags & TCP_RCV_CHECKSUM_OFFLOAD) {
            ChksumBuf->V4Receive.TcpChecksum = 1;
            //ChksumBuf->V4Receive.V4Checksum = 1;
        }
        if (ai->ai_OffloadFlags & IP_RCV_CHECKSUM_OFFLOAD) {
            ChksumBuf->V4Receive.IpChecksum = 1;
            //ChksumBuf->V4Receive.V4Checksum = 1;
        }
        LastTaskOffload = NextTaskOffLoad;

        NextTaskOffLoad = (PNDIS_TASK_OFFLOAD)
                          ((PUCHAR) NextTaskOffLoad + NextTaskOffLoad->OffsetNextTask);

    }
    if (ai->ai_OffloadFlags & TCP_LARGE_SEND_OFFLOAD) {

        PNDIS_TASK_TCP_LARGE_SEND TcpLargeSend, out_LargeSend = (PNDIS_TASK_TCP_LARGE_SEND) & NextTaskOffLoad->TaskBuffer[0];

        NextTaskOffLoad->Task = TcpLargeSendNdisTask;
        NextTaskOffLoad->TaskBufferLength = sizeof(NDIS_TASK_TCP_LARGE_SEND);

        NextTaskOffLoad->OffsetNextTask = FIELD_OFFSET(NDIS_TASK_OFFLOAD, TaskBuffer) + NextTaskOffLoad->TaskBufferLength;

        TotalLength += NextTaskOffLoad->OffsetNextTask;

        //(uchar)TaskOffload + sizeof(NDIS_TASK_OFFLOAD) + NextTaskOffload->TaskBufferLength;

        TcpLargeSend = &ai->ai_TcpLargeSend;

        RtlZeroMemory(out_LargeSend, sizeof(NDIS_TASK_TCP_LARGE_SEND));

        out_LargeSend->MaxOffLoadSize = TcpLargeSend->MaxOffLoadSize;
        out_LargeSend->MinSegmentCount = TcpLargeSend->MinSegmentCount;

        if (ai->ai_OffloadFlags & TCP_LARGE_SEND_TCPOPT_OFFLOAD) {
            out_LargeSend->TcpOptions = 1;
        }

        if (ai->ai_OffloadFlags & TCP_LARGE_SEND_IPOPT_OFFLOAD) {
            out_LargeSend->IpOptions = 1;
        }

        LastTaskOffload = NextTaskOffLoad;
        NextTaskOffLoad = (PNDIS_TASK_OFFLOAD)
                          ((PUCHAR) NextTaskOffLoad + NextTaskOffLoad->OffsetNextTask);

    }
    if (ai->ai_OffloadFlags & IPSEC_OFFLOAD_CRYPTO_ONLY) {

        PNDIS_TASK_IPSEC pIPSecCaps = (PNDIS_TASK_IPSEC) & NextTaskOffLoad->TaskBuffer[0];

        //
        // plunk down the advertised capabilities
        //

        RtlZeroMemory(pIPSecCaps, sizeof(NDIS_TASK_IPSEC));

        NextTaskOffLoad->Task = IpSecNdisTask;
        NextTaskOffLoad->TaskBufferLength = sizeof(NDIS_TASK_IPSEC);

        NextTaskOffLoad->OffsetNextTask = (FIELD_OFFSET(NDIS_TASK_OFFLOAD, TaskBuffer) + NextTaskOffLoad->TaskBufferLength);

        TotalLength += NextTaskOffLoad->OffsetNextTask;

        if (ai->ai_OffloadFlags & IPSEC_OFFLOAD_AH_ESP) {
            pIPSecCaps->Supported.AH_ESP_COMBINED = 1;
        }
        if (ai->ai_OffloadFlags & IPSEC_OFFLOAD_TPT_TUNNEL) {
            pIPSecCaps->Supported.TRANSPORT_TUNNEL_COMBINED = 1;
        }
        if (ai->ai_OffloadFlags & IPSEC_OFFLOAD_V4_OPTIONS) {
            pIPSecCaps->Supported.V4_OPTIONS = 1;
        }
        if (ai->ai_OffloadFlags & IPSEC_OFFLOAD_AH_MD5) {
            pIPSecCaps->V4AH.MD5 = 1;
        }
        if (ai->ai_OffloadFlags & IPSEC_OFFLOAD_AH_SHA_1) {
            pIPSecCaps->V4AH.SHA_1 = 1;
        }
        if (ai->ai_OffloadFlags & IPSEC_OFFLOAD_AH_TPT) {
            pIPSecCaps->V4AH.Transport = 1;
        }
        if (ai->ai_OffloadFlags & IPSEC_OFFLOAD_AH_TUNNEL) {
            pIPSecCaps->V4AH.Tunnel = 1;
        }
        if (ai->ai_OffloadFlags & IPSEC_OFFLOAD_AH_XMT) {
            pIPSecCaps->V4AH.Send = 1;
        }
        if (ai->ai_OffloadFlags & IPSEC_OFFLOAD_AH_RCV) {
            pIPSecCaps->V4AH.Receive = 1;
        }
        if (ai->ai_OffloadFlags & IPSEC_OFFLOAD_ESP_DES) {
            pIPSecCaps->V4ESP.DES = 1;
        }
        if (ai->ai_OffloadFlags & IPSEC_OFFLOAD_ESP_3_DES) {
            pIPSecCaps->V4ESP.TRIPLE_DES = 1;
        }
        if (ai->ai_OffloadFlags & IPSEC_OFFLOAD_ESP_NONE) {
            pIPSecCaps->V4ESP.NULL_ESP = 1;
        }
        if (ai->ai_OffloadFlags & IPSEC_OFFLOAD_ESP_TPT) {
            pIPSecCaps->V4ESP.Transport = 1;
        }
        if (ai->ai_OffloadFlags & IPSEC_OFFLOAD_ESP_TUNNEL) {
            pIPSecCaps->V4ESP.Tunnel = 1;
        }
        if (ai->ai_OffloadFlags & IPSEC_OFFLOAD_ESP_XMT) {
            pIPSecCaps->V4ESP.Send = 1;
        }
        if (ai->ai_OffloadFlags & IPSEC_OFFLOAD_ESP_RCV) {
            pIPSecCaps->V4ESP.Receive = 1;
        }
        LastTaskOffload = NextTaskOffLoad;
        NextTaskOffLoad = (PNDIS_TASK_OFFLOAD)
                          ((PUCHAR) NextTaskOffLoad + NextTaskOffLoad->OffsetNextTask);
    }
    LastTaskOffload->OffsetNextTask = 0;

    // Okay, lets set this now.

    Status = DoNDISRequest(ai, NdisRequestSetInformation,
                           OID_TCP_TASK_OFFLOAD, TaskOffloadHeader, TotalLength,
                           NULL, TRUE);

    if (Status != NDIS_STATUS_SUCCESS) {

        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Failed to enable indicated offload capabilities!!\n"));
        ai->ai_OffloadFlags = 0;

        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ARP: Failed set: %lx, status: %lx\n", ai->ai_OffloadFlags, Status));
    }
    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ARP: Enabling H/W capabilities: %lx\n", ai->ai_OffloadFlags));

    return TRUE;


}

//**QueryOffload - Query offload capabilities
//
//  Input:
//      ai - ARPInterface for which we are initializing
//           the task offload header.
//  Returns:
//      TRUE/FALSE - Success/Failure to query/set
//
BOOLEAN
QueryAndSetOffload(ARPInterface *ai)
{
    PNDIS_TASK_OFFLOAD_HEADER TaskOffloadHeader;
    uint TotalLength;
    NDIS_STATUS Status;
    BOOLEAN stat;
    uint Needed;
    uchar *buffer;

    // Query and set checksum capability

    TaskOffloadHeader = CTEAllocMemNBoot(sizeof(NDIS_TASK_OFFLOAD_HEADER), '8ICT');

    Status = STATUS_BUFFER_OVERFLOW;

    if (TaskOffloadHeader) {

        InitTaskOffloadHeader(ai, TaskOffloadHeader);

        Status = DoNDISRequest(ai, NdisRequestQueryInformation,
                               OID_TCP_TASK_OFFLOAD, TaskOffloadHeader,
                               sizeof(NDIS_TASK_OFFLOAD_HEADER),
                               &Needed, TRUE);

        // Need to initialize Needed to the real size of the buffer. The NDIS
        // call may not init on success.
        if (Status == NDIS_STATUS_SUCCESS) {
            Needed = sizeof(NDIS_TASK_OFFLOAD_HEADER);
        } else if ((Status == NDIS_STATUS_INVALID_LENGTH) ||
                   (Status == NDIS_STATUS_BUFFER_TOO_SHORT)) {

            // We know the size we need. Allocate a buffer.
            ASSERT(Needed >= sizeof(NDIS_TASK_OFFLOAD_HEADER));
            buffer = CTEAllocMemNBoot(Needed, '9ICT');

            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                      "Calling OID_TCP_TASK_OFFLOAD with %d bytes\n", Needed));

            if (buffer != NULL) {

                CTEFreeMem(TaskOffloadHeader);

                TaskOffloadHeader = (PNDIS_TASK_OFFLOAD_HEADER) buffer;
                InitTaskOffloadHeader(ai, TaskOffloadHeader);

                Status = DoNDISRequest(ai, NdisRequestQueryInformation,
                                       OID_TCP_TASK_OFFLOAD, buffer, Needed, NULL, TRUE);
            }
        }
    }
    if ((Status != NDIS_STATUS_SUCCESS)
        || (TaskOffloadHeader && TaskOffloadHeader->OffsetFirstTask == 0)) {

        //Make sure that the flag is null.
        ai->ai_OffloadFlags = 0;
        if (TaskOffloadHeader) {
            CTEFreeMem(TaskOffloadHeader);
        }
        return FALSE;

    }

    if (TaskOffloadHeader) {
        stat = SetOffload(ai, TaskOffloadHeader, Needed);
        CTEFreeMem(TaskOffloadHeader);
        return stat;
    }

    return FALSE;
}

//** ARPRegister - Register a protocol with the ARP module.
//
//  We register a protocol for ARP processing. We also open the
//  NDIS adapter here.
//
//      Note that much of the information passed in here is unused, as
//  ARP currently only works with IP.
//
//  Entry:
//      Adapter     - Name of the adapter to bind to.
//      IPContext   - Value to be passed to IP on upcalls.
//
int
ARPRegister(PNDIS_STRING Adapter, uint *Flags, struct ARPInterface **Interface)
{
    ARPInterface *ai;                   // Pointer to interface struct. for this interface.
    NDIS_STATUS Status, OpenStatus;     // Status values.
    uint i = 0;                         // Medium index.
    NDIS_MEDIUM MediaArray[MAX_MEDIA];
    uchar *buffer;                      // Pointer to our buffers.
    uint mss;
    uint speed;
    uint Needed;
    uint MacOpts;
    uchar bcastmask, bcastval, bcastoff, addrlen, hdrsize, snapsize;
    uint OID;
    uint PF;
    PNDIS_BUFFER Buffer;
    TRANSPORT_HEADER_OFFSET IPHdrOffset;
    CTELockHandle LockHandle;
    UINT MediaType;
    NDIS_STRING NdisString;

    DEBUGMSG(DBG_TRACE && DBG_PNP,
             (DTEXT("+ARPRegister(%x, %x, %x)\n"),
              Adapter, Flags, Interface));

    if ((ai = CTEAllocMemNBoot(sizeof(ARPInterface), '4ICT')) == (ARPInterface *) NULL)
        return FALSE;                   // Couldn't allocate memory for this one.

    *Interface = ai;

    RtlZeroMemory(ai, sizeof(ARPInterface));
    CTEInitTimer(&ai->ai_timer);

    ai->ai_timerstarted = FALSE;
    ai->ai_stoptimer = FALSE;

    MediaArray[MEDIA_DIX] = NdisMedium802_3;
    MediaArray[MEDIA_TR] = NdisMedium802_5;
    MediaArray[MEDIA_FDDI] = NdisMediumFddi;
    MediaArray[MEDIA_ARCNET] = NdisMediumArcnet878_2;

    // Initialize this adapter interface structure.
    ai->ai_state = INTERFACE_INIT;
    ai->ai_adminstate = IF_STATUS_DOWN;
    ai->ai_operstate = IF_OPER_STATUS_NON_OPERATIONAL;
    ai->ai_lastchange = GetTimeTicks();
    ai->ai_bcast = IP_LOCAL_BCST;
    ai->ai_atinst = ai->ai_ifinst = INVALID_ENTITY_INSTANCE;
    ai->ai_telladdrchng = 1;            //Initially let us do try to do network layer address stuff


    // Initialize the locks.
    CTEInitLock(&ai->ai_lock);
    CTEInitLock(&ai->ai_ARPTblLock);

    GetAlwaysSourceRoute(&sArpAlwaysSourceRoute, &sIPAlwaysSourceRoute);

    ArpCacheLife = GetArpCacheLife();

    if (!ArpCacheLife) {
        ArpCacheLife = 1;
    }
    ArpCacheLife = (ArpCacheLife * 1000L) / ARP_TIMER_TIME;

    ArpRetryCount = GetArpRetryCount();

    if (!ArpMinValidCacheLife) {
        ArpMinValidCacheLife = 1;
    }

    // Allocate  the buffer and packet pools.
    NdisAllocatePacketPoolEx(&Status, &ai->ai_ppool,
                             ARP_DEFAULT_PACKETS, ARP_DEFAULT_PACKETS * 1000,
                             sizeof(struct PCCommon));
    if (Status != NDIS_STATUS_SUCCESS) {
        FreeARPInterface(ai);
        return FALSE;
    }

    // Allocate the ARP table
    ai->ai_ARPTbl = (ARPTable *) CTEAllocMemNBoot(ARP_TABLE_SIZE * sizeof(ARPTableEntry*), '5ICT');
    if (ai->ai_ARPTbl == (ARPTable *) NULL) {
        FreeARPInterface(ai);
        return FALSE;
    }
    //
    // NULL out the pointers
    //
    RtlZeroMemory(ai->ai_ARPTbl, ARP_TABLE_SIZE * sizeof(ARPTableEntry *));

    CTEInitBlockStruc(&ai->ai_block);

    DEBUGMSG(DBG_INFO && DBG_PNP,
             (DTEXT("ARPRegister calling NdisOpenAdapter\n")));

    // Open the NDIS adapter.
    NdisOpenAdapter(&Status, &OpenStatus, &ai->ai_handle, &i, MediaArray,
                    MAX_MEDIA, ARPHandle, ai, Adapter, 0, NULL);

    // Block for open to complete.
    if (Status == NDIS_STATUS_PENDING)
        Status = (NDIS_STATUS) CTEBlock(&ai->ai_block);

    ai->ai_media = MediaArray[i];       // Fill in media type.

    // Open adapter completed. If it succeeded, we'll finish our intialization.
    // If it failed, bail out now.
    if (Status != NDIS_STATUS_SUCCESS) {
        ai->ai_handle = NULL;
        FreeARPInterface(ai);
        return FALSE;
    }
#if FFP_SUPPORT
    // Store NIC driver handle
    NdisGetDriverHandle(ai->ai_handle, &ai->ai_driver);
#endif

    // Read the local address.
    switch (ai->ai_media) {
    case NdisMedium802_3:
        addrlen = ARP_802_ADDR_LENGTH;
        bcastmask = ENET_BCAST_MASK;
        bcastval = ENET_BCAST_VAL;
        bcastoff = ENET_BCAST_OFF;
        OID = OID_802_3_CURRENT_ADDRESS;
        hdrsize = sizeof(ENetHeader);
        if (!UseEtherSNAP(Adapter)) {
            snapsize = 0;
        } else {
            snapsize = sizeof(SNAPHeader);
        }

        PF = NDIS_PACKET_TYPE_BROADCAST | \
             NDIS_PACKET_TYPE_DIRECTED | \
             NDIS_PACKET_TYPE_MULTICAST;

        ai->ai_mediatype = IF_TYPE_IS088023_CSMACD;

        break;

    case NdisMedium802_5:
        addrlen = ARP_802_ADDR_LENGTH;
        bcastmask = TR_BCAST_MASK;
        bcastval = TR_BCAST_VAL;
        bcastoff = TR_BCAST_OFF;
        OID = OID_802_5_CURRENT_ADDRESS;
        hdrsize = sizeof(TRHeader);
        snapsize = sizeof(SNAPHeader);
        PF = NDIS_PACKET_TYPE_BROADCAST | NDIS_PACKET_TYPE_DIRECTED;

        ai->ai_mediatype = IF_TYPE_ISO88025_TOKENRING;

        break;
    case NdisMediumFddi:
        addrlen = ARP_802_ADDR_LENGTH;
        bcastmask = FDDI_BCAST_MASK;
        bcastval = FDDI_BCAST_VAL;
        bcastoff = FDDI_BCAST_OFF;
        OID = OID_FDDI_LONG_CURRENT_ADDR;
        hdrsize = sizeof(FDDIHeader);
        snapsize = sizeof(SNAPHeader);

        PF = NDIS_PACKET_TYPE_BROADCAST | \
             NDIS_PACKET_TYPE_DIRECTED | \
             NDIS_PACKET_TYPE_MULTICAST;

        ai->ai_mediatype = IF_TYPE_FDDI;

        break;

    case NdisMediumArcnet878_2:
        addrlen = 1;
        bcastmask = ARC_BCAST_MASK;
        bcastval = ARC_BCAST_VAL;
        bcastoff = ARC_BCAST_OFF;
        OID = OID_ARCNET_CURRENT_ADDRESS;
        hdrsize = sizeof(ARCNetHeader);
        snapsize = 0;
        PF = NDIS_PACKET_TYPE_BROADCAST | NDIS_PACKET_TYPE_DIRECTED;

        ai->ai_mediatype = IF_TYPE_ARCNET;

        break;

    default:
        ASSERT(0);
        FreeARPInterface(ai);
        return FALSE;
    }

    ai->ai_bcastmask = bcastmask;
    ai->ai_bcastval = bcastval;
    ai->ai_bcastoff = bcastoff;
    ai->ai_addrlen = addrlen;
    ai->ai_hdrsize = hdrsize;
    ai->ai_snapsize = snapsize;
    ai->ai_pfilter = PF;

    Status = DoNDISRequest(ai, NdisRequestQueryInformation, OID,
                           ai->ai_addr, addrlen, NULL, TRUE);

    if (Status != NDIS_STATUS_SUCCESS) {
        FreeARPInterface(ai);
        return FALSE;
    }

    // Read the maximum frame size.
    if ((Status = DoNDISRequest(ai, NdisRequestQueryInformation,
                                OID_GEN_MAXIMUM_FRAME_SIZE, &mss, sizeof(mss), NULL, TRUE)) != NDIS_STATUS_SUCCESS) {
        FreeARPInterface(ai);
        return FALSE;
    }
    // If this is token ring, figure out the RC len stuff now.
    mss -= (uint) ai->ai_snapsize;

    if (ai->ai_media == NdisMedium802_5) {
        mss -= (sizeof(RC) + (ARP_MAX_RD * sizeof(ushort)));
    } else {
        if (ai->ai_media == NdisMediumFddi) {
            mss = MIN(mss, ARP_FDDI_MSS);
        }
    }

    ai->ai_mtu = (ushort) mss;

    // Read the speed for local purposes.
    if ((Status = DoNDISRequest(ai, NdisRequestQueryInformation,
                                OID_GEN_LINK_SPEED, &speed, sizeof(speed), NULL, TRUE)) == NDIS_STATUS_SUCCESS) {
        ai->ai_speed = speed * 100L;
    }

    // Read and save the options.
    Status = DoNDISRequest(ai, NdisRequestQueryInformation, OID_GEN_MAC_OPTIONS,
                           &MacOpts, sizeof(MacOpts), NULL, TRUE);

    if (Status != NDIS_STATUS_SUCCESS) {
        *Flags = 0;
    } else {
        *Flags = (MacOpts & NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA) ? LIP_COPY_FLAG : 0;
    }

    if (CTEMemCmp(ai->ai_addr, PPP_HW_ADDR, PPP_HW_ADDR_LEN) == 0) {
        *Flags = *Flags | LIP_P2P_FLAG;
    }

    //
    // Query the media capability to determine if it is a uni-directional adapter.
    //

    Status = DoNDISRequest(
        ai,
        NdisRequestQueryInformation,
        OID_GEN_MEDIA_CAPABILITIES,
        &MediaType,
        sizeof(MediaType),
        NULL,
        TRUE); // Blocking.

    if (Status == NDIS_STATUS_SUCCESS) {
        // Bit field of Rx and Tx. If only Rx, set uni flag.
        if (MediaType == NDIS_MEDIA_CAP_RECEIVE) {
            DEBUGMSG(DBG_WARN,
                (DTEXT("ARPRegister: ai %x: MEDIA_CAP_RX -> UniAdapter!!\n"), ai));
            *Flags |= LIP_UNI_FLAG;
            InterlockedIncrement(&cUniAdapters);
        }
    }

    // Read and store the vendor description string.
    Status = NdisQueryAdapterInstanceName(&NdisString, ai->ai_handle);

    if (Status == NDIS_STATUS_SUCCESS) {
        ANSI_STRING AnsiString;

        // Convert the string to ANSI, and use the new ANSI string's buffer
        // to store the description in the ARP interface.
        // N.B. The conversion results in a nul-terminated string.

        Status = RtlUnicodeStringToAnsiString(&AnsiString, &NdisString, TRUE);
        if (Status == STATUS_SUCCESS) {
            ai->ai_desc = AnsiString.Buffer;
            ai->ai_desclen = strlen(AnsiString.Buffer) + 1;
        }
        NdisFreeString(NdisString);
    }

    if (!ArpEnetHeaderPool || !ArpAuxHeaderPool) {
        PVOID SectionHandle;
        // Allocate our small and big buffer pools.  Take the interface list
        // lock simply to protect creating of the buffer pools if we haven't
        // already done so.  We could have used our own lock, but the interface
        // list lock is global, and not already used in this path.
        //

        // This routine is in pageable memory.  Since getting the lock
        // requires writable access to LockHandle at DISPATCH, we need to
        // lock this code in.
        //

        SectionHandle = MmLockPagableCodeSection(ARPRegister);
        CTEGetLock(&ArpInterfaceListLock.Lock, &LockHandle);

        if (!ArpEnetHeaderPool) {
            ArpEnetHeaderPool = MdpCreatePool(BUFSIZE_ENET_HEADER_POOL, 'ehCT');
        }

        if (!ArpAuxHeaderPool) {
            ArpAuxHeaderPool = MdpCreatePool(BUFSIZE_AUX_HEADER_POOL, 'ahCT');
        }

        CTEFreeLock(&ArpInterfaceListLock.Lock, LockHandle);
        MmUnlockPagableImageSection(SectionHandle);

        if (!ArpAuxHeaderPool || !ArpEnetHeaderPool) {
            FreeARPInterface(ai);
            return FALSE;
        }
    }

    ai->ai_promiscuous = 0;

#if FFP_SUPPORT
    {
        FFPVersionParams Version =
        {
            NDIS_PROTOCOL_ID_TCP_IP, 0
        };

        // Initialize all FFP Handling Variables
        ai->ai_ffpversion = 0;
        ai->ai_ffplastflush = 0;

        // Query FFP Handling capabilities
        Status = DoNDISRequest(ai, NdisRequestQueryInformation,
                               OID_FFP_SUPPORT, &Version, sizeof(FFPVersionParams), NULL, TRUE);

        TCPTRACE(("Querying FFP capabilities: Status = %08x, Version = %lu\n",
                  Status,
                  Version.FFPVersion));

        // Non-Zero Value indicates FFP support
        if (Version.FFPVersion) {
            // Set the FFP startup parameters
            FFPSupportParams Info =
            {
                NDIS_PROTOCOL_ID_TCP_IP,
                FFPRegFastForwardingCacheSize,
                FFPRegControlFlags
            };

            // But store away the version first
            ai->ai_ffpversion = Version.FFPVersion;

            DoNDISRequest(ai, NdisRequestSetInformation,
                          OID_FFP_SUPPORT, &Info, sizeof(FFPSupportParams), NULL, TRUE);

            TCPTRACE(("Setting FFP capabilities: Cache Size = %lu, Flags = %08x\n",
                      Info.FastForwardingCacheSize,
                      Info.FFPControlFlags));
        }
    }
#endif // if FFP_SUPPORT

    ai->ai_OffloadFlags = 0;

    if (DisableTaskOffload) {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Taskoffload disabled\n"));
    } else {

       if(!QueryAndSetOffload(ai)){
           DEBUGMSG(DBG_ERROR, (DTEXT("ARP: Query and set offload failed.\n")));
       }
    }

    // query the wakeup capabilities.
    Status = DoNDISRequest(
                          ai,
                          NdisRequestQueryInformation,
                          OID_PNP_CAPABILITIES,
                          &ai->ai_wakeupcap,
                          sizeof(NDIS_PNP_CAPABILITIES),
                          NULL, TRUE);
    if (Status == NDIS_STATUS_SUCCESS) {
        uint wakeup = NDIS_PNP_WAKE_UP_PATTERN_MATCH;
        // enable wakeup capabilities.
        Status = DoNDISRequest(
                              ai,
                              NdisRequestSetInformation,
                              OID_PNP_ENABLE_WAKE_UP,
                              &wakeup,
                              sizeof(wakeup),
                              NULL, TRUE);
        if (Status != NDIS_STATUS_SUCCESS) {
            ai->ai_wakeupcap.WakeUpCapabilities.MinPatternWakeUp = NdisDeviceStateUnspecified;
        }
    }
    // Store the device name, we need to pass this to our TDI clients when
    // we do the PNP notification.
    if ((ai->ai_devicename.Buffer = CTEAllocMemNBoot(Adapter->MaximumLength, 'aICT')) == NULL) {
        FreeARPInterface(ai);
        return FALSE;
    }
    RtlCopyMemory(ai->ai_devicename.Buffer, Adapter->Buffer, Adapter->MaximumLength);
    ai->ai_devicename.Length = Adapter->Length;
    ai->ai_devicename.MaximumLength = Adapter->MaximumLength;

    ai->ai_timerstarted = TRUE;

    IPHdrOffset.HeaderOffset = ai->ai_snapsize + ai->ai_hdrsize;
    IPHdrOffset.ProtocolType = NDIS_PROTOCOL_ID_TCP_IP;

    Status = DoNDISRequest(ai, NdisRequestSetInformation, OID_GEN_TRANSPORT_HEADER_OFFSET,
                           &IPHdrOffset, sizeof(TRANSPORT_HEADER_OFFSET), NULL, TRUE);

    // Everything's set up, so get the ARP timer running.
    CTEStartTimer(&ai->ai_timer, ARP_TIMER_TIME, ARPTimeout, ai);

    return TRUE;

}

#pragma END_INIT

//*     ARPDynRegister - Dynamically register IP.
//
//      Called by IP when he's about done binding to register with us. Since we
//      call him directly, we don't save his info here. We do keep his context
//      and index number.
//
//      Input:  See ARPRegister
//
//      Returns: Nothing.
//
int
__stdcall
ARPDynRegister(
              IN PNDIS_STRING Adapter,
              IN void *IPContext,
              IN struct _IP_HANDLERS *IpHandlers,
              OUT struct LLIPBindInfo *Info,
              IN uint NumIFBound)
{
    ARPInterface *Interface = (ARPInterface *) Info->lip_context;

    Interface->ai_context = IPContext;
    Interface->ai_index = NumIFBound;

    // TCPTRACE(("Arp Interface %lx ai_context %lx ai_index %lx\n",Interface, Interface->ai_context, Interface->ai_index));
    return TRUE;
}

//*     ARPBindAdapter - Bind and initialize an adapter.
//
//      Called in a PNP environment to initialize and bind an adapter. We open
//      the adapter and get it running, and then we call up to IP to tell him
//      about it. IP will initialize, and if all goes well call us back to start
//      receiving.
//
//      Input:  RetStatus               - Where to return the status of this call.
//              BindContext             - Handle to use for calling BindAdapterComplete.
//                              AdapterName             - Pointer to name of adapter.
//                              SS1                                             - System specific 1 parameter.
//                              SS2                                             - System specific 2 parameter.
//
//      Returns: Nothing.
//
void NDIS_API
ARPBindAdapter(PNDIS_STATUS RetStatus, NDIS_HANDLE BindContext,
               PNDIS_STRING AdapterName, PVOID SS1, PVOID SS2)
{
    uint Flags;                         // MAC binding flags.
    ARPInterface *Interface;            // Newly created interface.
    PNDIS_STRING ConfigName;            // Name used by IP for config. info.
    IP_STATUS Status;                   // State of IPAddInterface call.
    LLIPBindInfo BindInfo;              // Binding information for IP.
    NDIS_HANDLE Handle;
    NDIS_STRING IPConfigName;

    DEBUGMSG(DBG_TRACE && DBG_PNP,
             (DTEXT("+ARPBindAdapter(%x, %x, %x, %x, %x)\n"),
              RetStatus, BindContext, AdapterName, SS1, SS2));

    if (!OpenIFConfig(SS1, &Handle)) {
        *RetStatus = NDIS_STATUS_FAILURE;
        DEBUGMSG(DBG_ERROR && DBG_PNP, (DTEXT("ARPBindAdapter: Open failure\n")));
        DEBUGMSG(DBG_TRACE && DBG_PNP, (DTEXT("-ARPBindAdapter [%x]\n"), *RetStatus));
        return;
    }

#if !MILLEN
    if ((*RetStatus = GetIPConfigValue(Handle, &IPConfigName)) != NDIS_STATUS_SUCCESS) {
        CloseIFConfig(Handle);
        DEBUGMSG(DBG_ERROR && DBG_PNP, (DTEXT("ARPBindAdapter: GetIPConfigValue failure\n")));
        DEBUGMSG(DBG_TRACE && DBG_PNP, (DTEXT("-ARPBindAdapter [%x]\n"), *RetStatus));
        return;
    }
#endif // !MILLEN

    CloseIFConfig(Handle);

    // First, open the adapter and get the info.
    if (!ARPRegister(AdapterName, &Flags, &Interface)) {

#if !MILLEN
        CTEFreeMem(IPConfigName.Buffer);
#endif // !MILLEN

        *RetStatus = NDIS_STATUS_FAILURE;
        DEBUGMSG(DBG_ERROR && DBG_PNP, (DTEXT("ARPBindAdapter: ARPRegister failure\n")));
        DEBUGMSG(DBG_TRACE && DBG_PNP, (DTEXT("-ARPBindAdapter [%x]\n"), *RetStatus));
        return;
    }

    // OK, we're opened the adapter. Call IP to tell him about it.
    BindInfo.lip_context = Interface;
    BindInfo.lip_transmit = ARPTransmit;
    BindInfo.lip_transfer = ARPXferData;
    BindInfo.lip_close = ARPClose;
    BindInfo.lip_addaddr = ARPAddAddr;
    BindInfo.lip_deladdr = ARPDeleteAddr;
    BindInfo.lip_invalidate = ARPInvalidate;
    BindInfo.lip_open = ARPOpen;
    BindInfo.lip_qinfo = ARPQueryInfo;
    BindInfo.lip_setinfo = ARPSetInfo;
    BindInfo.lip_getelist = ARPGetEList;
    BindInfo.lip_dondisreq = DoNDISRequest;

    BindInfo.lip_mss = Interface->ai_mtu;
    BindInfo.lip_speed = Interface->ai_speed;
    BindInfo.lip_flags = Flags;
    BindInfo.lip_addrlen = Interface->ai_addrlen;
    BindInfo.lip_addr = Interface->ai_addr;
    BindInfo.lip_dowakeupptrn = DoWakeupPattern;
    BindInfo.lip_pnpcomplete = ARPPnPComplete;
    BindInfo.lip_setndisrequest = ARPSetNdisRequest;
    BindInfo.lip_arpresolveip = ARPResolveIP;
    BindInfo.lip_arpflushate = ARPFlushATE;
    BindInfo.lip_arpflushallate = ARPFlushAllATE;
#if !MILLEN
    BindInfo.lip_cancelpackets = ARPCancelPackets;
#endif


#if FFP_SUPPORT
    // NDIS Driver Handle, FFP Version are passed up
    // [ Non zero version implies FFP Support exists ]
    BindInfo.lip_ffpversion = Interface->ai_ffpversion;
    BindInfo.lip_ffpdriver = (ULONG_PTR) Interface->ai_driver;
#endif

    //Interface capability is passed on to IP via BindInfo

    BindInfo.lip_OffloadFlags = Interface->ai_OffloadFlags;
    BindInfo.lip_MaxOffLoadSize = (uint) Interface->ai_TcpLargeSend.MaxOffLoadSize;
    BindInfo.lip_MaxSegments = (uint) Interface->ai_TcpLargeSend.MinSegmentCount;
    BindInfo.lip_closelink = NULL;
    BindInfo.lip_pnpcap = Interface->ai_wakeupcap.Flags;

    DEBUGMSG(DBG_INFO && DBG_PNP,
             (DTEXT("ARPBindAdapter calling IPAddInterface.\n")));

    Status = IPAddInterface(AdapterName,
                            NULL,
#if MILLEN
                            (PNDIS_STRING) SS1,
#else // MILLEN
                            (PNDIS_STRING) & IPConfigName,
#endif // !MILLEN
                            SS2,
                            Interface,
                            ARPDynRegister,
                            &BindInfo,
                            0,
                            Interface->ai_mediatype,
                            IF_ACCESS_BROADCAST,
                            IF_CONNECTION_DEDICATED);

#if !MILLEN
    CTEFreeMem(IPConfigName.Buffer);
#endif // !MILLEN

    if (Status != IP_SUCCESS) {
        // Need to close the binding. FreeARPInterface will do that, as well
        // as freeing resources.

        DEBUGMSG(DBG_ERROR && DBG_PNP,
                 (DTEXT("ARPBindAdapter: IPAddInterface failure %x\n"), Status));

        FreeARPInterface(Interface);
        *RetStatus = NDIS_STATUS_FAILURE;
    } else {
        //
        // Insert into ARP IF list
        //
        ExInterlockedInsertTailList(&ArpInterfaceList,
                                    &Interface->ai_linkage,
                                    &ArpInterfaceListLock.Lock);
        *RetStatus = NDIS_STATUS_SUCCESS;
    }

    DEBUGMSG(DBG_TRACE && DBG_PNP, (DTEXT("-ARPBindAdapter [%x]\n"), *RetStatus));
}

//*   ARPUnbindAdapter - Unbind from an adapter.
//
//    Called when we need to unbind from an adapter. We'll call up to IP to tell
//    him. When he's done, we'll free our memory and return.
//
//   Input:  RetStatus               - Where to return status from call.
//           ProtBindContext - The context we gave NDIS earlier - really a
//                                       pointer to an ARPInterface structure.
//           UnbindContext   - Context for completeing this request.
//
//      Returns: Nothing.
//
void NDIS_API
ARPUnbindAdapter(PNDIS_STATUS RetStatus, NDIS_HANDLE ProtBindContext,
                 NDIS_HANDLE UnbindContext)
{
    ARPInterface *Interface = (ARPInterface *) ProtBindContext;
    NDIS_STATUS Status;                 // Status of close call.
    CTELockHandle LockHandle;

    // Shut him up, so we don't get any more frames.
    Interface->ai_pfilter = 0;
    if (Interface->ai_handle != NULL) {
        DoNDISRequest(Interface, NdisRequestSetInformation,
                      OID_GEN_CURRENT_PACKET_FILTER, &Interface->ai_pfilter, sizeof(uint),
                      NULL, TRUE);
    }
    CTEInitBlockStrucEx(&Interface->ai_timerblock);
    Interface->ai_stoptimer = TRUE;

    // Mark him as down.
    Interface->ai_state = INTERFACE_DOWN;
    Interface->ai_adminstate = IF_STATUS_DOWN;

#if FFP_SUPPORT
    // Stop FFP on this interface
    Interface->ai_ffpversion = 0;
#endif

    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Flushing all ates %x\n", Interface));
    ARPFlushAllATE(Interface);

    // Now tell IP he's gone. We need to make sure that we don't tell him twice.
    // To do this we set the context to NULL after we tell him the first time,
    // and we check to make sure it's non-NULL before notifying him.

    if (Interface->ai_context != NULL) {
        IPDelInterface(Interface->ai_context, TRUE);
        Interface->ai_context = NULL;
    }
    // Finally, close him. We do this here so we can return a valid status.

    CTEGetLock(&Interface->ai_lock, &LockHandle);

    if (Interface->ai_handle != NULL) {
        NDIS_HANDLE Handle = Interface->ai_handle;

        CTEFreeLock(&Interface->ai_lock, LockHandle);

        CTEInitBlockStruc(&Interface->ai_block);
        NdisCloseAdapter(&Status, Handle);

        // Block for close to complete.
        if (Status == NDIS_STATUS_PENDING) {
            Status = (NDIS_STATUS) CTEBlock(&Interface->ai_block);
        }
        Interface->ai_handle = NULL;
    } else {
        CTEFreeLock(&Interface->ai_lock, LockHandle);
        Status = NDIS_STATUS_SUCCESS;
    }

    //Check if are called from ARPUnload

    if ((ARPInterface *) UnbindContext != Interface) {
        CTELockHandle Handle;
        //No. Acquire lock and remove entry.
        CTEGetLock(&ArpInterfaceListLock.Lock, &Handle);
        RemoveEntryList(&Interface->ai_linkage);
        CTEFreeLock(&ArpInterfaceListLock.Lock, Handle);
    }

    *RetStatus = Status;

    if (Status == NDIS_STATUS_SUCCESS) {
        FreeARPInterface(Interface);
    }
}

extern ulong VIPTerminate;

//* ARPUnloadProtocol - Unload.
//
//      Called when we need to unload. All we do is call up to IP, and return.
//
//      Input:  Nothing.
//
//      Returns: Nothing.
//
void NDIS_API
ARPUnloadProtocol(void)
{
    NDIS_STATUS Status;

#if MILLEN
    DEBUGMSG(1, (DTEXT("ARPUnloadProtocol called! What to do???\n")));
#endif // MILLEN
}

VOID
ArpUnload(IN PDRIVER_OBJECT DriverObject)
/*++

Routine Description:

    This routine unloads the TCPIP stack.
    It unbinds from any NDIS drivers that are open and frees all resources
    associated with the transport. The I/O system will not call us until
    nobody above has IPX open.

    NOTE: Also, since other ARP modules depend on IP, they are unloaded before
    out unload handler is called. We concern ourselves with the LAN arp
    only at this point

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    None. When the function returns, the driver is unloaded.

--*/
{
    PLIST_ENTRY pEntry;
    CTELockHandle LockHandle;
    NTSTATUS status;
    ARPInterface *Interface;

    //
    // Walk the list of opened ARP interfaces, issuing
    // PnP deletes on each in turn.
    //
    CTEGetLock(&ArpInterfaceListLock.Lock, &LockHandle);

    while(!IsListEmpty(&ArpInterfaceList)) {
        pEntry = ArpInterfaceList.Flink;
        Interface = STRUCT_OF(ARPInterface, pEntry, ai_linkage);
        RemoveEntryList(&Interface->ai_linkage);
        CTEFreeLock(&ArpInterfaceListLock.Lock, LockHandle);
        // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Issuing unbind on %lx\n", Interface));
        ARPUnbindAdapter(&status, Interface, Interface);
        CTEGetLock(&ArpInterfaceListLock.Lock, &LockHandle);
    }

    CTEFreeLock(&ArpInterfaceListLock.Lock, LockHandle);

    MdpDestroyPool(ArpEnetHeaderPool);
    MdpDestroyPool(ArpAuxHeaderPool);

    //
    // Deal with any residual events/timers
    // Only one timer sits at this layer: ai_timer, which is stopped
    // on the unbind above.
    //

    //
    // call into IP so it can cleanup.
    //
    IPUnload(DriverObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipv4\arp.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

//** ARP.H - Exports from ARP.
//
// This file contains the public definitons from ARP.
int ARPInit(void);

int ARPRegister(PNDIS_STRING Adapter, uint *Flags,
                struct ARPInterface **Interface);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipv4\ffp.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    ffp.h

Abstract:

    Structures used in controlling the
    Fast Forwarding Path (FFP)
    functionality in network drivers.

Author:

    Chaitanya Kodeboyina (chaitk)  30-Sep-1998

Environment:

    Kernel Mode

Revision History:

--*/

#ifndef _FFP_H
#define _FFP_H

//
// CacheEntryTypes for OID_FFP_SEED
//

#define FFP_DISCARD_PACKET        -1 // -ve cache entry  - packet discarded
#define FFP_INDICATE_PACKET        0 // invalid entry - packet passed to xport
#define FFP_FORWARD_PACKET        +1 // +ve cache entry - packet forwarded

//
// Input format for various NDIS OIDs
// used in controlling FFP operation
//

//
// RequestInfo for OID_FFP_SUPPORT query
//
typedef    struct _FFPVersionParams {
    ULONG          NdisProtocolType;
    ULONG          FFPVersion;
}   FFPVersionParams;

//
// RequestInfo for OID_FFP_SUPPORT set
//
typedef    struct _FFPSupportParams {
    ULONG          NdisProtocolType;
    ULONG          FastForwardingCacheSize;
    ULONG          FFPControlFlags;
}   FFPSupportParams;

//
// RequestInfo for OID_FFP_FLUSH set
//
typedef struct _FFPFlushParams {
    ULONG          NdisProtocolType;
}   FFPFlushParams;

//
// RequestInfo for OID_FFP_CONTROL query/set
//
typedef    struct _FFPControlParams {
    ULONG          NdisProtocolType;
    ULONG          FFPControlFlags;
}   FFPControlParams;

//
// RequestInfo for OID_FFP_PARAMS query/set
//
typedef    struct _FFPCacheParams {
    ULONG          NdisProtocolType;
    ULONG          FastForwardingCacheSize;
}   FFPCacheParams;

//
// RequestInfo for OID_FFP_SEED query/set
//
typedef struct _FFPDataParams {
    ULONG          NdisProtocolType;
    LONG           CacheEntryType;
    ULONG          HeaderSize;
    union {
        UCHAR       Header[1];
        struct {
            IPHeader Header;
            ULONG    DwordAfterHeader;
        }           IpHeader;
    };
}   FFPDataParams;


//
// RequestInfo for OID_FFP_IFSTATS query/reset
// [ used to get per adapter FF statistics ]
//

/*
InPacketsForwarded refers to the number of packets
received on this adapter that were forwarded out
on another adapter, 
and
OutPacketsForwarded refer to the number of packets
received on another adapter and forwarded out on
on this adapter.
*/

typedef struct _FFPAdapterStats {
    ULONG          NdisProtocolType; 
    ULONG          InPacketsForwarded;
    ULONG          InOctetsForwarded;
    ULONG          InPacketsDiscarded;
    ULONG          InOctetsDiscarded;
    ULONG          InPacketsIndicated;
    ULONG          InOctetsIndicated;
    ULONG          OutPacketsForwarded;
    ULONG          OutOctetsForwarded;
}   FFPAdapterStats;


//
// RequestInfo for OID_FFP_GLSTATS query/reset
// [ used to get global Fast Forwarding stats ]
//

/*
PacketsForwarded refers to the number of packets
forwarded out in the fast path,
and
PacketsDiscarded refers to the number of packets
discarded on the fast path, 
and
PacketsIndicated refers to the number of packets
that were indicated to transport.
*/

typedef struct _FFPDriverStats {
    ULONG          NdisProtocolType;
    ULONG          PacketsForwarded;
    ULONG          OctetsForwarded;
    ULONG          PacketsDiscarded;
    ULONG          OctetsDiscarded;
    ULONG          PacketsIndicated;
    ULONG          OctetsIndicated;
}   FFPDriverStats;

#endif // _FFP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipv4\debug.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Debug macros for the ARP module

Revision History:


Notes:

--*/

#ifndef __RT_DEBUG_H__
#define __RT_DEBUG_H__

VOID
RtInitializeDebug();

//
// Tags for Pools
//

#define GROUP_TAG   'gmPI'
#define SOURCE_TAG  'smPI'
#define OIF_TAG     'omPI'
#define MSG_TAG     'mmPI'
#define FREE_TAG    'fmPI'

//
// File signatures for everyone
//

#define DEBUG_SIG   'gbed'
#define INI_SIG     'tini'
#define IOCT_SIG    'tcoi'
#define MFE_SIG     'efmm'
#define FWD_SIG     'dwfm'
#define TMR_SIG     'rmit'

//
// We use the RT_XXX_DEBUG flags so that we can force to
// different debug modes on free builds by changing sources.
// On a checked build, all debugging is on
//

#if DBG

#ifndef RT_TRACE_DEBUG
#define RT_TRACE_DEBUG  1
#endif

#ifndef RT_LOCK_DEBUG
#define RT_LOCK_DEBUG   1
#endif

#ifndef RT_ASSERT_ON
#define RT_ASSERT_ON    1
#endif

#ifndef RT_MEM_DEBUG
#define RT_MEM_DEBUG    1
#endif

#else // DBG

#ifndef RT_TRACE_DEBUG
#define RT_TRACE_DEBUG  0
#endif

#ifndef RT_LOCK_DEBUG
#define RT_LOCK_DEBUG   0
#endif

#ifndef RT_ASSERT_ON
#define RT_ASSERT_ON    0
#endif

#ifndef RT_MEM_DEBUG
#define RT_MEM_DEBUG    0
#endif

#endif // DBG


#if RT_ASSERT_ON

#define RtAssert(X)                                             \
{                                                               \
    if(!(X))                                                    \
    {                                                           \
        DbgPrint("[IPMCAST] Assertion failed in %s at line %d\n",\
                 __FILE__,__LINE__);                            \
        DbgPrint("IPMCAST: Assertion " #X "\n");                 \
        DbgBreakPoint();                                        \
    }                                                           \
}

#else   // RT_ASSERT_ON

#define RtAssert(X)

#endif


#if RT_TRACE_DEBUG

BYTE    g_byDebugLevel;
DWORD   g_fDebugComp;


#define MCAST_STREAM_GLOBAL         0x00000001
#define MCAST_STREAM_SEND           0x00000002
#define MCAST_STREAM_RCV            0x00000004
#define MCAST_STREAM_MFE            0x00000008
#define MCAST_STREAM_MEMORY         0x00000010
#define MCAST_STREAM_IF             0x00000020
#define MCAST_STREAM_FWD            0x00000040
#define MCAST_STREAM_TMR            0x00000080

#define RT_DBG_LEVEL_NONE           0xFF
#define RT_DBG_LEVEL_FATAL          0xF0
#define RT_DBG_LEVEL_ERROR          0xE0
#define RT_DBG_LEVEL_WARN           0xD0
#define RT_DBG_LEVEL_INFO           0xC0
#define RT_DBG_LEVEL_TRACE          0xB0

#define Trace(Stream, Level, Str)                   \
{                                                   \
    if ((RT_DBG_LEVEL_##Level >= RT_DBG_LEVEL_ERROR) ||             \
        ((RT_DBG_LEVEL_##Level >= g_byDebugLevel) &&                    \
         ((g_fDebugComp & MCAST_STREAM_##Stream) == MCAST_STREAM_##Stream)))\
    {                                               \
        DbgPrint("[IPMCAST] ");                      \
        DbgPrint Str;                               \
    }                                               \
}

#define TraceEnter(Stream, Str) Trace(Stream, TRACE, ("Entering "Str"\n"))
#define TraceLeave(Stream, Str) Trace(Stream, TRACE, ("Leaving "Str"\n"))

#else   // RT_TRACE_DEBUG

#define Trace(Stream, Level, Str)

#define TraceEnter(Stream, Str)
#define TraceLeave(Stream, Str)

#endif // RT_TRACE_DEBUG



#if RT_LOCK_DEBUG

extern KSPIN_LOCK  g_ksLockLock;

#ifndef __FILE_SIG__
#error File signature not defined
#endif

typedef struct _RT_LOCK
{
	ULONG		ulLockSig;
	BOOLEAN     bAcquired;
	PKTHREAD    pktLastThread;
	ULONG       ulFileSig;
	ULONG		ulLineNumber;
	KSPIN_LOCK  kslLock;
}RT_LOCK, *PRT_LOCK;


VOID
RtpInitializeSpinLock(
    IN  PRT_LOCK    pLock,
    IN  ULONG       ulFileSig,
    IN  ULONG       ulLineNumber
    );

VOID
RtpAcquireSpinLock(
    IN  PRT_LOCK    pLock,
    OUT PKIRQL      pkiIrql,
    IN  ULONG       ulFileSig,
    IN  ULONG       ulLineNumber,
    IN  BOOLEAN     bAtDpc
    );

VOID
RtpReleaseSpinLock(
    IN  PRT_LOCK    pLock,
    IN  KIRQL       kiIrql,
    IN  ULONG       ulFileSig,
    IN  ULONG       ulLineNumber,
    IN  BOOLEAN     bFromDpc
    );

#define RT_LOCK_SIG	'KCOL'


#define RtInitializeSpinLock(X)        RtpInitializeSpinLock((X), __FILE_SIG__, __LINE__)

#define RtAcquireSpinLock(X, Y)        RtpAcquireSpinLock((X), (Y), __FILE_SIG__, __LINE__, FALSE)

#define RtAcquireSpinLockAtDpcLevel(X) RtpAcquireSpinLock((X), NULL, __FILE_SIG__, __LINE__, TRUE)

#define RtReleaseSpinLock(X, Y)        RtpReleaseSpinLock((X), (Y), __FILE_SIG__, __LINE__, FALSE)

#define RtReleaseSpinLockFromDpcLevel(X) RtpReleaseSpinLock((X), 0, __FILE_SIG__, __LINE__, TRUE)


#else   // RT_LOCK_DEBUG


typedef KSPIN_LOCK  RT_LOCK, *PRT_LOCK;

#define RtInitializeSpinLock          KeInitializeSpinLock
#define RtAcquireSpinLock             KeAcquireSpinLock
#define RtAcquireSpinLockAtDpcLevel   KeAcquireSpinLockAtDpcLevel
#define RtReleaseSpinLock             KeReleaseSpinLock
#define RtReleaseSpinLockFromDpcLevel KeReleaseSpinLockFromDpcLevel


#endif	// RT_LOCK_DEBUG





#if RT_MEM_DEBUG


#ifndef __FILE_SIG__
#error File signature not defined
#endif

//
// Memory Allocation/Freeing Audit:
//

//
// The RT_ALLOCATION structure stores all info about one allocation
//

typedef struct _RT_ALLOCATION
{
    LIST_ENTRY  leLink;
    ULONG       ulMemSig;
    ULONG       ulFileSig;
    ULONG       ulLineNumber;
    ULONG       ulSize;
    UCHAR		pucData[1];
}RT_ALLOCATION, *PRT_ALLOCATION;

//
// The RT_FREE structure stores info about an allocation
// that was freed. Later if the memory is touched, the
// free list can be scanned to see where the allocation was
// freed
//

typedef struct _RT_FREE
{
    LIST_ENTRY  leLink;
    ULONG_PTR   ulStartAddr;
    ULONG       ulSize;
    ULONG       ulMemSig;
    ULONG       ulAllocFileSig;
    ULONG       ulAllocLineNumber;
    ULONG       ulFreeFileSig;
    ULONG       ulFreeLineNumber;
}RT_FREE, *PRT_FREE;


#define RT_MEMORY_SIG     'YRMM'
#define RT_FREE_SIG       'EERF'

PVOID
RtpAllocate(
    IN POOL_TYPE    ptPool,
	IN ULONG	    ulSize,
    IN ULONG        ulTag,
	IN ULONG	    ulFileSig,
	IN ULONG	    ulLineNumber
    );

VOID
RtpFree(
	PVOID	pvPointer,
    IN ULONG	    ulFileSig,
	IN ULONG	    ulLineNumber
    );

VOID
RtAuditMemory();

#define RtAllocate(X, Y, Z)   RtpAllocate((X), (Y), (Z), __FILE_SIG__, __LINE__)
#define RtFree(X)             RtpFree((X), __FILE_SIG__, __LINE__)



#else // RT_MEM_DEBUG



#define RtAllocate    ExAllocatePoolWithTag
#define RtFree        ExFreePool

#define RtAuditMemory()



#endif // RT_MEM_DEBUG




#endif // __RT_DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipv4\ftrie.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ftrie.h

Abstract:

    This module contains support definitions for 
    an F-trie data stucture, that forms the fast
    path in a fast IP route lookup implementation.

Author:

    Chaitanya Kodeboyina (chaitk)   26-Nov-1997

Revision History:

--*/
#ifndef FTRIE_H_INCLUDED
#define FTRIE_H_INCLUDED

#include "trie.h"

//
// Constants
//

// State of the trie
#define    NORMAL                        0
#define    PARTIAL                       1

//
// Structs
//

// A Node in an F-Trie
typedef struct _FTrieNode FTrieNode;

struct _FTrieNode
{
    LIST_ENTRY  linkage;                // Linkage into list of nodes on the F-Trie
    Dest       *comDest;                // Dest for this subtree's common prefix
    UINT        numDests;               // Number of dests in this node's subtree
    UINT        numBits;                // Number of addr bits to get to children
    FTrieNode  *child[0];               // Child Node (Or) Info Ptr Array [Var Len]
};

// An FTrie Data Structure
typedef struct _FTrie FTrie;

struct _FTrie
{
    FTrieNode   *trieRoot;              // Pointer to the root of the FTrie

    ULONG        availMemory;           // Memory available for allocation
    LIST_ENTRY   listofNodes;           // List of nodes allocated on FTrie
    
    UINT         numLevels;             // Total num of levels in the FTrie
    UINT        *bitsInLevel;           // Num of index bits in each level

    UINT        *numDestsInOrigLevel;   // Num of dests in each original level
    UINT        *numNodesInExpnLevel;   // Num of nodes in each expanded level
    UINT        *numDestsInExpnLevel;   // Num of dests in each expanded level
};

// Specific Dest Macros

#define  StoreDestPtr(_p_)     (FTrieNode *) ((ULONG_PTR) _p_ + 1)
#define  RestoreDestPtr(_p_)   (Dest *)      ((ULONG_PTR) _p_ - 1)
#define  IsPtrADestPtr(_p_)    (BOOLEAN)     ((ULONG_PTR) _p_ & 1)

#define  ReplaceDestPtr(_pNewDest_, _pOldDest_, _ppDest_)                       \
                                if (*_ppDest_ == _pOldDest_)                    \
                                {                                               \
                                    *_ppDest_ = _pNewDest_;                     \
                                }                                               \

// Specific FTrieNode Macros

#define  NewFTrieNode(_pFTrie_, _pFTrieNode_, _numBits_, _pDest_)               \
                                {                                               \
                                    UINT __i;                                   \
                                    UINT __numChild = 1 << _numBits_;           \
                                    UINT __numBytes = sizeof(FTrieNode) +       \
                                                    __numChild * sizeof(PVOID); \
                                                                                \
                                    if (_numBits_ > 7*sizeof(PVOID))            \
                                    {                                           \
                                         Recover("Unable to Allocate Memory",   \
                                                     ERROR_TRIE_RESOURCES);     \
                                    }                                           \
                                                                                \
                                    AllocMemory2(_pFTrieNode_,                  \
                                                 __numBytes,                    \
                                                 _pFTrie_->availMemory);        \
                                                                                \
                                    InsertHeadList(&_pFTrie_->listofNodes,      \
                                                   &_pFTrieNode_->linkage);     \
/*                                                                              \
                                    DbgPrint("Allocating FTNode @ %08x\n",      \
                                                 _pFTrieNode_);                 \
*/                                                                              \
                                    _pFTrieNode_->numDests = 0;                 \
                                                                                \
                                    _pFTrieNode_->comDest = _pDest_;            \
                                                                                \
                                    _pFTrieNode_->numBits = _numBits_;          \
                                                                                \
                                    for (__i = 0; __i < __numChild; __i++)      \
                                    {                                           \
                                         _pFTrieNode_->child[__i] =             \
                                                      StoreDestPtr(NULL);       \
                                    }                                           \
                                }                                               \

#define  FreeFTrieNode(_pFTrie_, _pFTrieNode_)                                  \
                                {                                               \
                                    UINT __numChild = 1 << _pFTrieNode_->numBits;\
                                    UINT __numBytes = sizeof(FTrieNode) +       \
                                                    __numChild * sizeof(PVOID); \
                                                                                \
                                    RemoveEntryList(&_pFTrieNode_->linkage);    \
/*                                                                              \
                                    DbgPrint("Freeing FTNode @ %08x\n",         \
                                                 _pFTrieNode_);                 \
*/                                                                              \
                                    FreeMemory1(_pFTrieNode_,                   \
                                               __numBytes,                      \
                                               _pFTrie_->availMemory);          \
                                }                                               \


// Prototypes
UINT
CALLCONV
InitFTrie                       (IN     FTrie    *pFTrie,
                                 IN     ULONG     levels,
                                 IN     ULONG     maxMemory);

UINT
CALLCONV
InsertIntoFTrie                 (IN     FTrie    *pFTrie,
                                 IN     Route    *pInsRoute,
                                 IN     Dest     *pInsDest,
                                 IN     Dest     *pOldDest);

UINT
CALLCONV
DeleteFromFTrie                 (IN     FTrie    *pFTrie,
                                 IN     Route    *pDelRoute,
                                 IN     Dest     *pDelDest,
                                 IN     Dest     *pNewDest,
                                 IN     BOOLEAN   trieState);

UINT
CALLCONV
SearchDestInFTrie               (IN     FTrie    *pFTrie,
                                 IN     Dest     *pSerDest,
                                 OUT    UINT     *pNumPtrs,
                                 OUT    Dest    **pStartPtr);

Dest *
CALLCONV
SearchAddrInFTrie               (IN     FTrie    *pFTrie,
                                 IN     ULONG     Addr);

UINT
CALLCONV
CleanupFTrie                    (IN     FTrie    *pFTrie);

#if DBG

VOID
CALLCONV
PrintFTrie                      (IN     FTrie    *pFTrie,
                                 IN     UINT      fPrintAll);

VOID
CALLCONV 
PrintFTrieNode                  (IN     FTrieNode *pFTrieNode,
                                 IN     UINT      levelNumber);

#endif // DBG

#endif // FTRIE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipv4\arpdef.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

//***   arpdef.h - ARP definitions
//
//  This file containes all of the private ARP related definitions.


#define MEDIA_DIX       0
#define MEDIA_TR        1
#define MEDIA_FDDI      2
#define MEDIA_ARCNET    3
#define MAX_MEDIA       4

#define INTERFACE_UP    0                   // Interface is up.
#define INTERFACE_INIT  1                   // Interface is initializing.
#define INTERFACE_DOWN  2                   // Interface is down.

#define LOOKAHEAD_SIZE  128                 // A reasonable lookahead size

// Definitions for state of an ATE. The 'RESOLVING' indicators must occur first.
#define ARP_RESOLVING_LOCAL     0           // Address is being resolved (on local ring, if TR)
#define ARP_RESOLVING_GLOBAL    1           // Address is being resolved globally.
#define ARP_RESOLVING ARP_RESOLVING_GLOBAL
#define ARP_GOOD            2               // ATE is good.
#define ARP_BAD             3               // ATE is bad.
#define ARP_FLOOD_RATE      1000L           // No more than once a second.
#define ARP_802_ADDR_LENGTH 6               // Length of an 802 address.

#define MIN_ETYPE           0x600           // Minimum valid Ethertype
#define SNAP_SAP            170
#define SNAP_UI             3


//* Structure of an Ethernet header.
typedef struct ENetHeader {
    uchar       eh_daddr[ARP_802_ADDR_LENGTH];
    uchar       eh_saddr[ARP_802_ADDR_LENGTH];
    ushort      eh_type;
} ENetHeader;

//* Structure of a token ring header.
typedef struct TRHeader {
    uchar       tr_ac;
    uchar       tr_fc;
    uchar       tr_daddr[ARP_802_ADDR_LENGTH];
    uchar       tr_saddr[ARP_802_ADDR_LENGTH];
} TRHeader;

#define ARP_AC      0x10
#define ARP_FC      0x40
#define TR_RII      0x80

typedef struct RC {
    uchar   rc_blen;                    // Broadcast indicator and length.
    uchar   rc_dlf;                     // Direction and largest frame.
} RC;
#define RC_DIR      0x80
#define RC_LENMASK  0x1f
#define RC_SRBCST   0xc2                    // Single route broadcast RC.
#define RC_ARBCST   0x82                    // All route broadcast RC.
#define RC_LMASK    0x1F                    // Mask for length field for route
                                            // information
#define RC_LEN      0x2                     // Length to put in the length bits
                                            // when sending source routed
                                            // frames
#define RC_BCST_LEN 0x70                    // Length for a broadcast.
#define RC_LF_MASK  0x70                    // Mask for length bits.

//* Structure of source routing information.
typedef struct SRInfo {
    RC      sri_rc;                         // Routing control info.
    ushort  sri_rd[1];                      // Routing designators.
} SRInfo;

#define ARP_MAX_RD      8

//* Structure of an FDDI header.
typedef struct FDDIHeader {
    uchar       fh_pri;
    uchar       fh_daddr[ARP_802_ADDR_LENGTH];
    uchar       fh_saddr[ARP_802_ADDR_LENGTH];
} FDDIHeader;

#define ARP_FDDI_PRI    0x57
#define ARP_FDDI_MSS    4352

//* Structure of an ARCNET header.
typedef struct ARCNetHeader {
    uchar       ah_saddr;
    uchar       ah_daddr;
    uchar       ah_prot;
} ARCNetHeader;

//* Structure of a SNAP header.
typedef struct SNAPHeader {
    uchar       sh_dsap;
    uchar       sh_ssap;
    uchar       sh_ctl;
    uchar       sh_protid[3];
    ushort      sh_etype;
} SNAPHeader;

#define ARP_MAX_MEDIA_ENET  sizeof(ENetHeader)
#define ARP_MAX_MEDIA_TR    (sizeof(TRHeader)+sizeof(RC)+(ARP_MAX_RD*sizeof(ushort))+sizeof(SNAPHeader))
#define ARP_MAX_MEDIA_FDDI  (sizeof(FDDIHeader)+sizeof(SNAPHeader))
#define ARP_MAX_MEDIA_ARC   sizeof(ARCNetHeader)

#define ENET_BCAST_MASK     0x01
#define TR_BCAST_MASK       0x80
#define FDDI_BCAST_MASK     0x01
#define ARC_BCAST_MASK      0xff

#define ENET_BCAST_VAL      0x01
#define TR_BCAST_VAL        0x80
#define FDDI_BCAST_VAL      0x01
#define ARC_BCAST_VAL       0x00

#define ENET_BCAST_OFF      0x00
#define TR_BCAST_OFF        offsetof(struct TRHeader, tr_daddr)
#define FDDI_BCAST_OFF      offsetof(struct FDDIHeader, fh_daddr)
#define ARC_BCAST_OFF       offsetof(struct ARCNetHeader, ah_daddr)

typedef void (*ArpRtn)(void *, IP_STATUS Status);

typedef struct ARPControlBlock {
   struct ARPControlBlock  *next;
   ArpRtn CompletionRtn;
   ulong status;
   ulong  PhyAddrLen;
   ulong *PhyAddr;

} ARPControlBlock;


//* Structure of an ARP table entry.
typedef struct ARPTableEntry {
    struct ARPTableEntry    *ate_next;      // Next ATE in hash chain
    ulong                   ate_valid;      // Last time ATE was known to be valid.
    IPAddr                  ate_dest;       // IP address represented.
    PNDIS_PACKET            ate_packet;     // Packet (if any) queued for resolution
    RouteCacheEntry         *ate_rce;       // List of RCEs that reference this ATE.
    DEFINE_LOCK_STRUCTURE(ate_lock)         // Lock for this ATE.
    uint                    ate_useticks;   // Number of ticks left until this
                                            // goes away.
    uchar                   ate_addrlength; // Length of the address.
    uchar                   ate_state;      // State of this entry
    ulong                   ate_userarp;    // added to facilitate user api ARP reauests
    ARPControlBlock         *ate_resolveonly;// This field points ARP control block(s)
    uint                    ate_refresh;     //refresh arp entries before timeingout
    uchar                   ate_addr[1];    // Address that maps to dest
} ARPTableEntry;

#define ALWAYS_VALID        0xffffffff

//* Structure of the ARP table.
#define ARP_TABLE_SIZE      64
#define ARP_HASH(x)         ((((uchar *)&(x))[3] + ((uchar *)&(x))[2] + ((uchar *)&(x))[1] + ((uchar *)&(x))[0]) % ARP_TABLE_SIZE)

typedef ARPTableEntry   *ARPTable[];

//* List structure for local representation of an IPAddress.
typedef struct ARPIPAddr {
    struct ARPIPAddr        *aia_next;      // Next in list.
    uint                    aia_age;
    IPAddr                  aia_addr;       // The address.
    IPMask                  aia_mask;
    void                    *aia_context;
} ARPIPAddr;

#define ARPADDR_NOT_LOCAL   4
#define ARPADDR_NEW_LOCAL   3
#define ARPADDR_OLD_LOCAL   0

//* List structure for Proxy-ARP addresses.
typedef struct ARPPArpAddr {
    struct ARPPArpAddr      *apa_next;      // Next in list.
    IPAddr                  apa_addr;       // The address.
    IPMask                  apa_mask;       // And the mask.
} ARPPArpAddr;

//* List structure for a multicast IP address.
typedef struct ARPMCastAddr {
    struct ARPMCastAddr     *ama_next;      // Next in list.
    IPAddr                  ama_addr;       // The (masked) address.
    uint                    ama_refcnt;     // Reference count for this address.
} ARPMCastAddr;

#define ARP_MCAST_MASK      0xffff7f00

#define ARP_TIMER_TIME          1000L
#define ARP_RESOLVE_TIMEOUT     1000L
#define ARP_MIN_VALID_TIMEOUT   600000L
#define ARP_REFRESH_TIME        2000L

#if FFP_SUPPORT
#define FFP_ARP_FLUSH_INTERVAL  300 // Time (in s) after which ARP forces an FFP
                                    // flush (inorder to keep the ARP cache and
                                    // FFP's MAC Addr mapping in limited sync)
#endif

typedef struct ARPNotifyStruct {
    CTEEvent                ans_event;
    uint                    ans_shutoff;
    IPAddr                  ans_addr;
    uint                    ans_hwaddrlen;
    uchar                   ans_hwaddr[1];
} ARPNotifyStruct;

//* Structure of information we keep on a per-interface basis.
typedef struct ARPInterface {
    LIST_ENTRY              ai_linkage;     // to link into ARP interface list
    void                    *ai_context;    // Upper layer context info.
#if FFP_SUPPORT
    NDIS_HANDLE             ai_driver;      // NDIS Miniport/MAC driver handle
#endif
    NDIS_HANDLE             ai_handle;      // NDIS bind handle.
    NDIS_MEDIUM             ai_media;       // Media type.
    NDIS_HANDLE             ai_ppool;       // Handle for packet pool.
    DEFINE_LOCK_STRUCTURE(ai_lock)          // Lock for this structure.
    DEFINE_LOCK_STRUCTURE(ai_ARPTblLock)    // ARP Table lock for this structure.
    ARPTable                *ai_ARPTbl;     // Pointer to the ARP table for this interface
    ARPIPAddr               ai_ipaddr;      // Local IP address list.
    ARPPArpAddr             *ai_parpaddr;   // Proxy ARP address list.
    IPAddr                  ai_bcast;       // Broadcast mask for this interface.
    // SNMP required counters
    uint                    ai_inoctets;    // Input octets.
    uint                    ai_inpcount[3]; // Count of nonunicast, unicast & promiscuous
                                            // packets received.
    uint                    ai_outoctets;   // Output octets
    uint                    ai_outpcount[2];// Count of nonunicast and unicast
                                            // packets sent.
    uint                    ai_qlen;        // Output q length.
    uchar                   ai_addr[ARP_802_ADDR_LENGTH]; // Local HW address.
    uchar                   ai_state;       // State of the interface. Union of
                                            // admin and operational states.
    uchar                   ai_addrlen;     // Length of ai_addr.
    uchar                   ai_bcastmask;   // Mask for checking unicast.
    uchar                   ai_bcastval;    // Value to check against.
    uchar                   ai_bcastoff;    // Offset in frame to check against.
    uchar                   ai_hdrsize;     // Size of 'typical' header.
    uchar                   ai_snapsize;    // Size of snap header, if any.
    uchar                   ai_pad[2];      // PAD PAD
    uint                    ai_pfilter;     // Packet filter for this i/f.
    uint                    ai_count;       // Number of entries in the ARPTable.
    uint                    ai_parpcount;   // Number of proxy ARP entries.
    CTETimer                ai_timer;       // ARP timer for this interface.

    BOOLEAN                 ai_timerstarted;// ARP timer started for this interface?
    BOOLEAN                 ai_stoptimer;   // ARP timer started for this interface?
    CTEBlockStruc           ai_timerblock;  // used to sync stopping the interface timer

    CTEBlockStruc           ai_block;       // Structure for blocking on.
    ushort                  ai_mtu;         // MTU for this interface.
    uchar                   ai_adminstate;  // Admin state.
    uchar                   ai_operstate;   // Operational state;
    uint                    ai_speed;       // Speed.
    uint                    ai_lastchange;  // Last change time.
    uint                    ai_indiscards;  // In discards.
    uint                    ai_inerrors;    // Input errors.
    uint                    ai_uknprotos;   // Unknown protocols received.
    uint                    ai_outdiscards; // Output packets discarded.
    uint                    ai_outerrors;   // Output errors.
    uint                    ai_desclen;     // Length of desc. string.
    uint                    ai_index;       // Global I/F index ID.
    uint                    ai_atinst;      // AT instance number.
    uint                    ai_ifinst;      // IF instance number.
    char                    *ai_desc;       // Descriptor string.
    ARPMCastAddr            *ai_mcast;      // Multicast list.
    uint                    ai_mcastcnt;    // Count of elements on mcast list.
    uint                    ai_ipaddrcnt;   // number of local address on this
    uint                    ai_telladdrchng;// tell link layer about addr change? (for psched)
    ULONG                   ai_mediatype;
    uint                    ai_promiscuous; // promiscuous mode or not.
#if FFP_SUPPORT
    ulong                   ai_ffpversion;  // The version of FFP in use (0 implies no support)
    uint                    ai_ffplastflush;// Number of timer ticks since arp's last FFP flush
#endif
    ARPNotifyStruct         *ai_conflict;
    uint                    ai_delay;
    uint                    ai_OffloadFlags;// H/W checksum capability flag
    NDIS_TASK_TCP_LARGE_SEND ai_TcpLargeSend;
    NDIS_PNP_CAPABILITIES   ai_wakeupcap;   // wakeup capabilities.
    NDIS_STRING             ai_devicename;  // Name of the device.
} ARPInterface;


//* NOTE: These two values MUST stay at 0 and 1.
#define AI_UCAST_INDEX      0
#define AI_NONUCAST_INDEX   1
#define AI_PROMIS_INDEX     2

#define ARP_DEFAULT_PACKETS 10

//* Structure of information passed as context in RCE.
typedef struct ARPContext {
    RouteCacheEntry     *ac_next;       // Next RCE in ARP table chain.
    ARPTableEntry       *ac_ate;        // Back pointer to ARP table entry.
} ARPContext;

typedef struct IPNMEContext {
    uint                inc_index;
    ARPTableEntry       *inc_entry;
} IPNMEContext;

#include <packon.h>
// Structure of an ARP header.
typedef struct ARPHeader {
    ushort      ah_hw;                      // Hardware address space.
    ushort      ah_pro;                     // Protocol address space.
    uchar       ah_hlen;                    // Hardware address length.
    uchar       ah_plen;                    // Protocol address length.
    ushort      ah_opcode;                  // Opcode.
    uchar       ah_shaddr[ARP_802_ADDR_LENGTH]; // Source HW address.
    IPAddr      ah_spaddr;                  // Source protocol address.
    uchar       ah_dhaddr[ARP_802_ADDR_LENGTH]; // Destination HW address.
    IPAddr      ah_dpaddr;                  // Destination protocol address.
} ARPHeader;
#include <packoff.h>

#define ARP_ETYPE_IP    0x800
#define ARP_ETYPE_ARP   0x806
#define ARP_REQUEST     1
#define ARP_RESPONSE    2
#define ARP_HW_ENET     1
#define ARP_HW_802      6
#define ARP_HW_ARCNET   7

#define ARP_ARCPROT_ARP 0xd5
#define ARP_ARCPROT_IP  0xd4

// The size we need to back off the buffer length because ARCNet address
// are one bytes instead of six.
#define ARCNET_ARPHEADER_ADJUSTMENT     10

typedef struct _AddAddrNotifyEvent {
    CTEEvent        Event;
    SetAddrControl  *SAC;
    IPAddr          Address;
    IP_STATUS       Status;
} AddAddrNotifyEvent;


// Compute the length of the wakeup pattern mask based on the length
// of the pattern. See NET_PM_WAKEUP_PATTERN_DESC.
//
__inline
UINT
GetWakeupPatternMaskLength(
    IN UINT Ptrnlen)
{
    return (Ptrnlen - 1)/8 + 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipv4\debug.c ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Debug functions

Revision History:

    AmritanR

--*/

#include "precomp.h"

#define __FILE_SIG__    DEBUG_SIG

#include "ipmcast.h"

#define PRINT_BYTES(x) (UCHAR)x,(UCHAR)(x>>8),(UCHAR)(x>>16),(UCHAR)(x>>24)

#if RT_LOCK_DEBUG

KSPIN_LOCK g_kslLockLock;

#endif

#if RT_MEM_DEBUG

RT_LOCK g_rlMemoryLock;
LIST_ENTRY g_leAllocMemListHead;
LIST_ENTRY g_leFreeMemListHead;

#endif

VOID
RtInitializeDebug()
{

#if RT_TRACE_DEBUG

    g_byDebugLevel = RT_DBG_LEVEL_WARN;
    //g_byDebugLevel  = 0x00;
    g_fDebugComp = 0xFFFFFFFF;

#endif

#if RT_LOCK_DEBUG

    KeInitializeSpinLock(&(g_kslLockLock));

#endif

#if RT_MEM_DEBUG

    RtInitializeSpinLock(&g_rlMemoryLock);

    InitializeListHead(&g_leAllocMemListHead);
    InitializeListHead(&g_leFreeMemListHead);

#endif

}

#if RT_LOCK_DEBUG

VOID
RtpInitializeSpinLock(
                      IN PRT_LOCK pLock,
                      IN ULONG ulFileSig,
                      IN ULONG ulLineNumber
                      )
{
    pLock->ulLockSig = RT_LOCK_SIG;
    pLock->ulFileSig = 0;
    pLock->ulLineNumber = 0;
    pLock->bAcquired = 0;
    pLock->pktLastThread = (PKTHREAD) NULL;

    KeInitializeSpinLock(&(pLock->kslLock));
}

VOID
RtpAcquireSpinLock(
                   IN PRT_LOCK pLock,
                   OUT PKIRQL pkiIrql,
                   IN ULONG ulFileSig,
                   IN ULONG ulLineNumber,
                   IN BOOLEAN bAtDpc
                   )
{
    PKTHREAD pThread;
    KIRQL kiInternalIrql;

    pThread = KeGetCurrentThread();

    if (bAtDpc) {
        kiInternalIrql = KeGetCurrentIrql();

        if (kiInternalIrql isnot DISPATCH_LEVEL) {
            DbgPrint("RTDBG: Called AcquireSpinLockAtDpc for lock at 0x%x when not at DISPATCH. File %c%c%c%c, Line %d\n",
                     pLock,
                     PRINT_BYTES(ulFileSig),
                     ulLineNumber);

            DbgBreakPoint();
        }
    }
    KeAcquireSpinLock(&(g_kslLockLock),
                      &kiInternalIrql);

    if (pLock->ulLockSig isnot RT_LOCK_SIG) {
        DbgPrint("RTDBG: Trying to acquire uninited lock 0x%x, File %c%c%c%c, Line %d\n",
                 pLock,
                 (CHAR) (ulFileSig & 0xff),
                 (CHAR) ((ulFileSig >> 8) & 0xff),
                 (CHAR) ((ulFileSig >> 16) & 0xff),
                 (CHAR) ((ulFileSig >> 24) & 0xff),
                 ulLineNumber);

        DbgBreakPoint();
    }
    if (pLock->bAcquired isnot 0) {
        if (pLock->pktLastThread is pThread) {
            DbgPrint("RTDBG: Detected recursive locking!: pLock 0x%x, File %c%c%c%c, Line %d\n",
                     pLock,
                     PRINT_BYTES(ulFileSig),
                     ulLineNumber);

            DbgPrint("RTDBG: pLock 0x%x already acquired in File %c%c%c%c, Line %d\n",
                     pLock,
                     PRINT_BYTES(pLock->ulFileSig),
                     pLock->ulLineNumber);

            DbgBreakPoint();
        }
    }
    KeReleaseSpinLock(&(g_kslLockLock),
                      kiInternalIrql);

    if (bAtDpc) {
        KeAcquireSpinLockAtDpcLevel(&(pLock->kslLock));
    } else {
        KeAcquireSpinLock(&(pLock->kslLock),
                          pkiIrql);
    }

    //
    //  Mark this lock.
    //

    pLock->pktLastThread = pThread;
    pLock->ulFileSig = ulFileSig;
    pLock->ulLineNumber = ulLineNumber;
    pLock->bAcquired = TRUE;
}

VOID
RtpReleaseSpinLock(
                   IN PRT_LOCK pLock,
                   IN KIRQL kiIrql,
                   IN ULONG ulFileSig,
                   IN ULONG ulLineNumber,
                   IN BOOLEAN bFromDpc
                   )
{
    if (pLock->ulLockSig isnot RT_LOCK_SIG) {
        DbgPrint("RTDBG: Trying to release uninited lock 0x%x, File %c%c%c%c, Line %d\n",
                 pLock,
                 PRINT_BYTES(ulFileSig),
                 ulLineNumber);
        DbgBreakPoint();
    }
    if (pLock->bAcquired is 0) {
        DbgPrint("RTDBG: Detected release of unacquired lock 0x%x, File %c%c%c%c, Line %d\n",
                 pLock,
                 PRINT_BYTES(ulFileSig),
                 ulLineNumber);

        DbgBreakPoint();
    }
    pLock->ulFileSig = ulFileSig;
    pLock->ulLineNumber = ulLineNumber;
    pLock->bAcquired = FALSE;
    pLock->pktLastThread = (PKTHREAD) NULL;

    if (bFromDpc) {
        KeReleaseSpinLockFromDpcLevel(&(pLock->kslLock));
    } else {
        KeReleaseSpinLock(&(pLock->kslLock),
                          kiIrql);
    }
}

#endif // RT_LOCK_DEBUG

#if RT_MEM_DEBUG

PVOID
RtpAllocate(
            IN POOL_TYPE ptPool,
            IN ULONG ulSize,
            IN ULONG ulTag,
            IN ULONG ulFileSig,
            IN ULONG ulLineNumber
            )
{
    PVOID pBuffer;
    PRT_ALLOCATION pwaAlloc;
    KIRQL kiIrql;

    pwaAlloc = ExAllocatePoolWithTag(ptPool,
                                     ulSize + sizeof(RT_ALLOCATION),
                                     ulTag);

    if (pwaAlloc is NULL) {
        Trace(MEMORY, ERROR,
              ("Failed to allocate %d bytes in file %c%c%c%c, line %d\n",
               ulSize, PRINT_BYTES(ulFileSig), ulLineNumber));

        pBuffer = NULL;
    } else {
        pBuffer = (PVOID) & (pwaAlloc->pucData);

        pwaAlloc->ulMemSig = RT_MEMORY_SIG;
        pwaAlloc->ulFileSig = ulFileSig;
        pwaAlloc->ulLineNumber = ulLineNumber;
        pwaAlloc->ulSize = ulSize;

        RtAcquireSpinLock(&(g_rlMemoryLock), &kiIrql);

        InsertHeadList(&g_leAllocMemListHead,
                       &(pwaAlloc->leLink));

        RtReleaseSpinLock(&g_rlMemoryLock, kiIrql);
    }

    return pBuffer;

}

VOID
RtpFree(
        PVOID pvPointer,
        IN ULONG ulFileSig,
        IN ULONG ulLineNumber
        )
{
    PRT_ALLOCATION pwaAlloc;
    KIRQL kiIrql;
    PRT_FREE pFree;

    pwaAlloc = CONTAINING_RECORD(pvPointer, RT_ALLOCATION, pucData);

    if (pwaAlloc->ulMemSig is RT_FREE_SIG) {
        DbgPrint("RTDBG: Trying to free memory that is already freed. Pointer0x%x, File %c%c%c%c, Line %d. Was freed at File %c%c%c%c, Line %d. \n",
                 pvPointer,
                 PRINT_BYTES(ulFileSig),
                 ulLineNumber,
                 PRINT_BYTES(pwaAlloc->ulFileSig),
                 pwaAlloc->ulLineNumber);

        return;
    }
    if (pwaAlloc->ulMemSig isnot RT_MEMORY_SIG) {
        DbgPrint("RTDBG: Trying to free memory whose signature is wrong. Pointer 0x%x\n",
                 pvPointer);

        DbgBreakPoint();

        return;
    }
    //
    // create a warp free block for it
    //

    pFree = ExAllocatePoolWithTag(NonPagedPool,
                                  sizeof(RT_FREE),
                                  FREE_TAG);

    RtAssert(pFree);

    //
    // Take the lock so that no one else touches the list
    //

    RtAcquireSpinLock(&(g_rlMemoryLock), &kiIrql);

    RemoveEntryList(&(pwaAlloc->leLink));

    pFree->ulMemSig = RT_FREE_SIG;
    pFree->ulAllocFileSig = pwaAlloc->ulFileSig;
    pFree->ulAllocLineNumber = pwaAlloc->ulLineNumber;
    pFree->ulFreeFileSig = ulFileSig;
    pFree->ulFreeLineNumber = ulLineNumber;
    pFree->ulStartAddr = (ULONG_PTR) (pwaAlloc->pucData);
    pFree->ulSize = pwaAlloc->ulSize;

    pwaAlloc->ulMemSig = RT_FREE_SIG;
    pwaAlloc->ulFileSig = ulFileSig;
    pwaAlloc->ulLineNumber = ulLineNumber;

    ExFreePool(pwaAlloc);

    InsertTailList(&g_leFreeMemListHead,
                   &(pFree->leLink));

    RtReleaseSpinLock(&(g_rlMemoryLock), kiIrql);
}

VOID
RtAuditMemory()
{
    PRT_ALLOCATION pwaAlloc;
    PLIST_ENTRY pleNode;
    PRT_FREE pFree;

    while (!IsListEmpty(&g_leAllocMemListHead)) {
        pleNode = RemoveHeadList(&g_leAllocMemListHead);

        pwaAlloc = CONTAINING_RECORD(pleNode, RT_ALLOCATION, leLink);

        if (pwaAlloc->ulMemSig is RT_MEMORY_SIG) {
            DbgPrint("RTDBG: Unfreed memory. %d bytes. Pointer 0x%x, File %c%c%c%c, Line %d\n",
                     pwaAlloc->ulSize,
                     pwaAlloc->pucData,
                     PRINT_BYTES(pwaAlloc->ulFileSig),
                     pwaAlloc->ulLineNumber);

            DbgBreakPoint();

            ExFreePool(pwaAlloc);

            continue;
        }
        DbgPrint("RTDBG: Allocation with bad signature. Pointer 0x%x\n",
                 pwaAlloc->pucData);

        DbgBreakPoint();

        continue;
    }

    while (!IsListEmpty(&g_leFreeMemListHead)) {
        pleNode = RemoveHeadList(&g_leFreeMemListHead);

        pFree = CONTAINING_RECORD(pleNode, RT_FREE, leLink);

        if (pFree->ulMemSig is RT_FREE_SIG) {
            ExFreePool(pFree);

            continue;
        }
        DbgPrint("RTDBG: Freed memory with bad signature.\n");

        DbgBreakPoint();
    }

}

#endif

#if IF_REFERENCE_DEBUG

uint
DbgLockedReferenceIF(
            IN Interface *RefIF,
            IN uchar *File,
            IN uint Line
            )
/*++

Routine Description:

    Increases the reference count of a IF and records a history of who
    made the call to reference.

Arguments:

    RefIF  - The IF to reference.
    File   - The filename containing the calling fcn (output of the __FILE__ macro).
    Line   - The line number of the call to this fcn (output of the __LINE__ macro).

Return Value:

    Reference count 

--*/
{
    void *CallersCaller;
    IF_REFERENCE_HISTORY *RefHistory;

    RefHistory = &RefIF->if_refhistory[RefIF->if_refhistory_index];
    RefHistory->File = File;
    RefHistory->Line = Line;
    RtlGetCallersAddress(&RefHistory->Caller, &CallersCaller);
    RefHistory->Count = ++RefIF->if_refcount;
    RefIF->if_refhistory_index = ++RefIF->if_refhistory_index % MAX_IFREFERENCE_HISTORY;

    return RefIF->if_refcount;

}


uint
DbgDereferenceIF(
              IN Interface *DerefIF,
              IN uchar *File,
              IN uint Line
              )
/*++

Routine Description:

    Lock, Dereference the interface and records a history of who made the call to dereference.

Arguments:

    DerefIF        - The IF to dereference.
    File           - The filename containing the calling fcn (output of the __FILE__ macro).
    Line           - The line number of the call to this fcn (output of the __LINE__ macro).

Return Value:
    Original reference count

--*/
{
    void *Caller;
    IF_REFERENCE_HISTORY *RefHistory;
    CTELockHandle RouteTableHandle;
    uint RefCount;

    CTEGetLock(&RouteTableLock.Lock, &RouteTableHandle);
    RefHistory = &DerefIF->if_refhistory[DerefIF->if_refhistory_index];
    RefHistory->File = File;
    RefHistory->Line = Line;
    RtlGetCallersAddress(&Caller, &RefHistory->Caller);
    RefCount = DerefIF->if_refcount;
    RefHistory->Count = --DerefIF->if_refcount;
    DerefIF->if_refhistory_index = ++DerefIF->if_refhistory_index % MAX_IFREFERENCE_HISTORY;
    CTEFreeLock(&RouteTableLock.Lock, RouteTableHandle);

    return RefCount;

}

uint
DbgLockedDereferenceIF(
              IN Interface *DerefIF,
              IN uchar *File,
              IN uint Line
              )
/*++

Routine Description:

    Dereference the interface and records a history of who made the call to dereference.

Arguments:

    DerefIF        - The IF to dereference.
    File           - The filename containing the calling fcn (output of the __FILE__ macro).
    Line           - The line number of the call to this fcn (output of the __LINE__ macro).

Return Value:
    Reference count

--*/
{
    void *Caller;
    IF_REFERENCE_HISTORY *RefHistory;
    uint RefCount;

    RefHistory = &DerefIF->if_refhistory[DerefIF->if_refhistory_index];
    RefHistory->File = File;
    RefHistory->Line = Line;
    RtlGetCallersAddress(&Caller, &RefHistory->Caller);
    RefCount = DerefIF->if_refcount;
    RefHistory->Count = --DerefIF->if_refcount;
    DerefIF->if_refhistory_index = ++DerefIF->if_refhistory_index % MAX_IFREFERENCE_HISTORY;

    return RefCount;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipv4\ftrie.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    ftrie.c

Abstract:

    This module contains routines that manipulate
    an F-trie data stucture, that forms the fast
    path in a fast IP route lookup implementation.

Author:

    Chaitanya Kodeboyina (chaitk)   26-Nov-1997

Revision History:

--*/

#include "precomp.h"
#include "ftrie.h"

UINT
CALLCONV
InitFTrie(IN FTrie * pFTrie,
          IN ULONG levels,
          IN ULONG maxMemory)
/*++

Routine Description:

    Initialises an F-trie. This should be done prior to
    any other trie operations.

Arguments:

    pFTrie - Pointer to the trie to be initialized
    levels - Bitmap [ 32 bits ] of expanded levels
    maxMemory - Limit on memory taken by the F-Trie

    For example, levels = 0xF0F0F0F0 [8,16,24,32 bits]
    means -> all prefixes are expanded to these levels
    and only these trie levels have any dests at all

    Num of Levels + 2 memory accesses are needed in the
    worst case to get to the dest corresponding to a
    prefix - Num of Levels + 1 accesses including the
    zero level access, and 1 access to read the dest.

Return Value:

    TRIE_SUCCESS or ERROR_TRIE_*

--*/
{
    UINT prevLevel;
    UINT currLevel;
    UINT nBytes, i;

    TRY_BLOCK
    {
        if (levels == 0) {
            Error("NewFTrie: No levels specified", ERROR_TRIE_BAD_PARAM);
        }
        // Zero all the memory for the trie header
        RtlZeroMemory(pFTrie, sizeof(FTrie));

        // Set a limit on the memory for trie/nodes
        pFTrie->availMemory = maxMemory;

        // Initialize list of trienodes allocated
        InitializeListHead(&pFTrie->listofNodes);

        // Initialize root node with a NULL dest
        pFTrie->trieRoot = StoreDestPtr(NULL);

        // Initialize the number of bits in each level
        nBytes = (MAXLEVEL + 1) * sizeof(UINT);
        AllocMemory2(pFTrie->bitsInLevel,
                     nBytes,
                     pFTrie->availMemory);
        RtlZeroMemory(pFTrie->bitsInLevel, nBytes);

        // Get the number of index bits at each level
        prevLevel = 0;
        i = 0;

        for (currLevel = 1; currLevel <= MAXLEVEL; currLevel++) {
            if (levels & 1) {
                pFTrie->bitsInLevel[i++] = currLevel - prevLevel;

                prevLevel = currLevel;
            }
            levels >>= 1;
        }

        pFTrie->numLevels = i;

        // Make sure that the last level is MAXLEVEL
        if (pFTrie->bitsInLevel[i] = MAXLEVEL - prevLevel) {
            pFTrie->numLevels++;
        }
#if DBG
        Print("Num of levels: %d\n", pFTrie->numLevels);
        Print("Bits In Level:\n");
        for (i = 0; i < pFTrie->numLevels; i++) {
            Print("\t%d", pFTrie->bitsInLevel[i]);
            if (i % 8 == 7)
                Print("\n");
        }
        Print("\n\n");
#endif

        // Allocate and Zero all the statistics variables
        nBytes = (MAXLEVEL + 1) * sizeof(UINT);
        AllocMemory2(pFTrie->numDestsInOrigLevel,
                     nBytes,
                     pFTrie->availMemory);
        RtlZeroMemory(pFTrie->numDestsInOrigLevel, nBytes);

        nBytes = pFTrie->numLevels * sizeof(UINT);
        AllocMemory2(pFTrie->numNodesInExpnLevel,
                     nBytes,
                     pFTrie->availMemory);
        RtlZeroMemory(pFTrie->numNodesInExpnLevel, nBytes);

        nBytes = pFTrie->numLevels * sizeof(UINT);
        AllocMemory2(pFTrie->numDestsInExpnLevel,
                     nBytes,
                     pFTrie->availMemory);
        RtlZeroMemory(pFTrie->numDestsInExpnLevel, nBytes);

        return TRIE_SUCCESS;
    }
    ERR_BLOCK
    {
        // Not enough resources to create an FTrie
        CleanupFTrie(pFTrie);
    }
    END_BLOCK
}

UINT
CALLCONV
InsertIntoFTrie(IN FTrie * pFTrie,
                IN Route * pInsRoute,
                IN Dest * pInsDest,
                IN Dest * pOldDest)
/*++

Routine Description:

    Inserts a dest corresponding to an address
    prefix into a F-trie. It actually replaces
    all pointers to OldDest by that of InsDest.

Arguments:

    pFTrie    - Pointer to the F-Trie to insert into
    pInsRoute - Pointer to best route on new dest
    pInsDest  - Pointer to the dest being inserted
    pOldDest  - Pointer to the dest being replaced

Return Value:

    TRIE_SUCCESS or ERROR_TRIE_*

--*/
{
    FTrieNode **ppCurrNode;
    FTrieNode *pCurrNode;
    Dest *pBestDest;
    Dest *pComDest;
    UINT startIndex;
    UINT stopIndex;
    UINT nextIndex;
    UINT shiftIndex;
    UINT addrBits;
    UINT numBits;
    UINT bitsLeft;
    UINT i, j;

#if DBG
    // Make sure the trie is initialized
    if (!pFTrie || !pFTrie->trieRoot) {
        Fatal("Insert Dest: FTrie not initialized",
              ERROR_TRIE_NOT_INITED);
    }
    // Make sure input dest is valid

    if (NULL_DEST(pInsDest)) {
        Fatal("Insert Dest: NULL or invalid dest",
              ERROR_TRIE_BAD_PARAM);
    }
    // Make sure input route is valid

    if (NULL_ROUTE(pInsRoute)) {
        Fatal("Insert Dest: NULL or invalid route",
              ERROR_TRIE_BAD_PARAM);
    }
    if (LEN(pInsRoute) > ADDRSIZE) {
        Fatal("Insert Dest: Invalid mask length",
              ERROR_TRIE_BAD_PARAM);
    }
#endif

    Assert(pInsDest != pOldDest);

    // Use addr bits to index the trie
    addrBits = RtlConvertEndianLong(DEST(pInsRoute));
    bitsLeft = LEN(pInsRoute);

#if DBG
    // Make sure addr and mask agree
    if (ShowMostSigNBits(addrBits, bitsLeft) != addrBits) {
        Fatal("Insert Dest: Addr & mask don't agree",
              ERROR_TRIE_BAD_PARAM);
    }
#endif

    TRY_BLOCK
    {
        // Special case: Default Prefix
        if (LEN(pInsRoute) == 0) {
            // Do we have a subtree in the trie's root node ?
            if (IsPtrADestPtr(pFTrie->trieRoot)) {
                // Make sure you are replacing right dest
                Assert(pFTrie->trieRoot == StoreDestPtr(pOldDest));

                // Make the root to point to the new default
                pFTrie->trieRoot = StoreDestPtr(pInsDest);
            } else {
                // Make sure you are replacing right dest
                Assert(pFTrie->trieRoot->comDest == pOldDest);

                // Make new dest the common subtrie dest
                pFTrie->trieRoot->comDest = pInsDest;
            }

            return TRIE_SUCCESS;
        }
        // Start going down the trie using addr bits

        pBestDest = NULL;

        ppCurrNode = &pFTrie->trieRoot;

        for (i = 0; /* NOTHING */ ; i++) {
            pCurrNode = *ppCurrNode;

            if (IsPtrADestPtr(pCurrNode)) {
                // Creating a new subtree for the current level

                // This pointer actually points to a dest node
                pComDest = RestoreDestPtr(pCurrNode);

                // Create, initialize a new FTrie node (grow it)
                NewFTrieNode(pFTrie,
                             pCurrNode,
                             pFTrie->bitsInLevel[i],
                             pComDest);

                // Attach it to the FTrie
                *ppCurrNode = pCurrNode;

                // Update FTrie Statistics
                pFTrie->numNodesInExpnLevel[i]++;
            }
            // Update the best dest seen so far - used later
            pComDest = pCurrNode->comDest;
            if (pComDest) {
                pBestDest = pComDest;
            }
            // Increment the number of dests in this subtrie
            pCurrNode->numDests++;

            // Can I pass this level with remaining bits ?
            if (bitsLeft <= pFTrie->bitsInLevel[i]) {
                break;
            }
            // Get the next index from the IP addr
            numBits = pCurrNode->numBits;

            nextIndex = PickMostSigNBits(addrBits, numBits);
            ppCurrNode = &pCurrNode->child[nextIndex];

            // Throw away the used bits
            addrBits <<= numBits;
            bitsLeft -= numBits;
        }

        // Update FTrie stats before expanding
        // Update if this isn't a dest change
        pFTrie->numDestsInExpnLevel[i]++;
        pFTrie->numDestsInOrigLevel[LEN(pInsRoute)]++;

        // At this level, expand and add the dest
        nextIndex = PickMostSigNBits(addrBits, bitsLeft);
        shiftIndex = pFTrie->bitsInLevel[i] - bitsLeft;

        startIndex = nextIndex << shiftIndex;
        stopIndex = (nextIndex + 1) << shiftIndex;

        // Have you seen the old dest already ?
        if (pBestDest == pOldDest) {
            pOldDest = NULL;
        }
        // These dests cannot be the same here
        Assert(pInsDest != pOldDest);

        // Fill the expanded range with the dest
        for (i = startIndex; i < stopIndex; i++) {
            if (IsPtrADestPtr(pCurrNode->child[i])) {
                // A dest pointer - replace with new one
                ReplaceDestPtr(StoreDestPtr(pInsDest),
                               StoreDestPtr(pOldDest),
                               &pCurrNode->child[i]);
            } else {
                // Node pointer - update subtree's dest
                ReplaceDestPtr(pInsDest,
                               pOldDest,
                               &pCurrNode->child[i]->comDest);
            }
        }

        return TRIE_SUCCESS;
    }
    ERR_BLOCK
    {
        // Not enough resources - rollback to original state
        DeleteFromFTrie(pFTrie, pInsRoute, pInsDest, pOldDest, PARTIAL);
    }
    END_BLOCK
}

UINT
CALLCONV
DeleteFromFTrie(IN FTrie * pFTrie,
                IN Route * pDelRoute,
                IN Dest * pDelDest,
                IN Dest * pNewDest,
                IN BOOLEAN trieState)
/*++

Routine Description:

    Deletes a dest corresponding to an address
    prefix from a F-trie. It actually replaces
    all pointers to DelDest by that of NewDest.

Arguments:

    pFTrie    - Pointer to the F-Trie to delete from
    pDelRoute - Pointer to last route on old dest
    pDelDest  - Pointer to the dest being deleted
    pNewDest  - Pointer to the dest replacing above
    trieState - NORMAL - deleting from a consistent FTrie
                PARTIAL - cleaning up an incomplete insert

Return Value:

    TRIE_SUCCESS or ERROR_TRIE_*

--*/
{
    FTrieNode **ppCurrNode;
    FTrieNode *pCurrNode;
    FTrieNode *pPrevNode;
    FTrieNode *pNextNode;
    Dest *pBestDest;
    Dest *pComDest;
    UINT startIndex;
    UINT stopIndex;
    UINT nextIndex;
    UINT shiftIndex;
    UINT addrBits;
    UINT numBits;
    UINT bitsLeft;
    UINT i, j;

#if DBG
    // Make sure the trie is initialized
    if (!pFTrie || !pFTrie->trieRoot) {
        Fatal("Delete Dest: FTrie not initialized",
              ERROR_TRIE_NOT_INITED);
    }
    // Make sure input dest is valid

    if (NULL_DEST(pDelDest)) {
        Fatal("Delete Dest: NULL or invalid dest",
              ERROR_TRIE_BAD_PARAM);
    }
    // Make sure input route is valid

    if (NULL_ROUTE(pDelRoute)) {
        Fatal("Delete Dest: NULL or invalid route",
              ERROR_TRIE_BAD_PARAM);
    }
    if (LEN(pDelRoute) > ADDRSIZE) {
        Fatal("Delete Dest: Invalid mask length",
              ERROR_TRIE_BAD_PARAM);
    }
#endif

    // Use addr bits to index the trie
    addrBits = RtlConvertEndianLong(DEST(pDelRoute));
    bitsLeft = LEN(pDelRoute);

#if DBG
    // Make sure addr and mask agree
    if (ShowMostSigNBits(addrBits, bitsLeft) != addrBits) {
        Fatal("Delete Dest: Addr & mask don't agree",
              ERROR_TRIE_BAD_PARAM);
    }
#endif

    Assert(pDelDest != pNewDest);

    // Special case: Default Prefix
    if (LEN(pDelRoute) == 0) {
        // Do we have a subtree in the trie's root node ?
        if (IsPtrADestPtr(pFTrie->trieRoot)) {
            // Make sure you are replacing right dest
            Assert(pFTrie->trieRoot == StoreDestPtr(pDelDest));

            // Make the root to point to the new default
            pFTrie->trieRoot = StoreDestPtr(pNewDest);
        } else {
            // Make sure you are replacing right dest
            Assert(pFTrie->trieRoot->comDest == pDelDest);

            // Make new dest the common subtrie dest
            pFTrie->trieRoot->comDest = pNewDest;
        }

        return TRIE_SUCCESS;
    }
    // Start going down the trie using addr bits

    pBestDest = NULL;

    ppCurrNode = &pFTrie->trieRoot;

    pPrevNode = pCurrNode = *ppCurrNode;

    for (i = 0; /* NOTHING */ ; i++) {
        // We still have bits left, so we go down the trie

        // Do we have a valid subtree at the current node
        if (IsPtrADestPtr(pCurrNode)) {
            // We are cleaning a partial (failed) insert
            Assert(trieState == PARTIAL);

            // We have cleaned up the trie - return now
            return TRIE_SUCCESS;
        }
        // We have a valid subtree, so we go down the trie

        // Update the best dest seen so far - used later
        pComDest = pCurrNode->comDest;
        if (pComDest) {
            pBestDest = pComDest;
        }
        // Decrement the number of dests in this subtrie
        pCurrNode->numDests--;

        // Is the number of dests in curr subtree zero ?
        if (pCurrNode->numDests == 0) {
#if DBG
            int k = 0;

            // Just make sure that only one dest exists
            for (j = 1; j < (UINT) 1 << pCurrNode->numBits; j++) {
                if (pCurrNode->child[j - 1] != pCurrNode->child[j]) {
                    Assert((pCurrNode->child[j] == StoreDestPtr(NULL)) ||
                           (pCurrNode->child[j - 1] == StoreDestPtr(NULL)));
                    k++;
                }
            }

            if (trieState == NORMAL) {
                if ((k != 1) && (k != 2)) {
                    Print("k = %d\n", k);
                    Assert(FALSE);
                }
            } else {
                if ((k != 0) && (k != 1) && (k != 2)) {
                    Print("k = %d\n", k);
                    Assert(FALSE);
                }
            }
#endif

            // Remove link from its parent (if it exists)
            if (pPrevNode) {
                *ppCurrNode = StoreDestPtr(pCurrNode->comDest);
            }
        }
        // Can I pass this level with remaining bits ?
        if (bitsLeft <= pFTrie->bitsInLevel[i]) {
            break;
        }
        // Get the next index from the IP addr
        numBits = pCurrNode->numBits;

        nextIndex = PickMostSigNBits(addrBits, numBits);
        ppCurrNode = &pCurrNode->child[nextIndex];

        pNextNode = *ppCurrNode;

        // Throw away the used bits
        addrBits <<= numBits;
        bitsLeft -= numBits;

        // Is the number of dests in subtree zero ?
        if (pCurrNode->numDests == 0) {
            // Deallocate it (shrink FTrie)
            FreeFTrieNode(pFTrie, pCurrNode);

            // Update FTrie Statistics
            pFTrie->numNodesInExpnLevel[i]--;
        }
        pPrevNode = pCurrNode;
        pCurrNode = pNextNode;
    }

    // Update F-Trie stats before deleting
    pFTrie->numDestsInExpnLevel[i]--;
    pFTrie->numDestsInOrigLevel[LEN(pDelRoute)]--;

    // Is the number of dests in curr subtree zero ?
    if (pCurrNode->numDests == 0) {
        // Deallocate it (shrink FTrie)
        FreeFTrieNode(pFTrie, pCurrNode);

        // Update FTrie Statistics
        pFTrie->numNodesInExpnLevel[i]--;
    } else {
        // At this level, expand and add the dest
        nextIndex = PickMostSigNBits(addrBits, bitsLeft);
        shiftIndex = pFTrie->bitsInLevel[i] - bitsLeft;

        startIndex = nextIndex << shiftIndex;
        stopIndex = (nextIndex + 1) << shiftIndex;

        // Have you seen the new dest already ?
        if (pBestDest == pNewDest) {
            pNewDest = NULL;
        }
        // These dests cannot be the same here
        Assert(pDelDest != pNewDest);

        // Fill the expanded range with the dest
        for (i = startIndex; i < stopIndex; i++) {
            if (IsPtrADestPtr(pCurrNode->child[i])) {
                // A dest pointer - replace with new one
                ReplaceDestPtr(StoreDestPtr(pNewDest),
                               StoreDestPtr(pDelDest),
                               &pCurrNode->child[i]);
            } else {
                // Node pointer - update subtree's dest
                ReplaceDestPtr(pNewDest,
                               pDelDest,
                               &pCurrNode->child[i]->comDest);
            }
        }
    }

    return TRIE_SUCCESS;
}

UINT
CALLCONV
SearchDestInFTrie(IN FTrie * pFTrie,
                  IN Dest * pSerDest,
                  OUT UINT * pNumPtrs,
                  OUT Dest ** pStartPtr)
/*++

Routine Description:

    Search for a specific dest in an F-trie,
    returns the expanded range for the dest

Arguments:

    pFTrie     - Pointer to the F-trie to search
    pSerDest   - Pointer to dest being searched
    pStartPtr  - Start of dest's expanded range
    pNumPtrs   - Number of pointers in the range

Return Value:

    TRIE_SUCCESS or ERROR_TRIE_*

--*/
{
    return ERROR_TRIE_BAD_PARAM;
}

Dest *
 CALLCONV
SearchAddrInFTrie(IN FTrie * pFTrie,
                  IN ULONG Addr)
/*++

Routine Description:

    Search for an address in an F-trie

Arguments:

    pFTrie  - Pointer to the trie to search
    Addr    - Pointer to addr being queried

Return Value:
    Return best dest match for this address

--*/
{
    FTrieNode *pCurrNode;
    Dest *pBestDest;
    Dest *pDest;
    ULONG addrBits;
    UINT numBits;
    UINT nextIndex;

#if DBG
    if (!pFTrie || !pFTrie->trieRoot) {
        Fatal("Searching into an uninitialized FTrie",
              ERROR_TRIE_NOT_INITED);
    }
#endif

    addrBits = RtlConvertEndianLong(Addr);

    pBestDest = NULL;

    pCurrNode = pFTrie->trieRoot;

    do {
        // Have we reached the end of this search ?
        if (IsPtrADestPtr(pCurrNode)) {
            // Get the best matching dest until now
            pDest = RestoreDestPtr(pCurrNode);
            if (!NULL_DEST(pDest)) {
                pBestDest = pDest;
            }
            return pBestDest;
        } else {
            // Get the best matching dest until now
            pDest = pCurrNode->comDest;
            if (!NULL_DEST(pDest)) {
                pBestDest = pDest;
            }
        }

        // Number of bits to use in this FTrie level
        numBits = pCurrNode->numBits;

        // Get the next index from IP address bits
        nextIndex = PickMostSigNBits(addrBits, numBits);

        // And go down the tree with the new index
        pCurrNode = pCurrNode->child[nextIndex];

        // Throw away the used bits for this iteration
        addrBits <<= numBits;
    }
    while (TRUE);
}

UINT
CALLCONV
CleanupFTrie(IN FTrie * pFTrie)
/*++

Routine Description:

    Deletes an F-trie if it is empty

Arguments:

    ppFTrie - Ptr to the F-trie

Return Value:

    TRIE_SUCCESS or ERROR_TRIE_*
--*/
{
    FTrieNode *pCurrNode;
    LIST_ENTRY *p;

    // Free all trie nodes and corresponding memory
    while (!IsListEmpty(&pFTrie->listofNodes)) {
        p = RemoveHeadList(&pFTrie->listofNodes);
        pCurrNode = CONTAINING_RECORD(p, FTrieNode, linkage);
        FreeFTrieNode(pFTrie, pCurrNode);
    }

    // Free the memory for the arr of levels
    if (pFTrie->bitsInLevel) {
        FreeMemory1(pFTrie->bitsInLevel,
                    (MAXLEVEL + 1) * sizeof(UINT),
                    pFTrie->availMemory);
    }
    // Free memory allocated for statistics
    if (pFTrie->numDestsInOrigLevel) {
        FreeMemory1(pFTrie->numDestsInOrigLevel,
                    (MAXLEVEL + 1) * sizeof(UINT),
                    pFTrie->availMemory);
    }
    if (pFTrie->numNodesInExpnLevel) {
        FreeMemory1(pFTrie->numNodesInExpnLevel,
                    pFTrie->numLevels * sizeof(UINT),
                    pFTrie->availMemory);
    }
    if (pFTrie->numDestsInExpnLevel) {
        FreeMemory1(pFTrie->numDestsInExpnLevel,
                    pFTrie->numLevels * sizeof(UINT),
                    pFTrie->availMemory);
    }
    // Reset other fields in trie structure
    pFTrie->trieRoot = NULL;
    pFTrie->numLevels = 0;

    return TRIE_SUCCESS;
}

#if DBG

VOID
CALLCONV
PrintFTrie(IN FTrie * pFTrie,
           IN UINT printFlags)
/*++

Routine Description:

    Print an F-Trie

Arguments:

    pFTrie - Pointer to the F-Trie
    printFlags - Information to print

Return Value:

    None
--*/
{
    FTrieNode *pCurrNode;
    UINT i;

    if (pFTrie == NULL) {
        Print("%s", "Uninitialized FTrie\n\n");
        return;
    }
    if ((printFlags & SUMM) == SUMM) {
        Print("\n\n/***Fast-Trie------------------------------------------------");
        Print("\n/***---------------------------------------------------------\n");
    }
    if (printFlags & POOL) {
        Print("Available Memory: %10lu\n\n", pFTrie->availMemory);
    }
    if (printFlags & STAT) {
        Print("Statistics:\n\n");

        Print("Num of levels: %d\n", pFTrie->numLevels);
        Print("Bits In Level:\n");
        for (i = 0; i < pFTrie->numLevels; i++) {
            Print("\t%d", pFTrie->bitsInLevel[i]);
            if (i % 8 == 7)
                Print("\n");
        }
        Print("\n\n");

        Print("Num of Nodes in Expanded Levels:\n");
        for (i = 0; i < pFTrie->numLevels; i++) {
            Print("\t%d", pFTrie->numNodesInExpnLevel[i]);
            if (i % 8 == 7)
                Print("\n");
        }
        Print("\n\n");

        Print("Num of Dests in Original Levels:\n");
        for (i = 0; i < MAXLEVEL + 1; i++) {
            Print("\t%d", pFTrie->numDestsInOrigLevel[i]);
            if (i % 8 == 0)
                Print("\n");
        }
        Print("\n\n");

        Print("Num of Dests in Expanded Levels:\n");
        for (i = 0; i < pFTrie->numLevels; i++) {
            Print("\t%d", pFTrie->numDestsInExpnLevel[i]);
            if (i % 8 == 7)
                Print("\n");
        }
        Print("\n\n");
    }
    if (printFlags & TRIE) {
        if (!IsPtrADestPtr(pFTrie->trieRoot)) {
            PrintFTrieNode(pFTrie->trieRoot, 0);
        } else {
            PrintDest(RestoreDestPtr(pFTrie->trieRoot));
        }
    }
    if ((printFlags & SUMM) == SUMM) {
        Print("\n---------------------------------------------------------***/\n");
        Print("---------------------------------------------------------***/\n\n");
    }
}

VOID
CALLCONV
PrintFTrieNode(IN FTrieNode * pFTrieNode,
               IN UINT levelNumber)
/*++

Routine Description:

    Print an F-Trie node

Arguments:

    pFTrieNode - Pointer to the FTrie node

Return Value:

    None
--*/
{
    FTrieNode *pCurrNode;
    UINT numElmts;
    UINT i, j;

    Print("\n/*-----------------------------------------------------------\n");
    Print("Num of bits at level %3d : %d\n", levelNumber, pFTrieNode->numBits);
    Print("Number of Subtrie Dests : %d\n", pFTrieNode->numDests);
    Print("Common SubTree Dest : ");
    PrintDest(pFTrieNode->comDest);
    Print("\n");

    numElmts = 1 << pFTrieNode->numBits;
    pCurrNode = StoreDestPtr(NULL);

    Print("Child Ptrs:\n\n");
    for (i = 0; i < numElmts; i++) {
        if (pFTrieNode->child[i] != pCurrNode) {
            pCurrNode = pFTrieNode->child[i];

            Print("Child Index: %8lu ", i);

            if (IsPtrADestPtr(pCurrNode)) {
                PrintDest(RestoreDestPtr(pCurrNode));
            } else {
                PrintFTrieNode(pCurrNode, levelNumber + 1);
            }
        }
    }
    Print("-----------------------------------------------------------*/\n\n");
}

#endif // DBG


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipv4\icmp.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1992          **/
/********************************************************************/
/* :ts=4 */

//***   icmp.h - IP ICMP header.
//
//  This module contains private ICMP definitions.
//
#pragma once

#define PROT_ICMP   1

#define ICMP_ECHO_RESP      0
#define ICMP_ECHO           8
#define ICMP_TIMESTAMP      13
#define ICMP_TIMESTAMP_RESP 14

#define MIN_ERRDATA_LENGTH  8       // Minimum amount of data we need.

// Structure of an ICMP header.

typedef struct ICMPHeader {
    uchar       ich_type;           // Type of ICMP packet.
    uchar       ich_code;           // Subcode of type.
    ushort      ich_xsum;           // Checksum of packet.
    ulong       ich_param;          // Type-specific parameter field.
} ICMPHeader;

typedef struct ICMPRouterAdHeader {
    uchar       irah_numaddrs;      // Number of addresses
    uchar       irah_addrentrysize; // Address Entry Size
    ushort      irah_lifetime;      // Lifetime
} ICMPRouterAdHeader;

typedef struct ICMPRouterAdAddrEntry {
    IPAddr      irae_addr;          // Router Address
    long        irae_preference;    // Preference Level
} ICMPRouterAdAddrEntry;

typedef struct ICMPSendCompleteCtxt {
    uchar       iscc_Type;
    uchar       *iscc_DataPtr;
} ICMPSendCompleteCtxt;

typedef void    (*EchoRtn)(struct EchoControl *, IP_STATUS, void *, uint, IPOptInfo *);

typedef struct EchoControl {
    struct EchoControl *ec_next;        // Next control structure in list.
    EchoRtn             ec_rtn;         // Pointer to routine to call when completing request.
    LARGE_INTEGER       ec_starttime;   // time request was issued
    void               *ec_replybuf;    // buffer to store replies
    ulong               ec_replybuflen; // size of reply buffer
    ulong               ec_to;          // Timeout
    IPAddr              ec_src;         // IPAddr of source
    uint                ec_seq;         // Seq. # of this ping request. 32-bit
                                        // to reduce collisons from wraparound.
    uchar               ec_active;      // Set when packet has been sent
} EchoControl;

extern ICMPHeader   *GetICMPBuffer(uint Size, PNDIS_BUFFER *Buffer);
extern void         FreeICMPBuffer(PNDIS_BUFFER Buffer, uchar Type);
extern void         ICMPSendComplete(ICMPSendCompleteCtxt *SCC, PNDIS_BUFFER BufferChain, IP_STATUS SendStatus);
extern uint         AddrMaskReply;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipv4\igmp.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

//** IGMP.H - IP multicast definitions.
//
// This file contains definitions related to IP multicast.

// IP protocol number for IGMP
#define    PROT_IGMP    2

extern uint IGMPLevel;
extern HANDLE IcmpHeaderPool;

// Structure used for local mcast address tracking.
typedef struct IGMPAddr {
    struct IGMPAddr    *iga_next;
    struct IGMPSrcAddr *iga_srclist;
    IPAddr              iga_addr;
    uint                iga_grefcnt;   // # sockets joining whole group
    uint                iga_isrccnt;   // # sources with isa_irefcnt>0
    uint                iga_resptimer; // query response timer
    uint                iga_resptype;  // response type
    uint                iga_trtimer;   // triggered report timer
    uchar               iga_changetype;// triggered change type
    uchar               iga_xmitleft;  // triggered xmit's left
} IGMPAddr;

// Values of iga_resptype
#define NO_RESP           0
#define GROUP_RESP        1
#define GROUP_SOURCE_RESP 2

// Values of iga_changetype
#define NO_CHANGE         0
#define MODE_CHANGE       1
#define SOURCE_CHANGE     2

typedef struct IGMPSrcAddr {
    struct IGMPSrcAddr  *isa_next;
    IPAddr               isa_addr;
    uint                 isa_irefcnt;  // # sockets Including this source
    uint                 isa_xrefcnt;  // # sockets Excluding this source
    uchar                isa_xmitleft; // triggered xmit's left
    uchar                isa_csmarked; // response xmit's left
} IGMPSrcAddr;

#define    IGMP_ADD           0
#define    IGMP_DELETE        1
#define    IGMP_DELETE_ALL    2
#define    IGMP_CHANGE        3

#define    IGMPV1             2       //IGMP version 1
#define    IGMPV2             3       //IGMP version 2
#define    IGMPV3             4       //IGMP version 3

extern void InitIGMPForNTE(NetTableEntry *NTE);
extern void StopIGMPForNTE(NetTableEntry *NTE);
extern    IP_STATUS IGMPAddrChange(NetTableEntry *NTE, IPAddr Addr,
                                   uint ChangeType,
                                   uint NumExclSources, IPAddr *ExclSourceList,
                                   uint NumEnclSources, IPAddr *InclSourceList);
extern  IP_STATUS IGMPInclChange(NetTableEntry *NTE, IPAddr Addr,
                                 uint NumAddSources, IPAddr *AddSourceList,
                                 uint NumDelSources, IPAddr *DelSourceList);
extern  IP_STATUS IGMPExclChange(NetTableEntry *NTE, IPAddr Addr,
                                 uint NumAddSources, IPAddr *AddSourceList,
                                 uint NumDelSources, IPAddr *DelSourceList);
extern void    IGMPTimer(NetTableEntry *NTE);
extern uchar IsMCastSourceAllowed(IPAddr Dest, IPAddr Src, uchar Protocol, NetTableEntry *NTE);

#define IGMP_TABLE_SIZE      32
#define IGMP_HASH(x)         ((((uchar *)&(x))[3]) % IGMP_TABLE_SIZE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipv4\internaldef.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1992          **/
/********************************************************************/
/* :ts=4 */
#ifndef INTERNALDEF_H_INCLUDED
#define INTERNALDEF_H_INCLUDED

typedef struct _UNICODE_STRING_NEW {
    ULONG  Length;
    ULONG  MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING_NEW;
typedef UNICODE_STRING_NEW *PUNICODE_STRING_NEW;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipv4\icmp.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

  icmp.c - IP ICMP routines.

Abstract:

 This module contains all of the ICMP related routines.

Author:


[Environment:]

    kernel mode only

[Notes:]

    optional-notes

Revision History:


--*/

#include "precomp.h"
#include "mdlpool.h"
#include "icmp.h"
#include "info.h"
#include "iproute.h"
#include "ipxmit.h"
#include <icmpif.h>
#include "iprtdef.h"
#include "tcpipbuf.h"

#if GPC
#include "qos.h"
#include "traffic.h"
#include "gpcifc.h"
#include "ntddtc.h"

extern GPC_HANDLE hGpcClient[];
extern ULONG GpcCfCounts[];
extern GPC_EXPORTED_CALLS GpcEntries;
extern ULONG GPCcfInfo;
extern ULONG ServiceTypeOffset;
#endif

extern ProtInfo IPProtInfo[];    // Protocol information table.

extern void *IPRegisterProtocol(uchar, void *, void *, void *, void *, void *, void *);

extern ulong GetTime();

extern ULStatusProc FindULStatus(uchar);
extern uchar IPUpdateRcvdOptions(IPOptInfo *, IPOptInfo *, IPAddr, IPAddr);
extern void IPInitOptions(IPOptInfo *);
extern IP_STATUS IPCopyOptions(uchar *, uint, IPOptInfo *);
extern IP_STATUS IPFreeOptions(IPOptInfo *);
extern uchar IPGetLocalAddr(IPAddr, IPAddr *);
void ICMPRouterTimer(NetTableEntry *);

extern NDIS_HANDLE BufferPool;

extern uint DisableUserTOS;
extern uint DefaultTOS;
extern NetTableEntry **NewNetTableList;        // hash table for NTEs
extern uint NET_TABLE_SIZE;
extern ProtInfo *RawPI;            // Raw IP protinfo

uint EnableICMPRedirects = 0;
uint AddrMaskReply;
ICMPStats ICMPInStats;
ICMPStats ICMPOutStats;

HANDLE IcmpHeaderPool;

// Each ICMP header buffer contains room for the outer IP header, the
// ICMP header and the inner IP header (for the ICMP error case).
//
#define BUFSIZE_ICMP_HEADER_POOL    sizeof(IPHeader) + sizeof(ICMPHeader) + \
                                    sizeof(IPHeader) +  MAX_OPT_SIZE + 8

#define TIMESTAMP_MSG_LEN  3    // icmp timestamp message length is 3 long words (12 bytes)
// fix for icmp 3 way ping bug

#define MAX_ICMP_ECHO 1000
int IcmpEchoPendingCnt = 0;

// fix for system crash because of
// too many UDP PORT_UNREACH errors
// this covers redirect as well as
// unreachable errors

#define MAX_ICMP_ERR 1000
int IcmpErrPendingCnt = 0;

void ICMPInit(uint NumBuffers);

IP_STATUS
ICMPEchoRequest(
                void *InputBuffer,
                uint InputBufferLength,
                EchoControl * ControlBlock,
                EchoRtn Callback);

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, ICMPInit)
#pragma alloc_text(PAGE, ICMPEchoRequest)

#endif // ALLOC_PRAGMA

//* UpdateICMPStats - Update ICMP statistics.
//
//  A routine to update the ICMP statistics.
//
//  Input:  Stats       - Pointer to stat. structure to update (input or output).
//          Type        - Type of stat to update.
//
//  Returns: Nothing.
//
void
UpdateICMPStats(ICMPStats * Stats, uchar Type)
{
    switch (Type) {
    case ICMP_DEST_UNREACH:
        Stats->icmps_destunreachs++;
        break;
    case ICMP_TIME_EXCEED:
        Stats->icmps_timeexcds++;
        break;
    case ICMP_PARAM_PROBLEM:
        Stats->icmps_parmprobs++;
        break;
    case ICMP_SOURCE_QUENCH:
        Stats->icmps_srcquenchs++;
        break;
    case ICMP_REDIRECT:
        Stats->icmps_redirects++;
        break;
    case ICMP_TIMESTAMP:
        Stats->icmps_timestamps++;
        break;
    case ICMP_TIMESTAMP_RESP:
        Stats->icmps_timestampreps++;
        break;
    case ICMP_ECHO:
        Stats->icmps_echos++;
        break;
    case ICMP_ECHO_RESP:
        Stats->icmps_echoreps++;
        break;
    case ADDR_MASK_REQUEST:
        Stats->icmps_addrmasks++;
        break;
    case ADDR_MASK_REPLY:
        Stats->icmps_addrmaskreps++;
        break;
    default:
        break;
    }

}

//** GetICMPBuffer - Get an ICMP buffer, and allocate an NDIS_BUFFER that maps it.
//
//  A routine to allocate an ICMP buffer and map an NDIS_BUFFER to it.
//
//  Entry:  Size    - Size in bytes header buffer should be mapped as.
//          Buffer  - Pointer to pointer to NDIS_BUFFER to return.
//
//  Returns: Pointer to ICMP buffer if allocated, or NULL.
//
ICMPHeader *
GetICMPBuffer(uint Size, PNDIS_BUFFER *Buffer)
{
    ICMPHeader *Header;

    ASSERT(Size);
    ASSERT(Buffer);

    *Buffer = MdpAllocate(IcmpHeaderPool, &Header);

    if (*Buffer) {
        NdisAdjustBufferLength(*Buffer, Size);

        // Reserve room for the IP Header.
        //
        Header = (ICMPHeader *)((uchar *)Header + sizeof(IPHeader));
        Header->ich_xsum = 0;
    }

    return Header;
}

//** FreeICMPBuffer - Free an ICMP buffer.
//
//  This routine puts an ICMP buffer back on our free list.
//
//  Entry:  Buffer      - Pointer to NDIS_BUFFER to be freed.
//          Type        - ICMP header type
//
//  Returns: Nothing.
//
void
FreeICMPBuffer(PNDIS_BUFFER Buffer, uchar Type)
{

    ASSERT(Buffer);

    // If the header is ICMP echo response, decrement the pending count.
    //
    if (Type == ICMP_ECHO_RESP) {
        InterlockedDecrement(&IcmpEchoPendingCnt);
    } else if ((Type == ICMP_DEST_UNREACH) ||
               (Type == ICMP_REDIRECT)) {
        InterlockedDecrement(&IcmpErrPendingCnt);
    }

    MdpFree(Buffer);
}

//** DeleteEC - Remove an EchoControl from an NTE, and return a pointer to it.
//
//  This routine is called when we need to remove an echo control structure from
//  an NTE. We walk the list of EC structures on the NTE, and if we find a match
//  we remove it and return a pointer to it.
//
//  Entry:  NTE         - Pointer to NTE to be searched.
//          Seq         - Seq. # identifying the EC.
//          MatchUshort - if TRUE, matches on lower 16 bits of seq. #
//
//  Returns: Pointer to the EC if it finds it.
//
EchoControl *
DeleteEC(NetTableEntry * NTE, uint Seq, BOOLEAN MatchUshort)
{
    EchoControl *Prev, *Current;
    CTELockHandle Handle;

    CTEGetLock(&NTE->nte_lock, &Handle);
    Prev = STRUCT_OF(EchoControl, &NTE->nte_echolist, ec_next);
    Current = NTE->nte_echolist;
    while (Current != (EchoControl *) NULL) {
        if (Current->ec_seq == Seq ||
            (MatchUshort && (ushort)Current->ec_seq == Seq)) {
            Prev->ec_next = Current->ec_next;
            break;
        } else {
            Prev = Current;
            Current = Current->ec_next;
        }
    }

    CTEFreeLock(&NTE->nte_lock, Handle);
    return Current;

}

//** ICMPSendComplete - Complete an ICMP send.
//
//  This rtn is called when an ICMP send completes. We free the header buffer,
//  the data buffer if there is one, and the NDIS_BUFFER chain.
//
//  Entry:  SCC         - SendCompleteContext
//          BufferChain - Pointer to NDIS_BUFFER chain.
//
//  Returns: Nothing
//
void
ICMPSendComplete(ICMPSendCompleteCtxt *SCC, PNDIS_BUFFER BufferChain, IP_STATUS SendStatus)
{
    PNDIS_BUFFER DataBuffer;
    uchar *DataPtr, Type;

    NdisGetNextBuffer(BufferChain, &DataBuffer);
    DataPtr = SCC->iscc_DataPtr;
    Type = SCC->iscc_Type;
    FreeICMPBuffer(BufferChain, Type);

    if (DataBuffer != (PNDIS_BUFFER) NULL) {    // We had data with this ICMP send.
        CTEFreeMem(DataPtr);
        NdisFreeBuffer(DataBuffer);
    }
    CTEFreeMem(SCC);
}

//* XsumBufChain - Checksum a chain of buffers.
//
//  Called when we need to checksum an IPRcvBuf chain.
//
//  Input:  BufChain    - Buffer chain to be checksummed.
//
//  Returns: The checksum.
//
ushort
XsumBufChain(IPRcvBuf * BufChain)
{
    ulong CheckSum = 0;

    ASSERT(BufChain);

    do {
        CheckSum += (ulong) xsum(BufChain->ipr_buffer, BufChain->ipr_size);
        BufChain = BufChain->ipr_next;
    } while (BufChain != NULL);

    // Fold the checksum down.
    CheckSum = (CheckSum >> 16) + (CheckSum & 0xffff);
    CheckSum += (CheckSum >> 16);

    return (ushort) CheckSum;
}

//** SendEcho - Send an ICMP Echo or Echo response.
//
//  This routine sends an ICMP echo or echo response. The Echo/EchoResponse may
//  carry data. If it does we'll copy the data here. The request may also have
//  options. Options are not copied, as the IPTransmit routine will copy
//  options.
//
//  Entry:  Dest        - Destination to send to.
//          Source      - Source to send from.
//          Type        - Type of request (ECHO or ECHO_RESP)
//          ID          - ID of request.
//          Seq         - Seq. # of request.
//          Data        - Pointer to data (NULL if none).
//          DataLength  - Length in bytes of data
//          OptInfo     - Pointer to IP Options structure.
//
//  Returns: IP_STATUS of request.
//
IP_STATUS
SendEcho(IPAddr Dest, IPAddr Source, uchar Type, ushort ID, uint Seq,
         IPRcvBuf * Data, uint DataLength, IPOptInfo * OptInfo)
{
    uchar *DataBuffer = (uchar *) NULL;        // Pointer to data buffer.
    PNDIS_BUFFER HeaderBuffer, Buffer;    // Buffers for our header and user data.
    ICMPHeader *Header;
    ushort header_xsum;
    IP_STATUS IpStatus;
    RouteCacheEntry *RCE;
    ushort MSS;
    uchar DestType;
    IPAddr SrcAddr;
    ICMPSendCompleteCtxt *SCC;

    ICMPOutStats.icmps_msgs++;

    DEBUGMSG(DBG_TRACE && DBG_ICMP && DBG_TX,
        (DTEXT("+SendEcho(%x, %x, %x, %x, %x, %x, %x, %x)\n"),
        Dest, Source, Type, ID, Seq, Data, DataLength, OptInfo));

    SrcAddr = OpenRCE(Dest, Source, &RCE, &DestType, &MSS, OptInfo);
    if (IP_ADDR_EQUAL(SrcAddr,NULL_IP_ADDR)) {
        //Failure, free resource and exit

        ICMPOutStats.icmps_errors++;
        if (Type == ICMP_ECHO_RESP)
            CTEInterlockedDecrementLong(&IcmpEchoPendingCnt);

        return IP_DEST_HOST_UNREACHABLE;
    }

    Header = GetICMPBuffer(sizeof(ICMPHeader), &HeaderBuffer);
    if (Header == (ICMPHeader *) NULL) {
        ICMPOutStats.icmps_errors++;
        if (Type == ICMP_ECHO_RESP)
            CTEInterlockedDecrementLong(&IcmpEchoPendingCnt);

        CloseRCE(RCE);
        return IP_NO_RESOURCES;
    }

    ASSERT(Type == ICMP_ECHO_RESP || Type == ICMP_ECHO);

    Header->ich_type = Type;
    Header->ich_code = 0;
    *(ushort *) & Header->ich_param = ID;
    *((ushort *) & Header->ich_param + 1) = (ushort)Seq;
    header_xsum = xsum(Header, sizeof(ICMPHeader));
    Header->ich_xsum = ~header_xsum;

    SCC = CTEAllocMemN(sizeof(ICMPSendCompleteCtxt), 'sICT');
    if (SCC == NULL) {
        FreeICMPBuffer(HeaderBuffer,Type);
        ICMPOutStats.icmps_errors++;
        CloseRCE(RCE);
        return IP_NO_RESOURCES;
    }
    SCC->iscc_Type = Type;
    SCC->iscc_DataPtr = NULL;

    // If there's data, get a buffer and copy it now. If we can't do this fail the request.
    if (DataLength != 0) {
        NDIS_STATUS Status;
        ulong TempXsum;
        uint BytesToCopy, CopyIndex;

        DataBuffer = CTEAllocMemN(DataLength, 'YICT');
        if (DataBuffer == (void *)NULL) {    // Couldn't get a buffer
            CloseRCE(RCE);
            FreeICMPBuffer(HeaderBuffer, Type);
            ICMPOutStats.icmps_errors++;
            CTEFreeMem(SCC);
            return IP_NO_RESOURCES;
        }

        BytesToCopy = DataLength;
        CopyIndex = 0;
        do {
            uint CopyLength;

            ASSERT(Data);
            CopyLength = MIN(BytesToCopy, Data->ipr_size);

            RtlCopyMemory(DataBuffer + CopyIndex, Data->ipr_buffer, CopyLength);
            Data = Data->ipr_next;
            CopyIndex += CopyLength;
            BytesToCopy -= CopyLength;
        } while (BytesToCopy);

        SCC->iscc_DataPtr = DataBuffer;

        NdisAllocateBuffer(&Status, &Buffer, BufferPool, DataBuffer, DataLength);
        if (Status != NDIS_STATUS_SUCCESS) {    // Couldn't get an NDIS_BUFFER

            CloseRCE(RCE);
            CTEFreeMem(DataBuffer);
            FreeICMPBuffer(HeaderBuffer, Type);
            ICMPOutStats.icmps_errors++;
            CTEFreeMem(SCC);
            return IP_NO_RESOURCES;
        }

        // Compute rest of xsum.
        TempXsum = (ulong) header_xsum + (ulong) xsum(DataBuffer, DataLength);
        TempXsum = (TempXsum >> 16) + (TempXsum & 0xffff);
        TempXsum += (TempXsum >> 16);
        Header->ich_xsum = ~(ushort) TempXsum;
        NDIS_BUFFER_LINKAGE(HeaderBuffer) = Buffer;
    }

    UpdateICMPStats(&ICMPOutStats, Type);

    OptInfo->ioi_hdrincl = 0;
    OptInfo->ioi_ucastif = 0;
    OptInfo->ioi_mcastif = 0;

#if GPC

    if (DisableUserTOS) {
        OptInfo->ioi_tos = (uchar) DefaultTOS;
    }

    if (GPCcfInfo) {
        //
        // we'll fall into here only if the GPC client is there
        // and there is at least one CF_INFO_QOS installed
        // (counted by GPCcfInfo).
        //

        GPC_STATUS status = STATUS_SUCCESS;
        ULONG ServiceType = 0;
        GPC_IP_PATTERN Pattern;
        CLASSIFICATION_HANDLE GPCHandle;

        Pattern.SrcAddr = Source;
        Pattern.DstAddr = Dest;
        Pattern.ProtocolId = PROT_ICMP;
        Pattern.gpcSrcPort = 0;
        Pattern.gpcDstPort = 0;

        Pattern.InterfaceId.InterfaceId = 0;
        Pattern.InterfaceId.LinkId = 0;

        GetIFAndLink(RCE,
                     &Pattern.InterfaceId.InterfaceId,
                     &Pattern.InterfaceId.LinkId);



        GPCHandle = 0;

        status = GpcEntries.GpcClassifyPatternHandler(
                                                     hGpcClient[GPC_CF_QOS],
                                                     GPC_PROTOCOL_TEMPLATE_IP,
                                                     &Pattern,
                                                     NULL,        // context
                                                     &GPCHandle,
                                                     0,
                                                     NULL,
                                                     FALSE);

        OptInfo->ioi_GPCHandle = (int)GPCHandle;

        //
        // Only if QOS patterns exist, we get the TOS bits out.
        //
        if (NT_SUCCESS(status) && GpcCfCounts[GPC_CF_QOS]) {

            status = GpcEntries.GpcGetUlongFromCfInfoHandler(
                                                     hGpcClient[GPC_CF_QOS],
                                                     OptInfo->ioi_GPCHandle,
                                                     ServiceTypeOffset,
                                                     &ServiceType);
            //
            // It is likely that the pattern has gone by now (Removed or whatever)
            // and the handle that we are caching is INVALID.
            // We need to pull up a new handle and get the
            // TOS bit again.
            //

            if (STATUS_NOT_FOUND == status) {

                GPCHandle = 0;

                status = GpcEntries.GpcClassifyPatternHandler(
                                                      hGpcClient[GPC_CF_QOS],
                                                      GPC_PROTOCOL_TEMPLATE_IP,
                                                      &Pattern,
                                                      NULL,        // context
                                                      &GPCHandle,
                                                      0,
                                                      NULL,
                                                      FALSE);

                OptInfo->ioi_GPCHandle = (int)GPCHandle;

                //
                // Only if QOS patterns exist, we get the TOS bits out.
                //
                if (NT_SUCCESS(status) && GpcCfCounts[GPC_CF_QOS]) {

                    status = GpcEntries.GpcGetUlongFromCfInfoHandler(
                                                      hGpcClient[GPC_CF_QOS],
                                                      OptInfo->ioi_GPCHandle,
                                                      ServiceTypeOffset,
                                                      &ServiceType);
                }
            }
        }
        if (status == STATUS_SUCCESS) {
            OptInfo->ioi_tos = (OptInfo->ioi_tos & TOS_MASK) | (uchar)ServiceType;
        }
    } // if (GPCcfInfo)

#endif

    IpStatus = IPTransmit(IPProtInfo, SCC, HeaderBuffer,
                         DataLength + sizeof(ICMPHeader), Dest, Source, OptInfo, RCE,
                         PROT_ICMP,NULL);

    CloseRCE(RCE);

    if (IpStatus != IP_PENDING) {
        ICMPSendComplete(SCC, HeaderBuffer, IP_SUCCESS);
    }
    return IpStatus;
}

//** SendICMPMsg - Send an ICMP message
//
//  This is the general ICMP message sending routine, called for most ICMP
//  sends besides echo. Basically, all we do is get a buffer, format the
//  info, copy the input  header, and send the message.
//
//  Entry:  Src         - IPAddr of source.
//          Dest        - IPAddr of destination
//          Type        - Type of request.
//          Code        - Subcode of request.
//          Pointer     - Pointer value for request.
//          Data        - Pointer to data (NULL if none).
//          DataLength  - Length in bytes of data
//
//  Returns: IP_STATUS of request.
//
IP_STATUS
SendICMPMsg(IPAddr Src, IPAddr Dest, uchar Type, uchar Code, ulong Pointer,
            uchar * Data, uchar DataLength)
{
    PNDIS_BUFFER HeaderBuffer;    // Buffer for our header
    ICMPHeader *Header;
    IP_STATUS IStatus;            // Status of transmit
    IPOptInfo OptInfo;            // Options for this transmit.
    RouteCacheEntry *RCE;
    ushort MSS;
    uchar DestType;
    IPAddr SrcAddr;
    ICMPSendCompleteCtxt *SCC;

    ICMPOutStats.icmps_msgs++;

    IPInitOptions(&OptInfo);

    SrcAddr = OpenRCE(Dest,Src, &RCE, &DestType, &MSS, &OptInfo);

    if (IP_ADDR_EQUAL(SrcAddr,NULL_IP_ADDR)) {

        ICMPOutStats.icmps_errors++;
        if ((Type == ICMP_DEST_UNREACH) || (Type == ICMP_REDIRECT))
            CTEInterlockedDecrementLong(&IcmpErrPendingCnt);

        return IP_DEST_HOST_UNREACHABLE;
    }

    Header = GetICMPBuffer(sizeof(ICMPHeader) + DataLength, &HeaderBuffer);
    if (Header == (ICMPHeader *) NULL) {
        ICMPOutStats.icmps_errors++;
        if ((Type == ICMP_DEST_UNREACH) || (Type == ICMP_REDIRECT))
            CTEInterlockedDecrementLong(&IcmpErrPendingCnt);
        CloseRCE(RCE);
        return IP_NO_RESOURCES;
    }

    Header->ich_type = Type;
    Header->ich_code = Code;
    Header->ich_param = Pointer;
    if (Data)
        RtlCopyMemory(Header + 1, Data, DataLength);
    Header->ich_xsum = ~xsum(Header, sizeof(ICMPHeader) + DataLength);

    SCC = CTEAllocMemN(sizeof(ICMPSendCompleteCtxt), 'sICT');

    if (SCC == NULL) {
        ICMPOutStats.icmps_errors++;
        FreeICMPBuffer(HeaderBuffer, Type);
        CloseRCE(RCE);
        return IP_NO_RESOURCES;
    }

    SCC->iscc_Type = Type;
    SCC->iscc_DataPtr = NULL;

    UpdateICMPStats(&ICMPOutStats, Type);

#if GPC
    if (DisableUserTOS) {
        OptInfo.ioi_tos = (uchar) DefaultTOS;
    }
    if (GPCcfInfo) {

        //
        // we'll fall into here only if the GPC client is there
        // and there is at least one CF_INFO_QOS installed
        // (counted by GPCcfInfo).
        //

        GPC_STATUS status = STATUS_SUCCESS;
        ULONG ServiceType = 0;
        GPC_IP_PATTERN Pattern;
        CLASSIFICATION_HANDLE GPCHandle;

        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL, "ICMPSend: Classifying \n"));

        Pattern.SrcAddr = Src;
        Pattern.DstAddr = Dest;
        Pattern.ProtocolId = PROT_ICMP;
        Pattern.gpcSrcPort = 0;
        Pattern.gpcDstPort = 0;

        Pattern.InterfaceId.InterfaceId = 0;
        Pattern.InterfaceId.LinkId = 0;

        GetIFAndLink(RCE,
                     &Pattern.InterfaceId.InterfaceId,
                     &Pattern.InterfaceId.LinkId);


        GPCHandle = 0;

        status = GpcEntries.GpcClassifyPatternHandler(
                                                      hGpcClient[GPC_CF_QOS],
                                                      GPC_PROTOCOL_TEMPLATE_IP,
                                                      &Pattern,
                                                      NULL,        // context
                                                      &GPCHandle,
                                                      0,
                                                      NULL,
                                                      FALSE);

        OptInfo.ioi_GPCHandle = (int)GPCHandle;

        //
        // Only if QOS patterns exist, we get the TOS bits out.
        //
        if (NT_SUCCESS(status) && GpcCfCounts[GPC_CF_QOS]) {

            status = GpcEntries.GpcGetUlongFromCfInfoHandler(
                                                    hGpcClient[GPC_CF_QOS],
                                                    OptInfo.ioi_GPCHandle,
                                                    ServiceTypeOffset,
                                                    &ServiceType);

            //
            // It is likely that the pattern has gone by now (Removed or whatever)
            // and the handle that we are caching is INVALID.
            // We need to pull up a new handle and get the
            // TOS bit again.
            //

            if (STATUS_NOT_FOUND == status) {

                GPCHandle = 0;

                status = GpcEntries.GpcClassifyPatternHandler(
                                                    hGpcClient[GPC_CF_QOS],
                                                    GPC_PROTOCOL_TEMPLATE_IP,
                                                    &Pattern,
                                                    NULL,        // context
                                                    &GPCHandle,
                                                    0,
                                                    NULL,
                                                    FALSE);

                OptInfo.ioi_GPCHandle = (int)GPCHandle;

                //
                // Only if QOS patterns exist, we get the TOS bits out.
                //
                if (NT_SUCCESS(status) && GpcCfCounts[GPC_CF_QOS]) {

                    status = GpcEntries.GpcGetUlongFromCfInfoHandler(
                                                      hGpcClient[GPC_CF_QOS],
                                                      OptInfo.ioi_GPCHandle,
                                                      ServiceTypeOffset,
                                                      &ServiceType);
                }
            }
        }
        if (status == STATUS_SUCCESS) {

            OptInfo.ioi_tos = (OptInfo.ioi_tos & TOS_MASK) | (UCHAR)ServiceType;

        }
    }                            // if (GPCcfInfo)

#endif

    IStatus = IPTransmit(IPProtInfo, SCC, HeaderBuffer,
                         DataLength + sizeof(ICMPHeader),
                         Dest, Src, &OptInfo, RCE,
                         PROT_ICMP,NULL);

    CloseRCE(RCE);

    if (IStatus != IP_PENDING)
        ICMPSendComplete(SCC, HeaderBuffer, IP_SUCCESS);

    return IStatus;

}

//** SendICMPErr - Send an ICMP error message
//
//  This is the routine used to send an ICMP error message, such as ]
//  Destination Unreachable. We examine the header to find the length of the
//  data, and also make sure we're not replying to another ICMP error message
//  or a broadcast message. Then we call SendICMPMsg to send it.
//
//  Entry:  Src         - IPAddr of source.
//          Header      - Pointer to IP Header that caused the problem.
//          Type        - Type of request.
//          Code        - Subcode of request.
//          Pointer     - Pointer value for request.
//
//  Returns: IP_STATUS of request.
//
IP_STATUS
SendICMPErr(IPAddr Src, IPHeader UNALIGNED * Header, uchar Type, uchar Code,
            ulong Pointer)
{
    uchar HeaderLength;            // Length in bytes if header.
    uchar DType;

    HeaderLength = (Header->iph_verlen & (uchar) ~ IP_VER_FLAG) << 2;

    if (Header->iph_protocol == PROT_ICMP) {
        ICMPHeader UNALIGNED *ICH = (ICMPHeader UNALIGNED *)
        ((uchar *) Header + HeaderLength);

        if (ICH->ich_type != ICMP_ECHO)
            return IP_SUCCESS;
    }
    // Don't respond to sends to a broadcast destination.
    DType = GetAddrType(Header->iph_dest);
    if (DType == DEST_INVALID || IS_BCAST_DEST(DType))
        return IP_SUCCESS;

    // Don't respond if the source address is bad.
    DType = GetAddrType(Header->iph_src);
    if (DType == DEST_INVALID || IS_BCAST_DEST(DType) ||
        (IP_LOOPBACK(Header->iph_dest) && DType != DEST_LOCAL))
        return IP_SUCCESS;

    // Make sure the source we're sending from is good.
    if (!IP_ADDR_EQUAL(Src, NULL_IP_ADDR)) {
        if (GetAddrType(Src) != DEST_LOCAL) {
            return IP_SUCCESS;
        }
    }
    // Double check to make sure it's an initial fragment.
    if ((Header->iph_offset & IP_OFFSET_MASK) != 0)
        return IP_SUCCESS;


    if ((Type == ICMP_DEST_UNREACH) || (Type == ICMP_REDIRECT)) {

        if (IcmpErrPendingCnt > MAX_ICMP_ERR) {
            return IP_SUCCESS;
        }
        CTEInterlockedIncrementLong(&IcmpErrPendingCnt);
    }
    return SendICMPMsg(Src, Header->iph_src, Type, Code, Pointer,
                       (uchar *) Header, (uchar) (MIN(HeaderLength + 8,
                       Header->iph_length)));

}

//** SendICMPIPSecErr - Send an ICMP error message related to IPSEC
//
//  This is the routine used to send an ICMP error message, such as Destination
//  Unreachable.  We examine the header to find the length of the data, and
//  also make sure we're not replying to another ICMP error message or a
//  broadcast message. Then we call SendICMPMsg to send it.
//
//  This function is essentially the same as SendICMPErr except we don't
//  verify the source address is local because the packet could be tunneled.
//
//  Entry:  Src         - IPAddr of source.
//          Header      - Pointer to IP Header that caused the problem.
//          Type        - Type of request.
//          Code        - Subcode of request.
//          Pointer     - Pointer value for request.
//
//  Returns: IP_STATUS of request.
//
IP_STATUS
SendICMPIPSecErr(IPAddr Src, IPHeader UNALIGNED * Header, uchar Type, uchar Code,
                 ulong Pointer)
{
    uchar HeaderLength;            // Length in bytes if header.
    uchar DType;

    HeaderLength = (Header->iph_verlen & (uchar) ~ IP_VER_FLAG) << 2;

    if (Header->iph_protocol == PROT_ICMP) {
        ICMPHeader UNALIGNED *ICH = (ICMPHeader UNALIGNED *)
        ((uchar *) Header + HeaderLength);

        if (ICH->ich_type != ICMP_ECHO)
            return IP_SUCCESS;
    }
    // Don't respond to sends to a broadcast destination.
    DType = GetAddrType(Header->iph_dest);
    if (DType == DEST_INVALID || IS_BCAST_DEST(DType))
        return IP_SUCCESS;

    // Don't respond if the source address is bad.
    DType = GetAddrType(Header->iph_src);
    if (DType == DEST_INVALID || IS_BCAST_DEST(DType) ||
        (IP_LOOPBACK(Header->iph_dest) && DType != DEST_LOCAL))
        return IP_SUCCESS;

    // Make sure the source we're sending from is good.
    if (IP_ADDR_EQUAL(Src, NULL_IP_ADDR))
        return IP_SUCCESS;

    // Double check to make sure it's an initial fragment.
    if ((Header->iph_offset & IP_OFFSET_MASK) != 0)
        return IP_SUCCESS;


    if ((Type == ICMP_DEST_UNREACH) || (Type == ICMP_REDIRECT)) {
        if (IcmpErrPendingCnt > MAX_ICMP_ERR) {
            return IP_SUCCESS;
        }
        CTEInterlockedIncrementLong(&IcmpErrPendingCnt);
    }

    return SendICMPMsg(Src, Header->iph_src, Type, Code, Pointer,
                       (uchar *) Header, (uchar) (HeaderLength + 8));

}

//** ICMPTimer - Timer for ICMP
//
//  This is the timer routine called periodically by global IP timer. We
//  walk through the list of pending pings, and if we find one that's timed
//  out we remove it and call the finish routine.
//
//  Entry: NTE      - Pointer to NTE being timed out.
//
//  Returns: Nothing
//
void
ICMPTimer(NetTableEntry * NTE)
{
    CTELockHandle Handle;
    EchoControl *TimeoutList = (EchoControl *) NULL;    // Timed out entries.
    EchoControl *Prev, *Current;
    ulong Now = CTESystemUpTime();

    CTEGetLock(&NTE->nte_lock, &Handle);
    Prev = STRUCT_OF(EchoControl, &NTE->nte_echolist, ec_next);
    Current = NTE->nte_echolist;
    while (Current != (EchoControl *) NULL)
        if ((Current->ec_active) && ((long)(Now - Current->ec_to) > 0)) {
            // This one's timed out.
            Prev->ec_next = Current->ec_next;
            // Link him on timed out list.
            Current->ec_next = TimeoutList;
            TimeoutList = Current;
            Current = Prev->ec_next;
        } else {
            Prev = Current;
            Current = Current->ec_next;
        }

    CTEFreeLock(&NTE->nte_lock, Handle);

    // Now go through the timed out entries, and call the completion routine.
    while (TimeoutList != (EchoControl *) NULL) {
        Current = TimeoutList;
        TimeoutList = Current->ec_next;

        Current->ec_rtn(Current, IP_REQ_TIMED_OUT, NULL, 0, NULL);
    }

    ICMPRouterTimer(NTE);

}

//* CompleteEcho - Complete an echo request.
//
//  Called when we need to complete an echo request, either because of
//  a response or a received ICMP error message. We look it up, and then
//  call the completion routine.
//
//  Input:  Header          - Pointer to ICMP header causing completion.
//          Status          - Final status of request.
//          Src             - IPAddr of source
//          Data            - Data to be returned, if any.
//          DataSize        - Size in bytes of data.
//          OptInfo         - Option info structure.
//
//  Returns: Nothing.
//
void
CompleteEcho(ICMPHeader UNALIGNED * Header, IP_STATUS Status,
             IPAddr Src, IPRcvBuf * Data, uint DataSize, IPOptInfo * OptInfo)
{
    ushort NTEContext;
    EchoControl *EC;
    NetTableEntry *NTE;
    uint i;

    // Look up and remove the matching echo control block.
    NTEContext = (*(ushort UNALIGNED *) & Header->ich_param);

    for (i = 0; i < NET_TABLE_SIZE; i++) {
        NetTableEntry *NetTableList = NewNetTableList[i];
        for (NTE = NetTableList; NTE != NULL; NTE = NTE->nte_next)
            if (NTEContext == NTE->nte_context)
                break;
        if (NTE != NULL)
            break;
    }

    if (NTE == NULL)
        return;                    // Bad context value.

    EC = DeleteEC(NTE, *(((ushort UNALIGNED *) & Header->ich_param) + 1), TRUE);
    if (EC != (EchoControl *) NULL) {    // Found a match.
        EC->ec_src = Src; // Set source address
        EC->ec_rtn(EC, Status, Data, DataSize, OptInfo);
    }
}

//** ICMPStatus - ICMP status handling procedure.
//
// This is the procedure called during a status change, either from an
// incoming ICMP message or a hardware status change. ICMP ignores most of
// these, unless we get an ICMP status message that was caused be an echo
// request. In that case we will complete the corresponding echo request with
// the appropriate error code.
//
//  Input:  StatusType      - Type of status (NET or HW)
//          StatusCode      - Code identifying IP_STATUS.
//          OrigDest        - If this is net status, the original dest. of DG
//                            that triggered it.
//          OrigSrc         - "   "    "  "    "   , the original src.
//          Src             - IP address of status originator (could be local
//                            or remote).
//          Param           - Additional information for status - i.e. the
//                            param field of an ICMP message.
//          Data            - Data pertaining to status - for net status, this
//                            is the first 8 bytes of the original DG.
//
//  Returns: Nothing
//
void
ICMPStatus(uchar StatusType, IP_STATUS StatusCode, IPAddr OrigDest,
           IPAddr OrigSrc, IPAddr Src, ulong Param, void *Data)
{
    if (StatusType == IP_NET_STATUS) {
        ICMPHeader UNALIGNED *ICH = (ICMPHeader UNALIGNED *) Data;
        // ICH is the datagram that caused the message.

        if (ICH->ich_type == ICMP_ECHO) {    // And it was an echo request.

            IPRcvBuf RcvBuf;

            RcvBuf.ipr_next = NULL;
            RcvBuf.ipr_buffer = (uchar *) & Src;
            RcvBuf.ipr_size = sizeof(IPAddr);
            CompleteEcho(ICH, StatusCode, Src, &RcvBuf, sizeof(IPAddr), NULL);
        }
    }
}

//* ICMPMapStatus - Map an ICMP error to an IP status code.
//
//  Called by ICMP status when we need to map from an incoming ICMP error
//  code and type to an ICMP status.
//
//  Entry:  Type        - Type of ICMP error.
//          Code        - Subcode of error.
//
//  Returns: Corresponding IP status.
//
IP_STATUS
ICMPMapStatus(uchar Type, uchar Code)
{
    switch (Type) {

    case ICMP_DEST_UNREACH:
        switch (Code) {
        case NET_UNREACH:
        case HOST_UNREACH:
        case PROT_UNREACH:
        case PORT_UNREACH:
            return IP_DEST_UNREACH_BASE + Code;
            break;
        case FRAG_NEEDED:
            return IP_PACKET_TOO_BIG;
            break;
        case SR_FAILED:
            return IP_BAD_ROUTE;
            break;
        case DEST_NET_UNKNOWN:
        case SRC_ISOLATED:
        case DEST_NET_ADMIN:
        case NET_UNREACH_TOS:
            return IP_DEST_NET_UNREACHABLE;
            break;
        case DEST_HOST_UNKNOWN:
        case DEST_HOST_ADMIN:
        case HOST_UNREACH_TOS:
            return IP_DEST_HOST_UNREACHABLE;
            break;
        default:
            return IP_DEST_NET_UNREACHABLE;
        }
        break;
    case ICMP_TIME_EXCEED:
        if (Code == TTL_IN_TRANSIT)
            return IP_TTL_EXPIRED_TRANSIT;
        else
            return IP_TTL_EXPIRED_REASSEM;
        break;
    case ICMP_PARAM_PROBLEM:
        return IP_PARAM_PROBLEM;
        break;
    case ICMP_SOURCE_QUENCH:
        return IP_SOURCE_QUENCH;
        break;
    default:
        return IP_GENERAL_FAILURE;
        break;
    }

}

void
SendRouterSolicitation(NetTableEntry * NTE)
{
    if (NTE->nte_rtrdiscovery) {
        SendICMPMsg(NTE->nte_addr, NTE->nte_rtrdiscaddr,
                    ICMP_ROUTER_SOLICITATION, 0, 0, NULL, 0);
    }
}

//** ICMPRouterTimer - Timeout default gateway entries
//
// This is the router advertisement timeout handler. When a router
// advertisement is received, we add the routers to our default gateway
// list if applicable. We then run a timer on the entries and refresh
// the list as new advertisements are received. If we fail to hear an
// update for a router within the specified lifetime we will delete the
// route from our routing tables.
//

void
ICMPRouterTimer(NetTableEntry * NTE)
{
    CTELockHandle Handle;
    IPRtrEntry *rtrentry;
    IPRtrEntry *temprtrentry;
    IPRtrEntry *lastrtrentry = NULL;
    uint SendIt = FALSE;

    CTEGetLock(&NTE->nte_lock, &Handle);
    rtrentry = NTE->nte_rtrlist;
    while (rtrentry != NULL) {
        if (rtrentry->ire_lifetime-- == 0) {
            if (lastrtrentry == NULL) {
                NTE->nte_rtrlist = rtrentry->ire_next;
            } else {
                lastrtrentry->ire_next = rtrentry->ire_next;
            }
            temprtrentry = rtrentry;
            rtrentry = rtrentry->ire_next;
            DeleteRoute(NULL_IP_ADDR, DEFAULT_MASK,
                        temprtrentry->ire_addr, NTE->nte_if, 0);
            CTEFreeMem(temprtrentry);
        } else {
            lastrtrentry = rtrentry;
            rtrentry = rtrentry->ire_next;
        }
    }
    if (NTE->nte_rtrdisccount != 0) {
        NTE->nte_rtrdisccount--;
        if ((NTE->nte_rtrdiscstate == NTE_RTRDISC_SOLICITING) &&
            ((NTE->nte_rtrdisccount % SOLICITATION_INTERVAL) == 0)) {
            SendIt = TRUE;
        }
        if ((NTE->nte_rtrdiscstate == NTE_RTRDISC_DELAYING) &&
            (NTE->nte_rtrdisccount == 0)) {
            NTE->nte_rtrdisccount = (SOLICITATION_INTERVAL) * (MAX_SOLICITATIONS - 1);
            NTE->nte_rtrdiscstate = NTE_RTRDISC_SOLICITING;
            SendIt = TRUE;
        }
    }
    CTEFreeLock(&NTE->nte_lock, Handle);
    if (SendIt) {
        SendRouterSolicitation(NTE);
    }
}

//** ProcessRouterAdvertisement - Process a router advertisement
//
// This is the router advertisement handler. When a router advertisement
// is received, we add the routers to our default gateway list if applicable.
//

uint
ProcessRouterAdvertisement(IPAddr Src, IPAddr LocalAddr, NetTableEntry * NTE,
                           ICMPRouterAdHeader UNALIGNED * AdHeader, IPRcvBuf * RcvBuf, uint Size)
{
    uchar NumAddrs = AdHeader->irah_numaddrs;
    uchar AddrEntrySize = AdHeader->irah_addrentrysize;
    ushort Lifetime = net_short(AdHeader->irah_lifetime);
    ICMPRouterAdAddrEntry UNALIGNED *RouterAddr = (ICMPRouterAdAddrEntry UNALIGNED *) RcvBuf->ipr_buffer;
    uint i;
    CTELockHandle Handle;
    IPRtrEntry *rtrentry;
    IPRtrEntry *lastrtrentry = NULL;
    int Update = FALSE;
    int New = FALSE;
    IP_STATUS status;

    if ((NumAddrs == 0) || (AddrEntrySize < 2))        // per rfc 1256

        return FALSE;

    CTEGetLock(&NTE->nte_lock, &Handle);
    for (i = 0; i < NumAddrs; i++, RouterAddr++) {
        if ((RouterAddr->irae_addr & NTE->nte_mask) != (NTE->nte_addr & NTE->nte_mask)) {
            continue;
        }
        if (!IsRouteICMP(NULL_IP_ADDR, DEFAULT_MASK, RouterAddr->irae_addr, NTE->nte_if)) {
            continue;
        }

        rtrentry = NTE->nte_rtrlist;
        while (rtrentry != NULL) {
            if (rtrentry->ire_addr == RouterAddr->irae_addr) {
                rtrentry->ire_lifetime = Lifetime * 2;
                if (rtrentry->ire_preference != RouterAddr->irae_preference) {
                    rtrentry->ire_preference = RouterAddr->irae_preference;
                    Update = TRUE;
                }
                break;
            }
            lastrtrentry = rtrentry;
            rtrentry = rtrentry->ire_next;
        }

        if (rtrentry == NULL) {
            rtrentry = (IPRtrEntry *) CTEAllocMemN(sizeof(IPRtrEntry), 'dICT');
            if (rtrentry == NULL) {
                return FALSE;
            }
            rtrentry->ire_next = NULL;
            rtrentry->ire_addr = RouterAddr->irae_addr;
            rtrentry->ire_preference = RouterAddr->irae_preference;
            rtrentry->ire_lifetime = Lifetime * 2;
            if (lastrtrentry == NULL) {
                NTE->nte_rtrlist = rtrentry;
            } else {
                lastrtrentry->ire_next = rtrentry;
            }
            New = TRUE;
            Update = TRUE;
        }
        if (Update && (RouterAddr->irae_preference != (long)0x00000080)) {    // per rfc 1256

            status = AddRoute(NULL_IP_ADDR, DEFAULT_MASK,
                              RouterAddr->irae_addr,
                              NTE->nte_if, NTE->nte_mss,
                              (uint) (MIN(9999, MAX(1, 1000 - net_long(RouterAddr->irae_preference)))),        // invert for metric
                               IRE_PROTO_ICMP, ATYPE_OVERRIDE, 0, 0);

            if (New && (status != IP_SUCCESS)) {

                if (lastrtrentry == NULL) {
                    NTE->nte_rtrlist = NULL;
                }
                CTEFreeMem(rtrentry);
            }
        }
        Update = FALSE;
        New = FALSE;
    }
    CTEFreeLock(&NTE->nte_lock, Handle);

    return TRUE;
}

//** ICMPRcv - Receive an ICMP datagram.
//
//  Called by the main IP code when we receive an ICMP datagram. The action we
//  take depends on what the DG is. For some DGs, we call upper layer status
//  handlers. For Echo Requests, we call the echo responder.
//
//  Entry:  NTE            - Pointer to NTE on which ICMP message was received.
//          Dest           - IPAddr of destionation.
//          Src            - IPAddr of source
//          LocalAddr      - Local address of network which caused this to be
//                              received.
//          SrcAddr        - Address of local interface which received the
//                              packet
//          IPHdr          - Pointer to IP Header
//          IPHdrLength    - Bytes in Header.
//          RcvBuf         - ICMP message buffer.
//          Size           - Size in bytes of ICMP message.
//          IsBCast        - Boolean indicator of whether or not this came in
//                              as a bcast.
//          Protocol       - Protocol this came in on.
//          OptInfo        - Pointer to info structure for received options.
//
//  Returns: Status of reception
//
IP_STATUS
ICMPRcv(NetTableEntry * NTE, IPAddr Dest, IPAddr Src, IPAddr LocalAddr,
        IPAddr SrcAddr, IPHeader UNALIGNED * IPHdr, uint IPHdrLength,
        IPRcvBuf * RcvBuf, uint Size, uchar IsBCast, uchar Protocol,
        IPOptInfo * OptInfo)
{
    ICMPHeader UNALIGNED *Header;
    void *Data;                    // Pointer to data received.
    IPHeader UNALIGNED *IPH;    // Pointer to IP Header in error messages.
    uint HeaderLength;            // Size of IP header.
    ULStatusProc ULStatus;        // Pointer to upper layer status procedure.
    IPOptInfo NewOptInfo;
    uchar DType;
    uint PassUp = FALSE;

    uint PromiscuousMode = 0;

    DEBUGMSG(DBG_TRACE && DBG_ICMP && DBG_RX,
        (DTEXT("+ICMPRcv(%x, %x, %x, %x, %x, %x, %d, %x, %d, %x, %x, %x)\n"),
        NTE, Dest, Src, LocalAddr, SrcAddr, IPHdr, IPHdrLength,
         RcvBuf, Size, IsBCast, Protocol, OptInfo));

    ICMPInStats.icmps_msgs++;

    PromiscuousMode = NTE->nte_if->if_promiscuousmode;

    DType = GetAddrType(Src);
    if (Size < sizeof(ICMPHeader) || DType == DEST_INVALID ||
        IS_BCAST_DEST(DType) || (IP_LOOPBACK(Dest) && DType != DEST_LOCAL) ||
        XsumBufChain(RcvBuf) != (ushort) 0xffff) {
        DEBUGMSG(DBG_WARN && DBG_ICMP && DBG_RX,
            (DTEXT("ICMPRcv: Packet dropped, invalid checksum.\n")));
        ICMPInStats.icmps_errors++;
        return IP_SUCCESS;        // Bad checksum.

    }
    Header = (ICMPHeader UNALIGNED *) RcvBuf->ipr_buffer;

    RcvBuf->ipr_buffer += sizeof(ICMPHeader);
    RcvBuf->ipr_size -= sizeof(ICMPHeader);

    // Set up the data pointer for most requests, i.e. those that take less
    // than MIN_FIRST_SIZE data.

    if (Size -= sizeof(ICMPHeader))
        Data = (void *)(Header + 1);
    else
        Data = (void *)NULL;

    switch (Header->ich_type) {

    case ICMP_DEST_UNREACH:
    case ICMP_TIME_EXCEED:
    case ICMP_PARAM_PROBLEM:
    case ICMP_SOURCE_QUENCH:
    case ICMP_REDIRECT:

        if (IsBCast)
            return IP_SUCCESS;    // ICMP doesn't respond to bcast requests.

        if (Data == NULL || Size < sizeof(IPHeader)) {
            ICMPInStats.icmps_errors++;
            return IP_SUCCESS;    // No data, error.

        }
        IPH = (IPHeader UNALIGNED *) Data;
        HeaderLength = (IPH->iph_verlen & (uchar) ~ IP_VER_FLAG) << 2;
        if (HeaderLength < sizeof(IPHeader) || Size < (HeaderLength + MIN_ERRDATA_LENGTH)) {
            ICMPInStats.icmps_errors++;
            return IP_SUCCESS;    // Not enough data for this
            // ICMP message.

        }
        // Make sure that the source address of the datagram that triggered
        // the message is one of ours.

        if (GetAddrType(IPH->iph_src) != DEST_LOCAL) {
            ICMPInStats.icmps_errors++;
            return IP_SUCCESS;    // Bad src in header.

        }
        if (Header->ich_type != ICMP_REDIRECT) {

            UpdateICMPStats(&ICMPInStats, Header->ich_type);

            if (ULStatus = FindULStatus(IPH->iph_protocol)) {
                (void)(*ULStatus) (IP_NET_STATUS,
                                   ICMPMapStatus(Header->ich_type, Header->ich_code),
                                   IPH->iph_dest, IPH->iph_src, Src, Header->ich_param,
                                   (uchar *) IPH + HeaderLength);
            }
            if (Header->ich_code == FRAG_NEEDED)
                RouteFragNeeded(
                                IPH,
                                (ushort) net_short(
                                                   *((ushort UNALIGNED *) & Header->ich_param + 1)));
        } else {
            ICMPInStats.icmps_redirects++;
            if (EnableICMPRedirects)
                Redirect(NTE, Src, IPH->iph_dest, IPH->iph_src,
                         Header->ich_param);
        }

        PassUp = TRUE;

        break;

    case ICMP_ECHO_RESP:
        if (IsBCast)
            return IP_SUCCESS;    // ICMP doesn't respond to bcast requests.

        ICMPInStats.icmps_echoreps++;
        // Look up and remove the matching echo control block.
        CompleteEcho(Header, IP_SUCCESS, Src, RcvBuf, Size, OptInfo);

        PassUp = TRUE;

        break;

    case ICMP_ECHO:
        if (IsBCast)
            return IP_SUCCESS;    // ICMP doesn't respond to bcast requests.

        // NKS Outstanding PINGs can not exceed MAX_ICMP_ECHO
        // else they can eat up system resource and kill the system

        if (IcmpEchoPendingCnt > MAX_ICMP_ECHO) {
            return IP_SUCCESS;
        }

        CTEInterlockedIncrementLong(&IcmpEchoPendingCnt);

        ICMPInStats.icmps_echos++;
        IPInitOptions(&NewOptInfo);
        NewOptInfo.ioi_tos = OptInfo->ioi_tos;
        NewOptInfo.ioi_flags = OptInfo->ioi_flags;

        // If we have options, we need to reverse them and update any
        // record route info. We can use the option buffer supplied by the
        // IP layer, since we're part of him.
        if (OptInfo->ioi_options != (uchar *) NULL)
            IPUpdateRcvdOptions(OptInfo, &NewOptInfo, Src, LocalAddr);

        DEBUGMSG(DBG_INFO && DBG_ICMP && DBG_RX,
            (DTEXT("ICMPRcv: responding to echo request from SA:%x\n"),
            Src));

        SendEcho(Src, LocalAddr, ICMP_ECHO_RESP,
                 *(ushort UNALIGNED *) & Header->ich_param,
                 *((ushort UNALIGNED *) & Header->ich_param + 1),
                 RcvBuf, Size, &NewOptInfo);

        IPFreeOptions(&NewOptInfo);
        break;

    case ADDR_MASK_REQUEST:

        if (!AddrMaskReply)
            return IP_SUCCESS;    // By default we dont send a reply

        ICMPInStats.icmps_addrmasks++;

        Dest = Src;
        SendICMPMsg(LocalAddr, Dest, ADDR_MASK_REPLY, 0, Header->ich_param,
                    (uchar *) & NTE->nte_mask, sizeof(IPMask));
        break;

    case ICMP_TIMESTAMP:
        {
            ulong *TimeStampData;
            ulong CurrentTime;

            // Don't respond to sends to a broadcast destination.
            if (IsBCast) {
                return IP_SUCCESS;
            }
            if (Header->ich_code != 0)
                return IP_SUCCESS;    // Code must be 0

            ICMPInStats.icmps_timestamps++;

            Dest = Src;
            // create the data to be transmited
            CurrentTime = GetTime();
            TimeStampData = (ulong *) (CTEAllocMemN(TIMESTAMP_MSG_LEN * sizeof(ulong), 'eICT'));

            if (TimeStampData) {
                // originate timestamp
                RtlCopyMemory(TimeStampData, RcvBuf->ipr_buffer, sizeof(ulong));
                // receive timestamp
                RtlCopyMemory(TimeStampData + 1, &CurrentTime, sizeof(ulong));
                // transmit timestamp = receive timestamp
                RtlCopyMemory(TimeStampData + 2, &CurrentTime, sizeof(ulong));
                SendICMPMsg(LocalAddr, Dest, ICMP_TIMESTAMP_RESP, 0, Header->ich_param,
                            (uchar *) TimeStampData, TIMESTAMP_MSG_LEN * sizeof(ulong));
                CTEFreeMem(TimeStampData);
            }
            break;
        }

    case ICMP_ROUTER_ADVERTISEMENT:
        if (Header->ich_code != 0)
            return IP_SUCCESS;    // Code must be 0 as per RFC1256

        if (NTE->nte_rtrdiscovery) {
            if (!ProcessRouterAdvertisement(Src, LocalAddr, NTE,
                                            (ICMPRouterAdHeader *) & Header->ich_param, RcvBuf, Size))
                return IP_SUCCESS;    // An error was returned

        }
        PassUp = TRUE;
        break;

    case ICMP_ROUTER_SOLICITATION:
        if (Header->ich_code != 0)
            return IP_SUCCESS;    // Code must be 0 as per RFC1256

        PassUp = TRUE;
        break;

    default:
        PassUp = TRUE;
        UpdateICMPStats(&ICMPInStats, Header->ich_type);
        break;
    }

    if (PromiscuousMode) {
        // since if promiscuous mode is set then we will anyway call rawrcv
        PassUp = FALSE;
    }
    //
    // Pass the packet up to the raw layer if applicable.
    //
    if (PassUp && (RawPI != NULL)) {
        if (RawPI->pi_rcv != NULL) {
            //
            // Restore the original values.
            //
            RcvBuf->ipr_buffer -= sizeof(ICMPHeader);
            RcvBuf->ipr_size += sizeof(ICMPHeader);
            Size += sizeof(ICMPHeader);
            Data = (void *)Header;

            (*(RawPI->pi_rcv)) (NTE, Dest, Src, LocalAddr, SrcAddr, IPHdr,
                                IPHdrLength, RcvBuf, Size, IsBCast, Protocol, OptInfo);
        }
    }
    return IP_SUCCESS;
}

//** ICMPEcho - Send an echo to the specified address.
//
// Entry:  ControlBlock    - Pointer to an EchoControl structure. This structure
//                           must remain valid until the req. completes.
//          Timeout        - Time in milliseconds to wait for response.
//          Data           - Pointer to data to send with echo.
//          DataSize       - Size in bytes of data.
//          Callback       - Routine to call when request is responded to or
//                           times out.
//          Dest           - Address to be pinged.
//          OptInfo        - Pointer to opt info structure to use for ping.
//
//  Returns: IP_STATUS of attempt to ping..
//
IP_STATUS
ICMPEcho(EchoControl * ControlBlock, ulong Timeout, void *Data, uint DataSize,

         EchoRtn Callback, IPAddr Dest, IPOptInfo * OptInfo)
{
    IPAddr Dummy;
    NetTableEntry *NTE;
    CTELockHandle Handle;
    uint Seq;
    IP_STATUS Status;
    IPOptInfo NewOptInfo;
    IPRcvBuf RcvBuf;
    uint MTU;
    Interface *IF;
    uchar DType;
    IPHeader IPH;

    if (OptInfo->ioi_ttl == 0) {
        return IP_BAD_OPTION;
    }

    IPInitOptions(&NewOptInfo);
    NewOptInfo.ioi_ttl = OptInfo->ioi_ttl;
    NewOptInfo.ioi_flags = OptInfo->ioi_flags;
    NewOptInfo.ioi_tos = OptInfo->ioi_tos & 0xfe;

    if (OptInfo->ioi_optlength != 0) {
        Status = IPCopyOptions(OptInfo->ioi_options, OptInfo->ioi_optlength,
                               &NewOptInfo);

        if (Status != IP_SUCCESS)
            return Status;
    }
    if (!IP_ADDR_EQUAL(NewOptInfo.ioi_addr, NULL_IP_ADDR)) {
        Dest = NewOptInfo.ioi_addr;
    }

    DType = GetAddrType(Dest);
    if (DType == DEST_INVALID) {
        IPFreeOptions(&NewOptInfo);
        return IP_BAD_DESTINATION;
    }
    IPH.iph_protocol = 1;
    IPH.iph_xsum = 0;
    IPH.iph_dest = Dest;
    IPH.iph_src = 0;
    IPH.iph_ttl = 128;

    IF = LookupNextHopWithBuffer(Dest, NULL_IP_ADDR, &Dummy, &MTU, 0x1,
            (uchar *) &IPH, sizeof(IPHeader), NULL, NULL, NULL_IP_ADDR, 0);
    if (IF == NULL) {
        IPFreeOptions(&NewOptInfo);
        return IP_DEST_HOST_UNREACHABLE;    // Don't know how to get there.
    }

    // Loop through the NetTable, looking for a matching NTE.
    CTEGetLock(&RouteTableLock.Lock, &Handle);
    if (DHCPActivityCount != 0) {
        NTE = NULL;
    } else {
        NTE = BestNTEForIF(Dummy, IF);
    }

    CTEFreeLock(&RouteTableLock.Lock, Handle);

    // We're done with the interface, so dereference it.
    DerefIF(IF);

    if (NTE == NULL) {
        IPFreeOptions(&NewOptInfo);
        return IP_DEST_HOST_UNREACHABLE;
    }

    // Figure out the timeout.
    ControlBlock->ec_to = CTESystemUpTime() + Timeout;
    ControlBlock->ec_rtn = Callback;
    ControlBlock->ec_active = 0;    // Prevent from timing out until sent

    CTEGetLock(&NTE->nte_lock, &Handle);
    // Link onto ping list, and get seq. # */
    Seq = ++NTE->nte_icmpseq;
    ControlBlock->ec_seq = Seq;
    ControlBlock->ec_next = NTE->nte_echolist;
    NTE->nte_echolist = ControlBlock;
    CTEFreeLock(&NTE->nte_lock, Handle);

    //
    // N.B. At this point, it is only safe to return IP_PENDING from this
    // routine.  This is because we may recieve a spoofed ICMP reply/status
    // which matches the Seq in the echo control block we just linked.  If
    // this happens, it will be completed via CompleteEcho and we do not
    // want to risk double-completion by returning anything other than
    // pending from here on.
    //

    RcvBuf.ipr_next = NULL;
    RcvBuf.ipr_buffer = Data;
    RcvBuf.ipr_size = DataSize;

    Status = SendEcho(Dest, NTE->nte_addr, ICMP_ECHO, NTE->nte_context,
                      Seq, &RcvBuf, DataSize, &NewOptInfo);

    IPFreeOptions(&NewOptInfo);

    if (Status != IP_PENDING && Status != IP_SUCCESS) {
        EchoControl *FoundEC;
        // We had an error on the send.  We need to complete the request
        // but only if it has not already been completed.  (We can get
        // an "error" via IpSec negotiating security, but the reply may
        // have already been received which would cause CompleteEcho to be
        // invoked.  Therefore, we must lookup the echo control by sequence
        // number and only complete it here if it was found (not already
        // completed.)
        FoundEC = DeleteEC(NTE, Seq, FALSE);
        if (FoundEC == ControlBlock) {
            FoundEC->ec_rtn(FoundEC, Status, NULL, 0, NULL);
        }
    } else {
        EchoControl *Current;

        // If the request is still pending, activate the timer
        CTEGetLock(&NTE->nte_lock, &Handle);
        for (Current = NTE->nte_echolist; Current != (EchoControl *) NULL;
            Current = Current->ec_next) {
            if (Current->ec_seq == Seq) {
                Current->ec_active = 1;    // start the timer
                break;
            }
        }
        CTEFreeLock(&NTE->nte_lock, Handle);
    }

    return IP_PENDING;
}

//** ICMPEchoRequest - Common dispatch routine for echo requests
//
//  This is the routine called by the OS-specific code on behalf of a user to
//  issue an echo request.
//
//  Entry:  InputBuffer       - Pointer to an ICMP_ECHO_REQUEST structure.
//          InputBufferLength - Size in bytes of the InputBuffer.
//          ControlBlock      - Pointer to an EchoControl structure. This
//                                structure must remain valid until the
//                                request completes.
//          Callback        - Routine to call when request is responded to
//                                or times out.
//
//  Returns: IP_STATUS of attempt to ping.
//
IP_STATUS
ICMPEchoRequest(void *InputBuffer, uint InputBufferLength,
                EchoControl *ControlBlock, EchoRtn Callback)
{
    PICMP_ECHO_REQUEST requestBuffer;
    struct IPOptInfo optionInfo;
    PUCHAR endOfRequestBuffer;
    IP_STATUS status;

    PAGED_CODE();

    requestBuffer = (PICMP_ECHO_REQUEST) InputBuffer;
    endOfRequestBuffer = ((PUCHAR) requestBuffer) + InputBufferLength;

    //
    // Validate the request.
    //
    if (InputBufferLength < sizeof(ICMP_ECHO_REQUEST)) {
        status = IP_BUF_TOO_SMALL;
        goto common_echo_exit;
    }
    if (requestBuffer->DataSize > 0) {

        if (((PUCHAR)requestBuffer + requestBuffer->DataSize > endOfRequestBuffer) ||
          ((PUCHAR)requestBuffer + requestBuffer->DataOffset > endOfRequestBuffer)){
            status = IP_GENERAL_FAILURE;
            goto common_echo_exit;
        }

        if ((requestBuffer->DataOffset < sizeof(ICMP_ECHO_REQUEST)) ||
            (((PUCHAR) requestBuffer + requestBuffer->DataOffset +
              requestBuffer->DataSize) > endOfRequestBuffer)) {
            status = IP_GENERAL_FAILURE;
            goto common_echo_exit;
        }
    }
    if (requestBuffer->OptionsSize > 0) {

        if (((PUCHAR)requestBuffer->OptionsOffset > endOfRequestBuffer) ||
          ((PUCHAR)requestBuffer->OptionsSize > endOfRequestBuffer)){
            status = IP_GENERAL_FAILURE;
            goto common_echo_exit;

        }

        if ((requestBuffer->OptionsOffset < sizeof(ICMP_ECHO_REQUEST)) ||
            (((PUCHAR) requestBuffer + requestBuffer->OptionsOffset +
              requestBuffer->OptionsSize) > endOfRequestBuffer)) {
            status = IP_GENERAL_FAILURE;
            goto common_echo_exit;
        }
    }
    RtlZeroMemory(&optionInfo, sizeof(IPOptInfo));
    //
    // Copy the options to a local structure.
    //
    if (requestBuffer->OptionsValid) {
        optionInfo.ioi_optlength = requestBuffer->OptionsSize;

        if (requestBuffer->OptionsSize > 0) {
            optionInfo.ioi_options = ((uchar *) requestBuffer) +
                requestBuffer->OptionsOffset;
        } else {
            optionInfo.ioi_options = NULL;
        }
        optionInfo.ioi_addr = 0;
        optionInfo.ioi_ttl = requestBuffer->Ttl;
        optionInfo.ioi_tos = requestBuffer->Tos;
        optionInfo.ioi_flags = requestBuffer->Flags;
        optionInfo.ioi_flags &= ~IP_FLAG_IPSEC;

    } else {
        optionInfo.ioi_optlength = 0;
        optionInfo.ioi_options = NULL;
        optionInfo.ioi_addr = 0;
        optionInfo.ioi_ttl = DEFAULT_TTL;
        optionInfo.ioi_tos = 0;
        optionInfo.ioi_flags = 0;
    }

    status = ICMPEcho(
                      ControlBlock,
                      requestBuffer->Timeout,
                      ((uchar *) requestBuffer) + requestBuffer->DataOffset,
                      requestBuffer->DataSize,
                      Callback,
                      (IPAddr) requestBuffer->Address,
                      &optionInfo);

  common_echo_exit:

    return (status);

} // ICMPEchoRequest

//** ICMPEchoComplete - Common completion routine for echo requests
//
//  This is the routine is called by the OS-specific code to process an
//  ICMP echo response.
//
//  Entry:  OutputBuffer       - Pointer to an ICMP_ECHO_REPLY structure.
//          OutputBufferLength - Size in bytes of the OutputBuffer.
//          Status             - The status of the reply.
//          Data               - The reply data (may be NULL).
//          DataSize           - The amount of reply data.
//          OptionInfo         - A pointer to the reply options
//
//  Returns: The number of bytes written to the output buffer
//
ulong
ICMPEchoComplete(EchoControl * ControlBlock, IP_STATUS Status, void *Data,
                 uint DataSize, struct IPOptInfo * OptionInfo)
{
    PICMP_ECHO_REPLY    replyBuffer;
    IPRcvBuf            *dataBuffer;
    uchar               *replyData;
    uchar               *replyOptionsData;
    uchar               optionsLength;
    uchar               *tmp;
    ulong               bytesReturned = sizeof(ICMP_ECHO_REPLY);

    replyBuffer = (PICMP_ECHO_REPLY)ControlBlock->ec_replybuf;
    dataBuffer = (IPRcvBuf *)Data;

    if (OptionInfo != NULL) {
        optionsLength = OptionInfo->ioi_optlength;
    } else {
        optionsLength = 0;
    }

    //
    // Initialize the reply buffer
    //
    replyBuffer->Options.OptionsSize = 0;
    replyBuffer->Options.OptionsData = (PUCHAR)(replyBuffer + 1);
    replyBuffer->DataSize = 0;
    replyBuffer->Data = replyBuffer->Options.OptionsData;

    replyOptionsData = (uchar*)(replyBuffer + 1);
    replyData = replyOptionsData;

    if ((Status != IP_SUCCESS) && (DataSize == 0)) {
        //
        // Timed out or internal error.
        //
        replyBuffer->Reserved = 0;    // indicate no replies.

        replyBuffer->Status = Status;
    } else {
        if (Status != IP_SUCCESS) {
            //
            // A message other than an echo reply was received.
            // The IP Address of the system that reported the error is
            // in the data buffer. There is no other data.
            //
            ASSERT(dataBuffer->ipr_size == sizeof(IPAddr));

            RtlCopyMemory(&(replyBuffer->Address), dataBuffer->ipr_buffer,
                          sizeof(IPAddr));

            DataSize = 0;
            dataBuffer = NULL;
        } else {
            // If there were no timeouts or errors, store the source
            // address in the reply buffer.
            //
            replyBuffer->Address = ControlBlock->ec_src;
        }

        //
        // Check that the reply buffer is large enough to hold all the data.
        //
        if (ControlBlock->ec_replybuflen <
            (sizeof(ICMP_ECHO_REPLY) + DataSize + optionsLength)) {
            //
            // Not enough space to hold the reply.
            //
            replyBuffer->Reserved = 0;    // indicate no replies

            replyBuffer->Status = IP_BUF_TOO_SMALL;
        } else {
            LARGE_INTEGER Now, Freq;

            replyBuffer->Reserved = 1;    // indicate one reply
            replyBuffer->Status = Status;

            Now = KeQueryPerformanceCounter(&Freq);
            replyBuffer->RoundTripTime = (uint)
                ((1000 * (Now.QuadPart - ControlBlock->ec_starttime.QuadPart))
                            / Freq.QuadPart);

            //
            // Copy the reply options.
            //
            if (OptionInfo != NULL) {
                replyBuffer->Options.Ttl = OptionInfo->ioi_ttl;
                replyBuffer->Options.Tos = OptionInfo->ioi_tos;
                replyBuffer->Options.Flags = OptionInfo->ioi_flags;
                replyBuffer->Options.OptionsSize = optionsLength;

                if (optionsLength > 0) {

                    RtlCopyMemory(replyOptionsData,
                                  OptionInfo->ioi_options, optionsLength);
                }
            }

            //
            // Copy the reply data
            //
            replyBuffer->DataSize = (ushort) DataSize;
            replyData = replyOptionsData + replyBuffer->Options.OptionsSize;

            if (DataSize > 0) {
                uint bytesToCopy;

                ASSERT(Data != NULL);

                tmp = replyData;

                while (DataSize) {
                    ASSERT(dataBuffer != NULL);

                    bytesToCopy =
                        (DataSize > dataBuffer->ipr_size)
                            ? dataBuffer->ipr_size : DataSize;

                    RtlCopyMemory(tmp, dataBuffer->ipr_buffer, bytesToCopy);

                    tmp += bytesToCopy;
                    DataSize -= bytesToCopy;
                    dataBuffer = dataBuffer->ipr_next;
                }
            }
            bytesReturned += replyBuffer->DataSize + optionsLength;

            //
            // Convert the kernel-mode pointers to offsets from start of reply
            // buffer.
            //
            replyBuffer->Options.OptionsData =
                (PUCHAR)((ULONG_PTR)replyOptionsData - (ULONG_PTR)replyBuffer);

            replyBuffer->Data =
                (PVOID)((ULONG_PTR)replyData - (ULONG_PTR)replyBuffer);
        }
    }

    return (bytesReturned);
}

#if defined(_WIN64)

//** ICMPEchoComplete32 - common completion routine for 32-bit client requests.
//
//  This is the routine called by the OS-specific request handler to complete
//  processing of an ICMP echo-request issued by a 32-bit client on Win64.
//
//  Entry:  see ICMPEchoComplete.
//
//  Returns:    see ICMPEchoComplete.
//
ulong
ICMPEchoComplete32(EchoControl * ControlBlock, IP_STATUS Status, void *Data,
                   uint DataSize, struct IPOptInfo * OptionInfo)
{
    PICMP_ECHO_REPLY32  replyBuffer;
    IPRcvBuf            *dataBuffer;
    uchar               *replyData;
    uchar               *replyOptionsData;
    uchar               optionsLength;
    uchar               *tmp;
    ulong               bytesReturned = sizeof(ICMP_ECHO_REPLY32);

    replyBuffer = (PICMP_ECHO_REPLY32)ControlBlock->ec_replybuf;
    dataBuffer = (IPRcvBuf *)Data;

    if (OptionInfo != NULL) {
        optionsLength = OptionInfo->ioi_optlength;
    } else {
        optionsLength = 0;
    }

    //
    // Initialize the reply buffer
    //
    replyBuffer->Options.OptionsSize = 0;
    replyBuffer->Options.OptionsData = (UCHAR* POINTER_32)(replyBuffer + 1);
    replyBuffer->DataSize = 0;
    replyBuffer->Data = replyBuffer->Options.OptionsData;

    replyOptionsData = (uchar*)(replyBuffer + 1);
    replyData = replyOptionsData;

    if ((Status != IP_SUCCESS) && (DataSize == 0)) {
        //
        // Timed out or internal error.
        //
        replyBuffer->Reserved = 0;    // indicate no replies.

        replyBuffer->Status = Status;
    } else {
        if (Status != IP_SUCCESS) {
            //
            // A message other than an echo reply was received.
            // The IP Address of the system that reported the error is
            // in the data buffer. There is no other data.
            //
            ASSERT(dataBuffer->ipr_size == sizeof(IPAddr));

            RtlCopyMemory(&(replyBuffer->Address), dataBuffer->ipr_buffer,
                          sizeof(IPAddr));

            DataSize = 0;
            dataBuffer = NULL;
        } else {
            // If there were no timeouts or errors, store the source
            // address in the reply buffer.
            //
            replyBuffer->Address = ControlBlock->ec_src;
        }

        //
        // Check that the reply buffer is large enough to hold all the data.
        //
        if (ControlBlock->ec_replybuflen <
            (sizeof(ICMP_ECHO_REPLY) + DataSize + optionsLength)) {
            //
            // Not enough space to hold the reply.
            //
            replyBuffer->Reserved = 0;    // indicate no replies

            replyBuffer->Status = IP_BUF_TOO_SMALL;
        } else {
            LARGE_INTEGER Now, Freq;

            replyBuffer->Reserved = 1;    // indicate one reply
            replyBuffer->Status = Status;

            Now = KeQueryPerformanceCounter(&Freq);
            replyBuffer->RoundTripTime = (uint)
                ((1000 * (Now.QuadPart - ControlBlock->ec_starttime.QuadPart))
                            / Freq.QuadPart);

            //
            // Copy the reply options.
            //
            if (OptionInfo != NULL) {
                replyBuffer->Options.Ttl = OptionInfo->ioi_ttl;
                replyBuffer->Options.Tos = OptionInfo->ioi_tos;
                replyBuffer->Options.Flags = OptionInfo->ioi_flags;
                replyBuffer->Options.OptionsSize = optionsLength;

                if (optionsLength > 0) {

                    RtlCopyMemory(replyOptionsData,
                                  OptionInfo->ioi_options, optionsLength);
                }
            }

            //
            // Copy the reply data
            //
            replyBuffer->DataSize = (ushort) DataSize;
            replyData = replyOptionsData + replyBuffer->Options.OptionsSize;

            if (DataSize > 0) {
                uint bytesToCopy;

                ASSERT(Data != NULL);

                tmp = replyData;

                while (DataSize) {
                    ASSERT(dataBuffer != NULL);

                    bytesToCopy =
                        (DataSize > dataBuffer->ipr_size)
                            ? dataBuffer->ipr_size : DataSize;

                    RtlCopyMemory(tmp, dataBuffer->ipr_buffer, bytesToCopy);

                    tmp += bytesToCopy;
                    DataSize -= bytesToCopy;
                    dataBuffer = dataBuffer->ipr_next;
                }
            }
            bytesReturned += replyBuffer->DataSize + optionsLength;

            //
            // Convert the kernel-mode pointers to offsets from start of reply
            // buffer.
            //
            replyBuffer->Options.OptionsData =
                (UCHAR * POINTER_32)
                    ((ULONG_PTR)replyOptionsData - (ULONG_PTR)replyBuffer);

            replyBuffer->Data =
                (VOID * POINTER_32)
                    ((ULONG_PTR)replyData - (ULONG_PTR)replyBuffer);
        }
    }

    return (bytesReturned);
}

#endif // _WIN64

#pragma BEGIN_INIT
//** ICMPInit - Initialize ICMP.
//
//  This routine initializes ICMP. All we do is allocate and link up some header buffers,
/// and register our protocol with IP.
//
//  Entry:  NumBuffers  - Number of ICMP buffers to allocate.
//
//  Returns: Nothing
//
void
ICMPInit(uint NumBuffers)
{
    IcmpHeaderPool = MdpCreatePool(BUFSIZE_ICMP_HEADER_POOL, 'chCT');

    IPRegisterProtocol(PROT_ICMP, ICMPRcv, ICMPSendComplete, ICMPStatus, NULL, NULL, NULL);
}

#pragma END_INIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipv4\igmp.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

  igmp.c - IP multicast routines.

Abstract:

  This file contains all the routines related to the Internet Group Management
  Protocol (IGMP).

Author:


[Environment:]

    kernel mode only

[Notes:]

    optional-notes

Revision History:
    Feb. 2000 - upgraded to IGMPv3  (DThaler)

--*/

#include "precomp.h"
#include "mdlpool.h"
#include "igmp.h"
#include "icmp.h"
#include "ipxmit.h"
#include "iproute.h"

#if GPC
#include "qos.h"
#include "traffic.h"
#include "gpcifc.h"
#include "ntddtc.h"

extern GPC_HANDLE hGpcClient[];
extern ULONG GpcCfCounts[];

extern GPC_EXPORTED_CALLS GpcEntries;
extern ULONG GPCcfInfo;
extern ULONG ServiceTypeOffset;
#endif

extern uint DisableUserTOS;
extern uint DefaultTOS;

#define IGMP_QUERY          0x11    // Membership query
#define IGMP_REPORT_V1      0x12    // Version 1 membership report
#define IGMP_REPORT_V2      0x16    // Version 2 membership report
#define IGMP_LEAVE          0x17    // Leave Group
#define IGMP_REPORT_V3      0x22    // Version 3 membership report

// IGMPv3 Group Record Types
#define MODE_IS_INCLUDE        1
#define MODE_IS_EXCLUDE        2
#define CHANGE_TO_INCLUDE_MODE 3
#define CHANGE_TO_EXCLUDE_MODE 4
#define ALLOW_NEW_SOURCES      5
#define BLOCK_OLD_SOURCES      6

#define ALL_HOST_MCAST      0x010000E0
#define IGMPV3_RTRS_MCAST   0x160000E0

#define UNSOLICITED_REPORT_INTERVAL 2 // used when sending a report after a
                                      // mcast group has been added.  The
                                      // report is sent at a interval of
                                      // 0 msecs to 1 sec.  IGMPv3 spec
                                      // changed this from previous value
                                      // of 10 seconds (value 20)

#define DEFAULT_ROBUSTNESS  2

static uchar g_IgmpRobustness = DEFAULT_ROBUSTNESS;

//
//  The following values are used to initialize counters that keep time in
//  1/2 a sec.
//
#define DEFAULT_QUERY_RESP_INTERVAL 100 // 10 seconds, note different units from other defines

#define DEFAULT_QUERY_INTERVAL      250     // 125 secs, per spec

// Macro to test whether a source passes the network-layer filter
#define IS_SOURCE_ALLOWED(Grp, Src) \
     (((Src)->isa_xrefcnt != (Grp)->iga_grefcnt) || ((Src)->isa_irefcnt != 0))

// Macro to test whether a group should pass the link-layer filter
#define IS_GROUP_ALLOWED(Grp) \
    (((Grp)->iga_grefcnt != 0) || ((Grp)->iga_srclist != NULL))

#define IS_SOURCE_DELETABLE(Src) \
    (((Src)->isa_irefcnt == 0) && ((Src)->isa_xrefcnt == 0) \
     && ((Src)->isa_xmitleft==0) && ((Src)->isa_csmarked == 0))

#define IS_GROUP_DELETABLE(Grp) \
    (!IS_GROUP_ALLOWED(Grp) && ((Grp)->iga_xmitleft == 0) \
     && ((Grp)->iga_resptimer == 0))

int RandomValue;
int Seed;

// Structure of an IGMPv1/v2 header.
typedef struct IGMPHeader {
    uchar igh_vertype;         //  Type of igmp message
    uchar igh_rsvd;            // max. resp. time for igmpv2 query;
                               // max. resp. code for igmpv3 query;
                               // will be 0 for other messages
    ushort igh_xsum;
    IPAddr igh_addr;
} IGMPHeader;

typedef struct IGMPv3GroupRecord {
    uchar  igr_type;
    uchar  igr_datalen;
    ushort igr_numsrc;
    IPAddr igr_addr;
    IPAddr igr_srclist[0];
} IGMPv3GroupRecord;

#define RECORD_SIZE(numsrc, datalen) (sizeof(IGMPv3GroupRecord) + (numsrc) * sizeof(IPAddr) + (datalen * sizeof(ulong)))

typedef struct IGMPv3RecordQueueEntry {
    struct IGMPv3RecordQueueEntry *i3qe_next;
    IGMPv3GroupRecord             *i3qe_buff;
    uint                           i3qe_size;
} IGMPv3RecordQueueEntry;

typedef struct IGMPReportQueueEntry {
    struct IGMPReportQueueEntry   *iqe_next;
    IGMPHeader                    *iqe_buff;
    uint                           iqe_size;
    IPAddr                         iqe_dest;
} IGMPReportQueueEntry;

typedef struct IGMPv3ReportHeader {
    uchar  igh_vertype;         //  Type of igmp message
    uchar  igh_rsvd;
    ushort igh_xsum;
    ushort igh_rsvd2;
    ushort igh_numrecords;
} IGMPv3ReportHeader;

typedef struct IGMPv3QueryHeader {
    uchar igh_vertype;         //  Type of igmp message
    union {
        uchar igh_maxresp;     // will be 0 for igmpv1 messages
        struct {
            uchar igh_mrcmant : 4;  // MaxRespCode mantissa
            uchar igh_mrcexp  : 3;  // MaxRespCode exponent
            uchar igh_mrctype : 1;  // MaxRespCode type
        };
    };
    ushort igh_xsum;
    IPAddr igh_addr;

    uchar  igh_qrv   : 3;
    uchar  igh_s     : 1;
    uchar  igh_rsvd2 : 4;

    uchar  igh_qqic;
    ushort igh_numsrc;
    IPAddr igh_srclist[0];
} IGMPv3QueryHeader;

#define IGMPV3_QUERY_SIZE(NumSrc) \
    (sizeof(IGMPv3QueryHeader) + (NumSrc) * sizeof(IPAddr))

#define TOTAL_HEADER_LENGTH \
    (sizeof(IPHeader) + ROUTER_ALERT_SIZE + sizeof(IGMPv3ReportHeader))

#define RECORD_MTU(NTE)  \
    (4 * (((NTE)->nte_if->if_mtu - TOTAL_HEADER_LENGTH) / 4))

typedef struct IGMPBlockStruct {
    struct IGMPBlockStruct *ibs_next;
    CTEBlockStruc ibs_block;
} IGMPBlockStruct;

void *IGMPProtInfo;

IGMPBlockStruct *IGMPBlockList;
uchar IGMPBlockFlag;

extern BOOLEAN CopyToNdisSafe(PNDIS_BUFFER DestBuf, PNDIS_BUFFER * ppNextBuf,
                              uchar * SrcBuf, uint Size, uint * StartOffset);
extern NDIS_HANDLE BufferPool;

DEFINE_LOCK_STRUCTURE(IGMPLock)
extern ProtInfo *RawPI;            // Raw IP protinfo

//
// the global address for unnumbered interfaces
//

extern IPAddr g_ValidAddr;

extern IP_STATUS IPCopyOptions(uchar *, uint, IPOptInfo *);
extern void IPInitOptions(IPOptInfo *);
extern void *IPRegisterProtocol(uchar Protocol, void *RcvHandler,
                                void *XmitHandler, void *StatusHandler,
                                void *RcvCmpltHandler, void *PnPHandler,
                                void *ElistHandler);

extern ushort XsumBufChain(IPRcvBuf * BufChain);

uint IGMPInit(void);

//
// All of the init code can be discarded
//
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, IGMPInit)
#endif // ALLOC_PRAGMA


//** GetIGMPBuffer - Get an IGMP buffer, and allocate an NDIS_BUFFER that maps it.
//
//  A routine to allocate an IGMP buffer and map an NDIS_BUFFER to it.
//
//  Entry:  Size    - Size in bytes header buffer should be mapped as.
//          Buffer  - Pointer to pointer to NDIS_BUFFER to return.
//
//  Returns: Pointer to ICMP buffer if allocated, or NULL.
//
__inline
IGMPHeader *
GetIGMPBuffer(uint Size, PNDIS_BUFFER *Buffer)
{
    IGMPHeader *Header;

    ASSERT(Size);
    ASSERT(Buffer);

    *Buffer = MdpAllocate(IcmpHeaderPool, &Header);

    if (*Buffer) {
        NdisAdjustBufferLength(*Buffer, Size);

        // Reserve room for the IP Header.
        //
        Header = (IGMPHeader *)((uchar *)Header + sizeof(IPHeader));
    }

    return Header;
}

//** FreeIGMPBuffer - Free an ICMP buffer.
//
//  This routine puts an ICMP buffer back on our free list.
//
//  Entry:  Buffer      - Pointer to NDIS_BUFFER to be freed.
//          Type        - ICMP header type
//
//  Returns: Nothing.
//
__inline
void
FreeIGMPBuffer(PNDIS_BUFFER Buffer)
{

    MdpFree(Buffer);
}


//** IGMPSendComplete - Complete an IGMP send.
//
//  This rtn is called when an IGMP send completes. We free the header buffer,
//  the data buffer if there is one, and the NDIS_BUFFER chain.
//
//  Entry:  DataPtr     - Pointer to data buffer, if any.
//          BufferChain - Pointer to NDIS_BUFFER chain.
//
//  Returns: Nothing
//
void
IGMPSendComplete(void *DataPtr, PNDIS_BUFFER BufferChain, IP_STATUS SendStatus)
{
    PNDIS_BUFFER DataBuffer;

    NdisGetNextBuffer(BufferChain, &DataBuffer);
    FreeIGMPBuffer(BufferChain);

    if (DataBuffer != (PNDIS_BUFFER) NULL) {    // We had data with this IGMP send.
        CTEFreeMem(DataPtr);
        NdisFreeBuffer(DataBuffer);
    }
}



//* IGMPRandomTicks - Generate a random value of timer ticks.
//
//  A random number routine to generate a random number of timer ticks,
//  between 1 and time (in units of half secs) passed. The random number
//  algorithm is adapted from the book 'System Simulation' by Geoffrey Gordon.
//
//  Input:  Nothing.
//
//  Returns: A random value between 1 and TimeDelayInHalfSec.
//
uint
IGMPRandomTicks(
    IN uint TimeDelayInHalfSec)
{

    RandomValue = RandomValue * 1220703125;

    if (RandomValue < 0) {
        RandomValue += 2147483647;    // inefficient, but avoids warnings.

        RandomValue++;
    }
    // Not sure if RandomValue can get to 0, but if it does the algorithm
    // degenerates, so fix this if it happens.
    if (RandomValue == 0)
        RandomValue = ((Seed + (int)CTESystemUpTime()) % 100000000) | 1;

    return (uint) (((uint) RandomValue % TimeDelayInHalfSec) + 1);
}


//////////////////////////////////////////////////////////////////////////////
// Routines accessing group entries
//////////////////////////////////////////////////////////////////////////////

//* FindIGMPAddr - Find an mcast entry on an NTE.
//
//      Called to search an NTE for an IGMP entry for a given multicast address.
//      We walk down the chain on the NTE looking for it. If we find it,
//      we return a pointer to it and the one immediately preceding it. If we
//      don't find it we return NULL. We assume the caller has taken the lock
//      on the NTE before calling us.
//
//      Input:  NTE             - NTE on which to search.
//              Addr            - Class D address to find.
//              PrevPtr         - Where to return pointer to preceding entry.
//
//      Returns: Pointer to matching IGMPAddr structure if found, or NULL if not
//               found.
//
IGMPAddr *
FindIGMPAddr(
    IN  NetTableEntry *NTE,
    IN  IPAddr         Addr,
    OUT IGMPAddr     **PrevPtr OPTIONAL)
{
    int bucket;
    IGMPAddr *Current, *Temp;
    IGMPAddr **AddrPtr;

    AddrPtr = NTE->nte_igmplist;

    if (AddrPtr != NULL) {
        bucket = IGMP_HASH(Addr);
        Temp = STRUCT_OF(IGMPAddr, &AddrPtr[bucket], iga_next);
        Current = AddrPtr[bucket];

        while (Current != NULL) {
            if (IP_ADDR_EQUAL(Current->iga_addr, Addr)) {
                // Found a match, so return it.
                if (PrevPtr) {
                    *PrevPtr = Temp;
                }
                return Current;
            }
            Temp = Current;
            Current = Current->iga_next;
        }
    }
    return NULL;
}

//* CreateIGMPAddr - Allocate memory and link the new IGMP address in
//
// Input:  NTE      - NetTableEntry to add group on
//         Addr     - Group address to add
//
// Output: pAddrPtr - group entry added
//         pPrevPtr - previous group entry
//
// Assumes caller holds lock on NTE.
//
IP_STATUS
CreateIGMPAddr(
    IN  NetTableEntry *NTE,
    IN  IPAddr         Addr,
    OUT IGMPAddr     **pAddrPtr,
    OUT IGMPAddr     **pPrevPtr)
{
    int       bucket;
    IGMPAddr *AddrPtr;
    uint      AddrAdded;

    // If this is not a multicast address, fail the request.
    if (!CLASSD_ADDR(Addr)) {
        return IP_BAD_REQ;
    }

    AddrPtr = CTEAllocMemN(sizeof(IGMPAddr), 'yICT');
    if (AddrPtr == NULL) {
        return IP_NO_RESOURCES;
    }

    // See if we added it succesfully. If we did, fill in
    // the structure and link it in.

    CTEMemSet(AddrPtr, 0, sizeof(IGMPAddr));
    AddrPtr->iga_addr = Addr;

    // check whether the hash table has been allocated
    if (NTE->nte_igmpcount == 0) {
        NTE->nte_igmplist = CTEAllocMemN(IGMP_TABLE_SIZE * sizeof(IGMPAddr *),
                                         'VICT');
        if (NTE->nte_igmplist) {
            CTEMemSet(NTE->nte_igmplist, 0,
                      IGMP_TABLE_SIZE * sizeof(IGMPAddr *));
        }
    }

    if (NTE->nte_igmplist == NULL) {
        // Alloc failure. Free the memory and fail the request.
        CTEFreeMem(AddrPtr);
        return IP_NO_RESOURCES;
    }

    NTE->nte_igmpcount++;
    bucket = IGMP_HASH(Addr);
    AddrPtr->iga_next = NTE->nte_igmplist[bucket];
    NTE->nte_igmplist[bucket] = AddrPtr;

    *pAddrPtr = AddrPtr;
    *pPrevPtr = STRUCT_OF(IGMPAddr, &NTE->nte_igmplist[bucket], iga_next);

    return IP_SUCCESS;
}

//* FindOrCreateIGMPAddr - Find or create a group entry
//
// Input:  NTE      - NetTableEntry to add group on
//         Addr     - Group address to add
//
// Output: pGrp     - group entry found or added
//         pPrevGrp - previous group entry
//
// Assumes caller holds lock on NTE
IP_STATUS
FindOrCreateIGMPAddr(
    IN  NetTableEntry *NTE,
    IN  IPAddr         Addr,
    OUT IGMPAddr     **pGrp,
    OUT IGMPAddr     **pPrevGrp)
{
    *pGrp = FindIGMPAddr(NTE, Addr, pPrevGrp);
    if (*pGrp)
        return IP_SUCCESS;

    return CreateIGMPAddr(NTE, Addr, pGrp, pPrevGrp);
}

//* DeleteIGMPAddr - delete a group entry
//
// Input:  NTE      - NetTableEntry to add group on
//         PrevPtr  - Previous group entry
//         pPtr     - Group entry to delete
//
// Output: pPtr     - zeroed since group entry is freed
//
// Assumes caller holds lock on NTE
void
DeleteIGMPAddr(
    IN     NetTableEntry *NTE,
    IN     IGMPAddr      *PrevPtr,
    IN OUT IGMPAddr     **pPtr)
{
    // Make sure all references have been released and retransmissions are done
    ASSERT(IS_GROUP_DELETABLE(*pPtr));

    // Unlink from the NTE
    PrevPtr->iga_next = (*pPtr)->iga_next;
    NTE->nte_igmpcount--;

    // Free the hash table if needed
    if (NTE->nte_igmpcount == 0) {
        CTEFreeMem(NTE->nte_igmplist);
        NTE->nte_igmplist = NULL;
    }

    // Free memory
    CTEFreeMem(*pPtr);
    *pPtr = NULL;
}

//////////////////////////////////////////////////////////////////////////////
// Routines accessing source entries
//////////////////////////////////////////////////////////////////////////////

//* FindIGMPSrcAddr - Find an mcast source entry on a source list.
//
//      Called to search an NTE for an IGMP source entry for a given address.
//      We walk down the chain on the group entry looking for it. If we find it,
//      we return a pointer to it and the one immediately preceding it. If we
//      don't find it we return NULL. We assume the caller has taken the lock
//      on the NTE before calling us.
//
//      Input:  IGA             - group entry on which to search.
//              Addr            - source address to find.
//              PrevPtr         - Where to return pointer to preceding entry.
//
//      Returns: Pointer to matching IGMPSrcAddr structure if found, or NULL
//                  if not found.
//
IGMPSrcAddr *
FindIGMPSrcAddr(
    IN  IGMPAddr     *IGA,
    IN  IPAddr        Addr,
    OUT IGMPSrcAddr **PrevPtr OPTIONAL)
{
    IGMPSrcAddr *Current, *Temp;

    Temp = STRUCT_OF(IGMPSrcAddr, &IGA->iga_srclist, isa_next);
    Current = IGA->iga_srclist;

    while (Current != NULL) {
        if (IP_ADDR_EQUAL(Current->isa_addr, Addr)) {
            // Found a match, so return it.
            if (PrevPtr) {
                *PrevPtr = Temp;
            }
            return Current;
        }
        Temp = Current;
        Current = Current->isa_next;
    }
    return NULL;
}

//* CreateIGMPSrcAddr - Allocate memory and link the new source address in
//
//  Input:  GroupPtr    - group entry to add source to.
//          SrcAddr     - source address to add.
//
//  Output: pSrcPtr     - source entry added.
//          pPrevSrcPtr - previous source entry.
//
// Assumes caller holds lock on NTE.
//
IP_STATUS
CreateIGMPSrcAddr(
    IN  IGMPAddr     *GroupPtr,
    IN  IPAddr        SrcAddr,
    OUT IGMPSrcAddr **pSrcPtr,
    OUT IGMPSrcAddr **pPrevSrcPtr OPTIONAL)
{
    IGMPSrcAddr *SrcAddrPtr;

    // If this is a multicast address, fail the request.
    if (CLASSD_ADDR(SrcAddr)) {
        return IP_BAD_REQ;
    }

    // Allocate space for the new source entry
    SrcAddrPtr = CTEAllocMemN(sizeof(IGMPSrcAddr), 'yICT');
    if (SrcAddrPtr == NULL) {
        return IP_NO_RESOURCES;
    }

    // Initialize fields
    RtlZeroMemory(SrcAddrPtr, sizeof(IGMPSrcAddr));
    SrcAddrPtr->isa_addr    = SrcAddr;

    // Link it off the group entry
    SrcAddrPtr->isa_next = GroupPtr->iga_srclist;
    GroupPtr->iga_srclist = SrcAddrPtr;

    *pSrcPtr = SrcAddrPtr;
    if (pPrevSrcPtr)
        *pPrevSrcPtr = STRUCT_OF(IGMPSrcAddr, &GroupPtr->iga_srclist, isa_next);
    return IP_SUCCESS;
}

//* FindOrCreateIGMPSrcAddr - Find or create a source entry
//
//  Input:  GroupPtr    - group entry to add source to.
//          SrcAddr     - source address to add.
//
//  Output: pSrcPtr     - source entry added.
//          pPrevSrcPtr - previous source entry.
//
// Assumes caller holds lock on NTE
IP_STATUS
FindOrCreateIGMPSrcAddr(
    IN  IGMPAddr      *AddrPtr,
    IN  IPAddr         SrcAddr,
    OUT IGMPSrcAddr  **pSrc,
    OUT IGMPSrcAddr  **pPrevSrc)
{
    *pSrc = FindIGMPSrcAddr(AddrPtr, SrcAddr, pPrevSrc);
    if (*pSrc)
        return IP_SUCCESS;

    return CreateIGMPSrcAddr(AddrPtr, SrcAddr, pSrc, pPrevSrc);
}

//* DeleteIGMPSrcAddr - delete a source entry
//
//  Input:  pSrcPtr    - source entry added.
//          PrevSrcPtr - previous source entry.
//
//  Output: pSrcPtr    - zeroed since source entry is freed.
//
// Caller is responsible for freeing group entry if needed
// Assumes caller holds lock on NTE
void
DeleteIGMPSrcAddr(
    IN     IGMPSrcAddr  *PrevSrcPtr,
    IN OUT IGMPSrcAddr **pSrcPtr)
{
    // Make sure all references have been released
    // and no retransmissions are left
    ASSERT(IS_SOURCE_DELETABLE(*pSrcPtr));

    // Unlink from the group entry
    PrevSrcPtr->isa_next = (*pSrcPtr)->isa_next;

    // Free memory
    CTEFreeMem(*pSrcPtr);
    *pSrcPtr = NULL;
}

//////////////////////////////////////////////////////////////////////////////
// Timer routines
//////////////////////////////////////////////////////////////////////////////

//* ResetGeneralTimer - Reset timer for responding to a General Query in
//                      IGMPv3 mode
//
// Input: IF                   - Interface to reset timer on
//        MaxRespTimeInHalfSec - Maximum expiration time
void
ResetGeneralTimer(
    IN Interface *IF,
    IN uint       MaxRespTimeInHalfSec)
{
    if ((IF->IgmpGeneralTimer == 0) ||
        (IF->IgmpGeneralTimer > MaxRespTimeInHalfSec)) {
        IF->IgmpGeneralTimer = IGMPRandomTicks(MaxRespTimeInHalfSec);
    }

    // We could walk all groups here to stop any timers longer
    // than IF->IgmpGeneralTimer, but is it really worth it?
}

//* CancelGroupResponseTimer - stop a group timer
//
// Caller is responsible for deleting AddrPtr if no longer needed.
void
CancelGroupResponseTimer(
    IN IGMPAddr  *AddrPtr)
{
    IGMPSrcAddr *Src, *PrevSrc;

    AddrPtr->iga_resptimer = 0;
    AddrPtr->iga_resptype  = NO_RESP;

    // Make sure we never violate the invariant:
    // iga_resptimer>0 if isa_csmarked=TRUE for any source
    PrevSrc = STRUCT_OF(IGMPSrcAddr, &AddrPtr->iga_srclist, isa_next);
    for (Src=AddrPtr->iga_srclist; Src; PrevSrc=Src,Src=Src->isa_next) {
        Src->isa_csmarked = FALSE;

        if (IS_SOURCE_DELETABLE(Src)) {
           DeleteIGMPSrcAddr(PrevSrc, &Src);
           Src = PrevSrc;
        }
    }
}

//* ResetGroupResponseTimer - Reset timer for responding to a Group-specific
//                            Query, or an IGMPv1/v2 General Query.
//
// Input: IF                   - Interface to reset timer on.
//        AddrPtr              - Group entry whose timer should be reset.
//        MaxRespTimeInHalfSec - Maximum expiration time.
//
// Caller is responsible for deleting AddrPtr if no longer needed.
void
ResetGroupResponseTimer(
    IN Interface     *IF,
    IN IGMPAddr      *AddrPtr,
    IN uint           MaxRespTimeInHalfSec)
{
    if ((AddrPtr->iga_resptimer == 0) ||
        (AddrPtr->iga_resptimer > MaxRespTimeInHalfSec)) {
        AddrPtr->iga_resptimer = IGMPRandomTicks(MaxRespTimeInHalfSec);
    }

    // Check if superceded by a general query
    if ((IF->IgmpGeneralTimer != 0)
     && (IF->IgmpGeneralTimer <= AddrPtr->iga_resptimer)) {
        CancelGroupResponseTimer(AddrPtr);
        return;
    }

    // Supercede group-source responses
    AddrPtr->iga_resptype = GROUP_RESP;
}

//* ResetGroupAndSourceTimer - Reset timer for responding to a
//                             Group-and-source-specific Query
//
// Input: IF                   - Interface to reset timer on.
//        AddrPtr              - Group entry whose timer should be reset.
//        MaxRespTimeInHalfSec - Maximum expiration time.
//
// Caller is responsible for deleting AddrPtr if no longer needed
void
ResetGroupAndSourceTimer(
    IN Interface *IF,
    IN IGMPAddr  *AddrPtr,
    IN uint       MaxRespTimeInHalfSec)
{
    if ((AddrPtr->iga_resptimer == 0) ||
        (AddrPtr->iga_resptimer > MaxRespTimeInHalfSec)) {
        AddrPtr->iga_resptimer = IGMPRandomTicks(MaxRespTimeInHalfSec);
    }

    // Check if superceded by a general query
    if ((IF->IgmpGeneralTimer != 0)
     && (IF->IgmpGeneralTimer < AddrPtr->iga_resptimer)) {
        CancelGroupResponseTimer(AddrPtr);
        return;
    }

    // Check if superceded by a group-specific responses
    if (AddrPtr->iga_resptype == NO_RESP)
        AddrPtr->iga_resptype = GROUP_SOURCE_RESP;
}

//////////////////////////////////////////////////////////////////////////////
// Receive routines
//////////////////////////////////////////////////////////////////////////////

//* SetVersion - change the IGMP compatability mode on an interface.
//
// Input: NTE     - NetTableEntry on which to set IGMP version.
//        Version - IGMP version number to set
//
// Caller is responsible for deleting AddrPtr if no longer needed
void
SetVersion(
    IN NetTableEntry *NTE,
    IN uint           Version)
{
    IGMPAddr   **HashPtr, *AddrPtr, *PrevPtr;
    IGMPSrcAddr *Src, *PrevSrc;
    uint         i;

    DEBUGMSG(DBG_INFO && DBG_IGMP,
        (DTEXT("Setting version on interface %d to %d\n"),
        NTE->nte_if->if_index, Version));

    NTE->nte_if->IgmpVersion = Version;

    // Cancel General Timer
    NTE->nte_if->IgmpGeneralTimer = 0;

    //
    // Cancel all Group-Response and Triggered Retransmission timers
    //

    HashPtr = NTE->nte_igmplist;
    for (i = 0; (i < IGMP_TABLE_SIZE) && (NTE->nte_igmplist != NULL); i++) {
        PrevPtr = STRUCT_OF(IGMPAddr, &HashPtr[i], iga_next);
        for (AddrPtr = HashPtr[i];
             (AddrPtr != NULL);
             PrevPtr = AddrPtr, AddrPtr = AddrPtr->iga_next)
        {
            PrevSrc = STRUCT_OF(IGMPSrcAddr, &AddrPtr->iga_srclist, isa_next);
            for (Src=AddrPtr->iga_srclist; Src; PrevSrc=Src,Src=Src->isa_next) {
                Src->isa_xmitleft = 0;
                Src->isa_csmarked = FALSE;

                if (IS_SOURCE_DELETABLE(Src)) {
                   DeleteIGMPSrcAddr(PrevSrc, &Src);
                   Src = PrevSrc;
                }
            }

            AddrPtr->iga_trtimer    = 0;
            AddrPtr->iga_changetype = NO_CHANGE;
            AddrPtr->iga_xmitleft   = 0;

            CancelGroupResponseTimer(AddrPtr);

            if (IS_GROUP_DELETABLE(AddrPtr)) {
                DeleteIGMPAddr(NTE, PrevPtr, &AddrPtr);
                AddrPtr = PrevPtr;
            }

            if (NTE->nte_igmplist == NULL)
                break;
        }
    }
}

//* ProcessGroupQuery - process an IGMP Group-specific query
//
// Caller is responsible for deleting AddrPtr if no longer needed.
void
ProcessGroupQuery(
    IN Interface     *IF,
    IN IGMPAddr      *AddrPtr,
    IN uint           ReportingDelayInHalfSec)
{
    DEBUGMSG(DBG_TRACE && DBG_IGMP && DBG_RX,
        (DTEXT("Got group query on interface %d\n"), IF->if_index));

    // Ignore query if we won't report anything.  This will happen
    // right after we leave and have retransmissions pending.
    if (!IS_GROUP_ALLOWED(AddrPtr))
        return;

    ResetGroupResponseTimer(IF, AddrPtr, ReportingDelayInHalfSec);
}

//* ProcessGeneralQuery - Process an IGMP General Query
//
// Assumes caller holds lock on NTE
void
ProcessGeneralQuery(
    IN NetTableEntry *NTE,
    IN uint           ReportingDelayInHalfSec)
{
    IGMPAddr **HashPtr, *AddrPtr, *PrevPtr;
    uint       i;

    DEBUGMSG(DBG_TRACE && DBG_IGMP && DBG_RX,
        (DTEXT("Got general query on interface %d\n"),
        NTE->nte_if->if_index));

    if (NTE->nte_if->IgmpVersion == IGMPV3) {
        // IGMPv3 can pack multiple group records into the same report
        // and hence does not stagger the timers.

        // Create a pending response record
        ResetGeneralTimer(NTE->nte_if, ReportingDelayInHalfSec);
    } else {
        //
        // Walk our list and set a random report timer for all those
        // multicast addresses (except for the all-hosts address) that
        // don't already have one running.
        //
        HashPtr = NTE->nte_igmplist;

        for (i=0; (i < IGMP_TABLE_SIZE) && (NTE->nte_igmplist != NULL); i++) {
            PrevPtr = STRUCT_OF(IGMPAddr, &HashPtr[i], iga_next);
            for (AddrPtr = HashPtr[i];
                 (AddrPtr != NULL);
                 PrevPtr=AddrPtr, AddrPtr = AddrPtr->iga_next)
            {
                if (IP_ADDR_EQUAL(AddrPtr->iga_addr, ALL_HOST_MCAST))
                    continue;

                ProcessGroupQuery(NTE->nte_if, AddrPtr,
                                  ReportingDelayInHalfSec);

                if (IS_GROUP_DELETABLE(AddrPtr)) {
                    DeleteIGMPAddr(NTE, PrevPtr, &AddrPtr);
                    AddrPtr = PrevPtr;
                }

                if (NTE->nte_igmplist == NULL)
                    break;
            }
        }
    }
}

//* Process an IGMP Group-and-source-specific Query
//
// Caller is responsible for deleting AddrPtr if no longer needed
void
ProcessGroupAndSourceQuery(
    IN NetTableEntry               *NTE,
    IN IGMPv3QueryHeader UNALIGNED *IQH,
    IN IGMPAddr                    *AddrPtr,
    IN uint                         ReportingDelayInHalfSec)
{
    uint         i, NumSrc;
    IGMPSrcAddr *Src;
    IP_STATUS    Status = IP_SUCCESS;

    DEBUGMSG(DBG_TRACE && DBG_IGMP && DBG_RX,
        (DTEXT("Got source query on interface %d\n"),
        NTE->nte_if->if_index));

    NumSrc  = net_short(IQH->igh_numsrc);

    ResetGroupAndSourceTimer(NTE->nte_if, AddrPtr, ReportingDelayInHalfSec);

    // Mark each source
    for (i=0; i<NumSrc; i++) {
        Src = FindIGMPSrcAddr(AddrPtr, IQH->igh_srclist[i], NULL);
        if (!Src) {
            if (AddrPtr->iga_grefcnt == 0)
                continue;

            // Create temporary source state
            Status = CreateIGMPSrcAddr(AddrPtr, IQH->igh_srclist[i],
                                       &Src, NULL);

            // If this fails, we have a problem since we won't be
            // able to override the leave and a temporary black
            // hole would result.  To avoid this, we pretend we
            // just got a group-specific query instead.
            if (Status != IP_SUCCESS) {
                ProcessGroupQuery(NTE->nte_if, AddrPtr,
                                  ReportingDelayInHalfSec);
                break;
            }
        }

        // Mark source for current-state report inclusion
        Src->isa_csmarked = TRUE;
    }
}

//* Process an IGMP Query message
//
//  Entry:  NTE           - Pointer to NTE on which IGMP message was received.
//          Dest          - IPAddr of destination (should be a Class D address).
//          IPHdr         - Pointer to the IP Header.
//          IPHdrLength   - Bytes in IPHeader.
//          IQH           - Pointer to IGMP Query received.
//          Size          - Size in bytes of IGMP message.
//
// Assumes caller holds lock on NTE
void
IGMPRcvQuery(
    IN NetTableEntry               *NTE,
    IN IPAddr                       Dest,
    IN IPHeader UNALIGNED          *IPHdr,
    IN uint                         IPHdrLength,
    IN IGMPv3QueryHeader UNALIGNED *IQH,
    IN uint                         Size)
{
    uint ReportingDelayInHalfSec, MaxResp, NumSrc, i;
    IP_STATUS Status;
    IGMPAddr *AddrPtr, *PrevPtr;
    IGMPSrcAddr *Src, *PrevSrc;
    uchar QRV;

    // Make sure we're running at least level 2 of IGMP support.
    if (IGMPLevel != 2)
        return;

    NumSrc  = (Size >= 12)? net_short(IQH->igh_numsrc) : 0;
    QRV     = (Size >= 12)? IQH->igh_qrv : 0;

    // Update Robustness to match querier's robustness variable
    g_IgmpRobustness = (QRV)? QRV : DEFAULT_ROBUSTNESS;

    //
    // If it is an older-version query, set the timer value for staying in
    // older-version mode
    //
    if ((Size == 8) && (IQH->igh_maxresp == 0)) {
        if (NTE->nte_if->IgmpVersion > IGMPV1) {
            SetVersion(NTE, IGMPV1);
        }
        MaxResp = DEFAULT_QUERY_RESP_INTERVAL;
        NTE->nte_if->IgmpVer1Timeout = g_IgmpRobustness * DEFAULT_QUERY_INTERVAL
                                       + (MaxResp+4)/5;
    } else if ((Size == 8) && (IQH->igh_maxresp != 0)) {
        if (NTE->nte_if->IgmpVersion > IGMPV2) {
            SetVersion(NTE, IGMPV2);
        }
        MaxResp = IQH->igh_maxresp;
        NTE->nte_if->IgmpVer2Timeout = g_IgmpRobustness * DEFAULT_QUERY_INTERVAL
                                       + (MaxResp+4)/5;
    } else if ((Size < 12) || (IQH->igh_rsvd2 != 0)) {
        // must silently ignore

        DEBUGMSG(DBG_WARN && DBG_IGMP,
            (DTEXT("Dropping IGMPv3 query with unrecognized version\n")));

        return;
    } else {
        // IGMPv3

        uchar* ptr = ((uchar*)IPHdr) + sizeof(IPHeader);
        int len = IPHdrLength - sizeof(IPHeader);
        uchar temp;
        BOOLEAN bRtrAlertFound = FALSE;

        // drop it if size is too short for advertised # sources
        if (Size < IGMPV3_QUERY_SIZE(NumSrc)) {

            DEBUGMSG(DBG_WARN && DBG_IGMP,
                (DTEXT("Dropping IGMPv3 query due to size too short\n")));

            return;
        }

        // drop it if it didn't have router alert
        while (!bRtrAlertFound && len>=2) {
            if (ptr[0] == IP_OPT_ROUTER_ALERT) {
                bRtrAlertFound = TRUE;
                break;
            }
            temp = ptr[1]; // length
            ptr += temp;
            len -= temp;
        }

        if (!bRtrAlertFound) {
            DEBUGMSG(DBG_WARN && DBG_IGMP,
                (DTEXT("Dropping IGMPv3 query due to lack of Router Alert option\n")));
            return;
        }

        if (IQH->igh_mrctype == 0) {
            MaxResp = IQH->igh_maxresp;
        } else {
            MaxResp = ((((uint)IQH->igh_mrcmant) + 16) << (((uint)IQH->igh_mrcexp) + 3));
        }
    }
    DEBUGMSG(DBG_TRACE && DBG_IGMP && DBG_RX,
        (DTEXT("IGMPRcvQuery: Max response time = %d.%d seconds\n"),
        MaxResp/10, MaxResp%10));

    //
    // MaxResp has time in 100 msec (1/10 sec) units.  Convert
    // to 500 msec units.  If the time is < 500 msec, use 1.
    //
    ReportingDelayInHalfSec = ((MaxResp > 5) ? (MaxResp / 5) : 1);

    if (IQH->igh_addr == 0) {
        // General Query
        ProcessGeneralQuery(NTE, ReportingDelayInHalfSec);
    } else {
        // If all-hosts address, ignore it
        if (IP_ADDR_EQUAL(IQH->igh_addr, ALL_HOST_MCAST)) {
            DEBUGMSG(DBG_WARN && DBG_IGMP,
                (DTEXT("Dropping IGMPv3 query for the All-Hosts group\n")));
            return;
        }

        // Don't need to do anything if we have no group state for the group
        AddrPtr = FindIGMPAddr(NTE, IQH->igh_addr, &PrevPtr);
        if (!AddrPtr)
            return;

        if (NumSrc == 0) {
            // Group-specific query
            ProcessGroupQuery(NTE->nte_if, AddrPtr, ReportingDelayInHalfSec);

        } else {
            // Group-and-source-specific query
            ProcessGroupAndSourceQuery(NTE, IQH, AddrPtr,
                                       ReportingDelayInHalfSec);
        }

        // Delete group if no longer needed
        if (IS_GROUP_DELETABLE(AddrPtr))
            DeleteIGMPAddr(NTE, PrevPtr, &AddrPtr);
    }
}

//** IGMPRcv - Receive an IGMP datagram.
//
//      Called by IP when we receive an IGMP datagram. We validate it to make
//      sure it's reasonable. Then if it it's a query for a group to which we
//      belong we'll start a response timer. If it's a report to a group to
//      which we belong  we'll stop any running timer.
//
//      The IGMP header is only 8 bytes long, and so should always fit in
//      exactly  one IP rcv buffer. We check this to make sure, and if it
//      takes multiple buffers we discard it.
//
//  Entry:  NTE           - Pointer to NTE on which IGMP message was received.
//          Dest          - IPAddr of destination (should be a Class D address).
//          Src           - IPAddr of source
//          LocalAddr     - Local address of network which caused this to be
//                          received.
//          SrcAddr       - Address of local interface which received the
//                          packet
//          IPHdr         - Pointer to the IP Header.
//          IPHdrLength   - Bytes in IPHeader.
//          RcvBuf        - Pointer to IP receive buffer chain.
//          Size          - Size in bytes of IGMP message.
//          IsBCast       - Boolean indicator of whether or not this came in
//                          as a bcast (should always be true).
//          Protocol      - Protocol this came in on.
//          OptInfo       - Pointer to info structure for received options.
//
//  Returns: Status of reception
IP_STATUS
IGMPRcv(
    IN NetTableEntry      * NTE,
    IN IPAddr               Dest,
    IN IPAddr               Src,
    IN IPAddr               LocalAddr,
    IN IPAddr               SrcAddr,
    IN IPHeader UNALIGNED * IPHdr,
    IN uint                 IPHdrLength,
    IN IPRcvBuf           * RcvBuf,
    IN uint                 Size,
    IN uchar                IsBCast,
    IN uchar                Protocol,
    IN IPOptInfo          * OptInfo)
{
    IGMPHeader UNALIGNED *IGH;
    IGMPv3QueryHeader UNALIGNED *IQH;
    CTELockHandle Handle;
    IGMPAddr *AddrPtr, *PrevPtr;
    uchar DType;
    uint PromiscuousMode = 0;

    DEBUGMSG(DBG_TRACE && DBG_IGMP && DBG_RX,
        (DTEXT("IGMPRcv entered\n")));

    PromiscuousMode = NTE->nte_if->if_promiscuousmode;

    // ASSERT(CLASSD_ADDR(Dest));
    // ASSERT(IsBCast);

    // Discard packets with invalid or broadcast source addresses.
    DType = GetAddrType(Src);
    if (DType == DEST_INVALID || IS_BCAST_DEST(DType)) {
        return IP_SUCCESS;
    }

    // Now get the pointer to the header, and validate the xsum.
    IGH = (IGMPHeader UNALIGNED *) RcvBuf->ipr_buffer;

    //
    // For mtrace like programs, use the entire IGMP packet to generate the xsum.
    //
    if ((Size < sizeof(IGMPHeader)) || (XsumBufChain(RcvBuf) != 0xffff)) {
        // Bad checksum, so fail.
        return IP_SUCCESS;
    }

    // OK, we may need to process this. See if we are a member of the
    // destination group. If we aren't, there's no need to proceed further.

    //
    // Since for any interface we always get notified with
    // same NTE, locking the NTE is fine.  We don't have to
    // lock the interface structure
    //
    CTEGetLock(&NTE->nte_lock, &Handle);
    {
        if (!(NTE->nte_flags & NTE_VALID)) {
            CTEFreeLock(&NTE->nte_lock, Handle);
            return IP_SUCCESS;
        }

        //
        // The NTE is valid. Demux on type.
        //
        switch (IGH->igh_vertype) {

        case IGMP_QUERY:
            IGMPRcvQuery(NTE, Dest, IPHdr, IPHdrLength,
                         (IGMPv3QueryHeader UNALIGNED *)IGH, Size);
            break;

        case IGMP_REPORT_V1:
        case IGMP_REPORT_V2:
            // Make sure we're running at least level 2 of IGMP support.
            if (IGMPLevel != 2) {
                CTEFreeLock(&NTE->nte_lock, Handle);
                return IP_SUCCESS;
            }

            //
            // This is a report. Check its validity and see if we have a
            // response timer running for that address. If we do, stop it.
            // Make sure the destination address matches the address in the
            // IGMP header.
            //
            if (IP_ADDR_EQUAL(Dest, IGH->igh_addr)) {
                // The addresses match. See if we have a membership in this
                // group.
                AddrPtr = FindIGMPAddr(NTE, IGH->igh_addr, &PrevPtr);
                if (AddrPtr != NULL) {
                    // We found a matching multicast address. Stop the response
                    // timer for any Group-specific or Group-and-source-
                    // specific queries.
                    CancelGroupResponseTimer(AddrPtr);

                    if (IS_GROUP_DELETABLE(AddrPtr))
                        DeleteIGMPAddr(NTE, PrevPtr, &AddrPtr);
                }
            }
            break;

        default:
            break;
        }
    }
    CTEFreeLock(&NTE->nte_lock, Handle);

    //
    // Pass the packet up to the raw layer if applicable.
    // If promiscuous mode is set then we will anyway call rawrcv later
    //
    if ((RawPI != NULL) && (!PromiscuousMode)) {
        if (RawPI->pi_rcv != NULL) {
            (*(RawPI->pi_rcv)) (NTE, Dest, Src, LocalAddr, SrcAddr, IPHdr,
                                IPHdrLength, RcvBuf, Size, IsBCast, Protocol, OptInfo);
        }
    }
    return IP_SUCCESS;
}

//////////////////////////////////////////////////////////////////////////////
// Send routines
//////////////////////////////////////////////////////////////////////////////

//* IGMPTransmit - transmit an IGMP message
IP_STATUS
IGMPTransmit(
    IN PNDIS_BUFFER Buffer,
    IN PVOID        Body,
    IN uint         Size,
    IN IPAddr       SrcAddr,
    IN IPAddr       DestAddr)
{
    uchar        RtrAlertOpt[4] = { IP_OPT_ROUTER_ALERT, 4, 0, 0 };
    IPOptInfo    OptInfo;            // Options for this transmit.
    IP_STATUS    Status;
    RouteCacheEntry *RCE;
    ushort MSS;
    uchar DestType;
    IPAddr Src;

    DEBUGMSG(DBG_TRACE && DBG_IGMP && DBG_TX,
        (DTEXT("IGMPTransmit: Buffer=%x Body=%x Size=%d SrcAddr=%x\n"),
        Buffer, Body, Size, SrcAddr));

    IPInitOptions(&OptInfo);

    OptInfo.ioi_ttl = 1;
    OptInfo.ioi_options = (uchar *) & RtrAlertOpt;
    OptInfo.ioi_optlength = ROUTER_ALERT_SIZE;

    Src = OpenRCE(DestAddr, SrcAddr, &RCE, &DestType, &MSS, &OptInfo);

    if (IP_ADDR_EQUAL(Src,NULL_IP_ADDR)) {
        IGMPSendComplete(Body, Buffer, IP_SUCCESS);
        return IP_DEST_HOST_UNREACHABLE;
    }

#if GPC
    if (DisableUserTOS) {
        OptInfo.ioi_tos = (uchar) DefaultTOS;
    }
    if (GPCcfInfo) {

        //
        // we'll fall into here only if the GPC client is there
        // and there is at least one CF_INFO_QOS installed
        // (counted by GPCcfInfo).
        //

        GPC_STATUS status = STATUS_SUCCESS;
        ULONG ServiceType = 0;
        GPC_IP_PATTERN Pattern;
        CLASSIFICATION_HANDLE GPCHandle;

        Pattern.SrcAddr = SrcAddr;
        Pattern.DstAddr = DestAddr;
        Pattern.ProtocolId = PROT_ICMP;
        Pattern.gpcSrcPort = 0;
        Pattern.gpcDstPort = 0;

        Pattern.InterfaceId.InterfaceId = 0;
        Pattern.InterfaceId.LinkId = 0;
        GPCHandle = 0;

        GetIFAndLink(RCE,
                     &Pattern.InterfaceId.InterfaceId,
                     &Pattern.InterfaceId.LinkId
                     );

        status = GpcEntries.GpcClassifyPatternHandler(
                                                 hGpcClient[GPC_CF_QOS],
                                                 GPC_PROTOCOL_TEMPLATE_IP,
                                                 &Pattern,
                                                 NULL,        // context
                                                 &GPCHandle,
                                                 0,
                                                 NULL,
                                                 FALSE);

        OptInfo.ioi_GPCHandle = (int)GPCHandle;

        //
        // Only if QOS patterns exist, we get the TOS bits out.
        //
        if (NT_SUCCESS(status) && GpcCfCounts[GPC_CF_QOS]) {

            status = GpcEntries.GpcGetUlongFromCfInfoHandler(
                                                 hGpcClient[GPC_CF_QOS],
                                                 OptInfo.ioi_GPCHandle,
                                                 ServiceTypeOffset,
                                                 &ServiceType);

            //
            // It is likely that the pattern has gone by now (Removed or
            // whatever) and the handle that we are caching is INVALID.
            // We need to pull up a new handle and get the
            // TOS bit again.
            //

            if (STATUS_NOT_FOUND == status) {

                GPCHandle = 0;

                status = GpcEntries.GpcClassifyPatternHandler(
                                                 hGpcClient[GPC_CF_QOS],
                                                 GPC_PROTOCOL_TEMPLATE_IP,
                                                 &Pattern,
                                                 NULL,        // context
                                                 &GPCHandle,
                                                 0,
                                                 NULL,
                                                 FALSE);

                OptInfo.ioi_GPCHandle = (int)GPCHandle;

                //
                // Only if QOS patterns exist, we get the TOS bits out.
                //
                if (NT_SUCCESS(status) && GpcCfCounts[GPC_CF_QOS]) {

                    status = GpcEntries.GpcGetUlongFromCfInfoHandler(
                                              hGpcClient[GPC_CF_QOS],
                                              OptInfo.ioi_GPCHandle,
                                              ServiceTypeOffset,
                                              &ServiceType);
                }
            }
        }
        if (status == STATUS_SUCCESS) {

            OptInfo.ioi_tos = (OptInfo.ioi_tos & TOS_MASK) | (UCHAR) ServiceType;

        }
    }                        // if (GPCcfInfo)

#endif

    Status = IPTransmit(IGMPProtInfo, Body, Buffer, Size,
                        DestAddr, SrcAddr, &OptInfo, RCE, PROT_IGMP, NULL);
    CloseRCE(RCE);

    if (Status != IP_PENDING)
        IGMPSendComplete(Body, Buffer, IP_SUCCESS);

    return Status;
}

//* GetAllowRecord - allocate and fill in an IGMPv3 ALLOW record for a group
//
// Caller is responsible for freeing pointer returned
IGMPv3GroupRecord *
GetAllowRecord(
    IN IGMPAddr *AddrPtr,
    IN uint     *RecSize)
{
    IGMPSrcAddr       *Src, *PrevSrc;
    IGMPv3GroupRecord *Rec;
    ushort             Count = 0;

    // Count sources to include
    for (Src=AddrPtr->iga_srclist; Src; Src=Src->isa_next) {
        if (Src->isa_xmitleft == 0)
            continue;
        if (!IS_SOURCE_ALLOWED(AddrPtr, Src))
            continue;
        Count++;
    }
    if (Count == 0) {
        *RecSize = 0;
        return NULL;
    }

    Rec = CTEAllocMemN(RECORD_SIZE(Count,0), 'qICT');

    //
    // We need to walk the source list regardless of whether the
    // allocation succeeded, so that we preserve the invariant that
    // iga_xmitleft >= isa_xmitleft for all sources.
    //
    Count = 0;
    PrevSrc = STRUCT_OF(IGMPSrcAddr, &AddrPtr->iga_srclist, isa_next);
    for (Src=AddrPtr->iga_srclist; Src; PrevSrc=Src,Src=Src->isa_next) {
        if (Src->isa_xmitleft == 0)
            continue;
        if (!IS_SOURCE_ALLOWED(AddrPtr, Src))
            continue;
        if (Rec)
            Rec->igr_srclist[Count++] = Src->isa_addr;
        Src->isa_xmitleft--;

        if (IS_SOURCE_DELETABLE(Src)) {
            DeleteIGMPSrcAddr(PrevSrc, &Src);
            Src = PrevSrc;
        }
    }

    if (Rec == NULL) {
        *RecSize = 0;
        return NULL;
    }

    Rec->igr_type    = ALLOW_NEW_SOURCES;
    Rec->igr_datalen = 0;
    Rec->igr_numsrc  = net_short(Count);
    Rec->igr_addr    = AddrPtr->iga_addr;
    *RecSize = RECORD_SIZE(Count,Rec->igr_datalen);
    return Rec;
}

// Count a state-change report as going out, and preserve the invariant
// that iga_xmitleft>0 if iga_changetype!=NO_CHANGE
//
VOID
IgmpDecXmitLeft(
    IN IGMPAddr *AddrPtr)
{
    AddrPtr->iga_xmitleft--;
    if (!AddrPtr->iga_xmitleft) {
        AddrPtr->iga_changetype = NO_CHANGE;
    }
}

//* GetBlockRecord - allocate and fill in an IGMPv3 BLOCK record for a group
//
// Caller is responsible for freeing pointer returned
IGMPv3GroupRecord *
GetBlockRecord(
    IN IGMPAddr *AddrPtr,
    IN uint     *RecSize)
{
    IGMPSrcAddr       *Src, *PrevSrc;
    IGMPv3GroupRecord *Rec;
    ushort             Count = 0;

    // We now need to decrement the retransmission count on the group.
    // This must be done exactly once for every pair of ALLOW/BLOCK
    // records possibly generated.  We centralize this code in one place
    // by putting it in either GetAllowRecord or GetBlockRecord (which
    // are always called together).  We arbitrarily choose to put it
    // in GetBlockRecord, rather than GetAllowRecord (which isn't currently
    // called from LeaveAllIGMPAddr).
    //
    IgmpDecXmitLeft(AddrPtr);

    // Count sources to include
    for (Src=AddrPtr->iga_srclist; Src; Src=Src->isa_next) {
        if (Src->isa_xmitleft == 0)
            continue;
        if (IS_SOURCE_ALLOWED(AddrPtr, Src))
            continue;
        Count++;
    }
    if (Count == 0) {
        *RecSize = 0;
        return NULL;
    }

    // Allocate record
    Rec = CTEAllocMemN(RECORD_SIZE(Count,0), 'qICT');

    //
    // We need to walk the source list regardless of whether the
    // allocation succeeded, so that we preserve the invariant that
    // iga_xmitleft >= isa_xmitleft for all sources.
    //
    Count = 0;
    PrevSrc = STRUCT_OF(IGMPSrcAddr, &AddrPtr->iga_srclist, isa_next);
    for (Src=AddrPtr->iga_srclist; Src; PrevSrc=Src,Src=Src->isa_next) {
        if (Src->isa_xmitleft == 0)
            continue;
        if (IS_SOURCE_ALLOWED(AddrPtr, Src))
            continue;
        if (Rec)
            Rec->igr_srclist[Count++] = Src->isa_addr;
        Src->isa_xmitleft--;

        if (IS_SOURCE_DELETABLE(Src)) {
            DeleteIGMPSrcAddr(PrevSrc, &Src);
            Src = PrevSrc;
        }
    }

    if (Rec == NULL) {
        *RecSize = 0;
        return NULL;
    }

    Rec->igr_type    = BLOCK_OLD_SOURCES;
    Rec->igr_datalen = 0;
    Rec->igr_numsrc  = net_short(Count);
    Rec->igr_addr    = AddrPtr->iga_addr;

    *RecSize = RECORD_SIZE(Count,Rec->igr_datalen);
    return Rec;
}

//* GetGSIsInRecord - allocate and fill in an IGMPv3 IS_IN record for a
//  group-and-source query response.
//
// Caller is responsible for freeing pointer returned
IGMPv3GroupRecord *
GetGSIsInRecord(
    IN IGMPAddr *AddrPtr,
    IN uint     *RecSize)
{
    IGMPSrcAddr       *Src, *PrevSrc;
    IGMPv3GroupRecord *Rec;
    ushort             Count = 0;

    // Count sources marked and included
    for (Src=AddrPtr->iga_srclist; Src; Src=Src->isa_next) {
        if (!IS_SOURCE_ALLOWED(AddrPtr, Src))
            continue;
        if (!Src->isa_csmarked)
            continue;
        Count++;
    }

    // Allocate record
    Rec = CTEAllocMemN(RECORD_SIZE(Count,0), 'qICT');
    if (Rec == NULL) {
        *RecSize = 0;
        return NULL;
    }

    Count = 0;
    PrevSrc = STRUCT_OF(IGMPSrcAddr, &AddrPtr->iga_srclist, isa_next);
    for (Src=AddrPtr->iga_srclist; Src; PrevSrc=Src,Src=Src->isa_next) {
        if (!IS_SOURCE_ALLOWED(AddrPtr, Src))
            continue;
        if (!Src->isa_csmarked)
            continue;
        Rec->igr_srclist[Count++] = Src->isa_addr;
        Src->isa_csmarked = FALSE;

        if (IS_SOURCE_DELETABLE(Src)) {
            DeleteIGMPSrcAddr(PrevSrc, &Src);
            Src = PrevSrc;
        }
    }

    Rec->igr_type    = MODE_IS_INCLUDE;
    Rec->igr_datalen = 0;
    Rec->igr_numsrc  = net_short(Count);
    Rec->igr_addr    = AddrPtr->iga_addr;

    *RecSize = RECORD_SIZE(Count,Rec->igr_datalen);

    return Rec;
}

//* GetInclRecord - allocate and fill in an IGMPv3 TO_IN or IS_IN record for
//  a group
//
// Caller is responsible for freeing pointer returned
IGMPv3GroupRecord *
GetInclRecord(
    IN IGMPAddr *AddrPtr,
    IN uint     *RecSize,
    IN uchar     Type)
{
    IGMPSrcAddr       *Src, *PrevSrc;
    IGMPv3GroupRecord *Rec;
    ushort             Count = 0;

    // Count sources
    for (Src=AddrPtr->iga_srclist; Src; Src=Src->isa_next) {
        if (!IS_SOURCE_ALLOWED(AddrPtr, Src))
            continue;
        Count++;
    }

    // Allocate record
    Rec = CTEAllocMemN(RECORD_SIZE(Count,0), 'qICT');
    if (Rec == NULL) {
        *RecSize = 0;
        return NULL;
    }

    //
    // Walk the source list, making sure to preserve the invariants:
    // iga_xmitleft >= isa_xmitleft for all sources, and
    // iga_resptimer>0 whenever isa_csmarked is TRUE.
    //
    Count = 0;
    PrevSrc = STRUCT_OF(IGMPSrcAddr, &AddrPtr->iga_srclist, isa_next);
    for (Src=AddrPtr->iga_srclist; Src; PrevSrc=Src,Src=Src->isa_next) {
        if ((Type == CHANGE_TO_INCLUDE_MODE) && (Src->isa_xmitleft > 0))
            Src->isa_xmitleft--;

        if (IS_SOURCE_ALLOWED(AddrPtr, Src)) {
            Rec->igr_srclist[Count++] = Src->isa_addr;
            Src->isa_csmarked = FALSE;
        }

        if (IS_SOURCE_DELETABLE(Src)) {
            DeleteIGMPSrcAddr(PrevSrc, &Src);
            Src = PrevSrc;
        }
    }

    Rec->igr_type    = Type;
    Rec->igr_datalen = 0;
    Rec->igr_numsrc  = net_short(Count);
    Rec->igr_addr    = AddrPtr->iga_addr;

    if (Type == CHANGE_TO_INCLUDE_MODE) {
        IgmpDecXmitLeft(AddrPtr);
    }

    *RecSize = RECORD_SIZE(Count,Rec->igr_datalen);

    return Rec;
}

#define GetIsInRecord(Grp, RecSz) \
        GetInclRecord(Grp, RecSz, MODE_IS_INCLUDE)

#define GetToInRecord(Grp, RecSz) \
        GetInclRecord(Grp, RecSz, CHANGE_TO_INCLUDE_MODE)

//* GetExclRecord - allocate and fill in an IGMPv3 TO_EX or IS_EX record for
//  a group
//
// Caller is responsible for freeing pointer returned
IGMPv3GroupRecord *
GetExclRecord(
    IN IGMPAddr *AddrPtr,
    IN uint     *RecSize,
    IN uint      BodyMTU,
    IN uchar     Type)
{
    IGMPSrcAddr       *Src, *PrevSrc;
    IGMPv3GroupRecord *Rec;
    ushort             Count = 0;

    // Count sources
    for (Src=AddrPtr->iga_srclist; Src; Src=Src->isa_next) {
        if (IS_SOURCE_ALLOWED(AddrPtr, Src))
            continue;
        Count++;
    }

    // Allocate record
    Rec = CTEAllocMemN(RECORD_SIZE(Count,0), 'qICT');
    if (Rec == NULL) {
        *RecSize = 0;
        return NULL;
    }

    //
    // Walk the source list, making sure to preserve the invariants:
    // iga_xmitleft <= isa_xmitleft for all sources, and
    // iga_resptimer>0 whenever isa_csmarked is TRUE.
    //
    Count = 0;
    PrevSrc = STRUCT_OF(IGMPSrcAddr, &AddrPtr->iga_srclist, isa_next);
    for (Src=AddrPtr->iga_srclist; Src; PrevSrc=Src,Src=Src->isa_next) {
        if ((Type == CHANGE_TO_EXCLUDE_MODE) && (Src->isa_xmitleft > 0))
            Src->isa_xmitleft--;

        if (!IS_SOURCE_ALLOWED(AddrPtr, Src)) {
            Rec->igr_srclist[Count++] = Src->isa_addr;
            Src->isa_csmarked = FALSE;
        }

        if (IS_SOURCE_DELETABLE(Src)) {
            DeleteIGMPSrcAddr(PrevSrc, &Src);
            Src = PrevSrc;
        }
    }

    Rec->igr_type    = Type;
    Rec->igr_datalen = 0;
    Rec->igr_numsrc  = net_short(Count);
    Rec->igr_addr    = AddrPtr->iga_addr;

    if (Type == CHANGE_TO_EXCLUDE_MODE) {
        IgmpDecXmitLeft(AddrPtr);
    }

    *RecSize = RECORD_SIZE(Count,Rec->igr_datalen);

    // Truncate at MTU boundary
    if (*RecSize > BodyMTU) {
        *RecSize = BodyMTU;
    }

    return Rec;
}

#define GetIsExRecord(Grp, RecSz, BodyMTU) \
        GetExclRecord(Grp, RecSz, BodyMTU, MODE_IS_EXCLUDE)

#define GetToExRecord(Grp, RecSz, BodyMTU) \
        GetExclRecord(Grp, RecSz, BodyMTU, CHANGE_TO_EXCLUDE_MODE)

//* QueueRecord - Queue an IGMPv3 group record for transmission.
//  If the record cannot be queued, the record is dropped and the
//  memory freed.
//
//  Input:  pCurr   = pointer to last queue entry
//          Record  = record to append to end of queue
//          RecSize = size of record to queue
//
//  Output: pCurr   = pointer to new queue entry
//          Record  = zeroed if queue failed and record was freed
//
//  Returns: status
//
IP_STATUS
QueueRecord(
    IN OUT IGMPv3RecordQueueEntry **pCurr,
    IN OUT IGMPv3GroupRecord      **pRecord,
    IN     uint                     RecSize)
{
    IGMPv3RecordQueueEntry *rqe;
    IGMPv3GroupRecord      *Record = *pRecord;
    IP_STATUS               Status = IP_SUCCESS;

    if (!Record) {
        return IP_SUCCESS;
    }

    do {

        DEBUGMSG(DBG_TRACE && DBG_IGMP && DBG_TX,
            (DTEXT("QueueRecord: Record=%x Type=%d Group=%x NumSrc=%d\n"),
            Record, Record->igr_type, Record->igr_addr,
            net_short(Record->igr_numsrc)));

        //
        // Make sure we never add a record for the all-hosts mcast address.
        //
        if (IP_ADDR_EQUAL(Record->igr_addr, ALL_HOST_MCAST)) {
            Status = IP_BAD_REQ;
            break;
        }

        // Allocate a queue entry
        rqe = CTEAllocMemN(sizeof(IGMPv3RecordQueueEntry), 'qICT');
        if (rqe == NULL) {
            Status = IP_NO_RESOURCES;
            break;
        }
        rqe->i3qe_next = NULL;
        rqe->i3qe_buff = Record;
        rqe->i3qe_size = RecSize;

        // Append to queue
        (*pCurr)->i3qe_next = rqe;
        *pCurr = rqe;

    } while (FALSE);

    if (Status != IP_SUCCESS) {
        // Free buffers
        CTEFreeMem(Record);
        *pRecord = NULL;
    }

    return Status;
}

VOID
FlushIGMPv3Queue(
    IN IGMPv3RecordQueueEntry *Head)
{
    IGMPv3RecordQueueEntry *Rqe;

    while ((Rqe = Head) != NULL) {
        // Remove entry from queue
        Head = Rqe->i3qe_next;
        Rqe->i3qe_next = NULL;

        // Free queued record
        CTEFreeMem(Rqe->i3qe_buff);
        CTEFreeMem(Rqe);
    }
}

//* SendIGMPv3Reports - send pending IGMPv3 reports
//
// Input: Head    - queue of IGMPv3 records to transmit
//        SrcAddr - source address to send with
//        BodyMTU - message payload size available to pack records in
IP_STATUS
SendIGMPv3Reports(
    IN IGMPv3RecordQueueEntry *Head,
    IN IPAddr                  SrcAddr,
    IN uint                    BodyMTU)
{
    PNDIS_BUFFER            HdrBuffer;
    uint                    HdrSize;
    IGMPv3ReportHeader     *IGH;

    PNDIS_BUFFER            BodyBuffer;
    uint                    BodySize;
    uchar*                  Body;

    IP_STATUS               Status;
    uint                    NumRecords;
    ushort                  NumOldSources, NumNewSources;
    IGMPv3RecordQueueEntry *Rqe;
    IGMPv3GroupRecord      *Rec, *HeadRec;
    BOOLEAN                 Ret;
    ulong                   csum;

    while (Head != NULL) {

        // Get header buffer
        HdrSize = sizeof(IGMPv3ReportHeader);
        IGH = (IGMPv3ReportHeader*) GetIGMPBuffer(HdrSize, &HdrBuffer);
        if (IGH == NULL) {
            FlushIGMPv3Queue(Head);
            return IP_NO_RESOURCES;
        }

        // We got the buffer. Fill it in and send it.
        IGH->igh_vertype = (UCHAR) IGMP_REPORT_V3;
        IGH->igh_rsvd = 0;
        IGH->igh_rsvd2 = 0;

        // Compute optimum body size
        for (;;) {
            NumRecords = 0;
            BodySize = 0;
            for (Rqe=Head; Rqe; Rqe=Rqe->i3qe_next) {
                if (BodySize + Rqe->i3qe_size > BodyMTU)
                    break;
                BodySize += Rqe->i3qe_size;
                NumRecords++;
            }

            // Make sure we fit at least one record
            if (NumRecords > 0)
                break;

            //
            // No records fit.  Let's split the first record and try again.
            // Note that igr_datalen is always 0 today.  If there is data
            // later, then splitting will need to know whether to copy
            // the data or not.  Today we assume not.
            //

            HeadRec = Head->i3qe_buff;
            NumOldSources = (BodyMTU - sizeof(IGMPv3GroupRecord)) / sizeof(IPAddr);
            NumNewSources = net_short(HeadRec->igr_numsrc) - NumOldSources;

            DEBUGMSG(DBG_TRACE && DBG_IGMP && DBG_TX,
                (DTEXT("SendIGMPv3Reports: Splitting queue entry %x Srcs=%d+%d\n"),
                HeadRec, NumOldSources, NumNewSources));

            // Truncate head
            HeadRec->igr_numsrc = net_short(NumOldSources);
            Head->i3qe_size = RECORD_SIZE(NumOldSources, HeadRec->igr_datalen);

            // Special case for IS_EX/TO_EX: just truncate or else the router
            // will end up forwarding all the sources we exclude in messages
            // other than the last one.
            if (HeadRec->igr_type == MODE_IS_EXCLUDE
             || HeadRec->igr_type == CHANGE_TO_EXCLUDE_MODE) {
                continue;
            }

            // Create a new record with NumNewSources sources
            Rec = CTEAllocMemN(RECORD_SIZE(NumNewSources,0), 'qICT');
            if (Rec == NULL) {
               // Forget the continuation, just send the truncated original.
               continue;
            }
            Rec->igr_type    = HeadRec->igr_type;
            Rec->igr_datalen = 0;
            Rec->igr_numsrc  = net_short(NumNewSources);
            Rec->igr_addr    = HeadRec->igr_addr;

            RtlCopyMemory(Rec->igr_srclist,
                          &HeadRec->igr_srclist[NumOldSources],
                          NumNewSources * sizeof(IPAddr));

            // Append it
            Rqe = Head;
            QueueRecord(&Rqe, &Rec, RECORD_SIZE(NumNewSources,
                                                Rec->igr_datalen));
        }

        // Get another ndis buffer for the body
        Body = CTEAllocMemN(BodySize, 'bICT');
        if (Body == NULL) {
            FreeIGMPBuffer(HdrBuffer);
            FlushIGMPv3Queue(Head);
            return IP_NO_RESOURCES;
        }
        NdisAllocateBuffer(&Status, &BodyBuffer, BufferPool, Body, BodySize);
        NDIS_BUFFER_LINKAGE(HdrBuffer) = BodyBuffer;

        // Fill in records
        NumRecords = 0;
        BodySize = 0;
        csum = 0;
        while ((Rqe = Head) != NULL) {
            if (BodySize + Rqe->i3qe_size > BodyMTU)
                break;

            // Remove from queue
            Head = Rqe->i3qe_next;
            Rqe->i3qe_next = NULL;

            // update checksum
            csum += xsum((uchar *)Rqe->i3qe_buff, Rqe->i3qe_size);

            DEBUGMSG(DBG_TRACE && DBG_IGMP && DBG_TX,
                (DTEXT("SendRecord: Record=%x RecSize=%d Type=%d Group=%x Body=%x Offset=%d\n"),
                Rqe->i3qe_buff, Rqe->i3qe_size, Rqe->i3qe_buff->igr_type,
                Rqe->i3qe_buff->igr_addr, Body, BodySize));

            RtlCopyMemory(Body + BodySize, (uchar *)Rqe->i3qe_buff,
                          Rqe->i3qe_size);
            BodySize += Rqe->i3qe_size;
            NumRecords++;

            CTEFreeMem(Rqe->i3qe_buff);
            CTEFreeMem(Rqe);
        }

        // Finish header
        IGH->igh_xsum = 0;
        IGH->igh_numrecords = net_short(NumRecords);
        csum += xsum(IGH, sizeof(IGMPv3ReportHeader));

        // Fold the checksum down.
        csum = (csum >> 16) + (csum & 0xffff);
        csum += (csum >> 16);

        IGH->igh_xsum = (ushort)~csum;

        Status = IGMPTransmit(HdrBuffer, Body, HdrSize + BodySize, SrcAddr,
                              IGMPV3_RTRS_MCAST);
    }

    return Status;
}

//* QueueIGMPv3GeneralResponse - compose and queue IGMPv3 responses to general
//  query
IP_STATUS
QueueIGMPv3GeneralResponse(
    IN IGMPv3RecordQueueEntry **pCurr,
    IN NetTableEntry           *NTE)
{
    IGMPAddr              **HashPtr, *AddrPtr;
    uint                    i;
    IGMPv3GroupRecord      *StateRec;
    uint                    StateRecSize;
    uint                    BodyMTU;

    BodyMTU = RECORD_MTU(NTE);

    //
    // Walk our list and set a random report timer for all those
    // multicast addresses (except for the all-hosts address) that
    // don't already have one running.
    //
    HashPtr = NTE->nte_igmplist;

    if (HashPtr != NULL) {
        for (i = 0; i < IGMP_TABLE_SIZE; i++) {
            for (AddrPtr = HashPtr[i];
                 AddrPtr != NULL;
                 AddrPtr = AddrPtr->iga_next)
            {
                if (IP_ADDR_EQUAL(AddrPtr->iga_addr, ALL_HOST_MCAST))
                    continue;

                if (AddrPtr->iga_grefcnt == 0)
                    StateRec = GetIsInRecord(AddrPtr, &StateRecSize);
                else
                    StateRec = GetIsExRecord(AddrPtr, &StateRecSize, BodyMTU);

                QueueRecord(pCurr, &StateRec, StateRecSize);
            }
        }
    }

    return IP_SUCCESS;
}

//* QueueOldReport - create and queue an IGMPv1/v2 membership report to be sent
IP_STATUS
QueueOldReport(
    IN IGMPReportQueueEntry **pCurr,
    IN uint                   ChangeType,
    IN uint                   IgmpVersion,
    IN IPAddr                 Group)
{
    IGMPReportQueueEntry *rqe;
    IGMPHeader           *IGH;
    uint                  ReportType, Size;
    IPAddr                Dest;

    DEBUGMSG(DBG_TRACE && DBG_IGMP && DBG_TX,
        (DTEXT("QueueOldReport: Type=%d Vers=%d Group=%x\n"),
        ChangeType, IgmpVersion, Group));

    //
    // Make sure we never queue a report for the all-hosts mcast address.
    //
    if (IP_ADDR_EQUAL(Group, ALL_HOST_MCAST)) {
        return IP_BAD_REQ;
    }

    //
    // If the report to be sent is a "Leave Group" report but we have
    // detected an igmp v1 router on this net, do not send the report
    //
    if (IgmpVersion == IGMPV1) {
        if (ChangeType == IGMP_DELETE) {
            return IP_SUCCESS;
        } else {
            ReportType = IGMP_REPORT_V1;
            Dest = Group;
        }
    } else {
        if (ChangeType == IGMP_DELETE) {
            ReportType = IGMP_LEAVE;
            Dest = ALL_ROUTER_MCAST;
        } else {
            ReportType = IGMP_REPORT_V2;
            Dest = Group;
        }
    }

    // Allocate an IGMP report
    Size = sizeof(IGMPHeader);
    IGH = (IGMPHeader *) CTEAllocMemN(Size, 'hICT');
    if (IGH == NULL) {
        return IP_NO_RESOURCES;
    }

    IGH->igh_vertype = (UCHAR) ReportType;
    IGH->igh_rsvd = 0;
    IGH->igh_xsum = 0;
    IGH->igh_addr = Group;
    IGH->igh_xsum = ~xsum(IGH, Size);

    // Allocate a queue entry
    rqe = (IGMPReportQueueEntry *) CTEAllocMemN(sizeof(IGMPReportQueueEntry),
                                                'qICT');
    if (rqe == NULL) {
        CTEFreeMem(IGH);
        return IP_NO_RESOURCES;
    }
    rqe->iqe_next = NULL;
    rqe->iqe_buff = IGH;
    rqe->iqe_size = Size;
    rqe->iqe_dest = Dest;
    ASSERT((IGH != NULL) && (Size > 0));

    // Append to queue
    (*pCurr)->iqe_next = rqe;
    *pCurr = rqe;

    DEBUGMSG(DBG_TRACE && DBG_IGMP && DBG_TX,
        (DTEXT("QueueOldReport: added rqe=%x buff=%x size=%d\n"),
        rqe, rqe->iqe_buff, rqe->iqe_size));

    return IP_SUCCESS;
}

//* SendOldReport - send an IGMPv1/v2 membership report
IP_STATUS
SendOldReport(
    IN IGMPReportQueueEntry *Rqe,
    IN IPAddr                SrcAddr)
{
    PNDIS_BUFFER Buffer;
    IPOptInfo    OptInfo;            // Options for this transmit.
    IP_STATUS    Status;
    int          ReportType, RecordType;
    IPAddr       GrpAdd;
    uchar        RtrAlertOpt[4] = { IP_OPT_ROUTER_ALERT, 4, 0, 0 };
    uint         Size, Offset;
    IGMPHeader  *IGH;
    uchar      **pIGMPBuff, *IGH2;
    IPAddr       DestAddr;

    //ASSERT(!IP_ADDR_EQUAL(SrcAddr, NULL_IP_ADDR));

    DEBUGMSG(DBG_TRACE && DBG_IGMP && DBG_TX,
        (DTEXT("SendOldReport: rqe=%x buff=%x size=%x\n"),
        Rqe, Rqe->iqe_buff, Rqe->iqe_size));

    IGH  = Rqe->iqe_buff;
    ASSERT(IGH != NULL);
    Size = Rqe->iqe_size;
    ASSERT(Size > 0);

    DestAddr = Rqe->iqe_dest;

    IGH2 = (uchar*)GetIGMPBuffer(Size, &Buffer);
    if (IGH2 == NULL) {
        CTEFreeMem(IGH);
        Rqe->iqe_buff = NULL;
        return IP_NO_RESOURCES;
    }

    RtlCopyMemory(IGH2, (uchar *)IGH, Size);

    CTEFreeMem(IGH);
    Rqe->iqe_buff = NULL;

    return IGMPTransmit(Buffer, NULL, Size, SrcAddr, DestAddr);
}

//* SendOldReports - send pending IGMPv1/v2 membership reports
void
SendOldReports(
    IN IGMPReportQueueEntry *Head,
    IN IPAddr                SrcAddr)
{
    IGMPReportQueueEntry *rqe;

    while ((rqe = Head) != NULL) {
        // Remove from queue
        Head = rqe->iqe_next;
        rqe->iqe_next = NULL;

        SendOldReport(rqe, SrcAddr);
        CTEFreeMem(rqe);
    }
}


//////////////////////////////////////////////////////////////////////////////
// Mark changes for triggered reports
//////////////////////////////////////////////////////////////////////////////

// Should only be called for leaves if in IGMPv3 mode,
// but should be called for joins always.
void
MarkGroup(
    IN IGMPAddr    *Grp)
{
    // No reports are sent for the ALL_HOST_MCAST group
    if (IP_ADDR_EQUAL(Grp->iga_addr, ALL_HOST_MCAST)) {
        return;
    }

    Grp->iga_changetype = MODE_CHANGE;
    Grp->iga_xmitleft = g_IgmpRobustness;
}

// Should only be called if in IGMPv3 mode
void
MarkSource(
    IN IGMPAddr    *Grp,
    IN IGMPSrcAddr *Src)
{
    // No reports are sent for the ALL_HOST_MCAST group
    if (IP_ADDR_EQUAL(Grp->iga_addr, ALL_HOST_MCAST)) {
        return;
    }

    Src->isa_xmitleft = g_IgmpRobustness;
    Grp->iga_xmitleft = g_IgmpRobustness;
    if (Grp->iga_changetype == NO_CHANGE) {
        Grp->iga_changetype = SOURCE_CHANGE;
    }
}

//* IGMPDelExclList - delete sources from an internal source exclude list
//
// This never affects link-layer filters.
// Assumes caller holds lock on NTE
void
IGMPDelExclList(
    IN     NetTableEntry *NTE,
    IN     IGMPAddr      *PrevAddrPtr,
    IN OUT IGMPAddr     **pAddrPtr,
    IN     uint           NumDelSources,
    IN     IPAddr        *DelSourceList,
    IN     BOOLEAN        AllowMsg)
{
    uint         i, j;
    IGMPSrcAddr *Src, *PrevSrc;

    DEBUGMSG(DBG_TRACE && DBG_IGMP,
                (DTEXT("IGMPDelExclList: AddrPtr=%x NumDelSources=%d DelSourceList=%x\n"),
        *pAddrPtr, NumDelSources, DelSourceList));

    for (i=0; i<NumDelSources; i++) {

        // Find the source entry
        Src = FindIGMPSrcAddr(*pAddrPtr, DelSourceList[i], &PrevSrc);

        // Break if not there or xrefcnt=0
        ASSERT(Src && (Src->isa_xrefcnt!=0));

        if (AllowMsg && (NTE->nte_if->IgmpVersion == IGMPV3)) {
            // If all sockets exclude and no sockets include, add source
            // to IGMP ALLOW message
            if (!IS_SOURCE_ALLOWED(*pAddrPtr, Src)) {
                // Add source to ALLOW message
                MarkSource(*pAddrPtr, Src);
            }
        }

        // Decrement the xrefcnt
        Src->isa_xrefcnt--;

        // If irefcnt and xrefcnt are both 0 and no rexmits left,
        // delete the source entry
        if (IS_SOURCE_DELETABLE(Src))
            DeleteIGMPSrcAddr(PrevSrc, &Src);

        // If the group refcount=0, and srclist is null, delete group entry
        if (IS_GROUP_DELETABLE(*pAddrPtr))
            DeleteIGMPAddr(NTE, PrevAddrPtr, pAddrPtr);
    }
}

//* IGMPDelInclList - delete sources from an internal source include list
//
// Assumes caller holds lock on NTE
void
IGMPDelInclList(
    IN     CTELockHandle *pHandle,
    IN     NetTableEntry *NTE,
    IN     IGMPAddr     **pPrevAddrPtr,
    IN OUT IGMPAddr     **pAddrPtr,
    IN     uint           NumDelSources,
    IN     IPAddr        *DelSourceList,
    IN     BOOLEAN        BlockMsg)
{
    uint         i, j;
    IGMPSrcAddr *Src, *PrevSrc;
    BOOLEAN      GroupWasAllowed;
    BOOLEAN      GroupNowAllowed;
    IPAddr       Addr;

    DEBUGMSG(DBG_TRACE && DBG_IGMP,
                (DTEXT("IGMPDelInclList: AddrPtr=%x NumDelSources=%d DelSourceList=%x\n"),
        *pAddrPtr, NumDelSources, DelSourceList));

    Addr = (*pAddrPtr)->iga_addr;
    GroupWasAllowed = IS_GROUP_ALLOWED(*pAddrPtr);

    for (i=0; i<NumDelSources; i++) {

        // Find the source entry
        Src = FindIGMPSrcAddr(*pAddrPtr, DelSourceList[i], &PrevSrc);

        // Break if not there or irefcnt=0
        ASSERT(Src && (Src->isa_irefcnt!=0));

        // Decrement the irefcnt
        Src->isa_irefcnt--;
        if (Src->isa_irefcnt == 0) {
            (*pAddrPtr)->iga_isrccnt--;
        }

        if (BlockMsg && (NTE->nte_if->IgmpVersion == IGMPV3)) {
            // If all sockets exclude and no sockets include, add source
            // to IGMP BLOCK message
            if (!IS_SOURCE_ALLOWED(*pAddrPtr, Src)) {
                // Add source to BLOCK message
                MarkSource(*pAddrPtr, Src);
            }
        }

        // If irefcnt and xrefcnt are both 0 and no rexmits left,
        // delete the source entry
        if (IS_SOURCE_DELETABLE(Src))
            DeleteIGMPSrcAddr(PrevSrc, &Src);

        // If the group refcount=0, and srclist is null, delete group entry
        if (IS_GROUP_DELETABLE(*pAddrPtr))
            DeleteIGMPAddr(NTE, *pPrevAddrPtr, pAddrPtr);
    }

    GroupNowAllowed = (*pAddrPtr != NULL) && IS_GROUP_ALLOWED(*pAddrPtr);

    if (GroupWasAllowed && !GroupNowAllowed) {

        if (*pAddrPtr) {
            // Cancel response timer if running
            CancelGroupResponseTimer(*pAddrPtr);

            if (IS_GROUP_DELETABLE(*pAddrPtr))
                DeleteIGMPAddr(NTE, *pPrevAddrPtr, pAddrPtr);
        }

        // update link-layer filter
        CTEFreeLock(&NTE->nte_lock, *pHandle);
        {
            (*NTE->nte_if->if_deladdr) (NTE->nte_if->if_lcontext,
                                        LLIP_ADDR_MCAST, Addr, 0);
        }
        CTEGetLock(&NTE->nte_lock, pHandle);

        // Revalidate NTE, AddrPtr, PrevPtr
        if (!(NTE->nte_flags & NTE_VALID)) {
            *pAddrPtr = *pPrevAddrPtr = NULL;
            return;
        }

        *pAddrPtr = FindIGMPAddr(NTE, Addr, pPrevAddrPtr);
    }
}

//* IGMPAddExclList - add sources to an internal source exclude list
//
// This never affects link-layer filters.
// Assumes caller holds lock on NTE
// If failure results, the source list will be unchanged afterwards
// but the group entry may have been deleted.
IP_STATUS
IGMPAddExclList(
    IN     NetTableEntry *NTE,
    IN     IGMPAddr      *PrevAddrPtr,
    IN OUT IGMPAddr     **pAddrPtr,
    IN     uint           NumAddSources,
    IN     IPAddr        *AddSourceList)
{
    uint         i, j;
    IGMPSrcAddr *Src, *PrevSrc;
    IP_STATUS    Status = IP_SUCCESS;

    DEBUGMSG(DBG_TRACE && DBG_IGMP,
                (DTEXT("IGMPAddExclList: AddrPtr=%x NumAddSources=%d AddSourceList=%x\n"),
        *pAddrPtr, NumAddSources, AddSourceList));

    for (i=0; i<NumAddSources; i++) {
        // If an IGMPSrcAddr entry for the source doesn't exist, create one.
        Status = FindOrCreateIGMPSrcAddr(*pAddrPtr, AddSourceList[i], &Src,
                                         &PrevSrc);
        if (Status != IP_SUCCESS) {
            break;
        }

        // Bump the xrefcnt on the source entry
        Src->isa_xrefcnt++;

        // If all sockets exclude and no sockets include, add source
        // to IGMP BLOCK message
        if (!IS_SOURCE_ALLOWED(*pAddrPtr, Src)
         && (NTE->nte_if->IgmpVersion == IGMPV3)) {
            // Add source to BLOCK message
            MarkSource(*pAddrPtr, Src);
        }
    }

    if (Status == IP_SUCCESS)
        return Status;

    // undo previous
    IGMPDelExclList(NTE, PrevAddrPtr, pAddrPtr, i, AddSourceList, FALSE);

    return Status;
}

//* IGMPAddInclList - add sources to an internal source include list
//
// Assumes caller holds lock on NTE
//
// If failure results, the source list will be unchanged afterwards
// but the group entry may have been deleted.
IP_STATUS
IGMPAddInclList(
    IN     CTELockHandle *pHandle,
    IN     NetTableEntry *NTE,
    IN     IGMPAddr     **pPrevAddrPtr,
    IN OUT IGMPAddr     **pAddrPtr,
    IN     uint           NumAddSources,
    IN     IPAddr        *AddSourceList)
{
    uint         i, j, AddrAdded;
    IGMPSrcAddr *Src, *PrevSrc;
    IP_STATUS    Status = IP_SUCCESS;
    BOOLEAN      GroupWasAllowed;
    BOOLEAN      GroupNowAllowed;
    IPAddr       Addr;

    DEBUGMSG(DBG_TRACE && DBG_IGMP,
        (DTEXT("IGMPAddInclList: AddrPtr=%x NumAddSources=%d AddSourceList=%x\n"),
        *pAddrPtr, NumAddSources, AddSourceList));

    Addr = (*pAddrPtr)->iga_addr;
    GroupWasAllowed = IS_GROUP_ALLOWED(*pAddrPtr);

    for (i=0; i<NumAddSources; i++) {
        // If an IGMPSrcAddr entry for the source doesn't exist, create one.
        Status = FindOrCreateIGMPSrcAddr(*pAddrPtr, AddSourceList[i], &Src,
                                         &PrevSrc);
        if (Status != IP_SUCCESS) {
            break;
        }

        // If all sockets exclude and no sockets include, add source
        // to IGMP ALLOW message
        if (!IS_SOURCE_ALLOWED(*pAddrPtr, Src)
         && (NTE->nte_if->IgmpVersion == IGMPV3)) {
            // Add source to ALLOW message
            MarkSource(*pAddrPtr, Src);
        }

        // Bump the irefcnt on the source entry
        if (Src->isa_irefcnt == 0) {
            (*pAddrPtr)->iga_isrccnt++;
        }
        Src->isa_irefcnt++;
    }

    GroupNowAllowed = IS_GROUP_ALLOWED(*pAddrPtr);

    if (!GroupWasAllowed && GroupNowAllowed) {
        // update link-layer filter
        CTEFreeLock(&NTE->nte_lock, *pHandle);
        {
            AddrAdded = (*NTE->nte_if->if_addaddr) (NTE->nte_if->if_lcontext,
                                           LLIP_ADDR_MCAST, Addr, 0, NULL);
        }
        CTEGetLock(&NTE->nte_lock, pHandle);

        // Revalidate NTE, AddrPtr, PrevPtr
        do {
            if (!(NTE->nte_flags & NTE_VALID)) {
                Status = IP_BAD_REQ;
                break;
            }

            // Find the IGMPAddr entry
            *pAddrPtr = FindIGMPAddr(NTE, Addr, pPrevAddrPtr);
            if (!*pAddrPtr) {
                Status = IP_BAD_REQ;
                break;
            }
        } while (FALSE);

        if (!AddrAdded) {
            Status = IP_NO_RESOURCES;
        }
    }

    if (Status == IP_SUCCESS)
        return Status;

    // undo previous
    IGMPDelInclList(pHandle, NTE, pPrevAddrPtr, pAddrPtr, i, AddSourceList,
                    FALSE);

    return Status;
}


//* IGMPInclChange - update source inclusion list
//
// On failure, inclusion list will be unchanged
IP_STATUS
IGMPInclChange(
    IN NetTableEntry *NTE,
    IN IPAddr         Addr,
    IN uint           NumAddSources,
    IN IPAddr        *AddSourceList,
    IN uint           NumDelSources,
    IN IPAddr        *DelSourceList)
{
    CTELockHandle      Handle;
    IGMPAddr          *AddrPtr, *PrevPtr;
    IP_STATUS          Status;
    Interface         *IF;
    IGMPBlockStruct    Block;
    IGMPBlockStruct   *BlockPtr;
    uint               IgmpVersion = 0, BodyMTU;
    IPAddr             SrcAddr;
    IGMPv3GroupRecord *AllowRec = NULL, *BlockRec = NULL;
    uint               AllowRecSize = 0, BlockRecSize = 0;
    BOOLEAN            GroupWasAllowed = FALSE;
    BOOLEAN            GroupNowAllowed = FALSE;

    // First make sure we're at level 2 of IGMP support.

    if (IGMPLevel != 2)
        return IP_BAD_REQ;

    // Make sure addlist and dellist aren't both empty
    ASSERT((NumAddSources > 0) || (NumDelSources > 0));

    if (NTE->nte_flags & NTE_VALID) {

        //
        // If this is an unnumbered interface
        //

        if ((NTE->nte_if->if_flags & IF_FLAGS_NOIPADDR) &&
            IP_ADDR_EQUAL(NTE->nte_addr, NULL_IP_ADDR)) {
            SrcAddr = g_ValidAddr;
            if (IP_ADDR_EQUAL(SrcAddr, NULL_IP_ADDR)) {
                return IP_BAD_REQ;
            }
        } else {
            SrcAddr = NTE->nte_addr;
        }
    }
    CTEInitBlockStruc(&Block.ibs_block);

    // Make sure we're the only ones in this routine. If someone else is
    // already here, block.

    CTEGetLock(&IGMPLock, &Handle);
    if (IGMPBlockFlag) {

        // Someone else is already here. Walk down the block list, and
        // put ourselves on the end. Then free the lock and block on our
        // IGMPBlock structure.
        BlockPtr = STRUCT_OF(IGMPBlockStruct, &IGMPBlockList, ibs_next);
        while (BlockPtr->ibs_next != NULL)
            BlockPtr = BlockPtr->ibs_next;

        Block.ibs_next = NULL;
        BlockPtr->ibs_next = &Block;
        CTEFreeLock(&IGMPLock, Handle);
        CTEBlock(&Block.ibs_block);
    } else {
        // Noone else here, set the flag so noone else gets in and free the
        // lock.
        IGMPBlockFlag = 1;
        CTEFreeLock(&IGMPLock, Handle);
    }

    // Now we're in the routine, and we won't be reentered here by another
    // thread of execution. Make sure everything's valid, and figure out
    // what to do.

    Status = IP_SUCCESS;

    // Now get the lock on the NTE and make sure it's valid.
    CTEGetLock(&NTE->nte_lock, &Handle);
    do {

        if (!(NTE->nte_flags & NTE_VALID)) {
            Status = IP_BAD_REQ;
            break;
        }

        IF = NTE->nte_if;
        BodyMTU = RECORD_MTU(NTE);
        IgmpVersion = IF->IgmpVersion;

        // If an IGMPAddr entry for the group on the interface doesn't
        // exist, create one.
        Status = FindOrCreateIGMPAddr(NTE, Addr, &AddrPtr, &PrevPtr);
        if (Status != IP_SUCCESS) {
            break;
        }

        GroupWasAllowed = IS_GROUP_ALLOWED(AddrPtr);

        // Perform IADDLIST
        Status = IGMPAddInclList(&Handle, NTE, &PrevPtr, &AddrPtr,
                                 NumAddSources, AddSourceList);
        if (Status != IP_SUCCESS) {
            break;
        }

        // Perform IDELLLIST
        IGMPDelInclList(&Handle, NTE, &PrevPtr, &AddrPtr,
                        NumDelSources, DelSourceList, TRUE);

        if (AddrPtr == NULL) {
            GroupNowAllowed = FALSE;
            break;
        } else {
            GroupNowAllowed = IS_GROUP_ALLOWED(AddrPtr);
        }

        if (IgmpVersion == IGMPV3) {
            // Get ALLOC/BLOCK records
            AllowRec = GetAllowRecord(AddrPtr, &AllowRecSize);
            BlockRec = GetBlockRecord(AddrPtr, &BlockRecSize);

            // Set retransmission timer
            AddrPtr->iga_trtimer = IGMPRandomTicks(UNSOLICITED_REPORT_INTERVAL);
        } else if (!GroupWasAllowed && GroupNowAllowed) {
            // Set retransmission timer only for joins, not leaves
            AddrPtr->iga_trtimer = IGMPRandomTicks(UNSOLICITED_REPORT_INTERVAL);
        }

    } while (FALSE);
    CTEFreeLock(&NTE->nte_lock, Handle);

    if (IgmpVersion == IGMPV3) {
        IGMPv3RecordQueueEntry *Head = NULL, *rqe;
        rqe = STRUCT_OF(IGMPv3RecordQueueEntry, &Head, i3qe_next);

        // Send IGMP ALLOW/BLOCK messages if non-empty
        QueueRecord(&rqe, &AllowRec, AllowRecSize);
        QueueRecord(&rqe, &BlockRec, BlockRecSize);
        SendIGMPv3Reports(Head, SrcAddr, BodyMTU);

    } else if (!GroupWasAllowed && GroupNowAllowed) {
        IGMPReportQueueEntry *Head = NULL, *rqe;
        rqe = STRUCT_OF(IGMPReportQueueEntry, &Head, iqe_next);
        QueueOldReport(&rqe, IGMP_ADD, IgmpVersion, Addr);
        SendOldReports(Head, SrcAddr);

    } else if (GroupWasAllowed && !GroupNowAllowed) {
        IGMPReportQueueEntry *Head = NULL, *rqe;
        rqe = STRUCT_OF(IGMPReportQueueEntry, &Head, iqe_next);
        QueueOldReport(&rqe, IGMP_DELETE, IgmpVersion, Addr);
        SendOldReports(Head, SrcAddr);
    }

    // We finished the request, and Status contains the completion status.
    // If there are any pending blocks for this routine, signal the next
    // one now. Otherwise clear the block flag.
    CTEGetLock(&IGMPLock, &Handle);
    if ((BlockPtr = IGMPBlockList) != NULL) {
        // Someone is blocking. Pull him from the list and signal him.
        IGMPBlockList = BlockPtr->ibs_next;
        CTEFreeLock(&IGMPLock, Handle);

        CTESignal(&BlockPtr->ibs_block, IP_SUCCESS);
    } else {
        // No one blocking, just clear the flag.
        IGMPBlockFlag = 0;
        CTEFreeLock(&IGMPLock, Handle);
    }

    return Status;
}

//* IGMPExclChange - update source exclusion list
//
// On failure, exclusion list will be unchanged
IP_STATUS
IGMPExclChange(
    IN NetTableEntry * NTE,
    IN IPAddr          Addr,
    IN uint            NumAddSources,
    IN IPAddr        * AddSourceList,
    IN uint            NumDelSources,
    IN IPAddr        * DelSourceList)
{
    CTELockHandle      Handle;
    IGMPAddr          *AddrPtr, *PrevPtr;
    IP_STATUS          Status;
    Interface         *IF;
    IGMPBlockStruct    Block;
    IGMPBlockStruct   *BlockPtr;
    uint               IgmpVersion = 0, BodyMTU;
    IPAddr             SrcAddr;
    IGMPv3GroupRecord *AllowRec = NULL, *BlockRec = NULL;
    uint               AllowRecSize = 0, BlockRecSize = 0;

    // First make sure we're at level 2 of IGMP support.

    if (IGMPLevel != 2)
        return IP_BAD_REQ;

    // Make sure addlist and dellist aren't both empty
    ASSERT((NumAddSources > 0) || (NumDelSources > 0));

    if (NTE->nte_flags & NTE_VALID) {

        //
        // If this is an unnumbered interface
        //

        if ((NTE->nte_if->if_flags & IF_FLAGS_NOIPADDR) &&
            IP_ADDR_EQUAL(NTE->nte_addr, NULL_IP_ADDR)) {
            SrcAddr = g_ValidAddr;
            if (IP_ADDR_EQUAL(SrcAddr, NULL_IP_ADDR)) {
                return IP_BAD_REQ;
            }
        } else {
            SrcAddr = NTE->nte_addr;
        }
    }
    CTEInitBlockStruc(&Block.ibs_block);

    // Make sure we're the only ones in this routine. If someone else is
    // already here, block.

    CTEGetLock(&IGMPLock, &Handle);
    if (IGMPBlockFlag) {

        // Someone else is already here. Walk down the block list, and
        // put ourselves on the end. Then free the lock and block on our
        // IGMPBlock structure.
        BlockPtr = STRUCT_OF(IGMPBlockStruct, &IGMPBlockList, ibs_next);
        while (BlockPtr->ibs_next != NULL)
            BlockPtr = BlockPtr->ibs_next;

        Block.ibs_next = NULL;
        BlockPtr->ibs_next = &Block;
        CTEFreeLock(&IGMPLock, Handle);
        CTEBlock(&Block.ibs_block);
    } else {
        // No one else here, set the flag so no one else gets in and free the
        // lock.
        IGMPBlockFlag = 1;
        CTEFreeLock(&IGMPLock, Handle);
    }

    // Now we're in the routine, and we won't be reentered here by another
    // thread of execution. Make sure everything's valid, and figure out
    // what to do.

    Status = IP_SUCCESS;

    // Now get the lock on the NTE and make sure it's valid.
    CTEGetLock(&NTE->nte_lock, &Handle);
    do {

        if (!(NTE->nte_flags & NTE_VALID)) {
            Status = IP_BAD_REQ;
            break;
        }

        IF = NTE->nte_if;
        BodyMTU = RECORD_MTU(NTE);
        IgmpVersion = IF->IgmpVersion;

        // Find the IGMPAddr entry
        AddrPtr = FindIGMPAddr(NTE, Addr, &PrevPtr);

        // Break if not there or refcount=0
        ASSERT(AddrPtr && (AddrPtr->iga_grefcnt!=0));

        // Perform XADDLIST
        Status = IGMPAddExclList(NTE, PrevPtr, &AddrPtr, NumAddSources,
                                 AddSourceList);
        if (Status != IP_SUCCESS) {
            break;
        }

        // Perform XDELLLIST
        IGMPDelExclList(NTE, PrevPtr, &AddrPtr, NumDelSources, DelSourceList,
                        TRUE);

        // Don't need to reget AddrPtr here since the NTE lock is never
        // released while modifying the exclusion list above, since the
        // linklayer filter is unaffected.

        if (IgmpVersion == IGMPV3) {
            AllowRec = GetAllowRecord(AddrPtr, &AllowRecSize);
            BlockRec = GetBlockRecord(AddrPtr, &BlockRecSize);

            // Set retransmission timer
            AddrPtr->iga_trtimer = IGMPRandomTicks(UNSOLICITED_REPORT_INTERVAL);
        }

    } while (FALSE);
    CTEFreeLock(&NTE->nte_lock, Handle);

    // Since AddrPtr->iga_grefcnt cannot be zero, and is unchanged by
    // this function, we never need to update the link-layer filter.

    // Send IGMP ALLOW/BLOCK messages if non-empty
    // Note that we never need to do anything here in IGMPv1/v2 mode.
    if (IgmpVersion == IGMPV3) {
        IGMPv3RecordQueueEntry *Head = NULL, *rqe;
        rqe = STRUCT_OF(IGMPv3RecordQueueEntry, &Head, i3qe_next);
        QueueRecord(&rqe, &AllowRec, AllowRecSize);
        QueueRecord(&rqe, &BlockRec, BlockRecSize);
        SendIGMPv3Reports(Head, SrcAddr, BodyMTU);
    }

    // We finished the request, and Status contains the completion status.
    // If there are any pending blocks for this routine, signal the next
    // one now. Otherwise clear the block flag.
    CTEGetLock(&IGMPLock, &Handle);
    if ((BlockPtr = IGMPBlockList) != NULL) {
        // Someone is blocking. Pull him from the list and signal him.
        IGMPBlockList = BlockPtr->ibs_next;
        CTEFreeLock(&IGMPLock, Handle);

        CTESignal(&BlockPtr->ibs_block, IP_SUCCESS);
    } else {
        // No one blocking, just clear the flag.
        IGMPBlockFlag = 0;
        CTEFreeLock(&IGMPLock, Handle);
    }

    return Status;
}

//* JoinIGMPAddr - add a membership reference to an entire group, and
//  update associated source list refcounts.
//
// On failure, state will remain unchanged.
IP_STATUS
JoinIGMPAddr(
    IN     NetTableEntry *NTE,
    IN     IPAddr         Addr,
    IN     uint           NumExclSources,
    IN OUT IPAddr        *ExclSourceList, // volatile
    IN     uint           NumInclSources,
    IN     IPAddr        *InclSourceList,
    IN     IPAddr         SrcAddr)
{
    IGMPAddr          *AddrPtr, *PrevPtr;
    IGMPSrcAddr       *SrcAddrPtr, *PrevSrc;
    Interface         *IF;
    uint               IgmpVersion, i, AddrAdded, BodyMTU;
    IP_STATUS          Status;
    CTELockHandle      Handle;
    IGMPv3GroupRecord *ToExRec = NULL, *AllowRec = NULL, *BlockRec = NULL;
    uint               ToExRecSize, AllowRecSize, BlockRecSize;
    BOOLEAN            GroupWasAllowed;
    uint               InitialRefOnIgmpAddr;

    Status = IP_SUCCESS;

    CTEGetLock(&NTE->nte_lock, &Handle);


    do {
        if (!(NTE->nte_flags & NTE_VALID)) {
            Status = IP_BAD_REQ;
            break;
        }

        IF = NTE->nte_if;
        IgmpVersion = IF->IgmpVersion;
        BodyMTU = RECORD_MTU(NTE);

        // If no group entry exists, create one in exclusion mode
        Status = FindOrCreateIGMPAddr(NTE, Addr, &AddrPtr, &PrevPtr);
        if (Status != IP_SUCCESS) {
            break;
        }


        // Store the ref count at this point in a local variable.
        InitialRefOnIgmpAddr = AddrPtr->iga_grefcnt;

        GroupWasAllowed = IS_GROUP_ALLOWED(AddrPtr);

        if (!GroupWasAllowed) {

            // We have to be careful not to release the lock while
            // IS_GROUP_DELETABLE() is true, or else it might be
            // deleted by IGMPTimer().  So before releasing the lock,
            // we bump the join refcount (which we want to do anyway
            // later on, so it won't hurt anything now).
            (AddrPtr->iga_grefcnt)++;

            // Update link-layer filter
            CTEFreeLock(&NTE->nte_lock, Handle);
            {
                AddrAdded = (*IF->if_addaddr) (IF->if_lcontext,
                                               LLIP_ADDR_MCAST, Addr, 0, NULL);
            }
            CTEGetLock(&NTE->nte_lock, &Handle);

            // Revalidate NTE, AddrPtr, PrevPtr
            if (!(NTE->nte_flags & NTE_VALID)) {
                // Don't need to undo any refcount here as the refcount
                // was blown away by StopIGMPForNTE.
                Status = IP_BAD_REQ;
                break;
            }

            // Find the IGMPAddr entry
            AddrPtr = FindIGMPAddr(NTE, Addr, &PrevPtr);
            if (!AddrPtr) {
                Status = IP_BAD_REQ;
                break;
            }

            // Now release the refcount we grabbed above
            // so the rest of the logic is the same for
            // all cases.
            (AddrPtr->iga_grefcnt)--;

            if (!AddrAdded) {
                if (IS_GROUP_DELETABLE(AddrPtr))
                    DeleteIGMPAddr(NTE, PrevPtr, &AddrPtr);
                Status = IP_NO_RESOURCES;
                break;
            }
        }

        // For each existing source entry,
        //    If not in {xaddlist}, xrefcnt=refcount, irefcnt=0
        //       Add source to ALLOW message
        //    If in {xaddlist},
        //       Increment xrefcnt and remove from {xaddlist}
        for (SrcAddrPtr = AddrPtr->iga_srclist;
             SrcAddrPtr;
             SrcAddrPtr = SrcAddrPtr->isa_next) {

            for (i=0; i<NumExclSources; i++) {

                if (IP_ADDR_EQUAL(SrcAddrPtr->isa_addr, ExclSourceList[i])) {
                    (SrcAddrPtr->isa_xrefcnt)++;
                    ExclSourceList[i] = ExclSourceList[--NumExclSources];
                    break;
                }
            }
            if ((i == NumExclSources)
             && !IS_SOURCE_ALLOWED(AddrPtr, SrcAddrPtr)
             && (NTE->nte_if->IgmpVersion == IGMPV3)) {
                // Add source to ALLOW message
                MarkSource(AddrPtr, SrcAddrPtr);
            }
        }

        // The purpose of this check is to mark this Address 'only the first time'.
        // To take care of race conditions, this has to be stored in a local variable.
        if (InitialRefOnIgmpAddr == 0) {
            MarkGroup(AddrPtr);
        }

        // Bump the refcount on the group entry
        (AddrPtr->iga_grefcnt)++;

        // For each entry left in {xaddlist}
        //    Add source entry and increment xrefcnt
        for (i=0; i<NumExclSources; i++) {
            Status = CreateIGMPSrcAddr(AddrPtr, ExclSourceList[i],
                                       &SrcAddrPtr, &PrevSrc);
            if (Status != IP_SUCCESS) {
                break;
            }
            (SrcAddrPtr->isa_xrefcnt)++;
        }
        if (Status != IP_SUCCESS) {
            // undo source adds
            IGMPDelExclList(NTE, PrevPtr, &AddrPtr, i, ExclSourceList, FALSE);

            // undo group join
            (AddrPtr->iga_grefcnt)--;

            if (IS_GROUP_DELETABLE(AddrPtr))
                DeleteIGMPAddr(NTE, PrevPtr, &AddrPtr);

            break;
        }

        // Perform IDELLIST
        IGMPDelInclList(&Handle, NTE, &PrevPtr, &AddrPtr,
                        NumInclSources, InclSourceList, TRUE);

        // Make sure AddrPtr didn't go away somehow
        if (AddrPtr == NULL) {
            Status = IP_BAD_REQ;
            break;
        }

        // No reports are sent for the ALL_HOST_MCAST group
        if (!IP_ADDR_EQUAL(AddrPtr->iga_addr, ALL_HOST_MCAST)) {
            if (IgmpVersion == IGMPV3) {
                // If filter mode was inclusion,
                //    Send TO_EX with list of sources where irefcnt=0,xrefcnt=refcnt
                // Else
                //    Send ALLOW/BLOCK messages if non-empty
                if (AddrPtr->iga_grefcnt == 1) {
                    ToExRec  = GetToExRecord( AddrPtr, &ToExRecSize, BodyMTU);
                } else {
                    AllowRec = GetAllowRecord(AddrPtr, &AllowRecSize);
                    BlockRec = GetBlockRecord(AddrPtr, &BlockRecSize);
                }

                // set triggered group retransmission timer
                AddrPtr->iga_trtimer = IGMPRandomTicks(UNSOLICITED_REPORT_INTERVAL);
            } else if (!GroupWasAllowed) {
                // Set retransmission timer
                AddrPtr->iga_trtimer = IGMPRandomTicks(UNSOLICITED_REPORT_INTERVAL);
            }
        }

    } while (FALSE);
    CTEFreeLock(&NTE->nte_lock, Handle);

    if (Status != IP_SUCCESS) {
        return Status;
    }

    if (IP_ADDR_EQUAL(Addr, ALL_HOST_MCAST))
        return Status;

    if (IgmpVersion == IGMPV3) {
        IGMPv3RecordQueueEntry *Head = NULL, *rqe;
        rqe = STRUCT_OF(IGMPv3RecordQueueEntry, &Head, i3qe_next);

        QueueRecord(&rqe, &ToExRec,  ToExRecSize);
        QueueRecord(&rqe, &AllowRec, AllowRecSize);
        QueueRecord(&rqe, &BlockRec, BlockRecSize);
        SendIGMPv3Reports(Head, SrcAddr, BodyMTU);

    } else if (!GroupWasAllowed) {
        IGMPReportQueueEntry *Head = NULL, *rqe;
        rqe = STRUCT_OF(IGMPReportQueueEntry, &Head, iqe_next);

        QueueOldReport(&rqe, IGMP_ADD, IgmpVersion, Addr);
        SendOldReports(Head, SrcAddr);
    }

    return Status;
}

//* LeaveIGMPAddr - remove a membership reference to an entire group, and
//  update associated source list refcounts.
IP_STATUS
LeaveIGMPAddr(
    IN     NetTableEntry *NTE,
    IN     IPAddr         Addr,
    IN     uint           NumExclSources,
    IN OUT IPAddr        *ExclSourceList, // volatile
    IN     uint           NumInclSources,
    IN     IPAddr        *InclSourceList,
    IN     IPAddr         SrcAddr)
{
    IGMPAddr     *AddrPtr, *PrevPtr;
    IGMPSrcAddr  *Src, *PrevSrc;
    IP_STATUS     Status;
    CTELockHandle Handle;
    Interface    *IF;
    uint          IgmpVersion, i, BodyMTU;
    BOOLEAN       GroupNowAllowed = TRUE;
    IGMPv3GroupRecord *ToInRec = NULL, *AllowRec = NULL, *BlockRec = NULL;
    uint               ToInRecSize, AllowRecSize, BlockRecSize;

    Status = IP_SUCCESS;

    DEBUGMSG(DBG_TRACE && DBG_IGMP,
        (DTEXT("LeaveIGMPAddr NTE=%x Addr=%x NumExcl=%d ExclSList=%x NumIncl=%d InclSList=%x SrcAddr=%x\n"),
        NTE, Addr, NumExclSources, ExclSourceList, NumInclSources,
        InclSourceList, SrcAddr));

    // Now get the lock on the NTE and make sure it's valid.
    CTEGetLock(&NTE->nte_lock, &Handle);
    do {

        if (!(NTE->nte_flags & NTE_VALID)) {
            Status = IP_BAD_REQ;
            break;
        }

        IF = NTE->nte_if;
        IgmpVersion = IF->IgmpVersion;
        BodyMTU = RECORD_MTU(NTE);

        // The NTE is valid. Try to find an existing IGMPAddr structure
        // that matches the input address.
        AddrPtr = FindIGMPAddr(NTE, Addr, &PrevPtr);

        // This is a delete request. If we didn't find the requested
        // address, fail the request.

        // For now, if the ref count is 0, we will treat it as equivalent to 
        // not-found. This is done to take care of the ref count on an
        // IGMPAddr going bad because of a race condition between the 
        // invalidation and revalidation of an NTE and deletion and creation
        // of an IGMPAddr.
        if ((AddrPtr == NULL) || (AddrPtr->iga_grefcnt == 0)) {
            Status = IP_BAD_REQ;
            break;
        }

        // Don't let the all-hosts mcast address go away.
        if (IP_ADDR_EQUAL(Addr, ALL_HOST_MCAST)) {
            break;
        }

        // Perform IADDLIST
        Status = IGMPAddInclList(&Handle, NTE, &PrevPtr, &AddrPtr,
                                 NumInclSources, InclSourceList);
        if (Status != IP_SUCCESS) {
            break;
        }

        // Decrement the refcount
        ASSERT(AddrPtr->iga_grefcnt > 0);
        AddrPtr->iga_grefcnt--;

        if ((AddrPtr->iga_grefcnt == 0)
         && (NTE->nte_if->IgmpVersion == IGMPV3)) {
            // Leaves are only retransmitted in IGMPv3
            MarkGroup(AddrPtr);
        }

        // For each existing source entry:
        //    If entry is not in {xdellist}, xrefcnt=refcnt, irefcnt=0,
        //       Add source to BLOCK message
        //    If entry is in {xdellist},
        //       Decrement xrefcnt and remove from {xdellist}
        //       If xrefcnt=irefcnt=0, delete entry
        PrevSrc = STRUCT_OF(IGMPSrcAddr, &AddrPtr->iga_srclist, isa_next);
        for (Src = AddrPtr->iga_srclist; Src; PrevSrc=Src,Src = Src->isa_next) {

            for (i=0; i<NumExclSources; i++) {

                if (IP_ADDR_EQUAL(Src->isa_addr, ExclSourceList[i])) {
                    (Src->isa_xrefcnt)--;
                    ExclSourceList[i] = ExclSourceList[--NumExclSources];
                    break;
                }
            }
            if ((i == NumExclSources)
             && !IS_SOURCE_ALLOWED(AddrPtr, Src)
             && (NTE->nte_if->IgmpVersion == IGMPV3)) {
                // Add source to BLOCK message
                MarkSource(AddrPtr, Src);
            }

            if (IS_SOURCE_DELETABLE(Src)) {
                DeleteIGMPSrcAddr(PrevSrc, &Src);
                Src = PrevSrc;
            }
        }

        // Break if {xdellist} is not empty
        ASSERT(NumExclSources == 0);

        if (IgmpVersion == IGMPV3) {
            // If refcnt is 0
            //    Send TO_IN(null)
            // Else
            //    Send ALLOW/BLOCK messages if non-empty
            if (AddrPtr->iga_grefcnt == 0) {
                ToInRec  = GetToInRecord(AddrPtr, &ToInRecSize);
            } else {
                AllowRec = GetAllowRecord(AddrPtr, &AllowRecSize);
                BlockRec = GetBlockRecord(AddrPtr, &BlockRecSize);
            }

            // set triggered group retransmission timer
            if (ToInRec || AllowRec || BlockRec) {
                AddrPtr->iga_trtimer = IGMPRandomTicks(UNSOLICITED_REPORT_INTERVAL);
            }
        }
        // Note: IGMPv2 leaves are not retransmitted, hence no timer set.

        GroupNowAllowed = IS_GROUP_ALLOWED(AddrPtr);

        if (!GroupNowAllowed)
            CancelGroupResponseTimer(AddrPtr);

        // Delete the group entry if it's no longer needed
        if (IS_GROUP_DELETABLE(AddrPtr))
            DeleteIGMPAddr(NTE, PrevPtr, &AddrPtr);

    } while (FALSE);
    CTEFreeLock(&NTE->nte_lock, Handle);

    if (Status != IP_SUCCESS) {
        return Status;
    }

    // Update link-layer filter
    if (!GroupNowAllowed) {
        (*IF->if_deladdr) (IF->if_lcontext, LLIP_ADDR_MCAST, Addr, 0);
    }

    if (IgmpVersion == IGMPV3) {
        IGMPv3RecordQueueEntry *Head = NULL, *rqe;
        rqe = STRUCT_OF(IGMPv3RecordQueueEntry, &Head, i3qe_next);

        QueueRecord(&rqe, &ToInRec, ToInRecSize);
        QueueRecord(&rqe, &AllowRec, AllowRecSize);
        QueueRecord(&rqe, &BlockRec, BlockRecSize);
        SendIGMPv3Reports(Head, SrcAddr, BodyMTU);
    } else if (!GroupNowAllowed) {
        IGMPReportQueueEntry *Head = NULL, *rqe;
        rqe = STRUCT_OF(IGMPReportQueueEntry, &Head, iqe_next);
        QueueOldReport(&rqe, IGMP_DELETE, IgmpVersion, Addr);
        SendOldReports(Head, SrcAddr);
    }

    return Status;
}

//* LeaveAllIGMPAddr - remove all group references on an interface
IP_STATUS
LeaveAllIGMPAddr(
    IN NetTableEntry *NTE,
    IN IPAddr         SrcAddr)
{
    IGMPAddr    **HashPtr, *Prev, *Next, *Curr;
    IGMPSrcAddr  *PrevSrc, *CurrSrc;
    int           i, Grefcnt;
    IP_STATUS     Status;
    CTELockHandle Handle;
    Interface    *IF;
    uint          IgmpVersion = 0, BodyMTU, OldMode;
    IPAddr        Addr;
    IGMPv3RecordQueueEntry *I3Head  = NULL, *i3qe;
    IGMPReportQueueEntry   *OldHead = NULL, *iqe;
    IGMPv3GroupRecord      *Rec;
    uint                    RecSize;

    i3qe = STRUCT_OF(IGMPv3RecordQueueEntry, &I3Head, i3qe_next);
    iqe  = STRUCT_OF(IGMPReportQueueEntry, &OldHead, iqe_next);

    // We've been called to delete all of the addresses,
    // regardless of their reference count. This should only
    // happen when the NTE is going away.

    Status = IP_SUCCESS;

    CTEGetLock(&NTE->nte_lock, &Handle);
    do {
        HashPtr = NTE->nte_igmplist;
        if (HashPtr == NULL) {
            break;
        }

        IF = NTE->nte_if;
        BodyMTU = RECORD_MTU(NTE);
        IgmpVersion = IF->IgmpVersion;

        for (i = 0; (i < IGMP_TABLE_SIZE) && (NTE->nte_igmplist != NULL); i++) {

            Curr = STRUCT_OF(IGMPAddr, &HashPtr[i], iga_next);
            Next = HashPtr[i];

            for (Prev=Curr,Curr=Next;
                 Curr && (NTE->nte_igmplist != NULL);
                 Prev=Curr,Curr=Next) {
                Next = Curr->iga_next;

                Grefcnt = Curr->iga_grefcnt;
                Addr = Curr->iga_addr;

                // Leave all sources
                PrevSrc = STRUCT_OF(IGMPSrcAddr, &Curr->iga_srclist, isa_next);
                for(CurrSrc=PrevSrc->isa_next;
                    CurrSrc;
                    PrevSrc=CurrSrc,CurrSrc=CurrSrc->isa_next) {

                    if (Grefcnt && IS_SOURCE_ALLOWED(Curr, CurrSrc)
                     && (IF->IgmpVersion == IGMPV3)) {
                        // Add source to BLOCK message
                        MarkSource(Curr, CurrSrc);
                    }

                    // Force leave
                    CurrSrc->isa_irefcnt = 0;
                    CurrSrc->isa_xrefcnt = Curr->iga_grefcnt;

                    //
                    // We may be able to delete the source now,
                    // but not if it's marked for inclusion in a block
                    // message to be sent below.
                    //
                    if (IS_SOURCE_DELETABLE(CurrSrc)) {
                        DeleteIGMPSrcAddr(PrevSrc, &CurrSrc);
                        CurrSrc = PrevSrc;
                    }
                }

                // Force group leave
                if (Grefcnt > 0) {
                    Curr->iga_grefcnt = 0;

                    // Leaves are only retransmitted in IGMPv3, where
                    // state will actually be deleted once retransmissions
                    // are complete.
                    if (NTE->nte_if->IgmpVersion == IGMPV3)
                        MarkGroup(Curr);

                    CancelGroupResponseTimer(Curr);

                    //
                    // We may be able to delete the group now,
                    // but not if it's marked for inclusion in an IGMPv3
                    // leave to be sent below.
                    //
                    if (IS_GROUP_DELETABLE(Curr))
                        DeleteIGMPAddr(NTE, Prev, &Curr);
                }

                // Queue triggered messages
                if (!IP_ADDR_EQUAL(Addr, ALL_HOST_MCAST)) {
                    if (IgmpVersion < IGMPV3) {
                        QueueOldReport(&iqe, IGMP_DELETE, IgmpVersion,Addr);
                    } else if (Grefcnt > 0) {
                        // queue TO_IN
                        Rec = GetToInRecord(Curr, &RecSize);
                        QueueRecord(&i3qe, &Rec, RecSize);
                    } else {
                        // queue BLOCK
                        Rec = GetBlockRecord(Curr, &RecSize);
                        QueueRecord(&i3qe, &Rec, RecSize);
                    }
                }

                // If we haven't deleted the group yet, delete it now
                if (Curr != NULL) {
                    // Delete any leftover sources
                    PrevSrc = STRUCT_OF(IGMPSrcAddr, &Curr->iga_srclist,
                                        isa_next);
                    while (Curr->iga_srclist != NULL) {
                        CurrSrc = Curr->iga_srclist;

                        CurrSrc->isa_irefcnt = CurrSrc->isa_xrefcnt = 0;
                        CurrSrc->isa_xmitleft = CurrSrc->isa_csmarked = 0;
                        DeleteIGMPSrcAddr(PrevSrc, &CurrSrc);
                    }

                    Curr->iga_xmitleft = 0;
                    DeleteIGMPAddr(NTE, Prev, &Curr);
                }
                Curr = Prev;

                CTEFreeLock(&NTE->nte_lock, Handle);
                {
                    // Update link-layer filter
                    (*IF->if_deladdr) (IF->if_lcontext, LLIP_ADDR_MCAST,
                                       Addr, 0);
                }
                CTEGetLock(&NTE->nte_lock, &Handle);
            }
        }

        ASSERT(NTE->nte_igmplist == NULL);
        ASSERT(NTE->nte_igmpcount == 0);

    } while (FALSE);
    CTEFreeLock(&NTE->nte_lock, Handle);

    if (IgmpVersion == IGMPV3)
        SendIGMPv3Reports(I3Head, SrcAddr, BodyMTU);
    else
        SendOldReports(OldHead, SrcAddr);

    return Status;
}

//*     IGMPAddrChange - Change the IGMP address list on an NTE.
//
//      Called to add or delete an IGMP address. We're given the relevant NTE,
//      the address, and the action to be performed. We validate the NTE, the
//      address, and the IGMP level, and then attempt to perform the action.
//
//      There are a bunch of strange race conditions that can occur during
//      adding/deleting addresses, related to trying to add the same address
//      twice and having it fail, or adding and deleting the same address
//      simultaneously. Most of these happen because we have to free the lock
//      to call the interface, and the call to the interface can fail. To
//      prevent this we serialize all access to this routine. Only one thread
//      of execution can go through here at a time, all others are blocked.
//
//      Input:  NTE             - NTE with list to be altered.
//              Addr            - Address affected.
//              ChangeType      - Type of change - IGMP_ADD, IGMP_DELETE,
//                                  IGMP_DELETE_ALL.
//              ExclSourceList  - list of exclusion sources (volatile)
//
//      Returns: IP_STATUS of attempt to perform action.
//
IP_STATUS
IGMPAddrChange(
    IN     NetTableEntry *NTE,
    IN     IPAddr         Addr,
    IN     uint           ChangeType,
    IN     uint           NumExclSources,
    IN OUT IPAddr        *ExclSourceList,
    IN     uint           NumInclSources,
    IN     IPAddr        *InclSourceList)
{
    CTELockHandle Handle;
    IGMPAddr *AddrPtr, *PrevPtr;
    IGMPSrcAddr *SrcAddrPtr;
    IP_STATUS Status;
    Interface *IF;
    uint AddrAdded;
    IGMPBlockStruct Block;
    IGMPBlockStruct *BlockPtr;
    uint IgmpVersion;
    IPAddr SrcAddr = 0;

    // First make sure we're at level 2 of IGMP support.

    if (IGMPLevel != 2)
        return IP_BAD_REQ;

    if (NTE->nte_flags & NTE_VALID) {

        //
        // If this is an unnumbered interface
        //

        if ((NTE->nte_if->if_flags & IF_FLAGS_NOIPADDR) &&
            IP_ADDR_EQUAL(NTE->nte_addr, NULL_IP_ADDR)) {
            SrcAddr = g_ValidAddr;
            if (IP_ADDR_EQUAL(SrcAddr, NULL_IP_ADDR)) {
                return IP_BAD_REQ;
            }
        } else {
            SrcAddr = NTE->nte_addr;
        }
    }
    CTEInitBlockStruc(&Block.ibs_block);

    // Make sure we're the only ones in this routine. If someone else is
    // already here, block.

    CTEGetLock(&IGMPLock, &Handle);
    if (IGMPBlockFlag) {

        // Someone else is already here. Walk down the block list, and
        // put ourselves on the end. Then free the lock and block on our
        // IGMPBlock structure.
        BlockPtr = STRUCT_OF(IGMPBlockStruct, &IGMPBlockList, ibs_next);
        while (BlockPtr->ibs_next != NULL)
            BlockPtr = BlockPtr->ibs_next;

        Block.ibs_next = NULL;
        BlockPtr->ibs_next = &Block;
        CTEFreeLock(&IGMPLock, Handle);
        CTEBlock(&Block.ibs_block);
    } else {
        // Noone else here, set the flag so noone else gets in and free the
        // lock.
        IGMPBlockFlag = 1;
        CTEFreeLock(&IGMPLock, Handle);
    }

    // Now we're in the routine, and we won't be reentered here by another
    // thread of execution. Make sure everything's valid, and figure out
    // what to do.

    Status = IP_SUCCESS;

    // Now figure out the action to be performed.
    switch (ChangeType) {

    case IGMP_ADD:
        Status = JoinIGMPAddr(NTE, Addr, NumExclSources, ExclSourceList,
                                         NumInclSources, InclSourceList,
                              SrcAddr);
        break;

    case IGMP_DELETE:
        Status = LeaveIGMPAddr(NTE, Addr, NumExclSources, ExclSourceList,
                                          NumInclSources, InclSourceList,
                               SrcAddr);
        break;

    case IGMP_DELETE_ALL:
        Status = LeaveAllIGMPAddr(NTE, SrcAddr);
        break;

    default:
        DEBUGCHK;
        break;
    }

    // We finished the request, and Status contains the completion status.
    // If there are any pending blocks for this routine, signal the next
    // one now. Otherwise clear the block flag.
    CTEGetLock(&IGMPLock, &Handle);
    if ((BlockPtr = IGMPBlockList) != NULL) {
        // Someone is blocking. Pull him from the list and signal him.
        IGMPBlockList = BlockPtr->ibs_next;
        CTEFreeLock(&IGMPLock, Handle);

        CTESignal(&BlockPtr->ibs_block, IP_SUCCESS);
    } else {
        // No one blocking, just clear the flag.
        IGMPBlockFlag = 0;
        CTEFreeLock(&IGMPLock, Handle);
    }

    return Status;
}

//* GroupResponseTimeout - Called when group-response timer expires
// Assumes caller holds lock on NTE
// Caller is responsible for deleting AddrPtr if no longer needed
void
GroupResponseTimeout(
    IN OUT IGMPv3RecordQueueEntry **pI3qe,
    IN OUT IGMPReportQueueEntry   **pIqe,
    IN     NetTableEntry           *NTE,
    IN     IGMPAddr                *AddrPtr)
{
    uint IgmpVersion, BodyMTU, StateRecSize = 0;
    IGMPv3GroupRecord *StateRec = NULL;

    DEBUGMSG(DBG_TRACE && DBG_IGMP && DBG_TX,
        (DTEXT("GroupResponseTimeout\n")));

    IgmpVersion = NTE->nte_if->IgmpVersion;
    BodyMTU = RECORD_MTU(NTE);

    if (IgmpVersion < IGMPV3) {
        QueueOldReport(pIqe, IGMP_ADD, IgmpVersion, AddrPtr->iga_addr);
        return;
    }

    if (AddrPtr->iga_resptype == GROUP_SOURCE_RESP) {
        StateRec = GetGSIsInRecord(AddrPtr, &StateRecSize);
    } else {
        // Group-specific response
        if (AddrPtr->iga_grefcnt == 0) {
           StateRec = GetIsInRecord(AddrPtr, &StateRecSize);
        } else {
           StateRec = GetIsExRecord(AddrPtr, &StateRecSize, BodyMTU);
        }
    }
    QueueRecord(pI3qe, &StateRec, StateRecSize);

    CancelGroupResponseTimer(AddrPtr);
}

//* RetransmissionTimeout - called when retransmission timer expires
//
// Caller is responsible for deleting Grp afterwards if no longer needed
void
RetransmissionTimeout(
    IN OUT IGMPv3RecordQueueEntry **pI3qe,
    IN OUT IGMPReportQueueEntry   **pIqe,
    IN     NetTableEntry           *NTE,
    IN     IGMPAddr                *Grp)
{
    IGMPv3GroupRecord *Rec = NULL;
    uint               RecSize = 0;
    uint               IgmpVersion, BodyMTU;

    DEBUGMSG(DBG_TRACE && DBG_IGMP && DBG_TX,
        (DTEXT("RetransmissionTimeout\n")));

    IgmpVersion = NTE->nte_if->IgmpVersion;

    BodyMTU = RECORD_MTU(NTE);

    if (IgmpVersion < IGMPV3) {
        // We decrement the counter here since the same function
        // is used to respond to queries.
        IgmpDecXmitLeft(Grp);

        QueueOldReport(pIqe, IGMP_ADD, IgmpVersion, Grp->iga_addr);
    } else {
        if (Grp->iga_changetype == MODE_CHANGE) {
            if (Grp->iga_grefcnt == 0) {
                Rec = GetToInRecord(Grp, &RecSize);
            } else {
                Rec = GetToExRecord(Grp, &RecSize, BodyMTU);
            }
            QueueRecord(pI3qe, &Rec, RecSize);
        } else {
            Rec = GetAllowRecord(Grp, &RecSize);
            QueueRecord(pI3qe, &Rec, RecSize);

            Rec = GetBlockRecord(Grp, &RecSize);
            QueueRecord(pI3qe, &Rec, RecSize);
        }
    }

    if (Grp->iga_xmitleft > 0) {
        Grp->iga_trtimer = IGMPRandomTicks(UNSOLICITED_REPORT_INTERVAL);
    }
}

//*     IGMPTimer - Handle an IGMP timer event.
//
//      This function is called every 500 ms. by IP. If we're at level 2 of
//      IGMP functionality we run down the NTE looking for running timers. If
//      we find one, we see if it has expired and if so we send an
//      IGMP report.
//
//      Input:  NTE             - Pointer to NTE to check.
//
//      Returns: Nothing.
//
void
IGMPTimer(
    IN NetTableEntry * NTE)
{
    CTELockHandle           Handle;
    IGMPAddr               *AddrPtr, *PrevPtr;
    uint                    IgmpVersion = 0, BodyMTU, i;
    IPAddr                  SrcAddr;
    IGMPAddr              **HashPtr;
    IGMPv3GroupRecord      *StateRec;
    uint                    StateRecSize;
    IGMPv3RecordQueueEntry *I3Head = NULL, *i3qe;
    IGMPReportQueueEntry   *OldHead = NULL, *iqe;

    i3qe = STRUCT_OF(IGMPv3RecordQueueEntry, &I3Head, i3qe_next);
    iqe  = STRUCT_OF(IGMPReportQueueEntry, &OldHead, iqe_next);

    if (IGMPLevel != 2) {
        return;
    }

    // We are doing IGMP. Run down the addresses active on this NTE.
    CTEGetLock(&NTE->nte_lock, &Handle);

    if (NTE->nte_flags & NTE_VALID) {

        //
        // If we haven't heard any query from an older version
        // router during timeout period, revert to newer version.
        // No need to check whether NTE is valid or not
        //
        if ((NTE->nte_if->IgmpVer2Timeout != 0)
        && (--(NTE->nte_if->IgmpVer2Timeout) == 0)) {
            NTE->nte_if->IgmpVersion = IGMPV3;
        }
        if ((NTE->nte_if->IgmpVer1Timeout != 0)
        && (--(NTE->nte_if->IgmpVer1Timeout) == 0)) {
            NTE->nte_if->IgmpVersion = IGMPV3;
        }
        if (NTE->nte_if->IgmpVer2Timeout != 0)
            NTE->nte_if->IgmpVersion = IGMPV2;
        if (NTE->nte_if->IgmpVer1Timeout != 0)
            NTE->nte_if->IgmpVersion = IGMPV1;

        if ((NTE->nte_if->if_flags & IF_FLAGS_NOIPADDR) &&
            IP_ADDR_EQUAL(NTE->nte_addr, NULL_IP_ADDR)) {
            SrcAddr = g_ValidAddr;
            if (IP_ADDR_EQUAL(SrcAddr, NULL_IP_ADDR)) {
                CTEFreeLock(&NTE->nte_lock, Handle);
                return;
            }
        } else {
            SrcAddr = NTE->nte_addr;
        }

        BodyMTU = RECORD_MTU(NTE);
        IgmpVersion = NTE->nte_if->IgmpVersion;

        HashPtr = NTE->nte_igmplist;

        for (i=0; (i<IGMP_TABLE_SIZE) && (NTE->nte_igmplist!=NULL); i++) {
            PrevPtr = STRUCT_OF(IGMPAddr, &HashPtr[i], iga_next);
            AddrPtr = PrevPtr->iga_next;
            while (AddrPtr != NULL) {

                // Hande group response timer
                if (AddrPtr->iga_resptimer != 0) {
                    AddrPtr->iga_resptimer--;
                    if ((AddrPtr->iga_resptimer == 0)
                     && (NTE->nte_flags & NTE_VALID)) {
                        GroupResponseTimeout(&i3qe, &iqe, NTE, AddrPtr);
                    }
                }

                // Handle triggered retransmission timer
                if (AddrPtr->iga_trtimer != 0) {
                    AddrPtr->iga_trtimer--;
                    if ((AddrPtr->iga_trtimer == 0)
                     && (NTE->nte_flags & NTE_VALID)) {
                        RetransmissionTimeout(&i3qe, &iqe, NTE, AddrPtr);
                    }
                }

                // Delete group if no longer needed
                if (IS_GROUP_DELETABLE(AddrPtr)) {
                    DeleteIGMPAddr(NTE, PrevPtr, &AddrPtr);
                    AddrPtr = PrevPtr;
                }

                if (NTE->nte_igmplist == NULL) {
                    // PrevPtr is gone
                    break;
                }

                //
                // Go on to the next one.
                //
                PrevPtr = AddrPtr;
                AddrPtr = AddrPtr->iga_next;
            }
        }

        // Check general query timer
        if ((NTE->nte_if->IgmpGeneralTimer != 0)
        && (--(NTE->nte_if->IgmpGeneralTimer) == 0)) {
            QueueIGMPv3GeneralResponse(&i3qe, NTE);
        }
    }                        //nte_valid

    CTEFreeLock(&NTE->nte_lock, Handle);

    if (IgmpVersion == IGMPV3)
        SendIGMPv3Reports(I3Head, SrcAddr, BodyMTU);
    else
        SendOldReports(OldHead, SrcAddr);
}

//* IsMCastSourceAllowed - check if incoming packet passes interface filter
//
// Returns: DEST_MCAST if allowed, DEST_LOCAL if not.
uchar
IsMCastSourceAllowed(
    IN IPAddr         Dest,
    IN IPAddr         Source,
    IN uchar          Protocol,
    IN NetTableEntry *NTE)
{
    CTELockHandle Handle;
    uchar         Result = DEST_LOCAL;
    IGMPAddr     *AddrPtr = NULL;
    IGMPSrcAddr  *SrcPtr = NULL;

    if (IGMPLevel != 2) {
        return DEST_LOCAL;
    }

    // IGMP Queries must be immune to source filters or else
    // we might not be able to respond to group-specific queries
    // from the querier and hence lose data.
    if (Protocol == PROT_IGMP) {
        return DEST_MCAST;
    }

    CTEGetLock(&NTE->nte_lock, &Handle);
    {
        AddrPtr = FindIGMPAddr(NTE, Dest, NULL);
        if (AddrPtr != NULL) {
            SrcPtr = FindIGMPSrcAddr(AddrPtr, Source, NULL);

            if (SrcPtr) {
                if (IS_SOURCE_ALLOWED(AddrPtr, SrcPtr))
                    Result = DEST_MCAST;
            } else {
                if (IS_GROUP_ALLOWED(AddrPtr))
                    Result = DEST_MCAST;
            }
        }
    }
    CTEFreeLock(&NTE->nte_lock, Handle);

    return Result;
}

//*     InitIGMPForNTE - Called to do per-NTE initialization.
//
//      Called when an NTE becomes valid. If we're at level 2, we put the
//      all-host mcast on the list and add the address to the interface.
//
//      Input:  NTE                     - NTE on which to act.
//
//      Returns: Nothing.
//
void
InitIGMPForNTE(
    IN NetTableEntry * NTE)
{
    if (IGMPLevel == 2) {
        IGMPAddrChange(NTE, ALL_HOST_MCAST, IGMP_ADD, 0, NULL, 0, NULL);
    }
    if (Seed == 0) {
        // No random seed yet.
        Seed = (int)NTE->nte_addr;

        // Make sure the inital value is odd, and less than 9 decimal digits.
        RandomValue = ((Seed + (int)CTESystemUpTime()) % 100000000) | 1;
    }
}

//*     StopIGMPForNTE - Called to do per-NTE shutdown.
//
//      Called when we're shutting down an NTE, and want to stop IGMP on it,
//
//      Input:  NTE                     - NTE on which to act.
//
//      Returns: Nothing.
//
void
StopIGMPForNTE(
    IN NetTableEntry * NTE)
{
    if (IGMPLevel == 2) {
        IGMPAddrChange(NTE, NULL_IP_ADDR, IGMP_DELETE_ALL,
                       0, NULL, 0, NULL);
    }
}

#pragma BEGIN_INIT

//** IGMPInit - Initialize IGMP.
//
//      This bit of code initializes IGMP generally. There is also some amount
//      of work done on a per-NTE basis that we do when each one is initialized.
//
//      Input:  Nothing.
///
//  Returns: TRUE if we init, FALSE if we don't.
//
uint
IGMPInit(void)
{
    DEBUGMSG(DBG_INFO && DBG_IGMP,
        (DTEXT("Initializing IGMP\n")));

    if (IGMPLevel != 2)
        return TRUE;

    CTEInitLock(&IGMPLock);
    IGMPBlockList = NULL;
    IGMPBlockFlag = 0;
    Seed = 0;

    // We fake things a little bit. We register our receive handler, but
    // since we steal buffers from ICMP we register the ICMP send complete
    // handler.
    IGMPProtInfo = IPRegisterProtocol(PROT_IGMP, IGMPRcv, IGMPSendComplete,
                                      NULL, NULL, NULL, NULL);

    if (IGMPProtInfo != NULL)
        return TRUE;
    else
        return FALSE;
}

#pragma END_INIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipv4\info.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

#pragma once

extern CACHE_ALIGN IPSNMPInfo  IPSInfo;
extern ICMPStats               ICMPInStats;
extern ICMPStats               ICMPOutStats;

typedef struct CACHE_ALIGN IPInternalPerCpuStats {
    ulong       ics_inreceives;
    ulong       ics_indelivers;
} IPInternalPerCpuStats;

#define IPS_MAX_PROCESSOR_BUCKETS 8
extern IPInternalPerCpuStats IPPerCpuStats[IPS_MAX_PROCESSOR_BUCKETS];

__forceinline
void IPSIncrementInReceiveCount(void)
{
#if !MILLEN
    const ulong Index = KeGetCurrentProcessorNumber() % IPS_MAX_PROCESSOR_BUCKETS;
    IPPerCpuStats[Index].ics_inreceives++;
#else
    IPSInfo.ipsi_inreceives++;
#endif
}

__forceinline
void IPSIncrementInDeliverCount(void)
{
#if !MILLEN
    const ulong Index = KeGetCurrentProcessorNumber() % IPS_MAX_PROCESSOR_BUCKETS;
    IPPerCpuStats[Index].ics_indelivers++;
#else
    IPSInfo.ipsi_indelivers++;
#endif
}

__inline
void IPSGetTotalCounts(IPInternalPerCpuStats* Stats)
{
    ulong Index;
    const ulong MaxIndex = MIN(KeNumberProcessors, IPS_MAX_PROCESSOR_BUCKETS);

    RtlZeroMemory(Stats, sizeof(IPInternalPerCpuStats));

    for (Index = 0; Index < MaxIndex; Index++) {
        Stats->ics_inreceives += IPPerCpuStats[Index].ics_inreceives;
        Stats->ics_indelivers += IPPerCpuStats[Index].ics_indelivers;
    }
}


typedef struct RouteEntryContext {
    uint                   rec_index;
    struct RouteTableEntry *rec_rte;
} RouteEntryContext;

extern long     IPQueryInfo(struct TDIObjectID *ID, PNDIS_BUFFER Buffer,
                            uint *Size, void *Context);
extern long     IPSetInfo(struct TDIObjectID *ID, void *Buffer, uint Size);
extern long     IPGetEList(struct TDIEntityID *Buffer, uint *Count);

extern ulong    IPSetNdisRequest(IPAddr Addr, NDIS_OID OID, uint On,
                                 uint IfIndex);

extern ulong    IPAbsorbRtrAlert(IPAddr Addr, uchar Protocol, uint IfIndex);

extern BOOLEAN  IsRtrAlertPacket(IPHeader UNALIGNED *Header);

extern NTSTATUS IPWakeupPattern(uint InterfaceContext,
                                PNET_PM_WAKEUP_PATTERN_DESC PtrnDesc,
                                BOOLEAN AddPattern);

extern long     IPGetInterfaceFriendlyName(uint InterfaceContext,
                                           PWCHAR Name, uint Size);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipv4\info.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

  info.c - Routines for querying and setting IP information.

Abstract:

  This file contains the code for dealing with Query/Set information calls.

Author:


[Environment:]

    kernel mode only

[Notes:]

    optional-notes

Revision History:


--*/

#include "precomp.h"
#include "info.h"
#include "iproute.h"
#include "igmp.h"
#include "iprtdef.h"
#include "arpdef.h"
#include "ntddndis.h"
#include "tcpipbuf.h"

extern NDIS_HANDLE BufferPool;
extern Interface *IFList;
extern NetTableEntry **NewNetTableList;        // hash table for NTEs
extern uint NET_TABLE_SIZE;
extern uint LoopIndex;            // Index of loopback I/F.
extern uint DefaultTTL;
extern uint NumIF;
extern uint NumNTE;
extern uint NumActiveNTE;
extern RouteInterface DummyInterface;    // Dummy interface.
extern NetTableEntry *LoopNTE;    // Pointer to loopback NTE
extern uint RTEReadNext(void *Context, void *Buffer);
extern uint RTValidateContext(void *Context, uint * Valid);
extern uint RTReadNext(void *Context, void *Buffer);
extern uint RTRead(void *Context, void *Buffer);
extern void IPInitOptions(IPOptInfo *);

uint IPInstance = INVALID_ENTITY_INSTANCE;
uint ICMPInstance = INVALID_ENTITY_INSTANCE;
TDIEntityID* IPEntityList = NULL;
uint IPEntityCount = 0;

#if FFP_SUPPORT
FFPDriverStats GlobalStatsInfoPrev = {0};   // Stats from the previous request
FFPDriverStats GlobalStatsInfoCurr = {0};   // Stats from the current request
#endif // if FFP_SUPPORT

#define MIB_IPADDR_PRIMARY 1

//* CopyToNdisSafe - Copy a flat buffer to an NDIS_BUFFER chain.
//
//  A utility function to copy a flat buffer to an NDIS buffer chain. We
//  assume that the NDIS_BUFFER chain is big enough to hold the copy amount;
//  in a debug build we'll  debugcheck if this isn't true. We return a pointer
//  to the buffer where we stopped copying, and an offset into that buffer.
//  This is useful for copying in pieces into the chain.
//
//  Input:  DestBuf     - Destination NDIS_BUFFER chain.
//          pNextBuf    - Pointer to next buffer in chain to copy into.
//          SrcBuf      - Src flat buffer.
//          Size        - Size in bytes to copy.
//          StartOffset - Pointer to start of offset into first buffer in
//                          chain. Filled in on return with the offset to
//                          copy into next.
//
//  Returns: TRUE  - Successfully copied flat buffer into NDIS_BUFFER chain.
//           FALSE - Failed to copy entire flat buffer.
//

BOOLEAN
CopyToNdisSafe(PNDIS_BUFFER DestBuf, PNDIS_BUFFER * ppNextBuf,
               uchar * SrcBuf, uint Size, uint * StartOffset)
{
    uint CopySize;
    uchar *DestPtr;
    uint DestSize;
    uint Offset = *StartOffset;
    uchar *VirtualAddress;
    uint Length;

    ASSERT(DestBuf != NULL);
    ASSERT(SrcBuf != NULL);

    TcpipQueryBuffer(DestBuf, &VirtualAddress, &Length, NormalPagePriority);

    if (VirtualAddress == NULL) {
        return (FALSE);
    }
    ASSERT(Length >= Offset);
    DestPtr = VirtualAddress + Offset;
    DestSize = Length - Offset;

    for (;;) {
        CopySize = MIN(Size, DestSize);
        RtlCopyMemory(DestPtr, SrcBuf, CopySize);

        DestPtr += CopySize;
        SrcBuf += CopySize;

        if ((Size -= CopySize) == 0)
            break;

        if ((DestSize -= CopySize) == 0) {
            DestBuf = NDIS_BUFFER_LINKAGE(DestBuf);
            ASSERT(DestBuf != NULL);

            TcpipQueryBuffer(DestBuf, &VirtualAddress, &Length, NormalPagePriority);

            if (VirtualAddress == NULL) {
                return FALSE;
            }
            DestPtr = VirtualAddress;
            DestSize = Length;
        }
    }

    *StartOffset = (uint) (DestPtr - VirtualAddress);

    if (ppNextBuf) {
        *ppNextBuf = DestBuf;
    }
    return TRUE;
}

// this structure is used in IPQueryInfo for IP_MIB_ADDRTABLE_ENTRY_ID
typedef struct _INFO_LIST {
    struct _INFO_LIST *info_next;
    NetTableEntry *info_nte;
} INFO_LIST, *PINFO_LIST;

//* FreeInfoList  - Free INFO_LIST used in IPQueryInfo for IP_MIB_ADDRTABLE_ENTRY_ID
//
// Input: Temp   - List to be freed
//
// Returns: Nothing.
//

void
FreeInfoList(PINFO_LIST Temp)
{
    PINFO_LIST NextTemp;
    PINFO_LIST CurrTemp = Temp;

    while (CurrTemp) {
        NextTemp = CurrTemp->info_next;
        CTEFreeMem(CurrTemp);
        CurrTemp = NextTemp;
    }
}

//* IPQueryInfo - IP query information handler.
//
//  Called by the upper layer when it wants to query information about us.
//  We take in an ID, a buffer and length, and a context value, and return
//  whatever information we can.
//
//  Input:  ID          - Pointer to ID structure.
//          Buffer      - Pointer to buffer chain.
//          Size        - Pointer to size in bytes of buffer. On return, filled
//                          in with bytes read.
//          Context     - Pointer to context value.
//
//  Returns: TDI_STATUS of attempt to read information.
//
long
IPQueryInfo(TDIObjectID * ID, PNDIS_BUFFER Buffer, uint * Size, void *Context)
{
    uint BufferSize = *Size;
    uint BytesCopied = 0;
    uint Offset = 0;
    TDI_STATUS Status;
    ushort NTEContext;
    uchar InfoBuff[sizeof(IPRouteEntry)];
    IPAddrEntry *AddrEntry;
    NetTableEntry *CurrentNTE;
    uint Valid, DataLeft;
    CTELockHandle Handle;
    Interface *LowerIF;
    IPInterfaceInfo *IIIPtr;
    uint LLID = 0;
    uint Entity;
    uint Instance;
    IPAddr IFAddr;
    uint i;
    uint bucket;
    NetTableEntry *NetTableList;
    CTELockHandle TableHandle;
    IPInternalPerCpuStats SumCpuStats;

    BOOLEAN fStatus;

     DEBUGMSG(DBG_TRACE && DBG_QUERYINFO,
         (DTEXT("+IPQueryInfo(%x, %x, %x, %x)\n"), ID, Buffer, Size, Context));

    Entity = ID->toi_entity.tei_entity;
    Instance = ID->toi_entity.tei_instance;

    // See if it's something we might handle.

    if (Entity != CL_NL_ENTITY && Entity != ER_ENTITY) {
        // We need to pass this down to the lower layer. Loop through until
        // we find one that takes it. If noone does, error out.

        CTEGetLock(&RouteTableLock.Lock, &TableHandle);

        LowerIF = IFList;

        while (LowerIF) {
            if (LowerIF->if_refcount == 0) {
                // this interface is about to get deleted
                // fail the request
                // we can also skip this interface
                LowerIF = LowerIF->if_next;
                continue;
            }
            LOCKED_REFERENCE_IF(LowerIF);
            CTEFreeLock(&RouteTableLock.Lock, TableHandle);
            // we have freed the routetablelock here
            // but since we have a refcount on LowerIF, LowerIF can't go away
            Status = (*LowerIF->if_qinfo) (LowerIF->if_lcontext, ID, Buffer,
                                           Size, Context);
            if (Status != TDI_INVALID_REQUEST) {
                DerefIF(LowerIF);
                return Status;
            }
            CTEGetLock(&RouteTableLock.Lock, &TableHandle);
            LockedDerefIF(LowerIF);
            // LowerIF->if_next can't be freed at this point.
            LowerIF = LowerIF->if_next;
        }

        CTEFreeLock(&RouteTableLock.Lock, TableHandle);

        // If we get here, noone took it. Return an error.
        return TDI_INVALID_REQUEST;

    }
    if ((Entity == CL_NL_ENTITY && Instance != IPInstance) ||
        Instance != ICMPInstance)
        return TDI_INVALID_REQUEST;

    // The request is for us.
    *Size = 0;                    // Set to 0 in case of an error.

    // Make sure it's something we support.
    if (ID->toi_class == INFO_CLASS_GENERIC) {
        if (ID->toi_type == INFO_TYPE_PROVIDER && ID->toi_id == ENTITY_TYPE_ID) {
            // He's trying to see what type we are.
            if (BufferSize >= sizeof(uint)) {
                *(uint *) & InfoBuff[0] = (Entity == CL_NL_ENTITY) ? CL_NL_IP :
                    ER_ICMP;
                fStatus = CopyToNdisSafe(Buffer, NULL, InfoBuff, sizeof(uint), &Offset);

                if (fStatus == FALSE) {
                    return TDI_NO_RESOURCES;
                }
                *Size = sizeof(uint);
                return TDI_SUCCESS;
            } else
                return TDI_BUFFER_TOO_SMALL;
        }
        return TDI_INVALID_PARAMETER;
    } else if (ID->toi_class != INFO_CLASS_PROTOCOL ||
               ID->toi_type != INFO_TYPE_PROVIDER)
        return TDI_INVALID_PARAMETER;

    // If it's ICMP, just copy the statistics.
    if (Entity == ER_ENTITY) {

        // It is ICMP. Make sure the ID is valid.
        if (ID->toi_id != ICMP_MIB_STATS_ID)
            return TDI_INVALID_PARAMETER;

        // He wants the stats. Copy what we can.
        if (BufferSize < sizeof(ICMPSNMPInfo))
            return TDI_BUFFER_TOO_SMALL;

        fStatus = CopyToNdisSafe(Buffer, &Buffer, (uchar *) & ICMPInStats, sizeof(ICMPStats), &Offset);

        if (fStatus == TRUE) {
            fStatus = CopyToNdisSafe(Buffer, NULL, (uchar *) & ICMPOutStats, sizeof(ICMPStats),
                                     &Offset);

            if (fStatus == TRUE) {
                *Size = sizeof(ICMPSNMPInfo);
                return TDI_SUCCESS;
            }
        }
        return (TDI_NO_RESOURCES);
    }
    // It's not ICMP. We need to figure out what it is, and take the
    // appropriate action.

    switch (ID->toi_id) {

    case IP_MIB_STATS_ID:
        if (BufferSize < sizeof(IPSNMPInfo))
            return TDI_BUFFER_TOO_SMALL;
        IPSInfo.ipsi_numif = NumIF;
        IPSInfo.ipsi_numaddr = NumActiveNTE;
        IPSInfo.ipsi_defaultttl = DefaultTTL;
        IPSInfo.ipsi_forwarding = ForwardPackets ? IP_FORWARDING :
            IP_NOT_FORWARDING;

#if FFP_SUPPORT
        //
        // Tweak SNMP information to include information from FFP'ed packets
        //

        // Keep a copy of the prev stats for use
        RtlCopyMemory(&GlobalStatsInfoPrev, &GlobalStatsInfoCurr, sizeof(FFPDriverStats));

        // Get the stats by querying the driver
        IPStatsFromFFPCaches(&GlobalStatsInfoCurr);

        // These counts missed packets fast fwded from last time a query was made

        IPPerCpuStats[0].ics_inreceives +=
            GlobalStatsInfoCurr.PacketsForwarded - GlobalStatsInfoPrev.PacketsForwarded;

        IPSInfo.ipsi_forwdatagrams +=
            GlobalStatsInfoCurr.PacketsForwarded - GlobalStatsInfoPrev.PacketsForwarded;

        // These counts missed all packets dropped from last time a query was made

        IPPerCpuStats[0].ics_inreceives +=
            GlobalStatsInfoCurr.PacketsDiscarded - GlobalStatsInfoPrev.PacketsDiscarded;

        IPSInfo.ipsi_outdiscards +=
            GlobalStatsInfoCurr.PacketsDiscarded - GlobalStatsInfoPrev.PacketsDiscarded;
#endif // if FFP_SUPPORT

#if !MILLEN
        IPSGetTotalCounts(&SumCpuStats);
        IPSInfo.ipsi_inreceives = SumCpuStats.ics_inreceives;
        IPSInfo.ipsi_indelivers = SumCpuStats.ics_indelivers;
#endif


        fStatus = CopyToNdisSafe(Buffer, NULL, (uchar *) & IPSInfo, sizeof(IPSNMPInfo), &Offset);

        if (fStatus == TRUE) {
            BytesCopied = sizeof(IPSNMPInfo);
            Status = TDI_SUCCESS;
        } else {
            Status = TDI_NO_RESOURCES;
        }
        break;
    case IP_MIB_ADDRTABLE_ENTRY_ID:
        {

            PINFO_LIST PrimaryList, NonDynamicList, DynamicList, UniList;
            PINFO_LIST LastPrimaryEle, LastNonDynamicEle, LastDynamicEle, LastUniEle;
            PINFO_LIST SavedTempInfo = NULL;
            PINFO_LIST tempInfo;
            PINFO_LIST FinalList, LastFinalListEle;
            PINFO_LIST CurrentNTEInfo;

            // He wants to read the address table. Figure out where we're
            // starting from, and if it's valid begin copying from there.
            NTEContext = *(ushort *) Context;

            // Build 3 lists: Primary, nondynamic nonprimary and dynamic

            PrimaryList = NULL;
            NonDynamicList = NULL;
            DynamicList = NULL;
            UniList = NULL;

            LastPrimaryEle = NULL;
            LastNonDynamicEle = NULL;
            LastDynamicEle = NULL;
            LastUniEle = NULL;

            for (i = 0; i < NET_TABLE_SIZE; i++) {
                for (CurrentNTE = NewNetTableList[i];
                     CurrentNTE != NULL;
                     CurrentNTE = CurrentNTE->nte_next) {

                    if ((CurrentNTE->nte_flags & NTE_VALID) &&
                        CurrentNTE->nte_if->if_flags & IF_FLAGS_UNI) {
                        // allocate the block to store the info
                        tempInfo = CTEAllocMemN(sizeof(INFO_LIST), '1ICT');
                        if (!tempInfo) {
                            // free all the lists
                            FreeInfoList(PrimaryList);
                            FreeInfoList(NonDynamicList);
                            FreeInfoList(DynamicList);
                            FreeInfoList(UniList);
                            return TDI_NO_RESOURCES;
                        }
                        if (UniList == NULL) {
                            // this is the last element in this list
                            LastUniEle = tempInfo;
                        }
                        tempInfo->info_nte = CurrentNTE;
                        tempInfo->info_next = UniList;
                        UniList = tempInfo;

                    } else if (CurrentNTE->nte_flags & NTE_PRIMARY) {
                        // allocate the block to store the info
                        tempInfo = CTEAllocMemN(sizeof(INFO_LIST), '1ICT');
                        if (!tempInfo) {
                            // free all the lists
                            FreeInfoList(PrimaryList);
                            FreeInfoList(NonDynamicList);
                            FreeInfoList(DynamicList);
                            FreeInfoList(UniList);
                            return TDI_NO_RESOURCES;
                        }
                        if (PrimaryList == NULL) {
                            // this is the last element in this list
                            LastPrimaryEle = tempInfo;
                        }
                        tempInfo->info_nte = CurrentNTE;
                        tempInfo->info_next = PrimaryList;
                        PrimaryList = tempInfo;
                    } else if (CurrentNTE->nte_flags & NTE_DYNAMIC) {
                        // allocate the block to store the info
                        tempInfo = CTEAllocMemN(sizeof(INFO_LIST), '1ICT');
                        if (!tempInfo) {
                            // free all the lists
                            FreeInfoList(PrimaryList);
                            FreeInfoList(NonDynamicList);
                            FreeInfoList(DynamicList);
                            FreeInfoList(UniList);
                            return TDI_NO_RESOURCES;
                        }
                        if (DynamicList == NULL) {
                            // this is the last element in this list
                            LastDynamicEle = tempInfo;
                        }
                        tempInfo->info_nte = CurrentNTE;
                        tempInfo->info_next = DynamicList;
                        DynamicList = tempInfo;
                    } else {
                        INFO_LIST** nextInfo;
                        // Non primary non Dynamic list
                        // allocate the block to store the info
                        tempInfo = CTEAllocMemN(sizeof(INFO_LIST), '1ICT');
                        if (!tempInfo) {
                            // free all the lists
                            FreeInfoList(PrimaryList);
                            FreeInfoList(NonDynamicList);
                            FreeInfoList(DynamicList);
                            FreeInfoList(UniList);
                            return TDI_NO_RESOURCES;
                        }

                        // Even though we are reading from a hash-table,
                        // we need to preserve the ordering of entries
                        // as given on the entries' interfaces' 'if_ntelist'.
                        // Attempt to find the entry for this NTE's predecessor
                        // and, if found, place this entry before that.
                        // This builds the list in reverse order, and ensures
                        // that an entry whose predecessor is not on the list
                        // will appear last.

                        for (nextInfo = &NonDynamicList;
                             (*nextInfo) &&
                             (*nextInfo)->info_nte->nte_ifnext != CurrentNTE;
                             nextInfo = &(*nextInfo)->info_next) { }
                        tempInfo->info_nte = CurrentNTE;
                        tempInfo->info_next = *nextInfo;
                        *nextInfo = tempInfo;
                        if (!tempInfo->info_next)
                            LastNonDynamicEle = tempInfo;
                    }
                    if (NTEContext != 0) {
                        if (CurrentNTE->nte_context == NTEContext) {
                            SavedTempInfo = tempInfo;
                        }
                    }
                } // for (CurrentNTE ...
            } // for (i= ...

            // at this point we have 4 lists and we have to merge 4 lists
            // order should be Uni -> Dynamic -> NonDynamic -> Primary

            FinalList = NULL;
            LastFinalListEle = NULL;

            if (UniList) {
                if (FinalList == NULL) {
                    FinalList = UniList;
                    LastFinalListEle = LastUniEle;
                } else {
                    LastFinalListEle->info_next = UniList;
                    LastFinalListEle = LastUniEle;
                }
            }
            if (DynamicList) {
                if (FinalList == NULL) {
                    FinalList = DynamicList;
                    LastFinalListEle = LastDynamicEle;
                } else {
                    LastFinalListEle->info_next = DynamicList;
                    LastFinalListEle = LastDynamicEle;
                }
            }
            if (NonDynamicList) {
                if (FinalList == NULL) {
                    FinalList = NonDynamicList;
                    LastFinalListEle = LastNonDynamicEle;
                } else {
                    LastFinalListEle->info_next = NonDynamicList;
                    LastFinalListEle = LastNonDynamicEle;
                }
            }
            if (PrimaryList) {
                if (FinalList == NULL) {
                    FinalList = PrimaryList;
                    LastFinalListEle = LastPrimaryEle;
                } else {
                    LastFinalListEle->info_next = PrimaryList;
                    LastFinalListEle = LastPrimaryEle;
                }
            }

#if MILLEN

#if DBG
            if (DBG_INFO && DBG_VERBOSE && DBG_QUERYINFO) {
                DEBUGMSG(1,
                    (DTEXT("IP_MIB_ADDRTABLE_ENTRY_ID: List before reverse:\n")));

                CurrentNTEInfo = FinalList;
                while (CurrentNTEInfo) {
                    DEBUGMSG(1, (DTEXT("    InfoList: %x NTE\n"), CurrentNTEInfo, CurrentNTEInfo->info_nte));
                    CurrentNTEInfo = CurrentNTEInfo->info_next;
                }
            }
#endif

            // Now guess what Win9X requires us to...reverse the list. It
            // expects that the primary is at the start of the list.
            {
                PINFO_LIST pCurrInfo, pPrevInfo, pNextInfo;

                pCurrInfo = FinalList;
                pPrevInfo = NULL;

                // Exchange final pointers.
                FinalList = LastFinalListEle;
                LastFinalListEle = pCurrInfo;

                while (pCurrInfo) {
                    pNextInfo = pCurrInfo->info_next;
                    pCurrInfo->info_next = pPrevInfo;
                    pPrevInfo = pCurrInfo;
                    pCurrInfo = pNextInfo;
                }
            }

#if DBG
            if (DBG_INFO && DBG_VERBOSE && DBG_QUERYINFO) {
                DEBUGMSG(1,
                    (DTEXT("IP_MIB_ADDRTABLE_ENTRY_ID: List after reverse:\n")));

                CurrentNTEInfo = FinalList;
                while (CurrentNTEInfo) {
                    DEBUGMSG(1, (DTEXT("    InfoList: %x NTE\n"), CurrentNTEInfo, CurrentNTEInfo->info_nte));
                    CurrentNTEInfo = CurrentNTEInfo->info_next;
                }
            }
#endif
#endif // MILLEN

            // we have at least loopback NTE
            ASSERT(FinalList != NULL);

            // At this point we have the whole list and also if the user specified NTEContext
            // we have the pointer saved in SavedTempInfo

            if (SavedTempInfo) {
                CurrentNTEInfo = SavedTempInfo;
            } else {
                CurrentNTEInfo = FinalList;
            }

            AddrEntry = (IPAddrEntry *) InfoBuff;
            fStatus = TRUE;

            for (; CurrentNTEInfo != NULL; CurrentNTEInfo = CurrentNTEInfo->info_next) {

                // NetTableEntry *CurrentNTE = CurrentNTEInfo->info_nte;
                CurrentNTE = CurrentNTEInfo->info_nte;
                if (CurrentNTE->nte_flags & NTE_ACTIVE) {
                    if ((int)(BufferSize - BytesCopied) >= (int)sizeof(IPAddrEntry)) {
                    // We have room to copy it. Build the entry, and copy
                    // it.
                        if (CurrentNTE->nte_flags & NTE_VALID) {
                            AddrEntry->iae_addr = CurrentNTE->nte_addr;
                            AddrEntry->iae_mask = CurrentNTE->nte_mask;
                        } else {
                            AddrEntry->iae_addr = NULL_IP_ADDR;
                            AddrEntry->iae_mask = NULL_IP_ADDR;
                        }

                        if (!(CurrentNTE->nte_flags & NTE_IF_DELETING)) {
                            AddrEntry->iae_index = CurrentNTE->nte_if->if_index;
                            AddrEntry->iae_bcastaddr =
                                *(int *)&(CurrentNTE->nte_if->if_bcast) & 1;
                        } else {
                            AddrEntry->iae_index = INVALID_IF_INDEX;
                            AddrEntry->iae_bcastaddr = 0;
                        }
                        AddrEntry->iae_reasmsize = 0xffff;
                        AddrEntry->iae_context = CurrentNTE->nte_context;

                        // LSB will have primary bit set if this is PRIMARY NTE

                        ASSERT((NTE_PRIMARY >> 2) == MIB_IPADDR_PRIMARY);

                        AddrEntry->iae_pad = CurrentNTE->nte_flags >> 2;

                        fStatus = CopyToNdisSafe(Buffer, &Buffer, (uchar *) AddrEntry,
                                                 sizeof(IPAddrEntry), &Offset);

                        if (fStatus == FALSE) {
                            break;
                        }
                        BytesCopied += sizeof(IPAddrEntry);
                    } else
                        break;
                }
            }

            if (fStatus == FALSE) {
                Status = TDI_NO_RESOURCES;
            } else if (CurrentNTEInfo == NULL) {
                Status = TDI_SUCCESS;
            } else {
                Status = TDI_BUFFER_OVERFLOW;
                **(ushort **) & Context = CurrentNTE->nte_context;
            }

            // free the list
            FreeInfoList(FinalList);

            break;
        }
    case IP_MIB_RTTABLE_ENTRY_ID:
        // Make sure we have a valid context.
        CTEGetLock(&RouteTableLock.Lock, &Handle);
        DataLeft = RTValidateContext(Context, &Valid);

        // If the context is valid, we'll continue trying to read.
        if (!Valid) {
            CTEFreeLock(&RouteTableLock.Lock, Handle);
            return TDI_INVALID_PARAMETER;
        }
        fStatus = TRUE;

        while (DataLeft) {
            // The invariant here is that there is data in the table to
            // read. We may or may not have room for it. So DataLeft
            // is TRUE, and BufferSize - BytesCopied is the room left
            // in the buffer.
            if ((int)(BufferSize - BytesCopied) >= (int)sizeof(IPRouteEntry)) {
                DataLeft = RTReadNext(Context, InfoBuff);
                BytesCopied += sizeof(IPRouteEntry);
                fStatus = CopyToNdisSafe(Buffer, &Buffer, InfoBuff, sizeof(IPRouteEntry),
                                         &Offset);
                if (fStatus == FALSE) {
                    break;
                }
            } else
                break;

        }

        CTEFreeLock(&RouteTableLock.Lock, Handle);

        if (fStatus == FALSE) {
            Status = TDI_NO_RESOURCES;
        } else {
            Status = (!DataLeft ? TDI_SUCCESS : TDI_BUFFER_OVERFLOW);
        }
        break;
    case IP_MIB_SINGLE_RT_ENTRY_ID:
        {
            CTEGetLock(&RouteTableLock.Lock, &Handle);

            if ((int)(BufferSize >= (int)sizeof(IPRouteEntry))) {
                Status = RTRead(Context, InfoBuff);
                fStatus = CopyToNdisSafe(Buffer, &Buffer, InfoBuff, sizeof(IPRouteEntry),
                                         &Offset);

                if (fStatus == FALSE) {
                    Status = TDI_NO_RESOURCES;
                } else {
                    //Status = TDI_SUCCESS;
                    BytesCopied = sizeof(IPRouteEntry);
                }
            } else {
                Status = TDI_BUFFER_OVERFLOW;
            }

            CTEFreeLock(&RouteTableLock.Lock, Handle);
        }
        break;
    case IP_INTFC_INFO_ID:

        IFAddr = *(IPAddr *) Context;
        // Loop through the NTE table, looking for a match.

        NetTableList = NewNetTableList[NET_TABLE_HASH(IFAddr)];
        for (CurrentNTE = NetTableList; CurrentNTE != NULL; CurrentNTE = CurrentNTE->nte_next) {
            if ((CurrentNTE->nte_flags & NTE_VALID) &&
                IP_ADDR_EQUAL(CurrentNTE->nte_addr, IFAddr))
                break;
        }
        if (CurrentNTE == NULL) {
            Status = TDI_INVALID_PARAMETER;
            break;
        }
        if (BufferSize < offsetof(IPInterfaceInfo, iii_addr)) {
            Status = TDI_BUFFER_TOO_SMALL;
            break;
        }
        // We have the NTE. Get the interface, fill in a structure,
        // and we're done.
        LowerIF = CurrentNTE->nte_if;
        IIIPtr = (IPInterfaceInfo *) InfoBuff;

        IIIPtr->iii_flags = 0;

        if (LowerIF->if_flags & IF_FLAGS_P2P) {
            IIIPtr->iii_flags |= IP_INTFC_FLAG_P2P;
        }
        if (LowerIF->if_flags & IF_FLAGS_P2MP) {
            IIIPtr->iii_flags |= IP_INTFC_FLAG_P2MP;
        }
        if (LowerIF->if_flags & IF_FLAGS_UNI) {
            IIIPtr->iii_flags |= IP_INTFC_FLAG_UNIDIRECTIONAL;
        }

        IIIPtr->iii_mtu = LowerIF->if_mtu;
        IIIPtr->iii_speed = LowerIF->if_speed;
        IIIPtr->iii_addrlength = LowerIF->if_addrlen;
        BytesCopied = offsetof(IPInterfaceInfo, iii_addr);
        if (BufferSize >= (offsetof(IPInterfaceInfo, iii_addr) +
                           LowerIF->if_addrlen)) {
            Status = TDI_NO_RESOURCES;

            fStatus = CopyToNdisSafe(Buffer, &Buffer, InfoBuff,
                                     offsetof(IPInterfaceInfo, iii_addr), &Offset);

            if (fStatus == TRUE) {
                if (LowerIF->if_addr) {
                    fStatus = CopyToNdisSafe(Buffer, NULL,
                                             LowerIF->if_addr, LowerIF->if_addrlen, &Offset);

                    if (fStatus == TRUE) {
                        Status = TDI_SUCCESS;
                        BytesCopied += LowerIF->if_addrlen;
                    }
                } else {
                    Status = TDI_SUCCESS;
                }
            }
        } else {
            Status = TDI_BUFFER_TOO_SMALL;
        }
        break;

    case IP_GET_BEST_SOURCE: {
        IPAddr Dest = * (IPAddr *) Context;
        IPAddr Source;
        RouteCacheEntry *RCE;
        ushort MSS;
        uchar Type;
        IPOptInfo OptInfo;

        if (BufferSize < sizeof Source) {
            Status = TDI_BUFFER_TOO_SMALL;
            break;
        }

        IPInitOptions(&OptInfo);

        Source = OpenRCE(Dest, NULL_IP_ADDR, &RCE, &Type, &MSS, &OptInfo);
        if (!IP_ADDR_EQUAL(Source, NULL_IP_ADDR))
            CloseRCE(RCE);

        fStatus = CopyToNdisSafe(Buffer, &Buffer,
                                 (uchar *)&Source, sizeof Source, &Offset);
        if (fStatus == FALSE) {
            Status = TDI_NO_RESOURCES;
        } else {
            Status = TDI_SUCCESS;
            BytesCopied = sizeof Source;
        }
        break;
    }

    default:
        return TDI_INVALID_PARAMETER;
        break;
    }

    *Size = BytesCopied;
    return Status;
}

//*     IPSetNdisRequest - IP set ndis request handler.
//
//      Called by the upper layer when it wants to set the general packet filter for
//      the corr. arp interface
//
//      Input:          IPAddr          - Addr of addrobject to set on
//                      NDIS_OID        - Packet Filter
//                      On              - Set_if, clear_if or clear_card
//                      IfIndex         - IfIndex if IPAddr not given
//
//      Returns: Matched if index or 0 if failure
//
ulong
IPSetNdisRequest(IPAddr Addr, NDIS_OID OID, uint On, uint IfIndex)
{
    Interface       *IF = NULL;
    NetTableEntry   *NTE;
    int             Status;
    uint            i;
    CTELockHandle   Handle;
    uint            Index;

    // set the interface to promiscuous mcast mode
    // scan s.t. match numbered interface with Addr or unnumbered interface
    // with IfIndex
    // can optimize it by taking special case for unnumbered interface

    CTEGetLock(&RouteTableLock.Lock, &Handle);
    for (i = 0; i < NET_TABLE_SIZE; i++) {
        NetTableEntry *NetTableList = NewNetTableList[i];
        for (NTE = NetTableList; NTE != NULL; NTE = NTE->nte_next) {
            if (NTE != LoopNTE && (NTE->nte_flags & NTE_VALID) &&
                (IP_ADDR_EQUAL(NTE->nte_addr, Addr) ||
                 NTE->nte_if->if_index == IfIndex)) {
                // Found one. Save it and break out.
                IF = NTE->nte_if;
                break;
            }
        }
        if (IF) {
            Index = IF->if_index;
            break;
        }
    }

    if (IF) {
        if (!IF->if_setndisrequest) {
            CTEFreeLock(&RouteTableLock.Lock, Handle);
            return 0;
        }

        if (On != CLEAR_CARD) {    // just clear the option on the card
            IF->if_promiscuousmode = (uchar)On;
        }

        LOCKED_REFERENCE_IF(IF);
        CTEFreeLock(&RouteTableLock.Lock, Handle);

        Status = (*(IF->if_setndisrequest)) (IF->if_lcontext, OID, On);

        DerefIF(IF);
        if (Status != NDIS_STATUS_SUCCESS) {
            return 0;
        }
    } else {
        CTEFreeLock(&RouteTableLock.Lock, Handle);
        return 0;
    }
    return Index;
}

//*     IPAbsorbRtrAlert - IP absorb rtr alert packet handler.
//
//      Called by the upper layer when it wants to set the general packet filter for
//      the corr. arp interface
//
//      Input:          IPAddr          - Addr of addrobject to set on
//                      Protocol        - if 0 turn of the option
//                      IfIndex         - IfIndex if IPAddr not given
//
//      Returns: Matched if index or 0 if failure
//
ulong
IPAbsorbRtrAlert(IPAddr Addr, uchar Protocol, uint IfIndex)
{
    Interface       *IF = NULL;
    NetTableEntry   *NTE;
    int             Status;
    uint            i;
    CTELockHandle   Handle;
    uint            Index;

    // can optimize it by taking special case for unnumbered interface

    CTEGetLock(&RouteTableLock.Lock, &Handle);
    for (i = 0; i < NET_TABLE_SIZE; i++) {
        NetTableEntry *NetTableList = NewNetTableList[i];
        for (NTE = NetTableList; NTE != NULL; NTE = NTE->nte_next) {
            if (NTE != LoopNTE && (NTE->nte_flags & NTE_VALID) &&
                (IP_ADDR_EQUAL(NTE->nte_addr, Addr) ||
                 NTE->nte_if->if_index == IfIndex)) {
                // Found one. Save it and break out.
                IF = NTE->nte_if;
                break;
            }
        }
        if (IF) {
            Index = IF->if_index;
            break;
        }
    }

    if (IF) {
        // we are keeping this property per interface so if there are 2 NTEs
        // on that interface its
        // set/unset on the interface
        // will decide later whether want to keep it per NTE also.

        IF->if_absorbfwdpkts = Protocol;
        CTEFreeLock(&RouteTableLock.Lock, Handle);

        return Index;
    }

    CTEFreeLock(&RouteTableLock.Lock, Handle);
    return 0;
}

NTSTATUS
SetIFPromiscuous(ULONG Index, UCHAR Type, UCHAR Add)
{
    Interface *pIf;
    BOOLEAN bFound = FALSE;
    UINT On;

    CTELockHandle Handle;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    //
    // Walk the interface to find the one with the given index
    //

    for (pIf = IFList; pIf != NULL; pIf = pIf->if_next) {
        if ((pIf->if_refcount != 0) && (pIf->if_index == Index)) {
            bFound = TRUE;

            break;
        }
    }

    if (!bFound) {
        CTEFreeLock(&RouteTableLock.Lock, Handle);
        return STATUS_OBJECT_NAME_NOT_FOUND;
    } else {
        LOCKED_REFERENCE_IF(pIf);
        CTEFreeLock(&RouteTableLock.Lock, Handle);
    }

    if (pIf->if_setndisrequest == NULL) {
        DerefIF(pIf);
        return STATUS_NOT_SUPPORTED;
    }
    if (Add == 0) {
        On = 0;
    } else {
        if (Add == 1) {
            On = 1;
        } else {
            DerefIF(pIf);
            return STATUS_INVALID_PARAMETER;
        }
    }

    if (Type == PROMISCUOUS_MCAST) {
        NTSTATUS status;

        status = (*(pIf->if_setndisrequest)) (pIf->if_lcontext,
                                              NDIS_PACKET_TYPE_ALL_MULTICAST,
                                              On);
        DerefIF(pIf);
        return status;
    }
    if (Type == PROMISCUOUS_BCAST) {
        NTSTATUS status;

        status = (*(pIf->if_setndisrequest)) (pIf->if_lcontext,
                                              NDIS_PACKET_TYPE_PROMISCUOUS,
                                              On);
        DerefIF(pIf);
        return status;
    }
    DerefIF(pIf);
    return STATUS_INVALID_PARAMETER;
}

//*     IPSetInfo - IP set information handler.
//
//      Called by the upper layer when it wants to set an object, which could
//      be a route table entry, an ARP table entry, or something else.
//
//      Input:  ID                      - Pointer to ID structure.
//                      Buffer          - Pointer to buffer containing element to set..
//                      Size            - Pointer to size in bytes of buffer.
//
//      Returns: TDI_STATUS of attempt to read information.
//
long
IPSetInfo(TDIObjectID * ID, void *Buffer, uint Size)
{
    uint Entity;
    uint Instance;
    Interface *LowerIF;
    Interface *OutIF;
    uint MTU;
    IPRouteEntry *IRE;
    NetTableEntry *OutNTE, *LocalNTE;
    IP_STATUS Status;
    IPAddr FirstHop, Dest, NextHop;
    uint i;
    CTELockHandle TableHandle;
    uint Flags;
    uchar Dtype;

    DEBUGMSG(DBG_TRACE && DBG_SETINFO,
        (DTEXT("+IPSetInfo(%x, %x, %d)\n"), ID, Buffer, Size));

    Entity = ID->toi_entity.tei_entity;
    Instance = ID->toi_entity.tei_instance;

    // If it's not for us, pass it down.
    if (Entity != CL_NL_ENTITY) {
        // We need to pass this down to the lower layer. Loop through until
        // we find one that takes it. If noone does, error out.

        CTEGetLock(&RouteTableLock.Lock, &TableHandle);

        LowerIF = IFList;

        while (LowerIF) {
            if (LowerIF->if_refcount == 0) {
                // this interface is about to get deleted
                // fail the request
                break;
            }
            LOCKED_REFERENCE_IF(LowerIF);
            CTEFreeLock(&RouteTableLock.Lock, TableHandle);
            // we have freed the routetablelock here
            // but since we have a refcount on LowerIF, LowerIF can't go away
            Status = (*LowerIF->if_setinfo) (LowerIF->if_lcontext, ID, Buffer,
                                             Size);
            if (Status != TDI_INVALID_REQUEST) {
                DEBUGMSG(DBG_ERROR && DBG_SETINFO,
                    (DTEXT("IPSetInfo: if_setinfo failure %x\n"), Status));
                DerefIF(LowerIF);
                return Status;
            }
            CTEGetLock(&RouteTableLock.Lock, &TableHandle);
            LockedDerefIF(LowerIF);
            // LowerIF->if_next can't be freed at this point.
            LowerIF = LowerIF->if_next;
        }

        CTEFreeLock(&RouteTableLock.Lock, TableHandle);

        // If we get here, noone took it. Return an error.
        return TDI_INVALID_REQUEST;
    }
    if (Instance != IPInstance)
        return TDI_INVALID_REQUEST;

    // We're identified as the entity. Make sure the ID is correct.

    Flags = RT_EXCLUDE_LOCAL;

    if (ID->toi_id == IP_MIB_RTTABLE_ENTRY_ID_EX) {

        Flags |= RT_NO_NOTIFY;
        ID->toi_id = IP_MIB_RTTABLE_ENTRY_ID;
    }
    if (ID->toi_id == IP_MIB_RTTABLE_ENTRY_ID) {
        NetTableEntry *TempNTE;

        DEBUGMSG(DBG_INFO && DBG_SETINFO,
            (DTEXT("IPSetInfo: IP_MIB_RTTABLE_ENTRY_ID - set route table entry.\n")));

        // This is an attempt to set a route table entry. Make sure the
        // size if correct.
        if (Size < sizeof(IPRouteEntry)) {
            DEBUGMSG(DBG_ERROR,
                (DTEXT("IPSetInfo RTTABLE: Buffer too small %d (IPRouteEntry = %d)\n"),
                 Size, sizeof(IPRouteEntry)));
            return TDI_INVALID_PARAMETER;
        }

        IRE = (IPRouteEntry *) Buffer;

        OutNTE = NULL;
        LocalNTE = NULL;

        Dest = IRE->ire_dest;
        NextHop = IRE->ire_nexthop;

        // Make sure that the nexthop is sensible. We don't allow nexthops
        // to be broadcast or invalid or loopback addresses.
        if (IP_LOOPBACK(NextHop) || CLASSD_ADDR(NextHop) ||
            CLASSE_ADDR(NextHop)) {
            DEBUGMSG(DBG_ERROR,
                (DTEXT("IPSetInfo RTTABLE: Invalid next hop %x\n"), NextHop));
            return TDI_INVALID_PARAMETER;
        }

        // Also make sure that the destination we're routing to is sensible.
        // Don't allow routes to be added to E or loopback addresses

        if (IP_LOOPBACK(Dest) || CLASSE_ADDR(Dest))
            return TDI_INVALID_PARAMETER;

        if (IRE->ire_index == LoopIndex) {
            DEBUGMSG(DBG_ERROR,
                (DTEXT("IPSetInfo RTTABLE: index == LoopIndex!! Invalid!\n")));
            return TDI_INVALID_PARAMETER;
        }

        if (IRE->ire_index != INVALID_IF_INDEX) {

            // First thing to do is to find the outgoing NTE for specified
            // interface, and also make sure that it matches the destination
            // if the destination is one of my addresses.

            for (i = 0; i < NET_TABLE_SIZE; i++) {
                NetTableEntry *NetTableList = NewNetTableList[i];
                for (TempNTE = NetTableList; TempNTE != NULL;
                     TempNTE = TempNTE->nte_next) {
                    if ((OutNTE == NULL) && (TempNTE->nte_flags & NTE_VALID) && (IRE->ire_index == TempNTE->nte_if->if_index))
                        OutNTE = TempNTE;
                    if (!IP_ADDR_EQUAL(NextHop, NULL_IP_ADDR) &&
                        IP_ADDR_EQUAL(NextHop, TempNTE->nte_addr) &&
                        (TempNTE->nte_flags & NTE_VALID))
                        LocalNTE = TempNTE;

                    // Don't let a route be set through a broadcast address.
                    if (IsBCastOnNTE(NextHop, TempNTE) != DEST_LOCAL) {
                        DEBUGMSG(DBG_ERROR,
                            (DTEXT("IPSetInfo RTTABLE: Bcast address. Invalid NextHop!\n")));
                        return TDI_INVALID_PARAMETER;
                    }

                    // Don't let a route to a broadcast address be added or deleted.
                    Dtype = IsBCastOnNTE(Dest, TempNTE);
                    if ((Dtype != DEST_LOCAL) && (Dtype != DEST_MCAST)) {
                        DEBUGMSG(DBG_ERROR,
                            (DTEXT("IPSetInfo RTTABLE: Bcast address. Invalid Dest!\n")));
                        return TDI_INVALID_PARAMETER;
                    }
                }
            }

            // At this point OutNTE points to the outgoing NTE, and LocalNTE
            // points to the NTE for the local address, if this is a direct route.
            // Make sure they point to the same interface, and that the type is
            // reasonable.
            if (OutNTE == NULL)
                return TDI_INVALID_PARAMETER;

            if (LocalNTE != NULL) {
                // He's routing straight out a local interface. The interface for
                // the local address must match the interface passed in, and the
                // type must be DIRECT (if we're adding) or INVALID (if we're
                // deleting).
                // LocalNTE is valid at this point
                if (LocalNTE->nte_if->if_index != IRE->ire_index)
                    return TDI_INVALID_PARAMETER;

                if (IRE->ire_type != IRE_TYPE_DIRECT &&
                    IRE->ire_type != IRE_TYPE_INVALID)
                    return TDI_INVALID_PARAMETER;

                OutNTE = LocalNTE;
            }
            // Figure out what the first hop should be. If he's routing straight
            // through a local interface, or the next hop is equal to the
            // destination, then the first hop is IPADDR_LOCAL. Otherwise it's the
            // address of the gateway.
            if ((LocalNTE != NULL) || IP_ADDR_EQUAL(NextHop, NULL_IP_ADDR))
                FirstHop = IPADDR_LOCAL;
            else if (IP_ADDR_EQUAL(Dest, NextHop))
                FirstHop = IPADDR_LOCAL;
            else
                FirstHop = NextHop;

            MTU = OutNTE->nte_mss;

            // Take RouteTableLock
            CTEGetLock(&RouteTableLock.Lock, &TableHandle);
            if ((OutNTE->nte_flags & NTE_VALID) && OutNTE->nte_if->if_refcount) {
                // ref the IF
                OutIF = OutNTE->nte_if;

                if (IP_ADDR_EQUAL(NextHop, NULL_IP_ADDR)) {

                    if (!(OutIF->if_flags & IF_FLAGS_P2P)) {

                        CTEFreeLock(&RouteTableLock.Lock, TableHandle);

                        return TDI_INVALID_PARAMETER;
                    }
                }

                LOCKED_REFERENCE_IF(OutIF);
                CTEFreeLock(&RouteTableLock.Lock, TableHandle);
            } else {
                CTEFreeLock(&RouteTableLock.Lock, TableHandle);
                return TDI_INVALID_PARAMETER;
            }

            OutIF = OutNTE->nte_if;

        } else {
            OutIF = (Interface *) & DummyInterface;
            MTU = DummyInterface.ri_if.if_mtu - sizeof(IPHeader);
            if (IP_ADDR_EQUAL(Dest, NextHop))
                FirstHop = IPADDR_LOCAL;
            else
                FirstHop = NextHop;
        }

        // We've done the validation. See if he's adding or deleting a route.
        if (IRE->ire_type != IRE_TYPE_INVALID) {
            // He's adding a route.
            uint AType = ATYPE_OVERRIDE;

            DEBUGMSG(DBG_INFO && DBG_SETINFO,
                (DTEXT("IPSetInfo RTTABLE: Calling AddRoute addr %x mask %x\n"),
                 Dest, IRE->ire_mask));

            Status = AddRoute(Dest, IRE->ire_mask, FirstHop, OutIF,
                              MTU, IRE->ire_metric1, IRE->ire_proto,
                              AType, IRE->ire_context, Flags);
            DEBUGMSG(Status != IP_SUCCESS && DBG_ERROR && DBG_SETINFO,
                (DTEXT("IPSetInfo: AddRoute failure %x\n"), Status));

        } else {
            DEBUGMSG(DBG_INFO && DBG_SETINFO,
                (DTEXT("IPSetInfo RTTABLE: Calling DeleteRoute addr %x mask %x\n"),
                 Dest, IRE->ire_mask));

            // He's deleting a route.
            Status = DeleteRoute(Dest, IRE->ire_mask, FirstHop, OutIF, Flags);

            DEBUGMSG(Status != IP_SUCCESS && DBG_ERROR && DBG_SETINFO,
                (DTEXT("IPSetInfo: DeleteRoute failure %x\n"), Status));

        }

        if (IRE->ire_index != INVALID_IF_INDEX) {
            ASSERT(OutIF != (Interface *) & DummyInterface);
            DerefIF(OutIF);
        }
        if (Status == IP_SUCCESS)
            return TDI_SUCCESS;
        else if (Status == IP_NO_RESOURCES)
            return TDI_NO_RESOURCES;
        else
            return TDI_INVALID_PARAMETER;

    } else {
        if (ID->toi_id == IP_MIB_STATS_ID) {
            IPSNMPInfo *Info = (IPSNMPInfo *) Buffer;

            // Setting information about TTL and/or routing.
            if (Info->ipsi_defaultttl > 255 || (!RouterConfigured &&
                                                Info->ipsi_forwarding == IP_FORWARDING)) {
                return TDI_INVALID_PARAMETER;
            }
            DefaultTTL = Info->ipsi_defaultttl;
            ForwardPackets = Info->ipsi_forwarding == IP_FORWARDING ? TRUE :
                FALSE;

            return TDI_SUCCESS;
        }
        return TDI_INVALID_PARAMETER;
    }

}

#pragma BEGIN_INIT

//*     IPGetEList - Get the entity list.
//
//      Called at init time to get an entity list. We fill our stuff in, and
//      then call the interfaces below us to allow them to do the same.
//
//      Input:  EntityList          - Pointer to entity list to be filled in.
//              Count               - Pointer to number of entries in the list.
//
//      Returns Status of attempt to get the info.
//
long
IPGetEList(TDIEntityID * EList, uint * Count)
{
    uint ECount;
    uint MyIPBase;
    uint MyERBase;
    int Status;
    uint i;
    Interface *LowerIF;
    TDIEntityID *EntityList;
    TDIEntityID *IPEntity, *EREntity;
    CTELockHandle TableHandle;

    EntityList = EList;

    // Walk down the list, looking for existing CL_NL or ER entities, and
    // adjust our base instance accordingly.
    // if we are already on the list then do nothing.
    // if we are going away, mark our entry invalid.

    MyIPBase = 0;
    MyERBase = 0;
    IPEntity = NULL;
    EREntity = NULL;
    for (i = 0; i < *Count; i++, EntityList++) {
        if (EntityList->tei_entity == CL_NL_ENTITY &&
            EntityList->tei_entity != INVALID_ENTITY_INSTANCE) {
            // if we are already on the list remember our entity item
            // o/w find an instance # for us.
            if (EntityList->tei_instance == IPInstance) {
                IPEntity = EntityList;
            } else {
                MyIPBase = MAX(MyIPBase, EntityList->tei_instance + 1);
            }
        } else {
            if (EntityList->tei_entity == ER_ENTITY &&
                EntityList->tei_entity != INVALID_ENTITY_INSTANCE)
                // if we are already on the list remember our entity item
                // o/w find an instance # for us.
                if (EntityList->tei_instance == ICMPInstance) {
                    EREntity = EntityList;
                } else {
                    MyERBase = MAX(MyERBase, EntityList->tei_instance + 1);
                }
        }
        if (IPEntity && EREntity) {
            break;
        }
    }

    if (!IPEntity) {
        // we are not on the list.
        // insert ourself iff we are not going away.
        // make sure we have the room for it.
        if (*Count >= MAX_TDI_ENTITIES) {
            return TDI_REQ_ABORTED;
        }
        IPInstance = MyIPBase;
        IPEntity = &EList[*Count];
        IPEntity->tei_entity = CL_NL_ENTITY;
        IPEntity->tei_instance = MyIPBase;
        (*Count)++;
    }
    if (!EREntity) {
        // we are not on the list.
        // insert ourself iff we are not going away.
        // make sure we have the room for it.
        if (*Count >= MAX_TDI_ENTITIES) {
            return TDI_REQ_ABORTED;
        }
        ICMPInstance = MyERBase;
        EREntity = &EList[*Count];
        EREntity->tei_entity = ER_ENTITY;
        EREntity->tei_instance = MyERBase;
        (*Count)++;
    }

    // Loop through the interfaces, querying each of them.

    CTEGetLock(&RouteTableLock.Lock, &TableHandle);

    LowerIF = IFList;

    while (LowerIF) {
        if (LowerIF->if_refcount == 0) {
            LowerIF = LowerIF->if_next;
            continue;
        }
        LOCKED_REFERENCE_IF(LowerIF);
        CTEFreeLock(&RouteTableLock.Lock, TableHandle);

        Status = (*LowerIF->if_getelist) (LowerIF->if_lcontext, EList, Count);
        if (!Status) {
            DerefIF(LowerIF);
            return TDI_BUFFER_TOO_SMALL;
        }
        CTEGetLock(&RouteTableLock.Lock, &TableHandle);
        LockedDerefIF(LowerIF);
        // LowerIF->if_next can't be freed at this point.
        LowerIF = LowerIF->if_next;
    }

    // Finally, cache the entries that are now on the list.
    // Note that our cache is covered by 'RouteTableLock'.
    if (!IPEntityList) {
        IPEntityList = CTEAllocMem(sizeof(TDIEntityID) * MAX_TDI_ENTITIES);
    }
    if (IPEntityList) {
        RtlZeroMemory(IPEntityList, sizeof(IPEntityList));
        if (IPEntityCount = *Count) {
            RtlCopyMemory(IPEntityList, EList, IPEntityCount * sizeof(*EList));
        }
    }

    CTEFreeLock(&RouteTableLock.Lock, TableHandle);

    return TDI_SUCCESS;

}

#pragma END_INIT

//* IPWakeupPattern - add or remove IP wakeup pattern.
//
//  Entry:  InterfaceConext   - ip interface context for which the pattern is to be added/removed
//          PtrnDesc        -   Pattern Descriptor
//          AddPattern      -   TRUE - add, FALSE - remove
//  Returns: Nothing.
//

NTSTATUS
IPWakeupPattern(uint InterfaceContext, PNET_PM_WAKEUP_PATTERN_DESC PtrnDesc,
                BOOLEAN AddPattern)
{
    Interface *IF;
    CTELockHandle Handle;
    NTSTATUS status;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    for (IF = IFList; IF != NULL; IF = IF->if_next) {
        if ((IF->if_refcount != 0) && (IF->if_index == InterfaceContext)) {
            break;
        }
    }

    if (IF == (Interface *) NULL) {
        CTEFreeLock(&RouteTableLock.Lock, Handle);
        return STATUS_INVALID_HANDLE;
    } else {
        LOCKED_REFERENCE_IF(IF);
        CTEFreeLock(&RouteTableLock.Lock, Handle);
    }

    if (NULL == IF->if_dowakeupptrn) {
        DerefIF(IF);
        return STATUS_NOT_SUPPORTED;
    }
    status = (*(IF->if_dowakeupptrn)) (IF->if_lcontext, PtrnDesc, ARP_ETYPE_IP, AddPattern);

    DerefIF(IF);

    return status;
}

NTSTATUS
IPGetCapability(uint InterfaceContext, PULONG pBuf, uint cap)
{
    Interface *IF;
    CTELockHandle Handle;
    NTSTATUS status;

    status = STATUS_SUCCESS;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    for (IF = IFList; IF != NULL; IF = IF->if_next) {
        if ((IF->if_refcount != 0) && (IF->if_index == InterfaceContext)) {
            break;
        }
    }

    if (IF != (Interface *) NULL) {
        if (cap == IF_WOL_CAP) {
            *pBuf = IF->if_pnpcap;
        } else if (cap == IF_OFFLOAD_CAP) {
            *pBuf = IF->if_OffloadFlags;
        } else {
            status = STATUS_INVALID_PARAMETER;
        }
    } else {
        status = STATUS_INVALID_PARAMETER;
    }

    CTEFreeLock(&RouteTableLock.Lock, Handle);

    return status;
}

//* IPGetInterfaceFriendlyName - get human-readable name for an interface.
//
// Called to retrieve the unique descriptive name for an interface. This name
// is provided by the interface's ARP module, and is used by IP to identify
// the interface in event logs.
//
// Input:   InterfaceContext    - IP interface context identifying the interface
//                                friendly name is required
//          Name                - on output, contains the friendly-name.
//          Size                - contains the length of the buffer at 'Name'.
//
// Returns: TDI_STATUS of query-attempt.

long
IPGetInterfaceFriendlyName(uint InterfaceContext, PWCHAR Name, uint Size)
{
    PNDIS_BUFFER Buffer;
    uint BufferSize;
    CTELockHandle Handle;
    uint i;
    TDIObjectID ID;
    Interface *IF;
    TDI_STATUS Status;

    // Attempt to retrieve the interface whose name is required,
    // and if successful issue a query-info request to get its friendly name.

    CTEGetLock(&RouteTableLock.Lock, &Handle);
    for (IF = IFList; IF != NULL; IF = IF->if_next) {
        if (IF->if_refcount != 0 && IF->if_index == InterfaceContext) {
            break;
        }
    }

    if (IF != (Interface *) NULL) {

        // Construct a TDI query to obtain the interface's friendly name.
        // Unfortunately, this operation is complicated by the fact that
        // we don't have the exact entity-instance for the lower-layer entity.
        // Therefore, we go through our whole cache of entity-instances,
        // until we find one which is acceptable to the lower-layer entity.

        ID.toi_class = INFO_CLASS_PROTOCOL;
        ID.toi_type = INFO_TYPE_PROVIDER;
        ID.toi_id = IF_FRIENDLY_NAME_ID;
        ID.toi_entity.tei_entity = IF_ENTITY;

        NdisAllocateBuffer(&Status, &Buffer, BufferPool, Name, Size);
        if (Status == NDIS_STATUS_SUCCESS) {
            LOCKED_REFERENCE_IF(IF);
            for (i = 0; i < IPEntityCount; i++) {
                if (IPEntityList[i].tei_entity != IF_ENTITY)
                    continue;
                ID.toi_entity.tei_instance = IPEntityList[i].tei_instance;
                CTEFreeLock(&RouteTableLock.Lock, Handle);
                BufferSize = Size;
                Status = (*IF->if_qinfo)(IF->if_lcontext, &ID, Buffer,
                                         &BufferSize, NULL);
                CTEGetLock(&RouteTableLock.Lock, &Handle);
                if (Status != TDI_INVALID_REQUEST)
                    break;

                // We just released the route-table lock in order to query
                // the lower-layer entity, and that means that the entity-list
                // may have changed. Handle that case by just making sure
                // that the entity we just queried is in the same location;
                // if not, we'll need to find it and continue from there.
                // If it's gone, give up.

                if (i < IPEntityCount &&
                    IPEntityList[i].tei_instance !=
                    ID.toi_entity.tei_instance) {
                    for (i = 0; i < IPEntityCount; i++) {
                        if (IPEntityList[i].tei_instance ==
                            ID.toi_entity.tei_instance) {
                            break;
                        }
                    }
                }
            }
            LockedDerefIF(IF);
            NdisFreeBuffer(Buffer);
        } else
            Status = TDI_NO_RESOURCES;
    } else
        Status = TDI_INVALID_PARAMETER;

    CTEFreeLock(&RouteTableLock.Lock, Handle);
    return Status;
}

#if MILLEN
//
// Support for VIP!!! For legacy support in VIP, we need to be able to convert
// the index into the if_pnpcontext. This will be exported from tcpip.sys
// to be accessed directly by VIP.
//

//* IPGetPNPCtxt
//
//  Entry:  index   - ip interface index
//          PNPCtxt - pointer to  pnpcontext
//

NTSTATUS
IPGetPNPCtxt(uint index, uint *PNPCtxt)
{
    Interface               *IF;

    for (IF = IFList; IF != NULL; IF = IF->if_next) {
        if (IF->if_index == index) {
            break;
        }
    }


    if ( IF == (Interface *)NULL ) {
        return STATUS_UNSUCCESSFUL;
    }

    *PNPCtxt  = (uint)IF->if_pnpcontext;

    return STATUS_SUCCESS;
}

//* IPGetPNPCap - add or remove IP wakeup pattern.
//
//  Entry:  InterfaceConext   - ip interface context for which the wol capability needs to be returned
//          flags             - pointer to capability flags
//

NTSTATUS
IPGetPNPCap(uchar *Context, uint *flags)
{
    Interface               *IF;

    for (IF = IFList; IF != NULL; IF = IF->if_next) {
        if (IF->if_pnpcontext == Context) {
            break;
        }
    }


    if ( IF == (Interface *)NULL ) {
        return STATUS_UNSUCCESSFUL;
    }

    *flags  = IF->if_pnpcap;

    return STATUS_SUCCESS;
}

#endif // MILLEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipv4\ipmlock.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tcpip\ip\ipmlock.h

Abstract:

    Reader Writer lock primitives for the IP Multicasting

Author:

    Amritansh Raghav

Revision History:

    AmritanR    Created

Notes:

--*/

//
// Need to include "debug.h" before this file is included because
// RT_LOCK is defined there
//

//
// A reader writer lock for kernel mode.
//

typedef struct _RW_LOCK
{
    RT_LOCK rlReadLock;
    RT_LOCK rlWriteLock;
    LONG    lReaderCount;
}RW_LOCK, *PRW_LOCK;

//
// VOID
// InitRwLock(
//  PRW_LOCK    pLock
//  )
//
//  Initializes the spin locks and the reader count
//


#define InitRwLock(l)                                           \
    RtInitializeSpinLock(&((l)->rlReadLock));                   \
    RtInitializeSpinLock(&((l)->rlWriteLock));                  \
    (l)->lReaderCount = 0
        
//
// VOID
// EnterReader(
//  PRW_LOCK    pLock,
//  PKIRQL      pCurrIrql 
//  )
//
// Acquires the Reader Spinlock (now thread is at DPC). 
// InterlockedIncrements the reader count (interlocked because the reader 
// lock is not taken when the count is decremented in ExitReader())
// If the thread is the first reader, also acquires the Writer Spinlock (at
// DPC to be more efficient) to block writers
// Releases the Reader Spinlock from DPC, so that it remains at DPC
// for the duration of the lock being held 
//
// If a writer is in the code, the first reader will wait on the Writer
// Spinlock and all subsequent readers will wait on the Reader Spinlock
// If a reader is in the code and is executing the EnterReader, then a new
// reader will wait for sometime on the Reader Spinlock, and then proceed
// on to the code (at DPC)
//



#define EnterReader(l, q)                                       \
    RtAcquireSpinLock(&((l)->rlReadLock), (q));                 \
    if(InterlockedIncrement(&((l)->lReaderCount)) == 1)         \
        RtAcquireSpinLockAtDpcLevel(&((l)->rlWriteLock));       \
    RtReleaseSpinLockFromDpcLevel(&((l)->rlReadLock))

#define EnterReaderAtDpcLevel(l)                                \
    RtAcquireSpinLockAtDpcLevel(&((l)->rlReadLock));            \
    if(InterlockedIncrement(&((l)->lReaderCount)) == 1)         \
        RtAcquireSpinLockAtDpcLevel(&((l)->rlWriteLock));       \
    RtReleaseSpinLockFromDpcLevel(&((l)->rlReadLock))

//
// VOID
// ExitReader(
//  PRW_LOCK    pLock,
//  KIRQL       kiOldIrql
//  )
//
// InterlockedDec the reader count.
// If this is the last reader, then release the Writer Spinlock to let
// other writers in
// Otherwise, just lower the irql to what was before the lock was
// acquired.  Either way, the irql is down to original irql
//

#define ExitReader(l, q)                                        \
    if(InterlockedDecrement(&((l)->lReaderCount)) == 0)         \
        RtReleaseSpinLock(&((l)->rlWriteLock), q);              \
    else                                                        \
        KeLowerIrql(q)

#define ExitReaderFromDpcLevel(l)                               \
    if(InterlockedDecrement(&((l)->lReaderCount)) == 0)         \
        RtReleaseSpinLockFromDpcLevel(&((l)->rlWriteLock))

//
// EnterWriter(
//  PRW_LOCK    pLock,
//  PKIRQL      pCurrIrql
//  )
//
// Acquire the reader and then the writer spin lock
// If there  are readers in the code, the first writer will wait
// on the Writer Spinlock.  All other writers will wait (with readers)
// on the Reader Spinlock
// If there is a writer in the code then a new writer will wait on 
// the Reader Spinlock

#define EnterWriter(l, q)                                       \
    RtAcquireSpinLock(&((l)->rlReadLock), (q));                 \
    RtAcquireSpinLockAtDpcLevel(&((l)->rlWriteLock))

#define EnterWriterAtDpcLevel(l)                                \
    RtAcquireSpinLockAtDpcLevel(&((l)->rlReadLock));            \
    RtAcquireSpinLockAtDpcLevel(&((l)->rlWriteLock))


//
// ExitWriter(
//  PRW_LOCK    pLock,
//  KIRQL       kiOldIrql
//  )
//
// Release both the locks
//

#define ExitWriter(l, q)                                        \
    RtReleaseSpinLockFromDpcLevel(&((l)->rlWriteLock));         \
    RtReleaseSpinLock(&((l)->rlReadLock), q)


#define ExitWriterFromDpcLevel(l)                               \
    RtReleaseSpinLockFromDpcLevel(&((l)->rlWriteLock));         \
    RtReleaseSpinLockFromDpcLevel(&((l)->rlReadLock))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tcpip\driver\ipv4\init.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

  init.c - IP Initialization routines

Abstract:

  All C init routines are located in this file. We get config. information, allocate structures,
  and generally get things going.

Author:


[Environment:]

    kernel mode only

[Notes:]

    optional-notes

Revision History:


--*/

#include "precomp.h"
#include "arp.h"
#include "info.h"
#include "iproute.h"
#include "iprtdef.h"
#include "ipxmit.h"
#include "igmp.h"
#include "icmp.h"
#include "mdlpool.h"
#include "tcpipbuf.h"
#include "bitmap.h"

extern ulong TRFunctionalMcast;

#define NUM_IP_NONHDR_BUFFERS   500
#define DEFAULT_RA_TIMEOUT      60
#define DEFAULT_ICMP_BUFFERS    5
#define MAX_NTE_CONTEXT         0xffff
#define INVALID_NTE_CONTEXT     MAX_NTE_CONTEXT
#define WLAN_DEADMAN_TIMEOUT    120000

#define BITS_PER_ULONG  32
RTL_BITMAP g_NTECtxtMap;

ULONG g_NTECtxtMapBuffer[(MAX_NTE_CONTEXT / BITS_PER_ULONG) + 1];

NDIS_HANDLE TDPacketPool = NULL;
NDIS_HANDLE TDBufferPool = NULL;

extern Interface LoopInterface;


// Format of ifindex
//    8b    8b       16bits
// |---------------------------|
// |Unused|Unique|   index     |
// |      |  ID  |             |
// |---------------------------|

#define IF_INDEX_MASK      0xffff0000
#define IF_INDEX_SHIFT     16
uint UniqueIfNumber = 0;

LONG MultihopSets = 0;
uint TotalFreeInterfaces = 0;
uint MaxFreeInterfaces = 100;
Interface *FrontFreeList = NULL;
Interface *RearFreeList = NULL;

#if DBG_MAP_BUFFER
// For testing failure conditions related to TcpipBufferVirtualAddress and
// TcpipQueryBuffer.
ULONG g_cFailSafeMDLQueries = 0;
ULONG g_fPerformMDLFailure = FALSE;
#endif // DBG_MAP_BUFFER

extern IPConfigInfo *IPGetConfig(void);
extern void IPFreeConfig(IPConfigInfo *);
extern int IsIPBCast(IPAddr, uchar);
extern BOOLEAN IsRunningOnPersonal(void);

extern uint OpenIFConfig(PNDIS_STRING ConfigName, NDIS_HANDLE * Handle);
extern void CloseIFConfig(NDIS_HANDLE Handle);

extern NDIS_STATUS __stdcall IPPnPEvent(void *Context, PNET_PNP_EVENT NetPnPEvent);
extern NTSTATUS IPAddNTEContextList(HANDLE KeyHandle, ushort contextvalue, uint isPrimary);
extern NTSTATUS IPDelNTEContextList(HANDLE KeyHandle, ushort contextValue);
uint InitTimeInterfaces = 1;
uint InitTimeInterfacesDone = FALSE;
extern HANDLE IPProviderHandle;
void IPDelNTE(NetTableEntry * NTE, CTELockHandle * RouteTableHandle);

extern void ICMPInit(uint);
extern uint IGMPInit(void);
extern void ICMPTimer(NetTableEntry *);
extern IP_STATUS SendICMPErr(IPAddr, IPHeader UNALIGNED *, uchar, uchar, ulong);
extern void TDUserRcv(void *, PNDIS_PACKET, NDIS_STATUS, uint);
extern void FreeRH(ReassemblyHeader *);
extern BOOLEAN AllocIPPacketList(void);
extern UINT PacketPoolSizeMax;

extern ulong GetGMTDelta(void);
extern ulong GetTime(void);
extern ulong GetUnique32BitValue(void);

extern NTSTATUS IPStatusToNTStatus(IP_STATUS ipStatus);
extern void IPCancelPackets(void *IPIF, void * Ctxt);
extern void CheckSetAddrRequestOnInterface( Interface *IF );

extern ushort GetIPID(void);

extern uint LoopIndex;
extern RouteInterface DummyInterface;

Interface *DampingIFList = NULL;

extern void DampCheck(void);

extern uint GetAutoMetric(uint);
uint IPSecStatus = 0;

extern uint BCastMinMTU;

ulong ReEnumerateCount = 0;

void
 ReplumbAddrComplete(
                     void *Context,
                     IP_STATUS Status
                     );

void
 TempDhcpAddrDone(
                  void *Context,
                  IP_STATUS Status
                  );

extern
RouteTableEntry *
 LookupRTE(IPAddr Address, IPAddr Src, uint MaxPri, BOOLEAN UnicastOpt);

extern void NotifyAddrChange(IPAddr Addr, IPMask Mask, void *Context,
                             ushort IPContext, PVOID * Handle, PNDIS_STRING ConfigName, PNDIS_STRING IFName, uint Added);

#if MILLEN
extern void NotifyInterfaceChange(ushort IPContext, uint Added);
#endif // MILLEN

void DecrInitTimeInterfaces(Interface * IF);

extern uint IPMapDeviceNameToIfOrder(PWSTR DeviceName);
extern void IPNotifyClientsIPEvent(Interface *interface, IP_STATUS ipStatus);
uint IPSetNTEAddr(ushort Context, IPAddr Addr, IPMask Mask);
uint IPSetNTEAddrEx(ushort Context, IPAddr Addr, IPMask Mask, SetAddrControl * ControlBlock, SetAddrRtn Rtn, ushort Type);

extern NDIS_HANDLE BufferPool;
EXTERNAL_LOCK(HeaderLock)
extern HANDLE IpHeaderPool;

extern NetTableEntry *LoopNTE;

extern uchar RouterConfigured;

extern BOOLEAN
GetTempDHCPAddr(
                NDIS_HANDLE Handle,
                IPAddr * Tempdhcpaddr,
                IPAddr * TempMask,
                IPAddr * TempGWAddr,
                PNDIS_STRING ConfigName
                );

NetTableEntry **NewNetTableList;// hash table for NTEs
uint NET_TABLE_SIZE;
NetTableEntry *NetTableList;    // List of NTEs.
int NumNTE;                     // Number of NTEs.
int NumActiveNTE;
uchar RATimeout;                // Number of seconds to time out a reassembly.
uint NextNTEContext = 1;        // Next NTE context to use.

//
// A global address used for unnumbered interfaces. It is protected
// by the same lock that protects NTEs. Currently that is the RouteTableLock
//

IPAddr g_ValidAddr = 0;

ProtInfo IPProtInfo[MAX_IP_PROT];    // Protocol information table.
ProtInfo *LastPI;                // Last protinfo structure looked at.
int NextPI;                        // Next PI field to be used.
ProtInfo *RawPI = NULL;            // Raw IP protinfo

ulong TimeStamp;
ulong TSFlag;

uint DefaultTTL;
uint DefaultTOS;
uchar TrRii = TR_RII_ALL;

// Interface       *IFTable[MAX_IP_NETS];
Interface *IFList;                // List of interfaces active.
ulong NumIF;

RTL_BITMAP g_rbIfMap;
ULONG g_rgulMapBuffer[(MAX_TDI_ENTITIES / BITS_PER_ULONG) + 1];

IPInternalPerCpuStats IPPerCpuStats[IPS_MAX_PROCESSOR_BUCKETS];
CACHE_ALIGN IPSNMPInfo IPSInfo;

uint DHCPActivityCount = 0;
uint IGMPLevel;

LIST_ENTRY AddChangeNotifyQueue;

#if MILLEN
LIST_ENTRY IfChangeNotifyQueue;
DEFINE_LOCK_STRUCTURE(IfChangeLock)
#endif // MILLEN

// Firewall-queue management structures
union FirewallQCounter {
    struct {
        uint            fqc_index : 1;
        uint            fqc_entrycount : 31;
    };
    uint                fqc_value;
};
typedef union FirewallQCounter FirewallQCounter;

struct FirewallQBlock {
    Queue               fqb_queue;
    FIREWALL_HOOK       *fqb_array;
    union {
        volatile uint   fqb_exitcount : 31;
        uint            fqb_value;
    };
};
typedef struct FirewallQBlock FirewallQBlock;

FirewallQCounter FQCounter;
FirewallQBlock FQBlock[2];
#if DBG
uint FQSpinCount = 0;
#endif

// IPSec routines
IPSecHandlerRtn IPSecHandlerPtr;
IPSecQStatusRtn IPSecQueryStatusPtr;
IPSecSendCompleteRtn IPSecSendCmpltPtr;
IPSecNdisStatusRtn IPSecNdisStatusPtr;
IPSecRcvFWPacketRtn IPSecRcvFWPacketPtr;

VOID
SetPersistentRoutesForNTE(
                          IPAddr Address,
                          IPMask Mask,
                          ULONG IFIndex
                          );
uint InterfaceSize;                // Size of a net interface.

NetTableEntry *DHCPNTE = NULL;

#ifdef ALLOC_PRAGMA
//
// Make init code disposable.
//
void InitTimestamp();
int InitNTE(NetTableEntry * NTE);
int InitInterface(NetTableEntry * NTE);
LLIPRegRtn GetLLRegPtr(PNDIS_STRING Name);
LLIPRegRtn FindRegPtr(PNDIS_STRING Name);
uint IPRegisterDriver(PNDIS_STRING Name, LLIPRegRtn Ptr);
void CleanAdaptTable();
void OpenAdapters();
int IPInit();

#pragma alloc_text(INIT, InitTimestamp)
#pragma alloc_text(INIT, CleanAdaptTable)
#pragma alloc_text(INIT, OpenAdapters)
#pragma alloc_text(INIT, IPRegisterDriver)
#pragma alloc_text(INIT, GetLLRegPtr)
#pragma alloc_text(INIT, FindRegPtr)
#pragma alloc_text(INIT, IPInit)

NTSTATUS
IPReserveIndex(
               IN ULONG ulNumIndices,
               OUT PULONG pulStartIndex,
               OUT PULONG pulLongestRun
               );

VOID
IPDereserveIndex(
                 IN ULONG ulNumIndices,
                 IN ULONG ulStartIndex
                 );

NTSTATUS
IPChangeIfIndexAndName(
                       IN PVOID pvContext,
                       IN ULONG ulNewIndex,
                       IN PUNICODE_STRING pusNewName OPTIONAL
                       );

extern
int
 swprintf(wchar_t * buffer, const wchar_t * format,...);

NTSTATUS
ConvertGuidToString(
                    IN GUID * Guid,
                    OUT PUNICODE_STRING GuidString
                    );

NTSTATUS
ConvertStringToGuid(
                    IN PUNICODE_STRING GuidString,
                    OUT GUID * Guid
                    );

IP_STATUS
IPAddDynamicNTE(ulong InterfaceContext, PUNICODE_STRING InterfaceName,
                int InterfaceNameLen, IPAddr NewAddr, IPMask NewMask,
                ushort * NTEContext, ulong * NTEInstance);

//        #pragma alloc_text(PAGE, IPAddDynamicNTE)

#endif // ALLOC_PRAGMA

extern PDRIVER_OBJECT IPDriverObject;

extern NDIS_HANDLE ARPHandle;    // Our NDIS protocol handle.



NTSTATUS
SetRegDWORDValue(
                 HANDLE KeyHandle,
                 PWCHAR ValueName,
                 PULONG ValueData
                 );



//      SetFilterPtr - A routine to set the filter pointer.
//
//      This routine sets the IP forwarding filter callout.
//
//      Input:  FilterPtr       - Pointer to routine to call when filtering. May
//              be NULL.
//
//      Returns: IP_SUCCESS.
//
IP_STATUS
SetFilterPtr(IPPacketFilterPtr FilterPtr)
{
    Interface *IF;
    CTELockHandle Handle;

    // If the pointer is being set to NULL, filtering is being disabled;
    // otherwise filtering is being enabled.

    if (FilterPtr == NULL) {
        if (!ForwardFilterEnabled)
            return IP_GENERAL_FAILURE;

        // We must now synchronize the disabling of filtering with
        // the execution of all threads processing packets. This involves
        // the following operations, *in the given order*:
        // - clear the 'enabled' flag and install the dummy callout routine;
        //   this ensures that no additional references will be made to the
        //   callout until we return control, and that any references begun
        //   after we set the flag will execute the dummy rather than the
        //   actual callout.
        // - clear the event in case we need to wait for outstanding callouts
        //   to complete; the event might still be signalled from a superfluous
        //   dereference during a previous deregistration of a filter hook.
        // - drop the initial reference made to the callout, and wait for all
        //   outstanding callouts (if any) to complete.

        ForwardFilterEnabled = FALSE;
        SetDummyFilterPtr(DummyFilterPtr);

        CTEClearSignal(&ForwardFilterBlock);
        if (CTEInterlockedDecrementLong(&ForwardFilterRefCount)) {
            CTEBlock(&ForwardFilterBlock);
        }

    } else {

        // If filtering is already enabled, turn it off first.

        if (ForwardFilterEnabled)
            SetFilterPtr(NULL);

        // We must synchronize the enabling of filtering with the execution
        // of all threads processing packets. Again, a sequence of operations
        // is required, in the given order:
        // - make an initial reference for the callout to be installed;
        //   if there were any existing references then someone beat us
        //   into the registration and we must fail this request.
        // - install the new callout; this is done before setting the flag
        //   to ensure that the callout is available before any thread
        //   attempts to execute it.
        // - set the flag indicating filtering has been enabled.

        if (CTEInterlockedIncrementLong(&ForwardFilterRefCount) != 1) {
            DerefFilterPtr();
            return IP_GENERAL_FAILURE;
        }
        InterlockedExchangePointer((PVOID*)&ForwardFilterPtr, FilterPtr);
        ForwardFilterEnabled = TRUE;
    }

    return IP_SUCCESS;
}

//      SetIPSecPtr - A routine to set the IPSEC callouts
//
//      This routine sets the IP forwarding filter callout.
//
//      Input:  FilterPtr       - Pointer to routine to call when filtering. May
//              be NULL.
//
//      Returns: IP_SUCCESS.
//
IP_STATUS
SetIPSecPtr(PIPSEC_FUNCTIONS IpsecFns)
{
    if (IpsecFns->Version != IP_IPSEC_BIND_VERSION) {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_ERROR_LEVEL,
                   "!!Mismatched IP and IPSEC!!\n"));
        return IP_SUCCESS;
    }
    IPSecHandlerPtr = IpsecFns->IPSecHandler;
    IPSecQueryStatusPtr = IpsecFns->IPSecQStatus;
    IPSecSendCmpltPtr = IpsecFns->IPSecSendCmplt;
    IPSecNdisStatusPtr = IpsecFns->IPSecNdisStatus;
    IPSecRcvFWPacketPtr = IpsecFns->IPSecRcvFWPacket;
    return IP_SUCCESS;
}

IP_STATUS
UnSetIPSecPtr(PIPSEC_FUNCTIONS IpsecFns)
{
    if (IpsecFns->Version != IP_IPSEC_BIND_VERSION) {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_ERROR_LEVEL,
                   "!!Mismatched IP and IPSEC!!\n"));
        return IP_SUCCESS;
    }
    IPSecHandlerPtr = IPSecHandlePacketDummy;

    IPSecQueryStatusPtr = IPSecQueryStatusDummy;
    IPSecSendCmpltPtr = IPSecSendCompleteDummy;
    IPSecNdisStatusPtr = IPSecNdisStatusDummy;
    IPSecRcvFWPacketPtr = IPSecRcvFWPacketDummy;
    return IP_SUCCESS;
}

IP_STATUS
UnSetIPSecSendPtr(PIPSEC_FUNCTIONS IpsecFns)
{
    if (IpsecFns->Version != IP_IPSEC_BIND_VERSION) {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_ERROR_LEVEL,
                   "!!Mismatched IP and IPSEC!!\n"));
        return IP_SUCCESS;
    }
    IPSecHandlerPtr = IPSecHandlePacketDummy;
    IPSecQueryStatusPtr = IPSecQueryStatusDummy;
    IPSecNdisStatusPtr = IPSecNdisStatusDummy;
    IPSecRcvFWPacketPtr = IPSecRcvFWPacketDummy;
    return IP_SUCCESS;
}

//** InitFirewallQ - initializes the queue of firewall-hooks.
//
//  This routine is called during initialization to prepare the firewall-hook
//  elements for operation.
//
//  Input:  nothing.
//
//  Returns: nothing.
//
void
InitFirewallQ(void)
{
    INITQ(&FQBlock[0].fqb_queue);
    FQBlock[0].fqb_array = NULL;
    FQBlock[0].fqb_exitcount = 0;

    INITQ(&FQBlock[1].fqb_queue);
    FQBlock[1].fqb_array = NULL;
    FQBlock[1].fqb_exitcount = 0;

    FQCounter.fqc_index = 0;
    FQCounter.fqc_entrycount = 0;
}

//** FreeFirewallQ - releases resources used by the queue of firewall-hooks.
//
//  This routine is called during shutdown to free the firewall queue's
//  resources. As such, it assumes there are no active invocations to any
//  firewall hook routines, and no registrations/deregistrations are in
//  progress.
//
//  Input:  nothing.
//
//  Returns: nothing.
//
void
FreeFirewallQ(void)
{
    if (FQBlock[FQCounter.fqc_index].fqb_array) {
        CTEFreeMem(FQBlock[FQCounter.fqc_index].fqb_array);
        FQBlock[FQCounter.fqc_index].fqb_array = NULL;
    }
}

//** UpdateFirewallQ - Creates an updated copy of the firewall queue.
//
//  This routine is called to generate a copy of the firewall queue
//  when an entry needs to be inserted or removed. The copy includes
//  (or excludes) the new (or old) entry. If an entry is to be removed
//  and it is not found in the existing list, no changes are made.
//  It assumes the caller holds the route-table lock.
//
//  Input:  FirewallPtr     - Pointer to routine for the entry to be added
//                            or removed.
//          AddEntry        - if TRUE, 'FirewallPtr' is to be added;
//                            otherwise, 'FirewallPtr' is to be removed.
//          Priority        - specifies priority for 'FirewallPtr' if adding.
//
//  Returns: IP_SUCCESS if the queue was updated, error otherwise.
//
IP_STATUS
UpdateFirewallQ(IPPacketFirewallPtr FirewallPtr, BOOLEAN AddEntry,
                uint Priority)
{
    int                 i;
    uint                Count;
    Queue*              CurrQ;
    PFIREWALL_HOOK      CurrHook;
    PFIREWALL_HOOK      EntryHook = NULL;
    FirewallQCounter    FQC;
    FirewallQBlock      *OldFQB = &FQBlock[FQCounter.fqc_index];
    FirewallQBlock      *NewFQB = &FQBlock[1 - FQCounter.fqc_index];

    // Scan the list for the item to be inserted or removed. We must do this
    // in either case, though what we do on finding it depends on whether
    // we're inserting or removing the item. At the same time, count how many
    // entries there are, since we'll allocate one block for them all.

    CurrQ = QHEAD(&OldFQB->fqb_queue);
    Count = 0;
    while (CurrQ != QEND(&OldFQB->fqb_queue)) {
        CurrHook = QSTRUCT(FIREWALL_HOOK, CurrQ, hook_q);
        if (CurrHook->hook_Ptr == FirewallPtr) { EntryHook = CurrHook; }
        CurrQ = QNEXT(CurrQ);
        ++Count;
    }

    if (AddEntry) {
        Queue*  PrevQ;

        // Make sure the entry to be removed isn't already present,
        // then allocate space for the new array.

        if (EntryHook) { return IP_GENERAL_FAILURE; }

        NewFQB->fqb_array =
            CTEAllocMemN(sizeof(FIREWALL_HOOK) * (Count + 1), 'mICT');
        if (!NewFQB->fqb_array) { return IP_NO_RESOURCES; }

        // Transfer the entire old array (if any) to the new space,
        // and relink the queue entries in the new space, using the old linkage
        // as a guide. (I.e. entry 'i' in the old queue goes in location 'i'
        // in the new block.)
        // In the process, find the insertion point for the new entry.

        INITQ(&NewFQB->fqb_queue);
        PrevQ = &NewFQB->fqb_queue;
        CurrQ = QHEAD(&OldFQB->fqb_queue);
        i = 0;
        while (CurrQ != QEND(&OldFQB->fqb_queue)) {
            CurrHook = QSTRUCT(FIREWALL_HOOK, CurrQ, hook_q);
            NewFQB->fqb_array[i].hook_Ptr = CurrHook->hook_Ptr;
            NewFQB->fqb_array[i].hook_priority = CurrHook->hook_priority;
            ENQUEUE(&NewFQB->fqb_queue, &NewFQB->fqb_array[i].hook_q);

            if (PrevQ == &NewFQB->fqb_queue &&
                Priority < CurrHook->hook_priority) {
                PrevQ = &NewFQB->fqb_array[i].hook_q;
            }

            CurrQ = QNEXT(CurrQ);
            ++i;
        }

        // Finally, append the new item to the new array,
        // and link it into the current queue according to the given priority,
        // using the insertion point determined above.

        NewFQB->fqb_array[Count].hook_Ptr = FirewallPtr;
        NewFQB->fqb_array[Count].hook_priority = Priority;
        ENQUEUE(PrevQ, &NewFQB->fqb_array[Count].hook_q);
    } else {

        // Make sure the entry to be removed is present.
        // If it is, figure out how much space the new array will require.
        // If it's zero, we're done.

        if (!EntryHook) { return IP_GENERAL_FAILURE; }
        if (!(Count - 1)) {
            NewFQB->fqb_array = NULL;
            INITQ(&NewFQB->fqb_queue);
        } else {
            NewFQB->fqb_array =
                CTEAllocMemN(sizeof(FIREWALL_HOOK) * (Count - 1), 'mICT');
            if (!NewFQB->fqb_array) { return IP_NO_RESOURCES; }

            // Transfer the old array to the new space minus the item being
            // removed, by traversing the old queue.

            INITQ(&NewFQB->fqb_queue);
            CurrQ = QHEAD(&OldFQB->fqb_queue);
            i = 0;
            while (CurrQ != QEND(&OldFQB->fqb_queue)) {
                CurrHook = QSTRUCT(FIREWALL_HOOK, CurrQ, hook_q);
                if (CurrHook == EntryHook) {
                    CurrQ = QNEXT(CurrQ);
                    continue;
                }

                NewFQB->fqb_array[i].hook_Ptr = CurrHook->hook_Ptr;
                NewFQB->fqb_array[i].hook_priority = CurrHook->hook_priority;
                ENQUEUE(&NewFQB->fqb_queue, &NewFQB->fqb_array[i].hook_q);
                CurrQ = QNEXT(CurrQ);
                ++i;
            }
        }
    }

    // Clear the exit-count for the new location,
    // and change the global active counter to start directing
    // new references to the copy that we've just created.
    // In the process, the number of threads processing the old list
    // is captured in a local counter.

    NewFQB->fqb_exitcount = 0;
    FQC.fqc_value =
        InterlockedExchange(&FQCounter.fqc_value, 1 - FQCounter.fqc_index);

    // If there were any references to the old list, wait for them
    // to be released; then free the memory that held the old list.
    //
    // N.B.!!! This assumes that any references to the old list
    // were made by threads running at dispatch IRQL or higher,
    // since we are about to block at dispatch IRQL.

    if (OldFQB->fqb_exitcount != FQC.fqc_entrycount) {
#if DBG
        ++FQSpinCount;
#endif
        do {
            volatile uint Delay = 100;
            while (Delay--) { }
        } while (OldFQB->fqb_exitcount != FQC.fqc_entrycount);
    }
    if (OldFQB->fqb_array) {
        CTEFreeMem(OldFQB->fqb_array);
        OldFQB->fqb_array = NULL;
        INITQ(&OldFQB->fqb_queue);
    }

    return IP_SUCCESS;
}

//** RefFirewallQ - Makes a reference to the active firewall queue.
//
//  This routine is called during data-processing to find and reference
//  the active firewall queue.
//
//  Input:  FirewallQ       - receives the active firewall queue on output
//
//  Returns: a 32-bit handle to be used to release the reference.
//
uint
RefFirewallQ(Queue** FirewallQ)
{
    FirewallQCounter FQC;
    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

    // Increment the 31-bit entry-count through the 32-bit value that
    // shares its address in the counter structure.
    //
    // N.B. In order to increment fqc_entrycount by 1, we increment fqc_value
    // by 2 since the least-significant bit is occupied by fqc_index,
    // (the current index into FQBlock) which we don't want to modify.

    FQC.fqc_value = InterlockedExchangeAdd(&FQCounter.fqc_value, 2);
    *FirewallQ = &FQBlock[FQC.fqc_index].fqb_queue;
    return FQC.fqc_index;
}

//** DerefFirewallQ - Releases a reference to a firewall queue.
//
//  This routine is called to release a reference made to a firewall queue
//  in a previous call to RefFirewallQ.
//
//  Input:  Handle          - supplies the handle returned by RefFirewallQ
//
//  Returns: nothing.
//
void
DerefFirewallQ(uint Handle)
{
    InterlockedIncrement(&FQBlock[Handle].fqb_value);
}

//** ProcessFirewallQ - Determines whether any firewall hooks are registered.
//
//  This routine is called during data-processing to determine whether
//  there are any registrants in the queue of firewall hooks.
//
//  Input:  nothing.
//
//  Output: TRUE if firewall-hooks might be present, FALSE otherwise.
//
BOOLEAN
ProcessFirewallQ(void)
{
    return !EMPTYQ(&FQBlock[FQCounter.fqc_index].fqb_queue);
}

//      SetFirewallHook - Set the firewall hook information on a particular interface.
//
//      A routine to set the firewall hook & context on a particular interface.
//
//      Input:  pFirewallHookInfo    - Info about the hook to set.
//
//      Returns: Status of attempt.
//
IP_STATUS
SetFirewallHook(PIP_SET_FIREWALL_HOOK_INFO pFirewallHookInfo)
{
    IP_STATUS ipStatus;
    CTELockHandle Handle;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    ipStatus = UpdateFirewallQ(pFirewallHookInfo->FirewallPtr,
                               pFirewallHookInfo->Add,
                               pFirewallHookInfo->Priority);

    CTEFreeLock(&RouteTableLock.Lock, Handle);
    return IPStatusToNTStatus(ipStatus);
}

//      SetMapRoutePtr - A routine to set the dial on demand callout pointer.
//
//      This routine sets the IP dial on demand callout.
//
//      Input:  MapRoutePtr     - Pointer to routine to call when we need to bring
//                      up a link. May be NULL
//
//      Returns: IP_SUCCESS.
//
IP_STATUS
SetMapRoutePtr(IPMapRouteToInterfacePtr MapRoutePtr)
{
    DODCallout = MapRoutePtr;
    return IP_SUCCESS;
}

//  SetRtChangePtr - A routine to set the filter pointer.
//
//  This routine sets the IP route change callout.
//
//  Input:  RtChangePtr - Pointer to routine to call when route table changes
//
//  Returns: IP_SUCCESS.
//
#if FUTURE
IP_STATUS
SetRtChangePtr(IPRouteChangePtr pRtChangePtr)
{

    pIPRtChangePtr = pRtChangePtr;

    return IP_SUCCESS;
}
#endif //FUTURES

//**    SetDHCPNTE
//
//      Routine to identify which NTE is currently being DHCP'ed. We take as input
//      an nte_context. If the context is less than the max NTE context, we look
//      for a matching NTE and if we find him we save a pointer. If we don't we
//      fail. If the context > max NTE context we're disabling DHCPing, and
//      we NULL out the save pointer.
//
//  Instead of saving a pointer, the nte is marked as "isdhcp".
//  No equivalent of "NULLing the ptr".
//  The above change is to have multiple dhcp'able NTE's simultaneously.
//
//      Input:  Context         - NTE context value.
//
//      Returns: TRUE if we succeed, FALSE if we don't.
//
uint
SetDHCPNTE(uint Context)
{
    CTELockHandle Handle;
    NetTableEntry *NTE;
    ushort NTEContext;
    uint RetCode;
    uint i;

    DEBUGMSG(DBG_TRACE && DBG_DHCP,
        (DTEXT("+SetDHCPNTE(%x)\n"), Context));

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    if (Context < MAX_NTE_CONTEXT) {
        // We're setting the DHCP NTE. Look for one matching the context.

        NTEContext = (ushort) Context;

        for (i = 0; i < NET_TABLE_SIZE; i++) {
            for (NTE = NewNetTableList[i]; NTE != NULL; NTE = NTE->nte_next) {
                if (NTE != LoopNTE && NTE->nte_context == NTEContext) {
                    // Found one. Save it and break out.
                    DHCPNTE = NTE;
                    if (!(NTE->nte_flags & NTE_VALID)) {
                        NTE->nte_flags |= NTE_DHCP;
                    }
                    break;
                }
            }
            if (NTE) {
                DEBUGMSG(DBG_INFO && DBG_DHCP,
                    (DTEXT("SetDHCPNTE: DHCPNTE = %x (%x)\n"), NTE, NTE->nte_context));
                break;
            }
        }
        RetCode = (NTE != NULL);
    } else {
        // The context is invalid, so we're deleting the DHCP NTE.
        DHCPNTE = NULL;

        RetCode = TRUE;
    }

    CTEFreeLock(&RouteTableLock.Lock, Handle);

    DEBUGMSG(DBG_TRACE && DBG_DHCP,
        (DTEXT("-SetDHCPNTE [%x]\n"), RetCode));

    return RetCode;
}

//**    SetDHCPNTE
//
//  Routine for upper layers to call to check if the IPContext value passed
//  up to a RcvHandler identifies an interface that is currently being
//  DHCP'd.
//
//      Input:   Context                - Pointer to an NTE
//
//      Returns: TRUE if we succeed, FALSE if we don't.
//
uint
IsDHCPInterface(void *IPContext)
{
//      CTELockHandle           Handle;
    uint RetCode;
    NetTableEntry *NTE = (NetTableEntry *) IPContext;

//      CTEGetLock(&RouteTableLock.Lock, &Handle);

    // just check to see if the dhcp-is-working flag is turned on on the
    // NTE.  This will be turned on by DHCP via SetDHCPNTE, and turned off
    // whenever a valid address is set on the interface.
    RetCode = (NTE->nte_flags & NTE_DHCP) ? TRUE : FALSE;

    if (RetCode) {
        ASSERT(!(NTE->nte_flags & NTE_VALID));
    }
//      CTEFreeLock(&RouteTableLock.Lock, Handle);

    DEBUGMSG(DBG_TRACE && DBG_DHCP,
        (DTEXT("IsDHCPInterface(%x) -> [%x]\n"), NTE, RetCode));

    return (RetCode);
}

//**    IsWlanInterface
//
//  Routine for upper layers to call to check if the Interface passed in
//  corresponds to a wireless medium.
//
//      Input:  IF      - Pointer to an Interface.
//
//      Returns: TRUE if wireless, FALSE otherwise.
//
uint
IsWlanInterface(Interface* IF)
{
    NDIS_PHYSICAL_MEDIUM NPM;
    NDIS_STATUS Status;

    if (IF->if_dondisreq) {
        Status = (*IF->if_dondisreq)(IF->if_lcontext,
                                     NdisRequestQueryInformation,
                                     OID_GEN_PHYSICAL_MEDIUM, &NPM, sizeof(NPM),
                                     NULL, TRUE);
        if (Status == NDIS_STATUS_SUCCESS &&
            NPM == NdisPhysicalMediumWirelessLan) {
            return TRUE;
        }
    }

    return FALSE;
}

void
DHCPActivityDone(NetTableEntry * NTE, Interface * IF, CTELockHandle * RouteTableHandle, uint Decr)
{
    DHCPActivityCount--;

    DEBUGMSG(DBG_TRACE && DBG_DHCP,
        (DTEXT("DHCPActivityDone(%x, %x, %x, %x) ActivityCount %d\n"),
         NTE, IF, RouteTableHandle, Decr));

    NTE->nte_flags &= ~NTE_DHCP;
    if (Decr) {
        // This routine takes route table lock inside so release it here
        CTEFreeLock(&RouteTableLock.Lock, *RouteTableHandle);
        DecrInitTimeInterfaces(IF);
        CTEGetLock(&RouteTableLock.Lock, RouteTableHandle);
    }
}

//**    CloseNets - Close active nets.
//
//  Called when we need to close some lower layer interfaces.
//
//  Entry:  Nothing
//
//  Returns: Nothing
//
void
CloseNets(void)
{
    NetTableEntry *nt;
    uint i;

    for (i = 0; i < NET_TABLE_SIZE; i++) {
        for (nt = NewNetTableList[i]; nt != NULL; nt = nt->nte_next) {
            (*nt->nte_if->if_close) (nt->nte_if->if_lcontext);    // Call close routine for this net.

        }
    }
}

void
__stdcall
IPBindComplete(
               IN IP_STATUS BindStatus,
               IN void *BindContext
               )
{
    NdisCompleteBindAdapter(BindContext, BindStatus, 0 /*??*/ );
}

//**    IPDelayedNdisReEnumerateBindings
//
//  This requests NDIS to reenumerate our bindings to adapters that
//  are still unresolved (i.e. unopened). This is to give a chance
//  for external ARP modules to try and bind to such adapters.
//
//  Input:      Event - event that fired us off
//                      Context - ignored
//
//  Returns: Nothing
//
VOID
IPDelayedNdisReEnumerateBindings(
                                 CTEEvent * Event,
                                 PVOID Context
                                 )
{
    UNREFERENCED_PARAMETER(Context);

    InterlockedIncrement(&ReEnumerateCount);
    NdisReEnumerateProtocolBindings(ARPHandle);

    if (Event) {
        CTEFreeMem(Event);
    }
}

PARP_MODULE
IPLookupArpModule(
                  UNICODE_STRING ArpName
                  )
{
    PLIST_ENTRY entry;
    PARP_MODULE pModule;
    KIRQL OldIrql;
    CTEGetLock(&ArpModuleLock, &OldIrql);

    DEBUGMSG(DBG_TRACE && DBG_ARP && DBG_INIT,
        (DTEXT("+IPLookupArpModule(%x)\n"), &ArpName));

    entry = ArpModuleList.Flink;
    while (entry != &ArpModuleList) {
        pModule = STRUCT_OF(ARP_MODULE, entry, Linkage);

        if ((pModule->Name.Length == ArpName.Length) &&
            RtlEqualMemory(pModule->Name.Buffer,
                           ArpName.Buffer,
                           ArpName.Length)) {
            CTEFreeLock(&ArpModuleLock, OldIrql);
            DEBUGMSG(DBG_TRACE && DBG_ARP && DBG_INIT,
                (DTEXT("-IPLookupArpModule [%x]\n"), pModule));
            return pModule;
        }
        entry = entry->Flink;
    }

    CTEFreeLock(&ArpModuleLock, OldIrql);
    DEBUGMSG(DBG_TRACE && DBG_ARP && DBG_INIT,
        (DTEXT("-IPLookupArpModule [NULL]\n")));
    return NULL;
}

PARP_MODULE
IPLookupArpModuleWithLock(
                          UNICODE_STRING ArpName
                          )
{
    PLIST_ENTRY entry;
    PARP_MODULE pModule;

    DEBUGMSG(DBG_TRACE && DBG_ARP && DBG_INIT,
        (DTEXT("+IPLookupArpModuleWithLock(%x)\n"), &ArpName));

    entry = ArpModuleList.Flink;
    while (entry != &ArpModuleList) {
        pModule = STRUCT_OF(ARP_MODULE, entry, Linkage);

        if ((pModule->Name.Length == ArpName.Length) &&
            RtlEqualMemory(pModule->Name.Buffer,
                           ArpName.Buffer,
                           ArpName.Length)) {
            DEBUGMSG(DBG_TRACE && DBG_ARP && DBG_INIT,
                (DTEXT("-IPLookupArpModuleWithLock [%x]\n"), pModule));
            return pModule;
        }
        entry = entry->Flink;
    }

    DEBUGMSG(DBG_TRACE && DBG_ARP && DBG_INIT,
        (DTEXT("-IPLookupArpModuleWithLock [NULL]\n")));
    return NULL;
}

//*     IPRegisterARP - Register an ARP module with us.
//
//      Called by ARP modules to register their bind handlers with IP.
//
//      Input:  ARPName                 -  name of the ARP module
//              Version                 -  Suggested value of 0x50000 for NT 5.0 and memphis
//                              ARPBindHandler          -  handler to call on BindAdapter
//                              IpAddInterfaceHandler   -  handler to Add interfaces
//                              IpDelInterfaceHandler   -  handler to Del interfaces
//              IpBindCompleteHandler   -  handler to complete binds
//              ARPRegisterHandle       -  handle returned on Deregister
//      Returns:    Status of operation
//
NTSTATUS
__stdcall
IPRegisterARP(
              IN PNDIS_STRING ARPName,
              IN uint Version,
              IN ARP_BIND ARPBindHandler,
              OUT IP_ADD_INTERFACE * IpAddInterfaceHandler,
              OUT IP_DEL_INTERFACE * IpDelInterfaceHandler,
              OUT IP_BIND_COMPLETE * IpBindCompleteHandler,
              OUT IP_ADD_LINK * IpAddLinkHandler,
              OUT IP_DELETE_LINK * IpDeleteLinkHandler,
              OUT IP_CHANGE_INDEX * IpChangeIndex,
              OUT IP_RESERVE_INDEX * IpReserveIndex,
              OUT IP_DERESERVE_INDEX * IpDereserveIndex,
              OUT HANDLE * ARPRegisterHandle
              )
{
    PARP_MODULE pArpModule;
    PARP_MODULE pArpModule1;
    CTEEvent *Event;

    DEBUGMSG(DBG_TRACE && DBG_ARP,
        (DTEXT("+IPRegisterARP(%x, %x, %x, ...)\n"),
         ARPName, Version, ARPBindHandler));

    *ARPRegisterHandle = NULL;

    if (Version != IP_ARP_BIND_VERSION) {
        // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Wrong bind version: %lx\n", Version));
        return STATUS_INVALID_PARAMETER;
    }
    //
    // Insert into the Arp module list
    //
    if ((pArpModule = CTEAllocMemNBoot(sizeof(ARP_MODULE) + ARPName->Length, 'mICT')) == NULL) {
        // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Failed to allocate Arpmodule struct\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    pArpModule->BindHandler = ARPBindHandler;

    pArpModule->Name.Buffer = (PWSTR) (pArpModule + 1);
    pArpModule->Name.MaximumLength = ARPName->Length;
    RtlCopyUnicodeString(&pArpModule->Name, ARPName);

#if DBG
    {
        KIRQL OldIrql;
        CTEGetLock(&ArpModuleLock, &OldIrql);
        if ((pArpModule1 = IPLookupArpModuleWithLock(*ARPName)) != NULL) {
            KdPrint(("Double register from %lx\n", pArpModule));
            DbgBreakPoint();
            CTEFreeLock(&ArpModuleLock, OldIrql);
            return STATUS_INVALID_PARAMETER;
        }
        InsertTailList(&ArpModuleList,
                       &pArpModule->Linkage);

        CTEFreeLock(&ArpModuleLock, OldIrql);
    }
#else
    ExInterlockedInsertTailList(&ArpModuleList,
                                &pArpModule->Linkage,
                                &ArpModuleLock);
#endif

    //
    // Return the other handler pointers
    //
    *IpAddInterfaceHandler = IPAddInterface;
    *IpDelInterfaceHandler = IPDelInterface;
    *IpBindCompleteHandler = IPBindComplete;

    *IpAddLinkHandler = IPAddLink;
    *IpDeleteLinkHandler = IPDeleteLink;

    *IpChangeIndex = IPChangeIfIndexAndName;
    *IpReserveIndex = IPReserveIndex;
    *IpDereserveIndex = IPDereserveIndex;

    //
    // We should request NDIS to reevaluate our adapter bindings, because
    // this new ARP module might handle one or more of our unbound adapters.
    // But we don't do it right here because our caller (ARP module) may not
    // be prepared for a BindAdapter call now. So we queue it to the
    // worker thread.
    //
    Event = CTEAllocMemNBoot(sizeof(CTEEvent), 'oICT');
    if (Event) {
        CTEInitEvent(Event, IPDelayedNdisReEnumerateBindings);
        CTEScheduleDelayedEvent(Event, NULL);
    }
    *ARPRegisterHandle = (PVOID) pArpModule;

    return STATUS_SUCCESS;
}

//*     IPDeregisterARP - Deregister an ARP module from IP.
//
//      Called by ARP modules to deregister their bind handlers with IP.
//
//      Input:  ARPRegisterHandle       -  handle returned on Register
//      Returns:    Status of operation
//
NTSTATUS
__stdcall
IPDeregisterARP(
                IN HANDLE ARPRegisterHandle
                )
{
    PARP_MODULE pArpModule = (PARP_MODULE) ARPRegisterHandle;
    PARP_MODULE pArpModule1;
    KIRQL OldIrql;

    CTEGetLock(&ArpModuleLock, &OldIrql);

#if DBG
    if ((pArpModule1 = IPLookupArpModuleWithLock(pArpModule->Name)) == NULL) {
        KdPrint(("Deregister from %lx when none registered!\n", pArpModule));
        DbgBreakPoint();
        CTEFreeLock(&ArpModuleLock, OldIrql);
        return STATUS_INVALID_PARAMETER;
    }
    ASSERT(pArpModule1 == pArpModule);
#endif
    RemoveEntryList(&pArpModule->Linkage);

    CTEFreeLock(&ArpModuleLock, OldIrql);

    CTEFreeMem(pArpModule);

    return STATUS_SUCCESS;
}

#if MILLEN

//
// Helper routine to append a NULL-terminated string to an ANSI_SRING.
//
NTSTATUS
AppendAnsiString (
    IN PANSI_STRING Destination,
    IN PCHAR Source
    )
{
    USHORT n;

    n = (USHORT) strlen(Source);

    if ((n + Destination->Length) > Destination->MaximumLength) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    RtlMoveMemory( &Destination->Buffer[ Destination->Length ], Source, n );
    Destination->Length += n;

    return STATUS_SUCCESS;
}

//*     MillenLoadDriver - Jump into NTKERNs NtKernWin9XLoadDriver.
//
//      Calls into NTKERNs VxD entrypoint for NtKernWin9xLoadDriver.
//
//      Input:
//          FileName - Full filename of driver to load. (no path).
//          RegistryPath - Registry path associated with driver.
//
//      Returns: NULL - Failure.
//               Pointer to driver object - success.
//
PVOID
__cdecl
MillenLoadDriver(
    PCHAR   FileName,
    PCHAR   RegistryPath
    )
{
    PVOID DriverObject;

    //
    // Do an int 20 to jmp into NTKERN service table - 0x000b is
    // NtKernWin9XLoadDriver entry.
    //

    _asm {
        push [RegistryPath]
        push [FileName]
        _emit 0xcd
        _emit 0x20
        _emit 0x0b // NtKernWin9XLoadDriver (Low)
        _emit 0x00 // NtKernWin9XLoadDriver (Hign)
        _emit 0x4b // NTKERN VxD ID (Low)
        _emit 0x00 // NTKERN VxD ID (High)
        add esp,8
        mov [DriverObject], eax
    }

    return DriverObject;
}

//*     MillenLoadArpModule - Loads an ARP module.
//
//      Calls into NTKERN to load the given ARP module. The real reason for this
//      is that the given registry path (under binding config) will contain a
//      key such that the ARP module is loaded into non-preemptable memory.
//      Otherwise, some issues arise with pre-emption when calling between
//      the stack and external ARP modules.
//
//      Input:
//          UnicodeFileName - Filename of the ARP module to open (without extension).
//          UnicodeConfigName - Registry path of TCP/IP binding.
//
//      Returns: NT Status code.
//
NTSTATUS
MillenLoadArpModule(
    PUNICODE_STRING UnicodeFileName,
    PUNICODE_STRING UnicodeConfigName
    )
{
    ANSI_STRING FileName;
    ANSI_STRING ConfigName;
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PVOID       DriverObject;

    RtlZeroMemory(&FileName, sizeof(ANSI_STRING));
    RtlZeroMemory(&ConfigName, sizeof(ANSI_STRING));

    //
    // Allocate FileName and convert from unicode. Append ".sys".
    //

    FileName.Length = 0;
    FileName.MaximumLength = UnicodeFileName->Length/2 + sizeof(".sys");

    FileName.Buffer = CTEAllocMem(FileName.MaximumLength);

    if (FileName.Buffer == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }

    RtlZeroMemory(FileName.Buffer, FileName.MaximumLength);

    NtStatus = RtlUnicodeStringToAnsiString(
        &FileName,
        UnicodeFileName,
        FALSE); // Buffer already allocated.

    if (NT_ERROR(NtStatus)) {
        goto done;
    }

    NtStatus = AppendAnsiString(
        &FileName,
        ".sys");

    if (NT_ERROR(NtStatus)) {
        goto done;
    }

    //
    // Allocate ConfigName and convert from unicode.
    //

    NtStatus = RtlUnicodeStringToAnsiString(
        &ConfigName,
        UnicodeConfigName,
        TRUE); // Allocate config name.

    if (NT_ERROR(NtStatus)) {
        goto done;
    }

    //
    // Now call into NtKern to load the driver.
    //

    DriverObject = MillenLoadDriver(FileName.Buffer, ConfigName.Buffer);

    if (DriverObject == NULL) {
        NtStatus = STATUS_UNSUCCESSFUL;
        goto done;
    }

done:

    if (FileName.Buffer) {
        CTEFreeMem(FileName.Buffer);
    }

    if (ConfigName.Buffer) {
        RtlFreeAnsiString(&ConfigName);
    }

    if (NT_ERROR(NtStatus)) {
        DEBUGMSG(DBG_ERROR, (DTEXT("MillenLoadArpModule failure %x\n"), NtStatus));
    }

    return NtStatus;
}
#endif // MILLEN

//*     IPBindAdapter - Bind and initialize an adapter.
//
//      Called in a PNP environment to initialize and bind an adapter. We determine
//      the appropriate underlying arp layer and call into its BindHandler.
//
//      Input:  RetStatus               - Where to return the status of this call.
//              BindContext             - Handle to use for calling BindAdapterComplete.
//                              AdapterName             - Pointer to name of adapter.
//                              SS1                                             - System specific 1 parameter.
//                              SS2                                             - System specific 2 parameter.
//
//      Returns: Nothing.
//
void
 __stdcall
IPBindAdapter(
              PNDIS_STATUS RetStatus,
              NDIS_HANDLE BindContext,
              PNDIS_STRING AdapterName,
              PVOID SS1,
              PVOID SS2
              )
{
    NDIS_HANDLE Handle;
    UNICODE_STRING valueString;
    ULONG valueType;
    PARP_MODULE pArpModule;
    NDIS_STATUS status;
    UNICODE_STRING ServicesKeyName = NDIS_STRING_CONST("\\Registry\\Machine\\System\\CurrentControlSet\\Services\\");
    UNICODE_STRING arpDriverName;

    *RetStatus = NDIS_STATUS_SUCCESS;

    DEBUGMSG(DBG_TRACE && DBG_PNP,
        (DTEXT("+IPBindAdapter(%x, %x, %x, %x, %x)\n"),
        RetStatus, BindContext, AdapterName, SS1, SS2));

    valueString.MaximumLength = 200;
    if ((valueString.Buffer = CTEAllocMemNBoot(valueString.MaximumLength, 'pICT')) == NULL) {
        *RetStatus = NDIS_STATUS_RESOURCES;
        return;
    }
    *(valueString.Buffer) = UNICODE_NULL;

    //
    // Get the value for LLInterface
    //
    if (!OpenIFConfig(SS1, &Handle)) {
        *RetStatus = NDIS_STATUS_FAILURE;
        CTEFreeMem(valueString.Buffer);
        return;
    }
    //
    // Get the value under LLInterface.
    //
    status = GetLLInterfaceValue(Handle, &valueString);

    // Can close the config handle here.
    CloseIFConfig(Handle);

#if MILLEN
    //
    // Note: On Millenium, the 1394 ARP module may not have plumbed the
    // LLInterface value into the bindings key, instead it may be under the
    // adapter instance key.
#define MILLEN_ADAPTER_INST_PATH L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Class\\Net\\"

    if (!NT_SUCCESS(status)) {
        NDIS_STRING AdapterInstance;
        NDIS_STRING UnicodeAdapterName;
        NTSTATUS    NtStatus;

        UnicodeAdapterName.Buffer = NULL;

        NtStatus = RtlAnsiStringToUnicodeString(
            &UnicodeAdapterName,
            (PANSI_STRING) AdapterName,
            TRUE);

        if (NT_SUCCESS(NtStatus)) {
            // I have seen where the length of AdapterName is incorrect. Ensure
            // that the length is correct since TDI bindings depend on this string
            // value.
            UnicodeAdapterName.Length = wcslen(UnicodeAdapterName.Buffer) * sizeof(WCHAR);

            DEBUGMSG(DBG_INFO && DBG_PNP,
                (DTEXT("IPBindAdapter: Win9X specific: attempting to retrieve LLIF ")
                 TEXT("under adapter instance %ws\n"), UnicodeAdapterName.Buffer));

            // sizeof will allow for null-termination character.
            AdapterInstance.MaximumLength = sizeof(MILLEN_ADAPTER_INST_PATH) +
                    UnicodeAdapterName.Length + sizeof(WCHAR);
            AdapterInstance.Length = 0;

            AdapterInstance.Buffer = CTEAllocMem(AdapterInstance.MaximumLength);


            if (AdapterInstance.Buffer != NULL) {

                RtlZeroMemory(AdapterInstance.Buffer, AdapterInstance.MaximumLength);

                RtlAppendUnicodeToString(&AdapterInstance, MILLEN_ADAPTER_INST_PATH);
                RtlAppendUnicodeStringToString(&AdapterInstance, &UnicodeAdapterName);

                if (OpenIFConfig(&AdapterInstance, &Handle)) {
                    status = GetLLInterfaceValue(Handle, &valueString);
                    CloseIFConfig(Handle);
                } else {
                    DEBUGMSG(DBG_ERROR,
                        (DTEXT("IPBindAdapter: failed to open secondary LLIF reg %ws\n"),
                         AdapterInstance.Buffer));
                }

                CTEFreeMem(AdapterInstance.Buffer);
            }
            RtlFreeUnicodeString(&UnicodeAdapterName);
        }
    }
#endif // MILLEN

    if (NT_SUCCESS(status) && (*(valueString.Buffer) != UNICODE_NULL)) {

        DEBUGMSG(DBG_INFO && DBG_PNP,
            (DTEXT("IPBindAdapter: found LLIF value %x\n"), valueString.Buffer));

        //
        // We found a proper value => non-default ARP
        //
        //
        // Lookup the appropriate BindHandler
        //
        if ((pArpModule = IPLookupArpModule(valueString)) == NULL) {
#if MILLEN
            status = MillenLoadArpModule(&valueString, SS1);

            if (status == STATUS_SUCCESS) {
                pArpModule = IPLookupArpModule(valueString);
            }
#else // MILLEN
            //
            // no entrypoint registered
            //

            //
            // Maybe the ARP driver isn't loaded yet. Try loading it.
            //
            arpDriverName.MaximumLength = ServicesKeyName.MaximumLength +
                valueString.MaximumLength;

            arpDriverName.Buffer = CTEAllocMemNBoot(arpDriverName.MaximumLength, 'qICT');

            if (arpDriverName.Buffer != NULL) {

                //
                // Prepare the complete registry path for the driver service.
                //
                arpDriverName.Length = 0;
                RtlCopyUnicodeString(&arpDriverName, &ServicesKeyName);
                status = RtlAppendUnicodeStringToString(&arpDriverName, &valueString);
                ASSERT(NT_SUCCESS(status));

                //
                // Try to load the driver.
                //
                status = ZwLoadDriver(&arpDriverName);

                CTEFreeMem(arpDriverName.Buffer);

                if (NT_SUCCESS(status)) {
                    pArpModule = IPLookupArpModule(valueString);
                }
            }
#endif // !MILLEN

            if (pArpModule == NULL) {
                *RetStatus = NDIS_STATUS_FAILURE;
                CTEFreeMem(valueString.Buffer);
                return;
            }
        }
        //
        // Bind to ARP
        //
        (*pArpModule->BindHandler) (RetStatus,
                                    BindContext,
                                    AdapterName,
                                    SS1,
                                    SS2);
    } else {

        DEBUGMSG(DBG_INFO && DBG_PNP,
            (DTEXT("IPBindAdapter: No LLIF value - Calling ARPBindAdapter...\n")));

        ARPBindAdapter(RetStatus,
                       BindContext,
                       AdapterName,
                       SS1,
                       SS2);
    }

    CTEFreeMem(valueString.Buffer);
}

//**    IPRegisterProtocol - Register a protocol with IP.
//
//  Called by upper layer software to register a protocol. The UL supplies
//  pointers to receive routines and a protocol value to be used on xmits/receives.
//
//  Entry:
//      Protocol - Protocol value to be returned.
//      RcvHandler - Receive handler to be called when frames for Protocol are received.
//      XmitHandler - Xmit. complete handler to be called when frames from Protocol are completed.
//      StatusHandler - Handler to be called when status indication is to be delivered.
//
//  Returns:
//      Pointer to ProtInfo,
//
void *
IPRegisterProtocol(uchar Protocol, void *RcvHandler, void *XmitHandler,
                   void *StatusHandler, void *RcvCmpltHandler, void *PnPHandler, void *ElistHandler)
{
    ProtInfo *PI = (ProtInfo *) NULL;
    int i;
    int Incr;

    // First check to see if it's already registered. If it is just replace it.
    for (i = 0; i < NextPI; i++)
        if (IPProtInfo[i].pi_protocol == Protocol) {
            PI = &IPProtInfo[i];
            Incr = 0;
            break;
        }
    if (PI == (ProtInfo *) NULL) {
        if (NextPI >= MAX_IP_PROT) {
            return NULL;
        }
        PI = &IPProtInfo[NextPI];
        Incr = 1;

        if (Protocol == PROTOCOL_ANY) {
            RawPI = PI;
        }
    }
    PI->pi_protocol = Protocol;
    PI->pi_rcv = RcvHandler;
    PI->pi_xmitdone = XmitHandler;
    PI->pi_status = StatusHandler;
    PI->pi_rcvcmplt = RcvCmpltHandler;
    PI->pi_pnppower = PnPHandler;
    PI->pi_elistchange = ElistHandler;
    PI->pi_valid = PI_ENTRY_VALID;
    NextPI += Incr;

    return PI;
}



//**    IPDeregisterProtocol - DeRegister a protocol with IP.
//
//  Called by upper layer software to de-register a protocol. The UL can not
//  unload itself after deregister is called.
//
//  Entry:
//      Protocol - Protocol value to be returned.
//
//  Returns:
//      None or pointer to ProtInfo
//
void *
IPDeregisterProtocol(uchar Protocol)
{
    ProtInfo *PI = (ProtInfo *) NULL;
    int i;

    // First check to see if it's already registered. If it is just replace it.
    for (i = 0; i < NextPI; i++) {

        if (IPProtInfo[i].pi_protocol == Protocol) {
            PI = &IPProtInfo[i];
            break;
        }
    }

    if (PI == (ProtInfo *) NULL) {
        return NULL;
    }

    if (PI == LastPI) {
        ProtInfo *tmpPI = (ProtInfo *) NULL;
        InterlockedExchangePointer(&LastPI, &tmpPI);
    }
    PI->pi_valid = PI_ENTRY_INVALID;

    return PI;
}


//** GetMcastNTEFromAddr - Get a multicast-capable NTE given an IP address.
//
//      Called when joining/leaving multicast groups on an interface identified
//      IP an address (or ifindex or INADDR_ANY).
//
//      Input:  IF         - IP Address/IfIndex of interface to set/delete on,
//                           in network byte order.
//
//      Returns: NTE to join on.
//
NetTableEntry *
GetMcastNTEFromAddr(IPAddr IF)
{
    NetTableEntry *LocalNTE;
    uint i;
    CTELockHandle   Handle;

    // To optimize the test below, we convert the address to host-byte
    // order outside the loop, just in case it's an interface index.
    uint IfIndex = net_long(IF);

    // now that we have a hash table we can optimize the search for the case
    // when IF is a non-NULL IP Addr, but then we have to make special cases when
    // IF is NULL / IF is actually an IF index.
    // Right now, lets do it simple way.

    CTEGetLock(&RouteTableLock.Lock, &Handle);
    for (i = 0; i < NET_TABLE_SIZE; i++) {
        NetTableEntry *NetTableList = NewNetTableList[i];
        for (LocalNTE = NetTableList; LocalNTE != NULL;
             LocalNTE = LocalNTE->nte_next) {
            if (!(LocalNTE->nte_flags & NTE_VALID) ||
                (LocalNTE->nte_if->if_flags & IF_FLAGS_NOLINKBCST))
                continue;

            if (LocalNTE != LoopNTE &&
                (((!IP_ADDR_EQUAL(LocalNTE->nte_addr, NULL_IP_ADDR) &&
                   (IP_ADDR_EQUAL(IF, NULL_IP_ADDR) ||
                    IP_ADDR_EQUAL(IF, LocalNTE->nte_addr))) ||
                  (LocalNTE->nte_if->if_index == IfIndex))))
                break;
        }
        if (LocalNTE != NULL)
            break;
    }

    if (LocalNTE == NULL) {
        // Couldn't find a matching NTE.
        // Search for a valid interface if IF specified was NULL.

        if (IP_ADDR_EQUAL(IF, NULL_IP_ADDR)) {
            for (i = 0; i < NET_TABLE_SIZE; i++) {
                NetTableEntry *NetTableList = NewNetTableList[i];
                for (LocalNTE = NetTableList; LocalNTE != NULL;
                     LocalNTE = LocalNTE->nte_next) {
                    if (!(LocalNTE->nte_flags & NTE_VALID) ||
                        (LocalNTE->nte_if->if_flags & IF_FLAGS_NOLINKBCST))
                        continue;
                    if (LocalNTE != LoopNTE)
                        break;

                }
                if (LocalNTE != NULL)
                    break;
            }
        }
    }

    CTEFreeLock(&RouteTableLock.Lock, Handle);

    return LocalNTE;
}

//** IPSetMCastAddr - Set/Delete a multicast address.
//
//      Called by an upper layer protocol or client to set or delete an IP multicast
//      address.
//
//      Input:  Address    - Address to be set/deleted.
//              IF         - IP Address/IfIndex of interface to set/delete on.
//              Action     - TRUE if we're setting, FALSE if we're deleting.
//              FilterMode - MCAST_INCLUDE or MCAST_EXCLUDE
//              NumSources - number of entries in SourceList array
//              SourceList - array of source addresses
//
//      Returns: IP_STATUS of set/delete attempt.
//
IP_STATUS
IPSetMCastAddr(IPAddr Address, IPAddr IF, uint Action,
               uint NumExclSources, IPAddr *ExclSourceList,
               uint NumInclSources, IPAddr *InclSourceList)
{
    NetTableEntry *LocalNTE;
    uint i;

    // Don't let him do this on the loopback address, since we don't have a
    // route table entry for class D address on the loopback interface and
    // we don't want a packet with a loopback source address to show up on
    // the wire.
    //new scheme for bug 250417
    // We will only enable receive on mcast address on loopback interface.
    // To facilitate this, GetLocalNTE on rcv path will return
    // DEST_MCAST and BcastRcv will check if we are rcving on LoopNTE.
    // So, fake IP_SUCCESS if this is a loopback NTE.
    // No need to add/delete igmp addr on this interface though

    if (IP_LOOPBACK_ADDR(IF) || (IF == net_long(LoopIndex))) {
        return IP_SUCCESS;
    }

    LocalNTE = GetMcastNTEFromAddr(IF);

    if (LocalNTE == NULL) {
        // Still can't find matching NTE
        return IP_BAD_REQ;
    }

    return IGMPAddrChange(LocalNTE, Address, Action ? IGMP_ADD : IGMP_DELETE,
                          NumExclSources, ExclSourceList,
                          NumInclSources, InclSourceList);
}

//** IPSetMCastInclude - Add/Delete multicast sources to include.
//
//      Called by an upper layer protocol or client to add or delete IP
//      multicast sources to allow to pass the source filter.
//
//      Input:  GroupAddress      - Group Address to be updated.
//              Interface Address - IP Address/IfIndex of interface.
//              NumAddSources     - Number of entries in AddSourceList
//              AddSourcelist     - Array of sources to add
//              NumDelSources     - Number of entries in DelSourceList
//              DelSourcelist     - Array of sources to delete
//
//      Returns: IP_STATUS of add/delete attempt.
//
IP_STATUS
IPSetMCastInclude(IPAddr GroupAddress, IPAddr InterfaceAddress,
                  uint NumAddSources, IPAddr *AddSourceList,
                  uint NumDelSources, IPAddr *DelSourceList)
{
    NetTableEntry *LocalNTE;
    uint i;

    // Don't let him do this on the loopback address, since we don't have a
    // route table entry for class D address on the loopback interface and
    // we don't want a packet with a loopback source address to show up on
    // the wire.
    //new scheme for bug 250417
    // We will only enable receive on mcast address on loopback interface.
    // To facilitate this, GetLocalNTE on rcv path will return
    // DEST_MCAST and BcastRcv will check if we are rcving on LoopNTE.
    // So, fake IP_SUCCESS if this is a loopback NTE.
    // No need to add/delete igmp addr on this interface though

    if (IP_LOOPBACK_ADDR(InterfaceAddress) ||
        (InterfaceAddress == net_long(LoopIndex))) {
        return IP_SUCCESS;
    }

    LocalNTE = GetMcastNTEFromAddr(InterfaceAddress);

    if (LocalNTE == NULL) {
        // Still can't find matching NTE
        return IP_BAD_REQ;
    }

    return IGMPInclChange(LocalNTE, GroupAddress,
                          NumAddSources, AddSourceList,
                          NumDelSources, DelSourceList);
}

//** IPSetMCastExclude - Add/Delete multicast sources to exclude.
//
//      Called by an upper layer protocol or client to add or delete IP
//      multicast sources to deny in a source filter.
//
//      Input:  GroupAddress      - Group Address to be set/deleted.
//              Interface Address - IP Address/IfIndex of interface.
//              NumAddSources     - Number of entries in AddSourceList
//              AddSourcelist     - Array of sources to add
//              NumDelSources     - Number of entries in DelSourceList
//              DelSourcelist     - Array of sources to delete
//
//      Returns: IP_STATUS of add/delete attempt.
//
IP_STATUS
IPSetMCastExclude(IPAddr GroupAddress, IPAddr InterfaceAddress,
                  uint NumAddSources, IPAddr *AddSourceList,
                  uint NumDelSources, IPAddr *DelSourceList)
{
    NetTableEntry *LocalNTE;
    uint i;

    // Don't let him do this on the loopback address, since we don't have a
    // route table entry for class D address on the loopback interface and
    // we don't want a packet with a loopback source address to show up on
    // the wire.
    //new scheme for bug 250417
    // We will only enable receive on mcast address on loopback interface.
    // To facilitate this, GetLocalNTE on rcv path will return
    // DEST_MCAST and BcastRcv will check if we are rcving on LoopNTE.
    // So, fake IP_SUCCESS if this is a loopback NTE.
    // No need to add/delete igmp addr on this interface though

    if (IP_LOOPBACK_ADDR(InterfaceAddress) ||
        (InterfaceAddress == net_long(LoopIndex))) {
        return IP_SUCCESS;
    }

    LocalNTE = GetMcastNTEFromAddr(InterfaceAddress);

    if (LocalNTE == NULL) {
        // Still can't find matching NTE
        return IP_BAD_REQ;
    }

    return IGMPExclChange(LocalNTE, GroupAddress,
                          NumAddSources, AddSourceList,
                          NumDelSources, DelSourceList);
}

//** IPGetAddrType - Return the type of a address.
//
//  Called by the upper layer to determine the type of a remote address.
//
//  Input:  Address         - The address in question.
//
//  Returns: The DEST type of the address.
//
uchar
IPGetAddrType(IPAddr Address)
{
    return GetAddrType(Address);
}

//** IPGetLocalMTU - Return the MTU for a local address
//
//  Called by the upper layer to get the local MTU for a local address.
//
//  Input:  LocalAddr           - Local address in question.
//          MTU                         - Where to return the local MTU.
//
//  Returns: TRUE if we found the MTU, FALSE otherwise.
//
uchar
IPGetLocalMTU(IPAddr LocalAddr, ushort * MTU)
{
    NetTableEntry *NTE;
    NetTableEntry *NetTableList = NewNetTableList[NET_TABLE_HASH(LocalAddr)];

    for (NTE = NetTableList; NTE != NULL; NTE = NTE->nte_next) {
        if (IP_ADDR_EQUAL(NTE->nte_addr, LocalAddr) &&
            (NTE->nte_flags & NTE_VALID)) {
            // if NTE is valid, nte->if is valid too
            if (NTE->nte_if->if_flags & IF_FLAGS_P2MP) {
                // P2MP Link
                LinkEntry *tmpLink = NTE->nte_if->if_link;
                uint mtu;
                //Determine the minimum MTU

                // if there are no links on this interface, supply the MTU
                // from the interface itself.
                if (!tmpLink) {
                    *MTU = (ushort)NTE->nte_if->if_mtu;
                    return TRUE ;
                }
                ASSERT(tmpLink);
                mtu = tmpLink->link_mtu;

                while (tmpLink) {

                    if (tmpLink->link_mtu < mtu)
                        mtu = tmpLink->link_mtu;
                    tmpLink = tmpLink->link_next;
                }
                *MTU = (ushort) mtu;
            } else {
                *MTU = NTE->nte_mss;
            }
            return TRUE;
        }
    }

    // Special case in case the local address is a loopback address other than
    // 127.0.0.1.
    if (IP_LOOPBACK_ADDR(LocalAddr)) {
        *MTU = LoopNTE->nte_mss;
        return TRUE;
    }
    return FALSE;

}

//** IPUpdateRcvdOptions - Update options for use in replying.
//
//  A routine to update options for use in a reply. We reverse any source route options,
//  and optionally update the record route option. We also return the index into the
//  options of the record route options (if we find one). The options are assumed to be
//  correct - no validation is performed on them. We fill in the caller provided
//  IPOptInfo with the new option buffer.
//
//  Input:  Options     - Pointer to option info structure with buffer to be reversed.
//          NewOptions  - Pointer to option info structure to be filled in.
//          Src         - Source address of datagram that generated the options.
//          LocalAddr   - Local address responding. If this != NULL_IP_ADDR, then
//                          record route and timestamp options will be updated with this
//                          address.
//
//
//  Returns: Index into options of record route option, if any.
//
IP_STATUS
IPUpdateRcvdOptions(IPOptInfo * OldOptions, IPOptInfo * NewOptions, IPAddr Src, IPAddr LocalAddr)
{
    uchar Length, Ptr;
    uchar i;                    // Index variable
    IPAddr UNALIGNED *LastAddr;    // First address in route.
    IPAddr UNALIGNED *FirstAddr;    // Last address in route.
    IPAddr TempAddr;            // Temp used in exchange.
    uchar *Options, OptLength;
    OptIndex Index;                // Optindex used by UpdateOptions.

    Options = CTEAllocMemN(OptLength = OldOptions->ioi_optlength, 'rICT');

    if (!Options)
        return IP_NO_RESOURCES;

    RtlCopyMemory(Options, OldOptions->ioi_options, OptLength);
    Index.oi_srindex = MAX_OPT_SIZE;
    Index.oi_rrindex = MAX_OPT_SIZE;
    Index.oi_tsindex = MAX_OPT_SIZE;

    NewOptions->ioi_flags &= ~IP_FLAG_SSRR;

    i = 0;
    while (i < OptLength) {
        if (Options[i] == IP_OPT_EOL)
            break;

        if (Options[i] == IP_OPT_NOP) {
            i++;
            continue;
        }
        Length = Options[i + IP_OPT_LENGTH];
        switch (Options[i]) {
        case IP_OPT_SSRR:
            NewOptions->ioi_flags |= IP_FLAG_SSRR;
        case IP_OPT_LSRR:
            // Have a source route. We save the last gateway we came through as
            // the new address, reverse the list, shift the list forward one address,
            // and set the Src address as the last gateway in the list.

            // First, check for an empty source route. If the SR is empty
            // we'll skip most of this.
            if (Length != (MIN_RT_PTR - 1)) {
                // A non empty source route.
                // First reverse the list in place.
                Ptr = Options[i + IP_OPT_PTR] - 1 - sizeof(IPAddr);
                LastAddr = (IPAddr *) (&Options[i + Ptr]);
                FirstAddr = (IPAddr *) (&Options[i + IP_OPT_PTR + 1]);
                NewOptions->ioi_addr = *LastAddr;    // Save Last address as
                // first hop of new route.

                while (LastAddr > FirstAddr) {
                    TempAddr = *LastAddr;
                    *LastAddr-- = *FirstAddr;
                    *FirstAddr++ = TempAddr;
                }

                // Shift the list forward one address. We'll copy all but
                // one IP address.
                RtlCopyMemory(&Options[i + IP_OPT_PTR + 1],
                           &Options[i + IP_OPT_PTR + 1 + sizeof(IPAddr)],
                           Length - (sizeof(IPAddr) + (MIN_RT_PTR - 1)));

                // Set source as last address of route.
                *(IPAddr UNALIGNED *) (&Options[i + Ptr]) = Src;
            }
            Options[i + IP_OPT_PTR] = MIN_RT_PTR;    // Set pointer to min legal value.

            i += Length;
            break;
        case IP_OPT_RR:
            // Save the index in case LocalAddr is specified. If it isn't specified,
            // reset the pointer and zero the option.
            Index.oi_rrindex = i;
            if (LocalAddr == NULL_IP_ADDR) {
                RtlZeroMemory(&Options[i + MIN_RT_PTR - 1], Length - (MIN_RT_PTR - 1));
                Options[i + IP_OPT_PTR] = MIN_RT_PTR;
            }
            i += Length;
            break;
        case IP_OPT_TS:
            Index.oi_tsindex = i;

            // We have a timestamp option. If we're not going to update, reinitialize
            // it for next time. For the 'unspecified' options, just zero the buffer.
            // For the 'specified' options, we need to zero the timestamps without
            // zeroing the specified addresses.
            if (LocalAddr == NULL_IP_ADDR) {    // Not going to update, reinitialize.

                uchar Flags;

                Options[i + IP_OPT_PTR] = MIN_TS_PTR;    // Reinitialize pointer.

                Flags = Options[i + IP_TS_OVFLAGS] & IP_TS_FLMASK;    // Get option type.

                Options[i + IP_TS_OVFLAGS] = Flags;        // Clear overflow count.

                switch (Flags) {
                    uchar j;
                    ulong UNALIGNED *TSPtr;

                    // The unspecified types. Just clear the buffer.
                case TS_REC_TS:
                case TS_REC_ADDR:
                    RtlZeroMemory(&Options[i + MIN_TS_PTR - 1], Length - (MIN_TS_PTR - 1));
                    break;

                    // We have a list of addresses specified. Just clear the timestamps.
                case TS_REC_SPEC:
                    // j starts off as the offset in bytes from start of buffer to
                    // first timestamp.
                    j = MIN_TS_PTR - 1 + sizeof(IPAddr);
                    // TSPtr points at timestamp.
                    TSPtr = (ulong UNALIGNED *) & Options[i + j];

                    // Now j is offset of end of timestamp being zeroed.
                    j += sizeof(ulong);
                    while (j <= Length) {
                        *TSPtr++ = 0;
                        j += sizeof(ulong);
                    }
                    break;
                default:
                    break;
                }
            }
            i += Length;
            break;

        default:
            i += Length;
            break;
        }

    }

    if (LocalAddr != NULL_IP_ADDR) {
        UpdateOptions(Options, &Index, LocalAddr);
    }
    NewOptions->ioi_optlength = OptLength;
    NewOptions->ioi_options = Options;
    return IP_SUCCESS;

}

//* ValidRouteOption - Validate a source or record route option.
//
//  Called to validate that a user provided source or record route option is good.
//
//  Entry:  Option      - Pointer to option to be checked.
//          NumAddr     - NumAddr that need to fit in option.
//          BufSize     - Maximum size of option.
//
//  Returns: 1 if option is good, 0 if not.
//
uchar
ValidRouteOption(uchar * Option, uint NumAddr, uint BufSize)
{

    //Make sure that bufsize can hold at least 1 address.

    if (BufSize < (3 + (sizeof(IPAddr) * NumAddr))) {
       return 0;
    }

    if (Option[IP_OPT_LENGTH] < (3 + (sizeof(IPAddr) * NumAddr)) ||
        Option[IP_OPT_LENGTH] > BufSize ||
        ((Option[IP_OPT_LENGTH] - 3) % sizeof(IPAddr)))        // Routing options is too small.

        return 0;

    if (Option[IP_OPT_PTR] != MIN_RT_PTR)    // Pointer isn't correct.

        return 0;

    return 1;
}



//      IPIsValidIndex - Find whether the given index is valid ifindex
//
//      Input:  Index           - Interface index to be checked for.
//
//      Returns: Addr of NTE (or g_validaddr for unnumbered) if found / NULL
//
IPAddr
IPIsValidIndex(uint Index)
{
    Interface *IF;
    CTELockHandle Handle;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    // Walk the list, looking for a matching index.
    for (IF = IFList; IF != NULL; IF = IF->if_next) {
        if (IF->if_index == Index) {
            break;
        }
    }

    // If we found one, return success. Otherwise fail.
    if (IF != NULL) {
        if ((IF->if_flags & IF_FLAGS_NOIPADDR) && IP_ADDR_EQUAL(IF->if_nte->nte_addr, NULL_IP_ADDR)) {
            CTEFreeLock(&RouteTableLock.Lock, Handle);
            return g_ValidAddr;
        } else {
            CTEFreeLock(&RouteTableLock.Lock, Handle);
            return IF->if_nte->nte_addr;
        }
    } else {
        CTEFreeLock(&RouteTableLock.Lock, Handle);
        return NULL_IP_ADDR;
    }
}

//      GetIfIndexFromNTE       - Find the ifindex given the NTE
//
//      Input:  NTE             - NTE
//
//      Returns: IfIndex of NTE if NTE is valid else return 0
//
uint
GetIfIndexFromNTE(void *IPContext, uint Capabilities)
{
    NetTableEntry *NTE = (NetTableEntry *) IPContext;
    uint IFIndex = 0;
    CTELockHandle Handle;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    if (NTE->nte_flags & NTE_VALID) {

        IFIndex = NTE->nte_if->if_index;

        if (Capabilities & IF_CHECK_MCAST) {
            if (NTE->nte_if->if_flags & IF_FLAGS_NOLINKBCST) {
                IFIndex = 0;
            }
        }

        if (Capabilities & IF_CHECK_SEND) {
            if (NTE->nte_if->if_flags & IF_FLAGS_UNI) {
                IFIndex = 0;
            }
        }
    }


    CTEFreeLock(&RouteTableLock.Lock, Handle);


    return IFIndex;
}

//      IPGetMCastIfAddr      - Find a suitable address to use for multicast
//
//      Returns: IP address of NTE else 0
//
IPAddr
IPGetMCastIfAddr()
{
    NetTableEntry *NTE;

    NTE = GetMcastNTEFromAddr(NULL_IP_ADDR);
    if (!NTE) {
        return 0;
    }

    return NTE->nte_addr;
}


//      GetIfIndexFromAddr      - Find the ifindex given the addr
//
//      Input:  Address         - IPAddr or IfIndex in network byte order
//              Capabilities    - Interface capabilities to check against
//
//      Returns:
//                  IfIndex of NTE if NTE->nte_addr equals Addr else 0
//
//
//
ulong
GetIfIndexFromAddr(IPAddr Address, uint Capabilities)
{
    NetTableEntry *NTE;
    uint IFIndex;
    CTELockHandle Handle;

    if (IP_LOOPBACK_ADDR(Address) || (Address == net_long(LoopIndex))) {

        // At present, we only check for mcast capabilities and
        // Loopback adapter supports this. So, no need to check
        // for capabilities.

        return LoopIndex;
    }

    NTE = GetMcastNTEFromAddr(Address);
    if (!NTE) {
        return 0;
    }

    IFIndex = GetIfIndexFromNTE(NTE, Capabilities);

    return IFIndex;
}

//** IPInitOptions - Initialize an option buffer.
//
//      Called by an upper layer routine to initialize an option buffer. We fill
//      in the default values for TTL, TOS, and flags, and NULL out the options
//      buffer and size.
//
//      Input:  Options                 - Pointer to IPOptInfo structure.
//
//      Returns: Nothing.
//
void
IPInitOptions(IPOptInfo * Options)
{
    // Initialize all the option fields
    RtlZeroMemory(Options, sizeof(IPOptInfo));

    Options->ioi_addr = NULL_IP_ADDR;
    Options->ioi_ttl = (uchar) DefaultTTL;
    Options->ioi_tos = (uchar) DefaultTOS;
    Options->ioi_limitbcasts = EnableSendOnSource;
}

//** IPCopyOptions - Copy the user's options into IP header format.
//
//  This routine takes an option buffer supplied by an IP client, validates it, and
//  creates an IPOptInfo structure that can be passed to the IP layer for transmission. This
//  includes allocating a buffer for the options, munging any source route
//  information into the real IP format.
//
//  Note that we never lock this structure while we're using it. This may cause transitory
//  incosistencies while the structure is being updated if it is in use during the update.
//  This shouldn't be a problem - a packet or too might get misrouted, but it should
//  straighten itself out quickly. If this is a problem the client should make sure not
//  to call this routine while it's in the IPTransmit routine.
//
//  Entry:  Options     - Pointer to buffer of user supplied options.
//          Size        - Size in bytes of option buffer
//          OptInfoPtr  - Pointer to IPOptInfo structure to be filled in.
//
//  Returns: A status, indicating whether or not the options were valid and copied.
//
IP_STATUS
IPCopyOptions(uchar * Options, uint Size, IPOptInfo * OptInfoPtr)
{
    uchar *TempOptions;            // Buffer of options we'll build
    uint TempSize;                // Size of options.
    IP_STATUS TempStatus;        // Temporary status
    uchar OptSeen = 0;            // Indicates which options we've seen.

    OptInfoPtr->ioi_addr = NULL_IP_ADDR;

    OptInfoPtr->ioi_flags &= ~IP_FLAG_SSRR;

    if (Size == 0) {
        ASSERT(FALSE);
        OptInfoPtr->ioi_options = (uchar *) NULL;
        OptInfoPtr->ioi_optlength = 0;
        return IP_SUCCESS;
    }
    // Option size needs to be rounded to multiple of 4.
    if ((TempOptions = CTEAllocMemN(((Size & 3) ? (Size & ~3) + 4 : Size), 'sICT')) == (uchar *) NULL)
        return IP_NO_RESOURCES;    // Couldn't get a buffer, return error.

    RtlZeroMemory(TempOptions, ((Size & 3) ? (Size & ~3) + 4 : Size));

    // OK, we have a buffer. Loop through the provided buffer, copying options.
    TempSize = 0;
    TempStatus = IP_PENDING;
    while (Size && TempStatus == IP_PENDING) {
        uint SRSize;            // Size of a source route option.

        switch (*Options) {
        case IP_OPT_EOL:
            TempStatus = IP_SUCCESS;
            break;
        case IP_OPT_NOP:
            TempOptions[TempSize++] = *Options++;
            Size--;
            break;
        case IP_OPT_SSRR:
            if (OptSeen & (OPT_LSRR | OPT_SSRR)) {
                TempStatus = IP_BAD_OPTION;        // We've already seen a record route.

                break;
            }
            OptInfoPtr->ioi_flags |= IP_FLAG_SSRR;
            OptSeen |= OPT_SSRR;    // Fall through to LSRR code.

        case IP_OPT_LSRR:
            if ((*Options == IP_OPT_LSRR) &&
                (OptSeen & (OPT_LSRR | OPT_SSRR))
                ) {
                TempStatus = IP_BAD_OPTION;        // We've already seen a record route.

                break;
            }
            if (*Options == IP_OPT_LSRR)
                OptSeen |= OPT_LSRR;
            if (!ValidRouteOption(Options, 2, Size)) {
                TempStatus = IP_BAD_OPTION;
                break;
            }
            // Option is valid. Copy the first hop address to NewAddr, and move all
            // of the other addresses forward.
            TempOptions[TempSize++] = *Options++;    // Copy option type.

            SRSize = *Options++;
            Size -= SRSize;
            SRSize -= sizeof(IPAddr);
            TempOptions[TempSize++] = (UCHAR) SRSize;
            TempOptions[TempSize++] = *Options++;    // Copy pointer.

            OptInfoPtr->ioi_addr = *(IPAddr UNALIGNED *) Options;
            Options += sizeof(IPAddr);    // Point to address beyond first hop.

            RtlCopyMemory(&TempOptions[TempSize], Options, SRSize - 3);
            TempSize += (SRSize - 3);
            Options += (SRSize - 3);
            break;
        case IP_OPT_RR:
            if (OptSeen & OPT_RR) {
                TempStatus = IP_BAD_OPTION;        // We've already seen a record route.

                break;
            }
            OptSeen |= OPT_RR;
            if (!ValidRouteOption(Options, 1, Size)) {
                TempStatus = IP_BAD_OPTION;
                break;
            }
            SRSize = Options[IP_OPT_LENGTH];
            RtlCopyMemory(&TempOptions[TempSize], Options, SRSize);
            TempSize += SRSize;
            Options += SRSize;
            Size -= SRSize;
            break;
        case IP_OPT_TS:
            {
                uchar Overflow, Flags;

                if (OptSeen & OPT_TS) {
                    TempStatus = IP_BAD_OPTION;        // We've already seen a time stamp

                    break;
                } else if (Size <= IP_TS_OVFLAGS) {
                    TempStatus = IP_BAD_OPTION;
                    break;
                }
                OptSeen |= OPT_TS;
                Flags = Options[IP_TS_OVFLAGS] & IP_TS_FLMASK;
                Overflow = (Options[IP_TS_OVFLAGS] & IP_TS_OVMASK) >> 4;

                if (Overflow || (Flags != TS_REC_TS && Flags != TS_REC_ADDR &&
                                 Flags != TS_REC_SPEC)) {
                    TempStatus = IP_BAD_OPTION;        // Bad flags or overflow value.

                    break;
                }
                SRSize = Options[IP_OPT_LENGTH];
                if (SRSize > Size || SRSize < 8 ||
                    Options[IP_OPT_PTR] != MIN_TS_PTR) {
                    TempStatus = IP_BAD_OPTION;        // Option size isn't good.

                    break;
                }
                RtlCopyMemory(&TempOptions[TempSize], Options, SRSize);
                TempSize += SRSize;
                Options += SRSize;
                Size -= SRSize;
            }
            break;

        case IP_OPT_ROUTER_ALERT:

            //
            // this is a four byte option to tell the router to look at this packet
            // RSVP uses this functionality.
            //

            if (OptSeen & OPT_ROUTER_ALERT) {
                TempStatus = IP_BAD_OPTION;
                break;
            }
            if (*(Options + 1) != ROUTER_ALERT_SIZE) {
                TempStatus = IP_BAD_OPTION;
            } else {

                RtlCopyMemory(&TempOptions[TempSize], Options, ROUTER_ALERT_SIZE);
                OptSeen |= OPT_ROUTER_ALERT;
                TempSize += ROUTER_ALERT_SIZE;
                Options += ROUTER_ALERT_SIZE;
                TempStatus = IP_SUCCESS;
                Size -= ROUTER_ALERT_SIZE;

            }

            break;

        default:
            TempStatus = IP_BAD_OPTION;        // Unknown option, error.

            break;
        }
    }

    if (TempStatus == IP_PENDING)    // We broke because we hit the end of the buffer.

        TempStatus = IP_SUCCESS;    // that's OK.

    if (TempStatus != IP_SUCCESS) {        // We had some sort of an error.

        CTEFreeMem(TempOptions);
        return TempStatus;
    }
    // Check the option size here to see if it's too big. We check it here at the end
    // instead of at the start because the option size may shrink if there are source route
    // options, and we don't want to accidentally error out a valid option.
    TempSize = (TempSize & 3 ? (TempSize & ~3) + 4 : TempSize);
    if (TempSize > MAX_OPT_SIZE) {
        CTEFreeMem(TempOptions);
        return IP_OPTION_TOO_BIG;
    }
    // if this is a call to zero out options (Options = 0)
    // turn off the options in info ptr.

    if ((Size == 4) && (*Options == IP_OPT_EOL)) {
        CTEFreeMem(TempOptions);
        OptInfoPtr->ioi_options = (uchar *) NULL;
        OptInfoPtr->ioi_optlength = 0;

        return IP_SUCCESS;
    }
    OptInfoPtr->ioi_options = TempOptions;
    OptInfoPtr->ioi_optlength = (UCHAR) TempSize;

    return IP_SUCCESS;

}

//**    IPFreeOptions - Free options we're done with.
//
//  Called by the upper layer when we're done with options. All we need to do is free
//  the options.
//
//  Input:  OptInfoPtr      - Pointer to IPOptInfo structure to be freed.
//
//  Returns: Status of attempt to free options.
//
IP_STATUS
IPFreeOptions(IPOptInfo * OptInfoPtr)
{
    if (OptInfoPtr->ioi_options) {
        // We have options to free. Save the pointer and zero the structure field before
        // freeing the memory to try and present race conditions with it's use.
        uchar *TempPtr = OptInfoPtr->ioi_options;

        OptInfoPtr->ioi_options = (uchar *) NULL;
        CTEFreeMem(TempPtr);
        OptInfoPtr->ioi_optlength = 0;
        OptInfoPtr->ioi_addr = NULL_IP_ADDR;
        OptInfoPtr->ioi_flags &= ~IP_FLAG_SSRR;
    }
    return IP_SUCCESS;
}

//**    ipgetinfo - Return pointers to our NetInfo structures.
//
//  Called by upper layer software during init. time. The caller
//  passes a buffer, which we fill in with pointers to NetInfo
//  structures.
//
//  Entry:
//      Buffer - Pointer to buffer to be filled in.
//      Size   - Size in bytes of buffer.
//
//  Returns:
//      Status of command.
//
IP_STATUS
IPGetInfo(IPInfo * Buffer, int Size)
{
    if (Size < sizeof(IPInfo))
        return IP_BUF_TOO_SMALL;    // Not enough buffer space.

    Buffer->ipi_version = IP_DRIVER_VERSION;
    Buffer->ipi_hsize = sizeof(IPHeader);
    Buffer->ipi_xmit = IPTransmit;
    Buffer->ipi_protreg = IPRegisterProtocol;
    Buffer->ipi_openrce = OpenRCE;
    Buffer->ipi_closerce = CloseRCE;
    Buffer->ipi_getaddrtype = IPGetAddrType;
    Buffer->ipi_getlocalmtu = IPGetLocalMTU;
    Buffer->ipi_getpinfo = IPGetPInfo;
    Buffer->ipi_checkroute = IPCheckRoute;
    Buffer->ipi_initopts = IPInitOptions;
    Buffer->ipi_updateopts = IPUpdateRcvdOptions;
    Buffer->ipi_copyopts = IPCopyOptions;
    Buffer->ipi_freeopts = IPFreeOptions;
    Buffer->ipi_qinfo = IPQueryInfo;
    Buffer->ipi_setinfo = IPSetInfo;
    Buffer->ipi_getelist = IPGetEList;
    Buffer->ipi_setmcastaddr = IPSetMCastAddr;
    Buffer->ipi_setmcastinclude = IPSetMCastInclude;
    Buffer->ipi_setmcastexclude = IPSetMCastExclude;
    Buffer->ipi_invalidsrc = InvalidSourceAddress;
    Buffer->ipi_isdhcpinterface = IsDHCPInterface;
    Buffer->ipi_setndisrequest = IPSetNdisRequest;
    Buffer->ipi_largexmit = IPLargeXmit;
    Buffer->ipi_absorbrtralert = IPAbsorbRtrAlert;
    Buffer->ipi_isvalidindex = IPIsValidIndex;
    Buffer->ipi_getifindexfromnte = GetIfIndexFromNTE;
    Buffer->ipi_isrtralertpacket = IsRtrAlertPacket;
    Buffer->ipi_getifindexfromaddr = GetIfIndexFromAddr;
    Buffer->ipi_cancelpackets = IPCancelPackets;
    Buffer->ipi_getmcastifaddr = IPGetMCastIfAddr;
    Buffer->ipi_getipid = GetIPID;
    Buffer->ipi_protdereg = IPDeregisterProtocol;
    return IP_SUCCESS;
}

//** IPTimeout - IP timeout handler.
//
//  The timeout routine called periodically to time out various things, such as entries
//  being reassembled and ICMP echo requests.
//
//  Entry:  Timer       - Timer being fired.
//          Context     - Pointer to NTE being time out.
//
//  Returns: Nothing.
//
void
IPTimeout(CTEEvent * Timer, void *Context)
{
    NetTableEntry *NTE = STRUCT_OF(NetTableEntry, Timer, nte_timer);
    CTELockHandle NTEHandle;
    ReassemblyHeader *PrevRH, *CurrentRH, *TempList = (ReassemblyHeader *) NULL;

    ICMPTimer(NTE);
    IGMPTimer(NTE);
    if (Context) {
        CTEGetLock(&NTE->nte_lock, &NTEHandle);
        PrevRH = STRUCT_OF(ReassemblyHeader, &NTE->nte_ralist, rh_next);
        CurrentRH = PrevRH->rh_next;
        while (CurrentRH) {
            if (--CurrentRH->rh_ttl == 0) {        // This guy timed out.

                PrevRH->rh_next = CurrentRH->rh_next;    // Take him out.

                CurrentRH->rh_next = TempList;    // And save him for later.

                TempList = CurrentRH;
                IPSInfo.ipsi_reasmfails++;
            } else
                PrevRH = CurrentRH;

            CurrentRH = PrevRH->rh_next;
        }

        // We've run the list. If we need to free anything, do it now. This may
        // include sending an ICMP message.
        CTEFreeLock(&NTE->nte_lock, NTEHandle);
        while (TempList) {
            CurrentRH = TempList;
            TempList = CurrentRH->rh_next;
            // If this wasn't sent to a bcast address and we already have the first fragment,
            // send a time exceeded message.
            if (CurrentRH->rh_headersize != 0)
                SendICMPErr(NTE->nte_addr, (IPHeader *) CurrentRH->rh_header, ICMP_TIME_EXCEED,
                            TTL_IN_REASSEM, 0);
            FreeRH(CurrentRH);
        }

        //
        // If the interface is being deleted, then dont re-start the timer
        //
        if (NTE->nte_deleting) {
            NTE->nte_flags &= ~NTE_TIMER_STARTED;
            CTESignal(&NTE->nte_timerblock, NDIS_STATUS_SUCCESS);
        } else {
            CTEStartTimer(&NTE->nte_timer, IP_TIMEOUT, IPTimeout, NULL);
        }
    } else {
        //
        // If the interface is being deleted, then dont re-start the timer
        //
        if (NTE->nte_deleting) {
            NTE->nte_flags &= ~NTE_TIMER_STARTED;
            CTESignal(&NTE->nte_timerblock, NDIS_STATUS_SUCCESS);
        } else {
            CTEStartTimer(&NTE->nte_timer, IP_TIMEOUT, IPTimeout, NTE);
        }
    }
}

//* IPpSetNTEAddr - Set the IP address of an NTE.
//
//  Called by the DHCP client to set or delete the IP address of an NTE. We
//  make sure he's specifiying a valid NTE, then mark it up or down as needed,
//  notify the upper layers of the change if necessary, and then muck with
//  the routing tables.
//
//  Input:  Context - Context of NTE to alter.
//          Addr    - IP address to set.
//          Mask    - Subnet mask for Addr.
//
//  Returns: TRUE if we changed the address, FALSE otherwise.
//
IP_STATUS
IPpSetNTEAddr(NetTableEntry * NTE, IPAddr Addr, IPMask Mask,
              CTELockHandle * RouteTableHandle,
              SetAddrControl * ControlBlock, SetAddrRtn Rtn)
{
    Interface *IF;
    uint(*CallFunc) (struct RouteTableEntry *, void *, void *);
    CTELockHandle NTEHandle;
    NetTableEntry *NetTableList;
    NetTableEntry *CurrNTE, *PrevNTE;
    uint i;

    if (NTE->nte_deleting == 2) {
        CTEFreeLock(&RouteTableLock.Lock, *RouteTableHandle);
        return IP_DEVICE_DOES_NOT_EXIST;
    }
    if (NTE->nte_deleting)
        NTE->nte_deleting = 2;

    IF = NTE->nte_if;
    DHCPActivityCount++;

    DEBUGMSG(DBG_TRACE && DBG_DHCP,
        (DTEXT("+IPpSetNTEAddr(%x, %x, %x, %x, %x, %x) DHCPActivityCount %d\n"),
         NTE, Addr, Mask, RouteTableHandle,
         ControlBlock, Rtn, DHCPActivityCount));

    LOCKED_REFERENCE_IF(IF);

    if (IP_ADDR_EQUAL(Addr, NULL_IP_ADDR)) {
        // We're deleting an address.
        if (NTE->nte_flags & NTE_VALID) {
            // The address is currently valid. Fix that.

            NTE->nte_flags &= ~NTE_VALID;

            //
            // If the old address is in the ATCache, flush it out.
            //
            AddrTypeCacheFlush(NTE->nte_addr);


            if (CTEInterlockedDecrementLong(&(IF->if_ntecount)) == 0) {
                // This is the last one, so we'll need to delete relevant
                // routes.
                CallFunc = DeleteRTEOnIF;
            } else
                CallFunc = InvalidateRCEOnIF;

            CTEFreeLock(&RouteTableLock.Lock, *RouteTableHandle);

            if (IF->if_arpflushate)
                (*(IF->if_arpflushate)) (IF->if_lcontext, NTE->nte_addr);


            StopIGMPForNTE(NTE);

            // Now call the upper layers, and tell them that address is
            // gone. We really need to do something about locking here.
            NotifyAddrChange(NTE->nte_addr, NTE->nte_mask, NTE->nte_pnpcontext,
                             NTE->nte_context, &NTE->nte_addrhandle, NULL, &IF->if_devname, FALSE);

            // Call RTWalk to take the appropriate action on the RTEs.

            RTWalk(CallFunc, IF, NULL);

            // Delete the route to the address itself.
            //DeleteRoute(NTE->nte_addr, HOST_MASK, IPADDR_LOCAL,
            //      LoopNTE->nte_if);

            DelNTERoutes(NTE);
            // Tell the lower interface this address is gone.
            (*IF->if_deladdr) (IF->if_lcontext, LLIP_ADDR_LOCAL, NTE->nte_addr,
                               NULL_IP_ADDR);

            CTEGetLock(&RouteTableLock.Lock, RouteTableHandle);

            if (IP_ADDR_EQUAL(g_ValidAddr, NTE->nte_addr)) {
                NetTableEntry *TempNte;
                uint i;
                //
                // Update the global address
                // First set the global address to 0, so that if there
                // are no valid NTEs left, we will have a global address
                // of 0
                //

                g_ValidAddr = NULL_IP_ADDR;

                for (i = 0; i < NET_TABLE_SIZE; i++) {
                    NetTableList = NewNetTableList[i];
                    for (TempNte = NetTableList;
                         TempNte != NULL;
                         TempNte = TempNte->nte_next) {
                        if (!IP_ADDR_EQUAL(TempNte->nte_addr, NULL_IP_ADDR) &&
                            !IP_LOOPBACK_ADDR(TempNte->nte_addr) &&
                            TempNte->nte_flags & NTE_VALID) {
                            g_ValidAddr = TempNte->nte_addr;
                        }
                    }
                }
            }
        }
        DHCPActivityDone(NTE, IF, RouteTableHandle, TRUE);
        LockedDerefIF(IF);
        CTEFreeLock(&RouteTableLock.Lock, *RouteTableHandle);

        CTEGetLock(&NTE->nte_lock, &NTEHandle);

        if (NTE->nte_rtrlist) {
            IPRtrEntry *rtrentry, *temprtrentry;

            rtrentry = NTE->nte_rtrlist;
            NTE->nte_rtrlist = NULL;
            while (rtrentry) {
                temprtrentry = rtrentry;
                rtrentry = rtrentry->ire_next;
                CTEFreeMem(temprtrentry);
            }
        }
        CTEFreeLock(&NTE->nte_lock, NTEHandle);

        return IP_SUCCESS;
    } else {
        uint Status;

        // We're not deleting, we're setting the address.
        // In the case of unidirectional adapter, NTE was set to valid
        // when the interface was added. If the address is being added on that NTE,
        // and if the nte_addr is NULL_IP_ADDR, allow this address addition.

        if (!(NTE->nte_flags & NTE_VALID) ||
            ((IF->if_flags & IF_FLAGS_NOIPADDR) &&
            (IP_ADDR_EQUAL(NTE->nte_addr, NULL_IP_ADDR)))) {

            uint index;
            NetTableEntry *tmpNTE = NewNetTableList[NET_TABLE_HASH(Addr)];

            //Check for duplicate address

            while (tmpNTE) {
                if ((tmpNTE != NTE) && IP_ADDR_EQUAL(tmpNTE->nte_addr, Addr) && (tmpNTE->nte_flags & NTE_VALID)) {
                    DHCPActivityDone(NTE, IF, RouteTableHandle, TRUE);
                    LockedDerefIF(IF);
                    CTEFreeLock(&RouteTableLock.Lock, *RouteTableHandle);
                    return IP_DUPLICATE_ADDRESS;
                }
                tmpNTE = tmpNTE->nte_next;
            }

            if ((IF->if_flags & IF_FLAGS_MEDIASENSE) && !IF->if_mediastatus) {

                DHCPActivityDone(NTE, IF, RouteTableHandle, TRUE);
                LockedDerefIF(IF);

                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"setting address %x on if %x with disconnected media\n", Addr, IF));
                CTEFreeLock(&RouteTableLock.Lock, *RouteTableHandle);
                return IP_MEDIA_DISCONNECT;
            }
            // The address is invalid. Save the info, mark him as valid,
            // and add the routes.

            if (NTE->nte_addr != Addr) {
                // Move the NTE to proper hash now that address has changed

                NetTableList = NewNetTableList[NET_TABLE_HASH(NTE->nte_addr)];

                PrevNTE = STRUCT_OF(NetTableEntry, &NewNetTableList[NET_TABLE_HASH(NTE->nte_addr)], nte_next);
                for (CurrNTE = NetTableList; CurrNTE != NULL; PrevNTE = CurrNTE, CurrNTE = CurrNTE->nte_next) {
                    if (CurrNTE == NTE) {
                        // found the matching NTE
                        ASSERT(CurrNTE->nte_context == NTE->nte_context);
                        // remove it from this particular hash
                        PrevNTE->nte_next = CurrNTE->nte_next;
                        break;
                    }
                }

                ASSERT(CurrNTE != NULL);
                ASSERT(CurrNTE == NTE);
                // Add the NTE in the proper hash
                NTE->nte_next = NewNetTableList[NET_TABLE_HASH(Addr)];
                NewNetTableList[NET_TABLE_HASH(Addr)] = NTE;
            }
            NTE->nte_addr = Addr;
            NTE->nte_mask = Mask;
            NTE->nte_flags |= NTE_VALID;
            // Turn DHCP flag off since we release the lock for a small interval
            // when do this at the end
            if (NTE->nte_flags & NTE_DHCP) {
                NTE->nte_flags |= NTE_DYNAMIC;
                NTE->nte_flags &= ~NTE_DHCP;
            } else {
                NTE->nte_flags &= ~NTE_DYNAMIC;
            }

            CTEInterlockedIncrementLong(&(IF->if_ntecount));
            index = IF->if_index;

            if (IP_ADDR_EQUAL(g_ValidAddr, NULL_IP_ADDR) &&
                !IP_LOOPBACK(Addr)) {
                //
                // Update the global address
                //

                g_ValidAddr = Addr;
            }
            //
            // If the new address is in the ATCache, flush it out, otherwise
            // TdiOpenAddress may fail.
            //
            AddrTypeCacheFlush(Addr);

            CTEFreeLock(&RouteTableLock.Lock, *RouteTableHandle);

            if (IF->if_arpflushate)
                (*(IF->if_arpflushate)) (IF->if_lcontext, NTE->nte_addr);

            // don't call AddNTERoutes for P2MP link
            // bug - 166836
            if (NTE->nte_if->if_flags & IF_FLAGS_P2MP) {
                Status = TRUE;
                AddNTERoutes(NTE);
            } else {
                if (AddNTERoutes(NTE))
                    Status = TRUE;
                else
                    Status = FALSE;
            }
            // Need to tell the lower layer about it.
            if (Status) {
                Interface *IF = NTE->nte_if;

                //
                // Rtn will be NULL when called from IPSetNTEAddr
                //
                if (Rtn) {
                    ControlBlock->sac_rtn = Rtn;

                    ControlBlock->interface = IF;
                    ControlBlock->nte_context = NTE->nte_context;

                    Status = (*IF->if_addaddr) (IF->if_lcontext, LLIP_ADDR_LOCAL,
                                                Addr, Mask, ControlBlock);
                } else {
                    Status = (*IF->if_addaddr) (IF->if_lcontext, LLIP_ADDR_LOCAL,
                                                Addr, Mask, NULL);
                }
            }
            if (Status == FALSE) {
                // Couldn't add the routes. Recurively mark this NTE as down.
                IPSetNTEAddrEx(NTE->nte_context, NULL_IP_ADDR, 0, NULL, NULL, 0);
                DerefIF(IF);
            } else {
                InitIGMPForNTE(NTE);

                // Now call the upper layers, and tell them that address is
                // is here. We really need to do something about locking here.
                // Modification: We do not notify about address here.We first do the conflict
                // detection and then notify in the completion routine.

                if (!IP_ADDR_EQUAL(Addr, NULL_IP_ADDR)) {
                    SetPersistentRoutesForNTE(
                                              net_long(Addr),
                                              net_long(Mask),
                                              index
                                              );
                }

                if (Status != IP_PENDING) {
                    NotifyAddrChange(NTE->nte_addr, NTE->nte_mask,
                                     NTE->nte_pnpcontext, NTE->nte_context, &NTE->nte_addrhandle,
                                     &(IF->if_configname), &IF->if_devname, TRUE);

                    DerefIF(IF);

                    // notify our clients right here because we rcvd
                    // immediate status from arp.
                    if (Rtn != NULL) {
                        (*Rtn) (ControlBlock, IP_SUCCESS);
                    }
                }
            }

            CTEGetLock(&RouteTableLock.Lock, RouteTableHandle);
            NTE->nte_rtrdisccount = MAX_SOLICITATION_DELAY;
            NTE->nte_rtrdiscstate = NTE_RTRDISC_DELAYING;
        } else {
            LockedDerefIF(IF);
            //
            // This is needed for remote boot -- when the DHCP client starts
            // we already have an address and NTE_VALID is set, but it will
            // try to set the address again. So if the NTE is already valid
            // and the address is the same, just succeed. In a non-remote boot
            // case we should never hit this since the address will always
            // be set to 0 before being changed to something else.
            //

            if ((NTE->nte_addr == Addr) &&
                (NTE->nte_mask == Mask)) {
                DHCPActivityDone(NTE, IF, RouteTableHandle, TRUE);

                CTEFreeLock(&RouteTableLock.Lock, *RouteTableHandle);
                return IP_SUCCESS;
            } else {
                Status = FALSE;
            }
        }

        // If this was enabled for DHCP, clear that flag now.
        DHCPActivityDone(NTE, IF, RouteTableHandle, (IP_PENDING == Status ? FALSE : TRUE));

        CTEFreeLock(&RouteTableLock.Lock, *RouteTableHandle);

        if (Status) {
            return IP_PENDING;
        } else {
            return IP_GENERAL_FAILURE;
        }
    }
}

//* IPSetNTEAddr - Set the IP address of an NTE.
//
//  Wrapper routine for IPpSetNTEAddr
//
//  Input:  Context - Context of NTE to alter.
//          Addr    - IP address to set.
//          Mask    - Subnet mask for Addr.
//
//  Returns: TRUE if we changed the address, FALSE otherwise.
//
uint
IPSetNTEAddr(ushort Context, IPAddr Addr, IPMask Mask)
{
    CTELockHandle Handle;
    uint Status;
    NetTableEntry *NTE;
    uint i;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    for (i = 0; i < NET_TABLE_SIZE; i++) {
        for (NTE = NewNetTableList[i]; NTE != NULL; NTE = NTE->nte_next) {
            if (NTE->nte_context == Context)
                break;
        }
        if (NTE != NULL)
            break;
    }

    if (NTE == NULL || NTE == LoopNTE) {
        // Can't alter the loopback NTE, or one we didn't find.
        CTEFreeLock(&RouteTableLock.Lock, Handle);
        return IP_DEVICE_DOES_NOT_EXIST;
    }
    Status = IPpSetNTEAddr(NTE, Addr, Mask, &Handle, NULL, NULL);
    return (Status);
}

//* IPSetNTEAddrEx - Set the IP address of an NTE.
//
//  Wrapper routine for IPpSetNTEAddr - with address conflict callback
//  context/routine
//
//  Input:  Context - Context of NTE to alter.
//          Addr    - IP address to set.
//          Mask    - Subnet mask for Addr.
//          Type    - Address Type
//
//  Returns: TRUE if we changed the address, FALSE otherwise.
//
uint
IPSetNTEAddrEx(ushort Context, IPAddr Addr, IPMask Mask,
               SetAddrControl *ControlBlock, SetAddrRtn Rtn, ushort Type)
{
    CTELockHandle Handle;
    uint Status;
    NetTableEntry *NTE;
    uint i;

    if (Context == INVALID_NTE_CONTEXT) {
        return IP_DEVICE_DOES_NOT_EXIST;
    }
    CTEGetLock(&RouteTableLock.Lock, &Handle);

    for (i = 0; i < NET_TABLE_SIZE; i++) {
        for (NTE = NewNetTableList[i]; NTE != NULL; NTE = NTE->nte_next) {
            if (NTE->nte_context == Context)
                break;
        }
        if (NTE != NULL)
            break;
    }

    // TCPTRACE(("IP: IPSetNTEAddrEx - context %lx, NTE %lx, IPAddr %lx\n",Context, NTE, Addr ));

    if (NTE == NULL || NTE == LoopNTE || (NTE->nte_flags & NTE_DISCONNECTED)) {

        //if the nte is in media disconnect state, then it should
        //not show up as valid when media is reconnected
        if(NTE)
          NTE->nte_flags &= ~NTE_DISCONNECTED;
        // Can't alter the loopback NTE, or one we didn't find.

        CTEFreeLock(&RouteTableLock.Lock, Handle);
        return IP_DEVICE_DOES_NOT_EXIST;
    }
    if (Type & IP_ADDRTYPE_TRANSIENT) {
        NTE->nte_flags |= NTE_TRANSIENT_ADDR;
    }


    Status = IPpSetNTEAddr(NTE, Addr, Mask, &Handle, ControlBlock, Rtn);


    return (Status);
}

#pragma BEGIN_INIT

extern NetTableEntry *InitLoopback(IPConfigInfo *);

//** InitTimestamp - Intialize the timestamp for outgoing packets.
//
//  Called at initialization time to setup our first timestamp. The timestamp we use
//  is the in ms since midnite GMT at which the system started.
//
//  Input:  Nothing.
//
//  Returns: Nothing.
//
void
InitTimestamp()
{
    ulong GMTDelta;                // Delta in ms from GMT.
    ulong Now;                    // Milliseconds since midnight.

    TimeStamp = 0;

    if ((GMTDelta = GetGMTDelta()) == 0xffffffff) {        // Had some sort of error.

        TSFlag = 0x80000000;
        return;
    }
    if ((Now = GetTime()) > (24L * 3600L * 1000L)) {    // Couldn't get time since midnight.

        TSFlag = net_long(0x80000000);
        return;
    }
    TimeStamp = Now + GMTDelta - CTESystemUpTime();
    TSFlag = 0;
}

//** InitNTE - Initialize an NTE.
//
//  This routine is called during initialization to initialize an NTE. We
//  allocate memory, NDIS resources, etc.
//
//
//  Entry: NTE      - Pointer to NTE to be initalized.
//
//  Returns: 0 if initialization failed, non-zero if it succeeds.
//
int
InitNTE(NetTableEntry * NTE)
{
    Interface *IF;
    NetTableEntry *PrevNTE;

    NTE->nte_ralist = NULL;
    NTE->nte_echolist = NULL;

    //
    // Taken together, the context and instance numbers uniquely identify
    // a network entry, even across boots of the system. The instance number
    // will have to become dynamic if contexts are ever reused.
    //

    NTE->nte_rtrlist = NULL;
    NTE->nte_instance = GetUnique32BitValue();

    // Now link him on the IF chain, and bump the count.
    IF = NTE->nte_if;
    PrevNTE = STRUCT_OF(NetTableEntry, &IF->if_nte, nte_ifnext);
    while (PrevNTE->nte_ifnext != NULL)
        PrevNTE = PrevNTE->nte_ifnext;

    PrevNTE->nte_ifnext = NTE;
    NTE->nte_ifnext = NULL;

    if ((NTE->nte_flags & NTE_VALID) || (IF->if_flags & IF_FLAGS_NOIPADDR)) {
        CTEInterlockedIncrementLong(&(IF->if_ntecount));
    }
    CTEInitTimer(&NTE->nte_timer);

    NTE->nte_flags |= NTE_TIMER_STARTED;
    CTEStartTimer(&NTE->nte_timer, IP_TIMEOUT, IPTimeout, (void *)NULL);

    return TRUE;
}

//** InitInterface - Initialize with an interface.
//
//  Called when we need to initialize with an interface. We set the appropriate NTE
//  info, then register our local address and any appropriate broadcast addresses
//  with the interface. We assume the NTE being initialized already has an interface
//  pointer set up for it. We also allocate at least one TD buffer for use on the interface.
//
//  Input:  NTE     - NTE to initialize with the interface.
//
//  Returns: TRUE is we succeeded, FALSE if we fail.
//
int
InitInterface(NetTableEntry * NTE)
{
    IPMask netmask = IPNetMask(NTE->nte_addr);
    uchar *TDBuffer;            // Pointer to tdbuffer
    PNDIS_PACKET Packet;
    PNDIS_BUFFER TDBufDesc;        // Buffer descriptor for TDBuffer.
    NDIS_STATUS Status;
    Interface *IF;                // Interface for this NTE.
    CTELockHandle Handle;

    IF = NTE->nte_if;

    ASSERT(NTE->nte_mss > sizeof(IPHeader));
    ASSERT(IF->if_mtu > 0);

    NTE->nte_mss = (ushort) MIN((NTE->nte_mss - sizeof(IPHeader)), IF->if_mtu);

    // Allocate resources needed for xfer data calls. The TD buffer has to be as large
    // as any frame that can be received, even though our MSS may be smaller, because we
    // can't control what might be sent at us.
    TDBuffer = CTEAllocMemNBoot((IF->if_mtu + sizeof(IPHeader)), 'tICT');

    if (TDBuffer == (uchar *) NULL)
        return FALSE;

    NdisAllocatePacket(&Status, &Packet, TDPacketPool);
    if (Status != NDIS_STATUS_SUCCESS) {
        CTEFreeMem(TDBuffer);
        return FALSE;
    }
    RtlZeroMemory(Packet->ProtocolReserved, sizeof(TDContext));

    NdisAllocateBuffer(&Status, &TDBufDesc, TDBufferPool, TDBuffer,
                       (IF->if_mtu + sizeof(IPHeader)));
    if (Status != NDIS_STATUS_SUCCESS) {
        NdisFreePacket(Packet);
        CTEFreeMem(TDBuffer);
        return FALSE;
    }
    NdisChainBufferAtFront(Packet, TDBufDesc);

    ((TDContext *) Packet->ProtocolReserved)->tdc_buffer = TDBuffer;

    if (NTE->nte_flags & NTE_VALID) {

        // Add our local IP address.
        if (!(*IF->if_addaddr) (IF->if_lcontext, LLIP_ADDR_LOCAL,
                                NTE->nte_addr, NTE->nte_mask, NULL)) {
            NdisFreePacket(Packet);
            CTEFreeMem(TDBuffer);
            return FALSE;        // Couldn't add local address.

        }
    }
    // Set up the broadcast addresses for this interface, iff we're the
    // 'primary' NTE on the interface.
    if (NTE->nte_flags & NTE_PRIMARY) {

        if (!(*IF->if_addaddr) (IF->if_lcontext, LLIP_ADDR_BCAST,
                                NTE->nte_if->if_bcast, 0, NULL)) {
            NdisFreePacket(Packet);
            CTEFreeMem(TDBuffer);
            return FALSE;        // Couldn't add broadcast address.

        }
    }
    if (IF->if_llipflags & LIP_COPY_FLAG) {
        NTE->nte_flags |= NTE_COPY;
    }
    CTEGetLock(&IF->if_lock, &Handle);
    ((TDContext *) Packet->ProtocolReserved)->tdc_common.pc_link = IF->if_tdpacket;
    IF->if_tdpacket = Packet;
    CTEFreeLock(&IF->if_lock, Handle);

    return TRUE;
}

//* FreeNets - Free nets we have allocated.
//
//  Called during init time if initialization fails. We walk down our list
//  of nets, and free them.
//
//  Input:  Nothing.
//
//  Returns: Nothing.
//
void
FreeNets(void)
{
    NetTableEntry *NTE;
    NetTableEntry *pNextNTE;
    uint i;

    for (i = 0; i < NET_TABLE_SIZE; i++) {
        for (NTE = NewNetTableList[i]; NTE != NULL;) {
            pNextNTE = NTE->nte_next;

            // Make sure we don't free memory that are holding timers that
            // are running.
            //
            if ((NTE->nte_flags & NTE_TIMER_STARTED) &&
                !CTEStopTimer(&NTE->nte_timer)) {
                (VOID) CTEBlock(&NTE->nte_timerblock);
                KeClearEvent(&NTE->nte_timerblock.cbs_event);
            }

            CTEFreeMem(NTE);
            NTE = pNextNTE;
        }
    }
}

extern uint GetGeneralIFConfig(IFGeneralConfig * GConfigInfo,
                               NDIS_HANDLE Handle,
                               PNDIS_STRING ConfigName);
extern IFAddrList *GetIFAddrList(uint * NumAddr, NDIS_HANDLE Handle,
                                 uint * EnableDhcp, BOOLEAN PppIf,
                                 PNDIS_STRING ConfigName);

//* NotifyElistChange
void
NotifyElistChange()
{
    int i;
    ULElistProc ElistProc;

    for (i = 0; i < NextPI; i++) {
        if (IPProtInfo[i].pi_valid == PI_ENTRY_VALID) {
            ElistProc = IPProtInfo[i].pi_elistchange;
            if (ElistProc != NULL)
                (*ElistProc) ();
        }
    }
}

//* NotifyAddrChange - Notify clients of a change in addresses.
//
//  Called when we want to notify registered clients that an address has come
//  or gone. We call TDI to perform this function.
//
//  Input:
//      Addr        - Addr that has changed.
//      Mask        - Mask that has changed.
//      Context     - PNP context for address
//      IPContext   - NTE context for NTE
//      Handle      - Pointer to where to get/set address registration
//                    handle
//      ConfigName  - Registry name to use to retrieve config info.
//      Added       - True if the addr is coming, False if it's going.
//
//  Returns: Nothing.
//
void
NotifyAddrChange(IPAddr Addr, IPMask Mask, void *Context, ushort IPContext,
                 PVOID * Handle, PNDIS_STRING ConfigName, PNDIS_STRING IFName,
                 uint Added)
{
    uchar Address[sizeof(TA_ADDRESS) + sizeof(TDI_ADDRESS_IP)];
    PTA_ADDRESS AddressPtr;
    PTDI_ADDRESS_IP IPAddressPtr;
    NTSTATUS Status;
    IP_STATUS StatusType;
    NDIS_HANDLE ConfigHandle = NULL;
    int i;
    ULStatusProc StatProc;

    DEBUGMSG(DBG_TRACE && DBG_NOTIFY,
        (DTEXT("+NotifyAddrChange(%x, %x, %x, %x, %x, %X, %X, %x)\n"),
         Addr, Mask, Context, IPContext,
         Handle, ConfigName, IFName, Added));

    // notify UL about possible entity list change.
    NotifyElistChange();

    AddressPtr = (PTA_ADDRESS) Address;

    AddressPtr->AddressLength = sizeof(TDI_ADDRESS_IP);
    AddressPtr->AddressType = TDI_ADDRESS_TYPE_IP;

    IPAddressPtr = (PTDI_ADDRESS_IP) AddressPtr->Address;

    RtlZeroMemory(IPAddressPtr, sizeof(TDI_ADDRESS_IP));

    IPAddressPtr->in_addr = Addr;

    //
    // Call the status entrypoint of the transports so they can
    // adjust their security filters.
    //
    if (Added) {
        StatusType = IP_ADDR_ADDED;

        //
        // Open a configuration key
        //
        if (!OpenIFConfig(ConfigName, &ConfigHandle)) {
            //
            // Not much we can do. The transports will have
            // to handle this.
            //
            ASSERT(ConfigHandle == NULL);
        }
    } else {
        StatusType = IP_ADDR_DELETED;
    }

    for (i = 0; i < NextPI; i++) {
        StatProc = IPProtInfo[i].pi_status;
        if (StatProc != NULL)
            (*StatProc) (IP_HW_STATUS, StatusType, Addr, NULL_IP_ADDR,
                         NULL_IP_ADDR, 0, ConfigHandle);
    }

    if (ConfigHandle != NULL) {
        CloseIFConfig(ConfigHandle);
    }

    //
    // Notify any interested parties via TDI. The transports all register
    // for this notification as well.
    //
    if (Added) {
        PTDI_PNP_CONTEXT tdiPnPContext2;

        if (Addr) {
            //ASSERT (*Handle == NULL);
            tdiPnPContext2 = CTEAllocMemNBoot(sizeof(TDI_PNP_CONTEXT) + sizeof(PVOID) - 1, 'uICT');

            if (tdiPnPContext2) {

                PVOID RegHandle;

                tdiPnPContext2->ContextSize = sizeof(PVOID);
                tdiPnPContext2->ContextType = TDI_PNP_CONTEXT_TYPE_PDO;
                *(PVOID UNALIGNED *) tdiPnPContext2->ContextData = Context;

                Status = TdiRegisterNetAddress(AddressPtr, IFName, tdiPnPContext2, &RegHandle);

                *Handle = RegHandle;

                CTEFreeMem(tdiPnPContext2);

                if (Status != STATUS_SUCCESS) {
                    *Handle = NULL;
                }
            }
        }
    } else {
        if (*Handle != NULL) {
            PVOID RegHandle = *Handle;
            *Handle = NULL;
            TdiDeregisterNetAddress(RegHandle);

        }
    }

#if MILLEN
    AddChangeNotify(
        Addr,
        Mask,
        Context,
        IPContext,
        ConfigName,
        IFName,
        Added,
        FALSE); // Not a uni-directional adapter!
#else // MILLEN
    AddChangeNotify(Addr);
#endif // !MILLEN
    DEBUGMSG(DBG_TRACE && DBG_NOTIFY, (DTEXT("-NotifyAddrChange\n")));
}

//* IPAddNTE - Add a new NTE to an interface
//
//  Called to create a new network entry on an interface.
//
//  Input:
//      GConfigInfo   - Configuration information for the interface
//      PNPContext    - The PNP context value associated with the interface
//      RegRtn        - Routine to call to register with ARP.
//      BindInfo      - Pointer to NDIS bind information.
//      IF            - The interface on which to create the NTE.
//      NewAddr       - The address of the new NTE.
//      NewMask       - The subnet mask for the new NTE.
//      IsPrimary     - TRUE if this NTE is the primary one on the interface
//      IsDynamic     - TRUE if this NTE is being created on an
//                      existing interface instead of a new one.
//
//  Returns: A pointer to the new NTE if the operation succeeds.
//       NULL if the operation fails.
//
NetTableEntry *
IPAddNTE(IFGeneralConfig * GConfigInfo, void *PNPContext, LLIPRegRtn RegRtn,
         LLIPBindInfo * BindInfo, Interface * IF, IPAddr NewAddr, IPMask NewMask,
         uint IsPrimary, uint IsDynamic)
{
    NetTableEntry *NTE, *PrevNTE, *tmpNTE;
    CTELockHandle Handle;
    BOOLEAN Duplicate = FALSE, GotNTE = FALSE, RegRtnCalled = FALSE;
    IP_HANDLERS ipHandlers;
    NetTableEntry *NetTableList;
    uint i;

    DEBUGMSG(DBG_TRACE && DBG_PNP,
        (DTEXT("+IPAddNTE(%x, %x, %x, %x, %x, %x, %x, %x, %x)\n"),
        GConfigInfo, PNPContext, RegRtn,
        BindInfo, IF, NewAddr, NewMask, IsPrimary, IsDynamic));


    // If the address is invalid we're done. Fail the request.
    if (CLASSD_ADDR(NewAddr) || CLASSE_ADDR(NewAddr)) {
        DEBUGMSG(DBG_ERROR && DBG_PNP, (DTEXT("IPAddNTE: Invalid address\n")));
        DEBUGMSG(DBG_TRACE && DBG_PNP, (DTEXT("-IPAddNTE [NULL]\n")));
        return NULL;
    }
    // See if we have an inactive NTE on the NetTableList. If we do, we'll
    // just recycle that. We will pull him out of the list. This is not
    // strictly MP safe, since other people could be walking the list while
    // we're doing this without holding a lock, but it should be harmless.
    // The removed NTE is marked as invalid, and his next pointer will
    // be nulled, so anyone walking the list might hit the end too soon,
    // but that's all. The memory is never freed, and the next pointer is
    // never pointed at freed memory.

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    NetTableList = NewNetTableList[NET_TABLE_HASH(NewAddr)];
    for (NTE = NetTableList; NTE != NULL; NTE = NTE->nte_next) {

        if (IP_ADDR_EQUAL(NTE->nte_addr, NewAddr) && !IP_ADDR_EQUAL(NTE->nte_addr, NULL_IP_ADDR)) {
            Duplicate = TRUE;
            break;
        }
    }

    if (Duplicate) {
        CTEFreeLock(&RouteTableLock.Lock, Handle);
        DEBUGMSG(DBG_ERROR && DBG_PNP, (DTEXT("IPAddNTE: Duplicate IP address\n")));
        DEBUGMSG(DBG_TRACE && DBG_PNP, (DTEXT("-IPAddNTE [NULL]\n")));
        return (NULL);
    }
    // can do both stuff in 1 loop though

    for (i = 0; i < NET_TABLE_SIZE; i++) {
        NetTableList = NewNetTableList[i];
        PrevNTE = STRUCT_OF(NetTableEntry, &NewNetTableList[i], nte_next);
        for (NTE = NetTableList; NTE != NULL; PrevNTE = NTE, NTE = NTE->nte_next) {
            if (!GotNTE && !(NTE->nte_flags & NTE_ACTIVE)) {
                PrevNTE->nte_next = NTE->nte_next;
                NTE->nte_next = NULL;
                NumNTE--;
                GotNTE = TRUE;
                tmpNTE = NTE;
            }
        }
        if (GotNTE)
            break;
    }

    //
    // Update the global address
    //

    if (IP_ADDR_EQUAL(g_ValidAddr, NULL_IP_ADDR) &&
        !IP_LOOPBACK(NewAddr) &&
        !IP_ADDR_EQUAL(NewAddr, NULL_IP_ADDR)) {
        //
        // Update the global address
        //

        g_ValidAddr = NewAddr;
    }
    CTEFreeLock(&RouteTableLock.Lock, Handle);

    // See if we got one.
    if (!GotNTE) {
        // Didn't get one. Try to allocate one.
        NTE = CTEAllocMemNBoot(sizeof(NetTableEntry), 'vICT');
        if (NTE == NULL) {
            DEBUGMSG(DBG_ERROR && DBG_PNP, (DTEXT("IPAddNTE: Failed to allocate NTE.\n")));
            DEBUGMSG(DBG_TRACE && DBG_PNP, (DTEXT("-IPAddNTE [NULL]\n")));
            return NULL;
        }
    } else {
        NTE = tmpNTE;
    }

    DEBUGMSG(DBG_INFO && DBG_PNP,
        (DTEXT("IPAddNTE: NTE %x allocated/reused. Initializing...\n")));

    // Initialize the address and mask stuff
    CTEInitTimer(&NTE->nte_timer);

    RtlZeroMemory(NTE, sizeof(NetTableEntry));

    NTE->nte_addr = NewAddr;
    NTE->nte_mask = NewMask;
    NTE->nte_mss = MAX(GConfigInfo->igc_mtu, 68);
    NTE->nte_rtrdiscaddr = GConfigInfo->igc_rtrdiscaddr;
    NTE->nte_rtrdiscstate = NTE_RTRDISC_UNINIT;
    NTE->nte_rtrdisccount = 0;
    NTE->nte_rtrdiscovery =
        (GConfigInfo->igc_rtrdiscovery == IP_IRDP_ENABLED) ? TRUE : FALSE;
    NTE->nte_rtrlist = NULL;
    NTE->nte_pnpcontext = PNPContext;
    NTE->nte_if = IF;
    NTE->nte_flags = NTE_ACTIVE;

    //
    // If the new address is in the ATCache, flush it out, otherwise
    // TdiOpenAddress may fail.
    //
    AddrTypeCacheFlush(NewAddr);

    if (!IP_ADDR_EQUAL(NTE->nte_addr, NULL_IP_ADDR)) {
        NTE->nte_flags |= NTE_VALID;
        NTE->nte_rtrdisccount = MAX_SOLICITATION_DELAY;
        NTE->nte_rtrdiscstate = NTE_RTRDISC_DELAYING;
    }
    if (IsDynamic) {
        NTE->nte_flags |= NTE_DYNAMIC;
    }
    NTE->nte_ralist = NULL;
    NTE->nte_echolist = NULL;
    NTE->nte_icmpseq = 0;
    NTE->nte_igmplist = NULL;
    NTE->nte_igmpcount = 0;
    CTEInitLock(&NTE->nte_lock);

    if (IsPrimary) {
        //
        // This is the first (primary) NTE on the interface.
        //
        NTE->nte_flags |= NTE_PRIMARY;

        // Pass our information to the underlying code.
        ipHandlers.IpRcvHandler = IPRcv;
        ipHandlers.IpRcvPktHandler = IPRcvPacket;
        ipHandlers.IpRcvCompleteHandler = IPRcvComplete;
        ipHandlers.IpTxCompleteHandler = IPSendComplete;
        ipHandlers.IpTransferCompleteHandler = IPTDComplete;
        ipHandlers.IpStatusHandler = IPStatus;
        ipHandlers.IpAddAddrCompleteRtn = IPAddAddrComplete;

        ipHandlers.IpPnPHandler = IPPnPEvent;    // IPPnPIndication;

        if (!(*RegRtn) (&(IF->if_configname),
                        NTE,
                        &ipHandlers,
                        BindInfo,
                        IF->if_index)) {

            DEBUGMSG(DBG_ERROR && DBG_PNP,
                (DTEXT("IPAddNTE: Failed to register with LLIPRegRtn.\n")));

            // Couldn't register.
            goto failure;
        } else {
            RegRtnCalled = TRUE;
        }
    }                            //primary
    //
    // Link the NTE onto the global NTE list.
    //

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    NTE->nte_next = NewNetTableList[NET_TABLE_HASH(NewAddr)];
    NewNetTableList[NET_TABLE_HASH(NewAddr)] = NTE;
    NumNTE++;
    NumActiveNTE++;

    NTE->nte_context = (ushort) RtlFindClearBitsAndSet(&g_NTECtxtMap,1,0);

    CTEFreeLock(&RouteTableLock.Lock, Handle);


    if (NTE->nte_context == MAX_NTE_CONTEXT) {

        goto failure;
    }

    if (!InitInterface(NTE)) {
        DEBUGMSG(DBG_ERROR && DBG_PNP,
            (DTEXT("IPAddNTE: InitInterface failure.\n")));
        goto failure;
    }
    if (!InitNTE(NTE)) {
        DEBUGMSG(DBG_ERROR && DBG_PNP,
            (DTEXT("IPAddNTE: InitNTE failure.\n")));
        goto failure;
    }

    if (NTE->nte_if->if_flags & IF_FLAGS_UNI) {
        // No routes required for uni-direction address.
        DEBUGMSG(DBG_TRACE && DBG_PNP,
            (DTEXT("-IPAddNTE [Unidirectional NTE %x]\n"), NTE));
        return (NTE);
    }

    if (!(NTE->nte_if->if_flags & IF_FLAGS_NOIPADDR)) {
        if (!InitNTERouting(NTE, GConfigInfo->igc_numgws, GConfigInfo->igc_gw,
                            GConfigInfo->igc_gwmetric)) {
            // Couldn't add the routes for this NTE. Mark him as not valid.
            // Probably should log an event here.
            if (NTE->nte_flags & NTE_VALID) {
                NTE->nte_flags &= ~NTE_VALID;
                CTEInterlockedDecrementLong(&(NTE->nte_if->if_ntecount));
                goto failure;
            }
        }
    }

    if (!IP_ADDR_EQUAL(NTE->nte_addr, NULL_IP_ADDR)) {
        SetPersistentRoutesForNTE(
                                  net_long(NTE->nte_addr),
                                  net_long(NTE->nte_mask),
                                  NTE->nte_if->if_index
                                  );
    }

    DEBUGMSG(DBG_TRACE && DBG_PNP, (DTEXT("-IPAddNTE [%x]\n"), NTE));

    return (NTE);

  failure:

    //
    // Don't free the NTE, it will be re-used. However, there is still
    // a timing window on failure that can access the invalid NTE since
    // this isn't done under lock and key.
    //

    if (RegRtnCalled) {
        (*(IF->if_close)) (IF->if_lcontext);
    }

    if (NTE->nte_flags & NTE_TIMER_STARTED) {

        CTEStopTimer(&NTE->nte_timer);
        NTE->nte_flags &= ~NTE_TIMER_STARTED;
    }

    if (NTE->nte_flags & NTE_VALID) {
        NTE->nte_flags &= ~NTE_VALID;
        CTEInterlockedDecrementLong(&(NTE->nte_if->if_ntecount));
    }
    NTE->nte_flags &= ~NTE_ACTIVE;

    // Remove this NTE if it is on IFlist.

    if (IF && NTE->nte_ifnext) {
        NetTableEntry *PrevNTE;
        PrevNTE = STRUCT_OF(NetTableEntry, &IF->if_nte, nte_ifnext);
        CTEGetLock(&RouteTableLock.Lock, &Handle);
            while (PrevNTE->nte_ifnext != NULL) {
                if (PrevNTE->nte_ifnext == NTE) {
                    PrevNTE->nte_ifnext = NTE->nte_ifnext;
                    break;
                }
                PrevNTE = PrevNTE->nte_ifnext;
            }
        CTEFreeLock(&RouteTableLock.Lock, Handle);
    }
    NTE->nte_if = NULL;
    DEBUGMSG(DBG_TRACE && DBG_PNP, (DTEXT("-IPAddNTE [NULL]\n")));

    return (NULL);
}

//* IPAddDynamicNTE - Add a new "dynamic" NTE to an existing interface
//
//  Called to dynamically create a new network entry on an existing interface.
//  This entry was not configured when the interaface was originally created
//  and will not persist if the interface is unbound.
//
//  Input:  InterfaceContext  - The context value which identifies the
//                                  interface on which to create the NTE.
//          InterfaceName     - The interface name to use when InterfaceContext
//                                is 0xffff
//          InterfaceNameLen  - The actaul length of the interface name contained
//                              in the IO buffer.
//          NewAddr           - The address of the new NTE.
//          NewMask           - The subnet mask for the new NTE.
//
//  Output: NTEContext    - The context identifying the new NTE.
//          NTEInstance   - The instance number which (reasonably) uniquely
//                              identifies this NTE in time.
//
//  Returns: Nonzero if the operation succeeded. Zero if it failed.
//
IP_STATUS
IPAddDynamicNTE(ulong InterfaceContext, PNDIS_STRING InterfaceName,
                int InterfaceNameLen, IPAddr NewAddr, IPMask NewMask,
                ushort * NTEContext, ulong * NTEInstance)
 {
    IFGeneralConfig GConfigInfo;    // General config info structure.
    NDIS_HANDLE ConfigHandle;    // Configuration handle.
    NetTableEntry *NTE;
    Interface *IF, *DuplicateIF;
    ushort MTU;
    uint Flags = 0;
    NTSTATUS writeStatus;
    CTELockHandle Handle;
    BOOLEAN Duplicate = FALSE;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    if ((InterfaceContext == INVALID_INTERFACE_CONTEXT) && InterfaceName &&
        InterfaceName->Length <= InterfaceNameLen) {
        for (IF = IFList; IF != NULL; IF = IF->if_next) {
            if ((IF->if_refcount != 0) && (IF->if_devname.Length == InterfaceName->Length) &&
                RtlEqualMemory(IF->if_devname.Buffer, InterfaceName->Buffer, IF->if_devname.Length)) {
                break;
            }
        }
    } else {
        for (IF = IFList; IF != NULL; IF = IF->if_next) {
            if ((IF->if_refcount != 0) && (IF->if_index == InterfaceContext) && (IF != &LoopInterface)) {
                break;
            }
        }

    }

    if (IF) {
        LOCKED_REFERENCE_IF(IF);

        //check for duplicate
        //This is required to return duplicate error immdtly.
        //Note that this check is already done in IPAddNTE.
        //But being duplicated here to prevent change in IpAddNTE
        //just for passing this status...

        NetTableList = NewNetTableList[NET_TABLE_HASH(NewAddr)];
        for (NTE = NetTableList; NTE != NULL; NTE = NTE->nte_next) {

            if (IP_ADDR_EQUAL(NTE->nte_addr, NewAddr) && !IP_ADDR_EQUAL(NTE->nte_addr, NULL_IP_ADDR)) {
                Duplicate = TRUE;
                DuplicateIF = NTE->nte_if;
                break;
            }
        }
    }
    CTEFreeLock(&RouteTableLock.Lock, Handle);

    if (IF == NULL) {
        return IP_DEVICE_DOES_NOT_EXIST;
    }
    if (Duplicate) {
        if (IF == DuplicateIF) {

            DerefIF(IF);
            return IP_DUPLICATE_IPADD;
        } else {
            DerefIF(IF);
            return IP_DUPLICATE_ADDRESS;

        }
    }

    if (!IF->if_mediastatus) {
        DerefIF(IF);
        return IP_MEDIA_DISCONNECT;
    }

    //* Try to get the network configuration information.
    if (!OpenIFConfig(&(IF->if_configname), &ConfigHandle)) {
        DerefIF(IF);
        return IP_GENERAL_FAILURE;
    }
    // Try to get our general config information.
    if (!GetGeneralIFConfig(&GConfigInfo, ConfigHandle, &IF->if_configname)) {
        goto failure;
    }
    NTE = IPAddNTE(&GConfigInfo,
                   NULL,        // PNPContext
                   NULL,        // RegRtn - not needed if not primary
                   NULL,        // BindInfo - not needed if not primary
                   IF,
                   NewAddr,
                   NewMask,
                   FALSE,       // not primary
                   TRUE         // is dynamic
                   );

    if (NTE == NULL) {
        goto failure;
    }

    writeStatus = IPAddNTEContextList(ConfigHandle,
                                      NTE->nte_context,
                                      FALSE        // no primary
                                      );

    if (!NT_SUCCESS(writeStatus)) {
        CTELogEvent(IPDriverObject,
                    EVENT_TCPIP_NTE_CONTEXT_LIST_FAILURE,
                    2,
                    1,
                    &IF->if_devname.Buffer,
                    0,
                    NULL
                    );

        TCPTRACE((
                  "IP: Unable to read or write the NTE Context list for adapter %ws\n"
                  "   (status %lx).IP interfaces on this adapter may not be initialized completely \n",
                  IF->if_devname.Buffer,
                  writeStatus
                 ));
    }

    CloseIFConfig(ConfigHandle);

    //
    // Notify upper layers of the new address.
    //
    NotifyAddrChange(NTE->nte_addr, NTE->nte_mask, NTE->nte_pnpcontext,
                     NTE->nte_context, &NTE->nte_addrhandle, &(IF->if_configname), &IF->if_devname, TRUE);
    if (!IP_ADDR_EQUAL(NTE->nte_addr, NULL_IP_ADDR)) {
        InitIGMPForNTE(NTE);
    }
    //
    // Fill in the out parameter value.
    //
    *NTEContext = NTE->nte_context;
    *NTEInstance = NTE->nte_instance;

    DerefIF(IF);

    return (STATUS_SUCCESS);

  failure:

    DerefIF(IF);
    CloseIFConfig(ConfigHandle);
    return (IP_GENERAL_FAILURE);
}

void
IncrInitTimeInterfaces(Interface * IF)
{
    CTELockHandle Handle;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    if (InitTimeInterfacesDone == FALSE) {
        InitTimeInterfaces++;
        IF->if_InitInProgress = TRUE;
    }
    CTEFreeLock(&RouteTableLock.Lock, Handle);
    // TCPTRACE(("IP: New init Interface %lx, Total InitTimeInterfaces %lx\n", IF, InitTimeInterfaces));
}

void
DecrInitTimeInterfaces(Interface * IF)
{
    CTELockHandle Handle;
    uint Decr;

    CTEGetLock(&RouteTableLock.Lock, &Handle);
    Decr = FALSE;

    // IF would be NULL if this is called when we receive bindcomplete event from ndis.
    // since ndis may give multiple bind complete events, we need to ignore any subsequent
    // events after InitTimeInterfacesDone is true.
    // similarly we decrement InitTimeInterfaces counter only for those interfaces
    // for which if_InitInProgress is true.
    if (IF) {
        if (IF->if_InitInProgress) {
            IF->if_InitInProgress = FALSE;
            Decr = TRUE;
        }
    } else {

        BOOLEAN CheckForProviderReady = FALSE;

        //
        // ReEnumerateNdisBinding results in
        // NdisBindComplete event that needs
        // to be ignored.
        //

        if (InterlockedDecrement(&ReEnumerateCount) < 0) {
            CheckForProviderReady = TRUE;
        }

        if (CheckForProviderReady &&
            (FALSE == InitTimeInterfacesDone)) {
            InitTimeInterfacesDone = TRUE;
            Decr = TRUE;
        }

    }
    if (Decr) {
        ASSERT(InitTimeInterfaces);

        --InitTimeInterfaces;
        //TCPTRACE(("IP: Decremented init Interface %lx, Total InitTimeInterfaces %lx\n", IF,InitTimeInterfaces));
        if (!InitTimeInterfaces) {
            CTEFreeLock(&RouteTableLock.Lock, Handle);
            // TdiProviderReady();
            TdiProviderReady(IPProviderHandle);
            return;
        }
    }
    CTEFreeLock(&RouteTableLock.Lock, Handle);
}

//*     RePlumbStaticAddr - Add static routes o media connect.
//
//
//      Input:  AddAddrEvent
//              Context
//
//      Returns: none.
//

void
RePlumbStaticAddr(CTEEvent * Event, PVOID Context)
{
    AddStaticAddrEvent *AddAddrEvent = (AddStaticAddrEvent *) Context;
    Interface *IF = NULL;
    NDIS_HANDLE Handle;
    CTELockHandle TableHandle;
    IFAddrList *AddrList;
    uint i, j, NumAddr = 0;
    uint EnableDhcp = TRUE;
    IFGeneralConfig GConfigInfo;
    NTSTATUS Status;
    IP_STATUS ipstatus;
    NetTableEntry *NTE;
    uint index;



    //
    //reset the interface metric when it is in auto mode, in case of a speed change
    //
    if (AddAddrEvent->IF) {
        // get lock
        CTEGetLock(&RouteTableLock.Lock, &TableHandle);

        if ((AddAddrEvent->IF->if_auto_metric) && (AddAddrEvent->IF->if_dondisreq)) {
            uint speed;
            LOCKED_REFERENCE_IF(AddAddrEvent->IF);
            CTEFreeLock(&RouteTableLock.Lock, TableHandle);
            if ((*AddAddrEvent->IF->if_dondisreq)(
                                                  AddAddrEvent->IF->if_lcontext,
                                                  NdisRequestQueryInformation,
                                                  OID_GEN_LINK_SPEED,
                                                  &speed,
                                                  sizeof(speed),
                                                  NULL,
                                                  TRUE) == NDIS_STATUS_SUCCESS) {
                speed *= 100L;
                //actual speed is 100 times what we got from the query
                CTEGetLock(&RouteTableLock.Lock, &TableHandle);
                if (speed != AddAddrEvent->IF->if_speed) {
                    AddAddrEvent->IF->if_speed = speed;
                    AddAddrEvent->IF->if_metric = GetAutoMetric(speed);
                }
                LockedDerefIF(AddAddrEvent->IF);
                CTEFreeLock(&RouteTableLock.Lock, TableHandle);
            } else {
                DerefIF(AddAddrEvent->IF);
            }
        } else {
            CTEFreeLock(&RouteTableLock.Lock, TableHandle);
        }
    }

    if (!OpenIFConfig(&AddAddrEvent->ConfigName, &Handle)) {

        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"RePlumbStaticAddr: Failed to Open config info\n"));
        if (AddAddrEvent->ConfigName.Buffer) {
            CTEFreeMem(AddAddrEvent->ConfigName.Buffer);
        }

        // Undo the refcount that was taken when ReplumbStaticAddr
        // was scheduled.
        if (AddAddrEvent->IF) {
            DerefIF(AddAddrEvent->IF);
        }

        CTEFreeMem(AddAddrEvent);
        return;
    }
    if (!GetGeneralIFConfig(&GConfigInfo, Handle, &AddAddrEvent->ConfigName)) {

        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"RePlumbStaticAddr: Failed to get configinfo\n"));
        if (AddAddrEvent->ConfigName.Buffer) {
            CTEFreeMem(AddAddrEvent->ConfigName.Buffer);
        }

        // Undo the refcount that was taken when ReplumbStaticAddr
        // was scheduled.
        if (AddAddrEvent->IF) {
            DerefIF(AddAddrEvent->IF);
        }

        CTEFreeMem(AddAddrEvent);
        CloseIFConfig(Handle);
        return;
    }
    AddrList = GetIFAddrList(&NumAddr, Handle, &EnableDhcp, FALSE,
                             &AddAddrEvent->ConfigName);

    // AddrList is not used, free it here.
    if (AddrList) {
        CTEFreeMem(AddrList);
    }

    if (EnableDhcp || !NumAddr) {

        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"RePlumbStaticAddr: No static routes(or dhcpenabled) on this interface %x\n", AddAddrEvent->IF));
        if (AddAddrEvent->ConfigName.Buffer) {
            CTEFreeMem(AddAddrEvent->ConfigName.Buffer);
        }

        // Undo the refcount that was taken when ReplumbStaticAddr
        // was scheduled.
        if (AddAddrEvent->IF) {
            DerefIF(AddAddrEvent->IF);
        }

        CTEFreeMem(AddAddrEvent);
        CloseIFConfig(Handle);
        return;
    }
    CloseIFConfig(Handle);

    CTEGetLock(&RouteTableLock.Lock, &TableHandle);



    for (IF = IFList; IF != NULL; IF = IF->if_next) {
        if (IF == AddAddrEvent->IF)
            break;
    }

    if (IF) {
        index = IF->if_index;
        CTEFreeLock(&RouteTableLock.Lock, TableHandle);

        for (i = 0; i < NET_TABLE_SIZE; i++) {
            NetTableEntry *NetTableList = NewNetTableList[i];

            NTE = NetTableList;
            while (NTE != NULL) {
                NetTableEntry *NextNTE = NTE->nte_next;

                if ((NTE->nte_if == IF) && (NTE->nte_flags & NTE_DISCONNECTED) &&

                    (NTE->nte_flags & NTE_ACTIVE)) {

                    SetAddrControl *controlBlock;

                    CTEGetLock(&RouteTableLock.Lock, &TableHandle);

                    ASSERT(NTE != LoopNTE);
                    ASSERT(NTE->nte_flags & ~NTE_VALID);
                    ASSERT(NTE->nte_flags & ~NTE_DYNAMIC);

                    // disconnected NTEs are still assumed to  have valid addr and mask

                    NTE->nte_flags &= ~NTE_DISCONNECTED;

                    controlBlock = CTEAllocMemN(sizeof(SetAddrControl), 'lICT');
                    if (!controlBlock) {
                        CTEFreeLock(&RouteTableLock.Lock, TableHandle);
                    } else {

                        RtlZeroMemory(controlBlock, sizeof(SetAddrControl));

                        //Indicate to arp that display popup is needed
                        controlBlock->StaticAddr=TRUE;

                        ipstatus = IPpSetNTEAddr(NTE, NTE->nte_addr, NTE->nte_mask, &TableHandle, controlBlock, ReplumbAddrComplete);
                        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                                  "Replumb nte addr on nte %x if %x\n",
                                   NTE, IF, ipstatus));

                        if ((ipstatus == IP_SUCCESS) ||
                            (ipstatus == IP_PENDING)) {

                            for (j = 0; j < GConfigInfo.igc_numgws; j++) {
                                IPAddr GWAddr;

                                GWAddr = net_long(GConfigInfo.igc_gw[j]);

                                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                                           "RePlumbStaticAddr: adding route "
                                           "GWAddr %x nteaddr %x\n",
                                           GWAddr, NTE->nte_addr));
                                if (IP_ADDR_EQUAL(GWAddr, NTE->nte_addr)) {

                                    AddRoute(NULL_IP_ADDR, DEFAULT_MASK,
                                             IPADDR_LOCAL, NTE->nte_if, NTE->nte_mss,
                                             GConfigInfo.igc_gwmetric[j]
                                             ? GConfigInfo.igc_gwmetric[j] : IF->if_metric,
                                             IRE_PROTO_NETMGMT, ATYPE_OVERRIDE,
                                             0, 0);
                                } else
                                    AddRoute(NULL_IP_ADDR, DEFAULT_MASK,
                                             GWAddr, NTE->nte_if, NTE->nte_mss,
                                             GConfigInfo.igc_gwmetric[j]
                                             ? GConfigInfo.igc_gwmetric[j] : IF->if_metric,
                                             IRE_PROTO_NETMGMT, ATYPE_OVERRIDE,
                                             0, 0);

                                //now plumb corresponding persistent route

                                SetPersistentRoutesForNTE(NTE->nte_addr,
                                                          NTE->nte_mask, index);
                            }
                        }
                    }
                }
                NTE = NextNTE;
            }
        }


    } else {

        CTEFreeLock(&RouteTableLock.Lock, TableHandle);
    }

    // Undo the refcount that was taken when ReplumbStaticAddr
    // was scheduled.
    if (AddAddrEvent->IF) {
        DerefIF(AddAddrEvent->IF);
    }

    if (AddAddrEvent->ConfigName.Buffer) {
        CTEFreeMem(AddAddrEvent->ConfigName.Buffer);
    }

    CTEFreeMem(AddAddrEvent);
}

void
ReplumbAddrComplete(
                    void *Context,
                    IP_STATUS Status
                    )
{
    SetAddrControl *controlBlock;

    controlBlock = (SetAddrControl *) Context;

    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
               "Replumb completed %d\n", Status));

    CTEFreeMem(controlBlock);
}

//*     RemoveStaticAddr - Add static routes o media connect.
//
//
//      Input:  AddAddrEvent
//              Context
//
//      Returns: none.
//

void
RemoveStaticAddr(CTEEvent * Event, PVOID Context)
{
    CTELockHandle Handle;
    uint Status;
    NetTableEntry *NTE;
    Interface *IF = NULL;
    AddStaticAddrEvent *AddAddrEvent = (AddStaticAddrEvent *) Context;
    uint i;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    for (IF = IFList; IF != NULL; IF = IF->if_next) {
        if (IF == AddAddrEvent->IF)
            break;
    }

    if (IF == NULL) {

        // Undo the refcount that was taken when ReplumbStaticAddr
        // was scheduled.
        if (AddAddrEvent->IF) {
            LockedDerefIF(AddAddrEvent->IF);
        }

        CTEFreeLock(&RouteTableLock.Lock, Handle);
        return;
    }


    CTEFreeLock(&RouteTableLock.Lock, Handle);

    //
    // This function is called on media disconnect. We need to call
    // DecrInitTimeInterfaces in case we have not removed our reference yet
    // (which causes tcpip not to indicate TdiProviderReady). Since
    // IPStatus is called DPC (and DampCheck also runs at timer DPC) we have
    // to wait this event to call DecrInitTimeInterfaces. This call has no
    // effect if we have already released our reference.
    //
    // This can occur if a media disconnect arrives before dhcp address
    // negotiation begins.
    //

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    DecrInitTimeInterfaces(IF);

    for (i = 0; i < NET_TABLE_SIZE; i++) {
        NetTableEntry *NetTableList = NewNetTableList[i];
        for (NTE = NetTableList; NTE != NULL; NTE = NTE->nte_next) {

            if ((NTE->nte_flags & NTE_VALID) && (NTE->nte_if == IF) &&
                (NTE->nte_flags & ~NTE_DYNAMIC) &&
                (NTE->nte_flags & NTE_ACTIVE)) {

                CTEGetLock(&RouteTableLock.Lock, &Handle);

                ASSERT(NTE != LoopNTE);

                NTE->nte_flags |= NTE_DISCONNECTED;
                // while setting the ip address to NULL, we just mark the NTE as INVALID
                // we don't actually move the hashes
                if (IPpSetNTEAddr(NTE, NULL_IP_ADDR, NULL_IP_ADDR, &Handle, NULL, NULL) != IP_SUCCESS) {
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_ERROR_LEVEL,
                              "Failed to set null address on nte %x if %x\n",
                               NTE, IF));
                }

                //Ippsetnteaddr frees the  routetable lock
            }
        }
    }


    // Undo the interface refcount that was taken when RemoveStaticAddr
    // was scheduled

    DerefIF(IF);


    return;
}

void
TempDhcpAddrDone(
                 void *Context,
                 IP_STATUS Status
                 )
/*++

Routine Description:

    Handles the completion of an IP Set Addr request

    Arguments:

    Context       - Pointer to the SetAddrControl structure for this
    Status        - The IP status of the transmission.

    Return Value:

    None.

--*/
{
    SetAddrControl *SAC;
    Interface *IF;
    SAC = (SetAddrControl *) Context;
    IF = (Interface *) SAC->interface;

    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
              "tempdhcpaddrdone: addaddr done, notifying bind\n"));

    IPNotifyClientsIPEvent(IF, IP_BIND_ADAPTER);

    CTEFreeMem(SAC);
}

Interface *
AllocInterface(uint IFSize)
/*++

Routine Description:

    Allocated an Interface, also checks if the freelist size has increased to a threshold
    Called with no locks, so take a routetable lock
    Arguments:

    IFSize : Size of the interface to be allocated

    Return Value:

    IF we are trying to allocate

--*/
{
    Interface *IF, *TmpIF;
    CTELockHandle Handle;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    IF = CTEAllocMemNBoot(IFSize, 'wICT');

    if (TotalFreeInterfaces > MaxFreeInterfaces) {
        // free the first interface in the list
        ASSERT(FrontFreeList != NULL);
        TmpIF = FrontFreeList;
        FrontFreeList = FrontFreeList->if_next;
        CTEFreeMem(TmpIF);

        TotalFreeInterfaces--;

        // check whether the list became empty
        if (FrontFreeList == NULL) {
            RearFreeList = NULL;
            ASSERT(TotalFreeInterfaces == 0);
        }
    }
    CTEFreeLock(&RouteTableLock.Lock, Handle);

    return IF;
}

void
FreeInterface(Interface * IF)
/*++

Routine Description:

    Free an Interface to the freelist
    Called with routetable lock held
    Arguments:

    IF : Interface to free

    Return Value:

    None

--*/
{

    if (FrontFreeList == NULL) {
        FrontFreeList = IF;
    }
    // link this new interface at the back of the list

    if (RearFreeList) {
        RearFreeList->if_next = IF;
    }
    RearFreeList = IF;
    IF->if_next = NULL;

    TotalFreeInterfaces++;

    return;
}

//*     IPAddInterface - Add an interface.
//
//      Called when someone has an interface they want us to add. We read our
//      configuration information, and see if we have it listed. If we do,
//      we'll try to allocate memory for the structures we need. Then we'll
//      call back to the guy who called us to get things going. Finally, we'll
//      see if we have an address that needs to be DHCP'ed.
//
//      Input:  ConfigName                              - Name of config info we're to read.
//                      Context                                 - Context to pass to i/f on calls.
//                      RegRtn                                  - Routine to call to register.
//                      BindInfo                                - Pointer to bind information.
//
//      Returns: Status of attempt to add the interface.
//
IP_STATUS
__stdcall
IPAddInterface(
               PNDIS_STRING DeviceName,
               PNDIS_STRING IfName, OPTIONAL
               PNDIS_STRING ConfigName,
               void *PNPContext,
               void *Context,
               LLIPRegRtn RegRtn,
               LLIPBindInfo * BindInfo,
               UINT RequestedIndex,
               ULONG MediaType,
               UCHAR AccessType,
               UCHAR ConnectionType
               )
{
    IFGeneralConfig GConfigInfo;
    IFAddrList *AddrList;
    uint NumAddr;
    NetTableEntry *NTE;
    uint i;
    Interface *IF, *PrevIf, *CurrIf;
    NDIS_HANDLE Handle;
    NetTableEntry *PrimaryNTE = NULL;
    uint IFIndex;
    NetTableEntry *LastNTE;
    NTSTATUS writeStatus;
    uint IFExportNamePrefixLen, IFBindNamePrefixLen;
    uint IFNameLen, IFSize;
    RouteInterface *RtIF;
    uint EnableDhcp;
    PWCHAR IfNameBuf;
    uint MediaStatus;
    NTSTATUS Status;
    CTELockHandle TableHandle;
    IPAddr TempDHCPAddr = NULL_IP_ADDR;
    IPAddr TempMask = NULL_IP_ADDR;
    IPAddr TempGWAddr[MAX_DEFAULT_GWS];
    BOOLEAN TempDHCP = FALSE;
    BOOLEAN UniDirectional = FALSE;
    BOOLEAN PppIf;

#if MILLEN
    // Millennium seems to pass in ANSI name in the buffer for DeviceName
    // rather than Unicode, even though an NDIS_STRING is unicode for
    // WDM drivers. ConfigName is correct, however.
    NDIS_STRING UnicodeDevName;

    UnicodeDevName.Buffer = NULL;

    Status = RtlAnsiStringToUnicodeString(
        &UnicodeDevName,
        (PANSI_STRING) DeviceName,
        TRUE);

    if (!NT_SUCCESS(Status)) {
        DEBUGMSG(DBG_ERROR && DBG_PNP, (DTEXT("IPAddInterface: RtlAnsiStringToUnicodeString failure.\n")));
        DEBUGMSG(DBG_TRACE && DBG_PNP, (DTEXT("-IPAddInterface [NDIS_STATUS_RESOURCES]\n")));
        return NDIS_STATUS_RESOURCES;
    }

    // I have seen where the length of DeviceName is incorrect. Ensure
    // that the length is correct since TDI bindings depend on this string
    // value.
    UnicodeDevName.Length = wcslen(UnicodeDevName.Buffer) * sizeof(WCHAR);
    DeviceName = &UnicodeDevName;

    //
    // Next thing that I have seen is that NDIS has indicated bindings twice.
    // Search the IFList and ensure that we aren't adding a second IF for the
    // same binding.
    //

    CTEGetLock(&RouteTableLock.Lock, &TableHandle);

    CurrIf = IFList;

    while (CurrIf) {
        if (DeviceName->Length == CurrIf->if_devname.Length &&
            RtlCompareMemory(DeviceName->Buffer, CurrIf->if_devname.Buffer, DeviceName->Length) == DeviceName->Length) {
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_ERROR_LEVEL,
                      "IPAddInterface -- double bind of same interface!!\n"));
            CTEFreeLock(&RouteTableLock.Lock, TableHandle);
            return STATUS_INVALID_PARAMETER;
        }

        CurrIf = CurrIf->if_next;
    }

    CTEFreeLock(&RouteTableLock.Lock, TableHandle);
#endif // MILLEN

    if (RequestedIndex != 0) {

        CTEGetLock(&RouteTableLock.Lock, &TableHandle);

        CurrIf = IFList;

        while (CurrIf != NULL) {

            if (CurrIf->if_index == RequestedIndex ) {

                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"IPAddInterface: Interface 0x%x already exists\n",
                         RequestedIndex));

                CTEFreeLock(&RouteTableLock.Lock, TableHandle);

                return STATUS_INVALID_PARAMETER;
            }

            CurrIf = CurrIf->if_next;
        }

        CTEFreeLock(&RouteTableLock.Lock, TableHandle);
    }

    AddrList = NULL;
    IF = NULL;
    LastNTE = NULL;
    EnableDhcp = TRUE;

    IfNameBuf = NULL;

    DEBUGMSG(DBG_TRACE && DBG_PNP,
        (DTEXT("+IPAddInterface(%x, %x, %x, %x, %x, %x, %x, %x, %x, %x, %x)\n"),
        DeviceName, IfName, ConfigName, PNPContext, Context, RegRtn,
        BindInfo, RequestedIndex, MediaType,
        (LONG) AccessType, (LONG) ConnectionType));

    //* First, try to get the network configuration information.
    if (!OpenIFConfig(ConfigName, &Handle)) {
        DEBUGMSG(DBG_ERROR && DBG_PNP, (DTEXT("IPAddInterface: OpenIFConfig failure.\n")));
        DEBUGMSG(DBG_TRACE && DBG_PNP, (DTEXT("-IPAddInterface [GENERAL_FAILURE]\n")));
        return IP_GENERAL_FAILURE;    // Couldn't get IFConfig.
    }

    // Try to get our general config information.
    if (!GetGeneralIFConfig(&GConfigInfo, Handle, ConfigName)) {
        DEBUGMSG(DBG_ERROR && DBG_PNP, (DTEXT("IPAddInterface: GetGeneralIFConfig failure.\n")));
        goto failure;
    }

    // We got the general config info. Now allocate an interface.
#if MILLEN
    // There is not a prefix in millennium.
    IFExportNamePrefixLen = 0;
    IFBindNamePrefixLen = 0;
#else // MILLEN
    IFExportNamePrefixLen = wcslen(TCP_EXPORT_STRING_PREFIX) * sizeof(WCHAR);
    IFBindNamePrefixLen = wcslen(TCP_BIND_STRING_PREFIX) * sizeof(WCHAR);
#endif // !MILLEN

    IFNameLen = DeviceName->Length +
        IFExportNamePrefixLen -
        IFBindNamePrefixLen;

    IFSize = InterfaceSize +
        ConfigName->Length + sizeof(WCHAR) +
        IFNameLen + sizeof(WCHAR);

    /*    IF = CTEAllocMemNBoot(IFSize,
                              'wICT'); */

    IF = AllocInterface(IFSize);
    if (IF == NULL) {
        DEBUGMSG(DBG_ERROR && DBG_PNP, (DTEXT("IPAddInterface: failed to allocate IF.\n")));
        goto failure;
    }

    RtlZeroMemory(IF, IFSize);

    if (IfName) {
        IfNameBuf = CTEAllocMemN(IfName->Length + sizeof(WCHAR),
                                 'wICT');

        if (IfNameBuf == NULL) {
            DEBUGMSG(DBG_ERROR && DBG_PNP, (DTEXT("IPAddInterface: failed to allocate IF name buf.\n")));
            goto failure;
        }
    }

    // increment the init time interface counter if this is indeed inittimeinterface

    IncrInitTimeInterfaces(IF);

    CTEInitLock(&IF->if_lock);

    // Initialize the broadcast we'll use.
    if (GConfigInfo.igc_zerobcast)
        IF->if_bcast = IP_ZERO_BCST;
    else
        IF->if_bcast = IP_LOCAL_BCST;

    RtIF = (RouteInterface *) IF;

    RtIF->ri_q.rsq_qh.fq_next = &RtIF->ri_q.rsq_qh;
    RtIF->ri_q.rsq_qh.fq_prev = &RtIF->ri_q.rsq_qh;
    RtIF->ri_q.rsq_running = FALSE;
    RtIF->ri_q.rsq_pending = 0;
    RtIF->ri_q.rsq_maxpending = GConfigInfo.igc_maxpending;
    RtIF->ri_q.rsq_qlength = 0;
    CTEInitLock(&RtIF->ri_q.rsq_lock);
    IF->if_xmit = BindInfo->lip_transmit;
    IF->if_transfer = BindInfo->lip_transfer;
    IF->if_close = BindInfo->lip_close;
    IF->if_invalidate = BindInfo->lip_invalidate;
    IF->if_lcontext = BindInfo->lip_context;
    IF->if_addaddr = BindInfo->lip_addaddr;
    IF->if_deladdr = BindInfo->lip_deladdr;
    IF->if_qinfo = BindInfo->lip_qinfo;
    IF->if_setinfo = BindInfo->lip_setinfo;
    IF->if_getelist = BindInfo->lip_getelist;
    IF->if_dowakeupptrn = BindInfo->lip_dowakeupptrn;
    IF->if_pnpcomplete = BindInfo->lip_pnpcomplete;
    IF->if_dondisreq = BindInfo->lip_dondisreq;
    IF->if_setndisrequest = BindInfo->lip_setndisrequest;
    IF->if_arpresolveip = BindInfo->lip_arpresolveip;
    IF->if_arpflushate = BindInfo->lip_arpflushate;
    IF->if_arpflushallate = BindInfo->lip_arpflushallate;
#if MILLEN
    IF->if_cancelpackets = NULL;
#else
    IF->if_cancelpackets = BindInfo->lip_cancelpackets;
#endif
    IF->if_tdpacket = NULL;
    ASSERT(BindInfo->lip_mss > sizeof(IPHeader));

    IF->if_mtu = BindInfo->lip_mss - sizeof(IPHeader);
    IF->if_speed = BindInfo->lip_speed;
    IF->if_flags = BindInfo->lip_flags & LIP_P2P_FLAG ? IF_FLAGS_P2P : 0;
    IF->if_pnpcap = BindInfo->lip_pnpcap;    //copy wol capability

    //
    // If ARP reported a uni-directional address, mark the IF.
    //
    if (BindInfo->lip_flags & LIP_UNI_FLAG) {
        IF->if_flags |= IF_FLAGS_UNI;
        UniDirectional = TRUE;
    }

    //Unnumbered interface change
    if (BindInfo->lip_flags & LIP_NOIPADDR_FLAG) {

        IF->if_flags |= IF_FLAGS_NOIPADDR;

        // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Unnumbered interface %x", IF));

    }

    // Check whether the lower interface is a P2MP interface
    if (BindInfo->lip_flags & LIP_P2MP_FLAG) {

        IF->if_flags |= IF_FLAGS_P2MP;

        DEBUGMSG(DBG_INFO && DBG_PNP,
            (DTEXT("IPAddInterface: %x :: P2MP interface\n"), IF));

        if (BindInfo->lip_flags & LIP_NOLINKBCST_FLAG) {

            IF->if_flags |= IF_FLAGS_NOLINKBCST;

            DEBUGMSG(DBG_INFO && DBG_PNP,
                (DTEXT("IPAddInterface: %x :: NOLINKBCST interface\n"), IF));
        }
    }

    // When the link is deleted, we call lower layers closelink
    IF->if_closelink = BindInfo->lip_closelink;

    IF->if_addrlen = BindInfo->lip_addrlen;
    IF->if_addr = BindInfo->lip_addr;
    IF->if_pnpcontext = PNPContext;
    IF->if_llipflags = BindInfo->lip_flags;

    // Initialize the reference count to 1, for the open.
    LOCKED_REFERENCE_IF(IF);

#if IPMCAST
    IF->if_mcastttl = 1;
    IF->if_mcastflags = 0;
    IF->if_lastupcall = 0;
#endif

    //Propogate checksum and per interface tcp parameters

    IF->if_OffloadFlags = BindInfo->lip_OffloadFlags;
    IF->if_MaxOffLoadSize = BindInfo->lip_MaxOffLoadSize;
    IF->if_MaxSegments = BindInfo->lip_MaxSegments;

#if FFP_SUPPORT
    IF->if_ffpversion = BindInfo->lip_ffpversion;
    IF->if_ffpdriver = BindInfo->lip_ffpdriver;
#endif

    IF->if_TcpWindowSize = GConfigInfo.igc_TcpWindowSize;
    IF->if_TcpInitialRTT = GConfigInfo.igc_TcpInitialRTT;

    //get the delack time in 100msec ticks
    IF->if_TcpDelAckTicks = GConfigInfo.igc_TcpDelAckTicks;
    IF->if_TcpAckFrequency = GConfigInfo.igc_TcpAckFrequency;
    IF->if_iftype = GConfigInfo.igc_iftype;

#ifdef IGMPV3
    IF->IgmpVersion = IGMPV3;
#else
#ifdef IGMPV2
    IF->IgmpVersion = IGMPV2;
#else
    IF->IgmpVersion = IGMPV1;
#endif
#endif

    //
    // No need to do the following since IF structure is inited to 0 through
    // memset above
    //
    // IF->IgmpVer1Timeout = 0;

    //
    // Copy the config string for use later when DHCP enables an address
    // on this interface or when an NTE is added dynamically.
    //

    IF->if_configname.Buffer = (PVOID) (((uchar *) IF) + InterfaceSize);

    IF->if_configname.Length = 0;
    IF->if_configname.MaximumLength = ConfigName->Length + sizeof(WCHAR);

    CTECopyString(&(IF->if_configname),
                  ConfigName);

    IF->if_devname.Buffer = (PVOID) (((uchar *) IF) +
                                     InterfaceSize +
                                     IF->if_configname.MaximumLength);

    IF->if_devname.Length = (USHORT) IFNameLen;
    IF->if_devname.MaximumLength = (USHORT) (IFNameLen + sizeof(WCHAR));

#if MILLEN
    IF->if_order = MAXLONG;
#else
    CTEGetLock(&RouteTableLock.Lock, &TableHandle);
    IF->if_order =
        IPMapDeviceNameToIfOrder(DeviceName->Buffer +
                                 IFBindNamePrefixLen / sizeof(WCHAR));
    CTEFreeLock(&RouteTableLock.Lock, TableHandle);

    RtlCopyMemory(IF->if_devname.Buffer,
               TCP_EXPORT_STRING_PREFIX,
               IFExportNamePrefixLen);
#endif // !MILLEN

    RtlCopyMemory((uchar *) IF->if_devname.Buffer + IFExportNamePrefixLen,
               (uchar *) DeviceName->Buffer + IFBindNamePrefixLen,
               DeviceName->Length - IFBindNamePrefixLen);

    IF->if_numgws = GConfigInfo.igc_numgws;

    RtlCopyMemory(IF->if_gw,
               GConfigInfo.igc_gw,
               sizeof(IPAddr) * GConfigInfo.igc_numgws);

    RtlCopyMemory(IF->if_gwmetric,
               GConfigInfo.igc_gwmetric,
               sizeof(uint) * GConfigInfo.igc_numgws);

    IF->if_metric = GConfigInfo.igc_metric;

    //if the metric is 0, set the metric according to the interface speed.

    if (!IF->if_metric) {
        IF->if_auto_metric = 1;
        IF->if_metric = GetAutoMetric(IF->if_speed);
    } else {
        IF->if_auto_metric = 0;
    }

    if (IfName) {
        ASSERT(IfNameBuf);
        ASSERT((IfName->Length % sizeof(WCHAR)) == 0);

        IF->if_name.Buffer = IfNameBuf;
        IF->if_name.Length = IfName->Length;

        IF->if_name.MaximumLength = IfName->Length + sizeof(WCHAR);

        RtlCopyMemory(IfNameBuf,
                   IfName->Buffer,
                   IfName->Length);

        IfNameBuf[IfName->Length / sizeof(WCHAR)] = UNICODE_NULL;
    }
    IF->if_rtrdiscovery = (ushort) GConfigInfo.igc_rtrdiscovery;
    IF->if_dhcprtrdiscovery = 0;

    PppIf = IF->if_flags & IF_FLAGS_P2P ? TRUE : FALSE;
    // Find out how many addresses we have, and get the address list.
    AddrList = GetIFAddrList(&NumAddr, Handle, &EnableDhcp, PppIf, ConfigName);

    if (AddrList == NULL) {
        DEBUGMSG(DBG_ERROR && DBG_PNP,
         