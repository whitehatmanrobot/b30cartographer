PrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                "SETUP:SpPtnRemoveLogicalDrive(%p) is the last"
                " logical drive\n", LogicalDrive));        
        }                                 

        if (ContainerRegion->Container) {            
            PDISK_REGION    Region = NULL;
            
            SPPT_SET_REGION_DELETED(ContainerRegion, TRUE);      
            SPPT_SET_REGION_DIRTY(ContainerRegion, TRUE);
            SPPT_SET_REGION_PARTITIONED(ContainerRegion, FALSE);            

            //
            // if this was the last logical drive then delete the
            // first container region also
            //
            if (LastLogicalDrive) {
                ASSERT(SPPT_IS_REGION_CONTAINER_PARTITION(
                        ContainerRegion->Container));
                        
                SPPT_SET_REGION_DELETED(ContainerRegion->Container, TRUE);      
                SPPT_SET_REGION_DIRTY(ContainerRegion->Container, TRUE);
                SPPT_SET_REGION_PARTITIONED(ContainerRegion->Container, FALSE);            
            }
        } else {
            if (LastLogicalDrive) {
                //
                // No trailing region, so delete the first container region
                //
                SPPT_SET_REGION_DELETED(ContainerRegion, TRUE);      
                SPPT_SET_REGION_DIRTY(ContainerRegion, TRUE);
                SPPT_SET_REGION_PARTITIONED(ContainerRegion, FALSE);            
            }
        }            

        Status = STATUS_SUCCESS;
    }

    return Status;
}


BOOLEAN
SpPtnDelete(
    IN ULONG        DiskNumber,
    IN ULONGLONG    StartSector
    )
/*++

Routine Description:

    Removes the requested partition for the given disk.

    Also updates the region structure when returns.
    
Arguments:

    DiskNumber  :   Disk where the partition needs to be
                    deleted.

    StartSector :   Start sector of the partition/region
                    which needs to be deleted.

Return Value:

    TRUE if successful otherwise FALSE.

--*/        
{
    BOOLEAN Result = FALSE;
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    PDISK_REGION Region;
    PPARTITIONED_DISK PartDisk;    
    NTSTATUS InitStatus;

#ifdef TESTING_COMMIT
    if (DiskNumber == 0)
        return TRUE;
#endif
  
    PartDisk = SPPT_GET_PARTITIONED_DISK(DiskNumber);
    Region = SpPtLookupRegionByStart(PartDisk, FALSE, StartSector);

    if (Region) {        
        if (SPPT_IS_REGION_DYNAMIC_VOLUME(Region) || SPPT_IS_REGION_LDM_METADATA(Region)) {
            //
            // delete all the regions on this disk
            //
            PDISK_REGION CurrRegion = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);


            if (SPPT_IS_MBR_DISK(DiskNumber)) {
                //
                // Skip OEM partitions on MBR disk since they will always be
                // hard partitions
                //
                // NOTE : Assumes that all the OEM partitions are primary
                //        partitions (which also indicates they are hard partitions)
                //
                while (CurrRegion) {                
                    if (!IsOEMPartition(SPPT_GET_PARTITION_TYPE(CurrRegion))) {
                        SPPT_SET_REGION_PARTITIONED(CurrRegion, FALSE);
                        SPPT_SET_REGION_DELETED(CurrRegion, TRUE);
                        SPPT_SET_REGION_DIRTY(CurrRegion, TRUE);
                    }   

                    CurrRegion = CurrRegion->Next;
                }
            } else {
                while (CurrRegion) {    
                    //
                    // Skip ESP & MSR partitions since they will always be
                    // hard partitions
                    //
                    if (!SPPT_IS_REGION_EFI_SYSTEM_PARTITION(CurrRegion) &&
                        !SPPT_IS_REGION_MSFT_RESERVED(CurrRegion)) {
                        SPPT_SET_REGION_PARTITIONED(CurrRegion, FALSE);
                        SPPT_SET_REGION_DELETED(CurrRegion, TRUE);
                        SPPT_SET_REGION_DIRTY(CurrRegion, TRUE);
                    }                        

                    CurrRegion = CurrRegion->Next;
                }
            }   

            Status = STATUS_SUCCESS;
        } else if (SPPT_IS_REGION_LOGICAL_DRIVE(Region)) {
            Status = SpPtnRemoveLogicalDrive(Region);
        } else {
            SPPT_SET_REGION_PARTITIONED(Region, FALSE);
            SPPT_SET_REGION_DELETED(Region, TRUE);
            SPPT_SET_REGION_DIRTY(Region, TRUE);
            
            Status = STATUS_SUCCESS;
        }

        if (NT_SUCCESS(Status)) {
            Status = SpPtnCommitChanges(DiskNumber, &Result);

            if (!(Result && NT_SUCCESS(Status))) {
                KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                    "SETUP: SpPtnDelete(%u, %I64u) failed to commit changes (%lx)\n",
                    DiskNumber, StartSector, Status));                                
            }                      
        } else {
            KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                "SETUP: SpPtnDelete(%u, %I64u) failed to delete logical drive (%lx)\n",
                DiskNumber, StartSector, Status));
        }
    }

    Result = Result && NT_SUCCESS(Status);

    //
    // Reinitialize regions irrespective of commit's status
    //
    InitStatus = SpPtnInitializeDiskDrive(DiskNumber);
    
    if (!NT_SUCCESS(InitStatus)) {
        KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
            "SETUP: SpPtnDelete(%u, %I64u) failed to reinit regions\n", 
            DiskNumber, 
            StartSector));

        Result = FALSE;
    }    

    return Result;
}    


ValidationValue
SpPtnGetSizeCB(
    IN ULONG Key
    )
/*++

Routine Description:

    Key stroke filter for getting the partition size
    from the user
    
Arguments:

    Key -   The key stroke

Return Value:

    One of the enumerated types of ValidationValue, indicating
    whether to accept / reject / terminate / ignore the key
    stroke.

--*/        
{
    if(Key == ASCI_ESC) {
        //
        // User wants to bail.
        //
        return(ValidateTerminate);
    }


    if(Key & KEY_NON_CHARACTER) {
        return(ValidateIgnore);
    }

    //
    // Allow only digits.
    //
    return(((Key >= L'0') && (Key <= L'9')) ? ValidateAccept : ValidateReject);
}

BOOLEAN
SpPtnGetSizeFromUser(
    IN PHARD_DISK   Disk,
    IN ULONGLONG    MinMB,
    IN ULONGLONG    MaxMB,
    OUT PULONGLONG  SizeMB
    )
/*++

Routine Description:

    Gets the size from user, after showing him the minimum
    and maximum values
    
Arguments:

    Disk    -   Disk for which the partition size is being
                requested

    MinMB   -   Minimum partition size

    MaxMB   -   Maximim patitions size

    SizeMB  -   Place holder for user entered size

Return Value:

    TRUE if the input was valid or FALSE if the user 
    cancelled the input dialog using ESC.

--*/        
{
    BOOLEAN     Result;
    WCHAR       Buffer[200];
    WCHAR       SizeBuffer[32] = {0};

    *SizeMB = 0;
    
    //
    // Put up a screen displaying min/max size info.
    //
    SpStartScreen(
        SP_SCRN_CONFIRM_CREATE_PARTITION,
        3,
        CLIENT_TOP + 1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE,
        Disk->Description,
        (ULONG)MinMB,
        (ULONG)MaxMB
        );

    //
    // Display the staus text.
    //
    SpDisplayStatusOptions(
        DEFAULT_STATUS_ATTRIBUTE,
        SP_STAT_ENTER_EQUALS_CREATE,
        SP_STAT_ESC_EQUALS_CANCEL,
        0
        );

    //
    // Get and display the size prompt.
    //
    SpFormatMessage(Buffer, sizeof(Buffer), SP_TEXT_SIZE_PROMPT);

    SpvidDisplayString(Buffer, DEFAULT_ATTRIBUTE, 3, NextMessageTopLine);

    Result = TRUE;
    
    //
    // Get the size from the user.
    //
    do {
        swprintf(SizeBuffer,L"%u", (ULONG)MaxMB);
        
        if(!SpGetInput(SpPtnGetSizeCB, 
                    SplangGetColumnCount(Buffer) + 5,
                    NextMessageTopLine,
                    8,                      // at the max 99999999
                    SizeBuffer,
                    TRUE)) {
            //
            // User pressed escape and bailed.
            //
            Result = FALSE;
            break;
        }

        *SizeMB = SpStringToLong(SizeBuffer, NULL, 10);
    } 
    while(((*SizeMB) < MinMB) || ((*SizeMB) > MaxMB));

    return Result;
}


VOID
SpPtnAlignPartitionStartAndEnd(
    IN  PHARD_DISK  Disk,
    IN  ULONGLONG   SizeMB,
    IN  ULONGLONG   StartSector,
    IN  PDISK_REGION Region,
    IN  BOOLEAN     ForExtended,
    OUT PULONGLONG  AlignedStartSector,
    OUT PULONGLONG  AlignedEndSector
    )
/*++

Routine Description:

    Aligns the partition start and end sector
    
Arguments:

    Disk    -   Partition's disk for which alignment needs to be
                done.

    SizeMB  -   The partition's size

    StartSector - The start sector of the partition

    Region  -   The region representing the partition

    ForExtended -   Whether this partition needs to be aligned
                    for creating a container partition.

    AlignedStartSector  - Place holder for the aligned start sector

    AlignedEndSector    - Place holder fot the aligned end sector


Return Value:

    None

--*/        
{
    ULONGLONG   SectorCount;
    ULONGLONG   LeftOverSectors;
    
    //
    // Determine the number of sectors in the size passed in.
    //
    SectorCount = SizeMB * ((1024 * 1024) / Disk->Geometry.BytesPerSector);

    //
    // If this is the first free space inside the extended partition
    // we need to decrement the StartSector so that while creating
    // first logical inside the extended we don't create the 
    // logical at one cylinder offset
    //
    if (SPPT_IS_REGION_NEXT_TO_FIRST_CONTAINER(Region) && StartSector) {        
        StartSector--;
    }

    //
    // Align the start sector.
    //
    (*AlignedStartSector) = SpPtAlignStart(Disk, StartSector, ForExtended);

    //
    // Determine the end sector based on the size passed in.
    //
    (*AlignedEndSector) = (*AlignedStartSector) + SectorCount;

    //
    // Align the ending sector to a cylinder boundary.  If it is not already
    // aligned and is more than half way into the final cylinder, align it up,
    // otherwise align it down.
    //
    LeftOverSectors = (*AlignedEndSector) % Disk->SectorsPerCylinder;

    if (LeftOverSectors) {
        (*AlignedEndSector) -= LeftOverSectors;
        
        if (LeftOverSectors > (Disk->SectorsPerCylinder / 2)) {
            (*AlignedEndSector) += Disk->SectorsPerCylinder;
        }
    }

    //
    // If the ending sector is past the end of the free space, shrink it
    // so it fits.
    //
    while((*AlignedEndSector) > StartSector + Region->SectorCount) {
        (*AlignedEndSector) -= Disk->SectorsPerCylinder;
    }

    //
    //  Find out if last sector is in the last cylinder. If it is then align it down.
    //  This is necessary so that we reserve a cylinder at the end of the disk, so that users
    //  can convert the disk to dynamic after the system is installed.
    //
    //  (guhans)  Don't align down if this is ASR.  ASR already takes this into account.
    //
    if( !DockableMachine && !SpDrEnabled() &&
        ((*AlignedEndSector) > ((Disk->CylinderCount - 1) * Disk->SectorsPerCylinder))) {
            (*AlignedEndSector) -= Disk->SectorsPerCylinder;
            
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                "SETUP: End of partition was aligned down 1 cylinder \n"));
                
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                "SETUP:     AlignedStartSector = %I64x \n", AlignedStartSector));
                
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                "SETUP:     AlignedEndSector   = %I64x \n", AlignedEndSector));
                
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                "SETUP:     SectorsPerCylinder = %lx \n", Disk->SectorsPerCylinder));
                
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                "SETUP:     CylinderCount = %lx \n", Disk->CylinderCount));
    }

    ASSERT((*AlignedEndSector) > 0);

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
            "SETUP:SpPtnAlignPartitionStartAndEnd:S/C:%d,Size:%I64d,"
            "StartSector:%I64d,RSS:%I64d,FE:%d,AS:%I64d,AE:%I64d\n"
            "LeftOverSectors:%I64d\n",            
            Disk->SectorsPerCylinder,
            SizeMB,
            StartSector,
            Region->StartSector,
            ForExtended,
            *AlignedStartSector,
            *AlignedEndSector,
            LeftOverSectors));            
}



BOOLEAN
SpPtnCreateLogicalDrive(
    IN  ULONG         DiskNumber,
    IN  ULONGLONG     StartSector,
    IN  ULONGLONG     SizeInSectors,    // Used ONLY in the ASR case
    IN  BOOLEAN       ForNT,    
    IN  BOOLEAN       AlignToCylinder,
    IN  ULONGLONG     DesiredMB OPTIONAL,
    IN  PPARTITION_INFORMATION_EX PartInfo OPTIONAL,
    OUT PDISK_REGION *ActualDiskRegion OPTIONAL
    )
/*++

Routine Description:

    Creates logical drive.

    To create a logical drive we need to create the
    logical drive's container partition also first.


    Algorithm:

    if (first logical drive) {
        1.  create an extended partition encompassing the
            whole free space in region        
        2.  create a logical drive at one track offset
            from the extened partition of the required size
    } else {
        1.  create an extended partition encompassing the 
            given space
        2.  create a logical drive of the maximim size
            inside the created extended partition
    }
    
Arguments:

    DiskNumber  -   Disk on which logical drive nedds to be
                    created.

    StartSector -   The starting sector for the region, which
                    will contain the container & logical drive

    ForNT       -   Indicating whether to use the given 
                    Desired Size or not

    AlignToCylinder - Indicating whether the partition should
                    be aligned on a cylinder boundary (Usually set 
                    to TRUE, except in a few specific ASR cases).


    PartInfo    -   Partition Information which needs to be
                    used while creating the partition (like
                    Partition Type on MBR disks and GUID
                    for Partition Id on GPT disks)

    ActualDiskRegion    -   Place holder for returning, the
                            region which indicates the new
                            partition in memory

Return Value:

    TRUE is successful otherwise FALSE.

--*/        
{
    BOOLEAN         Result = FALSE;
    NTSTATUS        Status;
    NTSTATUS        InitStatus;
    UCHAR           PartitionType = 0;
    ULONG           Primary = 0, Container = 0, Logical = 0;
    BOOLEAN         FirstLogical = FALSE;
    BOOLEAN         ReservedRegion = FALSE;
    BOOLEAN         CreateContainer = TRUE;
    BOOLEAN         Beyond1024;
    BOOLEAN         FreeRegions = FALSE;
    ULONGLONG       MinMB = 0, MaxMB = 0, SizeMB = 0;
    ULONGLONG       LogicalSize = 0;
    ULONGLONG       CylinderMB = 0;
    PDISK_REGION    Region;
    ULONGLONG       SectorCount, LeftOverSectors;    
    ULONGLONG       AlignedStartSector, AlignedEndSector;
    ULONGLONG       LogicalStartSector, LogicalEndSector;
    
    PHARD_DISK          Disk = SPPT_GET_HARDDISK(DiskNumber);
    PPARTITIONED_DISK   PartDisk = SPPT_GET_PARTITIONED_DISK(DiskNumber);
    PDISK_REGION        NewContainer = NULL, NewLogical = NULL;

    //
    // get hold of the region
    //
    Region = SpPtLookupRegionByStart(PartDisk, FALSE, StartSector);

    if (!Region)
        return Result;

    //
    // should be free
    //
    ASSERT(SPPT_IS_REGION_PARTITIONED(Region) == FALSE);              

    //
    // get the various partition type count on the disk
    //
    SpPtnGetPartitionTypeCounts(DiskNumber, 
                            TRUE, 
                            &Primary, 
                            &Container, 
                            &Logical,
                            NULL,
                            NULL);

    //
    // first logical indicates, what we will be creating the first
    // container partition which will consume the whole free space
    // available
    //
    FirstLogical = !(Logical || Container);

    //
    // Some times there might be just an extended partition and we
    // might be creating the partition in the starting free space inside
    // this extended partition. For this case we want to make sure that 
    // we don't create another container partition
    //
    if (!FirstLogical && SPPT_IS_REGION_NEXT_TO_FIRST_CONTAINER(Region)) {        
        CreateContainer = FALSE;
    }        

    //
    // Create an extened partition
    //
    SpPtQueryMinMaxCreationSizeMB(DiskNumber,
                                Region->StartSector,
                                CreateContainer,
                                !CreateContainer,
                                &MinMB,
                                &MaxMB,
                                &ReservedRegion
                                );

    if (ReservedRegion) {
        ULONG ValidKeys[2] = {ASCI_CR , 0};

        SpStartScreen(
            SP_SCRN_REGION_RESERVED,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE
            );

        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_ENTER_EQUALS_CONTINUE,
                    0);
                    
        SpWaitValidKey(ValidKeys, NULL, NULL);
        
        return FALSE;
    }
             
    if (ForNT) {
        //
        // If a size was requested then try to use that, otherwise use
        // the maximum.
        //
        if (DesiredMB) {
            if (DesiredMB <= MaxMB) {
                SizeMB = DesiredMB;
            } else {
                return FALSE;   // don't have the space user requested
            }
        } else {
            SizeMB = MaxMB;
        }
    } else {            
        if (SpPtnGetSizeFromUser(Disk, MinMB, MaxMB, &SizeMB)) {
            DesiredMB = SizeMB;
        } else {
            return FALSE;   // user didn't want to proceed
        }            

        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, 
                SP_STAT_PLEASE_WAIT,
                0);        
    }

    //
    // get the aligned start and end sector for exteneded/logical partition
    //
    if (AlignToCylinder) {
        SpPtnAlignPartitionStartAndEnd(Disk,
                                FirstLogical ? MaxMB : SizeMB,
                                StartSector,
                                Region,
                                CreateContainer,
                                &AlignedStartSector,
                                &AlignedEndSector); 
    }
    else {
        AlignedStartSector = StartSector;

        if (SpDrEnabled()) {
            AlignedEndSector = StartSector + SizeInSectors;

        }
        else {
            AlignedEndSector = StartSector + 
                (SizeMB * ((1024 * 1024) / Disk->Geometry.BytesPerSector));
        }
    }


    if (CreateContainer) {
        //
        // Logical drive start is always at 1 track offset from extended start
        //
        LogicalStartSector = AlignedStartSector + SPPT_DISK_TRACK_SIZE(DiskNumber);

        if (FirstLogical) {
            ULONGLONG   SectorCount = (SizeMB * 1024 * 1024) / SPPT_DISK_SECTOR_SIZE(DiskNumber);
            ULONGLONG   Remainder = 0;
            if (SpDrEnabled()) {
                SectorCount = SizeInSectors;
            }
            
            LogicalEndSector = LogicalStartSector + SectorCount;
            if (AlignToCylinder) {
                Remainder = LogicalEndSector % SPPT_DISK_CYLINDER_SIZE(DiskNumber);
                LogicalEndSector -= Remainder;

                if (Remainder > (SPPT_DISK_CYLINDER_SIZE(DiskNumber) / 2))
                    LogicalEndSector += SPPT_DISK_CYLINDER_SIZE(DiskNumber);
            }

            if (LogicalEndSector > AlignedEndSector)
                LogicalEndSector = AlignedEndSector;
        } else {
            LogicalEndSector = AlignedEndSector;
        }
    } else {
        //
        // The first free region (inside first extended) is at the offset 
        // of 1 sector from the previous exteneded region. Since we are not 
        // using the aligned start sector some times this first logical 
        // will be greater than the requested size i.e. 
        // end is aligned but start may not be aligned
        //
        LogicalStartSector = StartSector - 1 + SPPT_DISK_TRACK_SIZE(DiskNumber);
        LogicalEndSector = AlignedEndSector;
    }

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
            "SETUP:SpPtnCreateLogicalDrive():"
            "CMB:%I64d,CS:%I64d,CE:%I64d,LS:%I64d,LE:%I64d\n",
            CylinderMB,                
            AlignedStartSector,
            AlignedEndSector,
            LogicalStartSector,
            LogicalEndSector));

    //
    // allocate the new regions
    //
    if (CreateContainer) {
        //
        // allocate the container region
        //
        NewContainer = (PDISK_REGION)SpMemAlloc(sizeof(DISK_REGION));

        if (!NewContainer)
            return FALSE;
            
        RtlZeroMemory(NewContainer, sizeof(DISK_REGION));
    }

    //
    // allocate the logical drive region
    //
    NewLogical = (PDISK_REGION)SpMemAlloc(sizeof(DISK_REGION));

    if (!NewLogical) {
        SpMemFree(NewContainer);

        return FALSE;
    }

    RtlZeroMemory(NewLogical, sizeof(DISK_REGION));

    //
    // put the new regions in the list
    //
    if (CreateContainer) {    
        NewContainer->Next = NewLogical;
        NewLogical->Next = Region->Next;
        Region->Next = NewContainer;
    } else {
        //
        // This is the first logical inside the
        // already existing extended partition 
        //
        ASSERT(Region->Container->Next == Region);
        
        NewLogical->Next = Region->Next;
        Region->Container->Next = NewLogical;
    }

    //
    // fill the container disk region.
    //
    if (CreateContainer) {
        ASSERT(AlignedStartSector < AlignedEndSector);
        
        NewContainer->DiskNumber = DiskNumber;
        NewContainer->StartSector = AlignedStartSector;
        NewContainer->SectorCount = AlignedEndSector - AlignedStartSector;

        if (!FirstLogical) {
            PDISK_REGION    FirstContainer = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);

            while (FirstContainer && !SPPT_IS_REGION_FIRST_CONTAINER_PARTITION(FirstContainer))
                FirstContainer = FirstContainer->Next;

            ASSERT(FirstContainer);
            
            NewContainer->Container = FirstContainer;
        }

        SPPT_SET_REGION_PARTITIONED(NewContainer, FALSE);
        SPPT_SET_REGION_DIRTY(NewContainer, TRUE);
        SPPT_SET_REGION_EPT(NewContainer, EPTContainerPartition);

        NewContainer->FreeSpaceKB = (ULONG)(-1);
        NewContainer->AdjustedFreeSpaceKB = (ULONG)(-1);    

        Beyond1024 = SpIsRegionBeyondCylinder1024(NewContainer);

        //
        // Only mark the first extended (container) partition as XINT13_EXTENDED
        // if beyond 1024 cylinders, for backward compatability with Win9x
        //
        PartitionType = (Beyond1024 && FirstLogical) ? PARTITION_XINT13_EXTENDED : PARTITION_EXTENDED;    
        SPPT_SET_PARTITION_TYPE(NewContainer, PartitionType);
    }        

    //
    // fill in the logical disk region
    //    
    ASSERT(LogicalStartSector < LogicalEndSector);

    if (CreateContainer) {        
        ASSERT((AlignedStartSector + SPPT_DISK_TRACK_SIZE(DiskNumber)) == LogicalStartSector);
    
        if (LogicalStartSector != (AlignedStartSector + SPPT_DISK_TRACK_SIZE(DiskNumber))) {
            LogicalStartSector = AlignedStartSector + SPPT_DISK_TRACK_SIZE(DiskNumber);
        }
    }        
    
    ASSERT(LogicalEndSector <= AlignedEndSector);

    if (LogicalEndSector > AlignedEndSector) {
        LogicalEndSector = AlignedEndSector;
    }        
        
    NewLogical->DiskNumber = DiskNumber;
    NewLogical->StartSector = LogicalStartSector;
    NewLogical->SectorCount = LogicalEndSector - LogicalStartSector;

    if (CreateContainer) {
        NewLogical->Container = NewContainer;   // the new logical drive's container !!!
    } else {
        ASSERT(Region->Container);
        
        NewLogical->Container = Region->Container;
    }        

    SPPT_SET_REGION_PARTITIONED(NewLogical, TRUE);
    SPPT_SET_REGION_DIRTY(NewLogical, TRUE);
    SPPT_SET_REGION_EPT(NewLogical, EPTLogicalDrive);

    NewLogical->FreeSpaceKB = (ULONG)(-1);
    NewLogical->AdjustedFreeSpaceKB = (ULONG)(-1);    

    Beyond1024 = SpIsRegionBeyondCylinder1024(NewLogical);
    PartitionType = Beyond1024 ? PARTITION_XINT13 : PARTITION_HUGE;    

    //
    // If the argument is specified and is valid partition type
    // then use that making the assumption the caller knows exactly
    // what he wants
    //
    if (ARGUMENT_PRESENT(PartInfo) && !IsContainerPartition(PartInfo->Mbr.PartitionType)) {
        PartitionType = PartInfo->Mbr.PartitionType;
    }        
        
    SPPT_SET_PARTITION_TYPE(NewLogical, PartitionType);    
    NewLogical->Filesystem = FilesystemNewlyCreated;    // to zap boot sector
                   
    SpFormatMessage(Region->TypeName, 
                sizeof(Region->TypeName),
                SP_TEXT_FS_NAME_BASE + Region->Filesystem);
                    
    //
    // commit to the disk
    //
    Status = SpPtnCommitChanges(DiskNumber, &Result);

    if (!(NT_SUCCESS(Status) && Result)) {                
        KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
            "SETUP: SpPtnDelete(%u, %I64u) failed to commit changes (%lx)\n",
            DiskNumber, 
            StartSector, 
            Status));
    }

    Result = Result && NT_SUCCESS(Status);

    //
    // Reinitialize irrespective of commit's status
    //
    InitStatus = SpPtnInitializeDiskDrive(DiskNumber);
    
    if (!NT_SUCCESS(InitStatus)) {
        KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
            "SETUP: SpPtnCreateLogicalDrive(%u, %I64u) failed to reinit regions\n", 
            DiskNumber, 
            StartSector));

        Result = FALSE;
    }

    if (Result && ARGUMENT_PRESENT(ActualDiskRegion)) {
        *ActualDiskRegion = SpPtLookupRegionByStart(PartDisk, 
                                                    FALSE, 
                                                    LogicalStartSector);
            
        //SpPtDumpDiskRegion(*ActualDiskRegion);                                                    
    }


    //
    // We don't need to free the regions which we allocated above
    // as the above commit and init would have done that already
    //
    
    return Result;
}

BOOLEAN
SpPtnCreate(
    IN  ULONG         DiskNumber,
    IN  ULONGLONG     StartSector,
    IN  ULONGLONG     SizeInSectors,    // Used ONLY in the ASR case
    IN  ULONGLONG     SizeMB,
    IN  BOOLEAN       InExtended,
    IN  BOOLEAN       AlignToCylinder,
    IN  PPARTITION_INFORMATION_EX PartInfo,
    OUT PDISK_REGION *ActualDiskRegion OPTIONAL
    )
/*++

Routine Description:

    Creates a primary partition of the requested size on the
    given disk (either MBR/GPT).
    
Arguments:

    DiskNumber  :   Disk on which the partition needs to be
                    created

    StartSector :   Start sector of the region, which represents
                    the free space in which the partition needs
                    to be created

    SizeMB      :   The size of the partition

    InExtended  :   Whether to create an logical drive
                    or not (currently NOT USED except in the ASR case)

    AlignToCylinder : Indicating whether the partition should
                    be aligned on a cylinder boundary (Usually set 
                    to TRUE, except in a few specific ASR cases).

    PartInfo    :   Partition attributes to use                    

    ActualDiskRegion    :   Place holder for the actual disk
                            region which will represent the created
                            partition                    

Return Value:

    TRUE if successful, otherwise FALSE

--*/        
{
    BOOLEAN             Result = FALSE;
    PDISK_REGION        Region;
    ULONGLONG           SectorCount, AlignedStartSector;
    ULONGLONG           AlignedEndSector, LeftOverSectors;
    PPARTITIONED_DISK   PartDisk = SPPT_GET_PARTITIONED_DISK(DiskNumber);
    PHARD_DISK          Disk = SPPT_GET_HARDDISK(DiskNumber);
    PDISK_REGION        PrevRegion;
    PDISK_REGION        NewRegion = NULL;
    NTSTATUS            Status;
    NTSTATUS            InitStatus;
    BOOLEAN             FirstLogical = TRUE;

    //
    // Verify that the optional attributes specified
    // are correct
    //
    if (PartInfo) {
        if ((SPPT_IS_MBR_DISK(DiskNumber) && 
             (PartInfo->PartitionStyle != PARTITION_STYLE_MBR)) ||
            (SPPT_IS_GPT_DISK(DiskNumber) &&
             (PartInfo->PartitionStyle != PARTITION_STYLE_GPT))) {

            return FALSE;
        }            
    }
    
    Region = SpPtLookupRegionByStart(PartDisk, FALSE, StartSector);

    if (!Region)
        return Result;
                       
    ASSERT(SPPT_IS_REGION_PARTITIONED(Region) == FALSE);            

    SpPtDumpDiskRegion(Region);

    //
    // Determine the number of sectors in the size passed in.
    //
    if (SpDrEnabled()) {
        SectorCount = SizeInSectors;
    }
    else {
        SectorCount = SizeMB * ((1024 * 1024) / Disk->Geometry.BytesPerSector);
    }
    

    //
    // Align the start sector.
    //
    if (AlignToCylinder) {
        if (!SpDrEnabled()) {
            AlignedStartSector = SpPtAlignStart(Disk, StartSector, FALSE);
        }
        else {
            AlignedStartSector = SpPtAlignStart(Disk, StartSector, InExtended);
        }
    }
    else {
        AlignedStartSector = StartSector;
    }

    //
    // Determine the end sector based on the size passed in.
    //
    AlignedEndSector = AlignedStartSector + SectorCount;

    //
    // Align the ending sector to a cylinder boundary.  If it is not already
    // aligned and is more than half way into the final cylinder, align it up,
    // otherwise align it down.
    //
    if (AlignToCylinder) {
        LeftOverSectors = AlignedEndSector % Disk->SectorsPerCylinder;

        if (LeftOverSectors) {
            AlignedEndSector -= LeftOverSectors;
        
            if (LeftOverSectors > (Disk->SectorsPerCylinder / 2)) {
                AlignedEndSector += Disk->SectorsPerCylinder;
            }
        }

    }
    
    //
    // If the ending sector is past the end of the free space, shrink it
    // so it fits.
    //
    while(AlignedEndSector > Region->StartSector + Region->SectorCount) {
        AlignedEndSector -= Disk->SectorsPerCylinder;
    }

    //
    //  Find out if last sector is in the last cylinder. If it is then align it down.
    //  This is necessary so that we reserve a cylinder at the end of the disk, so that users
    //  can convert the disk to dynamic after the system is installed.
    //
    //  (guhans)  Don't align down if this is ASR.  ASR already takes this into account.
    //
    if( !DockableMachine && !SpDrEnabled() && SPPT_IS_MBR_DISK(DiskNumber) &&
        (AlignedEndSector > ((Disk->CylinderCount - 1) * Disk->SectorsPerCylinder))) {
            AlignedEndSector -= Disk->SectorsPerCylinder;
            
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                "SETUP: End of partition was aligned down 1 cylinder \n"));
                
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                "SETUP:     AlignedStartSector = %I64x \n", AlignedStartSector));
                
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                "SETUP:     AlignedEndSector   = %I64x \n", AlignedEndSector));
                
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                "SETUP:     SectorsPerCylinder = %lx \n", Disk->SectorsPerCylinder));
                
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
                "SETUP:     CylinderCount = %lx \n", Disk->CylinderCount));
    }

    ASSERT(AlignedEndSector > 0);

    //
    // Find the previous region 
    //
    PrevRegion = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);

    if(PrevRegion == Region) {
        PrevRegion = NULL;
    } else {
        while (PrevRegion) {
            if(PrevRegion->Next == Region) {                
                break;
            }

            PrevRegion = PrevRegion->Next;
        }
    }
    
    //
    // Create a new disk region for the new free space at the
    // beginning and end of the free space, if any.
    //
    if(AlignedStartSector - Region->StartSector) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
            "SETUP:SpPtnCreate():Previous:OS:%I64d,AS:%I64d,DIFF:%I64d,S/P:%d\n",
            Region->StartSector,
            AlignedStartSector,
            (ULONGLONG)(AlignedStartSector - Region->StartSector),
            Disk->SectorsPerCylinder));
            
        NewRegion = SpPtAllocateDiskRegionStructure(
                        DiskNumber,
                        Region->StartSector,
                        AlignedStartSector - Region->StartSector,
                        FALSE,
                        NULL,
                        0
                        );

        ASSERT(NewRegion);

        if(PrevRegion) {
            PrevRegion->Next = NewRegion;
        } else {
            ASSERT(Region == SPPT_GET_PRIMARY_DISK_REGION(DiskNumber));
            
            PartDisk->PrimaryDiskRegions = NewRegion;
        }

        NewRegion->Next = Region;
    }

    if(Region->StartSector + Region->SectorCount - AlignedEndSector) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
            "SETUP:SpPtnCreate():Next:OE:%I64d,AE:%I64d,DIFF:%I64d,S/P:%d\n",
            (ULONGLONG)(Region->StartSector + Region->SectorCount),
            AlignedEndSector,
            (ULONGLONG)(Region->StartSector + Region->SectorCount - AlignedEndSector),
            Disk->SectorsPerCylinder));
            
        NewRegion = SpPtAllocateDiskRegionStructure(
                        DiskNumber,
                        AlignedEndSector,
                        Region->StartSector + Region->SectorCount - 
                            AlignedEndSector,
                        FALSE,
                        NULL,
                        0
                        );

        NewRegion->Next = Region->Next;
        Region->Next = NewRegion;
    }

    //
    // fill the current disk region.
    //
    Region->DiskNumber = DiskNumber;
    Region->StartSector = AlignedStartSector;
    Region->SectorCount = AlignedEndSector - AlignedStartSector;
    SPPT_SET_REGION_PARTITIONED(Region, TRUE);
    SPPT_SET_REGION_DIRTY(Region, TRUE);
    Region->VolumeLabel[0] = 0;
    Region->Filesystem = FilesystemNewlyCreated;                    
    Region->FreeSpaceKB = (ULONG)(-1);
    Region->AdjustedFreeSpaceKB = (ULONG)(-1);

    //
    // Set the passed in partition information
    //
    if (PartInfo) {
        SpPtnSetRegionPartitionInfo(Region, PartInfo);
    }        
                
    SpFormatMessage(Region->TypeName, 
                sizeof(Region->TypeName),
                SP_TEXT_FS_NAME_BASE + Region->Filesystem);
                
    //
    // commit to the disk
    //
    Status = SpPtnCommitChanges(DiskNumber, &Result);   

    if (!(Result && NT_SUCCESS(Status))) {
        KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
            "SETUP: SpPtnCreate(%u, %I64u) failed to commit changes to"
            "the drive (%lx)\n",
            DiskNumber, 
            StartSector, 
            Status));
    }
    
    Result = Result && NT_SUCCESS(Status);

    //
    // Reinitialize irrespective of commit's status
    //
    InitStatus = SpPtnInitializeDiskDrive(DiskNumber);

    if (!NT_SUCCESS(InitStatus)){
        KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
            "SETUP: SpPtnCreate(%u, %I64u) failed to reinitialize regions\n", 
            DiskNumber, 
            StartSector));

        Result = FALSE;            
    }

    if (Result && ARGUMENT_PRESENT(ActualDiskRegion)) {
        *ActualDiskRegion = SpPtLookupRegionByStart(PartDisk, 
                                                    FALSE, 
                                                    AlignedStartSector);                                                    
    }
    
    return Result;
}


BOOLEAN
SpPtnDoCreate(
    IN  PDISK_REGION  Region,
    OUT PDISK_REGION  *ActualRegion, OPTIONAL
    IN  BOOLEAN       ForNT,
    IN  ULONGLONG     DesiredMB OPTIONAL,
    IN  PPARTITION_INFORMATION_EX PartInfo OPTIONAL,
    IN  BOOLEAN       ConfirmIt
    )
/*++

Routine Description:

    Given the region which was selected by the user,
    this routine creates the appropriate partition in
    it.

    This routine decides whether to create a primary or
    container partition on MBR disks.


    Algorithm:

    if (RemoveableMedia && already partition exists) {
        1.  put up a warning for the user
        2.  return with error
    }
    
    if ((MBR disk) && ((there is no space for primary partition) ||
            (region is in a container space)){
        1.  create a logical drive using SpPtnCreateLogicalDrive()    
    } else {    
        1. align the start sector.
        2. create the required GPT/MBR partition.
    }                
       
Arguments:

    Region  -   The region representing the free space on disk
                where the partition needs to be created.

    ActualRegion    - Place holder, for the region which will
                        represent the actual partition after
                        creating it.

    ForNT       -   Indicates whether to use the given desired size
                    argument or not.                    

    DesiredSize -   The size of the partition to created

    PartInfo    -   The partition attributes to use while creating
                    the new partition

    ConfirmIt   -   Whether to pop up error dialogs, if something
                    goes wrong while creating the partition

Return Value:

    TRUE if successful otherwise FALSE

--*/        
{
    BOOLEAN     Result = FALSE;
    ULONG       DiskNumber = Region->DiskNumber;
    ULONGLONG   MinMB = 0, MaxMB = 0;
    ULONGLONG   SizeMB = 0;
    BOOLEAN     ReservedRegion = FALSE;
    PHARD_DISK  Disk = SPPT_GET_HARDDISK(DiskNumber);    
    

    if (SPPT_IS_MBR_DISK(DiskNumber)) {
        ULONG   PrimaryCount = 0;
        ULONG   ContainerCount = 0;
        ULONG   LogicalCount = 0;
        ULONG   ValidPrimaryCount = 0;
        BOOLEAN InContainer = FALSE;
        BOOLEAN FirstContainer = FALSE;

        SpPtnGetPartitionTypeCounts(DiskNumber, 
                            TRUE,
                            &PrimaryCount, 
                            &ContainerCount, 
                            &LogicalCount,
                            &ValidPrimaryCount,
                            NULL);

        //
        // Create a logical drive if we have a valid primary
        // or there is no more space for another primary
        //
        FirstContainer = (ContainerCount == 0) && (ValidPrimaryCount > 0);                                 

        InContainer = (Region->Container != NULL);                            

        //
        // We allow only one partition on the removable media (?)
        //
        if (SPPT_IS_REMOVABLE_DISK(DiskNumber)) {
            if (PrimaryCount || ContainerCount || LogicalCount) {
                ULONG ValidKeys[2] = { ASCI_CR ,0 };

                //
                // Disk is already partitioned
                //
                SpDisplayScreen(SP_SCRN_REMOVABLE_ALREADY_PARTITIONED,
                                3,
                                HEADER_HEIGHT + 1);
                                
                SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
                                SP_STAT_ENTER_EQUALS_CONTINUE,
                                0);
                                
                SpWaitValidKey(ValidKeys, NULL, NULL);
                
                return  FALSE;
            }
        } else {
            if (FirstContainer || InContainer) {
                //
                // create the logical drive
                //
                Result = SpPtnCreateLogicalDrive(DiskNumber,
                                Region->StartSector,
                                0,          // SizeInSectors: used only in the ASR case
                                ForNT,
                                TRUE,       // AlignToCylinder
                                DesiredMB,
                                PartInfo,
                                ActualRegion);

                if (!Result) {
                    KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
                        "SETUP: SpPtnCreateLogicalDrive() failed\n"));            
                }


                return Result;
            }     

            //
            // check to see if there is no space in the partition table
            //
            if (PrimaryCount >= (PTABLE_DIMENSION - 1)) {                            
                //
                // Let the user know that the partition table is full
                //
                if (ConfirmIt) {
                    while (TRUE) {
                        ULONG Keys[2] = {ASCI_CR, 0};

                        SpDisplayScreen(SP_SCRN_PART_TABLE_FULL,
                                        3,
                                        CLIENT_TOP + 1);

                        SpDisplayStatusOptions(
                            DEFAULT_STATUS_ATTRIBUTE,
                            SP_STAT_ENTER_EQUALS_CONTINUE,
                            0
                            );

                        if (SpWaitValidKey(Keys, NULL, NULL) == ASCI_CR)
                            return  FALSE;
                    }
                } else {
                    return TRUE;
                }
            }                
        }            
    } 

    //
    // need to create the primary / GPT partition
    //
    SpPtQueryMinMaxCreationSizeMB(DiskNumber,
                                Region->StartSector,
                                FALSE,
                                TRUE,
                                &MinMB,
                                &MaxMB,
                                &ReservedRegion
                                );

    if (ReservedRegion) {
        ULONG ValidKeys[2] = {ASCI_CR , 0};

        SpStartScreen(
            SP_SCRN_REGION_RESERVED,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE
            );

        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_ENTER_EQUALS_CONTINUE,
                    0);
                    
        SpWaitValidKey(ValidKeys, NULL, NULL);
        
        return FALSE;
    }

    if (ForNT) {
        //
        // If a size was requested then try to use that, otherwise use
        // the maximum.
        //
        if (DesiredMB) {
            if (DesiredMB <= MaxMB) {
                SizeMB = DesiredMB;
            } else {
                return FALSE;   // don't have the space user requested
            }
        } else {
            SizeMB = MaxMB;
        }
    } else {
        if (!SpPtnGetSizeFromUser(Disk, MinMB, MaxMB, &SizeMB))
            return FALSE;   // user didn't want to proceed

        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, 
                SP_STAT_PLEASE_WAIT,
                0);
    }

    //SpPtDumpDiskRegionInformation(DiskNumber, FALSE);
    
    //
    // Create the partition.
    //
    Result = SpPtnCreate(
                Region->DiskNumber,
                Region->StartSector,
                0,          // SizeInSectors: used only in the ASR case
                SizeMB,
                FALSE,
                TRUE,       // AlignToCylinder
                PartInfo,
                ActualRegion
                );
                            
    //SpPtDumpDiskRegionInformation(DiskNumber, FALSE);

    if (!Result) {
        KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  
            "SETUP: SpPtnCreate() failed \n"));
    }
    
    return Result;
}

    
BOOLEAN
SpPtnDoDelete(
    IN PDISK_REGION pRegion,
    IN PWSTR        RegionDescription,
    IN BOOLEAN      ConfirmIt
    )
/*++

Routine Description:

    Given the region which was selected by the user,
    this routine prompts the user then calls the
    actual deletion routine

Argument:
    pRegion -   Region selected by the user which
                needs to be deleted

    RegionDescription   -   Description of the
                            region

    ConfirmIt   -   Whether the deletion needs to be
                    confirmed
                    
Return Value:

    TRUE if deletion was carried out and was successful.
    
    FALSE if deletion was cancelled or could not be carried
    out because of some other error.
    
++*/                    

{
    ULONG ValidKeys[3] = { ASCI_ESC, ASCI_CR, 0 };          // do not change order
    ULONG Mnemonics[2] = { MnemonicDeletePartition2, 0 };    
    PHARD_DISK  Disk;
    ULONG Key;
    BOOLEAN Result = FALSE;


    //
    // Prompt for MSR deletion
    //
    if (SPPT_IS_GPT_DISK(pRegion->DiskNumber) &&
        SPPT_IS_REGION_MSFT_RESERVED(pRegion) && ConfirmIt) {

        SpDisplayScreen(SP_SCRN_CONFIRM_REMOVE_MSRPART, 3, HEADER_HEIGHT+1);

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            SP_STAT_ESC_EQUALS_CANCEL,
            0
            );

        if(SpWaitValidKey(ValidKeys,NULL,NULL) == ASCI_ESC) {
            return Result;
        }        
    }

    //
    // Special warning if this is a system partition.
    //
    // Do not check system partition on NEC98.
    //
    if (!IsNEC_98) { //NEC98
        if(ConfirmIt && pRegion->IsSystemPartition) {

            SpDisplayScreen(SP_SCRN_CONFIRM_REMOVE_SYSPART,3,HEADER_HEIGHT+1);

            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_ENTER_EQUALS_CONTINUE,
                SP_STAT_ESC_EQUALS_CANCEL,
                0
                );

            if(SpWaitValidKey(ValidKeys,NULL,NULL) == ASCI_ESC) {
                return Result;
            }
        }
    } //NEC98

    if(ConfirmIt && (pRegion->DynamicVolume || SPPT_IS_REGION_LDM_METADATA(pRegion))) {

        SpDisplayScreen(SP_SCRN_CONFIRM_REMOVE_DYNVOL,3,HEADER_HEIGHT+1);

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            SP_STAT_ESC_EQUALS_CANCEL,
            0
            );

        if(SpWaitValidKey(ValidKeys,NULL,NULL) == ASCI_ESC) {
            return Result;
        }
    }

    //
    // CR is no longer a valid key.
    //
    ValidKeys[1] = 0;

    //
    // Display the staus text.
    //
    if (ConfirmIt) {
        Disk = SPPT_GET_HARDDISK(pRegion->DiskNumber);
        
        SpStartScreen(
            SP_SCRN_CONFIRM_REMOVE_PARTITION,
            3,
            CLIENT_TOP+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            RegionDescription,
            Disk->Description
            );
            
        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_L_EQUALS_DELETE,
            SP_STAT_ESC_EQUALS_CANCEL,
            0
            );

        Key = SpWaitValidKey(ValidKeys,NULL,Mnemonics);

        if(Key == ASCI_ESC) {
            return Result;
        }

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_PLEASE_WAIT,
            0);        
    }

    //
    // Delete the bootset, if any, for the region
    //
    SpPtDeleteBootSetsForRegion(pRegion);

    //
    // Now go ahead and delete it.
    //
    Result = SpPtDelete(pRegion->DiskNumber,pRegion->StartSector);
    
    if (!Result) {
        if (ConfirmIt) {
            SpDisplayScreen(SP_SCRN_PARTITION_DELETE_FAILED,3,HEADER_HEIGHT+1);
            SpDisplayStatusText(SP_STAT_ENTER_EQUALS_CONTINUE,DEFAULT_STATUS_ATTRIBUTE);
            SpInputDrain();
            
            while(SpInputGetKeypress() != ASCI_CR) ;
        }
        
        return Result;
    }


    //
    //  Delete the drive letters if the necessary. This is to ensure that 
    //  the drive letters assigned to CD-ROM drives will go away, 
    //  when the the disks have no partitioned space.
    //
    SpPtDeleteDriveLetters();

    return Result;
}

VOID
SpPtnMakeRegionActive(
    IN PDISK_REGION Region
    )
/*++

Routine Description:

    Makes the given region active (i.e. converts into system partition).
    Is valid only for MBR disks. Makes all the other regions
    inactive on the disk
    
Arguments:

    Region  -   The region (primary partition) which needs to made
                active.

Return Value:

    None.

--*/        
{
    static BOOLEAN WarnedOtherOS = FALSE;
    
    if (Region && SPPT_IS_REGION_PRIMARY_PARTITION(Region)) {
        PDISK_REGION    CurrRegion = SPPT_GET_PRIMARY_DISK_REGION(Region->DiskNumber);

        while (CurrRegion) {            
            if ((Region != CurrRegion) && 
                SPPT_IS_REGION_ACTIVE_PARTITION(CurrRegion)) {
                 
                //
                // Give the warning for the first time
                //
                if (!WarnedOtherOS && !UnattendedOperation) {        
                    SpDisplayScreen((SPPT_GET_PARTITION_TYPE(CurrRegion) == 10) ? 
                                        SP_SCRN_BOOT_MANAGER : SP_SCRN_OTHER_OS_ACTIVE,
                                    3,
                                    HEADER_HEIGHT + 1);

                    SpDisplayStatusText(SP_STAT_ENTER_EQUALS_CONTINUE,
                            DEFAULT_STATUS_ATTRIBUTE);

                    SpInputDrain();

                    while (SpInputGetKeypress() != ASCI_CR) ;

                    WarnedOtherOS = TRUE;            
                }

                SPPT_MARK_REGION_AS_ACTIVE(CurrRegion, FALSE);
                SPPT_SET_REGION_DIRTY(CurrRegion, TRUE);
            }

            CurrRegion = CurrRegion->Next;
        }
        
        SPPT_MARK_REGION_AS_ACTIVE(Region, TRUE);
        SPPT_SET_REGION_DIRTY(Region, TRUE);        
    }                
}


BOOLEAN
SpPtMakeDiskRaw(
    IN ULONG DiskNumber
    )
/*++

Routine Description:

    Converts the given disk to RAW i.e. Zaps couple of first
    sectors which have information about the disk format
    
Arguments:

    DiskNumber  :   Disk Index, to converted into RAW

Return Value:

    TRUE, if successful, otherwise FALSE

--*/        
{
    BOOLEAN Result = FALSE;

    if (DiskNumber < HardDiskCount) {
        HANDLE      DiskHandle;
        NTSTATUS    Status;
        WCHAR       DiskName[256];

        swprintf(DiskName, L"\\Device\\Harddisk%u", DiskNumber);        

        //
        // Open partition 0 on this disk..
        //
        Status = SpOpenPartition0(DiskName, &DiskHandle, TRUE);

        if(NT_SUCCESS(Status)){
            PHARD_DISK  Disk = SPPT_GET_HARDDISK(DiskNumber);
            ULONG       BytesPerSector = Disk->Geometry.BytesPerSector;
            ULONG       BufferSize = (BytesPerSector * 2);
            PVOID       UBuffer = SpMemAlloc(BufferSize);    

            if (UBuffer) {
                PVOID Buffer = UBuffer;
                
                RtlZeroMemory(UBuffer, BufferSize);
                
                Buffer = ALIGN(Buffer, BytesPerSector);

                //
                // Wipe out 0'th sector
                //
                Status = SpReadWriteDiskSectors(DiskHandle,
                                0,
                                1,
                                BytesPerSector,
                                Buffer,
                                TRUE);


                if (NT_SUCCESS(Status)) {                                
                    //
                    // Wipe out 1st sector
                    //
                    Status = SpReadWriteDiskSectors(DiskHandle,
                                    1,
                                    1,
                                    BytesPerSector,
                                    Buffer,
                                    TRUE);
                                    
                    if (NT_SUCCESS(Status)) {                                
                        //
                        // Wipe out 2nd sector
                        //
                        Status = SpReadWriteDiskSectors(DiskHandle,
                                        2,
                                        1,
                                        BytesPerSector,
                                        Buffer,
                                        TRUE);
                    }                                                                                    
                }                    
            } else {
                Status = STATUS_NO_MEMORY;
            }

            ZwClose(DiskHandle);
        }            

        Result = NT_SUCCESS(Status);
    }


    if (Result) {
        SpPtnFreeDiskRegions(DiskNumber);
    }                

    return Result;
}


VOID
SpPtnDeletePartitionsForRemoteBoot(
    PPARTITIONED_DISK PartDisk,
    PDISK_REGION StartRegion,
    PDISK_REGION EndRegion,
    BOOLEAN Extended
    )
/*++

Routine Description:

    Deletes the specified start region and end region partitions
    and all the partitions in between them.
    
Arguments:

    PartDisk    :   The partitioned disk
    StartRegion :   The starting region for deletion
    EndRegion   :   The Ending region for deletion
    Extended    :   Not used (for backward compatability)

Return Value:

    None

--*/        
{
    PDISK_REGION    CurrRegion = StartRegion;
    BOOLEAN         FirstContainerDeleted = FALSE;
    ULONG           DiskNumber = StartRegion ? 
                        StartRegion->DiskNumber : EndRegion->DiskNumber;
    BOOLEAN         Changes = FALSE;                                
    NTSTATUS        Status;
    NTSTATUS        InitStatus;

    //
    // Mark all the regions which need to be deleted
    //
    while (CurrRegion && (CurrRegion != EndRegion)) {
        if (!SPPT_IS_REGION_FREESPACE(CurrRegion)) {
            SPPT_SET_REGION_DELETED(CurrRegion, TRUE);
            SPPT_SET_REGION_DIRTY(CurrRegion, TRUE);

            if (SPPT_IS_REGION_FIRST_CONTAINER_PARTITION(CurrRegion))
                FirstContainerDeleted = TRUE;
                
            //
            // Remove any boot sets pointing to this region.
            //
            SpPtDeleteBootSetsForRegion(CurrRegion);

            //
            //  Get rid of the compressed drives, if any
            //

            if( CurrRegion->NextCompressed != NULL ) {
                SpDisposeCompressedDrives( CurrRegion->NextCompressed );
                CurrRegion->NextCompressed = NULL;
                CurrRegion->MountDrive  = 0;
                CurrRegion->HostDrive  = 0;
            }
        }

        CurrRegion = CurrRegion->Next;
    }

    if (EndRegion && CurrRegion && (CurrRegion == EndRegion)){
        if (!SPPT_IS_REGION_FREESPACE(CurrRegion)) {
            SPPT_SET_REGION_DELETED(CurrRegion, TRUE);
            SPPT_SET_REGION_DIRTY(CurrRegion, TRUE);

            if (SPPT_IS_REGION_FIRST_CONTAINER_PARTITION(CurrRegion))
                FirstContainerDeleted = TRUE;

            //
            // Remove any boot sets pointing to this region.
            //
            SpPtDeleteBootSetsForRegion(CurrRegion);

            //
            //  Get rid of the compressed drives, if any
            //

            if( CurrRegion->NextCompressed != NULL ) {
                SpDisposeCompressedDrives( CurrRegion->NextCompressed );
                CurrRegion->NextCompressed = NULL;
                CurrRegion->MountDrive  = 0;
                CurrRegion->HostDrive  = 0;
            }
        }
    }            

    //
    // If the first container partition was deleted then delete
    // all the container and logical partitions,
    //
    if (FirstContainerDeleted) {
        CurrRegion = PartDisk->PrimaryDiskRegions;

        while (CurrRegion) {
            if (SPPT_IS_REGION_CONTAINER_PARTITION(CurrRegion) ||
                SPPT_IS_REGION_LOGICAL_DRIVE(CurrRegion)) {
                
                SPPT_SET_REGION_DELETED(CurrRegion, TRUE);
                SPPT_SET_REGION_DIRTY(CurrRegion, TRUE);                

                //
                // Remove any boot sets pointing to this region.
                //
                SpPtDeleteBootSetsForRegion(CurrRegion);

                //
                //  Get rid of the compressed drives, if any
                //

                if( CurrRegion->NextCompressed != NULL ) {
                    SpDisposeCompressedDrives( CurrRegion->NextCompressed );
                    CurrRegion->NextCompressed = NULL;
                    CurrRegion->MountDrive  = 0;
                    CurrRegion->HostDrive  = 0;
                }                
            }

            CurrRegion = CurrRegion->Next;
        }
    }

    //
    // Commit the changes
    //
    Status = SpPtnCommitChanges(DiskNumber, &Changes);

    //
    // Initialize region structure for the disk again
    //
    InitStatus = SpPtnInitializeDiskDrive(DiskNumber);

    if (!NT_SUCCESS(Status) || !Changes || !NT_SUCCESS(InitStatus)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
            "SETUP:SpPtnDeletePartitionsForRemoteBoot(%p, %p, %p, %d) failed "
            "with %lx status\n",
            PartDisk,
            StartRegion,
            EndRegion,
            Extended,
            Status));
    }
}


NTSTATUS
SpPtnMakeRegionArcSysPart(
    IN PDISK_REGION Region
    )
/*++

Routine Description:

    Makes the given region a system partition on ARC machines
    
Arguments:

    Region  -   The region which needs to be convered to system 
                partition

Return Value:

    STATUS_SUCCESS if successful, otherwise appropriate error
    code.

--*/        
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if (Region && SpIsArc() && !ValidArcSystemPartition) {
        if (SPPT_IS_MBR_DISK(Region->DiskNumber)) {
            if (SPPT_IS_REGION_PRIMARY_PARTITION(Region)) {
                SpPtnMakeRegionActive(Region);    
                SPPT_MARK_REGION_AS_SYSTEMPARTITION(Region, TRUE);
                SPPT_SET_REGION_DIRTY(Region, TRUE);                
                Status = STATUS_SUCCESS;
            }                
        } else {
            WCHAR   RegionName[MAX_PATH];
            
            SPPT_MARK_REGION_AS_SYSTEMPARTITION(Region, TRUE);
            SPPT_SET_REGION_DIRTY(Region, TRUE);

            //
            // Remove the drive letter also
            //
            swprintf(RegionName, 
                L"\\Device\\Harddisk%u\\Partition%u",
                Region->DiskNumber,
                Region->PartitionNumber);
                
            SpDeleteDriveLetter(RegionName);            
            Region->DriveLetter = 0;
            
            Status = STATUS_SUCCESS;
        }
    }
    
    return Status;
}


ULONG
SpPtnCountPartitionsByFSType(
    IN ULONG DiskId,
    IN FilesystemType   FsType
    )
/*++

Routine Description:

    Counts the partition based on the file system type. 

    Note : The partitions which are marked 
           deleted are skipped.
    
Arguments:

    DiskId  :   The disk on which the partitions need to be
                counted

    FsType  :   File system type which needs to present on
                the partitions

Return Value:

    Number of partitions containing the requested file system

--*/        
{
    ULONG   Count = 0;

    if ((FsType < FilesystemMax) && (DiskId < HardDiskCount)) {
        PDISK_REGION    Region = SPPT_GET_PRIMARY_DISK_REGION(DiskId);

        while (Region) {
            if (SPPT_IS_REGION_PARTITIONED(Region) && 
                !SPPT_IS_REGION_MARKED_DELETE(Region) &&
                (Region->Filesystem == FsType)) {

                Count++;
            }           
            
            Region = Region->Next;
        }
    }
    
    return Count;
}


PDISK_REGION
SpPtnLocateESP(
    VOID
    )
{
    PDISK_REGION    EspRegion = NULL;
    ULONG Index;

    for (Index=0; (Index < HardDiskCount) && (!EspRegion); Index++) {
        if (SPPT_IS_GPT_DISK(Index)) {
            PDISK_REGION CurrRegion = SPPT_GET_PRIMARY_DISK_REGION(Index);

            while (CurrRegion) {
                if (SPPT_IS_REGION_PARTITIONED(CurrRegion) &&
                        SPPT_IS_REGION_EFI_SYSTEM_PARTITION(CurrRegion)) {
                    EspRegion = CurrRegion;

                    break;  // found the first ESP
                }                    

                CurrRegion = CurrRegion->Next;
            }
        }
    }

    return EspRegion;
}


NTSTATUS
SpPtnCreateESPForDisk(
    IN ULONG   DiskId
    )
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PDISK_REGION EspCandidateRegion = SPPT_GET_PRIMARY_DISK_REGION(DiskId);

    if (EspCandidateRegion && SpPtnIsValidESPRegion(EspCandidateRegion)) {        
        ULONG DiskId = EspCandidateRegion->DiskNumber;
        ULONGLONG   SizeMB = SpPtnGetDiskESPSizeMB(DiskId);
        PARTITION_INFORMATION_EX PartInfo;            
        PDISK_REGION EspRegion = NULL;
        BOOLEAN CreateResult;

        RtlZeroMemory(&PartInfo, sizeof(PARTITION_INFORMATION_EX));
        PartInfo.PartitionStyle = PARTITION_STYLE_GPT;
        PartInfo.Gpt.Attributes = 1;    // required ???
        PartInfo.Gpt.PartitionType = PARTITION_SYSTEM_GUID;
        SpCreateNewGuid(&(PartInfo.Gpt.PartitionId));
                
        CreateResult = SpPtnCreate(DiskId,
                            EspCandidateRegion->StartSector,
                            0,          // SizeInSectors: used only in the ASR case
                            SizeMB,
                            FALSE,
                            TRUE,
                            &PartInfo,
                            &EspRegion);
                    
                    
        if (CreateResult) {
            //
            // format this region
            //
            WCHAR   RegionDescr[128];
            
            //
            // Mark this region as ESP
            //
            SPPT_MARK_REGION_AS_SYSTEMPARTITION(EspRegion, TRUE);
            SPPT_SET_REGION_DIRTY(EspRegion, TRUE);
            ValidArcSystemPartition = TRUE;
            
            SpPtRegionDescription(
                SPPT_GET_PARTITIONED_DISK(EspRegion->DiskNumber),
                EspRegion,
                RegionDescr,
                sizeof(RegionDescr));

            if (!SetupSourceDevicePath || !DirectoryOnSetupSource) {                
                SpGetWinntParams(&SetupSourceDevicePath, &DirectoryOnSetupSource);                    
            }

            Status = SpDoFormat(RegionDescr,
                        EspRegion,
                        FilesystemFat,
                        TRUE,
                        TRUE,
                        FALSE,
                        SifHandle,
                        0,  // default cluster size
                        SetupSourceDevicePath,
                        DirectoryOnSetupSource);

            if (!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                    "SETUP:SpPtnCreateESP() failed to"
                    " format ESP partition for %p region (%lx)\n",
                    EspRegion,
                    Status));
            } else {
                BOOLEAN AnyChanges = FALSE;

                Status = SpPtnCommitChanges(EspRegion->DiskNumber,
                                &AnyChanges);   

                if (!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                        "SETUP:SpPtnCreateESP() failed to"
                        " commit changes to disk (%lx)\n",
                        Status));
                }                  
                
                Status = SpPtnInitializeDiskDrive(EspRegion->DiskNumber);

                if (!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                        "SETUP:SpPtnCreateESP() failed to"
                        " reinitialize disk regions (%lx)\n",
                        Status));
                }                                      
            }
        } else {
            Status = STATUS_UNSUCCESSFUL;
            
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                "SETUP:SpPtnCreateESP() failed to"
                " create ESP partition for %p region (%lx)\n",
                EspRegion,
                Status));
        }
    }                
    
    return Status;
}

NTSTATUS
SpPtnCreateESP(
    IN  BOOLEAN PromptUser
    )
{
    NTSTATUS Status = STATUS_CANCELLED;
    BOOLEAN Confirmed = FALSE;

    if (ValidArcSystemPartition) {
        Status = STATUS_SUCCESS;

        return Status;
    }

    if (UnattendedOperation) {
        Confirmed = TRUE;
    } else {
        if (PromptUser) {
            //
            // Prompt the user for confirmation
            //
            ULONG ValidKeys[] = { ASCI_CR, ASCI_ESC, 0 };
            ULONG UserOption = ASCI_CR;

            SpDisplayScreen(SP_AUTOCREATE_ESP, 3, HEADER_HEIGHT+1);

            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_ENTER_EQUALS_CONTINUE,
                SP_STAT_ESC_EQUALS_CANCEL,
                0);

            //
            // Wait for user input
            //
            SpInputDrain();
            
            UserOption = SpWaitValidKey(ValidKeys, NULL, NULL);

            if (UserOption == ASCI_CR) {
                Confirmed = TRUE;
            }            
        } else {
            Confirmed = TRUE;
        }            
    }

    if (Confirmed) {
        WCHAR ArcDiskName[MAX_PATH];
        ULONG DiskNumber;
        ULONG ArcDiskNumber;
        PDISK_REGION EspCandidateRegion = NULL;

        //
        // Find the first harddisk (non-removable) media that the 
        // BIOS enumerated to be used for system partition
        //
        for (DiskNumber = 0, Status = STATUS_UNSUCCESSFUL;
            (!NT_SUCCESS(Status) && (DiskNumber < HardDiskCount));
            DiskNumber++) {         

            swprintf(ArcDiskName, L"multi(0)disk(0)rdisk(%d)", DiskNumber);       
            ArcDiskNumber = SpArcDevicePathToDiskNumber(ArcDiskName);        

            //
            // Make sure its not removable disk and its reachable by firmware
            //
            if ((ArcDiskNumber == (ULONG)-1) || SPPT_IS_REMOVABLE_DISK(ArcDiskNumber)) {
                continue;   // get to the next disk                
            }

            Status = SpPtnCreateESPForDisk(ArcDiskNumber);
        }

        if (PromptUser && !NT_SUCCESS(Status)) {
            ULONG ValidKeys[] = { ASCI_CR, 0 };

            ValidArcSystemPartition = FALSE;

            SpDisplayScreen(SP_AUTOCREATE_ESP_FAILED, 3, HEADER_HEIGHT+1);

            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_ENTER_EQUALS_CONTINUE,
                0);

            //
            // Wait for user input
            //
            SpInputDrain();
            
            SpWaitValidKey(ValidKeys, NULL, NULL);
        }        
    } else {
        Status = STATUS_CANCELLED;
    }        
    
    return Status;
}

NTSTATUS
SpPtnInitializeGPTDisk(
    IN ULONG DiskNumber
    )
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if ((DiskNumber < HardDiskCount) && (SPPT_IS_GPT_DISK(DiskNumber))) {
        PDISK_REGION CurrRegion = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);
        PDISK_REGION EspRegion = NULL;
        PDISK_REGION MsrRegion = NULL;

        while (CurrRegion && !EspRegion && !MsrRegion) {
            if (SPPT_IS_REGION_EFI_SYSTEM_PARTITION(CurrRegion)) {
                EspRegion = CurrRegion;
            } else if (SPPT_IS_REGION_MSFT_RESERVED(CurrRegion)) {
                MsrRegion = CurrRegion;
            }                                
            
            CurrRegion = CurrRegion->Next;
        }

        if (!MsrRegion) {
            PDISK_REGION MsrCandidate = NULL;
            
            if (EspRegion) {
                MsrCandidate = EspRegion->Next;
            } else {
                MsrCandidate = SPPT_GET_PRIMARY_DISK_REGION(DiskNumber);
            }

            if (MsrCandidate && SpPtnIsValidMSRRegion(MsrCandidate)) {
                PARTITION_INFORMATION_EX PartInfo;            
                PDISK_REGION MsrRegion = NULL;
                ULONGLONG SizeMB = SpPtnGetDiskMSRSizeMB(DiskNumber);
                BOOLEAN CreateResult;

                RtlZeroMemory(&PartInfo, sizeof(PARTITION_INFORMATION_EX));
                PartInfo.PartitionStyle = PARTITION_STYLE_GPT;
                PartInfo.Gpt.Attributes = 0;    // required ???
                PartInfo.Gpt.PartitionType = PARTITION_MSFT_RESERVED_GUID;
                SpCreateNewGuid(&(PartInfo.Gpt.PartitionId));
                                
                CreateResult = SpPtnCreate(DiskNumber,
                                    MsrCandidate->StartSector,
                                    0,          // SizeInSectors: used only in the ASR case
                                    SizeMB,
                                    FALSE,
                                    TRUE,
                                    &PartInfo,
                                    &MsrRegion);

                Status = CreateResult ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
                            
                if (!NT_SUCCESS(Status)) {                                
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                        "SETUP:SpPtnInitializeGPTDisk() failed with "
                        " (%lx)\n",
                        Status));
                }
            } else {
                Status = STATUS_SUCCESS;
            }
        } else {
            Status = STATUS_SUCCESS;
        }
    }

    return Status;
}

NTSTATUS
SpPtnInitializeGPTDisks(
    VOID
    )
{
    NTSTATUS LastError = STATUS_SUCCESS;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG DiskNumber;

    for (DiskNumber = 0; (DiskNumber < HardDiskCount); DiskNumber++) {
        if (SPPT_IS_GPT_DISK(DiskNumber)) {
            Status = SpPtnInitializeGPTDisk(DiskNumber);

            if (!NT_SUCCESS(Status)) {
                LastError = Status;
            }
        }            
    }

    return LastError;
}


NTSTATUS
SpPtnRepartitionGPTDisk(
    IN ULONG           DiskId,
    IN ULONG           MinimumFreeSpaceKB,
    OUT PDISK_REGION   *RegionToInstall
    )
/*++

Routine Description:

    Repartitions a given disk for unattended and remote
    boot install case
    
Arguments:

    DiskId  :   The disk which needs to be repartitioned

    MinimumFreeSpace : Minimum space required in KB

    RegionToInstall : Place holder for the region which
                      will be selected for installation.


Return Value:

    Appropriate status code.

--*/        
{
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;

    if ((DiskId < HardDiskCount) && !SPPT_IS_REMOVABLE_DISK(DiskId)) {
        PDISK_REGION    CurrentRegion = SPPT_GET_PRIMARY_DISK_REGION(DiskId);
        BOOLEAN         Changes = FALSE;

        //
        // Mark all the existing partitioned space on the disk
        // for deletion
        //
        while (CurrentRegion) {
            if (SPPT_IS_REGION_PARTITIONED(CurrentRegion)) {
                SPPT_SET_REGION_DELETED(CurrentRegion, TRUE);
                SPPT_SET_REGION_DIRTY(CurrentRegion, TRUE);
                Changes = TRUE;
            }
            
            CurrentRegion = CurrentRegion->Next;
        }

        //
        // Delete all the partitioned space on the disk
        //
        if (Changes) {
            Status = SpPtnCommitChanges(DiskId, &Changes);
        } else {
            Status = STATUS_SUCCESS;
        }            

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        //
        // Update the in memory region structure for the disk
        //
        Status = SpPtnInitializeDiskDrive(DiskId);

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        //
        // Reinitialize the disk style to GPT to be sure its
        // GPT disk
        //
        SPPT_SET_DISK_BLANK(DiskId, TRUE);

        Status = SpPtnInitializeDiskStyle(DiskId,
                    PARTITION_STYLE_GPT,
                    NULL);

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        //
        // Update the in memory region structure for the disk
        //
        Status = SpPtnInitializeDiskDrive(DiskId);

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        //
        // First create the ESP on the disk
        //
        Status = SpPtnCreateESPForDisk(DiskId);

        if (!NT_SUCCESS(Status)) {
            return Status;
        }        

        //
        // Create the MSR partition 
        //
        Status = SpPtnInitializeGPTDisk(DiskId);

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        //
        // Find the first free space region with adequate space
        //       
        CurrentRegion = SPPT_GET_PRIMARY_DISK_REGION(DiskId);

        while (CurrentRegion) {
            if (SPPT_IS_REGION_FREESPACE(CurrentRegion) &&
                (SPPT_REGION_FREESPACE_KB(CurrentRegion) >= MinimumFreeSpaceKB)) {

                break;                
            }

            CurrentRegion = CurrentRegion->Next;
        }

        if (CurrentRegion) {
            *RegionToInstall = CurrentRegion;   
        } else {
            Status = STATUS_UNSUCCESSFUL;
        }            
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spsif.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spsif.c

Abstract:

    Section names and other data used for indexing into
    setup information files.

Author:

    Ted Miller (tedm) 31-August-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop

//
// [DiskDriverMap]
//
PWSTR SIF_DISKDRIVERMAP = L"DiskDriverMap";

PWSTR SIF_SETUPMEDIA = L"SourceDisksNames";
PWSTR SIF_FILESONSETUPMEDIA = L"SourceDisksFiles";

//
// [Files.KeyboardLayout]
//
PWSTR SIF_KEYBOARDLAYOUTFILES = L"Files.KeyboardLayout";
PWSTR SIF_KEYBOARDLAYOUTDESC = L"Keyboard Layout";

//
// [Files.Vga]
//
PWSTR SIF_VGAFILES = L"Files.Vga";

//
// [WinntDirectories]
//
PWSTR SIF_NTDIRECTORIES = L"WinntDirectories";

//
// [SystemPartitionFiles]
//
PWSTR SIF_SYSPARTCOPYALWAYS = L"SystemPartitionFiles";

//
// [SystemPartitionRoot]
//
PWSTR SIF_SYSPARTROOT       = L"SystemPartitionRoot";


//
// [SystemPartitionUtilities]
//
PWSTR SIF_SYSPARTUTIL       = L"SystemPartitionUtilities";

//
// [Keyboard Layout]
//
PWSTR SIF_KEYBOARDLAYOUT = L"Keyboard Layout";

#if defined(REMOTE_BOOT)
//
// [Files.RemoteBoot]
//
PWSTR SIF_REMOTEBOOTFILES = L"Files.RemoteBoot";
#endif // defined(REMOTE_BOOT)

//
// [SpecialFiles]
// Multiprocessor =
// Uniprocessor   =
// Atdisk =
// abiosdsk =
// mouseclass =
// keyboardclass =
//
PWSTR SIF_SPECIALFILES      = L"SpecialFiles";
PWSTR SIF_MPKERNEL          = L"Multiprocessor";
PWSTR SIF_UPKERNEL          = L"Uniprocessor";
PWSTR SIF_ATDISK            = L"atdisk";
PWSTR SIF_ABIOSDISK         = L"abiosdsk";
PWSTR SIF_MOUSECLASS        = L"MouseClass";
PWSTR SIF_KEYBOARDCLASS     = L"KeyboardClass";

//
// [bootvid]
//
PWSTR SIF_BOOTVID = L"bootvid";

//
// [hal]
//
PWSTR SIF_HAL = L"hal";

//
// [ntdetect]
// standard =
//
PWSTR SIF_NTDETECT = L"ntdetect";
PWSTR SIF_STANDARD = L"standard";

//
//  [BootBusExtenders]
//
PWSTR SIF_BOOTBUSEXTENDERS = L"BootBusExtenders";

//
//  [BusExtenders]
//
PWSTR SIF_BUSEXTENDERS = L"BusExtenders";

//
//  [InputDevicesSupport]
//
PWSTR SIF_INPUTDEVICESSUPPORT = L"InputDevicesSupport";


//
// Driver load lists.
//
PWSTR SIF_SCSICLASSDRIVERS = L"ScsiClass";
PWSTR SIF_DISKDRIVERS      = L"DiskDrivers";
PWSTR SIF_CDROMDRIVERS     = L"CdRomDrivers";
PWSTR SIF_FILESYSTEMS      = L"FileSystems";

//
// [SetupData]
// ProductType =
//      0 = workstation
//      1 = server
//      2 = advanced server (subset of server)
//      3 = datacenter server (subset of advanced server)
//      4 = personal (subset of workstation)
//
// FreeDiskSpace =
//      <amount of free space in KB>
// FreeSysPartDiskSpace =
//      <amount of free space on system partition in KB>
// DefaultPath =
//      <default target path, like \winnt for example>
// DefaultLayout =
//      <value that matches an entry in [Keyboard Layout]>
// LoadIdentifier =
//      <LOADIDENTIFIER boot variable: string to display in boot menu>
// BaseVideoLoadId =
//      <string to display in boot menu for VGA mode boot [x86 only]>
// OsLoadOptions =
//      <OSLOADOPTIONS for setup boot>
// OsLoadOptionsVar =
//      <optional OSLOADOPTIONS boot variable value>
// OsLoadOptionsVarAppend =
//      <optional OSLOADOPTIONS boot variable value to be appended to existing options >
// SetupSourceDevice =
//      <OPTIONAL: Nt path of source device, overrides cd-rom, etc>
// SetupSourcePath =
//      <directory on setup source where setup tree is to be found>
// DontCopy =
//      <OPTIONAL: 0,1, indicates whether to skip actual file copying>
// RequiredMemory =
//      <number of bytes of memory required for installation>
// SetupCmdlinePrepend =
//      <value to stick at front of command line, like windbg or ntsd -d>
//
PWSTR SIF_SETUPDATA             = L"SetupData";
PWSTR SIF_DISKSPACEREQUIREMENTS = L"DiskSpaceRequirements";
PWSTR SIF_PRODUCTTYPE           = L"ProductType";
PWSTR SIF_MAJORVERSION          = L"MajorVersion";
PWSTR SIF_MINORVERSION          = L"MinorVersion";
PWSTR SIF_WINDIRSPACE           = L"WindirSpace";
PWSTR SIF_FREESYSPARTDISKSPACE  = L"FreeSysPartDiskSpace";
PWSTR SIF_DEFAULTPATH           = L"DefaultPath";
PWSTR SIF_LOADIDENTIFIER        = L"LoadIdentifier";
PWSTR SIF_BASEVIDEOLOADID       = L"BaseVideoLoadId";
PWSTR SIF_OSLOADOPTIONS         = L"OsLoadOptions";
PWSTR SIF_OSLOADOPTIONSVAR      = L"OsLoadOptionsVar";
PWSTR SIF_OSLOADOPTIONSVARAPPEND = L"OsLoadOptionsVarAppend";
PWSTR SIF_SETUPSOURCEDEVICE     = L"SetupSourceDevice";
PWSTR SIF_SETUPSOURCEPATH       = L"SetupSourcePath";
PWSTR SIF_DONTCOPY              = L"DontCopy";
PWSTR SIF_REQUIREDMEMORY        = L"RequiredMemory";
PWSTR SIF_SETUPCMDPREPEND       = L"SetupCmdlinePrepend";
PWSTR SIF_PAGEFILE              = L"Pagefile";

//
// [nls]
// AnsiCodePage = <filename>,<identifier>
// OemCodePage = <filename>,<identifier>
// MacCodePage = <filename>,<identifier>
// UnicodeCasetable = <filename>
// OemHalFont = <filename>
// DefaultLayout = <identifier>
//
PWSTR SIF_NLS               = L"nls";
PWSTR SIF_ANSICODEPAGE      = L"AnsiCodepage";
PWSTR SIF_OEMCODEPAGE       = L"OemCodepage";
PWSTR SIF_MACCODEPAGE       = L"MacCodepage";
PWSTR SIF_UNICODECASETABLE  = L"UnicodeCasetable";
PWSTR SIF_OEMHALFONT        = L"OemHalFont";
PWSTR SIF_DEFAULTLAYOUT     = L"DefaultLayout";

//
// 1.0 repair disk sections.
//
PWSTR SIF_REPAIRWINNTFILES   = L"Repair.WinntFiles";
PWSTR SIF_REPAIRSYSPARTFILES = L"Repair.BootFiles";


//
// UPGRADE SIF SECTIONS
//

//
// Upgrade Registry sections
// =========================
//
//
// 1. The following section allows us to specify services to disable which may
// cause popups when net services are disabled:
//
// [NetServicesToDisable]
// ServiceName1
// ...
//
// 2. The following section allows us to remove keys which have been removed
// since the Windows NT 3.1 release:
//
// [KeysToDelete]
// RootName1( System | Software | Default | ControlSet ), RootRelativePath1
// ...
//
// 3. The following sections allow us to add/change keys / values under keys
// which have changed since the Windows NT 3.1 release:
//
// [KeysToAdd]
// RootName1, RootRelativePath1, ValueSection1 (can be "")
// ...
//
// [ValueSection1]
// name1 , type1, value1
// name2 , ...
//
// Format of the value is the following
//
// a. Type REG_SZ:          name , REG_SZ,           "value string"
// b. Type REG_EXPAND_SZ    name , REG_EXPAND_SZ,    "value string"
// c. Type REG_MULTI_SZ     name , REG_MULTI_SZ,     "value string1", "value string2", ...
// d. Type REG_BINARY       name , REG_BINARY,       byte1, byte2, ...
// e. Type REG_DWORD        name , REG_DWORD,        dword
// f. Type REG_BINARY_DWORD name , REG_BINARY_DWORD, dword1, dword2, ...
//

PWSTR SIF_NET_SERVICES_TO_DISABLE = L"NetServicesToDisable";
PWSTR SIF_KEYS_TO_DELETE          = L"KeysToDelete";
PWSTR SIF_KEYS_TO_ADD             = L"KeysToAdd";

PWSTR SIF_SYSTEM_HIVE      = L"System";
PWSTR SIF_SOFTWARE_HIVE    = L"Software";
PWSTR SIF_DEFAULT_HIVE     = L"Default";
PWSTR SIF_CONTROL_SET      = L"ControlSet";

PWSTR SIF_REG_SZ            = L"REG_SZ";
PWSTR SIF_REG_EXPAND_SZ     = L"REG_EXPAND_SZ";
PWSTR SIF_REG_MULTI_SZ      = L"REG_MULTI_SZ";
PWSTR SIF_REG_BINARY        = L"REG_BINARY";
PWSTR SIF_REG_BINARY_DWORD  = L"REG_BINARY_DWORD";
PWSTR SIF_REG_DWORD         = L"REG_DWORD";

//
// Upgrade File Sections
// =====================
//
//

//
// Files to backup, delete or move
//
PWSTR SIF_FILESDELETEONUPGRADE   = L"Files.DeleteOnUpgrade";
PWSTR SIF_FILESBACKUPONUPGRADE   = L"Files.BackupOnUpgrade";
PWSTR SIF_FILESBACKUPONOVERWRITE = L"Files.BackupOnOverwrite";

//
// Directories to delete
//

PWSTR SIF_DIRSDELETEONUPGRADE   = L"Directories.DeleteOnUpgrade";


#ifdef _X86_
PWSTR SIF_FILESMOVEBEFOREMIGRATION = L"Files.MoveBeforeMigration";
PWSTR SIF_FILESDELETEBEFOREMIGRATION = L"Files.DeleteBeforeMigration";
#endif

//
// Files to copy
//
PWSTR SIF_FILESUPGRADEWIN31    = L"Files.UpgradeWin31";
PWSTR SIF_FILESNEWHIVES        = L"Files.NewHives";


//
// New sections and keys added to setup.log
//

PWSTR SIF_NEW_REPAIR_WINNTFILES     = L"Files.WinNt";
PWSTR SIF_NEW_REPAIR_SYSPARTFILES   = L"Files.SystemPartition";
PWSTR SIF_NEW_REPAIR_SIGNATURE      = L"Signature";
PWSTR SIF_NEW_REPAIR_VERSION_KEY    = L"Version";
PWSTR SIF_NEW_REPAIR_NT_VERSION     = NULL; // Will be created during the
                                            // initialization of setupdd
                                            //
PWSTR SIF_NEW_REPAIR_NT_VERSION_TEMPLATE= L"WinNt%d.%d";
PWSTR SIF_NEW_REPAIR_PATHS                              = L"Paths";
PWSTR SIF_NEW_REPAIR_PATHS_SYSTEM_PARTITION_DEVICE      = L"SystemPartition";
PWSTR SIF_NEW_REPAIR_PATHS_SYSTEM_PARTITION_DIRECTORY   = L"SystemPartitionDirectory";
PWSTR SIF_NEW_REPAIR_PATHS_TARGET_DEVICE                = L"TargetDevice";
PWSTR SIF_NEW_REPAIR_PATHS_TARGET_DIRECTORY             = L"TargetDirectory";

PWSTR SETUP_REPAIR_DIRECTORY           = L"repair";
PWSTR SETUP_LOG_FILENAME            = L"\\setup.log";

PWSTR SIF_NEW_REPAIR_FILES_IN_REPAIR_DIR    = L"Files.InRepairDirectory";

//
// Unattended mode sections (winnt.sif)
//
PWSTR SIF_DATA                  = WINNT_DATA_W;
PWSTR SIF_UNATTENDED            = WINNT_UNATTENDED_W;
PWSTR SIF_SETUPPARAMS           = WINNT_SETUPPARAMS_W;
PWSTR SIF_CONFIRMHW             = WINNT_U_CONFIRMHW_W;
PWSTR SIF_GUI_UNATTENDED        = WINNT_GUIUNATTENDED_W;
PWSTR SIF_UNATTENDED_INF_FILE   = WINNT_GUI_FILE_W;
PWSTR SIF_UNIQUEID              = WINNT_D_UNIQUEID_W;
PWSTR SIF_ACCESSIBILITY         = WINNT_ACCESSIBILITY_W;

PWSTR SIF_EXTENDOEMPART         = L"ExtendOemPartition";

PWSTR SIF_REMOTEINSTALL         = L"RemoteInstall";
#if defined(REMOTE_BOOT)
PWSTR SIF_REMOTEBOOT            = L"RemoteBoot";
PWSTR SIF_ENABLEIPSECURITY      = L"EnableIpSecurity";
#endif // defined(REMOTE_BOOT)
PWSTR SIF_REPARTITION           = L"Repartition";
PWSTR SIF_USEWHOLEDISK          = L"UseWholeDisk";


PWSTR SIF_INCOMPATIBLE_TEXTMODE = WINNT_OVERWRITE_EXISTING_W;

//
// Alternate Source data
//
PWSTR SIF_UPDATEDSOURCES        = WINNT_SP_UPDATEDSOURCES_W;
//PWSTR SIF_ALTCOPYFILESSECTION   = WINNT_SP_ALTCOPY_W;

PWSTR
SpPlatformSpecificLookup(
    IN PVOID   SifHandle,
    IN PWSTR   Section,
    IN PWSTR   Key,
    IN ULONG   Index,
    IN BOOLEAN Fatal
    )

/*++

Routine Description:

    Look up a value in a platform-specific section and if not found,
    then in a platform-independent section. The platform-specific
    section name is the platform-independent name with .<platform>
    appended to it (where <platform is x86, mips, etc).

Arguments:

    SifHandle - supplies a handle to the open sif in which the
        value is to be found.

    Section - supplies the base section name of the section in which
        the value is to be found.

    Key - supplies the key name of the line in the section in which
        the value is to be found.

    Index - supplies the index (0-based) of the value to be looked up
        on the line with the given Key in the given section or its
        platform-specific analogue.

    Fatal - if TRUE and the value is not found, then this is a fatal error
        and this routine will not return. if FALSE and the value is not
        found, then this routine returns NULL.

Return Value:

    Value located in the section or its platform-specific analog,
    or NULL if it cannot be found and Fatal was FALSE.

--*/

{
    PWSTR p = NULL;
    PWSTR PlatformSpecificSection;

    PlatformSpecificSection = SpMakePlatformSpecificSectionName(Section);

    if (PlatformSpecificSection) {
        p = SpGetSectionKeyIndex(SifHandle,PlatformSpecificSection,Key,Index);
        SpMemFree(PlatformSpecificSection);
    }        

    if(!p) {
        p = SpGetSectionKeyIndex(SifHandle,Section,Key,Index);
    }

    if(!p && Fatal) {
        SpFatalSifError(SifHandle,Section,Key,0,Index);
    }

    return(p);
}


PWSTR
SpLookUpTargetDirectory(
    IN PVOID SifHandle,
    IN PWSTR Symbol
    )

/*++

Routine Description:

    Retreive the target directory associated with a particular
    shortname. The symbol is looked for as a key in the platform-
    specific [WinntDirectories.xxx] section and if not found there,
    in the platform-independent [WinntDirectories] section.

Arguments:

    SifHandle - supplies a handle to the open sif in which the
        [WinntDirectories] sections are to be found.

Return Value:

--*/

{
    PWSTR p;

    p = SpPlatformSpecificLookup(
            SifHandle,
            SIF_NTDIRECTORIES,
            Symbol,
            0,
            TRUE
            );

    return(p);
}


PWSTR
SpLookUpValueForFile(
    IN PVOID   SifHandle,
    IN PWSTR   File,
    IN ULONG   Index,
    IN BOOLEAN Fatal
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PWSTR p;

    p = SpPlatformSpecificLookup(
            SifHandle,
            SIF_FILESONSETUPMEDIA,
            File,
            Index,
            Fatal
            );

    return(p);
}


BOOLEAN
IsFileFlagSet(
    IN PVOID SifHandle,
    IN PWSTR FileName,
    IN ULONG Flag
    )
{
    PWSTR file;
    PWSTR p;
    ULONG flags;
    BOOLEAN b;

    //
    // Locate file name
    //
    if(file = wcsrchr(FileName,L'\\')) {
        file++;
    } else {
        file = FileName;
    }

    if(p = SpGetSectionKeyIndex(SifHandle,L"FileFlags",file,0)) {

        flags = SpStringToLong(p,NULL,10);

        b = (flags & Flag) ? TRUE : FALSE;

    } else {
        b = FALSE;
    }

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spreg.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spvideo.h

Abstract:

    Public header file for spreg.c.

Author:

    Ted Miller (tedm) 8-October-1993

Revision History:

--*/


#ifndef _SPREG_DEFN_
#define _SPREG_DEFN_

#define GUID_STRING_LEN (39)

#define REGSTR_VALUE_DRVINST    TEXT("DrvInst")
#define REGSTR_VALUE_GUID       TEXT("GUID")
#define REGSTR_VALUE_TYPE       TEXT("Type")
#define REGSTR_VALUE_HWIDS      TEXT("HwIDs")
#define REGSTR_VALUE_CIDS       TEXT("CIDs")

NTSTATUS
SpCreateServiceEntry(
    IN PWCHAR ImagePath,
    IN OUT PWCHAR *ServiceKey
    );

NTSTATUS
SpDeleteServiceEntry(
    IN PWCHAR ServiceKey
    );

NTSTATUS
SpLoadDeviceDriver(
    IN PWSTR Description,
    IN PWSTR PathPart1,
    IN PWSTR PathPart2,     OPTIONAL
    IN PWSTR PathPart3      OPTIONAL
    );

#endif // def _SPREG_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spstring.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spstring.c

Abstract:

    This module contains functions to manipulate strings.
    These functions would ordinarily be performed by C Runtime routines
    except that we want to avoid linking this device driver with
    the kernel crt.

Author:

    Ted Miller (tedm) 15-Jan-1994

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop

VOID
SpStringToUpper(
    IN PWSTR String
    )
{
    for( ; *String; String++) {
        *String = SpToUpper(*String);
    }
}

VOID
SpStringToLower(
    IN PWSTR String
    )
{
    for( ; *String; String++) {
        *String = SpToLower(*String);
    }
}


PWCHAR
SpFindCharFromListInString(
    PWSTR String,
    PWSTR CharList
    )
{
    PWSTR wcset;

    while(*String) {
        for(wcset=CharList; *wcset; wcset++) {
            if(*wcset == *String) {
                return(String);
            }
        }
        String++;
    }
    return(NULL);
}


unsigned
SpMultiByteStringToUnsigned(
    IN  PUCHAR  String,
    OUT PUCHAR *CharThatStoppedScan OPTIONAL
    )
{
    unsigned accum = 0;

    while(*String) {

        if(isdigit(*String)) {
            accum *= 10;
            accum += *String - '0';
        }

        String++;
    }

    if(CharThatStoppedScan) {
        *CharThatStoppedScan = String;
    }

    return(accum);
}


LONG
SpStringToLong(
    IN  PWSTR     String,
    OUT PWCHAR   *EndOfValue,
    IN  unsigned  Radix
    )
{
    PWSTR p;
    BOOLEAN Negative;
    LONG Accum,v;
    WCHAR HighestDigitAllowed,HighestLetterAllowed;
    WCHAR c;

    //
    // Validate radix, 0 or 2-36.
    //
    if((Radix == 1) || (Radix > 36)) {
        if(EndOfValue) {
            *EndOfValue = String;
        }
        return(0);    
    }
    
    p = String;

    //
    // Skip whitespace.
    //
    while(SpIsSpace(*p)) {
        p++;
    }

    //
    // First char may be a plus or minus.
    //
    Negative = FALSE;
    if(*p == L'-') {
        Negative = TRUE;            
        p++;
    } else {
        if(*p == L'+') {
            p++;
        }
    }

    if(!Radix) {
        if(*p == L'0') {
            //
            // Octal number
            //
            Radix = 8;
            p++;
            if((*p == L'x') || (*p == L'X')) {
                //
                // hex number
                //
                Radix = 16;
                p++;
            }
        } else {
            Radix = 10;
        }
    }

    HighestDigitAllowed = (Radix < 10) ? L'0'+(WCHAR)(Radix-1) : L'9';
    HighestLetterAllowed = (Radix > 10) ? L'A'+(WCHAR)(Radix-11) : 0;

    Accum = 0;

    while(1) {

        c = *p;

        if((c >= L'0') && (c <= HighestDigitAllowed)) {
            v = c - L'0';
        } else {

            c = SpToUpper(c);

            if((c >= L'A') && (c <= HighestLetterAllowed)) {
                v = c - L'A' + 10;
            } else {
                break;
            }
        }

        Accum *= Radix;
        Accum += v;

        p++;
    }

    if(EndOfValue) {
        *EndOfValue = p;
    }

    return(Negative ? (0-Accum) : Accum);
}

PWCHAR
SpConvertMultiSzStrToWstr(
    IN PCHAR Source,
    IN ULONG Length
    )
{
    NTSTATUS status;
    PCHAR s, sourceEnd;
    PWCHAR dest, d;
    ANSI_STRING ansiString;
    UNICODE_STRING unicodeString;

    if (Length <= 2) {

        return NULL;
    }

#if DBG
    for (s = Source; *s != '\0'; s += strlen(s) + 1) {
    }
    ASSERT(Length == (ULONG)(s - Source) + 1);
#endif

    dest = SpMemAlloc(Length * sizeof(WCHAR));
    if (dest) {

        s = Source;
        for (sourceEnd = s + Length, d = dest; 
             s < sourceEnd && *s != '\0'; 
             s += strlen(s) + 1) {

            RtlInitAnsiString(&ansiString, s);
            status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, TRUE);
            if (!NT_SUCCESS(status)) {

                SpMemFree(dest);
                return NULL;
            }
            RtlCopyMemory(d, unicodeString.Buffer, unicodeString.Length + sizeof(UNICODE_NULL));
            d += (unicodeString.Length + sizeof(UNICODE_NULL)) / sizeof(WCHAR);
            RtlFreeUnicodeString(&unicodeString);
        }
        if (s < sourceEnd) {
            *d = UNICODE_NULL;
        }
    }

    return dest;
}

PCHAR
SpConvertMultiSzWstrToStr(
    IN PWCHAR Source,
    IN ULONG Length
    )
{
    NTSTATUS status;
    PWCHAR  s, sourceEnd;
    PCHAR   dest, d;
    ANSI_STRING ansiString;
    UNICODE_STRING unicodeString;

    if (Length <= 2) {

        return NULL;
    }

#if DBG
    for (s = Source; *s != UNICODE_NULL; s += wcslen(s) + 1) {
    }
    ASSERT(Length == (ULONG)(s - Source) + 1);
#endif
    dest = SpMemAlloc(Length * sizeof(CHAR));
    if (dest) {

        s = Source;
        for (sourceEnd = s + Length, d = dest; 
             s < sourceEnd && *s != UNICODE_NULL; 
             s += wcslen(s) + 1) {

            RtlInitUnicodeString(&unicodeString, s);
            status = RtlUnicodeStringToAnsiString(&ansiString, &unicodeString, TRUE);
            if (!NT_SUCCESS(status)) {

                SpMemFree(dest);
                return NULL;
            }
            RtlCopyMemory(d, ansiString.Buffer, ansiString.Length + 1);
            d += ansiString.Length + 1;
            RtlFreeAnsiString(&ansiString);
        }
        if (s < sourceEnd) {
            *d = '\0';
        }
    }

    return dest;
}



UCHAR _SpCharTypes[CTSIZE] = {
                                
    _SP_NONE,                   /* 00 (NUL) */
    _SP_NONE,                   /* 01 (SOH) */
    _SP_NONE,                   /* 02 (STX) */
    _SP_NONE,                   /* 03 (ETX) */
    _SP_NONE,                   /* 04 (EOT) */
    _SP_NONE,                   /* 05 (ENQ) */
    _SP_NONE,                   /* 06 (ACK) */
    _SP_NONE,                   /* 07 (BEL) */
    _SP_NONE,                   /* 08 (BS)  */
    _SP_SPACE,                  /* 09 (HT)  */
    _SP_SPACE,                  /* 0A (LF)  */
    _SP_SPACE,                  /* 0B (VT)  */
    _SP_SPACE,                  /* 0C (FF)  */
    _SP_SPACE,                  /* 0D (CR)  */
    _SP_NONE,                   /* 0E (SI)  */
    _SP_NONE,                   /* 0F (SO)  */
    _SP_NONE,                   /* 10 (DLE) */
    _SP_NONE,                   /* 11 (DC1) */
    _SP_NONE,                   /* 12 (DC2) */
    _SP_NONE,                   /* 13 (DC3) */
    _SP_NONE,                   /* 14 (DC4) */
    _SP_NONE,                   /* 15 (NAK) */
    _SP_NONE,                   /* 16 (SYN) */
    _SP_NONE,                   /* 17 (ETB) */
    _SP_NONE,                   /* 18 (CAN) */
    _SP_NONE,                   /* 19 (EM)  */
    _SP_NONE,                   /* 1A (SUB) */
    _SP_NONE,                   /* 1B (ESC) */
    _SP_NONE,                   /* 1C (FS)  */
    _SP_NONE,                   /* 1D (GS)  */
    _SP_NONE,                   /* 1E (RS)  */
    _SP_NONE,                   /* 1F (US)  */
    _SP_SPACE,                  /* 20 SPACE */
    _SP_NONE,                   /* 21 !     */
    _SP_NONE,                   /* 22 "     */
    _SP_NONE,                   /* 23 #     */
    _SP_NONE,                   /* 24 $     */
    _SP_NONE,                   /* 25 %     */
    _SP_NONE,                   /* 26 &     */
    _SP_NONE,                   /* 27 '     */
    _SP_NONE,                   /* 28 (     */
    _SP_NONE,                   /* 29 )     */
    _SP_NONE,                   /* 2A *     */
    _SP_NONE,                   /* 2B +     */
    _SP_NONE,                   /* 2C ,     */
    _SP_NONE,                   /* 2D -     */
    _SP_NONE,                   /* 2E .     */
    _SP_NONE,                   /* 2F /     */
    _SP_DIGIT + _SP_XDIGIT,     /* 30 0     */
    _SP_DIGIT + _SP_XDIGIT,     /* 31 1     */
    _SP_DIGIT + _SP_XDIGIT,     /* 32 2     */
    _SP_DIGIT + _SP_XDIGIT,     /* 33 3     */
    _SP_DIGIT + _SP_XDIGIT,     /* 34 4     */
    _SP_DIGIT + _SP_XDIGIT,     /* 35 5     */
    _SP_DIGIT + _SP_XDIGIT,     /* 36 6     */
    _SP_DIGIT + _SP_XDIGIT,     /* 37 7     */
    _SP_DIGIT + _SP_XDIGIT,     /* 38 8     */
    _SP_DIGIT + _SP_XDIGIT,     /* 39 9     */
    _SP_NONE,                   /* 3A :     */
    _SP_NONE,                   /* 3B ;     */
    _SP_NONE,                   /* 3C <     */
    _SP_NONE,                   /* 3D =     */
    _SP_NONE,                   /* 3E >     */
    _SP_NONE,                   /* 3F ?     */
    _SP_NONE,                   /* 40 @     */
    _SP_UPPER + _SP_XDIGIT,     /* 41 A     */
    _SP_UPPER + _SP_XDIGIT,     /* 42 B     */
    _SP_UPPER + _SP_XDIGIT,     /* 43 C     */
    _SP_UPPER + _SP_XDIGIT,     /* 44 D     */
    _SP_UPPER + _SP_XDIGIT,     /* 45 E     */
    _SP_UPPER + _SP_XDIGIT,     /* 46 F     */
    _SP_UPPER,                  /* 47 G     */
    _SP_UPPER,                  /* 48 H     */
    _SP_UPPER,                  /* 49 I     */
    _SP_UPPER,                  /* 4A J     */
    _SP_UPPER,                  /* 4B K     */
    _SP_UPPER,                  /* 4C L     */
    _SP_UPPER,                  /* 4D M     */
    _SP_UPPER,                  /* 4E N     */
    _SP_UPPER,                  /* 4F O     */
    _SP_UPPER,                  /* 50 P     */
    _SP_UPPER,                  /* 51 Q     */
    _SP_UPPER,                  /* 52 R     */
    _SP_UPPER,                  /* 53 S     */
    _SP_UPPER,                  /* 54 T     */
    _SP_UPPER,                  /* 55 U     */
    _SP_UPPER,                  /* 56 V     */
    _SP_UPPER,                  /* 57 W     */
    _SP_UPPER,                  /* 58 X     */
    _SP_UPPER,                  /* 59 Y     */
    _SP_UPPER,                  /* 5A Z     */
    _SP_NONE,                   /* 5B [     */
    _SP_NONE,                   /* 5C \     */
    _SP_NONE,                   /* 5D ]     */
    _SP_NONE,                   /* 5E ^     */
    _SP_NONE,                   /* 5F _     */
    _SP_NONE,                   /* 60 `     */
    _SP_LOWER + _SP_XDIGIT,     /* 61 a     */
    _SP_LOWER + _SP_XDIGIT,     /* 62 b     */
    _SP_LOWER + _SP_XDIGIT,     /* 63 c     */
    _SP_LOWER + _SP_XDIGIT,     /* 64 d     */
    _SP_LOWER + _SP_XDIGIT,     /* 65 e     */
    _SP_LOWER + _SP_XDIGIT,     /* 66 f     */
    _SP_LOWER,                  /* 67 g     */
    _SP_LOWER,                  /* 68 h     */
    _SP_LOWER,                  /* 69 i     */
    _SP_LOWER,                  /* 6A j     */
    _SP_LOWER,                  /* 6B k     */
    _SP_LOWER,                  /* 6C l     */
    _SP_LOWER,                  /* 6D m     */
    _SP_LOWER,                  /* 6E n     */
    _SP_LOWER,                  /* 6F o     */
    _SP_LOWER,                  /* 70 p     */
    _SP_LOWER,                  /* 71 q     */
    _SP_LOWER,                  /* 72 r     */
    _SP_LOWER,                  /* 73 s     */
    _SP_LOWER,                  /* 74 t     */
    _SP_LOWER,                  /* 75 u     */
    _SP_LOWER,                  /* 76 v     */
    _SP_LOWER,                  /* 77 w     */
    _SP_LOWER,                  /* 78 x     */
    _SP_LOWER,                  /* 79 y     */
    _SP_LOWER                   /* 7A z     */
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spsif.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spsif.h

Abstract:

    Header file for section names and other data used for indexing into
    setup information files.

Author:

    Ted Miller (tedm) 31-August-1993

Revision History:

--*/


#ifndef _SPSIF_
#define _SPSIF_



//
// Field indices for hardware-related sections in txtsetup.sif
//

// in [Map.<Component>] sections
#define INDEX_MAP_FWID          0

// in [<Component>] sections
#define INDEX_DESCRIPTION       0
#define INDEX_FILESECTION       1
#define INDEX_INFKEYNAME        2
#define INDEX_FIRSTAUXFIELD     3


//
// Macro to determine whether a string is present in a SIF.
//
#define SIF_SPECIFIED(string)   ((string) && *(string))

extern PWSTR SIF_DISKDRIVERMAP;

//
// Media description and file placement
//
extern PWSTR SIF_SETUPMEDIA;
extern PWSTR SIF_FILESONSETUPMEDIA;

//
// defines to index into SIF_FILESONSETUPMEDIA section
//
#define INDEX_WHICHMEDIA        0
#define INDEX_WHICHBOOTMEDIA    6
#define INDEX_DESTINATION       7
#define INDEX_UPGRADE           8
#define INDEX_WINNTFILE         9
#define INDEX_TARGETNAME        10

//
// File copy lists
//
extern PWSTR SIF_SYSPARTCOPYALWAYS;
extern PWSTR SIF_SYSPARTROOT;
extern PWSTR SIF_SYSPARTUTIL;                             
extern PWSTR SIF_SPECIALFILES;
extern PWSTR SIF_MPKERNEL;
extern PWSTR SIF_UPKERNEL;
extern PWSTR SIF_ATDISK;
extern PWSTR SIF_ABIOSDISK;
extern PWSTR SIF_MOUSECLASS;
extern PWSTR SIF_KEYBOARDCLASS;

extern PWSTR SIF_HAL;
extern PWSTR SIF_BOOTVID;

extern PWSTR SIF_BOOTBUSEXTENDERS;
extern PWSTR SIF_BUSEXTENDERS;
extern PWSTR SIF_INPUTDEVICESSUPPORT;

extern PWSTR SIF_NTDETECT;
extern PWSTR SIF_STANDARD;

extern PWSTR SIF_KEYBOARDLAYOUTFILES;
extern PWSTR SIF_KEYBOARDLAYOUTDESC;
extern PWSTR SIF_VGAFILES;

extern PWSTR SIF_NTDIRECTORIES;

extern PWSTR SIF_SCSICLASSDRIVERS;
extern PWSTR SIF_DISKDRIVERS;
extern PWSTR SIF_CDROMDRIVERS;
extern PWSTR SIF_FILESYSTEMS;

extern PWSTR SIF_KEYBOARDLAYOUT;

#if defined(REMOTE_BOOT)
extern PWSTR SIF_REMOTEBOOTFILES;
#endif // defined(REMOTE_BOOT)

extern PWSTR SIF_SETUPDATA;
extern PWSTR SIF_DISKSPACEREQUIREMENTS;
extern PWSTR SIF_PRODUCTTYPE;
extern PWSTR SIF_MAJORVERSION;
extern PWSTR SIF_MINORVERSION;
extern PWSTR SIF_WINDIRSPACE;
extern PWSTR SIF_FREESYSPARTDISKSPACE;
extern PWSTR SIF_DEFAULTPATH;
extern PWSTR SIF_LOADIDENTIFIER;
extern PWSTR SIF_BASEVIDEOLOADID;
extern PWSTR SIF_OSLOADOPTIONS;
extern PWSTR SIF_OSLOADOPTIONSVAR;
extern PWSTR SIF_OSLOADOPTIONSVARAPPEND;
extern PWSTR SIF_SETUPSOURCEDEVICE;
extern PWSTR SIF_SETUPSOURCEPATH;
extern PWSTR SIF_DONTCOPY;
extern PWSTR SIF_REQUIREDMEMORY;
extern PWSTR SIF_SETUPCMDPREPEND;
extern PWSTR SIF_PAGEFILE;

extern PWSTR SIF_NLS;
extern PWSTR SIF_ANSICODEPAGE;
extern PWSTR SIF_OEMCODEPAGE;
extern PWSTR SIF_MACCODEPAGE;
extern PWSTR SIF_UNICODECASETABLE;
extern PWSTR SIF_OEMHALFONT;
extern PWSTR SIF_DEFAULTLAYOUT;

extern PWSTR SIF_REPAIRWINNTFILES;
extern PWSTR SIF_REPAIRSYSPARTFILES;


//
// Upgrade sections, values
//

extern PWSTR SIF_NET_SERVICES_TO_DISABLE;
extern PWSTR SIF_KEYS_TO_DELETE;
extern PWSTR SIF_KEYS_TO_ADD;

extern PWSTR SIF_SYSTEM_HIVE;
extern PWSTR SIF_SOFTWARE_HIVE;
extern PWSTR SIF_DEFAULT_HIVE;
extern PWSTR SIF_CONTROL_SET;

extern PWSTR SIF_REG_SZ;
extern PWSTR SIF_REG_DWORD;
extern PWSTR SIF_REG_EXPAND_SZ;
extern PWSTR SIF_REG_MULTI_SZ;
extern PWSTR SIF_REG_BINARY;
extern PWSTR SIF_REG_BINARY_DWORD;

extern PWSTR SIF_FILESDELETEONUPGRADE;
extern PWSTR SIF_FILESBACKUPONUPGRADE;
extern PWSTR SIF_FILESBACKUPONOVERWRITE;

extern PWSTR SIF_DIRSDELETEONUPGRADE;

#ifdef _X86_
extern PWSTR SIF_FILESMOVEBEFOREMIGRATION;
extern PWSTR SIF_FILESDELETEBEFOREMIGRATION;
#endif

extern PWSTR SIF_FILESUPGRADEWIN31;
extern PWSTR SIF_FILESNEWHIVES;

//
// New sections and keys added to setup.log
//

extern PWSTR SIF_NEW_REPAIR_WINNTFILES;
extern PWSTR SIF_NEW_REPAIR_SYSPARTFILES;
extern PWSTR SIF_NEW_REPAIR_SIGNATURE;
extern PWSTR SIF_NEW_REPAIR_VERSION_KEY;
extern PWSTR SIF_NEW_REPAIR_NT_VERSION_TEMPLATE;
extern PWSTR SIF_NEW_REPAIR_NT_VERSION;
extern PWSTR SIF_NEW_REPAIR_PATHS;
extern PWSTR SIF_NEW_REPAIR_PATHS_SYSTEM_PARTITION_DEVICE;
extern PWSTR SIF_NEW_REPAIR_PATHS_SYSTEM_PARTITION_DIRECTORY;
extern PWSTR SIF_NEW_REPAIR_PATHS_TARGET_DEVICE;
extern PWSTR SIF_NEW_REPAIR_PATHS_TARGET_DIRECTORY;

extern PWSTR SETUP_REPAIR_DIRECTORY;
extern PWSTR SETUP_LOG_FILENAME;

extern PWSTR SIF_NEW_REPAIR_FILES_IN_REPAIR_DIR;

extern PWSTR SIF_DATA;
extern PWSTR SIF_UNATTENDED;
extern PWSTR SIF_SETUPPARAMS;
extern PWSTR SIF_CONFIRMHW;
extern PWSTR SIF_GUI_UNATTENDED;
extern PWSTR SIF_UNATTENDED_INF_FILE;
extern PWSTR SIF_UNIQUEID;
extern PWSTR SIF_EXTENDOEMPART;
extern PWSTR SIF_ACCESSIBILITY;

extern PWSTR SIF_REMOTEINSTALL;
#if defined(REMOTE_BOOT)
extern PWSTR SIF_REMOTEBOOT;
extern PWSTR SIF_ENABLEIPSECURITY;
#endif // defined(REMOTE_BOOT)
extern PWSTR SIF_REPARTITION;
extern PWSTR SIF_USEWHOLEDISK;

//
// Alternate Source data
//
extern PWSTR SIF_UPDATEDSOURCES;
//extern PWSTR SIF_ALTCOPYFILESSECTION;

extern PWSTR SIF_INCOMPATIBLE_TEXTMODE;


PWSTR
SpPlatformSpecificLookup(
    IN PVOID   SifHandle,
    IN PWSTR   Section,
    IN PWSTR   Key,
    IN ULONG   Index,
    IN BOOLEAN Fatal
    );

PWSTR
SpLookUpTargetDirectory(
    IN PVOID SifHandle,
    IN PWSTR Symbol
    );

PWSTR
SpLookUpValueForFile(
    IN PVOID   SifHandle,
    IN PWSTR   File,
    IN ULONG   Index,
    IN BOOLEAN Fatal
    );

BOOLEAN
IsFileFlagSet(
    IN PVOID SifHandle,
    IN PWSTR FileName,
    IN ULONG Flag
    );

#endif // ndef _SPSIF_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spsetup.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spsetup.c

Abstract:

    Main module for character-base setup (ie, text setup).

Author:

    Ted Miller (tedm) 29-July-1993

--*/

#include "spprecmp.h"
#pragma hdrstop
#include "spcmdcon.h"
#include <initguid.h>
#include <pnpmgr.h>
#include <devguid.h>
#include <remboot.h>
#include <hdlsblk.h>
#include <hdlsterm.h>
#ifdef _X86_
#include "spwin9xuninstall.h"
#endif

#if !defined(SETUPBLK_FLAGS_ROLLBACK)
#define SETUPBLK_FLAGS_ROLLBACK 0
#endif

#if defined(REMOTE_BOOT)
VOID
IoStartCscForTextmodeSetup(
    IN BOOLEAN Upgrade
    );
#endif // defined(REMOTE_BOOT)

BOOL
SpDetermineBootPartitionEnumNec98(
    IN PPARTITIONED_DISK Disk,
    IN PDISK_REGION Region,
    IN ULONG_PTR Context
    );

VOID
SpCantFindBuildToUpgrade(
    VOID
    );


//
// TRUE if setup should run in the step-up upgrade mode.
// In this mode, setup is not allowed to do clean install,
// and is not allowed to upgrade workstation to server.
// Also, evaluation time in minutes, read from the setup hive.
// This value is passed through to GUI mode.
//
BOOLEAN StepUpMode;
DWORD EvaluationTime = 0;
ULONG RestrictCpu;
ULONG SuiteType;

//
// TRUE if user chose Custom Setup.
//
BOOLEAN CustomSetup = TRUE;

//
// Non-0 if gui setup is supposed to be restartable.
// This causes us to do special stuff with hives in spconfig.c.
//
BOOLEAN RestartableGuiSetup = TRUE;

//
// TRUE if user chose repair winnt
//

BOOLEAN RepairWinnt = FALSE;

//
// TRUE if this is a command console only boot
//
BOOLEAN ForceConsole = FALSE;
BOOLEAN ConsoleRunning = FALSE;
BOOLEAN ConsoleFromWinnt32 = FALSE;

//
// TRUE if repair from ER diskette
//

BOOLEAN RepairFromErDisk = TRUE;

//
// TRUE if this is advanced server we're setting up.
//
BOOLEAN AdvancedServer;

//
// Windows NT Version.
//
ULONG WinntMajorVer;
ULONG WinntMinorVer;

//
// Win9x uninstall
//
BOOLEAN Win9xRollback = FALSE;
BOOLEAN g_Win9xBackup = FALSE;

#ifdef PRERELEASE
//
// Test hooks
//

INT g_TestHook;
#endif

//
// True if NOLS = 1 in winnts.sif
//
BOOLEAN NoLs = FALSE;

//
// NTUpgrade - Whether we are upgrading an existing NT and if we are
//             what type of an upgrade it is.  Valid values are:
//
//    - DontUpgrade:         If we are not upgrading
//    - UpgradeFull:         Full upgrade
//    - UpgradeInstallFresh: There was a failed upgrade, so we want to install
//                           fresh into this, saving the hives
//
//
ENUMUPGRADETYPE NTUpgrade = DontUpgrade;

//
// Indicates whether actually NT was being upgraded
// to partitioning engine, so that on IA64 it can
// treat active MBR partitions as system partitions
//
ENUMUPGRADETYPE IsNTUpgrade = DontUpgrade;

//
// TRUE if upgrading Workstation to Standard Server, or upgrading
// existing Standard Server
//
BOOLEAN StandardServerUpgrade = FALSE;

//
// Contains the type of windows upgrade, if any (win31 or win95)
//
ENUMNONNTUPRADETYPE WinUpgradeType = NoWinUpgrade;

//
// TRUE if this setup was started with winnt.exe or winnt32.exe.
// Also a flag indicating whether the local source was not created and we
// should get files from the CD instead.
//
BOOLEAN WinntSetup = FALSE;
BOOLEAN WinntFromCd = FALSE;

//
// TRUE if floppyless boot
//
BOOLEAN IsFloppylessBoot = FALSE;

//
// TRUE if textmode is to pick a partition
//
BOOLEAN AutoPartitionPicker;

//
// Preferred installation dir
//
PWSTR PreferredInstallDir;

//
// If this is an unattended setup, this value will be a non-NULL
// handle to the SIF file with setup parameters.
// *Note*: Before referencing UnattendedSifHandle, you must first check
//         UnattendedOperation is not FALSE.
//
BOOLEAN UnattendedOperation = FALSE;
BOOLEAN UnattendedGuiOperation = FALSE;
PVOID UnattendedSifHandle = NULL;
PVOID WinntSifHandle = NULL;
PVOID ASRPnPSifHandle = NULL;
PVOID WinntMigrateInfHandle = NULL;
PVOID WinntUnsupDrvInfHandle = NULL;
BOOLEAN AccessibleSetup = FALSE;

//
// this value is a non-null pointer to the drvindex.inf file.  It is
// initialized on startup.  The list of files that are present in our
// driver cab file are indexed in this inf, so we can quickly look if a
// file is present in the cab
//
PVOID DriverInfHandle;

//
// this is a non-null pointer to the driver cab file.  It is also initialzied
// on startup.  The list of files in this cab is indexed in drvindex.inf.  this is
// the only cab file that textmode setup knows to look into.
//
CABDATA *CabData;

//
// pointer to delta.inf, an INF for private testing
//
PVOID PrivateInfHandle;

//
//  This is a handle to txtsetup.oem, used on pre-install mode.
//
PVOID PreinstallOemSifHandle = NULL;

//
// If this flag is true, we ignore files that are not present on the source
// when copying. This is used internally for people who don't build the
// entire system and don't care that a whole bunch of help files,
// device drivers, etc, aren't there.
//
BOOLEAN SkipMissingFiles;
BOOLEAN HideWinDir;

//
// On unattended mode, indicates whether OEM files
// that have same name as Microsoft files released
// with the product should be overwritten.
//
BOOLEAN UnattendedOverwriteOem = TRUE;

//
// On unattended mode, indicates that this is is
// an OEM pre-installation
//
BOOLEAN PreInstall = FALSE;

//
// In unattended mode, indicates whether to wait
// for reboot
//
BOOLEAN UnattendWaitForReboot = FALSE;

//
// On pre-install mode, indicates whether or not an OEM component needs
// to be pre-installed (txtsetup.oem needs to be loaded).
//
// BOOLEAN PreinstallOemComponents = FALSE;

//
//  On pre-install mode, the variables below point to the various lists of
//  drivers to pre-install
//
// PPREINSTALL_DRIVER_INFO PreinstallDisplayDriverList = NULL;
// PPREINSTALL_DRIVER_INFO PreinstallKeyboardDriverList = NULL;
// PPREINSTALL_DRIVER_INFO PreinstallPointingDeviceDriverList = NULL;
// PPREINSTALL_DRIVER_INFO PreinstallKeyboardLayout = NULL;

//
//  On pre-install mode, points to the directory that contains the files
//  that need to be copied during textmode setup
//
PWSTR   PreinstallOemSourcePath = NULL;

//
// Virtual OEM source devices (accessible through RAM disk driver)
//
PVIRTUAL_OEM_SOURCE_DEVICE VirtualOemSourceDevices = NULL;

//
//  Flags that indicate the type of mice detected in the machine.
//  Note that more than one type of mice may be present.
//
BOOLEAN UsbMouseDetected = FALSE;
BOOLEAN PS2MouseDetected = FALSE;
BOOLEAN SerMouseDetected = FALSE;

//
//  Flags that indicate the type of keyboard detected in the machine.
//  Note that more than one type of keyborad may be present.
//
BOOLEAN UsbKeyboardDetected = FALSE;
BOOLEAN StdKeyboardDetected = FALSE;

//
// Gets set to TRUE if the user elects to convert or format to ntfs.
// And a flag indicating whether we are doing a dirty sleazy hack
// for oem preinstall.
//
BOOLEAN ConvertNtVolumeToNtfs = FALSE;
BOOLEAN ExtendingOemPartition = FALSE;

//
// Variable used during the repair process, that indicates that the
// system has no CD-ROM drive.
// This is a hack that we did for World Bank so that they can repair
// the hives even if they don't have a CD-ROM drive.
//
BOOLEAN RepairNoCDROMDrive = FALSE;

//
// Indicates whether or not winnt32 detected at least one
// FT partition in the system.
// Note that on boot floppies install on x86 machines,
// or setupldr/CD install on ARC machines, this flag will always be
// set to FALSE
//
BOOLEAN FtPartitionDetected = FALSE;

//
// Filename of local source directory.
//
PWSTR LocalSourceDirectory = L"\\$win_nt$.~ls";

LIST_ENTRY MigratedDriversList;

//
// Platform-specific extension, used when creating names of sections
// in sif/inf files.
//
#if defined(_AMD64_)
PWSTR PlatformExtension = L".amd64";
#elif defined(_X86_)
PWSTR PlatformExtension = L".x86";
#elif defined(_IA64_)
PWSTR PlatformExtension = L".ia64";
#else
#error "No Target Architecture"
#endif

WCHAR TemporaryBuffer[16384];

//
// This global structure contains non-pointer values passed to us by setupldr
// in the setup loader parameter block.
//
// This structure is initialized during SpInitialize0().
//
SETUP_LOADER_BLOCK_SCALARS SetupParameters;

//
// These values are set during SpInitialize0() and are the ARC pathname
// of the device from which we were started and the directory within the device.
// DirectoryOnBootDevice will always be all uppercase.
//
PWSTR ArcBootDevicePath,DirectoryOnBootDevice;

//
// Representation of the boot device path in the nt namespace.
//
PWSTR NtBootDevicePath;


//
// Dynamic update boot driver path in NT namespace
//
PWSTR DynUpdtBootDriverPath = NULL;


//
// Global parameter block for command console
//
CMDCON_BLOCK Block = {0};

//
// Setupldr loads a text setup information file and passes us the buffer
// so that we don't have to reload it from disk. During SpInitialize0()
// we allocate some pool and store the image away for later use.
//
PVOID SetupldrInfoFile;
ULONG SetupldrInfoFileSize;

//
// During remote boot setup, setupldr also loads winnt.sif.
//
PVOID SetupldrWinntSifFile;
ULONG SetupldrWinntSifFileSize;

//
// Setupldr loads asrpnp.sif.
//
PVOID SetupldrASRPnPSifFile;
ULONG SetupldrASRPnPSifFileSize;

//
// Setupldr may load an inf that contains registry information that needs to be
// migrated to the setup hive. This file will be processed during SpInitialize0().
//
PVOID SetupldrMigrateInfFile;
ULONG SetupldrMigrateInfFileSize;

//
// Setupldr may load an inf that contains information about unsupported SCSI
// drivers that need to work during textmode setup.
// This file will be processed during SpInitialize0().
//
PVOID SetupldrUnsupDrvInfFile;
ULONG SetupldrUnsupDrvInfFileSize;

#if defined(REMOTE_BOOT)
//
// Setupldr passes in the hal name on remote boot.  Store them here
// before the loader block goes away.
//
UCHAR NetBootHalName[MAX_HAL_NAME_LENGTH + 1];
#endif // defined(REMOTE_BOOT)

//
// The name of the SIF file used by remote boot. This is saved since
// it needs to be deleted later.
//
PWSTR NetBootSifPath = NULL;

PDISK_SIGNATURE_INFORMATION DiskSignatureInformation;

//
// Setupldr passes in the path to IMirror.dat, store it here before the loader
// block goes away.
//
PUCHAR RemoteIMirrorFilePath;

//
// For remote install, save the NT boot path from the loader block, because
// DirectoryOnBootDevice becomes something else.
//
PWSTR RemoteIMirrorBootDirectoryPrefix;

//
// The file version and memory version of the IMirror.dat information
// (the memory version is modified to match this actual machine).
//
PMIRROR_CFG_INFO_FILE RemoteIMirrorFileData = NULL;
PMIRROR_CFG_INFO_MEMORY RemoteIMirrorMemoryData = NULL;

//
// Setupldr passes in the IP address of the server we are talking to.
//
ULONG RemoteServerIpAddress;

//
// setupldr may pass us the administrator password in a remote install
// if the user is prompted for the password.
//
PWSTR NetBootAdministratorPassword = NULL;

BOOLEAN GeneralInitialized = FALSE;

BOOLEAN PcmciaLoaded = FALSE;

BOOLEAN AtapiLoaded = FALSE;

//
//  Array with the PIDs of all NT greater than 4.x found in the machine (PID 2.0)
//  The values in this array will be saved under Setup\PidList key in the registry,
//  and will be used during GUI setup
//
PWSTR*  Pid20Array = NULL;

//
//  Product Id read from setupp.ini
//
PWSTR   PidString = NULL;

//
// Routines required by rtl.lib
//
const PRTL_ALLOCATE_STRING_ROUTINE RtlAllocateStringRoutine = SpMemAlloc;
const PRTL_FREE_STRING_ROUTINE RtlFreeStringRoutine = SpMemFree;

//
// Plug & Play notification handle
//
PVOID   NotificationEntry = NULL;

//
// Plug & Play hardware ID database (unicode)
//
PSETUP_PNP_HARDWARE_ID SetupHardwareIdDatabase = NULL;

//
//  Guid strings to identify mouse and keyboard
//
PWSTR MouseGuidString = NULL;
PWSTR KeyboardGuidString = NULL;

//
// This flag identifies "dockable" machines (portables)
// so that we can disble dynamic volumes on them
//
BOOLEAN DockableMachine = FALSE;

//
// Pointer to block of interesting values and other stuff
// passed to spcmdcon.sys
//
PCMDCON_BLOCK gpCmdConsBlock = NULL;

//begin NEC98
PDISK_REGION    TargetRegion_Nec98 = NULL;
#define WINNT_D_DRIVEASSIGN_NEC98_W L"DriveAssign_Nec98"
#define WINNT_D_DRIVEASSIGN_NEC98_A "DriveAssign_Nec98"

#ifdef UNICODE
#define WINNT_D_DRIVEASSIGN_NEC98 WINNT_D_DRIVEASSIGN_NEC98_W
#else
#define WINNT_D_DRIVEASSIGN_NEC98 WINNT_D_DRIVEASSIGN_NEC98_A
#endif


//
// Legacy drive assign for NEC98, HD start from A:
// but it is only case of upgrade from NT4.0 or Win9x.
//
BOOLEAN DriveAssignFromA = FALSE;     //PC-AT assign.


//
// Indicates whether we have a system partition or not
// on Arc Machines
//
BOOLEAN ValidArcSystemPartition = FALSE;

#ifdef _X86_
//
// NEC98
//
BOOLEAN
SpReInitializeBootVars_Nec98(
    VOID
);
#endif

VOID
SpSetAutoBootFlag(
    IN PDISK_REGION TargetRegion,
    IN BOOLEAN    SetBootPosision
    );
//end NEC98

VOID
SpTerminate(
    VOID
    );

VOID
SpInitialize0a(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID          Context,
    IN ULONG          ReferenceCount
    );

VOID
SpDetermineProductType(
    IN PVOID SifHandle
    );

BOOL
SpDetermineInstallationSource(
    IN  PVOID  SifHandle,
    OUT PWSTR *DevicePath,
    OUT PWSTR *DirectoryOnDevice,
    IN  BOOLEAN bEscape
    );

VOID
SpCompleteBootListConfig(
    WCHAR   DriveLetter
    );

VOID
SpInitializePidString(
    IN HANDLE       MasterSifHandle,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice
    );


BOOLEAN
SpGetStepUpMode(
    IN PWSTR PidExtraData,
    BOOLEAN  *StepUpMode
    );

NTSTATUS
SpCreateDriverRegistryEntries(
    IN PHARDWARE_COMPONENT  DriverList
    );


#if defined(REMOTE_BOOT)

NTSTATUS
SpFixupRemoteBootLoader(
    PWSTR RemoteBootTarget
    );

NTSTATUS
SpCreateRemoteBootCfg(
    IN PWSTR RemoteBootTarget,
    IN PDISK_REGION SystemPartitionRegion
    );

NTSTATUS
SpEraseCscCache(
    IN PDISK_REGION SystemPartitionRegion
    );
#endif // defined(REMOTE_BOOT)

#if defined HEADLESS_ATTENDEDTEXTMODE_UNATTENDEDGUIMODE

VOID SpGetServerType(
    )
{
    int ServerTypes, i;
    PWSTR Server[] = {
        L"Web Server",
        L"File Server",
        L"DHCP Server"
    };
    ULONG MenuTopY;
    ULONG MenuHeight;
    ULONG MenuWidth;
    PVOID Menu;
    ULONG CurrentServer;
    ULONG ValidKeys[] = {ASCI_CR};
    ULONG KeyPress;

    ServerTypes = 3;
    SpStartScreen(
        SP_SCRN_GET_SERVER_TYPE,
        3,
        CLIENT_TOP+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE
        );

    MenuTopY =NextMessageTopLine + 2;
    Menu = SpMnCreate(3,
                      MenuTopY,
                      VideoVars.ScreenWidth -6,
                      ServerTypes);
    if (Menu==NULL) {
        return;
    }
    for (i=0;i<ServerTypes;i++) {
        CurrentServer = (ULONG) i;
        SpMnAddItem(Menu,
                    Server[i],
                    3,
                    VideoVars.ScreenWidth -6,
                    TRUE,
                    CurrentServer
                    );
    }
    SpMnDisplay(Menu,
                0,
                TRUE,
                ValidKeys,
                NULL,
                NULL,
                &KeyPress,
                &CurrentServer
                );

    switch(KeyPress){
    case ASCI_CR:
        SpMnDestroy(Menu);
        break;
    default:
        SpMnDestroy(Menu);
    }

    // Add information to the inf file to setup the correct server

    return;
}


VOID
SpGetServerDetails(
    )
{
    // Get the type of server that needs to be installed on the machine.
    WCHAR *Constants[1];

    // Assume licenses are purchased per seat

    Constants[0]=L"PERSEAT";
    SpAddLineToSection(WinntSifHandle,L"LicenseFilePrintData",L"AutoMode",Constants,1);

    //Turn on Terminal Services
    Constants[0] = L"ON";
    SpAddLineToSection(WinntSifHandle,L"Components",L"TSEnable",Constants,1);

    // In order that the terminal server comes up properly, we need to make sure
    // that the network cards are properly configured. In the case of a multihomed
    // NIC or cases we cannot use dhcp, we need to statically configure addresses.
    // will try to do this in the GUI setup. now try to determine the type of server
    // to install.

    SpGetServerType();
    return;
}



VOID
SpGetTimeZone(
    )

{
    ULONG MenuTopY;
    ULONG MenuHeight;
    ULONG MenuWidth;
    PVOID Menu;
    ULONG ValidKeys[] = {ASCI_CR};
    ULONG KeyPress;
    int i,TimeZones;
    ULONG CurrentTimeZone=4;
    WCHAR *Constants[1];
    WCHAR Temp[20];
    PWSTR TimeZone[] = {
        L" -12:00   Dateline : Eniwetok, Kwajalein",
        L" -11:00   Samoa : Midway Island, Samoa",
        L" -10:00   Hawaiian : Hawaii",
        L" -09:00   Alaskan : Alaska",
        L" -08:00   Pacific : Pacific Time (US & Canada); Tijuana",
        L" -07:00   Mountain : Mountain Time (US & Canada)",
        L" -07:00   US Mountain : Arizona",
        L" -06:00   Central : Central Time (US & Canada)",
        L" -06:00   Canada Central : Saskatchewan",
        L" -06:00   Mexico : Mexico City, Tegucigalpa",
        L" -05:00   Eastern : Eastern Time (US & Canada)",
        L" -05:00   US Eastern : Indiana (East)",
        L" -05:00   SA Pacific : Bogota, Lima, Quito",
        L" -04:00   Atlantic : Atlantic Time (Canada)",
        L" -04:00   SA Western : Caracas, La Paz",
        L" -03:30   Newfoundland : Newfoundland",
        L" -03:00   E. South America : Brasilia",
        L" -03:00   SA Eastern : Buenos Aires, Georgetown",
        L" -02:00   Mid-Atlantic : Mid-Atlantic",
        L" -01:00   Azores: Azores, Cape Verde Is.",
        L"  00:00   GMT : Greenwich Mean Time : Dublin, Edinburgh, Lisbon, London",
        L"  00:00   Greenwich : Casablanca, Monrovia",
        L" +01:00   Central Europe : Belgrade, Bratislava, Budapest, Ljubljana, Prague",
        L" +01:00   Central European : Sarajevo, Skopje, Sofija, Warsaw, Zagreb",
        L" +01:00   Romance : Brussels, Copenhagen, Madrid, Paris, Vilnius",
        L" +01:00   W. Europe : Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna",
        L" +02:00   E. Europe : Bucharest",
        L" +02:00   Egypt : Cairo",
        L" +02:00   FLE : Helsinki, Riga, Tallinn",
        L" +02:00   GTB : Athens, Istanbul, Minsk",
        L" +02:00   Israel : IsraeL",
        L" +02:00   South Africa : Harare, Pretoria",
        L" +03:00   Russian : Moscow, St. Petersburg, Volgograd",
        L" +03:00   Arab : Baghdad, Kuwait, Riyadh",
        L" +03:00   E. Africa : Nairobi",
        L" +03:30   Iran : Tehran",
        L" +04:00   Arabian : Abu Dhabi, Muscat",
        L" +04:00   Caucasus : Baku, Tbilisi",
        L" +04:30   Afghanistan : KabuL",
        L" +05:00   Ekaterinburg : Ekaterinburg",
        L" +05:00   West Asia : Islamabad, Karachi, Tashkent",
        L" +05:30   India : Bombay, Calcutta, Madras, New Delhi",
        L" +06:00   Central Asia : Almaty, Dhaka",
        L" +06:00   Sri Lanka : Colombo",
        L" +07:00   SE Asia : Bangkok, Hanoi, Jakarta",
        L" +08:00   China : Beijing, Chongqing, Hong Kong, Urumqi",
        L" +08:00   Singapore : Singapore",
        L" +08:00   Taipei : Taipei",
        L" +08:00   W. Australia : Perth",
        L" +09:00   Korea : SeouL",
        L" +09:00   Tokyo : Osaka, Sapporo, Tokyo",
        L" +09:00   Yakutsk : Yakutsk",
        L" +09:30   AUS Central : Darwin",
        L" +09:30   Cen. Australia : Adelaide",
        L" +10:00   AUS Eastern : Canberra, Melbourne, Sydney",
        L" +10:00   E. Australia : Brisbane",
        L" +10:00   Tasmania : Hobart",
        L" +10:00   Vladivostok : Vladivostok",
        L" +10:00   West Pacific : Guam, Port Moresby",
        L" +11:00   Central Pacific : Magadan, Solomon Is., New Caledonia",
        L" +12:00   Fiji: Fiji, Kamchatka, Marshall Is.",
        L" +12:00   New Zealand : Auckland, Wellington"
        };
    ULONG TimeZoneIndex[] = {
        0,
        1,
        2,
        3,
        4,
        10,
        15,
        20,
        25,
        30,
        35,
        40,
        45,
        50,
        55,
        60,
        65,
        70,
        75,
        80,
        85,
        90,
        95,
        100,
        105,
        110,
        115,
        120,
        125,
        130,
        135,
        140,
        145,
        150,
        155,
        160,
        165,
        170,
        175,
        180,
        185,
        190,
        195,
        200,
        205,
        210,
        215,
        220,
        225,
        230,
        235,
        240,
        245,
        250,
        255,
        260,
        265,
        270,
        275,
        280,
        285,
        290
    };


    TimeZones = sizeof(TimeZoneIndex)/sizeof(ULONG);
    SpStartScreen(
        SP_SCRN_GET_TIME_ZONE,
        3,
        CLIENT_TOP+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE
        );

    MenuTopY =NextMessageTopLine + 2;
    Menu = SpMnCreate(
                      3,
                      MenuTopY,
                      VideoVars.ScreenWidth -6,
                      10);
    if (Menu==NULL) {
        Constants[0] = L"4";
        SpAddLineToSection(WinntSifHandle,WINNT_GUIUNATTENDED_W,
                            L"TimeZone",Constants,1);
        return;
    }
    for (i=0;i<TimeZones;i++) {
        SpMnAddItem(Menu,
                    TimeZone[i],
                    3,
                    VideoVars.ScreenWidth -6,
                    TRUE,
                    TimeZoneIndex[i]
                    );
    }
    SpMnDisplay(Menu,
                0,
                TRUE,
                ValidKeys,
                NULL,
                NULL,
                &KeyPress,
                &CurrentTimeZone
                );

    switch(KeyPress){
    case ASCI_CR:
        SpMnDestroy(Menu);
        break;
    default:
        SpMnDestroy(Menu);
    }
    swprintf(Temp,L"%ld",CurrentTimeZone);
    Constants[0] = Temp;
    SpAddLineToSection(WinntSifHandle,WINNT_GUIUNATTENDED_W,
                        L"TimeZone",Constants,1);
    return;
}

ValidationValue
SpGetAsciiCB(
    IN ULONG Key
    )
{
    if (Key & KEY_NON_CHARACTER) {
        return(ValidateReject);
    }
    return(ValidateAccept);

}

VOID
SpGetNecessaryParameters(
    )
/*+++
      Reads in the necessary input values to allow GUI mode setup to proceed
      unattended.
      1. Name of person
      2. Computer Name
      3. Organization
      4. Timezone
---*/
{
    /*+++
          Get Full Name of the User and the Organization
    ---*/


    WCHAR *Buffer[3];
    WCHAR *InputBuffer[3];
    WCHAR CompBuffer[200], NameBuffer[200], OrgBuffer[200];
    WCHAR Comp[40], Name[40], Org[40];
    ULONG Top[3];
    int index=0;
    int i;
    BOOLEAN notdone = TRUE;
    BOOLEAN status;
    WCHAR *Constants[1];

    Buffer[0] = NameBuffer;
    Buffer[1] = OrgBuffer;
    Buffer[2] = CompBuffer;

    InputBuffer[0] = Name;
    InputBuffer[1] = Org;
    InputBuffer[2] = Comp;

    for(i=0;i<3;i++){
        swprintf(Buffer[i],L"");
        swprintf(InputBuffer[i],L"");
    }
    do{
        notdone= FALSE;
        SpStartScreen(
            SP_SCRN_GET_GUI_STUFF,
            3,
            CLIENT_TOP+1,
               FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE
            );

        SpFormatMessage(NameBuffer,sizeof(NameBuffer),SP_TEXT_NAME_PROMPT);
        //SpvidDisplayString(Buffer[0],DEFAULT_ATTRIBUTE,3,NextMessageTopLine);
        SpContinueScreen(SP_TEXT_NAME_PROMPT,3,3,FALSE, DEFAULT_ATTRIBUTE);
        Top[0] = NextMessageTopLine - 1;

        SpFormatMessage(OrgBuffer,sizeof(OrgBuffer),SP_TEXT_ORG_PROMPT);
        //SpvidDisplayString(Buffer[1],DEFAULT_ATTRIBUTE,3,NextMessageTopLine);
        SpContinueScreen(SP_TEXT_ORG_PROMPT,3,3,FALSE, DEFAULT_ATTRIBUTE);
        Top[1] = NextMessageTopLine - 1;

        SpFormatMessage(CompBuffer,sizeof(CompBuffer),SP_TEXT_COMPUTER_PROMPT);
        //SpvidDisplayString(Buffer[2],DEFAULT_ATTRIBUTE,3,NextMessageTopLine);
        SpContinueScreen(SP_TEXT_COMPUTER_PROMPT,3,3,FALSE, DEFAULT_ATTRIBUTE);
        Top[2] = NextMessageTopLine - 1;

        index = 0;
        do{
            status = SpGetInput(SpGetAsciiCB,
                                SplangGetColumnCount(Buffer[index])+5,
                                Top[index],
                                20,
                                InputBuffer[index],
                                FALSE
                                );
            index = (index+1) %3;
        }while (index != 0);
        for(i=0;i<3;i++){
            if (wcscmp(InputBuffer[i],L"")==0) {
                notdone=TRUE;
            }
        }

    }while(notdone);

    SpAddLineToSection(WinntSifHandle,WINNT_USERDATA_W,
                       WINNT_US_FULLNAME_W,InputBuffer,1);
    SpAddLineToSection(WinntSifHandle,WINNT_USERDATA_W,
                       WINNT_US_ORGNAME_W,&(InputBuffer[1]),1);
    SpAddLineToSection(WinntSifHandle,WINNT_USERDATA_W,
                       WINNT_US_COMPNAME_W,&(InputBuffer[2]),1);
    Constants[0] = L"1";
    SpAddLineToSection(WinntSifHandle,WINNT_GUIUNATTENDED_W,
                       L"OemSkipWelcome",Constants,1);
    SpAddLineToSection(WinntSifHandle,WINNT_GUIUNATTENDED_W,
                       L"OemSkipRegional",Constants,1);

    // Get the Timezone Information
    SpGetTimeZone();

    Constants[0] =L"*";
    SpAddLineToSection(WinntSifHandle,WINNT_GUIUNATTENDED_W, L"AdminPassword",Constants,1);
    Constants[0]=L"Yes";
    SpAddLineToSection(WinntSifHandle,WINNT_GUIUNATTENDED_W,L"AutoLogon",Constants,1);
    SpAddLineToSection(WinntSifHandle,L"Networking",L"ProcessPageSections",Constants,1);
    Constants[0]=L"Dummy";
    SpAddLineToSection(WinntSifHandle,L"Identification",L"JoinWorkgroup",Constants,1);
    Constants[0] = L"%systemroot%\\rccser\\rccser.exe";
    SpAddLineToSection(WinntSifHandle,L"GuiRunOnce",NULL,Constants,1);
    return;
}

#endif

NTSTATUS
SpRenameSetupAPILog(
    PDISK_REGION TargetRegion,
    PCWSTR       TargetPath
    );

NTSTATUS
SpProcessMigrateInfFile(
    IN  PVOID InfHandle
    );

NTSTATUS
SpProcessUnsupDrvInfFile(
    IN  PVOID InfHandle
    );

NTSTATUS
SpCheckForDockableMachine(
    );

VOID
SpCheckForBadBios(
    );

void
SpUpgradeToNT50FileSystems(
    PVOID SifHandle,
    PDISK_REGION SystemPartitionRegion,
    PDISK_REGION NTPartitionRegion,
    PWSTR SetupSourceDevicePath,
    PWSTR DirectoryOnSetupSource
    );

//
// From spcopy.c.
//

BOOLEAN
SpDelEnumFile(
    IN  PCWSTR                     DirName,
    IN  PFILE_BOTH_DIR_INFORMATION FileInfo,
    OUT PULONG                     ret,
    IN  PVOID                      Pointer
    );

//begin NEC98
VOID
SpCheckHiveDriveLetters(
    VOID
    );

VOID
SpSetHiveDriveLetterNec98(
    BOOLEAN DriveAssign_AT
    );

VOID
SpDeleteDriveLetterFromNTFTNec98(
    VOID
    );

VOID
SpDeleteDriveLetterFromNTFTWorkerNec98(
    VOID
    );

NTSTATUS
SpDiskRegistryQueryRoutineNec98(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    );

extern VOID
SpPtRemapDriveLetters(
    IN BOOLEAN DriveAssign_AT
    );

extern VOID
SpPtAssignDriveLetters(
    VOID
    );
//end NEC98





ValidationValue
SpValidateAdminPassword(
    IN ULONG Key
    )
{
    if( Key == KEY_F3 ) {
        SpConfirmExit();

        // We didn't exit, so repaint the screen.        
        SpDisplayStatusOptions( DEFAULT_STATUS_ATTRIBUTE,
                                SP_STAT_F3_EQUALS_EXIT,
                                0 );
        SpDisplayScreen( SP_SCRN_GET_ADMIN_PASSWORD, 3, 4 );
        return ValidateRepaint;
    }


    if( (Key > 0x20) && (Key < 0x7F) ) {
        // The key fits our criteria.
        return(ValidateAccept);
    }
    return(ValidateReject);
}


BOOLEAN
SpGetAdministratorPassword( 
    PWCHAR   AdministratorPassword,
    ULONG    MaxPasswordLength
    )
/*++

Routine Description:

    This routine asks the user for an administrator password.
    
    The contents of the response are checked to ensure the password
    is reasonable.  If the response is not deemed reasonable, then
    the user is informed and requeried.

Arguments:

    AdministratorPassword - Pointer to a string which holds the password.

    MaxPasswordLength - size of the AdministratorPassword buffer.

Return Value:

    Returns TRUE if the password is successfully retrieved.
    
    FALSE otherwise.

--*/
{
    BOOLEAN Done = FALSE;    
    
    
    if( (AdministratorPassword == NULL) || (MaxPasswordLength == 0) ) {
        return FALSE;
    }



    //
    // Keep asking the user until we get what we want.
    //
    Done = FALSE;
    do {
        SpDisplayStatusOptions( DEFAULT_STATUS_ATTRIBUTE,
                                SP_STAT_F3_EQUALS_EXIT,
                                0 );
        SpDisplayScreen( SP_SCRN_GET_ADMIN_PASSWORD, 3, 4 );
        
        SpInputDrain();

        AdministratorPassword[0] = TEXT('\0');
        SpGetInput( SpValidateAdminPassword,
                    27,                     // left edge of edit field.
                    NextMessageTopLine - 1,
                    (MaxPasswordLength < 25) ? MaxPasswordLength : 20,
                    AdministratorPassword,
                    FALSE );

        if( wcscmp( AdministratorPassword, TEXT("") ) ) {
            // We got something.
            Done = TRUE;
        }

    } while ( !Done );
    
    
    return TRUE;
}



VOID
SpMigrateDeviceInstanceData(
    VOID
    )
{
    NTSTATUS    status;
    PVOID       tmpWinntSifHandle = NULL;
    ULONG       lineCount, errorLine, lineIndex;
    PWSTR       keyName, keyValue;
    ULONG       ulDisposition, drvInst;
    DWORD       valueData;
    UNICODE_STRING unicodeString, valueName, drvInstString;
    OBJECT_ATTRIBUTES obja;
    HANDLE      hControlClassKey, hClassGuidKey, hClassGuidSubkey;
    HANDLE      hEnumKey, hEnumeratorKey, hDeviceKey, hInstanceKey, hLogConfKey;
    PWSTR       classGuid, classGuidSubkey;
    PWSTR       enumerator, device, instance;

    //
    // Use the asrpnp.sif file, if present, otherwise use winnt.sif.
    //
    if (SetupldrASRPnPSifFileSize != 0) {
        status = SpLoadSetupTextFile(NULL,
                                     SetupldrASRPnPSifFile,
                                     SetupldrASRPnPSifFileSize,
                                     &tmpWinntSifHandle,
                                     &errorLine,
                                     FALSE,
                                     TRUE
                                     );
    } else {
        status = SpLoadSetupTextFile(NULL,
                                     SetupldrWinntSifFile,
                                     SetupldrWinntSifFileSize,
                                     &tmpWinntSifHandle,
                                     &errorLine,
                                     FALSE,
                                     TRUE
                                     );
    }

    if (!NT_SUCCESS(status)) {
        return;
    }

    //
    // Process the section for hash values to migrate
    //
    lineCount = SpCountLinesInSection(tmpWinntSifHandle,
                                      WINNT_DEVICEHASHVALUES_W);
    if (lineCount != 0) {
        //
        // There are hash values in the sif file that need to be migrated.
        // Open the Enum branch of the registry.
        //
        INIT_OBJA(&obja,
                  &unicodeString,
                  L"\\Registry\\Machine\\System\\CurrentControlSet\\Enum");

        status = ZwCreateKey(&hEnumKey,
                             KEY_ALL_ACCESS,
                             &obja,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             &ulDisposition);

        if (NT_SUCCESS(status)) {

            //
            // Make sure that the Enum key has already been created by
            // kernel-mode PnP.  This is important because kernel-mode PnP
            // creates the key with special ACLs.
            //
            ASSERT(ulDisposition == REG_OPENED_EXISTING_KEY);

            for (lineIndex = 0; lineIndex < lineCount; lineIndex++) {

                //
                // key name is the hash value name
                //
                keyName = SpGetKeyName(tmpWinntSifHandle,
                                       WINNT_DEVICEHASHVALUES_W,
                                       lineIndex);
                if ((keyName == NULL) || (wcslen(keyName) == 0)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                               "SETUP: Unable to get the hash value, Section = %ls \n",
                               WINNT_DEVICEHASHVALUES_W));
                    continue;
                }

                //
                // key value index == 0 is the hash value data
                //
                keyValue = SpGetSectionKeyIndex(tmpWinntSifHandle,
                                                WINNT_DEVICEHASHVALUES_W,
                                                keyName, 0);

                if ((keyValue == NULL) || (wcslen(keyValue) == 0)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                               "SETUP: Unable to get the hash value data, Section = %ls, hash = %ls\n",
                               WINNT_DEVICEHASHVALUES_W, keyName));
                    continue;
                }

                RtlInitUnicodeString(&unicodeString, keyValue);
                status = RtlUnicodeStringToInteger(&unicodeString,
                                                   0, // base 10 (or as specified)
                                                   &valueData);
                if (NT_SUCCESS(status)) {
                    RtlInitUnicodeString(&valueName, SpDupStringW(keyName));

                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                               "SETUP: Migrating hash value: %ls = %ls\n",
                               keyName, keyValue));

                    //
                    // Create the hash value under the Enum branch
                    //
                    status = ZwSetValueKey(hEnumKey,
                                           &valueName,
                                           0, // XXX TITLE_INDEX_VALUE
                                           REG_DWORD,
                                           &valueData,
                                           sizeof(DWORD));
                }

                if (!NT_SUCCESS(status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                               "SETUP: Unable to set hash value entry %ws\n",
                               valueName.Buffer));
                }

                SpMemFree(valueName.Buffer);
            }

            //
            // Close the Enum key
            //
            ZwClose(hEnumKey);

        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                       "SETUP: Unable to open Enum key, status == %08lx\n",
                       status));
        }
    }


    //
    // Process the section for class keys to migrate
    //
    lineCount = SpCountLinesInSection(tmpWinntSifHandle,
                                      WINNT_CLASSKEYS_W);
    if (lineCount != 0) {
        //
        // Open the Class key of the registry
        //
        INIT_OBJA(&obja,
                  &unicodeString,
                  L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Class");

        status = ZwCreateKey(&hControlClassKey,
                             KEY_ALL_ACCESS,
                             &obja,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             &ulDisposition);

        if (NT_SUCCESS(status)) {
            //
            // Verify that the key was already present
            //
            ASSERT(ulDisposition == REG_OPENED_EXISTING_KEY);

            //
            // Migrate the Class keys in the sif file
            //
            for (lineIndex = 0; lineIndex < lineCount; lineIndex++) {

                //
                // Index == 0 of each line in the classkeys section is the name
                // of a Class subkey to be created
                //
                keyName = SpGetSectionLineIndex(tmpWinntSifHandle,
                                                WINNT_CLASSKEYS_W,
                                                lineIndex, 0);

                if (keyName == NULL) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                               "SETUP: Unable to get the Class subkey, Section = %ls \n",
                               WINNT_CLASSKEYS_W));
                    continue;
                }

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Migrating class key = %ls. \n", keyName));

                //
                // Make a copy of the class subkey path
                //
                classGuid = SpDupStringW(keyName);
                if (!classGuid) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                               "SETUP: Cannot create the migrated Class subkey %ws\n",
                               keyName));
                    continue;
                }

                //
                // Separate the class GUID key and subkey strings
                //
                classGuidSubkey = wcschr(classGuid, L'\\');
                ASSERT(classGuidSubkey);
                if (classGuidSubkey == NULL) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                               "SETUP: Cannot create the migrated Class subkey %ws\n",
                               keyName));
                    SpMemFree(classGuid);
                    continue;
                }

                *classGuidSubkey = L'\0';
                classGuidSubkey++;

                //
                // Create/open the class GUID key under the Control\Class key
                //
                INIT_OBJA(&obja,
                          &unicodeString,
                          classGuid);

                obja.RootDirectory = hControlClassKey;

                status = ZwCreateKey(&hClassGuidKey,
                                     KEY_ALL_ACCESS,
                                     &obja,
                                     0,
                                     NULL,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL);

                if (NT_SUCCESS(status)) {
                    //
                    // Create/open the class GUID subkey under the class GUID key
                    //
                    INIT_OBJA(&obja,
                              &unicodeString,
                              classGuidSubkey);

                    obja.RootDirectory = hClassGuidKey;

                    status = ZwCreateKey(&hClassGuidSubkey,
                                         KEY_ALL_ACCESS,
                                         &obja,
                                         0,
                                         NULL,
                                         REG_OPTION_NON_VOLATILE,
                                         NULL);

                    if (NT_SUCCESS(status)) {
                        //
                        // Close the Class GUID subkey
                        //
                        ZwClose(hClassGuidSubkey);

                    } else {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                                   "SETUP: Unable to create subkey %ws for class %ws, status == %08lx\n",
                                   classGuid, classGuidSubkey, status));
                    }

                    //
                    // Close the Class GUID key
                    //
                    ZwClose(hClassGuidKey);


                } else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                               "SETUP: Unable to create class key %ws, status == %08lx\n",
                               classGuid, status));
                }

                //
                // Free the allocated string
                //
                SpMemFree(classGuid);

            }

            //
            // Close the Control\Class key
            //
            ZwClose(hControlClassKey);

        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                       "SETUP: Unable to open Control\\Class key, status == %08lx\n",
                       status));
        }
    }


    //
    // Process the section for device instances to migrate
    //
    lineCount = SpCountLinesInSection(tmpWinntSifHandle,
                                      WINNT_DEVICEINSTANCES_W);

    if (lineCount != 0) {
        //
        // Open the Enum key of the registry
        //
        INIT_OBJA(&obja,
                  &unicodeString,
                  L"\\Registry\\Machine\\System\\CurrentControlSet\\Enum");

        status = ZwCreateKey(&hEnumKey,
                             KEY_ALL_ACCESS,
                             &obja,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             &ulDisposition);

        //
        // Verify that the Enum key was already present
        //
        ASSERT(ulDisposition == REG_OPENED_EXISTING_KEY);

        for (lineIndex = 0; lineIndex < lineCount; lineIndex++) {
            //
            // Index == 0 of each line in the deviceinstances section is a
            // device instance key to be created
            //
            keyName = SpGetSectionLineIndex(tmpWinntSifHandle,
                                            WINNT_DEVICEINSTANCES_W,
                                            lineIndex, 0);
            if (keyName == NULL) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                           "SETUP: Unable to get the device instance path, Section = %ls \n",
                           WINNT_DEVICEINSTANCES_W));
                continue;
            }

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Migrating device instance = %ls. \n", keyName));

            //
            // Make a copy of the device instance path
            //
            enumerator = SpDupStringW(keyName);
            if (!enumerator) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                           "SETUP: Cannot copy device instance path %ws\n",
                           keyName));
                continue;
            }

            //
            // Separate the enumerator and device strings
            //
            device = wcschr(enumerator, L'\\');
            ASSERT(device);
            if (device == NULL) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                           "SETUP: Cannot separate device string from device instance path %ws\n",
                           enumerator));
                SpMemFree(enumerator);
                continue;
            }

            *device = L'\0';
            device++;

            //
            // Separate the device and instance strings
            //
            instance = wcschr(device, L'\\');
            ASSERT(instance);
            if (instance == NULL) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                           "SETUP: Cannot separate instance string from device instance path %ws\n",
                           enumerator));
                SpMemFree(enumerator);
                continue;
            }

            *instance = L'\0';
            instance++;

            //
            // Create/open the enumerator key under the Enum key
            //
            INIT_OBJA(&obja,
                      &unicodeString,
                      enumerator);

            obja.RootDirectory = hEnumKey;

            status = ZwCreateKey(&hEnumeratorKey,
                                 KEY_ALL_ACCESS,
                                 &obja,
                                 0,
                                 NULL,
                                 REG_OPTION_NON_VOLATILE,
                                 NULL);

            if (NT_SUCCESS(status)) {
                //
                // Create/open the device subkey under the enumerator key
                //
                INIT_OBJA(&obja,
                          &unicodeString,
                          device);

                obja.RootDirectory = hEnumeratorKey;

                status = ZwCreateKey(&hDeviceKey,
                                     KEY_ALL_ACCESS,
                                     &obja,
                                     0,
                                     NULL,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL);

                //
                // Close the enumerator key
                //
                ZwClose(hEnumeratorKey);

                if (NT_SUCCESS(status)) {
                    //
                    // Create/open the instance subkey under the device key
                    //
                    INIT_OBJA(&obja,
                              &unicodeString,
                              instance);

                    obja.RootDirectory = hDeviceKey;

                    status = ZwCreateKey(&hInstanceKey,
                                         KEY_ALL_ACCESS,
                                         &obja,
                                         0,
                                         NULL,
                                         REG_OPTION_NON_VOLATILE,
                                         &ulDisposition);

                    //
                    // Close the device key
                    //
                    ZwClose(hDeviceKey);

                    if (NT_SUCCESS(status)) {

                        //
                        // If this instance key was newly created, set a value
                        // indicating that it is a special migrated key.
                        //
                        if (ulDisposition == REG_CREATED_NEW_KEY) {
                            valueData = 1;
                            RtlInitUnicodeString(&valueName, L"Migrated");
                            status = ZwSetValueKey(hInstanceKey,
                                                   &valueName,
                                                   0, // XXX TITLE_INDEX_VALUE
                                                   REG_DWORD,
                                                   &valueData,
                                                   sizeof(DWORD));
                            if (!NT_SUCCESS(status)) {
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                                           "SETUP: Unable to set Migrated == 1 for %ws, status == %08lx\n",
                                           keyName, status));
                            }
                        }

                        //
                        // Index == 1 is the UniqueParentID
                        //
                        keyValue = SpGetSectionLineIndex(tmpWinntSifHandle,
                                                         WINNT_DEVICEINSTANCES_W,
                                                         lineIndex, 1);

                        if (keyValue && (wcslen(keyValue) != 0)) {
                            // temporarily use unicodeString for conversion
                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                                       "SETUP:\tUniqueParentID = %ls. \n",
                                       keyValue));
                            RtlInitUnicodeString(&unicodeString, keyValue);
                            status = RtlUnicodeStringToInteger(&unicodeString,
                                                               16,  // base 16
                                                               &valueData);
                            if (NT_SUCCESS(status)) {
                                RtlInitUnicodeString(&valueName, L"UniqueParentID");
                                status = ZwSetValueKey(hInstanceKey,
                                                       &valueName,
                                                       0, // XXX TITLE_INDEX_VALUE
                                                       REG_DWORD,
                                                       &valueData,
                                                       sizeof(DWORD));
                            }
                            if (!NT_SUCCESS(status)) {
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                                           "SETUP: Unable to set UniqueParentID value for %ws, status == %08lx\n",
                                           keyName, status));
                            }
                        }

                        //
                        // Index == 2 is the parent id prefix
                        //
                        keyValue = SpGetSectionLineIndex(tmpWinntSifHandle,
                                                         WINNT_DEVICEINSTANCES_W,
                                                         lineIndex, 2);

                        if (keyValue && (wcslen(keyValue) != 0)) {
                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                                       "SETUP:\tParentIdPrefix = %ls. \n",
                                       keyValue));
                            RtlInitUnicodeString(&unicodeString, keyValue);
                            RtlInitUnicodeString(&valueName, L"ParentIdPrefix");
                            status = ZwSetValueKey(hInstanceKey,
                                                   &valueName,
                                                   0, // XXX TITLE_INDEX_VALUE
                                                   REG_SZ,
                                                   unicodeString.Buffer,
                                                   unicodeString.Length + sizeof(UNICODE_NULL));
                            if (!NT_SUCCESS(status)) {
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                                           "SETUP: Unable to set ParentIdPrefix value for %ws, status == %08lx\n",
                                           keyName, status));
                            }
                        }

                        //
                        // Index == 3 is the class key name
                        //
                        keyValue = SpGetSectionLineIndex(tmpWinntSifHandle,
                                                         WINNT_DEVICEINSTANCES_W,
                                                         lineIndex, 3);

                        if (keyValue && (wcslen(keyValue) > GUID_STRING_LEN)) {
                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:\tClass key = %ls. \n", keyValue));

                            RtlInitUnicodeString(&valueName, REGSTR_VAL_DRIVER);
                            status = ZwSetValueKey(
                                hInstanceKey,
                                &valueName,
                                0,
                                REG_SZ,
                                keyValue,
                                (wcslen(keyValue) + 1) * sizeof(WCHAR));
                            if (!NT_SUCCESS(status)) {
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                                           "SETUP: Unable to set Driver value for %ws, status == %08lx\n",
                                           keyName, status));
                            }

                            //
                            // Migrate the ClassGUID value also (implied from
                            // the class key name), otherwise the class key name
                            // value may be considered invalid.
                            //
                            instance = wcschr(keyValue, L'\\');
                            ASSERT(instance);
                            ASSERT((instance - keyValue + 1) == GUID_STRING_LEN);
                            if ((instance != NULL) && ((instance - keyValue + 1) == GUID_STRING_LEN)) {
                                //
                                // Separate the instance subkey from the class GUID.
                                //
                                *instance = L'\0';

                                RtlInitUnicodeString(&valueName, REGSTR_VAL_CLASSGUID);

                                status = ZwSetValueKey(
                                    hInstanceKey,
                                    &valueName,
                                    0,
                                    REG_SZ,
                                    keyValue,
                                    GUID_STRING_LEN * sizeof(WCHAR));
                                if (!NT_SUCCESS(status)) {
                                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                                               "SETUP: Unable to set ClassGUID value for %ws, status == %08lx\n",
                                               keyName, status));
                                }
                            } else {
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                                           "SETUP: Cannot separate instance string class GUID for %ws\n",
                                           keyName));
                            }
                        }

                        //
                        // Index == 4 is the Service name, migrated for ROOT
                        // enumerated device instances only.
                        //
                        keyValue = SpGetSectionLineIndex(tmpWinntSifHandle,
                                                         WINNT_DEVICEINSTANCES_W,
                                                         lineIndex, 4);

                        if (keyValue && (wcslen(keyValue) != 0)) {
                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:\tService = %ls. \n", keyValue));
                            RtlInitUnicodeString(&unicodeString, keyValue);
                            RtlInitUnicodeString(&valueName, REGSTR_VAL_SERVICE);
                            status = ZwSetValueKey(hInstanceKey,
                                                   &valueName,
                                                   0, // XXX TITLE_INDEX_VALUE
                                                   REG_SZ,
                                                   unicodeString.Buffer,
                                                   unicodeString.Length + sizeof(UNICODE_NULL));
                            if (!NT_SUCCESS(status)) {
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                                           "SETUP: Unable to set Service value for %ws, status == %08lx\n",
                                           keyName, status));
                            }
                        }

                        //
                        // Index == 5 is the BootConfig data, migrated for ROOT
                        // enumerated device instances only.
                        //
                        keyValue = SpGetSectionLineIndex(tmpWinntSifHandle,
                                                         WINNT_DEVICEINSTANCES_W,
                                                         lineIndex, 5);

                        if (keyValue && (wcslen(keyValue) != 0)) {
                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                                       "SETUP:\tBootConfig = %ls. \n",
                                       keyValue));
                            //
                            // Create/open the non-volatile LogConf subkey,
                            // under the instance key.
                            //
                            INIT_OBJA(&obja,
                                      &unicodeString,
                                      L"LogConf");

                            obja.RootDirectory = hInstanceKey;

                            status = ZwCreateKey(&hLogConfKey,
                                                 KEY_ALL_ACCESS,
                                                 &obja,
                                                 0,
                                                 NULL,
                                                 REG_OPTION_NON_VOLATILE,
                                                 &ulDisposition);
                            if (NT_SUCCESS(status) && (ulDisposition == REG_CREATED_NEW_KEY)) {
                                DWORD i, length;
                                WCHAR szByte[3];
                                ULONG ulByte;
                                PBYTE pBootConfig = NULL;

                                //
                                // Since each character is just a nibble, make
                                // sure we have an even number of characters,
                                // else we won't have a whole number of bytes.
                                //
                                length = wcslen(keyValue);
                                ASSERT((length % 2) == 0);

                                pBootConfig = SpMemAlloc(length/2);
                                if (pBootConfig) {
                                    //
                                    // Convert the BootConfig string buffer data
                                    // to bytes.
                                    //
                                    for (i = 0; i < length; i+=2) {
                                        szByte[0] = keyValue[i];
                                        szByte[1] = keyValue[i+1];
                                        szByte[2] = UNICODE_NULL;

                                        RtlInitUnicodeString(&unicodeString, szByte);

                                        status = RtlUnicodeStringToInteger(&unicodeString,
                                                                           16,
                                                                           &ulByte);
                                        ASSERT(NT_SUCCESS(status));
                                        ASSERT(ulByte <= 0xFF);

                                        pBootConfig[i/2] = (BYTE)ulByte;

                                    }

                                    RtlInitUnicodeString(&valueName, REGSTR_VAL_BOOTCONFIG);
                                    status = ZwSetValueKey(hLogConfKey,
                                                           &valueName,
                                                           0, // XXX TITLE_INDEX_VALUE
                                                           REG_RESOURCE_LIST,
                                                           pBootConfig,
                                                           length/2);
                                    if (!NT_SUCCESS(status)) {
                                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                                                   "SETUP: Unable to set BootConfig value for %ws, status == %08lx\n",
                                                   keyName, status));
                                    }

                                    //
                                    // Free the allocated BootConfig buffer.
                                    //
                                    SpMemFree(pBootConfig);

                                } else {
                                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                                               "SETUP: Unable to allocate BootConfig buffer for %ws\n",
                                               keyName));
                                }
                                //
                                // Close the LogConf key
                                //
                                ZwClose(hLogConfKey);
                            }
                        }

                        //
                        // Index == 6 is the FirmwareIdentified value, migrated for ROOT
                        // enumerated device instances only.
                        //
                        keyValue = SpGetSectionLineIndex(tmpWinntSifHandle,
                                                         WINNT_DEVICEINSTANCES_W,
                                                         lineIndex, 6);

                        if (keyValue && (wcslen(keyValue) != 0)) {
                            // temporarily use unicodeString for conversion
                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                                       "SETUP:\tFirmwareIdentified = %ls. \n",
                                       keyValue));
                            RtlInitUnicodeString(&unicodeString, keyValue);
                            valueData = 0;
                            status = RtlUnicodeStringToInteger(&unicodeString,
                                                               16,  // base 16
                                                               &valueData);
                            if (NT_SUCCESS(status) && valueData != 0) {
                                RtlInitUnicodeString(&valueName, L"FirmwareIdentified");
                                status = ZwSetValueKey(hInstanceKey,
                                                       &valueName,
                                                       0, // XXX TITLE_INDEX_VALUE
                                                       REG_DWORD,
                                                       &valueData,
                                                       sizeof(DWORD));
                            }
                            if (!NT_SUCCESS(status)) {
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                                           "SETUP: Unable to set FirmwareIdentified value for %ws, status == %08lx\n",
                                           keyName, status));
                            }
                        }

                        //
                        // Close the instance key
                        //
                        ZwClose(hInstanceKey);

                    } else {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                                   "SETUP: Unable to create instance subkey %ws for device %ws, status == %08lx\n",
                                   instance, device, status));
                    }



                } else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                               "SETUP: Unable to create device subkey %ws for enumerator %ws, status == %08lx\n",
                               device, enumerator, status));
                }

            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                           "SETUP: Unable to create enumerator subkey %ws, status == %08lx\n",
                           enumerator, status));
            }

            //
            // Free the allocated device instance path string
            //
            SpMemFree(enumerator);
        }

        //
        // Close the Enum key
        //
        ZwClose(hEnumKey);
    }

    //
    // Free the loaded sif file
    //
    SpFreeTextFile(tmpWinntSifHandle);
}

BOOL
SpGetPnPDeviceInfo(
    IN PWSTR DeviceId,
    IN PSETUP_PNP_HARDWARE_ID HardwareIdDatabase,
    OUT PWSTR*  ServiceName,
    OUT PWSTR*  ClassGuid
    )
/*++

Routine Description:

    This routine searches the hardware id database, for an entry that matches
    the hardware id passed as parameter.
    If an entry is found, then the function returns the name of the service
    associated to the hardware id, and its ClassGUID (if any).

    Since this function is called by SpPnpNotificationCallback, it should not
    use TemporaryBuffer.
    If a temporary buffer is needed, then this function should allocate its own.

Arguments:

    HardwareId - Pointer to a hardware id string.

    ServiceName - On return, it will contain the pointer to the service name
                  for the device.

    ClassGuid - On return, it will contain the pointer the class GUID for
                the device.

Return Value:

    Returns TRUE if the HardwareId was found on the database,
    or FALSE otherwise.

--*/
{
    PWCHAR s,lastsep;
    BOOLEAN DeviceFound;
    PSETUP_PNP_HARDWARE_ID p;


    lastsep = DeviceId;
    for(s=DeviceId; *s; s++) {
        if((*s == L'*') || (*s == L'\\')) {
            lastsep = s+1;
        }
    }

    DeviceFound = FALSE;
    for(p=HardwareIdDatabase; p; p=p->Next) {
        //
        // Check for a direct match
        //
        if(!_wcsicmp(p->Id,DeviceId)) {
            *ServiceName = p->DriverName;
            *ClassGuid = p->ClassGuid;
            DeviceFound = TRUE;
            break;
        }

        //
        // If there was a '*' check for a component match
        //
        if((p->Id[0] == L'*') && !_wcsicmp(p->Id+1,lastsep)) {
            *ServiceName = p->DriverName;
            *ClassGuid = p->ClassGuid;
            DeviceFound = TRUE;
            break;
        }
    }

    return(DeviceFound);
}


NTSTATUS
SpPnPNotificationCallBack(
    IN PVOID    NotificationStructure,
    IN PVOID    Context
    )

/*++

Routine Description:

    This is the callback function called by P&P, to inform textmode
    setup of a new hardware detected.

Arguments:

    NotificationStructure - Pointer to a structure of type
                            SETUP_DEVICE_ARRIVAL_NOTIFICATION.

    Context - Context information that textmode setup provided during
              notification registration.


Return Value:

    Status is returned.

--*/

{
    NTSTATUS            Status;
    UNICODE_STRING      UnicodeString;
    HANDLE              hKey;
    ULONG               Length;
    PWSTR               Data = NULL;
    ULONG               DataSize;
    PWSTR               ServiceName = NULL;
    PWSTR               ClassGuid = NULL;
    PWSTR               p;
    PWSTR               HardwareID = NULL;
    ULONG               i;
    BOOLEAN             SerialPortDetected = FALSE;
    PVOID               Buffer = NULL;
    ULONG               BufferSize;
    PWSTR               ValueNames[] = {
                                       REGSTR_VAL_HARDWAREID,
                                       REGSTR_VAL_COMPATIBLEIDS
                                       };
    HARDWAREIDLIST     *MyHardwareIDList = HardwareIDList;


    if (!((PSETUP_DEVICE_ARRIVAL_NOTIFICATION)NotificationStructure)->InstallDriver) {
        return STATUS_SUCCESS;
    }


    //
    //  Retrieve the service name for the device detected.
    //  To do this, we need to get each each hardware id, and determine
    //  if there is a service name associated with the id. If there is
    //  no service associated with any of the hardware ids, then we try
    //  find a service name associated the compatible id.
    //  If we can't find a service name for this device at all, then we don't
    //  need this device during textmode setup (ie, we don't install this
    //  device during textmode setup).
    //

    //
    //  Allocate a big buffer to read the registry value (service name).
    //  Note that this function should not use TemporaryBuffer, since
    //  this function can be called asyncronously at any point during setup,
    //  and TemporaryBuffer may be in use.
    //
    BufferSize = 4*1024;
    Buffer = SpMemAlloc( BufferSize );
    if( Buffer == NULL ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPnPNotificationCallBack() failed to allocate memory.\n"));
        Status = STATUS_NO_MEMORY;
        goto CleanUp;
    }
    for( i = 0; i < sizeof(ValueNames)/sizeof(PWSTR); i++ ) {

        RtlInitUnicodeString(&UnicodeString, ValueNames[i]);

        Status = ZwQueryValueKey(((PSETUP_DEVICE_ARRIVAL_NOTIFICATION)NotificationStructure)->EnumEntryKey,
                                 &UnicodeString,
                                 KeyValuePartialInformation,
                                 Buffer,
                                 BufferSize,
                                 &Length
                                 );

        if( !NT_SUCCESS(Status) && ( Status == STATUS_BUFFER_OVERFLOW ) ) {
            BufferSize = Length;
            Buffer = SpMemRealloc( Buffer, BufferSize );
            Status = ZwQueryValueKey(((PSETUP_DEVICE_ARRIVAL_NOTIFICATION)NotificationStructure)->EnumEntryKey,
                                     &UnicodeString,
                                     KeyValuePartialInformation,
                                     Buffer,
                                     Length,
                                     &Length
                                    );
        }

        if( !NT_SUCCESS(Status) ) {
            if( i == 0 ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpPnPNotificationCallBack() failed to retrieve HardwareID. Status = %lx \n", Status));
                continue;
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpPnPNotificationCallBack() failed to retrieve HardwareID and CompatibleID. Status = %lx \n", Status));
                SpMemFree( Buffer );
                goto CleanUp;
            }
        }
        Data = (PWCHAR)(((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data);
        DataSize = ((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->DataLength;
        for( p = Data;
             (p < (PWSTR)((PUCHAR)Data + DataSize) && (*p != (WCHAR)'\0'));
             p += wcslen( p ) + 1 ) {
            //
            //  Retrieve the service name for this device
            //
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: HardwareID = %ls. \n", p));
            ServiceName = NULL;
            ClassGuid = NULL;

            //
            // Now remember our list of devices for later use.
            //
            MyHardwareIDList = SpMemAlloc( sizeof(HARDWAREIDLIST) );
            MyHardwareIDList->HardwareID = SpDupStringW( p );
            MyHardwareIDList->Next = HardwareIDList;
            HardwareIDList = MyHardwareIDList;


            if( SpGetPnPDeviceInfo(p,
                                   (PSETUP_PNP_HARDWARE_ID)Context,
                                   &ServiceName,
                                   &ClassGuid) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: HardwareID = %ls, ServiceName = %ls. \n", p, ServiceName));

                if (RemoteSysPrepSetup) {
                    HardwareID = SpMemAlloc((wcslen(p) + 1) * sizeof(WCHAR));
                    if (HardwareID != NULL) {
                        wcscpy(HardwareID, p);
                    }
                }

                break;
            }
        }
        if( ServiceName != NULL ) {
            break;
        }
    }
    if( ServiceName == NULL ) {
        //
        //  We just don't care about this device during text setup phase
        //
        SpMemFree( Buffer );
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto CleanUp;
    }

    //
    //  Find out if this device is a mouse or a USB keyboard
    //
    if( !_wcsicmp( ServiceName, L"i8042prt" ) ) {
        if( !_wcsicmp( ClassGuid, KeyboardGuidString ) ) {
            //
            //  This is a keyboard
            //
            StdKeyboardDetected = TRUE;
        } else if( !_wcsicmp( ClassGuid, MouseGuidString ) ) {
            //
            //  This is a Mouse Port compatible mouse
            //
            PS2MouseDetected = TRUE;
        }
    } else if( !_wcsicmp( ServiceName, L"sermouse" ) ) {
        SerMouseDetected = TRUE;
    } else if( !_wcsicmp( ServiceName, L"mouhid" ) ) {
        UsbMouseDetected = TRUE;
    } else if( !_wcsicmp( ServiceName, L"kbdhid" ) ) {
        UsbKeyboardDetected = TRUE;
    } else if( !_wcsicmp( ServiceName, L"serial" ) ) {
        SerialPortDetected = TRUE;
    }


    //
    // At this point Buffer is no longer needed, so we free it.
    //
    SpMemFree( Buffer );
    BufferSize = 0;
    Buffer = NULL;

    //
    //  If the driver for this device was already loaded, then the device may
    //  be needed during textmode setup.
    //  Create a value entry called "Service" of type REG_SZ, with the name
    //  of the service associated with this device.
    //
    RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_SERVICE);
    Status = ZwSetValueKey( ((PSETUP_DEVICE_ARRIVAL_NOTIFICATION)NotificationStructure)->EnumEntryKey,
                            &UnicodeString,
                            0,
                            REG_SZ,
                            ServiceName,
                            (wcslen( ServiceName ) + 1)*sizeof(WCHAR) );

    if( NT_SUCCESS( Status ) && ( ClassGuid != NULL ) ) {

        RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_CLASSGUID);
        Status = ZwSetValueKey( ((PSETUP_DEVICE_ARRIVAL_NOTIFICATION)NotificationStructure)->EnumEntryKey,
                                &UnicodeString,
                                0,
                                REG_SZ,
                                ClassGuid,
                                (wcslen(ClassGuid) + 1) * sizeof(WCHAR));
    }


    if( NT_SUCCESS( Status ) ) {
        //
        // If we successfully set the controlling service value, then we should also set
        // the CONFIGFLAG_FINISH_INSTALL config flag, so that we'll finish the installation
        // of this device later (i.e., when we're in user-mode and have access to the device
        // installer APIs, class installers, etc.)
        //
        ULONG ConfigFlags = 0x00000400;     // CONFIGFLAG_FINISH_INSTALL from sdk\inc\regstr.h

        RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_CONFIGFLAGS);
        Status = ZwSetValueKey( ((PSETUP_DEVICE_ARRIVAL_NOTIFICATION)NotificationStructure)->EnumEntryKey,
                                &UnicodeString,
                                0,
                                REG_DWORD,
                                &ConfigFlags,
                                sizeof(ConfigFlags) );

        if( !NT_SUCCESS( Status ) ) {
            goto CleanUp;
        }

        //
        // If we are doing an installation of a SysPrep image, then we want to
        // remember this device so that we can transfer it as a 'CriticalDevice'
        // to the SysPrep hives in SpPatchSysPrepImage()
        //
        if (RemoteSysPrepSetup && (HardwareID != NULL)) {

            OBJECT_ATTRIBUTES Obj;
            HANDLE TmpHandle;
            HANDLE NodeHandle;
            PWCHAR pwch;

            BufferSize = 4*1024;
            Buffer = SpMemAlloc( BufferSize );

            if( Buffer == NULL ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPnPNotificationCallBack() failed to allocate memory.\n"));
                goto CleanSysPrepSetup;
            }

            INIT_OBJA(&Obj,
                      &UnicodeString,
                      L"\\Registry\\Machine\\System\\CurrentControlSet\\Control"
                     );

            Status = ZwOpenKey(&TmpHandle, KEY_ALL_ACCESS, &Obj);

            if( !NT_SUCCESS(Status) ) {
                goto CleanSysPrepSetup;
            }

            INIT_OBJA(&Obj, &UnicodeString, L"CriticalDeviceDatabase");

            Obj.RootDirectory = TmpHandle;

            Status = ZwCreateKey(&NodeHandle,
                                 KEY_ALL_ACCESS,
                                 &Obj,
                                 0,
                                 NULL,
                                 0,
                                 NULL
                                );

            ZwClose(TmpHandle);

            if( !NT_SUCCESS(Status) ) {
                goto CleanSysPrepSetup;
            }

            //
            // Now create subkey with the device name
            //

            for (pwch = HardwareID; *pwch != UNICODE_NULL; pwch++) {
                if (*pwch == L'\\') {
                    *pwch = L'#';
                }
            }

            INIT_OBJA(&Obj, &UnicodeString, HardwareID);

            Obj.RootDirectory = NodeHandle;

            Status = ZwCreateKey(&TmpHandle,
                                 KEY_ALL_ACCESS,
                                 &Obj,
                                 0,
                                 NULL,
                                 0,
                                 NULL
                                );

            ZwClose(NodeHandle);

            if( !NT_SUCCESS(Status) ) {
                goto CleanSysPrepSetup;
            }

            //
            // Fill in service value now
            //
            RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_SERVICE);
            ZwSetValueKey(TmpHandle,
                          &UnicodeString,
                          0,
                          REG_SZ,
                          ServiceName,
                          (wcslen( ServiceName ) + 1)*sizeof(WCHAR)
                         );

            if (ClassGuid != NULL) {

                RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_CLASSGUID);
                ZwSetValueKey(TmpHandle,
                              &UnicodeString,
                              0,
                              REG_SZ,
                              ClassGuid,
                              (wcslen( ClassGuid ) + 1)*sizeof(WCHAR)
                             );

            }

            ZwClose(TmpHandle);

CleanSysPrepSetup:

            if (Buffer != NULL) {
                SpMemFree( Buffer );
                BufferSize = 0;
                Buffer = NULL;
            }

        }

        //
        //  Hack for serial
        //
        if( SerialPortDetected ) {
            // DWORD   PollingPeriod = 0x32;
            WCHAR   SerialUpperFilters[] = L"serenum\0";

#if 0       // remove polling, will be enabled after NT5.0
            Status = IoOpenDeviceRegistryKey( ((PSETUP_DEVICE_ARRIVAL_NOTIFICATION)NotificationStructure)->PhysicalDeviceObject,
                                              PLUGPLAY_REGKEY_DEVICE,
                                              MAXIMUM_ALLOWED,
                                              &hKey );

            if( !NT_SUCCESS( Status ) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: IoOpenDeviceRegistryKey() failed. Status = %lx. \n", Status));
                goto CleanUp;
            }

            RtlInitUnicodeString(&UnicodeString, L"PollingPeriod");
            Status = ZwSetValueKey( hKey,
                                    &UnicodeString,
                                    0,
                                    REG_DWORD,
                                    &PollingPeriod,
                                    sizeof(PollingPeriod) );
            ZwClose( hKey );

            if( !NT_SUCCESS( Status ) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ZwSetValueKey() failed to create PollingPeriod. Status = %lx. \n", Status));
                goto CleanUp;
            }
#endif

            RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_UPPERFILTERS);
            Status = ZwSetValueKey( ((PSETUP_DEVICE_ARRIVAL_NOTIFICATION)NotificationStructure)->EnumEntryKey,
                                    &UnicodeString,
                                    0,
                                    REG_MULTI_SZ,
                                    SerialUpperFilters,
                                    sizeof(SerialUpperFilters) );

            if( !NT_SUCCESS( Status ) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ZwSetValueKey() failed to create SerialUpperFilters. Status = %lx. \n", Status));
                goto CleanUp;
            }
        }
    }

CleanUp:

    if (HardwareID != NULL) {
        SpMemFree(HardwareID);
    }
    return Status;
}


PCOMMAND_INTERPRETER_ROUTINE _CmdRoutine;

VOID
CommandConsoleInterface(
    PCOMMAND_INTERPRETER_ROUTINE CmdRoutine
    )
{
    _CmdRoutine = CmdRoutine;
}


ULONG
SpStartCommandConsole(
    PVOID SifHandle,
    PWSTR SetupSourceDevicePath,
    PWSTR DirectoryOnSetupSource
    )
{
    #define CMDCONS_NAME L"SPCMDCON.SYS"
    NTSTATUS            Status;
    static BOOLEAN      Loaded = FALSE;
    PWCHAR              FullName;
    PWCHAR              ServiceKey;
    UNICODE_STRING      ServiceKeyU;
    PWSTR               pwstr;
    ULONG               rc;
    BOOLEAN             b;
    OBJECT_ATTRIBUTES   objectAttributes;
    UNICODE_STRING      unicodeString;
    IO_STATUS_BLOCK     ioStatusBlock;
    HANDLE              hFile;
    PWSTR               Tagfile;
    PWSTR               Description;
    PWSTR               MediaShortName;
    ULONG               MediaType=INDEX_WHICHBOOTMEDIA;
    ULONG               LoadCount;

    extern PVOID KeyboardTable;


    //
    // Let JPN/KOR user select keyboard type before running Command Console.
    //
    // SplangSelectKeyboard & SplangReinitializeKeyboard are from spddlang.sys.
    //
    // These two functions only affect JPN/KOR builds.
    //
    // They are stub functions on US build and do nothing.
    //
    // 0xFF in SplangSelectKeyboard is a tag, such that it knows this is
    // called from Command Console.
    //

    if (ConsoleFromWinnt32) {
        SplangSelectKeyboard(
            FALSE,
            NULL,
            0xFF,
            SifHandle,
            HardwareComponents
        );

        SplangReinitializeKeyboard(
            FALSE,
            SifHandle,
            DirectoryOnBootDevice,
            &KeyboardTable,
            HardwareComponents
        );
    }

    pwstr = TemporaryBuffer;

    //
    // Form the full name of the device driver file.
    //
    wcscpy(pwstr,NtBootDevicePath);
    SpConcatenatePaths(pwstr,DirectoryOnBootDevice);
    SpConcatenatePaths(pwstr,CMDCONS_NAME);
    FullName = SpDupStringW(pwstr);

    //
    // check to see if the file exists on the source media
    // if not then prompt for the correct media
    //

    SpStringToLower(pwstr);
    if(wcsstr(pwstr,L"cdrom"))
        MediaType = INDEX_WHICHMEDIA;
    else if(wcsstr(pwstr,L"floppy"))
        MediaType = INDEX_WHICHBOOTMEDIA;

    INIT_OBJA(&objectAttributes,&unicodeString,FullName);

    MediaShortName = SpLookUpValueForFile(SifHandle,CMDCONS_NAME,MediaType,TRUE);
    SpGetSourceMediaInfo(SifHandle,MediaShortName,&Description,&Tagfile,NULL);


    LoadCount = 0;

    do {
        Status = ZwOpenFile(
            &hFile,
            FILE_GENERIC_READ,
            &objectAttributes,
            &ioStatusBlock,
            0,
            0
            );

        if (NT_SUCCESS(Status)) {
            ZwClose(hFile);
        } else {
            if (!SpPromptForDisk(
                    Description,
                    NtBootDevicePath,
                    CMDCONS_NAME,
                    TRUE,             // Always prompt for at least once
                    TRUE,             // Allow user to cancel
                    FALSE,            // No multiple prompts
                    NULL              // don't care about redraw flag
                    ))
            {
              break;
            }

            //
            // try once more after prompting for disk
            //
            LoadCount++;
        }
    } while (!NT_SUCCESS(Status) && (LoadCount < 2));

    if (!NT_SUCCESS(Status)) {
      SpStartScreen(
              SP_CMDCONS_NOT_FOUND,
              0,
              0,
              TRUE,
              TRUE,
              ATT_FG_INTENSE | ATT_FG_WHITE | ATT_BG_BLACK
              );

      SpInputDrain();
      while(SpInputGetKeypress() != KEY_F3);

      SpMemFree(FullName);

      return 0;
    }

    //
    // Create a service entry for the driver.
    //
    ServiceKey = NULL;
    Status = SpCreateServiceEntry(FullName,&ServiceKey);

    SpMemFree(FullName);

    if(!NT_SUCCESS(Status)) {
        return 0;
    }

    RtlInitUnicodeString(&ServiceKeyU,ServiceKey);

again:
    if(!Loaded) {

        Status = ZwLoadDriver(&ServiceKeyU);

        if(NT_SUCCESS(Status)) {
            Loaded = TRUE;
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to load %s (%lx)\n",CMDCONS_NAME,Status));
        }
    }

    if(Loaded) {
        Block.VideoVars = &VideoVars;
        Block.TemporaryBuffer = TemporaryBuffer;
        Block.TemporaryBufferSize = sizeof(TemporaryBuffer);
        Block.UsetupProcess = UsetupProcess;
        Block.BootDevicePath = NtBootDevicePath;
        Block.DirectoryOnBootDevice = DirectoryOnBootDevice;
        Block.SifHandle = SifHandle;
        Block.SetupSourceDevicePath = SetupSourceDevicePath;
        Block.DirectoryOnSetupSource = DirectoryOnSetupSource;

        if (HeadlessTerminalConnected) {
            Block.VideoVars->ScreenHeight = HEADLESS_SCREEN_HEIGHT+1;
        }

        // make the global variable point to the block
        gpCmdConsBlock = &Block;

        ConsoleRunning = TRUE;
        rc = _CmdRoutine(&Block);
        ConsoleRunning = FALSE;

        if (rc == 1) {
            Status = ZwUnloadDriver(&ServiceKeyU);
            if(NT_SUCCESS(Status)) {
                Loaded = FALSE;
                goto again;
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to un-load %s (%lx)\n",CMDCONS_NAME,Status));
            }
        }

#if 0
        // why is this here? -matth 02/12/2001
        //
        // In the non-local case, this gets sent to a remote console,
        // then stays there until the machine reboots and pasts post.
        // This can take a really long time and confuses end users.
        //
        SpDisplayHeaderText(
            SpGetHeaderTextId(),
            DEFAULT_ATTRIBUTE
            );
#endif

    }

    SpMemFree(ServiceKey);
    return 0;
}


NTSTATUS
SpInitialize0(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    Initialize the setup device driver.  This includes initializing
    the memory allocator, saving away pieces of the os loader block,
    and populating the registry with information about device drivers
    that setupldr loaded for us.

Arguments:

    DriverObject - supplies pointer to driver object for setupdd.sys.

Return Value:

    Status is returned.

--*/

{
    PLOADER_PARAMETER_BLOCK loaderBlock;
    PSETUP_LOADER_BLOCK setupLoaderBlock;
    PLIST_ENTRY nextEntry;
    PBOOT_DRIVER_LIST_ENTRY bootDriver;
    PWSTR ServiceName;
    NTSTATUS Status = STATUS_SUCCESS;
    PWSTR imagePath;
    PWSTR registryPath;

    UNICODE_STRING  GuidString;

    //
    // Fetch a pointer to the os loader block and setup loader block.
    //
    loaderBlock = *(PLOADER_PARAMETER_BLOCK *)KeLoaderBlock;
    setupLoaderBlock = loaderBlock->SetupLoaderBlock;

    if ( (setupLoaderBlock->Flags & SETUPBLK_FLAGS_CONSOLE) != 0 ) {
        ForceConsole = TRUE;
    }

    if (setupLoaderBlock->Flags & SETUPBLK_FLAGS_ROLLBACK) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Rollback enabled through osloadoptions"));
        Win9xRollback = TRUE;
    }


    //
    // Phase 0 display initialization.
    //
    SpvidInitialize0(loaderBlock);

    //
    // Make a copy of the ARC pathname from which we booted.
    // This is guaranteed to be the ARC equivalent of \systemroot.
    //
    ArcBootDevicePath = SpToUnicode(loaderBlock->ArcBootDeviceName);

    if ( (setupLoaderBlock->Flags & SETUPBLK_FLAGS_IS_REMOTE_BOOT) != 0 ) {

        PUCHAR p;
        PUCHAR q;

        //
        // This is a remote boot setup. NtBootPathName is of the form
        // \<server>\<share>\setup\<install-directory>\<platform>.
        // System initialization (in ntos\fstub\drivesup.c, routine
        // xHalIoAssignDriveLetters) has assigned the C: drive to point to
        // \Device\LanmanRedirector\<server>\<share>\setup\<install-directory>.
        // DirectoryOnBootDevice should contain the path that needs to be
        // added to C: in order to access files from user mode. So to
        // calculate it, we want to start at the backslash before <platform>.
        //
        // N.B. We know that the strrchr calls below will not return NULL,
        //      because xHalIoAssignDriveLetters would have bugchecked if
        //      the string in NtBootPathName was malformed.
        //

        ASSERT( _stricmp( loaderBlock->ArcBootDeviceName, "net(0)" ) == 0 );

        RemoteBootSetup = TRUE;

        if (setupLoaderBlock->Flags & SETUPBLK_FLAGS_SYSPREP_INSTALL) {
            RemoteSysPrepSetup = TRUE;
            RemoteIMirrorFilePath = SpDupString(setupLoaderBlock->NetBootIMirrorFilePath);
            RemoteServerIpAddress = setupLoaderBlock->ServerIpAddress;
            RtlCopyMemory(&RemoteSysPrepNetCardInfo, setupLoaderBlock->NetbootCardInfo, sizeof(NET_CARD_INFO));
        }

        p = strrchr( loaderBlock->NtBootPathName, '\\' );
        ASSERT( p != NULL );
        if (!p)
        return STATUS_OBJECT_PATH_INVALID;
        if ( *(p+1) == 0 ) {

            //
            // NtBootPathName ends with a backslash, so we need to back up
            // to the previous backslash.
            //

            q = p;
            *q = 0;
            p = strrchr( loaderBlock->NtBootPathName, '\\' );   // find last separator
            ASSERT( p != NULL );
            *q = '\\';
        }

        if (!p)
        return STATUS_OBJECT_PATH_INVALID; // shut up PREfix.
        DirectoryOnBootDevice = SpToUnicode(p);
        SpStringToUpper(DirectoryOnBootDevice);

        //
        // Save this -- it is the part of loaderBlock->NtBootPathName that
        // is before the part we just copied to DirectoryOnBootDevice,
        // of the form \<server>\<share>\setup\<install-directory>.
        // NtBootDeviceName will be initially set up as \Device\LanmanRedirector
        // and DirectoryOnBootDevice was just set to be be only \<platform>
        // (so user-mode access works, see discussion above). We save the
        // intervening path and append it to NtBootDeviceName, so that
        // kernel-mode access that uses NtBootDeviceName + DirectoryOnBootDevice
        // will go to the correct path.
        //

        *p = 0;
        RemoteIMirrorBootDirectoryPrefix = SpToUnicode(loaderBlock->NtBootPathName);
        *p = '\\';

        if (setupLoaderBlock->NetBootAdministratorPassword[0] != '\0') {

            //
            // The Admin password that came through the setupldr block may not be terminated.
            // Copy it into a temporary buffer, terminate it, and then SpToUnicode it.
            //
            UCHAR TmpNetBootAdministratorPassword[NETBOOT_ADMIN_PASSWORD_LEN+1] = {0};

            RtlMoveMemory( TmpNetBootAdministratorPassword, 
                           setupLoaderBlock->NetBootAdministratorPassword,
                           NETBOOT_ADMIN_PASSWORD_LEN );
            TmpNetBootAdministratorPassword[NETBOOT_ADMIN_PASSWORD_LEN] = '\0';
            NetBootAdministratorPassword =
                    SpToUnicode( TmpNetBootAdministratorPassword );
        } else if (setupLoaderBlock->NetBootAdministratorPassword[NETBOOT_ADMIN_PASSWORD_LEN-1] == 0xFF) {
            //
            // this indicates that the administrator password was blank.
            //
            NetBootAdministratorPassword = SpToUnicode( "" );
        }

    } else {
        DirectoryOnBootDevice = SpToUnicode(loaderBlock->NtBootPathName);
        SpStringToUpper(DirectoryOnBootDevice);
    }


    //
    // Make a copy of the image of the setup information file.
    //
    SetupldrInfoFileSize = setupLoaderBlock->IniFileLength;
    SetupldrInfoFile = SpMemAlloc(SetupldrInfoFileSize);
    RtlMoveMemory(SetupldrInfoFile,setupLoaderBlock->IniFile,SetupldrInfoFileSize);

    SP_SET_UPGRADE_GRAPHICS_MODE(FALSE);

    //
    // Make a copy of the image of the winnt.sif file.
    //
    SetupldrWinntSifFileSize = setupLoaderBlock->WinntSifFileLength;

    if ( SetupldrWinntSifFileSize != 0 ) {
        NTSTATUS    Status;
        ULONG       ErrorLine;

        SetupldrWinntSifFile = SpMemAlloc(SetupldrWinntSifFileSize);
        RtlMoveMemory(SetupldrWinntSifFile,setupLoaderBlock->WinntSifFile,SetupldrWinntSifFileSize);

        Status = SpLoadSetupTextFile(NULL,
                    SetupldrWinntSifFile,
                    SetupldrWinntSifFileSize,
                    &WinntSifHandle,
                    &ErrorLine,
                    FALSE,
                    TRUE);

        if (NT_SUCCESS(Status)) {
            PWSTR NtUpgradeValue = SpGetSectionKeyIndex(WinntSifHandle,
                                        SIF_DATA, WINNT_D_NTUPGRADE_W, 0);

            if(NtUpgradeValue && !_wcsicmp(NtUpgradeValue, WINNT_A_YES_W)) {
                SP_SET_UPGRADE_GRAPHICS_MODE(TRUE);
                IsNTUpgrade = UpgradeFull;
            } else {
                PWSTR Win9xUpgradeValue = SpGetSectionKeyIndex(WinntSifHandle,
                                            SIF_DATA, WINNT_D_WIN95UPGRADE_W, 0);

                if (Win9xUpgradeValue && !_wcsicmp(Win9xUpgradeValue, WINNT_A_YES_W)) {
                    SP_SET_UPGRADE_GRAPHICS_MODE(TRUE);
                }
            }
        } else {
            WinntSifHandle = NULL;
        }
    } else {
        SetupldrWinntSifFile = NULL;
    }

#ifdef _GRAPHICS_TESTING_

    SP_SET_UPGRADE_GRAPHICS_MODE(TRUE);

#endif

    //
    // Make a copy of the image of the asrpnp.sif file.
    //
    SetupldrASRPnPSifFileSize = setupLoaderBlock->ASRPnPSifFileLength;
    if (SetupldrASRPnPSifFileSize != 0) {
        SetupldrASRPnPSifFile = SpMemAlloc(SetupldrASRPnPSifFileSize);
        RtlMoveMemory(SetupldrASRPnPSifFile,setupLoaderBlock->ASRPnPSifFile,SetupldrASRPnPSifFileSize);
        //
        // If user provided asrpnp.sif, he wants ASR.
        //
        SpAsrSetAsrMode(ASRMODE_NORMAL);
        RepairWinnt = FALSE;
    } else {
        SetupldrASRPnPSifFile = NULL;
        //
        // user didn't provide asrpnp.sif, he doesn't want ASR.
        //
        SpAsrSetAsrMode(ASRMODE_NONE);
    }

    //
    // Make a copy of the image of the migrate.inf file.
    //
    SetupldrMigrateInfFileSize = setupLoaderBlock->MigrateInfFileLength;
    if ( SetupldrMigrateInfFileSize != 0 ) {
        SetupldrMigrateInfFile = SpMemAlloc(SetupldrMigrateInfFileSize);
        RtlMoveMemory(SetupldrMigrateInfFile,setupLoaderBlock->MigrateInfFile,SetupldrMigrateInfFileSize);
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: migrate.inf was loaded. Address = %lx, size = %d \n", SetupldrMigrateInfFile, SetupldrMigrateInfFileSize));
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Couldn't load migrate.inf \n"));
        SetupldrMigrateInfFile = NULL;
    }

    //
    // NEC98 need to decide drive assign method right away(before IoAssignDriveLetters())..
    //
    // NEC98 has 2 kind of drive mapping method.
    // One is NEC98 legacy style assign that mapping hard drive begining from A:,
    // other is same as PC/AT.
    //
    if (IsNEC_98) { //NEC98
        //
        // If no winnt.sif present, we don't need to check hive.
        //
        if ( SetupldrWinntSifFileSize != 0 ) {
            SpCheckHiveDriveLetters();
        }
    } //NEC98

    if ((SetupldrWinntSifFileSize != 0) || (SetupldrASRPnPSifFileSize != 0)) {
        SpMigrateDeviceInstanceData();
    }

    //
    // Make a copy of the image of the unsupdrv.inf file.
    //
    SetupldrUnsupDrvInfFileSize = setupLoaderBlock->UnsupDriversInfFileLength;
    if ( SetupldrUnsupDrvInfFileSize != 0 ) {
        SetupldrUnsupDrvInfFile = SpMemAlloc(SetupldrUnsupDrvInfFileSize);
        RtlMoveMemory(SetupldrUnsupDrvInfFile,setupLoaderBlock->UnsupDriversInfFile,SetupldrUnsupDrvInfFileSize);
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: driver.inf was loaded. Address = %lx, size = %d \n", SetupldrUnsupDrvInfFile, SetupldrUnsupDrvInfFileSize));
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Couldn't load unsupdrv.inf \n"));
        SetupldrUnsupDrvInfFile = NULL;
    }


    //
    // Make a copy of the scalar portions of the setup loader block.
    //
    SetupParameters = setupLoaderBlock->ScalarValues;

    //
    // Save away remote boot information.
    //
    if (RemoteBootSetup) {
#if defined(REMOTE_BOOT)
        memcpy(NetBootHalName, setupLoaderBlock->NetBootHalName, sizeof(NetBootHalName));
#endif // defined(REMOTE_BOOT)
        if (setupLoaderBlock->NetBootSifPath) {
            NetBootSifPath = SpToUnicode(setupLoaderBlock->NetBootSifPath);
        }
    }

    //
    //  Find out if the machine is dockable
    //  Note that at this point we could remove dmio.sys, dmboot.sys and dmload.sys from our lists
    //  if we determine that the this is a dockable machine. In this way, dynamic volumes would be
    //  disable during textmode setup. This should be done in the future.
    //
    SpCheckForDockableMachine();

    //
    // Remember migrated boot drivers
    //
    InitializeListHead (&MigratedDriversList);
    SpRememberMigratedDrivers(&MigratedDriversList, setupLoaderBlock->ScsiDevices);
    //
    // Save away the hardware information passed to us by setupldr.
    //
    HardwareComponents[HwComponentDisplay] = SpSetupldrHwToHwDevice(&setupLoaderBlock->VideoDevice);
    HardwareComponents[HwComponentKeyboard] = SpSetupldrHwToHwDevice(setupLoaderBlock->KeyboardDevices);
    HardwareComponents[HwComponentComputer] = SpSetupldrHwToHwDevice(&setupLoaderBlock->ComputerDevice);
    ScsiHardware = SpSetupldrHwToHwDevice(setupLoaderBlock->ScsiDevices);
    BootBusExtenders = SpSetupldrHwToHwDevice(setupLoaderBlock->BootBusExtenders);
    BusExtenders = SpSetupldrHwToHwDevice(setupLoaderBlock->BusExtenders);
    InputDevicesSupport = SpSetupldrHwToHwDevice(setupLoaderBlock->InputDevicesSupport);

    //
    // For each driver loaded by setupldr, we need to go create a service list entry
    // for that driver in the registry.
    //
    for( nextEntry = loaderBlock->BootDriverListHead.Flink;
         nextEntry != &loaderBlock->BootDriverListHead;
         nextEntry = nextEntry->Flink)
    {
        bootDriver = CONTAINING_RECORD(nextEntry,BOOT_DRIVER_LIST_ENTRY,Link);

        //
        // Get the image path.
        //
        imagePath = SpMemAlloc(bootDriver->FilePath.Length + sizeof(WCHAR));

        wcsncpy(
            imagePath,
            bootDriver->FilePath.Buffer,
            bootDriver->FilePath.Length / sizeof(WCHAR)
            );

        imagePath[bootDriver->FilePath.Length / sizeof(WCHAR)] = 0;

        //
        // If provided, get the registry path, otherwise it will
        // be created by SpCreateServiceEntry.
        //
        if (bootDriver->RegistryPath.Length > 0) {
            registryPath = SpMemAlloc(bootDriver->RegistryPath.Length + sizeof(WCHAR));

            wcsncpy(
                registryPath,
                bootDriver->RegistryPath.Buffer,
                bootDriver->RegistryPath.Length / sizeof(WCHAR)
                );

            registryPath[bootDriver->RegistryPath.Length / sizeof(WCHAR)] = 0;

            ServiceName = registryPath;
        } else {
            registryPath = NULL;
            ServiceName = NULL;
        }

        Status = SpCreateServiceEntry(imagePath,&ServiceName);

        //
        // If this operation fails, nothing to do about it here. If we did
        // not provide the registry path, then save the returned one.
        //
        if(NT_SUCCESS(Status)) {
            if (bootDriver->RegistryPath.Length == 0) {
                bootDriver->RegistryPath.MaximumLength =
                bootDriver->RegistryPath.Length = wcslen(ServiceName)*sizeof(WCHAR);
                bootDriver->RegistryPath.Buffer = ServiceName;
            }
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: warning: unable to create service entry for %ws (%lx)\n",imagePath,Status));
        }

        SpMemFree(imagePath);
        if (registryPath) {
            SpMemFree(registryPath);
        }
    }


    if (NT_SUCCESS(Status)) {
        //
        // Create the virtual floppy (RAM driver) parameter entries
        // 
        // NOTE: We ignore the error here since we can't do much here
        // other than bug check the machine. The error
        // will be handled properly while copying the files
        // from the non existent OEM source devices
        //
        SpInitVirtualOemDevices(setupLoaderBlock, &VirtualOemSourceDevices);
    }                    
    
    //
    // Create the thirdy party OEM SCSI driver entries
    //
    SpCreateDriverRegistryEntries(ScsiHardware);

#ifdef FULL_DOUBLE_SPACE_SUPPORT
    if(NT_SUCCESS(Status)) {

        OBJECT_ATTRIBUTES Obja;
        UNICODE_STRING UnicodeString;
        HANDLE hKey;
        ULONG val = 1;

        //
        // Make sure we are automounting DoubleSpace
        //

        INIT_OBJA(
            &Obja,
            &UnicodeString,
            L"\\registry\\machine\\system\\currentcontrolset\\control\\doublespace"
            );

        Status = ZwCreateKey(
                    &hKey,
                    KEY_ALL_ACCESS,
                    &Obja,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    NULL
                    );

        if(NT_SUCCESS(Status)) {
            RtlInitUnicodeString(&UnicodeString,L"AutomountRemovable");
            Status = ZwSetValueKey(hKey,&UnicodeString,0,REG_DWORD,&val,sizeof(ULONG));
            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: init0: unable to create DoubleSpace automount value (%lx)\n",Status));
            }
            ZwClose(hKey);
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: init0: unable to create DoubleSpace key (%lx)\n",Status));
        }
    }
#endif

    //
    // Save arc disk info
    //
    if(NT_SUCCESS(Status)) {

        PARC_DISK_INFORMATION ArcInformation;
        PARC_DISK_SIGNATURE DiskInfo;
        PLIST_ENTRY ListEntry;
        PDISK_SIGNATURE_INFORMATION myInfo,prev;

        ArcInformation = loaderBlock->ArcDiskInformation;
        ListEntry = ArcInformation->DiskSignatures.Flink;

        prev = NULL;

        while(ListEntry != &ArcInformation->DiskSignatures) {

            DiskInfo = CONTAINING_RECORD(ListEntry,ARC_DISK_SIGNATURE,ListEntry);

            myInfo = SpMemAlloc(sizeof(DISK_SIGNATURE_INFORMATION));

            myInfo->Signature = DiskInfo->Signature;
            myInfo->ArcPath = SpToUnicode(DiskInfo->ArcName);
            myInfo->CheckSum = DiskInfo->CheckSum;
            myInfo->ValidPartitionTable = DiskInfo->ValidPartitionTable;
            myInfo->xInt13 = DiskInfo->xInt13;
            myInfo->Next = NULL;

            if(prev) {
                prev->Next = myInfo;
            } else {
                DiskSignatureInformation = myInfo;
            }
            prev = myInfo;

            ListEntry = ListEntry->Flink;
        }
    }
    //
    //  Create the registry keys listed in migrate.inf.
    //
    if(NT_SUCCESS(Status)) {
        if ( SetupldrMigrateInfFile != NULL ) {
            ULONG   ErrorLine;

            Status = SpLoadSetupTextFile(
                        NULL,
                        SetupldrMigrateInfFile,
                        SetupldrMigrateInfFileSize,
                        &WinntMigrateInfHandle,
                        &ErrorLine,
                        FALSE,
                        TRUE
                        );
            if( NT_SUCCESS(Status) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpLoadSetupTextFile( migrate.inf ) succeeded.\n"));
                Status = SpProcessMigrateInfFile( WinntMigrateInfHandle );
                if( !NT_SUCCESS(Status) ) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Failed to process migrate.inf. Status = %lx\n",Status));
                }
#ifdef _X86_
                //
                // Delete drive letter information from registry that
                // translated from migrate.inf.
                //
                if( IsNEC_98 ) {
                    if( NT_SUCCESS(Status) ) {
                        SpDeleteDriveLetterFromNTFTNec98();
                    }
                }
#endif //NEC98
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpLoadSetupTextFile( migrate.inf ) failed. Status = %lx\n",Status));
            }
        }

        if ( (NT_SUCCESS(Status)) && (SetupldrUnsupDrvInfFile != NULL) ) {
            ULONG   ErrorLine;

            Status = SpLoadSetupTextFile(
                        NULL,
                        SetupldrUnsupDrvInfFile,
                        SetupldrUnsupDrvInfFileSize,
                        &WinntUnsupDrvInfHandle,
                        &ErrorLine,
                        FALSE,
                        TRUE
                        );
            if( NT_SUCCESS(Status) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpLoadSetupTextFile( driver.inf ) succeeded.\n"));

                Status = SpProcessUnsupDrvInfFile( WinntUnsupDrvInfHandle );
                if( !NT_SUCCESS(Status) ) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to process driver.inf. Status = %lx\n",Status));
                }
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpLoadSetupTextFile( driver.inf ) failed. Status = %lx\n",Status));
            }
        }
    }

    SetupHardwareIdDatabase = SpSetupldrPnpDatabaseToSetupPnpDatabase( setupLoaderBlock->HardwareIdDatabase );

    if(NT_SUCCESS(Status)) {
        //
        //  Initialize keyboard Guid string
        //
        Status = RtlStringFromGUID( &GUID_DEVCLASS_KEYBOARD, &GuidString );
        if( NT_SUCCESS( Status ) ) {
            KeyboardGuidString = SpDupStringW( GuidString.Buffer );
            if( KeyboardGuidString == NULL ) {
                Status = STATUS_NO_MEMORY;
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: cannot create a GUID string for keyboard device. Status = %lx \n", Status ));
            }
            RtlFreeUnicodeString( &GuidString );
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: cannot create a GUID string for keyboard device. Status = %lx \n", Status ));
        }
    }
    if(NT_SUCCESS(Status)) {
        //
        //  Initialize mouse Guid strings
        //
        Status = RtlStringFromGUID( &GUID_DEVCLASS_MOUSE, &GuidString );
        if( NT_SUCCESS( Status ) ) {
            MouseGuidString = SpDupStringW( GuidString.Buffer );
            if( MouseGuidString == NULL ) {
                Status = STATUS_NO_MEMORY;
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: cannot create a GUID string for mouse device. Status = %lx \n", Status ));
            }
            RtlFreeUnicodeString( &GuidString );
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: cannot create a GUID string for mouse device. Status = %lx \n", Status ));
        }
    }

    if(NT_SUCCESS(Status)) {
        //
        //  Register for Plug & Play notification
        //
        Status = IoRegisterPlugPlayNotification ( EventCategoryReserved,
                                                  0,
                                                  NULL,
                                                  DriverObject,
                                                  SpPnPNotificationCallBack,
                                                  SetupHardwareIdDatabase,
                                                  &NotificationEntry );
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: init0: unable to register for PnP notification (%lx)\n",Status));
        }

        //
        // Register for reinitialization.
        //
        if(NT_SUCCESS(Status)) {
            IoRegisterDriverReinitialization(DriverObject,SpInitialize0a,loaderBlock);
        }
    }

    return(Status);
}


VOID
SpInitialize0a(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID          Context,
    IN ULONG          ReferenceCount
    )
{
    PLOADER_PARAMETER_BLOCK LoaderBlock;
    PLIST_ENTRY nextEntry;
    PBOOT_DRIVER_LIST_ENTRY bootDriver;
    PKLDR_DATA_TABLE_ENTRY driverEntry;
    PHARDWARE_COMPONENT pHw,pHwPrev,pHwTemp;
    BOOLEAN ReallyLoaded;
    PUNICODE_STRING name;

    ULONG   i;
    PHARDWARE_COMPONENT* HwArray[] = {
                                     &ScsiHardware,
                                     &BootBusExtenders,
                                     &BusExtenders,
                                     &InputDevicesSupport,
                                     };


    UNREFERENCED_PARAMETER(DriverObject);
    UNREFERENCED_PARAMETER(ReferenceCount);

    //
    // Context points to the os loader block.
    //
    LoaderBlock = Context;

    //
    //  Find out if the machine is dockable.
    //  We do this once more because some machines may not have provided this info in the first
    //  time we attempted to retrieve this information.
    //
    SpCheckForDockableMachine();

    //
    // Iterate all scsi hardware and bus enumerators we think we detected
    // and make sure the driver really initialized.
    //
    for( i = 0; i < sizeof(HwArray)/sizeof(PHARDWARE_COMPONENT*); i++ ) {
        pHwPrev = NULL;
        for(pHw=*(HwArray[i]); pHw; ) {

            //
            // Assume not really loaded.
            //
            ReallyLoaded = FALSE;

            //
            // Scan the boot driver list for this driver's entry.
            //
            nextEntry = LoaderBlock->BootDriverListHead.Flink;
            while(nextEntry != &LoaderBlock->BootDriverListHead) {

                bootDriver = CONTAINING_RECORD( nextEntry,
                                                BOOT_DRIVER_LIST_ENTRY,
                                                Link );

                driverEntry = bootDriver->LdrEntry;
                name = &driverEntry->BaseDllName;

                if(!_wcsnicmp(name->Buffer,pHw->BaseDllName,name->Length/sizeof(WCHAR))) {

                    //
                    // This is the driver entry we need.
                    //
                    if(!(driverEntry->Flags & LDRP_FAILED_BUILTIN_LOAD)
                      ) {
                        ReallyLoaded = TRUE;
                    }

                    break;
                }

                nextEntry = nextEntry->Flink;
            }

            //
            // If the driver didn't initialize properly,
            // then it's not really loaded.
            //
            if(ReallyLoaded) {
                if( !pHw->MigratedDriver ) {
                    //
                    // not a migrated driver, continue on
                    // processing with the next node
                    //
                    pHwPrev = pHw;
                    pHw = pHw->Next;
                } else {
                    //
                    // Migrated driver, remove & free the
                    // node from the linked list
                    //
                    pHwTemp = pHw->Next;

                    if(pHwPrev) {
                        pHwPrev->Next = pHwTemp;
                    } else {
                        *(HwArray[i]) = pHwTemp;
                    }
                    SpFreeHwComponent(&pHw,FALSE);
                    pHw = pHwTemp;
                }
            } else {
                //
                // Remove and free the node or link it to unsupported driver
                // list if its a migrated driver
                //
                pHwTemp = pHw->Next;

                if(pHwPrev) {
                    pHwPrev->Next = pHwTemp;
                } else {
                    *(HwArray[i]) = pHwTemp;
                }

                if( ( HwArray[i] == &ScsiHardware ) && ( pHw->MigratedDriver ) ) {
                    //
                    //  If this is an unsupported migrated driver that failed to initialize, then
                    //  remember it so that we can disable it later on. This can happen if the
                    //  system contains a driver that controls the unsupported device, but winnt32
                    //  winnt32 couldn't figure it out.
                    //
                    pHw->Next = UnsupportedScsiHardwareToDisable;
                    UnsupportedScsiHardwareToDisable = pHw;
                } else {
                    SpFreeHwComponent(&pHw,FALSE);
                }

                pHw = pHwTemp;
            }
        }
    }

    //
    //  Find the pcmcia and atapi drivers and make sure these drivers really
    //  initialized
    //

    //
    // Assume not really loaded.
    //
    PcmciaLoaded = FALSE;
    AtapiLoaded  = FALSE;

    //
    // Scan the boot driver list for this driver's entry.
    //
    nextEntry = LoaderBlock->BootDriverListHead.Flink;
    while(nextEntry != &LoaderBlock->BootDriverListHead) {

        bootDriver = CONTAINING_RECORD( nextEntry,
                                        BOOT_DRIVER_LIST_ENTRY,
                                        Link );

        driverEntry = bootDriver->LdrEntry;
        name = &driverEntry->BaseDllName;

        if(!_wcsnicmp(name->Buffer,L"pcmcia.sys",name->Length/sizeof(WCHAR))) {

            //
            // This is the driver entry we need.
            //
            if(!(driverEntry->Flags & LDRP_FAILED_BUILTIN_LOAD)) {
                PcmciaLoaded = TRUE;
            }
        } else if(!_wcsnicmp(name->Buffer,L"atapi.sys",name->Length/sizeof(WCHAR))) {

            //
            // This is the driver entry we need.
            //
            if(!(driverEntry->Flags & LDRP_FAILED_BUILTIN_LOAD)) {
                AtapiLoaded = TRUE;
            }
        }

        nextEntry = nextEntry->Flink;
    }

}


VOID
SpInitialize1(
    VOID
    )
{
    ASSERT(!GeneralInitialized);

    if(GeneralInitialized) {
        return;
    }

    SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),SP_MNEMONICS);

    MnemonicValues = SpMemAlloc((wcslen(TemporaryBuffer)+1)*sizeof(WCHAR));

    wcscpy(MnemonicValues,TemporaryBuffer);

    GeneralInitialized = TRUE;
}


VOID
SpTerminate(
    VOID
    )
{
    ASSERT(GeneralInitialized);

    if(GeneralInitialized) {
        if(MnemonicValues) {
            SpMemFree(MnemonicValues);
            MnemonicValues = NULL;
        }
        GeneralInitialized = FALSE;
    }
}


VOID
SpInvalidSystemPartition(
    VOID
    )

/*++

Routine Description:

    Display a screen telling the user that we think his system
    partition is invalid.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG EvaluationInstallKeys[] = { KEY_F3, ASCI_CR };

    SpDisplayScreen(SP_SCRN_SYSTEMPARTITION_INVALID, 3, 4 );

    SpDisplayStatusOptions(
        DEFAULT_STATUS_ATTRIBUTE,
        SP_STAT_ENTER_EQUALS_CONTINUE,
        SP_STAT_F3_EQUALS_EXIT,
        0
        );

    //
    // Wait for keypress.  Valid keys:
    //
    // ENTER = continue
    //

    SpInputDrain();

    switch(SpWaitValidKey(EvaluationInstallKeys,NULL,NULL)) {

        //
        // User wants to continue.
        //
        case ASCI_CR:
            break;

        //
        // User wants to exit.
        //
        case KEY_F3:
            SpConfirmExit();
            break;
    }
}


VOID
SpNotifyEvaluationInstall(
    VOID
    )

/*++

Routine Description:

    Display a screen telling the user we're about to install a demo
    version.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG EvaluationInstallKeys[] = { KEY_F3, ASCI_CR };

    SpDisplayScreen(SP_SCRN_EVALUATION_NOTIFY, 3, 4 );

    SpDisplayStatusOptions(
        DEFAULT_STATUS_ATTRIBUTE,
        SP_STAT_ENTER_EQUALS_CONTINUE,
        SP_STAT_F3_EQUALS_EXIT,
        0
        );

    //
    // Wait for keypress.  Valid keys:
    //
    // ENTER = continue
    //

    SpInputDrain();

    switch(SpWaitValidKey(EvaluationInstallKeys,NULL,NULL)) {

        //
        // User wants to continue.
        //
        case ASCI_CR:
            break;

        //
        // User wants to exit.
        //
        case KEY_F3:
            SpConfirmExit();
            break;
    }


}





VOID
SpWelcomeScreen(
    VOID
    )

/*++

Routine Description:

    Display a screen welcoming the user and allow him to choose among
    some options (help, exit, aux. menu, continue, repair).

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG WelcomeKeys[] = { KEY_F3, ASCI_CR, ASCI_ESC, KEY_F10, 0 };
    ULONG MnemonicKeys[] = { MnemonicRepair, 0 };
    BOOLEAN Welcoming;

    //
    // Welcome the user.
    //
    for(Welcoming = TRUE; Welcoming; ) {

        if (SpIsERDisabled()) {
            SpDisplayScreen(SP_SCRN_WELCOME_1, 3, 4);

            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_ENTER_EQUALS_CONTINUE,
                SP_STAT_R_EQUALS_REPAIR,
                SP_STAT_F3_EQUALS_EXIT,
                0
                );
        } else {
            SpDisplayScreen(SP_SCRN_WELCOME,3,4);

            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_ENTER_EQUALS_CONTINUE,
                SP_STAT_R_EQUALS_REPAIR,
                SP_STAT_F3_EQUALS_EXIT,
                0
                );

        }

        //
        // Wait for keypress.  Valid keys:
        //
        // F1 = help
        // F3 = exit
        // ENTER = continue
        // R = Repair Winnt
        // ESC = auxillary menu.
        //

        SpInputDrain();

        switch(SpWaitValidKey(WelcomeKeys,NULL,MnemonicKeys)) {

        case ASCI_ESC:

            //
            // User wants auxillary menu.
            //
            break;

        case ASCI_CR:

            //
            // User wants to continue.
            //
            RepairWinnt = FALSE;
            Welcoming = FALSE;
            break;


        case KEY_F3:

            //
            // User wants to exit.
            //
            SpConfirmExit();
            break;

        case KEY_F10:
            Welcoming = FALSE;
            ForceConsole = TRUE;
            break;

        default:

            //
            // Must be repair mnemonic
            //
            SpAsrSetAsrMode(ASRMODE_NORMAL);
            RepairWinnt = TRUE;
            Welcoming = FALSE;
            break;
        }
    }
}


VOID
SpDisplayEula (
    IN HANDLE       MasterSifHandle,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice
    )

/*++

Routine Description:

    Display the End User Licensing Agreement.

Arguments:

    MasterSifHandle - Handle to txtsetup.sif.

    SetupSourceDevicePath - Path to the device that contains the source media.

    DirectoryOnSourceDevice - Directory on the media where EULA is located.

Return Value:

    None.  Does not return if user does not accept licensing agreement or if
    the licensing agreement cannot be opened.

--*/

{
    PWSTR       MediaShortName;
    PWSTR       MediaDirectory;
    PWSTR       EulaPath;
    NTSTATUS    Status;
    PVOID       BaseAddress;
    ULONG       FileSize;
    HANDLE      hFile, hSection;
    ULONG       ValidKeys[2] = { KEY_F3,0 };
    PWSTR       Eula;
    ULONG       EulaSize;
    PWSTR       p;

    if (PreInstall) {
        return;
    }

    //
    // Winnt32 displays the EULA now so we might be able to skip it
    //
    p = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,WINNT_D_EULADONE_W,0);
    if(p && SpStringToLong(p,NULL,10)) {
       return;
    }

    //
    // Figure out the path to eula.txt
    //
    MediaShortName = SpLookUpValueForFile(
        MasterSifHandle,
        L"eula.txt",
        INDEX_WHICHMEDIA,
        TRUE
        );
    SpPromptForSetupMedia(
        MasterSifHandle,
        MediaShortName,
        SetupSourceDevicePath
        );


    if (UnattendedOperation && CustomSetup) {
        return;
    }


    SpGetSourceMediaInfo(
        MasterSifHandle,MediaShortName,NULL,NULL,&MediaDirectory);

    wcscpy( TemporaryBuffer, SetupSourceDevicePath );
    SpConcatenatePaths( TemporaryBuffer, DirectoryOnSourceDevice );
    SpConcatenatePaths( TemporaryBuffer, MediaDirectory );
    SpConcatenatePaths( TemporaryBuffer, L"eula.txt" );
    EulaPath = SpDupStringW( TemporaryBuffer );

    //
    // Open and map the file for read access.
    //
    hFile = 0;  // use EulaPath instead
    Status = SpOpenAndMapFile(
        EulaPath,
        &hFile,
        &hSection,
        &BaseAddress,
        &FileSize,
        FALSE
        );

    if(!NT_SUCCESS(Status)) {
        //
        // Display a message indicating that there was a fatal error while trying
        // to open the EULA file.
        //
        SpStartScreen(
            SP_SCRN_FATAL_ERROR_EULA_NOT_FOUND,
            3,
            HEADER_HEIGHT+3,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE
            );
        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,
            0);
        SpWaitValidKey(ValidKeys,NULL,NULL);
        SpDone(0,FALSE,TRUE);
    }

    //
    // Convert the text to Unicode.
    //
    Eula = SpMemAlloc ((FileSize+1) * sizeof(WCHAR));
    ASSERT (Eula);

    Status = RtlMultiByteToUnicodeN (
        Eula,
        FileSize * sizeof(WCHAR),
        &EulaSize,
        BaseAddress,
        FileSize
        );
    ASSERT (NT_SUCCESS(Status));
    Eula[EulaSize / sizeof(WCHAR)] = (WCHAR)'\0';

    //
    // Show text to user.
    //
    SpHelp(
        0,
        Eula,
        SPHELP_LICENSETEXT
        );

    //
    // Clean up
    //
    if (UnattendedOperation && !CustomSetup) {
        PWSTR   szOne = L"1";
        //
        // Remember that we displayed it here.
        //
        SpAddLineToSection(WinntSifHandle, SIF_DATA, WINNT_D_EULADONE_W, &szOne, 1);
    }

    SpMemFree (EulaPath);
    SpMemFree (Eula);
    SpUnmapFile(hSection,BaseAddress);
    ZwClose(hFile);

}



VOID
SpCustomExpressScreen(
    VOID
    )

/*++

Routine Description:

    Allow the user to choose between custom and express setup.

    The global variable CustomSetup is set according to the user's choice.

    NOTE : This feature is only available for headless installs

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG ValidKeys[] = { ASCI_CR, KEY_F3, 0 };
    ULONG MnemonicKeys[] = { MnemonicCustom, 0 };
    BOOLEAN Choosing;
    ULONG c;

    //
    // See whether this parameter is specified for unattended operation.
    //
    if(UnattendedOperation) {

        PWSTR p = SpGetSectionKeyIndex(UnattendedSifHandle,
            SIF_UNATTENDED,WINNT_U_METHOD_W,0);
        PWSTR q = SpGetSectionKeyIndex(UnattendedSifHandle,
            SIF_UNATTENDED,WINNT_U_OVERWRITEOEM_W,0);

        if( q && !_wcsicmp( q, L"no" ) ) {
            UnattendedOverwriteOem = FALSE;
        } else {
            UnattendedOverwriteOem = TRUE;
        }

        //
        // Default is custom. If user specified something
        // else then use express.
        //
        if(p && _wcsicmp(p,L"custom")) {
            CustomSetup = FALSE;
        }
        return;
    }


    //
    // Don't do this if they ran from winnt/winnt32
    // or headless terminal was not connected
    //
    if( WinntSetup || !HeadlessTerminalConnected) {
        return;
    }


    for(Choosing = TRUE; Choosing; ) {

        SpDisplayScreen(SP_SCRN_CUSTOM_EXPRESS,3,4);

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_EXPRESS,
            SP_STAT_C_EQUALS_CUSTOM,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        //
        // Wait for keypress.  Valid keys:
        //
        // ENTER = express setup
        // <MnemonicCustom> = custom setup
        //

        SpInputDrain();

        switch(c=SpWaitValidKey(ValidKeys,NULL,MnemonicKeys)) {

        case ASCI_CR:

            //
            // User wants express setup.
            //
            CustomSetup = FALSE;
            Choosing = FALSE;
            break;


        case (MnemonicCustom | KEY_MNEMONIC):
            CustomSetup = TRUE;
            Choosing = FALSE;
            break;

        case KEY_F3:
            SpDone(0, FALSE, TRUE);
            break;

        default:
            break;
        }
    }

}


PVOID
SpLoadSetupInformationFile(
    VOID
    )
{
    NTSTATUS Status;
    ULONG ErrLine;
    PVOID SifHandle;

    CLEAR_CLIENT_SCREEN();

    //
    // The image of txtsetup.sif has been passed to us
    // by setupldr.
    //
    Status = SpLoadSetupTextFile(
                NULL,
                SetupldrInfoFile,
                SetupldrInfoFileSize,
                &SifHandle,
                &ErrLine,
                TRUE,
                FALSE
                );

    //
    // We're done with the image.
    //
    SpMemFree(SetupldrInfoFile);
    SetupldrInfoFile = NULL;
    SetupldrInfoFileSize = 0;

    if(NT_SUCCESS(Status)) {
        return(SifHandle);
    }

    //
    // The file was already parsed once by setupldr.
    // If we can't do it here, there's a serious problem.
    // Assume it was a syntax error, because we didn't
    // have to load it from disk.
    //
    SpStartScreen(
        SP_SCRN_SIF_PROCESS_ERROR,
        3,
        HEADER_HEIGHT+1,
        FALSE,
        FALSE,
        DEFAULT_ATTRIBUTE,
        ErrLine
        );

    //
    // Since we haven't yet loaded the keyboard layout, we can't prompt the
    // user to press F3 to exit
    //
    SpDisplayStatusText(SP_STAT_KBD_HARD_REBOOT, DEFAULT_STATUS_ATTRIBUTE);

    while(TRUE);    // Loop forever
}


VOID
SpIsWinntOrUnattended(
    IN PVOID        SifHandle
    )
{
    PWSTR       szZero  = L"0";
    PWSTR       szOne   = L"1";
    NTSTATUS    Status;
    ULONG       ErrorLine;
    PWSTR       p;
    WCHAR       DiskDevicePath[MAX_PATH];
    ULONG       i;
    PWSTR       Architecture;

    //
    // Attempt to load winnt.sif. If the user is in the middle of
    // a winnt setup, this file will be present.
    //
    if ( SetupldrWinntSifFile != NULL ) {
        Status = SpLoadSetupTextFile(
                    NULL,
                    SetupldrWinntSifFile,
                    SetupldrWinntSifFileSize,
                    &WinntSifHandle,
                    &ErrorLine,
                    TRUE,
                    FALSE
                    );
    } else {

        //
        // There's no winnt.sif handle, so this is probably an el-torito
        // boot.  If that's true, *and* the user chose to do an express
        // setup, then use the on-CD unattend file.
        //
        if( !CustomSetup ) {

            //
            // The only way we should ever get here is if we went to
            // the custom/express screen and the user chose express, which
            // means this is the second time through this function (we had
            // to call this fuction again to re-initialize our variables
            // using the on-CD unattend file.
            //


            //
            // Use this for testing purposes.  Check for floppy0\unattend.txt
            // before getting the file off the CDROM.
            //
            wcscpy( DiskDevicePath, L"\\device\\floppy0\\unattend.txt" );
            Status = SpLoadSetupTextFile( DiskDevicePath,
                                          NULL,
                                          0,
                                          &WinntSifHandle,
                                          &ErrorLine,
                                          TRUE,
                                          FALSE );

            if( !NT_SUCCESS(Status) ) {


                Status = STATUS_OBJECT_NAME_NOT_FOUND;
                i = 0;
                Architecture = SpGetSectionKeyIndex( SifHandle,
                                                     SIF_SETUPDATA,
                                                     L"Architecture",
                                                     0 );
    
                if( Architecture == NULL ) {
#if defined(_AMD64_)
                    Architecture = L"amd64";
#elif defined(_X86_)
                    Architecture = L"x86";
#elif defined(_IA64_)
                    Architecture = L"ia64";
#else
#error "No Target Architcture"
#endif
                }
    
                while( (i < IoGetConfigurationInformation()->CdRomCount) && (!NT_SUCCESS(Status)) ) {
    
                    swprintf( DiskDevicePath, L"\\device\\cdrom%u", i);
                    SpConcatenatePaths( DiskDevicePath, Architecture );
                    SpConcatenatePaths( DiskDevicePath, L"\\unattend.txt" );
    
                    Status = SpLoadSetupTextFile( DiskDevicePath,
                                                  NULL,
                                                  0,
                                                  &WinntSifHandle,
                                                  &ErrorLine,
                                                  TRUE,
                                                  FALSE );
                    i++;
                }

            }



            if( NT_SUCCESS(Status) ) {
                //
                // Add a bunch of defaults which *should* of been there, but
                // were not
                SpAddLineToSection(WinntSifHandle,SIF_DATA,
                    WINNT_D_MSDOS_W,&szZero,1);
                SpAddLineToSection(WinntSifHandle,SIF_DATA,
                    WINNT_D_FLOPPY_W,&szZero,1);
                SpAddLineToSection(WinntSifHandle,SIF_SETUPPARAMS,
                    WINNT_S_SKIPMISSING_W,&szOne,1);
                SpAddLineToSection(WinntSifHandle,SIF_DATA,
                    WINNT_D_AUTO_PART_W,&szOne,1);

                //
                // Tell the autopartition picker to do his job.
                //
                AutoPartitionPicker = TRUE;

            }


        } else {
            //
            // fail.
            //
            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

    if(NT_SUCCESS(Status)) {

        //
        // Check for winnt setup and the case where the user left the
        // files on the CD-ROM.
        //
        p = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,WINNT_D_MSDOS_W,0);
        if(p && SpStringToLong(p,NULL,10)) {

            WinntSetup = TRUE;

            p = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,WINNT_D_LOCALSRC_CD_W,0);
            if(p && SpStringToLong(p,NULL,10)) {
                WinntFromCd = TRUE;
            }
        }

        //
        // Check for the case where the user ran "winnt32 -cmdcons"
        //
        p = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,
            WINNT_D_CMDCONS_W,0);
        if(p && SpStringToLong(p,NULL,10)) {

            ConsoleFromWinnt32 = TRUE;
        }


#ifdef _X86_
        //
        // Check for floppyless boot.
        //
        p = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,
            WINNT_D_FLOPPY_W,0);
        if(p && SpStringToLong(p,NULL,10)) {

            IsFloppylessBoot = TRUE;
        }


        //
        // Check for fake CD.
        //
        p = SpGetSectionKeyIndex (WinntSifHandle, SIF_DATA, WINNT_D_NOLS_W, 0);
        if (p && SpStringToLong (p, NULL, 10)) {

            //
            // get the original source path first
            //
            p = SpGetSectionKeyIndex (WinntSifHandle, SIF_DATA, WINNT_D_ORI_SRCPATH_W, 0);
            if (p) {
                if (p[0] && p[1] == L':') {
                    p += 2;
                }
                wcscpy (TemporaryBuffer, p);
                SpConcatenatePaths (TemporaryBuffer, (!IsNEC_98) ? L"i386" : L"nec98");
                LocalSourceDirectory = SpDupStringW (TemporaryBuffer);
                NoLs = TRUE;
            }
        }
#endif



        //
        // Check for ASR test mode.  This is intended as a way to automate
        // ASR testing.
        //
        p = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,L"AsrMode",0);
        if(p && SpStringToLong(p,NULL,10)) {

            switch (SpStringToLong(p,NULL,10)) {
            case 1:
                SpAsrSetAsrMode(ASRMODE_NORMAL);
                break;

            case 2:
                SpAsrSetAsrMode(ASRMODE_QUICKTEST_TEXT);
                break;

            case 3:
                SpAsrSetAsrMode(ASRMODE_QUICKTEST_FULL);
                break;

            default:
                SpAsrSetAsrMode(ASRMODE_NORMAL);
                break;
            }

            RepairWinnt = FALSE;    // ASR not ER
        }


        //
        // Check for auto Partition picker
        //
        p = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,WINNT_D_AUTO_PART_W,0);
        if(p && SpStringToLong(p,NULL,10)) {
            AutoPartitionPicker = TRUE;
        }

        //
        // Check for a preferred install directory
        //
        p = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,WINNT_D_INSTALLDIR_W,0);
        if (p) {
            PreferredInstallDir = SpDupStringW( p );
        }

        //
        // Check for ignore missing files.
        //
        p = SpGetSectionKeyIndex(WinntSifHandle,SIF_SETUPPARAMS,WINNT_S_SKIPMISSING_W,0);
        if(p && SpStringToLong(p,NULL,10)) {
            SkipMissingFiles = TRUE;
        }

        //
        // Check for hide windir
        //
        p = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,L"HideWinDir",0);
        if(p && SpStringToLong(p,NULL,10)) {
            HideWinDir = TRUE;
        }

        //
        // Check for accessibility options
        //
        AccessibleSetup = SpNonZeroValuesInSection(WinntSifHandle, SIF_ACCESSIBILITY, 0);

        //
        // Now check for an unattended setup.
        //
        if(SpSearchTextFileSection(WinntSifHandle,SIF_UNATTENDED)) {

            //
            // Run in unattended mode. Leave the sif open
            // and save away its handle for later use.
            //
            UnattendedSifHandle = WinntSifHandle;
            UnattendedOperation = TRUE;

        } else if(SpSearchTextFileSection(WinntSifHandle,SIF_GUI_UNATTENDED)) {

            //
            // Leave UnattendedOperation to FALSE (because it mainly uses to
            // control text mode setup.)  Store the handle of winnt.sif for later
            // reference.
            //

            UnattendedGuiOperation = TRUE;
        }

        if(UnattendedOperation) {
            PWSTR   TempStr = NULL;

            //
            //  If this is an unattended operation, find out if this is
            //  also an OEM pre-install
            //
            p = SpGetSectionKeyIndex(UnattendedSifHandle,
                                     SIF_UNATTENDED,
                                     WINNT_U_OEMPREINSTALL_W,
                                     0);

            if( p && !_wcsicmp( p, L"yes" ) ) {
                PreInstall = TRUE;
            }


            //
            // Find out if no wait has been specified or not.
            // Default is always false, in unattended case
            //
            UnattendWaitForReboot = FALSE;

            TempStr = SpGetSectionKeyIndex(UnattendedSifHandle,
                            SIF_UNATTENDED,
                            WINNT_U_WAITFORREBOOT_W,
                            0);


            if (TempStr && !_wcsicmp(TempStr, L"yes")) {
                UnattendWaitForReboot = TRUE;
            }


            //
            // See if we're upgrading.
            //
            p = SpGetSectionKeyIndex(UnattendedSifHandle,
                                     SIF_DATA,
                                     WINNT_D_NTUPGRADE_W, 
                                     0);
            if( p && !_wcsicmp( p, L"yes" ) ) {

                NTUpgrade = UpgradeFull;
            }

        }

    } else {
        // Case where there isn't an WINNT.SIF file to be found

        //
        // Create a handle to the new file
        //
        WinntSifHandle = SpNewSetupTextFile();
        //
        // Add a bunch of defaults which *should* of been there, but
        // was not
        SpAddLineToSection(WinntSifHandle,SIF_DATA,
            WINNT_D_MSDOS_W,&szZero,1);
        SpAddLineToSection(WinntSifHandle,SIF_DATA,
            WINNT_D_FLOPPY_W,&szZero,1);
        SpAddLineToSection(WinntSifHandle,SIF_SETUPPARAMS,
            WINNT_S_SKIPMISSING_W,&szZero,1);
    }
}


VOID
SpCheckSufficientMemory(
    IN PVOID SifHandle
    )

/*++

Routine Description:

    Determine whether sufficient memory exists in the system
    for installation to proceed.  The required amount is specified
    in the sif file.

Arguments:

    SifHandle - supplies handle to open setup information file.

Return Value:

    None.

--*/

{
    ULONGLONG RequiredBytes,AvailableBytes, RequiredMBytes, AvailableMBytes;
    PWSTR p;

    p = SpGetSectionKeyIndex(SifHandle,SIF_SETUPDATA,SIF_REQUIREDMEMORY,0);

    if(!p) {
        SpFatalSifError(SifHandle,SIF_SETUPDATA,SIF_REQUIREDMEMORY,0,0);
    }

    RequiredBytes = (ULONGLONG)(ULONG)SpStringToLong(p,NULL,10);

    AvailableBytes = UInt32x32To64(SystemBasicInfo.NumberOfPhysicalPages,SystemBasicInfo.PageSize);

    //
    // Now round to Mbytes for cleanliness...  Include a 4MB slack-factor.
    //
    RequiredMBytes  = ((RequiredBytes + ((4*1024*1024)-1)) >> 22) << 2;
    AvailableMBytes = ((AvailableBytes + ((4*1024*1024)-1)) >> 22) << 2;

    //
    // Allow UMA machines which may reserve 8MB for video memory.
    //
    if(AvailableMBytes < (RequiredMBytes-8)) {

        SpStartScreen(
            SP_SCRN_INSUFFICIENT_MEMORY,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            RequiredMBytes,
            0
            );

        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);

        SpInputDrain();
        while(SpInputGetKeypress() != KEY_F3) ;

        SpDone(0,FALSE,TRUE);
    }
}


PWSTR SetupSourceDevicePath = NULL;
PWSTR DirectoryOnSetupSource = NULL;
PVOID SifHandle;


ULONG
SpStartSetup(
    VOID
    )
{
    PDISK_REGION TargetRegion,SystemPartitionRegion=NULL;
    PDISK_REGION BootRegion; //NEC98
    PWSTR TargetPath=NULL,SystemPartitionDirectory=NULL,OriginalSystemPartitionDirectory=NULL;
    PWSTR DefaultTarget;
    PWSTR OldOsLoadOptions;
    PWSTR FullTargetPath;
#if defined(REMOTE_BOOT)
    PWSTR RemoteBootTarget;
#endif // defined(REMOTE_BOOT)
    BOOLEAN CdInstall = FALSE;
    BOOLEAN b, DeleteTarget=FALSE;
    NTSTATUS Status;
    PVOID NtfsConvert;
    PWSTR ThirdPartySourceDevicePath;
    HANDLE ThreadHandle = NULL;
#ifdef _X86_
    PCWSTR disableCompression;
    PCWSTR enableBackup;
    TCOMP compressionType;
#endif

    //
    // First things first, initialize the upgrade graphics global
    // variables and hook up the upgrade progress indicator
    // for graphics mode, if needed.
    //
    if (SP_IS_UPGRADE_GRAPHICS_MODE()) {
        UpgradeGraphicsInit();
        RegisterSetupProgressCallback(GraphicsModeProgressUpdate, NULL);
    }

    SendSetupProgressEvent(InitializationEvent, InitializationStartEvent, NULL);

    SpInitialize1();
    SpvidInitialize();  // initialize video first, so we can give err msg if keyboard error
    SpInputInitialize();

    if(!SpPatchBootMessages()) {
        SpBugCheck(SETUP_BUGCHECK_BOOTMSGS,0,0,0);
    }

    //
    // Initialize ARC<==>NT name translations.
    //
    SpInitializeArcNames(VirtualOemSourceDevices);

    //
    // Set up the boot device path, which we have stashed away
    // from the os loader block.
    //
    NtBootDevicePath = SpArcToNt(ArcBootDevicePath);
    if(!NtBootDevicePath) {
        SpBugCheck(SETUP_BUGCHECK_BOOTPATH,0,0,0);
    }

    //
    // Initialize dynamic update boot driver root directory path
    //
    DynUpdtBootDriverPath = SpGetDynamicUpdateBootDriverPath(NtBootDevicePath,
                                DirectoryOnBootDevice,
                                WinntSifHandle);

    //
    // For remote install, append RemoteIMirrorBootDirectoryPrefix to
    // NtBootDevicePath so that it matches what C: is linked to.
    // That way DirectoryOnBootDevice will be valid both from kernel
    // and user mode.
    //
    if (RemoteBootSetup) {
        ULONG NewBootDevicePathLen =
            (wcslen(NtBootDevicePath) + wcslen(RemoteIMirrorBootDirectoryPrefix) + 1) * sizeof(WCHAR);
        PWSTR NewBootDevicePath = SpMemAlloc(NewBootDevicePathLen);
        wcscpy(NewBootDevicePath, NtBootDevicePath);
        wcscat(NewBootDevicePath, RemoteIMirrorBootDirectoryPrefix);
        SpMemFree(NtBootDevicePath);
        NtBootDevicePath = NewBootDevicePath;
    }

    // Read SKU data, such as whether we are a product suite or
    // this is an evaluation unit. Fills in SuiteType and
    // EvaluationTime globals.
    //
    SpReadSKUStuff();

    //
    // Reinitialize video -- noop in western builds but switches into DBCS mode,
    // etc, in Far Eastern builds.
    //
    if (NT_SUCCESS(SplangInitializeFontSupport(NtBootDevicePath,
                            DirectoryOnBootDevice,
                            BootFontImage,
                            BootFontImageLength))) {
        SpvidInitialize();  // reinitialize video in alternate mode for Far East
    }


    //
    // Process the txtsetup.sif file, which the boot loader
    // will have loaded for us.
    //
    SifHandle = SpLoadSetupInformationFile();

    SpInputLoadLayoutDll(SifHandle,DirectoryOnBootDevice);

#ifdef PRERELEASE
    //
    // Initialize test hooks to allow testers to inject bug checks at random
    // points in text mode (internal use only)
    //

    {
        PCWSTR data;

        if (WinntSifHandle) {
            data = SpGetSectionKeyIndex (
                        WinntSifHandle,
                        L"TestHooks",
                        L"BugCheckPoint",
                        0
                        );

            if (data) {
                while (*data >= L'0' && *data <= L'9') {
                    g_TestHook = g_TestHook * 10 + (*data - L'0');
                    data++;
                }
            }
        }
    }
#endif

    //
    // Start the upgrade graphics
    //
    if (SP_IS_UPGRADE_GRAPHICS_MODE()) {
        if (!NT_SUCCESS(UpgradeGraphicsStart())) {
            SP_SET_UPGRADE_GRAPHICS_MODE(FALSE);
            CLEAR_ENTIRE_SCREEN();
        }
    }

    //
    // Check for bad BIOS. Does not return if a bad BIOS is found.
    //
    SpCheckForBadBios();

    //
    // Check for sufficient memory. Does not return if not enough.
    //
    SpCheckSufficientMemory(SifHandle);

    //
    // Determine whether this is a winnt/winnt32 setup and/or unattended setup.
    // If unattended, the global variable UnattendedSifHandle will be filled in.
    // If winnt/winnt32, the global variable WinntSetup will be set to TRUE.
    //
    SpIsWinntOrUnattended(SifHandle);

#ifdef _X86_
    //
    // Check if SIF has Rollback flag
    //

    if (SpGetSectionKeyIndex (
                WinntSifHandle,
                SIF_DATA,
                WINNT_D_WIN9X_ROLLBACK_W,
                0
                )) {
        Win9xRollback = TRUE;
    }

#ifdef PRERELEASE
    if (Win9xRollback) {
        g_TestHook -= 1000;     // uninstall test hooks start at 1001
    }
#endif

#endif

    TESTHOOK(1);

    //
    // If this is a remote boot setup, get the path to the target.
    //
    // If TargetNtPartition is not specified in winnt.sif, then this is a
    // remote boot for a remote install, not a remote boot setup.
    //
    if (RemoteBootSetup) {

#if defined(REMOTE_BOOT)

         RemoteBootTarget = SpGetSectionKeyIndex(WinntSifHandle,SIF_SETUPDATA,L"TargetNtPartition",0);
        if (RemoteBootTarget == NULL) {
            RemoteInstallSetup = (BOOLEAN)(!RemoteSysPrepSetup);
        } else {
            RemoteBootTargetRegion = SpPtAllocateDiskRegionStructure(0xffffffff,0,0,TRUE,NULL,0);
            ASSERT(RemoteBootTargetRegion);
            wcscpy(RemoteBootTargetRegion->TypeName,RemoteBootTarget);
        }
#else
        RemoteInstallSetup = (BOOLEAN)(!RemoteSysPrepSetup);
#endif // defined(REMOTE_BOOT)
    }

    //
    // Determine whether this is advanced server.
    //
    SpDetermineProductType(SifHandle);

    //
    // Display the correct header text based on the product.
    //
    if (!ForceConsole && !Win9xRollback) {
        SpDisplayHeaderText(
            SpGetHeaderTextId(),
            DEFAULT_ATTRIBUTE
            );
    }

    //
    // Check to see if we need to notify the user that we're installing a
    // demo version.  We assume that if the user is doing an unattended
    // install, they know what they're doing.
    //
    if ((!ForceConsole) && (!Win9xRollback) && (!UnattendedOperation) &&
        (EvaluationTime != 0) && (!SpDrEnabled())
        ) {
        SpNotifyEvaluationInstall();
    }

    if ((!ForceConsole) && (!Win9xRollback) && (!SpDrEnabled())) {
        //
        // Welcome the user and determine if this is for repairing.
        //
        if(!UnattendedOperation) {
            SpWelcomeScreen();
        }
    }

    //
    // The user may have chosen to do a repair during
    // the welcome screen, so we need to skip the check for
    // custom/express in this case.
    //
    if ((!ForceConsole) && (!Win9xRollback) && (!SpDrEnabled()) && (!RepairWinnt)) {

        SpCustomExpressScreen();

        if( !CustomSetup ) {
            //
            // The user wants to do an express setup.
            // reread the unattend file off the CD and use that.
            //
            // NULL-out the SetupldrWinntSifFile so we force the
            // re-read of the unattend file off the CDROM or floppy.
            //
            SetupldrWinntSifFile = NULL;
            SpIsWinntOrUnattended(SifHandle);
        }
    }

    if( (HeadlessTerminalConnected) && 
        (UnattendedOperation) &&
        (NTUpgrade != UpgradeFull) &&
        (!ForceConsole) ) {

        //
        // We're unattended and we're headless.  We really want to try and
        // not let gui-mode setup do *ANY* user-interaction.  So let's set
        // the unattend mode to fullunattended.
        //
        PWSTR   Value[1];
        WCHAR   Answer[128];

        Value[0] = Answer;

        wcscpy( Answer, WINNT_A_FULLUNATTENDED_W );
        SpAddLineToSection( WinntSifHandle, 
                            WINNT_UNATTENDED_W, 
                            WINNT_U_UNATTENDMODE_W, 
                            Value, 
                            1 );
    
    
        //
        // Is there already an Administrator Password in the unattend file?
        //
        Value[0] = SpGetSectionKeyIndex( WinntSifHandle,
                                         WINNT_GUIUNATTENDED_W, 
                                         WINNT_US_ADMINPASS_W, 
                                         0 );

        if( (NetBootAdministratorPassword == NULL) &&
            ((Value[0] == NULL) || !(_wcsicmp(Value[0], L"*"))) ) {

            //
            // We will also need to have the user provide an administrator password
            // because blank admin passwords are no longer acceptable on servers.  This
            // can be especially deadly on headless machines because it means the admin
            // can never login to change the admin password from being blank.  For that
            // reason, let's go get a password right now.
            //
            if( SpGetAdministratorPassword( Answer, sizeof(Answer)) ) {
    
                // Write the password into the unattend file.
                Value[0] = Answer;
                SpAddLineToSection( WinntSifHandle, 
                                    WINNT_GUIUNATTENDED_W,
                                    WINNT_US_ADMINPASS_W,
                                    Value,
                                    1 );
            }
        }
    }


    if (ForceConsole) {
        CLEAR_ENTIRE_SCREEN();
    }

    //
    // Detect/load scsi miniports.
    // WARNING WARNING WARNING
    //
    // Do NOT change the order of the actions carried out below without
    // understanding EXACTLY what you are doing.
    // There are many interdependencies...
    //
    SpConfirmScsiMiniports(SifHandle, NtBootDevicePath, DirectoryOnBootDevice);

    //
    // Load disk class drivers if necessary.
    // Do this before loading scsi class drivers, because atdisks
    // and the like 'come before' scsi disks in the load order.
    //
    SpLoadDiskDrivers(SifHandle,NtBootDevicePath,DirectoryOnBootDevice);

    //
    // Load scsi class drivers if necessary.
    //
    SpLoadScsiClassDrivers(SifHandle,NtBootDevicePath,DirectoryOnBootDevice);

    //
    // Reinitialize ARC<==>NT name translations.
    // Do this after loading disk and scsi class drivers because doing so
    // may bring additional devices on-line.
    //
    SpFreeArcNames();
    SpInitializeArcNames(VirtualOemSourceDevices);

    SendSetupProgressEvent(InitializationEvent, InitializationEndEvent, NULL);
    SendSetupProgressEvent(PartitioningEvent, PartitioningStartEvent, NULL);

    //
    // Initialize hard disk information.
    // Do this after loading disk drivers so we can talk to all attached disks.
    //
    SpDetermineHardDisks(SifHandle);

    SendSetupProgressEvent(PartitioningEvent, ScanDisksEvent, &HardDiskCount);

    //
    // Figure out where we are installing from (cd-rom or floppy).
    //      (tedm, 12/8/93) there is a minor problem here.
    //      This only works because we currently only support scsi cd-rom drives,
    //      and we have loaded the scsi class drivers above.
    //      SpDetermineInstallationSource won't allow cd-rom installation
    //      it there are no cd-rom drives on-line -- but we haven't loaded
    //      non-scsi cd-rom drivers yet.  What we really should do is
    //      allow cd-rom as a choice on all machines, and if the user selects
    //      it, not verify the presence of a drive until after we have called
    //      SpLoadCdRomDrivers().
    //
    // If winnt setup, defer this for now, because we will let the partitioning
    // engine search for the local source directory when it initializes.
    //

    TESTHOOK(2);

    if (Win9xRollback) {
        CdInstall = FALSE;
    } else {
        CdInstall = ((WinntSetup && !WinntFromCd && !RemoteBootSetup && !RemoteSysPrepSetup) ||
                        ConsoleFromWinnt32)
                  ? FALSE
                  : SpDetermineInstallationSource(
                        SifHandle,
                        &SetupSourceDevicePath,
                        &DirectoryOnSetupSource,
                        FALSE           // restart if CD-ROM is not present
                        );
    }

    //
    // Load cd-rom drivers if necessary.
    // Note that if we booted from CD (like on an ARC machine) then drivers
    // will already have been loaded by setupldr.  This call here catches the
    // case where we booted from floppy or hard disk and the user chose
    // 'install from cd' during SpDetermineInstallationSource.
    //
    // If we're in step-up mode then we load cd drivers, because the user
    // might need to insert a CD to prove that he qualifies for the step-up.
    //
    if (StepUpMode || CdInstall) {
        SpLoadCdRomDrivers(SifHandle,NtBootDevicePath,DirectoryOnBootDevice);

        //
        // Reinitialize ARC<==>NT name translations.
        //
        SpFreeArcNames();
        SpInitializeArcNames(VirtualOemSourceDevices);
    }

    //
    // At this point, any and all drivers that are to be loaded
    // are loaded -- we are done with the boot media and can switch over
    // to the setup media
    //
    // Initialize the partitioning engine.
    //
    SpPtInitialize();

    TESTHOOK(3);

    //
    // Initialize the boot variables (for ARC)
    //
    if (SpIsArc()) {
        SpInitBootVars();
    }

    //
    // If this is a winnt setup, the partition engine initialization
    // will have attempted to locate the local source partition for us.
    //
    // WARNING: Do not use the SetupSourceDevicePath or DirectoryOnSetupSource
    //      variables in the winnt case until AFTER this bit of code has executed
    //      as they are not set until we get here!
    //
    if(!ForceConsole && !Win9xRollback && WinntSetup && !WinntFromCd && !RemoteBootSetup && !RemoteSysPrepSetup) {
        SpGetWinntParams(&SetupSourceDevicePath,&DirectoryOnSetupSource);
    }

    if (!SpIsArc()) {
        //
        // Initialize the boot variables (X86)
        //
        SpInitBootVars();
    }

    //
    // invoke the command console
    //
    if (ForceConsole) {
        SpStartCommandConsole(SifHandle,SetupSourceDevicePath,DirectoryOnSetupSource);
        SpShutdownSystem();
    }

#ifdef _X86_
    //
    // invoke rollback
    //

    if (Win9xRollback) {

        PCWSTR testPath;
        BOOLEAN defaultToBootDir = TRUE;

        TESTHOOK(1001);     // this is bugcheck point 2001 in the answer file

        //
        // Prepare the globals that tell the rest of the code which drives to use
        //

        WinUpgradeType = SpLocateWin95 (&TargetRegion, &TargetPath, &SystemPartitionRegion);

        if(!SpIsArc()) {
            //
            // system partition directory is the root of C:.
            //
            SystemPartitionDirectory = L"";
        } else {
            SystemPartitionDirectory = SpDetermineSystemPartitionDirectory(
                                            SystemPartitionRegion,
                                            OriginalSystemPartitionDirectory
                                            );
        }

        SpStringToUpper(TargetPath);

        //
        // Force the ~LS directory to be the ~BT directory if needed. We need
        // this for autochk (which is normally in ~ls during setup).
        //

        if (LocalSourceRegion) {
            SpGetWinntParams (&SetupSourceDevicePath, &DirectoryOnSetupSource);

            if (SetupSourceDevicePath && DirectoryOnSetupSource) {
                wcscpy (TemporaryBuffer, SetupSourceDevicePath);
                SpConcatenatePaths (TemporaryBuffer, DirectoryOnSetupSource);

                testPath = SpDupStringW (TemporaryBuffer);

                if (SpFileExists (testPath, TRUE)) {
                    defaultToBootDir = FALSE;
                }

                SpMemFree ((PVOID) testPath);
            }
        }

        if (defaultToBootDir) {
            SetupSourceDevicePath = SpDupStringW (NtBootDevicePath);
            DirectoryOnSetupSource = SpDupStringW (L"\\$win_nt$.~bt");
        }

        //
        // Execute autochk
        //

        AutochkRunning = TRUE;

        SpRunAutochkOnNtAndSystemPartitions (
            SifHandle,
            TargetRegion,
            SystemPartitionRegion,
            SetupSourceDevicePath,
            DirectoryOnSetupSource,
            TargetPath
            );

        AutochkRunning = FALSE;

        TESTHOOK(1002);     // this is bugcheck point 2002 in the answer file

        //
        // We finished; now it is safe to restore the machine
        //

        SpExecuteWin9xRollback (WinntSifHandle, NtBootDevicePath);
        goto CleanAndFinish;
    }
#endif

    if(!SpDrEnabled()) {
        //
        // Display End User Licensing Agreement.  Also, in unattended case,
        // make sure the media is available.
        //

        SpDisplayEula (
                SifHandle,
                SetupSourceDevicePath,
                DirectoryOnSetupSource);
    }

    //
    //  Read the product id and setup info from setupp.ini. If we are doing ASR (specifically
    //  ER), we will wait, and only require the CD if we need it.
    //

    if (!SpDrEnabled()) {
        SpInitializePidString( SifHandle,
                               SetupSourceDevicePath,
                               DirectoryOnSetupSource );
    }

    //
    // Find out if there is any NT to upgrade and if the user wants us to
    // upgrade it.
    //
#if defined(REMOTE_BOOT)
    // If this is a remote boot setup, the target partition is
    // specified in winnt.sif.
    //
#endif // defined(REMOTE_BOOT)

    TargetRegion = NULL;

    if(SpDrEnabled()) {
        NTUpgrade = DontUpgrade;
    } else if (RemoteSysPrepSetup) {
        NTUpgrade = DontUpgrade;
    } else {
        NTUpgrade = SpFindNtToUpgrade(SifHandle,
                                  &TargetRegion,
                                  &TargetPath,
                                  &SystemPartitionRegion,
                                  &OriginalSystemPartitionDirectory);
    }

    if( PreInstall ) {
        //
        // In pre-install mode, get the information about the components
        // to pre-install
        //
        wcscpy( TemporaryBuffer, DirectoryOnSetupSource );
        SpConcatenatePaths( TemporaryBuffer, WINNT_OEM_TEXTMODE_DIR_W );
        PreinstallOemSourcePath = SpDupStringW( ( PWSTR )TemporaryBuffer );
        SpInitializePreinstallList(SifHandle,
                                   SetupSourceDevicePath ,
                                   PreinstallOemSourcePath);
    }

    //
    // Detect/confirm hardware.
    //
    SpConfirmHardware(SifHandle);
    //
    // Reinitialize the keyboard layout dll. This is a no-op for western builds
    // but in Far East builds this can cause a new keyboard layout dll to be loaded.
    //
    if(NTUpgrade != UpgradeFull) {
        extern PVOID KeyboardTable;

        SplangReinitializeKeyboard(
            UnattendedOperation,
            SifHandle,
            DirectoryOnBootDevice,
            &KeyboardTable,
            HardwareComponents
            );
    }

    TESTHOOK(4);

#ifdef _X86_
    //
    // Try to locate previous versions of windows, IFF we are not repairing
    //
    if (!RepairWinnt && !SpDrEnabled()) {
      if(!RemoteBootSetup && !RemoteSysPrepSetup && (NTUpgrade == DontUpgrade)) {
          //
          // Take a gander on the hard drives, looking for win95 or win3.1.
          //
          WinUpgradeType = SpLocateWin95(&TargetRegion,&TargetPath,&SystemPartitionRegion);
          if(WinUpgradeType == NoWinUpgrade) {
              if(SpLocateWin31(SifHandle,&TargetRegion,&TargetPath,&SystemPartitionRegion)) {
                  WinUpgradeType = UpgradeWin31;
                  //
                  // Note that on x86, it can happen that the machine already has NT installed
                  // on top of Win31, and the user is not upgrading NT but he is upgrading win31.
                  //
                  // This is kind of a strange case but we take the extra step here to
                  // ensure that the config directory is cleaned out so the fresh install
                  // will really be fresh.
                  //
                  if(SpIsNtInDirectory(TargetRegion,TargetPath)) {
                      NTUpgrade = UpgradeInstallFresh;
                  }
              }
          }else{

              //
              // We come here only if we are in the Win9x/Win31 case
              // WE want to make sure that we have a TargetRegion at this point
              //

              
              if( !TargetRegion ){

                  //Tell the user that we could not find Win9x to upgrade
                  //This is potentially possible when Win9x was installed on 1394 or USB or some such drive that is 
                  //not supported currently for the install drive.

                  KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: We could not find the installation to upgrade (Win9x) - could be on USB or Firewire drive\n" ));

                  SpCantFindBuildToUpgrade();

              }

          }

      } else {
          //
          // Just check to see if the target region also contains WIN31, Note
          // that the MIN KB to check for is 0, since we already have done
          // the space check.
          // Note also that if the directory contains Win95, then the Win95
          // migration was already done when NT was installed, and we don't
          // care about it now.
          //
          if(!RemoteBootSetup && !RemoteSysPrepSetup && SpIsWin31Dir(TargetRegion,TargetPath,0)) {
              if(SpConfirmRemoveWin31()) {
                  WinUpgradeType = UpgradeWin31;
              }
          } else {
              WinUpgradeType = NoWinUpgrade;
          }
      }
    }

    if (IsNEC_98) { //NEC98

        if (WinUpgradeType==UpgradeWin31) {

            //
            // Remap drive letter, as hard drive start from A:
            //
            DriveAssignFromA = TRUE;
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Re-map drive letters as NEC assign.\n" ));
            SpPtRemapDriveLetters(FALSE); // Re-map as "NEC" assign.

            //
            //  ReInitialize structure;
            //
            SpPtAssignDriveLetters();

        }

    } //NEC98
#endif

    //
    //  Special case upgrades where we want to convert to NTFS
    //
    if( ANY_TYPE_OF_UPGRADE && (( UnattendedSifHandle && (NtfsConvert = SpGetSectionKeyIndex(UnattendedSifHandle,SIF_UNATTENDED,L"Filesystem",0)) ) ||
        ( WinntSifHandle && (NtfsConvert = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,L"Filesystem",0))) ) ) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Should we convert to NTFS ?\n" ));

        if(!_wcsicmp(NtfsConvert,L"ConvertNtfs")){
            ConvertNtVolumeToNtfs = TRUE;
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Yes we should convert to NTFS\n" ));
        }
    }



    //
    // Do partitioning and ask the user for the target path.
    //
    if(!ANY_TYPE_OF_UPGRADE) {

        if(SpDrEnabled()) {
            BOOLEAN RepairedNt = FALSE;

            TargetRegion = NULL;
            SystemPartitionRegion = NULL;

            SpDrPtPrepareDisks(
                        SifHandle,
                        &TargetRegion,
                        &SystemPartitionRegion,
                        SetupSourceDevicePath,
                        DirectoryOnSetupSource,
                        &RepairedNt
                        );

            //
            // invoke the command console
            //
            if (ForceConsole) {
                CLEAR_ENTIRE_SCREEN();
                SpStartCommandConsole(SifHandle,SetupSourceDevicePath,DirectoryOnSetupSource);
                SpShutdownSystem();
            }

            if (RepairedNt) {
                //
                // retrieve information about the install we repaired
                //

                ASSERT(Gbl_HandleToSetupLog != NULL);

                SppGetRepairPathInformation(
                        Gbl_HandleToSetupLog,
                        &Gbl_SystemPartitionName,
                        &Gbl_SystemPartitionDirectory,
                        &Gbl_BootPartitionName,
                        &Gbl_BootPartitionDirectory );

                TargetPath = Gbl_BootPartitionDirectory;
                SystemPartitionDirectory = Gbl_SystemPartitionDirectory;

                ASSERT((TargetPath != NULL) && (SystemPartitionDirectory != NULL));

                RepairWinnt = TRUE;

                goto UpdateBootList;
            }
        }
        else if (RemoteSysPrepSetup) {

            PWSTR UseWholeDisk = NULL;
            BOOLEAN UseWholeDiskFlag = TRUE;

            //
            // Find IMirror.Dat file on server.  doesn't return on failure.
            //
            SpReadIMirrorFile(&RemoteIMirrorFileData, RemoteIMirrorFilePath);

            //
            // Determine what the local disk layout should be based
            // on IMirror.Dat and possible user input.  doesn't return on
            // failure. Read the .sif to see if it specifies that disks
            // should be partitioned as they originally were, or use the
            // entire size of the new disk.
            //
#if defined(REMOTE_BOOT)
            UseWholeDisk = SpGetSectionKeyIndex(WinntSifHandle,SIF_REMOTEBOOT,SIF_USEWHOLEDISK,0);
#else
            UseWholeDisk = SpGetSectionKeyIndex(WinntSifHandle,SIF_REMOTEINSTALL,SIF_USEWHOLEDISK,0);
#endif

            if ((UseWholeDisk != NULL) &&
                ((UseWholeDisk[0] == 'N') || (UseWholeDisk[0] == 'n')))
            {
                UseWholeDiskFlag = FALSE;
            }

            SpDetermineDiskLayout(RemoteIMirrorFileData, &RemoteIMirrorMemoryData);

            //
            // Make the local disks look ok.  doesn't return on failure.
            //

            SpFixupLocalDisks(SifHandle,
                              &TargetRegion,
                              &SystemPartitionRegion,
                              SetupSourceDevicePath,
                              DirectoryOnSetupSource,
                              RemoteIMirrorMemoryData,
                              UseWholeDiskFlag);
        } else {
            PWSTR RemoteBootRepartition = NULL;
            BOOLEAN PrepareForRemoteBoot = RemoteBootSetup;

            //
            // We tell SpPtPrepareDisks to repartition in a remote boot
            // case, unless there is an entry in the [RemoteBoot] section
            // saying "Repartition = No".
            //

            if (RemoteBootSetup) {
#if defined(REMOTE_BOOT)
                RemoteBootRepartition = SpGetSectionKeyIndex(WinntSifHandle,SIF_REMOTEBOOT,SIF_REPARTITION,0);
#else
                RemoteBootRepartition = SpGetSectionKeyIndex(WinntSifHandle,SIF_REMOTEINSTALL,SIF_REPARTITION,0);
#endif // defined(REMOTE_BOOT)
                if ((RemoteBootRepartition != NULL) &&
                    ((RemoteBootRepartition[0] != 'Y') && (RemoteBootRepartition[0] != 'y')))
                {
                    PrepareForRemoteBoot = FALSE;
                }
            } else {                
                BOOLEAN IsCdBoot = (!WinntSetup && !WinntFromCd);

                //
                // Honor Repartition flag only in the case of CD boot
                //
                if (UnattendedSifHandle && IsCdBoot) {
                
                    RemoteBootRepartition = SpGetSectionKeyIndex(UnattendedSifHandle,
                                                SIF_UNATTENDED,
                                                SIF_REPARTITION,
                                                0);

                    if ((RemoteBootRepartition != NULL) &&
                        ((RemoteBootRepartition[0] == 'Y') || (RemoteBootRepartition[0] == 'y')))
                    {
                        PrepareForRemoteBoot = TRUE;
                    }
                }
            }







            //
            // HACK
            // Some OEMs are shipping machines with a hidden, active partition
            // that gets marked unactive after the machine is booted once.  The
            // problem is that sometimes these machines are turned on with a win2k
            // bootable CD in them and we do all sorts of nasty stuff to their
            // hidden partition because its marked active and we think it's a
            // boot partition (which it is).
            //
            // If we detect this case, then we need to throw an error message
            // and go to the partitioning screen.
            //
            while( 1 ) {
                SpPtPrepareDisks(
                    SifHandle,
                    &TargetRegion,
                    &SystemPartitionRegion,
                    SetupSourceDevicePath,
                    DirectoryOnSetupSource,
                    PrepareForRemoteBoot
                    );

#ifdef _X86_
                if( SpIsArc() )
                    break;

                //
                // Only check this on a BIOS X86 machine
                //
                if( SpPtIsSystemPartitionRecognizable() ) {
#else
                if( 1 ) {
#endif
                    break;
                } else {
                    //
                    // Either exit or go back to the partitioning menu.
                    //
                    SpInvalidSystemPartition();
                }
            }




#if defined(REMOTE_BOOT)
            //
            // If this is a remote boot, erase any existing CSC cache, if we
            // did not repartition.
            //

            if (RemoteBootSetup && !RemoteInstallSetup && !PrepareForRemoteBoot &&
                !RemoteSysPrepSetup && (HardDiskCount != 0)) {
                SpEraseCscCache(SystemPartitionRegion);
            }
#endif // defined(REMOTE_BOOT)

        }

        //
        // Partitioning may have changed the partition ordinal of the local source
        //
        if(WinntSetup && !WinntFromCd) {
            SpMemFree(SetupSourceDevicePath);
            SpGetWinntParams(&SetupSourceDevicePath,&DirectoryOnSetupSource);
        }

        DefaultTarget = SpGetSectionKeyIndex(
                            SifHandle,
                            SIF_SETUPDATA,
                            SIF_DEFAULTPATH,
                            0
                            );

        if(!DefaultTarget) {

            SpFatalSifError(
                SifHandle,
                SIF_SETUPDATA,
                SIF_DEFAULTPATH,
                0,
                0
                );
        }

        //
        // Select the target path.
        //
        if (TargetRegion != NULL)
            DeleteTarget = SpGetTargetPath(SifHandle,TargetRegion,DefaultTarget,&TargetPath);


    }

    TESTHOOK(5);

    //
    // Form the SystemPartitionDirectory
    //
    if(!SpIsArc())
    {
        //
        // system partition directory is the root of C:.
        //
        SystemPartitionDirectory = L"";
    }
    else
    {
        SystemPartitionDirectory = SpDetermineSystemPartitionDirectory(
                                        SystemPartitionRegion,
                                        OriginalSystemPartitionDirectory
                                        );
    }

    SpStringToUpper(TargetPath);



    //
    // do any file system conversion
    //
    if(!RemoteSysPrepSetup && !SpDrEnabled()) {
        SpUpgradeToNT50FileSystems(
            SifHandle,
            SystemPartitionRegion,
            TargetRegion,
            SetupSourceDevicePath,
            DirectoryOnSetupSource
            );
    }


    //
    // Run autochk on Nt and system partitions
    //

    //
    // if it boot from hard disk, need to check the current partition.
    //

    if(IsNEC_98) {
        BootRegion = SystemPartitionRegion;

        if(!_wcsnicmp(NtBootDevicePath,DISK_DEVICE_NAME_BASE,wcslen(DISK_DEVICE_NAME_BASE))) {
            SpEnumerateDiskRegions( (PSPENUMERATEDISKREGIONS)SpDetermineBootPartitionEnumNec98,
                                    (ULONG_PTR)&BootRegion );
        }
    }

    if (!SpAsrIsQuickTest()) {

        AutochkRunning = TRUE;

        SpRunAutochkOnNtAndSystemPartitions( SifHandle,
                                             TargetRegion,
                                             (!IsNEC_98 ? SystemPartitionRegion : BootRegion),
                                             SetupSourceDevicePath,
                                             DirectoryOnSetupSource,
                                             TargetPath
                                             );

        AutochkRunning = FALSE;
    }

    if( DeleteTarget )
            SpDeleteExistingTargetDir( TargetRegion, TargetPath, TRUE, SP_SCRN_CLEARING_OLD_WINNT );

#ifdef _X86_
    if (WinUpgradeType == UpgradeWin95) {
        enableBackup = SpGetSectionKeyIndex (
                            WinntSifHandle,
                            WINNT_D_WIN9XUPG_USEROPTIONS_W,
                            WINNT_D_ENABLE_BACKUP_W,
                            0
                            );

        if (enableBackup && _wcsicmp(enableBackup, WINNT_A_YES_W) == 0) {
            disableCompression = SpGetSectionKeyIndex (
                                    WinntSifHandle,
                                    WINNT_D_WIN9XUPG_USEROPTIONS_W,
                                    WINNT_D_DISABLE_BACKUP_COMPRESSION_W,
                                    0
                                    );

            if (disableCompression && _wcsicmp(disableCompression, WINNT_A_YES_W) == 0) {
                compressionType = tcompTYPE_NONE;
            } else {
                compressionType = tcompTYPE_MSZIP;
            }

            g_Win9xBackup = SpBackUpWin9xFiles (WinntSifHandle, compressionType);
        }
    }
#endif // X86

    //
    // If we are installing into an existing tree we need to delete some
    // files and backup some files
    //
    if(NTUpgrade != DontUpgrade) {
       SpDeleteAndBackupFiles(
           SifHandle,
           TargetRegion,
           TargetPath
           );
    }

    TESTHOOK(6);

#ifdef _X86_
    //
    // If we are migrating Win95, delete some files, and move other files
    //
    switch(WinUpgradeType) {
    case UpgradeWin95:
        SpDeleteWin9xFiles(WinntSifHandle);
        SpMoveWin9xFiles(WinntSifHandle);
        break;
    case UpgradeWin31:
        SpRemoveWin31(TargetRegion,TargetPath);
        break;
    }
#endif

#if defined(REMOTE_BOOT)
    //
    // If this is a remote boot, tell the redirector that the local disk is
    // ready to be used for "local" items like the cache and pagefile.
    //

    if (RemoteBootSetup && !RemoteInstallSetup && !RemoteSysPrepSetup && (HardDiskCount != 0)) {
        IoStartCscForTextmodeSetup( (BOOLEAN)(NTUpgrade != DontUpgrade) );
    }
#endif // defined(REMOTE_BOOT)

    TESTHOOK(7);

    //
    // Create the paging file.
    //
    // The copy files and registry operations use memory mapped IO.
    // This can result in huge numbers of dirty pages and can cause
    // the filesystems to throttle if the percentage of memory that
    // is dirty becomes high.   The only way out of this is for the
    // dirty page writer thread to run and it cannot do so unless
    // there is a paging file.
    //
    SpNtNameFromRegion(
        TargetRegion,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );
    SpConcatenatePaths(TemporaryBuffer,L"PAGEFILE.SYS");
    FullTargetPath = SpDupStringW(TemporaryBuffer);

    // Status = SpCreatePageFile(FullTargetPath,1*(1024*1024*1024),(1792*1024*1024));
    Status = SpCreatePageFile(FullTargetPath,40*(1024*1024),50*(1024*1024));
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Warning: unable to create pagefile %ws (%lx)",FullTargetPath,Status));
    }

    SpMemFree(FullTargetPath);

    //
    // On a remote boot machine, copy over the sources to the disk,
    // then change the setup path to point to them.
    //
    if (RemoteInstallSetup) {

        PWSTR TargetPartitionName;
        PWSTR CopySource;
        PWSTR LocalSourcePath;

        //
        // Initialize the diamond decompression engine.
        //
        SpdInitialize();

        wcscpy( TemporaryBuffer, SetupSourceDevicePath );
        SpConcatenatePaths( TemporaryBuffer, DirectoryOnSetupSource );
        CopySource = SpDupStringW( TemporaryBuffer );

        //
        // Copy all the source files to the disk.
        //

        SpNtNameFromRegion(
            TargetRegion,
            TemporaryBuffer,
            sizeof(TemporaryBuffer),
            PartitionOrdinalCurrent
            );

        TargetPartitionName = SpDupStringW(TemporaryBuffer);

        //
        // Delete the directory if it is there.
        //

        SpConcatenatePaths(TemporaryBuffer,
                           LocalSourceDirectory);
        LocalSourcePath = SpDupStringW(TemporaryBuffer);

        if (SpFileExists(LocalSourcePath, TRUE)) {

            ENUMFILESRESULT Result;

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Deleting existing %ws directory\n", LocalSourcePath));

            SpStartScreen(SP_SCRN_WAIT_REMOVING_TEMP_FILES,0,6,TRUE,FALSE,DEFAULT_ATTRIBUTE);

            Result = SpEnumFilesRecursive(
                         LocalSourcePath,
                         SpDelEnumFile,
                         &Status,
                         NULL);
        }

        SpMemFree(LocalSourcePath);

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Copying directories from %ws to %ws%ws\n",
            CopySource, TargetPartitionName, LocalSourceDirectory));

        SpCopyDirRecursive(
            CopySource,
            TargetPartitionName,
            LocalSourceDirectory,
            COPY_NODECOMP
            );

        //
        // Now that the copy is done, the setup source path becomes the
        // previous target. We are no longer even pretending to be doing
        // a remote boot setup.
        //

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Switching to local setup source\n"));

        SetupSourceDevicePath = TargetPartitionName;
        DirectoryOnSetupSource = LocalSourceDirectory;
        if ( PreInstall ) {
            wcscpy( TemporaryBuffer, DirectoryOnSetupSource );
            SpConcatenatePaths( TemporaryBuffer, WINNT_OEM_TEXTMODE_DIR_W );
            SpMemFree( PreinstallOemSourcePath );
            PreinstallOemSourcePath = SpDupStringW( TemporaryBuffer );
        }

        RemoteBootSetup = FALSE;

        SpMemFree(CopySource);
    }

    //
    // If this isn't an automated ASR test, copy the files that make up the product.
    // Note that we cannot pass \device\floppy0 to SpCopyFiles() as a constant string,
    // because this function at some point will attempt to convert the string to lower case,
    // which will cause a bugcheck, since SpToLowerCase will overwrite the constant string.
    // So we make a duplicate of the constant string.
    //
    ThirdPartySourceDevicePath = SpDupStringW( L"\\device\\floppy0" );

    if (RemoteSysPrepSetup) {

        //
        // Initialize the diamond decompression engine.
        //
        SpdInitialize();

        SpInstallSysPrepImage(SifHandle,WinntSifHandle, RemoteIMirrorFileData, RemoteIMirrorMemoryData);

        SpFixupThirdPartyComponents( SifHandle,
                                     ( PreInstall ) ? SetupSourceDevicePath : ThirdPartySourceDevicePath,
                                     TargetRegion,
                                     TargetPath,
                                     SystemPartitionRegion,
                                     SystemPartitionDirectory );

        goto CleanAndFinish;
    }

    //
    // HACK: rename setupapi.log to setupapi.old here because this logfile can
    //       get very large on upgrades
    //
    if (NTUpgrade != DontUpgrade) {
        SpRenameSetupAPILog(TargetRegion,TargetPath);
    }

    if (!SpAsrIsQuickTest()) {
        SpCopyFiles(
            SifHandle,
            SystemPartitionRegion,
            TargetRegion,
            TargetPath,
            SystemPartitionDirectory,
            SetupSourceDevicePath,
            DirectoryOnSetupSource,
            ( PreInstall )? SetupSourceDevicePath : ThirdPartySourceDevicePath
            );
    }

    TESTHOOK(8);

    if (SpDrEnabled()) {
        SpDrCleanup();
    }

    #if defined HEADLESS_ATTENDEDTEXTMODE_UNATTENDEDGUIMODE

    // Get data into inf file if we have a terminal connected and it
    // is a fresh install only
    if (HeadlessTerminalConnected && (!UnattendedOperation) &&(!ANY_TYPE_OF_UPGRADE)) {
        UnattendedGuiOperation = TRUE;
        SpGetNecessaryParameters();
        if (AdvancedServer) {
            SpGetServerDetails();
        }

    }
    #endif

    SendSetupProgressEvent(SavingSettingsEvent, SavingSettingsStartEvent, NULL);


    //
    // Process Crash Recovery settings on upgrade. We call this here for another reason here. We flush the
    // $winnt$.inf file in SpInitializeRegistry. Since we write to that file doing it here makes sure that 
    // the file gets the entries we wrote
    //
    
    if( NTUpgrade == UpgradeFull ){
        SpDisableCrashRecoveryForGuiMode(TargetRegion, TargetPath);
    }

    if (ASRMODE_QUICKTEST_TEXT != SpAsrGetAsrMode()) {
        //
        // Configure the registry.
        //
        SpInitializeRegistry(
            SifHandle,
            TargetRegion,
            TargetPath,
            SetupSourceDevicePath,
            DirectoryOnSetupSource,
            wcsstr(DirectoryOnBootDevice,L"\\$WIN_NT$.~BT") ? NtBootDevicePath : NULL,
            SystemPartitionRegion
            );

        TESTHOOK(9);
    }

    SendSetupProgressEvent(SavingSettingsEvent, HiveProcessingEndEvent, NULL);

    



UpdateBootList:

    if (SpDrEnabled() && !RepairWinnt)  {    // ASR (not ER)
        SpDrCopyFiles();
    }

#ifdef _X86_
//
// NEC98
//
    if (IsNEC_98) { //NEC98
        //
        // Once clear BOOTVARS[], then rebuild it when upgrade from NT.
        //
        TargetRegion_Nec98 = TargetRegion;
        SpReInitializeBootVars_Nec98();
    } //NEC98
#endif

    //
    // If this is an upgrade we need to remove the entry which exists for
    // this system right now, because we are using new entries.  We can use
    // this opportunity to also clean out the boot ini and remove all entries
    // which point to the current nt partition and path
    //
    // Also do this in the case where we wiped out an existing directory during
    // a clean install.
    //
    OldOsLoadOptions = NULL;
    if(NTUpgrade == UpgradeFull || RepairItems[RepairNvram] || DeleteTarget
#if defined(REMOTE_BOOT)
       || RemoteBootSetup
#endif // defined(REMOTE_BOOT)
       ) {
        SpRemoveInstallationFromBootList(
            NULL,
            TargetRegion,
            TargetPath,
            NULL,
            NULL,
            PrimaryArcPath,
#if defined(REMOTE_BOOT)
            RemoteBootSetup,
#endif // defined(REMOTE_BOOT)
            &OldOsLoadOptions
            );

#ifdef _X86_
        // call again to delete the secondary Arc name
        SpRemoveInstallationFromBootList(
            NULL,
            TargetRegion,
            TargetPath,
            NULL,
            NULL,
            SecondaryArcPath,
#if defined(REMOTE_BOOT)
            RemoteBootSetup,
#endif // defined(REMOTE_BOOT)
            &OldOsLoadOptions
            );
#endif
    }


#ifdef _X86_
    //
    // Lay NT boot code on C:.  Do this before flushing boot vars
    // because it may change the 'previous os' selection.
    //
    if ((SystemPartitionRegion != NULL) && (!RepairWinnt || RepairItems[RepairBootSect])) {
        SpLayBootCode(SystemPartitionRegion);
    }
#endif

/*
At the end of text-mode setup, issue an IOCTL_STORAGE_EJECT_MEDIA to the CD-ROM
you are installing from.  On some machines this won't help at all, but on others we
can avoid the (txtsetup, reboot, boot from CD back into txtsetup) cycle that i always
get into.  This would also provide an interrupt for developers like me who don't pay
any attention to setup - we could tell when textmode setup was finished.

In GUI-mode setup if the CD can't be found in the cdrom drive issue an
IOCTL_STORAGE_LOAD_MEDIA to the cd to pull the tray back in.

If you still can't find the CD, wait for a media change notification from the
system.  When you get one (or the user hits the okay button), you continue.
Figureing out when the media has been inserted automagically would be snazzier
than just waiting there for the user to hit the OK button.
*/


#if defined(REMOTE_BOOT)
    //
    // If this is a remote boot setup, rename the loaders and initialize configuration.
    //

    if (RemoteBootSetup) {
        (VOID)SpFixupRemoteBootLoader(RemoteBootTarget);
        (VOID)SpCreateRemoteBootCfg(RemoteBootTarget, SystemPartitionRegion);
    }
#endif // defined(REMOTE_BOOT)

    if (!RepairWinnt || RepairItems[RepairNvram]) {

        //
        // Add a boot set for this installation.
        //
        SpAddInstallationToBootList(
            SifHandle,
            SystemPartitionRegion,
            SystemPartitionDirectory,
            TargetRegion,
            TargetPath,
            FALSE,
            OldOsLoadOptions
            );

        if(OldOsLoadOptions) {
            SpMemFree(OldOsLoadOptions);
        }

        SpCleanSysPartOrphan();

#if defined(REMOTE_BOOT)
        //
        // Make sure that the boot.ini in the machine directory is written.
        //
        if (RemoteBootSetup) {
            if (!SpFlushRemoteBootVars(TargetRegion)) {
                WCHAR   DriveLetterString[2];

                DriveLetterString[0] = TargetRegion->DriveLetter;
                DriveLetterString[1] = L'\0';
                SpStringToUpper(DriveLetterString);
                SpStartScreen(SP_SCRN_CANT_INIT_FLEXBOOT,
                              3,
                              HEADER_HEIGHT+1,
                              FALSE,
                              FALSE,
                              DEFAULT_ATTRIBUTE,
                              DriveLetterString,
                              DriveLetterString
                              );
                // SpDisplayScreen(SP_SCRN_CANT_INIT_FLEXBOOT,3,HEADER_HEIGHT+1);
                SpDisplayStatusText(SP_STAT_F3_EQUALS_EXIT,DEFAULT_STATUS_ATTRIBUTE);
                SpInputDrain();
                while(SpInputGetKeypress() != KEY_F3) ;
                SpDone(0,FALSE,TRUE);
            }
        }
#endif // defined(REMOTE_BOOT)

        SpCompleteBootListConfig( TargetRegion->DriveLetter );

        if (IsNEC_98) { //NEC98
            //
            // Set auto boot flag into PTE.
            //
            SpSetAutoBootFlag(TargetRegion,TRUE);
        } //NEC98
    }

    //
    //  If system was repaired, and either the System Partition
    //  or the NT Partition is an FT partition, then set the
    //  appropriate flag in the registry, so that next time the
    //  system boots, it checks and updates the partition's image.
    //
    //  (guhans) removed SpDrEnabled, ASR doesn't support FT partitions
    //
    if( RepairWinnt ) {
        UCHAR        TmpSysId;
        UCHAR        TmpNtPartitionSysId;
        BOOLEAN      SystemPartitionIsFT;
        BOOLEAN      TargetPartitionIsFT;

        TmpSysId = SpPtGetPartitionType(SystemPartitionRegion);
        ASSERT(TmpSysId != PARTITION_ENTRY_UNUSED);

        SystemPartitionIsFT = ((TmpSysId & VALID_NTFT) == VALID_NTFT) ||
                              ((TmpSysId & PARTITION_NTFT) == PARTITION_NTFT);

        TmpSysId = SpPtGetPartitionType(TargetRegion);
        ASSERT(TmpSysId != PARTITION_ENTRY_UNUSED);

        TargetPartitionIsFT = ((TmpSysId & VALID_NTFT) == VALID_NTFT) ||
                              ((TmpSysId & PARTITION_NTFT) == PARTITION_NTFT);
#ifdef _X86_
        if( ( SystemPartitionIsFT &&
              ( RepairItems[ RepairNvram ] || RepairItems[ RepairBootSect ] )
            ) ||
            ( TargetPartitionIsFT &&
              ( RepairItems[ RepairFiles ] )
            )
          ) {
            SpSetDirtyShutdownFlag( TargetRegion, TargetPath );
        }
#else
        if( ( SystemPartitionIsFT || TargetPartitionIsFT ) && RepairItems[ RepairFiles ] ) {
            SpSetDirtyShutdownFlag( TargetRegion, TargetPath );
        }
#endif
    }

CleanAndFinish:

    if ((RemoteInstallSetup || RemoteSysPrepSetup) && (NetBootSifPath != NULL)) {
        //
        // Clean out the temporary .sif file. SpDeleteFile concatenates its
        // arguments to form the final path.
        //
        Status = SpDeleteFile(L"\\Device\\LanmanRedirector", NetBootSifPath, NULL);
        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not delete temporary file %ws\n", NetBootSifPath));
        }
    }

    SendSetupProgressEvent(SavingSettingsEvent, SavingSettingsEndEvent, NULL);

    //
    // Done with boot variables and arc names.
    //
    SpFreeBootVars();
    SpFreeArcNames();

    SpDone(0,TRUE, UnattendedOperation ? UnattendWaitForReboot : TRUE);

    //
    // We never get here because SpDone doesn't return.
    //
    SpvidTerminate();
    SpInputTerminate();
    SpTerminate();
    return((ULONG)STATUS_SUCCESS);
}

VOID
SpDetermineProductType(
    IN PVOID SifHandle
    )

/*++

Routine Description:

    Determine whether this is advanced server we are setting up,
    as dictated by the ProductType value in [SetupData] section of
    txtsetup.sif.  A non-0 value indicates that we are running
    advanced server.

    Also determine product version.

    The global variables:

    - AdvancedServer
    - MajorVersion
    - MinorVersion

    are modified

Arguments:

    SifHandle - supplies handle to loaded txtsetup.sif.

Return Value:

    None.

--*/

{
    PWSTR p;
    ULONG l;

    //
    // Assume Workstation product.
    //
    AdvancedServer = FALSE;

    //
    // Get the product type from the sif file.
    //
    p = SpGetSectionKeyIndex(SifHandle,SIF_SETUPDATA,SIF_PRODUCTTYPE,0);
    if(p) {

        //
        // Convert to numeric value.
        //
        l = SpStringToLong(p,NULL,10);
        switch (l) {
            case 1:  //SRV
            case 2:  //ADS
            case 3:  //DTC
            case 5:  //BLA
        case 6:  //SBS
                AdvancedServer = TRUE;
                break;

            case 4: //PER
            case 0: //PRO
            default:
                ;
        }
    } else {
        SpFatalSifError(SifHandle,SIF_SETUPDATA,SIF_PRODUCTTYPE,0,0);
    }

    //
    // Get the product major version
    //
    p = SpGetSectionKeyIndex(
            SifHandle,
            SIF_SETUPDATA,
            SIF_MAJORVERSION,
            0
            );

    if(!p) {
        SpFatalSifError(SifHandle,SIF_SETUPDATA,SIF_MAJORVERSION,0,0);
    }
    WinntMajorVer = (ULONG)SpStringToLong(p,NULL,10);

    //
    // Get the product minor version
    //
    p = SpGetSectionKeyIndex(
            SifHandle,
            SIF_SETUPDATA,
            SIF_MINORVERSION,
            0
            );

    if(!p) {
        SpFatalSifError(SifHandle,SIF_SETUPDATA,SIF_MINORVERSION,0,0);
    }
    WinntMinorVer = (ULONG)SpStringToLong(p,NULL,10);

    //
    //  Build the string that contains the signature that
    //  identifies setup.log
    //  Allocate a buffer of reasonable size
    //
    SIF_NEW_REPAIR_NT_VERSION = SpMemAlloc( 30*sizeof(WCHAR) );
    if( SIF_NEW_REPAIR_NT_VERSION == NULL ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to allocate memory for SIF_NEW_REPAIR_NT_VERSION \n" ));
        return;
    }
    swprintf( SIF_NEW_REPAIR_NT_VERSION,
              SIF_NEW_REPAIR_NT_VERSION_TEMPLATE,
              WinntMajorVer,WinntMinorVer );

}


BOOL
SpDetermineInstallationSource(
    IN  PVOID  SifHandle,
    OUT PWSTR *DevicePath,
    OUT PWSTR *DirectoryOnDevice,
    IN  BOOLEAN bEscape
    )
{
    PWSTR p,q;
    BOOLEAN CdInstall;

    //
    // Assume CD-ROM installation.
    //
    CdInstall = TRUE;

    //
    // See whether an override source device has been specified. This can be
    // specified in either winnt.sif or in txtsetup.sif. (Remote boot setup
    // uses winnt.sif.)
    //
    p = SpGetSectionKeyIndex(WinntSifHandle,SIF_SETUPDATA,SIF_SETUPSOURCEDEVICE,0);

    if (p == NULL) {
        p = SpGetSectionKeyIndex(SifHandle,SIF_SETUPDATA,SIF_SETUPSOURCEDEVICE,0);
    }

    if(p != NULL) {

        //
        // Determine if the specified device is a cd-rom so we can set the
        // cd-rom flag accordingly.
        //
        q = SpDupStringW(p);

        if (q) {
            SpStringToLower(q);

            if(!wcsstr(q,L"\\device\\cdrom")) {
                CdInstall = FALSE;
            }

            SpMemFree(q);
        }

        //
        // Inform the caller of the device path.
        //
        *DevicePath = p;

    } else {
        WCHAR   szDevicePath[MAX_PATH];
        PWSTR   szDefDevicePath = L"\\device\\cdrom0";
        ULONG   ulNumCDRoms = IoGetConfigurationInformation()->CdRomCount;

        // assume cdrom0 has the required installation CD
        wcscpy(szDevicePath, szDefDevicePath);

        //
        //  If there is no CD-ROM drive, put a message informing the user
        //  that setup cannot continue.
        //  In the repair case, we pretend that there is a CD-ROM drive,
        //  so that the user can at least repair the hives, boot sector,
        //  and the boot variables (boot.ini on x86 case)
        //
        if (!ulNumCDRoms) {
            if (!RepairWinnt && !SpAsrIsQuickTest()) {
                if(!bEscape) {
                    SpDisplayScreen(SP_SCRN_NO_VALID_SOURCE,3,HEADER_HEIGHT+1);
                    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,
                            SP_STAT_F3_EQUALS_EXIT,0);

                    SpInputDrain();
                    while(SpInputGetKeypress() != KEY_F3) ;

                    SpDone(0,FALSE,TRUE);
                }
            } else {
                RepairNoCDROMDrive = TRUE;
            }
        } else {
            if(!RepairWinnt && !SpAsrIsQuickTest()) {
                PWSTR       szTagfile = 0, szDescription = 0, szMediaShortName;
                BOOLEAN     bRedrawNeeded = FALSE;
                BOOLEAN     bDiskInserted = FALSE;

                szMediaShortName = SpLookUpValueForFile(
                    SifHandle,
                    L"eula.txt",
                    INDEX_WHICHMEDIA,
                    TRUE
                    );

                SpGetSourceMediaInfo(SifHandle, szMediaShortName,
                                    &szDescription, &szTagfile, NULL);

                //
                // Prompt for the disk, based on the setup media type.
                // (this routine will scan all the CD-ROMs and return
                //  proper CD-ROM device path)
                //
                bDiskInserted = SpPromptForDisk(
                                    szDescription,
                                    szDevicePath,
                                    szTagfile,
                                    FALSE,          // don't ignore disk in drive
                                    bEscape,        // allow/disallow escape
                                    TRUE,           // warn about multiple prompts for same disk
                                    &bRedrawNeeded
                                    );

                if(!bDiskInserted)
                    wcscpy(szDevicePath, szDefDevicePath);
            }
        }

        *DevicePath = SpDupStringW(szDevicePath);
    }

    //
    // Fetch the directory on the source device.
    //
    if((p = SpGetSectionKeyIndex(SifHandle,SIF_SETUPDATA,SIF_SETUPSOURCEPATH,0)) == NULL) {
        SpFatalSifError(SifHandle,SIF_SETUPDATA,SIF_SETUPSOURCEPATH,0,0);
    }

    *DirectoryOnDevice = p;

    return(CdInstall);
}


VOID
SpGetWinntParams(
    OUT PWSTR *DevicePath,
    OUT PWSTR *DirectoryOnDevice
    )

/*++

Routine Description:

    Determine the local source partition and directory on the partition.

    The local source partition should have already been located for us
    by the partitioning engine when it initialized.  The directory name
    within the partition is constant.

    Note: this routine should only be called in the winnt.exe setup case!

Arguments:

    DevicePath - receives the path to the local source partition
        in the nt namespace.  The caller should not attempt to free
        this buffer.

    DirectoryOnDevice - receives the directory name of the local source.
        This is actually a fixed constant but is included here for future use.

Return Value:

    None.  If the local source was not located, setup cannot continue.

--*/

{
    ASSERT(WinntSetup && !WinntFromCd);

    if(LocalSourceRegion) {

        SpNtNameFromRegion(
            LocalSourceRegion,
            TemporaryBuffer,
            sizeof(TemporaryBuffer),
            PartitionOrdinalCurrent
            );

        *DevicePath = SpDupStringW(TemporaryBuffer);

        *DirectoryOnDevice = LocalSourceDirectory;

    } else {

        //
        // Error -- can't locate local source directory
        // prepared by winnt.exe.
        //

        SpDisplayScreen(SP_SCRN_CANT_FIND_LOCAL_SOURCE,3,HEADER_HEIGHT+1);

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        SpInputDrain();
        while(SpInputGetKeypress() != KEY_F3) ;

        SpDone(0,FALSE,TRUE);
    }
}

VOID
SpInitializeDriverInf(
    IN HANDLE       MasterSifHandle,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice
    )

/*++

Routine Description:

    Open a handle to drvindex.inf
    Then open a handle to driver.cab

Arguments:

    MasterSifHandle - Handle to txtsetup.sif.

    SetupSourceDevicePath - Path to the device that contains the source media.

    DirectoryOnSourceDevice - Directory on the media where setupp.ini is located.


Return Value:

    NONE.

--*/

{
    PWSTR    MediaShortName;
    PWSTR    MediaDirectory;
    PWSTR    DriverInfPath;
    ULONG    ErrorSubId;
    ULONG    ErrorLine;
    PWSTR    TmpPid;
    NTSTATUS Status;
    PWSTR    PidExtraData;
    CHAR     ExtraDataArray[25];
    PWSTR    PrivateInfPath;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    PWSTR Tagfile,Description;
    BOOLEAN bRedraw = FALSE;

    ULONG ValidKeys[3] = { KEY_F3,ASCI_CR,0 };

    //
    //  Prepair to load drvindex.inf
    //
    MediaShortName = SpLookUpValueForFile(
                        MasterSifHandle,
                        L"drvindex.inf",
                        INDEX_WHICHMEDIA,
                        TRUE
                        );


    if (ForceConsole || ConsoleFromWinnt32){
        //
        // The user needs to reach to console so he can
        // ESCAPE is the removable media is not present
        // in the drive
        //
        SpGetSourceMediaInfo(MasterSifHandle,MediaShortName,&Description,&Tagfile,NULL);

        //
        // if setup source or directory on source is not present
        // try to fetch it
        //
        if (!SetupSourceDevicePath)
            SetupSourceDevicePath = gpCmdConsBlock->SetupSourceDevicePath;

        if (!DirectoryOnSourceDevice)
            DirectoryOnSourceDevice = gpCmdConsBlock->DirectoryOnSetupSource;

        if (!SetupSourceDevicePath || !DirectoryOnSourceDevice){
            SpDetermineInstallationSource(
                MasterSifHandle,
                &SetupSourceDevicePath,
                &DirectoryOnSourceDevice,
                TRUE    // allow to ESCAPE if CD-ROM is not found
                );

            if (SetupSourceDevicePath) {
                if (gpCmdConsBlock->SetupSourceDevicePath) {
                    SpMemFree(gpCmdConsBlock->SetupSourceDevicePath);
                    gpCmdConsBlock->SetupSourceDevicePath = SetupSourceDevicePath;
                }
            }

            if (DirectoryOnSourceDevice){
                if(gpCmdConsBlock->DirectoryOnSetupSource) {
                    SpMemFree(gpCmdConsBlock->DirectoryOnSetupSource);
                    gpCmdConsBlock->DirectoryOnSetupSource = DirectoryOnSourceDevice;
                }
            }

            if (!SetupSourceDevicePath || !DirectoryOnSourceDevice)
                return; // can't proceed
        }


        if (!SpPromptForDisk(
                Description,
                SetupSourceDevicePath,
                Tagfile,
                FALSE,          // don't ignore disk in drive
                TRUE,           // allow escape
                TRUE,           // warn about multiple prompts for same disk
                &bRedraw
                )) {
            DriverInfHandle = NULL;

            if (bRedraw) {
                // redraw the screen
                SpvidClearScreenRegion( 0, 0, 0, 0, DEFAULT_BACKGROUND );
            }

            return;
        }

        if (bRedraw) {
            // redraw the screen
            SpvidClearScreenRegion( 0, 0, 0, 0, DEFAULT_BACKGROUND );
        }
    } else {
        //
        // Prompt for the disk, based on the setup media type.
        // Note : Will not return until the media is provided
        //
        SpPromptForSetupMedia(
                    MasterSifHandle,
                    MediaShortName,
                    SetupSourceDevicePath
                    );
    }


    SpGetSourceMediaInfo(MasterSifHandle,MediaShortName,NULL,NULL,&MediaDirectory);

    wcscpy( TemporaryBuffer, SetupSourceDevicePath );
    SpConcatenatePaths( TemporaryBuffer, DirectoryOnSourceDevice );
    SpConcatenatePaths( TemporaryBuffer, MediaDirectory );
    SpConcatenatePaths( TemporaryBuffer, L"drvindex.inf" );

    DriverInfPath = SpDupStringW( TemporaryBuffer );
    if (!DriverInfPath) {
        Status = STATUS_NO_MEMORY;
    } else {
TryAgain1:
        //
        // load the inf
        //
        Status = SpLoadSetupTextFile(
                    DriverInfPath,
                    NULL,                  // No image already in memory
                    0,                     // Image size is empty
                    &DriverInfHandle,
                    &ErrorLine,
                    TRUE,
                    FALSE
                    );
    }

    if(!NT_SUCCESS(Status)) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to read drvindex.inf. Status = %lx \n", Status ));
        DriverInfHandle = NULL;

        //
        //  bail out of setup
        //
        SpStartScreen(
            SP_SCRN_DRIVERCACHE_FATAL,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE
            );

        SpDisplayStatusOptions(
                        DEFAULT_STATUS_ATTRIBUTE,
                        SP_STAT_ENTER_EQUALS_RETRY,
                        SP_STAT_F3_EQUALS_EXIT,
                        0
                        );

        SpInputDrain();
        switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {
        case ASCI_CR:
            goto TryAgain1;
            break;
        case KEY_F3:
            SpConfirmExit();
            break;
        }

        SpDone(0,FALSE,FALSE);

        ASSERT(FALSE);

    }

    if (DriverInfPath) {
        SpMemFree( DriverInfPath );
    }

    //
    // load the driver cab
    //
    // won't return if it fails
    //

    SpOpenDriverCab(
        MasterSifHandle,
        SetupSourceDevicePath,
        DirectoryOnSourceDevice,
        &MediaDirectory);


    //
    // now read delta.inf from the directory the driver cab was in
    //

    wcscpy( TemporaryBuffer, SetupSourceDevicePath );
    SpConcatenatePaths( TemporaryBuffer, DirectoryOnSourceDevice );
    SpConcatenatePaths( TemporaryBuffer, MediaDirectory );
    SpConcatenatePaths( TemporaryBuffer, L"delta.inf" );

    PrivateInfPath = SpDupStringW( TemporaryBuffer );
    if (!PrivateInfPath) {
        Status = STATUS_NO_MEMORY;
    } else {

        //
        // load the inf
        //
        Status = SpLoadSetupTextFile(
                    PrivateInfPath,
                    NULL,                  // No image already in memory
                    0,                     // Image size is empty
                    &PrivateInfHandle,
                    &ErrorLine,
                    TRUE,
                    FALSE
                    );
    }

    if(!NT_SUCCESS(Status)) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Unable to read delta.inf. Status = %lx \n", Status ));
        PrivateInfHandle = NULL;
    }

    if( PrivateInfPath ) {
        SpMemFree( PrivateInfPath );
    }

    return;
}

VOID
SpOpenDriverCab(
    IN HANDLE       MasterSifHandle,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice,
    OUT PWSTR       *Directory        OPTIONAL
    )

/*++

Routine Description:

    open driver.cab based on the current source path and directory.

Arguments:

    MasterSifHandle - Handle to txtsetup.sif.

    SetupSourceDevicePath - Path to the device that contains the source media.

    DirectoryOnSourceDevice - Directory on the media where setupp.ini is located.

    Directory - If specified, returns the directory below DirectoryOnSourceDevice
        where the cab was opened from.


Return Value:

    NONE.

--*/

{
    PWSTR CabFileSection, CabFileName;
    WCHAR   CabPath[MAX_PATH];
    PWSTR    MediaShortName;
    PWSTR    MediaDirectory;
    NTSTATUS Status;
    PWSTR    DriverCabName, DriverCabPath;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    CABDATA *MyCabData;
    DWORD   i;
    HANDLE  CabHandle;

    ULONG ValidKeys[3] = { KEY_F3,ASCI_CR,0 };

    //
    // Load up every cab that's listed in drvindex.inf
    // and fill in the CabData structure.
    //
    ASSERT( DriverInfHandle );

    if (ARGUMENT_PRESENT(Directory)) {

        //
        // --lookup the name of the cab in txtsetup.sif
        //   then get the path to the file and open it
        //
        DriverCabName = SpGetSectionKeyIndex (MasterSifHandle,
                                   L"SetupData",
                                   L"DriverCabName",
                                   0);

        if (DriverCabName) {
            MediaShortName = SpLookUpValueForFile(
                                MasterSifHandle,
                                DriverCabName,
                                INDEX_WHICHMEDIA,
                                TRUE
                                );

            SpGetSourceMediaInfo(MasterSifHandle,MediaShortName,NULL,NULL,&MediaDirectory);
            *Directory = MediaDirectory;
        } else {
            //
            //  bail out of setup
            //
            DriverInfHandle = NULL;

            SpFatalSifError(MasterSifHandle,
                L"SetupData",
                L"DriverCabName",
                0,
                0);

            return; // for prefix
        }
    }


    //
    // get the cabfiles line from the Version section
    //
    i = 0;
    CabFileSection = NULL;
    CabData = SpMemAlloc( sizeof(CABDATA) );
    RtlZeroMemory( CabData, sizeof(CABDATA) );
    MyCabData = CabData;

    //
    // SpGetSectionKeyIndex will return NULL when there are no more entries on
    // this line.
    //
    while( CabFileSection = SpGetSectionKeyIndex(DriverInfHandle,L"Version",L"CabFiles",i) ) {
        //
        // Got the section name.  Go figure out which cab we need
        // to open and load the handle.
        //
        CabFileName = SpGetSectionKeyIndex(DriverInfHandle,L"Cabs",CabFileSection,0);

        if( CabFileName ) {
            MediaShortName = SpLookUpValueForFile( MasterSifHandle,
                                                   CabFileName,
                                                   INDEX_WHICHMEDIA,
                                                   TRUE );

            SpGetSourceMediaInfo(MasterSifHandle,MediaShortName,NULL,NULL,&MediaDirectory);

            wcscpy( CabPath, SetupSourceDevicePath );
            SpConcatenatePaths( CabPath, DirectoryOnSourceDevice );
            SpConcatenatePaths( CabPath, MediaDirectory );
            SpConcatenatePaths( CabPath, CabFileName );

TryAgain2:
            INIT_OBJA(&Obja,&UnicodeString,CabPath);

            Status = ZwCreateFile( &CabHandle,
                                   FILE_GENERIC_READ,
                                   &Obja,
                                   &IoStatusBlock,
                                   NULL,
                                   FILE_ATTRIBUTE_NORMAL,
                                   FILE_SHARE_READ,
                                   FILE_OPEN,
                                   0,
                                   NULL,
                                   0 );
            if( NT_SUCCESS(Status) ) {
                //
                // load the data structure.
                //
                if( (MyCabData->CabName) && (MyCabData->CabHandle) ) {
                    //
                    // This entry is being used.  Create another.
                    //
                    MyCabData->Next = SpMemAlloc( sizeof(CABDATA) );
                    MyCabData = MyCabData->Next;
                }

                if( MyCabData ) {
                    MyCabData->Next = NULL;
                    MyCabData->CabName = SpDupStringW(CabFileName);
                    MyCabData->CabHandle = CabHandle;
                    MyCabData->CabInfHandle = DriverInfHandle;
                    MyCabData->CabSectionName = SpDupStringW(CabFileSection);
                } else {
                    //
                    // What to do...
                    //
                }



            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open cab file %ws. Status = %lx \n", CabPath, Status ));

                //
                //  bail out of setup
                //
                DriverInfHandle = NULL;

                SpStartScreen(
                    SP_SCRN_DRIVERCACHE_FATAL,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE
                    );

                SpDisplayStatusOptions(
                                DEFAULT_STATUS_ATTRIBUTE,
                                SP_STAT_ENTER_EQUALS_RETRY,
                                SP_STAT_F3_EQUALS_EXIT,
                                0
                                );
                SpInputDrain();
                switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {
                case ASCI_CR:
                    goto TryAgain2;
                    break;
                case KEY_F3:
                    SpConfirmExit();
                    break;
                }

                SpDone(0,FALSE,FALSE);

                ASSERT(FALSE);
            }
        }

        //
        // Go look in the next section.
        //
        i++;
    }

    return;
}


VOID
SpInitializePidString(
    IN HANDLE       MasterSifHandle,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice
    )

/*++

Routine Description:

    Read th Pid20 from setupp.ini on the media, and save it on the global
    variable PidString. Also read the "extradata" from setupp.ini and translate it
    into the StepUpMode global.  Note that the StepUpMode global is already set from
    reading setupreg.hiv initially, but this overrides that value

Arguments:

    MasterSifHandle - Handle to txtsetup.sif.

    SetupSourceDevicePath - Path to the device that contains the source media.

    DirectoryOnSourceDevice - Directory on the media where setupp.ini is located.


Return Value:

    NONE.

--*/

{
    PWSTR    MediaShortName;
    PWSTR    MediaDirectory;
    PWSTR    SetupIniPath;
    ULONG    ErrorSubId;
    ULONG    ErrorLine;
    PVOID    SetupIniHandle;
    PWSTR    TmpPid;
    NTSTATUS Status;
    PWSTR    PidExtraData;
    CHAR     ExtraDataArray[25];


    //
    //  Prepair to run autofmt
    //
    MediaShortName = SpLookUpValueForFile(
                        MasterSifHandle,
                        L"setupp.ini",
                        INDEX_WHICHMEDIA,
                        TRUE
                        );

    //
    // Prompt the user to insert the setup media.
    //
    SpPromptForSetupMedia(
        MasterSifHandle,
        MediaShortName,
        SetupSourceDevicePath
        );

    SpGetSourceMediaInfo(MasterSifHandle,MediaShortName,NULL,NULL,&MediaDirectory);

    wcscpy( TemporaryBuffer, SetupSourceDevicePath );
    SpConcatenatePaths( TemporaryBuffer, DirectoryOnSourceDevice );
    SpConcatenatePaths( TemporaryBuffer, MediaDirectory );
    SpConcatenatePaths( TemporaryBuffer, L"setupp.ini" );
    SetupIniPath = SpDupStringW( TemporaryBuffer );

    CLEAR_CLIENT_SCREEN();

    Status = SpLoadSetupTextFile(
                SetupIniPath,
                NULL,                  // No image already in memory
                0,                     // Image size is empty
                &SetupIniHandle,
                &ErrorLine,
                TRUE,
                FALSE
                );

    if(!NT_SUCCESS(Status)) {
        //
        //  Silently fail if unable to read setupp.ini
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Unable to read setupp.ini. Status = %lx \n", Status ));

        PidString = NULL;
        StepUpMode = TRUE;
        return;
    }

    TmpPid = SpGetSectionKeyIndex (SetupIniHandle,
                                   L"Pid",
                                   L"Pid",
                                   0);

    PidString = ( TmpPid == NULL )? NULL : SpDupStringW(TmpPid);

    TmpPid = SpGetSectionKeyIndex (SetupIniHandle,
                               L"Pid",
                               L"Pid",
                               0);

    PidString = ( TmpPid == NULL )? NULL : SpDupStringW(TmpPid);

    TmpPid = SpGetSectionKeyIndex (SetupIniHandle,
                                   L"Pid",
                                   L"ExtraData",
                                   0);

    PidExtraData = (TmpPid == NULL) ? NULL : SpDupStringW(TmpPid);
    if ( PidExtraData ) {

        if (! SpGetStepUpMode(PidExtraData,&StepUpMode)) {
            //
            // fatal error processing PidExtraData
            //  -- someone tampered with this file so bail out
            //

            SpStartScreen(
                SP_SCRN_PIDINIT_FATAL,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE
                );

            SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);
            SpInputDrain();
            while(SpInputGetKeypress() != KEY_F3);
            SpDone(0, FALSE,FALSE);

            ASSERT(FALSE);
        }

        SpMemFree( PidExtraData );

    }

    SpFreeTextFile( SetupIniHandle );
    return;
}

NTSTATUS
SpRenameSetupAPILog(
    PDISK_REGION TargetRegion,
    PCWSTR       TargetPath
    )
/*++

Routine Description:

    This routine deletes the copy of setupapi.old if present, and then
    renames setupapi.log to setupapi.old.

Arguments:

    TargetRegion -  identifies the disk containing the NT installation
    TargetPath   -  path to NT installation on disk

Return Value:

    NONE.

--*/

{
    PWSTR SetupAPIOldName;
    PWSTR SetupAPILogName;
    PWSTR p;
    NTSTATUS Status;

    SpNtNameFromRegion(
            TargetRegion,
            TemporaryBuffer,
            sizeof(TemporaryBuffer),
            PartitionOrdinalCurrent
            );

    SpConcatenatePaths( TemporaryBuffer, TargetPath );

    //
    // Allocate a string buffer large enough to contain space for the string
    // in TemporaryBuffer, plus "setupapi.old", plus the path seperator that
    // SpConcatenatePaths() may insert between them.  Include room for the
    // null terminator as well.
    //

    SetupAPIOldName = SpMemAlloc(wcslen(TemporaryBuffer) * sizeof(WCHAR) +
                                 sizeof(L'\\') +
                                 sizeof(L"setupapi.old") +
                                 sizeof(L'\0'));
    if (SetupAPIOldName == NULL) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not allocate memory to rename setupapi.log.\n"));
        return STATUS_NO_MEMORY;
    }

    SetupAPILogName = SpMemAlloc(wcslen(TemporaryBuffer) * sizeof(WCHAR) +
                                 sizeof(L'\\') +
                                 sizeof(L"setupapi.log") +
                                 sizeof(L'\0'));
    if (SetupAPILogName == NULL) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not allocate memory to rename setupapi.log.\n"));
        SpMemFree(SetupAPIOldName);
        return STATUS_NO_MEMORY;
    }

    wcscpy(SetupAPIOldName, TemporaryBuffer);
    SpConcatenatePaths(SetupAPIOldName, L"setupapi.old");
    wcscpy(SetupAPILogName, TemporaryBuffer);
    SpConcatenatePaths(SetupAPILogName, L"setupapi.log");


    Status = SpDeleteFile(SetupAPIOldName, NULL, NULL);
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Could not delete %ws: %lx.\n", SetupAPIOldName, Status));
    }

    Status = SpRenameFile(SetupAPILogName, SetupAPIOldName, FALSE);
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Could not rename %ws to %ws: %lx.\n", SetupAPILogName, SetupAPIOldName, Status));
    }

    SpMemFree(SetupAPILogName);
    SpMemFree(SetupAPIOldName);

    return Status;

}



#if defined(REMOTE_BOOT)
NTSTATUS
SpFixupRemoteBootLoader(
    PWSTR RemoteBootTarget
    )

/*++

Routine Description:

    This routine deletes the setup loader that is currently NTLDR, and
    puts the os loader in its place.

Arguments:

    RemoteBootTarget -- the network path to the machine directory root
        on the server.

Return Value:

    NONE.

--*/

{
    PWSTR NtldrName;
    PWSTR OsLoaderName;
    PWSTR p;
    NTSTATUS Status;

    NtldrName = SpMemAlloc(wcslen(RemoteBootTarget) * sizeof(WCHAR) + sizeof(L"ntldr"));
    if (NtldrName == NULL) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not allocate memory to fixup remote boot loader.\n"));
        return STATUS_NO_MEMORY;
    }
    OsLoaderName = SpMemAlloc((wcslen(RemoteBootTarget) + 20) * sizeof(WCHAR));
    if (OsLoaderName == NULL) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not allocate memory to fixup remote boot loader.\n"));
        SpMemFree(NtldrName);
        return STATUS_NO_MEMORY;
    }

    wcscpy(NtldrName, RemoteBootTarget);
    p = wcsstr(NtldrName, L"BootDrive");
    ASSERT(p != NULL);
    wcscpy(p, L"ntldr");

    Status = SpDeleteFile(NtldrName, NULL, NULL);
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not delete %ws: %lx.\n", NtldrName, Status));
        goto Cleanup;
    }

    wcscpy(OsLoaderName, RemoteBootTarget);
    wcscat(OsLoaderName, L"\\winnt\\osloader.exe");

    Status = SpRenameFile(OsLoaderName, NtldrName, FALSE);
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not rename %ws to %ws: %lx.\n", OsLoaderName, NtldrName, Status));
    }

Cleanup:

    SpMemFree(NtldrName);
    SpMemFree(OsLoaderName);

    return Status;

}

NTSTATUS
SpCreateRemoteBootCfg(
    IN PWSTR RemoteBootTarget,
    IN PDISK_REGION SystemPartitionRegion
    )

/*++

Routine Description:

    This routine creates the RemoteBoot.cfg file in the system32\config directory, and
    initializes it.

Arguments:

    RemoteBootTarget -- the network path to the machine directory root
        on the server.

    SystemPartitionRegion -- The drive that is installed on the local machine.

Return Value:

    NONE.

--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    PWSTR FileName;
    PWSTR p;
    NTSTATUS Status;
    HANDLE Handle;
    ULONG BootSerialNumber = 1;
    ULONG DiskSignature;
    LARGE_INTEGER ByteOffset;

    if ((SystemPartitionRegion != NULL) &&
        (!SystemPartitionRegion->PartitionedSpace ||
         (SystemPartitionRegion->Filesystem != FilesystemNtfs))) {
        KdPrintEx((Ex"SDPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, ETUP: ERROR! Invalid system partition for remoteboot!\n");
        return STATUS_UNSUCCESSFUL;
    }

    if (SystemPartitionRegion != NULL) {
        DiskSignature = U_ULONG(SystemPartitionRegion->MbrInfo->OnDiskMbr.NTFTSignature);
    } else {
        DiskSignature = 0;
    }

    FileName = SpMemAlloc(wcslen(RemoteBootTarget)  * sizeof(WCHAR) + sizeof(L"RemoteBoot.cfg"));
    if (FileName == NULL) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not allocate memory remoteboot.cfg file name.\n"));
        return STATUS_NO_MEMORY;
    }

    wcscpy(FileName, RemoteBootTarget);
    p = wcsstr(FileName, L"BootDrive");
    ASSERT(p != NULL);
    wcscpy(p, L"RemoteBoot.cfg");

    INIT_OBJA(&ObjectAttributes,&UnicodeString,FileName);

    Status = ZwCreateFile( &Handle,
                           (ACCESS_MASK)FILE_GENERIC_WRITE | FILE_GENERIC_READ,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_HIDDEN,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OVERWRITE_IF,
                           FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS,
                           NULL,
                           0
                         );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not create %ws file. Status == 0x%x\n", FileName, Status));
        goto Cleanup;
    }


    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_TRACE_LEVEL, "SETUP: Writing remoteboot.cfg file.\n"));

    //
    // Update the information
    //
    ByteOffset.LowPart = 0;
    ByteOffset.HighPart = 0;

    ZwWriteFile( Handle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 &BootSerialNumber,
                 sizeof(ULONG),
                 &ByteOffset,
                 NULL
               );

    ByteOffset.LowPart = sizeof(ULONG);

    ZwWriteFile( Handle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 &DiskSignature,
                 sizeof(ULONG),
                 &ByteOffset,
                 NULL
               );

    ByteOffset.LowPart = sizeof(ULONG) + sizeof(ULONG);

    ZwWriteFile( Handle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 NetBootHalName,
                 sizeof(NetBootHalName),
                 &ByteOffset,
                 NULL
               );

    ZwClose(Handle);

Cleanup:

    SpMemFree(FileName);
    return Status;

}

NTSTATUS
SpEraseCscCache(
    IN PDISK_REGION SystemPartitionRegion
    )

/*++

Routine Description:

    This routine erases the local CSC cache.

Arguments:

    SystemPartitionRegion - The system partition region (the local drive).

Return Value:

    NONE.

--*/

{
    NTSTATUS Status;
    ENUMFILESRESULT Result;
    PWSTR FullCscPath;

    //
    // Show a screen, the status line will show each file as it is
    // deleted.
    //

    SpDisplayScreen(SP_SCRN_CLEARING_CSC, 3, 4 );

    SpNtNameFromRegion(
        SystemPartitionRegion,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    SpConcatenatePaths(TemporaryBuffer,
                       REMOTE_BOOT_IMIRROR_PATH_W REMOTE_BOOT_CSC_SUBDIR_W);
    FullCscPath = SpDupStringW(TemporaryBuffer);

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_TRACE_LEVEL, "SETUP: SpEraseCscCache clearing CSC cache %ws\n", FullCscPath));

    Result = SpEnumFilesRecursive(
                 FullCscPath,
                 SpDelEnumFile,
                 &Status,
                 NULL);

    SpMemFree(FullCscPath);

    return Status;

}
#endif // defined(REMOTE_BOOT)

NTSTATUS
SpProcessMigrateInfFile(
    IN  PVOID InfHandle
    )

/*++

Routine Description:

    Process the [AddReg] section of migrate.inf.
    The keys are created on the setup hive.

Arguments:

    InfHandle - Handle to migrate.inf file.

Return Value:

    Status code indicating outcome.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HANDLE  SystemHiveRoot;
    PWSTR   KeyPath = L"\\registry\\machine\\system";

    //
    //  Open a handle to HKEY_LOCAL_MACHINE\System on the setup hive
    //
    INIT_OBJA(&Obja,&UnicodeString,KeyPath);
    Obja.RootDirectory = NULL;

    Status = ZwOpenKey(&SystemHiveRoot,KEY_ALL_ACCESS,&Obja);
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ls on the setup hive. Status =  %lx \n", KeyPath, Status));
        return( Status );
    }

    Status = SpProcessAddRegSection( InfHandle,
                                     L"AddReg",
                                     SystemHiveRoot,
                                     NULL,
                                     NULL,
                                     NULL );

    ZwClose( SystemHiveRoot );
    return( Status );

}

//begin NEC98
VOID
SpSetAutoBootFlag(
    PDISK_REGION TargetRegion,
    BOOLEAN      SetBootPosision
    )
{
#if defined(NEC_98) //NEC98
    PHARD_DISK      pHardDisk;
    WCHAR DevicePath[(sizeof(DISK_DEVICE_NAME_BASE)+sizeof(L"000"))/sizeof(WCHAR)];
    ULONG i,bps;//,DiskLayoutSize;
    HANDLE Handle;
    NTSTATUS Sts;
    PREAL_DISK_PTE_NEC98 Pte;
    PUCHAR Buffer,UBuffer;
    UCHAR Position = 0;


    UBuffer = SpMemAlloc(2 * 2 * 512);
    Buffer = ALIGN(UBuffer,512);

    for(i=0; i<HardDiskCount; i++){
        swprintf(DevicePath,L"\\Device\\Harddisk%u",i);
        if(HardDisks[i].Status == DiskOffLine) {
            continue;
        }
        //
        // ignore removable disk.
        //
        if(HardDisks[i].Characteristics & FILE_REMOVABLE_MEDIA ){
            continue;
        }
        bps = HardDisks[i].Geometry.BytesPerSector;
        Sts = SpOpenPartition0(DevicePath,&Handle,TRUE);
        if(!NT_SUCCESS(Sts)) {
            continue;
        }
        RtlZeroMemory(Buffer,bps * 2);
        Sts = SpReadWriteDiskSectors(Handle,0,1,bps,Buffer,FALSE);

        if(!NT_SUCCESS(Sts)) {
            ZwClose(Handle);
            continue;
        }

        //
        //  Clear BootRecord
        //
        Buffer[bps - 5] = 0x00;
        Buffer[bps - 6] = 0x00;

        Sts = SpReadWriteDiskSectors(Handle,0,1,bps,Buffer,TRUE);

        if(!NT_SUCCESS(Sts)) {
            ZwClose(Handle);
            continue;
        }
        ZwClose(Handle);
    }

    if(SetBootPosision){

        //
        // Set RealDiskPosition.(in upgrade or repair)
        //
        if( (NTUpgrade == UpgradeFull) || (WinUpgradeType != NoWinUpgrade) ||  RepairWinnt ||
            (AutoPartitionPicker
#if defined(REMOTE_BOOT)
             && !RemoteBootSetup
#endif // defined(REMOTE_BOOT)
            ) ) {

            ASSERT(TargetRegion);
            TargetRegion->MbrInfo->OnDiskMbr.PartitionTable[TargetRegion->TablePosition].RealDiskPosition
                = (UCHAR)TargetRegion->TablePosition;
        }

        ASSERT(TargetRegion);
        RtlZeroMemory(Buffer,bps * 2);
        pHardDisk = &HardDisks[TargetRegion->DiskNumber];
        bps = HardDisks[TargetRegion->DiskNumber].Geometry.BytesPerSector;
        Sts = SpOpenPartition0(pHardDisk->DevicePath,&Handle,TRUE);
        if(!NT_SUCCESS(Sts)) {
            return;
        }
        Sts = SpReadWriteDiskSectors(Handle,0,2,bps,Buffer,FALSE);

        if(!NT_SUCCESS(Sts)) {
            ZwClose(Handle);
            SpMemFree(UBuffer);
            return;
        }

        (PUCHAR)Pte = &Buffer[bps];
        Position = TargetRegion->MbrInfo->OnDiskMbr.PartitionTable[TargetRegion->TablePosition].RealDiskPosition;

        //
        // Update BootRecord and Volume Information
        //
        Buffer[bps - 5] = Position;
        Buffer[bps - 6] = 0x80;
        Pte[Position].ActiveFlag |= 0x80;
        Pte[Position].SystemId   |= 0x80;

        //
        // If target partition was created windisk.exe on NT3.5, there is not IPL adress
        // in its volume info. So,textmode setup must write it to the volume info.
        //
        if ((Pte[Position].IPLSector != Pte[Position].StartSector)           ||
            (Pte[Position].IPLHead != Pte[Position].StartHead)               ||
            (Pte[Position].IPLCylinderLow != Pte[Position].StartCylinderLow) ||
            (Pte[Position].IPLCylinderHigh != Pte[Position].StartCylinderHigh))
        {
            //
            // Not much! Set IPL adress value same as partition start address.
            //

            Pte[Position].IPLSector = Pte[Position].StartSector;
            Pte[Position].IPLHead   = Pte[Position].StartHead;
            Pte[Position].IPLCylinderLow  = Pte[Position].StartCylinderLow;
            Pte[Position].IPLCylinderHigh = Pte[Position].StartCylinderHigh;
        }

        Sts = SpReadWriteDiskSectors(Handle,0,2,bps,Buffer,TRUE);

        if(!NT_SUCCESS(Sts)) {
            ZwClose(Handle);
            SpMemFree(UBuffer);
            return;
        }
        ZwClose(Handle);
    }
    SpMemFree(UBuffer);
#endif //NEC98
}


VOID
SpCheckHiveDriveLetters(
    VOID
    )
{
#if defined(NEC_98) //NEC98
    NTSTATUS    Status;
    PWSTR       p;
    ULONG       ErrorLine;
    PVOID       TmpWinntSifHandle = NULL;
    BOOLEAN     ForceRemapDriveLetter = FALSE;
    BOOLEAN     DriveAssign_AT = TRUE;

    if ( SetupldrWinntSifFileSize ) {

        Status = SpLoadSetupTextFile( NULL,
                                      SetupldrWinntSifFile,
                                      SetupldrWinntSifFileSize,
                                      &TmpWinntSifHandle,
                                      &ErrorLine,
                                      FALSE,
                                      TRUE
                                      );

        if (!NT_SUCCESS(Status))
            return;

        p = SpGetSectionKeyIndex(TmpWinntSifHandle,SIF_DATA,WINNT_D_DRIVEASSIGN_NEC98_W,0);
        if(p && !_wcsicmp(p,WINNT_A_YES_W)) {

            if (SetupldrMigrateInfFile) {
                p = SpGetSectionKeyIndex(TmpWinntSifHandle,SIF_DATA,WINNT_D_NTUPGRADE_W,0);
                if(p && !_wcsicmp(p,WINNT_A_YES_W)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Upgrade NEC assigned WinNT.(AT=FALSE)\n"));
                    DriveAssign_AT = FALSE;
                } else {

                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Fresh setup from NEC assigned WinNT.(AT=TRUE)\n"));
                    DriveAssign_AT = TRUE;
                }
            } else {

                p = SpGetSectionKeyIndex(TmpWinntSifHandle,SIF_DATA,WINNT_D_WIN95UPGRADE_W,0);
                if(p && !_wcsicmp(p,WINNT_A_YES_W)) {
                   KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Upgrade NEC assigned Win95.(AT=FALSE)\n"));
                   DriveAssign_AT = FALSE;
                } else {
                   KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Fresh setup from NEC assigned Win95.(AT=TRUE)\n"));
                   DriveAssign_AT = TRUE;
                }
            }
        }
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Fresh setup.(AT=TRUE)\n"));
        DriveAssign_AT = TRUE;
    }

    SpSetHiveDriveLetterNec98( DriveAssign_AT );
#endif //NEC98
}


VOID
SpSetHiveDriveLetterNec98(
    BOOLEAN DriveAssign_AT
    )
{
#if defined(NEC_98) //NEC98
    NTSTATUS    Status;
    UNICODE_STRING StartDriveLetterFrom;
    UNICODE_STRING Dummy;


    RTL_QUERY_REGISTRY_TABLE SetupTypeTable[]=
    {
        {NULL,
        RTL_QUERY_REGISTRY_DIRECT,
        L"DriveLetter",
        &StartDriveLetterFrom,
        REG_SZ,
        &Dummy,
        0
        },
        {NULL,0,NULL,NULL,REG_NONE,NULL,0}
    };

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_TRACE_LEVEL, "SETUP: SpSetHiveDriveLetter(%ld).\n", DriveAssign_AT));

    RtlInitUnicodeString(&StartDriveLetterFrom, NULL);
    RtlInitUnicodeString(&Dummy, NULL);

    Status = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE,
                                     L"\\Registry\\MACHINE\\SYSTEM\\Setup",
                                     SetupTypeTable,
                                     NULL,
                                     NULL);

    if (DriveAssign_AT) {
        //
        // Write hive "DriveLetter",
        //
        if ((StartDriveLetterFrom.Buffer[0] != L'C') &&
            (StartDriveLetterFrom.Buffer[0] != L'c')) {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Write DriveLetter=C into setup hiv.\n"));
            Status = RtlWriteRegistryValue( RTL_REGISTRY_ABSOLUTE,
                                            L"\\Registry\\Machine\\System\\Setup",
                                            L"DriveLetter",
                                            REG_SZ,
                                            L"C",
                                            sizeof(L"C")+sizeof(WCHAR));
        }
        DriveAssignFromA = FALSE;

    } else {
        //
        // Delete hive "DriveLetter",
        //
        if (NT_SUCCESS(Status)) {
            if ((StartDriveLetterFrom.Buffer[0] == L'C') ||
                (StartDriveLetterFrom.Buffer[0] == L'c')) {

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Delete DriveLetter=C from setup hiv.\n"));
                Status = RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                            L"\\Registry\\MACHINE\\SYSTEM\\Setup",
                                            L"DriveLetter");
            }
        }
        DriveAssignFromA = TRUE;
    }
#endif //NEC98
}


VOID
SpDeleteDriveLetterFromNTFTNec98(
    VOID
    )
{
#if defined(NEC_98) //NEC98
    NTSTATUS    Status;
    PWSTR       p;
    ULONG       ErrorLine;
    UNICODE_STRING StartDriveLetterFrom;
    UNICODE_STRING Dummy;
    PVOID       TmpWinntSifHandle = NULL;
    BOOLEAN     ForceRemapDriveLetter = FALSE;

    // 1st step:
    // Check whether we need to reassign drive letters.
    Status = SpLoadSetupTextFile(
                NULL,
                SetupldrWinntSifFile,
                SetupldrWinntSifFileSize,
                &TmpWinntSifHandle,
                &ErrorLine,
                FALSE,
                TRUE
                );

    if (!NT_SUCCESS(Status))
        return;

    if (SetupldrMigrateInfFile) {
        p = SpGetSectionKeyIndex(TmpWinntSifHandle,SIF_DATA,WINNT_D_NTUPGRADE_W,0);
        if(!p || !_wcsicmp(p,WINNT_A_NO_W)) {
            SpDeleteDriveLetterFromNTFTWorkerNec98();
        }
    }
#endif //NEC98
}


VOID
SpDeleteDriveLetterFromNTFTWorkerNec98(
    VOID
    )
{
#if defined(NEC_98) //NEC98

#define MOUNT_REGISTRY_KEY_W    L"\\registry\\machine\\SYSTEM\\MountedDevices"
#define DISK_REGISTRY_KEY_W     L"\\registry\\machine\\SYSTEM\\DISK"

    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HANDLE  KeyHandle;
    ULONG Disposition;

    RTL_QUERY_REGISTRY_TABLE    queryTable[2];
    ULONG                       registrySize;
    //NTSTATUS                    status;
    PDISK_CONFIG_HEADER         registry;
    PDISK_REGISTRY              diskRegistry;
    PDISK_DESCRIPTION           diskDescription;
    ULONG                       signature;
    LONGLONG                    offset;
    PDISK_PARTITION             diskPartition;
    UCHAR                       driveLetter;
    USHORT                      i, j;


    //
    // Delete \SYSTEM\\MountedDevices.
    //
    INIT_OBJA(&Obja,&UnicodeString,MOUNT_REGISTRY_KEY_W);
    Obja.RootDirectory = NULL;
    Status = ZwOpenKey(&KeyHandle,KEY_ALL_ACCESS,&Obja);

    if( NT_SUCCESS( Status ) ) {
        Status = ZwDeleteKey(KeyHandle);
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Delete %ls on the setup hive. Status =  %lx \n", MOUNT_REGISTRY_KEY_W, Status));
        ZwClose(KeyHandle);
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: No %ls on the setup hive.\n", MOUNT_REGISTRY_KEY_W));
    }


    //
    // Delete drive letter information from \SYSTEM\\DISK.
    //
    INIT_OBJA(&Obja,&UnicodeString,DISK_REGISTRY_KEY_W);
    Obja.RootDirectory = NULL;
    Status = ZwOpenKey(&KeyHandle,KEY_ALL_ACCESS,&Obja);

    if( NT_SUCCESS( Status ) ) {

        RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
        queryTable[0].QueryRoutine = SpDiskRegistryQueryRoutineNec98;
        queryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
        queryTable[0].Name = L"Information";
        queryTable[0].EntryContext = &registrySize;

        Status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE, DISK_REGISTRY_KEY_W,
                                        queryTable, &registry, NULL);

        if( NT_SUCCESS(Status) ) {

            diskRegistry = (PDISK_REGISTRY) ((PUCHAR)registry +
                                             registry->DiskInformationOffset);

            diskDescription = &diskRegistry->Disks[0];
            for (i = 0; i < diskRegistry->NumberOfDisks; i++) {
                for (j = 0; j < diskDescription->NumberOfPartitions; j++) {

                    diskPartition = &diskDescription->Partitions[j];
                    diskPartition->AssignDriveLetter = TRUE;
                    diskPartition->DriveLetter = (UCHAR)NULL;
                }

                diskDescription = (PDISK_DESCRIPTION) &diskDescription->
                                   Partitions[diskDescription->NumberOfPartitions];
            }

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Delete %ls on the setup hive. Status =  %lx \n", DISK_REGISTRY_KEY_W, Status));
            ZwDeleteKey(KeyHandle);
            ZwClose(KeyHandle);

            INIT_OBJA(&Obja,&UnicodeString,DISK_REGISTRY_KEY_W);
            Obja.RootDirectory = NULL;
            Status = ZwCreateKey(&KeyHandle,
                                 READ_CONTROL | KEY_SET_VALUE,
                                 //KEY_ALL_ACCESS,
                                 &Obja,
                                 0,
                                 NULL,
                                 REG_OPTION_NON_VOLATILE,
                                 &Disposition
                                 );

            if( NT_SUCCESS( Status ) ) {
                ZwClose(KeyHandle);
            }

            Status = RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                           DISK_REGISTRY_KEY_W,
                                           L"Information",
                                           REG_BINARY,
                                           registry,
                                           registrySize);

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Wrote Information in %ls. Status =  %lx \n", DISK_REGISTRY_KEY_W, Status));
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: No Information found in DISK registry.\n"));
            ZwDeleteKey(KeyHandle);
            ZwClose(KeyHandle);
        }
    }
#endif //NEC98
}


NTSTATUS
SpDiskRegistryQueryRoutineNec98(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )

/*++

Routine Description:

    This routine is a query routine for the disk registry entry.  It allocates
    space for the disk registry and copies it to the given context.

Arguments:

    ValueName       - Supplies the name of the registry value.

    ValueType       - Supplies the type of the registry value.

    ValueData       - Supplies the data of the registry value.

    ValueLength     - Supplies the length of the registry value.

    Context         - Returns the disk registry entry.

    EntryContext    - Returns the disk registry size.

Return Value:

    NTSTATUS

--*/

{
#if defined(NEC_98) //NEC98
    PVOID                   p;
    PDISK_CONFIG_HEADER*    reg;
    PULONG                  size;

    p = ExAllocatePool(PagedPool, ValueLength);
    if (!p) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(p, ValueData, ValueLength);

    reg = (PDISK_CONFIG_HEADER*) Context;
    *reg = (PDISK_CONFIG_HEADER) p;

    size = (PULONG) EntryContext;
    if (size) {
        *size = ValueLength;
    }

#endif //NEC98
    return STATUS_SUCCESS;
}

BOOL
SpDetermineBootPartitionEnumNec98(
    IN PPARTITIONED_DISK Disk,
    IN PDISK_REGION Region,
    IN ULONG_PTR Context
    )

/*++

Routine Description:

    Callback routine passed to SpEnumDiskRegions.

Arguments:

    Region - a pointer to a disk region returned by SpEnumDiskRegions
    Ignore - ignored parameter

Return Value:

    TRUE - to continue enumeration
    FALSE - to end enumeration

--*/

{
    WCHAR DeviceName[256];

    SpNtNameFromRegion(
        Region,
        DeviceName,
        MAX_PATH * sizeof(WCHAR),
        PartitionOrdinalOnDisk
        );

    if( !_wcsicmp(DeviceName,NtBootDevicePath)) {

        *(PDISK_REGION *)Context = Region;

        return FALSE;
    }

    return TRUE;
}
//end NEC98


NTSTATUS
SpProcessUnsupDrvInfFile(
    IN  PVOID InfHandle
    )

/*++

Routine Description:

    Process the [AddReg] section of migrate.inf.
    The keys are created on the setup hive.

Arguments:

    InfHandle - Handle to migrate.inf file.

Return Value:

    Status code indicating outcome.

--*/

{
    NTSTATUS Status;
    NTSTATUS SavedStatus = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HANDLE  SystemHiveRoot;
    PWSTR   KeyPath = L"\\registry\\machine\\system";
    ULONG   i;
    PWSTR   p, q;

    //
    // Verify arguments
    //
    if (!InfHandle) {
        KdPrintEx((DPFLTR_SETUP_ID, 
            DPFLTR_ERROR_LEVEL, 
            "SETUP: Invalid argument to SpProcessUnsupDrvInfFile(%p) \n",
            InfHandle));    
            
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Open a handle to HKEY_LOCAL_MACHINE\System on the setup hive
    //
    INIT_OBJA(&Obja,&UnicodeString,KeyPath);
    Obja.RootDirectory = NULL;

    Status = ZwOpenKey(&SystemHiveRoot,KEY_ALL_ACCESS,&Obja);
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ls on the setup hive. Status =  %lx \n", KeyPath, Status));
        return( Status );
    }


    for( i = 0;
         ((p = SpGetSectionLineIndex( InfHandle,
                                      L"Devices",
                                      i,
                                      0 )) != NULL);
         i++ ) {

        wcscpy( TemporaryBuffer, L"AddReg." );
        wcscat( TemporaryBuffer, p );
        q = SpDupStringW( ( PWSTR )TemporaryBuffer );
        Status = SpProcessAddRegSection( InfHandle,
                                         q,
                                         SystemHiveRoot,
                                         NULL,
                                         NULL,
                                         NULL );
        if( !NT_SUCCESS(Status) ) {
            if( SavedStatus == STATUS_SUCCESS ) {
                SavedStatus = Status;
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Unable to process section %ls in driver.inf. Status =  %lx \n", q, Status));
            }
        }
        SpMemFree( q );
    }

    ZwClose( SystemHiveRoot );
    return( Status );
}


NTSTATUS
SpCheckForDockableMachine(
    )

/*++

Routine Description:

    This routine attempts to determine if the machine is "dockable" (laptops),
    and set the flag DockableMachine appropriately.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HANDLE  hKey;
    PWSTR   KeyPath = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\IDConfigDB\\CurrentDockInfo";
    PWSTR   ValueName = L"DockingState";
    ULONG   ResultLength;
    DWORD   DockingState;

    Status = STATUS_SUCCESS;
    //
    //  If we have already determined if the machine is dockable, then just return
    //  This is because some machine will have the info in the registry already set prior to pnp
    //  notification, and some machines won't. So this function is always called twice.
    //
    if( !DockableMachine ) {
        //
        //  Open a the key in the setup hive that contains the docking information
        //
        INIT_OBJA(&Obja,&UnicodeString,KeyPath);
        Obja.RootDirectory = NULL;

        Status = ZwOpenKey(&hKey,KEY_READ,&Obja);
        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ls on the setup hive. Status =  %lx \n", KeyPath, Status));
            return( Status );
        }

        RtlInitUnicodeString(&UnicodeString,ValueName);
        Status = ZwQueryValueKey( hKey,
                                  &UnicodeString,
                                  KeyValuePartialInformation,
                                  TemporaryBuffer,
                                  sizeof(TemporaryBuffer),
                                  &ResultLength );

        ZwClose(hKey);

        if( !NT_SUCCESS(Status) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: ZwQueryValueKey() failed. Value name = %ls, Status = %lx \n", ValueName, Status));
            return( Status );
        }
        DockingState = *((PDWORD)(((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data));
        DockingState &= HW_PROFILE_DOCKSTATE_UNKNOWN;
        if( ( DockingState == HW_PROFILE_DOCKSTATE_UNDOCKED ) ||
            ( DockingState == HW_PROFILE_DOCKSTATE_DOCKED ) ) {
            DockableMachine = TRUE;
        } else {
            DockableMachine = FALSE;
        }
    }
    return( Status );
}


VOID
SpCheckForBadBios(
    )

/*++

Routine Description:

    Determine whether the bios of the machine supports NT, by checking the
    registry value "BadBios" on \Registry\Machine\System\CurrentControlSet\Services\Setup.
    If this value exists and it is set to 1, then we stop the installation. Otherwise, we
    assume that the bios on this machine is fine.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HANDLE  hKey;
    PWSTR   KeyPath = L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\setupdd";
    PWSTR   ValueName = L"BadBios";
    ULONG   ResultLength;
    DWORD   BadBios;

    Status = STATUS_SUCCESS;

    //
    //  Open a the setup key in the setup hive
    //
    INIT_OBJA(&Obja,&UnicodeString,KeyPath);
    Obja.RootDirectory = NULL;

    Status = ZwOpenKey(&hKey,KEY_READ,&Obja);
    if( !NT_SUCCESS( Status ) ) {
        //
        //  If we can't open the key, then assume the BIOS is fine.
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ls on the setup hive. Status =  %lx \n", KeyPath, Status));
        return;
    }

    RtlInitUnicodeString(&UnicodeString,ValueName);
    Status = ZwQueryValueKey( hKey,
                              &UnicodeString,
                              KeyValuePartialInformation,
                              TemporaryBuffer,
                              sizeof(TemporaryBuffer),
                              &ResultLength );

    ZwClose(hKey);

    if( !NT_SUCCESS(Status) ) {
        //
        //  If we can't query the value, assume that the BIOS is fine
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: ZwQueryValueKey() failed. Value name = %ls, Status = %lx \n", ValueName, Status));
        return;
    }
    BadBios = *((PDWORD)(((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data));
    if( BadBios ) {
        //
        //  If BadBios is anything other then 0, then stop the installation
        //

        SpStartScreen( SP_SCRN_BAD_BIOS,
                       3,
                       HEADER_HEIGHT+1,
                       FALSE,
                       FALSE,
                       DEFAULT_ATTRIBUTE );

        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);

        SpInputDrain();
                while(SpInputGetKeypress() != KEY_F3) ;

        SpDone(0,FALSE,TRUE);
    }
    return;
}

NTSTATUS
SpCreateDriverRegistryEntries(
    IN PHARDWARE_COMPONENT  DriverList
    )
/*++

Routine Description:

    Creates the specified registry keys & values for the
    thirdy party (OEM) drivers

Arguments:

    DriverList : List of OEM drivers loaded for which the
                 keys need to be created

Return Value:

    STATUS_SUCCESS if successful, otherwise appropriate
    error code.

--*/
{
    NTSTATUS LastError = STATUS_SUCCESS;
    PHARDWARE_COMPONENT CurrNode;
    NTSTATUS Status = DriverList ?
                STATUS_SUCCESS : STATUS_INVALID_PARAMETER;

    for (CurrNode = DriverList; CurrNode; CurrNode = CurrNode->Next) {
        if (CurrNode->ThirdPartyOptionSelected) {
            PHARDWARE_COMPONENT_FILE CurrFile;

            for (CurrFile = CurrNode->Files;
                CurrFile;
                CurrFile = CurrFile->Next) {

                if ((CurrFile->FileType == HwFileDriver) &&
                    CurrFile->ConfigName && CurrFile->RegistryValueList) {

                    WCHAR DriverKeyName[128];
                    WCHAR DriverName[32];
                    PWSTR DriverExt;
                    HANDLE hDriverKey = NULL;
                    UNICODE_STRING UniDriverKeyName;
                    OBJECT_ATTRIBUTES ObjAttrs;
                    PHARDWARE_COMPONENT_REGISTRY CurrEntry;

                    wcscpy(DriverName, CurrFile->Filename);
                    DriverExt = wcsrchr(DriverName, L'.');

                    if (DriverExt) {
                        *DriverExt = UNICODE_NULL;
                    }

                    //
                    // Note : We use driver name, instead of ConfigName for
                    // subkey name to take care of the case where ConfigName
                    // is different from DriverName
                    //

                    wcscpy(DriverKeyName,
                        L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\");

                    wcscat(DriverKeyName, DriverName);

                    RtlInitUnicodeString(&UniDriverKeyName,
                        DriverKeyName);

                    InitializeObjectAttributes(&ObjAttrs,
                        &UniDriverKeyName,
                        OBJ_CASE_INSENSITIVE,
                        NULL,
                        NULL);


                    Status = ZwCreateKey(&hDriverKey,
                                KEY_ALL_ACCESS,
                                &ObjAttrs,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                NULL);

                    if (NT_SUCCESS(Status) && hDriverKey) {
                        for (CurrEntry = CurrFile->RegistryValueList;
                            CurrEntry;
                            CurrEntry = CurrEntry->Next) {

                            PWSTR   SubKey = CurrEntry->KeyName;

                            if (SubKey && !*SubKey) {
                                SubKey = NULL;
                            }

                            Status = SpOpenSetValueAndClose(
                                        hDriverKey,
                                        SubKey,
                                        CurrEntry->ValueName,
                                        CurrEntry->ValueType,
                                        CurrEntry->Buffer,
                                        CurrEntry->BufferSize);

                            if (!NT_SUCCESS(Status)) {
                                LastError = Status;

                                KdPrintEx((DPFLTR_SETUP_ID,
                                    DPFLTR_ERROR_LEVEL,
                                    "SETUP:SpCreateDriverRegistryEntries() :"
                                    " unable to set %ws (%lx)\n",
                                    CurrEntry->ValueName,
                                    Status));
                            }

                        }

                        ZwClose(hDriverKey);
                    } else {
                        LastError = Status;
                    }
                }
            }
        }
    }

    if (!NT_SUCCESS(LastError)) {
        Status = LastError;
    }

    return Status;
}


BOOL
SpRememberMigratedDrivers (
    OUT     PLIST_ENTRY List,
    IN      PDETECTED_DEVICE SetupldrList
    )
{
    PSP_MIG_DRIVER_ENTRY MigEntry;
    BOOL b = TRUE;

    while (SetupldrList) {

        if (SetupldrList->MigratedDriver) {

            MigEntry = SpMemAlloc(sizeof (*MigEntry));
            if (MigEntry) {
                MigEntry->BaseDllName = SpToUnicode(SetupldrList->BaseDllName);
                if (MigEntry->BaseDllName) {
                    InsertTailList (List, &MigEntry->ListEntry);
                } else {
                    SpMemFree (MigEntry);
                    b = FALSE;
                }
            } else {
                b = FALSE;
            }
        }

        SetupldrList = SetupldrList->Next;
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spstrings.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    spstrings.c

Abstract:

    from windows\winstate\cobra\utils\main\strings.c

Author:

    Jay Krell (a-JayK) November 2000

Revision History:


--*/

#include "spprecmp.h"
#include "spstrings.h"
#include "spwin.h"
#include "spcab.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spstring.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spstring.h

Abstract:

    Header file for functions to manipulate strings.
    These functions would ordinarily be performed by C Runtime routines
    except that we want to avoid linking this device driver with
    the kernel crt.

Author:

    Ted Miller (tedm) 15-Jan-1994

Revision History:

--*/


//
// Character types.
//
#define _SP_NONE      0x00
#define _SP_SPACE     0x01
#define _SP_DIGIT     0x02
#define _SP_XDIGIT    0x04
#define _SP_UPPER     0x08
#define _SP_LOWER     0x10

//
// Optimize the size of the types array by noting that no characters
// above 'z' have any attributes we care about.
//
#define CTSIZE ('z'+1)
extern UCHAR _SpCharTypes[CTSIZE];

//
// Be careful using these as they evaluate their arguments more than once.
//
#define SpIsSpace(c)    (((c) < CTSIZE) ? (_SpCharTypes[(c)] & _SP_SPACE)  : FALSE)
#define SpIsDigit(c)    (((c) < CTSIZE) ? (_SpCharTypes[(c)] & _SP_DIGIT)  : FALSE)
#define SpIsXDigit(c)   (((c) < CTSIZE) ? (_SpCharTypes[(c)] & _SP_XDIGIT) : FALSE)
#define SpIsUpper(c)    (((c) < CTSIZE) ? (_SpCharTypes[(c)] & _SP_UPPER)  : FALSE)
#define SpIsLower(c)    (((c) < CTSIZE) ? (_SpCharTypes[(c)] & _SP_LOWER)  : FALSE)
#define SpIsAlpha(c)    (SpIsUpper(c) || SpIsLower(c))
#define SpToUpper(c)    ((WCHAR)(SpIsLower(c) ? ((c)-(L'a'-L'A')) : (c)))
#define SpToLower(c)    ((WCHAR)(SpIsUpper(c) ? ((c)+(L'a'-L'A')) : (c)))

VOID
SpStringToUpper(
    IN PWSTR String
    );

VOID
SpStringToLower(
    IN PWSTR String
    );

PWCHAR
SpFindCharFromListInString(
    PWSTR String,
    PWSTR CharList
    );

unsigned
SpMultiByteStringToUnsigned(
    IN  PUCHAR  String,
    OUT PUCHAR *CharThatStoppedScan OPTIONAL
    );

LONG
SpStringToLong(
    IN  PWSTR     String,
    OUT PWCHAR   *EndOfValue,
    IN  unsigned  Radix
    );

PCHAR
SpConvertMultiSzWstrToStr(
    IN PWCHAR Source,
    IN ULONG Length
    );

PWCHAR
SpConvertMultiSzStrToWstr(
    IN PCHAR Source,
    IN ULONG Length
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spswitch.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    spswitch.h

Abstract:

    Macros & Functions to switch between old and 
    new partitioning engine in textmode.

    NEW_PARTITION_ENGINE forces new partition engine
    code to be used for both MBR and GPT disks.

    GPT_PARTITION_ENGINE forces new partition engine
    code to be used for GPT disks and old partition
    engine code for MBR disks.

    OLD_PARTITION_ENGINE forces the old partition
    engine to used for MBR disks. This option cannot
    handle GPT disks correctly.

    Note : 
    If none of the NEW_PARTITION_ENGINE, 
    OLD_PARTITION_ENGINE or GPT_PARTITION_ENGINE are
    defined, then by default NEW_PARTITION_ENGINE is
    used.

Author:

    Vijay Jayaseelan    (vijayj)    18 March 2000

Revision History:

--*/


#ifndef _SPSWITCH_H_
#define _SPSWITCH_H_

#ifdef NEW_PARTITION_ENGINE

#undef OLD_PARTITION_ENGINE
#undef GPT_PARTITION_ENGINE

#else

#ifdef OLD_PARTITION_ENGINE

#undef NEW_PARTITION_ENGINE
#undef GPT_PARTITION_ENGINE

#else

#ifndef GPT_PARTITION_ENGINE

#pragma message( "!!! Defaulting to NEW_PARTITION_ENGINE !!!" )

#define NEW_PARTITION_ENGINE    1

#endif // !GPT_PARTITION_ENGINE

#endif // OLD_PARTITION_ENGINE

#endif // NEW_PARTITION_ENGINE

#if defined(NEW_PARTITION_ENGINE) || defined(GPT_PARTITION_ENGINE)
#include "sppart3.h"
#endif

#endif // for _SPSWITCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spstrings.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    spstrings.h

Abstract:

    from windows\winstate\cobra\utils\inc\strings.h

Author:

    Jay Krell (a-JayK) November 2000

Revision History:


--*/

#pragma once
#include <string.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spsysprp.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spsysprp.h

Abstract:

    Public header file for setup of sys prep images

Author:

    Sean Selitrennikoff (v-seasel) 16-Jun-1998

Revision History:

--*/


#ifndef _SPSYSPREP_DEFN_
#define _SPSYSPREP_DEFN_

#include <remboot.h>
#include <oscpkt.h>

extern NET_CARD_INFO RemoteSysPrepNetCardInfo;

typedef struct _MIRROR_VOLUME_INFO_MEMORY {
    WCHAR   DriveLetter;
    UCHAR   PartitionType;
    BOOLEAN PartitionActive;
    BOOLEAN IsBootDisk;
    BOOLEAN CompressedVolume;
    ULONG   DiskNumber;
    ULONG   PartitionNumber;
    ULONG   DiskSignature;
    ULONG   BlockSize;
    ULONG   LastUSNMirrored;
    ULONG   FileSystemFlags;
    WCHAR   FileSystemName[16];
    PWCHAR  VolumeLabel;
    PWCHAR  OriginalArcName;
    LARGE_INTEGER DiskSpaceUsed;
    LARGE_INTEGER StartingOffset;
    LARGE_INTEGER PartitionSize;
    PDISK_REGION CreatedRegion;
} MIRROR_VOLUME_INFO_MEMORY, *PMIRROR_VOLUME_INFO_MEMORY;

typedef struct _MIRROR_CFG_INFO_MEMORY {
    ULONG   NumberVolumes;
    MIRROR_VOLUME_INFO_MEMORY Volumes[1];
} MIRROR_CFG_INFO_MEMORY, *PMIRROR_CFG_INFO_MEMORY;

extern PUCHAR RemoteIMirrorFilePath;

VOID
SpInstallSysPrepImage(
    IN HANDLE SetupSifHandle,
    IN HANDLE WinntSifHandle,
    IN PMIRROR_CFG_INFO_FILE pFileData,
    IN PMIRROR_CFG_INFO_MEMORY pMemoryData
    );

NTSTATUS
SpFixupThirdPartyComponents(
    IN PVOID        SifHandle,
    IN PWSTR        ThirdPartySourceDevicePath,
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR        Sysroot,
    IN PDISK_REGION SystemPartitionRegion,
    IN PWSTR        SystemPartitionDirectory
    );

BOOLEAN
SpReadIMirrorFile(
    OUT PMIRROR_CFG_INFO_FILE *ppFileData,
    IN PCHAR pszIMirrorFilePath
    );

BOOLEAN
SpFindMirrorDataFile(
    IN  PCWSTR SrcPath,
    IN  PFILE_BOTH_DIR_INFORMATION  FileInfo,
    OUT PULONG ReturnData,
    IN  PVOID *ppFileData
    );

BOOLEAN
SpDetermineDiskLayout(
    IN PMIRROR_CFG_INFO_FILE pFileData,
    OUT PMIRROR_CFG_INFO_MEMORY *pMemoryData
    );

BOOLEAN
SpFixupLocalDisks(
    IN HANDLE SifHandle,
    OUT PDISK_REGION *InstallRegion,
    OUT PDISK_REGION *SystemPartitionRegion,
    IN PWSTR SetupSourceDevicePath,
    IN PWSTR DirectoryOnSetupSource,
    IN PMIRROR_CFG_INFO_MEMORY pMemoryData,
    IN BOOLEAN UseWholeDisk
    );

BOOLEAN
SpCopyMirrorDisk(
    PMIRROR_CFG_INFO_FILE pFileData,
    ULONG cDisk
    );

NTSTATUS
SpPatchSysPrepImage(
    IN HANDLE SetupSifHandle,
    IN HANDLE WinntSifHandle,
    IN PMIRROR_CFG_INFO_FILE pFileData,
    IN PMIRROR_CFG_INFO_MEMORY pMemoryData
    );

NTSTATUS
SpPatchBootIni(
    IN PWCHAR BootIniPath,
    IN PMIRROR_CFG_INFO_MEMORY pMemoryData
    );

NTSTATUS
SpCopyNicFiles(
    IN PWCHAR SetupPath,
    IN PWCHAR DestPath
    );

NTSTATUS
SpSysPrepNicRcvFunc(
    PVOID DataBuffer,
    ULONG DataBufferLength
    );

VOID
SpSysPrepFailure(
    ULONG ReasonNumber,
    PVOID Parameter1,
    PVOID Parameter2
    );

NTSTATUS
SpSysPrepSetExtendedInfo (
    PWCHAR Source,
    PWCHAR Dest,
    BOOLEAN Directory,
    BOOLEAN RootDir
    );

NTSTATUS
SpCopyEAsAndStreams (
    PWCHAR SourceFile,
    HANDLE SourceHandle,
    PWCHAR TargetFile,
    HANDLE TargetHandle,
    BOOLEAN Directory
    );

#endif // ndef _SPSYSPREP_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spswitch.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    spswitch.h

Abstract:

    Macros & Functions to switch between old and 
    new partitioning engine in textmode.

    NEW_PARTITION_ENGINE forces new partition engine
    code to be used for both MBR and GPT disks.

    GPT_PARTITION_ENGINE forces new partition engine
    code to be used for GPT disks and old partition
    engine code for MBR disks.

    OLD_PARTITION_ENGINE forces the old partition
    engine to used for MBR disks. This option cannot
    handle GPT disks.

    Note : 
    If none of the NEW_PARTITION_ENGINE, 
    OLD_PARTITION_ENGINE or GPT_PARTITION_ENGINE macro
    is defined, then by default NEW_PARTITION_ENGINE is
    used.

Author:

    Vijay Jayaseelan    (vijayj)    18 March 2000

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop


#ifdef NEW_PARTITION_ENGINE

//
// Switching stubs for NEW_PARTITION_ENGINE
//

NTSTATUS
SpPtPrepareDisks(
    IN  PVOID         SifHandle,
    OUT PDISK_REGION *InstallRegion,
    OUT PDISK_REGION *SystemPartitionRegion,
    IN  PWSTR         SetupSourceDevicePath,
    IN  PWSTR         DirectoryOnSetupSource,
    IN  BOOLEAN       RemoteBootRepartition
    )
{
    return SpPtnPrepareDisks(SifHandle,
                    InstallRegion,
                    SystemPartitionRegion,
                    SetupSourceDevicePath,
                    DirectoryOnSetupSource,
                    RemoteBootRepartition);
}

NTSTATUS
SpPtInitialize(
    VOID
    )
{
    return SpPtnInitializeDiskDrives();
}


PDISK_REGION
SpPtValidSystemPartition(
    VOID
    )
{
    return SpPtnValidSystemPartition();
}


PDISK_REGION
SpPtValidSystemPartitionArc(
    IN PVOID SifHandle,
    IN PWSTR SetupSourceDevicePath,
    IN PWSTR DirectoryOnSetupSource
    )
{
    return SpPtnValidSystemPartitionArc(SifHandle,
                    SetupSourceDevicePath,
                    DirectoryOnSetupSource,
                    TRUE);
}


BOOLEAN
SpPtDoCreate(
    IN  PDISK_REGION  pRegion,
    OUT PDISK_REGION *pActualRegion, OPTIONAL
    IN  BOOLEAN       ForNT,
    IN  ULONGLONG     DesiredMB OPTIONAL,
    IN  PPARTITION_INFORMATION_EX PartInfo OPTIONAL,
    IN  BOOLEAN       ConfirmIt
    )
{
    return SpPtnDoCreate(pRegion,
                        pActualRegion,
                        ForNT,
                        DesiredMB,
                        PartInfo,
                        ConfirmIt);
}


VOID
SpPtDoDelete(
    IN PDISK_REGION pRegion,
    IN PWSTR        RegionDescription,
    IN BOOLEAN      ConfirmIt
    )
{
    SpPtnDoDelete(pRegion,
                RegionDescription,
                ConfirmIt);
}


ULONG
SpPtGetOrdinal(
    IN PDISK_REGION         Region,
    IN PartitionOrdinalType OrdinalType
    )
{
    return SpPtnGetOrdinal(Region, OrdinalType);
}


VOID
SpPtGetSectorLayoutInformation(
    IN  PDISK_REGION Region,
    OUT PULONGLONG   HiddenSectors,
    OUT PULONGLONG   VolumeSectorCount
    )
{
    SpPtnGetSectorLayoutInformation(Region,
                            HiddenSectors,
                            VolumeSectorCount);
}


BOOLEAN
SpPtCreate(
    IN  ULONG         DiskNumber,
    IN  ULONGLONG     StartSector,
    IN  ULONGLONG     SizeMB,
    IN  BOOLEAN       InExtended,
    IN  PPARTITION_INFORMATION_EX PartInfo,
    OUT PDISK_REGION *ActualDiskRegion OPTIONAL
    )
{
    return SpPtnCreate(DiskNumber, 
                    StartSector,
                    0,              // SizeInSectors: Used only in ASR
                    SizeMB,
                    InExtended,
                    TRUE,          // AlignToCylinder
                    PartInfo,
                    ActualDiskRegion);
}

BOOLEAN
SpPtDelete(
    IN ULONG   DiskNumber,
    IN ULONGLONG  StartSector
    )
{
    return SpPtnDelete(DiskNumber, StartSector);
}

BOOL
SpPtIsSystemPartitionRecognizable(
    VOID
    )
{
    return SpPtnIsSystemPartitionRecognizable();
}


VOID
SpPtMakeRegionActive(
    IN PDISK_REGION Region
    )
{
    SpPtnMakeRegionActive(Region);
}


NTSTATUS
SpPtCommitChanges(
    IN  ULONG    DiskNumber,
    OUT PBOOLEAN AnyChanges
    )
{
    return SpPtnCommitChanges(DiskNumber, AnyChanges);
}

VOID
SpPtDeletePartitionsForRemoteBoot(
    PPARTITIONED_DISK PartDisk,
    PDISK_REGION StartRegion,
    PDISK_REGION EndRegion,
    BOOLEAN Extended
    )
{
    SpPtnDeletePartitionsForRemoteBoot(PartDisk,
                StartRegion,
                EndRegion,
                Extended);
}

VOID
SpPtLocateSystemPartitions(
    VOID
    )
{
    SpPtnLocateSystemPartitions();
}

#else

#ifdef GPT_PARTITION_ENGINE

//
// Switching stubs for GPT_PARTITION_ENGINE
//

NTSTATUS
SpPtPrepareDisks(
    IN  PVOID         SifHandle,
    OUT PDISK_REGION *InstallRegion,
    OUT PDISK_REGION *SystemPartitionRegion,
    IN  PWSTR         SetupSourceDevicePath,
    IN  PWSTR         DirectoryOnSetupSource,
    IN  BOOLEAN       RemoteBootRepartition
    )
{
    return SpPtnPrepareDisks(SifHandle,
                    InstallRegion,
                    SystemPartitionRegion,
                    SetupSourceDevicePath,
                    DirectoryOnSetupSource,
                    RemoteBootRepartition);
}

VOID
SpPtMakeRegionActive(
    IN PDISK_REGION Region
    )
{
    SpPtnMakeRegionActive(Region);
}

PDISK_REGION
SpPtValidSystemPartitionArc(
    IN PVOID SifHandle,
    IN PWSTR SetupSourceDevicePath,
    IN PWSTR DirectoryOnSetupSource
    )
{
    return SpPtnValidSystemPartitionArc(SifHandle,
                        SetupSourceDevicePath,
                        DirectoryOnSetupSource,
                        TRUE);
}

BOOL
SpPtIsSystemPartitionRecognizable(
    VOID
    )
{
    return SpPtnIsSystemPartitionRecognizable();
}

VOID
SpPtLocateSystemPartitions(
    VOID
    )
{
    SpPtnLocateSystemPartitions();
}

#endif

#endif // NEW_PARTITION_ENGINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spsysprp.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spsetup.c

Abstract:

    Module for supporing installation of SysPrep images from a remote share

Author:

    Sean Selitrennikoff (v-seasel) 6-10-1998

--*/

#include "spprecmp.h"
#pragma hdrstop
#include "spcmdcon.h"
#include <remboot.h>
#include <oscpkt.h>
#include <regstr.h>

NET_CARD_INFO RemoteSysPrepNetCardInfo;
PVOID pGlobalResponsePacket = NULL;
ULONG GlobalResponsePacketLength = 0;

#define SYSPREP_PARTITION_SLOP 10       // in percent

VOID
SpInstallSysPrepImage(
    IN HANDLE SetupSifHandle,
    IN HANDLE WinntSifHandle,
    IN PMIRROR_CFG_INFO_FILE pFileData,
    IN PMIRROR_CFG_INFO_MEMORY pMemoryData
    )

/*++

Routine Description:

    Main routine for installing a SysPrep images from a remote share.

Arguments:

    WinntSifHandle - Handle to the SIF file.

    pFileData - The IMirror.dat data, as saved in the file.

    pMemoryData - The IMirror.dat data, as modified to match this computer.

Return Value:

    None.  Doesn't return on fatal failure.

--*/

{
    DWORD cDisk;
    NTSTATUS Status;

    //
    // Right here we should check to see if any patching is going to be needed
    // by opening the hive files on the server and checking with the passed in
    // PCI ids.  If patching is necessary, and the SIF file contains a pointer
    // to a CD image that matches the SysPrep image, then we call off to BINL
    // to find the appropriate drivers.  If BINL does not return an error, then
    // we assume that later we will be able to do the patch (after the file copy
    // below).
    //
    // If it looks like the patch will fail, either because there is no pointer
    // to a CD image, or BINL returned an error, then we present the user with
    // a screen telling them that any hardware differences between their machine
    // and the SysPrep image may result in an unbootable system.  They may choose
    // to continue the setup, or quit.
    //
    // NOTE: seanse - Put all of the above here.

    //
    // For each disk, copy all the files to the local store.
    //
    for (cDisk = 0; cDisk < pFileData->NumberVolumes; cDisk++) {
        if (!SpCopyMirrorDisk(pFileData, cDisk)) {
            goto CleanUp;
        }
    }

    //
    // Patch up the SysPrep image.
    //
    Status = SpPatchSysPrepImage(   SetupSifHandle,
                                    WinntSifHandle,
                                    pFileData,
                                    pMemoryData);

    if (!NT_SUCCESS(Status)) {

        ULONG ValidKeys[2] = { KEY_F3, 0 };
        ULONG Mnemonics[2] = { MnemonicContinueSetup,0 };

        while (1) {

            if (Status == STATUS_INVALID_PARAMETER) {

                SpStartScreen(
                    SP_SCRN_SYSPREP_PATCH_MISSING_OS,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE
                    );

            } else {

                SpStartScreen(
                    SP_SCRN_SYSPREP_PATCH_FAILURE,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE
                    );
            }

            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_C_EQUALS_CONTINUE_SETUP,
                SP_STAT_F3_EQUALS_EXIT,
                0
                );

            switch(SpWaitValidKey(ValidKeys,NULL,Mnemonics)) {
            case KEY_F3:
                SpConfirmExit();
                break;
            default:
                //
                // must be c=continue
                //
                goto CleanUp;
            }

        }

    }

CleanUp:

    return;

}

NTSTATUS
SpFixupThirdPartyComponents(
    IN PVOID        SifHandle,
    IN PWSTR        ThirdPartySourceDevicePath,
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR        Sysroot,
    IN PDISK_REGION SystemPartitionRegion,
    IN PWSTR        SystemPartitionDirectory
    )

/*++

Routine Description:

    This routine will take care of installing any 3rd party drivers detected during setupldr.
    We have to take care of this here because the normal code path for textmode setup has
    been bypassed in lieu of installing a sysprep'd image.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    ThirdPartySourceDevicePath - path to 3rd party install files.

    NtPartitionRegion - region where installation is located.

    Sysroot - string containing %windir% (with no drive).

    SystemPartitionRegion - region where system partition is located.

    SystemPartitionDirectory - directory on the system partition where
                               system-specific files are located (should
                               be NULL for non-ARC machines)

Return Value:

    NTSTATUS which will indicate success or failure.

--*/

{
NTSTATUS        Status = STATUS_SUCCESS;
PWSTR           NtPartition = NULL,
                SystemPartition = NULL;
PDISK_FILE_LIST DiskFileLists;
ULONG           DiskCount;
HANDLE          hKeyControlSetServices;
UNICODE_STRING  UnicodeString1;
UNICODE_STRING  UnicodeString2;
UNICODE_STRING  UnicodeString;
WCHAR           Path[MAX_PATH];
HANDLE          DstHandle = NULL;
DWORD           Size, Number;
PVOID           Buffer = NULL;
OBJECT_ATTRIBUTES Obj;
OBJECT_ATTRIBUTES DstObj;

    //
    // See if there's anything for us to do.
    //
    if( PreinstallScsiHardware == NULL ) {
        return STATUS_SUCCESS;
    }


    //
    // =================
    // Install the files.
    // =================
    //

    //
    // Get the device path of the nt partition.
    //
    SpNtNameFromRegion( NtPartitionRegion,
                        TemporaryBuffer,
                        sizeof(TemporaryBuffer),
                        PartitionOrdinalCurrent );
    NtPartition = SpDupStringW(TemporaryBuffer);

    //
    // Get the device path of the system partition.
    //
    if (SystemPartitionRegion != NULL) {
        SpNtNameFromRegion( SystemPartitionRegion,
                            TemporaryBuffer,
                            sizeof(TemporaryBuffer),
                            PartitionOrdinalCurrent );
        SystemPartition = SpDupStringW(TemporaryBuffer);
    } else {
        SystemPartition = NULL;
    }

    //
    // Generate media descriptors for the source media.
    //
    SpInitializeFileLists( SifHandle,
                           &DiskFileLists,
                           &DiskCount );

    SpCopyThirdPartyDrivers( ThirdPartySourceDevicePath,
                             NtPartition, 
                             Sysroot,
                             SystemPartition,
                             SystemPartitionDirectory,
                             DiskFileLists,
                             DiskCount );


    //
    // =================
    // Set the registry.
    // =================
    //

    //
    // We need to open the hive of the target install, not
    // our own.  Get a path to the system hive.
    //
    wcscpy(Path, NtPartition);
    SpConcatenatePaths(Path, Sysroot);
    SpConcatenatePaths(Path, L"system32\\config\\system");

    //
    // Load him up.
    //
    INIT_OBJA(&Obj, &UnicodeString2, Path);
    INIT_OBJA(&DstObj, &UnicodeString1, L"\\Registry\\SysPrepReg");

    Status = ZwLoadKey(&DstObj, &Obj);

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpFixupThirdPartyComponents: ZwLoadKey to SysPrepReg failed %lx\n", Status));
        goto CleanUp0;
    }


    //
    // Now get path to services key in the SysPrep image
    //
    wcscpy(Path, L"\\Registry\\SysPrepReg");
    INIT_OBJA(&Obj, &UnicodeString2, Path);
    Status = ZwOpenKey(&DstHandle, KEY_READ, &Obj);

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpFixupThirdPartyComponents: ZwOpenKey of root SysPrepReg failed %lx\n", Status));
        goto CleanUp1;
    }

    //
    // Allocate a temporary buffer, then figure out which is the current control set.
    //
    Buffer = SpMemAlloc(1024 * 4);
    if( Buffer == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto CleanUp1;
    }

    Status = SpGetValueKey( DstHandle,
                            L"Select",
                            L"Current",
                            1024 * 4,
                            Buffer,
                            &Size );

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpFixupThirdPartyComponents: SpGetValueKey of Select\\Current failed %lx\n", Status));
        goto CleanUp1;
    }

    if ( (ULONG)(((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Type) != REG_DWORD ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpFixupThirdPartyComponents: SpGetValueKey of Select\\Current didn't return a REG_DWORD.\n"));
        goto CleanUp1;
    }

    Number = *((DWORD *)(((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data));

    ZwClose(DstHandle);
    DstHandle = NULL;



    //
    // We're ready to actually open CCS\Services key.
    //
    swprintf(Path,
             L"\\Registry\\SysPrepReg\\ControlSet%03d\\Services",
             Number
            );
    INIT_OBJA(&Obj, &UnicodeString, Path);
    Status = ZwOpenKey(&DstHandle, KEY_ALL_ACCESS, &Obj);

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpFixupThirdPartyComponents: ZwOpenKey of SysPrepReg services failed %lx for %ws\n", Status,Path));
        goto CleanUp1;
    }

    //
    // Do it.
    //
    Status = SpThirdPartyRegistry(DstHandle);

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpFixupThirdPartyComponents: SpThirdPartyRegistry failed %lx\n", Status));
        goto CleanUp1;
    }


CleanUp1:
    ZwUnloadKey(&DstObj);

    if( Buffer ) {
        SpMemFree( Buffer );
    }

    if( DstHandle ) {
        ZwClose(DstHandle);
    }

CleanUp0:
    if( NtPartition ) {
        SpMemFree( NtPartition );
    }

    if( SystemPartition ) {
        SpMemFree( SystemPartition );
    }




    return Status;

}

BOOLEAN
SpReadIMirrorFile(
    OUT PMIRROR_CFG_INFO_FILE *ppFileData,
    IN PCHAR IMirrorFilePath
    )

/*++

Routine Description:

    This routine opens the file in IMirrorFilePath, allocates a buffer, copies the data
    into the buffer and returns the buffer.  This buffer needs to be freed later.

Arguments:

    ppFileData - If TRUE is returned, a pointer to an in-memory copy of the file.

    IMirrorFilePath - The UNC to the root directory containing all the IMirrorX directories.

Return Value:

    TRUE if successful, else it generates a fatal error.

--*/

{
    WCHAR wszRootDir[MAX_PATH];
    ULONG ulReturnData;

    mbstowcs(wszRootDir, IMirrorFilePath, strlen(IMirrorFilePath) + 1);

    *ppFileData = NULL;

    //
    // Enumerate thru all the files in the base directory looking for the IMirror data file.
    // If it is found, the callback function fills in pFileData.
    //
    if ((SpEnumFiles(wszRootDir, SpFindMirrorDataFile, &ulReturnData, (PVOID)ppFileData) == EnumFileError) ||
        (*ppFileData == NULL)) {

        SpSysPrepFailure( SP_SYSPREP_NO_MIRROR_FILE, wszRootDir, NULL );

        // shouldn't get here.
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
SpFindMirrorDataFile(
    IN  PCWSTR SrcPath,
    IN  PFILE_BOTH_DIR_INFORMATION  FileInfo,
    OUT PULONG ReturnData,
    IN  PVOID *ppFileData
    )

/*++

Routine Description:

    This routine is called by the file enumerator as a callback for
    each file or subdirectory found in the source directory.
    If FileInfo represents a file, then we skip it.
    If FileInfo represents a directory, then we search it for the IMirror data file.

Arguments:

    SrcPath - Absolute path to the source directory. This path should contain
              the path to the source device.

    FileInfo - supplies find data for a file in the source dir.

    ReturnData - receives an error code if an error occurs.

    ppFileData - If successful in finding the IMirror data file, this is a buffer which is
    a copy of the file.

Return Value:

    FALSE if we find the IMirror data file, else TRUE. (return value is used to continue
    the enumeration or not)

--*/

{
    PWSTR Temp1;
    PWSTR Temp2;
    ULONG ulLen;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle;

    if(!(FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
        return TRUE;
    }

    Handle = NULL;

    //
    // Build the path name to the IMirror data file
    //
    Temp1 = TemporaryBuffer + (sizeof(TemporaryBuffer) / sizeof(WCHAR) / 2);
    ulLen = FileInfo->FileNameLength/sizeof(WCHAR);

    wcsncpy(Temp1,FileInfo->FileName, ulLen);
    Temp1[ulLen] = 0;

    wcscpy(TemporaryBuffer, SrcPath);
    SpConcatenatePaths(TemporaryBuffer, Temp1);
    SpConcatenatePaths(TemporaryBuffer, IMIRROR_DAT_FILE_NAME);
    Temp2 = SpDupStringW(TemporaryBuffer);

    INIT_OBJA(&Obja, &UnicodeString, Temp2);

    Status = ZwCreateFile(&Handle,
                          FILE_GENERIC_READ,
                          &Obja,
                          &IoStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ,
                          FILE_OPEN,
                          FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0
                         );

    SpMemFree(Temp2);

    if(!NT_SUCCESS(Status)) {
        return TRUE;
    }

    Status = SpGetFileSize(Handle, &ulLen);

    if(!NT_SUCCESS(Status)) {
        ZwClose(Handle);
        return TRUE;
    }

    //
    // Now allocate memory and read in the file.
    //
    *ppFileData = SpMemAlloc(ulLen);

    Status = ZwReadFile(Handle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        *ppFileData,
                        ulLen,
                        0,
                        NULL
                        );

    if(!NT_SUCCESS(Status)) {
        SpMemFree(*ppFileData);
        *ppFileData = NULL;
        ZwClose(Handle);
        return TRUE;
    }

    ZwClose(Handle);
    return FALSE;
}

BOOLEAN
SpDetermineDiskLayout(
    IN PMIRROR_CFG_INFO_FILE pFileData,
    OUT PMIRROR_CFG_INFO_MEMORY *pMemoryData
    )
/*++

Routine Description:

    This routine takes the passed-in IMirror.dat file and produces a
    resulting memory structure indicating how the local disks should
    be partitioned.

Arguments:

    pFileData - A pointer to an in-memory copy of IMirror.Dat.

    pMemoryData - Returnes an allocated pointed to how the disks should
        be partitioned.

Return Value:

    TRUE if successful, else it generates a fatal error.

--*/
{
    PMIRROR_CFG_INFO_MEMORY memData;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    NTSTATUS Status;
    ULONG ResultLength;
    PKEY_BASIC_INFORMATION KeyInfo;
    PWSTR CurrentHalName, OriginalHalName;
    ULONG CurrentHalNameLength;
    ULONG i, j;
    ULONG diskNumber;
    PPARTITIONED_DISK pDisk;

    if (pFileData->MirrorVersion != IMIRROR_CURRENT_VERSION) {

        SpSysPrepFailure( SP_SYSPREP_INVALID_VERSION, NULL, NULL );
        return FALSE;
    }

    //
    // Check if the current HAL that textmode installed for this
    // system is different from the one that is running on this system
    // (note that this works because for remote install boots, setupldr
    // loads the real HAL, not the one from the short list of HALs
    // included on the boot floppy).
    //

    INIT_OBJA(&Obja, &UnicodeString, L"\\Registry\\Machine\\Hardware\\RESOURCEMAP\\Hardware Abstraction Layer");
    Status = ZwOpenKey(&Handle, KEY_READ, &Obja);
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpDetermineDiskLayout: ZwOpenKey of HAL key failed %lx\n", Status));
        SpSysPrepFailure( SP_SYSPREP_WRONG_HAL, NULL, NULL );
        return FALSE;
    }

    KeyInfo = (PKEY_BASIC_INFORMATION)TemporaryBuffer;
    Status = ZwEnumerateKey(Handle, 0, KeyBasicInformation, KeyInfo, sizeof(TemporaryBuffer), &ResultLength);

    ZwClose(Handle);

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpDetermineDiskLayout: ZwEnumerateKey of HAL key failed %lx\n", Status));
        SpSysPrepFailure( SP_SYSPREP_WRONG_HAL, NULL, NULL );
        return FALSE;
    }

    KeyInfo->Name[KeyInfo->NameLength / sizeof(WCHAR)] = L'\0';
    CurrentHalName = SpDupStringW(KeyInfo->Name);
    CurrentHalNameLength = KeyInfo->NameLength;

    OriginalHalName = (PWCHAR)(((PUCHAR)pFileData) + pFileData->HalNameOffset);

    if (!CurrentHalName || 
            (memcmp(OriginalHalName, CurrentHalName, CurrentHalNameLength) != 0)) {
            
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, 
                 "SpDetermineDiskLayout: HAL strings different, old <%ws> new <%ws>\n",
                 OriginalHalName,
                 CurrentHalName));
                 
        SpSysPrepFailure(
            SP_SYSPREP_WRONG_HAL,
            OriginalHalName,
            CurrentHalName);
            
        return FALSE;
    }

    //
    // For the moment, don't worry about the number of processors being
    // different. The HAL check will probably catch it, and if not it should
    // still work as long as the build is internally consistent, since we
    // don't replace any components right now. There are two error screens
    // defined for this case, SP_SYSPREP_WRONG_PROCESSOR_COUNT_UNI and
    // SP_SYSPREP_WRONG_PROCESSOR_COUNT_MULTI.
    //

    memData = SpMemAlloc(FIELD_OFFSET(MIRROR_CFG_INFO_MEMORY, Volumes[0]) +
                         (pFileData->NumberVolumes * sizeof(MIRROR_VOLUME_INFO_MEMORY)));

    memData->NumberVolumes = pFileData->NumberVolumes;
    for (i = 0; i < pFileData->NumberVolumes; i++) {

        memData->Volumes[i].DriveLetter = pFileData->Volumes[i].DriveLetter;
        memData->Volumes[i].PartitionType = pFileData->Volumes[i].PartitionType;
        memData->Volumes[i].PartitionActive = pFileData->Volumes[i].PartitionActive;
        memData->Volumes[i].IsBootDisk = pFileData->Volumes[i].IsBootDisk;
        memData->Volumes[i].CompressedVolume = pFileData->Volumes[i].CompressedVolume;
        diskNumber = pFileData->Volumes[i].DiskNumber;
        memData->Volumes[i].DiskNumber = diskNumber;
        memData->Volumes[i].PartitionNumber = pFileData->Volumes[i].PartitionNumber;
        memData->Volumes[i].DiskSignature = pFileData->Volumes[i].DiskSignature;
        memData->Volumes[i].BlockSize = pFileData->Volumes[i].BlockSize;
        memData->Volumes[i].LastUSNMirrored = pFileData->Volumes[i].LastUSNMirrored;
        memData->Volumes[i].FileSystemFlags = pFileData->Volumes[i].FileSystemFlags;

        wcscpy(memData->Volumes[i].FileSystemName, pFileData->Volumes[i].FileSystemName);
        memData->Volumes[i].VolumeLabel = SpDupStringW((PWCHAR)(((PUCHAR)pFileData) + pFileData->Volumes[i].VolumeLabelOffset));
        memData->Volumes[i].OriginalArcName = SpDupStringW((PWCHAR)(((PUCHAR)pFileData) + pFileData->Volumes[i].ArcNameOffset));

        memData->Volumes[i].DiskSpaceUsed = pFileData->Volumes[i].DiskSpaceUsed;
        memData->Volumes[i].StartingOffset = pFileData->Volumes[i].StartingOffset;
        memData->Volumes[i].PartitionSize = pFileData->Volumes[i].PartitionSize;

        //
        // Ensure that the required disk number actually exists, and that the
        // disk is online.
        //

        pDisk = &PartitionedDisks[diskNumber];
        if ((diskNumber >= HardDiskCount) ||
            (pDisk->HardDisk == NULL) ||
            (pDisk->HardDisk->Status == DiskOffLine) ) {
            SpSysPrepFailure( SP_SYSPREP_INVALID_PARTITION, NULL, NULL );
        }
    }

    *pMemoryData = memData;

    SpMemFree(CurrentHalName);

    return TRUE;
}

NTSTATUS
SpGetBaseDeviceName(
    IN PWSTR SymbolicName,
    OUT PWSTR Buffer,
    IN ULONG Size
    )

/*++

Routine Description:

    This routine drills down thru symbolic links until it finds the base device name.

Arguments:

    SymbolicName - The name to start with.

    Buffer - The output buffer.

    Size - Length, in bytes of Buffer

Return Value:

    STATUS_SUCCESS if it completes adding all the to do items properly.

--*/

{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    NTSTATUS Status;

    //
    // Start at the first name
    //
    INIT_OBJA(&Obja,&UnicodeString,SymbolicName);

    Status = ZwOpenSymbolicLinkObject(&Handle,
                                      (ACCESS_MASK)SYMBOLIC_LINK_QUERY,
                                      &Obja
                                     );

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    while (TRUE) {

        //
        // Take this open and get the next name
        //
        UnicodeString.Length = 0;
        UnicodeString.MaximumLength = (USHORT)Size;
        UnicodeString.Buffer = (PWCHAR)Buffer;
        Status = ZwQuerySymbolicLinkObject(Handle,
                                           &UnicodeString,
                                           NULL
                                          );

        ZwClose(Handle);

        Buffer[(UnicodeString.Length / sizeof(WCHAR))] = UNICODE_NULL;

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        //
        // See if the next name is also a symbolic name
        //

        INIT_OBJA(&Obja,&UnicodeString,MOUNTMGR_DEVICE_NAME);

        Status = ZwOpenSymbolicLinkObject(&Handle,
                                          (ACCESS_MASK)SYMBOLIC_LINK_QUERY,
                                          &Obja
                                         );

        if (!NT_SUCCESS(Status)) {
            return STATUS_SUCCESS;
        }

    }
}

BOOLEAN
SpVerifyDriveLetter(
    IN PWSTR RegionName,
    IN WCHAR DriveLetter
    )

/*++

Routine Description:

    This routine makes sure that the specified region has been assigned
    the correct drive letter by the mount manager, if not it changes it.

Arguments:

    RegionName - The region name, \Device\HardiskX\PartitionY.

    DriveLetter - The desired drive letter.

Return Value:

    TRUE if successful, else FALSE.

--*/

{
    WCHAR currentLetter;
    ULONG i;
    PMOUNTMGR_MOUNT_POINT mountPoint = NULL;
    PMOUNTMGR_CREATE_POINT_INPUT createMountPoint;
    WCHAR NewSymbolicLink[16];
    PWSTR regionBaseName;
    ULONG mountPointSize;
    ULONG createMountPointSize;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle;
    PMOUNTMGR_MOUNT_POINTS mountPointsReturned;
    LARGE_INTEGER DelayTime;

    //
    // See what drive letter the region has. Since the mount manager
    // assigns drive letters asynchronously, we wait a little while
    // if we don't get one back.
    //

    for (i = 0; ; i++) {

        currentLetter = SpGetDriveLetter(RegionName, &mountPoint);

        if (currentLetter == DriveLetter) {
            if (mountPoint) {
                SpMemFree(mountPoint);
            }
            
            return TRUE;
        } else if (currentLetter != L'\0') {
            break;
        } else if (i == 5) {
            break;
        }

        //
        // Wait 2 sec and try again.
        //
        DelayTime.HighPart = -1;
        DelayTime.LowPart = (ULONG)(-20000000);
        KeDelayExecutionThread(KernelMode,FALSE,&DelayTime);
    }

    //
    // At this point, we either have no drive letter assigned, or a
    // wrong one.
    //

    if (currentLetter != L'\0') {

        //
        // There is an existing drive letter, so delete it.
        //

        INIT_OBJA(&Obja,&UnicodeString,MOUNTMGR_DEVICE_NAME);

        Status = ZwOpenFile(
                    &Handle,
                    // (ACCESS_MASK)(FILE_GENERIC_READ | FILE_GENERIC_WRITE),
                    (ACCESS_MASK)(FILE_GENERIC_READ),
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE ,
                    FILE_NON_DIRECTORY_FILE
                  );

        if( !NT_SUCCESS( Status ) ) {
            SpMemFree(mountPoint);
            FALSE;
        }

        mountPointsReturned = SpMemAlloc( 4096 );

        mountPointSize = sizeof(MOUNTMGR_MOUNT_POINT) +
                         mountPoint->SymbolicLinkNameLength +
                         mountPoint->UniqueIdLength +
                         mountPoint->DeviceNameLength;

        Status = ZwDeviceIoControlFile(
                        Handle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        IOCTL_MOUNTMGR_DELETE_POINTS,
                        mountPoint,
                        mountPointSize,
                        mountPointsReturned,
                        4096
                        );


        if (!NT_SUCCESS( Status )) {
            SpMemFree(mountPointsReturned);
            SpMemFree(mountPoint);
            ZwClose(Handle);
            return FALSE;
        }

        SpMemFree(mountPointsReturned);
        SpMemFree(mountPoint);   // don't need this anymore
    }

    //
    // Now add the one we want.
    //

    //
    // We need to get the real base name (\Device\HardDiskX\PartitionY
    // is a symbolic link).
    //

    SpGetBaseDeviceName(RegionName, TemporaryBuffer, sizeof(TemporaryBuffer));
    regionBaseName = SpDupStringW(TemporaryBuffer);

    swprintf(NewSymbolicLink, L"\\DosDevices\\%c:", DriveLetter);
    createMountPointSize = sizeof(MOUNTMGR_CREATE_POINT_INPUT) +
                           (wcslen(regionBaseName) * sizeof(WCHAR)) +
                           (wcslen(NewSymbolicLink) * sizeof(WCHAR));
    createMountPoint = SpMemAlloc(createMountPointSize);
    createMountPoint->SymbolicLinkNameLength = wcslen(NewSymbolicLink) * sizeof(WCHAR);
    createMountPoint->SymbolicLinkNameOffset = sizeof(MOUNTMGR_CREATE_POINT_INPUT);
    memcpy((PCHAR)createMountPoint + createMountPoint->SymbolicLinkNameOffset,
           NewSymbolicLink,
           createMountPoint->SymbolicLinkNameLength);

    createMountPoint->DeviceNameLength = wcslen(regionBaseName) * sizeof(WCHAR);
    createMountPoint->DeviceNameOffset = createMountPoint->SymbolicLinkNameOffset +
                                         createMountPoint->SymbolicLinkNameLength;
    memcpy((PCHAR)createMountPoint + createMountPoint->DeviceNameOffset,
           regionBaseName,
           createMountPoint->DeviceNameLength);

    Status = ZwDeviceIoControlFile(
                    Handle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    IOCTL_MOUNTMGR_CREATE_POINT,
                    createMountPoint,
                    createMountPointSize,
                    NULL,
                    0
                    );

    SpMemFree(createMountPoint);
    SpMemFree(regionBaseName);
    ZwClose(Handle);

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
SpSetVolumeLabel(
    IN PWSTR RegionName,
    IN PWSTR VolumeLabel
    )

/*++

Routine Description:

    This routine sets the volume label on the specified region.

Arguments:

    RegionName - The region name, \Device\HardiskX\PartitionY.

    DriveLetter - The desired volume label.

Return Value:

    TRUE if successful, else FALSE.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle;
    struct LABEL_BUFFER {
        FILE_FS_LABEL_INFORMATION VolumeInfo;
        WCHAR Label[64];
        } LabelBuffer;

    INIT_OBJA(&Obja,&UnicodeString,RegionName);

    Status = ZwOpenFile(
                &Handle,
                (ACCESS_MASK)(FILE_GENERIC_READ | FILE_GENERIC_WRITE),
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE ,
                FILE_NON_DIRECTORY_FILE
              );

    if( !NT_SUCCESS( Status ) ) {
        return FALSE;
    }

    LabelBuffer.VolumeInfo.VolumeLabelLength = wcslen(VolumeLabel) * sizeof(WCHAR);
    wcscpy(LabelBuffer.VolumeInfo.VolumeLabel, VolumeLabel);

    Status = ZwSetVolumeInformationFile(
                 Handle,
                 &IoStatusBlock,
                 &LabelBuffer,
                 FIELD_OFFSET(FILE_FS_LABEL_INFORMATION, VolumeLabel[0]) + LabelBuffer.VolumeInfo.VolumeLabelLength,
                 FileFsLabelInformation);

    ZwClose(Handle);

    if( !NT_SUCCESS( Status ) ) {
        return FALSE;
    }

    return TRUE;

}

BOOLEAN
SpFixupLocalDisks(
    IN HANDLE SifHandle,
    OUT PDISK_REGION *InstallRegion,
    OUT PDISK_REGION *SystemPartitionRegion,
    IN PWSTR SetupSourceDevicePath,
    IN PWSTR DirectoryOnSetupSource,
    IN PMIRROR_CFG_INFO_MEMORY pMemoryData,
    IN BOOLEAN UseWholeDisk
    )

/*++

Routine Description:

    This routine parses the IMirror.dat file given and makes the local disk(s) look as
    closely as possible to the configuration in the file.

Arguments:

    SifHandle - Controlling sif file.

    InstallRegion - Returns the install region to use.

    SystemPartitionRegion - Returns the system partition to use.

    SetupSourceDevicePath - Path to the setup device.

    DirectoryOnSetupSource - Subdirectory of the setup files.

    pMemoryData - A pointer to an in-memory copy of the file.

    UseWholeDisk - TRUE if disks should be partitioned as their current
        physical size; FALSE if they should be partitioned to match
        the size that the original source machine had.

Return Value:

    TRUE if successful, else it generates a fatal error.

--*/

{
    PDISK_REGION pRegion=NULL;
    PDISK_REGION p;
    PWSTR RegionDescr;
    PWSTR RegionNtName;
    NTSTATUS Status;
    BOOLEAN DiskCleaned[8] = { FALSE };  // track if a disk has been cleaned up.
    ULONG volume, disk;
    PMIRROR_VOLUME_INFO_MEMORY volumeInfo;
    LARGE_INTEGER SizeInMB;
    PPARTITIONED_DISK pDisk;
    BOOLEAN ExpandToEnd;
    ULONG j;
    PARTITION_INFORMATION_EX    PartInfo;
    ULONGLONG   SysPartStartSector = 0;
    ULONG       SysPartDisk = 0;

    LARGE_INTEGER SizeAvailable;
    LARGE_INTEGER SlopSize;
    LARGE_INTEGER SlopSizeTimes100;
    LARGE_INTEGER SizeRequiredMax;
    LARGE_INTEGER SizeRequiredMin;

    PULONGLONG     StartSectors = NULL;

    if (pMemoryData->NumberVolumes) {
        StartSectors = (PULONGLONG)(SpMemAlloc(sizeof(ULONGLONG) * pMemoryData->NumberVolumes));

        if (!StartSectors) {
            *InstallRegion = NULL;
            *SystemPartitionRegion = NULL;

            return FALSE;   // ran out of memory
        }
    }       

    RtlZeroMemory(StartSectors, (sizeof(ULONGLONG) * pMemoryData->NumberVolumes));

    //
    // NOTE: imirror.dat
    // doesn't have information about which partitions were in the extended
    // partition. We could read the boot sector from the server, or just
    // try to guess at when we need an extended partition. For the moment,
    // we will just let the partition creation code create extended
    // partitions whent it wants to (all regions after the first primary
    // become logical disks in an extended partition).
    //

    for (volume = 0; volume < pMemoryData->NumberVolumes; volume++) {

        volumeInfo = &pMemoryData->Volumes[volume];

        //
        // If this disk has not been cleaned up, then do so.
        //

        disk = volumeInfo->DiskNumber;

        if (!DiskCleaned[disk]) {

            //
            // Clean out the different partitions on disk.
            //

            SpPtPartitionDiskForRemoteBoot(
                disk,
                &pRegion);

            //
            // That function may leave one big partitioned region, if so delete
            // it so we can start from scratch.
            //

            if (pRegion && pRegion->PartitionedSpace) {
                SpPtDelete(pRegion->DiskNumber,pRegion->StartSector);
            }

            DiskCleaned[disk] = TRUE;

        } else {

            //
            // We have already cleaned out this disk, so pRegion points
            // to the last partition we created. However, we have these 2 dirty looking validation checks on pRegion
            // to make PREFIX happy. pRegion is never NULL but if it is we think that something is wrong and move on.
            //
            
            if( pRegion == NULL )
                continue;

            pRegion = pRegion->Next;

            if( pRegion == NULL )
                continue;
        }

        //
        // Create a region of the specified size.
        // NOTE: Worry about volumeInfo->PartitionType/CompressedVolume?
        // NOTE: What if the rounding to the nearest MB loses something?
        //
        //  We allow for some slop.
        //  a) If the new disk is <= x% smaller, and the image will still fit, then we'll do it.
        //  b) If the new disk is <= x% bigger, then we'll make one partition out of the whole disk.
        //  c) If the new disk is >x% bigger, then we'll make one partition equal to the original one and leave the rest of the disk raw.
        //  d) If the new disk is >x% smaller, then we'll fail.

        pDisk = &PartitionedDisks[pRegion->DiskNumber];
//        SizeAvailable = RtlEnlargedUnsignedMultiply( pRegion->SectorCount, pDisk->HardDisk->Geometry.BytesPerSector );
        SizeAvailable.QuadPart = pRegion->SectorCount * pDisk->HardDisk->Geometry.BytesPerSector;

        // SYSPREP_PARTITION_SLOP is specified as a percentage

        SlopSizeTimes100 = RtlExtendedIntegerMultiply(SizeAvailable, SYSPREP_PARTITION_SLOP);
        SlopSize = RtlExtendedLargeIntegerDivide( SlopSizeTimes100, 100, NULL );

        SizeRequiredMin = RtlLargeIntegerSubtract( volumeInfo->PartitionSize, SlopSize );

        if ( SizeRequiredMin.QuadPart < volumeInfo->DiskSpaceUsed.QuadPart ) {

            SizeRequiredMin = volumeInfo->DiskSpaceUsed;
        }

        SizeRequiredMax = RtlLargeIntegerAdd( volumeInfo->PartitionSize, SlopSize );

        ExpandToEnd = FALSE;
        if (UseWholeDisk) {
            ExpandToEnd = TRUE;

            //
            // If this is the last partition on the disk, then use the rest of it.
            //
            for (j = 0; j < pMemoryData->NumberVolumes; j++) {
                if ((j != volume) &&
                    (pMemoryData->Volumes[j].DiskNumber == pMemoryData->Volumes[volume].DiskNumber) &&
                    (pMemoryData->Volumes[j].StartingOffset.QuadPart > pMemoryData->Volumes[volume].StartingOffset.QuadPart)) {
                    ExpandToEnd = FALSE;
                    break;
                }
            }
        }

        SizeInMB = RtlExtendedLargeIntegerDivide(volumeInfo->PartitionSize, 1024 * 1024, NULL);

        if (!ExpandToEnd && (SizeAvailable.QuadPart > SizeRequiredMax.QuadPart)) {

            // use volumeInfo->PartitionSize

        } else if (SizeAvailable.QuadPart >= SizeRequiredMin.QuadPart ) {

            SizeInMB.QuadPart = 0; // use all available space

        } else {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Sysprep partition of %d Mb is too big\n", SizeInMB.LowPart));

            SpSysPrepFailure( SP_SYSPREP_NOT_ENOUGH_DISK_SPACE, NULL, NULL );
            return(FALSE);
        }

        //
        // TBD : fix the partition type 
        // if(!SpPtDoCreate(pRegion,&p,TRUE,SizeInMB.LowPart,volumeInfo->PartitionType,TRUE)) {
        //
        RtlZeroMemory(&PartInfo, sizeof(PARTITION_INFORMATION_EX));
        PartInfo.Mbr.PartitionType = volumeInfo->PartitionType;
        
        if(!SpPtDoCreate(pRegion, &p, TRUE, SizeInMB.LowPart, &PartInfo, TRUE)) {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not create sys prep partition %d Mb\n", SizeInMB.LowPart));

            SpSysPrepFailure( SP_SYSPREP_NOT_ENOUGH_DISK_SPACE, NULL, NULL );
            return(FALSE);
        }

        //
        // If we just created an extended partition and a logical drive,
        // we'll need to switch regions -- Region points to the extended partition
        // region, but we want to point to the logical drive region.
        //
        ASSERT(p);
        pRegion = p;

#ifdef _X86_
        if (volumeInfo->PartitionActive) {

            if (volumeInfo->IsBootDisk) {

                //
                // On an x86 machine, make sure that we have a valid primary partition
                // on drive 0 (C:), for booting.
                //
                PDISK_REGION SysPart = SpPtValidSystemPartition();

                ASSERT(pRegion == SysPart);

                SPPT_MARK_REGION_AS_SYSTEMPARTITION(pRegion, TRUE);
                SPPT_SET_REGION_DIRTY(pRegion, TRUE);
                
                SysPartDisk = disk;
                SysPartStartSector = pRegion->StartSector;
            }

            //
            // Make sure the system partition is active and all others are inactive.
            //
            SpPtMakeRegionActive(pRegion);            
        }
#endif

        volumeInfo->CreatedRegion = NULL;
        StartSectors[disk] = pRegion->StartSector;
    }

    if (SysPartStartSector == 0) {
        *InstallRegion = *SystemPartitionRegion = NULL;
        SpMemFree(StartSectors);

        return FALSE;   // We need the system partition and install region
    }
    
    //
    // At this point, everything is fine, so commit any
    // partition changes the user may have made.
    // This won't return if an error occurs while updating the disk.
    //
    SpPtDoCommitChanges();

    //
    // Now format all the partitions and make sure the drive letter
    // is correct.
    //

    for (volume = 0; volume < pMemoryData->NumberVolumes; volume++) {
        ULONG FilesystemType;
        ULONG DiskNumber = volumeInfo->DiskNumber;

        volumeInfo = &pMemoryData->Volumes[volume];        
        
        if (StartSectors[DiskNumber]) {
            volumeInfo->CreatedRegion = SpPtLookupRegionByStart(
                                            SPPT_GET_PARTITIONED_DISK(DiskNumber),
                                            TRUE,
                                            StartSectors[DiskNumber]);
        } else {
            ASSERT(FALSE);

            continue;
        }            
        
        pRegion = volumeInfo->CreatedRegion;

        SpPtRegionDescription(
            &PartitionedDisks[pRegion->DiskNumber],
            pRegion,
            TemporaryBuffer,
            sizeof(TemporaryBuffer)
            );

        RegionDescr = SpDupStringW(TemporaryBuffer);

        if (wcscmp(volumeInfo->FileSystemName, L"FAT") == 0) {
            FilesystemType = FilesystemFat;
        } else if (wcscmp(volumeInfo->FileSystemName, L"FAT32") == 0) {
            FilesystemType = FilesystemFat32;
        } else {
            FilesystemType = FilesystemNtfs;
        }

        Status = SpDoFormat(
                    RegionDescr,
                    pRegion,
                    FilesystemType,
                    FALSE,
                    FALSE,      // don't need to worry about fat size
                    TRUE,
                    SifHandle,
                    0,          // default cluster size
                    SetupSourceDevicePath,
                    DirectoryOnSetupSource
                    );

        SpMemFree(RegionDescr);

        //
        // This checks that the drive letter is correct.
        //

        SpNtNameFromRegion(
            pRegion,
            TemporaryBuffer,
            sizeof(TemporaryBuffer),
            PartitionOrdinalCurrent);

        RegionNtName = SpDupStringW(TemporaryBuffer);

        SpVerifyDriveLetter(
            RegionNtName,
            volumeInfo->DriveLetter
            );

        SpSetVolumeLabel(
            RegionNtName,
            volumeInfo->VolumeLabel
            );

        pRegion->DriveLetter = volumeInfo->DriveLetter;
        wcsncpy(pRegion->VolumeLabel,
                volumeInfo->VolumeLabel,
                (sizeof(pRegion->VolumeLabel) / sizeof(WCHAR)) - 1
               );

        pRegion->VolumeLabel[ (sizeof(pRegion->VolumeLabel) / sizeof(WCHAR)) - 1] = UNICODE_NULL;

        SpMemFree(RegionNtName);

    }

    //
    // Locate the system and install region
    //
    *SystemPartitionRegion = SpPtLookupRegionByStart(SPPT_GET_PARTITIONED_DISK(SysPartDisk),
                                            TRUE,
                                            SysPartStartSector);

    *InstallRegion = *SystemPartitionRegion;

    SpMemFree(StartSectors);
    

    return (*InstallRegion != NULL);
}

BOOLEAN
SpCopyMirrorDisk(
    IN PMIRROR_CFG_INFO_FILE pFileData,
    IN ULONG cDisk
    )

/*++

Routine Description:

    This routine uses the IMirror.dat file given and a disk number to copy the contents
    on the mirror share down to the local machine.

Arguments:

    pFileData - A pointer to an in-memory copy of the file.

    cDisk - The disk number to copy.

Return Value:

    TRUE if successful, else FALSE.

--*/
{
    PMIRROR_VOLUME_INFO_FILE pVolume;
    PDISK_REGION pRegion;
    WCHAR Buffer[MAX_PATH];
    NTSTATUS Status;
    PWSTR pNtName;

    if (pFileData->NumberVolumes <= cDisk) {
        SpSysPrepFailure( SP_SYSPREP_INVALID_PARTITION, NULL, NULL );
        return FALSE;
    }

    //
    // Find the correct region.
    // NOTE: the drive with this
    // letter might not be on the same disk, we should scan all disks
    // for this drive letter.
    //
    pVolume = &(pFileData->Volumes[cDisk]);
    pRegion = PartitionedDisks[pVolume->DiskNumber].PrimaryDiskRegions;

    while (pRegion != NULL) {
        if (pRegion->DriveLetter == pVolume->DriveLetter) {
            break;
        }
        pRegion = pRegion->Next;
    }

    if (pRegion ==  NULL) {

        pRegion = PartitionedDisks[pVolume->DiskNumber].ExtendedDiskRegions;

        while (pRegion != NULL) {
            if (pRegion->DriveLetter == pVolume->DriveLetter) {
                break;
            }
            pRegion = pRegion->Next;
        }

        if (pRegion == NULL) {
            SpSysPrepFailure( SP_SYSPREP_NOT_ENOUGH_PARTITIONS, NULL, NULL );
            return FALSE;
        }
    }

    SpPtRegionDescription(
        &PartitionedDisks[pRegion->DiskNumber],
        pRegion,
        Buffer,
        sizeof(Buffer)
        );

    //
    // Now copy all files over
    //
    SpNtNameFromRegion(
        pRegion,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    pNtName = SpDupStringW(TemporaryBuffer);

    mbstowcs(Buffer, RemoteIMirrorFilePath, strlen(RemoteIMirrorFilePath) + 1);
    wcscat(Buffer, (PWSTR)(((PUCHAR)pFileData) + pVolume->MirrorUncPathOffset));

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Copying directories from %ws to %ws%ws\n",
        Buffer, pNtName, L"\\"));

    //
    //  setup the global that says whether we look at compression bit or ACL.
    //

    if ((wcscmp(pVolume->FileSystemName, L"FAT") == 0) ||
        (wcscmp(pVolume->FileSystemName, L"FAT32") == 0)) {

        RemoteSysPrepVolumeIsNtfs = FALSE;

    } else {

        RemoteSysPrepVolumeIsNtfs = TRUE;
    }

    //
    //  copy the acl onto the root.
    //

    Status = SpSysPrepSetExtendedInfo( Buffer, pNtName, TRUE, TRUE );

    if (!NT_SUCCESS(Status)) {

        SpSysPrepFailure( SP_SYSPREP_ACL_FAILURE, pNtName, NULL );
        SpMemFree( pNtName );
        return FALSE;
    }

    SpCopyDirRecursive(
        Buffer,
        pNtName,
        L"\\",
        0
        );

    //
    //  create the \sysprep\sysprep.inf file as a dup of our sif file for gui
    //  mode setup answer file.
    //

    if (pVolume->IsBootDisk) {

        //
        //  first we create the sysprep directory, then we create the inf
        //  file in it.
        //

        SpCreateDirectory( pNtName,
                           NULL,
                           L"sysprep",
                           0,
                           0 );

        Status = SpWriteSetupTextFile(WinntSifHandle,pNtName,L"sysprep",L"sysprep.inf");
    }

    SpMemFree( pNtName );
    return TRUE;
}

VOID
SpDeleteStorageVolumes (
    IN HANDLE SysPrepRegHandle,
    IN DWORD ControlSetNumber
    )
/*++

Routine Description:

    This routine deletes those subkeys of the CCS\Enum\STORAGE\Volume key that
    represent volumes that were never fully installed. This eliminates stale
    information about volumes that may not exist on this computer.

    The motivation for this is this scenario and others like it:

    On the initial install of the OS, the disk has one large partition. The user
    chooses to delete this partition and create a smaller one to hold the OS.
    The result of this is that textmode setup transfers volume information about
    both partitions into the system hive for the running OS. GUI mode setup then
    completely installs the smaller volume, but the larger volume is left partially
    installed and marked with CONFIGFLAG_REINSTALL.

    Next RIPREP is run to copy the OS image to a RIS server. When the image is
    brought back down, say to the same machine or to a machine with the same
    hard disk size, and the automatic UseWholeDisk partitioning is done, there
    will be one large partition of the same size as the original large partition.
    The Volume instance name will match the partially installed one, so when
    mini-GUI mode setup starts, it will get a bugcheck 7B because the partially
    installed volume cannot be used as the system disk.

    To combat this problem, this routine deletes all partially installed volumes
    from the CCS\Enum\STORAGE\Volume key.

Arguments:

    SysPrepRegHandle - Handle to the system hive of the build we are patching.

    ControlSetNumber - Current control set number in the hive.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING unicodeString;
    HANDLE volumeKeyHandle;
    DWORD enumIndex;
    DWORD resultLength;
    PKEY_BASIC_INFORMATION keyInfo;
    PKEY_VALUE_FULL_INFORMATION valueInfo;
    PWCH instanceName;
    HANDLE instanceKeyHandle;
    DWORD configFlags;

    //
    // Open the Enum\STORAGE\Volume key in the current control set.
    //

    swprintf(
        TemporaryBuffer,
        L"ControlSet%03d\\Enum\\STORAGE\\Volume",
        ControlSetNumber
        );

    INIT_OBJA( &obja, &unicodeString, TemporaryBuffer );
    obja.RootDirectory = SysPrepRegHandle;

    status = ZwOpenKey( &volumeKeyHandle, KEY_ALL_ACCESS, &obja );
    if( !NT_SUCCESS(status) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SpDeleteStorageVolumes: Unable to open %ws.  status = %lx\n", TemporaryBuffer, status ));
        return;
    }

    //
    // Enumerate all of the instance keys.
    //

    enumIndex = 0;

    while ( TRUE ) {

        status = ZwEnumerateKey(
                    volumeKeyHandle,
                    enumIndex,
                    KeyBasicInformation,
                    TemporaryBuffer,
                    sizeof(TemporaryBuffer),
                    &resultLength
                    );

        if ( !NT_SUCCESS(status) ) {

            if ( status == STATUS_NO_MORE_ENTRIES ) {

                //
                // Enumeration completed successfully.
                //

                status = STATUS_SUCCESS;

            } else {

                //
                // Some kind of error occurred. Print a message and bail.
                //

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SpDeleteStorageVolumes: Unable to enumerate existing storage volumes (%lx)\n", status ));
            }

            break;
        }

        //
        // Zero-terminate the subkey name just in case. Copy it out of the
        // temporary buffer into "local" storage.
        //

        keyInfo = (PKEY_BASIC_INFORMATION)TemporaryBuffer;
        keyInfo->Name[keyInfo->NameLength/sizeof(WCHAR)] = UNICODE_NULL;
        instanceName = SpDupStringW( keyInfo->Name );

        //
        // Open the key for the volume instance.
        //

        INIT_OBJA( &obja, &unicodeString, instanceName );
        obja.RootDirectory = volumeKeyHandle;

        status = ZwOpenKey( &instanceKeyHandle, KEY_ALL_ACCESS, &obja );

        if( !NT_SUCCESS(status) ) {

            //
            // Unable to open the instance key. Print a message and move
            // on to the next one.
            //

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SpDeleteStorageVolumes: Unable to open %ws.  status = %lx\n", instanceName, status ));
            SpMemFree( instanceName );
            enumIndex++;
            continue;
        }

        //
        // Query the ConfigFlags value.
        //

        RtlInitUnicodeString( &unicodeString, L"ConfigFlags");
        status = ZwQueryValueKey(
                    instanceKeyHandle,
                    &unicodeString,
                    KeyValueFullInformation,
                    TemporaryBuffer,
                    sizeof(TemporaryBuffer),
                    &resultLength
                    );
        valueInfo = (PKEY_VALUE_FULL_INFORMATION)TemporaryBuffer;

        if ( NT_SUCCESS(status) &&
             (valueInfo->Type == REG_DWORD) ) {

            //
            // Got the value. If the volume isn't fully installed, delete the
            // whole instance key.
            //

            configFlags = *(PULONG)((PUCHAR)valueInfo + valueInfo->DataOffset);

            if ( (configFlags & 
                   (CONFIGFLAG_REINSTALL | CONFIGFLAG_FINISH_INSTALL)) != 0 ) {

                //KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SpDeleteStorageVolumes: instance %ws has ConfigFlags %x; DELETING\n", instanceName, configFlags ));
                ZwClose( instanceKeyHandle );
                status = SppDeleteKeyRecursive(
                            volumeKeyHandle,
                            instanceName,
                            TRUE // ThisKeyToo
                            );
                SpMemFree( instanceName );
                // Don't increment enumIndex, because we just deleted a key.
                continue;

            } else {

                //
                // This volume is fully installed. Leave it alone.
                //

                //KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SpDeleteStorageVolumes: instance %ws has ConfigFlags %x; not deleting\n", instanceName, configFlags ));
            }

        } else {

            //
            // ConfigFlags value not present or not a DWORD. Print a
            // message and move on.
            //

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SpDeleteStorageVolumes: instance %ws has invalid ConfigFlags\n", instanceName ));
        }

        //
        // Clean up and move on to the next volume instance.
        //

        ZwClose( instanceKeyHandle );
        SpMemFree( instanceName );
        enumIndex++;
    }

    //
    // All done. Close the Volume key.
    //

    ZwClose( volumeKeyHandle );

    return;
}


NTSTATUS
SpPatchSysPrepImage(
    IN HANDLE SetupSifHandle,
    IN HANDLE WinntSifHandle,
    IN PMIRROR_CFG_INFO_FILE pFileData,
    IN PMIRROR_CFG_INFO_MEMORY pMemoryData
    )

/*++

Routine Description:

    This routine uses the IMirror.dat file given and the given SIF file to make the
    following modifications to a locally copied SysPrep image.
        - Replace the disk controller driver in the image with one that supports the current hardware.
        - Replace the NIC driver in the image with one that supports the current hardware.
        - Replace the HAL, kernel and other mp/up dependent drivers if necessary.
        - Migrate the mounted device settings.
        - Modify boot.ini ARC names if necessary.

Arguments:

    WinntSifHandle - Handle to the open SIF file.

    pFileData - A pointer to an in-memory copy of IMirror.Dat

    pMemoryData - A pointer to an in-memory copy of IMirror.Dat, modified to
        match the specs of this computer (disk sizes etc).

Return Value:

    The NTSTATUS of the operation.
--*/
{
    PWCHAR SysPrepDriversDevice;
    PWCHAR Tmp;
    ULONG Index;
    DWORD Size;
    DWORD Number;
    WCHAR Path[MAX_PATH];
    WCHAR Path2[MAX_PATH];
    WCHAR ImageName[MAX_PATH];
    WCHAR SrvPath[MAX_PATH];
    HANDLE SrcHandle = NULL;
    HANDLE DstHandle = NULL;
    HANDLE TmpHandle = NULL;
    HANDLE TmpHandle2 = NULL;
    HANDLE FileHandle = NULL;
    HANDLE FileHandle2 = NULL;
    PVOID Buffer = NULL;
    BOOLEAN NeedToUnload = FALSE;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obj;
    OBJECT_ATTRIBUTES DstObj;
    UNICODE_STRING UnicodeString1;
    UNICODE_STRING UnicodeString2;
    IO_STATUS_BLOCK IoStatusBlock;
    PKEY_BASIC_INFORMATION pKeyNode;
    ULONG volume;
    PMIRROR_VOLUME_INFO_MEMORY volumeInfo;
    PDISK_FILE_LIST DiskFileLists;
    ULONG   DiskCount;
    BOOLEAN HaveCopyList = FALSE;
    BOOLEAN CopyListEmpty = TRUE;
    PMIRROR_VOLUME_INFO_FILE pVolume = NULL;
    PWSTR pVolumePath = NULL;

    //
    // Find the volume descriptor for the boot disk.
    //
    DiskCount = 0;
    while (DiskCount < pFileData->NumberVolumes) {

        pVolume = &(pFileData->Volumes[DiskCount]);
        if (pVolume->IsBootDisk) {
            break;
        }
        pVolume = NULL;
        DiskCount++;
    }
    if (pVolume == NULL) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage:  Couldn't find boot drive record\n"));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // First check if the SIF file has a value for SysPrepDriversDevice so that we can
    // get new drivers, etc, if necessary.
    //
    SysPrepDriversDevice = SpGetSectionKeyIndex(WinntSifHandle,
                                                L"SetupData",
                                                L"SysPrepDriversDevice",
                                                0
                                               );

    if ((SysPrepDriversDevice == NULL) || (wcslen(SysPrepDriversDevice) == 0)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage:  SIF has no SysPrepDriversDevice value\n"));
        return STATUS_INVALID_PARAMETER;
    }

    Tmp = SysPrepDriversDevice;
    while(*Tmp != UNICODE_NULL) {
        if (*Tmp == L'%') {
            return STATUS_INVALID_PARAMETER;
        }
        Tmp++;
    }

    //
    // Generate media descriptors for the source media.
    //
    SpInitializeFileLists(
        SetupSifHandle,
        &DiskFileLists,
        &DiskCount
        );

    HaveCopyList = TRUE;

    //
    // Allocate a temporary buffer
    //
    Buffer = SpMemAlloc(1024 * 4);

    //
    // Make a string that contains the path to the volume (\??\X:).
    //
    wcscpy(TemporaryBuffer, L"\\??\\X:");
    TemporaryBuffer[4] = pVolume->DriveLetter;
    pVolumePath = SpDupStringW(TemporaryBuffer);

    //
    // Now load the local version of the SysPrep hives, using IMirror.Dat to find them
    // NOTE: DstObj is assumed by CleanUp to still be the key.
    //
    Tmp = (PWCHAR)(((PUCHAR)pFileData) + pFileData->SystemPathOffset);
    wcscpy(Path, L"\\??\\");
    wcscat(Path, Tmp);
    wcscat(Path, L"\\System32\\Config\\System");

    INIT_OBJA(&DstObj, &UnicodeString1, L"\\Registry\\SysPrepReg");
    INIT_OBJA(&Obj, &UnicodeString2, Path);

    Status = ZwLoadKey(&DstObj, &Obj);

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: ZwLoadKey to SysPrepReg failed %lx\n", Status));
        goto CleanUp;
    }

    NeedToUnload = TRUE;

    //
    // Compare the local SysPrep NIC to the NIC that is currently running
    //

    //
    // If different, then replace the NIC
    //

    //
    // Put all critical devices in the currently running hives into the SysPrep hive.
    //
    wcscpy(Path, L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Control\\CriticalDeviceDatabase");

    INIT_OBJA(&Obj, &UnicodeString2, Path);

    Status = ZwOpenKey(&SrcHandle, KEY_READ, &Obj);

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: ZwOpenKey of local CriticalDeviceDatabase failed %lx\n", Status));
        goto CleanUp;
    }

    wcscpy(Path, L"\\Registry\\SysPrepReg");

    INIT_OBJA(&Obj, &UnicodeString2, Path);

    Status = ZwOpenKey(&DstHandle, KEY_READ, &Obj);

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: ZwOpenKey of root SysPrepReg failed %lx\n", Status));
        goto CleanUp;
    }

    Status = SpGetValueKey(
                 DstHandle,
                 L"Select",
                 L"Current",
                 1024 * 4,
                 Buffer,
                 &Size
                 );

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: SpGetValueKey of Select\\Current failed %lx\n", Status));
        goto CleanUp;
    }

    Number = *((DWORD *)(((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data));

    ZwClose(DstHandle);
    DstHandle = NULL;

    //
    // Print the current control set number to find the current control set
    //
    swprintf(Path,
             L"\\Registry\\SysPrepReg\\ControlSet%03d\\Control\\CriticalDeviceDatabase",
             Number
            );

    //
    // Open the critical device database in the SysPrep image
    //
    INIT_OBJA(&Obj, &UnicodeString2, Path);

    Status = ZwOpenKey(&DstHandle, KEY_READ | KEY_WRITE, &Obj);

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: ZwOpenKey of SysPrepReg CriticalDeviceDatabase failed %lx\n", Status));
        goto CleanUp;
    }

    //
    // Start looping and copying the data from the currently running critical device database
    // into the SysPrep's database.
    //
    pKeyNode = (PKEY_BASIC_INFORMATION)Buffer;

    for (Index = 0; ; Index++) {

        if (TmpHandle) {
            ZwClose(TmpHandle);
            TmpHandle = NULL;
        }
        if (TmpHandle2) {
            ZwClose(TmpHandle2);
            TmpHandle2 = NULL;
        }

        Status = ZwEnumerateKey(SrcHandle,
                                Index,
                                KeyBasicInformation,
                                pKeyNode,
                                1024 * 4,
                                &Size
                                );

        if (!NT_SUCCESS(Status)) {
            Status = STATUS_SUCCESS;
            break;
        }

        RtlCopyMemory((PUCHAR)Path2, (PUCHAR)(pKeyNode->Name), pKeyNode->NameLength);
        Path2[pKeyNode->NameLength/sizeof(WCHAR)] = UNICODE_NULL;



        //
        // We need to quit migrating everything from the current critical device database.
        // In order to do that, we'll only migrate the following types:
        //

        //
        // Make sure this is the type of device we really want to migrate.  We will
        // accept any of the following classes:
        // {4D36E965-E325-11CE-BFC1-08002BE10318}    CDROM
        // {4D36E967-E325-11CE-BFC1-08002BE10318}    DiskDrive
        // {4D36E96A-E325-11CE-BFC1-08002BE10318}    hdc
        // {4D36E96B-E325-11CE-BFC1-08002BE10318}    Keyboard
        // {4D36E96F-E325-11CE-BFC1-08002BE10318}    Mouse
        // {4D36E97B-E325-11CE-BFC1-08002BE10318}    SCSIAdapter
        // {4D36E97D-E325-11CE-BFC1-08002BE10318}    System
        //
        Status = SpGetValueKey( SrcHandle,
                                Path2,
                                L"ClassGUID",
                                1024 * 4,
                                Buffer,
                                &Size );
        if( NT_SUCCESS(Status) ) {

            if( (_wcsnicmp(L"{4D36E965-E325-11CE-BFC1-08002BE10318}", (PWSTR)((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data, ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->DataLength)) &&
                (_wcsnicmp(L"{4D36E967-E325-11CE-BFC1-08002BE10318}", (PWSTR)((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data, ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->DataLength)) &&
                (_wcsnicmp(L"{4D36E96A-E325-11CE-BFC1-08002BE10318}", (PWSTR)((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data, ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->DataLength)) &&
                (_wcsnicmp(L"{4D36E96B-E325-11CE-BFC1-08002BE10318}", (PWSTR)((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data, ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->DataLength)) &&
                (_wcsnicmp(L"{4D36E96F-E325-11CE-BFC1-08002BE10318}", (PWSTR)((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data, ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->DataLength)) &&
                (_wcsnicmp(L"{4D36E97B-E325-11CE-BFC1-08002BE10318}", (PWSTR)((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data, ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->DataLength)) &&
                (_wcsnicmp(L"{4D36E97D-E325-11CE-BFC1-08002BE10318}", (PWSTR)((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data, ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->DataLength)) ) {

                // he's not something we want to migrate.
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SpPatchSysPrepImage: We're skipping migration of %ws because his type is %ws\n", Path2, ((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data));
                continue;
            } else {

                // looks good.
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SpPatchSysPrepImage: We're going to migration %ws because his type is %ws\n", Path2, ((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data));
            }
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SpPatchSysPrepImage: SpGetValueKey failed to open %ws\\ClassGUID, but we're going to migrate this key anyway. (%lx)\n", Path2, Status));    
        }


        INIT_OBJA(&Obj, &UnicodeString, Path2);

        Obj.RootDirectory = DstHandle;

        Status = ZwOpenKey(&TmpHandle, KEY_ALL_ACCESS, &Obj);

        if(NT_SUCCESS(Status)) {

            //
            // Delete the current item to rid of stale data
            //
            ZwDeleteKey(TmpHandle);
            ZwClose(TmpHandle);
        }

        TmpHandle = NULL;

        Status = SppCopyKeyRecursive(SrcHandle,
                                     DstHandle,
                                     Path2,
                                     Path2,
                                     TRUE,               // CopyAlways
                                     FALSE               // ApplyACLsAlways
                                    );

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: SppCopyKeyRecursive of %ws failed %lx\n", Path2, Status));
            continue;
        }

        //
        // Now open the services key in both registries
        //
        Status = SpGetValueKey(
                    DstHandle,
                    Path2,
                    L"Service",
                    sizeof(TemporaryBuffer),
                    (PVOID)TemporaryBuffer,
                    &Size
                    );

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage:  Couldn't get target service for %ws, 0x%x\n", Path2,Status));
            continue;
        }


        RtlCopyMemory(Path,
                      ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data,
                      ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->DataLength
                     );

        Path[((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->DataLength/sizeof(WCHAR)] = UNICODE_NULL;

        INIT_OBJA(&Obj,
                  &UnicodeString,
                  L"\\Registry\\Machine\\System\\CurrentControlSet\\Services"
                 );

        Status = ZwOpenKey(&TmpHandle, KEY_ALL_ACCESS, &Obj);

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: ZwOpenKey of Services failed %lx for %ws\n", Status, Path2));
            continue;
        }

        //
        // Get the image path -- remember, since we are in Textmode Setup, the path
        // does *not* contain system32\drivers
        //
        Status = SpGetValueKey(TmpHandle,
                               Path,
                               L"ImagePath",
                               sizeof(TemporaryBuffer),
                               (PVOID)TemporaryBuffer,
                               &Size
                              );

        if (!NT_SUCCESS(Status)) {
            //
            //  if ImagePath isn't there, we default to using the service name.
            //

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: GetValue for ImagePath failed %lx for %ws, we'll default it.\n", Status, Path));
            wcscpy( ImageName, Path );
            wcscat( ImageName, L".sys" );

        } else {

            RtlCopyMemory(ImageName,
                          ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data,
                          ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->DataLength
                         );

            ImageName[((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->DataLength/sizeof(WCHAR)] = UNICODE_NULL;
        }

        //
        // Now delete the old services entry first
        //
        swprintf(TemporaryBuffer,
                 L"\\Registry\\SysPrepReg\\ControlSet%03d\\Services\\%ws",
                 Number,
                 Path
                );

        INIT_OBJA(&Obj, &UnicodeString, TemporaryBuffer);

        Status = ZwOpenKey(&TmpHandle2, KEY_ALL_ACCESS, &Obj);

        if (NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage:  Deleting target service %ws so that we can recreate it cleanly.\n", Path));
            ZwDeleteKey(TmpHandle2);
            ZwClose(TmpHandle2);
            TmpHandle2 = NULL;
        }

        //
        // Now get path to services key in the SysPrep image
        //
        swprintf(TemporaryBuffer,
                 L"\\Registry\\SysPrepReg\\ControlSet%03d\\Services",
                 Number
                );

        INIT_OBJA(&Obj, &UnicodeString, TemporaryBuffer);

        Status = ZwOpenKey(&TmpHandle2, KEY_ALL_ACCESS, &Obj);

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: ZwOpenKey of SysPrepReg services failed %lx for %ws\n", Status,Path2));
            continue;
        }

        //
        // Build the path to the server source.
        //
        wcscpy(SrvPath, SysPrepDriversDevice);
        SpConcatenatePaths(SrvPath, ImageName);

        //
        // Build the path in the SysPrep image for where to store it
        //
        Tmp = (PWCHAR)(((PUCHAR)pFileData) + pFileData->SystemPathOffset);
        wcscpy(TemporaryBuffer, L"\\??\\");
        SpConcatenatePaths(TemporaryBuffer, Tmp);
        SpConcatenatePaths(TemporaryBuffer, L"\\System32\\Drivers\\");
        SpConcatenatePaths(TemporaryBuffer, ImageName);

        wcscpy(Path2, TemporaryBuffer);

        //
        // Copy the driver from the server
        //
        Status = SpCopyFileUsingNames(SrvPath,
                                      Path2,
                                      0,
                                      COPY_ONLY_IF_NOT_PRESENT | COPY_DECOMPRESS_SYSPREP
                                     );

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: SpCopyFilesUsingNames for %ws failed %lx\n", Path2, Status));
            continue;
        }

        wcscpy( ImageName, L"Files." );
        wcscat( ImageName, Path );

        CopyListEmpty = FALSE;

        //  copy the rest of the files for this service by looking up the
        //  appropriate section in txtsetup.inf

        SpAddSectionFilesToCopyList(
            SetupSifHandle,
            DiskFileLists,
            DiskCount,
            ImageName,              // this is now L"Files.Path"
            pVolumePath,            // L"\\Device\\Harddisk0\\Partition1"
            NULL,                   // it should look up the target directory
            COPY_ONLY_IF_NOT_PRESENT,
            TRUE                    // force nocompression, we don't know what
            );                      // type of driver it is.

        //
        // Now duplicate the services key
        //
        Status = SppCopyKeyRecursive(TmpHandle,
                                     TmpHandle2,
                                     Path,
                                     Path,
                                     TRUE,               // CopyAlways
                                     FALSE               // ApplyACLsAlways
                                    );

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: SppCopyKeyRecursive for %ws failed %lx\n", Path, Status));
            continue;
        }

        //
        // Set the start type to 0
        //
        Size = 0;
        Status = SpOpenSetValueAndClose(TmpHandle2,
                                        Path,
                                        L"Start",
                                        REG_DWORD,
                                        &Size,
                                        sizeof(ULONG)
                                       );

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: SpOpenSetValueAndClose for %ws Start failed %lx\n", Path, Status));
            continue;
        }

        //
        // Set the image path to one with system32\drivers on the front.  We do this by
        // moving backwards thru the target path we have already built to the 3rd backslash
        // from the end.
        //
        Tmp = &(Path2[wcslen(Path2)]);
        for (Size = 0; Size < 3; Size++) {
            while (*Tmp != L'\\') {
                Tmp--;
            }
            Tmp--;
        }

        Tmp += 2;

        Status = SpOpenSetValueAndClose(TmpHandle2,
                                        Path,
                                        L"ImagePath",
                                        REG_EXPAND_SZ,
                                        Tmp,
                                        (wcslen(Tmp) + 1) * sizeof(WCHAR)
                                       );

        ZwClose(TmpHandle);
        ZwClose(TmpHandle2);
        TmpHandle = NULL;
        TmpHandle2 = NULL;

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: SpOpenSetValueAndClose for %ws ImagePath failed %lx\n", Path, Status));
            continue;
        }
    }

    //
    // Copy over the NIC files, including the INF file.
    //
    Tmp = (PWCHAR)(((PUCHAR)pFileData) + pFileData->SystemPathOffset);
    wcscpy(Path, L"\\??\\");
    SpConcatenatePaths(Path, Tmp);
    Status = SpCopyNicFiles(SysPrepDriversDevice, Path);

    //
    // Get the HAL and just always copy it over.
    //

    //
    // Now test for mp/up and then replace dependent drivers as necessary.
    //

    //
    // Migrate the MountedDevices and DISK registry information.
    //

    ZwClose(SrcHandle);
    SrcHandle = NULL;
    ZwClose(DstHandle);
    DstHandle = NULL;

    //
    // Open the system hive of the current build.
    //
    INIT_OBJA(&Obj, &UnicodeString2, L"\\Registry\\Machine\\SYSTEM");
    Status = ZwOpenKey(&SrcHandle, KEY_READ, &Obj);
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: ZwOpenKey for local SYSTEM failed %lx\n", Status));
        goto CleanUp;
    }

    //
    // Open the system hive of the build we are patching.
    //
    INIT_OBJA(&Obj, &UnicodeString2, L"\\Registry\\SysPrepReg");
    Status = ZwOpenKey(&DstHandle, KEY_READ | KEY_WRITE, &Obj);
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: ZwOpenKey for SysPrepReg SYSTEM failed %lx\n", Status));
        goto CleanUp;
    }

    //
    // Delete the existing subkeys of the MountedDevices key.
    //

    Status = SppDeleteKeyRecursive(DstHandle,
                                   L"MountedDevices",
                                   TRUE);  // ThisKeyToo
    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
        Status = STATUS_SUCCESS;
    }
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: SppDeleteKeyRecursive of MountedDevices failed %lx\n", Status));
        goto CleanUp;
    }

    //
    // Copy the MountedDevices key over.
    //

    Status = SppCopyKeyRecursive(SrcHandle,
                                 DstHandle,
                                 L"MountedDevices",
                                 L"MountedDevices",
                                 TRUE,      // CopyAlways
                                 TRUE);     // ApplyACLsAlways
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: SppCopyKeyRecursive of MountedDevices failed %lx\n", Status));
        goto CleanUp;
    }

    //
    // Delete the existing subkeys of the DISK key. This routine returns
    // STATUS_OBJECT_NAME_NOT_FOUND if the key does not exist, which is
    // not an error in this case.
    //

    Status = SppDeleteKeyRecursive(DstHandle,
                                   L"DISK",
                                   TRUE);  // ThisKeyToo

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
        Status = STATUS_SUCCESS;
    }
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: SppDeleteKeyRecursive of DISK failed %lx\n", Status));
        goto CleanUp;
    }

    //
    // Copy the DISK key over.
    //

    Status = SppCopyKeyRecursive(SrcHandle,
                                 DstHandle,
                                 L"DISK",
                                 L"DISK",
                                 TRUE,      // CopyAlways
                                 TRUE);     // ApplyACLsAlways

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
        Status = STATUS_SUCCESS;
    }
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: SppCopyKeyRecursive of DISK failed %lx\n", Status));
        Status = STATUS_SUCCESS;
        goto CleanUp;
    }

    //
    // Delete those subkeys of the CCS\Enum\STORAGE\Volume key that
    // represent volumes that were never fully installed. This eliminates
    // stale information about volumes that may not exist on this computer.
    //

    SpDeleteStorageVolumes( DstHandle, Number );

CleanUp:

    if (!CopyListEmpty) {
        //
        // Copy files in the copy list.
        //

        WCHAR emptyString = L'\0';
        PWCHAR lastComponent;

        Tmp = (PWCHAR)(((PUCHAR)pFileData) + pFileData->SystemPathOffset);

        if (*Tmp != L'\0' && *(Tmp+1) == L':') {
            Tmp += 2;           // have it skip L"C:" at front of path
            wcscpy(Path2, Tmp);
        } else {
            wcscpy(Path2, L"\\??\\");
            SpConcatenatePaths(Path2, Tmp);
        }

        //
        //  first we need to remove the L"\i386" off the end of the source
        //  path since SpCopyFilesInCopyList or decendent will tack it on.
        //
        //  divide up the source path into two parts so that SpConcatenatePaths
        //  does the right thing when it puts it back together.
        //

        wcscpy( SrvPath, SysPrepDriversDevice );

        lastComponent = SrvPath + wcslen( SrvPath ) - 1;

        while (lastComponent > SrvPath && *lastComponent != L'\\') {
            lastComponent--;
        }

        if (lastComponent > SrvPath) {

            *lastComponent = L'\0';     // this removes the architecture off the end

            // now move backwards until we find the start of the last component
            while (lastComponent > SrvPath && *lastComponent != L'\\') {
                lastComponent--;
            }

            if (lastComponent > SrvPath) {
                *lastComponent = L'\0';
                lastComponent++;
            } else {
                lastComponent = &emptyString;
            }
        } else {
            lastComponent = &emptyString;
        }

        SpCopyFilesInCopyList(
            SetupSifHandle,
            DiskFileLists,
            DiskCount,
            SrvPath,                        // L"\\device\\harddisk0\\partition1"
            lastComponent,                  // L"\\$win_nt$.~ls"
            Path2,                          // L"\\WINNT"
            NULL
            );
    }

    if (HaveCopyList) {
        SpFreeCopyLists(&DiskFileLists,DiskCount);
    }

    if (SrcHandle != NULL) {
        ZwClose(SrcHandle);
    }

    if (DstHandle != NULL) {
        ZwClose(DstHandle);
    }

    if (TmpHandle != NULL) {
        ZwClose(TmpHandle);
    }

    if (TmpHandle2 != NULL) {
        ZwClose(TmpHandle2);
    }

    if (NeedToUnload) {
        ZwUnloadKey(&DstObj);
        NeedToUnload = FALSE;
    }

    if (pVolumePath != NULL) {
        SpMemFree( pVolumePath );
    }

    //
    //  update the NT source path in the software section of the registry
    //  since we have a valid SysPrepDriversDevice
    //

    if (SysPrepDriversDevice && *SysPrepDriversDevice != L'\0') {

        //
        // Now load the local version of the SysPrep hives, using IMirror.Dat to find them
        // NOTE: DstObj is assumed by CleanUp to still be the key.
        //
        Tmp = (PWCHAR)(((PUCHAR)pFileData) + pFileData->SystemPathOffset);
        wcscpy(Path, L"\\??\\");
        wcscat(Path, Tmp);
        wcscat(Path, L"\\System32\\Config\\Software");

        INIT_OBJA(&DstObj, &UnicodeString1, L"\\Registry\\SysPrepReg");
        INIT_OBJA(&Obj, &UnicodeString2, Path);

        Status = ZwLoadKey(&DstObj, &Obj);

        if (NT_SUCCESS(Status)) {

            NeedToUnload = TRUE;

            //
            // Open the system hive of the build we are patching.
            //
            INIT_OBJA(&Obj, &UnicodeString2, L"\\Registry\\SysPrepReg\\Microsoft\\Windows\\CurrentVersion\\Setup");
            Status = ZwOpenKey(&DstHandle, KEY_READ | KEY_WRITE, &Obj);
            if (NT_SUCCESS(Status)) {

                BOOLEAN haveDecentString = FALSE;

                //
                // the path is of the form
                //    \device\lanmanredirector\server\share\..\flat\i386
                // when we want it of the form \\server\share\..\flat
                //

                Tmp = SysPrepDriversDevice + 1;

                while (*Tmp != L'\0' && *Tmp != L'\\') {
                    Tmp++;
                }
                if (*Tmp == L'\\') {

                    Tmp++;
                    while (*Tmp != L'\0' && *Tmp != L'\\') {
                        Tmp++;
                    }
                    if (*Tmp == L'\\') {    // back up one before the \server\share
                                            // so we can put another \ on it
                        Tmp--;
                        wcscpy( Path, Tmp );
                        Tmp = Path;
                        *Tmp = L'\\';       // we now have \\server\share\..\flat\i386

                        Tmp = Path + wcslen(Path);

                        while (Tmp > Path && *Tmp != L'\\') {
                            Tmp--;
                        }
                        if (Tmp > Path) {
                            *Tmp = L'\0';       // remove the \i386
                            haveDecentString = TRUE;
                        }
                    }
                }

                if (haveDecentString) {
                    INIT_OBJA(&Obj, &UnicodeString2, L"SourcePath");
                    Status = ZwSetValueKey (DstHandle,
                                            &UnicodeString2,
                                            0,
                                            REG_SZ,
                                            Path,
                                            (wcslen(Path) + 1 ) * sizeof(WCHAR));
                    if (!NT_SUCCESS(Status)) {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: Setting SourcePath to %ws failed with 0x%x\n", Path, Status));
                    }
                } else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: Couldn't set SourcePath to %ws\n", SysPrepDriversDevice));
                    Status = STATUS_OBJECT_PATH_INVALID;
                }
                ZwClose(DstHandle);
                DstHandle = NULL;

            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: ZwOpenKey for SysPrepReg SOFTWARE failed %lx\n", Status));
            }
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SpPatchSysPrepImage: ZwLoadKey to SysPrepReg failed %lx\n", Status));
        }
    }

    //
    //  patch boot.ini regardless of the status of the patching of everything
    //  else.  if we don't patch boot.ini, the whole image has no hope of
    //  booting.
    //

#ifdef _X86_
    //
    // Patch boot.ini if the ARC names have changed. Boot.ini will
    // be on the active partition of disk 0.
    //

    for (volume = 0; volume < pMemoryData->NumberVolumes; volume++) {
        volumeInfo = &pMemoryData->Volumes[volume];
        if ((volumeInfo->DiskNumber == 0) &&
            (volumeInfo->PartitionActive)) {

            ULONG tmpLen;
            wcscpy(Path, L"\\??\\");
            tmpLen = wcslen(Path);
            Path[tmpLen] = volumeInfo->DriveLetter;
            Path[tmpLen+1] = L'\0';
            wcscat(Path, L":\\boot.ini");

            SpPatchBootIni(Path, pMemoryData);
            break;
        }
    }
#endif

    if (NeedToUnload) {
        ZwUnloadKey(&DstObj);
    }

    if (Buffer != NULL) {
        SpMemFree(Buffer);
    }

    return Status;
}

VOID
SpReplaceArcName(
    IN PUCHAR CurrentArcName,
    IN PMIRROR_CFG_INFO_MEMORY pMemoryData,
    OUT PBOOLEAN Replaced
    )
/*++

Routine Description:

    This routine looks in pMemoryData to see if there is a partition
    whose OriginalArcName is equal to CurrentArcName, and if so it
    replaces CurrentArcName, adjusting the rest of the string that
    follows CurrentArcName if needed.

Arguments:

    CurrentArcName - The ARC name to check.

    pMemoryData - A pointer to an in-memory copy of IMirror.Dat, modified to
        match the specs of this computer (disk sizes etc).

    Replaced - Returns TRUE if the name is replaced.

Return Value:

    The NTSTATUS of the operation.
--*/
{
    ULONG volume;
    PMIRROR_VOLUME_INFO_MEMORY volumeInfo;
    ULONG originalArcNameLength, newArcNameLength;
    CHAR TmpArcName[128];

    //
    // Scan pMemoryData to see if any ARC names match.
    //

    *Replaced = FALSE;

    for (volume = 0; volume < pMemoryData->NumberVolumes; volume++) {
        volumeInfo = &pMemoryData->Volumes[volume];

        originalArcNameLength = wcslen(volumeInfo->OriginalArcName);
        wcstombs(TmpArcName, volumeInfo->OriginalArcName, originalArcNameLength+1);

        if (RtlCompareMemory(TmpArcName, CurrentArcName, originalArcNameLength) == originalArcNameLength) {

            //
            // This is the partition that CurrentArcName refers to,
            // see what the ARC name is now.
            //

            SpArcNameFromRegion(
                volumeInfo->CreatedRegion,
                TemporaryBuffer,
                sizeof(TemporaryBuffer),
                PartitionOrdinalOnDisk,
                PrimaryArcPath);

            //
            // If we got an ARC name and it is different from what it was on
            // the old machine, we need to replace.
            //

            if (*TemporaryBuffer &&
                (wcscmp(volumeInfo->OriginalArcName, TemporaryBuffer) != 0)) {

                //
                // See if we need to adjust the buffer because the length
                // of the ARC names is different.
                //

                newArcNameLength = wcslen(TemporaryBuffer);
                if (newArcNameLength != originalArcNameLength) {
                    memmove(
                        CurrentArcName+newArcNameLength,
                        CurrentArcName+originalArcNameLength,
                        strlen(CurrentArcName+originalArcNameLength) + 1);
                }

                //
                // Copy over the new ARC name.
                //

                wcstombs(TmpArcName, TemporaryBuffer, newArcNameLength);
                memcpy(CurrentArcName, TmpArcName, newArcNameLength);

                *Replaced = TRUE;
                break;    // no need to look at any other volumeInfo's.

            }
        }
    }
}

NTSTATUS
SpPatchBootIni(
    IN PWCHAR BootIniPath,
    IN PMIRROR_CFG_INFO_MEMORY pMemoryData
    )

/*++

Routine Description:

    This routine modifies boot.ini to modify any ARC names that have
    changed.

Arguments:

    BootIniPath - The path to the local boot.ini.

    pMemoryData - A pointer to an in-memory copy of IMirror.Dat, modified to
        match the specs of this computer (disk sizes etc).

Return Value:

    The NTSTATUS of the operation.
--*/
{
    ULONG ulLen;
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle;
    PCHAR pFileData = NULL, pNewFileData = NULL;
    PCHAR curLoc, endOfLine;
    BOOLEAN changedFile = FALSE;
    PWCHAR TmpBootIni = NULL;

    //
    // Read in the current boot.ini.
    //

    INIT_OBJA(&Obja, &UnicodeString, BootIniPath);

    Status = ZwCreateFile(&Handle,
                          FILE_GENERIC_READ,
                          &Obja,
                          &IoStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ,
                          FILE_OPEN,
                          FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0
                         );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPatchBootIni could not open %ws: %lx\n", BootIniPath, Status));
        goto Cleanup;
    }

    Status = SpGetFileSize(Handle, &ulLen);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPatchBootIni could not SpGetFileSize: %lx\n", Status));
        ZwClose(Handle);
        goto Cleanup;
    }

    //
    // Allocate memory and read in the file.
    //
    pFileData = SpMemAlloc(ulLen);

    Status = ZwReadFile(Handle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        pFileData,
                        ulLen,
                        0,
                        NULL
                        );

    ZwClose(Handle);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPatchBootIni could not ZwReadFile: %lx\n", Status));
        goto Cleanup;
    }


    //
    // Allocate memory for the new copy of the file (we use twice the
    // current size as a worst-case scenario).
    //

    pNewFileData = SpMemAlloc(ulLen * 2);
    memcpy(pNewFileData, pFileData, ulLen);
    pNewFileData[ulLen] = '\0';   // NULL-terminate to make replace easier.

    //
    // Run through each line of the file, looking for ARC names to
    // replace. ARC names are either after the "default=" text or
    // else they start a line.
    //

    curLoc = pNewFileData;

    while (TRUE) {

        BOOLEAN replaced = FALSE;
        LONG adjustment;

        //
        // Replace if this is a "default=" line, or a line that does not
        // start with "timeout=" or a '['.
        //

        if (RtlCompareMemory(curLoc, "default=", strlen("default=")) == strlen("default=")) {
            SpReplaceArcName(curLoc + strlen("default="), pMemoryData, &replaced);
        } else if ((*curLoc != '[') &&
                   (RtlCompareMemory(curLoc, "timeout=", strlen("timeout=")) != strlen("timeout="))) {
            SpReplaceArcName(curLoc, pMemoryData, &replaced);
        }

        if (replaced) {
            changedFile = TRUE;
        }

        //
        // Look for a '\n' in the file.
        //

        endOfLine = strchr(curLoc, '\n');
        if (endOfLine == NULL) {
            break;
        }

        curLoc = endOfLine + 1;

        if (*curLoc == L'\0') {
            break;
        }
    }

    //
    // If we changed the file, write out the new one.
    //

    if (changedFile) {

        //
        // Replace the old boot.ini with the new one.
        //

        TmpBootIni = SpDupStringW(BootIniPath);

        if (!TmpBootIni) {
            goto Cleanup;
        }

        TmpBootIni[wcslen(TmpBootIni)-1] = L'$';   // make it boot.in$

        INIT_OBJA(&Obja, &UnicodeString, TmpBootIni);

        Status = ZwCreateFile(&Handle,
                              FILE_GENERIC_WRITE,
                              &Obja,
                              &IoStatusBlock,
                              NULL,
                              FILE_ATTRIBUTE_NORMAL,
                              0,    // no sharing
                              FILE_OVERWRITE_IF,
                              FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_WRITE_THROUGH,
                              NULL,
                              0
                             );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPatchBootIni could not create %ws: %lx\n", TmpBootIni, Status));
            goto Cleanup;
        }

        Status = ZwWriteFile(Handle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            pNewFileData,
                            strlen(pNewFileData),
                            NULL,
                            NULL
                            );

        ZwClose(Handle);

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPatchBootIni could not ZwWriteFile: %lx\n", Status));
            goto Cleanup;
        }


        //
        // Now that we have written the tmp file, do the swap.
        //

        Status = SpDeleteFile(BootIniPath, NULL, NULL);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPatchBootIni could not SpDeleteFile(%ws): %lx\n", BootIniPath, Status));
            goto Cleanup;
        }

        Status = SpRenameFile(TmpBootIni, BootIniPath, FALSE);

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpPatchBootIni could not SpRenameFile(%ws,%ws): %lx\n", TmpBootIni, BootIniPath, Status));
            goto Cleanup;
        }

    }

Cleanup:

    if (pFileData != NULL) {
        SpMemFree(pFileData);
    }

    if (pNewFileData != NULL) {
        SpMemFree(pNewFileData);
    }

    if (TmpBootIni != NULL) {
        SpMemFree(TmpBootIni);
    }

    return Status;

}

NTSTATUS
SpCopyNicFiles(
    IN PWCHAR SetupPath,
    IN PWCHAR DestPath
    )

/*++

Routine Description:

    This routine packages up information and sends it to the BINL server, getting back
    a list of files to copy to support the given NIC. It then copies those files.

Arguments:

    SetupPath - Setup path that supports the SysPrep image.

    DestPath - Path to the winnt directory.

Return Value:

    The NTSTATUS of the operation.

--*/
{
    PSPUDP_PACKET pUdpPacket = NULL;
    WCHAR UNALIGNED * pPacketEnd;
    PSP_NETCARD_INFO_REQ pReqPacket;
    PSP_NETCARD_INFO_RSP pRspPacket;
    ULONG PacketSize;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG i,j;
    PWCHAR pSrc, pDst, pTmp;
    WCHAR SrcFqn[MAX_PATH];
    WCHAR DstFqn[MAX_PATH];

    //
    // BINL expects the path to be a UNC w/o the architecture type, so take the current
    // setup path, in the form of "\device\lanmanredirector\server\share\...\i386" and
    // make it "\\server\share\..."
    //
    // First remove the architecture type, and the the leading stuff.
    //
    wcscpy(SrcFqn, SetupPath);

    pTmp = &(SrcFqn[wcslen(SrcFqn)]);

    while ((*pTmp != L'\\') && (pTmp != SrcFqn)) {
        pTmp--;
    }

    if (*pTmp == L'\\') {
        *pTmp = UNICODE_NULL;
    }

    pTmp = SrcFqn;
    pTmp++;
    while ((*pTmp != UNICODE_NULL) && (*pTmp != L'\\')) {
        pTmp++;
    }
    if (*pTmp == L'\\') {
        pTmp++;
    }
    while ((*pTmp != UNICODE_NULL) && (*pTmp != L'\\')) {
        pTmp++;
    }
    if (*pTmp == L'\\') {
        pTmp--;
        *pTmp = L'\\';
    }

    //
    // Allocate the packet
    //
    PacketSize = FIELD_OFFSET(SPUDP_PACKET, Data[0]) +
                 FIELD_OFFSET(SP_NETCARD_INFO_REQ, SetupPath[0]) +
                 (wcslen(pTmp) + 1) * sizeof(WCHAR);

    pUdpPacket = (PSPUDP_PACKET)SpMemAllocNonPagedPool(PacketSize);

    //
    // Fill in the packet
    //
    RtlCopyMemory(&(pUdpPacket->Signature[0]), SetupRequestSignature, 4);
    pUdpPacket->Length = PacketSize - FIELD_OFFSET(SPUDP_PACKET, RequestType);
    pUdpPacket->RequestType = 0;
    pUdpPacket->Status = STATUS_SUCCESS;
    pUdpPacket->SequenceNumber = 1;
    pUdpPacket->FragmentNumber = 1;
    pUdpPacket->FragmentTotal = 1;

    pReqPacket = (PSP_NETCARD_INFO_REQ)(&(pUdpPacket->Data[0]));
    pReqPacket->Version = OSCPKT_NETCARD_REQUEST_VERSION;
    RtlCopyMemory(&(pReqPacket->CardInfo), &RemoteSysPrepNetCardInfo, sizeof(NET_CARD_INFO));
    wcscpy(&(pReqPacket->SetupPath[0]), pTmp);

#if defined(_AMD64_)
    pReqPacket->Architecture = PROCESSOR_ARCHITECTURE_AMD64;
#elif defined(_IA64_)
    pReqPacket->Architecture = PROCESSOR_ARCHITECTURE_IA64;
#elif defined(_X86_)
    pReqPacket->Architecture = PROCESSOR_ARCHITECTURE_INTEL;
#else
#error "No Target Architecture"
#endif


    //
    // Open the Udp stack
    //
    Status = SpUdpConnect();

    if (!NT_SUCCESS(Status)) {
        goto CleanUp;
    }


    //
    // Send the request
    //
    Status = SpUdpSendAndReceiveDatagram(pUdpPacket,
                                         PacketSize,
                                         RemoteServerIpAddress,
                                         BINL_DEFAULT_PORT,
                                         SpSysPrepNicRcvFunc
                                        );

    SpUdpDisconnect();

    if (!NT_SUCCESS(Status)) {
        goto CleanUp;
    }

    //
    // Get the received packet
    //
    SpMemFree(pUdpPacket);
    pUdpPacket = (PSPUDP_PACKET)pGlobalResponsePacket;

    Status = pUdpPacket->Status;

    if (!NT_SUCCESS(Status)) {
        goto CleanUp;
    }

    if (GlobalResponsePacketLength <
        (ULONG)(FIELD_OFFSET(SPUDP_PACKET, Data[0]) + FIELD_OFFSET(SP_NETCARD_INFO_RSP, MultiSzFiles[0]))) {
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }

    pRspPacket = (PSP_NETCARD_INFO_RSP)(&(pUdpPacket->Data[0]));
    pPacketEnd = (WCHAR UNALIGNED *)(((PUCHAR)pGlobalResponsePacket) + GlobalResponsePacketLength);

    //
    // Now copy each file
    //
    pTmp = &(pRspPacket->MultiSzFiles[0]);
    for (i = 0; i < pRspPacket->cFiles;) {

        i++;

        if (pTmp >= pPacketEnd) {
            Status = STATUS_INVALID_PARAMETER;
            goto CleanUp;
        }

        
        //
        // Be careful about reading this data, since it's come in over the
        // network.  ie., make sure that the string length is reasonable
        // before proceeding with processing the string.
        //
        pSrc = pTmp;

        try {            
            j = wcslen(pSrc);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            j = sizeof(SrcFqn)/sizeof(WCHAR) + 1;
        }

        
        if (j + wcslen(SetupPath) + 1 > sizeof(SrcFqn)/sizeof(WCHAR)) {
            Status = STATUS_INVALID_PARAMETER;
            goto CleanUp;
        }

        pDst = pTmp = pSrc + j + 1;
        if (pTmp >= pPacketEnd) {
            Status = STATUS_INVALID_PARAMETER;
            goto CleanUp;
        }
        wcscpy(SrcFqn, SetupPath);
        SpConcatenatePaths(SrcFqn, pSrc);

        wcscpy(DstFqn, DestPath);

        if (i == pRspPacket->cFiles) {  // the last file in the list is the INF
            SpConcatenatePaths(DstFqn, L"inf");
        } else {                        // all the others go in system32\drivers
            SpConcatenatePaths(DstFqn, L"system32\\drivers");
        }

        if (*pDst != UNICODE_NULL) {
            try {            
                j = wcslen(pDst);
            } except(EXCEPTION_EXECUTE_HANDLER) {
                j = sizeof(DstFqn)/sizeof(WCHAR) + 1;
            }

            if (j+wcslen(DstFqn)+1 > sizeof(DstFqn)/sizeof(WCHAR)) {
                Status = STATUS_INVALID_PARAMETER;
                goto CleanUp;
            }

            pTmp = pDst + j + 1;
            if (pTmp >= pPacketEnd) {
                Status = STATUS_INVALID_PARAMETER;
                goto CleanUp;
            }

            SpConcatenatePaths(DstFqn, pDst);
        } else {
            SpConcatenatePaths(DstFqn, pSrc);
            pTmp = pDst + 1;
        }

        Status = SpCopyFileUsingNames(SrcFqn, DstFqn, 0, COPY_DECOMPRESS_SYSPREP );

        if (!NT_SUCCESS(Status)) {
            goto CleanUp;
        }

    }


CleanUp:

    if (pUdpPacket != NULL) {
        SpMemFree(pUdpPacket);
    }

    return Status;
}

NTSTATUS
SpSysPrepNicRcvFunc(
    PVOID DataBuffer,
    ULONG DataBufferLength
    )

/*++

Routine Description:

    This routine receives datagrams from the server into the global variable
    pGlobalResponsePacket, iff it is NULL, otherwise it is presumed to hold data
    and the incoming packet is assumed to be a duplicate response packet.

    NOTE: spudp.c guarantees singly-threaded callbacks, so we don't have to spin lock
    here.

Arguments:

    DataBuffer - The incoming data.

    DataBufferLength - Length of the data in bytes.

Return Value:

    The NTSTATUS of the operation.

--*/

{
    PSPUDP_PACKET pUdpPacket;
    WCHAR UNALIGNED * pPacketEnd;

    if ((pGlobalResponsePacket != NULL) || (DataBufferLength == 0)) {
        return STATUS_UNSUCCESSFUL;
    }

    pUdpPacket = (PSPUDP_PACKET)DataBuffer;

    if (RtlCompareMemory(&(pUdpPacket->Signature[0]), SetupResponseSignature, 4) != 4) {
        return STATUS_UNSUCCESSFUL;
    }

    pGlobalResponsePacket = SpMemAlloc(DataBufferLength + sizeof(WCHAR));

    RtlCopyMemory(pGlobalResponsePacket, DataBuffer, DataBufferLength);
    pPacketEnd = (WCHAR UNALIGNED *)(((PUCHAR)pGlobalResponsePacket) + DataBufferLength);
    *pPacketEnd = L'\0';  // NULL-terminate it
    GlobalResponsePacketLength = DataBufferLength;

    return STATUS_SUCCESS;
}

VOID
SpSysPrepFailure(
    ULONG ReasonNumber,
    PVOID Parameter1,
    PVOID Parameter2
    )

/*++

Routine Description:

    Inform the user that we were unable to bring down the sysprep image
    correctly.

    This is a fatal condition.

Arguments:

    None.

Return Value:

    Does not return.

--*/

{
    ULONG ValidKeys[2] = { KEY_F3, 0 };
    PWCHAR MessageText = NULL;
    WCHAR blankMessage[1];

    if (ReasonNumber > 0) {

        // Get the message text.
        //

        if (Parameter1 == NULL) {

            MessageText = SpRetreiveMessageText(NULL,ReasonNumber,NULL,0);

        } else {

            SpFormatMessage(  TemporaryBuffer,
                              sizeof(TemporaryBuffer),
                              ReasonNumber,
                              Parameter1,
                              Parameter2
                              );

            MessageText = SpDupStringW(TemporaryBuffer);
        }
        if (MessageText == NULL) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpSysPrepFailure: SpRetreiveMessageText %u returned NULL\n",ReasonNumber));
        }
    }

    if (MessageText == NULL) {

        blankMessage[0] = L'\0';
        MessageText = &blankMessage[0];
    }

    CLEAR_CLIENT_SCREEN();

    SpStartScreen(  SP_SCRN_SYSPREP_FATAL_FAILURE,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE,
                    MessageText
                    );

    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);

    SpWaitValidKey(ValidKeys,NULL,NULL);

    SpDone(0,FALSE,FALSE);
}


NTSTATUS
SpSysPrepSetShortFileName (
    PWCHAR Source,
    PWCHAR Dest
    )

/*++

Routine Description:

    Try to set the short filename out of the sysprep image.
    
    This should be considered non-fatal if it fails since not all
    files will have this information set for them.   

Arguments:

    Source :

Return Value:

    The status code from setting the info.  May not return if we hit a failure
    and the user specifies to abort the setup.

--*/


{
    ULONG stringLength = 0;
    ULONG FileNameInformationLength = 0;
    PWCHAR fullName = NULL;
    PWCHAR SFNBuffer = NULL;
    
    HANDLE sourceHandle = NULL;
    HANDLE streamHandle = NULL;
    HANDLE destHandle = NULL;

    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    MIRROR_SFN_STREAM mirrorHeader;
    
    LARGE_INTEGER byteOffset;
    ULONG bytesRead;
    

    BOOLEAN haveSFN = FALSE;
    BOOLEAN haveStream = FALSE;
    BOOLEAN haveSourceAttributes = FALSE;

    PFILE_NAME_INFORMATION FileNameInformation;

    if ((Source == NULL) || (Dest == NULL)) {

        return STATUS_SUCCESS;
    }

    // alloc a buffer to hold the full file of the source including stream

    while (*(Source+stringLength) != L'\0') {
        stringLength++;
    }
    stringLength += sizeof( IMIRROR_SFN_STREAM_NAME ) + 1;      // + 1 for size of null
    stringLength *= sizeof(WCHAR);

    fullName = SpMemAlloc( stringLength );
    if (!fullName) {
        Status = STATUS_SUCCESS;
        goto exit;
    }

    wcscpy( fullName, Source );
    wcscat( fullName, IMIRROR_SFN_STREAM_NAME );

    //
    // Open the source stream.
    //

    INIT_OBJA(&Obja,&UnicodeString,fullName);

    Status = ZwCreateFile(
                &streamHandle,
                GENERIC_READ | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                NULL,
                0,
                FILE_SHARE_READ,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_SEQUENTIAL_ONLY,
                NULL,
                0
                );

    if ( ! NT_SUCCESS(Status) ) {

        //
        //  for now, if a directory or file doesn't have our stream, it's ok.
        //  we'll just skip it.
        //

        Status = STATUS_SUCCESS;
        goto exit;
    }

    byteOffset.QuadPart = 0;

    Status = ZwReadFile(streamHandle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        (PCHAR) &mirrorHeader,
                        sizeof( mirrorHeader ),
                        &byteOffset,
                        NULL
                        );

    if (!NT_SUCCESS(Status) ||
        (IoStatusBlock.Information < sizeof( mirrorHeader ))) {

        //
        // we can't read the header correctly.  just skip setting SFN.
        //
        Status = STATUS_SUCCESS;
        goto exit;

    }
    if (mirrorHeader.StreamVersion != IMIRROR_SFN_STREAM_VERSION) {

        //
        //  we can't read the header correctly.  just skip setting SFN.
        //
        Status = STATUS_SUCCESS;
        goto exit;
    }

    haveStream = TRUE;

    //
    //  allocate a buffer to hold the SFN.  The size is embedded in the header.
    //  take off room for the structure and tack on two for a UNICODE_NULL at 
    //  the end, just in case the stream doesn't have one.
    //

    if (mirrorHeader.StreamLength) {

        SFNBuffer = SpMemAlloc( mirrorHeader.StreamLength - sizeof(MIRROR_SFN_STREAM) + 2 );
        if (!SFNBuffer) {
            Status = STATUS_SUCCESS;
            goto exit;
        }

        byteOffset.QuadPart += sizeof( mirrorHeader );

        //
        //  now we read the SFN  since we know how long it is.
        //

        Status = ZwReadFile(streamHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            SFNBuffer,
                            mirrorHeader.StreamLength - sizeof(MIRROR_SFN_STREAM),
                            &byteOffset,
                            NULL
                            );

        if (!NT_SUCCESS(Status) ||
            (IoStatusBlock.Information < (mirrorHeader.StreamLength - sizeof(MIRROR_SFN_STREAM)))) {

            //
            //  oh joy, we can't read the SFN correctly
            //
            Status = STATUS_SUCCESS;
            goto exit;
        }

        haveSFN = TRUE;
        //
        // tack on a unicode NULL just in case.
        //
        SFNBuffer[(mirrorHeader.StreamLength - sizeof(MIRROR_SFN_STREAM))/sizeof(WCHAR)] = UNICODE_NULL;

    } else {
        ASSERT(FALSE);
        Status = STATUS_SUCCESS;
        goto exit;
    }

    INIT_OBJA(&Obja,&UnicodeString,Dest);
    
    Status = ZwCreateFile(
                &destHandle,
                FILE_READ_ATTRIBUTES |
                FILE_WRITE_ATTRIBUTES |
                FILE_READ_DATA |
                FILE_WRITE_DATA |
                DELETE,
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_DIRECTORY,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT,
                NULL,
                0
                );

    if (!NT_SUCCESS(Status)) {
        
        //
        // Maybe it's not a directory...  Try for a file.
        //
        
        Status = ZwCreateFile(
                    &destHandle,
                    FILE_READ_ATTRIBUTES |
                    FILE_WRITE_ATTRIBUTES |
                    FILE_READ_DATA |
                    FILE_WRITE_DATA |
                    DELETE,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN,
                    FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT,
                    NULL,
                    0
                    );

              
        if( !NT_SUCCESS(Status) ) {
            Status = STATUS_SUCCESS;
            goto exit;
        }
    }


    FileNameInformationLength = FIELD_OFFSET(FILE_NAME_INFORMATION, FileName) + ((wcslen(SFNBuffer)+1)*sizeof(WCHAR));
    FileNameInformation = SpMemAlloc( FileNameInformationLength );

    if (FileNameInformation) {
        
        FileNameInformation->FileNameLength = wcslen(SFNBuffer) * sizeof(WCHAR);
        wcscpy( FileNameInformation->FileName, SFNBuffer );
        

        Status = ZwSetInformationFile(  destHandle,
                                        &IoStatusBlock,
                                        FileNameInformation,
                                        FileNameInformationLength,
                                        FileShortNameInformation
                                        );
        
        SpMemFree( FileNameInformation );
        
        // Keep quiet.
        Status = STATUS_SUCCESS;
    }
   
exit:
    if (fullName) {
        SpMemFree( fullName );
    }
    if (SFNBuffer) {
        SpMemFree( SFNBuffer );
    }
    if (streamHandle) {
        ZwClose( streamHandle );
    }
    if (sourceHandle) {
        ZwClose( sourceHandle );
    }
    if (destHandle) {
        ZwClose( destHandle );
    }

    return(Status);
}


NTSTATUS
SpSysPrepSetExtendedInfo (
    PWCHAR Source,
    PWCHAR Dest,
    BOOLEAN Directory,
    BOOLEAN RootDir
    )

/*++

Routine Description:

    Try to set the extended information out of the sysprep image.  This
    includes the acl and the compression info.  If we encounter an error,
    we may not only fail the operation but also reboot if the user chooses
    to abandon the setup.

Arguments:

    Source :

Return Value:

    The status code from setting the info.  May not return if we hit a failure
    and the user specifies to abort the setup.

--*/


{
    ULONG stringLength = 0;
    PWCHAR fullName = NULL;
    PWCHAR rootWithSlash = NULL;
    HANDLE sourceHandle = NULL;
    HANDLE streamHandle = NULL;
    HANDLE destHandle = NULL;
    PCHAR sdBuffer = NULL;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    MIRROR_ACL_STREAM mirrorHeader;
    LARGE_INTEGER byteOffset;
    ULONG bytesRead;
    ULONG ValidKeys[4] = { ASCI_ESC, KEY_F3, 0 };
    ULONG WarnKeys[2] = { KEY_F3, 0 };
    ULONG MnemonicKeys[] = { MnemonicContinueSetup, 0 };
    BOOLEAN haveSecurityDescriptor = FALSE;
    BOOLEAN haveStream = FALSE;
    BOOLEAN haveSourceAttributes = FALSE;
    FILE_BASIC_INFORMATION BasicFileInfo;
    USHORT CompressionState;

    if ((Source == NULL) || (Dest == NULL)) {

        return STATUS_SUCCESS;
    }

    if (!RootDir) {        
        SpSysPrepSetShortFileName(Source, Dest);
    }

    mirrorHeader.ExtendedAttributes = 0;

    // alloc a buffer to hold the full file of the source including stream

    while (*(Source+stringLength) != L'\0') {
        stringLength++;
    }
    stringLength += sizeof( IMIRROR_ACL_STREAM_NAME ) + 1;      // + 1 for size of null
    stringLength *= sizeof(WCHAR);

    fullName = SpMemAlloc( stringLength );

    wcscpy( fullName, Source );
    wcscat( fullName, IMIRROR_ACL_STREAM_NAME );

    //
    // Open the source stream.
    //

    INIT_OBJA(&Obja,&UnicodeString,fullName);

    Status = ZwCreateFile(
                &streamHandle,
                GENERIC_READ | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                NULL,
                0,
                FILE_SHARE_READ,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_SEQUENTIAL_ONLY,
                NULL,
                0
                );

    if ( ! NT_SUCCESS(Status) ) {

        //
        //  for now, if a directory or file doesn't have our stream, it's ok.
        //  we'll just copy the attributes from the source.
        //

        Status = STATUS_SUCCESS;
        goto setFileAttributes;
    }

    byteOffset.QuadPart = 0;

    Status = ZwReadFile(streamHandle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        (PCHAR) &mirrorHeader,
                        sizeof( mirrorHeader ),
                        &byteOffset,
                        NULL
                        );

    if (!NT_SUCCESS(Status) ||
        (IoStatusBlock.Information < sizeof( mirrorHeader ))) {

        //
        //  oh joy, we can't read the header correctly.  Let's ask the user
        //  if he wants to continue or abort.
        //

failSetInfo:
        SpStartScreen(
            SP_SCRN_SYSPREP_SETACL_FAILED,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            Dest
            );

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ESC_EQUALS_SKIP_FILE,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {

        case ASCI_ESC:      // skip file

            break;

        case KEY_F3:        // exit setup

            SpConfirmExit();
            goto failSetInfo;
        }

        CLEAR_CLIENT_SCREEN();

        //
        //  we're skipping the file, delete it if it's not a directory since
        //  it isn't correctly formed.
        //

        if (destHandle) {
            ZwClose( destHandle );
            destHandle = NULL;
        }

        if ( ! Directory ) {
            SpDeleteFile(Dest,NULL,NULL);
        } else {
            if (!RootDir) {
                SpDeleteFileEx( Dest, NULL, NULL,
                                FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                                FILE_OPEN_FOR_BACKUP_INTENT );
            }
        }

        return Status;
    }
    if (mirrorHeader.StreamVersion != IMIRROR_ACL_STREAM_VERSION) {

        //
        //  oh joy, we've hit a file we don't support.
        //
        goto failSetInfo;
    }

    haveStream = TRUE;

    //
    //  allocate a buffer to hold the security descriptor.
    //

    if (mirrorHeader.SecurityDescriptorLength) {

        sdBuffer = SpMemAlloc( mirrorHeader.SecurityDescriptorLength );

        byteOffset.QuadPart += sizeof( mirrorHeader );

        //
        //  now we read the security descriptor since we know how long it is.
        //

        Status = ZwReadFile(streamHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            sdBuffer,
                            mirrorHeader.SecurityDescriptorLength,
                            &byteOffset,
                            NULL
                            );

        if (!NT_SUCCESS(Status) ||
            (IoStatusBlock.Information < mirrorHeader.SecurityDescriptorLength)) {

            //
            //  oh joy, we can't read the SD correctly
            //
            goto failSetInfo;
        }

        haveSecurityDescriptor = TRUE;
    }
setFileAttributes:

    //
    //  we first open the source to get the file attributes and times that we're
    //  going to copy over to the dest.
    //

    INIT_OBJA(&Obja,&UnicodeString,Source);

    Status = ZwCreateFile(
                &sourceHandle,
                FILE_READ_ATTRIBUTES,
                &Obja,
                &IoStatusBlock,
                NULL,
                0,
                FILE_SHARE_READ,
                FILE_OPEN,
                Directory ? ( FILE_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT ) : FILE_NON_DIRECTORY_FILE,
                NULL,
                0
                );

    if ( NT_SUCCESS(Status) ) {

        Status = ZwQueryInformationFile(    sourceHandle,
                                            &IoStatusBlock,
                                            &BasicFileInfo,
                                            sizeof(BasicFileInfo),
                                            FileBasicInformation
                                            );
        if (NT_SUCCESS(Status)) {

            haveSourceAttributes = TRUE;
        }
    }

    //
    //  Now we open the target to write out the security descriptor and
    //  attributes.
    //

    if (RootDir) {

        //
        //  append a \ to the end of the dest path
        //

        stringLength = 0;
        while (*(Dest+stringLength) != L'\0') {
            stringLength++;
        }
        stringLength += 2;      // one for null, one for backslash
        stringLength *= sizeof(WCHAR);

        rootWithSlash = SpMemAlloc( stringLength );

        wcscpy( rootWithSlash, Dest );
        wcscat( rootWithSlash, L"\\" );

        INIT_OBJA(&Obja,&UnicodeString,rootWithSlash);

    } else {

        INIT_OBJA(&Obja,&UnicodeString,Dest);
    }

    Status = ZwCreateFile(
                &destHandle,
                WRITE_OWNER |
                    WRITE_DAC |
                    ACCESS_SYSTEM_SECURITY |
                    FILE_READ_ATTRIBUTES |
                    FILE_WRITE_ATTRIBUTES |
                    FILE_READ_DATA |
                    FILE_WRITE_DATA,
                &Obja,
                &IoStatusBlock,
                NULL,
                0,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0
                );

    if (!NT_SUCCESS(Status)) {

        //
        //  oh joy, we can't open the target correctly.
        //
        goto failSetInfo;
    }

    // NOTE: figure out what to do about reparse points and encrypted files

//  if (mirrorHeader.ExtendedAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
//  }
//  if (mirrorHeader.ExtendedAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
//  }

    if (mirrorHeader.ExtendedAttributes & FILE_ATTRIBUTE_COMPRESSED) {

        CompressionState = COMPRESSION_FORMAT_DEFAULT;

    } else {

        CompressionState = COMPRESSION_FORMAT_NONE;
    }

    try {
        Status = ZwFsControlFile(   destHandle,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    FSCTL_SET_COMPRESSION,
                                    &CompressionState,
                                    sizeof(CompressionState),
                                    NULL,
                                    0
                                    );
        if (Status == STATUS_INVALID_DEVICE_REQUEST) {

            //
            //  if this file system doesn't support compression for this
            //  object, we'll just ignore the error.
            //

            Status = STATUS_SUCCESS;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_IN_PAGE_ERROR;
    }

    if ( NT_SUCCESS(Status) && ! haveSourceAttributes ) {

        //
        //  if we don't have the source attributes, just grab them from the
        //  destination so that we have some attributes to manipulate.
        //

        Status = ZwQueryInformationFile(    destHandle,
                                            &IoStatusBlock,
                                            &BasicFileInfo,
                                            sizeof(BasicFileInfo),
                                            FileBasicInformation
                                            );
    }

    if (haveStream) {

        //
        //  If this file has our stream, use the stream fields as the overriding
        //  values.  They even override the source file's attributes on the server.
        //

        BasicFileInfo.FileAttributes = mirrorHeader.ExtendedAttributes;
        BasicFileInfo.ChangeTime.QuadPart = mirrorHeader.ChangeTime.QuadPart;
    }
    if ( NT_SUCCESS(Status) ) {

        if (Directory) {

            BasicFileInfo.FileAttributes |= FILE_ATTRIBUTE_DIRECTORY;

        } else if (BasicFileInfo.FileAttributes == 0) {

            BasicFileInfo.FileAttributes = FILE_ATTRIBUTE_NORMAL;
        }

        Status = ZwSetInformationFile(  destHandle,
                                        &IoStatusBlock,
                                        &BasicFileInfo,
                                        sizeof(BasicFileInfo),
                                        FileBasicInformation
                                        );
        if (Status == STATUS_INVALID_PARAMETER && RootDir) {

            //
            //  if this file system doesn't support setting attributes on the
            //  root of the volume, we'll ignore the error.
            //

            Status = STATUS_SUCCESS;
        }
    }

    if (!NT_SUCCESS(Status)) {

        //
        //  post a warning that we couldn't set it.  shouldn't be fatal.
        //

        SpStartScreen(
            SP_SCRN_SYSPREP_COPY_FAILURE,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            Status,
            Dest
            );

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_C_EQUALS_CONTINUE_SETUP,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        switch(SpWaitValidKey(WarnKeys,NULL,MnemonicKeys)) {

        case KEY_F3:        // exit setup

            SpConfirmExit();
            break;

        default:
            break;
        }
    }

    if (haveSecurityDescriptor) {
        try {

            // the state of the security descriptor is unknown, let's protect
            // ourselves

            Status = ZwSetSecurityObject( destHandle,
                                          OWNER_SECURITY_INFORMATION |
                                            GROUP_SECURITY_INFORMATION |
                                            DACL_SECURITY_INFORMATION |
                                            SACL_SECURITY_INFORMATION,
                                          (PSECURITY_DESCRIPTOR) sdBuffer
                                          );
        } except(EXCEPTION_EXECUTE_HANDLER) {
            Status = STATUS_IN_PAGE_ERROR;
        }

        if (!NT_SUCCESS(Status)) {

            //
            //  oh joy, we can't write the SD correctly.
            //
            goto failSetInfo;
        }
    }

// endSetExtended:
    if (rootWithSlash) {
        SpMemFree( rootWithSlash );
    }
    if (fullName) {
        SpMemFree( fullName );
    }
    if (sdBuffer) {
        SpMemFree( sdBuffer );
    }
    if (streamHandle) {
        ZwClose( streamHandle );
    }
    if (sourceHandle) {
        ZwClose( sourceHandle );
    }
    if (destHandle) {
        ZwClose( destHandle );
    }
    return STATUS_SUCCESS;
}

NTSTATUS
SpCopyEAsAndStreams (
    PWCHAR SourceFile,
    HANDLE SourceHandle OPTIONAL,
    PWCHAR TargetFile,
    HANDLE TargetHandle OPTIONAL,
    BOOLEAN Directory
    )
//
//  This copies the EAs and streams from the source to the target.  The
//  source and dest handles are specified for files and optional for
//  directories.
//
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG ValidKeys[4] = { ASCI_CR, ASCI_ESC, KEY_F3, 0 };
    FILE_EA_INFORMATION eaInfo;
    HANDLE tempSourceHandle = SourceHandle;
    HANDLE tempTargetHandle = TargetHandle;
    HANDLE StreamHandle;
    HANDLE newStreamHandle;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    ULONG StreamInfoSize = 4096-8; // alloc a whole page. spmemalloc reserves 8 bytes
    PFILE_STREAM_INFORMATION StreamInfoBase = NULL;
    PFILE_STREAM_INFORMATION StreamInfo;
    PUCHAR StreamBuffer = NULL;
    UNICODE_STRING StreamName;

retryCopyEAs:

    if (tempSourceHandle == NULL) {

        INIT_OBJA(&Obja,&UnicodeString,SourceFile);

        Status = ZwCreateFile(
                    &tempSourceHandle,
                    FILE_LIST_DIRECTORY | SYNCHRONIZE,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_DIRECTORY,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN_IF,
                    FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_ALERT | FILE_OPEN_FOR_BACKUP_INTENT,
                    NULL,
                    0
                    );

        if (!NT_SUCCESS(Status)) {
            goto EndCopyEAs;
        }
    }

    if (tempTargetHandle == NULL) {

        INIT_OBJA(&Obja,&UnicodeString,TargetFile);

        Status = ZwCreateFile(
                    &tempTargetHandle,
                    FILE_LIST_DIRECTORY | SYNCHRONIZE,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_DIRECTORY,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN_IF,
                    FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_ALERT | FILE_OPEN_FOR_BACKUP_INTENT,
                    NULL,
                    0
                    );

        if(!NT_SUCCESS(Status)) {
            goto EndCopyEAs;
        }
    }

    //
    //  EAs can be on either FAT or NTFS.
    //

    Status = ZwQueryInformationFile(    tempSourceHandle,
                                        &IoStatusBlock,
                                        &eaInfo,
                                        sizeof( eaInfo ),
                                        FileEaInformation
                                        );

    if (Status == STATUS_SUCCESS && eaInfo.EaSize > 0) {

        //
        // FileEaInformation, oddly enough, doesn't tell you how big a
        // buffer you need to retrieve the EAs. Instead, it tells you
        // how much room the EAs take up on the disk (in OS/2 format)!
        // So we use the OS/2 size as a rough approximation of how large
        // a buffer we need.
        //

        ULONG actualEaSize = eaInfo.EaSize;
        PCHAR eaBuffer;

        do {
            actualEaSize *= 2;
            eaBuffer = SpMemAlloc( actualEaSize );

            Status = ZwQueryEaFile( tempSourceHandle,
                                    &IoStatusBlock,
                                    eaBuffer,
                                    actualEaSize,
                                    FALSE,
                                    NULL,
                                    0,
                                    NULL,
                                    TRUE );

            if ( !NT_SUCCESS(Status) ) {
                SpMemFree( eaBuffer );
                IoStatusBlock.Information = 0;
            }

        } while ( (Status == STATUS_BUFFER_OVERFLOW) ||
                  (Status == STATUS_BUFFER_TOO_SMALL) );

        actualEaSize = (ULONG)IoStatusBlock.Information;

        if (NT_SUCCESS( Status )) {

            Status = ZwSetEaFile(   tempTargetHandle,
                                    &IoStatusBlock,
                                    eaBuffer,
                                    actualEaSize
                                    );
        }
        SpMemFree( eaBuffer );

        if (! NT_SUCCESS( Status )) {
            goto EndCopyEAs;
        }
    }

    //
    //  Streams are only on NTFS and they're also only on files, not directories.
    //

    if (( RemoteSysPrepVolumeIsNtfs != TRUE ) || Directory ) {

        goto EndCopyEAs;
    }

    do {
        if (StreamInfoBase == NULL) {
            StreamInfoBase = SpMemAlloc( StreamInfoSize );
        }
        Status = ZwQueryInformationFile(
                    tempSourceHandle,
                    &IoStatusBlock,
                    (PVOID) StreamInfoBase,
                    StreamInfoSize,
                    FileStreamInformation
                    );
        if ( !NT_SUCCESS(Status) ) {
            SpMemFree( StreamInfoBase );
            StreamInfoBase = NULL;
            StreamInfoSize *= 2;
        }
    } while ( Status == STATUS_BUFFER_OVERFLOW ||
              Status == STATUS_BUFFER_TOO_SMALL );

    if ( NT_SUCCESS(Status) && IoStatusBlock.Information ) {

        StreamInfo = StreamInfoBase;

        for (;;) {

            PWCHAR streamPtr;
            USHORT remainingLength;
            PWCHAR streamName;

            //
            // Build a string descriptor for the name of the stream.
            //

            StreamName.Buffer = &StreamInfo->StreamName[0];
            StreamName.Length = (USHORT) StreamInfo->StreamNameLength;
            StreamName.MaximumLength = StreamName.Length;

            streamPtr = StreamName.Buffer;

            if ((StreamName.Length > 0) && *streamPtr == L':') {

                streamPtr++;    // skip leading ":"
                streamName = streamPtr;     // remember start of stream name
                remainingLength = StreamName.Length - sizeof(WCHAR);

                while (remainingLength > 0 && *streamPtr != L':') {
                    streamPtr++;
                    remainingLength -= sizeof(WCHAR);
                }

                if (remainingLength > 0) {

                    if ((remainingLength == (sizeof(L":$DATA")-sizeof(WCHAR))) &&
                        (RtlCompareMemory( streamPtr, L":$DATA", remainingLength )
                            == remainingLength)) {

                        //
                        //  the attribute type on this is of type data so we
                        //  have a data stream here.  Now check that it is not
                        //  the unnamed primary data stream and our own acl stream
                        //  or the short file name stream.
                        //
                        if ((*streamName != L':') &&
                            ((RtlCompareMemory(StreamName.Buffer,
                                              IMIRROR_ACL_STREAM_NAME,
                                              (sizeof(IMIRROR_ACL_STREAM_NAME)-sizeof(WCHAR)))
                                             != (sizeof(IMIRROR_ACL_STREAM_NAME)-sizeof(WCHAR))) &&
                             (RtlCompareMemory(StreamName.Buffer,
                                              IMIRROR_SFN_STREAM_NAME,
                                              (sizeof(IMIRROR_SFN_STREAM_NAME)-sizeof(WCHAR)))
                                             != (sizeof(IMIRROR_SFN_STREAM_NAME)-sizeof(WCHAR))))) {
                            //
                            //  allocate a buffer to hold the stream data.
                            //  Can't use TemporaryBuffer as it's used by
                            //  SpCopyDirRecursiveCallback et al.
                            //

                            if (StreamBuffer == NULL) {
                                StreamBuffer = SpMemAlloc( StreamInfoSize );
                            }

                            //
                            //  we chop off the ":DATA" suffix from the stream name
                            //

                            StreamName.Length -= remainingLength;

                            //
                            // Open the source stream.
                            //

                            InitializeObjectAttributes(
                                &Obja,
                                &StreamName,
                                0,
                                tempSourceHandle,
                                NULL
                                );
                            Status = ZwCreateFile(
                                        &StreamHandle,
                                        GENERIC_READ | SYNCHRONIZE,
                                        &Obja,
                                        &IoStatusBlock,
                                        NULL,
                                        0,
                                        FILE_SHARE_READ,
                                        FILE_OPEN,
                                        FILE_SYNCHRONOUS_IO_NONALERT,
                                        NULL,
                                        0
                                        );
                            if ( ! NT_SUCCESS(Status) ) {
                                break;
                            }

                            //
                            // Open the source stream.
                            //

                            InitializeObjectAttributes(
                                &Obja,
                                &StreamName,
                                0,
                                tempTargetHandle,
                                NULL
                                );
                            Status = ZwCreateFile(
                                        &newStreamHandle,
                                        GENERIC_WRITE,
                                        &Obja,
                                        &IoStatusBlock,
                                        NULL,
                                        0,
                                        FILE_SHARE_READ,
                                        FILE_CREATE,
                                        FILE_SYNCHRONOUS_IO_NONALERT,
                                        NULL,
                                        0
                                        );
                            if ( NT_SUCCESS(Status) ) {

                                LARGE_INTEGER byteOffset;
                                ULONG bytesRead;

                                byteOffset.QuadPart = 0;

                                while (NT_SUCCESS(Status)) {

                                    Status = ZwReadFile(StreamHandle,
                                                        NULL,
                                                        NULL,
                                                        NULL,
                                                        &IoStatusBlock,
                                                        StreamBuffer,
                                                        StreamInfoSize,
                                                        &byteOffset,
                                                        NULL
                                                        );

                                    if ( ! NT_SUCCESS(Status) ) {

                                        if (Status == STATUS_END_OF_FILE) {
                                            Status = STATUS_SUCCESS;
                                        }
                                        break;
                                    }
                                    bytesRead = (ULONG)IoStatusBlock.Information;
                                    try {
                                        Status = ZwWriteFile(newStreamHandle,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             &IoStatusBlock,
                                                             StreamBuffer,
                                                             bytesRead,
                                                             &byteOffset,
                                                             NULL
                                                             );
                                    } except(EXCEPTION_EXECUTE_HANDLER) {
                                        Status = STATUS_IN_PAGE_ERROR;
                                    }
                                    byteOffset.QuadPart += bytesRead;
                                }
                                ZwClose(newStreamHandle);
                            }
                            ZwClose(StreamHandle);
                        }
                    }
                }
            }

            if ( NT_SUCCESS(Status) && StreamInfo->NextEntryOffset ) {
                StreamInfo = (PFILE_STREAM_INFORMATION)((PCHAR) StreamInfo + StreamInfo->NextEntryOffset);
            } else {
                break;
            }
        }
    }
EndCopyEAs:

    if (tempSourceHandle != NULL && SourceHandle == NULL) {
        ZwClose( tempSourceHandle );
    }
    if (tempTargetHandle != NULL && TargetHandle == NULL) {
        ZwClose( tempTargetHandle );
    }
    if (!NT_SUCCESS(Status)) {

        //
        //  this failed.  let's ask the user if he wants to retry, skip, or
        //  abort.
        //
repaint:
        SpStartScreen(
            SP_SCRN_COPY_FAILED,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            TargetFile
            );

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_RETRY,
            SP_STAT_ESC_EQUALS_SKIP_FILE,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {

        case ASCI_CR:       // retry

            SpCopyFilesScreenRepaint(SourceFile,TargetFile,TRUE);
            goto retryCopyEAs;

        case ASCI_ESC:      // skip file

            break;

        case KEY_F3:        // exit setup

            SpConfirmExit();
            goto repaint;
        }

        //
        //  we're skipping the file, delete it if it's not a directory since
        //  it isn't correctly formed.
        //

        if ( ! Directory ) {
            SpDeleteFile(TargetFile,NULL,NULL);
        }

        //
        // Need to completely repaint gauge, etc.
        //
        SpCopyFilesScreenRepaint(SourceFile,TargetFile,TRUE);
    }
    if (StreamInfoBase != NULL) {
       SpMemFree(StreamInfoBase);
    }
    if (StreamBuffer != NULL) {
        SpMemFree(StreamBuffer);
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\sptarget.c ===
#include "spprecmp.h"
#pragma hdrstop

#define MAX_NT_DIR_LEN 50



/*++
Revision History:

--*/

VOID
SpCheckDirectoryForNt(
    IN  PDISK_REGION Region,
    IN  PWSTR        Directory,
    OUT PBOOLEAN     ReselectDirectory,
    OUT PBOOLEAN     NtInDirectory
    );

VOID
pSpDrawGetNtPathScreen(
    OUT PULONG EditFieldY
    );

ValidationValue
SpGetPathKeyCallback(
    IN ULONG Key
    );

BOOLEAN
SpIsValid8Dot3(
    IN PWSTR Path
    );

BOOLEAN
pSpConsecutiveBackslashes(
    IN PWSTR Path
    );

VOID
SpNtfsNameFilter(
    IN OUT PWSTR Path
    );

BOOLEAN
SpGetUnattendedPath(
    IN  PDISK_REGION Region,
    IN  PWSTR        DefaultPath,
    OUT PWSTR        TargetPath
    );

BOOLEAN
SpGenerateNTPathName(
    IN  PDISK_REGION Region,
    IN  PWSTR        DefaultPath,
    OUT PWSTR        TargetPath
    );

//
// From spcopy.c.
//

BOOLEAN
SpDelEnumFileAndDirectory(
    IN  PCWSTR                     DirName,
    IN  PFILE_BOTH_DIR_INFORMATION FileInfo,
    OUT PULONG                     ret,
    IN  PVOID                      Pointer
    );

extern PVOID FileDeleteGauge;

BOOLEAN
SpGetTargetPath(
    IN  PVOID            SifHandle,
    IN  PDISK_REGION     Region,
    IN  PWSTR            DefaultPath,
    OUT PWSTR           *TargetPath
    )
//
//  Return value - True  - indicates that the path has to be wiped out
//                 False - the path doesn't already exist
//
{
    ULONG EditFieldY;
    WCHAR NtDir[MAX_NT_DIR_LEN+2];
    BOOLEAN BadDirectory = FALSE;
    BOOLEAN NtAlreadyPresent;
    BOOLEAN GotUnattendedPath = FALSE;
    BOOLEAN WipeDir = FALSE;

    NtDir[0] = 0;

    //
    // If this is an ASR recovery session, just get the target path from
    // the dr_state.sif file and return.
    //

    if( SpDrEnabled() && ! RepairWinnt ) {
        PWSTR TargetPathFromDrState;

        TargetPathFromDrState = SpDrGetNtDirectory();
        *TargetPath = SpDupStringW(TargetPathFromDrState);
        ASSERT(*TargetPath);

        NTUpgrade = DontUpgrade;
        return(FALSE);
    }

    //
    // If this is unattended operation, fetch the path from the
    // unattended script.  The path we get there might have
    // indicate that we should generate a pathname.  This allows
    // installation into a path that is guaranteed to be unique.
    // (in case the user already has nt on the machine, etc).
    //

    if(UnattendedOperation) {
        GotUnattendedPath = SpGetUnattendedPath(Region,DefaultPath,NtDir);
    } else {
        if (PreferredInstallDir) {
            GotUnattendedPath = TRUE;
            wcscpy( NtDir, PreferredInstallDir );
        } else {
            GotUnattendedPath = TRUE;
            wcscpy( NtDir, DefaultPath );
        }
    }

    if (!GotUnattendedPath) {
        BadDirectory = TRUE;
    }

    do {
        if (BadDirectory) {
            //
            // we do not have a good path so ask the user
            //
            ASSERT(wcslen(DefaultPath) < MAX_NT_DIR_LEN);
            ASSERT(*DefaultPath == L'\\');

            wcsncpy(NtDir,DefaultPath,MAX_NT_DIR_LEN);

            NtDir[MAX_NT_DIR_LEN] = 0;

            pSpDrawGetNtPathScreen(&EditFieldY);

            SpGetInput(
                SpGetPathKeyCallback,
                6,                        // left edge of the edit field
                EditFieldY,
                MAX_NT_DIR_LEN,
                NtDir,
                FALSE                   // escape clears edit field
                );
        }

        //
        // If the user didn't start with a backslash, put one in there
        // for him.
        //
        if(NtDir[0] != L'\\') {
            RtlMoveMemory(NtDir+1,NtDir,MAX_NT_DIR_LEN+1);
            NtDir[0] = L'\\';
        }

        //
        // Assume the directory is OK and not already present.
        //
        BadDirectory = FALSE;
        NtAlreadyPresent = FALSE;

        //
        // Force 8.3 because otherwise WOW won't run.
        // This checks also nabs "" and "\" and disallows them.
        //
        if(!SpIsValid8Dot3(NtDir)) {
            BadDirectory = TRUE;
        } else {

            //
            // Perform a filtering operation that coalesces
            // consecutive dots, etc.
            //
            SpNtfsNameFilter(NtDir);

            //
            // If the name has consecutive backslashes, disallow it.
            //
            if(pSpConsecutiveBackslashes(NtDir)) {
                BadDirectory = TRUE;
            }
        }

        //
        // If we have a bad directory, tell the user.
        //
        if(BadDirectory) {

            SpDisplayScreen(SP_SCRN_INVALID_NTPATH,3,HEADER_HEIGHT+1);

            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_ENTER_EQUALS_CONTINUE,
                0
                );

            SpInputDrain();
            while(SpInputGetKeypress() != ASCI_CR) ;
        } else {
            //
            // The directory is good.  Check to see if Windows NT is
            // already in there.  If it is, then the user will have
            // the option of reselecting a path or overwriting the
            // existing installation.  This is brute force.  Next
            // time look for an opportunity to be more elegant.
            //
            if(!SpDrEnabled()) {
                SpCheckDirectoryForNt(Region,NtDir,&BadDirectory,&NtAlreadyPresent);
            } else {
                BadDirectory = FALSE;
            }


            //
            // If the directory is OK and we didn't find Windows NT in it,
            // then see if the directory is the Windows directory and whether
            // the user wants to install into this.  If we found Windows NT
            // in this directory, no user input is needed.  We just need to
            // find out if this also contains a Windows installation.
            //
            if(!BadDirectory && NtAlreadyPresent)
                WipeDir = TRUE;


        }

    } while(BadDirectory);

    //
    // Remove trailing backslash.  Only have to worry about one
    // because if there were two, pSpConsecutiveBackslashes() would
    // have caught this earlier and we'd never have gotten here.
    //

    if(NtDir[wcslen(NtDir)-1] == L'\\') {
        NtDir[wcslen(NtDir)-1] = 0;
    }

    //
    // Make a duplicate of the directory name.
    //

    *TargetPath = SpDupStringW(NtDir);

    ASSERT(*TargetPath);

    return( WipeDir );
}



BOOLEAN
SpGenerateNTPathName(
    IN  PDISK_REGION Region,
    IN  PWSTR        DefaultPath,
    OUT PWSTR        TargetPath
    )

/*++

Routine Description:

    Using the default path as a starting point,
    this routine generates a unique path name
    to install nt into.

Arguments:

    Region - supplies region to which nt is being installed.

    DefaultPath - supplies the default path for the installation.
        The path to install to will be based on this name.

    TargetPath - receives the path to install to if the return value is TRUE.
        This buffer must be large enough to hold MAX_NT_DIR_LEN+2 wchars.

Return Value:

    TRUE if the path we return is valid and should be used as
    the target path.  FALSE otherwise.

--*/

{
    PWCHAR p;
    unsigned i;
    WCHAR num[5];


    //
    // Init TargetPath and remember where he ends.
    //
    wcscpy( TargetPath, DefaultPath );
    num[0] = L'.';

    p = TargetPath + wcslen( TargetPath );

    //
    // Form the region's nt pathname.
    //
    SpNtNameFromRegion(
        Region,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    //
    // Using extensions with numerical values 0-999, attempt to locate
    // a nonexistent directory name.
    //
    for(i=0; i<999; i++) {

        //
        // See whether a directory or file exists.  If not, we found our path.
        //
        if( (!SpNFilesExist(TemporaryBuffer,&TargetPath,1,TRUE )) &&
            (!SpNFilesExist(TemporaryBuffer,&TargetPath,1,FALSE)) ) {
            return(TRUE);
        }

        swprintf(&num[1],L"%u",i);
        wcscpy(p,num);
    }

    //
    // Couldn't find a pathname that doesn't exist.
    //
    return FALSE;
}


BOOLEAN
SpGetUnattendedPath(
    IN  PDISK_REGION Region,
    IN  PWSTR        DefaultPath,
    OUT PWSTR        TargetPath
    )

/*++

Routine Description:

    In an unattended installation, look in the unattended script
    to determine the target path.  The target path can either be fully
    specified or can be * which will cause is to generate
    a unique pathname.  This is useful to ensure that nt gets installed
    into a unique directory when other installations may be present
    on the same machine.

    Call this routine only if this is unattended mode setup.

Arguments:

    Region - supplies region to which nt is being installed.

    DefaultPath - supplies the default path for the installation.
        The path to install to will be based on this name.

    TargetPath - receives the path to install to if the return value is TRUE.
        This buffer must be large enough to hold MAX_NT_DIR_LEN+2 wchars.

Return Value:

    TRUE if the path we return is valid and should be used as
    the target path.  FALSE otherwise.

--*/

{
    PWSTR PathSpec;


    ASSERT(UnattendedOperation);
    if(!UnattendedOperation) {
        return(FALSE);
    }

    PathSpec = SpGetSectionKeyIndex(UnattendedSifHandle,SIF_UNATTENDED,L"TargetPath",0);
    if(!PathSpec) {
         //
        // Default to *.
        //
        PathSpec = L"*";
    }

    //
    // if it's not "*" then it's an absolute path -- just return it.
    //
    if(wcscmp(PathSpec,L"*")) {
        wcsncpy(TargetPath,PathSpec,MAX_NT_DIR_LEN);
        TargetPath[MAX_NT_DIR_LEN] = 0;
        return(TRUE);
    }

    return SpGenerateNTPathName( Region, DefaultPath, TargetPath );
}


VOID
SpCheckDirectoryForNt(
    IN  PDISK_REGION Region,
    IN  PWSTR        Directory,
    OUT PBOOLEAN     ReselectDirectory,
    OUT PBOOLEAN     NtInDirectory
    )

/*++

Routine Description:

    Check a directory for the presence of Windows NT.  If Windows NT
    is in there, then inform the user that if he continues, his existing
    configuration will be overwritten.

Arguments:

    Region - supplies region descriptor for partition to check for nt.

    Directory - supplies name of directory on the partition ro check for nt.

    ReselectDirectory - receives boolean value indicating whether the caller
        should ask the user to select a different directory.

    NtInDirectory - receives a boolean value indicating whether we found
        windows nt in the given directory.

Return Value:

    None.

--*/

{
    ULONG ValidKeys[3] = { KEY_F3,ASCI_ESC,0 };
    ULONG Mnemonics[2] = { MnemonicDeletePartition2, 0 };

    //
    // Assume the directory is ok as-is and so the user does not have to
    // select a different one.
    //
    *ReselectDirectory = FALSE;
    *NtInDirectory = FALSE;

    //
    // Check for Windows NT in the directory.
    // If it's in there, then ask the user whether he wants to
    // overwrite it.
    //

    SpNtNameFromRegion(
        Region,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    if( (!SpNFilesExist(TemporaryBuffer,&Directory,1,TRUE )) &&
            (!SpNFilesExist(TemporaryBuffer,&Directory,1,FALSE)) ) {
        return;
    }
    else{


        *NtInDirectory = TRUE;

        while(1) {
            SpStartScreen( SP_SCRN_NTPATH_EXISTS,
                           3,
                           HEADER_HEIGHT+1,
                           FALSE,
                           FALSE,
                           DEFAULT_ATTRIBUTE,
                           Directory );

            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_L_EQUALS_DELETE,
                SP_STAT_ESC_EQUALS_NEW_PATH,
                SP_STAT_F3_EQUALS_EXIT,
                0
                );

            switch(SpWaitValidKey(ValidKeys,NULL,Mnemonics)) {

            case KEY_F3:
                SpConfirmExit();
                break;

            case ASCI_ESC:
                //
                // Reselect path.
                //
                *ReselectDirectory = TRUE;
                // fall through
            default:
                //
                // Path is ok, just return.
                //
                return;
            }
        }
    }
}

ValidationValue
SpGetPathKeyCallback(
    IN ULONG Key
    )
{
    ULONG u;

    switch(Key) {

    case KEY_F3:
        SpConfirmExit();
        pSpDrawGetNtPathScreen(&u);
        return(ValidateRepaint);

    default:

        //
        // Ignore special keys and illegal characters.
        // Use the set of illegal FAT characters.
        // Disallow 127 because there is no ANSI equivalent
        // and so the name can't be displayed by Windows.
        // Disallow space because DOS can't handle it.
        // Disallow oem characters because we have problems
        // booting if they are used.
        //
        if((Key & KEY_NON_CHARACTER)
        || wcschr(L" \"*+,/:;<=>?[]|!#$&@^'`{}()%~",(WCHAR)Key)
        || (Key >= 127) || (Key < 32))
        {
            return(ValidateReject);
        }
        break;
    }

    return(ValidateAccept);
}

VOID
pSpDrawGetNtPathScreen(
    OUT PULONG EditFieldY
    )
{
    SpDisplayScreen(SP_SCRN_GETPATH_1,3,HEADER_HEIGHT+1);
    *EditFieldY = NextMessageTopLine + 1;
    SpContinueScreen(SP_SCRN_GETPATH_2,3,4,FALSE,DEFAULT_ATTRIBUTE);

    SpDisplayStatusOptions(
        DEFAULT_STATUS_ATTRIBUTE,
        SP_STAT_ENTER_EQUALS_CONTINUE,
        SP_STAT_F3_EQUALS_EXIT,
        0
        );
}


BOOLEAN
SpIsValid8Dot3(
    IN PWSTR Path
    )

/*++

Routine Description:

    Check whether a path is valid 8.3.  The path may or may not start with
    a backslash.  Only backslashes are recognized as path separators.
    Individual characters are not checked for validity (ie, * would not
    invalidate the path).  The path may or may not terminate with a backslash.
    A component may have a dot without characters in the extension
    (ie, a\b.\c is valid).

    \ and "" are explicitly disallowed even though they fit the rules.

Arguments:

    Path - pointer to path to check.

Return Value:

    TRUE if valid 8.3, FALSE otherwise.

--*/

{
    unsigned Count;
    BOOLEAN DotSeen,FirstChar;

    if((*Path == 0) || ((Path[0] == L'\\') && (Path[1] == 0))) {
        return(FALSE);
    }

    DotSeen = FALSE;
    FirstChar = TRUE;
    Count = 0;

    while(*Path) {

        //
        // Path points to start of current component (1 past the slash)
        //

        switch(*Path) {

        case L'.':
            if(FirstChar) {
                return(FALSE);
            }
            if(DotSeen) {
                return(FALSE);
            }

            Count = 0;
            DotSeen = TRUE;
            break;

        case L'\\':

            DotSeen = FALSE;
            FirstChar = TRUE;
            Count = 0;

            if(*(++Path) == '\\') {

                // 2 slashes in a row
                return(FALSE);
            }

            continue;

        default:

            Count++;
            FirstChar = FALSE;

            if((Count == 4) && DotSeen) {
                return(FALSE);
            }

            if(Count == 9) {
                return(FALSE);
            }

        }

        Path++;
    }

    return(TRUE);
}


BOOLEAN
pSpConsecutiveBackslashes(
    IN PWSTR Path
    )
{
    int x = wcslen(Path);
    int i;

    for(i=0; i<x-1; i++) {

        if((Path[i] == L'\\') && (Path[i+1] == L'\\')) {

            return(TRUE);
        }
    }

    return(FALSE);
}

VOID
SpNtfsNameFilter(
    IN OUT PWSTR Path
    )

/*++

Routine Description:

    Strip trailing .' within a path component.  This also strips tailing
    .'s from the entire path itself.  Also condense other consecutive .'s
    into a single ..

    Example: \...\..a...b.  ==> \\.a.b

Arguments:

    Path - On input, supplies the path to be filtered.  On output, contains
        the filtered pathname.

Return Value:

    None.

--*/

{
    PWSTR TempPath = SpDupStringW(Path);
    PWSTR p,q;
    BOOLEAN Dot;

    if (TempPath) {
        //
        // Coalesce adjacent dots and strip trailing dots within a component.
        // xfers Path ==> TempPath
        //

        for(Dot=FALSE,p=Path,q=TempPath; *p; p++) {

            if(*p == L'.') {

                Dot = TRUE;

            } else  {

                if(Dot && (*p != L'\\')) {
                    *q++ = L'.';
                }
                Dot = FALSE;
                *q++ = *p;
            }
        }
        *q = 0;

        wcscpy(Path,TempPath);
    }        
}

ULONG
SpGetMaxNtDirLen( VOID )
{
        return( MAX_NT_DIR_LEN );
}

VOID
SpDeleteExistingTargetDir(
    IN  PDISK_REGION     Region,
    IN  PWSTR            NtDir,
    IN  BOOLEAN          GaugeNeeded,
    IN  DWORD            MsgId
    )
/*

    Parameters :
    
        Region  - Pointer to Region structure associated with the partition that contains the OS
        NtDir   - The directory to recursively delete
        GaugeNeeded - Should we display a gauge while deleting the dir ?
        MsgId   - Use this if you want to display a title message

*/

{
    ENUMFILESRESULT Result;
    PWSTR FullNtPath;
    NTSTATUS Status, Stat;
    PULONG RecursiveOperation;

    if( MsgId )
        SpDisplayScreen(MsgId, 3, 4 );

    SpNtNameFromRegion(
        Region,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    SpConcatenatePaths( TemporaryBuffer, NtDir );

    FullNtPath = SpDupStringW(TemporaryBuffer);


    // First try and delete the install directory
    // This is to see if itself is a reparse point. Also if it is just an empty dir
    // then we save time.

    Stat = SpDeleteFileEx( FullNtPath,
                        NULL,
                        NULL,
                        FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT );


    if(NT_SUCCESS(Stat)){
        SpMemFree( FullNtPath);
        return;  // We are done
    }



    RecursiveOperation = SpMemAlloc(sizeof(ULONG));
    ASSERT( RecursiveOperation );

    //
    // Do the counting phase for the clean-up
    //

    *RecursiveOperation = SP_COUNT_FILESTODELETE;

    SpDisplayStatusText(SP_STAT_SETUP_IS_EXAMINING_DIRS,DEFAULT_STATUS_ATTRIBUTE);

    Result = SpEnumFilesRecursiveDel(
        FullNtPath,
        SpDelEnumFileAndDirectory,
        &Status,
        RecursiveOperation);

    //
    // Now do the cleanup (actual deleting)
    //

    FileDeleteGauge = NULL;
    if( GaugeNeeded ){
        SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),SP_TEXT_SETUP_IS_DELETING);
        FileDeleteGauge = SpCreateAndDisplayGauge(*RecursiveOperation,0,15,TemporaryBuffer,NULL,GF_PERCENTAGE,0);
        ASSERT(FileDeleteGauge);
    }

    *RecursiveOperation = SP_DELETE_FILESTODELETE;

    Result = SpEnumFilesRecursiveDel(
        FullNtPath,
        SpDelEnumFileAndDirectory,
        &Status,
        RecursiveOperation);

    //Delete the main parent as the recursive call only cleans out everythin below it

    Stat = SpDeleteFileEx( FullNtPath,
                        NULL,
                        NULL,
                        FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT );

    if(!NT_SUCCESS(Stat) && (Stat != STATUS_OBJECT_NAME_NOT_FOUND)) {
         KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Dir Not Deleted - Status - %ws (%lx)\n", (PWSTR)FullNtPath, Stat));
    }

    if (GaugeNeeded) {
        SpDestroyGauge(FileDeleteGauge);
        FileDeleteGauge = NULL;
    }
    

    SpMemFree( FullNtPath );
    SpMemFree( RecursiveOperation );

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spudp.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spudp.h

Abstract:

    Public header file for supporting UDP conversations during setup

Author:

    Sean Selitrennikoff (v-seasel) 16-Jun-1998

Revision History:

--*/


#ifndef _SPUDP_DEFN_
#define _SPUDP_DEFN_

#define BINL_DEFAULT_PORT 4011

extern ULONG RemoteServerIpAddress;
extern ULONG SpUdpSendSequenceNumber;
extern KSPIN_LOCK SpUdpLock;
extern KIRQL SpUdpOldIrql;

typedef NTSTATUS (CALLBACK * SPUDP_RECEIVE_FN)(PVOID DataBuffer, ULONG DataBufferLength);

NTSTATUS
SpUdpConnect(
    VOID
    );


NTSTATUS
SpUdpDisconnect(
    VOID
    );

NTSTATUS
SpUdpSendAndReceiveDatagram(
    IN PVOID                 SendBuffer,
    IN ULONG                 SendBufferLength,
    IN ULONG                 RemoteHostAddress,
    IN USHORT                RemoteHostPort,
    IN SPUDP_RECEIVE_FN      SpUdpReceiveFunc
    );

#endif // _SPUDP_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\sptxtfil.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    sptxtfil.c

Abstract:

    Routines to load and extract information from
    setup text files.

Author:

    Ted Miller (tedm) 4-Aug-1993

Revision History:

--*/



#include "spprecmp.h"
#pragma hdrstop
#include <setupapi.h>

BOOLEAN HandleLineContinueChars = TRUE;

//
// We often need an empty string while processing the inf files.  Rather
// than incur the overhead of allocating memory for an empty string, we'll
// just point to this empty string for all cases.
//
PWSTR  CommonStrings[11] =
    { (PWSTR)(L"0"),
      (PWSTR)(L"1"),
      (PWSTR)(L"2"),
      (PWSTR)(L"3"),
      (PWSTR)(L"4"),
      (PWSTR)(L"5"),
      (PWSTR)(L"6"),
      (PWSTR)(L"7"),
      (PWSTR)(L"8"),
      (PWSTR)(L"9"),
      (PWSTR)(L"")
    };

PVOID
ParseInfBuffer(
    PWCHAR  Buffer,
    ULONG   Size,
    PULONG  ErrorLine
    );

NTSTATUS
SppWriteTextToFile(
    IN PVOID Handle,
    IN PWSTR String
    );

BOOLEAN
pSpAdjustRootAndSubkeySpec(
    IN  PVOID    SifHandle,
    IN  LPCWSTR  RootKeySpec,
    IN  LPCWSTR  SubkeySpec,
    IN  HANDLE   HKLM_SYSTEM,
    IN  HANDLE   HKLM_SOFTWARE,
    IN  HANDLE   HKCU,
    IN  HANDLE   HKR,
    OUT HANDLE  *RootKey,
    OUT LPWSTR   Subkey
    );



NTSTATUS
SpLoadSetupTextFile(
    IN  PWCHAR  Filename,   OPTIONAL
    IN  PVOID   Image,      OPTIONAL
    IN  ULONG   ImageSize,  OPTIONAL
    OUT PVOID  *Handle,
    OUT PULONG  ErrorLine,
    IN  BOOLEAN ClearScreen,
    IN  BOOLEAN ScreenNotReady
    )

/*++

Routine Description:

    Load a setup text file into memory.

Arguments:

    Filename - If specified, supplies full filename (in NT namespace)
        of the file to be loaded. Oneof Image or Filename must be specified.

    Image - If specified, supplies a pointer to an image of the file
        already in memory. One of Image or Filename must be specified.

    ImageSize - if Image is specified, then this parameter supplies the
        size of the buffer pointed to by Image.  Ignored otherwise.

    Handle - receives handle to loaded file, which can be
        used in subsequent calls to other text file services.

    ErrorLine - receives line number of syntax error, if parsing fails.

    ClearScreen - supplies boolean value indicating whether to clear the
        screen.

    ScreenNotReady - Indicates that this function was invoked during the initialization
                     of setupdd.sys, and that the screen is not ready yet for output.
                     If this flag is set, then this function will not clear the screen or update
                     the status line.


Return Value:

    STATUS_SUCCESS - file was read and parsed successfully.
        In this case, Handle is filled in.

    STATUS_UNSUCCESSFUL - syntax error in file.  In this case, ErrorLine
        is filled in.

    STATUS_NO_MEMORY - unable to allocate memory while parsing.

    STATUS_IN_PAGE_ERROR - i/o error while reading the file.

--*/

{
    HANDLE hFile;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING FilenameU;
    OBJECT_ATTRIBUTES oa;
    PWCHAR pText;
    ULONG cbText;
    HANDLE hSection;
    PVOID UnmapAddress;
    PWCHAR UniText = NULL;
    BOOLEAN LoadFromFile;

    // Set Errorline to zero to take care of default failure case

    if(ErrorLine)
        *ErrorLine=0;

    //
    // Argument validation -- one of Filename or Image must be specified,
    // but not both.
    //
    ASSERT(!(Filename && Image));
    ASSERT(Filename || Image);

    LoadFromFile = (BOOLEAN)(Filename != NULL);
    if(ScreenNotReady) {
        ClearScreen = FALSE;
    }
    if(ClearScreen) {
        CLEAR_CLIENT_SCREEN();
    }

    if(LoadFromFile) {

        if(!ScreenNotReady) {
            SpDisplayStatusText(
                SP_STAT_LOADING_SIF,
                DEFAULT_STATUS_ATTRIBUTE,
                wcsrchr(Filename,L'\\')+1
                );
        }

        //
        // Open the file.
        //
        RtlInitUnicodeString(&FilenameU,Filename);
        InitializeObjectAttributes(&oa,&FilenameU,OBJ_CASE_INSENSITIVE,NULL,NULL);
        Status = ZwCreateFile(
                    &hFile,
                    FILE_GENERIC_READ,
                    &oa,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ,
                    FILE_OPEN,
                    0,
                    NULL,
                    0
                    );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpLoadSetupTextFile: unable to open file %ws (%lx)\n",Filename,Status));
            goto ltf0;
        }

        //
        // Get the file size.
        //
        Status = SpGetFileSize(hFile,&cbText);
        if(!NT_SUCCESS(Status)) {
            goto ltf1;
        }

        //
        // Map the file.
        //
        Status = SpMapEntireFile(hFile,&hSection,&pText,FALSE);
        if(!NT_SUCCESS(Status)) {
            goto ltf1;
        }

        UnmapAddress = pText;

    } else {

        if(!ScreenNotReady) {
            SpDisplayStatusText(SP_STAT_PROCESSING_SIF,DEFAULT_STATUS_ATTRIBUTE);
        }

        pText = Image;
        cbText = ImageSize;

        Status = STATUS_SUCCESS;  // We are now ready to go to the next block.
    }


    //
    // See if we think the file is Unicode.  We think it's Unicode
    // if it's even length and starts with the Unicode text marker.
    //
    try {

        if((*pText == 0xfeff) && !(cbText & 1)) {

            //
            // Assume it's already unicode.
            //
            pText++;
            cbText -= sizeof(WCHAR);

        } else {

            //
            // It's not Unicode. Convert it from OEM to Unicode.
            //
            // Allocate a buffer large enough to hold the maximum
            // unicode text.  This max size occurs when
            // every character is single-byte, and this size is
            // equal to exactly double the size of the single-byte text.
            //
            if(UniText = SpMemAllocEx(cbText*sizeof(WCHAR),'1teS', PagedPool)) {

                Status = RtlOemToUnicodeN(
                            UniText,                // output: newly allocatd buffer
                            cbText * sizeof(WCHAR), // max size of output
                            &cbText,                // receives # bytes in unicode text
                            (PUCHAR)pText,          // input: oem text (mapped file)
                            cbText                  // size of input
                            );

                if(NT_SUCCESS(Status)) {
                    pText = UniText;                // Use newly converted Unicode text
                }

            } else {
                Status = STATUS_NO_MEMORY;
            }
        }
    } except(IN_PAGE_ERROR) {
        Status = STATUS_IN_PAGE_ERROR;
    }

    //
    // Process the file.
    //
    if(NT_SUCCESS(Status)) {

        try {
            if((*Handle = ParseInfBuffer(pText,cbText,ErrorLine)) == (PVOID)NULL) {
                Status = STATUS_UNSUCCESSFUL;
            } else {
                Status = STATUS_SUCCESS;
            }
        } except(IN_PAGE_ERROR) {
            Status = STATUS_IN_PAGE_ERROR;
        }
    }

    //
    // Free the unicode text buffer if we allocated it.
    //
    if(UniText) {
        SpMemFree(UniText);
    }

    //
    // Unmap the file.
    //
  //ltf2:

    if(LoadFromFile) {
        SpUnmapFile(hSection,UnmapAddress);
    }

  ltf1:
    //
    // Close the file.
    //
    if(LoadFromFile) {
        ZwClose(hFile);
    }

  ltf0:

    return(Status);
}

//
// [Strings] section types.
//
typedef enum {
    StringsSectionNone,
    StringsSectionPlain,
    StringsSectionLoosePrimaryMatch,
    StringsSectionExactPrimaryMatch,
    StringsSectionExactMatch
} StringsSectionType;


typedef struct _TEXTFILE_VALUE {
    struct _TEXTFILE_VALUE *pNext;
    PWCHAR                  pName;
} TEXTFILE_VALUE, *PTEXTFILE_VALUE;

typedef struct _TEXTFILE_LINE {
    struct _TEXTFILE_LINE *pNext;
    PWCHAR                  pName;
    PTEXTFILE_VALUE         pValue;
} TEXTFILE_LINE, *PTEXTFILE_LINE;

typedef struct _TEXTFILE_SECTION {
    struct _TEXTFILE_SECTION *pNext;
    PWCHAR                    pName;
    PTEXTFILE_LINE            pLine;
    PTEXTFILE_LINE            PreviouslyFoundLine;
} TEXTFILE_SECTION, *PTEXTFILE_SECTION;

typedef struct _TEXTFILE {
    PTEXTFILE_SECTION pSection;
    PTEXTFILE_SECTION PreviouslyFoundSection;
    PTEXTFILE_SECTION StringsSection;
    StringsSectionType StringsSectionType;
} TEXTFILE, *PTEXTFILE;

//
// DEFINES USED FOR THE PARSER INTERNALLY
//
//
// typedefs used
//

typedef enum _tokentype {
    TOK_EOF,
    TOK_EOL,
    TOK_LBRACE,
    TOK_RBRACE,
    TOK_STRING,
    TOK_EQUAL,
    TOK_COMMA,
    TOK_ERRPARSE,
    TOK_ERRNOMEM
} TOKENTYPE, *PTOKENTTYPE;


typedef struct _token {
    TOKENTYPE Type;
    PWCHAR    pValue;
} TOKEN, *PTOKEN;


//
// Routine defines
//

NTSTATUS
SpAppendSection(
    IN PWCHAR pSectionName
    );

NTSTATUS
SpAppendLine(
    IN PWCHAR pLineKey
    );

NTSTATUS
SpAppendValue(
    IN PWCHAR pValueString
    );

TOKEN
SpGetToken(
    IN OUT PWCHAR *Stream,
    IN PWCHAR     MaxStream,
    IN OUT PULONG LineNumber
    );

// what follows was alinf.c

//
// Internal Routine Declarations for freeing inf structure members
//

VOID
FreeSectionList (
   IN PTEXTFILE_SECTION pSection
   );

VOID
FreeLineList (
   IN PTEXTFILE_LINE pLine
   );

VOID
FreeValueList (
   IN PTEXTFILE_VALUE pValue
   );


//
// Internal Routine declarations for searching in the INF structures
//


PTEXTFILE_VALUE
SearchValueInLine(
   IN PTEXTFILE_LINE pLine,
   IN ULONG ValueIndex
   );

PTEXTFILE_LINE
SearchLineInSectionByKey(
   IN PTEXTFILE_SECTION pSection,
   IN PWCHAR    Key
   );

PTEXTFILE_LINE
SearchLineInSectionByIndex(
   IN PTEXTFILE_SECTION pSection,
   IN ULONG    LineIndex
   );

PTEXTFILE_SECTION
SearchSectionByName(
   IN PTEXTFILE pINF,
   IN LPCWSTR    SectionName
   );

PWCHAR
SpProcessForSimpleStringSub(
    IN PTEXTFILE pInf,
    IN PWCHAR    String
    );


PVOID
SpNewSetupTextFile(
    VOID
    )
{
    PTEXTFILE pFile;

    pFile = SpMemAllocEx(sizeof(TEXTFILE),'2teS', PagedPool);

    RtlZeroMemory(pFile,sizeof(TEXTFILE));
    return(pFile);
}


VOID
SpAddLineToSection(
    IN PVOID Handle,
    IN PWSTR SectionName,
    IN PWSTR KeyName,       OPTIONAL
    IN PWSTR Values[],
    IN ULONG ValueCount
    )
{
    PTEXTFILE_SECTION pSection;
    PTEXTFILE_LINE pLine;
    PTEXTFILE_VALUE pValue,PrevVal;
    PTEXTFILE pFile;
    ULONG v;
    ULONG nameLength;

    pFile = (PTEXTFILE)Handle;

    //
    // If the section doesn't exist, create it.
    //
    pSection = SearchSectionByName(pFile,SectionName);
    if(!pSection) {
        nameLength = (wcslen(SectionName) + 1) * sizeof(WCHAR);
        pSection = SpMemAllocEx(sizeof(TEXTFILE_SECTION) + nameLength,'3teS', PagedPool);
        RtlZeroMemory(pSection,sizeof(TEXTFILE_SECTION));

        pSection->pNext = pFile->pSection;
        pFile->pSection = pSection;

        pSection->pName = (PWCHAR)(pSection + 1);
        RtlCopyMemory( pSection->pName, SectionName, nameLength );
    }

    //
    // if the line already exists, then overwrite it
    //
    if (KeyName && (pLine = SearchLineInSectionByKey(pSection,KeyName))) {
        FreeValueList(pLine->pValue);   
    } else {
    
        //
        // Create a structure for the line in the section.
        //
        if (KeyName) {
            nameLength = (wcslen(KeyName) + 1) * sizeof(WCHAR);
        } else {
            nameLength = 0;
        }
    
        pLine = SpMemAllocEx(sizeof(TEXTFILE_LINE) + nameLength,'4teS', PagedPool);
        RtlZeroMemory(pLine,sizeof(TEXTFILE_LINE));
    
        pLine->pNext = pSection->pLine;
        pSection->pLine = pLine;
    
        if(KeyName) {
            pLine->pName = (PWCHAR)(pLine + 1);
            RtlCopyMemory( pLine->pName, KeyName, nameLength );
        }

    }

    //
    // Create value entries for each specified value.
    // These must be kept in the order they were specified.
    //
    for(v=0; v<ValueCount; v++) {

        nameLength = (wcslen(Values[v]) + 1) * sizeof(WCHAR);

        pValue = SpMemAllocEx(sizeof(TEXTFILE_VALUE) + nameLength,'5teS', PagedPool);
        RtlZeroMemory(pValue,sizeof(TEXTFILE_VALUE));

        pValue->pName = (PWCHAR)(pValue + 1);
        RtlCopyMemory( pValue->pName, Values[v], nameLength );

        if(v == 0) {
            pLine->pValue = pValue;
        } else {
            PrevVal->pNext = pValue;
        }
        PrevVal = pValue;
    }    
}


NTSTATUS
SpWriteSetupTextFile(
    IN PVOID Handle,
    IN PWSTR FilenamePart1,
    IN PWSTR FilenamePart2, OPTIONAL
    IN PWSTR FilenamePart3  OPTIONAL
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    HANDLE hFile;
    PWSTR p;
    PTEXTFILE pFile;
    PTEXTFILE_SECTION pSection;
    PTEXTFILE_LINE pLine;
    PTEXTFILE_VALUE pValue;

    //
    // Do this because it takes care of read-only attributes, etc.
    // Do it before starting to use TemporaryBuffer.
    //
    SpDeleteFile(FilenamePart1,FilenamePart2,FilenamePart3);

    p = TemporaryBuffer;

    wcscpy(p,FilenamePart1);
    if(FilenamePart2) {
        SpConcatenatePaths(p,FilenamePart2);
    }
    if(FilenamePart3) {
        SpConcatenatePaths(p,FilenamePart3);
    }

    INIT_OBJA(&Obja,&UnicodeString, p);

    Status = ZwCreateFile(
                &hFile,
                FILE_ALL_ACCESS,
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                0,                          // no sharing
                FILE_OVERWRITE_IF,
                FILE_SYNCHRONOUS_IO_ALERT | FILE_NON_DIRECTORY_FILE,
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open .sif file %ws (%lx)\n",p, Status ));
        return(Status);
    }

    //
    // Write out the file contents.
    //
    pFile = (PTEXTFILE)Handle;

    for(pSection=pFile->pSection; pSection; pSection=pSection->pNext) {

        swprintf(p,L"[%s]\r\n",pSection->pName);
        Status = SppWriteTextToFile( hFile, p );
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SppWriteTextToFile() failed. Status = %lx \n", Status));
            goto wtf1;
        }

        for(pLine=pSection->pLine; pLine; pLine=pLine->pNext) {

            wcscpy( p, L"" );
            //
            // Write the keyname if there is one.
            //
            if(pLine->pName) {
                BOOLEAN AddDoubleQuotes;

                AddDoubleQuotes = (wcschr(pLine->pName, (WCHAR)' ') == NULL)? FALSE : TRUE;
                if( AddDoubleQuotes ) {
                    wcscat(p,L"\"");
                }
                wcscat(p,pLine->pName);
                if( AddDoubleQuotes ) {
                    wcscat(p,L"\"");
                }
                wcscat(p,L" = ");
            }

            for(pValue=pLine->pValue; pValue; pValue=pValue->pNext) {

                if(pValue != pLine->pValue) {
                    wcscat(p,L",");
                }

                wcscat(p,L"\"");
                wcscat(p,pValue->pName);
                wcscat(p,L"\"");
            }

            if(!pLine->pValue) {
                wcscat(p,L"\"\"");
            }
            wcscat(p,L"\r\n");
            Status = SppWriteTextToFile( hFile, p );
            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SppWriteTextToFile() failed. Status = %lx \n", Status));
                goto wtf1;
            }
        }
    }

wtf1:
    ZwClose(hFile);

    return(Status);
}


BOOLEAN
SpFreeTextFile(
   IN PVOID Handle
   )

/*++

Routine Description:

    Frees a text file.

Arguments:


Return Value:

    TRUE.

--*/

{
   PTEXTFILE pINF;

   ASSERT(Handle);

   //
   // cast the buffer into an INF structure
   //

   pINF = (PTEXTFILE)Handle;

   FreeSectionList(pINF->pSection);

   //
   // free the inf structure too
   //

   SpMemFree(pINF);

   return(TRUE);
}


VOID
FreeSectionList (
   IN PTEXTFILE_SECTION pSection
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PTEXTFILE_SECTION Next;

    while(pSection) {
        Next = pSection->pNext;
        FreeLineList(pSection->pLine);
        if ((pSection->pName != (PWCHAR)(pSection + 1)) && (pSection->pName != NULL)) {
            SpMemFree(pSection->pName);
        }
        SpMemFree(pSection);
        pSection = Next;
    }
}


VOID
FreeLineList (
   IN PTEXTFILE_LINE pLine
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PTEXTFILE_LINE Next;

    while(pLine) {
        Next = pLine->pNext;
        FreeValueList(pLine->pValue);
        if ((pLine->pName != (PWCHAR)(pLine + 1)) && (pLine->pName != NULL)) {
            SpMemFree(pLine->pName);
        }
        SpMemFree(pLine);
        pLine = Next;
    }
}

VOID
FreeValueList (
   IN PTEXTFILE_VALUE pValue
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PTEXTFILE_VALUE Next;

    while(pValue) {
        Next = pValue->pNext;
        if ((pValue->pName != (PWCHAR)(pValue + 1)) && (pValue->pName != NULL)) {
            SpMemFree(pValue->pName);
        }
        SpMemFree(pValue);
        pValue = Next;
    }
}


BOOLEAN
SpSearchTextFileSection (
    IN PVOID  Handle,
    IN PWCHAR SectionName
    )

/*++

Routine Description:

    Searches for the existance of a particular section.

Arguments:


Return Value:


--*/

{
    return((BOOLEAN)(SearchSectionByName((PTEXTFILE)Handle,SectionName) != NULL));
}




PWCHAR
SpGetSectionLineIndex(
    IN PVOID   Handle,
    IN LPCWSTR SectionName,
    IN ULONG   LineIndex,
    IN ULONG   ValueIndex
    )

/*++

Routine Description:

    Given section name, line number and index return the value.

Arguments:


Return Value:


--*/

{
    PTEXTFILE_SECTION pSection;
    PTEXTFILE_LINE    pLine;
    PTEXTFILE_VALUE   pValue;

    if((pSection = SearchSectionByName((PTEXTFILE)Handle,SectionName)) == NULL) {
        return(NULL);
    }

    if((pLine = SearchLineInSectionByIndex(pSection,LineIndex)) == NULL) {
        return(NULL);
    }

    if((pValue = SearchValueInLine(pLine,ValueIndex)) == NULL) {
        return(NULL);
    }

    return(SpProcessForSimpleStringSub(Handle,pValue->pName));
}


BOOLEAN
SpGetSectionKeyExists (
   IN PVOID  Handle,
   IN PWCHAR SectionName,
   IN PWCHAR Key
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PTEXTFILE_SECTION pSection;

    if((pSection = SearchSectionByName((PTEXTFILE)Handle,SectionName)) == NULL) {
        return(FALSE);
    }

    if(SearchLineInSectionByKey(pSection,Key) == NULL) {
        return(FALSE);
    }

    return(TRUE);
}


PWCHAR
SpGetKeyName(
    IN PVOID   Handle,
    IN LPCWSTR SectionName,
    IN ULONG   LineIndex
    )
{
    PTEXTFILE_SECTION pSection;
    PTEXTFILE_LINE    pLine;

    pSection = SearchSectionByName((PTEXTFILE)Handle,SectionName);
    if(pSection == NULL) {
        return(NULL);
    }

    pLine = SearchLineInSectionByIndex(pSection,LineIndex);
    if(pLine == NULL) {
        return(NULL);
    }

    return(pLine->pName);
}



PWCHAR
SpGetSectionKeyIndex (
   IN PVOID  Handle,
   IN PWCHAR SectionName,
   IN PWCHAR Key,
   IN ULONG  ValueIndex
   )

/*++

Routine Description:

    Given section name, key and index return the value

Arguments:


Return Value:


--*/

{
    PTEXTFILE_SECTION pSection;
    PTEXTFILE_LINE    pLine;
    PTEXTFILE_VALUE   pValue;

    if((pSection = SearchSectionByName((PTEXTFILE)Handle,SectionName)) == NULL) {
        return(NULL);
    }

    if((pLine = SearchLineInSectionByKey(pSection,Key)) == NULL) {
        return(NULL);
    }

    if((pValue = SearchValueInLine(pLine,ValueIndex)) == NULL) {
       return(NULL);
    }

    return(SpProcessForSimpleStringSub(Handle,pValue->pName));
}

ULONG
SpGetKeyIndex(
  IN PVOID Handle,
  IN PWCHAR SectionName,
  IN PWCHAR KeyName
  )
{
  ULONG Result = -1;

  if (SectionName && KeyName) {
    ULONG MaxLines = SpCountLinesInSection(Handle, SectionName);
    ULONG Index;
    PWSTR CurrKey = 0;

    for (Index=0; Index < MaxLines; Index++) {
      CurrKey = SpGetKeyName(Handle, SectionName, Index);

      if (CurrKey && !wcscmp(CurrKey, KeyName)) {
        Result = Index;

        break;
      }
    }
  }

  return Result;
}

ULONG
SpCountLinesInSection(
    IN PVOID Handle,
    IN PWCHAR SectionName
    )
{
    PTEXTFILE_SECTION pSection;
    PTEXTFILE_LINE    pLine;
    ULONG    Count;

    if((pSection = SearchSectionByName((PTEXTFILE)Handle,SectionName)) == NULL) {
        return(0);
    }

    for(pLine = pSection->pLine, Count = 0;
        pLine;
        pLine = pLine->pNext, Count++
       );

    return(Count);
}


PTEXTFILE_VALUE
SearchValueInLine(
    IN PTEXTFILE_LINE pLine,
    IN ULONG          ValueIndex
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PTEXTFILE_VALUE pValue;
    ULONG  i;

    if(pLine == NULL) {
       return(NULL);
    }

    pValue = pLine->pValue;
    for(i=0; (i<ValueIndex) && (pValue=pValue->pNext); i++) {
        ;
    }

    return pValue;
}


PTEXTFILE_LINE
SearchLineInSectionByKey(
    IN PTEXTFILE_SECTION pSection,
    IN PWCHAR            Key
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PTEXTFILE_LINE pLine,pFirstSearchedLine;

    //
    // Start at the line where we left off in the last search.
    //
    pLine = pFirstSearchedLine = pSection->PreviouslyFoundLine;

    while(pLine && ((pLine->pName == NULL) || _wcsicmp(pLine->pName,Key))) {
        pLine = pLine->pNext;
    }

    //
    // If we haven't found it yet, wrap around to the beginning of the section.
    //
    if(!pLine) {

        pLine = pSection->pLine;

        while(pLine && (pLine != pFirstSearchedLine)) {

            if(pLine->pName && !_wcsicmp(pLine->pName,Key)) {
                break;
            }

            pLine = pLine->pNext;
        }

        //
        // If we wrapped around to the first line we searched,
        // then we didn't find the line we're looking for.
        //
        if(pLine == pFirstSearchedLine) {
            pLine = NULL;
        }
    }

    //
    // If we found the line, save it away so we can resume the
    // search from that point the next time we are called.
    //
    if(pLine) {
        pSection->PreviouslyFoundLine = pLine;
    }

    return pLine;
}


PTEXTFILE_LINE
SearchLineInSectionByIndex(
    IN PTEXTFILE_SECTION pSection,
    IN ULONG             LineIndex
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PTEXTFILE_LINE pLine;
    ULONG  i;

    //
    // Validate the parameters passed in
    //

    if(pSection == NULL) {
        return(NULL);
    }

    //
    // find the start of the line list in the section passed in
    //

    pLine = pSection->pLine;

    //
    // traverse down the current line list to the LineIndex th line
    //

    for(i=0; (i<LineIndex) && (pLine = pLine->pNext); i++) {
       ;
    }

    //
    // return the Line found
    //

    return pLine;
}


PTEXTFILE_SECTION
SearchSectionByName(
    IN PTEXTFILE pINF,
    IN LPCWSTR   SectionName
    )
{
    PTEXTFILE_SECTION pSection,pFirstSearchedSection;

    //
    // find the section list
    //
    pSection = pFirstSearchedSection = pINF->PreviouslyFoundSection;

    //
    // traverse down the section list searching each section for the section
    // name mentioned
    //

    while(pSection && _wcsicmp(pSection->pName,SectionName)) {
        pSection = pSection->pNext;
    }

    //
    // If we didn't find it so far, search the beginning of the file.
    //
    if(!pSection) {

        pSection = pINF->pSection;

        while(pSection && (pSection != pFirstSearchedSection)) {

            if(pSection->pName && !_wcsicmp(pSection->pName,SectionName)) {
                break;
            }

            pSection = pSection->pNext;
        }

        //
        // If we wrapped around to the first section we searched,
        // then we didn't find the section we're looking for.
        //
        if(pSection == pFirstSearchedSection) {
            pSection = NULL;
        }
    }

    if(pSection) {
        pINF->PreviouslyFoundSection = pSection;
    }

    //
    // return the section at which we stopped (either NULL or the section
    // which was found).
    //

    return pSection;
}


PWCHAR
SpProcessForSimpleStringSub(
    IN PTEXTFILE pInf,
    IN PWCHAR    String
    )
{
    UINT Len;
    PWCHAR ReturnString;
    PTEXTFILE_SECTION pSection;
    PTEXTFILE_LINE pLine;

    //
    // Assume no substitution necessary.
    //
    ReturnString = String;

    //
    // If it starts and end with % then look it up in the
    // strings section. Note the initial check before doing a
    // wcslen, to preserve performance in the 99% case where
    // there is no substitution.
    //
    if((String[0] == L'%') && ((Len = wcslen(String)) > 2) && (String[Len-1] == L'%')
    && (pSection = pInf->StringsSection)) {

        for(pLine = pSection->pLine; pLine; pLine=pLine->pNext) {
            if(pLine->pName
            && !_wcsnicmp(pLine->pName,String+1,Len-2)
            && (pLine->pName[Len-2] == 0)) {
                break;
            }
        }

        if(pLine && pLine->pValue && pLine->pValue->pName) {
            ReturnString = pLine->pValue->pName;
        }
    }

    return(ReturnString);
}


VOID
SpProcessForStringSubs(
    IN  PVOID   SifHandle,
    IN  LPCWSTR StringIn,
    OUT LPWSTR  StringOut,
    IN  ULONG   BufferSizeChars
    )
{
    LPCWSTR In,q;
    LPWSTR Out,p;
    WCHAR Str[511];
    ULONG Len,i;
    WCHAR *End;

    In = StringIn;
    Out = StringOut;
    End = Out + BufferSizeChars;

    while(*In) {
        if(*In == L'%') {
            //
            // Double % in input ==> single % in output
            //
            if(*(++In) == L'%') {
                if(Out < End) {
                    *Out++ = L'%';
                }
                In++;
            } else {
                //
                // Look for terminating %.
                //
                if(p = wcschr(In,L'%')) {
                    //
                    // Get value to substitute. If we can't find the value,
                    // put the whole string like %abc% in there.
                    //
                    Len = (ULONG)(p - In);
                    if(Len > ((sizeof(Str)/sizeof(WCHAR))-1)) {
                        //
                        // We can't handle substitutions for tokens this long.
                        // We'll just bail in this case, and copy over the token as-is.
                        //
                        q = NULL;
                    } else {
                        RtlCopyMemory(Str,In-1,(Len+2)*sizeof(WCHAR));
                        Str[Len+2] = 0;

                        q = SpProcessForSimpleStringSub(SifHandle,Str);
                        if(q == Str) {
                            q = NULL;
                        }
                    }
                    if(q) {
                        Len = wcslen(q);
                        for(i=0; i<Len; i++) {
                            if(Out < End) {
                                *Out++ = q[i];
                            }
                        }
                        In = p+1;
                    } else {
                        //
                        // Len is the length of the internal part (the abc in %abc%).
                        //
                        if(Out < End) {
                            *Out++ = L'%';
                        }
                        for(i=0; i<=Len; i++, In++) {
                            if(Out < End) {
                                *Out++ = *In;
                            }
                        }
                    }
                } else {
                    //
                    // No terminating %. So we have something like %abc.
                    // Want to put %abc in the output. Put the % in here
                    // manually and then just let subsequent passes
                    // through the loop copy the rest of the chars.
                    //
                    if(Out < End) {
                        *Out++ = L'%';
                    }
                }
            }
        } else {
            //
            // Plain char.
            //
            if(Out < End) {
                *Out++ = *In;
            }
            In++;
        }
    }

    *Out = 0;
}


//
//  Globals used to make building the lists easier
//

PTEXTFILE         pINF;
PTEXTFILE_SECTION pSectionRecord;
PTEXTFILE_LINE    pLineRecord;
PTEXTFILE_VALUE   pValueRecord;


//
// Globals used by the token parser
//

// string terminators are the whitespace characters (isspace: space, tab,
// linefeed, formfeed, vertical tab, carriage return) or the chars given below

WCHAR  StringTerminators[] = L"[]=,\t \"\n\f\v\r";

PWCHAR QStringTerminators = StringTerminators+6;


//
// Main parser routine
//

PVOID
ParseInfBuffer(
    PWCHAR Buffer,
    ULONG  Size,
    PULONG ErrorLine
    )

/*++

Routine Description:

   Given a character buffer containing the INF file, this routine parses
   the INF into an internal form with Section records, Line records and
   Value records.

Arguments:

   Buffer - contains to ptr to a buffer containing the INF file

   Size - contains the size of the buffer in bytes.

   ErrorLine - if a parse error occurs, this variable receives the line
        number of the line containing the error.


Return Value:

   PVOID - INF handle ptr to be used in subsequent INF calls.

--*/

{
    PWCHAR     Stream, MaxStream, pchSectionName = NULL, pchValue = NULL;
    ULONG      State, InfLine;
    TOKEN      Token;
    BOOLEAN    Done;
    BOOLEAN    Error;
    NTSTATUS   ErrorCode;

    //
    // Initialise the globals
    //
    pINF            = NULL;
    pSectionRecord  = NULL;
    pLineRecord     = NULL;
    pValueRecord    = NULL;

    //
    // Get INF record
    //
    if((pINF = SpMemAllocEx(sizeof(TEXTFILE),'6teS', PagedPool)) == NULL) {
        return NULL;
    }

    RtlZeroMemory(pINF,sizeof(TEXTFILE));

    //
    // Set initial state
    //
    State     = 1;
    InfLine   = 1;
    Stream    = Buffer;
    MaxStream = Buffer + (Size/sizeof(WCHAR));
    Done      = FALSE;
    Error     = FALSE;

    //
    // Enter token processing loop
    //

    while (!Done)       {

       Token = SpGetToken(&Stream, MaxStream, &InfLine);

       switch (State) {
       //
       // STATE1: Start of file, this state remains till first
       //         section is found
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_LBRACE, TOK_STRING
       //               TOK_STRING occurs when reading dblspace.ini
       //
       case 1:
           switch (Token.Type) {
              case TOK_EOL:
                  break;
              case TOK_EOF:
                  Done = TRUE;
                  break;
              case TOK_LBRACE:
                  State = 2;
                  break;
              case TOK_STRING:
                  pchSectionName = SpMemAllocEx( ( wcslen( DBLSPACE_SECTION ) + 1 )*sizeof( WCHAR ),'7teS', PagedPool );
                  if( pchSectionName == NULL ) {
                        Error = Done = TRUE;
                        ErrorCode = STATUS_NO_MEMORY;
                  }
                  wcscpy( pchSectionName, DBLSPACE_SECTION );
                  pchValue = Token.pValue;
                  if ((ErrorCode = SpAppendSection(pchSectionName)) != STATUS_SUCCESS) {
                    Error = Done = TRUE;
                    ErrorCode = STATUS_UNSUCCESSFUL;
                  } else {
                    pchSectionName = NULL;
                    State = 6;
                  }
                  break;
              default:
                  Error = Done = TRUE;
                  ErrorCode = STATUS_UNSUCCESSFUL;
                  break;
           }
           break;

       //
       // STATE 2: Section LBRACE has been received, expecting STRING or RBRACE
       //
       // Valid Tokens: TOK_STRING, TOK_RBRACE
       //
       case 2:
           switch (Token.Type) {
              case TOK_STRING:
                  State = 3;
                  pchSectionName = Token.pValue;
                  break;

              case TOK_RBRACE:
                  State = 4;
                  pchSectionName = CommonStrings[10];
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = STATUS_UNSUCCESSFUL;
                  break;

           }
           break;

       //
       // STATE 3: Section Name received, expecting RBRACE
       //
       // Valid Tokens: TOK_RBRACE
       //
       case 3:
       switch (Token.Type) {
              case TOK_RBRACE:
                State = 4;
                break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = STATUS_UNSUCCESSFUL;
                  break;
           }
           break;
       //
       // STATE 4: Section Definition Complete, expecting EOL
       //
       // Valid Tokens: TOK_EOL, TOK_EOF
       //
       case 4:
           switch (Token.Type) {
              case TOK_EOL:
                  if ((ErrorCode = SpAppendSection(pchSectionName)) != STATUS_SUCCESS)
                    Error = Done = TRUE;
                  else {
                    pchSectionName = NULL;
                    State = 5;
                  }
                  break;

              case TOK_EOF:
                  if ((ErrorCode = SpAppendSection(pchSectionName)) != STATUS_SUCCESS)
                    Error = Done = TRUE;
                  else {
                    pchSectionName = NULL;
                    Done = TRUE;
                  }
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = STATUS_UNSUCCESSFUL;
                  break;
           }
           break;

       //
       // STATE 5: Expecting Section Lines
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_STRING, TOK_LBRACE
       //
       case 5:
           switch (Token.Type) {
              case TOK_EOL:
                  break;
              case TOK_EOF:
                  Done = TRUE;
                  break;
              case TOK_STRING:
                  pchValue = Token.pValue;
                  State = 6;
                  break;
              case TOK_LBRACE:
                  State = 2;
                  break;
              default:
                  Error = Done = TRUE;
                  ErrorCode = STATUS_UNSUCCESSFUL;
                  break;
           }
           break;

       //
       // STATE 6: String returned, not sure whether it is key or value
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA, TOK_EQUAL
       //
       case 6:
           switch (Token.Type) {
              case TOK_EOL:
                  if ( (ErrorCode = SpAppendLine(NULL)) != STATUS_SUCCESS ||
                       (ErrorCode = SpAppendValue(pchValue)) !=STATUS_SUCCESS )
                      Error = Done = TRUE;
                  else {
                      pchValue = NULL;
                      State = 5;
                  }
                  break;

              case TOK_EOF:
                  if ( (ErrorCode = SpAppendLine(NULL)) != STATUS_SUCCESS ||
                       (ErrorCode = SpAppendValue(pchValue)) !=STATUS_SUCCESS )
                      Error = Done = TRUE;
                  else {
                      pchValue = NULL;
                      Done = TRUE;
                  }
                  break;

              case TOK_COMMA:
                  if ( (ErrorCode = SpAppendLine(NULL)) != STATUS_SUCCESS ||
                       (ErrorCode = SpAppendValue(pchValue)) !=STATUS_SUCCESS )
                      Error = Done = TRUE;
                  else {
                      pchValue = NULL;
                      State = 7;
                  }
                  break;

              case TOK_EQUAL:
                  if ( (ErrorCode = SpAppendLine(pchValue)) != STATUS_SUCCESS)
                      Error = Done = TRUE;
                  else {
                      pchValue = NULL;
                      State = 8;
                  }
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = STATUS_UNSUCCESSFUL;
                  break;
           }
           break;

       //
       // STATE 7: Comma received, Expecting another string
       //       Also allow a comma to indicate an empty value ie x = 1,,2
       //
       // Valid Tokens: TOK_STRING TOK_COMMA
       //
       case 7:
           switch (Token.Type) {
              case TOK_COMMA:
                  Token.pValue = CommonStrings[10];
                  if ((ErrorCode = SpAppendValue(Token.pValue)) != STATUS_SUCCESS)
                      Error = Done = TRUE;

                  //
                  // State stays at 7 because we are expecting a string
                  //
                  break;

              case TOK_STRING:
                  if ((ErrorCode = SpAppendValue(Token.pValue)) != STATUS_SUCCESS)
                      Error = Done = TRUE;
                  else
                     State = 9;

                  break;
              default:
                  Error = Done = TRUE;
                  ErrorCode = STATUS_UNSUCCESSFUL;
                  break;
           }
           break;
       //
       // STATE 8: Equal received, Expecting another string
       //          If none, assume there is a single empty string on the RHS
       //
       // Valid Tokens: TOK_STRING, TOK_EOL, TOK_EOF
       //
       case 8:
           switch (Token.Type) {
              case TOK_EOF:
                  Token.pValue = CommonStrings[10];
                  if((ErrorCode = SpAppendValue(Token.pValue)) != STATUS_SUCCESS) {
                      Error = TRUE;
                  }
                  Done = TRUE;
                  break;

              case TOK_EOL:
                  Token.pValue = CommonStrings[10];
                  if((ErrorCode = SpAppendValue(Token.pValue)) != STATUS_SUCCESS) {
                      Error = TRUE;
                      Done = TRUE;
                  } else {
                      State = 5;
                  }
                  break;

              case TOK_STRING:
                  if ((ErrorCode = SpAppendValue(Token.pValue)) != STATUS_SUCCESS)
                      Error = Done = TRUE;
                  else
                      State = 9;

                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = STATUS_UNSUCCESSFUL;
                  break;
           }
           break;
       //
       // STATE 9: String received after equal, value string
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA
       //
       case 9:
           switch (Token.Type) {
              case TOK_EOL:
                  State = 5;
                  break;

              case TOK_EOF:
                  Done = TRUE;
                  break;

              case TOK_COMMA:
                  State = 7;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = STATUS_UNSUCCESSFUL;
                  break;
           }
           break;
       //
       // STATE 10: Value string definitely received
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA
       //
       case 10:
           switch (Token.Type) {
              case TOK_EOL:
                  State =5;
                  break;

              case TOK_EOF:
                  Done = TRUE;
                  break;

              case TOK_COMMA:
                  State = 7;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = STATUS_UNSUCCESSFUL;
                  break;
           }
           break;

       default:
           Error = Done = TRUE;
           ErrorCode = STATUS_UNSUCCESSFUL;
           break;

       } // end switch(State)


       if (Error) {

           switch (ErrorCode) {
               case STATUS_UNSUCCESSFUL:
                  *ErrorLine = InfLine;
                  break;
               case STATUS_NO_MEMORY:
                  //SpxOutOfMemory();
                  break;
               default:
                  break;
           }

           SpFreeTextFile(pINF);
           if(pchSectionName) {
               SpMemFree(pchSectionName);
           }

           if(pchValue) {
               SpMemFree(pchValue);
           }

           pINF = NULL;
       }
       else {

          //
          // Keep track of line numbers so that we can display Errors
          //

          if(Token.Type == TOK_EOL) {
              InfLine++;
          }
       }

    } // End while

    if(pINF) {

        PTEXTFILE_SECTION p;

        pINF->PreviouslyFoundSection = pINF->pSection;

        for(p=pINF->pSection; p; p=p->pNext) {
            p->PreviouslyFoundLine = p->pLine;
        }
    }

    return(pINF);
}



NTSTATUS
SpAppendSection(
    IN PWCHAR pSectionName
    )

/*++

Routine Description:

    This appends a new section to the section list in the current INF.
    All further lines and values pertain to this new section, so it resets
    the line list and value lists too.

Arguments:

    pSectionName - Name of the new section. ( [SectionName] )

Return Value:

    STATUS_SUCCESS      if successful.
    STATUS_NO_MEMORY    if memory allocation failed.
    STATUS_UNSUCCESSFUL if invalid parameters passed in or the INF buffer not
                           initialised

--*/

{
    PTEXTFILE_SECTION pNewSection;
    StringsSectionType type;
    WCHAR *p;
    USHORT Id;
    USHORT ThreadLang;

    //
    // Check to see if INF initialised and the parameter passed in is valid
    //

    ASSERT(pINF);
    ASSERT(pSectionName);
    if((pINF == NULL) || (pSectionName == NULL)) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // See if we already have a section by this name. If so we want
    // to merge sections.
    //
    for(pNewSection=pINF->pSection; pNewSection; pNewSection=pNewSection->pNext) {
        if(pNewSection->pName && !_wcsicmp(pNewSection->pName,pSectionName)) {
            break;
        }
    }
    if(pNewSection) {
        //
        // Set pLineRecord to point to the list line currently in the section.
        //
        for(pLineRecord = pNewSection->pLine;
            pLineRecord && pLineRecord->pNext;
            pLineRecord = pLineRecord->pNext)
            ;

    } else {
        //
        // Allocate memory for the new section and initialize the structure.
        //
        if((pNewSection = SpMemAllocEx(sizeof(TEXTFILE_SECTION),'8teS', PagedPool)) == NULL) {
            return STATUS_NO_MEMORY;
        }
        RtlZeroMemory(pNewSection,sizeof(TEXTFILE_SECTION));
        pNewSection->pName = pSectionName;

        //
        // Link it in. Also track the [strings] sections in order of desirability:
        //
        // 1) Strings.xxxx where xxxx is the language id part of the current thread locale.
        // 2) Strings.xxxx where xxxx is the primary language id part of the thread locale.
        // 3) Stirngs.xxxx where the primary language id part of xxxx matches the
        //    primary language id part of the thread locale.
        // 4) Plain old [Strings].
        //
        pNewSection->pNext = pINF->pSection;
        pINF->pSection = pNewSection;

        if(!_wcsnicmp(pSectionName,L"Strings",7)) {

            type = StringsSectionNone;

            if(pSectionName[7] == L'.') {
                //
                // The langid part must be in the form of 4 hex digits.
                //
                Id = (USHORT)SpStringToLong(pSectionName+8,&p,16);
                if((p == pSectionName+8+5) && (*p == 0)) {

                    ThreadLang = LANGIDFROMLCID(NtCurrentTeb()->CurrentLocale);

                    if(ThreadLang == Id) {
                        type = StringsSectionExactMatch;
                    } else {
                        if(Id == PRIMARYLANGID(ThreadLang)) {
                            type = StringsSectionExactPrimaryMatch;
                        } else {
                            if(PRIMARYLANGID(Id) == PRIMARYLANGID(ThreadLang)) {
                                type = StringsSectionLoosePrimaryMatch;
                            }
                        }
                    }
                }
            } else {
                if(!pSectionName[7]) {
                    type = StringsSectionPlain;
                }
            }

            if(type > pINF->StringsSectionType) {
                pINF->StringsSection = pNewSection;
            }
        }

        //
        // reset the current line record
        //
        pLineRecord = NULL;
    }

    pSectionRecord = pNewSection;
    pValueRecord   = NULL;

    return STATUS_SUCCESS;
}


NTSTATUS
SpAppendLine(
    IN PWCHAR pLineKey
    )

/*++

Routine Description:

    This appends a new line to the line list in the current section.
    All further values pertain to this new line, so it resets
    the value list too.

Arguments:

    pLineKey - Key to be used for the current line, this could be NULL.

Return Value:

    STATUS_SUCCESS      if successful.
    STATUS_NO_MEMORY    if memory allocation failed.
    STATUS_UNSUCCESSFUL if invalid parameters passed in or current section not
                        initialised


--*/


{
    PTEXTFILE_LINE pNewLine;

    //
    // Check to see if current section initialised
    //

    ASSERT(pSectionRecord);
    if(pSectionRecord == NULL) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Allocate memory for the new Line
    //

    if((pNewLine = SpMemAllocEx(sizeof(TEXTFILE_LINE),'9teS', PagedPool)) == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // Link it in
    //
    pNewLine->pNext  = NULL;
    pNewLine->pValue = NULL;
    pNewLine->pName  = pLineKey;

    if (pLineRecord == NULL) {
        pSectionRecord->pLine = pNewLine;
    } else {
        pLineRecord->pNext = pNewLine;
    }

    pLineRecord  = pNewLine;

    //
    // Reset the current value record
    //

    pValueRecord = NULL;

    return STATUS_SUCCESS;
}



NTSTATUS
SpAppendValue(
    IN PWCHAR pValueString
    )

/*++

Routine Description:

    This appends a new value to the value list in the current line.

Arguments:

    pValueString - The value string to be added.

Return Value:

    STATUS_SUCCESS      if successful.
    STATUS_NO_MEMORY    if memory allocation failed.
    STATUS_UNSUCCESSFUL if invalid parameters passed in or current line not
                        initialised.

--*/

{
    PTEXTFILE_VALUE pNewValue;

    //
    // Check to see if current line record has been initialised and
    // the parameter passed in is valid
    //

    ASSERT(pLineRecord);
    ASSERT(pValueString);
    if((pLineRecord == NULL) || (pValueString == NULL)) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Allocate memory for the new value record
    //

    if((pNewValue = SpMemAllocEx(sizeof(TEXTFILE_VALUE),'ateS', PagedPool)) == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // Link it in.
    //

    pNewValue->pNext  = NULL;
    pNewValue->pName  = pValueString;

    if (pValueRecord == NULL) {
        pLineRecord->pValue = pNewValue;
    } else {
        pValueRecord->pNext = pNewValue;
    }

    pValueRecord = pNewValue;
    return STATUS_SUCCESS;
}

TOKEN
SpGetToken(
    IN OUT PWCHAR *Stream,
    IN PWCHAR      MaxStream,
    IN OUT PULONG LineNumber
    )

/*++

Routine Description:

    This function returns the Next token from the configuration stream.

Arguments:

    Stream - Supplies the address of the configuration stream.  Returns
        the address of where to start looking for tokens within the
        stream.

    MaxStream - Supplies the address of the last character in the stream.


Return Value:

    TOKEN - Returns the next token

--*/

{

    PWCHAR pch, pchStart, pchNew;
    ULONG  Length;
    TOKEN  Token;
    ULONG QuotedQuotes;

    //
    //  Skip whitespace (except for eol)
    //
    pch = *Stream;
    restart:
    while((pch < MaxStream) && (*pch != '\n') && SpIsSpace(*pch)) {
        pch++;
    }


    //
    // Check for comments and remove them
    //

    if((pch < MaxStream) && ((*pch == L';') || (*pch == L'#'))) {
        while((pch < MaxStream) && (*pch != L'\n')) {
            pch++;
        }
    }

    //
    // Check to see if EOF has been reached, set the token to the right
    // value
    //

    if((pch >= MaxStream) || (*pch == 26)) {
        *Stream = pch;
        Token.Type  = TOK_EOF;
        Token.pValue = NULL;
        return Token;
    }


    switch (*pch) {

    case L'[' :
        pch++;
        Token.Type  = TOK_LBRACE;
        Token.pValue = NULL;
        break;

    case L']' :
        pch++;
        Token.Type  = TOK_RBRACE;
        Token.pValue = NULL;
        break;

    case L'=' :
        pch++;
        Token.Type  = TOK_EQUAL;
        Token.pValue = NULL;
        break;

    case L',' :
        pch++;
        Token.Type  = TOK_COMMA;
        Token.pValue = NULL;
        break;

    case L'\n' :
        pch++;
        Token.Type  = TOK_EOL;
        Token.pValue = NULL;
        break;

    case L'\"':
        pch++;
        //
        // Determine quoted string. Within a quoted string, two double-quotes
        // in a row are replaced by a single double-quote. In the normal case
        // the number of characters in the string equals the number of
        // characters in the input field (minus 2 for the quotes) so we
        // preserve performance for that case. In the case where we have
        // quoted quotes, we have to filter the string from the input file
        // into our internal buffer to get rid of some quote chars.
        //
        // Note that in the txtsetup.sif case, setupldr has replaced all
        // terminating quote chars with nul chars in the image we're parsing,
        // so we have to deal with that here.
        //
        pchStart = pch;
        QuotedQuotes = 0;
        morequotedstring:
        while((pch < MaxStream) && *pch && !wcschr(QStringTerminators,*pch)) {
            pch++;
        }
        if(((pch+1) < MaxStream) && (*pch == L'\"') && (*(pch+1) == L'\"')) {
            QuotedQuotes++;
            pch += 2;
            goto morequotedstring;
        }

        if((pch >= MaxStream) || ((*pch != L'\"') && *pch)) {
            Token.Type   = TOK_ERRPARSE;
            Token.pValue = NULL;
        } else {
            Length = (ULONG)(((PUCHAR)pch - (PUCHAR)pchStart)/sizeof(WCHAR));
            if ((pchNew = SpMemAllocEx(((Length + 1) - QuotedQuotes) * sizeof(WCHAR),'bteS', PagedPool)) == NULL) {
                Token.Type = TOK_ERRNOMEM;
                Token.pValue = NULL;
            } else {
                if(Length) {    // Null quoted strings are allowed
                    if(QuotedQuotes) {
                        for(Length=0; pchStart<pch; pchStart++) {
                            if((pchNew[Length++] = *pchStart) == L'\"') {
                                //
                                // The only way this could happen is if there's
                                // another double-quote char after this one, since
                                // otherwise this would have terminated the string.
                                //
                                pchStart++;
                            }
                        }
                    } else {
                        wcsncpy(pchNew,pchStart,Length);
                    }
                }
                pchNew[Length] = 0;
                Token.Type = TOK_STRING;
                Token.pValue = pchNew;
            }
            pch++;   // advance past the quote
        }
        break;

    default:
        //
        // Check to see if we have a line continuation,
        // which is \ followed by only whitespace on the line
        //
        pchStart = pch;
        if((*pch == L'\\') && (HandleLineContinueChars)) {
            pch++;
            //
            // Keep skipping until we hit the end of the file,
            // or the newline, or a non-space character.
            //
            while((pch < MaxStream) && (*pch != L'\n') && SpIsSpace(*pch)) {
                pch++;
            }

            if(*pch == L'\n') {
                //
                // No non-space chars between the \ and the end of the line.
                // Ignore the newline.
                //
                pch++;
                *LineNumber = *LineNumber + 1;
                goto restart;
            } else {
                if(pch < MaxStream) {
                    //
                    // Not line continuation.
                    // Reset the input to the start of the field.
                    //
                    pch = pchStart;
                }
            }
        }

        //
        // determine regular string
        //
        pchStart = pch;
        while((pch < MaxStream) && (wcschr(StringTerminators,*pch) == NULL)) {
            pch++;
        }

        if (pch == pchStart) {
            pch++;
            Token.Type  = TOK_ERRPARSE;
            Token.pValue = NULL;
        }
        else {
            ULONG i;
            Length = (ULONG)(((PUCHAR)pch - (PUCHAR)pchStart)/sizeof(WCHAR));
            //
            // Check for a common string...
            //
            for( i = 0; i < sizeof(CommonStrings)/sizeof(PWSTR); i++ ) {
                if( !_wcsnicmp( pchStart, CommonStrings[i], Length ) ) {
                    break;
                }
            }
            if( i < sizeof(CommonStrings)/sizeof(PWSTR) ) {
                //
                // Hit...
                //
                Token.Type = TOK_STRING;
                Token.pValue = CommonStrings[i];
            } else if((pchNew = SpMemAllocEx((Length + 1) * sizeof(WCHAR),'cteS', PagedPool)) == NULL) {
                Token.Type = TOK_ERRNOMEM;
                Token.pValue = NULL;
            }
            else {
                wcsncpy(pchNew, pchStart, Length);
                pchNew[Length] = 0;
                Token.Type = TOK_STRING;
                Token.pValue = pchNew;
            }
        }
        break;
    }

    *Stream = pch;
    return (Token);
}



#if DBG
VOID
pSpDumpTextFileInternals(
    IN PVOID Handle
    )
{
    PTEXTFILE pInf = Handle;
    PTEXTFILE_SECTION pSection;
    PTEXTFILE_LINE pLine;
    PTEXTFILE_VALUE pValue;

    for(pSection = pInf->pSection; pSection; pSection = pSection->pNext) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "Section: [%ws]\r\n",pSection->pName));

        for(pLine = pSection->pLine; pLine; pLine = pLine->pNext) {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "   [%ws] = ",pLine->pName ? pLine->pName : L"(none)"));

            for(pValue = pLine->pValue; pValue; pValue = pValue->pNext) {

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "[%ws] ",pValue->pName));
            }
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "\n"));
        }
    }
}
#endif


PWSTR
SpGetKeyNameByValue(
    IN PVOID Inf,
    IN PWSTR SectionName,
    IN PWSTR Value
    )

/*++

Routine Description:

    Determines the key name of a given value in a given section.

Arguments:

    Inf - Handle to an inf file (txtsetup.sif or winnt.sif).

    SectionName - Supplies the name of the section

    Value - Supplies the string to be matched (eg. "Digital DECpc AXP 150")

Return Value:

    NULL - No match was found.

    PWSTR - Pointer to the canonical shortname of the component.

--*/

{
    ULONG i;
    PWSTR SearchName;

    //
    // If this is not an OEM component, then enumerate the entries in the
    // section in txtsetup.sif
    //
    for (i=0;;i++) {
        SearchName = SpGetSectionLineIndex(Inf,
                                           SectionName,
                                           i,
                                           0);
        if (SearchName==NULL) {
            //
            // we have enumerated the entire section without finding a
            // match, return failure.
            //
            return(NULL);
        }

        if (_wcsicmp(Value, SearchName) == 0) {
            //
            // we have a match
            //
            break;
        }
    }
    //
    // i is the index into the section of the short machine name
    //
    return(SpGetKeyName(Inf,
                        SectionName,
                        i));
}


ULONG
SpCountSectionsInFile(
    IN PVOID Handle
    )
{
    PTEXTFILE_SECTION pSection;
    PTEXTFILE         pFile;
    ULONG             Count;

    pFile = (PTEXTFILE)Handle;
    for(pSection=pFile->pSection, Count = 0;
        pSection;
        pSection = pSection->pNext, Count++
       );

    return(Count);
}

PWSTR
SpGetSectionName(
    IN PVOID Handle,
    IN ULONG Index
    )
{
    PTEXTFILE_SECTION pSection;
    PTEXTFILE         pFile;
    ULONG             Count;
    PWSTR             SectionName;

    pFile = (PTEXTFILE)Handle;
    for(pSection=pFile->pSection, Count = 0;
        pSection && (Count < Index);
        pSection = pSection->pNext, Count++
       );
    return( (pSection != NULL)? pSection->pName : NULL );
}



NTSTATUS
SppWriteTextToFile(
    IN PVOID Handle,
    IN PWSTR String
    )
{
    NTSTATUS        Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PCHAR           OemText;

    OemText = SpToOem( String );

    Status = ZwWriteFile( Handle,
                          NULL,
                          NULL,
                          NULL,
                          &IoStatusBlock,
                          OemText,
                          strlen( OemText ),
                          NULL,
                          NULL );
    SpMemFree( OemText );

    return( Status );
}


NTSTATUS
SpProcessAddRegSection(
    IN PVOID   SifHandle,
    IN LPCWSTR SectionName,
    IN HANDLE  HKLM_SYSTEM,
    IN HANDLE  HKLM_SOFTWARE,
    IN HANDLE  HKCU,
    IN HANDLE  HKR
    )
{
    LPCWSTR p;
    WCHAR *q;
    ULONG Flags;
    HKEY RootKey;
    PTEXTFILE_SECTION pSection;
    PTEXTFILE_LINE pLine;
    PTEXTFILE_VALUE pValue;
    LPWSTR buffer;
    ULONG DataType;
    LPCWSTR ValueName;
    PVOID Data;
    ULONG DataSize;
    ULONG len;
    HANDLE hkey;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;
    KEY_VALUE_BASIC_INFORMATION BasicInfo;
    BOOLEAN b;
    WCHAR c;

    //
    // Find the section.
    //
    pSection = SearchSectionByName(SifHandle,SectionName);
    if(!pSection) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: addreg section %ws missing\n",SectionName));
        return(STATUS_UNSUCCESSFUL);
    }

    for(pLine=pSection->pLine; pLine; pLine=pLine->pNext) {

        buffer = TemporaryBuffer;

        //
        // 0th field is HKCU, HKLM, HKCR, or HKR.
        // 1st field is subkey name, which may be empty.
        //
        if(pValue = pLine->pValue) {

            b = pSpAdjustRootAndSubkeySpec(
                    SifHandle,
                    pValue->pName,
                    pValue->pNext ? pValue->pNext->pName : L"",
                    HKLM_SYSTEM,
                    HKLM_SOFTWARE,
                    HKCU,
                    HKR,
                    &RootKey,
                    buffer
                    );

            if(!b) {
                return(STATUS_UNSUCCESSFUL);
            }

        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: missing root key spec in section %ws\n",SectionName));
            return(STATUS_UNSUCCESSFUL);
        }

        //
        // Advance past key path to free area in buffer
        //
        buffer += wcslen(buffer) + 1;

        //
        // 2nd field is value name, which may be empty.
        //
        if(pValue = pValue->pNext) {
            pValue = pValue->pNext;
        }
        if(pValue) {
            p = pValue->pName;
            pValue = pValue->pNext;
        } else {
            p = L"";
        }

        SpProcessForStringSubs(SifHandle,p,buffer,sizeof(TemporaryBuffer));
        ValueName = buffer;

        //
        // Advance past value name to free area in buffer -
        // align on DWORD boundary.
        //
        buffer += wcslen(buffer) + sizeof(DWORD);
        buffer = (LPWSTR) ((DWORD_PTR)buffer & (~((DWORD_PTR) sizeof(DWORD) - 1)));

        //
        // 3rd field is flags.
        //
        if(pValue) {
            SpProcessForStringSubs(SifHandle,pValue->pName,buffer,sizeof(TemporaryBuffer));
            Flags = (ULONG)SpStringToLong(buffer,NULL,0);
            pValue = pValue->pNext;
        } else {
            Flags = 0;
        }

        //
        // 4th field and beyond is data, whose interpretation depends on
        // the flags.
        //
        switch(Flags & FLG_ADDREG_TYPE_MASK) {

        case FLG_ADDREG_TYPE_SZ:
            DataType = REG_SZ;
            break;

        case FLG_ADDREG_TYPE_MULTI_SZ:
            DataType = REG_MULTI_SZ;
            break;

        case FLG_ADDREG_TYPE_EXPAND_SZ:
            DataType = REG_EXPAND_SZ;
            break;

        case FLG_ADDREG_TYPE_BINARY:
            DataType = REG_BINARY;
            break;

        case FLG_ADDREG_TYPE_DWORD:
            DataType = REG_DWORD;
            break;

        case FLG_ADDREG_TYPE_NONE:
            DataType = REG_NONE;
            break;

        default:
            //
            // If the FLG_ADDREG_BINVALUETYPE is set, then the highword
            // can contain just about any random reg data type ordinal value.
            //
            if(Flags & FLG_ADDREG_BINVALUETYPE) {
                //
                // Disallow the following reg data types:
                //
                //    REG_NONE, REG_SZ, REG_EXPAND_SZ, REG_MULTI_SZ
                //
                DataType = (ULONG)HIWORD(Flags);

                if((DataType < REG_BINARY) || (DataType == REG_MULTI_SZ)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: bogus flags value 0x%lx in addreg section %ws\n",Flags,SectionName));
                    return(STATUS_UNSUCCESSFUL);
                }
            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: bogus flags value 0x%lx in addreg section %ws\n",Flags,SectionName));
                return(STATUS_UNSUCCESSFUL);
            }
        }
        //
        // Don't support append flag for now.
        //
        if(Flags & FLG_ADDREG_APPEND) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: FLG_ADDREG_APPEND not supported\n"));
            return(STATUS_UNSUCCESSFUL);
        }

        Data = buffer;
        DataSize = 0;

        switch(DataType) {

        case REG_MULTI_SZ:
            //
            // Each remaining field is a member of the multi_sz
            //
            while(pValue) {
                SpProcessForStringSubs(SifHandle,pValue->pName,buffer,sizeof(TemporaryBuffer));
                len = wcslen(buffer);
                buffer = buffer + len + 1;
                DataSize += (len+1)*sizeof(WCHAR);
                pValue = pValue->pNext;
            }
            *buffer = 0;
            DataSize += sizeof(WCHAR);
            break;

        case REG_DWORD:
            //
            // Support specification as 4 bytes of binary data or as a dword.
            //

            *(PULONG)buffer = 0;

            if(pValue) {

                if(pValue->pNext
                && pValue->pNext->pNext
                && pValue->pNext->pNext->pNext
                && !pValue->pNext->pNext->pNext->pNext) {

                    goto binarytype;
                }

                SpProcessForStringSubs(
                    SifHandle,
                    pValue->pName,
                    buffer,
                    sizeof(TemporaryBuffer)
                    );

                *(PULONG)buffer = (ULONG)SpStringToLong(buffer,NULL,0);
            }

            buffer += sizeof(ULONG) / sizeof(WCHAR);
            DataSize = sizeof(ULONG);
            break;

        case REG_SZ:
        case REG_EXPAND_SZ:

            p = pValue ? pValue->pName : L"";

            SpProcessForStringSubs(SifHandle,p,buffer,sizeof(TemporaryBuffer));
            len = wcslen(buffer);

            DataSize = (len+1)*sizeof(WCHAR);
            buffer = buffer + len + 1;
            break;

        case REG_BINARY:
        default:
        binarytype:
            //
            // All other types are specified in binary format.
            //
            while(pValue)  {

                // Advance past value name to free area in buffer -
                // align on DWORD boundary.
                //
                q = buffer + 1 + sizeof(DWORD);
                q = (LPWSTR) ((DWORD_PTR)q & (~((DWORD_PTR) sizeof(DWORD) - 1)));

                SpProcessForStringSubs(SifHandle,pValue->pName,q,sizeof(TemporaryBuffer));

                *(PUCHAR)buffer = (UCHAR)SpStringToLong(q,NULL,16);
                pValue = pValue->pNext;
                DataSize++;
                buffer = (PWSTR) ((PUCHAR)buffer + 1);
            }
            break;
        }

        //
        // Open/create the key if it's a subkey, otherwise just use
        // the root key itself.
        //
        if(*TemporaryBuffer) {

            InitializeObjectAttributes(
                &ObjectAttributes,
                &UnicodeString,
                OBJ_CASE_INSENSITIVE,
                RootKey,
                NULL
                );

            //
            // Multilevel key create, one component at a time.
            //
            q = TemporaryBuffer;
            if(*q == L'\\') {
                q++;
            }
            do {
                if(q = wcschr(q,L'\\')) {
                    c = *q;
                    *q = 0;
                } else {
                    c = 0;
                }

                RtlInitUnicodeString(&UnicodeString,TemporaryBuffer);

                Status = ZwCreateKey(
                            &hkey,
                            READ_CONTROL | KEY_SET_VALUE,
                            &ObjectAttributes,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            &len
                            );

                if(!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: addreg: ZwCreateKey(%ws) failed %lx\n",TemporaryBuffer,Status));
                    return(Status);
                }

                if(c) {
                    *q = c;
                    q++;
                    //
                    // The call to ZwClose is in here so that we retain a handle
                    // to the final full key. We close it later, below.
                    //
                    ZwClose(hkey);
                }
            } while(c);

            RtlInitUnicodeString(&UnicodeString,ValueName);

            //
            // If the key already existed and the noclobber flag is set,
            // then leave the default value alone.
            //
            if(len == REG_OPENED_EXISTING_KEY) {
                if((Flags & FLG_ADDREG_NOCLOBBER) && (*ValueName == 0)) {
                    //
                    // Nothing to do.
                    //
                    ZwClose(hkey);
                    continue;
                } else if (Flags & FLG_ADDREG_DELVAL) {
                    //
                    // If this flag is set, ignore value data and delete the value.
                    //
                    ZwDeleteValueKey(hkey,&UnicodeString);
                }
            }

        } else {
            hkey = RootKey;
            RtlInitUnicodeString(&UnicodeString,ValueName);
        }

        if(!(Flags & FLG_ADDREG_KEYONLY)) {
            //
            // If the noclobber flag is set, see if the value exists
            // and if so leave it alone. To see if the value exists,
            // we attempt to get basic information on the key and pass in
            // a buffer that's large enough only for the fixed part of the
            // basic info structure. If this is successful or reports buffer overflow,
            // then the key exists. Otherwise it doesn't exist.
            //
            if(Flags & FLG_ADDREG_NOCLOBBER) {

                Status = ZwQueryValueKey(
                            hkey,
                            &UnicodeString,
                            KeyValueBasicInformation,
                            &BasicInfo,
                            sizeof(BasicInfo),
                            &len
                            );

                if(NT_SUCCESS(Status) || (Status == STATUS_BUFFER_OVERFLOW)) {
                    Status = STATUS_SUCCESS;
                } else {
                    Status = ZwSetValueKey(hkey,&UnicodeString,0,DataType,Data,DataSize);
                }
            } else {
                Status = ZwSetValueKey(hkey,&UnicodeString,0,DataType,Data,DataSize);
            }
        }

        if(hkey != RootKey) {
            ZwClose(hkey);
        }

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: addreg: status %lx adding value %ws to %ws\n",Status,ValueName,TemporaryBuffer));
            return(Status);
        }
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
SpProcessDelRegSection(
    IN PVOID   SifHandle,
    IN LPCWSTR SectionName,
    IN HANDLE  HKLM_SYSTEM,
    IN HANDLE  HKLM_SOFTWARE,
    IN HANDLE  HKCU,
    IN HANDLE  HKR
    )
{
    LPWSTR KeyPath;
    LPWSTR ValueName;
    PTEXTFILE_SECTION pSection;
    PTEXTFILE_LINE pLine;
    PTEXTFILE_VALUE pValue;
    HKEY RootKey;
    NTSTATUS Status;
    HANDLE hkey;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    BOOLEAN b;

    //
    // Allocate a temporary buffer. The registry delnode routine
    // uses TemporaryBuffer so we can't use that.
    //
    KeyPath = SpMemAllocEx(1000,'dteS', PagedPool);
    ValueName = SpMemAllocEx(1000,'eteS', PagedPool);

    //
    // Find the section.
    //
    pSection = SearchSectionByName(SifHandle,SectionName);
    if(!pSection) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: delreg section %ws missing\n",SectionName));
        SpMemFree(KeyPath);
        SpMemFree(ValueName);
        return(STATUS_UNSUCCESSFUL);
    }

    for(pLine=pSection->pLine; pLine; pLine=pLine->pNext) {

        //
        // 0th field is HKCU, HKLM, HKCR, or HKR.
        // 1st field is subkey name.
        // Both must be present.
        //
        if((pValue = pLine->pValue) && (pValue->pNext)) {

            b = pSpAdjustRootAndSubkeySpec(
                    SifHandle,
                    pValue->pName,
                    pValue->pNext->pName,
                    HKLM_SYSTEM,
                    HKLM_SOFTWARE,
                    HKCU,
                    HKR,
                    &RootKey,
                    KeyPath
                    );

            if(!b) {
                SpMemFree(KeyPath);
                SpMemFree(ValueName);
                return(STATUS_UNSUCCESSFUL);
            }
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: delreg: missing root key spec in section %ws\n",SectionName));
            SpMemFree(KeyPath);
            SpMemFree(ValueName);
            return(STATUS_UNSUCCESSFUL);
        }

        //
        // 2nd field is value name, which may be missing or empty.
        // If it's missing, we want to delete the whole tree rooted at
        // the given subkey. If it's present then we want to delete only
        // one value (which may be the unnamed value).
        //
        if(pValue = pValue->pNext->pNext) {

            SpProcessForStringSubs(SifHandle,pValue->pName,ValueName,1000);

            if(*KeyPath) {

                RtlInitUnicodeString(&UnicodeString,KeyPath);

                InitializeObjectAttributes(
                    &ObjectAttributes,
                    &UnicodeString,
                    OBJ_CASE_INSENSITIVE,
                    RootKey,
                    NULL
                    );

                Status = ZwOpenKey(
                            &hkey,
                            READ_CONTROL | KEY_SET_VALUE,
                            &ObjectAttributes
                            );

                if(!NT_SUCCESS(Status)) {
                    if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: delreg: warning: key %ws not present for delete (%lx)\n",KeyPath,Status));
                    }
                    hkey = NULL;
                }
            } else {
                Status = STATUS_SUCCESS;
                hkey = RootKey;
            }

            if(NT_SUCCESS(Status)) {
                RtlInitUnicodeString(&UnicodeString,ValueName);
                Status = ZwDeleteValueKey(hkey,&UnicodeString);
                if(!NT_SUCCESS(Status) && (Status != STATUS_OBJECT_NAME_NOT_FOUND)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: delreg: warning: delete value %ws from key %ws returned %lx\n",ValueName,KeyPath,Status));
                }
            }

            if(hkey && (hkey != RootKey)) {
                ZwClose(hkey);
            }

        } else {
            //
            // If we're trying to delete the key from the root of the hive,
            // ignore it.
            //
            if(*KeyPath) {
                SppDeleteKeyRecursive(RootKey,KeyPath,TRUE);
            }
        }
    }

    SpMemFree(ValueName);
    SpMemFree(KeyPath);
    return(STATUS_SUCCESS);
}


BOOLEAN
pSpAdjustRootAndSubkeySpec(
    IN  PVOID    SifHandle,
    IN  LPCWSTR  RootKeySpec,
    IN  LPCWSTR  SubkeySpec,
    IN  HANDLE   HKLM_SYSTEM,
    IN  HANDLE   HKLM_SOFTWARE,
    IN  HANDLE   HKCU,
    IN  HANDLE   HKR,
    OUT HANDLE  *RootKey,
    OUT LPWSTR   Subkey
    )
{
    ULONG len;

    if(*SubkeySpec == L'\\') {
        SubkeySpec++;
    }

    if(!_wcsicmp(RootKeySpec,L"HKCR")) {
        //
        // HKEY_CLASSES_ROOT. The ultimate root is HKLM\Software\Classes.
        // We take care not to produce a subkey spec that ends with \.
        //
        *RootKey = HKLM_SOFTWARE;
        wcscpy(Subkey,L"Classes");
        if(*SubkeySpec) {
            if(*SubkeySpec == L'\\') {
                SubkeySpec++;
            }
            Subkey[7] = L'\\';
            SpProcessForStringSubs(SifHandle,SubkeySpec,Subkey+8,sizeof(TemporaryBuffer));
        }
    } else {
        if(!_wcsicmp(RootKeySpec,L"HKLM")) {
            //
            // The first component of the subkey must be SYSTEM or SOFTWARE.
            //
            len = wcslen(SubkeySpec);

            if((len >= 8)
            && ((SubkeySpec[8] == L'\\') || !SubkeySpec[8])
            && !_wcsnicmp(SubkeySpec,L"software",8)) {

                *RootKey = HKLM_SOFTWARE;
                SubkeySpec += 8;

            } else {
                if((len >= 6)
                && ((SubkeySpec[6] == L'\\') || !SubkeySpec[6])
                && !_wcsnicmp(SubkeySpec,L"system",6)) {

                    *RootKey = HKLM_SYSTEM;
                    SubkeySpec += 6;

                } else {

                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unknown root/subkey spec %ws %ws\n",RootKeySpec,SubkeySpec));
                    return(FALSE);
                }
            }

            if(*SubkeySpec == L'\\') {
                SubkeySpec++;
            }

            SpProcessForStringSubs(SifHandle,SubkeySpec,Subkey,sizeof(TemporaryBuffer));

        } else {
            if(!_wcsicmp(RootKeySpec,L"HKCU")) {
                *RootKey = HKCU;
                SpProcessForStringSubs(SifHandle,SubkeySpec,Subkey,sizeof(TemporaryBuffer));
            } else {
                if(!_wcsicmp(RootKeySpec,L"HKR")) {
                    *RootKey = HKR;
                    SpProcessForStringSubs(SifHandle,SubkeySpec,Subkey,sizeof(TemporaryBuffer));
                } else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unknown root key spec %ws\n",RootKeySpec));
                    return(FALSE);
                }
            }
        }
    }

    return(TRUE);
}



BOOLEAN
pSpIsFileInPrivateInf(
    IN PCWSTR FileName
    )

/*++

Routine Description:

    Tell the caller if the file specified is in the inf that
    lists the privates being tested (as specifed by using
    the /M flag in winnt32.exe).

Arguments:

    FileName - supplies name of the file we're looking for.

Return Value:

    TRUE/FALSE indicating the presence of the file in the inf.

--*/
{
    PWSTR  SectionName = L"Privates";
    PWSTR  InfFileName;
    UINT   FileCount,i;

    if (!PrivateInfHandle) {
        return(FALSE);
    }

    FileCount = SpCountLinesInSection(PrivateInfHandle, SectionName);

    for (i=0; i< FileCount; i++) {
        InfFileName = SpGetSectionLineIndex( PrivateInfHandle, SectionName, i, 0);
        if (InfFileName) {
            if (wcscmp(InfFileName, FileName) == 0) {
                return(TRUE);
            }
        }
    }

    return(FALSE);
}

BOOLEAN
SpNonZeroValuesInSection(
    PVOID Handle,
    PCWSTR SectionName,
    ULONG ValueIndex
    )
{
    PTEXTFILE_SECTION pSection;
    PTEXTFILE_LINE pLine;
    PTEXTFILE_VALUE pVal;
    ULONG i;

    pSection = SearchSectionByName((PTEXTFILE) Handle, SectionName);

    for(i = 0; (pLine = SearchLineInSectionByIndex(pSection, i)) != NULL; ++i) {
        pVal = SearchValueInLine(pLine, ValueIndex);

        if(pVal != NULL && pVal->pName != NULL && SpStringToLong(pVal->pName, NULL, 0) != 0) {
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spterm.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spterm.h

Abstract:

    Text setup support for terminals

Author:

    Sean Selitrennikoff (v-seans) 25-May-1999

Revision History:

--*/


extern BOOLEAN HeadlessTerminalConnected;

//
// <CSI>K is the vt100 code to clear from cursor to end of line
//
#define HEADLESS_CLEAR_TO_EOL_STRING L"\033[K"

VOID 
SpTermInitialize(
    VOID
    );

VOID 
SpTermTerminate(
    VOID
    );

VOID 
SpTermDisplayStringOnTerminal(
    IN PWSTR String,
    IN UCHAR Attribute,
    IN ULONG X,                 // 0-based coordinates (character units)
    IN ULONG Y
    );

PWSTR
SpTermAttributeToTerminalEscapeString(
    IN UCHAR Attribute
    );
    
VOID
SpTermSendStringToTerminal(
    IN PWSTR String,
    IN BOOLEAN Raw
    );

ULONG
SpTermGetKeypress(
    VOID
    );

BOOLEAN
SpTermIsKeyWaiting(
    VOID
    );
    
VOID
SpTermDrain(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spterm.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spterm.c

Abstract:

    Text setup support for terminals

Author:

    Sean Selitrennikoff (v-seans) 25-May-1999

Revision History:

--*/



#include "spprecmp.h"
#include "ntddser.h"
#pragma hdrstop
#include <hdlsblk.h>
#include <hdlsterm.h>

#define MS_DSRCTSCD 0xB0            // Status bits for DSR, CTS and CD

BOOLEAN HeadlessTerminalConnected = FALSE;
UCHAR Utf8ConversionBuffer[80*3+1];
PUCHAR TerminalBuffer = Utf8ConversionBuffer;
WCHAR UnicodeScratchBuffer[80+1];

//
// Use these variables to decode incoming UTF8
// data streams.
//
WCHAR IncomingUnicodeValue;
UCHAR IncomingUtf8ConversionBuffer[3];

BOOLEAN
SpTranslateUnicodeToUtf8(
    PCWSTR SourceBuffer,
    UCHAR  *DestinationBuffer
    )
/*++

Routine Description:

    translates a unicode buffer into a UTF8 version.

Arguments:

    SourceBuffer - unicode buffer to be translated.
    DestinationBuffer - receives UTF8 version of same buffer.

Return Value:

    TRUE - We successfully translated the Unicode value into its
           corresponding UTF8 encoding.

    FALSE - The translation failed.

--*/

{
    ULONG Count = 0;

    //
    // convert into UTF8 for actual transmission
    //
    // UTF-8 encodes 2-byte Unicode characters as follows:
    // If the first nine bits are zero (00000000 0xxxxxxx), encode it as one byte 0xxxxxxx
    // If the first five bits are zero (00000yyy yyxxxxxx), encode it as two bytes 110yyyyy 10xxxxxx
    // Otherwise (zzzzyyyy yyxxxxxx), encode it as three bytes 1110zzzz 10yyyyyy 10xxxxxx
    //
    DestinationBuffer[Count] = (UCHAR)'\0';
    while (*SourceBuffer) {

        if( (*SourceBuffer & 0xFF80) == 0 ) {
            //
            // if the top 9 bits are zero, then just
            // encode as 1 byte.  (ASCII passes through unchanged).
            //
            DestinationBuffer[Count++] = (UCHAR)(*SourceBuffer & 0x7F);
        } else if( (*SourceBuffer & 0xF700) == 0 ) {
            //
            // if the top 5 bits are zero, then encode as 2 bytes
            //
            DestinationBuffer[Count++] = (UCHAR)((*SourceBuffer >> 6) & 0x1F) | 0xC0;
            DestinationBuffer[Count++] = (UCHAR)(*SourceBuffer & 0xBF) | 0x80;
        } else {
            //
            // encode as 3 bytes
            //
            DestinationBuffer[Count++] = (UCHAR)((*SourceBuffer >> 12) & 0xF) | 0xE0;
            DestinationBuffer[Count++] = (UCHAR)((*SourceBuffer >> 6) & 0x3F) | 0x80;
            DestinationBuffer[Count++] = (UCHAR)(*SourceBuffer & 0xBF) | 0x80;
        }
        SourceBuffer += 1;
    }

    DestinationBuffer[Count] = (UCHAR)'\0';

    return(TRUE);

}




BOOLEAN
SpTranslateUtf8ToUnicode(
    UCHAR  IncomingByte,
    UCHAR  *ExistingUtf8Buffer,
    WCHAR  *DestinationUnicodeVal
    )
/*++

Routine Description:

    Takes IncomingByte and concatenates it onto ExistingUtf8Buffer.
    Then attempts to decode the new contents of ExistingUtf8Buffer.

Arguments:

    IncomingByte -          New character to be appended onto
                            ExistingUtf8Buffer.


    ExistingUtf8Buffer -    running buffer containing incomplete UTF8
                            encoded unicode value.  When it gets full,
                            we'll decode the value and return the
                            corresponding Unicode value.

                            Note that if we *do* detect a completed UTF8
                            buffer and actually do a decode and return a
                            Unicode value, then we will zero-fill the
                            contents of ExistingUtf8Buffer.


    DestinationUnicodeVal - receives Unicode version of the UTF8 buffer.

                            Note that if we do *not* detect a completed
                            UTF8 buffer and thus can not return any data
                            in DestinationUnicodeValue, then we will
                            zero-fill the contents of DestinationUnicodeVal.


Return Value:

    TRUE - We received a terminating character for our UTF8 buffer and will
           return a decoded Unicode value in DestinationUnicode.

    FALSE - We haven't yet received a terminating character for our UTF8
            buffer.

--*/

{
//    ULONG Count = 0;
    ULONG i = 0;
    BOOLEAN ReturnValue = FALSE;



    //
    // Insert our byte into ExistingUtf8Buffer.
    //
    i = 0;
    do {
        if( ExistingUtf8Buffer[i] == 0 ) {
            ExistingUtf8Buffer[i] = IncomingByte;
            break;
        }

        i++;
    } while( i < 3 );

    //
    // If we didn't get to actually insert our IncomingByte,
    // then someone sent us a fully-qualified UTF8 buffer.
    // This means we're about to drop IncomingByte.
    //
    // Drop the zero-th byte, shift everything over by one
    // and insert our new character.
    //
    // This implies that we should *never* need to zero out
    // the contents of ExistingUtf8Buffer unless we detect
    // a completed UTF8 packet.  Otherwise, assume one of
    // these cases:
    // 1. We started listening mid-stream, so we caught the
    //    last half of a UTF8 packet.  In this case, we'll
    //    end up shifting the contents of ExistingUtf8Buffer
    //    until we detect a proper UTF8 start byte in the zero-th
    //    position.
    // 2. We got some garbage character, which would invalidate
    //    a UTF8 packet.  By using the logic below, we would
    //    end up disregarding that packet and waiting for
    //    the next UTF8 packet to come in.
    if( i >= 3 ) {
        ExistingUtf8Buffer[0] = ExistingUtf8Buffer[1];
        ExistingUtf8Buffer[1] = ExistingUtf8Buffer[2];
        ExistingUtf8Buffer[2] = IncomingByte;
    }





    //
    // Attempt to convert the UTF8 buffer
    //
    // UTF8 decodes to Unicode in the following fashion:
    // If the high-order bit is 0 in the first byte:
    //      0xxxxxxx yyyyyyyy zzzzzzzz decodes to a Unicode value of 00000000 0xxxxxxx
    //
    // If the high-order 3 bits in the first byte == 6:
    //      110xxxxx 10yyyyyy zzzzzzzz decodes to a Unicode value of 00000xxx xxyyyyyy
    //
    // If the high-order 3 bits in the first byte == 7:
    //      1110xxxx 10yyyyyy 10zzzzzz decodes to a Unicode value of xxxxyyyy yyzzzzzz
    //
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpTranslateUtf8ToUnicode - About to decode the UTF8 buffer.\n" ));
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "                                  UTF8[0]: 0x%02lx UTF8[1]: 0x%02lx UTF8[2]: 0x%02lx\n",
                                                   ExistingUtf8Buffer[0],
                                                   ExistingUtf8Buffer[1],
                                                   ExistingUtf8Buffer[2] ));

    if( (ExistingUtf8Buffer[0] & 0x80) == 0 ) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpTranslateUtf8ToUnicode - Case1\n" ));

        //
        // First case described above.  Just return the first byte
        // of our UTF8 buffer.
        //
        *DestinationUnicodeVal = (WCHAR)(ExistingUtf8Buffer[0]);


        //
        // We used 1 byte.  Discard that byte and shift everything
        // in our buffer over by 1.
        //
        ExistingUtf8Buffer[0] = ExistingUtf8Buffer[1];
        ExistingUtf8Buffer[1] = ExistingUtf8Buffer[2];
        ExistingUtf8Buffer[2] = 0;

        ReturnValue = TRUE;

    } else if( (ExistingUtf8Buffer[0] & 0xE0) == 0xC0 ) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpTranslateUtf8ToUnicode - 1st byte of UTF8 buffer says Case2\n" ));

        //
        // Second case described above.  Decode the first 2 bytes of
        // of our UTF8 buffer.
        //
        if( (ExistingUtf8Buffer[1] & 0xC0) == 0x80 ) {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpTranslateUtf8ToUnicode - 2nd byte of UTF8 buffer says Case2.\n" ));

            // upper byte: 00000xxx
            *DestinationUnicodeVal = ((ExistingUtf8Buffer[0] >> 2) & 0x07);
            *DestinationUnicodeVal = *DestinationUnicodeVal << 8;

            // high bits of lower byte: xx000000
            *DestinationUnicodeVal |= ((ExistingUtf8Buffer[0] & 0x03) << 6);

            // low bits of lower byte: 00yyyyyy
            *DestinationUnicodeVal |= (ExistingUtf8Buffer[1] & 0x3F);


            //
            // We used 2 bytes.  Discard those bytes and shift everything
            // in our buffer over by 2.
            //
            ExistingUtf8Buffer[0] = ExistingUtf8Buffer[2];
            ExistingUtf8Buffer[1] = 0;
            ExistingUtf8Buffer[2] = 0;

            ReturnValue = TRUE;

        }
    } else if( (ExistingUtf8Buffer[0] & 0xF0) == 0xE0 ) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpTranslateUtf8ToUnicode - 1st byte of UTF8 buffer says Case3\n" ));

        //
        // Third case described above.  Decode the all 3 bytes of
        // of our UTF8 buffer.
        //

        if( (ExistingUtf8Buffer[1] & 0xC0) == 0x80 ) {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpTranslateUtf8ToUnicode - 2nd byte of UTF8 buffer says Case3\n" ));

            if( (ExistingUtf8Buffer[2] & 0xC0) == 0x80 ) {

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpTranslateUtf8ToUnicode - 3rd byte of UTF8 buffer says Case3\n" ));

                // upper byte: xxxx0000
                *DestinationUnicodeVal = ((ExistingUtf8Buffer[0] << 4) & 0xF0);

                // upper byte: 0000yyyy
                *DestinationUnicodeVal |= ((ExistingUtf8Buffer[1] >> 2) & 0x0F);

                *DestinationUnicodeVal = *DestinationUnicodeVal << 8;

                // lower byte: yy000000
                *DestinationUnicodeVal |= ((ExistingUtf8Buffer[1] << 6) & 0xC0);

                // lower byte: 00zzzzzz
                *DestinationUnicodeVal |= (ExistingUtf8Buffer[2] & 0x3F);

                //
                // We used all 3 bytes.  Zero out the buffer.
                //
                ExistingUtf8Buffer[0] = 0;
                ExistingUtf8Buffer[1] = 0;
                ExistingUtf8Buffer[2] = 0;

                ReturnValue = TRUE;

            }
        }
    }

    return ReturnValue;
}




VOID
SpTermInitialize(
    VOID
    )

/*++

Routine Description:

    Attempts to connect to a VT100 attached to COM1

Arguments:

    None.

Return Value:

    None.

--*/

{
    HEADLESS_CMD_ENABLE_TERMINAL Command;
    NTSTATUS Status;

    Command.Enable = TRUE;
    Status = HeadlessDispatch(HeadlessCmdEnableTerminal,
                              &Command,
                              sizeof(HEADLESS_CMD_ENABLE_TERMINAL),
                              NULL,
                              NULL
                             );

    HeadlessTerminalConnected = NT_SUCCESS(Status);
}

VOID
SpTermDisplayStringOnTerminal(
    IN PWSTR  String,
    IN UCHAR Attribute,
    IN ULONG X,                 // 0-based coordinates (character units)
    IN ULONG Y
    )

/*++

Routine Description:

    Write a string of characters to the terminal.

Arguments:

    Character - supplies a string to be displayed at the given position.

    Attribute - supplies the attributes for the characters in the string.

    X,Y - specify the character-based (0-based) position of the output.

Return Value:

    None.

--*/

{
    PWSTR EscapeString;

    //
    // send <CSI>x;yH to move the cursor to the specified location
    //
    swprintf(UnicodeScratchBuffer, L"\033[%d;%dH", Y + 1, X + 1);
    SpTermSendStringToTerminal(UnicodeScratchBuffer, TRUE);

    //
    // convert any attributes to an escape string.  EscapeString uses
    // the TerminalBuffer global scratch buffer
    //
    EscapeString = SpTermAttributeToTerminalEscapeString(Attribute);

    //
    // transmit the escape string if we received one
    //
    if (EscapeString != NULL) {
        SpTermSendStringToTerminal(EscapeString, TRUE);
    }

    //
    // finally send the actual string contents to the terminal
    //
    SpTermSendStringToTerminal(String, FALSE);
}

PWSTR
SpTermAttributeToTerminalEscapeString(
    IN UCHAR Attribute
    )

/*++

Routine Description:

    Convert a vga attribute byte to an escape sequence to send to the terminal.

Arguments:

    Attribute - supplies the attribute.

Return Value:

    A pointer to the escape sequence, or NULL if it could not be converted.

--*/

{
    ULONG BgColor;
    ULONG FgColor;
    BOOLEAN Inverse;

    BgColor = (Attribute & 0x70) >> 4;
    FgColor = Attribute & 0x07;

    Inverse = !((BgColor == 0) || (BgColor == DEFAULT_BACKGROUND));

    //
    // Convert the colors.
    //
    switch (BgColor) {
    case ATT_BLUE:
        BgColor = 44;
        break;
    case ATT_GREEN:
        BgColor = 42;
        break;
    case ATT_CYAN:
        BgColor = 46;
        break;
    case ATT_RED:
        BgColor = 41;
        break;
    case ATT_MAGENTA:
        BgColor = 45;
        break;
    case ATT_YELLOW:
        BgColor = 43;
        break;
    case ATT_BLACK:
        BgColor = 40;
        break;
    case ATT_WHITE:
        BgColor = 47;
        break;
    }
    switch (FgColor) {
    case ATT_BLUE:
        FgColor = 34;
        break;
    case ATT_GREEN:
        FgColor = 32;
        break;
    case ATT_CYAN:
        FgColor = 36;
        break;
    case ATT_RED:
        FgColor = 31;
        break;
    case ATT_MAGENTA:
        FgColor = 35;
        break;
    case ATT_YELLOW:
        FgColor = 33;
        break;
    case ATT_BLACK:
        FgColor = 30;
        break;
    case ATT_WHITE:
        FgColor = 37;
        break;
    }

    //
    // <CSI>%1;%2;%3m is the escape to set a color
    // where 1 = video mode
    //       2 = foreground color
    //       3 = background color
    //
    swprintf(UnicodeScratchBuffer,
            L"\033[%u;%u;%um",
            (Inverse ? 7 : 0),
            FgColor,
            BgColor
           );

    return UnicodeScratchBuffer;
}

VOID
SpTermSendStringToTerminal(
    IN PWSTR String,
    IN BOOLEAN Raw
    )

/*++

Routine Description:

    Write a character string to the terminal, translating some codes if desired.

Arguments:

    String - NULL terminated string to write.

    Raw - Send the string raw or not.

Return Value:

    None.

--*/


{
    ULONG i = 0;
    PWSTR LocalBuffer = UnicodeScratchBuffer;
    //
    // if we're in an FE build, we do UTF8, otherwise we do oem codepage
    //
    BOOL DoUtf8 = (VideoFunctionVector != &VgaVideoVector);


    ASSERT(FIELD_OFFSET(HEADLESS_CMD_PUT_STRING, String) == 0);  // ASSERT if anyone changes this structure.

    //
    // Don't do anything if we aren't running headless.
    //
    if( !HeadlessTerminalConnected ) {
        return;
    }

    if (Raw) {

        if (DoUtf8) {
            SpTranslateUnicodeToUtf8( String, Utf8ConversionBuffer );

            HeadlessDispatch( HeadlessCmdPutData,
                     Utf8ConversionBuffer,
                     strlen(Utf8ConversionBuffer),
                     NULL,
                     NULL
                    );
        } else {
            //
            // Convert unicode string to oem, guarding against overflow.
            //
            RtlUnicodeToOemN(
                Utf8ConversionBuffer,
                sizeof(Utf8ConversionBuffer)-1,     // guarantee room for nul
                NULL,
                String,
                (wcslen(String)+1)*sizeof(WCHAR)
                );

            Utf8ConversionBuffer[sizeof(Utf8ConversionBuffer)-1] = '\0';

            HeadlessDispatch( HeadlessCmdPutString,
                     Utf8ConversionBuffer,
                     strlen(Utf8ConversionBuffer) + sizeof('\0'),
                     NULL,
                     NULL
                    );
        }




        return;
    }

    while (*String != L'\0') {

        LocalBuffer[i++] = *String;

        if (*String == L'\n') {

            //
            // Every \n becomes a \n\r sequence.
            //
            LocalBuffer[i++] = L'\r';

        } else if (*String == 0x00DC) {

            //
            // The cursor becomes a space and then a backspace, this is to
            // delete the old character and position the terminal cursor properly.
            //
            LocalBuffer[i-1] = 0x0020;
            LocalBuffer[i++] = 0x0008;

        }

        //
        // we've got an entire line of text -- we need to transmit it now or
        // we can end up scrolling the text and everything will look funny from
        // this point forward.
        //
        if (i >= 70) {

            LocalBuffer[i] = L'\0';
            if (DoUtf8) {
                SpTranslateUnicodeToUtf8( LocalBuffer, Utf8ConversionBuffer );

                HeadlessDispatch(HeadlessCmdPutData,
                                 Utf8ConversionBuffer,
                                 strlen(Utf8ConversionBuffer),
                                 NULL,
                                 NULL
                                );


            } else {
                //
                // Convert unicode string to oem, guarding against overflow.
                //
                RtlUnicodeToOemN(
                    Utf8ConversionBuffer,
                    sizeof(Utf8ConversionBuffer)-1,     // guarantee room for nul
                    NULL,
                    LocalBuffer,
                    (wcslen(LocalBuffer)+1)*sizeof(WCHAR)
                    );


                Utf8ConversionBuffer[sizeof(Utf8ConversionBuffer)-1] = '\0';

                HeadlessDispatch(HeadlessCmdPutString,
                                 Utf8ConversionBuffer,
                                 strlen(Utf8ConversionBuffer) + sizeof('\0'),
                                 NULL,
                                 NULL
                                );

            }

            i = 0;
        }

        String++;
    }

    LocalBuffer[i] = L'\0';
    if (DoUtf8) {
        SpTranslateUnicodeToUtf8( LocalBuffer, Utf8ConversionBuffer );

        HeadlessDispatch(HeadlessCmdPutData,
                     Utf8ConversionBuffer,
                     strlen(Utf8ConversionBuffer),
                     NULL,
                     NULL
                    );

    } else {
        //
        // Convert unicode string to oem, guarding against overflow.
        //
        RtlUnicodeToOemN(
            Utf8ConversionBuffer,
            sizeof(Utf8ConversionBuffer)-1,     // guarantee room for nul
            NULL,
            LocalBuffer,
            (wcslen(LocalBuffer)+1)*sizeof(WCHAR)
            );

        Utf8ConversionBuffer[sizeof(Utf8ConversionBuffer)-1] = '\0';

        HeadlessDispatch(HeadlessCmdPutString,
                     Utf8ConversionBuffer,
                     strlen(Utf8ConversionBuffer) + sizeof('\0'),
                     NULL,
                     NULL
                    );

    }

}

VOID
SpTermTerminate(
    VOID
    )

/*++

Routine Description:

    Close down connection to the dumb terminal

Arguments:

    None.

Return Value:

    None.

--*/

{
    HEADLESS_CMD_ENABLE_TERMINAL Command;

    //
    // Don't do anything if we aren't running headless.
    //
    if( !HeadlessTerminalConnected ) {
        return;
    }



    Command.Enable = FALSE;
    HeadlessDispatch(HeadlessCmdEnableTerminal,
                     &Command,
                     sizeof(HEADLESS_CMD_ENABLE_TERMINAL),
                     NULL,
                     NULL
                    );

    HeadlessTerminalConnected = FALSE;
}

BOOLEAN
SpTermIsKeyWaiting(
    VOID
    )

/*++

Routine Description:

    Probe for a read.

Arguments:

    None.

Return Value:

    TRUE if there is a character waiting for input, else FALSE.

--*/

{
    HEADLESS_RSP_POLL Response;
    NTSTATUS Status;
    SIZE_T Length;


    //
    // Don't do anything if we aren't running headless.
    //
    if( !HeadlessTerminalConnected ) {
        return FALSE;
    }


    Length = sizeof(HEADLESS_RSP_POLL);

    Response.QueuedInput = FALSE;

    Status = HeadlessDispatch(HeadlessCmdTerminalPoll,
                              NULL,
                              0,
                              &Response,
                              &Length
                             );

    return (NT_SUCCESS(Status) && Response.QueuedInput);
}

ULONG
SpTermGetKeypress(
    VOID
    )

/*++

Routine Description:

    Read in a (possible) sequence of keystrokes and return a Key value.

Arguments:

    None.

Return Value:

    0 if no key is waiting, else a ULONG key value.

--*/

{
    UCHAR Byte;
    BOOLEAN Success;
    TIME_FIELDS StartTime;
    TIME_FIELDS EndTime;
    HEADLESS_RSP_GET_BYTE Response;
    SIZE_T Length;
    NTSTATUS Status;


    //
    // Don't do anything if we aren't running headless.
    //
    if( !HeadlessTerminalConnected ) {
        return 0;
    }


    //
    // Read first character
    //
    Length = sizeof(HEADLESS_RSP_GET_BYTE);

    Status = HeadlessDispatch(HeadlessCmdGetByte,
                              NULL,
                              0,
                              &Response,
                              &Length
                             );

    if (NT_SUCCESS(Status)) {
        Byte = Response.Value;
    } else {
        Byte = 0;
    }



    //
    // Handle all the special escape codes.
    //
    if (Byte == 0x8) {   // backspace (^h)
        return ASCI_BS;
    }
    if (Byte == 0x7F) {  // delete
        return KEY_DELETE;
    }
    if ((Byte == '\r') || (Byte == '\n')) {  // return
        return ASCI_CR;
    }

    if (Byte == 0x1b) {    // Escape key

        do {

            Success = HalQueryRealTimeClock(&StartTime);
            ASSERT(Success);

            //
            // Adjust StartTime to be our ending time.
            //
            StartTime.Second += 2;
            if (StartTime.Second > 59) {
                StartTime.Second -= 60;
            }

            while (!SpTermIsKeyWaiting()) {

                //
                // Give the user 1 second to type in a follow up key.
                //
                Success = HalQueryRealTimeClock(&EndTime);
                ASSERT(Success);

                if (StartTime.Second == EndTime.Second) {
                    break;
                }
            }

            if (!SpTermIsKeyWaiting()) {
                return ASCI_ESC;
            }

            //
            // Read the next keystroke
            //
            Length = sizeof(HEADLESS_RSP_GET_BYTE);

            Status = HeadlessDispatch(HeadlessCmdGetByte,
                                      NULL,
                                      0,
                                      &Response,
                                      &Length
                                     );

            if (NT_SUCCESS(Status)) {
                Byte = Response.Value;
            } else {
                Byte = 0;
            }


            //
            // Some terminals send ESC, or ESC-[ to mean
            // they're about to send a control sequence.  We've already
            // gotten an ESC key, so ignore an '[' if it comes in.
            //
        } while ( Byte == '[' );


        switch (Byte) {
            case '@':
                return KEY_F12;
            case '!':
                return KEY_F11;
            case '0':
                return KEY_F10;
            case '9':
                return KEY_F9;
            case '8':
                return KEY_F8;
            case '7':
                return KEY_F7;
            case '6':
                return KEY_F6;
            case '5':
                return KEY_F5;
            case '4':
                return KEY_F4;
            case '3':
                return KEY_F3;
            case '2':
                return KEY_F2;
            case '1':
                return KEY_F1;
            case '+':
                return KEY_INSERT;
            case '-':
                return KEY_DELETE;
            case 'H':
                return KEY_HOME;
            case 'K':
                return KEY_END;
            case '?':
                return KEY_PAGEUP;
            case '/':
                return KEY_PAGEDOWN;
            case 'A':
                return KEY_UP;
            case 'B':
                return KEY_DOWN;
            case 'C':
                return KEY_RIGHT;
            case 'D':
                return KEY_LEFT;

        }

        //
        // We didn't get anything we recognized after the
        // ESC key.  Just return the ESC key.
        //
        return ASCI_ESC;

    } // Escape key



    //
    // The incoming byte isn't an escape code.
    //
    // Decode it as if it's a UTF8 stream.
    //
    if( SpTranslateUtf8ToUnicode( Byte,
                                  IncomingUtf8ConversionBuffer,
                                  &IncomingUnicodeValue ) ) {

        //
        // He returned TRUE, so we must have recieved a complete
        // UTF8-encoded character.
        //
        return IncomingUnicodeValue;
    } else {
        //
        // The UTF8 stream isn't complete yet, so we don't have
        // a decoded character to return yet.
        //
        return 0;
    }

}

VOID
SpTermDrain(
    VOID
    )

/*++

Routine Description:

    Read in and throw out all characters in input stream

Arguments:

    None.

Return Value:

    None.

--*/

{
    while (SpTermIsKeyWaiting()) {
        SpTermGetKeypress();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spupgcfg.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Spupgcfg.c

Abstract:

    Configuration routines for the upgrade case

Author:

    Sunil Pai (sunilp) 18-Nov-1993

Revision History:

--*/

#include "spprecmp.h"
#include <initguid.h>
#include <devguid.h>
#pragma hdrstop

NTSTATUS
SppResetLastKnownGood(
    IN  HANDLE  hKeySystem
    );

BOOLEAN
SppEnsureHardwareProfileIsPresent(
    IN HANDLE   hKeyCCSet
    );

VOID
SppSetGuimodeUpgradePath(
    IN HANDLE hKeySoftwareHive,
    IN HANDLE hKeyControlSet
    );

NTSTATUS
SppMigratePrinterKeys(
    IN HANDLE hControlSet,
    IN HANDLE hDestSoftwareHive
    );

VOID
SppClearMigratedInstanceValues(
    IN HANDLE hKeyCCSet
    );

VOID
SppClearMigratedInstanceValuesCallback(
    IN     HANDLE  SetupInstanceKeyHandle,
    IN     HANDLE  UpgradeInstanceKeyHandle  OPTIONAL,
    IN     BOOLEAN RootEnumerated,
    IN OUT PVOID   Context
    );


//
// Callback routine for SppMigrateDeviceParentId
//
typedef BOOL (*PSPP_DEVICE_MIGRATION_CALLBACK_ROUTINE) (
    IN     HANDLE  InstanceKeyHandle,
    IN     HANDLE  DriverKeyHandle
    );

VOID
SppMigrateDeviceParentId(
    IN HANDLE hKeyCCSet,
    IN PWSTR  DeviceId,
    IN PSPP_DEVICE_MIGRATION_CALLBACK_ROUTINE DeviceMigrationCallbackRoutine
    );

VOID
SppMigrateDeviceParentIdCallback(
    IN     HANDLE  SetupInstanceKeyHandle,
    IN     HANDLE  UpgradeInstanceKeyHandle OPTIONAL,
    IN     BOOLEAN RootEnumerated,
    IN OUT PVOID   Context
    );

BOOL
SppParallelClassCallback(
    IN     HANDLE  InstanceKeyHandle,
    IN     HANDLE  DriverKeyHandle
    );

typedef struct _GENERIC_BUFFER_CONTEXT {
    PUCHAR Buffer;
    ULONG  BufferSize;
} GENERIC_BUFFER_CONTEXT, *PGENERIC_BUFFER_CONTEXT;

typedef struct _DEVICE_MIGRATION_CONTEXT {
    PUCHAR Buffer;
    ULONG  BufferSize;
    ULONG  UniqueParentID;
    PWSTR  ParentIdPrefix;
    HANDLE hKeyCCSet;
    PSPP_DEVICE_MIGRATION_CALLBACK_ROUTINE DeviceMigrationCallbackRoutine;
} DEVICE_MIGRATION_CONTEXT, *PDEVICE_MIGRATION_CONTEXT;


//
// Device classe(s) for root device(s) that need to be deleted on upgrade
//
RootDevnodeSectionNamesType UpgRootDeviceClassesToDelete[] =
{
    { L"RootDeviceClassesToDelete",     RootDevnodeSectionNamesType_ALL,   0x0000, 0xffff },
    { L"RootDeviceClassesToDelete.NT4", RootDevnodeSectionNamesType_NTUPG, 0x0000, 0x04ff },
    { NULL, 0, 0, 0 }
};



NTSTATUS
SpUpgradeNTRegistry(
    IN PVOID    SifHandle,
    IN HANDLE  *HiveRootKeys,
    IN LPCWSTR  SetupSourceDevicePath,
    IN LPCWSTR  DirectoryOnSourceDevice,
    IN HANDLE   hKeyCCSet
    )

/*++

Routine Description:

    This routine does all the NT registry modifications needed on an upgrade.
    This includes the following:

    - Disabling network services
    - Running the addreg/delreg sections specified in txtsetup.sif
    - Deleting various root-enumerated devnode keys specified in txtsetup.sif

Arguments:

    SifHandle - supplies handle to txtsetup.sif.

    HiveRootKeys - supplies array of handles of root keys in the hives
            of the system being upgraded.

    hKeyCCSet: Handle to the root of the control set in the system
        being upgraded.

Return Value:

    Status is returned.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    BOOLEAN b;

    //
    // Disable the network stuff
    //
    Status = SpDisableNetwork(SifHandle,HiveRootKeys[SetupHiveSoftware],hKeyCCSet);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: warning: SpDisableNetworkFailed (%lx)\n",Status));
    }

    //
    // Migrate the parallel class device parent id value to all parallel
    // devices.
    //
    SppMigrateDeviceParentId(hKeyCCSet,
                             L"Root\\PARALLELCLASS\\0000",
                             SppParallelClassCallback);

    //
    // Delete legacy root-enumerated devnode keys out of Enum tree.
    //
    SpDeleteRootDevnodeKeys(SifHandle,
            hKeyCCSet,
            L"RootDevicesToDelete",
            UpgRootDeviceClassesToDelete);

    //
    // Clean the "Migrated" values from device instance keys in the setup
    // and upgrade registries, as appropriate.
    //
    SppClearMigratedInstanceValues(hKeyCCSet);

    //
    // If the user doesn't have any hardware profiles defined (i.e., we're upgrading
    // from a pre-NT4 system), then create them one.
    //
    b = SppEnsureHardwareProfileIsPresent(hKeyCCSet);

    if(!b) {
        return STATUS_UNSUCCESSFUL;
    }

    Status = SppMigratePrinterKeys( hKeyCCSet,
                                    HiveRootKeys[SetupHiveSoftware] );
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: warning: SppMigratePrinterKeys() failed. Status = %lx \n",Status));
    }


    //
    // Perform the general and wide-ranging hive upgrade.
    //
    b = SpHivesFromInfs(
            SifHandle,
            L"HiveInfs.Upgrade",
            SetupSourceDevicePath,
            DirectoryOnSourceDevice,
            HiveRootKeys[SetupHiveSystem],
            HiveRootKeys[SetupHiveSoftware],
            HiveRootKeys[SetupHiveDefault],
            HiveRootKeys[SetupHiveUserdiff]
            );

    if(!b) {
        return(STATUS_UNSUCCESSFUL);
    }


    SppSetGuimodeUpgradePath(HiveRootKeys[SetupHiveSystem],hKeyCCSet);

    //
    // Set 'LastKnownGood' the same as 'Current'
    // Ignore the error in case of failure, since this will
    // not affect the installation process
    //
    Status = SppResetLastKnownGood(HiveRootKeys[SetupHiveSystem]);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: warning: SppResetLastKnownGood() failed. Status = (%lx)\n",Status));
        return(Status);
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
SppDeleteKeyRecursive(
    HANDLE  hKeyRoot,
    PWSTR   Key,
    BOOLEAN ThisKeyToo
    )
/*++

Routine Description:

    Routine to recursively delete all subkeys under the given
    key, including the key given.

Arguments:

    hKeyRoot:    Handle to root relative to which the key to be deleted is
                 specified.

    Key:         Root relative path of the key which is to be recursively deleted.

    ThisKeyToo:  Whether after deletion of all subkeys, this key itself is to
                 be deleted.

Return Value:

    Status is returned.

--*/
{
    ULONG ResultLength;
    PKEY_BASIC_INFORMATION KeyInfo;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    PWSTR SubkeyName;
    HANDLE hKey;

    //
    // Initialize
    //

    KeyInfo = (PKEY_BASIC_INFORMATION)TemporaryBuffer;

    //
    // Open the key
    //

    INIT_OBJA(&Obja,&UnicodeString,Key);
    Obja.RootDirectory = hKeyRoot;
    Status = ZwOpenKey(&hKey,KEY_ALL_ACCESS,&Obja);
    if( !NT_SUCCESS(Status) ) {
        return(Status);
    }

    //
    // Enumerate all subkeys of the current key. if any exist they should
    // be deleted first.  since deleting the subkey affects the subkey
    // index, we always enumerate on subkeyindex 0
    //
    while(1) {
        Status = ZwEnumerateKey(
                    hKey,
                    0,
                    KeyBasicInformation,
                    TemporaryBuffer,
                    sizeof(TemporaryBuffer),
                    &ResultLength
                    );
        if(!NT_SUCCESS(Status)) {
            break;
        }

        //
        // Zero-terminate the subkey name just in case.
        //
        KeyInfo->Name[KeyInfo->NameLength/sizeof(WCHAR)] = 0;

        //
        // Make a duplicate of the subkey name because the name is
        // in TemporaryBuffer, which might get clobbered by recursive
        // calls to this routine.
        //
        SubkeyName = SpDupStringW(KeyInfo->Name);
        Status = SppDeleteKeyRecursive( hKey, SubkeyName, TRUE);
        SpMemFree(SubkeyName);
        if(!NT_SUCCESS(Status)) {
            break;
        }
    }

    ZwClose(hKey);

    //
    // Check the status, if the status is anything other than
    // STATUS_NO_MORE_ENTRIES we failed in deleting some subkey,
    // so we cannot delete this key too
    //

    if( Status == STATUS_NO_MORE_ENTRIES) {
        Status = STATUS_SUCCESS;
    }

    if(!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // else delete the current key if asked to do so
    //

    if( ThisKeyToo ) {
        Status = SpDeleteKey(hKeyRoot, Key);
    }

    return(Status);
}


NTSTATUS
SppCopyKeyRecursive(
    HANDLE  hKeyRootSrc,
    HANDLE  hKeyRootDst,
    PWSTR   SrcKeyPath,   OPTIONAL
    PWSTR   DstKeyPath,   OPTIONAL
    BOOLEAN CopyAlways,
    BOOLEAN ApplyACLsAlways
    )
/*++

Routine Description:

    This routine recursively copies a src key to a destination key.  Any new
    keys that are created will receive the same security that is present on
    the source key.

Arguments:

    hKeyRootSrc: Handle to root src key

    hKeyRootDst: Handle to root dst key

    SrcKeyPath:  src root key relative path to the subkey which needs to be
                 recursively copied. if this is null hKeyRootSrc is the key
                 from which the recursive copy is to be done.

    DstKeyPath:  dst root key relative path to the subkey which needs to be
                 recursively copied.  if this is null hKeyRootDst is the key
                 from which the recursive copy is to be done.

    CopyAlways:  If FALSE, this routine doesn't copy values which are already
                 there on the target tree.

Return Value:

    Status is returned.

--*/

{
    NTSTATUS             Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES    ObjaSrc, ObjaDst;
    UNICODE_STRING       UnicodeStringSrc, UnicodeStringDst, UnicodeStringValue;
    HANDLE               hKeySrc=NULL,hKeyDst=NULL;
    ULONG                ResultLength, Index;
    PWSTR                SubkeyName,ValueName;
    PSECURITY_DESCRIPTOR Security = NULL;

    PKEY_BASIC_INFORMATION      KeyInfo;
    PKEY_VALUE_FULL_INFORMATION ValueInfo;

    //
    // Get a handle to the source key
    //

    if(SrcKeyPath == NULL) {
        hKeySrc = hKeyRootSrc;
    }
    else {
        //
        // Open the Src key
        //

        INIT_OBJA(&ObjaSrc,&UnicodeStringSrc,SrcKeyPath);
        ObjaSrc.RootDirectory = hKeyRootSrc;
        Status = ZwOpenKey(&hKeySrc,KEY_READ,&ObjaSrc);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to open key %ws in the source hive (%lx)\n",SrcKeyPath,Status));
            return(Status);
        }
    }

    //
    // Get a handle to the destination key
    //

    if(DstKeyPath == NULL) {
        hKeyDst = hKeyRootDst;
    } else {
        //
        // First, get the security descriptor from the source key so we can create
        // the destination key with the correct ACL.
        //
        Status = ZwQuerySecurityObject(hKeySrc,
                                       DACL_SECURITY_INFORMATION,
                                       NULL,
                                       0,
                                       &ResultLength
                                      );
        if(Status==STATUS_BUFFER_TOO_SMALL) {
            Security=SpMemAlloc(ResultLength);
            Status = ZwQuerySecurityObject(hKeySrc,
                                           DACL_SECURITY_INFORMATION,
                                           Security,
                                           ResultLength,
                                           &ResultLength);
            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to query security for key %ws in the source hive (%lx)\n",
                         SrcKeyPath,
                         Status)
                       );
                SpMemFree(Security);
                Security=NULL;
            }
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to query security size for key %ws in the source hive (%lx)\n",
                     SrcKeyPath,
                     Status)
                   );
            Security=NULL;
        }
        //
        // Attempt to open (not create) the destination key first.  If we can't
        // open the key because it doesn't exist, then we'll create it and apply
        // the security present on the source key.
        //
        INIT_OBJA(&ObjaDst,&UnicodeStringDst,DstKeyPath);
        ObjaDst.RootDirectory = hKeyRootDst;
        Status = ZwOpenKey(&hKeyDst,KEY_ALL_ACCESS,&ObjaDst);
        if(!NT_SUCCESS(Status)) {
            //
            // Assume that failure was because the key didn't exist.  Now try creating
            // the key.

            ObjaDst.SecurityDescriptor = Security;

            Status = ZwCreateKey(
                        &hKeyDst,
                        KEY_ALL_ACCESS,
                        &ObjaDst,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        NULL
                        );

            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to create key %ws(%lx)\n",DstKeyPath, Status));
                if(SrcKeyPath != NULL) {
                    ZwClose(hKeySrc);
                }
                if(Security) {
                    SpMemFree(Security);
                }
                return(Status);
            }
        } else if (ApplyACLsAlways) {
            Status = ZwSetSecurityObject(
                        hKeyDst,
                        DACL_SECURITY_INFORMATION,
                        Security );

            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to copy ACL to existing key %ws(%lx)\n",DstKeyPath, Status));
            }
        }

        //
        // Free security descriptor buffer before checking return status from ZwCreateKey.
        //
        if(Security) {
            SpMemFree(Security);
        }

    }

    //
    // Enumerate all keys in the source key and recursively create
    // all the subkeys
    //

    KeyInfo = (PKEY_BASIC_INFORMATION)TemporaryBuffer;
    for( Index=0;;Index++ ) {

        Status = ZwEnumerateKey(
                    hKeySrc,
                    Index,
                    KeyBasicInformation,
                    TemporaryBuffer,
                    sizeof(TemporaryBuffer),
                    &ResultLength
                    );

        if(!NT_SUCCESS(Status)) {
            if(Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            }
            else {
                if(SrcKeyPath!=NULL) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to enumerate subkeys in key %ws(%lx)\n",SrcKeyPath, Status));
                }
                else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to enumerate subkeys in root key(%lx)\n", Status));
                }
            }
            break;
        }

        //
        // Zero-terminate the subkey name just in case.
        //
        KeyInfo->Name[KeyInfo->NameLength/sizeof(WCHAR)] = 0;

        //
        // Make a duplicate of the subkey name because the name is
        // in TemporaryBuffer, which might get clobbered by recursive
        // calls to this routine.
        //
        SubkeyName = SpDupStringW(KeyInfo->Name);
        Status = SppCopyKeyRecursive(
                     hKeySrc,
                     hKeyDst,
                     SubkeyName,
                     SubkeyName,
                     CopyAlways,
                     ApplyACLsAlways
                     );

        SpMemFree(SubkeyName);

    }

    //
    // Process any errors if found
    //

    if(!NT_SUCCESS(Status)) {

        if(SrcKeyPath != NULL) {
            ZwClose(hKeySrc);
        }
        if(DstKeyPath != NULL) {
            ZwClose(hKeyDst);
        }

        return(Status);
    }

    //
    // Enumerate all values in the source key and create all the values
    // in the destination key
    //
    ValueInfo = (PKEY_VALUE_FULL_INFORMATION)TemporaryBuffer;
    for( Index=0;;Index++ ) {

        Status = ZwEnumerateValueKey(
                    hKeySrc,
                    Index,
                    KeyValueFullInformation,
                    TemporaryBuffer,
                    sizeof(TemporaryBuffer),
                    &ResultLength
                    );

        if(!NT_SUCCESS(Status)) {
            if(Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            }
            else {
                if(SrcKeyPath!=NULL) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to enumerate values in key %ws(%lx)\n",SrcKeyPath, Status));
                }
                else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to enumerate values in root key(%lx)\n", Status));
                }
            }
            break;
        }

        //
        // Process the value found and create the value in the destination
        // key
        //
        ValueName = (PWSTR)SpMemAlloc(ValueInfo->NameLength + sizeof(WCHAR));
        ASSERT(ValueName);
        wcsncpy(ValueName, ValueInfo->Name, (ValueInfo->NameLength)/sizeof(WCHAR));
        ValueName[(ValueInfo->NameLength)/sizeof(WCHAR)] = 0;
        RtlInitUnicodeString(&UnicodeStringValue,ValueName);

        //
        // If it is a conditional copy, we need to check if the value already
        // exists in the destination, in which case we shouldn't set the value
        //
        if( !CopyAlways ) {
            ULONG Length;
            PKEY_VALUE_BASIC_INFORMATION DestValueBasicInfo;

            Length = sizeof(KEY_VALUE_BASIC_INFORMATION) + ValueInfo->NameLength + sizeof(WCHAR) + MAX_PATH;
            DestValueBasicInfo = (PKEY_VALUE_BASIC_INFORMATION)SpMemAlloc(Length);
            ASSERT(DestValueBasicInfo);
            Status = ZwQueryValueKey(
                         hKeyDst,
                         &UnicodeStringValue,
                         KeyValueBasicInformation,
                         DestValueBasicInfo,
                         Length,
                         &ResultLength
                         );
            SpMemFree((PVOID)DestValueBasicInfo);

            if(NT_SUCCESS(Status)) {
                //
                // Value exists, we shouldn't change the value
                //
                SpMemFree(ValueName);
                continue;
            }


            if( Status!=STATUS_OBJECT_NAME_NOT_FOUND && Status!=STATUS_OBJECT_PATH_NOT_FOUND) {
                if(DstKeyPath) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to query value %ws in key %ws(%lx)\n",ValueName,DstKeyPath, Status));
                }
                else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to query value %ws in root key(%lx)\n",ValueName, Status));
                }
                SpMemFree(ValueName);
                break;
            }

        }

        Status = ZwSetValueKey(
                    hKeyDst,
                    &UnicodeStringValue,
                    ValueInfo->TitleIndex,
                    ValueInfo->Type,
                    (PBYTE)ValueInfo + ValueInfo->DataOffset,
                    ValueInfo->DataLength
                    );

        if(!NT_SUCCESS(Status)) {
            if(DstKeyPath) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to set value %ws in key %ws(%lx)\n",ValueName,DstKeyPath, Status));
            }
            else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to set value %ws(%lx)\n",ValueName, Status));
            }
            SpMemFree(ValueName);
            break;
        }
        SpMemFree(ValueName);
    }

    //
    // cleanup
    //
    if(SrcKeyPath != NULL) {
        ZwClose(hKeySrc);
    }
    if(DstKeyPath != NULL) {
        ZwClose(hKeyDst);
    }

    return(Status);
}

NTSTATUS
SppResetLastKnownGood(
    IN  HANDLE  hKeySystem
    )
{
    NTSTATUS                        Status;
    ULONG                           ResultLength;
    DWORD                           Value;

    //
    //  Make the appropriate change
    //

    Status = SpGetValueKey(
                 hKeySystem,
                 L"Select",
                 L"Current",
                 sizeof(TemporaryBuffer),
                 (PCHAR)TemporaryBuffer,
                 &ResultLength
                 );

    //
    //  TemporaryBuffer is 32kb long, and it should be big enough
    //  for the data.
    //
    ASSERT( Status != STATUS_BUFFER_OVERFLOW );
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to read value from registry. KeyName = Select, ValueName = Current, Status = (%lx)\n",Status));
        return( Status );
    }

    Value = *(DWORD *)(((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data);
    Status = SpOpenSetValueAndClose( hKeySystem,
                                     L"Select",
                                     L"LastKnownGood",
                                     REG_DWORD,
                                     &Value,
                                     sizeof( ULONG ) );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to write value to registry. KeyName = Select, ValueName = LastKnownGood, Status = (%lx)\n",Status));
    }
    //
    //  We need also to reset the value 'Failed'. Otherwise, the Service Control
    //  Manager will display a popup indicating the LastKnownGood CCSet was
    //  used.
    //
    Value = 0;
    Status = SpOpenSetValueAndClose( hKeySystem,
                                     L"Select",
                                     L"Failed",
                                     REG_DWORD,
                                     &Value,
                                     sizeof( ULONG ) );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to write value to registry. KeyName = Select, ValueName = Failed, Status = (%lx)\n",Status));
    }
    return( Status );
}

VOID
SpDeleteRootDevnodeKeys(
    IN PVOID  SifHandle,
    IN HANDLE hKeyCCSet,
    IN PWSTR DevicesToDelete,
    IN RootDevnodeSectionNamesType *DeviceClassesToDelete
    )

/*++

Routine Description:

    This routine deletes some root-enumerated devnode registry keys
    based on criteria specified in txtsetup.sif.  The following sections
    are processed:

    [RootDevicesToDelete] - this section lists device IDs under
                            HKLM\System\CurrentControlSet\Enum\Root that
                            should be deleted (including their subkeys).

    [RootDeviceClassesToDelete] - this section lists device class GUIDs
                                  whose root-enumerated members are to be
                                  deleted.

    For each device instance key to be deleted, we also delete the corresponding
    Driver key under HKLM\System\CurrentControlSet\Control\Class, if specified.

    We also do two additional operations to clean-up in certain cases where we
    may encounter junk deposited in the registry from NT4:

        1.  Delete any root-enumerated devnode keys that have a nonzero (or
            ill-formed) "Phantom" value, indicating that they're a "private
            phantom".
        2.  Delete any Control subkeys we may find--since these are supposed to
            always be volatile, we _should_ never see these, but we've seen
            cases where OEM preinstalls 'seed' the hives with device instance
            keys including this subkey, and the results are disastrous (i.e.,
            we bugcheck when we encounter a PDO address we'd squirreled away in
            the key on a previous boot thinking it was nonvolatile, hence would
            disappear upon reboot).

Arguments:

    SifHandle: Supplies handle to txtsetup.sif.

    hKeyCCSet: Handle to the root of the control set in the system
        being upgraded.

    DevicesToDelete: Section name containing the root device names that need
        to be deleted.

    DeviceClassesToDelete: Specifies the classes of root devices that need to
        be deleted.

Return Value:

    none.

--*/
{
    HANDLE hRootKey, hDeviceKey, hInstanceKey, hClassKey;
    HANDLE hSetupRootKey, hSetupDeviceKey, hSetupInstanceKey, hSetupClassKey;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString, guidString;
    ULONG LineIndex, DeviceKeyIndex, ResultLength, InstanceKeyIndex;
    PKEY_BASIC_INFORMATION DeviceKeyInfo, InstanceKeyInfo;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    PUCHAR p, q;
    BOOLEAN InstanceKeysEnumerated;
    PWSTR DeviceId, ClassGuidToDelete;
    PUCHAR MyScratchBuffer;
    ULONG MyScratchBufferSize, drvInst;
    BOOLEAN DeleteInstanceKey;
    int SectionIndex;
    DWORD OsFlags = 0;
    DWORD OsVersion = 0;
    DWORD MangledVersion;
    PWSTR Value;

    //
    // Determine OSFlags & OSVersion for going through various sections
    //
    Value = SpGetSectionKeyIndex(WinntSifHandle,
                                SIF_DATA, WINNT_D_NTUPGRADE_W, 0);

    if(Value && _wcsicmp(Value, WINNT_A_YES_W)==0) {
        //
        // It's an NT upgrade
        //
        OsFlags |= RootDevnodeSectionNamesType_NTUPG;
    }
    if(!OsFlags) {
        Value = SpGetSectionKeyIndex(WinntSifHandle,
                                    SIF_DATA, WINNT_D_WIN95UPGRADE_W, 0);

        if (Value && _wcsicmp(Value, WINNT_A_YES_W)==0) {
            //
            // It's a Win9x upgrade
            //
            OsFlags |= RootDevnodeSectionNamesType_W9xUPG;
        }
        if(!OsFlags) {
            //
            // in all other cases assume clean
            //
            OsFlags = RootDevnodeSectionNamesType_CLEAN;
        }
    }

    Value = SpGetSectionKeyIndex(WinntSifHandle,
                                SIF_DATA, WINNT_D_WIN32_VER_W, 0);

    if(Value) {
        //
        // version is bbbbllhh - build/low/high
        //
        MangledVersion = (DWORD)SpStringToLong( Value, NULL, 16 );

        //
        // NTRAID#453953 2001/08/09-JamieHun OsVersion checking is wrong
        // this should be RtlUshortByteSwap((USHORT)MangledVersion) & 0xffff;
        // Win2k -> 0005 WinXP -> 0105
        // so we always run ".NT4" below
        //
        OsVersion = MAKEWORD(LOBYTE(LOWORD(MangledVersion)),HIBYTE(LOWORD(MangledVersion)));
    } else {
        OsVersion = 0;
    }

    //
    // open CCS\Enum\Root in the registry being upgraded.
    //
    INIT_OBJA(&Obja, &UnicodeString, L"Enum\\Root");
    Obja.RootDirectory = hKeyCCSet;

    Status = ZwOpenKey(&hRootKey, KEY_ALL_ACCESS, &Obja);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                   "SETUP: Unable to open upgrade Enum\\Root for devnode deletion.  Status = %lx \n",
                   Status));
        return;
    }

    //
    // Open CCS\Enum\Root in the current setup registry.
    //
    INIT_OBJA(&Obja, &UnicodeString, L"\\Registry\\Machine\\System\\CurrentControlSet\\Enum\\Root");
    Obja.RootDirectory = NULL;

    Status = ZwOpenKey(&hSetupRootKey, KEY_ALL_ACCESS, &Obja);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                   "SETUP: Unable to open setup Enum\\Root for devnode deletion.  Status = %lx \n",
                   Status));
        ZwClose(hRootKey);
        return;
    }

    //
    // Next, open CCS\Control\Class in the registry being upgraded.
    //
    INIT_OBJA(&Obja, &UnicodeString, L"Control\\Class");
    Obja.RootDirectory = hKeyCCSet;

    Status = ZwOpenKey(&hClassKey, KEY_ALL_ACCESS, &Obja);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                   "SETUP: Unable to open upgrade Control\\Class for devnode deletion.  Status = %lx \n",
                   Status));
        ZwClose(hSetupRootKey);
        ZwClose(hRootKey);
        return;
    }

    //
    // Open CCS\Control\Class in the current setup registry.
    //
    INIT_OBJA(&Obja, &UnicodeString, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Class");
    Obja.RootDirectory = NULL;

    Status = ZwOpenKey(&hSetupClassKey, KEY_ALL_ACCESS, &Obja);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                   "SETUP: Unable to open setup Control\\Class for devnode deletion.  Status = %lx \n",
                   Status));
        ZwClose(hClassKey);
        ZwClose(hSetupRootKey);
        ZwClose(hRootKey);
        return;
    }

    //
    // Allocate some scratch space to work with.  The most we'll need is enough for 2
    // KEY_BASIC_INFORMATION structures, plus the maximum length of a device instance ID,
    // plus a KEY_VALUE_PARTIAL_INFORMATION structure, plus the length of a driver instance
    // key path [stringified GUID + '\' + 4 digit ordinal + term NULL], plus 2 large integer
    // structures for alignment.
    //
    MyScratchBufferSize = (2*sizeof(KEY_BASIC_INFORMATION)) + (200*sizeof(WCHAR)) +
                          sizeof(KEY_VALUE_PARTIAL_INFORMATION) + ((GUID_STRING_LEN+5)*sizeof(WCHAR) +
                          2*sizeof(LARGE_INTEGER));

    MyScratchBuffer = SpMemAlloc(MyScratchBufferSize);
    if(!MyScratchBuffer) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                   "SETUP: Can't allocate memory for deletion of classes of root-enumerated devnodes!\n"));
        ZwClose(hSetupClassKey);
        ZwClose(hClassKey);
        ZwClose(hSetupRootKey);
        ZwClose(hRootKey);
        return;
    }

    //
    // PART 1: Process [RootDevicesToDelete]
    //

    //
    // Now, traverse the entries under the [RootDevicesToDelete] section, and
    // delete each one.
    //
    for(LineIndex = 0;
        DeviceId = SpGetSectionLineIndex(SifHandle, DevicesToDelete, LineIndex, 0);
        LineIndex++) {

        //
        // Open up the device key so we can enumerate the instances.
        //
        INIT_OBJA(&Obja, &UnicodeString, DeviceId);
        Obja.RootDirectory = hRootKey;

        Status = ZwOpenKey(&hDeviceKey, KEY_ALL_ACCESS, &Obja);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                       "SETUP: Unable to open Enum\\Root\\%ws during devnode deletion.  Status = %lx \n",
                       DeviceId,
                       Status));
            //
            // Skip this key and continue.
            //
            continue;
        }

        //
        // Attempt to open the device key in the setup registry.
        //
        Obja.RootDirectory = hSetupRootKey;

        Status = ZwOpenKey(&hSetupDeviceKey, KEY_ALL_ACCESS, &Obja);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                       "SETUP: Unable to open Enum\\Root\\%ws during devnode deletion.  Status = %lx \n",
                       DeviceId,
                       Status));
            //
            // It's ok if we don't have this device key in the setup registry.
            //
            hSetupDeviceKey = NULL;
        }

        //
        // Now enumerate the instance subkeys under this device key.
        //

        p = ALIGN_UP_POINTER(((PUCHAR)MyScratchBuffer), sizeof(LARGE_INTEGER));

        InstanceKeyInfo = (PKEY_BASIC_INFORMATION)p;
        InstanceKeyIndex = 0;

        while(TRUE) {

            Status = ZwEnumerateKey(hDeviceKey,
                                    InstanceKeyIndex,
                                    KeyBasicInformation,
                                    p,
                                    (ULONG)MyScratchBufferSize,
                                    &ResultLength
                                    );
            if(!NT_SUCCESS(Status)) {
                break;
            }

            //
            // Zero-terminate the instance key name, just in case.
            //
            InstanceKeyInfo->Name[InstanceKeyInfo->NameLength/sizeof(WCHAR)] = 0;

            //
            // Now, open up the instance key so we can check its Driver value.
            //
            INIT_OBJA(&Obja, &UnicodeString, InstanceKeyInfo->Name);
            Obja.RootDirectory = hDeviceKey;

            Status = ZwOpenKey(&hInstanceKey, KEY_ALL_ACCESS, &Obja);
            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                           "SETUP: Unable to open Enum\\Root\\%ws\\%ws for potential devnode deletion.  Status = %lx \n",
                           DeviceId,
                           InstanceKeyInfo->Name,
                           Status));
                //
                // Skip this key and continue.
                //
                InstanceKeyIndex++;
                continue;
            }

            //
            // Attempt to open the same instance key in the setup registry.
            //
            hSetupInstanceKey = NULL;
            if (hSetupDeviceKey) {
                Obja.RootDirectory = hSetupDeviceKey;
                Status = ZwOpenKey(&hSetupInstanceKey, KEY_ALL_ACCESS, &Obja);
                if(!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                               "SETUP: Unable to open setup Enum\\Root\\%ws\\%ws for potential devnode deletion.  Status = %lx \n",
                               DeviceId,
                               InstanceKeyInfo->Name,
                               Status));
                }
            }

            //
            // Now look for some value entries under this instance key.  Don't
            // overwrite the instance key name already in MyScratchBuffer,
            // since we'll need it later.
            //
            q = ALIGN_UP_POINTER(((PUCHAR)p + ResultLength), sizeof(LARGE_INTEGER));

            if (hSetupInstanceKey) {
                //
                // Check if the Migrated value still exists on this registry
                // key.  If so, it was migrated, but wasn't ever used by
                // textmode setup and is now specified to be deleted.
                //
                KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
                RtlInitUnicodeString(&UnicodeString, L"Migrated");
                Status = ZwQueryValueKey(hSetupInstanceKey,
                                         &UnicodeString,
                                         KeyValuePartialInformation,
                                         q,
                                         (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                         &ResultLength);
                if (NT_SUCCESS(Status) &&
                    (KeyValueInfo->Type == REG_DWORD) &&
                    (*(PULONG)(KeyValueInfo->Data) == 1)) {
                    DeleteInstanceKey = TRUE;
                } else {
                    DeleteInstanceKey = FALSE;
                }
            }
            //
            // First check for the presence of old style "Driver" value.
            //
            KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
            RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_DRIVER);
            Status = ZwQueryValueKey(hInstanceKey,
                                     &UnicodeString,
                                     KeyValuePartialInformation,
                                     q,
                                     (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                     &ResultLength
                                     );
            if (NT_SUCCESS(Status) && KeyValueInfo->Type == REG_SZ) {
                //
                // Delete the Driver key.
                //
                SppDeleteKeyRecursive(hClassKey, (PWCHAR)KeyValueInfo->Data, TRUE);

                //
                // Also attempt to delete the driver key from the setup
                // registry.  Note that we don't need to check that it has the
                // same Driver value, since we explicitly migrated it to be the
                // same value at the start of textmode setup.
                //
                if (hSetupInstanceKey && DeleteInstanceKey) {
                    SppDeleteKeyRecursive(hSetupClassKey, (PWCHAR)KeyValueInfo->Data, TRUE);
                }
            } else {
                //
                // Construct the driver instance as "ClassGuid\nnnn"
                //
                KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
                RtlInitUnicodeString(&UnicodeString, REGSTR_VALUE_GUID);
                Status = ZwQueryValueKey(hInstanceKey,
                                         &UnicodeString,
                                         KeyValuePartialInformation,
                                         q,
                                         (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                         &ResultLength
                                         );
                if (NT_SUCCESS(Status) && KeyValueInfo->Type == REG_BINARY) {

                    Status = RtlStringFromGUID((REFGUID)KeyValueInfo->Data, &guidString);
                    ASSERT(NT_SUCCESS(Status));
                    if (NT_SUCCESS(Status)) {

                        KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
                        RtlInitUnicodeString(&UnicodeString, REGSTR_VALUE_DRVINST);
                        Status = ZwQueryValueKey(hInstanceKey,
                                                 &UnicodeString,
                                                 KeyValuePartialInformation,
                                                 q,
                                                 (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                                 &ResultLength
                                                 );
                        if (NT_SUCCESS(Status) && KeyValueInfo->Type == REG_DWORD) {

                            drvInst = *(PULONG)KeyValueInfo->Data;
                            swprintf((PWCHAR)&KeyValueInfo->Data[0], TEXT("%wZ\\%04u"), &guidString, drvInst);
                            //
                            // Delete the Driver key.
                            //
                            SppDeleteKeyRecursive(hClassKey, (PWCHAR)KeyValueInfo->Data, TRUE);

                            //
                            // Also attempt to delete the driver key from the setup
                            // registry.  Note that we don't need to check that it has the
                            // same Driver value, since we explicitly migrated it to be the
                            // same value at the start of textmode setup.
                            //
                            if (hSetupInstanceKey && DeleteInstanceKey) {
                                SppDeleteKeyRecursive(hSetupClassKey, (PWCHAR)KeyValueInfo->Data, TRUE);
                            }
                        }
                        RtlFreeUnicodeString(&guidString);
                    }
                }
            }
            //
            // Delete the instance key from the setup registry, if we should do so.
            //
            if (hSetupInstanceKey && DeleteInstanceKey) {
                ZwClose(hSetupInstanceKey);
                SppDeleteKeyRecursive(hSetupDeviceKey, InstanceKeyInfo->Name, TRUE);
            }

            //
            // Now close the handle, and move on to the next one.
            //
            ZwClose(hInstanceKey);
            InstanceKeyIndex++;
        }

        //
        // Delete the device key, and all instance subkeys.
        //
        ZwClose(hDeviceKey);
        SppDeleteKeyRecursive(hRootKey, DeviceId, TRUE);

        //
        // If the device has no remaining instances in the setup registry,
        // delete the device key.
        //
        if (hSetupDeviceKey) {
            KEY_FULL_INFORMATION keyFullInfo;
            Status = ZwQueryKey(hSetupDeviceKey,
                                KeyFullInformation,
                                (PVOID)&keyFullInfo,
                                sizeof(KEY_FULL_INFORMATION),
                                &ResultLength);
            ZwClose(hSetupDeviceKey);
            hSetupDeviceKey = NULL;
            if ((NT_SUCCESS(Status) || (Status == STATUS_BUFFER_TOO_SMALL)) &&
                (keyFullInfo.SubKeys == 0)) {
                SppDeleteKeyRecursive(hSetupRootKey, DeviceId, TRUE);
            }
        }
    }


    //
    // PART 2: Process [RootDeviceClassesToDelete]
    //

    //
    // Now, enumerate all remaining device instances under Enum\Root, looking for
    // devices whose class is one of our classes to delete.
    //
    DeviceKeyInfo = (PKEY_BASIC_INFORMATION)MyScratchBuffer;
    DeviceKeyIndex = 0;
    while(TRUE && DeviceClassesToDelete) {

        Status = ZwEnumerateKey(hRootKey,
                                DeviceKeyIndex,
                                KeyBasicInformation,
                                MyScratchBuffer,
                                MyScratchBufferSize,
                                &ResultLength
                               );
        if(!NT_SUCCESS(Status)) {
            break;
        }

        //
        // Reset our flag that indicates whether or not we enumerated the instance
        // subkeys under this key.  We use this later in determining whether the
        // device key itself should be deleted.
        //
        InstanceKeysEnumerated = FALSE;

        //
        // Zero-terminate the subkey name just in case.
        //
        DeviceKeyInfo->Name[DeviceKeyInfo->NameLength/sizeof(WCHAR)] = 0;
        //
        // Go ahead and bump the used-buffer length by sizeof(WCHAR), to
        // accomodate the potential growth caused by adding a terminating NULL.
        //
        ResultLength += sizeof(WCHAR);

        //
        // Now, open up the device key so we can enumerate the instances.
        //
        INIT_OBJA(&Obja, &UnicodeString, DeviceKeyInfo->Name);
        Obja.RootDirectory = hRootKey;

        Status = ZwOpenKey(&hDeviceKey, KEY_ALL_ACCESS, &Obja);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                       "SETUP: Unable to open Enum\\Root\\%ws for potential devnode deletion.  Status = %lx \n",
                       DeviceKeyInfo->Name,
                       Status));
            //
            // Skip this key and continue.
            //
            DeviceKeyIndex++;
            continue;
        }

        //
        // Attempt to open the device key in the setup registry.
        //
        Obja.RootDirectory = hSetupRootKey;

        Status = ZwOpenKey(&hSetupDeviceKey, KEY_ALL_ACCESS, &Obja);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                       "SETUP: Unable to open setup Enum\\Root\\%ws during devnode deletion.  Status = %lx \n",
                       DeviceKeyInfo->Name,
                       Status));
            //
            // It's ok if we don't have this device key in the setup registry.
            //
            hSetupDeviceKey = NULL;
        }

        //
        // Now enumerate the instance subkeys under this device key.  Don't overwrite
        // the device ID key name already in MyScratchBuffer, since we'll probably
        // be needing it again in the case where all subkeys get deleted.
        //

        p = ALIGN_UP_POINTER(((PUCHAR)MyScratchBuffer + ResultLength), sizeof(LARGE_INTEGER));

        InstanceKeyInfo = (PKEY_BASIC_INFORMATION)p;
        InstanceKeyIndex = 0;
        InstanceKeysEnumerated = TRUE;
        while(TRUE) {

            Status = ZwEnumerateKey(hDeviceKey,
                                    InstanceKeyIndex,
                                    KeyBasicInformation,
                                    p,
                                    (ULONG)((MyScratchBuffer + MyScratchBufferSize) - p),
                                    &ResultLength
                                   );
            if(!NT_SUCCESS(Status)) {
                break;
            }

            //
            // Zero-terminate the instance key name, just in case.
            //
            InstanceKeyInfo->Name[InstanceKeyInfo->NameLength/sizeof(WCHAR)] = 0;

            //
            // Go ahead and bump the used-buffer length by sizeof(WCHAR), to
            // accomodate the potential growth caused by adding a terminating NULL.
            //
            ResultLength += sizeof(WCHAR);

            //
            // Now, open up the instance key so we can check its class.
            //
            INIT_OBJA(&Obja, &UnicodeString, InstanceKeyInfo->Name);
            Obja.RootDirectory = hDeviceKey;

            Status = ZwOpenKey(&hInstanceKey, KEY_ALL_ACCESS, &Obja);
            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                           "SETUP: Unable to open Enum\\Root\\%ws\\%ws for potential devnode deletion.  Status = %lx \n",
                           DeviceKeyInfo->Name,
                           InstanceKeyInfo->Name,
                           Status));
                //
                // Skip this key and continue.
                //
                InstanceKeyIndex++;
                continue;
            }

            //
            // Attempt to open the same instance key in the setup registry.
            //
            hSetupInstanceKey = NULL;
            if (hSetupDeviceKey) {
                Obja.RootDirectory = hSetupDeviceKey;
                Status = ZwOpenKey(&hSetupInstanceKey, KEY_ALL_ACCESS, &Obja);
                if(!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                               "SETUP: Unable to open setup Enum\\Root\\%ws\\%ws for potential devnode deletion.  Status = %lx \n",
                               DeviceId,
                               InstanceKeyInfo->Name,
                               Status));
                }
            }

            DeleteInstanceKey = FALSE;

            //
            // Now look for some value entries under this instance key.  Don't
            // overwrite the instance key name already in MyScratchBuffer,
            // since we'll need it if we discover that the instance should be
            // deleted.
            //
            q = ALIGN_UP_POINTER(((PUCHAR)p + ResultLength), sizeof(LARGE_INTEGER));

            //
            // If we find a nonzero Phantom value entry, then the devnode
            // should be removed.
            //
            KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
            RtlInitUnicodeString(&UnicodeString, L"Phantom");
            Status = ZwQueryValueKey(hInstanceKey,
                                     &UnicodeString,
                                     KeyValuePartialInformation,
                                     q,
                                     (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                     &ResultLength
                                    );

            if(NT_SUCCESS(Status) &&
               ((KeyValueInfo->Type != REG_DWORD) ||
                *(PULONG)(KeyValueInfo->Data))) {

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                           "SETUP: SpDeleteRootDevnodeKeys: Encountered a left-over phantom in Enum\\Root\\%ws\\%ws. Deleting key. \n",
                           DeviceKeyInfo->Name,
                           InstanceKeyInfo->Name));

                DeleteInstanceKey = TRUE;
            }

            if(!DeleteInstanceKey) {
                //
                // Unless it is a phantom, if we find a nonzero
                // FirmwareIdentified value entry, then the devnode should not
                // be removed, no matter what class it is.
                //
                KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
                RtlInitUnicodeString(&UnicodeString, L"FirmwareIdentified");
                Status = ZwQueryValueKey(hInstanceKey,
                                         &UnicodeString,
                                         KeyValuePartialInformation,
                                         q,
                                         (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                         &ResultLength
                                         );

                if(NT_SUCCESS(Status) &&
                   ((KeyValueInfo->Type != REG_DWORD) ||
                    *(PULONG)(KeyValueInfo->Data))) {
                    //
                    // Skip this key and continue;
                    //
                    goto CloseInstanceKeyAndContinue;
                }
            }

            if(!DeleteInstanceKey) {
                //
                // Retrieve the ClassGUID value entry.
                //
                // First check for the old value.
                //
                KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
                RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_CLASSGUID);
                Status = ZwQueryValueKey(hInstanceKey,
                                         &UnicodeString,
                                         KeyValuePartialInformation,
                                         q,
                                         (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                         &ResultLength
                                        );
                if(!NT_SUCCESS(Status)) {
                    //
                    // Check the new value.
                    //
                    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
                    RtlInitUnicodeString(&UnicodeString, REGSTR_VALUE_GUID);
                    Status = ZwQueryValueKey(hInstanceKey,
                                             &UnicodeString,
                                             KeyValuePartialInformation,
                                             q,
                                             (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                             &ResultLength
                                            );
                    if(NT_SUCCESS(Status) && KeyValueInfo->Type == REG_BINARY) {
                        GUID    guid;
                        UNICODE_STRING guidString;

                        guid = *(GUID *)KeyValueInfo->Data;
                        Status = RtlStringFromGUID(&guid, &guidString);
                        ASSERT(NT_SUCCESS(Status));
                        if (NT_SUCCESS(Status)) {

                            KeyValueInfo->Type = REG_SZ;
                            KeyValueInfo->DataLength = guidString.MaximumLength;
                            RtlCopyMemory(KeyValueInfo->Data, guidString.Buffer, KeyValueInfo->DataLength);
                            RtlFreeUnicodeString(&guidString);
                        } else {

                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                                       "SETUP: SpDeleteRootDevnodeKeys: Failed to convert GUID to string! \n",
                                       DeviceKeyInfo->Name,
                                       InstanceKeyInfo->Name));
                            //
                            // Skip this key and continue;
                            //
                            goto CloseInstanceKeyAndContinue;
                        }
                    } else {

                        DeleteInstanceKey = TRUE;
                    }
                }
            }

            if(DeleteInstanceKey) {
                //
                // The instance key will be deleted.  Check if the instance
                // specifies a corresponding Driver key that should also be
                // deleted.
                //
                // First read the old style "Driver" value.
                //
                KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
                RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_DRIVER);
                Status = ZwQueryValueKey(hInstanceKey,
                                         &UnicodeString,
                                         KeyValuePartialInformation,
                                         q,
                                         (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                         &ResultLength
                                         );
                if (NT_SUCCESS(Status) && KeyValueInfo->Type == REG_SZ) {
                    //
                    // Delete the Driver key.
                    //
                    SppDeleteKeyRecursive(hClassKey, (PWCHAR)KeyValueInfo->Data, TRUE);
                    //
                    // Also attempt to delete the driver key from the setup
                    // registry.  Note that we don't need to check that it has the
                    // same Driver value, since we explicitly migrated it to be the
                    // same value at the start of textmode setup.
                    //
                    if (hSetupInstanceKey) {
                        SppDeleteKeyRecursive(hSetupClassKey, (PWCHAR)KeyValueInfo->Data, TRUE);
                    }
                } else {
                    //
                    // Create the driver instance.
                    //
                    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
                    RtlInitUnicodeString(&UnicodeString, REGSTR_VALUE_GUID);
                    Status = ZwQueryValueKey(hInstanceKey,
                                             &UnicodeString,
                                             KeyValuePartialInformation,
                                             q,
                                             (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                             &ResultLength
                                             );
                    if (NT_SUCCESS(Status) && KeyValueInfo->Type == REG_BINARY) {

                        Status = RtlStringFromGUID((REFGUID)KeyValueInfo->Data, &guidString);
                        ASSERT(NT_SUCCESS(Status));
                        if (NT_SUCCESS(Status)) {

                            KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
                            RtlInitUnicodeString(&UnicodeString, REGSTR_VALUE_DRVINST);
                            Status = ZwQueryValueKey(hInstanceKey,
                                                     &UnicodeString,
                                                     KeyValuePartialInformation,
                                                     q,
                                                     (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                                     &ResultLength
                                                     );
                            if (NT_SUCCESS(Status) && KeyValueInfo->Type == REG_DWORD) {

                                drvInst = *(PULONG)KeyValueInfo->Data;
                                swprintf((PWCHAR)&KeyValueInfo->Data[0], TEXT("%wZ\\%04u"), &guidString, drvInst);
                                //
                                // Delete the Driver key.
                                //
                                SppDeleteKeyRecursive(hClassKey, (PWCHAR)KeyValueInfo->Data, TRUE);

                                //
                                // Also attempt to delete the driver key from the setup
                                // registry.  Note that we don't need to check that it has the
                                // same Driver value, since we explicitly migrated it to be the
                                // same value at the start of textmode setup.
                                //
                                if (hSetupInstanceKey) {
                                    SppDeleteKeyRecursive(hSetupClassKey, (PWCHAR)KeyValueInfo->Data, TRUE);
                                }
                            }
                            RtlFreeUnicodeString(&guidString);
                        }
                    }
                }
                //
                // Delete the instance key.
                //
                ZwClose(hInstanceKey);
                SppDeleteKeyRecursive(hDeviceKey, InstanceKeyInfo->Name, TRUE);

                //
                // Delete the instance key from the setup registry.
                //
                if (hSetupInstanceKey) {
                    ZwClose(hSetupInstanceKey);
                    SppDeleteKeyRecursive(hSetupDeviceKey, InstanceKeyInfo->Name, TRUE);
                }

                //
                // We deleted the instance key, so set the instance enumeration
                // index back to zero and continue.
                //
                InstanceKeyIndex = 0;
                continue;
            }

            //
            // This value should be exactly the length of a stringified GUID + terminating NULL.
            //
            if(KeyValueInfo->DataLength != (GUID_STRING_LEN * sizeof(WCHAR))) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                           "SETUP: SpDeleteRootDevnodeKeys: Enum\\Root\\%ws\\%ws has corrupted ClassGUID! \n",
                           DeviceKeyInfo->Name,
                           InstanceKeyInfo->Name));
                //
                // Skip this key and continue;
                //
                goto CloseInstanceKeyAndContinue;
            }

            //
            // Now loop through the [RootDeviceClassesToDelete] section to see if this class is one
            // of the ones whose devices we're supposed to delete.
            //
            // NTRAID#453953 2001/08/09-JamieHun OsVersion checking is wrong
            // as this stands, we will always process all sections
            //
            for(SectionIndex = 0; DeviceClassesToDelete[SectionIndex].SectionName; SectionIndex++) {
                if((!DeviceClassesToDelete[SectionIndex].SectionFlags & OsFlags)
                   || (OsVersion < DeviceClassesToDelete[SectionIndex].VerLow)
                   || (OsVersion > DeviceClassesToDelete[SectionIndex].VerHigh)) {
                    //
                    // not interesting
                    //
                    // NTRAID#453953 2001/08/09-JamieHun OsVersion checking is wrong
                    // we don't get here
                    //
                    continue;
                }
                for(LineIndex = 0;
                    ClassGuidToDelete = SpGetSectionLineIndex(SifHandle,
                                            DeviceClassesToDelete[SectionIndex].SectionName,
                                            LineIndex,
                                            0);
                    LineIndex++) {
                    //
                    // Compare the two GUID strings.
                    //
                    if(!_wcsicmp(ClassGuidToDelete, (PWCHAR)(KeyValueInfo->Data))) {
                        //
                        // NTRAID#257655 2001/08/09-JamieHun SMS AppCompat due to #453953
                        //
                        if((_wcsicmp(DeviceKeyInfo->Name,L"*SMS_KEYBOARD")==0) ||
                           (_wcsicmp(DeviceKeyInfo->Name,L"*SMS_MOUSE")==0)) {
                            //
                            // looks like an SMS mouse or keyboard
                            // check service name to be double-safe
                            //
                            KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
                            RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_SERVICE);
                            Status = ZwQueryValueKey(hInstanceKey,
                                                     &UnicodeString,
                                                     KeyValuePartialInformation,
                                                     q,
                                                     (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                                     &ResultLength
                                                     );
                            if (NT_SUCCESS(Status) && KeyValueInfo->Type == REG_SZ) {

                                //
                                // device has a service
                                //
                                if(_wcsicmp((PWCHAR)KeyValueInfo->Data,L"kbstuff")==0) {
                                    //
                                    // yup, definately SMS!
                                    // we really don't want to delete this
                                    //
                                    goto CloseInstanceKeyAndContinue;
                                }

                            }

                        }

                        //
                        // We have a match.  Check if the instance specifies a
                        // corresponding Driver key that should also be deleted.
                        //
                        // First check the old style "Driver" value.
                        //
                        KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
                        RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_DRIVER);
                        Status = ZwQueryValueKey(hInstanceKey,
                                                 &UnicodeString,
                                                 KeyValuePartialInformation,
                                                 q,
                                                 (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                                 &ResultLength
                                                 );
                        if (NT_SUCCESS(Status) && KeyValueInfo->Type == REG_SZ) {

                            SppDeleteKeyRecursive(hClassKey, (PWCHAR)KeyValueInfo->Data, TRUE);

                        } else {

                            KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
                            RtlInitUnicodeString(&UnicodeString, REGSTR_VALUE_GUID);
                            Status = ZwQueryValueKey(hInstanceKey,
                                                     &UnicodeString,
                                                     KeyValuePartialInformation,
                                                     q,
                                                     (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                                     &ResultLength
                                                     );
                            if (NT_SUCCESS(Status) && KeyValueInfo->Type == REG_BINARY) {

                                Status = RtlStringFromGUID((REFGUID)KeyValueInfo->Data, &guidString);
                                ASSERT(NT_SUCCESS(Status));
                                if (NT_SUCCESS(Status)) {

                                    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)q;
                                    RtlInitUnicodeString(&UnicodeString, REGSTR_VALUE_DRVINST);
                                    Status = ZwQueryValueKey(hInstanceKey,
                                                             &UnicodeString,
                                                             KeyValuePartialInformation,
                                                             q,
                                                             (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                                             &ResultLength
                                                             );
                                    if (NT_SUCCESS(Status) && KeyValueInfo->Type == REG_DWORD) {

                                        drvInst = *(PULONG)KeyValueInfo->Data;
                                        swprintf((PWCHAR)&KeyValueInfo->Data[0], TEXT("%wZ\\%04u"), &guidString, drvInst);
                                        //
                                        // Delete the Driver key.
                                        //
                                        SppDeleteKeyRecursive(hClassKey, (PWCHAR)KeyValueInfo->Data, TRUE);
                                    }
                                    RtlFreeUnicodeString(&guidString);
                                }
                            }
                        }

                        //
                        // Nuke this key and break out of the GUID comparison loop.
                        //
                        ZwClose(hInstanceKey);
                        SppDeleteKeyRecursive(hDeviceKey, InstanceKeyInfo->Name, TRUE);
                        goto DeletedKeyRecursive;
                    }
                }
            }
DeletedKeyRecursive:

            if(ClassGuidToDelete) {
                //
                // We deleted the instance key, so set the instance enumeration index back to zero
                // and continue.
                //
                InstanceKeyIndex = 0;
                continue;
            }

CloseInstanceKeyAndContinue:
            //
            // If we get to here, then we've decided that this instance key
            // should not be deleted. Delete the Control key (if there happens
            // to be one) to avoid a painful death at next boot.
            //
            SppDeleteKeyRecursive(hInstanceKey, L"Control", TRUE);

            //
            // Now close the handle, and move on to the next one.
            //
            ZwClose(hInstanceKey);
            if (hSetupInstanceKey) {
                ZwClose(hSetupInstanceKey);
            }
            InstanceKeyIndex++;
        }

        ZwClose(hDeviceKey);

        //
        // If we dropped out of the loop on instance subkeys, and the index is non-zero,
        // then there remains at least one subkey that we didn't delete, so we can't nuke
        // the parent.  Otherwise, delete the device key.
        //
        if(InstanceKeysEnumerated && !InstanceKeyIndex) {
            SppDeleteKeyRecursive(hRootKey, DeviceKeyInfo->Name, TRUE);
            //
            // Since we deleted a key, we must reset our enumeration index.
            //
            DeviceKeyIndex = 0;
        } else {
            //
            // We didn't delete this key--move on to the next one.
            //
            DeviceKeyIndex++;
        }

        //
        // If the device has no remaining instances in the setup registry,
        // delete the device key.
        //
        if (hSetupDeviceKey) {
            KEY_FULL_INFORMATION keyFullInfo;
            Status = ZwQueryKey(hSetupDeviceKey,
                                KeyFullInformation,
                                (PVOID)&keyFullInfo,
                                sizeof(KEY_FULL_INFORMATION),
                                &ResultLength);
            ZwClose(hSetupDeviceKey);
            if ((NT_SUCCESS(Status) || (Status == STATUS_BUFFER_TOO_SMALL)) &&
                (keyFullInfo.SubKeys == 0)) {
                SppDeleteKeyRecursive(hSetupRootKey, DeviceKeyInfo->Name, TRUE);
            }
        }
    }

    ZwClose(hSetupClassKey);
    ZwClose(hClassKey);
    ZwClose(hSetupRootKey);
    ZwClose(hRootKey);

    SpMemFree(MyScratchBuffer);

    return;
}


VOID
SppClearMigratedInstanceValues(
    IN HANDLE hKeyCCSet
    )

/*++

Routine Description:

    This routine removes "Migrated" values from device instance keys in the
    setup registry that were migrated at the start of textmode setup (from
    winnt.sif, via SpMigrateDeviceInstanceData).

Arguments:

    hKeyCCSet: Handle to the root of the control set in the system
               being upgraded.

Return Value:

    None.

Notes:

    This routine is not called when performing an ASR setup (not an upgrade).

    For upgrade setup, it is safe to remove "Migrated" values from all
    device instance keys because these keys were migrated from the system
    registry in the winnt.sif during the winnt32 portion of setup, so all the
    information will be present when we boot into GUI setup after this.

    Note that during ASR setup, these values are not removed during textmode
    setp because the registry these instances were migrated from is not restored
    until late in GUI setup.

--*/
{
    GENERIC_BUFFER_CONTEXT Context;

    //
    // Allocate some scratch space for the callback routine to work with.  The
    // most it will need is enough for a KEY_VALUE_PARTIAL_INFORMATION
    // structure, plus a stringified GUID, plus a large integer structure for
    // alignment.
    //
    Context.BufferSize = sizeof(KEY_VALUE_PARTIAL_INFORMATION) +
                         sizeof(DWORD) + sizeof(LARGE_INTEGER);
    Context.Buffer = SpMemAlloc(Context.BufferSize);
    if(!Context.Buffer) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                   "SETUP: Can't allocate context for SppClearMigratedInstanceValuesCallback, exiting!\n"));
        return;
    }

    //
    // Apply the devnode migration processing callback to all device instance
    // keys.
    //
    SpApplyFunctionToDeviceInstanceKeys(hKeyCCSet,
        SppClearMigratedInstanceValuesCallback,
        &Context);

    //
    // Free the allocated context buffer,
    //
    SpMemFree(Context.Buffer);

    return;
}


VOID
SppMigrateDeviceParentId(
    IN HANDLE hKeyCCSet,
    IN PWSTR  DeviceId,
    IN PSPP_DEVICE_MIGRATION_CALLBACK_ROUTINE DeviceMigrationCallbackRoutine
    )

/*++

Routine Description:

    This routine migrates the ParentIdPrefix or UniqueParentID value from the
    specified device instance in the registry being upgraded to any device
    instances in the current registry, as dictated by the specified
    InstanceKeyCallbackRoutine.

Arguments:

    hKeyCCSet: Handle to the root of the control set in the system
               being upgraded.

    DeviceId:  Device instance Id of the device in the system being upgraded
               whose ParentIdPrefix (or UniqueParentID) value is to be migrated
               to device instance keys in the current system registry.

    InstanceKeyCallbackRoutine: Callback routine for each device instance key in
               the existsing registry that should decide if the values should be
               replaced.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HANDLE hEnumKey, hInstanceKey;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    PUCHAR p;
    ULONG ResultLength;
    DEVICE_MIGRATION_CONTEXT DeviceMigrationContext;


    //
    // Allocate some scratch space to work with here, and in our callback
    // routine.  The most we'll need is enough for a
    // KEY_VALUE_PARTIAL_INFORMATION structure, the length of a stringified GUID
    // + '\' + 4 digit ordinal + terminating NULL, plus a large integer
    // structure for alignment.
    //
    DeviceMigrationContext.BufferSize = sizeof(KEY_VALUE_PARTIAL_INFORMATION) +
                                        ((GUID_STRING_LEN + 5)*sizeof(WCHAR)) +
                                        sizeof(LARGE_INTEGER);

    DeviceMigrationContext.Buffer = SpMemAlloc(DeviceMigrationContext.BufferSize);
    if(!DeviceMigrationContext.Buffer) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                   "SETUP: Can't allocate memory for device migration processing!\n"));
        return;
    }

    //
    // Open the Enum key in the registry being upgraded.
    //
    INIT_OBJA(&Obja, &UnicodeString, L"Enum");
    Obja.RootDirectory = hKeyCCSet;

    Status = ZwOpenKey(&hEnumKey, KEY_ALL_ACCESS, &Obja);
    if (!NT_SUCCESS(Status)) {
        SpMemFree(DeviceMigrationContext.Buffer);
        return;
    }

    //
    // Open the specified device instance key in the registry being upgraded.
    //
    INIT_OBJA(&Obja, &UnicodeString, DeviceId);
    Obja.RootDirectory = hEnumKey;

    Status = ZwOpenKey(&hInstanceKey, KEY_ALL_ACCESS, &Obja);

    ZwClose(hEnumKey);

    if (!NT_SUCCESS(Status)) {
        //
        // Couldn't find the key to migrate, so we're done.
        //
        SpMemFree(DeviceMigrationContext.Buffer);
        return;
    }

    //
    // Retrieve the UniqueParentID, if one exists.
    //
    DeviceMigrationContext.ParentIdPrefix = NULL;
    p = ALIGN_UP_POINTER(((PUCHAR)DeviceMigrationContext.Buffer), sizeof(LARGE_INTEGER));
    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)p;
    RtlInitUnicodeString(&UnicodeString, L"UniqueParentID");
    Status = ZwQueryValueKey(hInstanceKey,
                             &UnicodeString,
                             KeyValuePartialInformation,
                             KeyValueInfo,
                             (ULONG)((DeviceMigrationContext.Buffer +
                                      DeviceMigrationContext.BufferSize) - p),
                             &ResultLength);
    if (NT_SUCCESS(Status)) {
        ASSERT(KeyValueInfo->Type == REG_DWORD);
        DeviceMigrationContext.UniqueParentID = *(PULONG)(KeyValueInfo->Data);
    } else {
        //
        // No UniqueParentID, so look for the ParentIdPrefix.
        //
        RtlInitUnicodeString(&UnicodeString, L"ParentIdPrefix");
        Status = ZwQueryValueKey(hInstanceKey,
                                 &UnicodeString,
                                 KeyValuePartialInformation,
                                 KeyValueInfo,
                                 (ULONG)((DeviceMigrationContext.Buffer +
                                          DeviceMigrationContext.BufferSize) - p),
                                 &ResultLength);
        if (NT_SUCCESS(Status)) {
            ASSERT(KeyValueInfo->Type == REG_SZ);
            DeviceMigrationContext.ParentIdPrefix = SpDupStringW((PWSTR)KeyValueInfo->Data);
            ASSERT(DeviceMigrationContext.ParentIdPrefix);
        }
    }

    ZwClose(hInstanceKey);

    if (!NT_SUCCESS(Status)) {
        //
        // If we couldn't find either value, there's nothing more we can do.
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                   "SETUP: No Parent Id values were found for %ws for migration.  Status = %lx \n",
                   DeviceId,
                   Status));
        SpMemFree(DeviceMigrationContext.Buffer);
        return;
    }

    //
    // Supply the hKeyCCSet for the system being upgraded.
    //
    DeviceMigrationContext.hKeyCCSet = hKeyCCSet;

    //
    // Supply the caller specified device migration callback routine.
    //
    DeviceMigrationContext.DeviceMigrationCallbackRoutine = DeviceMigrationCallbackRoutine;

    //
    // Apply the parent id migration callback for all device instance keys.
    // This will in turn, call the specified device instance callback routine to
    // determine whether parent id migration should be done.
    //
    SpApplyFunctionToDeviceInstanceKeys(hKeyCCSet,
        SppMigrateDeviceParentIdCallback,
        &DeviceMigrationContext);

    if (DeviceMigrationContext.ParentIdPrefix) {
        SpMemFree(DeviceMigrationContext.ParentIdPrefix);
    }
    SpMemFree(DeviceMigrationContext.Buffer);

    return;
}


VOID
SppMigrateDeviceParentIdCallback(
    IN     HANDLE  SetupInstanceKeyHandle,
    IN     HANDLE  UpgradeInstanceKeyHandle OPTIONAL,
    IN     BOOLEAN RootEnumerated,
    IN OUT PVOID   Context
    )

/*++

Routine Description:

    This routine is a callback routine for SpApplyFunctionToDeviceInstanceKeys.

Arguments:

    SetupInstanceKeyHandle: Handle to the device instance key in the current
        registry.

    UpgradeInstanceKeyHandle: Handle to the corresponding device instance key in
        the system being upgraded, if it exists.

    Context: User supplied context.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString, guidString;
    PDEVICE_MIGRATION_CONTEXT DeviceMigrationContext;
    PUCHAR p;
    ULONG ResultLength, drvInst;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    HANDLE hClassKey, hDriverKey;
    BOOL CallbackResult;

    UNREFERENCED_PARAMETER(SetupInstanceKeyHandle);
    UNREFERENCED_PARAMETER(RootEnumerated);

    //
    // We only care about keys that exist in the system being upgraded.
    //
    if (!UpgradeInstanceKeyHandle) {
        return;
    }

    //
    // Retrieve the "Driver" value from the instance key.
    //
    DeviceMigrationContext = (PDEVICE_MIGRATION_CONTEXT)Context;
    p = ALIGN_UP_POINTER(((PUCHAR)DeviceMigrationContext->Buffer), sizeof(LARGE_INTEGER));

    //
    // First check the old style "Driver" value.
    //
    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)p;
    RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_DRIVER);
    Status = ZwQueryValueKey(UpgradeInstanceKeyHandle,
                             &UnicodeString,
                             KeyValuePartialInformation,
                             p,
                             (ULONG)((DeviceMigrationContext->Buffer +
                                      DeviceMigrationContext->BufferSize) - p),
                             &ResultLength
                             );
    if (!NT_SUCCESS(Status) || KeyValueInfo->Type != REG_SZ) {

        //
        // Try the new style "GUID" and "DrvInst" values.
        //
        KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)p;
        RtlInitUnicodeString(&UnicodeString, REGSTR_VALUE_GUID);
        Status = ZwQueryValueKey(UpgradeInstanceKeyHandle,
                                 &UnicodeString,
                                 KeyValuePartialInformation,
                                 p,
                                 (ULONG)((DeviceMigrationContext->Buffer +
                                          DeviceMigrationContext->BufferSize) - p),
                                 &ResultLength
                                 );
        if (!NT_SUCCESS(Status) || KeyValueInfo->Type != REG_BINARY) {

            return;
        }

        Status = RtlStringFromGUID((REFGUID)KeyValueInfo->Data, &guidString);
        ASSERT(NT_SUCCESS(Status));
        if (!NT_SUCCESS(Status)) {

            return;
        }

        KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)p;
        RtlInitUnicodeString(&UnicodeString, REGSTR_VALUE_DRVINST);
        Status = ZwQueryValueKey(UpgradeInstanceKeyHandle,
                                 &UnicodeString,
                                 KeyValuePartialInformation,
                                 p,
                                 (ULONG)((DeviceMigrationContext->Buffer +
                                          DeviceMigrationContext->BufferSize) - p),
                                 &ResultLength
                                 );
        if (!NT_SUCCESS(Status) || KeyValueInfo->Type != REG_DWORD) {

            return;
        }
        drvInst = *(PULONG)KeyValueInfo->Data;
        swprintf((PWCHAR)&KeyValueInfo->Data[0], TEXT("%wZ\\%04u"), &guidString, drvInst);
        RtlFreeUnicodeString(&guidString);
    }

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
               "SETUP: SppMigrateDeviceParentIdCallback: Driver = %ws\n",
               (PWSTR)KeyValueInfo->Data));

    //
    // Open the Control\Class key in the system being upgraded.
    //
    INIT_OBJA(&Obja, &UnicodeString, L"Control\\Class");
    Obja.RootDirectory = DeviceMigrationContext->hKeyCCSet;

    Status = ZwOpenKey(&hClassKey, KEY_ALL_ACCESS, &Obja);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                   "SETUP: Unable to open Class key for device migration processing.  Status = %lx \n",
                   Status));
        return;
    }

    //
    // Open the device's "Driver" key.
    //
    INIT_OBJA(&Obja, &UnicodeString, (PWSTR)KeyValueInfo->Data);
    Obja.RootDirectory = hClassKey;

    Status = ZwOpenKey(&hDriverKey, KEY_ALL_ACCESS, &Obja);

    ZwClose(hClassKey);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                   "SETUP: Unable to open Class\\%ws key for device migration processing.  Status = %lx \n",
                   (PWSTR)KeyValueInfo->Data,
                   Status));
        return;
    }

    //
    // Call the specified device migration callback routine.
    //
    CallbackResult = (DeviceMigrationContext->DeviceMigrationCallbackRoutine)(
                          UpgradeInstanceKeyHandle,
                          hDriverKey);

    ZwClose(hDriverKey);

    if (!CallbackResult) {
        return;
    }

    //
    // Replace the UniqueParentID or ParentIdPrefix values for this device
    // instance.  First, remove any UniqueParentId or ParentIdPrefix values that
    // already exist for this instance key.
    //
    RtlInitUnicodeString(&UnicodeString, L"ParentIdPrefix");
    ZwDeleteValueKey(UpgradeInstanceKeyHandle, &UnicodeString);

    RtlInitUnicodeString(&UnicodeString, L"UniqueParentID");
    ZwDeleteValueKey(UpgradeInstanceKeyHandle, &UnicodeString);

    //
    // Replace the instance key's UniqueParentID or ParentIdPrefix with that
    // from the device migration context.
    //
    if (!DeviceMigrationContext->ParentIdPrefix) {

        //
        // We're using the old UniqueParentID mechanism.
        //
        RtlInitUnicodeString(&UnicodeString, L"UniqueParentID");
        Status = ZwSetValueKey(UpgradeInstanceKeyHandle,
                               &UnicodeString,
                               0,
                               REG_DWORD,
                               &DeviceMigrationContext->UniqueParentID,
                               sizeof(DeviceMigrationContext->UniqueParentID));
        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                       "SETUP: Unable to set %ws during device migration processing.  Status = %lx \n",
                       UnicodeString.Buffer,
                       Status));
        }
    } else {

        //
        // We're using the ParentIdPrefix mechanism.
        //
        RtlInitUnicodeString(&UnicodeString, L"ParentIdPrefix");
        Status = ZwSetValueKey(UpgradeInstanceKeyHandle,
                               &UnicodeString,
                               0,
                               REG_SZ,
                               DeviceMigrationContext->ParentIdPrefix,
                               (wcslen(DeviceMigrationContext->ParentIdPrefix)+1)*sizeof(WCHAR));
        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                       "SETUP: Unable to set %ws during device migration processing.  Status = %lx \n",
                       UnicodeString.Buffer,
                       Status));
        }
    }

    return;
}


BOOL
SppParallelClassCallback(
    IN     HANDLE  InstanceKeyHandle,
    IN     HANDLE  DriverKeyHandle
    )

/*++

Routine Description:

    This routine is a callback routine for SpApplyFunctionToDeviceInstanceKeys.

Arguments:

    InstanceKeyHandle: Handle to the device instance key in the system being
        upgraded.

    DriverKeyHandle: Handle to the driver key for device instance in
        the system being upgraded.

Return Value:

    Returns TRUE/FALSE.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    PUCHAR MyScratchBuffer;
    ULONG MyScratchBufferSize;
    PUCHAR p;
    ULONG ResultLength;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    HANDLE hClassKey, hDriverKey;
    UNICODE_STRING UnicodeString;
    GUID guid;

    //
    // Allocate some scratch space to work with.  The most we'll need is enough
    // for a KEY_VALUE_PARTIAL_INFORMATION structure, plus a stringified GUID,
    // plus a large integer structure for alignment.
    //
    MyScratchBufferSize = sizeof(KEY_VALUE_PARTIAL_INFORMATION) +
                          (GUID_STRING_LEN * sizeof(WCHAR)) +
                          sizeof(LARGE_INTEGER);
    MyScratchBuffer = SpMemAlloc(MyScratchBufferSize);
    if(!MyScratchBuffer) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                   "SETUP: Can't allocate memory for parallel migration processing!\n"));
        return FALSE;
    }

    //
    // Check the class of the enumerated device instance, and see if it is a
    // member of the "Ports" class.
    //
    p = ALIGN_UP_POINTER(((PUCHAR)MyScratchBuffer), sizeof(LARGE_INTEGER));

    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)p;
    RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_CLASSGUID);
    Status = ZwQueryValueKey(InstanceKeyHandle,
                             &UnicodeString,
                             KeyValuePartialInformation,
                             p,
                             (ULONG)((MyScratchBuffer + MyScratchBufferSize) - p),
                             &ResultLength);
    if (NT_SUCCESS(Status)) {

        if (KeyValueInfo->Type == REG_SZ) {

            RtlInitUnicodeString(&UnicodeString, (PWSTR)KeyValueInfo->Data);
            Status = RtlGUIDFromString(&UnicodeString, &guid);

        } else {

            Status = STATUS_UNSUCCESSFUL;
        }
    } else {

        KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)p;
        RtlInitUnicodeString(&UnicodeString, REGSTR_VALUE_GUID);
        Status = ZwQueryValueKey(InstanceKeyHandle,
                                 &UnicodeString,
                                 KeyValuePartialInformation,
                                 p,
                                 (ULONG)((MyScratchBuffer + MyScratchBufferSize) - p),
                                 &ResultLength);
        if (NT_SUCCESS(Status)) {

            if (KeyValueInfo->Type == REG_BINARY) {

                guid = *(GUID *)KeyValueInfo->Data;
            } else {

                Status = STATUS_UNSUCCESSFUL;
            }
        }
    }
    if (NT_SUCCESS(Status)) {

        if (!IsEqualGUID(&GUID_DEVCLASS_PORTS, &guid)) {
            //
            // Not a match.
            //
            Status = STATUS_UNSUCCESSFUL;
        }
    }

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    //
    // Check the "PortSubClass" value from the device's driver key.
    //
    RtlInitUnicodeString(&UnicodeString, REGSTR_VAL_PORTSUBCLASS);
    Status = ZwQueryValueKey(DriverKeyHandle,
                             &UnicodeString,
                             KeyValuePartialInformation,
                             p,
                             (ULONG)((MyScratchBuffer + MyScratchBufferSize) - p),
                             &ResultLength);

    if (!NT_SUCCESS(Status) ||
        (KeyValueInfo->Type != REG_BINARY) ||
        (KeyValueInfo->DataLength != sizeof(BYTE)) ||
        (*(PBYTE)(KeyValueInfo->Data) != 0x0)) {
        return FALSE;
    }

    //
    // This device instance is a parallel port device.
    //
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
               "SETUP: \tSppParallelClassCallback: Found a parallel port!\n"));

    return TRUE;
}


VOID
SppClearMigratedInstanceValuesCallback(
    IN     HANDLE  SetupInstanceKeyHandle,
    IN     HANDLE  UpgradeInstanceKeyHandle  OPTIONAL,
    IN     BOOLEAN RootEnumerated,
    IN OUT PVOID   Context
    )

/*++

Routine Description:

    This routine is a callback routine for SpApplyFunctionToDeviceInstanceKeys.

Arguments:

    SetupInstanceKeyHandle: Handle to the device instance key in the current
        registry.

    UpgradeInstanceKeyHandle: Handle to the corresponding device instance key in
        the system being upgraded, if it exists.

    Context: User supplied context.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    PUCHAR p;
    ULONG ResultLength;
    PGENERIC_BUFFER_CONTEXT BufferContext;

    //
    // To save us the effort of allocating a buffer on every iteration of the
    // callback, SppClearMigratedInstanceValues has already allocated a buffer
    // for us to use, and supplied to us as our context.
    //
    BufferContext = (PGENERIC_BUFFER_CONTEXT)Context;

    ASSERT(BufferContext->Buffer);
    ASSERT(BufferContext->BufferSize > 0);

    //
    // Check if the Migrated value still exists on this registry key.  If so, it
    // was migrated, but wasn't seen by textmode setup.
    //
    p = ALIGN_UP_POINTER(((PUCHAR)BufferContext->Buffer), sizeof(LARGE_INTEGER));
    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)p;
    RtlInitUnicodeString(&UnicodeString, L"Migrated");
    Status = ZwQueryValueKey(SetupInstanceKeyHandle,
                             &UnicodeString,
                             KeyValuePartialInformation,
                             p,
                             (ULONG)(BufferContext->BufferSize),
                             &ResultLength);
    if (NT_SUCCESS(Status)) {
        //
        // If there is a Migrated value, it should be well-formed, but we still
        // want to delete it no matter what it is.
        //
        ASSERT(KeyValueInfo->Type == REG_DWORD);
        ASSERT(*(PULONG)(KeyValueInfo->Data) == 1);

        if (UpgradeInstanceKeyHandle) {
            //
            // This instance key exists in the upgraded registry, so we'll
            // remove the Migrated value from it in the setup registry.
            //
            Status = ZwDeleteValueKey(SetupInstanceKeyHandle, &UnicodeString);
            ASSERT(NT_SUCCESS(Status));

            //
            // Remove the migrated value from the key in the upgraded registry
            // only if it is root-enumerated, because those devices should
            // always be enumerated, no matter what.
            //
            // (If the instance key is not root-enumerated, the value should
            // really stay as it is - so that migrated values on ASR machines
            // are preserved on upgrades.)
            //
            if (RootEnumerated) {
                ZwDeleteValueKey(UpgradeInstanceKeyHandle, &UnicodeString);
            }
        }
    }

    return;
}


VOID
SpApplyFunctionToDeviceInstanceKeys(
    IN HANDLE hKeyCCSet,
    IN PSPP_INSTANCEKEY_CALLBACK_ROUTINE InstanceKeyCallbackRoutine,
    IN OUT PVOID Context
    )

/*++

Routine Description:

    This routine enumerates device instance keys in the setup registry, and
    calls the specified callback routine for each such device instance key.

Arguments:

    hKeyCCSet: Handle to the root of the control set in the system
               being upgraded.

    InstanceKeyCallbackRoutine - Supplies a pointer to a function that will be
        called for each device instance key in the setup registry.
        The prototype of the function is as follows:

          typedef VOID (*PSPP_INSTANCEKEY_CALLBACK_ROUTINE) (
              IN     HANDLE  SetupInstanceKeyHandle,
              IN     HANDLE  UpgradeInstanceKeyHandle  OPTIONAL,
              IN     BOOLEAN RootEnumerated,
              IN OUT PVOID   Context
              );

        where SetupInstanceKeyHandle is the handle to an enumerated device
        instance key in the setup registry, UpgradeInstanceKeyHandle is the
        handle to the corresponding device instance key in the registry being
        upgraded (if exists), and Context is a pointer to user-defined data.

Return Value:

    None.

Note:

    Note that a device instance key in the system being upgraded is opened only
    after the corresponding device instance key was enumerated in the setup
    registry.

--*/
{
    NTSTATUS Status;
    HANDLE hEnumKey, hEnumeratorKey, hDeviceKey, hInstanceKey;
    HANDLE hUpgradeEnumKey, hUpgradeEnumeratorKey, hUpgradeDeviceKey, hUpgradeInstanceKey;
    BOOLEAN RootEnumerated;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    PUCHAR MyScratchBuffer;
    ULONG MyScratchBufferSize;
    ULONG EnumeratorKeyIndex, DeviceKeyIndex, InstanceKeyIndex, ResultLength;
    PKEY_BASIC_INFORMATION EnumeratorKeyInfo, DeviceKeyInfo, InstanceKeyInfo;
    PUCHAR p, q, r;

    //
    // First, open CCS\Enum in the setup registry.
    //
    INIT_OBJA(&Obja, &UnicodeString, L"\\Registry\\Machine\\System\\CurrentControlSet\\Enum");
    Obja.RootDirectory = NULL;

    Status = ZwOpenKey(&hEnumKey, KEY_ALL_ACCESS, &Obja);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                   "SETUP: Unable to open setup Enum for device migration processing.  Status = %lx \n",
                   Status));
        return;
    }

    //
    // Next, open CCS\Enum in the registry being upgraded.
    //
    INIT_OBJA(&Obja, &UnicodeString, L"Enum");
    Obja.RootDirectory = hKeyCCSet;

    Status = ZwOpenKey(&hUpgradeEnumKey, KEY_ALL_ACCESS, &Obja);
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
                   "SETUP: Unable to open upgrade Enum for device migration processing.  Status = %lx \n",
                   Status));
        //
        // This is really odd, but not fatal.
        //
        hUpgradeEnumKey = NULL;
    }

    //
    // Allocate some scratch space to work with.  The most we'll need is enough
    // for 3 KEY_BASIC_INFORMATION structures, plus the maximum length of a
    // device instance ID, plus 3 large integer structures for alignment.
    //
    MyScratchBufferSize = (3*sizeof(KEY_BASIC_INFORMATION)) +
                          (200*sizeof(WCHAR)) +
                          (3*sizeof(LARGE_INTEGER));

    MyScratchBuffer = SpMemAlloc(MyScratchBufferSize);
    if(!MyScratchBuffer) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                   "SETUP: Can't allocate memory for device migration processing!\n"));
        ZwClose(hEnumKey);
        return;
    }

    //
    // First, enumerate the enumerator subkeys under the Enum key.
    //
    EnumeratorKeyInfo = (PKEY_BASIC_INFORMATION)MyScratchBuffer;
    EnumeratorKeyIndex = 0;
    while(TRUE) {

        Status = ZwEnumerateKey(hEnumKey,
                                EnumeratorKeyIndex,
                                KeyBasicInformation,
                                MyScratchBuffer,
                                MyScratchBufferSize,
                                &ResultLength);
        if(!NT_SUCCESS(Status)) {
            break;
        }

        //
        // Zero-terminate the subkey name just in case.
        //
        EnumeratorKeyInfo->Name[EnumeratorKeyInfo->NameLength/sizeof(WCHAR)] = 0;

        //
        // Go ahead and bump the used-buffer length by sizeof(WCHAR), to
        // accomodate the potential growth caused by adding a terminating NULL.
        //
        ResultLength += sizeof(WCHAR);

        //
        // Determine if the subkey devices are root-enumerated.
        //
        RootEnumerated = (_wcsnicmp(EnumeratorKeyInfo->Name,
                                    REGSTR_KEY_ROOTENUM, 4) == 0);

        //
        // Now, open up the enumerator key so we can enumerate the devices.
        //
        INIT_OBJA(&Obja, &UnicodeString, EnumeratorKeyInfo->Name);
        Obja.RootDirectory = hEnumKey;

        Status = ZwOpenKey(&hEnumeratorKey, KEY_ALL_ACCESS, &Obja);
        if(!NT_SUCCESS(Status)) {
            //
            // Skip this key and continue.
            //
            EnumeratorKeyIndex++;
            continue;
        }

        //
        // Open the enumerator key in the registry being upgraded.
        //
        hUpgradeEnumeratorKey = NULL;
        if (hUpgradeEnumKey) {
            Obja.RootDirectory = hUpgradeEnumKey;

            Status = ZwOpenKey(&hUpgradeEnumeratorKey, KEY_ALL_ACCESS, &Obja);
            if(!NT_SUCCESS(Status)) {
                //
                // Again, this is odd, but not fatal.
                //
                hUpgradeEnumeratorKey = NULL;
            }
        }

        //
        // Now enumerate the device subkeys under this enumerator key.  Don't
        // overwrite the enumerator key name already in MyScratchBuffer.
        //
        p = ALIGN_UP_POINTER(((PUCHAR)MyScratchBuffer + ResultLength), sizeof(LARGE_INTEGER));

        //
        // Now, enumerate all devices under the enumerator.
        //
        DeviceKeyInfo = (PKEY_BASIC_INFORMATION)p;
        DeviceKeyIndex = 0;
        while(TRUE) {

            Status = ZwEnumerateKey(hEnumeratorKey,
                                    DeviceKeyIndex,
                                    KeyBasicInformation,
                                    p,
                                    (ULONG)((MyScratchBuffer + MyScratchBufferSize) - p),
                                    &ResultLength);
            if(!NT_SUCCESS(Status)) {
                break;
            }

            //
            // Zero-terminate the subkey name just in case.
            //
            DeviceKeyInfo->Name[DeviceKeyInfo->NameLength/sizeof(WCHAR)] = 0;

            //
            // Go ahead and bump the used-buffer length by sizeof(WCHAR), to
            // accomodate the potential growth caused by adding a terminating NULL.
            //
            ResultLength += sizeof(WCHAR);

            //
            // Now, open up the device key so we can enumerate the instances.
            //
            INIT_OBJA(&Obja, &UnicodeString, DeviceKeyInfo->Name);
            Obja.RootDirectory = hEnumeratorKey;

            Status = ZwOpenKey(&hDeviceKey, KEY_ALL_ACCESS, &Obja);
            if(!NT_SUCCESS(Status)) {
                //
                // Skip this key and continue.
                //
                DeviceKeyIndex++;
                continue;
            }

            //
            // Open the device key in the registry being upgraded.
            //
            hUpgradeDeviceKey = NULL;
            if (hUpgradeEnumeratorKey) {
                Obja.RootDirectory = hUpgradeEnumeratorKey;

                Status = ZwOpenKey(&hUpgradeDeviceKey, KEY_ALL_ACCESS, &Obja);
                if(!NT_SUCCESS(Status)) {
                    //
                    // Again, this is odd, but not fatal.
                    //
                    hUpgradeDeviceKey = NULL;
                }
            }

            //
            // Now enumerate the device subkeys under this enumerator key.  Don't
            // overwrite the enumerator key name already in MyScratchBuffer.
            //
            q = ALIGN_UP_POINTER(((PUCHAR)p + ResultLength), sizeof(LARGE_INTEGER));

            //
            // Now, enumerate all instances under the device.
            //
            InstanceKeyInfo = (PKEY_BASIC_INFORMATION)q;
            InstanceKeyIndex = 0;
            while(TRUE) {

                Status = ZwEnumerateKey(hDeviceKey,
                                        InstanceKeyIndex,
                                        KeyBasicInformation,
                                        q,
                                        (ULONG)((MyScratchBuffer + MyScratchBufferSize) - q),
                                        &ResultLength);
                if(!NT_SUCCESS(Status)) {
                    break;
                }

                //
                // Zero-terminate the subkey name just in case.
                //
                InstanceKeyInfo->Name[InstanceKeyInfo->NameLength/sizeof(WCHAR)] = 0;

                //
                // Go ahead and bump the used-buffer length by sizeof(WCHAR), to
                // accomodate the potential growth caused by adding a terminating NULL.
                //
                ResultLength += sizeof(WCHAR);

                //
                // Now, open up the instance key.
                //
                INIT_OBJA(&Obja, &UnicodeString, InstanceKeyInfo->Name);
                Obja.RootDirectory = hDeviceKey;

                Status = ZwOpenKey(&hInstanceKey, KEY_ALL_ACCESS, &Obja);
                if(!NT_SUCCESS(Status)) {
                    //
                    // Skip this key and continue.
                    //
                    InstanceKeyIndex++;
                    continue;
                }

                //
                // Open the instance key in the registry being upgraded.
                //
                hUpgradeInstanceKey = NULL;
                if (hUpgradeDeviceKey) {
                    Obja.RootDirectory = hUpgradeDeviceKey;

                    Status = ZwOpenKey(&hUpgradeInstanceKey, KEY_ALL_ACCESS, &Obja);
                    if(!NT_SUCCESS(Status)) {
                        //
                        // Again, this is odd, but not fatal.
                        //
                        hUpgradeInstanceKey = NULL;
                    }
                }

                //
                // Call the specified callback routine for this device instance key.
                //
                InstanceKeyCallbackRoutine(hInstanceKey,
                                           hUpgradeInstanceKey,
                                           RootEnumerated,
                                           Context);

                InstanceKeyIndex++;
                ZwClose(hInstanceKey);
                if (hUpgradeInstanceKey) {
                    ZwClose(hUpgradeInstanceKey);
                }
            }
            DeviceKeyIndex++;
            ZwClose(hDeviceKey);
            if (hUpgradeDeviceKey) {
                ZwClose(hUpgradeDeviceKey);
            }
        }
        EnumeratorKeyIndex++;
        ZwClose(hEnumeratorKey);
        if (hUpgradeEnumeratorKey) {
            ZwClose(hUpgradeEnumeratorKey);
        }
    }

    ZwClose(hEnumKey);
    if (hUpgradeEnumKey) {
        ZwClose(hUpgradeEnumKey);
    }
    SpMemFree(MyScratchBuffer);

    return;
}


BOOLEAN
SppEnsureHardwareProfileIsPresent(
    IN HANDLE   hKeyCCSet
    )

/*++

Routine Description:

    This routine checks for the presence of the presence of the following keys:

    HKLM\System\CurrentControlSet\Control\IDConfigDB\Hardware Profiles
    HKLM\System\CurrentControlSet\Hardware Profiles

    If these keys exist, it checks the profile information subkeys under
    IDConfigDB for a "Pristine Profile".

    If the Pristine Profile is not in the proper NT5 format, that is
    under the \0000 subkey, with a PreferenceOrder == -1 and Pristine == 1,
    then it is deleted, and we rely on a valid pristine profile with
    these settings to be migrated from the SETUPREG.HIV.  We then re-order
    the PreferenceOrder values for the remaining hardware profiles, and
    make sure sure each has a HwProfileGuid.

    If a valid Pristine profile is found, it is not removed, and will
    not be replaced during migration.

    If one of either the CCS\Control\IDConfigDB\Hardware Profiles key, or
    the CCS\Hardware Profiles keys is missing, then the set of hardware
    profiles is invalid, and both keys will be removed and migrated from
    the SETUPREG.HIV.


Arguments:

    hKeyCCSet - Handle to the root of the control set in the system
        being upgraded.

Return Value:

    If successful, the return value is TRUE, otherwise it is FALSE.

--*/
{
    OBJECT_ATTRIBUTES ObjaID, ObjaHw;
    UNICODE_STRING UnicodeString, TempString, UnicodeValueName;
    UNICODE_STRING UnicodeKeyName, GuidString, UnicodeLabel;
    NTSTATUS Status;
    HANDLE IDConfigProfiles=NULL, IDConfigEntry=NULL;
    HANDLE HwProfiles=NULL, HwProfileEntry=NULL;
    ULONG profileNumber;
    ULONG len;
    PWSTR  SubkeyName;
    ULONG  ValueBufferSize;
    BOOLEAN b = TRUE;
    BOOLEAN ReOrder = FALSE, bKeyNameIs0000 = FALSE;
    ULONG   pristinePreferenceOrder, preferenceOrder;
    ULONG   enumIndex, resultLength;
    ULONG   nameIndex, dockState;
    UUID    uuid;
    PKEY_BASIC_INFORMATION pKeyInfo;
    PKEY_VALUE_FULL_INFORMATION pValueInfo;


    //
    // Initialize Object Attributes for Hardware profile specific keys
    //
    INIT_OBJA(&ObjaID, &UnicodeString, L"Control\\IDConfigDB\\Hardware Profiles");
    ObjaID.RootDirectory = hKeyCCSet;

    INIT_OBJA(&ObjaHw, &TempString, L"Hardware Profiles");
    ObjaHw.RootDirectory = hKeyCCSet;

    //
    // Attempt to open "CCS\Control\IDConfigDB\Hardware Profiles"
    // and "CCS\Hardware Profiles" keys.
    // If either key is missing, this is an inconsistent state;
    // make sure neither key is present and rely on the migration of these
    // keys from SETUPREG.HIV to provide the basic state (pristine only).
    //
    if ((ZwOpenKey(&IDConfigProfiles,
                   KEY_READ | KEY_WRITE,
                   &ObjaID) != STATUS_SUCCESS) ||
        (ZwOpenKey(&HwProfiles,
                   KEY_READ | KEY_WRITE,
                   &ObjaHw) != STATUS_SUCCESS)) {

        SppDeleteKeyRecursive(hKeyCCSet, UnicodeString.Buffer, TRUE);
        SppDeleteKeyRecursive(hKeyCCSet, TempString.Buffer, TRUE);

        goto Clean;
    }

    //
    // Look for the pristine profile.
    //
    enumIndex = 0;
    while(TRUE) {

        //
        //Enumerate through each Profile Key
        //
        Status = ZwEnumerateKey(IDConfigProfiles,
                                enumIndex,
                                KeyBasicInformation,
                                TemporaryBuffer,
                                sizeof(TemporaryBuffer),
                                &resultLength);

        if(!NT_SUCCESS(Status)) {
            //
            // couldn't enumerate subkeys
            //
            if(Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            }
            else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ** Unable to enumerate existing Hardware Profiles (%lx)\n", Status));
                b = FALSE;
            }
            break;
        }

        //
        // Zero-terminate the subkey name just in case.
        //
        pKeyInfo = (PKEY_BASIC_INFORMATION)TemporaryBuffer;
        pKeyInfo->Name[pKeyInfo->NameLength/sizeof(WCHAR)] = UNICODE_NULL;
        SubkeyName = SpDupStringW(pKeyInfo->Name);
        RtlInitUnicodeString(&UnicodeKeyName, SubkeyName);

        //
        // See if this Profile is occupying the space the Pristine Profile should
        // occupy.  We'll check to see if it is really the Pristine Profile later.
        //
        Status = RtlUnicodeStringToInteger( &UnicodeKeyName, 10, &profileNumber );
        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not get integer profile number for key %ws (%lx)\n",
                     UnicodeKeyName.Buffer,Status));
            bKeyNameIs0000 = FALSE;
        } else {
            bKeyNameIs0000 = (profileNumber==0);
        }

        //
        // Open the subkey
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Checking Profile Key %ws (%lx)\n",UnicodeKeyName.Buffer,Status));
        InitializeObjectAttributes (&ObjaID,
                                    &UnicodeKeyName,
                                    OBJ_CASE_INSENSITIVE,
                                    IDConfigProfiles,
                                    NULL);
        Status = ZwOpenKey(&IDConfigEntry,
                           KEY_ALL_ACCESS,
                           &ObjaID);
        if (!NT_SUCCESS(Status)) {
            //
            // Couldn't open this particular profile key, just log
            // it and check the others, shouldn't stop Setup here.
            //
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ** Unable to open enumerated Hardware Profile key %ws (%lx)\n",
                     UnicodeKeyName.Buffer, Status));
            SpMemFree(SubkeyName);
            enumIndex++;
            continue;
        }

        //
        // Look for the Pristine Entry
        //
        RtlInitUnicodeString(&UnicodeValueName, L"Pristine");
        Status = ZwQueryValueKey(IDConfigEntry,
                                 &UnicodeValueName,
                                 KeyValueFullInformation,
                                 TemporaryBuffer,
                                 sizeof(TemporaryBuffer),
                                 &resultLength);
        pValueInfo = (PKEY_VALUE_FULL_INFORMATION)TemporaryBuffer;

        if (NT_SUCCESS(Status) && (pValueInfo->Type == REG_DWORD) &&
            (* (PULONG) ((PUCHAR)pValueInfo + pValueInfo->DataOffset))) {
            //
            // Found the Pristine Entry, now find its PreferenceOrder
            //
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Found what appears to be a Pristine profile (%lx)\n",Status));
            RtlInitUnicodeString(&UnicodeValueName, REGSTR_VAL_PREFERENCEORDER);
            Status = ZwQueryValueKey(IDConfigEntry,
                                     &UnicodeValueName,
                                     KeyValueFullInformation,
                                     TemporaryBuffer,
                                     sizeof(TemporaryBuffer),
                                     &resultLength);

            if(NT_SUCCESS(Status) && (pValueInfo->Type == REG_DWORD)) {
                //
                // Found the PreferenceOrder of the Pristine;
                // save it so we can fill in the gap left after we delete it.
                //
                pristinePreferenceOrder = (* (PULONG) ((PUCHAR)pValueInfo + pValueInfo->DataOffset));

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: PreferenceOrder of this Pristine ==  %u\n",
                         pristinePreferenceOrder));

                //
                // At most one Pristine Profile should ever be found and reordered,
                // or else the reordering of profiles will not work properly.
                //
                ASSERT(!ReOrder);

                if (bKeyNameIs0000 && (pristinePreferenceOrder == -1)) {
                    //
                    // This is a valid 0000 Pristine Profile Key, don't touch it.
                    //
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Key %ws is a valid pristine profile\n",
                             UnicodeKeyName.Buffer));
                    enumIndex++;
                } else {
                    //
                    // This is an old-style Pristine Profile, delete it and the corresponding
                    // key under "CCS\Hardware Profiles", and rely on the Pristine Profile
                    // keys migrated from setupreg.hiv (as specified in txtsetup.sif)
                    //
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Key %ws is an invalid pristine profile, deleteing this key.\n",
                             UnicodeKeyName.Buffer));
                    ReOrder = TRUE;
                    ZwDeleteKey(IDConfigEntry);
                    SppDeleteKeyRecursive(HwProfiles,
                                          UnicodeKeyName.Buffer,
                                          TRUE);
                }

            } else {
                //
                // An invalid Pristine config has no PreferenceOrder,
                // Just delete it, and nobody should miss it.
                //
                ZwDeleteKey(IDConfigEntry);
                SppDeleteKeyRecursive(HwProfiles,
                                      UnicodeKeyName.Buffer,
                                      TRUE);
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Invalid PreferenceOrder value for key %ws, deleting this key. (%lx)\n",
                         UnicodeKeyName.Buffer,Status));
            }

        } else {
            //
            // Not a Pristine Profile
            //

            if (bKeyNameIs0000) {
                //
                // We need to wipe out any non-Pristine Profiles currently occupying key \0000
                // to make room for the new Pristine Profile that we'll migrate over later.
                // (sorry, but nobody has any business being here in the first place.)
                //
                ZwDeleteKey(IDConfigEntry);
                SppDeleteKeyRecursive(HwProfiles,
                                      UnicodeKeyName.Buffer,
                                      TRUE);
            } else {

                //
                // Check that it has a PreferenceOrder
                //
                RtlInitUnicodeString(&UnicodeValueName, REGSTR_VAL_PREFERENCEORDER);
                Status = ZwQueryValueKey(IDConfigEntry,
                                         &UnicodeValueName,
                                         KeyValueFullInformation,
                                         TemporaryBuffer,
                                         sizeof(TemporaryBuffer),
                                         &resultLength);

                if(!NT_SUCCESS(Status) || (pValueInfo->Type != REG_DWORD)) {
                    //
                    // Invalid or missing PreferenceOrder for this profile;
                    // Since this profile was most likely inaccessible anyways,
                    // just delete it and the corresponding entry under CCS\\Hardware Profiles.
                    //
                    ZwDeleteKey(IDConfigEntry);
                    SppDeleteKeyRecursive(HwProfiles,
                                          UnicodeKeyName.Buffer,
                                          TRUE);
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Invalid PreferenceOrder value for key %ws, deleting this key. (%lx)\n",
                             UnicodeKeyName.Buffer,Status));
                }  else {

                    //
                    // Make sure all profiles have a HwProfileGuid value.
                    //
                    RtlInitUnicodeString(&UnicodeValueName, L"HwProfileGuid");
                    Status = ZwQueryValueKey(IDConfigEntry,
                                             &UnicodeValueName,
                                             KeyValueFullInformation,
                                             TemporaryBuffer,
                                             sizeof(TemporaryBuffer),
                                             &resultLength);
                    pValueInfo = (PKEY_VALUE_FULL_INFORMATION)TemporaryBuffer;

                    if (!NT_SUCCESS(Status) || (pValueInfo->Type != REG_SZ)) {
                        //
                        // Profile doesn't have a HwProfileGuid; make one up.
                        //
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Missing or invalid HwProfileGuid for Profile %ws, creating one (%lx)\n",
                                 UnicodeKeyName.Buffer, Status));
                        Status = ExUuidCreate(&uuid);
                        if (NT_SUCCESS(Status)) {
                            Status = RtlStringFromGUID(&uuid, &GuidString);
                            ASSERT(NT_SUCCESS(Status));
                            if (NT_SUCCESS(Status)) {
                                Status = ZwSetValueKey(IDConfigEntry,
                                                       &UnicodeValueName,
                                                       0,
                                                       REG_SZ,
                                                       GuidString.Buffer,
                                                       GuidString.Length + sizeof(UNICODE_NULL));
                                RtlFreeUnicodeString(&GuidString);
                                if(!NT_SUCCESS(Status)) {
                                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ** Unable to set HwProfileGuid value for key %ws, Status = (%lx)\n",
                                             UnicodeKeyName.Buffer,Status));
                                }
                            } else {
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ** Unable to create string from GUID (Status = %lx)\n",
                                         Status));
                            }
                        } else {
                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ** Could not create a GUID for this profile (Status = %lx)\n",
                                     Status));
                        }
                    }

                    //
                    // only raise enumIndex when we don't delete a key.
                    //
                    enumIndex++;
                }
            }
        }
        SpMemFree(SubkeyName);
        ZwClose(IDConfigEntry);
        IDConfigEntry = NULL;
    }

    //
    // If we don't need to reorder any PreferenceOrder values, we're done.
    //
    if (!ReOrder) {
        goto Clean;
    }


    //
    // ReOrder PreferenceOrder values after deleting one
    // to make up for the gap.
    //

    enumIndex = 0;
    while(TRUE) {

        //
        //Enumerate through each Profile Key again
        //
        Status = ZwEnumerateKey(IDConfigProfiles,
                                enumIndex,
                                KeyBasicInformation,
                                TemporaryBuffer,
                                sizeof(TemporaryBuffer),
                                &resultLength);
        if(!NT_SUCCESS(Status)) {
            if(Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            }
            else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ** Unable to reorder remaining Hardware Profiles (%lx)\n", Status));
                b = FALSE;
            }
            break;
        }

        //
        // Zero-terminate the subkey name just in case.
        //
        pKeyInfo = (PKEY_BASIC_INFORMATION)TemporaryBuffer;
        pKeyInfo->Name[pKeyInfo->NameLength/sizeof(WCHAR)] = UNICODE_NULL;
        SubkeyName = SpDupStringW(pKeyInfo->Name);
        RtlInitUnicodeString(&UnicodeKeyName, SubkeyName);

        InitializeObjectAttributes (&ObjaID,
                                    &UnicodeKeyName,
                                    OBJ_CASE_INSENSITIVE,
                                    IDConfigProfiles,
                                    NULL);
        Status = ZwOpenKey (&IDConfigEntry,
                            KEY_ALL_ACCESS,
                            &ObjaID);
        if (!NT_SUCCESS(Status)) {
            //
            // Couldn't open this particular profile key, just log
            // it and check the others, shouldn't stop Setup here.
            //
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ** Unable to open enumerated Hardware Profile key %ws (%lx)\n",
                     UnicodeKeyName.Buffer, Status));
            SpMemFree(SubkeyName);
            enumIndex++;
            continue;
        }

        pValueInfo = (PKEY_VALUE_FULL_INFORMATION)(TemporaryBuffer + (sizeof(TemporaryBuffer) / sizeof(WCHAR) / 2));
        ValueBufferSize = sizeof(TemporaryBuffer) / 2;

        //
        // Get the PreferenceOrder for this profile
        //
        RtlInitUnicodeString(&UnicodeValueName, REGSTR_VAL_PREFERENCEORDER);
        Status = ZwQueryValueKey(IDConfigEntry,
                                 &UnicodeValueName,
                                 KeyValueFullInformation,
                                 pValueInfo,
                                 ValueBufferSize,
                                 &len);

        if(NT_SUCCESS(Status) && (pValueInfo->Type == REG_DWORD)) {
            //
            // Got the Preference Order
            //
            ASSERT((* (PULONG) ((PUCHAR)pValueInfo + pValueInfo->DataOffset)) != pristinePreferenceOrder);
            if (((* (PULONG) ((PUCHAR)pValueInfo + pValueInfo->DataOffset))  > pristinePreferenceOrder) &&
                ((* (PULONG) ((PUCHAR)pValueInfo + pValueInfo->DataOffset)) != -1)) {
                //
                // Re-order PreferenceOrders for profiles other than a valid pristine,
                // beyond deleted pristine up one.
                //
                preferenceOrder = (* (PULONG) ((PUCHAR)pValueInfo + pValueInfo->DataOffset)) - 1;
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: ReOrdering Profile %ws to PreferenceOrder %u\n",
                         UnicodeKeyName.Buffer,preferenceOrder));
                Status = ZwSetValueKey(IDConfigEntry,
                                       &UnicodeValueName,
                                       0,
                                       REG_DWORD,
                                       &preferenceOrder,
                                       sizeof(preferenceOrder));
                if(!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to change PreferenceOrder for Profile %ws, Status = (%lx)\n",
                             UnicodeKeyName.Buffer,Status));
                    b = FALSE;
                }
            }
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: *** Couldn't determine PreferenceOrder of profile %ws (%lx)\n",
                     UnicodeKeyName.Buffer,Status));
        }

        enumIndex++;
        SpMemFree(SubkeyName);
        ZwClose(IDConfigEntry);
        IDConfigEntry = NULL;
    }

Clean:

    if (NULL != IDConfigProfiles) {
        ZwClose (IDConfigProfiles);
    }
    if (NULL != IDConfigEntry) {
        ZwClose (IDConfigEntry);
    }
    if (NULL != HwProfiles) {
        ZwClose (HwProfiles);
    }
    if (NULL != HwProfileEntry) {
        ZwClose (HwProfileEntry);
    }
    return b;
}

VOID
SppSetGuimodeUpgradePath(
    IN HANDLE hKeySoftwareHive,
    IN HANDLE hKeyControlSet
    )
{


    PWSTR Default_Path[3] = { L"%SystemRoot%\\system32",
                             L"%SystemRoot%",
                             L"%SystemRoot%\\system32\\WBEM"};
    UNICODE_STRING StringRegPath;
    UNICODE_STRING StringRegOldPath, UnicodeString;
    PKEY_VALUE_PARTIAL_INFORMATION pValueInfo;
    ULONG len;
    PWSTR CurrentPath = NULL;
    PWSTR p,q,final;
    OBJECT_ATTRIBUTES Obja;
    HKEY hKeyEnv;
    DWORD err;
    BOOL Found;
    int i;

    INIT_OBJA( &Obja, &UnicodeString, L"Control\\Session Manager\\Environment" );
    Obja.RootDirectory = hKeyControlSet;

    err = ZwOpenKey( &hKeyEnv, KEY_ALL_ACCESS, &Obja );
    if( NT_SUCCESS( err )){
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP:SppSetGuimodeUpgradePath - Opened the Environment key\n" ));

        RtlInitUnicodeString(&StringRegPath, L"Path");
        err = ZwQueryValueKey(
                  hKeyEnv,
                  &StringRegPath,
                  KeyValuePartialInformation,
                  TemporaryBuffer,
                  sizeof(TemporaryBuffer),
                  &len);

        if( NT_SUCCESS(err)) {
            pValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer;
            if( pValueInfo->Type == REG_EXPAND_SZ || pValueInfo->Type == REG_SZ) {

                CurrentPath = SpDupStringW( (PWSTR)pValueInfo->Data );


                // Now we try to extract from the existing path all elements that are not part of the default
                // path that we maintain during GUI Setup. We then append that to the default path. That way
                // we don't end up duplicating path elements over successive upgrades. We store this in the
                // 'OldPath' value and restore it at the end of GUI mode.
                //

                TemporaryBuffer[0]=L'\0';
                for(i=0; i<ELEMENT_COUNT(Default_Path); i++){
                    wcscat( TemporaryBuffer, Default_Path[i] );
                    wcscat( TemporaryBuffer, L";");
                }
                TemporaryBuffer[wcslen(TemporaryBuffer)-1]=L'\0';

                //Set the default path in the registry

                err = ZwSetValueKey(
                          hKeyEnv,
                          &StringRegPath,
                          0,
                          REG_EXPAND_SZ,
                          TemporaryBuffer,
                          ((wcslen(TemporaryBuffer)+1)*sizeof(WCHAR)));


                if( !NT_SUCCESS( err ) )
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "\nSETUP: Error %x in saving path. Ignoring and not resetting PATH for GUI Setup\n", err));


                for( p=q=CurrentPath; p && *p; ){

                    //Jump to the ';' delimiter

                    if( q = wcsstr(p, L";") )
                        *q=0;


                    //  Compare with elements of our default path

                    Found=FALSE;
                    for(i=0; i<ELEMENT_COUNT(Default_Path); i++){
                        if (!_wcsicmp(p,Default_Path[i])) {
                            Found=TRUE;
                            break;

                        }
                    }
                    if(!Found){
                        wcscat( TemporaryBuffer, L";");
                        wcscat( TemporaryBuffer, p);
                    }

                    if(q)
                        p=q+1;
                    else
                        break;
                }


                RtlInitUnicodeString(&StringRegOldPath, L"OldPath");


                //
                // Set the Oldpath always, if it exists or not
                //
                err = ZwSetValueKey(
                          hKeyEnv,
                          &StringRegOldPath,
                          0,
                          REG_EXPAND_SZ,
                          TemporaryBuffer,
                          ((wcslen(TemporaryBuffer)+1)*sizeof(WCHAR)));

                if( !NT_SUCCESS( err ) )
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "\nSETUP: Error %x in saving old PATH. \n", err));


            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "\nSETUP:PATH type in registry not REG_EXPAND_SZ nor REG_SZ. Resetting PATH to default\n"));

                TemporaryBuffer[0]=L'\0';
                for(i=0; i<ELEMENT_COUNT(Default_Path); i++){
                    wcscat( TemporaryBuffer, Default_Path[i] );
                    wcscat( TemporaryBuffer, L";");
                }
                TemporaryBuffer[wcslen(TemporaryBuffer)-1]=L'\0';

                //Set the default path in the registry

                err = ZwSetValueKey(
                          hKeyEnv,
                          &StringRegPath,
                          0,
                          REG_EXPAND_SZ,
                          TemporaryBuffer,
                          ((wcslen(TemporaryBuffer)+1)*sizeof(WCHAR)));

                if( !NT_SUCCESS( err ) )
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "\nSETUP: Error %x in saving path. Ignoring and not resetting PATH for GUI Setup\n", err));
            }

        }else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "\nSETUP:Query for PATH value failed with error %x. Ignoring and not resetting PATH for GUI Setup\n",err));
        }
        ZwClose( hKeyEnv );

    }else
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "\nSETUP:Error %x while opening Environment key. Ignoring and not resetting PATH for GUI Setup\n",err));

    if( CurrentPath )
        SpMemFree( CurrentPath );

    return;
}


NTSTATUS
SppMigratePrinterKeys(
    IN HANDLE hControlSet,
    IN HANDLE hDestSoftwareHive
    )

/*++

Routine Description:

    This routine migrates HKLM\SYSTEM\CurrentControlSet\Control\Print\Printers to
    HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers.

Arguments:

    hControlSet - Handle to CurrentControlSet key in the system hive of the system being upgraded

    hDestSoftwareHive - Handle to the root of the software hive on the system
                        being upgraded.


Return Value:

    Status value indicating outcome of operation.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;


    PWSTR   SrcPrinterKeyPath = L"Control\\Print\\Printers";
    PWSTR   DstPrinterKeyName = L"Printers";
    PWSTR   DstPrinterKeyPath = SpDupStringW(L"Microsoft\\Windows NT\\CurrentVersion\\Print\\Printers");
    HANDLE  SrcKey;
    HANDLE  DstKey;

    //
    //  Find out if the destination key exists
    //
    INIT_OBJA(&Obja,&UnicodeString,DstPrinterKeyPath);
    Obja.RootDirectory = hDestSoftwareHive;
    Status = ZwOpenKey(&DstKey,KEY_ALL_ACCESS,&Obja);
    if( NT_SUCCESS( Status ) ) {
        //
        //  If the key exists, then there is no need to do any migration.
        //  The migration has occurred on previous upgrades.
        //
        ZwClose( DstKey );
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: HKLM\\SYSTEM\\CurrentControlSet\\%ls doesn't need to be migrated. \n", DstPrinterKeyPath));
        SpMemFree( DstPrinterKeyPath );
        return( Status );
    } else if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
        //
        //  The key doesn't exist, so we need to do migration.
        //  First create the parent key.
        //

        PWSTR   p;

        p = wcsrchr ( DstPrinterKeyPath, L'\\' );

        if (p) {
            *p = L'\0';
        }

        INIT_OBJA(&Obja,&UnicodeString,DstPrinterKeyPath);
        Obja.RootDirectory = hDestSoftwareHive;
        Status = ZwCreateKey(&DstKey,
                             KEY_ALL_ACCESS,
                             &Obja,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             NULL );

        if( !NT_SUCCESS( Status ) ) {
            //
            //  If unable to create the parent key, then don't do migration
            //
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to create HKLM\\SOFTWARE\\%ls. Status =  %lx \n", DstPrinterKeyPath, Status));
            SpMemFree( DstPrinterKeyPath );
            return( Status );
        }
    } else {
        //
        //  We can't really determine whether or not the migration has occurred in the past, because the key is
        //  unaccessible. So son't attempt to do migration.
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open HKLM\\SOFTWARE\\%ls. Status = %lx \n", DstPrinterKeyPath, Status));
        SpMemFree( DstPrinterKeyPath );
        return( Status );
    }

    //
    //  At this point we now that the migration needs to be done.
    //  First, open the source key. Note that DstPrinterKeyPath is no longer needed.
    //
    SpMemFree( DstPrinterKeyPath );
    INIT_OBJA(&Obja,&UnicodeString,SrcPrinterKeyPath);
    Obja.RootDirectory = hControlSet;

    Status = ZwOpenKey(&SrcKey,KEY_ALL_ACCESS,&Obja);
    if( !NT_SUCCESS( Status ) ) {
        //
        //  If unable to open the source key, then fail.
        //
        ZwClose( DstKey );
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open HKLM\\SYSTEM\\CurrentControlSet\\%ls. Status = %lx \n", SrcPrinterKeyPath, Status));
        return( Status );
    }
    Status = SppCopyKeyRecursive( SrcKey,
                                  DstKey,
                                  NULL,
                                  DstPrinterKeyName,
                                  FALSE,
                                  TRUE
                                );

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to migrate %ls. Status = %lx\n", SrcPrinterKeyPath, Status));
    }
    ZwClose( SrcKey );
    ZwClose( DstKey );
    //
    //  If the key was migrated successfully, then attempt to delete the source key.
    //  if we are unable to delete the key, then silently fail.
    //
    if( NT_SUCCESS( Status ) ) {
        NTSTATUS    Status1;
        PWSTR       q, r;

        //
        //  q will point to "Control\Print"
        //  r will point to "Printers"
        //
        q = SpDupStringW( SrcPrinterKeyPath );
        r = wcsrchr ( q, L'\\' );
        *r = L'\0';
        r++;

        INIT_OBJA(&Obja,&UnicodeString,q);
        Obja.RootDirectory = hControlSet;

        Status1 = ZwOpenKey(&SrcKey,KEY_ALL_ACCESS,&Obja);
        if( NT_SUCCESS( Status1 ) ) {
            Status1 = SppDeleteKeyRecursive(SrcKey,
                                            r,
                                            TRUE);

            if( !NT_SUCCESS( Status1 ) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to delete %ls\\%ls. Status = %lx\n", q, r, Status1));
            }
            ZwClose( SrcKey );
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to delete %ls. ZwOpenKey() failed. Status = %lx\n", SrcPrinterKeyPath, Status1));
        }
        SpMemFree(q);
    }
    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\sptxtfil.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    sptxtfil.h

Abstract:

    Public header file for text file functions in text setup.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:

--*/


#ifndef _SPTXTFIL_DEFN_
#define _SPTXTFIL_DEFN_

#define DBLSPACE_SECTION    L"DBLSPACE_SECTION"


NTSTATUS
SpLoadSetupTextFile(
    IN  PWCHAR  Filename,
    IN  PVOID   Image,      OPTIONAL
    IN  ULONG   ImageSize,  OPTIONAL
    OUT PVOID  *Handle,
    OUT PULONG  ErrorLine,
    IN  BOOLEAN ClearScreen,
    IN  BOOLEAN ScreenNotReady
    );

BOOLEAN
SpFreeTextFile(
    IN PVOID Handle
    );

BOOLEAN
SpSearchTextFileSection(        // searches for the existance of a section
    IN PVOID  Handle,
    IN PWCHAR SectionName
    );

ULONG
SpCountLinesInSection(      // count # lines in section; 0 if no such section
    IN PVOID  Handle,
    IN PWCHAR SectionName
    );

ULONG
SpGetKeyIndex(
  IN PVOID Handle,
  IN PWCHAR SectionName,
  IN PWCHAR KeyName
  );

PWCHAR
SpGetSectionLineIndex(     // given section name, line number and index return the value.
    IN PVOID   Handle,
    IN LPCWSTR SectionName,
    IN ULONG   LineIndex,
    IN ULONG   ValueIndex
    );

BOOLEAN
SpGetSectionKeyExists(     // given section name, key searches existance
    IN PVOID  Handle,
    IN PWCHAR SectionName,
    IN PWCHAR Key
    );

PWCHAR
SpGetSectionKeyIndex(      // given section name, key and index return the value
    IN PVOID  Handle,
    IN PWCHAR Section,
    IN PWCHAR Key,
    IN ULONG  ValueIndex
    );

PWCHAR
SpGetKeyName(               // given section name and line index, return key
    IN PVOID   Handle,
    IN LPCWSTR SectionName,
    IN ULONG   LineIndex
    );

PWSTR
SpGetKeyNameByValue(        // given section name and value, return key
    IN PVOID Inf,
    IN PWSTR SectionName,
    IN PWSTR Value
    );

ULONG
SpCountSectionsInFile(      // count # sections in file;
    IN PVOID Handle
    );

PWSTR
SpGetSectionName(           // given section index, return section name
    IN PVOID Handle,
    IN ULONG Index
    );

VOID
SpProcessForStringSubs(
    IN  PVOID   SifHandle,
    IN  LPCWSTR StringIn,
    OUT LPWSTR  StringOut,
    IN  ULONG   BufferSizeChars
    );

PVOID
SpNewSetupTextFile(
    VOID
    );

VOID
SpAddLineToSection(
    IN PVOID Handle,
    IN PWSTR SectionName,
    IN PWSTR KeyName,       OPTIONAL
    IN PWSTR Values[],
    IN ULONG ValueCount
    );

NTSTATUS
SpWriteSetupTextFile(
    IN PVOID Handle,
    IN PWSTR FilenamePart1,
    IN PWSTR FilenamePart2, OPTIONAL
    IN PWSTR FilenamePart3  OPTIONAL
    );

NTSTATUS
SpProcessAddRegSection(
    IN PVOID   SifHandle,
    IN LPCWSTR SectionName,
    IN HANDLE  HKLM_SYSTEM,
    IN HANDLE  HKLM_SOFTWARE,
    IN HANDLE  HKCU,
    IN HANDLE  HKR
    );

NTSTATUS
SpProcessDelRegSection(
    IN PVOID   SifHandle,
    IN LPCWSTR SectionName,
    IN HANDLE  HKLM_SYSTEM,
    IN HANDLE  HKLM_SOFTWARE,
    IN HANDLE  HKCU,
    IN HANDLE  HKR
    );

BOOLEAN
pSpIsFileInPrivateInf(    
    IN PCWSTR FileName
    );

BOOLEAN
SpNonZeroValuesInSection(
    PVOID Handle,
    PCWSTR SectionName,
    ULONG ValueIndex
    );


#endif // ndef _SPTXTFIL_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spudp.c ===
/*++

Copyright (c) 1998  Micros  oft Corporation

Module Name:

    spudp.c

Abstract:

    Routines for handling sending and receiving datagram packets to a BINL server.

Author:

    Sean Selitrennikoff (v-seasel) 22-Jun-1998

Revision History:

Notes:

--*/

#include "spprecmp.h"
#pragma hdrstop
#include "spcmdcon.h"
#include <tdi.h>
#include <tdikrnl.h>
#include <remboot.h>
#include <oscpkt.h>

//
// Useful definitions
//
#define NULL_IP_ADDR    0
#define htons( a ) ((((a) & 0xFF00) >> 8) |\
                    (((a) & 0x00FF) << 8))

//
// Type definitions
//
typedef struct _SPUDP_FSCONTEXT {
        LIST_ENTRY     Linkage;
        PFILE_OBJECT   FileObject;
        LONG           ReferenceCount;
        UCHAR          CancelIrps;
        UCHAR          Pad[3];
} SPUDP_FSCONTEXT, *PSPUDP_FSCONTEXT;

typedef enum {
    SpUdpNetworkDisconnected,
    SpUdpNetworkDisconnecting,
    SpUdpNetworkConnecting,
    SpUdpNetworkConnected
} SPUDP_NETWORK_STATE;

typedef struct _SPUDP_RECEIVE_ENTRY {
    LIST_ENTRY ListEntry;
    ULONG DataBufferLength;
    PVOID DataBuffer;
} SPUDP_RECEIVE_ENTRY, *PSPUDP_RECEIVE_ENTRY;


//
// Globals
//
SPUDP_NETWORK_STATE SpUdpNetworkState = SpUdpNetworkDisconnected;
ULONG SpUdpActiveRefCount = 0;
HANDLE SpUdpDatagramHandle;
PFILE_OBJECT SpUdpDatagramFileObject;
PDEVICE_OBJECT SpUdpDatagramDeviceObject;
KSPIN_LOCK SpUdpLock;
KIRQL SpUdpOldIrql;
LIST_ENTRY SpUdpReceiveList;
ULONG SpUdpNumReceivePackets = 0;
ULONG SpUdpSendSequenceNumber = 1;

//
// Function definitions
//
NTSTATUS
SpUdpRestartDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

NTSTATUS
SpUdpTdiErrorHandler(
    IN PVOID     TdiEventContext,
    IN NTSTATUS  Status
    );

NTSTATUS
SpUdpTdiSetEventHandler(
    IN PFILE_OBJECT    FileObject,
    IN PDEVICE_OBJECT  DeviceObject,
    IN ULONG           EventType,
    IN PVOID           EventHandler,
    IN PVOID           EventContext
    );

NTSTATUS
SpUdpIssueDeviceControl (
    IN PFILE_OBJECT     FileObject,
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            IrpParameters,
    IN ULONG            IrpParametersLength,
    IN PVOID            MdlBuffer,
    IN ULONG            MdlBufferLength,
    IN UCHAR            MinorFunction
    );

NTSTATUS
SpUdpTdiReceiveDatagramHandler(
    IN  PVOID    TdiEventContext,
    IN  LONG     SourceAddressLength,
    IN  PVOID    SourceAddress,
    IN  LONG     OptionsLength,
    IN  PVOID    Options,
    IN  ULONG    ReceiveDatagramFlags,
    IN  ULONG    BytesIndicated,
    IN  ULONG    BytesAvailable,
    OUT PULONG   BytesTaken,
    IN  PVOID    Tsdu,
    OUT PIRP *   Irp
    );

NTSTATUS
SpUdpReceivePacketHandler(
    IN  ULONG          TdiReceiveDatagramFlags,
    IN  ULONG          BytesIndicated,
    IN  ULONG          BytesAvailable,
    OUT PULONG         BytesTaken,
    IN  PVOID          Tsdu,
    OUT PIRP *         Irp
    );

NTSTATUS
SpUdpCompleteReceivePacket(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    );

VOID
SpUdpProcessReceivePacket(
    IN  ULONG          TsduSize,
    IN  PVOID          Tsdu
    );

NTSTATUS
SpUdpSendDatagram(
    IN PVOID                 SendBuffer,
    IN ULONG                 SendBufferLength,
    IN ULONG                 RemoteHostAddress,
    IN USHORT                RemoteHostPort
    );

NTSTATUS
SpUdpCompleteSendDatagram(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );





VOID
SpUdpDereferenceFsContext(
    PSPUDP_FSCONTEXT   FsContext
    )
{
    LONG  newValue = InterlockedDecrement(&(FsContext->ReferenceCount));


    ASSERT(newValue >= 0);

    if (newValue != 0) {
        return;
    }

    return;
}  // SpUdpDereferenceFsContext


NTSTATUS
SpUdpMarkRequestPending(
    PIRP                Irp,
    PIO_STACK_LOCATION  IrpSp,
    PDRIVER_CANCEL      CancelRoutine
    )
/*++

Notes:

    Called with IoCancelSpinLock held.

--*/
{
    PSPUDP_FSCONTEXT   fsContext = (PSPUDP_FSCONTEXT) IrpSp->FileObject->FsContext;
    KIRQL              oldIrql;

    //
    // Set up for cancellation
    //
    ASSERT(Irp->CancelRoutine == NULL);

    if (!Irp->Cancel) {

        IoMarkIrpPending(Irp);
        IoSetCancelRoutine(Irp, CancelRoutine);

        InterlockedIncrement(&(fsContext->ReferenceCount));

        return(STATUS_SUCCESS);
    }

    //
    // The IRP has already been cancelled.
    //
    return(STATUS_CANCELLED);

}  // SpUdpMarkRequestPending



VOID
SpUdpCompletePendingRequest(
    IN PIRP      Irp,
    IN NTSTATUS  Status,
    IN ULONG     BytesReturned
    )
/*++

Routine Description:

    Completes a pending request.

Arguments:

    Irp           - A pointer to the IRP for this request.
    Status        - The final status of the request.
    BytesReturned - Bytes sent/received information.

Return Value:

    None.

Notes:

    Called with IoCancelSpinLock held. Lock Irql is stored in Irp->CancelIrql.
    Releases IoCancelSpinLock before returning.

--*/

{
    PIO_STACK_LOCATION  irpSp;
    PSPUDP_FSCONTEXT       fsContext;


    irpSp = IoGetCurrentIrpStackLocation(Irp);
    fsContext = (PSPUDP_FSCONTEXT) irpSp->FileObject->FsContext;

    IoSetCancelRoutine(Irp, NULL);

    SpUdpDereferenceFsContext(fsContext);

    if (Irp->Cancel || fsContext->CancelIrps) {
        Status = (unsigned int) STATUS_CANCELLED;
        BytesReturned = 0;
    }

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    Irp->IoStatus.Status = (NTSTATUS) Status;
    Irp->IoStatus.Information = BytesReturned;

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    return;

}  // SpUdpCompletePendingRequest



PFILE_OBJECT
SpUdpBeginCancelRoutine(
    IN  PIRP     Irp
    )

/*++

Routine Description:

    Performs common bookkeeping for irp cancellation.

Arguments:

    Irp          - Pointer to I/O request packet

Return Value:

    A pointer to the file object on which the irp was submitted.
    This value must be passed to SpUdpEndCancelRequest().

Notes:

    Called with cancel spinlock held.

--*/

{
    PIO_STACK_LOCATION  irpSp;
    PSPUDP_FSCONTEXT    fsContext;
    NTSTATUS            status = STATUS_SUCCESS;
    PFILE_OBJECT        fileObject;


    ASSERT(Irp->Cancel);

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    fileObject = irpSp->FileObject;
    fsContext = (PSPUDP_FSCONTEXT) fileObject->FsContext;

    IoSetCancelRoutine(Irp, NULL);

    //
    // Add a reference so the object can't be closed while the cancel routine
    // is executing.
    //
    InterlockedIncrement(&(fsContext->ReferenceCount));

    return(fileObject);

}  // SpUdpBeginCancelRoutine



VOID
SpUdpEndCancelRoutine(
    PFILE_OBJECT    FileObject
    )
/*++

Routine Description:

    Performs common bookkeeping for irp cancellation.

Arguments:


Return Value:


Notes:

    Called with cancel spinlock held.

--*/
{

    PSPUDP_FSCONTEXT   fsContext = (PSPUDP_FSCONTEXT) FileObject->FsContext;

    //
    // Remove the reference placed on the endpoint by the cancel routine.
    //
    SpUdpDereferenceFsContext(fsContext);
    return;

} // SpUdpEndCancelRoutine





NTSTATUS
SpUdpConnect(
    VOID
)
{

    NTSTATUS                               status;
    OBJECT_ATTRIBUTES                      objectAttributes;
    IO_STATUS_BLOCK                        iosb;
    PFILE_FULL_EA_INFORMATION              ea = NULL;
    ULONG                                  eaBufferLength;
    HANDLE                                 addressHandle = NULL;
    PFILE_OBJECT                           addressFileObject = NULL;
    PDEVICE_OBJECT                         addressDeviceObject = NULL;
    BOOLEAN                                attached = FALSE;
    UNICODE_STRING                         unicodeString;
    TDI_REQUEST_KERNEL_QUERY_INFORMATION   queryInfo;
    PTDI_ADDRESS_INFO                      addressInfo;
    TDI_PROVIDER_INFO                      providerInfo;
    PWCHAR                                 TdiProviderName;
    ULONG                                  TdiProviderNameLength;
    PTRANSPORT_ADDRESS                     TransportAddress;
    PTDI_ADDRESS_IP                        TdiAddressIp;

    TdiProviderName = L"\\Device\\Udp";
    TdiProviderNameLength = (wcslen(TdiProviderName) + 1) * sizeof(WCHAR);

    InitializeListHead(&SpUdpReceiveList);

    //
    // Allocate memory to hold the EA buffer we'll use to specify the
    // transport address to NtCreateFile.
    //
    eaBufferLength = FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                     TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                     sizeof(TA_IP_ADDRESS);

    ea = SpMemAlloc(eaBufferLength);

    if (ea == NULL) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: memory allocation of %u bytes failed.\n", eaBufferLength));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Initialize the EA using the network's transport information.
    //
    ea->NextEntryOffset = 0;
    ea->Flags = 0;
    ea->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    ea->EaValueLength = (USHORT)sizeof(TA_IP_ADDRESS);

    RtlMoveMemory(
        ea->EaName,
        TdiTransportAddress,
        ea->EaNameLength + 1
        );

    TransportAddress = (PTRANSPORT_ADDRESS)(&(ea->EaName[ea->EaNameLength + 1]));
    TransportAddress->TAAddressCount = 1;
    TransportAddress->Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
    TransportAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
    TdiAddressIp = (PTDI_ADDRESS_IP)(&(TransportAddress->Address[0].Address[0]));
    TdiAddressIp->sin_port= 0; // Means that you want a port assigned
    TdiAddressIp->in_addr= NULL_IP_ADDR;
    RtlZeroMemory(TdiAddressIp->sin_zero, sizeof(TdiAddressIp->sin_zero));

    RtlInitUnicodeString(&unicodeString, TdiProviderName);

    KeAcquireSpinLock(&SpUdpLock, &SpUdpOldIrql);

    if (SpUdpNetworkState != SpUdpNetworkDisconnected) {
        KeReleaseSpinLock(&SpUdpLock, SpUdpOldIrql);
        SpMemFree(ea);
        return((SpUdpNetworkState == SpUdpNetworkConnected) ? STATUS_SUCCESS : STATUS_PENDING);
    }

    ASSERT(SpUdpDatagramHandle == NULL);
    ASSERT(SpUdpDatagramFileObject == NULL);
    ASSERT(SpUdpDatagramDeviceObject == NULL);
    ASSERT(SpUdpActiveRefCount == 0);

    //
    // Set the initial active refcount to 2. One reference will be removed
    // when the network is successfully brought online. The other will be
    // removed when the network is to be taken offline. Also increment the
    // base refcount to account for the active refcount. Change to
    // the online pending state.
    //
    SpUdpActiveRefCount = 2;
    SpUdpNetworkState = SpUdpNetworkConnecting;

    KeReleaseSpinLock(&SpUdpLock, SpUdpOldIrql);

    //
    // Prepare for opening the address object.
    //
    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,         // attributes
        NULL,
        NULL
        );

    //
    // Perform the actual open of the address object.
    //
    status = ZwCreateFile(
                 &addressHandle,
                 GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                 &objectAttributes,
                 &iosb,                          // returned status information.
                 0,                              // block size (unused).
                 0,                              // file attributes.
                 0,                              // not shareable
                 FILE_CREATE,                    // create disposition.
                 0,                              // create options.
                 ea,
                 eaBufferLength
                 );

    SpMemFree(ea);
    ea = NULL;

    if (status != STATUS_SUCCESS) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to open address for UDP, status %lx.\n", status));
        goto error_exit;
    }

    //
    // Get a pointer to the file object of the address.
    //
    status = ObReferenceObjectByHandle(
                 addressHandle,
                 0L,                         // DesiredAccess
                 NULL,
                 KernelMode,
                 &addressFileObject,
                 NULL
                 );

    if (status != STATUS_SUCCESS) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to reference address handle, status %lx.\n", status));
        goto error_exit;
    }

    //
    // Remember the device object to which we need to give requests for
    // this address object.  We can't just use the fileObject->DeviceObject
    // pointer because there may be a device attached to the transport
    // protocol.
    //
    addressDeviceObject = IoGetRelatedDeviceObject(addressFileObject);

    //
    // Get the transport provider info
    //
    queryInfo.QueryType = TDI_QUERY_PROVIDER_INFO;
    queryInfo.RequestConnectionInformation = NULL;

    status = SpUdpIssueDeviceControl(
                 addressFileObject,
                 addressDeviceObject,
                 &queryInfo,
                 sizeof(queryInfo),
                 &providerInfo,
                 sizeof(providerInfo),
                 TDI_QUERY_INFORMATION
                 );

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to get provider info, status %lx\n", status));
        goto error_exit;
    }

    if (!(providerInfo.ServiceFlags & TDI_SERVICE_CONNECTIONLESS_MODE)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Provider doesn't support datagrams!\n"));
        status = STATUS_UNSUCCESSFUL;
        goto error_exit;
    }

    //
    // Set up indication handlers on the address object. We are eligible
    // to receive indications as soon as we do this.
    //
    status = SpUdpTdiSetEventHandler(
                 addressFileObject,
                 addressDeviceObject,
                 TDI_EVENT_ERROR,
                 SpUdpTdiErrorHandler,
                 NULL
                 );

    if ( !NT_SUCCESS(status) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Setting TDI_EVENT_ERROR failed: %lx\n", status));
        goto error_exit;
    }

    status = SpUdpTdiSetEventHandler(
                 addressFileObject,
                 addressDeviceObject,
                 TDI_EVENT_RECEIVE_DATAGRAM,
                 SpUdpTdiReceiveDatagramHandler,
                 NULL
                 );

    if ( !NT_SUCCESS(status) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Setting TDI_EVENT_RECEIVE_DATAGRAM failed: %lx\n", status));
        goto error_exit;
    }

    //
    // Finish transition to online state. Note that an offline request
    // could have been issued in the meantime.
    //
    KeAcquireSpinLock(&SpUdpLock, &SpUdpOldIrql);

    SpUdpDatagramHandle = addressHandle;
    addressHandle = NULL;
    SpUdpDatagramFileObject = addressFileObject;
    addressFileObject = NULL;
    SpUdpDatagramDeviceObject = addressDeviceObject;
    addressDeviceObject = NULL;

    ASSERT(SpUdpActiveRefCount == 2);
    SpUdpActiveRefCount--;
    SpUdpNetworkState = SpUdpNetworkConnected;

    KeReleaseSpinLock(&SpUdpLock, SpUdpOldIrql);

    return(STATUS_SUCCESS);


error_exit:

    if (addressFileObject != NULL) {
        ObDereferenceObject(addressFileObject);
    }

    if (addressHandle != NULL) {
        ZwClose(addressHandle);
    }

    SpUdpDisconnect();

    return(status);

}  // SpUdpConnect


NTSTATUS
SpUdpDisconnect(
    VOID
    )
{
    PLIST_ENTRY ListEntry;
    PSPUDP_RECEIVE_ENTRY ReceiveEntry;

    KeAcquireSpinLock(&SpUdpLock, &SpUdpOldIrql);

    if (SpUdpNetworkState == SpUdpNetworkDisconnected) {
        KeReleaseSpinLock(&SpUdpLock, SpUdpOldIrql);
        return(STATUS_SUCCESS);
    }

    SpUdpNetworkState = SpUdpNetworkDisconnecting;

    if (SpUdpActiveRefCount != 1) {
        KeReleaseSpinLock(&SpUdpLock, SpUdpOldIrql);
        return(STATUS_PENDING);
    }

    KeReleaseSpinLock(&SpUdpLock, SpUdpOldIrql);

    if (SpUdpDatagramFileObject != NULL) {
        ObDereferenceObject(SpUdpDatagramFileObject);
    }

    if (SpUdpDatagramHandle != NULL) {
        ZwClose(SpUdpDatagramHandle);
    }

    KeAcquireSpinLock(&SpUdpLock, &SpUdpOldIrql);

    SpUdpDatagramFileObject = NULL;
    SpUdpDatagramHandle = NULL;
    SpUdpDatagramDeviceObject = NULL;
    SpUdpActiveRefCount = 0;
    SpUdpNetworkState = SpUdpNetworkDisconnected;

    while (!IsListEmpty(&SpUdpReceiveList)) {
        ListEntry = RemoveHeadList(&SpUdpReceiveList);
        ReceiveEntry = CONTAINING_RECORD(ListEntry,
                                         SPUDP_RECEIVE_ENTRY,
                                         ListEntry
                                        );

        SpMemFree(ReceiveEntry->DataBuffer);
        SpMemFree(ReceiveEntry);
    }

    SpUdpNumReceivePackets = 0;

    KeReleaseSpinLock(&SpUdpLock, SpUdpOldIrql);

    return(STATUS_SUCCESS);

}  // SpUdpDisconnect


NTSTATUS
SpUdpIssueDeviceControl (
    IN PFILE_OBJECT     FileObject,
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            IrpParameters,
    IN ULONG            IrpParametersLength,
    IN PVOID            MdlBuffer,
    IN ULONG            MdlBufferLength,
    IN UCHAR            MinorFunction
    )

/*++

Routine Description:

    Issues a device control request to a TDI provider and waits for the
    request to complete.

Arguments:

    FileObject - a pointer to the file object corresponding to a TDI
        handle

    DeviceObject - a pointer to the device object corresponding to the
        FileObject.

    IrpParameters - information to write to the parameters section of the
        stack location of the IRP.

    IrpParametersLength - length of the parameter information.  Cannot be
        greater than 16.

    MdlBuffer - if non-NULL, a buffer of nonpaged pool to be mapped
        into an MDL and placed in the MdlAddress field of the IRP.

    MdlBufferLength - the size of the buffer pointed to by MdlBuffer.

    MinorFunction - the minor function code for the request.

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    NTSTATUS             status = STATUS_SUCCESS;
    PIRP                 irp;
    PIO_STACK_LOCATION   irpSp;
    KEVENT               event;
    IO_STATUS_BLOCK      ioStatusBlock;
    PDEVICE_OBJECT       deviceObject;
    PMDL                 mdl;

    //
    // Initialize the kernel event that will signal I/O completion.
    //
    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Reference the passed in file object. This is necessary because
    // the IO completion routine dereferences it.
    //
    ObReferenceObject( FileObject );

    //
    // Set the file object event to a non-signaled state.
    //
    (VOID) KeResetEvent( &FileObject->Event );

    //
    // Attempt to allocate and initialize the I/O Request Packet (IRP)
    // for this operation.
    //
    irp = IoAllocateIrp( (DeviceObject)->StackSize, TRUE );

    if ( irp == NULL ) {
        ObDereferenceObject( FileObject );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->Flags = (LONG)IRP_SYNCHRONOUS_API;
    irp->RequestorMode = KernelMode;
    irp->PendingReturned = FALSE;

    irp->UserIosb = &ioStatusBlock;
    irp->UserEvent = &event;

    irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;

    irp->AssociatedIrp.SystemBuffer = NULL;
    irp->UserBuffer = NULL;

    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.AuxiliaryBuffer = NULL;

    //
    // If an MDL buffer was specified, get an MDL, map the buffer,
    // and place the MDL pointer in the IRP.
    //

    if ( MdlBuffer != NULL ) {

        mdl = IoAllocateMdl(
                  MdlBuffer,
                  MdlBufferLength,
                  FALSE,
                  FALSE,
                  irp
                  );
        if ( mdl == NULL ) {
            IoFreeIrp( irp );
            ObDereferenceObject( FileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        MmBuildMdlForNonPagedPool( mdl );

    } else {

        irp->MdlAddress = NULL;
    }

    //
    // Put the file object pointer in the stack location.
    //
    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->FileObject = FileObject;
    irpSp->DeviceObject = DeviceObject;

    //
    // Fill in the service-dependent parameters for the request.
    //
    ASSERT( IrpParametersLength <= sizeof(irpSp->Parameters) );
    RtlCopyMemory( &irpSp->Parameters, IrpParameters, IrpParametersLength );

    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->MinorFunction = MinorFunction;

    //
    // Set up a completion routine which we'll use to free the MDL
    // allocated previously.
    //
    IoSetCompletionRoutine(
        irp,
        SpUdpRestartDeviceControl,
        NULL,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Queue the IRP to the thread and pass it to the driver.
    //
    IoEnqueueIrp( irp );

    status = IoCallDriver( DeviceObject, irp );

    //
    // If necessary, wait for the I/O to complete.
    //

    if ( status == STATUS_PENDING ) {
        KeWaitForSingleObject(
            (PVOID)&event,
            UserRequest,
            KernelMode,
            FALSE,
            NULL
            );
    }

    //
    // If the request was successfully queued, get the final I/O status.
    //

    if ( NT_SUCCESS(status) ) {
        status = ioStatusBlock.Status;
    }

    return status;

} // SpUdpIssueDeviceControl


NTSTATUS
SpUdpTdiSetEventHandler(
    IN PFILE_OBJECT    FileObject,
    IN PDEVICE_OBJECT  DeviceObject,
    IN ULONG           EventType,
    IN PVOID           EventHandler,
    IN PVOID           EventContext
    )
/*++

Routine Description:

    Sets up a TDI indication handler on the address object.  This is done synchronously, which
    shouldn't usually be an issue since TDI providers can usually complete
    indication handler setups immediately.

Arguments:

    FileObject - a pointer to the file object for an open connection or
        address object.

    DeviceObject - a pointer to the device object associated with the
        file object.

    EventType - the event for which the indication handler should be
        called.

    EventHandler - the routine to call when tghe specified event occurs.

    EventContext - context which is passed to the indication routine.

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    TDI_REQUEST_KERNEL_SET_EVENT  parameters;
    NTSTATUS                      status;

    parameters.EventType = EventType;
    parameters.EventHandler = EventHandler;
    parameters.EventContext = EventContext;

    status = SpUdpIssueDeviceControl(
                 FileObject,
                 DeviceObject,
                 &parameters,
                 sizeof(parameters),
                 NULL,
                 0,
                 TDI_SET_EVENT_HANDLER
                 );

    return(status);

}  // SpUdpTdiSetEventHandler



NTSTATUS
SpUdpTdiErrorHandler(
    IN PVOID     TdiEventContext,
    IN NTSTATUS  Status
    )
{

    return(STATUS_SUCCESS);

}  // SpUdpTdiErrorHandler


NTSTATUS
SpUdpRestartDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
{
    //
    // If there was an MDL in the IRP, free it and reset the pointer to
    // NULL.  The IO system can't handle a nonpaged pool MDL being freed
    // in an IRP, which is why we do it here.
    //

    if ( Irp->MdlAddress != NULL ) {
        IoFreeMdl( Irp->MdlAddress );
        Irp->MdlAddress = NULL;
    }

    return STATUS_SUCCESS;

} // SpUdpRestartDeviceControl


NTSTATUS
SpUdpTdiReceiveDatagramHandler(
    IN  PVOID    TdiEventContext,
    IN  LONG     SourceAddressLength,
    IN  PVOID    SourceAddress,
    IN  LONG     OptionsLength,
    IN  PVOID    Options,
    IN  ULONG    ReceiveDatagramFlags,
    IN  ULONG    BytesIndicated,
    IN  ULONG    BytesAvailable,
    OUT PULONG   BytesTaken,
    IN  PVOID    Tsdu,
    OUT PIRP *   Irp
    )
{
    NTSTATUS                        status;
    SPUDP_PACKET UNALIGNED *        pHeader = Tsdu;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    if (SpUdpNetworkState != SpUdpNetworkConnected) {
        return(STATUS_SUCCESS);
    }

    //
    // Validate the CNP header.
    //
    if (BytesIndicated > sizeof(SPUDP_PACKET)) {

        //
        // Deliver the packet to the appropriate upper layer protocol.
        //
        status = SpUdpReceivePacketHandler(
                     ReceiveDatagramFlags,
                     BytesIndicated,
                     BytesAvailable,
                     BytesTaken,
                     Tsdu,
                     Irp
                     );

        return(status);
    }

    //
    // Something went wrong. Drop the packet by
    // indicating that we consumed it.
    //

    *BytesTaken = BytesAvailable;
    *Irp = NULL;

    return(STATUS_SUCCESS);

}  // SpUdpTdiReceiveDatagramHandler


NTSTATUS
SpUdpReceivePacketHandler(
    IN  ULONG          TdiReceiveDatagramFlags,
    IN  ULONG          BytesIndicated,
    IN  ULONG          BytesAvailable,
    OUT PULONG         BytesTaken,
    IN  PVOID          Tsdu,
    OUT PIRP *         Irp
    )
{
    NTSTATUS                 status;
    PVOID                    DataBuffer;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    if (BytesAvailable == 0) {

        *Irp = NULL;
        return(STATUS_SUCCESS);
    }

    //
    // We need to fetch the rest of the packet before we
    // can process it.
    //
    //
    // Allocate a buffer to hold the data.
    //
    DataBuffer = SpMemAllocNonPagedPool(BytesAvailable);

    if (DataBuffer != NULL) {
        *Irp = IoAllocateIrp(SpUdpDatagramDeviceObject->StackSize, FALSE);

        if (*Irp != NULL) {

            PMDL  mdl = IoAllocateMdl(
                            DataBuffer,
                            BytesAvailable,
                            FALSE,
                            FALSE,
                            NULL
                            );

            if (mdl != NULL) {

                MmBuildMdlForNonPagedPool(mdl);

                //
                // Build the irp.
                //
                (*Irp)->Flags = 0;
                (*Irp)->RequestorMode = KernelMode;
                (*Irp)->PendingReturned = FALSE;
                (*Irp)->UserIosb = NULL;
                (*Irp)->UserEvent = NULL;
                (*Irp)->Overlay.AsynchronousParameters.UserApcRoutine = NULL;
                (*Irp)->AssociatedIrp.SystemBuffer = NULL;
                (*Irp)->UserBuffer = NULL;
                (*Irp)->Tail.Overlay.Thread = 0;
                (*Irp)->Tail.Overlay.OriginalFileObject = SpUdpDatagramFileObject;
                (*Irp)->Tail.Overlay.AuxiliaryBuffer = NULL;

                TdiBuildReceiveDatagram(
                    (*Irp),
                    SpUdpDatagramDeviceObject,
                    SpUdpDatagramFileObject,
                    SpUdpCompleteReceivePacket,
                    DataBuffer,
                    mdl,
                    BytesAvailable,
                    NULL,
                    NULL,
                    0
                    );

                //
                // Make the next stack location current.
                // Normally IoCallDriver would do this, but
                // since we're bypassing that, we do it directly.
                //
                IoSetNextIrpStackLocation( *Irp );
                return(STATUS_MORE_PROCESSING_REQUIRED);
            }

            IoFreeIrp(*Irp);
            *Irp = NULL;
        }

        SpMemFree(DataBuffer);
        DataBuffer = NULL;
    }


    //
    // Something went wrong. Drop the packet.
    //
    *BytesTaken += BytesAvailable;
    return(STATUS_SUCCESS);

}  // SpUdpReceivePacketHandler


NTSTATUS
SpUdpCompleteReceivePacket(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    )
{
    if (Irp->IoStatus.Status == STATUS_SUCCESS) {

        SpUdpProcessReceivePacket(
            (ULONG)Irp->IoStatus.Information,
            Context
            );

        IoFreeMdl(Irp->MdlAddress);
        IoFreeIrp(Irp);
    }

    return(STATUS_MORE_PROCESSING_REQUIRED);

} // SpUdpCompleteReceivePacket


VOID
SpUdpProcessReceivePacket(
    IN  ULONG          TsduSize,
    IN  PVOID          Tsdu
    )
{
    SPUDP_PACKET UNALIGNED * header = Tsdu;
    PSPUDP_RECEIVE_ENTRY ReceiveEntry;

    ASSERT(TsduSize >= sizeof(SPUDP_PACKET));

    if ((RtlCompareMemory(header->Signature, SetupResponseSignature, sizeof(SetupResponseSignature)) ==
         sizeof(SetupResponseSignature)) &&
        (SpUdpNumReceivePackets < 100)) {

        //
        // Put this packet on the receive list
        //
        ReceiveEntry = SpMemAllocNonPagedPool(sizeof(SPUDP_RECEIVE_ENTRY));

        if (ReceiveEntry == NULL) {
            SpMemFree(Tsdu);
            return;
        }

        ReceiveEntry->DataBufferLength = TsduSize;
        ReceiveEntry->DataBuffer = Tsdu;

        KeAcquireSpinLock(&SpUdpLock, &SpUdpOldIrql);
        InsertTailList(&SpUdpReceiveList, &(ReceiveEntry->ListEntry));
        SpUdpNumReceivePackets++;
        KeReleaseSpinLock(&SpUdpLock, SpUdpOldIrql);

    } else {

        SpMemFree(Tsdu);

    }

    return;

} // SpUdpProcessReceivePacket


NTSTATUS
SpUdpSendDatagram(
    IN PVOID                 SendBuffer,
    IN ULONG                 SendBufferLength,
    IN ULONG                 RemoteHostAddress,
    IN USHORT                RemoteHostPort
    )
{
    NTSTATUS         status = STATUS_SUCCESS;
    PLIST_ENTRY      entry;
    PIRP             irp;
    PMDL             dataMdl;
    PTDI_CONNECTION_INFORMATION   TdiSendDatagramInfo = NULL;
    PTRANSPORT_ADDRESS TaAddress;
    PTDI_ADDRESS_IP  TdiAddressIp;

    TdiSendDatagramInfo = SpMemAllocNonPagedPool(sizeof(TDI_CONNECTION_INFORMATION) +
                                                 sizeof(TA_IP_ADDRESS)
                                                );

    if (TdiSendDatagramInfo == NULL) {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlZeroMemory(TdiSendDatagramInfo,
                  sizeof(TDI_CONNECTION_INFORMATION) +
                      sizeof(TA_IP_ADDRESS)
                 );

    dataMdl = IoAllocateMdl(
                 SendBuffer,
                 SendBufferLength,
                 FALSE,
                 FALSE,
                 NULL
                 );

    if (dataMdl == NULL) {
        SpMemFree(TdiSendDatagramInfo);
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    MmBuildMdlForNonPagedPool(dataMdl);

    //
    // Ok, we can send the packet.
    //
    irp = IoAllocateIrp(SpUdpDatagramDeviceObject->StackSize, FALSE);

    if (irp != NULL) {

        //
        // Reference the network so it can't disconnect while we are using it.
        //
        KeAcquireSpinLock(&SpUdpLock, &SpUdpOldIrql);

        if (SpUdpNetworkState != SpUdpNetworkConnected) {
            KeReleaseSpinLock(&SpUdpLock, SpUdpOldIrql);
            return STATUS_SUCCESS;
        }
        SpUdpActiveRefCount++;

        KeReleaseSpinLock(&SpUdpLock, SpUdpOldIrql);

        //
        // Set the addressing info
        //
        TdiSendDatagramInfo->RemoteAddressLength = sizeof(TA_IP_ADDRESS);
        TdiSendDatagramInfo->RemoteAddress = (PVOID)(TdiSendDatagramInfo + 1);
        TaAddress = (PTRANSPORT_ADDRESS)(TdiSendDatagramInfo->RemoteAddress);
        TaAddress->TAAddressCount = 1;
        TaAddress->Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
        TaAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
        TdiAddressIp = (PTDI_ADDRESS_IP)(&(TaAddress->Address[0].Address[0]));
        TdiAddressIp->in_addr = RemoteHostAddress;
        TdiAddressIp->sin_port= htons(RemoteHostPort);
        RtlZeroMemory(TdiAddressIp->sin_zero, sizeof(TdiAddressIp->sin_zero));

        //
        // Build the irp.
        //
        irp->Flags = 0;
        irp->RequestorMode = KernelMode;
        irp->PendingReturned = FALSE;

        irp->UserIosb = NULL;
        irp->UserEvent = NULL;

        irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;

        irp->AssociatedIrp.SystemBuffer = NULL;
        irp->UserBuffer = NULL;

        irp->Tail.Overlay.Thread = PsGetCurrentThread();
        irp->Tail.Overlay.OriginalFileObject = SpUdpDatagramFileObject;
        irp->Tail.Overlay.AuxiliaryBuffer = NULL;

        TdiBuildSendDatagram(
            irp,
            SpUdpDatagramDeviceObject,
            SpUdpDatagramFileObject,
            SpUdpCompleteSendDatagram,
            TdiSendDatagramInfo,
            dataMdl,
            SendBufferLength,
            TdiSendDatagramInfo
            );

        //
        // Now send the packet.
        //
        IoCallDriver(
            SpUdpDatagramDeviceObject,
            irp
            );

        return(STATUS_PENDING);
    }

    IoFreeMdl(dataMdl);
    SpMemFree(TdiSendDatagramInfo);

    return(STATUS_INSUFFICIENT_RESOURCES);

}  // SpUdpSendDatagram


NTSTATUS
SpUdpCompleteSendDatagram(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
{
    PMDL               dataMdl;

    dataMdl = Irp->MdlAddress;
    Irp->MdlAddress = NULL;

    //
    // Remove the active reference we put on.
    //
    KeAcquireSpinLock(&SpUdpLock, &SpUdpOldIrql);

    SpUdpActiveRefCount--;

    if (SpUdpNetworkState == SpUdpNetworkDisconnecting) {
        SpUdpDisconnect();
    }

    KeReleaseSpinLock(&SpUdpLock, SpUdpOldIrql);

    //
    // Free the TDI address buffer
    //
    SpMemFree(Context);

    //
    // Free the Irp
    //
    IoFreeIrp(Irp);

    //
    // Free the MDL chain
    //
    IoFreeMdl(dataMdl);

    return(STATUS_MORE_PROCESSING_REQUIRED);

}  // SpUdpCompleteSendPacket

NTSTATUS
SpUdpSendAndReceiveDatagram(
    IN PVOID                 SendBuffer,
    IN ULONG                 SendBufferLength,
    IN ULONG                 RemoteHostAddress,
    IN USHORT                RemoteHostPort,
    IN SPUDP_RECEIVE_FN      SpUdpReceiveFunc
    )
{
    LARGE_INTEGER DelayTime;
    ULONG SendTries;
    ULONG RcvTries;
    PLIST_ENTRY ListEntry;
    PSPUDP_RECEIVE_ENTRY ReceiveEntry;
    NTSTATUS Status;

    DelayTime.QuadPart = -10*1000*1; // 10 millisecond (wake up at next tick)

    for (SendTries=0; SendTries < 15; SendTries++) {

        SpUdpSendDatagram(SendBuffer,
                          SendBufferLength,
                          RemoteHostAddress,
                          RemoteHostPort
                          );

        //
        // Wait for 1 second for a response
        //
        for (RcvTries=0; RcvTries < 400; ) {

            KeAcquireSpinLock(&SpUdpLock, &SpUdpOldIrql);
            if (!IsListEmpty(&SpUdpReceiveList)) {

                SpUdpNumReceivePackets--;
                ListEntry = RemoveHeadList(&SpUdpReceiveList);
                KeReleaseSpinLock(&SpUdpLock, SpUdpOldIrql);

                ReceiveEntry = CONTAINING_RECORD(ListEntry,
                                                 SPUDP_RECEIVE_ENTRY,
                                                 ListEntry
                                                );

                Status = (*SpUdpReceiveFunc)(ReceiveEntry->DataBuffer, ReceiveEntry->DataBufferLength);

                SpMemFree(ReceiveEntry->DataBuffer);
                SpMemFree(ReceiveEntry);

                if (NT_SUCCESS(Status)) {
                    return Status;
                }

            } else {

                KeReleaseSpinLock(&SpUdpLock, SpUdpOldIrql);

                RcvTries++;

                KeDelayExecutionThread(KernelMode, FALSE, &DelayTime);

            }

        }

    }

    return STATUS_UNSUCCESSFUL;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spupgcfg.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Spupgcfg.h

Abstract:

    Configuration routines for the upgrade case

Author:

    Sunil Pai (sunilp) 18-Nov-1993

Revision History:

--*/

#pragma once

//
// data types
//
typedef struct {
    PWSTR SectionName;
    DWORD SectionFlags;
    DWORD VerLow;
    DWORD VerHigh;
} RootDevnodeSectionNamesType;

#define RootDevnodeSectionNamesType_NTUPG  (0x0001)
#define RootDevnodeSectionNamesType_W9xUPG (0x0002)
#define RootDevnodeSectionNamesType_CLEAN  (0x0004)
#define RootDevnodeSectionNamesType_ALL    (0x0007)


//
// Public routines
//
NTSTATUS
SpUpgradeNTRegistry(
    IN PVOID    SifHandle,
    IN HANDLE  *HiveRootKeys,
    IN LPCWSTR  SetupSourceDevicePath,
    IN LPCWSTR  DirectoryOnSourceDevice,
    IN HANDLE   hKeyCCSet
    );

BOOLEAN
SpHivesFromInfs(
    IN PVOID   SifHandle,
    IN LPCWSTR SectionName,
    IN LPCWSTR SourcePath1,
    IN LPCWSTR SourcePath2,     OPTIONAL
    IN HANDLE  SystemHiveRoot,
    IN HANDLE  SoftwareHiveRoot,
    IN HANDLE  DefaultUserHiveRoot,
    IN HANDLE  HKR
    );

VOID
SpDeleteRootDevnodeKeys(
    IN PVOID  SifHandle,
    IN HANDLE hKeyCCSet,
    IN PWSTR DevicesToDelete,
    IN RootDevnodeSectionNamesType *DeviceClassesToDelete
    );

//
// Private routines
//
NTSTATUS
SppDeleteKeyRecursive(
    HANDLE  hKeyRoot,
    PWSTR   Key,
    BOOLEAN ThisKeyToo
    );

NTSTATUS
SppCopyKeyRecursive(
    HANDLE  hKeyRootSrc,
    HANDLE  hKeyRootDst,
    PWSTR   SrcKeyPath,
    PWSTR   DstKeyPath,
    BOOLEAN CopyAlways,
    BOOLEAN ApplyACLsAlways
    );


//
// Callback routine for SpApplyFunctionToDeviceInstanceKeys
//
typedef VOID (*PSPP_INSTANCEKEY_CALLBACK_ROUTINE) (
    IN     HANDLE  SetupInstanceKeyHandle,
    IN     HANDLE  UpgradeInstanceKeyHandle,
    IN     BOOLEAN RootEnumerated,
    IN OUT PVOID   Context
    );

VOID
SpApplyFunctionToDeviceInstanceKeys(
    IN HANDLE hKeyCCSet,
    IN PSPP_INSTANCEKEY_CALLBACK_ROUTINE InstanceKeyCallbackRoutine,
    IN OUT PVOID Context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spvideo.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spvideo.h

Abstract:

    Public header file for text setup display support.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:

--*/


#ifndef _SPVID_DEFN_
#define _SPVID_DEFN_


//
// Character attributes.
//
#define ATT_BLACK           0
#define ATT_BLUE            1
#define ATT_GREEN           2
#define ATT_CYAN            3
#define ATT_RED             4
#define ATT_MAGENTA         5
#define ATT_YELLOW          6
#define ATT_WHITE           7
#define ATT_INTENSE         8

#define ATT_FG_BLACK        ATT_BLACK
#define ATT_FG_BLUE         ATT_BLUE
#define ATT_FG_GREEN        ATT_GREEN
#define ATT_FG_CYAN         ATT_CYAN
#define ATT_FG_RED          ATT_RED
#define ATT_FG_MAGENTA      ATT_MAGENTA
#define ATT_FG_YELLOW       ATT_YELLOW
#define ATT_FG_WHITE        ATT_WHITE

#define ATT_BG_BLACK       (ATT_BLACK   << 4)
#define ATT_BG_BLUE        (ATT_BLUE    << 4)
#define ATT_BG_GREEN       (ATT_GREEN   << 4)
#define ATT_BG_CYAN        (ATT_CYAN    << 4)
#define ATT_BG_RED         (ATT_RED     << 4)
#define ATT_BG_MAGENTA     (ATT_MAGENTA << 4)
#define ATT_BG_YELLOW      (ATT_YELLOW  << 4)
#define ATT_BG_WHITE       (ATT_WHITE   << 4)

#define ATT_FG_INTENSE      ATT_INTENSE
#define ATT_BG_INTENSE     (ATT_INTENSE << 4)

#define DEFAULT_ATTRIBUTE           GetDefaultAttr()
#define DEFAULT_BACKGROUND          GetDefaultBackground()

#define DEFAULT_STATUS_ATTRIBUTE    GetDefaultStatusAttr()
#define DEFAULT_STATUS_BACKGROUND   GetDefaultStatusBackground()


UCHAR
GetDefaultAttr(
    void
    );

UCHAR
GetDefaultBackground(
    void
    );

UCHAR
GetDefaultStatusAttr(
    void
    );

UCHAR
GetDefaultStatusBackground(
    void
    );

BOOLEAN
SpvidGetModeParams(
    OUT PULONG XResolution,
    OUT PULONG YResolution,
    OUT PULONG BitsPerPixel,
    OUT PULONG VerticalRefresh,
    OUT PULONG InterlacedFlag
    );

//
// Display routines.
//

VOID
SpvidInitialize0(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
SpvidInitialize(
    VOID
    );

VOID
SpvidTerminate(
    VOID
    );


VOID
SpvidDisplayString(
    IN PWSTR String,
    IN UCHAR Attribute,
    IN ULONG X,
    IN ULONG Y
    );


VOID
SpvidDisplayOemString(
    IN PSTR  String,
    IN UCHAR Attribute,
    IN ULONG X,
    IN ULONG Y
    );


VOID
SpvidClearScreenRegion(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG W,
    IN ULONG H,
    IN UCHAR Attribute
    );


BOOLEAN
SpvidScrollUp(
    IN ULONG TopLine,
    IN ULONG BottomLine,
    IN ULONG LineCount,
    IN UCHAR FillAttribute
    );

NTSTATUS
SpvidSwitchToTextmode(
    VOID
    );   
    
//
// Structure used to contain global video vars. These are broken out
// like this because they are shared with the locale/lang-specific
// text setup module.
//
typedef struct _SP_VIDEO_VARS {

    //
    // Habdle to \device\video0
    //
    HANDLE hDisplay;

    //
    // The following are character values, and must be filled in
    // in the display-specific initialization routine.
    //
    ULONG ScreenWidth,ScreenHeight;

    //
    // The display-specific subsystems fill these in with information
    // that reflects the video mode they are using, and the video memory.
    //
    VIDEO_MEMORY_INFORMATION VideoMemoryInfo;
    VIDEO_MODE_INFORMATION   VideoModeInfo;

    //
    // Graphics mode information (if any)
    //
    VIDEO_MODE_INFORMATION  GraphicsModeInfo;

    //
    // The display routines will be doing unicode to oem translations.
    // We'll limit the length of a string that can be displayed at one time
    // to the width of the screen.  Theese two vars track a buffer
    // we preallocate to hold translated text.
    //
    ULONG  SpvCharTranslationBufferSize;
    PUCHAR SpvCharTranslationBuffer;

    //
    // The following table maps each possible attribute to
    // a corresponding bit pattern to be be placed into the
    // frame buffer to generate that attribute.
    // On palette managed displays, this table will be an
    // identity mapping (ie, AttributeToColorValue[i] = i)
    // so we can poke the attribute driectly into the
    // frame buffer.
    //
    ULONG AttributeToColorValue[16];

    //
    // Upgrade graphics mode
    //
    BOOLEAN UpgradeGraphicsMode;
    
    //
    // Background Video buffer for upgrade graphics mode 
    //
    PVOID   VideoBuffer;
    ULONG   VideoBufferSize;

    //
    // Active video buffer
    //
    PVOID   ActiveVideoBuffer;
} SP_VIDEO_VARS, *PSP_VIDEO_VARS;

extern SP_VIDEO_VARS VideoVars;

//
// bootfont.bin file image
//

extern PVOID BootFontImage;
extern ULONG BootFontImageLength;

#endif // ndef _SPVID_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spvideo.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spvideo.c

Abstract:

    Text setup display support.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:


--*/



#include "spprecmp.h"
#include <hdlsblk.h>
#include <hdlsterm.h>
#pragma hdrstop

extern BOOLEAN ForceConsole;

//
// Video function vectors.
//
PVIDEO_FUNCTION_VECTOR VideoFunctionVector;

//
// Other display paramters
//
SP_VIDEO_VARS VideoVars;

BOOLEAN VideoInitialized = FALSE;

POEM_FONT_FILE_HEADER FontHeader;
ULONG                 FontBytesPerRow;
ULONG                 FontCharacterHeight;
ULONG                 FontCharacterWidth;

//
// bootfont.bin file image
//
PVOID   BootFontImage = NULL;
ULONG   BootFontImageLength = 0;

//
// The following structures and constants are used in font files.
//

//
// Define OS/2 executable resource information structure.
//

#define FONT_DIRECTORY 0x8007
#define FONT_RESOURCE 0x8008

typedef struct _RESOURCE_TYPE_INFORMATION {
    USHORT Ident;
    USHORT Number;
    LONG   Proc;
} RESOURCE_TYPE_INFORMATION, *PRESOURCE_TYPE_INFORMATION;

//
// Define OS/2 executable resource name information structure.
//

typedef struct _RESOURCE_NAME_INFORMATION {
    USHORT Offset;
    USHORT Length;
    USHORT Flags;
    USHORT Ident;
    USHORT Handle;
    USHORT Usage;
} RESOURCE_NAME_INFORMATION, *PRESOURCE_NAME_INFORMATION;

//
// These values are passed to us by setupldr and represent monitor config
// data from the monitor peripheral for the display we are supposed to use
// during setup.  They are used only for non-vga displays.
//
PMONITOR_CONFIGURATION_DATA MonitorConfigData;
PCHAR MonitorFirmwareIdString;

//
// Function prototypes.
//
BOOLEAN
pSpvidInitPalette(
    VOID
    );

VOID
SpvidInitialize0(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    Perform phase-0 display initialization.  This routine is used to
    perform initialization that can be performed only at driver load time.

    Actions:

        - initialize the font.  We retreive the hal oem font image
          from the loader block and copy it into locally allocated memory.
          This must be done here because the loader block is gone
          when setup is actually started.

Arguments:

    LoaderBlock - supplies pointer to loader parameter block.

Return Value:

    None.  Does not return if error.

--*/

{
    POEM_FONT_FILE_HEADER fontHeader;
    PSETUP_LOADER_BLOCK SetupBlock;
    BOOLEAN bValidOemFont;

    //
    // Check if the file has a font file header. Use SEH so that we don't bugcheck if
    // we got passed something screwy.
    //
    try {

        fontHeader = (POEM_FONT_FILE_HEADER)LoaderBlock->OemFontFile;

        if ((fontHeader->Version != OEM_FONT_VERSION) ||
            (fontHeader->Type != OEM_FONT_TYPE) ||
            (fontHeader->Italic != OEM_FONT_ITALIC) ||
            (fontHeader->Underline != OEM_FONT_UNDERLINE) ||
            (fontHeader->StrikeOut != OEM_FONT_STRIKEOUT) ||
            (fontHeader->CharacterSet != OEM_FONT_CHARACTER_SET) ||
            (fontHeader->Family != OEM_FONT_FAMILY) ||
            (fontHeader->PixelWidth > 32))
        {
            bValidOemFont = FALSE;
        } else {
            bValidOemFont = TRUE;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {

        bValidOemFont = FALSE;
    }

    if(!bValidOemFont) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: oem hal font image is not a .fnt file.\n"));
        SpBugCheck(SETUP_BUGCHECK_BAD_OEM_FONT,0,0,0);
    }

    FontHeader = SpMemAlloc(fontHeader->FileSize);
    RtlMoveMemory(FontHeader,fontHeader,fontHeader->FileSize);

    FontBytesPerRow     = (FontHeader->PixelWidth + 7) / 8;
    FontCharacterHeight = FontHeader->PixelHeight;
    FontCharacterWidth  = FontHeader->PixelWidth;

    //
    // Get pointer to the setup loader block.
    //
    SetupBlock = LoaderBlock->SetupLoaderBlock;

    //
    // Save away monitor data.
    //

    if(SetupBlock->Monitor) {

        RtlMoveMemory(
            MonitorConfigData = SpMemAlloc(sizeof(MONITOR_CONFIGURATION_DATA)),
            SetupBlock->Monitor,
            sizeof(MONITOR_CONFIGURATION_DATA)
            );
    }

    if(SetupBlock->MonitorId) {

        MonitorFirmwareIdString = SpDupString(SetupBlock->MonitorId);
    }

    //
    // save off bootfont.bin file image, if any
    //
    if (SetupBlock->BootFontFile && SetupBlock->BootFontFileLength) {
        BootFontImage = SpMemAlloc(SetupBlock->BootFontFileLength);

        if (BootFontImage) {
            BootFontImageLength = SetupBlock->BootFontFileLength;

            RtlMoveMemory(BootFontImage, 
                SetupBlock->BootFontFile, 
                BootFontImageLength);
        }
    }

    //
    // Initialize the global video state
    //
    RtlZeroMemory(&VideoVars, sizeof(SP_VIDEO_VARS));
}


VOID
SpvidInitialize(
    VOID
    )
{
    NTSTATUS                Status;
    OBJECT_ATTRIBUTES       Attributes;
    IO_STATUS_BLOCK         IoStatusBlock;
    UNICODE_STRING          UnicodeString;
    VIDEO_NUM_MODES         NumModes;
    PVIDEO_MODE_INFORMATION VideoModes;
    PVIDEO_MODE_INFORMATION pVideoMode;
    ULONG                   VideoModesSize;
    ULONG                   mode;
    BOOLEAN                 IsVga;
    PVIDEO_FUNCTION_VECTOR  NewVector;
    PVIDEO_MODE_INFORMATION GraphicsVideoMode = NULL;


    //
    // If video is already initialized, we are performing a reinit.
    //
    if(VideoInitialized) {
        //
        // Request video function vector from the locale/lang-specific module.
        //
        NewVector = SplangGetVideoFunctionVector(
                        (VideoFunctionVector == &VgaVideoVector) ? SpVideoVga : SpVideoFrameBuffer,
                        &VideoVars
                        );

        //
        // If there is no alternate video then we're done. Else go into action.
        //
        if(NewVector) {
            SpvidTerminate();
        } else {
            return;
        }
    } else {
        NewVector = NULL;
    }

    // Initialize the headless terminal

    SpTermInitialize();
    //
    // Open \Device\Video0.
    //
    RtlInitUnicodeString(&UnicodeString,L"\\Device\\Video0");

    InitializeObjectAttributes(
        &Attributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = ZwCreateFile(
                &VideoVars.hDisplay,
                GENERIC_READ | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                &Attributes,
                &IoStatusBlock,
                NULL,                   // allocation size
                FILE_ATTRIBUTE_NORMAL,
                0,                      // no sharing
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,                   // no EAs
                0
                );

    if(!NT_SUCCESS(Status)) {
        //
        // if we're in headless mode, try to operate without the video card 
        // present...otherwise we're done
        //
        if (HeadlessTerminalConnected) {
            //
            // if there's no video card, then we default into VGA mode,
            // which will do nothing if there is no video card
            //
            VideoFunctionVector = &VgaVideoVector;
            VideoVars.ScreenWidth  = 80;
            VideoVars.ScreenHeight = HEADLESS_SCREEN_HEIGHT;
            //
            // Allocate a buffer for use translating unicode to oem.
            // Assuming each unicode char translates to a dbcs char,
            // we need a buffer twice the width of the screen to hold
            // (the width of the screen being the longest string
            // we'll display in one shot).
            //
            VideoVars.SpvCharTranslationBufferSize = (VideoVars.ScreenWidth+1)*2;
            VideoVars.SpvCharTranslationBuffer = SpMemAlloc(VideoVars.SpvCharTranslationBufferSize);

            VideoInitialized = TRUE;

            return;
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: NtOpenFile of \\device\\video0 returns %lx\n",Status));
            SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_OPEN, Status);
            while(TRUE);    // loop forever
        }
    }

    //
    // Request a list of video modes.
    //
    Status = ZwDeviceIoControlFile(
                VideoVars.hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
                NULL,
                0,
                &NumModes,
                sizeof(NumModes)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to query video mode count (status = %lx)\n",Status));
        ZwClose(VideoVars.hDisplay);
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_GETNUMMODES, Status);
        while(TRUE);    // loop forever
    }

    VideoModesSize = NumModes.NumModes * NumModes.ModeInformationLength;
    VideoModes = SpMemAlloc(VideoModesSize);

    Status = ZwDeviceIoControlFile(
                VideoVars.hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_QUERY_AVAIL_MODES,
                NULL,
                0,
                VideoModes,
                VideoModesSize
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to get list of video modes (status = %lx)\n",Status));
        SpMemFree(VideoModes);
        ZwClose(VideoVars.hDisplay);
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_GETMODES, Status);
        while(TRUE);    // loop forever
    }

    //
    // If we have a 720 x 400 text mode, it's vga.
    // Otherwise it's a frame buffer.
    //
    IsVga = FALSE;

    pVideoMode = &VideoModes[0];

    for(mode=0; mode<NumModes.NumModes; mode++) {

        if(!IsVga && !(pVideoMode->AttributeFlags & VIDEO_MODE_GRAPHICS)
        && (pVideoMode->VisScreenWidth == 720)
        && (pVideoMode->VisScreenHeight == 400))
        {
            IsVga = TRUE;
        }

        if ((pVideoMode->AttributeFlags & VIDEO_MODE_GRAPHICS) &&
             (pVideoMode->VisScreenWidth == 640) &&
             (pVideoMode->VisScreenHeight == 480) && 
             (pVideoMode->NumberOfPlanes == 4) && 
             (pVideoMode->BitsPerPlane == 1)) {
             GraphicsVideoMode = pVideoMode;
        }             

        pVideoMode = (PVIDEO_MODE_INFORMATION) (((PUCHAR) pVideoMode) + NumModes.ModeInformationLength);
    }

    VideoFunctionVector = NewVector ? NewVector : (IsVga ? &VgaVideoVector : &FrameBufferVideoVector);

    //
    // Headless redirection only works in the VGA case.
    // If you enable another video mode, you must fix headless for that video
    // mode and then remove this assert
    //
    ASSERT( HeadlessTerminalConnected
                ? (VideoFunctionVector == &VgaVideoVector)
                : TRUE );


    if (GraphicsVideoMode) {
        VideoVars.GraphicsModeInfo = *GraphicsVideoMode;
    } else {
        //
        // disable graphics mode
        //
        SP_SET_UPGRADE_GRAPHICS_MODE(FALSE);
    }                

    spvidSpecificInitialize(VideoModes,NumModes.NumModes,NumModes.ModeInformationLength);

    // Set the terminal Height to the correct value
    if (HeadlessTerminalConnected) {
        VideoVars.ScreenHeight = HEADLESS_SCREEN_HEIGHT;
    }
    
    //
    // Allocate a buffer for use translating unicode to oem.
    // Assuming each unicode char translates to a dbcs char,
    // we need a buffer twice the width of the screen to hold
    // (the width of the screen being the longest string
    // we'll display in one shot).
    //
    VideoVars.SpvCharTranslationBufferSize = (VideoVars.ScreenWidth+1)*2;
    VideoVars.SpvCharTranslationBuffer = SpMemAlloc(VideoVars.SpvCharTranslationBufferSize);

    pSpvidInitPalette();

    if (!SP_IS_UPGRADE_GRAPHICS_MODE()) {
        CLEAR_ENTIRE_SCREEN();
    }

    VideoInitialized = TRUE;

    SpMemFree(VideoModes);

}



VOID
SpvidTerminate(
    VOID
    )
{
    NTSTATUS Status;

    if(VideoInitialized) {

        spvidSpecificTerminate();

        SpTermTerminate();

        if (VideoVars.hDisplay) {
            Status = ZwClose(VideoVars.hDisplay);
    
            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to close \\device\\video0 (status = %lx)\n",Status));
            }
        }

        SpMemFree(VideoVars.SpvCharTranslationBuffer);
        VideoVars.SpvCharTranslationBuffer = NULL;

        VideoInitialized = FALSE;
    }
}


UCHAR
GetDefaultAttr(
    void
    )
{
    return (UCHAR)(ForceConsole ? (ATT_FG_WHITE | ATT_BG_BLACK) : (ATT_FG_WHITE | ATT_BG_BLUE));
}


UCHAR
GetDefaultBackground(
    void
    )
{
    return (UCHAR)(ForceConsole ? ATT_BLACK : ATT_BLUE);
}


UCHAR
GetDefaultStatusAttr(
    void
    )
{
    return (UCHAR)(ForceConsole ? (ATT_FG_WHITE | ATT_BG_BLACK) : (ATT_FG_BLACK | ATT_BG_WHITE));
}


UCHAR
GetDefaultStatusBackground(
    void
    )
{
    return (UCHAR)(ForceConsole ? ATT_BLACK : ATT_WHITE);
}


BOOLEAN
SpvidGetModeParams(
    OUT PULONG XResolution,
    OUT PULONG YResolution,
    OUT PULONG BitsPerPixel,
    OUT PULONG VerticalRefresh,
    OUT PULONG InterlacedFlag
    )
{
    if(VideoVars.VideoModeInfo.AttributeFlags & VIDEO_MODE_GRAPHICS) {

        *XResolution = VideoVars.VideoModeInfo.VisScreenWidth;
        *YResolution = VideoVars.VideoModeInfo.VisScreenHeight;
        *BitsPerPixel = VideoVars.VideoModeInfo.BitsPerPlane;
        *VerticalRefresh = VideoVars.VideoModeInfo.Frequency;
        *InterlacedFlag = (VideoVars.VideoModeInfo.AttributeFlags & VIDEO_MODE_INTERLACED) ? 1 : 0;

        return(TRUE);

    } else {

        //
        // VGA/text mode. Params are not interesting.
        //
        return(FALSE);
    }
}



BOOLEAN
pSpvidInitPalette(
    VOID
    )

/*++

Routine Description:

    Set the display up so we can use the standard 16 cga attributes.

    If the video mode is direct color, then we construct a table of
    attribute to color mappings based on the number of bits for
    red, green, and blue.

    If the video mode is palette driven, then we actually construct
    a 16-color palette and pass it to the driver.

Arguments:

    VOID

Return Value:

    TRUE if display set up successfully, false if not.

--*/


{
    ULONG i;
    ULONG MaxVal[3];
    ULONG MidVal[3];

    #define C_RED 0
    #define C_GRE 1
    #define C_BLU 2

    if(VideoVars.VideoModeInfo.AttributeFlags & VIDEO_MODE_PALETTE_DRIVEN) {

        UCHAR Buffer[sizeof(VIDEO_CLUT)+(sizeof(VIDEO_CLUTDATA)*15)];   // size is close enough
        PVIDEO_CLUT clut = (PVIDEO_CLUT)Buffer;
        NTSTATUS Status;
        IO_STATUS_BLOCK IoStatusBlock;

        //
        // Palette driven.  Set up the attribute to color table
        // as a one-to-one mapping so we can use attribute values
        // directly in the frame buffer and get the expected result.
        //
        MaxVal[C_RED] = ((1 << VideoVars.VideoModeInfo.NumberRedBits  ) - 1);
        MaxVal[C_GRE] = ((1 << VideoVars.VideoModeInfo.NumberGreenBits) - 1);
        MaxVal[C_BLU] = ((1 << VideoVars.VideoModeInfo.NumberBlueBits ) - 1);

        MidVal[C_RED] = 2 * MaxVal[C_RED] / 3;
        MidVal[C_GRE] = 2 * MaxVal[C_GRE] / 3;
        MidVal[C_BLU] = 2 * MaxVal[C_BLU] / 3;

        clut->NumEntries = 16;
        clut->FirstEntry = 0;

        for(i=0; i<16; i++) {

            VideoVars.AttributeToColorValue[i] = i;

            clut->LookupTable[i].RgbArray.Red   = (UCHAR)((i & ATT_RED  )
                                                ? ((i & ATT_INTENSE) ? MaxVal[C_RED] : MidVal[C_RED])
                                                : 0);

            clut->LookupTable[i].RgbArray.Green = (UCHAR)((i & ATT_GREEN)
                                                ? ((i & ATT_INTENSE) ? MaxVal[C_GRE] : MidVal[C_GRE])
                                                : 0);

            clut->LookupTable[i].RgbArray.Blue  = (UCHAR)((i & ATT_BLUE )
                                                ? ((i & ATT_INTENSE) ? MaxVal[C_BLU] : MidVal[C_BLU])
                                                : 0);

            clut->LookupTable[i].RgbArray.Unused = 0;
        }

        Status = ZwDeviceIoControlFile(
                    VideoVars.hDisplay,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    IOCTL_VIDEO_SET_COLOR_REGISTERS,
                    clut,
                    sizeof(Buffer),
                    NULL,
                    0
                    );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set palette (status = %lx)\n",Status));
            return(FALSE);
        }

    } else {

        //
        // Direct color. Construct an attribute to color value table.
        //
        ULONG mask[3];
        ULONG bitcnt[3];
        ULONG bits;
        ULONG shift[3];
        unsigned color;

        //
        // Determine the ranges for each of red, green, and blue.
        //
        mask[C_RED] = VideoVars.VideoModeInfo.RedMask;
        mask[C_GRE] = VideoVars.VideoModeInfo.GreenMask;
        mask[C_BLU] = VideoVars.VideoModeInfo.BlueMask;

        bitcnt[C_RED] = VideoVars.VideoModeInfo.NumberRedBits;
        bitcnt[C_GRE] = VideoVars.VideoModeInfo.NumberGreenBits;
        bitcnt[C_BLU] = VideoVars.VideoModeInfo.NumberBlueBits;

        shift[C_RED] = 32;
        shift[C_GRE] = 32;
        shift[C_BLU] = 32;

        for(color=0; color<3; color++) {

            bits = 0;

            //
            // Count the number of 1 bits and determine the shift value
            // to shift in that color component.
            //
            for(i=0; i<32; i++) {

                if(mask[color] & (1 << i)) {

                    bits++;

                    //
                    // Remember the position of the least significant bit
                    // in this mask.
                    //
                    if(shift[color] == 32) {
                        shift[color] = i;
                    }
                }
            }

            //
            // Calculate the maximum color value for this color component.
            //
            MaxVal[color] = (1 << bits) - 1;

            //
            // Make sure we haven't overflowed the actual number of bits
            // available for this color component.
            //
            if(bitcnt[color] && (MaxVal[color] > ((ULONG)(1 << bitcnt[color]) - 1))) {
                MaxVal[color] = (ULONG)(1 << bitcnt[color]) - 1;
            }
        }

        MidVal[C_RED] = 2 * MaxVal[C_RED] / 3;
        MidVal[C_GRE] = 2 * MaxVal[C_GRE] / 3;
        MidVal[C_BLU] = 2 * MaxVal[C_BLU] / 3;

        //
        // Now go through and construct the color table.
        //
        for(i=0; i<16; i++) {

            VideoVars.AttributeToColorValue[i] =

                (((i & ATT_RED)
               ? ((i & ATT_INTENSE) ? MaxVal[C_RED] : MidVal[C_RED])
               : 0)
                << shift[C_RED])

             |  (((i & ATT_GREEN)
               ? ((i & ATT_INTENSE) ? MaxVal[C_GRE] : MidVal[C_GRE])
               : 0)
                << shift[C_GRE])

             |  (((i & ATT_BLUE)
               ? ((i & ATT_INTENSE) ? MaxVal[C_BLU] : MidVal[C_BLU])
               : 0)
                << shift[C_BLU]);
        }
    }

    //
    // Perform any display-specific palette setup.
    //
    return(spvidSpecificInitPalette());
}



VOID
pSpvidMapVideoMemory(
    IN BOOLEAN Map
    )

/*++

Routine Description:

    Map or unmap video memory.  Fills in or uses the VideoMemoryInfo global.

Arguments:

    Map - if TRUE, map video memory.
          if FALSE, unmap video memory.


Return Value:

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    VIDEO_MEMORY VideoMemory;

    VideoMemory.RequestedVirtualAddress = Map ? NULL : VideoVars.VideoMemoryInfo.VideoRamBase;

    Status = ZwDeviceIoControlFile(
                VideoVars.hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                Map ? IOCTL_VIDEO_MAP_VIDEO_MEMORY : IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
                &VideoMemory,
                sizeof(VideoMemory),
                Map ? &VideoVars.VideoMemoryInfo : NULL,
                Map ? sizeof(VideoVars.VideoMemoryInfo) : 0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to %smap video memory (status = %lx)\n",Map ? "" : "un",Status));
        if(Map) {
            SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_MAP, Status);
            while(TRUE);    // loop forever
        }
    }
}


VOID
SpvidDisplayString(
    IN PWSTR String,
    IN UCHAR Attribute,
    IN ULONG X,
    IN ULONG Y
    )
{
    //
    // Convert unicode string to oem, guarding against overflow.
    //
    RtlUnicodeToOemN(
        VideoVars.SpvCharTranslationBuffer,
        VideoVars.SpvCharTranslationBufferSize-1,     // guarantee room for nul
        NULL,
        String,
        (wcslen(String)+1)*sizeof(WCHAR)
        );

    VideoVars.SpvCharTranslationBuffer[VideoVars.SpvCharTranslationBufferSize-1] = 0;

    spvidSpecificDisplayString(VideoVars.SpvCharTranslationBuffer,Attribute,X,Y);
       
    SpTermDisplayStringOnTerminal( String, Attribute, X, Y);

}


VOID
SpvidDisplayOemString(
    IN PSTR  String,
    IN UCHAR Attribute,
    IN ULONG X,
    IN ULONG Y
    )
{
    spvidSpecificDisplayString(String,Attribute,X,Y);

    RtlOemToUnicodeN(
        (PWSTR)VideoVars.SpvCharTranslationBuffer,
        VideoVars.SpvCharTranslationBufferSize-1,     // guarantee room for nul
        NULL,
        String,
        (strlen(String)+1)*sizeof(CHAR));

    //
    // make it a unicode NULL at the end
    //
    VideoVars.SpvCharTranslationBuffer[VideoVars.SpvCharTranslationBufferSize-1] = '\0';
    VideoVars.SpvCharTranslationBuffer[VideoVars.SpvCharTranslationBufferSize-2] = '\0';

    SpTermDisplayStringOnTerminal((PWSTR)VideoVars.SpvCharTranslationBuffer, Attribute, X, Y);

}


VOID
SpvidClearScreenRegion(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG W,
    IN ULONG H,
    IN UCHAR Attribute
    )

/*++

Routine Description:

    Clear out a screen region to a specific attribute.

Arguments:

    X,Y,W,H - specify rectangle in 0-based character coordinates.
        If W or H are 0, clear the entire screen.

    Attribute - Low nibble specifies attribute to be filled in the rectangle
        (ie, the background color to be cleared to).

Return Value:

    None.

--*/

{
    ULONG   i;
    UCHAR   FillAttribute;
    WCHAR   TerminalLine[80];
    BOOLEAN ToEOL;

    if(!W || !H) {
        X = Y = 0;
        W = VideoVars.ScreenWidth;
        H = VideoVars.ScreenHeight;

    } else {
        ASSERT(X+W <= VideoVars.ScreenWidth);
        ASSERT(X <= VideoVars.ScreenWidth);
        ASSERT(W <= VideoVars.ScreenWidth);
        ASSERT(Y+H <= VideoVars.ScreenHeight);
        ASSERT(Y <= VideoVars.ScreenHeight);
        ASSERT(H <= VideoVars.ScreenHeight);

        if (W > VideoVars.ScreenWidth)
                W = VideoVars.ScreenWidth;

        if (X > VideoVars.ScreenWidth)
            X = VideoVars.ScreenWidth;
        
        if(X+W > VideoVars.ScreenWidth) {
            W = VideoVars.ScreenWidth-X;
        }

        if(Y > VideoVars.ScreenHeight) {
            Y = VideoVars.ScreenHeight;
        }

        if(H > VideoVars.ScreenHeight) {
            H = VideoVars.ScreenHeight;
        }

        if(Y+H > VideoVars.ScreenHeight) {
            H = VideoVars.ScreenHeight-Y;
        }
    }

    spvidSpecificClearRegion(X,Y,W,H,Attribute);
    
    FillAttribute = (Attribute << 4) | Attribute;    

    ToEOL = FALSE;
    if (X + W < 80) {
        for (i = 0; i<W;i++) {
            TerminalLine[i] = L' ';
        }
        TerminalLine[W] = L'\0';
    } else {
        for (i = 0; i<(79-X); i++) {
            TerminalLine[i] = L' ';
        }
        TerminalLine[79 - X] = L'\0';    
        if ((X == 0) && (Attribute == DEFAULT_BACKGROUND)) {
            ToEOL = TRUE;
        }
    }
    for(i=0; i<H; i++) {

        if (ToEOL) {
            SpTermDisplayStringOnTerminal(HEADLESS_CLEAR_TO_EOL_STRING, 
                                          FillAttribute, 
                                          X, 
                                          Y + i
                                         );
        } else {
            SpTermDisplayStringOnTerminal(TerminalLine, FillAttribute, X, Y + i);
        }
    }


}


BOOLEAN
SpvidScrollUp(
    IN ULONG TopLine,
    IN ULONG BottomLine,
    IN ULONG LineCount,
    IN UCHAR FillAttribute
    )
{
    BOOLEAN vidSpecificRet;
    ULONG i; 
    ULONG line;
    WCHAR TerminalLine[80];
    
    vidSpecificRet = spvidSpecificScrollUp(TopLine,BottomLine,LineCount,FillAttribute);
    if (!HeadlessTerminalConnected) {
        return(vidSpecificRet);
    }

    if ((TopLine == 0) && (BottomLine==VideoVars.ScreenHeight-1)) {        
        //
        // Efficient scrolling for *whole screen* by
        // issuing the <CSI>x;80H escape, which moves the cursor to
        // the bottom right corner of the VT100.  Each time we
        // move the cursor to this position, it makes the VT100 scroll
        // one line.
        //
        swprintf(TerminalLine, L"\033[%d;80H\n", BottomLine+1);
        for (i=0;i<LineCount; i++){
            SpTermSendStringToTerminal(TerminalLine,
                                       TRUE
                                       );
        }
        return vidSpecificRet;
    }

    //
    // We have to scroll it the hard way because we're not doing the
    // entire screen
    //

    //
    // Select the top and bottom line numbers via <CSI>x;yr escape
    // this will be some portion of the active display
    //
    swprintf(TerminalLine,L"\033[%d;%dr", TopLine+1, BottomLine+1);
    SpTermSendStringToTerminal(TerminalLine,
                               TRUE
                               );

    //
    // move the cursor to the bottom right corner of the selected area 
    // via <CSI>x;80H escape.  Each time we write to this area, it makes
    // the selected area scroll one line
    //
    swprintf(TerminalLine, L"\033[%d;80H\n", BottomLine+1);
    for(i = 0; i< LineCount; i++){
        SpTermSendStringToTerminal(TerminalLine,
                                   TRUE
                                   );
    }

    //
    // get a line of whitespace to clear out the bottom lines that may
    // have garbage in them now.
    //
    for (i=0;i<79;i++) {
        TerminalLine[i] = L' ';
    }
    TerminalLine[79] = '\0';

    
    line = BottomLine - LineCount + 1;
    for(i=0;i<LineCount;i++){
        SpTermDisplayStringOnTerminal(TerminalLine,
                                      FillAttribute,
                                      0,
                                      line + i
                                      );
    }

    //
    // send <CSI>r escape, which resets the selected line numbers
    // so that the entire display is active again.
    //
    swprintf(TerminalLine, L"\033[r");
    SpTermSendStringToTerminal(TerminalLine,
                               TRUE
                               );
    return vidSpecificRet;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\sputil.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    sputil.c

Abstract:

    Miscellaneous functions for text setup.

Author:

    Ted Miller (tedm) 17-Sep-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop
#include "bootvar.h"
#include "bootstatus.h"

#if !defined(SETUP_CAB_TEST_USERMODE)


//
// On x86, we want to clear the previous OS entry in boot.ini if
// we reformat C:
//
#ifdef _X86_
UCHAR    OldSystemLine[MAX_PATH];
BOOLEAN  DiscardOldSystemLine = FALSE;
#endif

BOOLEAN Nec98RestoreBootFiles = TRUE; //NEC98
extern PDISK_REGION TargetRegion_Nec98;

#define REGKEY_SERVICES L"\\Registry\\Machine\\System\\CurrentControlSet\\Services"

LIST_ENTRY SpServiceList;

typedef struct _SERVICE_ENTRY {
    LIST_ENTRY Next;
    PWCHAR ServiceName;
} SERVICE_ENTRY, *PSERVICE_ENTRY;

//
// Setup progress callback data
//
#define MAX_SETUP_PROGRESS_SUBSCRIBERS  8

ULONG ProgressSubscribersCount = 0;
TM_PROGRESS_SUBSCRIBER  ProgressSubscribers[MAX_SETUP_PROGRESS_SUBSCRIBERS] = {0};


//
// NEC98
//
NTSTATUS
SpDeleteAndBackupBootFiles(
    IN BOOLEAN  RestoreBackupFiles,
    IN BOOLEAN  DeleteBackupFiles,
    IN BOOLEAN  DeleteRootFiles,
    IN BOOLEAN  RestorePreviousOs,
    IN BOOLEAN  ClearBootFlag
    );

//
// NEC98
//
VOID
SpSetAutoBootFlag(
    IN PDISK_REGION TargetRegion,
    IN BOOLEAN      SetBootPosision
    );

//
// NEC98
//
NTSTATUS
SppRestoreBootCode(
    VOID
    );

//
// These symbols are the Chkdsk return codes given by autochk
// when invoked with the '/s' switch.  They were duplicated from
// utils\ifsutil\inc\supera.hxx, and should be kept in sync with
// the codes listed there.
//

#define CHKDSK_EXIT_SUCCESS         0
#define CHKDSK_EXIT_ERRS_FIXED      1
#define CHKDSK_EXIT_MINOR_ERRS      2       // whether or not "/f"
#define CHKDSK_EXIT_COULD_NOT_CHK   3
#define CHKDSK_EXIT_ERRS_NOT_FIXED  3
#define CHKDSK_EXIT_COULD_NOT_FIX   3

#define AUTOFMT_EXIT_SUCCESS          0
#define AUTOFMT_EXIT_COULD_NOT_FORMAT 1

//
//  Gauge used to display progress of autochk and autofmt
//
PVOID   UserModeGauge = NULL;

//
//  This variable is used when displaying the progress bar
//  during autochk and autofmt. It indicates the disk that
//  is being autochecked or formatted.
//
ULONG   CurrentDiskIndex = 0;


//
// Seed used for generating random number for disk signature
// and pseudo GUIDs
//
ULONG RandomSeed = 17;


BOOLEAN
SppPromptOptionalAutochk(
    IN PVOID SifHandle,
    IN PWSTR MediaShortname,
    IN PWSTR DiskDevicePath
    );


extern BOOLEAN
SpGenerateNTPathName(
    IN  PDISK_REGION Region,
    IN  PWSTR        DefaultPath,
    OUT PWSTR        TargetPath
    );

VOID
SpDone(
    IN DWORD   MsgId,
    IN BOOLEAN Successful,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    Display a message indicating that we are done with setup,
    and text setup completed successfully, or that windows nt
    is not installed.  Then reboot the machine.

Arguments:

    Successful - if TRUE, then tell the user that pressing enter will
        restart the machine and continue setup.  Otherwise, tell the user
        that Windows NT is not installed.

    Wait - if FALSE, do not display a screen, just reboot immediately.
        Otherwise, wait for the user to press enter before rebooting.

Return Value:

    DOES NOT RETURN

--*/

{
    #define SECS_FOR_REBOOT 15
    ULONG MessageId;
    PWSTR p;
    LARGE_INTEGER DelayInterval;
    ULONG InputChar;
    ULONG Seconds;
    PVOID DelayGauge;


    if(Wait) {

        if (MsgId) {
            MessageId = MsgId;
        } else if(RepairWinnt) {
            MessageId = Successful ? SP_SCRN_REPAIR_SUCCESS : SP_SCRN_REPAIR_FAILURE;
        } else {
            MessageId = Successful ? SP_SCRN_TEXTSETUP_SUCCESS : SP_SCRN_TEXTSETUP_FAILURE;
        }

        SpStartScreen(MessageId,3,4,FALSE,FALSE,DEFAULT_ATTRIBUTE);

#ifdef _X86_
        SpContinueScreen(SP_SCRN_REMOVE_FLOPPY,3,1,FALSE,DEFAULT_ATTRIBUTE);
        //
        // For machines with El-Torito boot we need to tell the user
        // to remove the CD-ROM also. There are a whole bunch of different
        // possibilities: user booted from floppy but is using the CD, etc.
        // We'll only tell the user to remove the CD if he actually booted
        // from it, since otherwise we assume the machine is set up to *not*
        // boot from CD-ROM and the presence of the CD is irrelevent.
        //
        // tedm: the above logic is nice but there are plenty of machines
        // out there with broken eltorito. Thus well always tell people to
        // remove the CD if they have a CD-ROM drive.
        //
#if 0
        SpStringToLower(ArcBootDevicePath);
        if(wcsstr(ArcBootDevicePath,L")cdrom(")) {
            SpContinueScreen(SP_SCRN_ALSO_REMOVE_CD,3,0,FALSE,DEFAULT_ATTRIBUTE);
        }
// #else
        if(IoGetConfigurationInformation()->CdRomCount) {
            SpContinueScreen(SP_SCRN_ALSO_REMOVE_CD,3,0,FALSE,DEFAULT_ATTRIBUTE);
        }
#endif

#endif

        SpContinueScreen(SP_SCRN_ENTER_TO_RESTART,3,1,FALSE,DEFAULT_ATTRIBUTE);
        if(!RepairWinnt && Successful) {
            SpContinueScreen(SP_SCRN_RESTART_EXPLAIN,3,0,FALSE,DEFAULT_ATTRIBUTE);
        }

        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_ENTER_EQUALS_RESTART,0);

        DelayInterval.LowPart = -10000000;
        DelayInterval.HighPart = -1;
        Seconds = 0;

        SpFormatMessage(TemporaryBuffer,sizeof(TemporaryBuffer),SP_TEXT_SETUP_REBOOT);
        DelayGauge = SpCreateAndDisplayGauge(
            SECS_FOR_REBOOT,
            0,
            15,
            L"",
            TemporaryBuffer,
            GF_ITEMS_REMAINING,
            ATT_BG_RED | ATT_BG_INTENSE
            );
        ASSERT( DelayGauge );

        SpInputDrain();
        while (Seconds < SECS_FOR_REBOOT) {
            KeDelayExecutionThread( ExGetPreviousMode(), FALSE, &DelayInterval );
            if (SpInputIsKeyWaiting()) {
                InputChar = SpInputGetKeypress();
                if (InputChar == ASCI_CR) {
                    break;
                } else {
                    SpInputDrain();
                    break;
                }
            }
            SpTickGauge( DelayGauge );
            Seconds += 1;
        }

        SpDestroyGauge( DelayGauge );
    }


#ifdef _X86_
    //
    // restore backed up boot files for other OS on NEC98.
    //
    if (IsNEC_98) { //NEC98
        if(Nec98RestoreBootFiles && (IsFloppylessBoot || UnattendedOperation)) {

            WCHAR DevicePath[MAX_PATH];
            WCHAR PartitionPath[MAX_PATH];
            BOOLEAN RestoreBackupFiles, DeleteBackupFiles, DeleteRootDirFiles, RestorePreviousOs, ClearBootFlag;

            if(TargetRegion_Nec98) {
                wcscpy(DevicePath,
                       PartitionedDisks[TargetRegion_Nec98->DiskNumber].HardDisk->DevicePath
                       );
                swprintf(PartitionPath,
                         L"partition%lu",
                         SpPtGetOrdinal(TargetRegion_Nec98,PartitionOrdinalCurrent)
                         );
                SpConcatenatePaths(DevicePath,PartitionPath);
            }

            if(Successful){
                if(!_wcsicmp(NtBootDevicePath, DevicePath)) {
                    //
                    // case normal exit and same bootpath and targetpath.
                    //
                    RestoreBackupFiles  = FALSE;
                    DeleteBackupFiles   = TRUE;
                    DeleteRootDirFiles  = FALSE;
                    RestorePreviousOs   = FALSE;
                    ClearBootFlag       = FALSE;
                    //SpDeleteAndBackupBootFiles(FALSE,TRUE,FALSE,FALSE,FALSE);
                } else {
                    //
                    // case normal exit and different bootpath and targetpath.
                    //
                    RestoreBackupFiles  = TRUE;
                    DeleteBackupFiles   = TRUE;
                    DeleteRootDirFiles  = TRUE;
                    RestorePreviousOs   = TRUE;
                    ClearBootFlag       = FALSE;
                    //SpDeleteAndBackupBootFiles(TRUE,TRUE,TRUE,TRUE,FALSE);

                }
            } else {
                //
                // case abnormal exit
                //
                if(TargetRegion_Nec98) {
                    //
                    // after selecting target partition
                    //
                    if(!_wcsicmp(NtBootDevicePath, DevicePath)) {
                        RestoreBackupFiles  = FALSE;
                        DeleteBackupFiles   = TRUE;
                        DeleteRootDirFiles  = TRUE;
                        RestorePreviousOs   = FALSE;
                        ClearBootFlag       = TRUE;
                        //SpDeleteAndBackupBootFiles(FALSE,TRUE,TRUE,FALSE,TRUE);
                    }else{
                        RestoreBackupFiles  = TRUE;
                        DeleteBackupFiles   = TRUE;
                        DeleteRootDirFiles  = TRUE;
                        RestorePreviousOs   = TRUE;
                        ClearBootFlag       = TRUE;
                        //SpDeleteAndBackupBootFiles(TRUE,TRUE,TRUE,TRUE,TRUE);
                    }
                } else {
                    RestoreBackupFiles  = TRUE;
                    DeleteBackupFiles   = TRUE;
                    DeleteRootDirFiles  = TRUE;
                    RestorePreviousOs   = TRUE;
                    ClearBootFlag       = FALSE;
                    //SpDeleteAndBackupBootFiles(TRUE,TRUE,TRUE,TRUE,FALSE);
                }

                //
                // In the case of, winnt32 from Win95 that have separated
                // system partition or winnt from DOS, Auto boot flag will
                // set system partition not booted partition..
                //
                if(IsFloppylessBoot){
                    ClearBootFlag = TRUE;
                }
            }

            SpDeleteAndBackupBootFiles(RestoreBackupFiles,
                                       DeleteBackupFiles,
                                       DeleteRootDirFiles,
                                       RestorePreviousOs,
                                       ClearBootFlag);
        }
    } //NEC98
#endif

    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_SHUTTING_DOWN,DEFAULT_STATUS_ATTRIBUTE);

    SpShutdownSystem();

    //
    // Shouldn't get here.
    //
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: shutdown returned!\n"));

    HalReturnToFirmware(HalRebootRoutine);
}



VOID
SpFatalSifError(
    IN PVOID SifHandle,
    IN PWSTR Section,
    IN PWSTR Key,           OPTIONAL
    IN ULONG Line,
    IN ULONG ValueNumber
    )

/*++

Routine Description:

    Inform the user that a required value is missing or corrupt in
    a sif file.  Display the section, line number or key, and value
    number.

    Then reboot the machine.

Arguments:

    SifHandle - specifies the information file which is corrupt.

    Section - supplies the name of the section that is corrupt.

    Key - if specified, specifies the line in the section that is
        missing or corrupt.

    Line - if Key is not specified, then this is the line number
        within the section that is corrupt.

    ValueNumber - supplies the value number on the line that is
        missing or corrupt.

Return Value:

    DOES NOT RETURN

--*/

{
    ULONG ValidKeys[2] = { KEY_F3,0 };

    //
    // Display a message indicating that there is a fatal
    // error in the sif file.
    //
    if(Key) {

        SpStartScreen(
            SP_SCRN_FATAL_SIF_ERROR_KEY,
            3,
            HEADER_HEIGHT+3,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            ValueNumber,
            Section,
            Key
            );

    } else {

        SpStartScreen(
            SP_SCRN_FATAL_SIF_ERROR_LINE,
            3,
            HEADER_HEIGHT+3,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            ValueNumber,
            Line,
            Section
            );
    }

    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);
    SpWaitValidKey(ValidKeys,NULL,NULL);

    SpDone(0,FALSE,TRUE);
}


VOID
SpNonFatalSifError(
    IN PVOID SifHandle,
    IN PWSTR Section,
    IN PWSTR Key,           OPTIONAL
    IN ULONG Line,
    IN ULONG ValueNumber,
    IN PWSTR FileName
    )

/*++

Routine Description:

    Inform the user that a required value is missing or corrupt in
    a sif file.  Display the section, line number or key, and value
    number, along with the file name that cannot be copied.

    Then ask the user if they want to skip the file or exit Setup.

Arguments:

    SifHandle - specifies the information file which is corrupt.

    Section - supplies the name of the section that is corrupt.

    Key - if specified, specifies the line in the section that is
        missing or corrupt.

    Line - if Key is not specified, then this is the line number
        within the section that is corrupt.

    ValueNumber - supplies the value number on the line that is
        missing or corrupt.

    FileName - supplies the name of the file that cannot be copied.

Return Value:

    none (may not return if user chooses to exit Setup)

--*/

{
    ULONG ValidKeys[3] = { ASCI_ESC, KEY_F3, 0 };

    //
    // Display a message indicating that there is a fatal
    // error in the sif file.
    //
    if(Key) {

        SpStartScreen(
            SP_SCRN_NONFATAL_SIF_ERROR_KEY,
            3,
            HEADER_HEIGHT+3,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            ValueNumber,
            Section,
            Key,
            FileName
            );

    } else {

        SpStartScreen(
            SP_SCRN_NONFATAL_SIF_ERROR_LINE,
            3,
            HEADER_HEIGHT+3,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            ValueNumber,
            Line,
            Section,
            FileName
            );
    }

    SpDisplayStatusOptions(
        DEFAULT_STATUS_ATTRIBUTE,
        SP_STAT_ESC_EQUALS_SKIP_FILE,
        SP_STAT_F3_EQUALS_EXIT,
        0
        );

    switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {

        case ASCI_ESC:      // skip file

            break;

        case KEY_F3:        // exit setup

            SpConfirmExit();
    }
}


VOID
SpConfirmExit(
    VOID
    )

/*++

Routine Description:

    Confirm with the user that he really wants to exit.
    If he does, then exit, otherwise return.

    When this routine returns, the caller must repaint the entire
    client area and status area of the screen.

Arguments:

    None.

Return Value:

    MAY NOT RETURN

--*/

{
    ULONG ValidKeys[3] = { ASCI_CR, KEY_F3, 0 };
    WCHAR *p = (WCHAR *)TemporaryBuffer;
    BOOLEAN FirstLine,FirstCharOnLine;


    //
    // Don't erase the screen.
    //
    // We have to do something very funky here because the resources
    // are originally in ANSI, which doesn't have the line-draw chars.
    //
    vSpFormatMessage(
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        SP_SCRN_EXIT_CONFIRMATION,
        NULL,
        NULL
        );

    for(FirstCharOnLine=TRUE,FirstLine=TRUE; *p; p++) {

        switch(*p) {

        case L'+':
            if(FirstCharOnLine) {

                *p = SplangGetLineDrawChar(
                        FirstLine ? LineCharDoubleUpperLeft : LineCharDoubleLowerLeft
                        );

                FirstCharOnLine = FALSE;
            } else {

                *p = SplangGetLineDrawChar(
                        FirstLine ? LineCharDoubleUpperRight : LineCharDoubleLowerRight
                        );
            }
            break;

        case L'=':
            FirstCharOnLine = FALSE;
            *p = SplangGetLineDrawChar(LineCharDoubleHorizontal);
            break;

        case L'-':
            FirstCharOnLine = FALSE;
            *p = SplangGetLineDrawChar(LineCharSingleHorizontal);
            break;

        case L'|':
            FirstCharOnLine = FALSE;
            *p = SplangGetLineDrawChar(LineCharDoubleVertical);
            break;

        case L'*':
            *p = SplangGetLineDrawChar(
                      FirstCharOnLine
                    ? LineCharDoubleVerticalToSingleHorizontalRight
                    : LineCharDoubleVerticalToSingleHorizontalLeft
                    );

            FirstCharOnLine = FALSE;
            break;

        case L'\n':
            FirstCharOnLine = TRUE;
            FirstLine = FALSE;
            break;

        default:
            FirstCharOnLine = FALSE;
            break;
        }
    }

    SpDisplayText(
        TemporaryBuffer,
        wcslen(TemporaryBuffer)+1,
        TRUE,
        TRUE,
        ATT_FG_RED | ATT_BG_WHITE,
        0,
        0
        );

    SpvidClearScreenRegion(
        0,
        VideoVars.ScreenHeight-STATUS_HEIGHT,
        VideoVars.ScreenWidth,
        STATUS_HEIGHT,
        DEFAULT_STATUS_BACKGROUND
        );

    if(SpWaitValidKey(ValidKeys,NULL,NULL) == KEY_F3) {
        SpDone(0,FALSE,TRUE);
    }

    //
    // User backed out of bailing, just return to caller.
    //
}


#endif

PWSTR
SpDupStringW(
    IN PCWSTR String
    )
{
    PWSTR p;

    p = SpMemAlloc((wcslen(String)+1) * sizeof(WCHAR));
    ASSERT(p);

    wcscpy(p,String);
    return(p);
}


PSTR
SpDupString(
    IN PCSTR String
    )
{
    PUCHAR p;

    p = SpMemAlloc(strlen(String)+1);
    ASSERT(p);

    strcpy(p,String);
    return(p);
}

PWSTR
SpToUnicode(
    IN PUCHAR OemString
    )
{
    ULONG OemStringSize;
    ULONG MaxUnicodeStringSize;
    ULONG ActualUnicodeStringSize;
    PWSTR UnicodeString;

    //
    // Determine the maximum number of bytes in the oem string
    // and allocate a buffer to hold a string of that size.
    // The maximum length of the equivalent unicode string
    // is twice that number (this occurs when all oem chars
    // in the string are single-byte).
    //
    OemStringSize = strlen(OemString) + 1;

    MaxUnicodeStringSize = OemStringSize * sizeof(WCHAR);

    UnicodeString = SpMemAlloc(MaxUnicodeStringSize);
    ASSERT(UnicodeString);

    //
    // Call the conversion routine.
    //
    RtlOemToUnicodeN(
        UnicodeString,
        MaxUnicodeStringSize,
        &ActualUnicodeStringSize,
        OemString,
        OemStringSize
        );

    //
    // Reallocate the unicode string to its real size,
    // which depends on the number of doublebyte characters
    // OemString contained.
    //
    if(ActualUnicodeStringSize != MaxUnicodeStringSize) {

        UnicodeString = SpMemRealloc(UnicodeString,ActualUnicodeStringSize);
        ASSERT(UnicodeString);
    }

    return(UnicodeString);
}

PUCHAR
SpToOem(
    IN PWSTR UnicodeString
    )
{
    ULONG UnicodeStringSize;
    ULONG MaxOemStringSize;
    ULONG ActualOemStringSize;
    PUCHAR OemString;

    //
    // Allocate a buffer of maximum size to hold the oem string.
    // The maximum size would occur if all characters in the
    // unicode string being converted have doublebyte OEM equivalents.
    //
    UnicodeStringSize = (wcslen(UnicodeString)+1) * sizeof(WCHAR);

    MaxOemStringSize = UnicodeStringSize;

    OemString = SpMemAlloc(MaxOemStringSize);
    ASSERT(OemString);

    //
    // Call the conversion routine.
    //
    RtlUnicodeToOemN(
        OemString,
        MaxOemStringSize,
        &ActualOemStringSize,
        UnicodeString,
        UnicodeStringSize
        );

    //
    // Reallocate the oem string to reflect its true size,
    // which depends on the number of doublebyte characters it contains.
    //
    if(ActualOemStringSize != MaxOemStringSize) {
        OemString = SpMemRealloc(OemString,ActualOemStringSize);
        ASSERT(OemString);
    }

    return(OemString);
}


VOID
SpConcatenatePaths(
    IN OUT PWSTR  Path1,        OPTIONAL
    IN     PCWSTR Path2         OPTIONAL
    )
{
    PWSTR end;

    if (!Path1) {
        return;
    }

    //
    // Compute the location to concatenate, and also check the base path for
    // an existing backslash.
    //

    end = Path1;
    if (*end) {

        do {
            end++;
        } while (*end);

        if (end[-1] == L'\\') {
            end--;
        }
    }

    //
    // If Path2 was specified, skip over an initial backslash
    //

    if (Path2 && Path2[0] == L'\\') {
        Path2++;
    }

    //
    // Append a backslash, then Path2 if it was specified
    //

    *end++ = L'\\';

    if (Path2) {
        wcscpy (end, Path2);
    } else {
        *end = 0;
    }

    return;
}

#if !defined(SETUP_CAB_TEST_USERMODE)

VOID
SpFetchDiskSpaceRequirements(
    IN  PVOID  SifHandle,
    IN  ULONG  BytesPerCluster,
    OUT PULONG FreeKBRequired,          OPTIONAL
    OUT PULONG FreeKBRequiredSysPart    OPTIONAL
    )
{
    PWSTR p;


    if(FreeKBRequired) {
    WCHAR   ClusterSizeString[64];

        if( BytesPerCluster <= 512 ) {
            //
            // We got some miniscule cluster size.  Assume 512 byte.
            //
            wcscpy( ClusterSizeString, L"WinDirSpace512" );
        } else if( BytesPerCluster > (256 * 1024) ) {
            //
            // We got some huge cluster size.  Must be garbage, assume 32K byte.
            //
            wcscpy( ClusterSizeString, L"WinDirSpace32K" );
        } else {
            swprintf( ClusterSizeString, L"WinDirSpace%uK", BytesPerCluster/1024 );
        }

        p = SpGetSectionKeyIndex( SifHandle,
                                  SIF_DISKSPACEREQUIREMENTS,
                                  ClusterSizeString,
                                  0 );

        if(!p) {
            SpFatalSifError( SifHandle,
                             SIF_DISKSPACEREQUIREMENTS,
                             ClusterSizeString,
                             0,
                             0 );
        }

        *FreeKBRequired = (ULONG)SpStringToLong(p,NULL,10);
    }

    if(FreeKBRequiredSysPart) {

        p = SpGetSectionKeyIndex( SifHandle,
                                  SIF_DISKSPACEREQUIREMENTS,
                                  SIF_FREESYSPARTDISKSPACE,
                                  0 );

        if(!p) {
            SpFatalSifError( SifHandle,
                             SIF_DISKSPACEREQUIREMENTS,
                             SIF_FREESYSPARTDISKSPACE,
                             0,
                             0 );
        }

        *FreeKBRequiredSysPart = (ULONG)SpStringToLong(p,NULL,10);
    }
}

VOID
SpFetchTempDiskSpaceRequirements(
    IN  PVOID  SifHandle,
    IN  ULONG  BytesPerCluster,
    OUT PULONG LocalSourceKBRequired,   OPTIONAL
    OUT PULONG BootKBRequired           OPTIONAL
    )
{
    PWSTR p;
    WCHAR   ClusterSizeString[64];

    if( BytesPerCluster <= 512 ) {
        //
        // We got some miniscule cluster size.  Assume 512 byte.
        //
        wcscpy( ClusterSizeString, L"TempDirSpace512" );
    } else if( BytesPerCluster > (256 * 1024) ) {
        //
        // We got some huge cluster size.  Must be garbage, assume 32K byte.
        //
        wcscpy( ClusterSizeString, L"TempDirSpace32K" );
    } else {
        swprintf( ClusterSizeString, L"TempDirSpace%uK", BytesPerCluster/1024 );
    }

    if(LocalSourceKBRequired) {
        p = SpGetSectionKeyIndex( SifHandle,
                                  SIF_DISKSPACEREQUIREMENTS,
                                  ClusterSizeString,
                                  0 );

        if(!p) {
            SpFatalSifError( SifHandle,
                             SIF_DISKSPACEREQUIREMENTS,
                             ClusterSizeString,
                             0,
                             0 );
        }

        *LocalSourceKBRequired = ((ULONG)SpStringToLong(p,NULL,10) + 1023) / 1024;  // round up
    }

    if(BootKBRequired) {

        p = SpGetSectionKeyIndex( SifHandle,
                                  SIF_DISKSPACEREQUIREMENTS,
                                  ClusterSizeString,
                                  1 );

        if(!p) {
            SpFatalSifError( SifHandle,
                             SIF_DISKSPACEREQUIREMENTS,
                             ClusterSizeString,
                             0,
                             1 );
        }

        *BootKBRequired = ((ULONG)SpStringToLong(p,NULL,10) + 1023) / 1024;  // round up
    }
}

PDISK_REGION
SpRegionFromArcName(
    IN PWSTR                ArcName,
    IN PartitionOrdinalType OrdinalType,
    IN PDISK_REGION         PreviousMatch
    )
/*++

Routine Description:

    Given an ARC name find the region descriptor which describes the drive
    this ARC name is on.

Arguments:

    ArcName - supplies the arc name.

    OrdinalType - primary (multi) or secondary (scsi) type.

    PreviousMatch - specifies where we should begin looking.

Return Value:

    Region descriptor if one found, otherwise NULL.

--*/
{
    PDISK_REGION Region = NULL;
    PWSTR   NormalizedArcPath = NULL;
    ULONG   disk;
    PWSTR   ArcPath1,ArcPath2;
    BOOLEAN StartLooking = FALSE;
    #define BufferSize 2048

    ArcPath1 = SpMemAlloc(BufferSize);
    ArcPath2 = SpMemAlloc(BufferSize);

    if( ArcName && *ArcName ) {
        NormalizedArcPath = SpNormalizeArcPath( ArcName );
        if( NormalizedArcPath ) {

            if(!PreviousMatch) {    // then we start from the beginning
                StartLooking = TRUE;
            }

            for( disk=0; disk<HardDiskCount; disk++ ) {
                Region = PartitionedDisks[disk].PrimaryDiskRegions;
                while( Region ) {
                    if((!StartLooking) && (Region == PreviousMatch)) {
                        StartLooking = TRUE;
                    } else if(Region->PartitionedSpace && StartLooking) {
                        SpArcNameFromRegion(Region,ArcPath1,BufferSize,OrdinalType,PrimaryArcPath);
                        SpArcNameFromRegion(Region,ArcPath2,BufferSize,OrdinalType,SecondaryArcPath);
                        if(!_wcsicmp(ArcPath1, NormalizedArcPath)
                        || !_wcsicmp(ArcPath2, NormalizedArcPath)) {
                            break;
                        }
                    }
                    Region = Region->Next;
                }
                if ( Region ) {
                    break;
                }

                Region = PartitionedDisks[disk].ExtendedDiskRegions;
                while( Region ) {
                    if((!StartLooking) && (Region == PreviousMatch)) {
                        StartLooking = TRUE;
                    } else if(Region->PartitionedSpace && StartLooking) {
                        SpArcNameFromRegion(Region,ArcPath1,BufferSize,OrdinalType,PrimaryArcPath);
                        SpArcNameFromRegion(Region,ArcPath2,BufferSize,OrdinalType,SecondaryArcPath);
                        if(!_wcsicmp(ArcPath1, NormalizedArcPath)
                        || !_wcsicmp(ArcPath2, NormalizedArcPath)) {
                            break;
                        }
                    }
                    Region = Region->Next;
                }
                if ( Region ) {
                    break;
                }

            }

#if defined(REMOTE_BOOT)
            if ( (Region == NULL) && RemoteBootSetup && !RemoteInstallSetup &&
                 (PreviousMatch == NULL) ) {
                if (_wcsicmp(L"net(0)", NormalizedArcPath) == 0) {
                    Region = RemoteBootTargetRegion;
                }
            }
#endif // defined(REMOTE_BOOT)

        }
        if( NormalizedArcPath ) {
            SpMemFree( NormalizedArcPath );
        }
    }

    SpMemFree(ArcPath1);
    SpMemFree(ArcPath2);

    return( Region );
}

PDISK_REGION
SpRegionFromNtName(
    IN PWSTR                NtName,
    IN PartitionOrdinalType OrdinalType
    )
/*++

Routine Description:

    Given an Nt name find the region descriptor which describes the drive
    this NT name is on.

Arguments:

    NtName - supplies the Nt name of the desired region.

    PartitionOrdinalType - Specifies the ordinal type of the partition.

Return Value:

    Region descriptor if one found, otherwise NULL.

--*/
{
    PDISK_REGION Region = NULL;
    PWSTR p;

    //
    // Convert to arc path.
    //

    if (p = SpNtToArc(NtName, PrimaryArcPath)) {
        Region = SpRegionFromArcName(p, PartitionOrdinalCurrent, NULL);
        SpMemFree(p);
    }
    return(Region);
}

PDISK_REGION
SpRegionFromDosName(
    IN PCWSTR DosName
    )
/*++

Routine Description:

    Given a DOS name find the region descriptor which describes the drive
    this ARC name is on.

Arguments:

    ArcName - supplies the arc name.

Return Value:

    Region descriptor if one found, otherwise NULL.

--*/

{
    PDISK_REGION Region = NULL;
    ULONG        disk;
    WCHAR        DriveLetter;

    if( DosName && *DosName && *(DosName + 1) == L':' ) {
        DriveLetter = SpToUpper(*DosName);

#if defined(REMOTE_BOOT)
        if ( RemoteBootSetup && !RemoteInstallSetup && (DriveLetter == L'C') ) {
            return RemoteBootTargetRegion;
        }
#endif // defined(REMOTE_BOOT)

        for( disk=0; disk<HardDiskCount; disk++ ) {
            Region = PartitionedDisks[disk].PrimaryDiskRegions;
            while( Region ) {
                if(Region->PartitionedSpace && (Region->DriveLetter == DriveLetter)) {
                    break;
                }
                Region = Region->Next;
            }
            if ( Region ) {
                break;
            }

            Region = PartitionedDisks[disk].ExtendedDiskRegions;
            while( Region ) {
                if(Region->PartitionedSpace && (Region->DriveLetter == DriveLetter)) {
                    break;
                }
                Region = Region->Next;
            }
            if ( Region ) {
                break;
            }
        }
    }
    return( Region );
}


PDISK_REGION
SpRegionFromArcOrDosName(
    IN PWSTR                Name,
    IN PartitionOrdinalType OrdinalType,
    IN PDISK_REGION         PreviousMatch
    )
{
    PDISK_REGION Region;

    //
    // Determine if Name represents an ARC name or a DOS name and use
    // the appropriate routine to extract the region for this name.  Check
    // for the ":" character at position 2 to see if it is a DOS name.
    // If not a DOS name then assume it is an ARC name.
    //
    if(Name) {
        if(Name[0] && (Name[1] == ':')) {
            if(PreviousMatch) {
                Region = NULL;
            } else {
                Region = SpRegionFromDosName(Name);
            }
        } else {
            Region = SpRegionFromArcName(Name, OrdinalType, PreviousMatch);
        }
    } else {
        Region = NULL;
    }

    return(Region);
}


VOID
SpNtNameFromRegion(
    IN  PDISK_REGION          Region,
    OUT PWSTR                 NtPath,
    IN  ULONG                 BufferSizeBytes,
    IN  PartitionOrdinalType  OrdinalType
    )

/*++

Routine Description:

    Generate a name in the NT name space for a region.  This name can be
    in one of three forms.  For partitions, the name is always of the form

        \device\harddisk<n>\partition<m>.

    If the region is actually a DoubleSpace drive, then the name is of the form

    \device\harddisk<n>\partition<m>.<xxx> where <xxx> is the filename of
    the CVF (ie, something like dblspace.001).

    If the region is on a redirected drive, the name is of the form

        \device\lanmanredirector\<server>\<share>

Arguments:

    Region - supplies a pointer to the region descriptor for the region
        whose path is desired.

    NtPath - receives the path.

    BufferSizeBytes - specifies the size of the buffer pointed to by NtPath.
        The name will be truncated to fit in the buffer if necessary.

    OrdinalType - indicates which partition ordinal (original, on disk,
        current) to use when generating the name.

Return Value:

    None.

--*/

{
    ULONG MaxNameChars;
    ULONG NeededChars;
    WCHAR PartitionComponent[50];

#if defined(REMOTE_BOOT)
    //
    //  Handle remote boot case where target is over the network.
    //

    if (Region->DiskNumber == 0xffffffff) {
        wcscpy(NtPath,Region->TypeName);
        return;
    }
#endif // defined(REMOTE_BOOT)

    //
    // Calculate the maximum size of the name if unicode characters.
    // Leave room for a terminating nul.
    //
    MaxNameChars = (BufferSizeBytes / sizeof(WCHAR)) - 1;

    //
    // Generate the partition component of the name.
    // Note that the first letter of PartitionComponent must be upper case.
    //
    _snwprintf(
        PartitionComponent,
        (sizeof(PartitionComponent)/sizeof(WCHAR)) - 1,
        L"\\Partition%u",
        SpPtGetOrdinal(Region,OrdinalType)
        );

    //
    // Calculate the amount of buffer space needed for the path.
    //
    NeededChars = wcslen(HardDisks[Region->DiskNumber].DevicePath)
                + wcslen(PartitionComponent);

    if(Region->Filesystem == FilesystemDoubleSpace) {
        //
        // Add the size taken up by the double space cvf name.
        // This is the length of the name, plus one character
        // for the dot.
        //
        NeededChars += 8+1+3+1;  // Maximum size of a CVF file name
    }

    //
    // Even though we do something reasonable in this case,
    // really it should never happen.  If the name is truncated,
    // it won't be of any use anyway.
    //
    ASSERT(NeededChars <= MaxNameChars);

    //
    // Generate the name.
    //
    if(Region->Filesystem == FilesystemDoubleSpace) {
        _snwprintf(
            NtPath,
            MaxNameChars,
            L"%ws%ws.%ws.%03d",
            HardDisks[Region->DiskNumber].DevicePath,
            PartitionComponent,
            L"DBLSPACE",
            Region->SeqNumber
            );
    } else {
        _snwprintf(
            NtPath,
            MaxNameChars,
            L"%ws%ws",
            HardDisks[Region->DiskNumber].DevicePath,
            PartitionComponent
            );
    }
}


VOID
SpArcNameFromRegion(
    IN  PDISK_REGION         Region,
    OUT PWSTR                ArcPath,
    IN  ULONG                BufferSizeBytes,
    IN  PartitionOrdinalType OrdinalType,
    IN  ENUMARCPATHTYPE      ArcPathType
    )

/*++

Routine Description:

    Generate a name in the ARC name space for a region.

Arguments:

    Region - supplies a pointer to the region descriptor for the region
        whose path is desired.

    ArcPath - receives the path.

    BufferSizeBytes - specifies the size of the buffer pointed to by ArcPath.
        The name will be truncated to fit in the buffer if necessary.

    OrdinalType - indicates which partition ordinal (original, on disk,
        current) to use when generating the name.

    ArcPathType - Look for the primary or secondary arc path depending on this value.
                  This is meaningful for disks on x86 that are scsi but visible
                  through the bios.  The multi() style name is the 'primary' arc
                  path; the scsi() style name is the 'secondary' one.

Return Value:

    None.

--*/

{
    PWSTR p;

    //
    // Get the nt name.
    //
    SpNtNameFromRegion(Region,ArcPath,BufferSizeBytes,OrdinalType);

    //
    // Convert to arc path.
    //
    if(p = SpNtToArc(ArcPath,ArcPathType)) {
        wcsncpy(ArcPath,p,(BufferSizeBytes/sizeof(WCHAR))-1);
        SpMemFree(p);
        ArcPath[(BufferSizeBytes/sizeof(WCHAR))-1] = 0;
    } else {
        *ArcPath = 0;
    }
}


BOOLEAN
SpNtNameFromDosPath (
    IN      PCWSTR DosPath,
    OUT     PWSTR NtPath,
    IN      UINT NtPathSizeInBytes,
    IN      PartitionOrdinalType OrdinalType
    )

/*++

Routine Description:

  SpNtNameFromDosPath converts a DOS path (in x:\foo\bar format) into an NT
  name (such as \devices\harddisk0\parition1\foo\bar).

Arguments:

  DosPath - Specifies the DOS path to convert

  NtPath - Receives the NT object

  NtPathSizeInBytes - Specifies the size of NtPath

  OrdinalType - indicates which partition ordinal (original, on disk, current)
                to use when generating the name.

Return Value:

  TRUE if the path was converted, FALSE otherwise.

--*/

{
    PDISK_REGION region;

    //
    // Get region on disk for the DOS path
    //

    region = SpRegionFromDosName (DosPath);

    if (!region) {
        KdPrintEx ((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: SpNtPathFromDosPath failed to get region for %ws\n",
            DosPath
            ));

        return FALSE;
    }

    //
    // Convert region struct into an NT path.
    //

    SpNtNameFromRegion(
        region,
        NtPath,
        NtPathSizeInBytes - (wcslen (&DosPath[2]) * sizeof (WCHAR)),
        OrdinalType
        );

    SpConcatenatePaths (NtPath, &DosPath[2]);
    return TRUE;
}



BOOLEAN
SpPromptForDisk(
    IN      PWSTR    DiskDescription,
    IN OUT  PWSTR    DiskDevicePath,
    IN      PWSTR    DiskTagFile,
    IN      BOOLEAN  IgnoreDiskInDrive,
    IN      BOOLEAN  AllowEscape,
    IN      BOOLEAN  WarnMultiplePrompts,
    OUT     PBOOLEAN pRedrawFlag
    )

/*++

Routine Description:

    Prompt the user to insert a floppy disk or CD-ROM.

Arguments:

    DiskDescription - supplies a descriptive name for the disk.

    DiskDevicePath - supplies the device path for the device on
        which we want the user to insert the disk.  This should
        be a real nt device object, as opposed to a symbolic link
        (ie, use \device\floppy0, not \dosdevices\a:).

        NOTE: This path will be modified only in case of prompting
        for a CD-ROM 0 and the required disk existed on another
        CD-ROM like CD-ROM 2.


    DiskTagFile - supplies the full path (relative to the root)
        of a file whose presence on the disk indicates the presence
        of the disk we are prompting for.

    IgnoreDiskInDrive - if TRUE, the Setup will always issue at least
        one prompt.  If FALSE, Setup checks the disk in the drive
        and thus may issue 0 prompts.

    AllowEscape - if TRUE, the user can press escape to indicate
        that he wishes to cancel the operation. (This is meaningful
        only to the caller).

    WarnMultiplePrompts - if TRUE and DiskDevicePath desribes a
        floppy disk drive, then put up a little note when displaying the
        disk prompt, that we may prompt for some disks more than once.
        Users get confused when we ask them to insert disks that they
        already inserted once before.

    pRedrawFlag - if non-NULL, receives a flag indicating whether the
        screen was messed up with a disk prompt, requiring a redraw.

Return Value:

    TRUE if the requested disk is in the drive.  FALSE otherwise.
    FALSE can only be returned if AllowEscape is TRUE.

--*/

{
    WCHAR               OpenPath[MAX_PATH];
    NTSTATUS            Status;
    UNICODE_STRING      UnicodeString;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    HANDLE              Handle;
    BOOLEAN             Done = FALSE;
    BOOLEAN             rc;
    WCHAR               DriveLetter;
    ULONG               PromptId;
    ULONG               ValidKeys[4] = { KEY_F3, ASCI_CR, 0, 0 };
    BOOLEAN             TryOpen;

    //
    // Initially, assume no redraw required
    //
    if(pRedrawFlag) {
        *pRedrawFlag = FALSE;
    }

    //
    // Need to get device characteristics to see whether
    // the device is a cd, fixed disk or removable disk/floppy.
    //
    SpStringToLower(DiskDevicePath);

    if( !_wcsnicmp(DiskDevicePath,L"\\device\\cdrom",13)) {
        PromptId = SP_SCRN_CDROM_PROMPT;
        WarnMultiplePrompts = FALSE;
    } else if( !_wcsnicmp(DiskDevicePath,L"\\device\\floppy",14)) {
        PromptId = SP_SCRN_FLOPPY_PROMPT;
        DriveLetter = (WCHAR)SpStringToLong(wcsstr(DiskDevicePath,L"floppy")+6,NULL,10) + L'A';
    } else {
        //
        // Assume hard disk
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpPromptforDisk assuming %ws is hard disk, returning TRUE\n",DiskDevicePath));

        return(TRUE);
    }

    //
    // Form the complete NT pathname of the tagfile.
    //
    wcscpy(OpenPath,DiskDevicePath);
    SpConcatenatePaths(OpenPath,DiskTagFile);

    //
    // Initialize object attributes.
    //
    INIT_OBJA(&ObjectAttributes,&UnicodeString,OpenPath);


    //
    // If we're looking for a cdrom0, and there are multiple CDROM
    // drives in the machine, skip prompting the user the first time
    // and look for our tag on all the CD drives first.
    //
    if( (PromptId == SP_SCRN_CDROM_PROMPT) &&
        (IoGetConfigurationInformation()->CdRomCount > 1) &&
        (wcsstr( OpenPath, L"cdrom0" ))) {
        IgnoreDiskInDrive = FALSE;
    }

    do {
        //
        // Put up the prompt.
        //
        TryOpen = TRUE;

        if(IgnoreDiskInDrive) {
            //
            // We going to put up a prompt screen, so a redraw will be required
            //
            if(pRedrawFlag) {
                *pRedrawFlag = TRUE;
            }

            SpStartScreen(PromptId,0,0,TRUE,TRUE,DEFAULT_ATTRIBUTE,DiskDescription,DriveLetter);

            //
            // Display status options: exit, enter, and escape if specified.
            //
            SpDisplayStatusOptions(
                DEFAULT_STATUS_ATTRIBUTE,
                SP_STAT_F3_EQUALS_EXIT,
                SP_STAT_ENTER_EQUALS_CONTINUE,
                AllowEscape ? SP_STAT_ESC_EQUALS_CANCEL : 0,
                0
                );

            if(AllowEscape) {
                ValidKeys[2] = ASCI_ESC;
            }

            switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {
            case ASCI_ESC:
                rc = FALSE;
                Done = TRUE;
                TryOpen = FALSE;
                break;
            case KEY_F3:
                TryOpen = FALSE;
                SpConfirmExit();
                break;
            case ASCI_CR:
                break;
            }
        }

        //
        // Attempt to open the tagfile.
        //
        if(TryOpen) {
            //
            //  If this function was called during repair, do not clear the scree.
            //  This condition is necessary so that the screen will not
            //  blink when setup is repairing multiple files without asking the
            //  user to confirm each file.
            //
            if( !RepairWinnt ) {
                CLEAR_CLIENT_SCREEN();
            }

            SpDisplayStatusText(SP_STAT_PLEASE_WAIT,DEFAULT_STATUS_ATTRIBUTE);

            //
            // If we're looking for a cdrom0, and there are multiple CDROM
            // drives in the machine, check all of them.
            //
            if( (PromptId == SP_SCRN_CDROM_PROMPT) &&
                (IoGetConfigurationInformation()->CdRomCount > 1) &&
                (wcsstr( OpenPath, L"cdrom0" ))) {

                WCHAR  CdRomDevicePath[MAX_PATH];
                ULONG  i;

                //
                // We're looking for a CD.  We've assumed we're looking for
                // Cdrom0, but there are more than one on the system.
                //
                for( i = 0; i < IoGetConfigurationInformation()->CdRomCount; i++ ) {
                    //
                    // Modify our path, taking into account our new device.  Let's
                    // leave OpenPath alone.  Just in case we fail, we won't have to
                    // re-initialize him.
                    //
                    swprintf(CdRomDevicePath, L"\\device\\cdrom%u", i);

                    if(DiskTagFile)
                        SpConcatenatePaths(CdRomDevicePath, DiskTagFile);

                    //
                    // Initialize object attributes.
                    //
                    INIT_OBJA(&ObjectAttributes,&UnicodeString,CdRomDevicePath);

                    Status = ZwCreateFile(
                                &Handle,
                                FILE_GENERIC_READ,
                                &ObjectAttributes,
                                &IoStatusBlock,
                                NULL,
                                FILE_ATTRIBUTE_NORMAL,
                                FILE_SHARE_READ,
                                FILE_OPEN,
                                0,
                                NULL,
                                0
                                );

                    if(NT_SUCCESS(Status)) {
                        if( i > 0 ) {
                            //
                            // We found the tagfile on a different device than
                            // than where we were supposed to look.  Modify the
                            // DiskDevicePath.
                            //
                            swprintf(DiskDevicePath, L"\\device\\cdrom%u", i);

                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP:SpPromptForDisk: %ws has the requested %ws file.\n",
                                        DiskDevicePath, DiskTagFile));
                        }

                        ZwClose(Handle);

                        return( TRUE );
                    }
                }

                //
                // If we missed, we can fall through without any harm and use
                // the prompt/error code below.  But first, cover our tracks.
                //
                INIT_OBJA(&ObjectAttributes, &UnicodeString, OpenPath);
            }


            Status = ZwCreateFile(
                        &Handle,
                        FILE_GENERIC_READ,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        NULL,
                        FILE_ATTRIBUTE_NORMAL,
                        FILE_SHARE_READ,
                        FILE_OPEN,
                        0,
                        NULL,
                        0
                        );

            //
            // If we got back success, then we're done.
            //
            if(NT_SUCCESS(Status)) {

                ZwClose(Handle);
                Done = TRUE;
                rc = TRUE;

            } else {

                //
                // Handle CD-ROM error code indicating that there is no media
                // in the drive.
                //
                if((Status == STATUS_DEVICE_NOT_READY) && (PromptId == SP_SCRN_CDROM_PROMPT)) {
                    Status = STATUS_NO_MEDIA_IN_DEVICE;
                }

                //
                // If we got back something other than file not found, path not found,
                // or no media in drive, tell the user that the disk may be damaged.
                //
                if((Status != STATUS_NO_MEDIA_IN_DEVICE)
                && (Status != STATUS_OBJECT_NAME_NOT_FOUND)
                && (Status != STATUS_OBJECT_PATH_NOT_FOUND)
                && (Status != STATUS_NO_SUCH_FILE))
                {
                    SpDisplayScreen(SP_SCRN_DISK_DAMAGED,3,HEADER_HEIGHT+1);
                    SpDisplayStatusText(SP_STAT_ENTER_EQUALS_CONTINUE,DEFAULT_STATUS_ATTRIBUTE);
                    SpInputDrain();
                    while(SpInputGetKeypress() != ASCI_CR) ;
                }
            }
        }

        //
        // Set this value to true to force us to put up the prompt.
        //
        IgnoreDiskInDrive = TRUE;

    } while(!Done);

    return(rc);
}


VOID
SpGetSourceMediaInfo(
    IN  PVOID  SifHandle,
    IN  PWSTR  MediaShortName,
    OUT PWSTR *Description,     OPTIONAL
    OUT PWSTR *Tagfile,         OPTIONAL
    OUT PWSTR *Directory        OPTIONAL
    )
{
    PWSTR description,tagfile,directory;
    PWSTR SectionName;

    //
    // Look in the platform-specific section first.
    //
    SectionName = SpMakePlatformSpecificSectionName(SIF_SETUPMEDIA);

    if(SectionName && !SpGetSectionKeyExists(SifHandle,SectionName,MediaShortName)) {
        SpMemFree(SectionName);
        SectionName = SIF_SETUPMEDIA;
    }

    if(Description) {
        description = SpGetSectionKeyIndex(
                            SifHandle,
                            SectionName,
                            MediaShortName,
                            0
                            );

        if(description) {
            *Description = description;
        } else {
            SpFatalSifError(SifHandle,SectionName,MediaShortName,0,0);
        }
    }

    if(Tagfile) {
        tagfile = SpGetSectionKeyIndex(
                        SifHandle,
                        SectionName,
                        MediaShortName,
                        1
                        );

        if(tagfile) {
            *Tagfile = tagfile;
        } else {
            SpFatalSifError(SifHandle,SectionName,MediaShortName,0,1);
        }
    }

    if(Directory) {


        if (NoLs && !_wcsicmp (MediaShortName, L"1")) {

            directory = L"";

        }
        else {

            directory = SpGetSectionKeyIndex(
                            SifHandle,
                            SectionName,
                            MediaShortName,
                            3
                            );

        }

        if(directory) {
            *Directory = directory;
        } else {
            SpFatalSifError(SifHandle,SectionName,MediaShortName,0,3);
        }
    }

    if(SectionName != SIF_SETUPMEDIA) {
        SpMemFree(SectionName);
    }
}


BOOLEAN
SpPromptForSetupMedia(
    IN  PVOID  SifHandle,
    IN  PWSTR  MediaShortname,
    IN  PWSTR  DiskDevicePath
    )
{
    PWSTR Tagfile,Description;
    BOOLEAN RedrawNeeded;

    SpGetSourceMediaInfo(SifHandle,MediaShortname,&Description,&Tagfile,NULL);

    //
    // Prompt for the disk, based on the setup media type.
    //
    SpPromptForDisk(
        Description,
        DiskDevicePath,
        Tagfile,
        FALSE,          // don't ignore disk in drive
        FALSE,          // don't allow escape
        TRUE,           // warn about multiple prompts for same disk
        &RedrawNeeded
        );

    return(RedrawNeeded);
}



ULONG
SpFindStringInTable(
    IN PWSTR *StringTable,
    IN PWSTR  StringToFind
    )
{
    ULONG i;

    for(i=0; StringTable[i]; i++) {
        if(!_wcsicmp(StringTable[i],StringToFind)) {
            break;
        }
    }
    return(i);
}


PWSTR
SpGenerateCompressedName(
    IN PWSTR Filename
    )

/*++

Routine Description:

    Given a filename, generate the compressed form of the name.
    The compressed form is generated as follows:

    Look backwards for a dot.  If there is no dot, append "._" to the name.
    If there is a dot followed by 0, 1, or 2 charcaters, append "_".
    Otherwise assume there is a 3-character extension and replace the
    third character after the dot with "_".

Arguments:

    Filename - supplies filename whose compressed form is desired.

Return Value:

    Pointer to buffer containing nul-terminated compressed-form filename.
    The caller must free this buffer via SpFree().

--*/

{
   PWSTR CompressedName,p,q;

   //
   // The maximum length of the compressed filename is the length of the
   // original name plus 2 (for ._).
   //
   CompressedName = SpMemAlloc((wcslen(Filename)+3)*sizeof(WCHAR));
   wcscpy(CompressedName,Filename);

   p = wcsrchr(CompressedName,L'.');
   q = wcsrchr(CompressedName,L'\\');
   if(q < p) {

        //
        // If there are 0, 1, or 2 characters after the dot, just append
        // the underscore.  p points to the dot so include that in the length.
        //
        if(wcslen(p) < 4) {
            wcscat(CompressedName,L"_");
        } else {

            //
            // Assume there are 3 characters in the extension.  So replace
            // the final one with an underscore.
            //

            p[3] = L'_';
        }

    } else {

        //
        // No dot, just add ._.
        //

        wcscat(CompressedName,L"._");
    }

    return(CompressedName);
}

BOOLEAN
SpNonCriticalError(
    IN PVOID SifHandle,
    IN ULONG MsgId,
    IN PWSTR p1, OPTIONAL
    IN PWSTR p2  OPTIONAL
    )
/*++

Routine Description:

    This routine lets Setup display a non critical error to the user
    and ask the user whether he wants to retry the operation, skip the
    operation or exit Setup.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    MsgId     - message to display

    p1 - optional replacement string

    p2 - optional replacement string

Return Value:

    TRUE if user wants to retry the operation, FALSE otherwise.  Exit
    Setup won't return from this routine

--*/

{
    ULONG ValidKeys[4] = { ASCI_CR, ASCI_ESC, KEY_F3, 0 };

    CLEAR_CLIENT_SCREEN();
    while(1) {
        if(p1!=NULL && p2!=NULL ) {
            SpStartScreen(
                MsgId,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                p1,
                p2
                );

        }
        else if (p1!=NULL) {
            SpStartScreen(
                MsgId,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                p1
                );

        }
        else{
            SpStartScreen(
                MsgId,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE
                );

        }

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_RETRY,
            SP_STAT_ESC_EQUALS_SKIP_OPERATION,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {

        case ASCI_CR:       // retry

            return(TRUE);

        case ASCI_ESC:      // skip operation

            return(FALSE);

        case KEY_F3:        // exit setup

            SpConfirmExit();
            break;
        }
    }
}



BOOLEAN
SpNonCriticalErrorWithContinue (
    IN ULONG MsgId,
    IN PWSTR p1, OPTIONAL
    IN PWSTR p2  OPTIONAL
    )
/*++

Routine Description:

    This routine lets Setup display a non critical error to the user and ask
    the user whether he wants to ignore the failure, skip the operation or
    exit Setup.

Arguments:

    MsgId     - message to display

    p1 - optional replacement string

    p2 - optional replacement string

Return Value:

    TRUE if user wants to ignore the failure, FALSE otherwise.  Exit
    Setup won't return from this routine

--*/

{
    ULONG ValidKeys[4] = { ASCI_CR, ASCI_ESC, KEY_F3, 0 };

    CLEAR_CLIENT_SCREEN();
    while(1) {
        if(p1!=NULL && p2!=NULL ) {
            SpStartScreen(
                MsgId,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                p1,
                p2
                );

        }
        else if (p1!=NULL) {
            SpStartScreen(
                MsgId,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                p1
                );

        }
        else{
            SpStartScreen(
                MsgId,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE
                );

        }

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            SP_STAT_ESC_EQUALS_SKIP_OPERATION,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {

        case ASCI_CR:       // ignore failure

            return(TRUE);

        case ASCI_ESC:      // skip operation

            return(FALSE);

        case KEY_F3:        // exit setup

            SpConfirmExit();
            break;
        }
    }
}



VOID
SpNonCriticalErrorNoRetry (
    IN ULONG MsgId,
    IN PWSTR p1, OPTIONAL
    IN PWSTR p2  OPTIONAL
    )
/*++

Routine Description:

    This routine lets Setup display a non critical error to the user and ask
    the user whether he wants to continue exit Setup.

Arguments:

    MsgId     - message to display

    p1 - optional replacement string

    p2 - optional replacement string

Return Value:

    None.

--*/

{
    ULONG ValidKeys[3] = { ASCI_CR, KEY_F3, 0 };

    CLEAR_CLIENT_SCREEN();
    while(1) {
        if(p1!=NULL && p2!=NULL ) {
            SpStartScreen(
                MsgId,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                p1,
                p2
                );

        }
        else if (p1!=NULL) {
            SpStartScreen(
                MsgId,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                p1
                );

        }
        else{
            SpStartScreen(
                MsgId,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE
                );

        }

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {

        case ASCI_CR:       // continue

            return;

        case KEY_F3:        // exit setup

            SpConfirmExit();
            break;
        }
    }
}



PWSTR
SpDetermineSystemPartitionDirectory(
    IN PDISK_REGION SystemPartitionRegion,
    IN PWSTR        OriginalSystemPartitionDirectory OPTIONAL
    )

/*++

Routine Description:

    This routine figures out what directory to use for the hal and
    osloader on the system partition.  In the past we just used \os\nt
    but consider the case where there is a Windows NT 3.1 installation
    and a Windows NT 3.5 system sharing a system partition.  The 3.5
    installation overwrites the 3.1 hal with a 3.5 one, which  won't work
    with 3.1, and the 3.1 system is now hosed.

    For now, we will use the existing directory (in the case of an upgrade),
    or \os\winnt50.n (where 'n' is a unique digit from 0 to 999) for a
    fresh install.

Arguments:

    SystemPartitionRegion - supplies the disk region for the system partition
        to be used for the windows nt we are installing.

    OriginalSystemPartitionDirectory - if we are upgrading nt, then this
        will be the directory on the system partition that is used by
        the system we are upgrading.

Return Value:

    Directory to be used on the system partition.

--*/

{
WCHAR   ReturnPath[512];

#if defined(EFI_NVRAM_ENABLED)
    #define OS_DIRECTORY_PREFIX         L"\\EFI\\Microsoft\\WINNT50"
#else
    #define OS_DIRECTORY_PREFIX         L"\\OS\\WINNT50"
#endif


    if(ARGUMENT_PRESENT(OriginalSystemPartitionDirectory)) {

        //
        // Note that we're about to break an install under
        // certain conditions.  For example, say the user has
        // two NT4 installs, both sharing the same \os\winnt40
        // directory.  Now the user has decided to upgrade one
        // of those.  We're about to upgrade the hal, osloader, ...
        // in that winnt40 directory, which will break the
        // users secondary install that's sharing this directory.
        // This should be a rare case though, and this is
        // exactly how we behaved in NT40 and NT3.51.
        //
        wcscpy( ReturnPath, OriginalSystemPartitionDirectory );
    } else {

        //
        // We want to return os\winnt50, but we also want
        // to make sure that whatever directory we select, it's
        // unique (since this is a clean install).  Note that
        // this allows the user to have multiple NT installs,
        // with no shared files (which fixes the upgrade problem
        // described above.
        //
        if( !SpGenerateNTPathName( SystemPartitionRegion,
#if DBG
                                   OS_DIRECTORY_PREFIX L"C",    // C - for Checked
#else
                                   OS_DIRECTORY_PREFIX,
#endif
                                   ReturnPath ) ) {
            //
            // Odd...  Just default to using
            // the base directory name.
            //
            wcscpy( ReturnPath,
#if DBG
                    OS_DIRECTORY_PREFIX L"C"    // C - for Checked
#else
                    OS_DIRECTORY_PREFIX
#endif
                  );
        }
    }

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SpDetermineSystemPartitionDirectory - Generated directory name: %ws\n", ReturnPath ));
    return SpDupStringW( ReturnPath );
}


VOID
SpFindSizeOfFilesInOsWinnt(
    IN PVOID        MasterSifHandle,
    IN PDISK_REGION SystemPartition,
    IN PULONG       TotalSize
    )

/*++

Routine Description:

    This routine computes the size of of the files present on os\winnt.
    Currently these files are osloader.exe and hal.dll.
    The size computed by this function can be used to adjust the total
    required free space on the system partition.

Arguments:

    Region - supplies the disk region for the system partition.

    TotalSize - Variable that will contain the total size of the files
                in os\winnt, in number of bytes.

Return Value:

    None.

--*/

{
    ULONG               FileSize;
    ULONG               i, Count;
    PWSTR               FileName;
    NTSTATUS            Status;
    PWSTR               SystemPartitionDirectory;
    PWSTR               SystemPartitionDevice;

    *TotalSize = 0;
    SystemPartitionDirectory = SpDetermineSystemPartitionDirectory( SystemPartition,
                                                                    NULL );
    if( SystemPartitionDirectory == NULL ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to determine system partition directory \n"));
        return;
    }

    //
    // Get the device path of the system partition.
    //
    SpNtNameFromRegion(
        SystemPartition,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    SystemPartitionDevice = SpDupStringW(TemporaryBuffer);

    //
    //  Compute the size of the files that are always copied to the system
    //  partition directory. These files are listed on SIF_SYSPARTCOPYALWAYS
    //
    Count = SpCountLinesInSection(MasterSifHandle, SIF_SYSPARTCOPYALWAYS);
    for (i = 0; i < Count; i++) {
        FileName = SpGetSectionLineIndex(MasterSifHandle,SIF_SYSPARTCOPYALWAYS,i,0);
        if( FileName == NULL ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SETUP: Unable to get file name from txtsetup.sif, Section = %ls \n", SIF_SYSPARTCOPYALWAYS ));
            continue;
        }

        Status = SpGetFileSizeByName( SystemPartitionDevice,
                                      SystemPartitionDirectory,
                                      FileName,
                                      &FileSize );
        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpGetFileSizeByName() failed. File = %ls, Status = %x\n",FileName, Status ) );
            continue;
        }

        *TotalSize += FileSize;
    }
    //
    // Now compute the size of hal.dll
    //
    FileName = L"hal.dll";
    Status = SpGetFileSizeByName( SystemPartitionDevice,
                                  SystemPartitionDirectory,
                                  FileName,
                                  &FileSize );
    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpGetFileSizeByName() failed. File = %ls, Status = %x\n",FileName, Status ) );
        return;
    }
    *TotalSize += FileSize;
}


ENUMFILESRESULT
SpEnumFiles(
    IN  PCWSTR        DirName,
    IN  ENUMFILESPROC EnumFilesProc,
    OUT PULONG        ReturnData,
    IN  PVOID         p1    OPTIONAL
    )
/*++

Routine Description:

    This routine processes every file (and subdirectory) in the directory
    specified by 'DirName'. Each entry is sent to the callback function
    'EnumFilesProc' for processing.  If the callback returns TRUE, processing
    continues, otherwise processing terminates.

Arguments:

    DirName       - Supplies the directory name containing the files/subdirectories
                    to be processed.

    EnumFilesProc - Callback function to be called for each file/subdirectory.
                    The function must have the following prototype:

                    BOOLEAN EnumFilesProc(
                        IN  PWSTR,
                        IN  PFILE_BOTH_DIR_INFORMATION,
                        OUT PULONG
                        );

    ReturnData    - Pointer to the returned data.  The contents stored here
                    depend on the reason for termination (See below).

    p1 - Optional pointer, to be passed to the callback function.

Return Value:

    This function can return one of three values.  The data stored in
    'ReturnData' depends upon which value is returned:

        NormalReturn   - if the whole process completes uninterrupted
                         (ReturnData is not used)
        EnumFileError  - if an error occurs while enumerating files
                         (ReturnData contains the error code)
        CallbackReturn - if the callback returns FALSE, causing termination
                         (ReturnData contains data defined by the callback)

--*/
{
    HANDLE                     hFindFile;
    NTSTATUS                   Status;
    UNICODE_STRING             PathName;
    OBJECT_ATTRIBUTES          Obja;
    IO_STATUS_BLOCK            IoStatusBlock;
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo;
    BOOLEAN                    bStartScan;
    ENUMFILESRESULT            ret;

    //
    // Prepare to open the directory
    //
    INIT_OBJA(&Obja, &PathName, DirName);

    //
    // Open the specified directory for list access
    //
    Status = ZwOpenFile(
        &hFindFile,
        FILE_LIST_DIRECTORY | SYNCHRONIZE,
        &Obja,
        &IoStatusBlock,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
        );

    if(!NT_SUCCESS(Status)) {
        if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open directory %ws for list (%lx)\n", DirName, Status));
        }
        *ReturnData = Status;
        return EnumFileError;
    }

    DirectoryInfo = SpMemAlloc(ACTUAL_MAX_PATH * sizeof(WCHAR) + sizeof(FILE_BOTH_DIR_INFORMATION));
    if(!DirectoryInfo) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Unable to allocate memory for SpEnumFiles()\n"));
        *ReturnData = STATUS_NO_MEMORY;
        return EnumFileError;
    }

    bStartScan = TRUE;
    while(TRUE) {
        Status = ZwQueryDirectoryFile(
            hFindFile,
            NULL,
            NULL,
            NULL,
            &IoStatusBlock,
            DirectoryInfo,
            (ACTUAL_MAX_PATH * sizeof(WCHAR) + sizeof(FILE_BOTH_DIR_INFORMATION)),
            FileBothDirectoryInformation,
            TRUE,
            NULL,
            bStartScan
            );

        if(Status == STATUS_NO_MORE_FILES) {

            ret = NormalReturn;
            break;

        } else if(!NT_SUCCESS(Status)) {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Unable to query directory %ws (%lx)\n", DirName, Status));
            *ReturnData = Status;
            ret = EnumFileError;
            break;
        }


        if(bStartScan) {
            bStartScan = FALSE;
        }

        //
        // Now pass this entry off to our callback function for processing
        //
        if(!EnumFilesProc(DirName, DirectoryInfo, ReturnData, p1)) {

            ret = CallbackReturn;
            break;
        }
    }

    SpMemFree(DirectoryInfo);
    ZwClose(hFindFile);
    return ret;
}


/*typedef struct {
    PVOID           OptionalPtr;
    ENUMFILESPROC   EnumProc;
} RECURSION_DATA, *PRECURSION_DATA;

BOOLEAN
SppRecursiveEnumProc (
    IN  PCWSTR                     DirName,
    IN  PFILE_BOTH_DIR_INFORMATION FileInfo,
    OUT PULONG                     ret,
    IN  PVOID                      Param
    )
{
    PWSTR           FullPath;
    PWSTR           temp;
    ULONG           Len;
    NTSTATUS        Status;
    ULONG           ReturnData;
    ENUMFILESRESULT EnumResult;
    BOOLEAN         b = FALSE;
    PRECURSION_DATA RecursionData;

    RecursionData = (PRECURSION_DATA) Param;

    //
    // Build the full file or dir path
    //

    temp = TemporaryBuffer + (sizeof(TemporaryBuffer) / sizeof(WCHAR) / 2);
    Len = FileInfo->FileNameLength/sizeof(WCHAR);

    wcsncpy(temp,FileInfo->FileName,Len);
    temp[Len] = 0;

    wcscpy(TemporaryBuffer,DirName);
    SpConcatenatePaths(TemporaryBuffer,temp);
    FullPath = SpDupStringW(TemporaryBuffer);


    //
    // For directories, recurse
    //

    if(FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        if( (wcscmp( temp, L"." ) == 0) ||
            (wcscmp( temp, L".." ) == 0) ) {
            //
            // Skip past . and .. directories
            //
            b = TRUE;
        } else {
            //
            // Recurse through subdirectory
            //

            EnumResult = SpEnumFilesRecursive (
                                FullPath,
                                RecursionData->EnumProc,
                                &ReturnData,
                                RecursionData->OptionalPtr
                                );

            if (EnumResult != NormalReturn) {
                *ret = EnumResult;
                return FALSE;
            }
        }
    }

    //
    // Call normal enum proc for file or dir (except . or .. dirs)
    //

    if (!b) {
        b = RecursionData->EnumProc (
                                DirName,
                                FileInfo,
                                ret,
                                RecursionData->OptionalPtr
                                );
    }

    SpMemFree (FullPath);

    return b;
}*/



/*BOOLEAN
SppRecursiveEnumProcDel (
    IN  PCWSTR                     DirName,
    IN  PFILE_BOTH_DIR_INFORMATION FileInfo,
    OUT PULONG                     ret,
    IN  PVOID                      Param
    )
{*/
/*
    This function is the same as above except that it checks for reparse points. The reason
    we have 2 seperate functions rather than one function and an extra parameter is so that
    we don't have the Reparse point check overhead for other recursive processing like copying
    file. Given the no. of files this could be overhead. Also this way we don't hack the
    recursive directory search algo as well as reduce stack overhead in a recursive operation.

*/
/*

    HANDLE                     hFixed;
    NTSTATUS                   Status;
    UNICODE_STRING             PathName;
    OBJECT_ATTRIBUTES          Obja;
    IO_STATUS_BLOCK            IoStatusBlock;
    FILE_FS_DEVICE_INFORMATION DeviceInfo;

    PWSTR           FullPath;
    PWSTR           temp;
    ULONG           Len;
    ULONG           ReturnData;
    ENUMFILESRESULT EnumResult;
    BOOLEAN         b = FALSE;
    BOOLEAN         IsLink = FALSE;
    PRECURSION_DATA RecursionData;

    RecursionData = (PRECURSION_DATA) Param;

    //
    // Build the full file or dir path
    //

    temp = TemporaryBuffer + (sizeof(TemporaryBuffer) / sizeof(WCHAR) / 2);
    Len = FileInfo->FileNameLength/sizeof(WCHAR);

    wcsncpy(temp,FileInfo->FileName,Len);
    temp[Len] = 0;

    wcscpy(TemporaryBuffer,DirName);
    SpConcatenatePaths(TemporaryBuffer,temp);
    FullPath = SpDupStringW(TemporaryBuffer);


    //
    // For directories, recurse
    //

    if(FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        if( (wcscmp( temp, L"." ) == 0) ||
            (wcscmp( temp, L".." ) == 0) ) {
            //
            // Skip past . and .. directories
            //
            b = TRUE;
        } else {
            //
            // Recurse through subdirectory
            //


            //
            //   Look for mount point and delete right away to avoid cycle complications
            //

            if( FileInfo->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT )
                IsLink = TRUE;



            if( !IsLink ){

                EnumResult = SpEnumFilesRecursiveDel (
                                    FullPath,
                                    RecursionData->EnumProc,
                                    &ReturnData,
                                    RecursionData->OptionalPtr
                                    );

                if (EnumResult != NormalReturn) {
                    *ret = EnumResult;
                    return FALSE;
                }
            }
        }
    }

    //
    // Call normal enum proc for file or dir (except . or .. dirs)
    //

    if (!b) {
        b = RecursionData->EnumProc (
                                DirName,
                                FileInfo,
                                ret,
                                RecursionData->OptionalPtr
                                );
    }

    SpMemFree (FullPath);

    return b;
}*/

#define LONGEST_NT_PATH_LENGTH      512 // RtlGetLongestNtPathLength always return just 277(MAX_PATH+UNC_PREFIX_LENGTH)
                                        // longest NT path is 32000 character.
#define MAX_DEPTH      -1

typedef struct
{
    HANDLE hHandle;
    int    Index;
    PFILE_BOTH_DIR_INFORMATION FileInfo;
}ENUM_LEVEL, *PENUM_LEVEL;

BOOLEAN 
SpEnumFilesInline(
    IN  PCWSTR pPath, 
    IN  ENUMFILESPROC EnumFilesProc, 
    OUT PULONG ReturnData, 
    IN  PVOID   p1                      OPTIONAL, 
    IN  BOOLEAN bExcludeRepasePointDirs OPTIONAL, 
    IN  LONG    DirectoriesMaxDepth, 
    IN  BOOLEAN bEnumerateDirFirst      OPTIONAL
    )
{
    PENUM_LEVEL         level = NULL;
    int                 MaxLevelNumber = 0;
    UNICODE_STRING      UnicodeString;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    PFILE_BOTH_DIR_INFORMATION FileInfo = NULL;
    int                 SizeOfFileInfo;
    NTSTATUS            Status;
    PWSTR               Path = NULL;
    PWSTR               SubDir = NULL;
    int                 index;
    int                 i;
    BOOLEAN             FirstQuery;
    ENUMFILESRESULT     enumResult = NormalReturn;


    if(!pPath || wcslen(pPath) >= LONGEST_NT_PATH_LENGTH){
        return EnumFileError;
    }

    __try{
        Path = (PWSTR)SpMemAlloc(LONGEST_NT_PATH_LENGTH * sizeof(WCHAR));
        if(!Path){
            if(ReturnData){
                *ReturnData = STATUS_NO_MEMORY;
            }
            enumResult = EnumFileError;
            __leave;
        }

        SubDir = (PWSTR)SpMemAlloc(LONGEST_NT_PATH_LENGTH * sizeof(WCHAR));
        if(!SubDir){
            if(ReturnData){
                *ReturnData = STATUS_NO_MEMORY;
            }
            enumResult = EnumFileError;
            __leave;
        }
        
        SizeOfFileInfo = LONGEST_NT_PATH_LENGTH * sizeof(WCHAR) + sizeof(FILE_BOTH_DIR_INFORMATION);
        FileInfo = (PFILE_BOTH_DIR_INFORMATION)SpMemAlloc(SizeOfFileInfo);
        if(!FileInfo){
            if(ReturnData){
                *ReturnData = STATUS_NO_MEMORY;
            }
            enumResult = EnumFileError;
            __leave;
        }
    
        MaxLevelNumber = LONGEST_NT_PATH_LENGTH / 2;
        level = (PENUM_LEVEL)SpMemAlloc(sizeof(level[0]) * MaxLevelNumber);
        if(!level){
            if(ReturnData){
                *ReturnData = STATUS_NO_MEMORY;
            }
            enumResult = EnumFileError;
            __leave;
        }
        memset(level, 0, sizeof(level[0]) * MaxLevelNumber);
        
        wcscpy(Path, pPath);

        index = wcslen(Path) - 1;
        if('\\' != Path[index] && '//' != Path[index]){
            Path[index + 1] = '\\';
            Path[index + 2] = '\0';
        }
    
        for(index = 0; index >= 0;){
            INIT_OBJA(&ObjectAttributes, &UnicodeString, Path);
            level[index].Index = wcslen(Path);
            if(!bEnumerateDirFirst){
                level[index].FileInfo = (PFILE_BOTH_DIR_INFORMATION)SpMemAlloc(SizeOfFileInfo);
                if(!level[index].FileInfo){
                    if(ReturnData){
                        *ReturnData = STATUS_NO_MEMORY;
                    }
                    enumResult = EnumFileError;
                    __leave;
                }
            }
            
            Status = ZwOpenFile(&level[index].hHandle,
                                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                                &ObjectAttributes,
                                &IoStatusBlock,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                FILE_DIRECTORY_FILE |
                                    FILE_SYNCHRONOUS_IO_NONALERT |
                                    FILE_OPEN_FOR_BACKUP_INTENT
                                );
            if(!NT_SUCCESS(Status)){
                level[index].hHandle = NULL;
                if(ReturnData){
                    *ReturnData = Status;
                }
                enumResult = EnumFileError;
                if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {
                    KdPrintEx((
                        DPFLTR_SETUP_ID, 
                        DPFLTR_ERROR_LEVEL, 
                        "SETUP:SpEnumFilesInline, Failed to open %ws folder for list access - status 0x%08X.\n", 
                        Path, 
                        Status));
                }
                __leave;//index--;
            }
            else{
                FirstQuery = TRUE;
            }

            for(;;)
            {
                for(; index >= 0; index--){
                    Status = ZwQueryDirectoryFile(level[index].hHandle, 
                                                  NULL,                           // no event to signal
                                                  NULL,                           // no apc routine
                                                  NULL,                           // no apc context
                                                  &IoStatusBlock, 
                                                  FileInfo, 
                                                  SizeOfFileInfo - sizeof(WCHAR), // leave room for terminating nul
                                                  FileBothDirectoryInformation, 
                                                  TRUE,                           // want single entry
                                                  NULL,                           // get 'em all
                                                  FirstQuery);
                    FirstQuery = FALSE;
                    if(NT_SUCCESS(Status)){
                        break;
                    }
                    else{
                        if(STATUS_NO_MORE_FILES != Status){
                            if(ReturnData){
                                *ReturnData = Status;
                            }
                            KdPrintEx((
                                DPFLTR_SETUP_ID, 
                                DPFLTR_ERROR_LEVEL, 
                                "SETUP:SpEnumFilesInline, Failed to query %d level - status 0x%08X.\n", 
                                index, 
                                Status));
                            enumResult = EnumFileError;
                            __leave;
                        }
                        else{
                            if(!bEnumerateDirFirst){
                                if(index > 0){
                                    wcsncpy(SubDir, Path, level[index - 1].Index);
                                    SubDir[level[index - 1].Index] = '\0';
                                
                                    if(!EnumFilesProc(SubDir, level[index - 1].FileInfo, ReturnData, p1)){
                                        enumResult = CallbackReturn;
                                        KdPrintEx((
                                            DPFLTR_SETUP_ID, 
                                            DPFLTR_ERROR_LEVEL, 
                                            "SETUP:SpEnumFilesInline, Callback returned FALSE on %ws\\%ws\n", 
                                            SubDir, 
                                            level[index - 1].FileInfo->FileName));
                                        __leave;
                                    }
                                }
                            }
                        }
                    }
                
                    ZwClose(level[index].hHandle);
                    level[index].hHandle = NULL;
                }

                if(index < 0){
                    break;
                }

                FileInfo->FileName[FileInfo->FileNameLength / sizeof(WCHAR)] = '\0';

                wcscpy(&Path[level[index].Index], FileInfo->FileName);
                
                wcsncpy(SubDir, Path, level[index].Index);
                SubDir[level[index].Index] = '\0';

                if(!(FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY)){
                    if(!EnumFilesProc(SubDir, FileInfo, ReturnData, p1)){
                        enumResult = CallbackReturn;
                        KdPrintEx((
                            DPFLTR_SETUP_ID, 
                            DPFLTR_ERROR_LEVEL, 
                            "SETUP:SpEnumFilesInline, Callback returned FALSE on %ws\\%ws\n", 
                            SubDir, 
                            FileInfo->FileName));
                        __leave;
                    }
                }
                else{
                    if(wcscmp(FileInfo->FileName, L".") && 
                       wcscmp(FileInfo->FileName, L"..")){
                        wcscat(Path, L"\\");
                        if(bEnumerateDirFirst){
                            if(!EnumFilesProc(SubDir, FileInfo, ReturnData, p1)){
                                enumResult = CallbackReturn;
                                KdPrintEx((
                                    DPFLTR_SETUP_ID, 
                                    DPFLTR_ERROR_LEVEL, 
                                    "SETUP:SpEnumFilesInline, Callback returned FALSE on %ws\\%ws\n", 
                                    SubDir, 
                                    FileInfo->FileName));
                                __leave;
                            }
                        }
                        else{
                            ASSERT(level[index].FileInfo);
                            memcpy(level[index].FileInfo, FileInfo, SizeOfFileInfo);
                        }
                        
                        if(DirectoriesMaxDepth >= 0 && index >= DirectoriesMaxDepth){
                            continue;
                        }
                        if(bExcludeRepasePointDirs && FileInfo->FileAttributes&FILE_ATTRIBUTE_REPARSE_POINT){
                            continue;
                        }

                        index++;
                        break;
                    }
                }
            }
        }
        
        enumResult = NormalReturn;
    }
    __finally{
        if(level){
            for(i = 0; i < MaxLevelNumber; i++){
                if(level[i].hHandle){
                    ZwClose(level[i].hHandle);
                }
                if(level[i].FileInfo){
                    SpMemFree(level[i].FileInfo);
                }
            }
            SpMemFree(level);
        }
        if(SubDir){
            SpMemFree(SubDir);
        }
        if(Path){
            SpMemFree(Path);
        }
        if(FileInfo){
            SpMemFree(FileInfo);
        }
    }

    return enumResult;
}

ENUMFILESRESULT
SpEnumFilesRecursive (
    IN  PWSTR         DirName,
    IN  ENUMFILESPROC EnumFilesProc,
    OUT PULONG        ReturnData,
    IN  PVOID         p1    OPTIONAL
    )
{
    return SpEnumFilesInline(DirName, 
                             EnumFilesProc, 
                             ReturnData, 
                             p1, 
                             FALSE, 
                             MAX_DEPTH, 
                             FALSE);
/*
    RECURSION_DATA RecursionData;

    RecursionData.OptionalPtr = p1;
    RecursionData.EnumProc    = EnumFilesProc;

    return SpEnumFiles (
                DirName,
                SppRecursiveEnumProc,
                ReturnData,
                &RecursionData
                );
                */
}

/*typedef struct {
    ULONG           MaxDepth;
    ULONG           CurrentDepth;
    PVOID           OptionalPtr;
    ENUMFILESPROC   EnumProc;
} RECURSION_LIMITED_DATA, *PRECURSION_LIMITED_DATA;

BOOLEAN
SppRecursiveLimitedEnumProc (
    IN  PCWSTR                     DirName,
    IN  PFILE_BOTH_DIR_INFORMATION FileInfo,
    OUT PULONG                     ret,
    IN  PVOID                      Param
    )*/
/*++

Routine Description:

    This routine is the same as SppRecursiveEnumProc with the added feature
    that it supports recursion depth limiting.  The recursion context is passed
    in via the Param argument and is of type RECURSION_LIMITED_DATA.

Arguments:

    DirName     - Supplies the directory name containing the current directory of the 
                  File/Dir currently being enumerated.

    FileInfo    - File/Dir info about the current file being enumerated

    ret         - Pointer to the returned data.  The contents stored here
                    depend on the reason for termination:
                
                        NormalReturn   - if the whole process completes uninterrupted
                                         (ReturnData is not used)
                        EnumFileError  - if an error occurs while enumerating files
                                         (ReturnData contains the error code)
                        CallbackReturn - if the callback returns FALSE, causing termination
                                         (ReturnData contains data defined by the callback)

    Param       - Recursion context

Return Value:

    TRUE    - continue processing 
    
    otherwise, FALSE

--*/
/*{
    PWSTR           FullPath;
    PWSTR           temp;
    ULONG           Len;
    NTSTATUS        Status;
    ULONG           ReturnData;
    ENUMFILESRESULT EnumResult;
    BOOLEAN         b = FALSE;
    PRECURSION_LIMITED_DATA RecursionData;

    RecursionData = (PRECURSION_LIMITED_DATA) Param;

    //
    // If we are at our max recursion depth, bail out
    //
    // Note: using >= allows us to look at files at the MaxDepth,
    //       but not recurse into directories beyond MaxDepth.
    //
    if (RecursionData->CurrentDepth >= RecursionData->MaxDepth) {
        *ret = NormalReturn;
        return TRUE;
    }

    //
    // Build the full file or dir path
    //

    temp = TemporaryBuffer + (sizeof(TemporaryBuffer) / sizeof(WCHAR) / 2);
    Len = FileInfo->FileNameLength/sizeof(WCHAR);

    wcsncpy(temp,FileInfo->FileName,Len);
    temp[Len] = 0;

    wcscpy(TemporaryBuffer,DirName);
    SpConcatenatePaths(TemporaryBuffer,temp);
    FullPath = SpDupStringW(TemporaryBuffer);

    //
    // if the length of FullPath >= MAX_PATH, then we might
    // have encountered a corrupt region of the file system.
    // Hence, ensure that the length of FullPath is < MAX_PATH-1.
    // (allow for null termination when comparing to MAX_PATH)
    //
    if (wcslen(FullPath) >= MAX_PATH) {
        
        SpMemFree(FullPath);
        
        //
        // skip this entry and continue scanning
        //
        // (Since this routine is used by Bootcfg in the recover console,
        //  this behavior is helpful because it allows us to continue scanning
        //  and perhaps find a valid Windows install - which would then allow
        //  us to possibly do more recovery work...)
        //
        *ret = NormalReturn;
        return TRUE;
    
    }

    //
    // For directories, recurse
    //

    if(FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        if( (wcscmp( temp, L"." ) == 0) ||
            (wcscmp( temp, L".." ) == 0) ) {
            //
            // Skip past . and .. directories
            //
            b = TRUE;
        } else {
            //
            // Recurse through subdirectory
            //
            
            RecursionData->CurrentDepth++;

            EnumResult = SpEnumFilesRecursiveLimited (
                                FullPath,
                                RecursionData->EnumProc,
                                RecursionData->MaxDepth,
                                RecursionData->CurrentDepth,
                                &ReturnData,
                                RecursionData->OptionalPtr
                                );
            
            RecursionData->CurrentDepth--;

            if (EnumResult != NormalReturn) {
                *ret = EnumResult;
                return FALSE;
            }
        }
    }

    //
    // Call normal enum proc for file or dir (except . or .. dirs)
    //

    if (!b) {
        b = RecursionData->EnumProc (
                                DirName,
                                FileInfo,
                                ret,
                                RecursionData->OptionalPtr
                                );
    }

    SpMemFree (FullPath);

    return b;
}*/

ENUMFILESRESULT
SpEnumFilesRecursiveLimited (
    IN  PWSTR         DirName,
    IN  ENUMFILESPROC EnumFilesProc,
    IN  ULONG         MaxDepth,
    IN  ULONG         CurrentDepth,
    OUT PULONG        ReturnData,
    IN  PVOID         p1    OPTIONAL
    )
/*++

Routine Description:

    This routine processes every file (and subdirectory) in the directory
    specified by 'DirName'. Each entry is sent to the callback function
    'EnumFilesProc' for processing.  If the callback returns TRUE, processing
    continues, otherwise processing terminates.

    This routine employs recursion depth limiting.

Arguments:

    DirName       - Supplies the directory name containing the files/subdirectories
                    to be processed.

    EnumFilesProc - Callback function to be called for each file/subdirectory.
                    The function must have the following prototype:

                    BOOLEAN EnumFilesProc(
                        IN  PWSTR,
                        IN  PFILE_BOTH_DIR_INFORMATION,
                        OUT PULONG
                        );

    MaxDepth      - The maximum depth the recursion will be allowed to go.
                    
                    Note: During the recursion process, the directories will be
                          recursed until CurrentDepth == MaxDepth.  Files at 
                          MaxDepth + 1 will be processed via EnumProc, but any
                          directories below MaxDepth will not be visited.
                                                            
                                                      
    CurrentDepth  - The depth the recursion is currently at.
                
                    Note: When first calling this routine, CurrentDepth should be 0.
                          This argument exists because this routine is the core of the
                          recursion and is called by SppRecursiveLimitedEnumProc.  Each
                          time SppRecursiveLimitedEnumProc calls this function, it passes
                          the current recursion depth.

    ReturnData    - Pointer to the returned data.  The contents stored here
                    depend on the reason for termination (See below).

    p1 - Optional pointer, to be passed to the callback function.

Return Value:

    This function can return one of three values.  The data stored in
    'ReturnData' depends upon which value is returned:

        NormalReturn   - if the whole process completes uninterrupted
                         (ReturnData is not used)
        EnumFileError  - if an error occurs while enumerating files
                         (ReturnData contains the error code)
        CallbackReturn - if the callback returns FALSE, causing termination
                         (ReturnData contains data defined by the callback)

--*/
{
/*    RECURSION_LIMITED_DATA RecursionData;

    RecursionData.OptionalPtr   = p1;
    RecursionData.EnumProc      = EnumFilesProc;
    RecursionData.MaxDepth      = MaxDepth;
    RecursionData.CurrentDepth  = CurrentDepth;

    return SpEnumFiles (
                DirName,
                SppRecursiveLimitedEnumProc,
                ReturnData,
                &RecursionData
                );*/

    return SpEnumFilesInline(DirName, 
                             EnumFilesProc, 
                             ReturnData, 
                             p1, 
                             FALSE, 
                             MaxDepth, 
                             FALSE);
}

ENUMFILESRESULT
SpEnumFilesRecursiveDel (
    IN  PWSTR         DirName,
    IN  ENUMFILESPROC EnumFilesProc,
    OUT PULONG        ReturnData,
    IN  PVOID         p1    OPTIONAL
    )
//
// This function is the same as SpEnumFilesRecursive except that
// it handles reparse points too and avoids name cycles and calls
// SppRecursiveEnumProcDel instead
//

{
    return SpEnumFilesInline(DirName, 
                             EnumFilesProc, 
                             ReturnData, 
                             p1, 
                             TRUE, 
                             MAX_DEPTH, 
                             FALSE);

/*    RECURSION_DATA RecursionData;

    RecursionData.OptionalPtr = p1;
    RecursionData.EnumProc    = EnumFilesProc;

    return SpEnumFiles (
                DirName,
                SppRecursiveEnumProcDel,
                ReturnData,
                &RecursionData
                );*/
}


VOID
SpFatalKbdError(
    IN ULONG MessageId,
    ...
    )

/*++

Routine Description:

    Inform the user that a keyboard problem (specified by MessageId)
    prevents setup from continuing.  Since we can't prompt the user
    to press a key to reboot, we just go into an infinite loop until
    they power-cycle the computer.

Arguments:

    MessageId - Message ID for keyboard error message to display

    ...       - Supply arguments for insertion/substitution into the message text.

Return Value:

    DOES NOT RETURN

--*/

{
    va_list arglist;

    //
    // Display a message indicating that a keyboard
    // error prevents Setup from continuing.
    //
    CLEAR_CLIENT_SCREEN();

    va_start(arglist, MessageId);

    vSpDisplayFormattedMessage(
            MessageId,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            3,
            HEADER_HEIGHT+3,
            arglist
            );

    va_end(arglist);

    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, SP_STAT_KBD_HARD_REBOOT, 0);

    while(TRUE);    // Loop forever
}

VOID
SpFatalError(
    IN ULONG MessageId,
    ...
    )

/*++

Routine Description:

    Inform the user of a blocking problem. Then reboot.

Arguments:

    MessageId - Message ID for keyboard error message to display

    ...       - Supply arguments for insertion/substitution into the message text.

Return Value:

    DOES NOT RETURN

--*/

{
    va_list arglist;

    CLEAR_CLIENT_SCREEN();

    va_start(arglist, MessageId);

    vSpDisplayFormattedMessage(
            MessageId,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            3,
            HEADER_HEIGHT+3,
            arglist
            );

    va_end(arglist);

    SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE, SP_STAT_F3_EQUALS_REBOOT, 0);

    SpInputDrain();
    while( SpInputGetKeypress() != KEY_F3 );
    SpDone( 0, FALSE, TRUE );
}

VOID
SpRunAutochkOnNtAndSystemPartitions(
    IN HANDLE       MasterSifHandle,
    IN PDISK_REGION WinntPartitionRegion,
    IN PDISK_REGION SystemPartitionRegion,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice,
    IN PWSTR        TargetPath
    )

/*++

Routine Description:

    Run autochk on the NT and System partitions.

    We always invoke autochk.exe for both the winnt and system
    partitions.  However under some conditions we pass flags that
    cause it to run only if the dirty bit is set.  Running only when
    the dirty bit is set is referred to below as a "light check" wheras
    running regardless of the state of the dirty bit is the "heavy check."

    If this is repair, run the heavy check in all cases on both partitions.

    If this is express setup or unattended operation, run light check on
    ntfs partitions and heavy check on fat ones.

    Otherwise (attended custom setup), ask the user.

Arguments:

    MasterSifHandle         - Handle to txtsetup.sif.

    WinntPartitionRegion    - Pointer to the structure that describes the
                              NT partition.

    SystemPartitionRegion   - Pointer to the structure that describes the
                              system partition.

    SetupSourceDevicePath   - NT device path where autochk.exe is located

    DirectoryOnSourceDevice - Directory on that device where autochk.exe is located


Return Value:

    None.

--*/

{
    PWSTR           MediaShortName;
    PWSTR           MediaDirectory;
    PWSTR           AutochkPath;
    ULONG           AutochkStatus;
    WCHAR           DriveLetterString[3] = L"?:";
    NTSTATUS        Status;
    ULONG ValidKeys[3] = { ASCI_CR, ASCI_ESC, 0 };
    PWSTR           WinntPartition, SystemPartition;
    ULONG           WinntPartIndex, SystemPartIndex, i;
    PWSTR           AutochkPartition[2];
    PWSTR           AutochkType[2];
    LARGE_INTEGER   DelayTime;
    PWSTR           HeavyCheck = L"-t -p";  // -t causes autochk to send messages (like % complete)
    PWSTR           LightCheck = L"-t";     // to the setup driver
    BOOLEAN         RunAutochkForRepair;
    BOOLEAN         MultiplePartitions = TRUE, RebootRequired = FALSE;
    ULONG           InputChar;

    //
    // We first need to determine if either the system partition
    // or winnt partition also contains the directory from which
    // autochk is being run. If so, then we want to run autochk on that
    // partition last.  This is done so that no further access to
    // that partition will be necessary should a reboot be required.
    //
    // First, get the device path of the nt partition and system partition.
    //
#if defined(REMOTE_BOOT)
    // Note that during a remote boot setup, there will be no winnt partition,
    // and if the machine is diskless there will be no system partition.
    //
#endif // defined(REMOTE_BOOT)
    if (WinntPartitionRegion != NULL) {
        SpNtNameFromRegion(
            WinntPartitionRegion,
            TemporaryBuffer,
            sizeof(TemporaryBuffer),
            PartitionOrdinalCurrent
            );
        WinntPartition = SpDupStringW(TemporaryBuffer);
    } else {
        WinntPartition = NULL;
    }

    if (SystemPartitionRegion != NULL) {
        SpNtNameFromRegion(
            SystemPartitionRegion,
            TemporaryBuffer,
            sizeof(TemporaryBuffer),
            PartitionOrdinalCurrent
            );
        SystemPartition = SpDupStringW(TemporaryBuffer);
    } else {
        SystemPartition = NULL;
    }

    //
    // Skip autocheck if not partitions names could
    // be formed
    //
    if (!WinntPartition && !SystemPartition) {
        return;
    }

#if defined(REMOTE_BOOT)
    if (!RemoteBootSetup) {
#endif // defined(REMOTE_BOOT)
        if (WinntPartition) {
        if (SystemPartition && !_wcsicmp(WinntPartition, SystemPartition)) {
                SystemPartIndex = WinntPartIndex = 0;
                MultiplePartitions = FALSE;
            } else if(!_wcsicmp(WinntPartition, SetupSourceDevicePath)) {
                WinntPartIndex = 1;
                SystemPartIndex = 0;
            } else {
                WinntPartIndex = 0;
                SystemPartIndex = 1;
            }
        } else {
            WinntPartIndex = 1;
            SystemPartIndex = 0;
        }

        AutochkPartition[WinntPartIndex] = WinntPartition;

        if(MultiplePartitions) {
            AutochkPartition[SystemPartIndex] = SystemPartition;
        }

#if defined(REMOTE_BOOT)
    } else {

        //
        // Remote boot system - only check the system partition.
        //

        SystemPartIndex = WinntPartIndex = 0;
        AutochkPartition[SystemPartIndex] = SystemPartition;
        MultiplePartitions = FALSE;
    }
#endif // defined(REMOTE_BOOT)

    //
    // For repair or Disaster Recovery, we run the heavy check in all cases.    // @@ mtp
    //
    if( RepairWinnt || SpDrEnabled() ) {

        AutochkType[WinntPartIndex] = HeavyCheck;
        if(MultiplePartitions) {
            AutochkType[SystemPartIndex] = HeavyCheck;
        }

    } else {


#if defined(REMOTE_BOOT)
        //
        // On a diskless remote boot system, there will be no system partition.
        //

        if (SystemPartitionRegion != NULL)
#endif // defined(REMOTE_BOOT)
        {
            AutochkType[SystemPartIndex] = (SystemPartitionRegion->Filesystem == FilesystemNtfs) ? LightCheck : HeavyCheck;
        }

        //
        // If MultiplePartitions is FALSE, then the WinntPartition is the same
        // as the SystemPartition, so we are not going to autochk the WinntPartition.
        //
#if defined(REMOTE_BOOT)
        // MultiplePartitions will also be FALSE if this is a remote boot system,
        // in which case the WinntPartition is remote. Again, we are not going
        // to autochk the WinntPartition.
        //
#endif // defined(REMOTE_BOOT)

        if (MultiplePartitions) {
            ASSERT(WinntPartitionRegion != NULL);
            ASSERT(WinntPartition != NULL);
            AutochkType[WinntPartIndex] = (WinntPartitionRegion->Filesystem == FilesystemNtfs) ? LightCheck : HeavyCheck;
        }
    }

    CLEAR_CLIENT_SCREEN();

    //
    //  Prepare to run autochk
    //
    MediaShortName = SpLookUpValueForFile(
                        MasterSifHandle,
                        L"autochk.exe",
                        INDEX_WHICHMEDIA,
                        TRUE
                        );

    //
    // Prompt the user to insert the setup media.  If we're repairing,
    // then we don't want to force the user to have the setup media
    // (there's certain things they can do without it), so we give them
    // a slightly different prompt, that allows them to press ESC and
    // not run autochk.
    //
    if (!Win9xRollback) {
        if(RepairWinnt) {
            RunAutochkForRepair = SppPromptOptionalAutochk(
                                        MasterSifHandle,
                                        MediaShortName,
                                        SetupSourceDevicePath
                                        );

            if(!RunAutochkForRepair) {
                SpMemFree( WinntPartition );
                SpMemFree( SystemPartition );
                CLEAR_CLIENT_SCREEN();
                return;
            }
        } else {
            SpPromptForSetupMedia(
                MasterSifHandle,
                MediaShortName,
                SetupSourceDevicePath
                );
        }

        SpGetSourceMediaInfo(MasterSifHandle,MediaShortName,NULL,NULL,&MediaDirectory);

        wcscpy( TemporaryBuffer, SetupSourceDevicePath );
        SpConcatenatePaths( TemporaryBuffer, DirectoryOnSourceDevice );
        SpConcatenatePaths( TemporaryBuffer, MediaDirectory );
        SpConcatenatePaths( TemporaryBuffer, L"autochk.exe" );
        AutochkPath = SpDupStringW( TemporaryBuffer );
    } else {
        //
        // Win9x rollback -- autochk.exe is in $win_nt$.~bt\i386
        //

        wcscpy (TemporaryBuffer, NtBootDevicePath);
        SpConcatenatePaths (TemporaryBuffer, DirectoryOnBootDevice);
        SpConcatenatePaths (TemporaryBuffer, L"i386\\autochk.exe");
        AutochkPath = SpDupStringW (TemporaryBuffer);
    }

    //
    // Run autochk on the partition(s)
    //
    CLEAR_CLIENT_SCREEN();
    SpDisplayScreen( SP_SCRN_RUNNING_AUTOCHK, 3, 4 );

    //
    //  Create the gauge.
    //  Since we want only one progress bar displayed to the user
    //  while autochk is running, we initialize the range of the
    //  gauge based on the number of partitions to be examined.
    //  If the system and NT partitions are the same, the we set
    //  the range as 100. Otherwise, we set the range at 200.
    //  Note that on the multiple partitions case, 50% of the gauge
    //  will be used to display the progress for each disk.
    //  The IOCTL that calls SpFillGauge(), will have to adjust the
    //  amount of the gauge to be filled, based on the partition that
    //  is currently being examined.
    //
    UserModeGauge = SpCreateAndDisplayGauge( (MultiplePartitions)? 200 : 100,
                                             0,
                                             15,
                                             L"",
                                             NULL,
                                             GF_PERCENTAGE,
                                             0
                                           );       //          Setup is checking disk(s)...
                                                    //

    for(i = 0; i < (ULONG)(MultiplePartitions ? 2 : 1); i++) {
        //
        //  Display message informing that autocheck is being run
        //
        if (AutochkPartition[i] != NULL) {
            DriveLetterString[0] = (i == WinntPartIndex) ?
                                   WinntPartitionRegion->DriveLetter :
                                   SystemPartitionRegion->DriveLetter;

            SpDisplayStatusText( SP_STAT_CHECKING_DRIVE,
                                 DEFAULT_STATUS_ATTRIBUTE,
                                 DriveLetterString );

            if(!i) {
                //
                // Cheesy kludge below to wait 4 seconds before invoking autochk.exe
                // the first time. This was necessary because the cache manager delays
                // in closing the handle to system.log (opened by NT registry APIs when
                // we find NT's to upgrade)
                //
                DelayTime.HighPart = -1;
                DelayTime.LowPart  = (ULONG)-40000000;
                KeDelayExecutionThread (KernelMode, FALSE, &DelayTime);
            }

            //
            //  Tell the IOCTL which disk is being examined.
            //
            CurrentDiskIndex = i;

            AutochkStatus = 0;
            Status = SpExecuteImage( AutochkPath,
                                     &AutochkStatus,
                                     2,
                                     AutochkType[i],
                                     AutochkPartition[i]
                                     );


            if( NT_SUCCESS( Status ) ) {

                switch(AutochkStatus) {

                    case CHKDSK_EXIT_COULD_NOT_FIX :
                        //
                        //  Inform that the partition has an unrecoverable error
                        //
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: autochk.exe failed on %ls. ReturnCode = %x \n", AutochkPartition[i], AutochkStatus ));
                        SpStartScreen( SP_SCRN_FATAL_ERROR_AUTOCHK_FAILED,
                                       3,
                                       HEADER_HEIGHT+1,
                                       FALSE,
                                       FALSE,
                                       DEFAULT_ATTRIBUTE,
                                       DriveLetterString );

                        SpDisplayStatusOptions( DEFAULT_STATUS_ATTRIBUTE,
                                                SP_STAT_F3_EQUALS_EXIT,
                                                0 );
                        SpInputDrain();
                        while( SpInputGetKeypress() != KEY_F3 );

                        //
                        // The third arg of SpDone is TRUE to provide 15
                        // seconds before reboot. We don't want this during
                        // an uninstall.
                        //

                        SpDone( 0, FALSE, !Win9xRollback );

                    case CHKDSK_EXIT_ERRS_FIXED :
                        //
                        // Autochk was able to repair the partition, but will require a reboot.
                        //
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: autochk requires a reboot for %ls.\n", AutochkPartition[i]));
                        RebootRequired = TRUE;

                    default :
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Ran autochk.exe on %ls. \n", AutochkPartition[i] ));
                }

            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to run autochk.exe on %ls. Status = %x \n", AutochkPartition[i], Status ));
                SpStartScreen( Win9xRollback ? SP_SCRN_CANT_RUN_AUTOCHK_UNINSTALL : SP_SCRN_CANT_RUN_AUTOCHK,
                               3,
                               HEADER_HEIGHT+1,
                               FALSE,
                               FALSE,
                               DEFAULT_ATTRIBUTE,
                               DriveLetterString );

                SpDisplayStatusOptions( DEFAULT_STATUS_ATTRIBUTE,
                                        SP_STAT_ENTER_EQUALS_CONTINUE,
                                        0 );
                SpInputDrain();

                do {
                    InputChar = SpInputGetKeypress();
                } while (InputChar != ASCI_CR && (!Win9xRollback || InputChar != KEY_F3));

                if (InputChar == KEY_F3) {
                    SpDone (0, FALSE, FALSE);
                }

                //
                //  Put the screen back the way it was
                //
                CLEAR_CLIENT_SCREEN();
                SpDisplayScreen( SP_SCRN_RUNNING_AUTOCHK, 3, 4 );
                if( UserModeGauge != NULL ) {
                    SpDrawGauge( UserModeGauge );
                }
            }
        }
    }

    //
    //  The gauge is no longer needed.
    //
    SpDestroyGauge( UserModeGauge );
    UserModeGauge = NULL;

    if (WinntPartition != NULL) {
        SpMemFree( WinntPartition );
    }
    if (SystemPartition != NULL) {
        SpMemFree( SystemPartition );
    }
    SpMemFree( AutochkPath );

    CLEAR_CLIENT_SCREEN();

    if (RebootRequired) {
#ifdef _X86_
        //
        // If we are trying to cancel a setup that is in-progress, make sure
        // that the textmode option is removed from boot.ini, but the textmode
        // option that has /rollback is left in-place.
        //

        if (Win9xRollback) {
            SpRemoveExtraBootIniEntry();
            SpAddRollbackBootOption (TRUE);
            SpFlushBootVars();
        }
#endif

        if (TargetPath && TargetPath[0] && NTUpgrade == UpgradeFull) {
          SpSetUpgradeStatus(
           WinntPartitionRegion,
           TargetPath,
           UpgradeNotInProgress
           );
        }

        //
        // If this is not an unattended case let the user see the
        // error message and confirm it.
        //
        if (!UnattendedOperation) {
          SpStartScreen( SP_SCRN_AUTOCHK_REQUIRES_REBOOT,
                         3,
                         HEADER_HEIGHT+1,
                         TRUE,
                         TRUE,
                         DEFAULT_ATTRIBUTE );

          SpDisplayStatusOptions( DEFAULT_STATUS_ATTRIBUTE,
                                  SP_STAT_F3_EQUALS_REBOOT,
                                  0 );
          SpInputDrain();
          while( SpInputGetKeypress() != KEY_F3 );
        }

        if (IsNEC_98) { //NEC98
            Nec98RestoreBootFiles = FALSE;
        } //NEC98

        SpDone(SP_SCRN_AUTOCHK_REQUIRES_REBOOT, FALSE, TRUE );
    }
}


BOOLEAN
SppPromptOptionalAutochk(
    IN PVOID SifHandle,
    IN PWSTR MediaShortname,
    IN PWSTR DiskDevicePath
    )
{
    PWSTR             Tagfile,Description,Directory;
    NTSTATUS          Status;
    UNICODE_STRING    UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK   IoStatusBlock;
    HANDLE            Handle;
    ULONG ValidKeys[4] = { KEY_F3, ASCI_CR, ASCI_ESC, 0 };
    BOOLEAN           AutochkChosen;


    SpGetSourceMediaInfo(SifHandle,MediaShortname,&Description,&Tagfile,&Directory);

    //
    // We initially see if the media is in the drive, and if not, we give
    // the user a message with the option of skipping autochk.  We
    // do this now, so that the user doesn't simply get a disk prompt with
    // a Cancel option (Cancel what?  Autochk?  The whole repair process?)
    //
    wcscpy(TemporaryBuffer, DiskDevicePath);
    SpConcatenatePaths(TemporaryBuffer, Tagfile);
    INIT_OBJA(&ObjectAttributes, &UnicodeString, TemporaryBuffer);
    Status = ZwCreateFile(
                &Handle,
                FILE_GENERIC_READ,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ,
                FILE_OPEN,
                0,
                NULL,
                0
                );

    //
    // If we got back success, then we're done.
    //
    if(NT_SUCCESS(Status)) {
        ZwClose(Handle);
        return TRUE;
    }

    //
    // The media isn't currently in the drive, so give the
    // user the option of whether to run autochk or not.
    //
    AutochkChosen = FALSE;
    do {
        SpDisplayScreen(SP_SCRN_AUTOCHK_OPTION, 3, HEADER_HEIGHT+1);

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_F3_EQUALS_EXIT,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            SP_STAT_ESC_EQUALS_CANCEL,
            0
            );

        switch(SpWaitValidKey(ValidKeys, NULL, NULL)) {
        case ASCI_ESC:
            return FALSE;
        case KEY_F3:
            SpConfirmExit();
            break;
        case ASCI_CR:
            AutochkChosen = TRUE;
        }
    } while(!AutochkChosen);

    //
    // Prompt for the disk, based on the setup media type.
    //
    return(SpPromptForDisk(Description, DiskDevicePath, Tagfile, FALSE, TRUE, TRUE, NULL));
}


PWSTR
SpMakePlatformSpecificSectionName(
    IN PWSTR SectionName
    )
{
    PWSTR p;

    p = SpMemAlloc((wcslen(SectionName) + wcslen(PlatformExtension) + 1) * sizeof(WCHAR));

    wcscpy(p,SectionName);
    wcscat(p,PlatformExtension);

    return(p);
}

NTSTATUS
SpRunAutoFormat(
    IN HANDLE       MasterSifHandle,
    IN PWSTR        RegionDescription,
    IN PDISK_REGION PartitionRegion,
    IN ULONG        FilesystemType,
    IN BOOLEAN      QuickFormat,
    IN DWORD        ClusterSize,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice
    )

/*++

Routine Description:

    Run autofmt to format a partition.

Arguments:

    MasterSifHandle         - Handle to txtsetup.sif.

    RegionDescription       - The region description, as displayed to the
                              user, in the screen with the various partitions
                              for the user to choose.

    PartitionRegion         - Pointer to the structure that describes the
                              partition to be formatted.

    FilesystemType          - Indicates the file system to use.

    ClusterSize             - File system cluster-size to use. (0=>Use default)

    SetupSourceDevicePath   - NT device path where autochk.exe is located

    DirectoryOnSourceDevice - Directory on that device where autochk.exe is located

Return Value:

    None.

--*/

{
    PWSTR           MediaShortName;
    PWSTR           MediaDirectory;
    PWSTR           AutofmtPath;
    ULONG           AutofmtStatus;
    NTSTATUS        Status;
    WCHAR           AutofmtArgument[32];
    PWSTR           PartitionPath;
    LARGE_INTEGER   DelayTime;
    ULONG           PartitionOrdinal;


    ASSERT( ( FilesystemType == FilesystemNtfs ) ||
            ( FilesystemType == FilesystemFat32) ||
            ( FilesystemType == FilesystemFat  ) );

    //
    // Make SURE it's not partition0!  The results of formatting partition0
    // are so disasterous that this warrants a special check.
    //
    PartitionOrdinal = SpPtGetOrdinal(PartitionRegion,PartitionOrdinalCurrent);

    if(!PartitionOrdinal) {
        SpBugCheck(
            SETUP_BUGCHECK_PARTITION,
            PARTITIONBUG_B,
            PartitionRegion->DiskNumber,
            0
            );
    }

    //
    // Get the device path of the partition to format
    //
    SpNtNameFromRegion(
        PartitionRegion,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );
    PartitionPath = SpDupStringW(TemporaryBuffer);

    CLEAR_CLIENT_SCREEN();

    //
    //  Prepair to run autofmt
    //
    MediaShortName = SpLookUpValueForFile(
                        MasterSifHandle,
                        L"autofmt.exe",
                        INDEX_WHICHMEDIA,
                        TRUE
                        );

    //
    // Prompt the user to insert the setup media.
    //
    SpPromptForSetupMedia(
        MasterSifHandle,
        MediaShortName,
        SetupSourceDevicePath
        );

    SpGetSourceMediaInfo(MasterSifHandle,MediaShortName,NULL,NULL,&MediaDirectory);

    wcscpy( TemporaryBuffer, SetupSourceDevicePath );
    SpConcatenatePaths( TemporaryBuffer, DirectoryOnSourceDevice );
    SpConcatenatePaths( TemporaryBuffer, MediaDirectory );
    SpConcatenatePaths( TemporaryBuffer, L"autofmt.exe" );
    AutofmtPath = SpDupStringW( TemporaryBuffer );

    //
    // Run autofmt on the partition
    //

    CLEAR_CLIENT_SCREEN();
    //
    // Put up a screen indicating what we are doing.
    //
    SpStartScreen(
        SP_SCRN_SETUP_IS_FORMATTING,
        0,
        HEADER_HEIGHT + 3,
        TRUE,
        FALSE,
        DEFAULT_ATTRIBUTE,
        RegionDescription,
        HardDisks[PartitionRegion->DiskNumber].Description
        );

    SpvidClearScreenRegion(
        0,
        VideoVars.ScreenHeight-STATUS_HEIGHT,
        VideoVars.ScreenWidth,
        STATUS_HEIGHT,
        DEFAULT_STATUS_BACKGROUND
        );

    //
    //  Create and display the (global) gauge.
    //
    SpFormatMessage(
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        SP_TEXT_SETUP_IS_FORMATTING
        );

    UserModeGauge = SpCreateAndDisplayGauge( 100,
                                             0,
                                             VideoVars.ScreenHeight - STATUS_HEIGHT - (3*GAUGE_HEIGHT/2),
                                             TemporaryBuffer,
                                             NULL,
                                             GF_PERCENTAGE,
                                             0
                                             );


    //
    // Cheesy kludge below to wait 4 seconds before invoking autochk.exe
    // the first time. This was necessary because the cache manager delays
    // in closing the handle to system.log (opened by NT registry APIs when
    // we find NT's to upgrade)
    //
    DelayTime.HighPart = -1;
    DelayTime.LowPart  = (ULONG)-40000000;
    KeDelayExecutionThread (KernelMode, FALSE, &DelayTime);

    AutofmtStatus = AUTOFMT_EXIT_SUCCESS;

    if (ClusterSize > 0) {
        swprintf(AutofmtArgument, L"/a:%lu /t ", ClusterSize);
    }
    else {
        wcscpy(AutofmtArgument, L"/t ");
    }

    if (QuickFormat) {
        wcscat(AutofmtArgument, L"/Q ");
    }

    switch(FilesystemType) {
    case FilesystemNtfs:
        wcscat(AutofmtArgument, L"/fs:ntfs");
        break;
    case FilesystemFat32:
        wcscat(AutofmtArgument, L"/fs:fat32");
        break;
    case FilesystemFat:
    default:
        wcscat(AutofmtArgument, L"/fs:fat");
        break;
    }



    //
    //  Tell the IOCTL which disk is being examined.
    //
    CurrentDiskIndex = 0;

    //
    // For quick format, emulate as though progress is
    // being made
    //
    if (UserModeGauge && QuickFormat) {
        SpFillGauge(UserModeGauge, 20);
    }

    //
    //  Note that autofmt requires that the partition path comes
    //  before the autofmt switches
    //
    Status = SpExecuteImage( AutofmtPath,
                             &AutofmtStatus,
                             2,
                             PartitionPath,
                             AutofmtArgument
                           );

    //
    // For quick format, emulate as though progress is
    // being made
    //
    if (UserModeGauge && QuickFormat) {
        SpFillGauge(UserModeGauge, 100);

        //
        // wait for a second so that user can
        // see it filled
        //
        DelayTime.HighPart = -1;
        DelayTime.LowPart  = (ULONG)-10000000;
        KeDelayExecutionThread (KernelMode, FALSE, &DelayTime);
    }

    //
    //  Destroy the gauge
    //
    SpDestroyGauge( UserModeGauge );
    UserModeGauge = NULL;

    if( NT_SUCCESS( Status ) ) {
        //
        //  autofmt.exe was run.
        //  Find out if the partition was formatted.
        //
        KdPrint(("SETUP:AutoFormat Status : %lx\n", AutofmtStatus));

        switch(AutofmtStatus) {
            case AUTOFMT_EXIT_SUCCESS:
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Ran autofmt.exe on %ls. \n", PartitionPath ));
#ifdef _X86_
                if (!IsNEC_98) { //NEC98
                    //
                    // If we formatted C:, then clear the previous OS entry
                    // in boot.ini.
                    //
                    if(PartitionRegion == SpPtValidSystemPartition()) {
                        *OldSystemLine = '\0';
                    }
                } //NEC98
#endif
                break;

            // case AUTOFMT_EXIT_COULD_NOT_FORMAT :
            default:
                //
                //  autofmt was unable to format the partition
                //
                Status =  STATUS_UNSUCCESSFUL;
                break;

        }

    } else {
        //
        //  autofmt.exe didn't get executed.
        //  Display a fatal error message.
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to run autofmt.exe on %ls. Status = %x \n", PartitionPath, Status ));
        SpStartScreen( SP_SCRN_CANT_RUN_AUTOFMT,
                       3,
                       HEADER_HEIGHT+1,
                       FALSE,
                       FALSE,
                       DEFAULT_ATTRIBUTE );

        SpDisplayStatusOptions( DEFAULT_STATUS_ATTRIBUTE,
                                SP_STAT_F3_EQUALS_EXIT,
                                0 );
        SpInputDrain();
        while( SpInputGetKeypress() != KEY_F3 );
        SpDone( 0, FALSE, TRUE );
    }

    //
    //  Do the cleanup and return
    //
    SpMemFree( PartitionPath );
    SpMemFree( AutofmtPath );

    CLEAR_CLIENT_SCREEN();
    return( Status );
}

//
// NEC98
//

//
// On floppyless setup if user have canceled setup or setup be stoped by error
// occured,previous OS cann't boot to be written boot code and boot loader.
//

NTSTATUS
SpDeleteAndBackupBootFiles(
    BOOLEAN    RestoreBackupFiles,
    BOOLEAN    DeleteBackupFiles,
    BOOLEAN    DeleteRootDirFiles,
    BOOLEAN    RestorePreviousOs,
    BOOLEAN    ClearBootFlag
    )
{

    #define WINNT_BAK  L"$WIN_NT$.~BU"
    #define ATTR_RHS (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_ARCHIVE)

    PWSTR DeleteRootFiles[] = {L"ntdetect.com",L"$ldr$",L"boot.ini",L"txtsetup.sif",L"ntldr",L"bootfont.bin",L"bootsect.dos"};
    PWSTR RestoreFiles[] = {L"boot.ini",L"ntdetect.com",L"ntldr"};
    WCHAR DevicePath[256],SourceFileName[256],TargetFileName[256],TmpFileName[256];
    UCHAR i;
    NTSTATUS status=0;
    PWSTR SetupSourceDevicePath,DirectoryOnSetupSource;

    SpdInitialize();

#ifdef _X86_

    if(RestorePreviousOs){

        //
        // IF bootsect.dos exist in boot path, setup restore previous OS bootcode.
        //
        // NOTE:When you modefied boot.ini for multi boot function if it is same NT boot partition
        //      and partition where is exiting bootsect.dos , setup restore DOS bootcode.
        //      Therefore NT on this partition is not boot forever.
        //
        SppRestoreBootCode();
    }

#endif

    if(DeleteRootDirFiles){

        //
        // Delete floppy less boot files in root.
        //

        for(i=0 ; i < ELEMENT_COUNT(DeleteRootFiles); i++) {

            wcscpy(TargetFileName,NtBootDevicePath);
            SpDeleteFile(TargetFileName, DeleteRootFiles[i], NULL);

        }


#ifdef _X86_
        //
        // If we're on an x86, but it's *NOT* an ARC machine,
        // then there's no need for the arc loaders to be
        // present.
        //
        if( !SpIsArc() ) {
            wcscpy(TargetFileName,NtBootDevicePath);
            SpDeleteFile(TargetFileName, L"arcsetup.exe", NULL);
            wcscpy(TargetFileName,NtBootDevicePath);
            SpDeleteFile(TargetFileName, L"arcldr.exe", NULL);
        }
#endif

    }

    //
    // If \BOOTSECT.NEC exists, restore it to \BOOTSECT.DOS.
    // BTY, winnt32 makes \BOOTSECT.DOS even if boot sector is for NT.(NEC98 only)
    //
    wcscpy(SourceFileName,NtBootDevicePath);
    SpConcatenatePaths(SourceFileName,L"\\");
    SpConcatenatePaths(SourceFileName,L"bootsect.nec");
    wcscpy(TargetFileName,NtBootDevicePath);
    SpConcatenatePaths(TargetFileName,L"\\");
    SpConcatenatePaths(TargetFileName,L"bootsect.dos");

    if(SpFileExists(SourceFileName,FALSE)) {

        if(SpFileExists(TargetFileName,FALSE)) {
            SpDeleteFile( TargetFileName, NULL, NULL);
        }
        SpRenameFile( SourceFileName, TargetFileName, FALSE );
    }

    if(RestoreBackupFiles){

        //
        // Restore previous NT files to root form $WIN_NT$.~BU.
        //
        for(i=0 ; i < ELEMENT_COUNT(RestoreFiles) ;i++) {

            wcscpy(SourceFileName,NtBootDevicePath);
            SpConcatenatePaths(SourceFileName,WINNT_BAK);
            SpConcatenatePaths(SourceFileName,RestoreFiles[i]);
            wcscpy(TargetFileName,NtBootDevicePath);
            SpConcatenatePaths(TargetFileName,L"\\");
            SpConcatenatePaths(TargetFileName,RestoreFiles[i]);

            if( SpFileExists( SourceFileName, FALSE ) ) {
                SpCopyFileUsingNames(SourceFileName,TargetFileName,ATTR_RHS,0L);
            }

        }

        //
        // Force uncompressd to "\ntldr".
        //
        wcscpy(TargetFileName,NtBootDevicePath);
        SpConcatenatePaths(TargetFileName,L"\\");
        SpConcatenatePaths(TargetFileName,L"ntldr");

        if( SpFileExists( TargetFileName, FALSE ) ) {
            SpVerifyNoCompression(TargetFileName);
        }

    }

    if(DeleteBackupFiles){

        //
        // Delete files in $WIN_NT$.~BU.
        //
        for(i=0 ; i < ELEMENT_COUNT(RestoreFiles); i++) {

            wcscpy(TargetFileName,NtBootDevicePath);
            SpConcatenatePaths(TargetFileName,WINNT_BAK);
            SpDeleteFile(TargetFileName, RestoreFiles[i], NULL);


        }

        //
        // Delete $WIN_NT$.~BU
        //
        wcscpy(TargetFileName,NtBootDevicePath);
        SpConcatenatePaths(TargetFileName,WINNT_BAK);
        if( SpFileExists( TargetFileName, FALSE ) ) {
            SpDeleteFile(TargetFileName, NULL, NULL);
        }

#if NEC_TEST //0
        //
        // It's not available to delete $WIN_NT.~BT, but we will try
        // to delete $WIN_NT$.~LS, Because Nec98 will boot back after F.3
        //
        if (WinntSetup && !WinntFromCd && !RemoteBootSetup && LocalSourceRegion) {
            SpGetWinntParams(&SetupSourceDevicePath,&DirectoryOnSetupSource);
            wcscpy(TargetFileName,SetupSourceDevicePath);
            SpConcatenatePaths(TargetFileName,DirectoryOnSetupSource);
            if( SpFileExists( TargetFileName, FALSE ) ) {
                SpDeleteFile(TargetFileName, NULL, NULL);
            }
        }
#endif //NEC_TEST
    }

    //if(ClearBootFlag && TmpTargetRegion){
    if(ClearBootFlag){

        SpSetAutoBootFlag(NULL,FALSE);
    }

    SpdTerminate();
    return(status);
}


BOOLEAN
SpFindServiceInList(
    IN PWSTR ServiceName
    )
{
    LIST_ENTRY *Next;
    PSERVICE_ENTRY ServiceEntry;


    Next = SpServiceList.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&SpServiceList) {
        ServiceEntry = CONTAINING_RECORD( Next, SERVICE_ENTRY, Next );
        Next = ServiceEntry->Next.Flink;
        if (_wcsicmp( ServiceEntry->ServiceName, ServiceName ) == 0) {
            return TRUE;
        }
    }

    return FALSE;
}


BOOLEAN
AddServiceToList(
    IN PWSTR ServiceName
    )
{
    PSERVICE_ENTRY ServiceEntry;


    if (SpFindServiceInList(ServiceName)) {
        return TRUE;
    }

    ServiceEntry = (PSERVICE_ENTRY) SpMemAlloc( sizeof(SERVICE_ENTRY) );
    if (ServiceEntry == NULL) {
        return FALSE;
    }

    ServiceEntry->ServiceName = SpDupStringW( ServiceName );
    InsertTailList( &SpServiceList, &ServiceEntry->Next );

    return TRUE;
}


BOOLEAN
SpFindServiceDependencies(
    IN HANDLE ServicesHandle,
    IN PWSTR ServiceName,
    IN PWSTR ServiceDependName
    )
{
    NTSTATUS Status;
    HANDLE KeyHandle;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    PKEY_VALUE_PARTIAL_INFORMATION ValInfo;
    ULONG ResultLength;
    PWSTR SubkeyName;
    PWSTR s;
    BOOLEAN rVal = FALSE;


    INIT_OBJA( &Obja, &UnicodeString, ServiceName );
    Obja.RootDirectory = ServicesHandle;
    Status = ZwOpenKey( &KeyHandle, KEY_READ, &Obja );
    if (!NT_SUCCESS(Status)) {
        return rVal;
    }

    ValInfo = (PKEY_VALUE_PARTIAL_INFORMATION) TemporaryBuffer;
    RtlInitUnicodeString( &UnicodeString, L"DependOnService");

    Status = ZwQueryValueKey(
        KeyHandle,
        &UnicodeString,
        KeyValuePartialInformation,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        &ResultLength
        );
    if (!NT_SUCCESS(Status)) {
        ZwClose( KeyHandle );
        return rVal;
    }

    if (ValInfo->Type == REG_MULTI_SZ) {
        s = (PWSTR)ValInfo->Data;
        while (s && *s) {
            SubkeyName = SpDupStringW( s );

            if (SubkeyName) {
                if (_wcsicmp( ServiceDependName, SubkeyName ) == 0) {
                    if (AddServiceToList( ServiceName )) {
                        rVal = TRUE;
                    }
                } else if (SpFindServiceDependencies( ServicesHandle, SubkeyName, ServiceDependName )) {
                    if (AddServiceToList( ServiceName )) {
                        rVal = TRUE;
                    }
                }
                SpMemFree( SubkeyName );
            }

            s = s + ((wcslen(s)+1)*sizeof(WCHAR));
        }
    } else if (ValInfo->Type == REG_SZ) {
        SubkeyName = SpDupStringW( (PWSTR)ValInfo->Data );
        if (_wcsicmp( ServiceDependName, SubkeyName ) == 0) {
            if (AddServiceToList( ServiceName )) {
                rVal = TRUE;
            }
        } else if (SpFindServiceDependencies( ServicesHandle, SubkeyName, ServiceDependName )) {
            if (AddServiceToList( ServiceName )) {
                rVal = TRUE;
            }
        }
        SpMemFree( SubkeyName );
    }

    ZwClose( KeyHandle );
    return rVal;
}



NTSTATUS
SpGetServiceTree(
    IN PWSTR ServiceName
    )
{
    NTSTATUS Status;
    HANDLE KeyHandle = NULL;
    HANDLE ServicesHandle = NULL;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    ULONG ResultLength;
    ULONG SubKeyIndex;
    PKEY_BASIC_INFORMATION KeyInfo;
    PWSTR SubkeyName;


    InitializeListHead( &SpServiceList );

    RtlInitUnicodeString( &UnicodeString, REGKEY_SERVICES );
    InitializeObjectAttributes( &Obja, &UnicodeString, OBJ_CASE_INSENSITIVE, NULL, NULL );

    Status = ZwOpenKey( &ServicesHandle, KEY_READ, &Obja );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    for (SubKeyIndex=0,KeyInfo=(PKEY_BASIC_INFORMATION)TemporaryBuffer;
         NT_SUCCESS( ZwEnumerateKey( ServicesHandle,
                        SubKeyIndex,
                        KeyBasicInformation,
                        TemporaryBuffer,
                        sizeof(TemporaryBuffer), &ResultLength ) );
         SubKeyIndex++
         )
    {
        KeyInfo->Name[KeyInfo->NameLength/sizeof(WCHAR)] = 0;
        SubkeyName = SpDupStringW(KeyInfo->Name);

        if (SubkeyName) {
            SpFindServiceDependencies( ServicesHandle,
                SubkeyName,
                ServiceName );

            SpMemFree( SubkeyName );
        }
    }

    ZwClose( ServicesHandle );

    return Status;
}


VOID
SpCreateNewGuid(
    IN GUID *Guid
    )
/*++

Routine Description:

    Creates a new pseudo GUID

Arguments:

    Guid    -   Place holder for the new pseudo

Return Value:

    None.

--*/
{
    if (Guid) {
        LARGE_INTEGER   Time;
        ULONG Random1 = RtlRandom(&RandomSeed);
        ULONG Random2 = RtlRandom(&RandomSeed);

        //
        // Get system time
        //
        KeQuerySystemTime(&Time);

        RtlZeroMemory(Guid, sizeof(GUID));

        //
        // First 8 bytes is system time
        //
        RtlCopyMemory(Guid, &(Time.QuadPart), sizeof(Time.QuadPart));

        //
        // Next 8 bytes are two random numbers
        //
        RtlCopyMemory(Guid->Data4, &Random1, sizeof(ULONG));

        RtlCopyMemory(((PCHAR)Guid->Data4) + sizeof(ULONG),
            &Random2, sizeof(ULONG));

#if 0
        {
            WCHAR   GuidStr[256];

            KdPrintEx(( DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                "SETUP: SpCreateNewGuid : %ws\n",
                SpPtGuidToString(Guid, GuidStr)));
        }
#endif
    }
}


NTSTATUS
RegisterSetupProgressCallback(
    IN TM_SETUP_PROGRESS_CALLBACK Callback,
    IN PVOID Context
    )

/*++

Routine Description:

    Registers the given callback function to
    post setup progress events

Arguments:

    Callback - The callback function

    Context  - Caller specified, context for the callback function
               that needs to sent with each event

Return Value:

    STATUS_SUCCESS if successful, otherwise appropriate
    error code.

--*/
{
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;

    if (Callback) {
        if (ProgressSubscribersCount < MAX_SETUP_PROGRESS_SUBSCRIBERS) {
            ProgressSubscribers[ProgressSubscribersCount].Callback = Callback;
            ProgressSubscribers[ProgressSubscribersCount].Context = Context;
            ProgressSubscribersCount++;
            Callback(CallbackEvent, CallbackInitialize, Context, NULL);
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_NO_MEMORY;
        }
    }

    return Status;
}

NTSTATUS
DeregisterSetupProgressCallback(
    IN TM_SETUP_PROGRESS_CALLBACK Callback,
    IN PVOID Context
    )
/*++

Routine Description:

    Deregisters the given callback function to
    quit posting setup progress events

Arguments:

    Callback - The callback function

    Context  - Caller specified, context for the callback function
               that needs to sent with each event

Return Value:

    STATUS_SUCCESS if successful, otherwise appropriate
    error code.

--*/
{
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;

    if (Callback) {
        ULONG Index;

        for (Index = 0; Index < MAX_SETUP_PROGRESS_SUBSCRIBERS; Index++) {
            if (ProgressSubscribers[Index].Callback == Callback) {
                ProgressSubscribers[Index].Callback = NULL;
                ProgressSubscribers[Index].Context = NULL;
                ProgressSubscribersCount--;
                Index++;

                //
                // Compact the array
                //
                while ((Index < MAX_SETUP_PROGRESS_SUBSCRIBERS) &&
                       (ProgressSubscribers[Index].Callback)) {
                    ProgressSubscribers[Index - 1] = ProgressSubscribers[Index];
                    Index++;
                }

                //
                // Indicate the callback is going away
                //
                Callback(CallbackEvent, CallbackDeInitialize, Context, NULL);

                Status = STATUS_SUCCESS;

                break;
            }
        }
    }

    return Status;
}

VOID
SendSetupProgressEvent(
    IN TM_SETUP_MAJOR_EVENT MajorEvent,
    IN TM_SETUP_MINOR_EVENT MinorEvent,
    IN PVOID EventData
    )
/*++

Routine Description:

    Post the specified events and the associated data to
    all the registered parties interested in setup progress
    events.

Arguments:

    MajorEvent - Setup progress major event

    MinorEvent - Setup progress minor event, w.r.t to the
                 major event type

    EventData  - The associated event data with the specified
                 Major and Minor event pair

Return Value:

    None.

--*/

{
    ULONG Index;

    for (Index = 0; Index < ProgressSubscribersCount; Index++) {
        ASSERT(ProgressSubscribers[Index].Callback != NULL);

        ProgressSubscribers[Index].Callback(MajorEvent,
                MinorEvent,
                ProgressSubscribers[Index].Context,
                EventData);
    }
}

ULONG
SpGetHeaderTextId(
    VOID
    )
/*++

Routine Description:

    Retreives the appropriate product type title id based on the system.

Arguments:

    None.

Return Value:

    Text ID for the product.  This ID may be found in usetup.exe

--*/
{
    ULONG HeaderTextId;

    if (AdvancedServer) {
        HeaderTextId = SP_HEAD_SRV_SETUP;

        if (SpIsProductSuite(VER_SUITE_BLADE)) {
            HeaderTextId = SP_HEAD_BLA_SETUP;
        }
		
        if (SpIsProductSuite(VER_SUITE_SMALLBUSINESS_RESTRICTED)) {
            HeaderTextId = SP_HEAD_SBS_SETUP;
        }
 
	if (SpIsProductSuite(VER_SUITE_ENTERPRISE)) {
            HeaderTextId = SP_HEAD_ADS_SETUP;
        }

        if (SpIsProductSuite(VER_SUITE_DATACENTER)) {
            HeaderTextId = SP_HEAD_DTC_SETUP;
        }
    } else {
        HeaderTextId = SP_HEAD_PRO_SETUP;

        if (SpIsProductSuite(VER_SUITE_PERSONAL)) {
            HeaderTextId = SP_HEAD_PER_SETUP;
        }
    }

    return(HeaderTextId);

}

NTSTATUS
SpGetVersionFromStr(
    IN  PWSTR   VersionStr,
    OUT PDWORD  Version,        // major * 100 + minor
    OUT PDWORD  BuildNumber
    )
/*++

Routine Description:

    Converts the given version string major.minor.build#.sp#
    (e.g. 5.0.2195.1) to the two dwords

Arguments:

    VersionStr  : The version string
    Version     : Place holder for receiving major & minor version
                  (major * 100 + minor)
    BuildNumber : Place holder for receiving build number

Return Value:

    STATUS_SUCCESS if successful otherwise appropriate error code

--*/
{
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;

    if (VersionStr && (Version || BuildNumber)) {
        DWORD MajorVer = 0, MinorVer = 0, BuildNum = 0;
        WCHAR *EndPtr = NULL;
        WCHAR *EndChar = NULL;
        WCHAR TempBuff[64] = {0};

        EndPtr = wcschr(VersionStr, TEXT('.'));

        if (EndPtr) {
            wcsncpy(TempBuff, VersionStr, (EndPtr - VersionStr));
            MajorVer = SpStringToLong(TempBuff, &EndChar, 10);

            VersionStr = EndPtr + 1;

            if (VersionStr) {
                EndPtr = wcschr(VersionStr, TEXT('.'));

                if (EndPtr) {
                    memset(TempBuff, 0, sizeof(TempBuff));
                    wcsncpy(TempBuff, VersionStr, (EndPtr - VersionStr));
                    MinorVer = SpStringToLong(TempBuff, &EndChar, 10);

                    VersionStr = EndPtr + 1;

                    if (VersionStr) {
                        EndPtr = wcschr(VersionStr, TEXT('.'));

                        if (EndPtr) {
                            memset(TempBuff, 0, sizeof(TempBuff));
                            wcsncpy(TempBuff, VersionStr, (EndPtr - VersionStr));
                            BuildNum = SpStringToLong(TempBuff, &EndChar, 10);
                        }
                    }
                }
            }
        }

        if ((MajorVer > 0) || (MinorVer > 0) || (BuildNum > 0))
            Status = STATUS_SUCCESS;

        if (NT_SUCCESS(Status)) {
            if (Version)
                *Version = (MajorVer * 100) + MinorVer;

            if (BuildNumber)
                *BuildNumber = BuildNum;
        }
    }

    return Status;
}


NTSTATUS
SpQueryCanonicalName(
    IN  PWSTR   Name,
    IN  ULONG   MaxDepth,
    OUT PWSTR   CanonicalName,
    IN  ULONG   SizeOfBufferInBytes
    )
/*++

Routine Description:

    Resolves the symbolic name to the specified depth. To resolve
    a symbolic name completely specify the MaxDepth as -1

Arguments:

    Name        -   Symbolic name to be resolved

    MaxDepth    -   The depth till which the resolution needs to
                    be carried out

    CanonicalName   -   The fully resolved name

    SizeOfBufferInBytes -   The size of the CanonicalName buffer in
                            bytes

Return Value:

    Appropriate NT status code

--*/
{
    UNICODE_STRING      name, canonName;
    OBJECT_ATTRIBUTES   oa;
    NTSTATUS            status;
    HANDLE              handle;
    ULONG               CurrentDepth;

    RtlInitUnicodeString(&name, Name);

    canonName.MaximumLength = (USHORT) (SizeOfBufferInBytes - sizeof(WCHAR));
    canonName.Length = 0;
    canonName.Buffer = CanonicalName;

    if (name.Length >= canonName.MaximumLength) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    RtlCopyMemory(canonName.Buffer, name.Buffer, name.Length);
    canonName.Length = name.Length;
    canonName.Buffer[canonName.Length/sizeof(WCHAR)] = 0;

    for (CurrentDepth = 0; CurrentDepth < MaxDepth; CurrentDepth++) {

        InitializeObjectAttributes(&oa, &canonName, OBJ_CASE_INSENSITIVE, 0, 0);

        status = ZwOpenSymbolicLinkObject(&handle,
                                          READ_CONTROL | SYMBOLIC_LINK_QUERY,
                                          &oa);
        if (!NT_SUCCESS(status)) {
            break;
        }

        status = ZwQuerySymbolicLinkObject(handle, &canonName, NULL);
        ZwClose(handle);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        canonName.Buffer[canonName.Length/sizeof(WCHAR)] = 0;
    }

    return STATUS_SUCCESS;
}



NTSTATUS
SpIterateMountMgrMountPoints(
    IN PVOID Context,
    IN SPMOUNTMGR_ITERATION_CALLBACK Callback
    )
/*++

Routine Description:

    Iterates through all the mount points acquired from mountmgr
    and calls the call back function for each mount point.

Arguments:

    Context : Context that needs to be passed on to the caller
              across iterations

    Callback : The function that needs to be called back for
               each mount point.

Return Value:

    Appropriate NT status code

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    OBJECT_ATTRIBUTES ObjAttrs;
    UNICODE_STRING UnicodeString;
    HANDLE MountMgrHandle;
    IO_STATUS_BLOCK IoStatusBlock;

    if (Callback) {
        INIT_OBJA(&ObjAttrs, &UnicodeString, MOUNTMGR_DEVICE_NAME);

        //
        // Open the mountmgr
        //
        Status = ZwOpenFile(&MountMgrHandle,
                    (ACCESS_MASK)(FILE_GENERIC_READ),
                    &ObjAttrs,
                    &IoStatusBlock,
                    FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE ,
                    FILE_NON_DIRECTORY_FILE);

        if (NT_SUCCESS(Status)) {
            MOUNTMGR_MOUNT_POINT MountPoint;
            ULONG   BufferLength = 0;
            PVOID   Buffer = NULL;
            Status = STATUS_BUFFER_OVERFLOW;

            RtlZeroMemory(&MountPoint, sizeof(MOUNTMGR_MOUNT_POINT));

            while (Status == STATUS_BUFFER_OVERFLOW) {
                if (Buffer) {
                    BufferLength = ((PMOUNTMGR_MOUNT_POINTS)Buffer)->Size;
                    SpMemFree(Buffer);
                } else {
                    BufferLength += (8 * 1024); // start with 8K
                }

                //
                // Allocate the output buffer
                //
                Buffer = SpMemAlloc(BufferLength);

                if (!Buffer) {
                    Status = STATUS_NO_MEMORY;

                    break;  // ran out of memory
                }

                RtlZeroMemory(Buffer, BufferLength);

                //
                // Get the mount points
                //
                Status = ZwDeviceIoControlFile(MountMgrHandle,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                IOCTL_MOUNTMGR_QUERY_POINTS,
                                &MountPoint,
                                sizeof(MOUNTMGR_MOUNT_POINT),
                                Buffer,
                                BufferLength);
            }

            if (NT_SUCCESS(Status)) {
                ULONG Index;
                BOOLEAN Done = FALSE;
                PMOUNTMGR_MOUNT_POINTS  MountPoints = (PMOUNTMGR_MOUNT_POINTS)Buffer;

                //
                // Call the callback function for each mountpoint until the requester
                // doesn't want to continue on.
                //
                for (Index=0; !Done && (Index < MountPoints->NumberOfMountPoints); Index++) {
                    Done = Callback(Context, MountPoints, MountPoints->MountPoints + Index);
                }
            }

            //
            // Free the allocated buffer
            //
            if (Buffer) {
                SpMemFree(Buffer);
            }

            //
            // Done with mountmgr handle
            //
            ZwClose(MountMgrHandle);
        }
    }

    return Status;
}


NTSTATUS
SppLockBootStatusData(
    OUT PHANDLE BootStatusDataHandle,
    IN PDISK_REGION TargetRegion,
    IN PWSTR        SystemRoot
    )
/*
    This function has the same functionality as the RtlLockBootStatusData API except that
    it doesn't point to SystemRoot. This is needed for textmode setup to open the 
    correct boot status data file on the installation we are upgrading.
    
    We can still call the RtlUnlock routine as it operates on the handle.

*/
{
    OBJECT_ATTRIBUTES objectAttributes;

    UNICODE_STRING fileName;

    HANDLE dataFileHandle;

    IO_STATUS_BLOCK ioStatusBlock;

    NTSTATUS status;

    PWSTR NtPartition;



    //
    // Get the name of the target patition.
    //
    SpNtNameFromRegion(
        TargetRegion,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    
    SpConcatenatePaths(TemporaryBuffer,SystemRoot);
    SpConcatenatePaths(TemporaryBuffer,L"bootstat.dat");

    RtlInitUnicodeString(&fileName, TemporaryBuffer);

    InitializeObjectAttributes(&objectAttributes,
                               &fileName,
                               OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
                               NULL,
                               NULL);

    status = ZwOpenFile(&dataFileHandle,
                        FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                        &objectAttributes,
                        &ioStatusBlock,
                        0,
                        FILE_SYNCHRONOUS_IO_NONALERT);

    ASSERT(status != STATUS_PENDING);

    if(NT_SUCCESS(status)) {
        *BootStatusDataHandle = dataFileHandle;
    } else {
        *BootStatusDataHandle = NULL;
    }
    
    return status;
}


void
SpDisableCrashRecoveryForGuiMode(
    IN PDISK_REGION TargetRegion,
    IN PWSTR        SystemRoot
    )
/*
    This function processes the Crash Recovery settings. Crash Recovery functions are
    implemented as RTL functions. We try to call RtlLockBootStatusData to
    see if there are settings already in place. If we get STATUS_OBJECT_NAME_NOT_FOUND we know there
    weren't any settings before and we move on. If we succeed we save away the settings and then 
    disable the feature for GUI mode. At the end of GUI mode we migrate the settings
    and re-enable crash recovery.
*/
{
    NTSTATUS Status;
    HANDLE BootStatusData;
    BOOLEAN Enabled = TRUE;
    PWSTR szYes = L"Yes";
    PWSTR szNo = L"No";
    
    //We make this special call to lock the file as the RTL API looks at SystemRoot
    //that points to ~bt in textmode setup.

    Status = SppLockBootStatusData( &BootStatusData, TargetRegion, SystemRoot );


    if(!NT_SUCCESS(Status)){
        
        if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {
            //Some other error occured
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: SpDisableCrashRecoveryForGuiMode() - RtlLockBootStatusData failed - Status = %lx \n", Status));
        }
        
        return;
    }

    // If we made it here we need to migrate the current settings.

    Status = RtlGetSetBootStatusData(
        BootStatusData,
        TRUE,
        RtlBsdItemAabEnabled,
        &Enabled,
        sizeof(BOOLEAN),
        NULL
        );

    if(!NT_SUCCESS(Status)){
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpDisableCrashRecoveryForGuiMode() - RtlGetSetBootStatusData failed to get AabEnabled - Status = %lx \n", Status));
    }

    SpAddLineToSection(
        WinntSifHandle,
        SIF_DATA,
        WINNT_D_CRASHRECOVERYENABLED_W,
        Enabled ? &szYes : &szNo,
        1
        );

    // Finally disable Crash Recovery for Guimode setup

    Enabled = FALSE;

    Status = RtlGetSetBootStatusData(
        BootStatusData,
        FALSE,
        RtlBsdItemAabEnabled,
        &Enabled,
        sizeof(BOOLEAN),
        NULL
        );

    if(!NT_SUCCESS(Status)){
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpDisableCrashRecoveryForGuiMode() - RtlGetSetBootStatusData failed to set AabEnabled - Status = %lx \n", Status));
    }

    RtlUnlockBootStatusData( BootStatusData );

    return;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spvideop.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spvideop.h

Abstract:

    Private header file for text setup display support.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:

--*/


#ifndef _SPVIDP_DEFN_
#define _SPVIDP_DEFN_


//
// Globals that contain information about the font currently in use.
//
extern POEM_FONT_FILE_HEADER FontHeader;

extern ULONG FontBytesPerRow;
extern ULONG FontCharacterHeight;
extern ULONG FontCharacterWidth;

//
// These values are passed to us by setupldr and represent monitor config
// data from the monitor peripheral for the display we are supposed to use
// during setup.  They are used only for non-vga displays.
//
extern PMONITOR_CONFIGURATION_DATA MonitorConfigData;
extern PCHAR MonitorFirmwareIdString;

//
// Routine to map or unmap video memory.  Fills in or uses
// the VideoMemoryInfo global.
//
VOID
pSpvidMapVideoMemory(
    IN BOOLEAN Map
    );

typedef
VOID
(*SPVID_DISPLAY_STRING_ROUTINE) (
    IN PSTR  String,
    IN UCHAR Attribute,
    IN ULONG X,             // 0-based coordinates (character units)
    IN ULONG Y
    );

typedef
VOID
(*SPVID_CLEAR_REGION_ROUTINE) (
    IN ULONG X,
    IN ULONG Y,
    IN ULONG W,
    IN ULONG H,
    IN UCHAR Attribute
    );

typedef
VOID
(*SPVID_SPECIFIC_INIT_ROUTINE) (
    IN PVIDEO_MODE_INFORMATION VideoModes,
    IN ULONG                   NumberOfModes,
    IN ULONG                   ModeSize
    );

typedef
VOID
(*SPVID_SPECIFIC_REINIT_ROUTINE) (
    VOID
    );
    
typedef
VOID
(*SPVID_SPECIFIC_TERMINATE_ROUTINE) (
    VOID
    );

typedef
BOOLEAN
(*SPVID_SPECIFIC_PALETTE_ROUTINE) (
    VOID
    );

typedef
BOOLEAN
(*SPVID_SPECIFIC_SCROLL_UP_ROUTINE) (
    IN ULONG TopLine,
    IN ULONG BottomLine,
    IN ULONG LineCount,
    IN UCHAR FillAttribute
    );

typedef struct _VIDEO_FUNCTION_VECTOR {
    SPVID_DISPLAY_STRING_ROUTINE      DisplayStringRoutine;
    SPVID_CLEAR_REGION_ROUTINE        ClearRegionRoutine;
    SPVID_SPECIFIC_INIT_ROUTINE       SpecificInitRoutine;
    SPVID_SPECIFIC_REINIT_ROUTINE     SpecificReInitRoutine;
    SPVID_SPECIFIC_TERMINATE_ROUTINE  SpecificTerminateRoutine;
    SPVID_SPECIFIC_PALETTE_ROUTINE    SpecificInitPaletteRoutine;
    SPVID_SPECIFIC_SCROLL_UP_ROUTINE  SpecificScrollUpRoutine;
} VIDEO_FUNCTION_VECTOR, *PVIDEO_FUNCTION_VECTOR;


extern PVIDEO_FUNCTION_VECTOR VideoFunctionVector;

//
// Shorthand for accessing routines in the video function vector.
//
#define spvidSpecificInitialize(v,n,m)                              \
                                                                    \
    VideoFunctionVector->SpecificInitRoutine((v),(n),(m))

#define spvidSpecificReInitialize()                                 \
                                                                    \
    VideoFunctionVector->SpecificReInitRoutine()
    

#define spvidSpecificTerminate()                                    \
                                                                    \
    VideoFunctionVector->SpecificTerminateRoutine()

#define spvidSpecificClearRegion(x,y,w,h,a)                         \
                                                                    \
    VideoFunctionVector->ClearRegionRoutine((x),(y),(w),(h),(a))

#define spvidSpecificDisplayString(s,a,x,y)                         \
                                                                    \
    VideoFunctionVector->DisplayStringRoutine((s),(a),(x),(y))

#define spvidSpecificInitPalette()                                  \
                                                                    \
    VideoFunctionVector->SpecificInitPaletteRoutine()

#define spvidSpecificScrollUp(t,b,c,a)                              \
                                                                    \
    VideoFunctionVector->SpecificScrollUpRoutine((t),(b),(c),(a))


//
// Frame buffer routines (spvidfb.c).
//


VOID
FrameBufferDisplayString(
    IN PSTR  String,
    IN UCHAR Attribute,
    IN ULONG X,                 // 0-based coordinates (character units)
    IN ULONG Y
    );

VOID
FrameBufferClearRegion(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG W,
    IN ULONG H,
    IN UCHAR Attribute
    );

VOID
FrameBufferSpecificInit(
    IN PVIDEO_MODE_INFORMATION VideoModes,
    IN ULONG                   NumberOfModes,
    IN ULONG                   ModeSize
    );

VOID
FrameBufferSpecificReInit(
    VOID
    );
    
VOID
FrameBufferSpecificTerminate(
    VOID
    );

BOOLEAN
FrameBufferSpecificInitPalette(
    VOID
    );

BOOLEAN
FrameBufferSpecificScrollUp(
    IN ULONG TopLine,
    IN ULONG BottomLine,
    IN ULONG LineCount,
    IN UCHAR FillAttribute
    );

extern VIDEO_FUNCTION_VECTOR FrameBufferVideoVector;

PVIDEO_MODE_INFORMATION
pFrameBufferDetermineModeToUse(
    IN PVIDEO_MODE_INFORMATION VideoModes,
    IN ULONG                   NumberOfModes,
    IN ULONG                   ModeSize
    );


//
// Textmode display routines (spvidvga.c).
//


VOID
VgaDisplayString(
    IN PSTR  String,
    IN UCHAR Attribute,
    IN ULONG X,                 // 0-based coordinates (character units)
    IN ULONG Y
    );

VOID
VgaClearRegion(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG W,
    IN ULONG H,
    IN UCHAR Attribute
    );

VOID
VgaSpecificInit(
    IN PVIDEO_MODE_INFORMATION VideoModes,
    IN ULONG                   NumberOfModes,
    IN ULONG                   ModeSize
    );

VOID
VgaSpecificReInit(
    VOID
    );
    

VOID
VgaSpecificTerminate(
    VOID
    );

BOOLEAN
VgaSpecificInitPalette(
    VOID
    );

BOOLEAN
VgaSpecificScrollUp(
    IN ULONG TopLine,
    IN ULONG BottomLine,
    IN ULONG LineCount,
    IN UCHAR FillAttribute
    );

extern VIDEO_FUNCTION_VECTOR VgaVideoVector;


#endif // ndef _SPVIDP_DEFN_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spvidfb.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spvidfb.c

Abstract:

    Text setup display support for frame buffer displays.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:

--*/



#include "spprecmp.h"
#pragma hdrstop

#define MINXRES 80
#define MINYRES 32

//
// Vector for frame buffer functions.
//

VIDEO_FUNCTION_VECTOR FrameBufferVideoVector =

    {
        FrameBufferDisplayString,
        FrameBufferClearRegion,
        FrameBufferSpecificInit,
        FrameBufferSpecificReInit,
        FrameBufferSpecificTerminate,
        FrameBufferSpecificInitPalette,
        FrameBufferSpecificScrollUp
    };


BOOLEAN FrameBufferInitialized = FALSE;


//
// Variables that indicate whether we should double the width
// and/or height of a font glyph when it is drawn.  This is useful
// on a 1280*1024 screen for example, to make things readable
// with an 8*12 font like vgaoem.fon.
//
BOOLEAN DoubleCharWidth,DoubleCharHeight;

//
// Number of bytes that make up a row of characters.
// Equal to the screen stride (number of bytes on a scan line)
// multiplied by the height of a char in bytes; double that
// if DoubleCharHeight is TRUE.
//
ULONG CharRowDelta;

ULONG ScaledCharWidth,HeightIterations;
ULONG BytesPerPixel;

PULONG GlyphMap;


//
// Pointer to a dynamically allocated buffer that is the size of one scanline.
//

VOID
pFrameBufferInitGlyphs(
    VOID
    );

VOID
FrameBufferSpecificInit(
    IN PVIDEO_MODE_INFORMATION VideoModes,
    IN ULONG                   NumberOfModes,
    IN ULONG                   ModeSize
    )

/*++

Routine Description:

    Perform frame buffer specific initialization.  This includes

    - setting the desired video mode.

Arguments:

    None.

Return Value:

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    VIDEO_MODE VideoMode;
    PVIDEO_MODE_INFORMATION mode;

    //
    // headless isn't enabled on frame buffer because no frame buffer systems
    // currently exist.  if this changes, then this code must be enabled for
    // headless operation.
    //
    ASSERT( HeadlessTerminalConnected == FALSE );

    if(FrameBufferInitialized) {
        return;
    }

    mode = pFrameBufferDetermineModeToUse(VideoModes,NumberOfModes, ModeSize);

    if(mode == 0) {
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_BADMODE, 0);
        while(TRUE);    // loop forever
    }

    //
    // Save away the mode info in a global.
    //
    VideoVars.VideoModeInfo = *mode;

    //
    // Set the desired mode.
    //
    VideoMode.RequestedMode = VideoVars.VideoModeInfo.ModeIndex;

    Status = ZwDeviceIoControlFile(
                VideoVars.hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_SET_CURRENT_MODE,
                &VideoMode,
                sizeof(VideoMode),
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set mode %u (status = %lx)\n",VideoMode.RequestedMode,Status));
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_SETMODE, Status);
        while(TRUE);    // loop forever
    }

    //
    // Map the frame buffer.
    //
    pSpvidMapVideoMemory(TRUE);

    FrameBufferInitialized = TRUE;

    //
    // Determine the width of the screen.  If it's double the size
    // of the minimum number of characters per row (or larger)
    // then we'll double the width of each character as we draw it.
    //
    VideoVars.ScreenWidth  = VideoVars.VideoModeInfo.VisScreenWidth  / FontCharacterWidth;
    if(VideoVars.ScreenWidth >= 2*MINXRES) {
        VideoVars.ScreenWidth /= 2;
        DoubleCharWidth = TRUE;
    } else {
        DoubleCharWidth = FALSE;
    }

    //
    // Determine the height of the screen.  If it's double the size
    // of the minimum number of characters per column (or larger)
    // then we'll double the height of each character as we draw it.
    //
    VideoVars.ScreenHeight = VideoVars.VideoModeInfo.VisScreenHeight / FontCharacterHeight;
    CharRowDelta = VideoVars.VideoModeInfo.ScreenStride * FontCharacterHeight;
    if(VideoVars.ScreenHeight >= 2*MINYRES) {
        VideoVars.ScreenHeight /= 2;
        DoubleCharHeight = TRUE;
        CharRowDelta *= 2;
    } else {
        DoubleCharHeight = FALSE;
    }

    BytesPerPixel = VideoVars.VideoModeInfo.BitsPerPlane / 8;
    if(BytesPerPixel == 3) {
        BytesPerPixel = 4;
    }
    ScaledCharWidth = (DoubleCharWidth ? 2 : 1) * FontCharacterWidth * BytesPerPixel;
    HeightIterations = DoubleCharHeight ? 2 : 1;

    //
    // initialize glyphs.
    //

    pFrameBufferInitGlyphs();

    //
    // get hold of the space require for background textmode video buffer
    // while upgrade graphics mode is running in the foreground
    //
    if (SP_IS_UPGRADE_GRAPHICS_MODE()) {
        VideoVars.VideoBufferSize = VideoVars.VideoModeInfo.VisScreenHeight *
                    VideoVars.VideoModeInfo.VisScreenWidth * BytesPerPixel;

        VideoVars.VideoBuffer = SpMemAlloc(VideoVars.VideoBufferSize);

        if (!VideoVars.VideoBuffer) {
            //
            // Out of memory, run only in textmode
            //
            VideoVars.VideoBufferSize = 0;
            SP_SET_UPGRADE_GRAPHICS_MODE(FALSE);
            VideoVars.ActiveVideoBuffer = VideoVars.VideoMemoryInfo.FrameBufferBase;
        } else {
            VideoVars.ActiveVideoBuffer = VideoVars.VideoBuffer;
        }
    } else {
        VideoVars.VideoBufferSize = 0;
        VideoVars.VideoBuffer = NULL;
        VideoVars.ActiveVideoBuffer = VideoVars.VideoMemoryInfo.FrameBufferBase;
    }
}


VOID
FrameBufferSpecificReInit(
    VOID
    )
{
    NTSTATUS        Status;
    IO_STATUS_BLOCK IoStatusBlock;
    VIDEO_MODE      VideoMode;

    if (!FrameBufferInitialized) {
        return; 
    }        
    
    //
    // Set the desired mode.
    //
    VideoMode.RequestedMode = VideoVars.VideoModeInfo.ModeIndex;

    Status = ZwDeviceIoControlFile(
                VideoVars.hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_SET_CURRENT_MODE,
                &VideoMode,
                sizeof(VideoMode),
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set mode %u (status = %lx)\n",VideoMode.RequestedMode,Status));
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_SETMODE, Status);
        while(TRUE);    // loop forever
    }

    //
    // Determine the width of the screen.  If it's double the size
    // of the minimum number of characters per row (or larger)
    // then we'll double the width of each character as we draw it.
    //
    VideoVars.ScreenWidth  = VideoVars.VideoModeInfo.VisScreenWidth  / FontCharacterWidth;

    if(VideoVars.ScreenWidth >= 2*MINXRES) {
        VideoVars.ScreenWidth /= 2;
        DoubleCharWidth = TRUE;
    } else {
        DoubleCharWidth = FALSE;
    }

    //
    // Determine the height of the screen.  If it's double the size
    // of the minimum number of characters per column (or larger)
    // then we'll double the height of each character as we draw it.
    //
    VideoVars.ScreenHeight = VideoVars.VideoModeInfo.VisScreenHeight / FontCharacterHeight;
    CharRowDelta = VideoVars.VideoModeInfo.ScreenStride * FontCharacterHeight;

    if(VideoVars.ScreenHeight >= 2*MINYRES) {
        VideoVars.ScreenHeight /= 2;
        DoubleCharHeight = TRUE;
        CharRowDelta *= 2;
    } else {
        DoubleCharHeight = FALSE;
    }

    BytesPerPixel = VideoVars.VideoModeInfo.BitsPerPlane / 8;
    if(BytesPerPixel == 3) {
        BytesPerPixel = 4;
    }

    ScaledCharWidth = (DoubleCharWidth ? 2 : 1) * FontCharacterWidth * BytesPerPixel;
    HeightIterations = DoubleCharHeight ? 2 : 1;

    //
    // initialize glyphs.
    //
    pFrameBufferInitGlyphs();

    FrameBufferSpecificInitPalette();

    //
    // Blast the cached video memory to the real framebuffer now
    //
    if (SP_IS_UPGRADE_GRAPHICS_MODE() && VideoVars.VideoBuffer && 
        VideoVars.VideoBufferSize) {
        PUCHAR Source = VideoVars.VideoBuffer;
        PUCHAR Destination = VideoVars.VideoMemoryInfo.FrameBufferBase;
        ULONG Index;

        for (Index=0; Index < VideoVars.VideoBufferSize; Index++) {
            WRITE_REGISTER_UCHAR(Destination + Index, *(Source + Index));
        }

        SP_SET_UPGRADE_GRAPHICS_MODE(FALSE);
        VideoVars.ActiveVideoBuffer = VideoVars.VideoMemoryInfo.FrameBufferBase;
    }    
}

BOOLEAN
FrameBufferSpecificInitPalette(
    VOID
    )
{
    BOOLEAN rc;
    ULONG NumEntries;
    ULONG BufferSize;
    PVIDEO_CLUT clut;
//  NTSTATUS Status;
//  IO_STATUS_BLOCK IoStatusBlock;
    UCHAR i;

    rc = TRUE;

    //
    // For non-palette-driven displays, we construct a simple palette
    // for use w/ gamma correcting adapters.
    //

    if(!(VideoVars.VideoModeInfo.AttributeFlags & VIDEO_MODE_PALETTE_DRIVEN)) {

        switch(BytesPerPixel) {
        case 1:
            NumEntries = 3;
            break;
        case 2:
            NumEntries = 32;
            break;
        default:
            NumEntries = 255;
            break;
        }

        BufferSize = sizeof(VIDEO_CLUT)+(sizeof(VIDEO_CLUTDATA)*NumEntries);    // size is close enough
        clut = SpMemAlloc(BufferSize);

        clut->NumEntries = (USHORT)NumEntries;
        clut->FirstEntry = 0;

        for(i=0; i<NumEntries; i++) {
            clut->LookupTable[i].RgbArray.Red    = i;
            clut->LookupTable[i].RgbArray.Green  = i;
            clut->LookupTable[i].RgbArray.Blue   = i;
            clut->LookupTable[i].RgbArray.Unused = 0;
        }

//        Status = ZwDeviceIoControlFile(
//                    hDisplay,
//                    NULL,
//                    NULL,
//                    NULL,
//                    &IoStatusBlock,
//                    IOCTL_VIDEO_SET_COLOR_REGISTERS,
//                    clut,
//                    BufferSize,
//                    NULL,
//                    0
//                    );

        SpMemFree(clut);

//        if(!NT_SUCCESS(Status)) {
//            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set palette (status = %lx)\n",Status));
//            rc = FALSE;
//        }
    }

    return(rc);
}


VOID
FrameBufferSpecificTerminate(
    VOID
    )

/*++

Routine Description:

    Perform frame buffer specific termination.  This includes

    - unmapping the frame buffer from memory

Arguments:

    None.

Return Value:

--*/

{
    if(FrameBufferInitialized) {

        //
        // Be a good citizen and clear the screen. Important in Far East where
        // we switch screen modes on the fly as we go in and out of localized mode.
        //
        FrameBufferClearRegion(0,0,VideoVars.ScreenWidth,VideoVars.ScreenHeight,ATT_FG_BLACK|ATT_BG_BLACK);

        pSpvidMapVideoMemory(FALSE);
        FrameBufferInitialized = FALSE;

        SpMemFree(GlyphMap);

        if (VideoVars.VideoBuffer && VideoVars.VideoBufferSize) {
            SpMemFree(VideoVars.VideoBuffer);
            VideoVars.VideoBuffer = NULL;
            VideoVars.VideoBufferSize = 0;
        }
    }
}



VOID
FrameBufferDisplayString(
    IN PSTR  String,
    IN UCHAR Attribute,
    IN ULONG X,                 // 0-based coordinates (character units)
    IN ULONG Y
    )

/*++

Routine Description:

    Write a string of characters to the display.

Arguments:

    Character - supplies a string in the OEM character set, to be displayed
        at the given position.

    Attribute - supplies the attributes for the character.

    X,Y - specify the character-based (0-based) position of the output.

Return Value:

    None.

--*/

{
    ULONG BgColorValue;
    ULONG FgColorValue;
    PUCHAR Destination;
    ULONG I;
    ULONG J;
    ULONG K;
    ULONG Length;
    PUCHAR Origin;
    ULONG Pixel;
    ULONG PixelMap;
    ULONG RealHeight;

    ASSERT(X < VideoVars.ScreenWidth);
    ASSERT(Y < VideoVars.ScreenHeight);

    //
    // Calculate the bit patterns that yield the foreground and background
    // attributes when poked into the frame buffer.
    //

    FgColorValue = VideoVars.AttributeToColorValue[Attribute & 0x0f];
    BgColorValue = VideoVars.AttributeToColorValue[(Attribute >> 4) & 0x0f];

    //
    // Calculate the address of the upper left pixel of the first character
    // to be displayed.
    //

    Origin = (PUCHAR)VideoVars.ActiveVideoBuffer
           + (Y * CharRowDelta)
           + (X * ScaledCharWidth);

    RealHeight = FontCharacterHeight * HeightIterations;

    //
    // Output the character string by generating a complete scanline into
    // a temporary buffer using glyph segments from each character, then
    // copy the scanline to the frame buffer.
    //

    Length = strlen(String);
    for (I = 0; I < RealHeight; I += 1) {
        Destination = Origin;
        for (J = 0; J < Length; J += 1) {
            PixelMap = *(GlyphMap + (((UCHAR)String[J] * RealHeight) + I));
            for (K = 0; K < FontCharacterWidth; K += 1) {

                Pixel = (PixelMap >> 31) ? FgColorValue : BgColorValue;

                switch(BytesPerPixel) {

                case 1:
                    *Destination++ = (UCHAR)Pixel;
                    if(DoubleCharWidth) {
                        *Destination++ = (UCHAR)Pixel;
                    }
                    break;

                case 2:
                    *(PUSHORT)Destination = (USHORT)Pixel;
                    Destination += 2;
                    if(DoubleCharWidth) {
                        *(PUSHORT)Destination = (USHORT)Pixel;
                        Destination += 2;
                    }
                    break;

                case 4:
                    *(PULONG)Destination = Pixel;
                    Destination += 4;
                    if(DoubleCharWidth) {
                        *(PULONG)Destination = Pixel;
                        Destination += 4;
                    }
                    break;
                }

                PixelMap <<= 1;
            }
        }

        Origin += VideoVars.VideoModeInfo.ScreenStride;
    }
}



VOID
FrameBufferClearRegion(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG W,
    IN ULONG H,
    IN UCHAR Attribute
    )

/*++

Routine Description:

    Clear out a screen region to a specific attribute.

Arguments:

    X,Y,W,H - specify rectangle in 0-based character coordinates.

    Attribute - Low nibble specifies attribute to be filled in the rectangle
        (ie, the background color to be cleared to).

Return Value:

    None.

--*/

{
    PUCHAR Destination;
    ULONG  Fill;
    ULONG  i;
    ULONG  FillLength;
    ULONG  x;
    ULONG  Iterations;

    ASSERT(X+W <= VideoVars.ScreenWidth);
    ASSERT(Y+H <= VideoVars.ScreenHeight);

    if(X+W > VideoVars.ScreenWidth) {
        W = VideoVars.ScreenWidth-X;
    }

    if(Y+H > VideoVars.ScreenHeight) {
        H = VideoVars.ScreenHeight-Y;
    }

    Fill = VideoVars.AttributeToColorValue[Attribute & 0x0f];

    Destination = (PUCHAR)VideoVars.ActiveVideoBuffer
                + (Y * CharRowDelta)
                + (X * ScaledCharWidth);

    FillLength = W * ScaledCharWidth;
    Iterations = H * FontCharacterHeight * HeightIterations;

    switch(BytesPerPixel) {

    case 1:
        for(i=0; i<Iterations; i++) {
            for(x=0; x<FillLength; x++) {
                ((PUCHAR)Destination)[x] = (UCHAR)Fill;
            }
            Destination += VideoVars.VideoModeInfo.ScreenStride;
        }
        break;

    case 2:
        for(i=0; i<Iterations; i++) {
            for(x=0; x<FillLength/2; x++) {
                ((PUSHORT)Destination)[x] = (USHORT)Fill;
            }
            Destination += VideoVars.VideoModeInfo.ScreenStride;
        }
        break;

    case 4:
        for(i=0; i<Iterations; i++) {
            for(x=0; x<FillLength/4; x++) {
                ((PULONG)Destination)[x] = (ULONG)Fill;
            }
            Destination += VideoVars.VideoModeInfo.ScreenStride;
        }
        break;
    }
}


BOOLEAN
FrameBufferSpecificScrollUp(
    IN ULONG TopLine,
    IN ULONG BottomLine,
    IN ULONG LineCount,
    IN UCHAR FillAttribute
    )
{
    PUCHAR Source,Target;
    ULONG Count;

    Target = (PUCHAR)VideoVars.ActiveVideoBuffer
           +         (TopLine * CharRowDelta);

    Source = Target + (LineCount * CharRowDelta);

    Count = (((BottomLine - TopLine) + 1) - LineCount) * CharRowDelta;

    RtlMoveMemory(Target,Source,Count);

    FrameBufferClearRegion(
        0,
        (BottomLine - LineCount) + 1,
        VideoVars.ScreenWidth,
        LineCount,
        FillAttribute
        );

    return(TRUE);
}


VOID
pFrameBufferInitGlyphs(
    VOID
    )
{
    ULONG I,J,z,FontValue;
    UCHAR Character;
    USHORT chr;
    PUCHAR Glyph;
    PULONG dest;

    if (!GlyphMap) {
        GlyphMap = SpMemAlloc(sizeof(ULONG)*256*FontCharacterHeight*HeightIterations);
    }        

    dest = GlyphMap;

    for(chr=0; chr<256; chr++) {

        Character = (UCHAR)chr;

        if((Character < FontHeader->FirstCharacter)
        || (Character > FontHeader->LastCharacter))
        {
            Character = FontHeader->DefaultCharacter;
        }

        Character -= FontHeader->FirstCharacter;

        Glyph = (PUCHAR)FontHeader + FontHeader->Map[Character].Offset;

        for (I = 0; I < FontCharacterHeight; I++) {

            //
            // Build up a bitmap of pixels that comprise the row of the glyph
            // we are drawing.
            //
            FontValue = 0;
            for (J = 0; J < FontBytesPerRow; J++) {
                FontValue |= *(Glyph + (J * FontCharacterHeight)) << (24 - (J * 8));
            }
            Glyph++;

            for(z=0; z<HeightIterations; z++) {
                *dest++ = FontValue;
            }
        }
    }
}


PVIDEO_MODE_INFORMATION
pFrameBufferLocateMode(
    IN PVIDEO_MODE_INFORMATION VideoModes,
    IN ULONG                   NumberOfModes,
    IN ULONG                   ModeSize,
    IN ULONG                   X,
    IN ULONG                   Y,
    IN ULONG                   Bpp,
    IN ULONG                   VRefresh
    )
{
    ULONG modenum;
    PVIDEO_MODE_INFORMATION pVideoMode = &VideoModes[0];

    for(modenum=0; modenum<NumberOfModes; modenum++) {

        if((pVideoMode->AttributeFlags & VIDEO_MODE_GRAPHICS)
        && (pVideoMode->VisScreenWidth == X)
        && (pVideoMode->VisScreenHeight == Y)
        && (((Bpp == (ULONG)(-1)) && (pVideoMode->BitsPerPlane >= 8)) || (pVideoMode->BitsPerPlane == Bpp))
        && ((VRefresh == (ULONG)(-1)) || (pVideoMode->Frequency == VRefresh)))
        {
            return(pVideoMode);
        }

        pVideoMode = (PVIDEO_MODE_INFORMATION) (((PUCHAR) pVideoMode) + ModeSize);
    }

    return(0);
}


PVIDEO_MODE_INFORMATION
pFrameBufferDetermineModeToUse(
    IN PVIDEO_MODE_INFORMATION VideoModes,
    IN ULONG                   NumberOfModes,
    IN ULONG                   ModeSize
    )
{
    PCHAR p,q,end;
    ULONG X,Y;
    PVIDEO_MODE_INFORMATION mode;

    ULONG i; //NEC98

    //return(2);      //TEDM

    if(!NumberOfModes) {
        return(0);
    }

    X = Y = 0;

    //
    // Get x and y resolution.  If we have a monitor id string
    // in the form XxY, then it is the resolution to use.
    //
    if((p=MonitorFirmwareIdString) && (q=strchr(p+3,'x')) && (strlen(q+1) >= 3)) {

        *q++ = 0;

        //
        // Now p points to the x resolution and q to the y resolution.
        //
        X = SpMultiByteStringToUnsigned(p,&end);
        if(X && (end == (q-1))) {

            Y = SpMultiByteStringToUnsigned(q,&end);
            if(end != (q+strlen(q))) {
                Y = 0;
            }

        } else {
            X = 0;
        }
    }

    //
    // If we don't have x or y resolution yet, look in the
    // monitor config data.
    //
    if((!X || !Y) && MonitorConfigData) {

        X = (ULONG)MonitorConfigData->HorizontalResolution;
        Y = (ULONG)MonitorConfigData->VerticalResolution;
    }

    if(X && Y) {

        //
        // We found what seems like a reasonable resolution.
        // Now try to locate a mode that uses it.
        //

        //
        // Find a mode of 8bpp with the x and y resolution at 60 Hz.
        //
        mode = pFrameBufferLocateMode(VideoModes,NumberOfModes,ModeSize,X,Y,8,60);

        if (mode) {
            return(mode);
        }

        //
        // Couldn't find an 8bpp mode @ 60Hz; find any mode with that resolution at 8bpp.
        //
        mode = pFrameBufferLocateMode(VideoModes,NumberOfModes,ModeSize,X,Y,8,(ULONG)(-1));
        if(mode) {
            return(mode);
        }
    }

    //
    // Can't find a mode so far.  See if mode 0 is acceptable.
    //
    // First video mode in list is not for VGA on NEC98,
    // so make a loop to check VGA mode.
    // (First video mode in list is for VGA on PC/AT.)
    //
    for(i=0;
        i<((!IsNEC_98) ? 1 : NumberOfModes);
        i++, VideoModes=(PVIDEO_MODE_INFORMATION)(((PUCHAR)VideoModes)+ModeSize))
    {
        if((VideoModes->AttributeFlags & VIDEO_MODE_GRAPHICS)
        && (VideoModes->BitsPerPlane >= 8)
        && (VideoModes->VisScreenWidth >= 640)
        && (VideoModes->VisScreenHeight >= 480))
        {
            return(VideoModes);
        }
    } //NEC98

    //
    // Give up.
    //
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spvidvga.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spvidvga.c

Abstract:

    Text setup display support displays with a text mode.

Author:

    Ted Miller (tedm) 2-Aug-1993

Revision History:

--*/



#include "spprecmp.h"
#include "ntddser.h"
#include <hdlsblk.h>
#include <hdlsterm.h>
#pragma hdrstop

//
// Vector for text-mode functions.
//

VIDEO_FUNCTION_VECTOR VgaVideoVector =

    {
        VgaDisplayString,
        VgaClearRegion,
        VgaSpecificInit,
        VgaSpecificReInit,
        VgaSpecificTerminate,
        VgaSpecificInitPalette,
        VgaSpecificScrollUp
    };



BOOLEAN VgaInitialized = FALSE;

VOID
pSpvgaInitializeFont(
    VOID
    );

VOID
VgaSpecificInit(
    IN PVIDEO_MODE_INFORMATION VideoModes,
    IN ULONG                   NumberOfModes,
    IN ULONG                   ModeSize
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    VIDEO_MODE VideoMode;
    ULONG mode;
    ULONG StandardMode = -1;
    ULONG HeadlessMode = -1;
    ULONG HeadlessLines = 0;
    VIDEO_CURSOR_ATTRIBUTES VideoCursorAttributes;

    PVIDEO_MODE_INFORMATION pVideoMode = &VideoModes[0];
    

    if(VgaInitialized) {
        return;
    }

    //
    // Find a mode that will work.  If we are not running on a headless machine,
    // then we search for standard 720x400 mode.  Otherwise we try and find the 
    // mode that will result in a screen closest to the terminal height.
    //
    for(mode=0; mode<NumberOfModes; mode++) {

        if(!(pVideoMode->AttributeFlags & VIDEO_MODE_GRAPHICS)
           && (pVideoMode->VisScreenWidth  == 720)
           && (pVideoMode->VisScreenHeight == 400)) {
            StandardMode = mode;
        }

        if ((HeadlessTerminalConnected) &&
            ((pVideoMode->VisScreenHeight / FontCharacterHeight) >= HEADLESS_SCREEN_HEIGHT)
            && (!(pVideoMode->AttributeFlags & VIDEO_MODE_GRAPHICS))) { 

            if ((HeadlessMode == -1) || 
                ((pVideoMode->VisScreenHeight / FontCharacterHeight) < HeadlessLines)) {
                HeadlessMode = mode;
                HeadlessLines = pVideoMode->VisScreenHeight / FontCharacterHeight;
            }
        }

        pVideoMode = (PVIDEO_MODE_INFORMATION) (((PUCHAR) pVideoMode) + ModeSize);
    }

    //
    // if we're in headless mode, we might not have found an acceptable mode
    // first try to use the standard video mode if that's available.
    // otherwise we have to assume that there isn't any video, etc.
    //
    if (HeadlessTerminalConnected && (HeadlessMode == -1)) {
        if (StandardMode != -1) {
            HeadlessMode = StandardMode;
        } else {
            KdPrintEx((
                DPFLTR_SETUP_ID, 
                DPFLTR_ERROR_LEVEL, 
                "SETUP: no video mode present in headless mode.  Run w/out video\n"));
        }
    }

    if (((StandardMode == -1) && !HeadlessTerminalConnected)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Desired video mode not supported!\n"));
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_BADMODE, 0);
        while(TRUE);    // loop forever
    }

    if (HeadlessTerminalConnected && (HeadlessMode == -1)) {
        return;
    }

    pVideoMode = HeadlessTerminalConnected 
                            ? &VideoModes[HeadlessMode]
                            : &VideoModes[StandardMode];

    
    VideoVars.VideoModeInfo = *pVideoMode;

    //
    // Set the desired mode.
    //
    VideoMode.RequestedMode = VideoVars.VideoModeInfo.ModeIndex;

    Status = ZwDeviceIoControlFile(
                VideoVars.hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_SET_CURRENT_MODE,
                &VideoMode,
                sizeof(VideoMode),
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set mode %u (status = %lx)\n",VideoMode.RequestedMode,Status));
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_SETMODE, Status);
        while(TRUE);    // loop forever
    }

    pSpvidMapVideoMemory(TRUE);

    pSpvgaInitializeFont();

    //
    // Shut the hardware cursor off.
    //
    RtlZeroMemory(&VideoCursorAttributes,sizeof(VideoCursorAttributes));
    Status = ZwDeviceIoControlFile(
                VideoVars.hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_SET_CURSOR_ATTR,
                &VideoCursorAttributes,
                sizeof(VideoCursorAttributes),
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to turn hw cursor off (status = %lx)\n",Status));
    }

    VgaInitialized = TRUE;

    ASSERT(VideoVars.VideoModeInfo.ScreenStride = 160);
    ASSERT(VideoVars.VideoModeInfo.AttributeFlags & VIDEO_MODE_PALETTE_DRIVEN);
    VideoVars.ScreenWidth  = 80;
    VideoVars.ScreenHeight = VideoVars.VideoModeInfo.VisScreenHeight / FontCharacterHeight;

    //
    // allocate the background video buffer, if needed
    //
    if (SP_IS_UPGRADE_GRAPHICS_MODE()) {        
        VideoVars.VideoBufferSize = 
            (VideoVars.VideoModeInfo.ScreenStride * VideoVars.VideoModeInfo.VisScreenHeight) / 8;
            
        VideoVars.VideoBuffer = SpMemAlloc(VideoVars.VideoBufferSize);

        if (!VideoVars.VideoBuffer) {
            //
            // Out of memory, run only in textmode
            //
            VideoVars.VideoBufferSize = 0;
            SP_SET_UPGRADE_GRAPHICS_MODE(FALSE);
            VideoVars.ActiveVideoBuffer = VideoVars.VideoMemoryInfo.FrameBufferBase;
        } else {
            VideoVars.ActiveVideoBuffer = VideoVars.VideoBuffer;
        }
    } else {
        VideoVars.VideoBufferSize = 0;
        VideoVars.VideoBuffer = NULL;
        VideoVars.ActiveVideoBuffer = VideoVars.VideoMemoryInfo.FrameBufferBase;
    }
}

BOOLEAN
VgaSpecificInitPalette(
    VOID
    )
{

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    USHORT InitialPalette[] = {
        16, // 16 entries
        0,  // start with first palette register
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F};

    if (!VgaInitialized) {
        return(TRUE);
    }

    Status = ZwDeviceIoControlFile(
                VideoVars.hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_SET_PALETTE_REGISTERS,
                InitialPalette,
                sizeof(InitialPalette),
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set palette (status = %lx)\n",Status));
        return(FALSE);
    }

    return (TRUE);
}

VOID
VgaSpecificReInit(
    VOID
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS                Status;
    IO_STATUS_BLOCK         IoStatusBlock;
    VIDEO_MODE              VideoMode;
    VIDEO_CURSOR_ATTRIBUTES VideoCursorAttributes;    
    
    if(!VgaInitialized) {
        return;
    }

    //
    // Set the desired mode back
    //
    VideoMode.RequestedMode = VideoVars.VideoModeInfo.ModeIndex;

    Status = ZwDeviceIoControlFile(
                VideoVars.hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_SET_CURRENT_MODE,
                &VideoMode,
                sizeof(VideoMode),
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set mode %u (status = %lx)\n",VideoMode.RequestedMode,Status));
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_SETMODE, Status);
        while(TRUE);    // loop forever
    }

    pSpvgaInitializeFont();

    //
    // Shut the hardware cursor off.
    //
    RtlZeroMemory(&VideoCursorAttributes,sizeof(VideoCursorAttributes));

    Status = ZwDeviceIoControlFile(
                VideoVars.hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_SET_CURSOR_ATTR,
                &VideoCursorAttributes,
                sizeof(VideoCursorAttributes),
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to turn hw cursor off (status = %lx)\n",Status));
    }

    VgaSpecificInitPalette();

    //
    // Blast the cached video memory to the real framebuffer now
    //
    if (SP_IS_UPGRADE_GRAPHICS_MODE() && VideoVars.VideoBuffer && 
        VideoVars.VideoBufferSize) {
        PUCHAR Source = VideoVars.VideoBuffer;
        PUCHAR Destination = VideoVars.VideoMemoryInfo.FrameBufferBase;
        ULONG Index;

        for (Index=0; Index < VideoVars.VideoBufferSize; Index++) {
            WRITE_REGISTER_UCHAR(Destination + Index, *(Source + Index));
        }

        SP_SET_UPGRADE_GRAPHICS_MODE(FALSE);
        VideoVars.ActiveVideoBuffer = VideoVars.VideoMemoryInfo.FrameBufferBase;
    }
}


VOID
VgaSpecificTerminate(
    VOID
    )

/*++

Routine Description:

    Perform text display specific termination.  This includes

    - unmapping video memory

Arguments:

    None.

Return Value:

--*/

{
    if(VgaInitialized) {

        pSpvidMapVideoMemory(FALSE);

        if (VideoVars.VideoBuffer && VideoVars.VideoBufferSize) {
            SpMemFree(VideoVars.VideoBuffer);
            VideoVars.VideoBuffer = NULL;
            VideoVars.VideoBufferSize = 0;
        }                        
        
        VgaInitialized = FALSE;
    }
}



VOID
VgaDisplayString(
    IN PSTR  String,
    IN UCHAR Attribute,
    IN ULONG X,                 // 0-based coordinates (character units)
    IN ULONG Y
    )

/*++

Routine Description:

    Write a string of characters to the display.

Arguments:

    Character - supplies a string (OEM charset) to be displayed
        at the given position.

    Attribute - supplies the attributes for the characters in the string.

    X,Y - specify the character-based (0-based) position of the output.

Return Value:

    None.

--*/

{
    PUCHAR Destination;
    PUCHAR pch;

    if (!VgaInitialized) {
        return;
    }

    ASSERT(X < VideoVars.ScreenWidth);
    ASSERT(Y < VideoVars.ScreenHeight);

    Destination = (PUCHAR)VideoVars.ActiveVideoBuffer
                + (Y * VideoVars.VideoModeInfo.ScreenStride)
                + (2*X);

    for(pch=String; *pch; pch++) {

        WRITE_REGISTER_UCHAR(Destination  ,*pch);
        WRITE_REGISTER_UCHAR(Destination+1,Attribute);

        Destination += 2;
    }

}



VOID
VgaClearRegion(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG W,
    IN ULONG H,
    IN UCHAR Attribute
    )

/*++

Routine Description:

    Clear out a screen region to a specific attribute.

Arguments:

    X,Y,W,H - specify rectangle in 0-based character coordinates.

    Attribute - Low nibble specifies attribute to be filled in the rectangle
        (ie, the background color to be cleared to).

Return Value:

    None.

--*/


{
    PUSHORT Destination;
    USHORT  Fill;
    ULONG   i,j;

    if (!VgaInitialized) {
        return;
    }

    Destination = (PUSHORT)((PUCHAR)VideoVars.ActiveVideoBuffer
                +           (Y * VideoVars.VideoModeInfo.ScreenStride)
                +           (2*X));

    Fill = ((USHORT)VideoVars.AttributeToColorValue[Attribute] << 12) + ' ';

    for(i=0; i<H; i++) {

        for(j=0; j<W; j++) {
            WRITE_REGISTER_USHORT(&Destination[j],Fill);
        }
        
        Destination += VideoVars.VideoModeInfo.ScreenStride / sizeof(USHORT);
    }
}


BOOLEAN
VgaSpecificScrollUp(
    IN ULONG TopLine,
    IN ULONG BottomLine,
    IN ULONG LineCount,
    IN UCHAR FillAttribute
    )
{
    PUSHORT Source,Target;
    ULONG Count;

    if (!VgaInitialized) {
        return(TRUE);
    }

    Target = (PUSHORT)VideoVars.ActiveVideoBuffer
           +         ((TopLine * VideoVars.VideoModeInfo.ScreenStride)/2);

    Source = Target + ((LineCount * VideoVars.VideoModeInfo.ScreenStride)/2);

    Count = ((((BottomLine - TopLine) + 1) - LineCount) * VideoVars.VideoModeInfo.ScreenStride) / 2;

    while (Count--) {
        WRITE_REGISTER_USHORT(Target++, READ_REGISTER_USHORT(Source++));
    }
    

    //
    // Clear bottom of scroll region
    //
    VgaClearRegion(0,
                   (BottomLine - LineCount) + 1,
                   VideoVars.ScreenWidth,
                   LineCount,
                   FillAttribute
                   );

    return(TRUE);
}


VOID
pSpvgaInitializeFont(
    VOID
    )

/*++

Routine Description:

    Set up font support for the VGA.  This assumes that the mode has been
    set to the standard 720x400 VGA text mode.  The current font (in .fnt
    format) is transformed into a vga-loadable font and then loaded into
    the VGA character generator.

Arguments:

    None.

Return Value:

    None.

--*/

{
    USHORT i;
    PVIDEO_LOAD_FONT_INFORMATION DstFont;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PUCHAR FontBuffer;
    ULONG FontBufferSize;

    FontBufferSize = (256*FontCharacterHeight) + sizeof(VIDEO_LOAD_FONT_INFORMATION);
    FontBuffer = SpMemAlloc(FontBufferSize);

    DstFont = (PVIDEO_LOAD_FONT_INFORMATION)FontBuffer;

    DstFont->WidthInPixels = 9;
    DstFont->HeightInPixels = (USHORT)FontCharacterHeight;
    DstFont->FontSize = 256*FontCharacterHeight;

    //
    // Special case character 0 because it is not in vgaoem.fon, and we don't
    // want to use the default character for it.
    //
    RtlZeroMemory(DstFont->Font,FontCharacterHeight);

    //
    // If i is not a USHORT, then (i<=255) is always TRUE!
    //
    for(i=1; i<=255; i++) {

        UCHAR x;

        if((i < FontHeader->FirstCharacter) || (i > FontHeader->LastCharacter)) {
            x = FontHeader->DefaultCharacter;
        } else {
            x = (UCHAR)i;
        }

        x -= FontHeader->FirstCharacter;

        RtlMoveMemory(
            DstFont->Font + (i*FontCharacterHeight),
            (PUCHAR)FontHeader + FontHeader->Map[x].Offset,
            FontCharacterHeight
            );
    }

    Status = ZwDeviceIoControlFile(
                VideoVars.hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_LOAD_AND_SET_FONT,
                FontBuffer,
                FontBufferSize,
                NULL,
                0
                );

    SpMemFree(FontBuffer);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set vga font (%lx)\n",Status));
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_SETFONT, Status);
        while(TRUE);    // loop forever
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spwin.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    spwin.h

Abstract:

    Win32 portability layer
        file i/o
        Get/SetLastError
        slight wrappers around such for porting windows\winstate\...\cablib.c

Author:

    Jay Krell (a-JayK) November 2000

Revision History:

        
--*/
#pragma once

#include "windows.h"

#define PATHS_ALWAYS_NATIVE 1

VOID
SpSetLastWin32ErrorAndNtStatusFromNtStatus(
    NTSTATUS Status
    );

NTSTATUS
SpGetLastNtStatus(
    VOID
    );

NTSTATUS
SpConvertWin32FileOpenOrCreateToNtFileOpenOrCreate(
    ULONG Win32OpenOrCreate,
    ULONG* NtOpenOrCreate
    );

NTSTATUS
SpConvertWin32FileAccessToNtFileAccess(
    ULONG  Win32FileAccess,
    ULONG* NtFileAccess
    );

NTSTATUS
SpConvertWin32FileShareToNtFileShare(
    ULONG  Win32FileShare,
    ULONG* NtFileShare
    );

NTSTATUS
SpGetLastNtStatus(
    VOID
    );

ULONG
WINAPI
SpGetLastWin32Error(
    VOID
    );

VOID
WINAPI
SpSetLastWin32Error(
    ULONG Error
    );

HANDLE
SpNtCreateFileW(
    PCUNICODE_STRING           ConstantPath,
    IN ULONG                   FileAccess,
    IN ULONG                   FileShare,
    IN LPSECURITY_ATTRIBUTES   SecurityAttributes,
    IN ULONG                   Win32FileOpenOrCreate,
    IN ULONG                   FlagsAndAttributes,
    IN HANDLE                  TemplateFile
    );

HANDLE
WINAPI
SpWin32CreateFileW(
    IN PCWSTR FileName,
    IN ULONG  FileAccess,
    IN ULONG  FileShare,
    IN LPSECURITY_ATTRIBUTES SecurityAttributes,
    IN ULONG  FileOpenOrCreate,
    IN ULONG  FlagsAndAttributes,
    IN HANDLE TemplateFile
    );

HANDLE
WINAPI
SpWin32CreateFileA(
    IN PCSTR FileName,
    IN ULONG FileAccess,
    IN ULONG FileShare,
    IN LPSECURITY_ATTRIBUTES SecurityAttributes,
    IN ULONG FileOpenOrCreate,
    IN ULONG dwFlagsAndAttributes,
    IN HANDLE TemplateFile
    );

BOOL
WINAPI
SpWin32ReadFile(
    HANDLE hFile,
    PVOID lpBuffer,
    ULONG nNumberOfBytesToRead,
    ULONG* lpNumberOfBytesRead,
    LPOVERLAPPED lpOverlapped
    );

BOOL
WINAPI
SpWin32WriteFile(
    HANDLE hFile,
    CONST VOID* lpBuffer,
    ULONG nNumberOfBytesToWrite,
    ULONG* lpNumberOfBytesWritten,
    LPOVERLAPPED lpOverlapped
    );

ULONG
WINAPI
SpSetFilePointer(
    HANDLE hFile,
    LONG lDistanceToMove,
    LONG* lpDistanceToMoveHigh,
    ULONG dwMoveMethod
    );

BOOL
WINAPI
SpWin32DeleteFileA(
    PCSTR FileName
    );

BOOL
APIENTRY
SpFileTimeToDosDateTime(
    CONST FILETIME *lpFileTime,
    LPWORD lpFatDate,
    LPWORD lpFatTime
    );

BOOL
APIENTRY
SpDosDateTimeToFileTime(
    WORD wFatDate,
    WORD wFatTime,
    LPFILETIME lpFileTime
    );

BOOL
WINAPI
SpFileTimeToLocalFileTime(
    CONST FILETIME *lpFileTime,
    LPFILETIME lpLocalFileTime
    );

BOOL
WINAPI
SpLocalFileTimeToFileTime(
    CONST FILETIME *lpLocalFileTime,
    LPFILETIME lpFileTime
    );

BOOL
WINAPI
SpSetFileTime(
    HANDLE hFile,
    CONST FILETIME *lpCreationTime,
    CONST FILETIME *lpLastAccessTime,
    CONST FILETIME *lpLastWriteTime
    );

BOOL
APIENTRY
SpSetFileAttributesA(
    PCSTR lpFileName,
    DWORD dwFileAttributes
    );

BOOL
APIENTRY
SpSetFileAttributesW(
    PCWSTR lpFileName,
    DWORD dwFileAttributes
    );

UINT
WINAPI
SpWin32GetTempFileNameW(
    PCWSTR TempDirectory,
    PCWSTR Prefix,
    UINT   IgnoredNumber,
    PWSTR  File
    );

BOOL
APIENTRY
SpGetFileAttributesExA(
    PCSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    PVOID lpFileInformation
    );

BOOL
APIENTRY
SpGetFileAttributesExW(
    LPCWSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFileInformation
    );

WINBASEAPI
BOOL
WINAPI
SpWin32CreateDirectoryW(
    IN PCWSTR lpPathName,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\textmode.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    textmode.h

Abstract:

    main textmode header file

Revision History:

--*/

//
// This header file is intended to be used with PCH
// (precompiled header files).
//

//
// NT header files
//
#if !defined(NOWINBASEINTERLOCK)
#define NOWINBASEINTERLOCK
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#undef _WINBASE_
#include <ntosp.h>
#define _WINBASE_

#include <zwapi.h>

#include "fci.h"

#include <mountmgr.h>
#include <inbv.h>

#include <ntdddisk.h>
#include <ntddvdeo.h>
#include <ntddft.h>
#include <ntddnfs.h>
#include <ntddvol.h>
#include <ntddramd.h>
#include <fmifs.h>
#include <pnpsetup.h>

//
// CRT header files
//
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>

//
// Setup header files
//
#include <setupbat.h>
#include "setupblk.h"
#include "spvideo.h"
#include "spdsputl.h"
#include "spmemory.h"
#include "spkbd.h"
#include "spmsg.h"
#include "spfile.h"
#include "spsif.h"
#include "spgauge.h"
#include "spfsrec.h"
#include "spdisk.h"
#include "sppartit.h"
#include "sptxtfil.h"
#include "spmenu.h"
#include "spreg.h"
#include "spmisc.h"
#include "sppartp.h"
#include "sphw.h"
#include "sparc.h"
#include "spnttree.h"
#include "scsi.h"
#include "setupdd.h"
#include "spvideop.h"
#include "spcopy.h"
#include "spboot.h"
#include "spdblspc.h"
#include "dynupdt.h"

#ifndef KERNEL_MODE
#define KERNEL_MODE
#endif

#undef TEXT
#define TEXT(quote) L##quote
#include <regstr.h>

#include "compliance.h"

#include "spntupg.h"
#include "spnetupg.h"
#include "spupgcfg.h"
#include "spstring.h"
#include "spntfix.h"
#include "spddlang.h"
#include "spdr.h"
#include "spdrpriv.h"
#include "spsysprp.h"
#include "spterm.h"
#include "spptdump.h"


#include "spudp.h"
//
// Platform-specific header files
//
#ifdef _X86_
#include "spi386.h"
#endif

#include "spswitch.h"
#include "graphics.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\cabtest\cabtest.c ===
#include <stdlib.h>
#include "textmode.h"
#include "spcab.h"

const PRTL_ALLOCATE_STRING_ROUTINE RtlAllocateStringRoutine = SpMemAlloc;
const PRTL_FREE_STRING_ROUTINE RtlFreeStringRoutine = SpMemFree;

WCHAR TemporaryBuffer[16384];

PWSTR SpCabDupStringW(PCWSTR s)
{
    if (s == NULL)
        return NULL;
    else
    {
        PWSTR q = (PWSTR)RtlAllocateHeap(RtlProcessHeap(), 0, (wcslen(s) + 1) * sizeof(*q));
        if (q)
            wcscpy(q, s);
        return q;
    }
}

PVOID SpMemAlloc(SIZE_T n)
{
    return RtlAllocateHeap(RtlProcessHeap(), 0, n);
}

VOID  SpMemFree(PVOID p)
{
    RtlFreeHeap(RtlProcessHeap(), 0, p);
}

PVOID
SpMemRealloc(
    IN PVOID Block,
    IN SIZE_T NewSize
    )
{
    return RtlReAllocateHeap(RtlProcessHeap(), 0, Block, NewSize);
}

int g_argi = 0;

void CabTestCreateW(int argc, wchar_t** argv)
{
    CCABHANDLE CabHandle;
    wchar_t** LocalArgv = argv + g_argi;

    CabHandle = SpCabCreateCabinetW(LocalArgv[1], (LocalArgv[1][0] != 0) ? LocalArgv[2] : NULL, (LocalArgv[3][0] != 0) ? LocalArgv[3] : NULL, 0);
    SpCabAddFileToCabinetW(CabHandle, LocalArgv[4], (LocalArgv[5] != NULL && LocalArgv[5][0] != 0) ? LocalArgv[5] : LocalArgv[4]);
    SpCabFlushAndCloseCabinetEx(CabHandle, NULL, NULL, NULL, NULL);

    g_argi += 4;
    g_argi += (LocalArgv[5] != NULL);

/*
SpCabCreateCabinetExW(0,0);
SpCabOpenCabinetW(0);
SpCabExtractAllFilesExW(0,0,0);
SpCabCloseCabinetW(0);

SpCabCreateCabinetA(0,0,0,0);
SpCabCreateCabinetExA(0,0);
SpCabOpenCabinetA(0);
SpCabExtractAllFilesExA(0,0,0);
SpCabCloseCabinetA(0);
*/
}

BOOL CabTestExtractFileCallbackW(PCWSTR File)
{
    printf("extracting %ls\n", File);
    return TRUE;
}

BOOL CabTestExtractFileCallbackA(PCSTR File)
{
    printf("extracting %s\n", File);
    return TRUE;
}

void CabTestExtractW(int argc, wchar_t** argv)
{
    CCABHANDLE CabHandle;
    wchar_t** LocalArgv = argv + g_argi;

    CabHandle = SpCabOpenCabinetW(LocalArgv[1]);
    SpCabExtractAllFilesExW(CabHandle, LocalArgv[2], CabTestExtractFileCallbackW);
    SpCabCloseCabinet(CabHandle);

    g_argi += 2;
}

void CabTestExtractA(int argc, char** argv)
{
    CCABHANDLE CabHandle;
    char** LocalArgv = argv + g_argi;

    CabHandle = SpCabOpenCabinetA(LocalArgv[1]);
    SpCabExtractAllFilesExA(CabHandle, LocalArgv[2], CabTestExtractFileCallbackA);
    SpCabCloseCabinet(CabHandle);

    g_argi += 2;
}

void CabTestCreateA(int argc, char** argv)
{
    CCABHANDLE CabHandle;
    char** LocalArgv = argv + g_argi;

    CabHandle = SpCabCreateCabinetA(LocalArgv[1], (LocalArgv[1][0] != 0) ? LocalArgv[2] : NULL, (LocalArgv[3][0] != 0) ? LocalArgv[3] : NULL, 0);
    SpCabAddFileToCabinetA(CabHandle, LocalArgv[4], (LocalArgv[5] != NULL && LocalArgv[5][0] != 0) ? LocalArgv[5] : LocalArgv[4]);
    SpCabFlushAndCloseCabinetEx(CabHandle, NULL, NULL, NULL, NULL);

    g_argi += 4;
    g_argi += (LocalArgv[5] != NULL);
}

void MainA(int argc, char** argv)
{
    argv[1] += (argv[1][0] == '-');
    if (_stricmp(argv[1], "create") == 0)
        CabTestCreateA(argc - 1, argv + 1);
    else if (_stricmp(argv[1], "extract") == 0)
        CabTestExtractA(argc - 1, argv + 1);
}

void MainW(int argc, wchar_t** argv)
{
    argv[1] += (argv[1][0] == '-');
    if (_wcsicmp(argv[1], L"create") == 0)
        CabTestCreateW(argc - 1, argv + 1);
    else if (_wcsicmp(argv[1], L"extract") == 0)
        CabTestExtractW(argc - 1, argv + 1);
}

int __cdecl wmain(int argc, wchar_t** argv)
{
    MainW(argc, argv);
    return 0;
}

void __cdecl wmainCRTStartup(void);

int __cdecl main(int argc, char** argv)
{
    MainA(argc, argv);
    wmainCRTStartup(); // trick to get A and W coverage in a single binary, this call doesn't return
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spwin.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    spwin.c

Abstract:

    Win32 portability layer to support windows\winstate\...\cablib.c
        file i/o
        Get/SpSetLastWin32Error

    see also
        .\spcab.c
        .\spbasefile.c
        .\spbasefile.h
        windows\winstate\...\cablib.c
        windows\winstate\cobra\utils\main\basefile.c
        windows\winstate\cobra\utils\inc\basefile.h

Author:

    Jay Krell (a-JayK) November 2000

Revision History:

--*/

#include "spprecmp.h"
#include "spcab.h"
#include "nt.h"
#include "ntrtl.h"
#include "zwapi.h"
#include "spwin.h"
#include "spwinp.h"
#include <limits.h>
#include "fci.h"

//
// fold with rtl..
//
extern const UNICODE_STRING SpWin32NtRoot         = RTL_CONSTANT_STRING( L"\\\\?" );
extern const UNICODE_STRING SpWin32NtRootSlash    = RTL_CONSTANT_STRING( L"\\\\?\\" );
extern const UNICODE_STRING SpWin32NtUncRoot      = RTL_CONSTANT_STRING( L"\\\\?\\UNC" );
extern const UNICODE_STRING SpWin32NtUncRootSlash = RTL_CONSTANT_STRING( L"\\\\?\\UNC\\" );

NTSTATUS
SpConvertWin32FileOpenOrCreateToNtFileOpenOrCreate(
    ULONG Win32OpenOrCreate,
    ULONG* NtOpenOrCreate
    )
{
    //
    // there's no pattern here and the values all overlap
    // yuck; this is copied from kernel32 source
    //
    *NtOpenOrCreate = ~0;
    switch (Win32OpenOrCreate)
    {
    default:
        return STATUS_INVALID_PARAMETER;
    case CREATE_NEW:
        *NtOpenOrCreate = FILE_CREATE;
        break;
    case CREATE_ALWAYS:
        *NtOpenOrCreate = FILE_OVERWRITE_IF;
        break;
    case OPEN_EXISTING:
        *NtOpenOrCreate = FILE_OPEN;
        break;
    case OPEN_ALWAYS:
        *NtOpenOrCreate = FILE_OPEN_IF;
        break;
    case TRUNCATE_EXISTING :
        *NtOpenOrCreate = FILE_OPEN;
    }
    return STATUS_SUCCESS;
}

NTSTATUS
SpConvertWin32FileAccessToNtFileAccess(
    ULONG  Win32FileAccess,
    ULONG* NtFileAccess
    )
{
    //
    // ZwCreateFile oddities require us to do this conversion, or at least
    // to add in SYNCHRONIZE.
    //
    *NtFileAccess =
           (Win32FileAccess & ~(GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL))
        | ((Win32FileAccess & GENERIC_READ) ? FILE_GENERIC_READ : 0)
        | ((Win32FileAccess & GENERIC_WRITE) ? FILE_GENERIC_WRITE : 0)
        | ((Win32FileAccess & GENERIC_EXECUTE) ? FILE_GENERIC_EXECUTE : 0)
        | ((Win32FileAccess & GENERIC_ALL) ? FILE_ALL_ACCESS : 0)
        | SYNCHRONIZE
        ;
    return STATUS_SUCCESS;
}

NTSTATUS
SpConvertWin32FileShareToNtFileShare(
    ULONG  Win32FileShare,
    ULONG* NtFileShare
    )
{
    *NtFileShare = Win32FileShare;
    return STATUS_SUCCESS;
}

NTSTATUS
SpGetLastNtStatus(
    VOID
    )
{
    return NtCurrentTeb()->LastStatusValue;
}

ULONG
WINAPI
SpGetLastWin32Error(
    VOID
    )
{
    return NtCurrentTeb()->LastErrorValue;
}

VOID
WINAPI
SpSetLastWin32Error(
    ULONG Error
    )
{
#if DBG
    if (NtCurrentTeb()->LastErrorValue != Error)
#endif
        NtCurrentTeb()->LastErrorValue = Error;
}

VOID
SpSetLastWin32ErrorAndNtStatusFromNtStatus(
    NTSTATUS Status
    )
{
    SpSetLastWin32Error(RtlNtStatusToDosError(Status));
}

HANDLE
SpNtCreateFileW(
    PCUNICODE_STRING           ConstantPath,
    IN ULONG                   FileAccess,
    IN ULONG                   FileShare,
    IN LPSECURITY_ATTRIBUTES   SecurityAttributes,
    IN ULONG                   Win32FileOpenOrCreate,
    IN ULONG                   FlagsAndAttributes,
    IN HANDLE                  TemplateFile
    )
/*++
Subset:
    no security
    no directories
    no async
    no console
    no ea (extended attributes)
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock = { 0 };
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    ULONG NtFileOpenOrCreate = 0;
    FILE_ALLOCATION_INFORMATION AllocationInfo = { 0 };
    PUNICODE_STRING Path = RTL_CONST_CAST(PUNICODE_STRING)(ConstantPath);
    /*const*/OBJECT_ATTRIBUTES ObjectAttributes = { sizeof(ObjectAttributes), NULL, Path, OBJ_CASE_INSENSITIVE };

    ASSERT(TemplateFile == NULL);
    ASSERT(SecurityAttributes == NULL);
    ASSERT((FlagsAndAttributes & ~(FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_ARCHIVE)) == 0);

    if (!NT_SUCCESS(Status = SpConvertWin32FileAccessToNtFileAccess(FileAccess, &FileAccess)))
        goto NtExit;
    if (!NT_SUCCESS(Status = SpConvertWin32FileOpenOrCreateToNtFileOpenOrCreate(Win32FileOpenOrCreate, &NtFileOpenOrCreate)))
        goto NtExit;
    if (!NT_SUCCESS(Status = SpConvertWin32FileShareToNtFileShare(FileShare, &FileShare)))
        goto NtExit;

    Status =
        ZwCreateFile(
            &FileHandle,
            FileAccess
                | SYNCHRONIZE // like kernel32
                | FILE_READ_ATTRIBUTES,  // like kernel32
            &ObjectAttributes,
            &IoStatusBlock,
            NULL, // AllocationSize
            FlagsAndAttributes,
            FileShare,
            NtFileOpenOrCreate,
            FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE,
            NULL, // EaBuffer,
            0 // EaLength
            );

    // based closely on kernel32

    if ( !NT_SUCCESS(Status) ) {
        SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
        if ( Status == STATUS_OBJECT_NAME_COLLISION ) {
            SpSetLastWin32Error(ERROR_FILE_EXISTS);
        }
        else if ( Status == STATUS_FILE_IS_A_DIRECTORY ) {
            if (Path->Length != 0 && Path->Buffer[Path->Length / sizeof(Path->Buffer[0])] == '\\') {
                SpSetLastWin32Error(ERROR_PATH_NOT_FOUND);
            }
            else {
                SpSetLastWin32Error(ERROR_ACCESS_DENIED);
            }
        }
        FileHandle = INVALID_HANDLE_VALUE;
        goto Exit;
    }

    //
    // if NT returns supersede/overwritten, it means that a create_always, openalways
    // found an existing copy of the file. In this case ERROR_ALREADY_EXISTS is returned
    //

    if ( (Win32FileOpenOrCreate == CREATE_ALWAYS && IoStatusBlock.Information == FILE_OVERWRITTEN) ||
         (Win32FileOpenOrCreate == OPEN_ALWAYS && IoStatusBlock.Information == FILE_OPENED) ) {
        SpSetLastWin32Error(ERROR_ALREADY_EXISTS);
    }
    else {
        SpSetLastWin32Error(0);
    }

    //
    // Truncate the file if required
    //

    if ( Win32FileOpenOrCreate == TRUNCATE_EXISTING) {

        AllocationInfo.AllocationSize.QuadPart = 0;
        Status = ZwSetInformationFile(
                    FileHandle,
                    &IoStatusBlock,
                    &AllocationInfo,
                    sizeof(AllocationInfo),
                    FileAllocationInformation
                    );
        if ( !NT_SUCCESS(Status) ) {
            ZwClose(FileHandle);
            FileHandle = INVALID_HANDLE_VALUE;
            SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
        }
    }
Exit:
    return FileHandle;
NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
    goto Exit;
}

HANDLE
WINAPI
SpWin32CreateFileW(
    IN PCWSTR FileName,
    IN ULONG  FileAccess,
    IN ULONG  FileShare,
    IN LPSECURITY_ATTRIBUTES SecurityAttributes,
    IN ULONG  FileOpenOrCreate,
    IN ULONG  FlagsAndAttributes,
    IN HANDLE TemplateFile
    )
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    UNICODE_STRING UnicodeString = { 0 };
    NTSTATUS Status = STATUS_SUCCESS;

    RtlInitUnicodeString(&UnicodeString, FileName);

    FileHandle = SpNtCreateFileW(&UnicodeString, FileAccess, FileShare, SecurityAttributes, FileOpenOrCreate, FlagsAndAttributes, TemplateFile);
    ASSERT (FileHandle);    // never NULL
    if (FileHandle == INVALID_HANDLE_VALUE)
        goto Exit;
Exit:
    return FileHandle;
}

HANDLE
WINAPI
SpWin32CreateFileA(
    IN PCSTR FileName,
    IN ULONG FileAccess,
    IN ULONG FileShare,
    IN LPSECURITY_ATTRIBUTES SecurityAttributes,
    IN ULONG FileOpenOrCreate,
    IN ULONG dwFlagsAndAttributes,
    IN HANDLE TemplateFile
    )
{
    ANSI_STRING AnsiString = { 0 };
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE Handle = INVALID_HANDLE_VALUE;

    UNICODE_STRING UnicodeString = { 0 };

    RtlInitAnsiString(&AnsiString, FileName);
    AnsiString.Length = AnsiString.MaximumLength; // include terminal nul

    if (!NT_SUCCESS(Status = SpAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE)))
        goto NtExit;

    UnicodeString.Length -= sizeof(UnicodeString.Buffer[0]); // remove terminal nul

    Handle = SpNtCreateFileW(&UnicodeString, FileAccess, FileShare, SecurityAttributes, FileOpenOrCreate, dwFlagsAndAttributes, TemplateFile);
Exit:
    SpFreeStringW(&UnicodeString);
    KdPrintEx((
        DPFLTR_SETUP_ID,
        SpHandleToDbgPrintLevel(Handle),
        "SETUP:"__FUNCTION__"(%s) exiting with FileHandle: %p Status:0x%08lx Error:%d\n",
        FileName, Handle, SpGetLastNtStatus(), SpGetLastWin32Error()
        ));
    return Handle;

NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
    goto Exit;
}

BOOL
WINAPI
SpWin32ReadFile(
    HANDLE hFile,
    PVOID lpBuffer,
    ULONG nNumberOfBytesToRead,
    ULONG* lpNumberOfBytesRead,
    LPOVERLAPPED lpOverlapped
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    ASSERT(!ARGUMENT_PRESENT(lpOverlapped));

    if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
        *lpNumberOfBytesRead = 0;
        }

    Status = ZwReadFile(
            hFile,
            NULL,
            NULL,
            NULL,
            &IoStatusBlock,
            lpBuffer,
            nNumberOfBytesToRead,
            NULL,
            NULL
            );

    if ( Status == STATUS_PENDING) {
        // Operation must complete before return & IoStatusBlock destroyed
        Status = ZwWaitForSingleObject( hFile, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {
            Status = IoStatusBlock.Status;
            }
        }

    if ( NT_SUCCESS(Status) ) {
        *lpNumberOfBytesRead = (ULONG)IoStatusBlock.Information;
        return TRUE;
        }
    else
    if (Status == STATUS_END_OF_FILE) {
        *lpNumberOfBytesRead = 0;
        return TRUE;
        }
    else {
        if ( NT_WARNING(Status) ) {
            *lpNumberOfBytesRead = (ULONG)IoStatusBlock.Information;
            }
        SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
        return FALSE;
        }
}

BOOL
WINAPI
SpWin32WriteFile(
    HANDLE hFile,
    CONST VOID* lpBuffer,
    ULONG nNumberOfBytesToWrite,
    ULONG* lpNumberOfBytesWritten,
    LPOVERLAPPED lpOverlapped
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PPEB Peb;

    ASSERT(!ARGUMENT_PRESENT( lpOverlapped ) );

    if ( ARGUMENT_PRESENT(lpNumberOfBytesWritten) ) {
        *lpNumberOfBytesWritten = 0;
        }

    Status = ZwWriteFile(
            hFile,
            NULL,
            NULL,
            NULL,
            &IoStatusBlock,
            RTL_CONST_CAST(PVOID)(lpBuffer),
            nNumberOfBytesToWrite,
            NULL,
            NULL
            );

    if ( Status == STATUS_PENDING) {
        // Operation must complete before return & IoStatusBlock destroyed
        Status = ZwWaitForSingleObject( hFile, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {
            Status = IoStatusBlock.Status;
            }
        }

    if ( NT_SUCCESS(Status)) {
        *lpNumberOfBytesWritten = (ULONG)IoStatusBlock.Information;
        return TRUE;
        }
    else {
        if ( NT_WARNING(Status) ) {
            *lpNumberOfBytesWritten = (ULONG)IoStatusBlock.Information;
            }
        SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
        return FALSE;
        }
}

ULONG
WINAPI
SpSetFilePointer(
    HANDLE hFile,
    LONG lDistanceToMove,
    LONG* lpDistanceToMoveHigh,
    ULONG dwMoveMethod
    )
{

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_POSITION_INFORMATION CurrentPosition;
    FILE_STANDARD_INFORMATION StandardInfo;
    LARGE_INTEGER Large;

    if (ARGUMENT_PRESENT(lpDistanceToMoveHigh)) {
        Large.HighPart = *lpDistanceToMoveHigh;
        Large.LowPart = lDistanceToMove;
        }
    else {
        Large.QuadPart = lDistanceToMove;
        }
    switch (dwMoveMethod) {
        case FILE_BEGIN :
            CurrentPosition.CurrentByteOffset = Large;
                break;

        case FILE_CURRENT :

            //
            // Get the current position of the file pointer
            //

            Status = ZwQueryInformationFile(
                        hFile,
                        &IoStatusBlock,
                        &CurrentPosition,
                        sizeof(CurrentPosition),
                        FilePositionInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
                return (ULONG)(LONG)-1;
                }
            CurrentPosition.CurrentByteOffset.QuadPart += Large.QuadPart;
            break;

        case FILE_END :
            Status = ZwQueryInformationFile(
                        hFile,
                        &IoStatusBlock,
                        &StandardInfo,
                        sizeof(StandardInfo),
                        FileStandardInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
                return (ULONG)(LONG)-1;
                }
            CurrentPosition.CurrentByteOffset.QuadPart =
                                StandardInfo.EndOfFile.QuadPart + Large.QuadPart;
            break;

        default:
            SpSetLastWin32Error(ERROR_INVALID_PARAMETER);
            return (ULONG)(LONG)-1;
            break;
        }

    //
    // If the resulting file position is negative, or if the app is not
    // prepared for greater than
    // than 32 bits than fail
    //

    if ( CurrentPosition.CurrentByteOffset.QuadPart < 0 ) {
        SpSetLastWin32Error(ERROR_NEGATIVE_SEEK);
        return (ULONG)(LONG)-1;
        }
    if ( !ARGUMENT_PRESENT(lpDistanceToMoveHigh) &&
        (CurrentPosition.CurrentByteOffset.HighPart & MAXLONG) ) {
        SpSetLastWin32Error(ERROR_INVALID_PARAMETER);
        return (ULONG)(LONG)-1;
        }


    //
    // Set the current file position
    //

    Status = ZwSetInformationFile(
                hFile,
                &IoStatusBlock,
                &CurrentPosition,
                sizeof(CurrentPosition),
                FilePositionInformation
                );
    if ( NT_SUCCESS(Status) ) {
        if (ARGUMENT_PRESENT(lpDistanceToMoveHigh)){
            *lpDistanceToMoveHigh = CurrentPosition.CurrentByteOffset.HighPart;
            }
        if ( CurrentPosition.CurrentByteOffset.LowPart == -1 ) {
            SpSetLastWin32Error(0);
            }
        return CurrentPosition.CurrentByteOffset.LowPart;
        }
    else {
        SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
        if (ARGUMENT_PRESENT(lpDistanceToMoveHigh)){
            *lpDistanceToMoveHigh = -1;
            }
        return (ULONG)(LONG)-1;
        }
}

BOOL
WINAPI
SpWin32DeleteFileA(
    PCSTR FileName
    )
{
    BOOL Success = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;
    ANSI_STRING AnsiString = { 0 };
    UNICODE_STRING UnicodeString = { 0 };

    if (FileName == NULL || FileName[0] == 0) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_TRACE_LEVEL,
            "SETUP:"__FUNCTION__"(NULL or empty), claiming success\n"
            ));
        Success = TRUE;
        goto Exit;
    }

    RtlInitAnsiString(&AnsiString, FileName);
    AnsiString.Length = AnsiString.MaximumLength; // include terminal nul

    Status = SpAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);
    if (!NT_SUCCESS(Status))
        goto NtExit;

    Status = SpDeleteFile(UnicodeString.Buffer, NULL, NULL);
    if (!NT_SUCCESS(Status))
        goto NtExit;

    Success = TRUE;
Exit:
    SpFreeStringW(&UnicodeString);
    KdPrintEx((
        DPFLTR_SETUP_ID,
        SpBoolToDbgPrintLevel(Success),
        "SETUP:"__FUNCTION__"(%s) exiting with Success: %s Status:0x%08lx Error:%d\n",
        FileName, SpBooleanToStringA(Success), SpGetLastNtStatus(), SpGetLastWin32Error()
        ));
    return Success;
NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
    goto Exit;
}

//
// move this to ntrtl
//

#define AlmostTwoSeconds (2*1000*1000*10 - 1)

BOOL
APIENTRY
SpFileTimeToDosDateTime(
    CONST FILETIME *lpFileTime,
    LPWORD lpFatDate,
    LPWORD lpFatTime
    )
{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER FileTime;

    FileTime.LowPart = lpFileTime->dwLowDateTime;
    FileTime.HighPart = lpFileTime->dwHighDateTime;

    FileTime.QuadPart = FileTime.QuadPart + (LONGLONG)AlmostTwoSeconds;

    if ( FileTime.QuadPart < 0 ) {
        SpSetLastWin32Error(ERROR_INVALID_PARAMETER);
        return FALSE;
        }
    RtlTimeToTimeFields(&FileTime, &TimeFields);

    if (TimeFields.Year < 1980 || TimeFields.Year > 2107) {
        SpSetLastWin32ErrorAndNtStatusFromNtStatus(STATUS_INVALID_PARAMETER);
        return FALSE;
        }

    *lpFatDate = (WORD)( ((USHORT)(TimeFields.Year-(CSHORT)1980) << 9) |
                         ((USHORT)TimeFields.Month << 5) |
                         (USHORT)TimeFields.Day
                       );

    *lpFatTime = (WORD)( ((USHORT)TimeFields.Hour << 11) |
                         ((USHORT)TimeFields.Minute << 5) |
                         ((USHORT)TimeFields.Second >> 1)
                       );

    return TRUE;
}

BOOL
APIENTRY
SpDosDateTimeToFileTime(
    WORD wFatDate,
    WORD wFatTime,
    LPFILETIME lpFileTime
    )
{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER FileTime;

    TimeFields.Year         = (CSHORT)((wFatDate & 0xFE00) >> 9)+(CSHORT)1980;
    TimeFields.Month        = (CSHORT)((wFatDate & 0x01E0) >> 5);
    TimeFields.Day          = (CSHORT)((wFatDate & 0x001F) >> 0);
    TimeFields.Hour         = (CSHORT)((wFatTime & 0xF800) >> 11);
    TimeFields.Minute       = (CSHORT)((wFatTime & 0x07E0) >>  5);
    TimeFields.Second       = (CSHORT)((wFatTime & 0x001F) << 1);
    TimeFields.Milliseconds = 0;

    if (RtlTimeFieldsToTime(&TimeFields,&FileTime)) {
        lpFileTime->dwLowDateTime = FileTime.LowPart;
        lpFileTime->dwHighDateTime = FileTime.HighPart;
        return TRUE;
        }
    else {
        SpSetLastWin32ErrorAndNtStatusFromNtStatus(STATUS_INVALID_PARAMETER);
        return FALSE;
        }
}

BOOL
WINAPI
SpFileTimeToLocalFileTime(
    CONST FILETIME *lpFileTime,
    LPFILETIME lpLocalFileTime
    )
{
    //
    // just return it unchanged
    // UTC is good
    //
    *lpLocalFileTime = *lpFileTime;
    return TRUE;
}

BOOL
WINAPI
SpLocalFileTimeToFileTime(
    CONST FILETIME *lpLocalFileTime,
    LPFILETIME lpFileTime
    )
{
    //
    // just return it unchanged
    // UTC is good
    //
    *lpFileTime = *lpLocalFileTime;
    return TRUE;
}

BOOL
WINAPI
SpSetFileTime(
    HANDLE hFile,
    CONST FILETIME *lpCreationTime,
    CONST FILETIME *lpLastAccessTime,
    CONST FILETIME *lpLastWriteTime
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicInfo = { 0 };

    //
    // For each time value that is specified, copy it to the I/O system
    // record.
    //
    if (ARGUMENT_PRESENT( lpCreationTime )) {
        BasicInfo.CreationTime.LowPart = lpCreationTime->dwLowDateTime;
        BasicInfo.CreationTime.HighPart = lpCreationTime->dwHighDateTime;
        }

    if (ARGUMENT_PRESENT( lpLastAccessTime )) {
        BasicInfo.LastAccessTime.LowPart = lpLastAccessTime->dwLowDateTime;
        BasicInfo.LastAccessTime.HighPart = lpLastAccessTime->dwHighDateTime;
        }

    if (ARGUMENT_PRESENT( lpLastWriteTime )) {
        BasicInfo.LastWriteTime.LowPart = lpLastWriteTime->dwLowDateTime;
        BasicInfo.LastWriteTime.HighPart = lpLastWriteTime->dwHighDateTime;
        }

    //
    // Set the requested times.
    //

    Status = ZwSetInformationFile(
                hFile,
                &IoStatusBlock,
                &BasicInfo,
                sizeof(BasicInfo),
                FileBasicInformation
                );

    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
        return FALSE;
        }
}

BOOL
APIENTRY
SpSetFileAttributesA(
    PCSTR lpFileName,
    DWORD dwFileAttributes
    )
{
    UNICODE_STRING UnicodeString = { 0 };
    ANSI_STRING    AnsiString = { 0 };
    BOOL Success = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;

    RtlInitAnsiString(&AnsiString, lpFileName);
    AnsiString.Length = AnsiString.MaximumLength; // include terminal nul

    if (!NT_SUCCESS(Status = SpAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE)))
        goto NtExit;

    Success = ( SpSetFileAttributesW(
                UnicodeString.Buffer,
                dwFileAttributes
                )
            );

    if (!Success)
        goto Exit;

    Success = TRUE;
Exit:
    SpFreeStringW(&UnicodeString);
    return Success;
NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
    goto Exit;
}

BOOL
APIENTRY
SpSetFileAttributesW(
    PCWSTR lpFileName,
    DWORD dwFileAttributes
    )
{
    BOOL     Success = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE Handle;
    UNICODE_STRING FileName;
    OBJECT_ATTRIBUTES ObjectAttributes = { sizeof(ObjectAttributes), NULL, &FileName, OBJ_CASE_INSENSITIVE };
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicInfo = { 0 };

    RtlInitUnicodeString(&FileName, lpFileName);

    //
    // Open the file inhibiting the reparse behavior.
    //

    Status = ZwOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
                );

    if ( !NT_SUCCESS(Status) ) {
        SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
        goto Exit;
    }

    //
    // Set the attributes
    //

    BasicInfo.FileAttributes = (dwFileAttributes & FILE_ATTRIBUTE_VALID_SET_FLAGS) | FILE_ATTRIBUTE_NORMAL;

    Status = ZwSetInformationFile(
                Handle,
                &IoStatusBlock,
                &BasicInfo,
                sizeof(BasicInfo),
                FileBasicInformation
                );

    ZwClose(Handle);
    if ( !NT_SUCCESS(Status) ) {
        SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
        goto Exit;
    }

    Success = TRUE;
Exit:
    return Success;
}


NTSTATUS
SpAllocateLocallyUniqueId(
    PLUID Luid
    )
/*
hack until ZwAllocateLocallyUniqueId is exported
*/
{
    static LUID Counter = { 0, 0 };
//
// This does not actually correctly deal with wrapperaround in a multithreaded environment.
// That's ok with us, and we can switch to ZwAllocateLocallyUniqueId.
//
    Luid->LowPart = InterlockedIncrement(&Counter.LowPart);
    if (Luid->LowPart == 0)
        Luid->HighPart = 0; /*InterlockedIncrement(&Counter.HighPart);*/
    else
        Luid->HighPart = 0; /*Counter.HighPart;*/

    return STATUS_SUCCESS;
}

#if 0

UINT
WINAPI
SpWin32GetTempFileNameW(
    PCWSTR TempDirectory,
    PCWSTR Prefix, // oops, I forgot to handle this..
    UINT   IgnoredNumber,
    PWSTR  File
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    LUID Luid = { 0 };
    UNICODE_STRING UnicodeString = { 0 };
    WCHAR LuidStringBuffer[sizeof(LUID) * CHAR_BIT];
    UNICODE_STRING LuidString = { 0, sizeof(LuidStringBuffer), LuidStringBuffer };
    /*const*/ static UNICODE_STRING BackSlashString = RTL_CONSTANT_STRING(L"\\");
    LARGE_INTEGER LargeInteger = { 0 };
    UINT Length = 0;

    ASSERT(TempDirectory != NULL && TempDirectory[0] != 0);

    Status = SpAllocateLocallyUniqueId(&Luid);
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            SpNtStatusToDbgPrintLevel(Status),
            "SETUP:"__FUNCTION__":AllocateLocallyUniqueId:0x%08lx\n",
            Status
            ));
        goto NtExit;
    }
    LargeInteger.LowPart = Luid.LowPart;
    LargeInteger.HighPart = Luid.HighPart;

    UnicodeString.Buffer = File;
    UnicodeString.Length = 0;
    UnicodeString.MaximumLength = (CB_MAX_CAB_PATH - 1) * sizeof(UnicodeString.Buffer[0]);

    Status = RtlAppendUnicodeToString(&UnicodeString, TempDirectory);
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            SpNtStatusToDbgPrintLevel(Status),
            "SETUP:"__FUNCTION__":RtlAppendUnicodeToString:0x%08lx\n",
            Status
            ));
        goto NtExit;
    }

    if (UnicodeString.Buffer[UnicodeString.Length / sizeof(UnicodeString.Buffer[0]) - 1] != BackSlashString.Buffer[0]) {
        Status = RtlAppendUnicodeStringToString(&UnicodeString, &BackSlashString);
        if (!NT_SUCCESS(Status)) {
            KdPrintEx((
                DPFLTR_SETUP_ID,
                SpNtStatusToDbgPrintLevel(Status),
                "SETUP:"__FUNCTION__":RtlAppendUnicodeStringToString:0x%08lx\n",
                Status
                ));
            goto NtExit;
        }
    }
    Status = RtlInt64ToUnicodeString(LargeInteger.QuadPart, 10, &LuidString);
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            SpNtStatusToDbgPrintLevel(Status),
            "SETUP:"__FUNCTION__":RtlInt64ToUnicodeString:0x%08lx\n",
            Status
            ));
        goto NtExit;
    }
    Status = RtlAppendUnicodeStringToString(&UnicodeString, &LuidString);
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            SpNtStatusToDbgPrintLevel(Status),
            "SETUP:"__FUNCTION__":RtlAppendUnicodeStringToString:0x%08lx\n",
            Status
            ));
        goto NtExit;
    }

    Length = UnicodeString.Length / sizeof(UnicodeString.Buffer[0]);
    UnicodeString.Buffer[Length] = 0;
Exit:
    KdPrintEx((
        DPFLTR_SETUP_ID,
        SpBoolToDbgPrintLevel(Length != 0),
        "SETUP:"__FUNCTION__":Length:0x%08lx\n",
        Length
        ));
    return Length;
NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
    goto Exit;
}

#endif

BOOL
APIENTRY
SpGetFileAttributesExA(
    PCSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    PVOID lpFileInformation
    )
{
    UNICODE_STRING UnicodeString = { 0 };
    ANSI_STRING    AnsiString = { 0 };
    BOOL Success = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;

    RtlInitAnsiString(&AnsiString, lpFileName);
    AnsiString.Length = AnsiString.MaximumLength; // include terminal nul

    if (!NT_SUCCESS(Status = SpAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE))) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            SpNtStatusToDbgPrintLevel(Status),
            "SETUP:"__FUNCTION__":SpAnsiStringToUnicodeString:0x%08lx\n",
            Status
            ));
        goto NtExit;
    }

    Success = SpGetFileAttributesExW(
                UnicodeString.Buffer,
                fInfoLevelId,
                lpFileInformation
                );

Exit:
    SpFreeStringW(&UnicodeString);

    return Success;
NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
    goto Exit;
}

#if 0
NTSTATUS
SpQueryFullAttributesFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PFILE_NETWORK_OPEN_INFORMATION FileInformation
    )
/*
cut dependency for now on NtQueryFullAttributesFile, since it isn't yet exported
and I'm having problems with the kernel I built, use Jim's instead..
*/
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    NTSTATUS Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;

    Status =
        ZwCreateFile(
            &FileHandle,
            FILE_READ_ATTRIBUTES,
            ObjectAttributes,
            &IoStatusBlock,
            NULL, // AllocationSize
            0, // FileAttributes
            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
            FILE_OPEN, // CreateDisposition
            FILE_OPEN_REPARSE_POINT | FILE_OPEN_FOR_BACKUP_INTENT, // CreateOptions
            NULL, // ea
            0 // ea
            );
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            SpNtStatusToDbgPrintLevel(Status),
            "SETUP:"__FUNCTION__":ZwCreateFile:0x%08lx\n",
            Status
            ));
        goto Exit;
    }
    Status =
        ZwQueryInformationFile(
            FileHandle,
            &IoStatusBlock,
            FileInformation,
            sizeof(*FileInformation),
            FileNetworkOpenInformation
            );
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            SpNtStatusToDbgPrintLevel(Status),
            "SETUP:"__FUNCTION__":ZwQueryInformationFile:0x%08lx\n",
            Status
            ));
        goto Exit;
    }

    Status = STATUS_SUCCESS;
Exit:
    if (FileHandle != INVALID_HANDLE_VALUE) {
        ZwClose(FileHandle);
    }
    return Status;
}
#else
#define SpQueryFullAttributesFile ZwQueryFullAttributesFile
#endif
BOOL
APIENTRY
SpGetFileAttributesExW(
    LPCWSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFileInformation
    )
// from base\win32\client\filemisc.c
{
    NTSTATUS Status;
    UNICODE_STRING FileName;
    /*const*/ OBJECT_ATTRIBUTES ObjectAttributes = { sizeof(ObjectAttributes), NULL, &FileName, OBJ_CASE_INSENSITIVE };
    FILE_NETWORK_OPEN_INFORMATION NetworkInfo;

    RtlInitUnicodeString(&FileName, lpFileName);

    if ( !RTL_SOFT_VERIFY(fInfoLevelId == GetFileExInfoStandard )) {
        SpSetLastWin32Error(ERROR_INVALID_PARAMETER);
        return FALSE;
        }

    Status = SpQueryFullAttributesFile( &ObjectAttributes, &NetworkInfo );
    if ( NT_SUCCESS(Status) ) {
        const LPWIN32_FILE_ATTRIBUTE_DATA AttributeData = (LPWIN32_FILE_ATTRIBUTE_DATA)lpFileInformation;
        AttributeData->dwFileAttributes = NetworkInfo.FileAttributes;
        AttributeData->ftCreationTime = *(PFILETIME)&NetworkInfo.CreationTime;
        AttributeData->ftLastAccessTime = *(PFILETIME)&NetworkInfo.LastAccessTime;
        AttributeData->ftLastWriteTime = *(PFILETIME)&NetworkInfo.LastWriteTime;
        AttributeData->nFileSizeHigh = NetworkInfo.EndOfFile.HighPart;
        AttributeData->nFileSizeLow = (DWORD)NetworkInfo.EndOfFile.LowPart;
        return TRUE;
        }
    else {
        if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {
            KdPrintEx((
                DPFLTR_SETUP_ID,
                SpNtStatusToDbgPrintLevel(Status),
                "SETUP:"__FUNCTION__":SpQueryFullAttributesFile:0x%08lx\n",
                Status
                ));
        }
        SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
        return FALSE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\i386\bootini.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    bootini.c

Abstract:

    Code to lay boot blocks on x86, and to configure for boot loader,
    including munging/creating boot.ini and bootsect.dos.

Author:

    Ted Miller (tedm) 12-November-1992

Revision History:

    Sunil Pai ( sunilp ) 2-November-1993 rewrote for new text setup

--*/


#include "spprecmp.h"
#pragma hdrstop

#include "spboot.h"
#include "bootvar.h"
#include "spfile.h" //NEC98
#include <hdlsblk.h>
#include <hdlsterm.h>

extern PDISK_REGION  TargetRegion_Nec98; //NEC98

SIGNATURED_PARTITIONS SignedBootVars;

BOOLEAN
SpHasMZHeader(
    IN PWSTR   FileName
    );

NTSTATUS
Spx86WriteBootIni(
    IN PWCHAR BootIni,
    IN PWSTR **BootVars,
    IN ULONG Timeout,
    IN PWSTR Default,
    IN ULONG Count
    );

//
// DefSwitches support
//
UCHAR DefSwitches[128];
UCHAR DefSwitchesNoRedirect[128];

//
// Routines
//

BOOLEAN
Spx86InitBootVars(
    OUT PWSTR        **BootVars,
    OUT PWSTR        *Default,
    OUT PULONG       Timeout
    )
{
    WCHAR       BootIni[512];
    HANDLE      FileHandle;
    HANDLE      SectionHandle;
    PVOID       ViewBase;
    NTSTATUS    Status;
    ULONG       FileSize;
    PUCHAR      BootIniBuf;
    PDISK_REGION CColonRegion;
    BOOTVAR     i;
    PUCHAR      p;
    ULONG       index;

    //
    // Initialize the defaults
    //

    for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
        BootVars[i] = (PWSTR *)SpMemAlloc( sizeof ( PWSTR * ) );
        ASSERT( BootVars[i] );
        *BootVars[i] = NULL;
    }
    *Default = NULL;
    *Timeout  = DEFAULT_TIMEOUT;


    //
    // See if there is a valid C: already.  If not, then silently fail.
    //

    if (!IsNEC_98 // NEC98
#if defined(REMOTE_BOOT)
        || RemoteBootSetup
#endif // defined(REMOTE_BOOT)
        ) {

#if defined(REMOTE_BOOT)
        if (RemoteBootSetup && !RemoteInstallSetup) {
            ASSERT(RemoteBootTargetRegion != NULL);
            CColonRegion = RemoteBootTargetRegion;
        } else
#endif // defined(REMOTE_BOOT)
        {
            CColonRegion = SpPtValidSystemPartition();
            if(!CColonRegion) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: no C:, no boot.ini!\n"));
                return(TRUE);
            }
        }

        //
        // Form name of file.  Boot.ini better not be on a doublespace drive.
        //

        ASSERT(CColonRegion->Filesystem != FilesystemDoubleSpace);
        SpNtNameFromRegion(CColonRegion,BootIni,sizeof(BootIni),PartitionOrdinalCurrent);
        SpConcatenatePaths(BootIni,WBOOT_INI);

        //
        // Open and map the file.
        //

        FileHandle = 0;
        Status = SpOpenAndMapFile(BootIni,&FileHandle,&SectionHandle,&ViewBase,&FileSize,FALSE);
        if(!NT_SUCCESS(Status)) {
            return TRUE;
        }

        //
        // Allocate a buffer for the file.
        //

        BootIniBuf = SpMemAlloc(FileSize+1);
        ASSERT(BootIniBuf);
        RtlZeroMemory(BootIniBuf, FileSize+1);

        //
        // Transfer boot.ini into the buffer.  We do this because we also
        // want to place a 0 byte at the end of the buffer to terminate
        // the file.
        //
        // Guard the RtlMoveMemory because if we touch the memory backed by boot.ini
        // and get an i/o error, the memory manager will raise an exception.

        try {
            RtlMoveMemory(BootIniBuf,ViewBase,FileSize);
        }
        except( IN_PAGE_ERROR ) {
            //
            // Do nothing, boot ini processing can proceed with whatever has been
            // read
            //
        }

        //
        // Not needed since buffer has already been zeroed, however just do this
        // just the same
        //
        BootIniBuf[FileSize] = 0;

        //
        // Cleanup
        //
        SpUnmapFile(SectionHandle,ViewBase);
        ZwClose(FileHandle);

    } else { //NEC98
        //
        // Serch for all drive which include boot.ini file.
        //
        FileSize = 0;
        BootIniBuf = SpCreateBootiniImage(&FileSize);

        if(BootIniBuf == NULL){
            return(TRUE);
        }

    } //NEC98


    //
    // Do the actual processing of the file.
    //
    SppProcessBootIni(BootIniBuf, BootVars, Default, Timeout);

    //
    // Dump the boot vars
    //
    KdPrintEx( (DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "Spx86InitBootVars - Boot.ini entries:\n") );
    for( index = 0; BootVars[OSLOADPARTITION][index] ; index++ ) {
        KdPrintEx( (DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "    BootVar: %d\n    =========\n", index) );
        KdPrintEx( (DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "        OsLoadpartition: %ws\n", BootVars[OSLOADPARTITION][index]) );
        KdPrintEx( (DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "        OsLoadFileName: %ws\n\n", BootVars[OSLOADFILENAME][index]) );
    }


    //
    // Dump the signatures too...
    //
    KdPrintEx( (DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "Spx86InitBootVars - Boot.ini signed entries:\n") );
    {
    SIGNATURED_PARTITIONS *my_ptr = &SignedBootVars;
        do{
            if( my_ptr->SignedString ) {
                KdPrintEx( (DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "Signature entry:\n================\n") );
                KdPrintEx( (DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "    %ws\n", my_ptr->SignedString) );
                KdPrintEx( (DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "    %ws\n", my_ptr->MultiString) );

            };
            my_ptr = my_ptr->Next;
        } while( my_ptr );
    }


    //
    // Scan the Buffer to see if there is a DefSwitches line,
    // to move into new boot.ini in the  [boot loader] section.
    // If no DefSwitches, just point to a null string to be moved.
    //

    DefSwitches[0] = '\0';
    for(p=BootIniBuf; *p && (p < BootIniBuf+FileSize-(sizeof("DefSwitches")-1)); p++) {
      if(!_strnicmp(p,"DefSwitches",sizeof("DefSwitches")-1)) {
          index = 0;
          while ((*p != '\r') && (*p != '\n') && *p && (index < sizeof(DefSwitches)-4)) {
              DefSwitches[index++] = *p++;
          }
          DefSwitches[index++] = '\r';
          DefSwitches[index++] = '\n';
          DefSwitches[index] = '\0';
          break;
      }
    }

    //
    // get a copy of the defswitches without any redirection switches
    //
    strcpy(DefSwitchesNoRedirect, DefSwitches);

    //
    // Now add any headless parameters to the default switches.
    // Scan the Buffer to see if there's already a headless line.
    // If so, keep it.
    //
    for(p=BootIniBuf; *p && (p < BootIniBuf+FileSize-(sizeof("redirect=")-1)); p++) {


        if(!_strnicmp(p,"[Operat",sizeof("[Operat")-1)) {

            //
            // We're past the [Boot Loader] section.  Stop looking.
            //
            break;
        }


        if(!_strnicmp(p,"redirect=",sizeof("redirect=")-1)) {

            PUCHAR      q = p;
            UCHAR       temp;

            while ((*p != '\r') && (*p != '\n') && *p) {
                p++;
            }
            temp = *p;
            *p = '\0';
            strcat(DefSwitches, q);
            strcat(DefSwitches, "\r\n");
            *p = temp;
        }
    }

    //
    // Now look for a 'redirectbaudrate' line.
    //
    for(p=BootIniBuf; *p && (p < BootIniBuf+FileSize-(sizeof("redirectbaudrate=")-1)); p++) {


        if(!_strnicmp(p,"[Operat",sizeof("[Operat")-1)) {

            //
            // We're past the [Boot Loader] section.  Stop looking.
            //
            break;
        }


        if(!_strnicmp(p,"redirectbaudrate=",sizeof("redirectbaudrate=")-1)) {

            PUCHAR      q = p;
            UCHAR       temp;

            while ((*p != '\r') && (*p != '\n') && *p) {
                p++;
            }
            temp = *p;
            *p = '\0';
            strcat(DefSwitches, q);
            strcat(DefSwitches, "\r\n");
            *p = temp;
        }
    }

    SpMemFree(BootIniBuf);
    return( TRUE );
}


BOOLEAN
Spx86FlushBootVars(
    IN PWSTR **BootVars,
    IN ULONG Timeout,
    IN PWSTR Default
    )
{
    PDISK_REGION CColonRegion;
    WCHAR        *BootIni;
    WCHAR        *BootIniBak;
    BOOLEAN      BootIniBackedUp = FALSE;

    NTSTATUS Status;

    //
    // See if there is a valid C: already.  If not, then fail.
    //
#if defined(REMOTE_BOOT)
    // On a remote boot machine, it's acceptable to have no local disk.
    //
#endif // defined(REMOTE_BOOT)

    if (!IsNEC_98){ //NEC98
        CColonRegion = SpPtValidSystemPartition();
        if(!CColonRegion) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: no C:, no boot.ini!\n"));
#if defined(REMOTE_BOOT)
            if (RemoteBootSetup && !RemoteInstallSetup) {
                return(TRUE);
            }
#endif // defined(REMOTE_BOOT)
            return(FALSE);
        }
    } else {
        //
        // CColonRegion equal TargetRegion on NEC98.
        //
        CColonRegion = TargetRegion_Nec98;
    } //NEC98


    //
    // Allocate the buffers to 2K worth of stack space.
    //

    BootIni = SpMemAlloc(512*sizeof(WCHAR));
    if (!BootIni) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: No memory for boot.ini!\n"));
        return FALSE;
    }

    BootIniBak = SpMemAlloc(512*sizeof(WCHAR));
    if (!BootIniBak) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: No memory for boot.ini.bak!\n"));
        SpMemFree(BootIni);
        return FALSE;
    }

    //
    // Form name of file.  Boot.ini better not be on a doublespace drive.
    //

    ASSERT(CColonRegion->Filesystem != FilesystemDoubleSpace);
    SpNtNameFromRegion(CColonRegion,BootIni,512*sizeof(WCHAR),PartitionOrdinalCurrent);
    wcscpy(BootIniBak, BootIni);
    SpConcatenatePaths(BootIni,WBOOT_INI);
    SpConcatenatePaths(BootIniBak,WBOOT_INI_BAK);


    //
    // If Boot.ini already exists, delete any backup bootini
    // rename the existing bootini to the backup bootini, if unable
    // to rename, delete the file
    //

    if( SpFileExists( BootIni, FALSE ) ) {

        if( SpFileExists( BootIniBak, FALSE ) ) {
            SpDeleteFile( BootIniBak, NULL, NULL);
        }

        Status = SpRenameFile( BootIni, BootIniBak, FALSE );
        if (!(BootIniBackedUp = NT_SUCCESS( Status ))) {
            SpDeleteFile( BootIni, NULL, NULL );
        }
    }

    //
    // Write boot.ini.
    //

    Status = Spx86WriteBootIni(
                 BootIni,
                 BootVars,
                 Timeout,
                 Default,
                 0         // write all lines
                 );

    if(!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Error writing boot.ini!\n"));
        goto cleanup;
    }

cleanup:

    //
    // If we were unsuccessful in writing out boot ini then try recovering
    // the old boot ini from the backed up file, else delete the backed up
    // file.
    //

    if( !NT_SUCCESS(Status) ) {

        //
        // If the backup copy of boot ini exists then delete incomplete boot
        // ini and rename the backup copy of boot into bootini
        //
        if ( BootIniBackedUp ) {
            SpDeleteFile( BootIni, NULL, NULL );
            SpRenameFile( BootIniBak, BootIni, FALSE );
        }

    }
    else {

        SpDeleteFile( BootIniBak, NULL, NULL );

    }

    SpMemFree(BootIni);
    SpMemFree(BootIniBak);

    return( NT_SUCCESS(Status) );
}


PCHAR
Spx86ConvertToSignatureArcName(
    IN PWSTR ArcPathIn,
    IN ULONG Signature
    )
{
    PWSTR s,p,b;
    PWSTR UseSignatures;
    SIGNATURED_PARTITIONS *SignedEntries = &SignedBootVars;

    KdPrintEx( (DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "Spx86ConvertToSignatureArcName - Incoming ArcPath: %ws\n\tIncoming Signature %lx\n", ArcPathIn, Signature ) );

    //
    // First, check for any boot.ini entries that already had a 'signature'
    // string.
    //
    do {
        if( (SignedEntries->MultiString) && (SignedEntries->SignedString) ) {
            if( !_wcsicmp( ArcPathIn, SignedEntries->MultiString ) ) {

                //
                // We hit.  Convert the signatured string
                // to ASCII and return.
                //

                KdPrintEx( (DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "Spx86ConvertToSignatureArcName - Matched a multi-signed boot.ini entry:\n") );
                KdPrintEx( (DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "\t%ws\n\t%ws\n", SignedEntries->MultiString, SignedEntries->SignedString) );
                return SpToOem( SignedEntries->SignedString );
            }

        }

        SignedEntries = SignedEntries->Next;
    } while( SignedEntries );

#if 0
    //
    // Don't do this because winnt.exe and CDROM-boot installs won't
    // have this entry set, so we won't use signature entries, which
    // is a mistake.
    //
    UseSignatures = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,L"UseSignatures",0);
    if (UseSignatures == NULL || _wcsicmp(UseSignatures,WINNT_A_YES_W) != 0) {
        //
        // Just return the string we came in with.
        //
        return SpToOem(ArcPathIn);
    }
#endif

    if (_wcsnicmp( ArcPathIn, L"scsi(", 5 ) != 0) {
        //
        // If he's anything but a "scsi(..." entry,
        // just return the string that was sent in.
        //
        return SpToOem(ArcPathIn);
    }
    
    if( Signature ) {
        b = (PWSTR)TemporaryBuffer;
        p = ArcPathIn;
        s = wcschr( p, L')' ) + 1;
        swprintf( b, L"signature(%x)%ws", Signature, s );
        return SpToOem( b );
    } else {
        //
        // Just return the string we came in with.
        //
        return SpToOem(ArcPathIn);
    }
}


NTSTATUS
Spx86WriteBootIni(
    IN PWCHAR BootIni,
    IN PWSTR **BootVars,
    IN ULONG Timeout,
    IN PWSTR Default,
    IN ULONG Count
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING BootIni_U;
    HANDLE fh = NULL;
    PCHAR Default_O, Osloadpartition_O, Osloadfilename_O, Osloadoptions_O, Loadidentifier_O;
    FILE_BASIC_INFORMATION BasicInfo;
    OBJECT_ATTRIBUTES oa;
    ULONG i;
    NTSTATUS Status1;
    NTSTATUS Status;
    PWSTR s;
    PDISK_REGION Region;
    WCHAR   _Default[MAX_PATH] = {0};
    extern ULONG DefaultSignature;

    //
    // Open Bootini file.  Open if write through because we'll be shutting down
    // shortly (this is for safety).
    //

    RtlInitUnicodeString(&BootIni_U,BootIni);
    InitializeObjectAttributes(&oa,&BootIni_U,OBJ_CASE_INSENSITIVE,NULL,NULL);
    Status = ZwCreateFile(
                &fh,
                FILE_GENERIC_WRITE | DELETE,
                &oa,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                0,                      // no sharing
                FILE_OVERWRITE_IF,
                FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_WRITE_THROUGH,
                NULL,
                0
                );

    if( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ws for writing!\n", BootIni));
        goto cleanup;
    }

    //
    // make sure there is a Default specified before we use it.
    //
    if (Default != NULL) {
    
        //
        // use the temporary buffer to form the FLEXBOOT section.
        // and then write it out
        //

        s = NULL;
        s = wcschr( Default, L'\\' );
        if( s ) {
            //
            // Save off the Default string, then terminate
            // the Default string where the directory path starts.
            //
            wcscpy( _Default, Default );
            *s = L'\0';
            s = wcschr( _Default, L'\\' );
        }

        if( ForceBIOSBoot ) {
            //
            // If ForceBIOSBoot is TRUE, then we want to
            // force a "multi(..." string.  Don't even bother calling
            // Spx86ConvertToSignatureArcName on the off chance
            // that we may get erroneously converted.
            //

            if (_wcsnicmp( Default, L"scsi(", 5 ) == 0) {
            PWSTR MyStringPointer = NULL;

                //
                // Darn!  We have a string that the old standard
                // thought should be converted into a signature(...
                // string, but we didn't write out a miniport driver.
                // That can happen if someone asked us not to via
                // an unattend switch.
                //
                // We need to change the "scsi(" to "multi("
                //
                // We must preserve Default because we use it later
                // for comparison.
                //
                MyStringPointer = SpScsiArcToMultiArc( Default );

                if( MyStringPointer ) {
                    Default_O = SpToOem( MyStringPointer );
                } else {
                    //
                    // We're in trouble.  Take a shot though.  Just
                    // change the "scsi(" part to "multi(".
                    //
                    wcscpy( TemporaryBuffer, L"multi" );
                    wcscat( TemporaryBuffer, &Default[4] );

                    Default_O = SpToOem( TemporaryBuffer );
                }
            } else {
                //
                // Just convert to ANSI.
                //
                Default_O = SpToOem( Default );

            }
        } else {
            Default_O = Spx86ConvertToSignatureArcName( Default, DefaultSignature );
        }

        if( s ) {
            //
            // We need to append our directory path back on.
            //
            strcpy( (PCHAR)TemporaryBuffer, Default_O );
            SpMemFree( Default_O );
            Default_O = SpToOem( s );
            strcat( (PCHAR)TemporaryBuffer, Default_O );
            SpMemFree( Default_O );
            Default_O = SpDupString( (PCHAR)TemporaryBuffer );
        }


        if (Default_O == NULL) {
            Default_O = SpToOem( Default );
        }
    
    } else {

        //
        // the Default was not set, so make a null Default_O
        //
        Default_O = SpDupString("");

    }
    
    ASSERT( Default_O );

    //
    // See if we should use the loaded redirect switches, 
    // if there were any, or insert user defined swithes
    //
    if(RedirectSwitchesMode != UseDefaultSwitches) {

        //
        // get a copy of the switches up to the [operat region
        //
        strcpy(DefSwitches, DefSwitchesNoRedirect);

        //
        // insert our custom switch(s) if appropriate
        //
        switch(RedirectSwitchesMode){
        case DisableRedirect: {   
        
            //
            // we don't have to do anything here
            //

            break;
        }
        case UseUserDefinedRedirect: {
            
            sprintf((PUCHAR)TemporaryBuffer, 
                    "redirect=%s\r\n",
                    RedirectSwitches.port
                    );
            strcat(DefSwitches, (PUCHAR)TemporaryBuffer);
            
            break;
        }
        case UseUserDefinedRedirectAndBaudRate: {
            
            sprintf((PUCHAR)TemporaryBuffer, 
                    "redirect=%s\r\n",
                    RedirectSwitches.port
                    );
            strcat(DefSwitches, (PUCHAR)TemporaryBuffer);
            
            sprintf((PUCHAR)TemporaryBuffer, 
                    "redirectbaudrate=%s\r\n",
                    RedirectSwitches.baudrate
                    );
            strcat(DefSwitches, (PUCHAR)TemporaryBuffer);
            
            break;
        }
        default:{
            ASSERT(0);
        }
        } 

    } else {
        
        //
        // Make sure the required headless settings are already in the DefSwitches string before
        // we write it out.
        //
        _strlwr( DefSwitches );

        if( !strstr(DefSwitches, "redirect") ) {

            PUCHAR  p;
            HEADLESS_RSP_QUERY_INFO Response;
            SIZE_T      Length;


            //
            // There are no headless settings.  See if we need to add any.
            //
            Length = sizeof(HEADLESS_RSP_QUERY_INFO);
            Status = HeadlessDispatch(HeadlessCmdQueryInformation,
                                      NULL,
                                      0,
                                      &Response,
                                      &Length
                                     );

            p=NULL;

            if (NT_SUCCESS(Status) && 
                (Response.PortType == HeadlessSerialPort) &&
                Response.Serial.TerminalAttached) {

                if (Response.Serial.UsedBiosSettings) {

                    strcat(DefSwitches, "redirect=UseBiosSettings\r\n");

                } else {

                    switch (Response.Serial.TerminalPort) {
                    case ComPort1:
                        p = "redirect=com1\r\n";
                        break;
                    case ComPort2:
                        p = "redirect=com2\r\n";
                        break;
                    case ComPort3:
                        p = "redirect=com3\r\n";
                        break;
                    case ComPort4:
                        p = "redirect=com4\r\n";
                        break;
                    default:
                        ASSERT(0);
                        p = NULL;
                        break;
                    }

                    if (p) {
                        strcat(DefSwitches, p);
                    }                        

                    //
                    // Now take care of the 'redirectbaudrate' entry.
                    //
                    switch (Response.Serial.TerminalBaudRate) {
                    case 115200:
                        p = "redirectbaudrate=115200\r\n";
                        break;
                    case 57600:
                        p = "redirectbaudrate=57600\r\n";
                        break;
                    case 19200:
                        p = "redirectbaudrate=19200\r\n";
                        break;
                    default:
                        p = "redirectbaudrate=9600\r\n";
                        break;
                    }

                    strcat(DefSwitches, p);
                }
            }
        }        
    }

    sprintf(
        (PUCHAR)TemporaryBuffer,
        "%s%s%s%s%s%ld%s%s%s%s%s",
        FLEXBOOT_SECTION2,
        CRLF,
        DefSwitches,
        TIMEOUT,
        EQUALS,
        Timeout,
        CRLF,
        DEFAULT,
        EQUALS,
        Default_O,
        CRLF
        );

    SpMemFree( Default_O );

    Status = ZwWriteFile(
                fh,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                TemporaryBuffer,
                strlen((PUCHAR)TemporaryBuffer) * sizeof(UCHAR),
                NULL,
                NULL
                );

    if(!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Error writing %s section to %ws!\n", FLEXBOOT_SECTION2, BootIni));
        goto cleanup;
    }

    //
    // Now write the BOOTINI_OS_SECTION label to boot.ini
    //

    sprintf(
        (PUCHAR)TemporaryBuffer,
        "%s%s",
        BOOTINI_OS_SECTION,
        CRLF
        );

    Status = ZwWriteFile(
                fh,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                TemporaryBuffer,
                strlen((PUCHAR)TemporaryBuffer) * sizeof(UCHAR),
                NULL,
                NULL
                );

    if(!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Error writing %s section to %ws!\n", BOOTINI_OS_SECTION, BootIni));
        goto cleanup;
    }

    //
    // run through all the systems that we have and write them out
    //

    for( i = 0; BootVars[OSLOADPARTITION][i] ; i++ ) {

        //
        // If we were told to write a specified number of lines, exit
        // when we have done that.
        //

        if (Count && (i == Count)) {
            Status = STATUS_SUCCESS;
            goto cleanup;
        }

        ASSERT( BootVars[OSLOADFILENAME][i] );
        ASSERT( BootVars[OSLOADOPTIONS][i] );
        ASSERT( BootVars[LOADIDENTIFIER][i] );

        //
        // On some upgrades, if we're upgrading a "signature" entry,
        // then we may not have a DefaultSignature.  I fixed that case over
        // in Spx86ConvertToSignatureArcName.  The other case is where
        // we have a DefaultSignature, but there are also some "scsi(..."
        // entries in the boot.ini that don't pertain to the entry we're
        // upgrading.  For that case, we need to send in a signature
        // of 0 here, which will force Spx86ConvertToSignatureArcName
        // to return us the correct item.
        //

        //
        // You thought the hack above was gross...  This one's even
        // worse.  Problem: we don't think we need a miniport to boot,
        // but there are some other boot.ini entries (that point to our
        // partition) that do.  We always want to leave existing
        // boot.ini entries alone though, so we'll leave those broken.
        //
        // Solution: if the OSLOADPARTITION that we're translating ==
        // Default, && ForceBIOSBoot is TRUE && we're translating
        // the first OSLOADPARTITION (which is the one for our Default),
        // then just don't call Spx86ConvertToSignatureArcName.
        // This is bad because it assumes that our entry is the first,
        // which it is, but it's a shakey assumption.
        //

        if( !_wcsicmp( BootVars[OSLOADPARTITION][i], Default ) ) {
            //
            // This might be our Default entry.  Make sure it
            // really is and if so, process it the same way.
            //
            if( i == 0 ) {
                //
                // It is.
                //
                if( ForceBIOSBoot ) {

                    //
                    // If ForceBIOSBoot is TRUE, then we want to
                    // force a "multi(..." string.  Don't even bother calling
                    // Spx86ConvertToSignatureArcName on the off chance
                    // that we may get erroneously converted.
                    //
                    if (_wcsnicmp( BootVars[OSLOADPARTITION][i], L"scsi(", 5 ) == 0) {
                    PWSTR MyStringPointer = NULL;

                        //
                        // Darn!  We have a string that the old standard
                        // thought should be converted into a signature(...
                        // string, but we didn't write out a miniport driver.
                        // That can happen if someone asked us not to via
                        // an unattend switch.
                        //
                        // We need to change the "scsi(" to "multi("
                        //
                        MyStringPointer = SpScsiArcToMultiArc( BootVars[OSLOADPARTITION][i] );

                        if( MyStringPointer ) {
                            Osloadpartition_O = SpToOem( MyStringPointer );
                        } else {
                            //
                            // We're in trouble.  Take a shot though.  Just
                            // change the "scsi(" part to "multi(".
                            //
                            wcscpy( TemporaryBuffer, L"multi" );
                            wcscat( TemporaryBuffer, &BootVars[OSLOADPARTITION][i][4] );

                            Osloadpartition_O = SpToOem( TemporaryBuffer );
                        }

                    } else {
                        //
                        // Just convert to ANSI.
                        //
                        Osloadpartition_O = SpToOem( BootVars[OSLOADPARTITION][i] );

                    }

                } else {
                    //
                    // We may need to convert this entry.
                    //
                    Osloadpartition_O = Spx86ConvertToSignatureArcName( BootVars[OSLOADPARTITION][i], DefaultSignature );
                }
            } else {
                //
                // This entry looks just like our Default, but it's point
                // to a different installation.  Just call Spx86ConvertToSignatureArcName
                //
                Osloadpartition_O = Spx86ConvertToSignatureArcName( BootVars[OSLOADPARTITION][i], DefaultSignature );
            }
        } else {
            //
            // This entry doesn't even look like our string.  Send in a
            // 0x0 DefaultSignature so that it will only get translated if it
            // matches some entry that we know was signed in the original boot.ini.
            //
            Osloadpartition_O = Spx86ConvertToSignatureArcName( BootVars[OSLOADPARTITION][i], 0 );
        }

        //
        // Insurance...
        //
        if (Osloadpartition_O == NULL) {
            Osloadpartition_O = SpToOem( BootVars[OSLOADPARTITION][i] );
        }


        Osloadfilename_O  = SpToOem( BootVars[OSLOADFILENAME][i]  );
        Osloadoptions_O   = SpToOem( BootVars[OSLOADOPTIONS][i]   );
        Loadidentifier_O  = SpToOem( BootVars[LOADIDENTIFIER][i]  );

        sprintf(
            (PUCHAR)TemporaryBuffer,
            "%s%s%s%s %s%s",
            Osloadpartition_O,
            Osloadfilename_O,
            EQUALS,
            Loadidentifier_O,
            Osloadoptions_O,
            CRLF
            );

        SpMemFree( Osloadpartition_O );
        SpMemFree( Osloadfilename_O  );
        SpMemFree( Osloadoptions_O   );
        SpMemFree( Loadidentifier_O  );

        Status = ZwWriteFile(
                    fh,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    TemporaryBuffer,
                    strlen((PUCHAR)TemporaryBuffer) * sizeof(UCHAR),
                    NULL,
                    NULL
                    );

        if(!NT_SUCCESS( Status )) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Error writing %s section entry to %ws!\n", BOOTINI_OS_SECTION, BootIni));
            goto cleanup;
        }
    }


    //
    // Finally write the old operating system line to boot.ini
    // (but only if not installing on top of Win9x) and if it was
    // not specifically disabled
    //
    if (!DiscardOldSystemLine && (WinUpgradeType != UpgradeWin95)) {
        Status = ZwWriteFile(
                    fh,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    OldSystemLine,
                    strlen(OldSystemLine) * sizeof(UCHAR),
                    NULL,
                    NULL
                    );

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, 
                DPFLTR_ERROR_LEVEL, 
                "SETUP: Error writing %s section line to %ws!\n", 
                BOOTINI_OS_SECTION, 
                BootIni));
                
            goto cleanup;
        }
    }

cleanup:

    if( !NT_SUCCESS(Status) ) {

        if( fh ) {
            ZwClose( fh );
        }

    }
    else {

        //
        // Set the hidden, system, readonly attributes on bootini.  ignore
        // error
        //

        RtlZeroMemory( &BasicInfo, sizeof( FILE_BASIC_INFORMATION ) );
        BasicInfo.FileAttributes = FILE_ATTRIBUTE_READONLY |
                                   FILE_ATTRIBUTE_HIDDEN   |
                                   FILE_ATTRIBUTE_SYSTEM   |
                                   FILE_ATTRIBUTE_ARCHIVE
                                   ;

        Status1 = SpSetInformationFile(
                      fh,
                      FileBasicInformation,
                      sizeof(BasicInfo),
                      &BasicInfo
                      );

        if(!NT_SUCCESS(Status1)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to change attribute of %ws. Status = (%lx). Ignoring error.\n",BootIni,Status1));
        }

        ZwClose( fh );

    }

    //
    // If we copied out the Default, then
    // put the original copy of Default back
    //
    if (Default != NULL) {
        wcscpy(Default, _Default);
    }

    return Status;

}

VOID
SppProcessBootIni(
    IN  PCHAR  BootIni,
    OUT PWSTR  **BootVars,
    OUT PWSTR  *Default,
    OUT PULONG Timeout
    )

/*++

Routine Description:

    Look through the [operating systems] section and save all lines
    except the one for "C:\" (previous operating system) and one other
    optionally specified line.

    Filters out the local boot line (C:\$WIN_NT$.~BT) if present.

Arguments:

Return Value:

--*/

{
    PCHAR sect,s,p,n;
    PWSTR tmp;
    CHAR Key[MAX_PATH], Value[MAX_PATH], RestOfLine[MAX_PATH];
    ULONG NumComponents;
    BOOTVAR i;
    ULONG DiskSignature,digval;
    SIGNATURED_PARTITIONS *SignedBootIniVars = &SignedBootVars;;

    //
    // Process the flexboot section, extract timeout and default
    //

    sect = SppFindSectionInBootIni(BootIni, FLEXBOOT_SECTION1);
    if (!sect) {
        sect = SppFindSectionInBootIni(BootIni, FLEXBOOT_SECTION2);
    }
    if (!sect) {
        sect = SppFindSectionInBootIni(BootIni, FLEXBOOT_SECTION3);
    }
    if ( sect ) {
        while (sect = SppNextLineInSection(sect))  {
            if( SppProcessLine( sect, Key, Value, RestOfLine) ) {
                if ( !_stricmp( Key, TIMEOUT ) ) {
                    *Timeout = atol( Value );
                }
                else if( !_stricmp( Key, DEFAULT ) ) {
                    *Default = SpToUnicode( Value );
                }
            }
        }
    }

    //
    // Process the operating systems section
    //

    sect = SppFindSectionInBootIni(BootIni,BOOTINI_OS_SECTION);
    if(!sect) {
        return;
    }

    NumComponents = 0;

    while(sect = SppNextLineInSection(sect)) {
        if( SppProcessLine( sect, Key, Value, RestOfLine)) {
            PCHAR OsLoaddir;

            //
            // Check if the line is the old bootloader line in which case just
            // save it above, else add it to the BootVars structure
            //

            if (!IsNEC_98) { //NEC98
                if( !_stricmp( Key, "C:\\" ) ) {
                    sprintf( OldSystemLine, "%s=%s %s\r\n", Key, Value, RestOfLine );
                } else {

                    //
                    // Ignore if local boot directory.  This automatically
                    // filters out that directory when boot.ini is later flushed.
                    //
                    if(_strnicmp(Key,"C:\\$WIN_NT$.~BT",15) && (OsLoaddir = strchr(Key,'\\'))) {
                        //
                        // Get the ARC name of the x86 system partition region.
                        //
                        PDISK_REGION SystemPartitionRegion;
                        WCHAR SystemPartitionPath[256];

                        NumComponents++;
                        for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
                            BootVars[i] = SpMemRealloc( BootVars[i],  (NumComponents + 1) * sizeof( PWSTR * ) );
                            ASSERT( BootVars[i] );
                            BootVars[i][NumComponents] = NULL;
                        }

                        SystemPartitionRegion = SpPtValidSystemPartition();
#if defined(REMOTE_BOOT)
                        ASSERT(SystemPartitionRegion ||
                               (RemoteBootSetup && !RemoteInstallSetup));
#else
                        ASSERT(SystemPartitionRegion);
#endif // defined(REMOTE_BOOT)

                        if (SystemPartitionRegion) {
                            SpArcNameFromRegion(
                                SystemPartitionRegion,
                                SystemPartitionPath,
                                sizeof(SystemPartitionPath),
                                PartitionOrdinalOriginal,
                                PrimaryArcPath
                                );

                            BootVars[OSLOADER][NumComponents - 1] = SpMemAlloc((wcslen(SystemPartitionPath)*sizeof(WCHAR))+sizeof(L"ntldr")+sizeof(WCHAR));
                            wcscpy(BootVars[OSLOADER][NumComponents - 1],SystemPartitionPath);
                            SpConcatenatePaths(BootVars[OSLOADER][NumComponents - 1],L"ntldr");

                            BootVars[SYSTEMPARTITION][NumComponents - 1] = SpDupStringW( SystemPartitionPath );
                        }

                        BootVars[LOADIDENTIFIER][NumComponents - 1]  = SpToUnicode( Value );
                        BootVars[OSLOADOPTIONS][NumComponents - 1]   = SpToUnicode( RestOfLine );

                        *OsLoaddir = '\0';

                        //
                        // Now convert the signature entry into a 'multi...' entry.
                        //
                        s = strstr( Key, "signature(" );
                        if (s) {

                            s += 10;
                            p = strchr( s, ')' );
                            if (p) {

                                //
                                // We've got a boot.ini entry with a 'signature' string.
                                // Let's save it off before we convert it into a 'multi'
                                // string so we can convert back easily when we're ready
                                // to write out the boot.ini.
                                //
                                if( SignedBootIniVars->SignedString != NULL ) {
                                    //
                                    // We've used this entry, get another...
                                    //
                                    SignedBootIniVars->Next = SpMemAlloc(sizeof(SIGNATURED_PARTITIONS));
                                    SignedBootIniVars = SignedBootIniVars->Next;

                                    //
                                    // Make sure...
                                    //
                                    SignedBootIniVars->Next = NULL;
                                    SignedBootIniVars->SignedString = NULL;
                                    SignedBootIniVars->MultiString = NULL;
                                }
                                SignedBootIniVars->SignedString = SpToUnicode( Key );


                                *p = 0;
                                DiskSignature = 0;
                                for (n=s; *n; n++) {
                                    if (isdigit((int)(unsigned char)*n)) {
                                        digval = *n - '0';
                                    } else if (isxdigit((int)(unsigned char)*n)) {
                                        digval = toupper(*n) - 'A' + 10;
                                    } else {
                                        digval = 0;
                                    }
                                    DiskSignature = DiskSignature * 16 + digval;
                                }
                                *p = ')';


                                //
                                // !!! ISSUE : 4/27/01 : vijayj !!!
                                //
                                // Sometimes we might map a arcname to wrong region on
                                // disk.
                                //
                                // Although we compute a new multi(0)... style arcname 
                                // from the nt device name, we don't have an entry in 
                                // the map which actually maps the scsi(0)... style 
                                // arcname to nt device name.
                                //
                                // In a multi installation scenario, if the current installation
                                // is on a disk which is not visible by firmware and the
                                // boot.ini has scsi(...) entry for this installation we
                                // would convert it into multi(0)... format which could be
                                // similar to the actual multi(0) disk. If this is the case
                                // and another installation exists on the first disk also
                                // with the same partition number and WINDOWS directory
                                // then we would end up using the first disk region as the
                                // region to upgrade and fail subsequently while trying
                                // to match unique IDs. User will end up with "unable to
                                // locate installation to upgrade message". 
                                // 
                                // Since the probability of all this conditions being replicated
                                // on different machines is very very less, currently
                                // I am not going to fix this.
                                //
                                

                                //
                                // We've isolated the signature.  Now go find a disk
                                // with that signature and get his ARC path.
                                //
                                for(i=0; (ULONG)i<HardDiskCount; i++) {
                                    if (HardDisks[i].Signature == DiskSignature) {
                                        tmp = SpNtToArc( HardDisks[i].DevicePath, PrimaryArcPath );
                                        if( tmp ) {
                                            wcscpy( (PWSTR)TemporaryBuffer, tmp );
                                            SpMemFree(tmp);
                                            p = strstr( Key, "partition(" );
                                            if( p ) {
                                                tmp = SpToUnicode(p);
                                                if( tmp ) {
                                                    wcscat( (PWSTR)TemporaryBuffer, tmp );
                                                    SpMemFree(tmp);
                                                    BootVars[OSLOADPARTITION][NumComponents - 1] = SpDupStringW( (PWSTR)TemporaryBuffer );
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                                if ((ULONG)i == HardDiskCount) {
                                    BootVars[OSLOADPARTITION][NumComponents - 1] = SpToUnicode( Key );
                                }

                                //
                                // Save off the 'multi' entry in our list of signatures.
                                //
                                SignedBootIniVars->MultiString = SpDupStringW( BootVars[OSLOADPARTITION][NumComponents - 1] );
                            }
                        } else {
                            BootVars[OSLOADPARTITION][NumComponents - 1] = SpToUnicode( Key );
                        }

                        *OsLoaddir = '\\';
#if defined(REMOTE_BOOT)
                        if (RemoteBootSetup && !RemoteInstallSetup) {
                            BootVars[OSLOADFILENAME][NumComponents - 1] = SpToUnicode( strrchr(OsLoaddir,'\\') );
                        } else
#endif // defined(REMOTE_BOOT)
                        {
                            BootVars[OSLOADFILENAME][NumComponents - 1] = SpToUnicode( OsLoaddir );
                        }
                    }
                }
            } else { //NEC98
                if (_strnicmp(Key,"C:\\$WIN_NT$.~BT",15) && (OsLoaddir = strchr( Key, '\\' ))) {

                    NumComponents++;
                    for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
                        BootVars[i] = SpMemRealloc( BootVars[i],  (NumComponents + 1) * sizeof( PWSTR * ) );
                        ASSERT( BootVars[i] );
                        BootVars[i][NumComponents] = NULL;
                    }

                    BootVars[OSLOADER][NumComponents - 1] = SpMemAlloc(sizeof(L"ntldr")+sizeof(WCHAR));
                    wcscpy(BootVars[OSLOADER][NumComponents - 1],L"\\");
                    SpConcatenatePaths(BootVars[OSLOADER][NumComponents - 1],L"ntldr");

                    BootVars[SYSTEMPARTITION][NumComponents - 1] = SpToUnicode( Key );

                    BootVars[LOADIDENTIFIER][NumComponents - 1]  = SpToUnicode( Value );
                    BootVars[OSLOADOPTIONS][NumComponents - 1]   = SpToUnicode( RestOfLine );
                    *OsLoaddir = '\0';
                    BootVars[OSLOADPARTITION][NumComponents - 1]   = SpToUnicode( Key );
                    *OsLoaddir = '\\';
                    BootVars[OSLOADFILENAME][NumComponents - 1]   = SpToUnicode( OsLoaddir );


                    ASSERT( BootVars[OSLOADER][NumComponents - 1]        );
                    ASSERT( BootVars[SYSTEMPARTITION][NumComponents - 1] );
                    ASSERT( BootVars[LOADIDENTIFIER][NumComponents - 1]  );
                    ASSERT( BootVars[OSLOADOPTIONS][NumComponents - 1]   );
                    ASSERT( BootVars[OSLOADPARTITION][NumComponents - 1] );
                    ASSERT( BootVars[OSLOADPARTITION][NumComponents - 1] );
                }
            } //NEC98
        }
    }
    return;
}


PCHAR
SppNextLineInSection(
    IN PCHAR p
    )
{
    //
    // Find the next \n.
    //
    p = strchr(p,'\n');
    if(!p) {
        return(NULL);
    }

    //
    // skip crs, lfs, spaces, and tabs.
    //

    while(*p && strchr("\r\n \t",*p)) {
        p++;
    }

    // detect if at end of file or section
    if(!(*p) || (*p == '[')) {
        return(NULL);
    }

    return(p);
}


PCHAR
SppFindSectionInBootIni(
    IN PCHAR p,
    IN PCHAR Section
    )
{
    ULONG len = strlen(Section);

    do {

        //
        // Skip space at front of line
        //
        while(*p && ((*p == ' ') || (*p == '\t'))) {
            p++;
        }

        if(*p) {

            //
            // See if this line matches.
            //
            if(!_strnicmp(p,Section,len)) {
                return(p);
            }

            //
            // Advance to the start of the next line.
            //
            while(*p && (*p != '\n')) {
                p++;
            }

            if(*p) {    // skip nl if that terminated the loop.
                p++;
            }
        }
    } while(*p);

    return(NULL);
}


BOOLEAN
SppProcessLine(
    IN PCHAR Line,
    IN OUT PCHAR Key,
    IN OUT PCHAR Value,
    IN OUT PCHAR RestOfLine
    )
{
    PCHAR p = Line, pLine = Line, pToken;
    CHAR  savec;
    BOOLEAN Status = FALSE;

    //
    // Determine end of line
    //

    if(!p) {
        return( Status );
    }

    while( *p && (*p != '\r') && (*p != '\n') ) {
        p++;
    }

    //
    // back up from this position to squeeze out any whitespaces at the
    // end of the line
    //

    while( ((p - 1) >= Line) && strchr(" \t", *(p - 1)) ) {
        p--;
    }

    //
    // terminate the line with null temporarily
    //

    savec = *p;
    *p = '\0';

    //
    // Start at beginning of line and pick out the key
    //

    if ( SppNextToken( pLine, &pToken, &pLine ) ) {
        CHAR savec1 = *pLine;

        *pLine = '\0';
        strcpy( Key, pToken );
        *pLine = savec1;

        //
        // Get next token, it should be a =
        //

        if ( SppNextToken( pLine, &pToken, &pLine ) && *pToken == '=') {

             //
             // Get next token, it will be the value
             //

             if( SppNextToken( pLine, &pToken, &pLine ) ) {
                savec1 = *pLine;
                *pLine = '\0';
                strcpy( Value, pToken );
                *pLine = savec1;

                //
                // if another token exists then take the whole remaining line
                // and make it the RestOfLine token
                //

                if( SppNextToken( pLine, &pToken, &pLine ) ) {
                    strcpy( RestOfLine, pToken );
                }
                else {
                    *RestOfLine = '\0';
                }

                //
                // We have a well formed line
                //

                Status = TRUE;
             }
        }

    }
    *p = savec;
    return( Status );
}


BOOLEAN
SppNextToken(
    PCHAR p,
    PCHAR *pBegin,
    PCHAR *pEnd
    )
{
    BOOLEAN Status = FALSE;

    //
    // Validate pointer
    //

    if( !p ) {
        return( Status );
    }

    //
    // Skip whitespace
    //

    while (*p && strchr( " \t", *p ) ) {
        p++;
    }

    //
    // Valid tokens are "=", space delimited strings, quoted strings
    //

    if (*p) {
        *pBegin = p;
        if ( *p == '=' ) {
            *pEnd = p + 1;
            Status = TRUE;
        }
        else if ( *p == '\"' ) {
            if ( p = strchr( p + 1, '\"' ) ) {
                *pEnd = p + 1;
                Status = TRUE;
            }
        }
        else {
            while (*p && !strchr(" \t\"=", *p) ) {
                p++;
            }
            *pEnd = p;
            Status = TRUE;
        }
    }
    return( Status );
}


//
// Boot code stuff.
//

NTSTATUS
pSpBootCodeIo(
    IN     PWSTR     FilePath,
    IN     PWSTR     AdditionalFilePath, OPTIONAL
    IN     ULONG     BytesToRead,
    IN OUT PUCHAR   *Buffer,
    IN     ULONG     OpenDisposition,
    IN     BOOLEAN   Write,
    IN     ULONGLONG Offset,
    IN     ULONG     BytesPerSector
    )
{
    PWSTR FullPath;
    PUCHAR buffer = NULL;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    LARGE_INTEGER LargeZero;
    PVOID UnalignedMem,AlignedBuffer;

    LargeZero.QuadPart = Offset;

    //
    // Form the name of the file.
    //
    wcscpy((PWSTR)TemporaryBuffer,FilePath);
    if(AdditionalFilePath) {
        SpConcatenatePaths((PWSTR)TemporaryBuffer,AdditionalFilePath);
    }
    FullPath = SpDupStringW((PWSTR)TemporaryBuffer);

    //
    // Open the file.
    //
    INIT_OBJA(&Obja,&UnicodeString,FullPath);
    Status = ZwCreateFile(
                &Handle,
                Write ? FILE_GENERIC_WRITE : FILE_GENERIC_READ,
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                OpenDisposition,
                FILE_SYNCHRONOUS_IO_NONALERT | (Write ? FILE_WRITE_THROUGH : 0),
                NULL,
                0
                );

    if(NT_SUCCESS(Status)) {

        //
        // Allocate a buffer if we are reading.
        // Otherwise the caller passed us the buffer.
        //
        buffer = Write ? *Buffer : SpMemAlloc(BytesToRead);

        //
        // Read or write the disk -- properly aligned. Note that we force at least
        // 512-byte alignment, since there's a hard-coded alignment requirement
        // in the FT driver that must be satisfied.
        //
        if(BytesPerSector < 512) {
            BytesPerSector = 512;
        }
        UnalignedMem = SpMemAlloc(BytesToRead + BytesPerSector);
        AlignedBuffer = ALIGN(UnalignedMem,BytesPerSector);

        if(Write) {
            RtlMoveMemory(AlignedBuffer,buffer,BytesToRead);
        }

        Status = Write

               ?
                    ZwWriteFile(
                        Handle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        AlignedBuffer,
                        BytesToRead,
                        &LargeZero,
                        NULL
                        )
                :

                    ZwReadFile(
                        Handle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        AlignedBuffer,
                        BytesToRead,
                        &LargeZero,
                        NULL
                        );

        if(NT_SUCCESS(Status)) {
            if(!Write) {
                RtlMoveMemory(buffer,AlignedBuffer,BytesToRead);
            }
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                "SETUP: Unable to %ws %u bytes from %ws (%lx)\n",
                Write ? L"write" : L"read",
                BytesToRead,
                FullPath,
                Status
                ));
        }

        SpMemFree(UnalignedMem);

        //
        // Close the file.
        //
        ZwClose(Handle);

    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: pSpBootCodeIo: Unable to open %ws (%lx)\n",FullPath,Status));
    }

    SpMemFree(FullPath);

    if(!Write) {
        if(NT_SUCCESS(Status)) {
            *Buffer = buffer;
        } else {
            if(buffer) {
                SpMemFree(buffer);
            }
        }
    }

    return(Status);
}


BOOLEAN
pSpScanBootcode(
    IN PVOID Buffer,
    IN PCHAR String
    )

/*++

Routine Description:

    Look in a boot sector to find an identifying string.  The scan starts
    at offset 128 and continues through byte 509 of the buffer.
    The search is case-sensitive.

    Arguments:

    Buffer - buffer to scan

    String - string to scan for

    Return Value:


--*/

{
    ULONG len = strlen(String);
    ULONG LastFirstByte = 510 - len;
    ULONG i;
    PCHAR p = Buffer;

    //
    // Use the obvious brute force method.
    //
    for(i=128; i<LastFirstByte; i++) {
        if(!strncmp(p+i,String,len)) {
            return(TRUE);
        }
    }

    return(FALSE);
}


VOID
SpDetermineOsTypeFromBootSector(
    IN  PWSTR     CColonPath,
    IN  PUCHAR    BootSector,
    OUT PUCHAR   *OsDescription,
    OUT PBOOLEAN  IsNtBootcode,
    OUT PBOOLEAN  IsOtherOsInstalled,
    IN  WCHAR     DriveLetter
    )
{
    PWSTR   description;
    PWSTR   *FilesToLookFor;
    ULONG   FileCount;
    BOOLEAN PossiblyChicago = FALSE;

    PWSTR MsDosFiles[2] = { L"MSDOS.SYS" , L"IO.SYS"    };

    //
    // Some versions of PC-DOS have ibmio.com, others have ibmbio.com.
    //
  //PWSTR PcDosFiles[2] = { L"IBMDOS.COM", L"IBMIO.COM" };
    PWSTR PcDosFiles[1] = { L"IBMDOS.COM" };

    PWSTR Os2Files[2]   = { L"OS2LDR"    , L"OS2KRNL"   };

    //
    // Check for nt boot code.
    //
    if(pSpScanBootcode(BootSector,"NTLDR")) {

        *IsNtBootcode = TRUE;
        *IsOtherOsInstalled = FALSE;
        description = L"";

    } else {

        //
        // It's not NT bootcode.
        //
        *IsNtBootcode = FALSE;
        *IsOtherOsInstalled = TRUE;

        //
        // Check for MS-DOS.
        //
        if (pSpScanBootcode(BootSector,((!IsNEC_98) ? "MSDOS   SYS" : "IO      SYS"))) { //NEC98

            FilesToLookFor = MsDosFiles;
            FileCount = ELEMENT_COUNT(MsDosFiles);
            description = L"MS-DOS";
            PossiblyChicago = TRUE; // Chicago uses same signature files

        } else {

            //
            // Check for PC-DOS.
            //
            if(pSpScanBootcode(BootSector,"IBMDOS  COM")) {

                FilesToLookFor = PcDosFiles;
                FileCount = ELEMENT_COUNT(PcDosFiles);
                description = L"PC-DOS";

            } else {

                //
                // Check for OS/2.
                //
                if(pSpScanBootcode(BootSector,"OS2")) {

                    FilesToLookFor = Os2Files;
                    FileCount = ELEMENT_COUNT(Os2Files);
                    description = L"OS/2";

                } else {
                    //
                    // Not NT, DOS, or OS/2.
                    // It's just plain old "previous operating system."
                    // Fetch the string from the resources.
                    //
                    WCHAR   DriveLetterString[2];

                    DriveLetterString[0] = DriveLetter;
                    DriveLetterString[1] = L'\0';
                    SpStringToUpper(DriveLetterString);
                    FilesToLookFor = NULL;
                    FileCount = 0;
                    description = (PWSTR)TemporaryBuffer;
                    SpFormatMessage(description,sizeof(TemporaryBuffer),SP_TEXT_PREVIOUS_OS, DriveLetterString);
                }
            }
        }

        //
        // If we think we have found an os, check to see whether
        // its signature files are present.
        // We could have, say, a disk where the user formats is using DOS
        // and then installs NT immediately thereafter.
        //
        if(FilesToLookFor) {

            //
            // Copy CColonPath into a larger buffer, because
            // SpNFilesExist wants to append a backslash onto it.
            //
            wcscpy((PWSTR)TemporaryBuffer,CColonPath);

            if(!SpNFilesExist((PWSTR)TemporaryBuffer,FilesToLookFor,FileCount,FALSE)) {

                //
                // Ths os is not really there.
                //
                *IsOtherOsInstalled = FALSE;
                description = L"";
            } else if(PossiblyChicago) {

                wcscpy((PWSTR)TemporaryBuffer, CColonPath);
                SpConcatenatePaths((PWSTR)TemporaryBuffer, L"IO.SYS");

                if(SpHasMZHeader((PWSTR)TemporaryBuffer)) {
                    description = L"Microsoft Windows";
                }
            }
        }
    }

    //
    // convert the description to oem text.
    //
    *OsDescription = SpToOem(description);
}


VOID
SpLayBootCode(
    IN OUT PDISK_REGION CColonRegion
    )
{
    PUCHAR NewBootCode;
    ULONG BootCodeSize;
    PUCHAR ExistingBootCode;
    NTSTATUS Status;
    PUCHAR ExistingBootCodeOs;
    PWSTR CColonPath;
    HANDLE  PartitionHandle;
    PWSTR BootsectDosName = L"\\bootsect.dos";
    PWSTR OldBootsectDosName = L"\\bootsect.bak";
    PWSTR BootSectDosFullName, OldBootSectDosFullName, p;
    BOOLEAN IsNtBootcode,OtherOsInstalled, FileExist;
    UNICODE_STRING    UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK   IoStatusBlock;
    BOOLEAN BootSectorCorrupt = FALSE;
    ULONG   MirrorSector;
    ULONG   BytesPerSector;
    ULONGLONG  ActualSectorCount, hidden_sectors, super_area_size;
    UCHAR   SysId;

    ULONGLONG HiddenSectorCount,VolumeSectorCount; //NEC98
    PUCHAR   DiskArraySectorData,TmpBuffer; //NEC98


    ExistingBootCode = NULL;
    BytesPerSector = HardDisks[CColonRegion->DiskNumber].Geometry.BytesPerSector;

    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_INITING_FLEXBOOT,DEFAULT_STATUS_ATTRIBUTE);

    switch(CColonRegion->Filesystem) {

    case FilesystemNewlyCreated:

        //
        // If the filesystem is newly-created, then there is
        // nothing to do, because there can be no previous
        // operating system.
        //
        return;

    case FilesystemNtfs:

        NewBootCode = (!IsNEC_98) ? NtfsBootCode : PC98NtfsBootCode; //NEC98
        BootCodeSize = (!IsNEC_98) ? sizeof(NtfsBootCode) : sizeof(PC98NtfsBootCode); //NEC98
        ASSERT(BootCodeSize == 8192);
        break;

    case FilesystemFat:

        NewBootCode = (!IsNEC_98) ? FatBootCode : PC98FatBootCode; //NEC98
        BootCodeSize = (!IsNEC_98) ? sizeof(FatBootCode) : sizeof(PC98FatBootCode); //NEC98
        ASSERT(BootCodeSize == 512);
        break;

    case FilesystemFat32:
        //
        // Special hackage required for Fat32 because its NT boot code
        // is discontiguous.
        //
        ASSERT(sizeof(Fat32BootCode) == 1536);
        NewBootCode = (!IsNEC_98) ? Fat32BootCode : PC98Fat32BootCode; //NEC98
        BootCodeSize = 512;
        break;

    default:

        if (RepairItems[RepairBootSect]) {
            BootSectorCorrupt = TRUE;
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: bogus filesystem %u for C:!\n",CColonRegion->Filesystem));
            ASSERT(0);
            return;
        }
    }

    //
    // Form the device path to C: and open the partition.
    //

    SpNtNameFromRegion(CColonRegion,(PWSTR)TemporaryBuffer,sizeof(TemporaryBuffer),PartitionOrdinalCurrent);
    CColonPath = SpDupStringW((PWSTR)TemporaryBuffer);
    INIT_OBJA(&Obja,&UnicodeString,CColonPath);

    Status = ZwCreateFile(
        &PartitionHandle,
        FILE_GENERIC_READ | FILE_GENERIC_WRITE,
        &Obja,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_OPEN,
        FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0
        );

    if (!NT_SUCCESS(Status)) {
        KdPrintEx ((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to open the partition for C:!\n"));
        ASSERT(0);
        return;
    }

    //
    // Allocate a buffer and read in the boot sector(s) currently on the disk.
    //

    if (BootSectorCorrupt) {

        //
        // We can't determine the file system type from the boot sector, so
        // we assume it's NTFS if we find a mirror sector, and FAT otherwise.
        //

        if (MirrorSector = NtfsMirrorBootSector (PartitionHandle,
            BytesPerSector, &ExistingBootCode)) {

            //
            // It's NTFS - use the mirror boot sector
            //

            NewBootCode = (!IsNEC_98) ? NtfsBootCode : PC98NtfsBootCode; //NEC98
            BootCodeSize = (!IsNEC_98) ? sizeof(NtfsBootCode) : sizeof(PC98NtfsBootCode); //NEC98
            ASSERT(BootCodeSize == 8192);

            CColonRegion->Filesystem = FilesystemNtfs;
            IsNtBootcode = TRUE;

        } else {

            //
            // It's FAT - create a new boot sector
            //

            NewBootCode = (!IsNEC_98) ? FatBootCode : PC98FatBootCode; //NEC98
            BootCodeSize = (!IsNEC_98) ? sizeof(FatBootCode) : sizeof(PC98FatBootCode); //NEC98
            ASSERT(BootCodeSize == 512);

            CColonRegion->Filesystem = FilesystemFat;
            IsNtBootcode = FALSE;

            SpPtGetSectorLayoutInformation (CColonRegion, &hidden_sectors,
                &ActualSectorCount);

            //
            // No alignment requirement here
            //
            ExistingBootCode = SpMemAlloc(BytesPerSector);

            //
            // This will actually fail with STATUS_BUFFER_TOO_SMALL but it will fill in
            // the bpb, which is what we want
            //
            FmtFillFormatBuffer (
               ActualSectorCount,
               BytesPerSector,
               HardDisks[CColonRegion->DiskNumber].Geometry.SectorsPerTrack,
               HardDisks[CColonRegion->DiskNumber].Geometry.TracksPerCylinder,
               hidden_sectors,
               ExistingBootCode,
               BytesPerSector,
               &super_area_size,
               NULL,
               0,
               &SysId
               );
        }

        Status = STATUS_SUCCESS;

    } else if (
        RepairItems[RepairBootSect] &&
        CColonRegion->Filesystem == FilesystemNtfs &&
        (MirrorSector = NtfsMirrorBootSector (PartitionHandle, BytesPerSector,
            &ExistingBootCode))
        ) {

        //
        // We use the mirror sector to repair a NTFS file system
        //

    } else {

        //
        // Just use the existing boot code.
        //

        Status = pSpBootCodeIo(
                        CColonPath,
                        NULL,
                        BootCodeSize,
                        &ExistingBootCode,
                        FILE_OPEN,
                        FALSE,
                        0,
                        BytesPerSector
                        );

        if(CColonRegion->Filesystem == FilesystemNtfs) {
            MirrorSector = NtfsMirrorBootSector(PartitionHandle,BytesPerSector,NULL);
        }
    }

    if(NT_SUCCESS(Status)) {

        //
        // Determine the type of operating system the existing boot sector(s) are for
        // and whether that os is actually installed. Note that we don't need to call
        // this for NTFS.
        //
        if (BootSectorCorrupt) {

            OtherOsInstalled = FALSE;
            ExistingBootCodeOs = NULL;

        } else if(CColonRegion->Filesystem != FilesystemNtfs) {

            SpDetermineOsTypeFromBootSector(
                CColonPath,
                ExistingBootCode,
                &ExistingBootCodeOs,
                &IsNtBootcode,
                &OtherOsInstalled,
                CColonRegion->DriveLetter
                );

        } else {

            IsNtBootcode = TRUE;
            OtherOsInstalled = FALSE;
            ExistingBootCodeOs = NULL;
        }

        //
        //  lay down the new boot code
        //
        if(OtherOsInstalled) {

            if(RepairItems[RepairBootSect]) {

                p = (PWSTR)TemporaryBuffer;
                wcscpy(p,CColonPath);
                SpConcatenatePaths(p,OldBootsectDosName);
                OldBootSectDosFullName = SpDupStringW(p);
                p = (PWSTR)TemporaryBuffer;
                wcscpy(p,CColonPath);
                SpConcatenatePaths(p,BootsectDosName);
                BootSectDosFullName = SpDupStringW(p);

                //
                // If bootsect.dos already exists, we need to delete
                // bootsect.pre, which may or may not exist and
                // rename the bootsect.dos to bootsect.pre.
                //

                FileExist = SpFileExists(BootSectDosFullName, FALSE);
                if (SpFileExists(OldBootSectDosFullName, FALSE) && FileExist) {

                    SpDeleteFile(CColonPath,OldBootsectDosName,NULL);
                }
                if (FileExist) {
                    SpRenameFile(BootSectDosFullName, OldBootSectDosFullName, FALSE);
                }
                SpMemFree(BootSectDosFullName);
                SpMemFree(OldBootSectDosFullName);
            } else {

                //
                // Delete bootsect.dos in preparation for rewriting it below.
                // Doing this leverages code to set its attributes in SpDeleteFile.
                // (We need to remove read-only attribute before overwriting).
                //
                SpDeleteFile(CColonPath,BootsectDosName,NULL);
            }

            //
            // Write out the existing (old) boot sector into c:\bootsect.dos.
            //
            Status = pSpBootCodeIo(
                            CColonPath,
                            BootsectDosName,
                            BootCodeSize,
                            &ExistingBootCode,
                            FILE_OVERWRITE_IF,
                            TRUE,
                            0,
                            BytesPerSector
                            );

            //
            // Set the description text to the description calculated
            // by SpDetermineOsTypeFromBootSector().
            //
            _snprintf(
                OldSystemLine,
                sizeof(OldSystemLine),
                "C:\\ = \"%s\"\r\n",
                ExistingBootCodeOs
                );

        } // end if(OtherOsInstalled)


        if(NT_SUCCESS(Status)) {

            //
            // Transfer the bpb from the existing boot sector into the boot code buffer
            // and make sure the physical drive field is set to hard disk (0x80).
            //
            // The first three bytes of the NT boot code are going to be something like
            // EB 3C 90, which is intel jump instruction to an offset in the boot sector,
            // past the BPB, to continue execution.  We want to preserve everything in the
            // current boot sector up to the start of that code.  Instead of harcoding
            // a value, we'll use the offset of the jump instruction to determine how many
            // bytes must be preserved.
            //
            RtlMoveMemory(NewBootCode+3,ExistingBootCode+3,NewBootCode[1]-1);
            if(CColonRegion->Filesystem != FilesystemFat32) {
                //
                // On fat32 this overwrites the BigNumFatSecs field,
                // a very bad thing to do indeed!
                //
                NewBootCode[36] = 0x80;
            }

            //
            // get Hidden sector informatin.
            //
            if (IsNEC_98) { //NEC98
                SpPtGetSectorLayoutInformation(
                    CColonRegion,
                    &HiddenSectorCount,
                    &VolumeSectorCount    // not used
                    );
                //
                // write Hidden sector informatin.
                //
                if (!RepairWinnt) {  // for install a partition where before DOS 3.x
                    *((ULONG *)&(NewBootCode[0x1c])) = (ULONG)HiddenSectorCount;
                    if(*((USHORT *)&(NewBootCode[0x13])) != 0) {
                        *((ULONG *)&(NewBootCode[0x20])) = 0L;
                    }
                }
            } //NEC98

            //
            // Write out boot code buffer, which now contains the valid bpb,
            // to the boot sector(s).
            //
            Status = pSpBootCodeIo(
                            CColonPath,
                            NULL,
                            BootCodeSize,
                            &NewBootCode,
                            FILE_OPEN,
                            TRUE,
                            0,
                            BytesPerSector
                            );

            //
            // Special case for Fat32, which has a second sector of boot code
            // at sector 12, discontiguous from the code on sector 0.
            //
            if(NT_SUCCESS(Status) && (CColonRegion->Filesystem == FilesystemFat32)) {

                NewBootCode = (!IsNEC_98) ? Fat32BootCode + 1024
                                          : PC98Fat32BootCode + 1024; //NEC98

                Status = pSpBootCodeIo(
                                CColonPath,
                                NULL,
                                BootCodeSize,
                                &NewBootCode,
                                FILE_OPEN,
                                TRUE,
                                12*512,
                                BytesPerSector
                                );
            }

            //
            // Update the mirror boot sector.
            //
            if((CColonRegion->Filesystem == FilesystemNtfs) && MirrorSector) {
                WriteNtfsBootSector(PartitionHandle,BytesPerSector,NewBootCode,MirrorSector);
            }
        }

        if(ExistingBootCodeOs) {
            SpMemFree(ExistingBootCodeOs);
        }
    }

    if(ExistingBootCode) {
        SpMemFree(ExistingBootCode);
    }

    SpMemFree(CColonPath);
    ZwClose (PartitionHandle);

    //
    // Handle the error case.
    //
    if(!NT_SUCCESS(Status)) {

        WCHAR   DriveLetterString[2];

        DriveLetterString[0] = CColonRegion->DriveLetter;
        DriveLetterString[1] = L'\0';
        SpStringToUpper(DriveLetterString);
        SpStartScreen(SP_SCRN_CANT_INIT_FLEXBOOT,
                      3,
                      HEADER_HEIGHT+1,
                      FALSE,
                      FALSE,
                      DEFAULT_ATTRIBUTE,
                      DriveLetterString,
                      DriveLetterString
                      );

        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);

        SpInputDrain();
        while(SpInputGetKeypress() != KEY_F3) ;

        SpDone(0,FALSE,TRUE);
    }
}


#if defined(REMOTE_BOOT)
BOOLEAN
Spx86FlushRemoteBootVars(
    IN PDISK_REGION TargetRegion,
    IN PWSTR **BootVars,
    IN PWSTR Default
    )
{
    WCHAR BootIni[512];
    NTSTATUS Status;


    //
    // Form the path to boot.ini.
    //

    SpNtNameFromRegion(TargetRegion,BootIni,sizeof(BootIni),PartitionOrdinalCurrent);
    SpConcatenatePaths(BootIni,WBOOT_INI);

    //
    // If Boot.ini already exists, delete it.
    //

    if( SpFileExists( BootIni, FALSE ) ) {
        SpDeleteFile( BootIni, NULL, NULL );
    }

    Status = Spx86WriteBootIni(
                 BootIni,
                 BootVars,
                 1,        // timeout
                 Default,
                 1         // only write one line
                 );

    if(!NT_SUCCESS( Status )) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Error writing boot.ini!\n"));
        goto cleanup;
    }

cleanup:

    return( NT_SUCCESS(Status) );

}
#endif // defined(REMOTE_BOOT)


BOOLEAN
SpHasMZHeader(
    IN PWSTR   FileName
    )
{
    HANDLE   FileHandle;
    HANDLE   SectionHandle;
    PVOID    ViewBase;
    ULONG    FileSize;
    NTSTATUS Status;
    PUCHAR   Header;
    BOOLEAN  Ret = FALSE;

    //
    // Open and map the file.
    //
    FileHandle = 0;
    Status = SpOpenAndMapFile(FileName,
                              &FileHandle,
                              &SectionHandle,
                              &ViewBase,
                              &FileSize,
                              FALSE
                              );
    if(!NT_SUCCESS(Status)) {
        return FALSE;
    }

    Header = (PUCHAR)ViewBase;

    //
    // Guard with try/except in case we get an inpage error
    //
    try {
        if((FileSize >= 2) && (Header[0] == 'M') && (Header[1] == 'Z')) {
            Ret = TRUE;
        }
    } except(IN_PAGE_ERROR) {
        //
        // Do nothing, we simply want to return FALSE.
        //
    }

    SpUnmapFile(SectionHandle, ViewBase);
    ZwClose(FileHandle);

    return Ret;
}

//
// NEC98
//
PUCHAR
SpCreateBootiniImage(
    OUT PULONG   FileSize
)

{

    PUCHAR BootIniBuf,IniImageBuf,IniImageBufSave,IniCreateBuf,IniCreateBufSave;
    PUCHAR FindSectPtr;
    PUCHAR sect; // point to target section. if it is NULL,not existing target section.
    PUCHAR pArcNameA;
    WCHAR  TempBuffer[256];
    WCHAR  TempArcPath[256];
    ULONG  NtDirLen,TotalNtDirlen,CreateBufCnt;
    ULONG  Timeout;
    ULONG  Disk;
    ULONG  BootiniSize;
    ULONG  ArcNameLen;
    PDISK_REGION pRegion;
    HANDLE fh;
    HANDLE SectionHandle;
    PVOID  ViewBase;

#define   Default_Dir "\\MOCHI"

    if(!HardDiskCount){
         return(NULL);
    }
    //
    // Create basic style of boot.ini image and progress pointer end of line.
    //

    NtDirLen = TotalNtDirlen = CreateBufCnt = 0;
    IniCreateBufSave = IniCreateBuf = SpMemAlloc(1024);
    RtlZeroMemory(IniCreateBuf,1024);
    Timeout = DEFAULT_TIMEOUT;
    sprintf(
        IniCreateBuf,
        "%s%s%s%s%ld%s%s%s%s%s%s%s%s",
        FLEXBOOT_SECTION2, // [boot loader]
        CRLF,
        TIMEOUT,
        EQUALS,
        Timeout,
        CRLF,
        DEFAULT,
        EQUALS,
        "c:",
        Default_Dir,
        CRLF
        BOOTINI_OS_SECTION, // [operating systems]
        CRLF
        );

    sect = SppFindSectionInBootIni(IniCreateBuf,FLEXBOOT_SECTION2);
    if(sect == NULL){
        return(NULL);
    }
    for( IniCreateBuf = sect; *IniCreateBuf && (*IniCreateBuf != '\n'); IniCreateBuf++,CreateBufCnt++);
    CreateBufCnt++;

    sect = SppFindSectionInBootIni(IniCreateBuf,TIMEOUT);
    if(sect == NULL){
        return(NULL);
    }
    for( IniCreateBuf = sect; *IniCreateBuf && (*IniCreateBuf != '\n'); IniCreateBuf++,CreateBufCnt++);
    CreateBufCnt++;

    sect = SppFindSectionInBootIni(IniCreateBuf,DEFAULT);
    if(sect == NULL){
        return(NULL);
    }
    for( IniCreateBuf = sect; *IniCreateBuf && (*IniCreateBuf != '\n'); IniCreateBuf++,CreateBufCnt++);
    CreateBufCnt++;

    sect = SppFindSectionInBootIni(IniCreateBuf,BOOTINI_OS_SECTION);
    if(sect == NULL){
        return(NULL);
    }
    for( IniCreateBuf = sect; *IniCreateBuf && (*IniCreateBuf != '\n'); IniCreateBuf++,CreateBufCnt++);
    IniCreateBuf++;
    CreateBufCnt++;


    //
    // Read boot.ini files from all drives.(except sleep and non bootable drives.)
    //

    for(Disk=0; Disk < HardDiskCount; Disk++){

        for(pRegion=PartitionedDisks[Disk].PrimaryDiskRegions; pRegion;pRegion=pRegion->Next){

            if(!pRegion->PartitionedSpace) {
                continue;
            }

            SpNtNameFromRegion(
                            pRegion,
                            TempBuffer,
                            sizeof(TempBuffer),
                            PartitionOrdinalCurrent
                            );


            SpConcatenatePaths(TempBuffer,WBOOT_INI);

            //
            // Open and map the boot.ini file.
            //
            fh = 0;
            if(!NT_SUCCESS(SpOpenAndMapFile(TempBuffer,&fh,&SectionHandle,&ViewBase,&BootiniSize,FALSE))) {
                 continue;
            }

            //
            // Allocate a buffer for the file.
            //

            IniImageBuf = SpMemAlloc(BootiniSize+1);
            IniImageBufSave = IniImageBuf;
            ASSERT(IniImageBuf);
            RtlZeroMemory(IniImageBuf, BootiniSize+1);

            //
            // Transfer boot.ini into the buffer.  We do this because we also
            // want to place a 0 byte at the end of the buffer to terminate
            // the file.
            //
            // Guard the RtlMoveMemory because if we touch the memory backed by boot.ini
            // and get an i/o error, the memory manager will raise an exception.

            try {
                RtlMoveMemory(IniImageBuf,ViewBase,BootiniSize);
            }
            except( IN_PAGE_ERROR ) {
            //
            // Do nothing, boot ini processing can proceed with whatever has been
            // read
            //
            }

            //
            // check out existing target section in boot.ini
            //

            sect = SppFindSectionInBootIni(IniImageBuf,FLEXBOOT_SECTION2);
            if(sect==NULL){
                            SpMemFree(IniImageBufSave);
                            SpUnmapFile(SectionHandle,ViewBase);
                            ZwClose(fh);
                            continue;
            }

            sect = SppFindSectionInBootIni(IniImageBuf,DEFAULT);
            if(sect==NULL){
                            SpMemFree(IniImageBufSave);
                            SpUnmapFile(SectionHandle,ViewBase);
                            ZwClose(fh);
                            continue;
            }


            sect = SppFindSectionInBootIni(IniImageBuf,BOOTINI_OS_SECTION);
            if(sect == NULL){
                SpUnmapFile(SectionHandle,ViewBase);
                ZwClose(fh);
                continue;
            }

            //
            // move pointer to end of line and skip the space.
            //

            for( IniImageBuf = sect; *IniImageBuf && (*IniImageBuf != '\n'); IniImageBuf++ );
            for( ; *IniImageBuf && (( *IniImageBuf == ' ' ) || (*IniImageBuf == '\t')) ; IniImageBuf++ );

            IniImageBuf++;
            FindSectPtr = IniImageBuf;

            //
            //  NOTE:
            //  override arc name when boot path written as "C:", not as arc name.
            //
            ArcNameLen = 0;
            pArcNameA = (PUCHAR)NULL;

            if( ( *(IniImageBuf+1) == L':' )&&( *(IniImageBuf+2) == L'\\' ) ) {

                //
                // This is NEC98 legacy style format, like "C:\WINNT=...",
                // So translate to arc name for boot.ini in NT 5.0
                //
                SpArcNameFromRegion(pRegion,
                                    TempArcPath,
                                    sizeof(TempArcPath),
                                    PartitionOrdinalOriginal,
                                    PrimaryArcPath
                    );

                pArcNameA = SpToOem(TempArcPath);

                if( pArcNameA ) {
                    ArcNameLen = strlen(pArcNameA);
                    IniImageBuf += 2;
                    FindSectPtr = IniImageBuf;
                }
            }

            for( NtDirLen = 0 ; *IniImageBuf && (*IniImageBuf != '\n');NtDirLen++,IniImageBuf++);
            NtDirLen++;

            if( ArcNameLen && pArcNameA ) { // Only case of override arc path.
                RtlMoveMemory( IniCreateBuf+TotalNtDirlen, pArcNameA, ArcNameLen );
                TotalNtDirlen += ArcNameLen;
                SpMemFree(pArcNameA);
            }

            RtlMoveMemory(IniCreateBuf+TotalNtDirlen,FindSectPtr,NtDirLen);
            TotalNtDirlen += NtDirLen;
            SpMemFree(IniImageBufSave);
            SpUnmapFile(SectionHandle,ViewBase);
            ZwClose(fh);

        }
    }

    if(TotalNtDirlen == 0){
        SpMemFree(IniCreateBufSave);
        return(NULL);
    }

    BootIniBuf = SpMemAlloc(CreateBufCnt + TotalNtDirlen + 1);

    if(!(BootIniBuf)){
        SpMemFree(IniCreateBufSave);
        return(NULL);
    }

    if(FileSize) {
        *FileSize = CreateBufCnt + TotalNtDirlen;
    }

    RtlZeroMemory(BootIniBuf,CreateBufCnt + TotalNtDirlen + 1);
    RtlMoveMemory(BootIniBuf,IniCreateBufSave,CreateBufCnt + TotalNtDirlen);
    BootIniBuf[CreateBufCnt + TotalNtDirlen] = 0;
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Create NT List\n%s\n",BootIniBuf));
    SpMemFree(IniCreateBufSave);
    return(BootIniBuf);
}

//
// NEC98
//
BOOLEAN
SppReInitializeBootVars_Nec98(
    OUT PWSTR        **BootVars,
    OUT PWSTR        *Default,
    OUT PULONG       Timeout
    )
{
    WCHAR  BootIni[512];
    HANDLE FileHandle;
    HANDLE SectionHandle;
    PVOID ViewBase;
    NTSTATUS Status;
    ULONG FileSize;
    PUCHAR BootIniBuf;
    PDISK_REGION CColonRegion;
    BOOTVAR i;
    PUCHAR  p;
    ULONG   index;

    PUCHAR TmpBootIniBuf;
    PUCHAR pBuf;
    PUCHAR pTmpBuf;
    PUCHAR pArcNameA;
    PUCHAR NtDir;
    ULONG ArcNameLen;
    ULONG NtDirLen;
    WCHAR TempArcPath[256];
    BOOLEAN IsChanged = FALSE;
    SIZE_T Length;
    HEADLESS_RSP_QUERY_INFO Response;

    //
    // Initialize the defaults
    //

    for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
        if(BootVars[i]){
            SpMemFree(BootVars[i]);
        }
    }

    for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
        BootVars[i] = (PWSTR *)SpMemAlloc( sizeof ( PWSTR * ) );
        ASSERT( BootVars[i] );
        *BootVars[i] = NULL;
    }

    *Default = NULL;
    *Timeout = DEFAULT_TIMEOUT;

    //
    // Just clear BOOTVARS[] when fresh setup.
    //

    if(NTUpgrade != UpgradeFull)
        return TRUE;


    //
    // See if there is a valid C: already.  If not, then silently fail.
    //

#if defined(REMOTE_BOOT)
    if (RemoteBootSetup && !RemoteInstallSetup) {
        ASSERT(RemoteBootTargetRegion != NULL);
        CColonRegion = RemoteBootTargetRegion;
    } else
#endif // defined(REMOTE_BOOT)
    {
        CColonRegion = TargetRegion_Nec98;
    }

    //
    // Form name of file.  Boot.ini better not be on a doublespace drive.
    //

    ASSERT(CColonRegion->Filesystem != FilesystemDoubleSpace);
    SpNtNameFromRegion(CColonRegion,BootIni,sizeof(BootIni),PartitionOrdinalCurrent);
    SpConcatenatePaths(BootIni,WBOOT_INI);

    //
    // Open and map the file.
    //

    FileHandle = 0;
    Status = SpOpenAndMapFile(BootIni,&FileHandle,&SectionHandle,&ViewBase,&FileSize,FALSE);
    if(!NT_SUCCESS(Status)) {
        return TRUE;
    }

    //
    // Allocate a buffer for the file.
    //

    BootIniBuf = SpMemAlloc(FileSize+1);
    ASSERT(BootIniBuf);
    RtlZeroMemory(BootIniBuf, FileSize+1);

    //
    // Transfer boot.ini into the buffer.  We do this because we also
    // want to place a 0 byte at the end of the buffer to terminate
    // the file.
    //
    // Guard the RtlMoveMemory because if we touch the memory backed by boot.ini
    // and get an i/o error, the memory manager will raise an exception.

    try {
        RtlMoveMemory(BootIniBuf,ViewBase,FileSize);
    }
    except( IN_PAGE_ERROR ) {
        //
        // Do nothing, boot ini processing can proceed with whatever has been
        // read
        //
    }

    //
    // Not needed since buffer has already been zeroed, however just do this
    // just the same
    //
    BootIniBuf[FileSize] = 0;
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Create NT List\n%s\n",BootIniBuf));

//***
    TmpBootIniBuf = SpMemAlloc(FileSize+256);
    RtlZeroMemory(TmpBootIniBuf,FileSize+256);
    RtlMoveMemory(TmpBootIniBuf,BootIniBuf,FileSize);

    pBuf = SppFindSectionInBootIni(BootIniBuf,BOOTINI_OS_SECTION);
    pTmpBuf = SppFindSectionInBootIni(TmpBootIniBuf,BOOTINI_OS_SECTION);

    if (pBuf && pTmpBuf) {
        while( *pBuf && (pBuf < BootIniBuf+FileSize-(sizeof("C:\\")-1)) ) {

            if((!_strnicmp(pBuf,"C:\\",sizeof("C:\\")-1))||
               (!_strnicmp(pBuf,"c:\\",sizeof("c:\\")-1))) {

                ArcNameLen = 0;
                pArcNameA = NULL;

                p = strchr(pBuf+3,'='); // *(pBuf+3) == '\\'

                if((p != pBuf+3) && (*p == '=')) {

                    NtDirLen = p - (pBuf+3);
                    NtDir = SpMemAlloc(NtDirLen+1);
                    RtlZeroMemory(NtDir,NtDirLen+1);
                    RtlMoveMemory(NtDir,pBuf+3,NtDirLen);

                    if(SpIsNtInDirectory(TargetRegion_Nec98,SpToUnicode(NtDir))){

                        SpArcNameFromRegion(TargetRegion_Nec98,
                                            TempArcPath,
                                            sizeof(TempArcPath),
                                            PartitionOrdinalOriginal,
                                            PrimaryArcPath
                            );

                        if(pArcNameA=SpToOem(TempArcPath)) {

                            ArcNameLen = strlen(pArcNameA);
                            RtlMoveMemory(pTmpBuf,pArcNameA,ArcNameLen);
                            pBuf += 2;
                            pTmpBuf += ArcNameLen;

                            if( !IsChanged)
                                IsChanged = TRUE;

                            SpMemFree(NtDir);
                            continue;
                        }
                    }
                    SpMemFree(NtDir);
                }
            }
            *pTmpBuf = *pBuf;
            pBuf++;
            pTmpBuf++;
        }
    }        

    if (IsChanged) {
        if (pTmpBuf) {
            *pTmpBuf = 0;
        }            

        SpMemFree(BootIniBuf);
        BootIniBuf = TmpBootIniBuf;
        TmpBootIniBuf = (PUCHAR)NULL;

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, 
            "SETUP: Create New NT List\n%s\n",BootIniBuf));
    } else {
        SpMemFree(TmpBootIniBuf);
        TmpBootIniBuf = (PUCHAR)NULL;
    }

    //
    // Cleanup
    //
    SpUnmapFile(SectionHandle,ViewBase);
    ZwClose(FileHandle);


    //
    // Do the actual processing of the file.
    //
    SppProcessBootIni(BootIniBuf, BootVars, Default, Timeout);

    //
    // Scan the Buffer to see if there is a DefSwitches line,
    // to move into new boot.ini in the  [boot loader] section.
    // If no DefSwitches, just point to a null string to be moved.
    //

    DefSwitches[0] = '\0';
    for(p=BootIniBuf; *p && (p < BootIniBuf+FileSize-(sizeof("DefSwitches")-1)); p++) {
      if(!_strnicmp(p,"DefSwitches",sizeof("DefSwitches")-1)) {
          index = 0;
          while ((*p != '\r') && (*p != '\n') && *p && (index < sizeof(DefSwitches)-4)) {
              DefSwitches[index++] = *p++;
          }
          DefSwitches[index++] = '\r';
          DefSwitches[index++] = '\n';
          DefSwitches[index] = '\0';
          break;
      }
    }


    //
    // Now add any headless parameters to the default switches.
    //
    Length = sizeof(HEADLESS_RSP_QUERY_INFO);
    Status = HeadlessDispatch(HeadlessCmdQueryInformation,
                              NULL,
                              0,
                              &Response,
                              &Length
                             );

    if (NT_SUCCESS(Status) && 
        (Response.PortType == HeadlessSerialPort) &&
        Response.Serial.TerminalAttached) {
        
        if (Response.Serial.UsedBiosSettings) {

            p = "redirect=UseBiosSettings\r\n";

        } else {

            switch (Response.Serial.TerminalPort) {
            case ComPort1:
                p = "redirect=com1\r\n";
                break;
            case ComPort2:
                p = "redirect=com2\r\n";
                break;
            case ComPort3:
                p = "redirect=com3\r\n";
                break;
            case ComPort4:
                p = "redirect=com4\r\n";
                break;
            default:
                ASSERT(0);
                p = NULL;
                break;
            }

        }

        if (p != NULL) {
            strcat(DefSwitches, p);
        }

    }

    SpMemFree(BootIniBuf);
    return( TRUE );
}

//
// NEC98
//
NTSTATUS
SppRestoreBootCode(
    VOID
    )
{

//
// Restore previous OS boot code to boot sector from bootsect.dos.
//

    WCHAR p1[256] = {0};
    PUCHAR BootSectBuf;
    PUCHAR BootCodeBuf;
    HANDLE   FileHandle;
    HANDLE   SectionHandle;
    PVOID    ViewBase;
    ULONG    FileSize;
    NTSTATUS Status;
    PDISK_REGION SystemRegion;
//
// add some code to determine bytes per sector.
//
    ULONG   BytesPerSector;

//    BytesPerSector = HardDisks[SystemPartitionRegion->DiskNumber].Geometry.BytesPerSector;
    BytesPerSector = 512;       //???

    wcscpy(p1,NtBootDevicePath);
    SpConcatenatePaths(p1,L"bootsect.dos");

    FileHandle = 0;
    Status = SpOpenAndMapFile(p1,&FileHandle,&SectionHandle,&ViewBase,&FileSize,FALSE);

    if(!NT_SUCCESS(Status)) {
        return(Status);
    }

    BootCodeBuf = SpMemAlloc(FileSize+1);

    try {
        RtlMoveMemory(BootCodeBuf,ViewBase,FileSize);
    }
    except( IN_PAGE_ERROR ) {
        //
        // Do nothing, boot ini processing can proceed with whatever has been
        // read
        //
    }

    Status = pSpBootCodeIo(
            NtBootDevicePath,
                    NULL,
                    2048,
                    &BootSectBuf,
                    FILE_OPEN,
                    FALSE,
                    0,
                    BytesPerSector
                    );

    if(!NT_SUCCESS(Status)) {
        SpMemFree(BootCodeBuf);
        SpUnmapFile(SectionHandle,ViewBase);
        ZwClose(FileHandle);
        return(Status);
    }

    //
    // Keep dirty flag in FAT BPB, to avoid confusion in disk management.
    //
    SystemRegion = SpRegionFromNtName(NtBootDevicePath, PartitionOrdinalCurrent);
    
    if(SystemRegion && (SystemRegion->Filesystem != FilesystemNtfs)) {
        BootCodeBuf[0x25] = BootSectBuf[0x25]; // Dirty flag in BPB.
    }

    RtlMoveMemory(BootSectBuf,BootCodeBuf,512);

    pSpBootCodeIo(
        NtBootDevicePath,
        NULL,
        2048,
        &BootSectBuf,
        FILE_OPEN,
        TRUE,
        0,
        BytesPerSector
        );

    SpMemFree(BootCodeBuf);
    SpMemFree(BootSectBuf);
    SpUnmapFile(SectionHandle,ViewBase);
    ZwClose(FileHandle);
    
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spwinp.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    spwinp.h

Abstract:

    Win32 portability layer
        file i/o
        Get/SetLastError

Author:

    Calin Negreanu (calinn) 27-Apr-2000

Revision History:

    Jay Krell (a-JayK) November 2000
        ported from windows\winstate\... to admin\ntsetup\textmode\kernel\spcab.h
--*/

#define PATHS_ALWAYS_NATIVE 1

NTSTATUS
SpConvertWin32FileOpenOrCreateToNtFileOpenOrCreate(
    ULONG Win32OpenOrCreate,
    ULONG* NtOpenOrCreate
    );

NTSTATUS
SpConvertWin32FileAccessToNtFileAccess(
    ULONG  Win32FileAccess,
    ULONG* NtFileAccess
    );

NTSTATUS
SpConvertWin32FileShareToNtFileShare(
    ULONG  Win32FileShare,
    ULONG* NtFileShare
    );

HANDLE
SpCreateFileW(
    PCUNICODE_STRING Path,
    IN ULONG FileAccess,
    IN ULONG FileShare,
    IN LPSECURITY_ATTRIBUTES SecurityAttributes,
    IN ULONG  Win32FileOpenOrCreate,
    IN ULONG  FlagsAndAttributes,
    IN HANDLE TemplateFile
    );

BOOL
SpDeleteFileW(
    PCUNICODE_STRING Path
    );

#if !PATHS_ALWAYS_NATIVE

NTSTATUS
SpConvertPathToNtPath(
    PRTL_UNICODE_STRING_BUFFER Buffer
    )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\i386\bootini.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    bootx86.h

Abstract:

    Code to do

Author:

    Sunil Pai (sunilp) 26-Oct-1993

Revision History:

--*/

#define     FLEXBOOT_SECTION1       "[flexboot]"
#define     FLEXBOOT_SECTION2       "[boot loader]"
#define     FLEXBOOT_SECTION3       "[multiboot]"
#define     BOOTINI_OS_SECTION      "[operating systems]"
#define     TIMEOUT                 "timeout"
#define     DEFAULT                 "default"
#define     CRLF                    "\r\n"
#define     EQUALS                  "="

#define     WBOOT_INI               L"boot.ini"
#define     WBOOT_INI_BAK           L"bootini.bak"


//
// Use this to keep track of boot.ini entries
// that previously contained 'signatured' entries
// since we convert them to multi... enties when
// we initially read the boot.ini.  Rather than
// work backwards, we'll just use this struct
// to re-match the boot.ini entries when we're
// about to write it out, thus giving us a shortcut
// to determining which boot.ini entries need to
// have the 'signature' entry.
//
typedef struct _SIGNATURED_PARTITIONS {
    struct _SIGNATURED_PARTITIONS   *Next;

    //
    // What's the original boot.ini entry with that contained
    // the signature?
    //
    PWSTR                           SignedString;

    //
    // What's the boot.ini entry after we've converted it into
    // a 'multi' string?
    //
    PWSTR                           MultiString;
    } SIGNATURED_PARTITIONS;

extern SIGNATURED_PARTITIONS SignedBootVars;


//
// Public routines
//

BOOLEAN
Spx86InitBootVars(
    OUT PWSTR  **BootVars,
    OUT PWSTR  *Default,
    OUT PULONG Timeout
    );

BOOLEAN
Spx86FlushBootVars(
    IN PWSTR **BootVars,
    IN ULONG Timeout,
    IN PWSTR Default
    );

VOID
SpLayBootCode(
    IN PDISK_REGION CColonRegion
    );

#if defined(REMOTE_BOOT)
BOOLEAN
Spx86FlushRemoteBootVars(
    IN PDISK_REGION TargetRegion,
    IN PWSTR **BootVars,
    IN PWSTR Default
    );
#endif // defined(REMOTE_BOOT)

//
// Private routines
//

VOID
SppProcessBootIni(
    IN  PCHAR  BootIni,
    OUT PWSTR  **BootVars,
    OUT PWSTR  *Default,
    OUT PULONG Timeout
    );

PCHAR
SppNextLineInSection(
    IN PCHAR p
    );

PCHAR
SppFindSectionInBootIni(
    IN PCHAR p,
    IN PCHAR Section
    );

BOOLEAN
SppProcessLine(
    IN PCHAR Line,
    IN OUT PCHAR Key,
    IN OUT PCHAR Value,
    IN OUT PCHAR RestOfLine
    );

BOOLEAN
SppNextToken(
    PCHAR p,
    PCHAR *pBegin,
    PCHAR *pEnd
    );

//
// NEC98
//
PUCHAR
SpCreateBootiniImage(
    OUT PULONG   FileSize
);

//
// NEC98
//
BOOLEAN
SppReInitializeBootVars_Nec98(
    OUT PWSTR **BootVars,
    OUT PWSTR *Default,
    OUT PULONG Timeout
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\i386\smashlck.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    smashlck.c

Abstract:

    This function smashes lock prefixes replacing them with NOPs

Author:

    Mark Lucovsky (markl) 30-Apr-1993

Revision History:

    Ted Miller (tedm) 7-Dec-1993 -- copied from imagehlp, modified for setup.

--*/

#include "spprecmp.h"
#pragma hdrstop

#define OPCODE_LOCK_PREFIX ((UCHAR)0xf0)
#define OPCODE_NO_OP       ((UCHAR)0x90)

typedef struct _LOADED_IMAGE {
    HANDLE                hFile;
    HANDLE                hSection;
    PUCHAR                MappedAddress;
    ULONG                 FileSize;
    ULONG                 Characteristics;
    PIMAGE_NT_HEADERS     NtHeader;
    PIMAGE_SECTION_HEADER LastRvaSection;
    ULONG                 NumberOfSections;
    PIMAGE_SECTION_HEADER Sections;
} LOADED_IMAGE, *PLOADED_IMAGE;


PVOID
RvaToVa(
    PVOID Rva,
    PLOADED_IMAGE Image
    )
{

    PIMAGE_SECTION_HEADER Section;
    ULONG i;
    PVOID Va;

    Rva = (PVOID)((PUCHAR)Rva-(PUCHAR)Image->NtHeader->OptionalHeader.ImageBase);
    Va = NULL;
    Section = Image->LastRvaSection;
    if ( (ULONG)Rva >= Section->VirtualAddress &&
         (ULONG)Rva < Section->VirtualAddress + Section->SizeOfRawData ) {
        Va = (PVOID)((ULONG)Rva - Section->VirtualAddress + Section->PointerToRawData + Image->MappedAddress);
        }
    else {
        for(Section = Image->Sections,i=0; i<Image->NumberOfSections; i++,Section++) {
            if ( (ULONG)Rva >= Section->VirtualAddress &&
                 (ULONG)Rva < Section->VirtualAddress + Section->SizeOfRawData ) {
                Va = (PVOID)((ULONG)Rva - Section->VirtualAddress + Section->PointerToRawData + Image->MappedAddress);
                Image->LastRvaSection = Section;
                break;
                }
            }
        }
    if ( !Va ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: RvaToVa %lx failed\n",Rva));
        }
    return Va;
}


BOOLEAN
pSpLoadForSmash(
    IN  PWSTR         ImageName,  OPTIONAL
    IN  HANDLE        FileHandle, OPTIONAL
    OUT PLOADED_IMAGE LoadedImage
    )
{
    NTSTATUS          Status;
    PIMAGE_NT_HEADERS NtHeader;

    //
    // open and map the file.
    // then fill in the loaded image descriptor
    //

    if(FileHandle) {

        LoadedImage->hFile = FileHandle;

        Status =  SpGetFileSize(FileHandle,&LoadedImage->FileSize);
        if(NT_SUCCESS(Status)) {
            Status = SpMapEntireFile(
                        FileHandle,
                        &LoadedImage->hSection,
                        &LoadedImage->MappedAddress,
                        TRUE
                        );
        }

    } else {

        ASSERT(ImageName);

        Status = SpOpenAndMapFile(
                    ImageName,
                    &LoadedImage->hFile,
                    &LoadedImage->hSection,
                    &LoadedImage->MappedAddress,
                    &LoadedImage->FileSize,
                    TRUE
                    );
    }

    if(!NT_SUCCESS(Status)) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
            "SETUP: pSpLoadForSmash: open/map %ws failed (%lx)\n",
            ImageName ? ImageName : L"(by handle)",
            Status
            ));

        return FALSE;
    }

    //
    // Check the image and find nt image headers
    //

    if((NtHeader = RtlImageNtHeader(LoadedImage->MappedAddress))
    &&  NtHeader->FileHeader.SizeOfOptionalHeader)
    {
        LoadedImage->Characteristics = NtHeader->FileHeader.Characteristics;
        LoadedImage->NumberOfSections = NtHeader->FileHeader.NumberOfSections;
        LoadedImage->Sections = (PIMAGE_SECTION_HEADER)((PUCHAR)NtHeader + sizeof(IMAGE_NT_HEADERS));
        LoadedImage->LastRvaSection = LoadedImage->Sections;

        LoadedImage->NtHeader = NtHeader;

    } else {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
            "SETUP: pSpLoadForSmash: %ws is not an NT image\n",
            ImageName ? ImageName : L"(by handle)"
            ));

        SpUnmapFile(LoadedImage->hSection,LoadedImage->MappedAddress);
        ZwClose(LoadedImage->hFile);
    }

    return (BOOLEAN)(NtHeader != NULL);
}


VOID
SpMashemSmashem(
    IN HANDLE FileHandle, OPTIONAL
    IN PWSTR  Name1,      OPTIONAL
    IN PWSTR  Name2,      OPTIONAL
    IN PWSTR  Name3       OPTIONAL
    )
{
    PWSTR FullFilename;
    LOADED_IMAGE LoadedImage;
    ULONG whocares;
    PIMAGE_LOAD_CONFIG_DIRECTORY ConfigInfo;
    ULONG CheckSum;
    ULONG HeaderSum;
    BOOLEAN LocksSmashed;
    BOOLEAN b;

    //
    // Determine whether we really need to smash locks.
    // We need to do this if we are installing for a UP machine.
    //
    if(SpInstallingMp()) {
        return;
    }

    //
    // Form the full name of the file if a file handle is not specified.
    //
    if(FileHandle) {

        FullFilename = NULL;

    } else {

        ASSERT(Name1);

        wcscpy((PWSTR)TemporaryBuffer,Name1);
        if(Name2) {
            SpConcatenatePaths((PWSTR)TemporaryBuffer,Name2);
        }
        if(Name3) {
            SpConcatenatePaths((PWSTR)TemporaryBuffer,Name3);
        }
        FullFilename = SpDupStringW((PWSTR)TemporaryBuffer);
    }

    //
    // Attempt to load and map the image for smashing.
    //
    try {

        b = pSpLoadForSmash(FullFilename,FileHandle,&LoadedImage);

    } except(EXCEPTION_EXECUTE_HANDLER) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
            "SETUP: Warning: exception while loading %ws for smash\n",
            FullFilename ? FullFilename : L"(by handle)"
            ));

        b = FALSE;
    }

    if(b) {

        //
        // make sure the image has correct configuration information,
        // and that the LockPrefixTable is set up properly
        //
        // Put exception handling around this since we haven't yet verified the file
        // and it may be corrupted.
        //

        try {

            ConfigInfo = (PIMAGE_LOAD_CONFIG_DIRECTORY)RtlImageDirectoryEntryToData(
                                                            LoadedImage.MappedAddress,
                                                            FALSE,
                                                            IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,
                                                            &whocares
                                                            );

            if(ConfigInfo && ConfigInfo->LockPrefixTable) {

                //
                // Walk through the lock prefix table
                //

                PUCHAR *LockPrefixs;
                PUCHAR LockPrefix;

                LockPrefixs = (PUCHAR *)RvaToVa((PVOID)ConfigInfo->LockPrefixTable,&LoadedImage);

                while(LockPrefixs && *LockPrefixs) {

                    LockPrefix = RvaToVa(*LockPrefixs,&LoadedImage);
                    if(LockPrefix && (*LockPrefix == OPCODE_LOCK_PREFIX)) {

                        LocksSmashed = TRUE;
                        *LockPrefix = OPCODE_NO_OP;
                    }

                    LockPrefixs++;
                }

                if(LocksSmashed) {

                    //
                    // recompute the checksum.
                    //

                    LoadedImage.NtHeader->OptionalHeader.CheckSum = 0;

                    SpChecksumMappedFile(
                        LoadedImage.MappedAddress,
                        LoadedImage.FileSize,
                        &HeaderSum,
                        &CheckSum
                        );

                    LoadedImage.NtHeader->OptionalHeader.CheckSum = CheckSum;

                    //
                    // Flush changes.
                    //
                    SpFlushVirtualMemory(LoadedImage.MappedAddress,0);
                }
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                "SETUP: Warning: exception while smashing locks for %ws\n",
                FullFilename ? FullFilename : L"(by handle)"
                ));

        }

        SpUnmapFile(LoadedImage.hSection,LoadedImage.MappedAddress);
        if(!FileHandle) {
            ZwClose(LoadedImage.hFile);
        }

    } else {
        //
        // This is not really a fatal problem
        // but we probably ought to alert the user.
        //
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Failed to smash a lock.\n"));

    }

    if(FullFilename) {
        SpMemFree(FullFilename);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\i386\spwin9xuninstall.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    spwin9xuninstall.h

Abstract:

Author:

    Jay Krell (a-JayK) December 2000

Revision History:

--*/
#pragma once

#include "spcab.h"

#define BACKUP_IMAGE_IS_CAB 1

#if !BACKUP_IMAGE_IS_CAB

#pragma pack(push,1)

typedef struct {
    DWORD Signature;
    DWORD FileCount;

    struct {
        // zero means "no directory"
        DWORD Low;
        DWORD High;
    } DirectoryOffset;

} BACKUP_IMAGE_HEADER, *PBACKUP_IMAGE_HEADER;

typedef struct {
    DWORD FileSize;         // we don't support files > 4G
    WORD FileNameBytes;
    FILE_BASIC_INFORMATION Attributes;
    // file name is next (NT name in unicode)
    // file content is next
} BACKUP_FILE_HEADER, *PBACKUP_FILE_HEADER;

#pragma pack(pop)

#define BACKUP_IMAGE_SIGNATURE          0x53574A01          // JWS plus version

#else

#pragma pack(push,1)

typedef struct {
    BYTE Pad;
} BACKUP_IMAGE_HEADER, *PBACKUP_IMAGE_HEADER;

typedef struct {
    BYTE Pad;
} BACKUP_FILE_HEADER, *PBACKUP_FILE_HEADER;

#pragma pack(pop)

typedef struct {
    // This is actually a OCAB_HANDLE / PFDI_CAB_HANDLE half the time, but this is ok.
    CCABHANDLE CabHandle;
    BOOL (*CloseCabinet)(PVOID CabHandle);
} *BACKUP_IMAGE_HANDLE;

#endif

BOOLEAN
SppPutFileInBackupImage(
    IN      BACKUP_IMAGE_HANDLE ImageHandle,
    IN OUT  PLARGE_INTEGER ImagePos,
    IN OUT  PBACKUP_IMAGE_HEADER ImageHeader,
    IN      PWSTR DosPath
    );

BOOLEAN
SppCloseBackupImage (
    IN      BACKUP_IMAGE_HANDLE BackupImageHandle,
    IN      PBACKUP_IMAGE_HEADER ImageHeader,       OPTIONAL
    IN      PWSTR JournalFile                       OPTIONAL
    );

BOOLEAN
SppWriteToFile (
    IN      HANDLE FileHandle,
    IN      PVOID Data,
    IN      UINT DataSize,
    IN OUT  PLARGE_INTEGER WritePos         OPTIONAL
    );

BOOLEAN
SppReadFromFile (
    IN      HANDLE FileHandle,
    OUT     PVOID Data,
    IN      UINT DataBufferSize,
    OUT     PINT BytesRead,
    IN OUT  PLARGE_INTEGER ReadPos          OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\i386\spdskreg.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    spdskreg.c

Abstract:

    Code for building and manipulating the disk registry. Used in the Win9x Upgrade
        case.

Author:

    Marc R. Whitten (marcw) 11-Mar-1997

Revision History:

--*/

#include "spprecmp.h"
#pragma hdrstop

PUCHAR DiskRegistryKey = DISK_REGISTRY_KEY;
PUCHAR DiskRegistryClass = "Disk and fault tolerance information.";
PUCHAR DiskRegistryValue = DISK_REGISTRY_VALUE;
#define WORK_BUFFER_SIZE 4096


//
// In spw9xupg.c - Should be moved to a header file.
//
PDISK_REGION
SpFirstPartitionedRegion (
    IN PDISK_REGION Region,
    IN BOOLEAN Primary
    );

PDISK_REGION
SpNextPartitionedRegion (
    IN PDISK_REGION Region,
    IN BOOLEAN Primary
    );


//
// In spupgcfg.c
//
NTSTATUS
SppCopyKeyRecursive(
    HANDLE  hKeyRootSrc,
    HANDLE  hKeyRootDst,
    PWSTR   SrcKeyPath,   OPTIONAL
    PWSTR   DstKeyPath,   OPTIONAL
    BOOLEAN CopyAlways,
    BOOLEAN ApplyACLsAlways
    );


//
// wrapper functions to allow linking with diskreg.lib.
//

//
// Have to turn off this warning temporarily.
//

#define TESTANDFREE(Memory) {if (Memory) {SpMemFree(Memory);}}


NTSTATUS
FtCreateKey(
    PHANDLE HandlePtr,
    PUCHAR KeyName,
    PUCHAR KeyClass
    )


{
    NTSTATUS          status;
    STRING            keyString;
    UNICODE_STRING    unicodeKeyName;
    STRING            classString;
    UNICODE_STRING    unicodeClassName;
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG             disposition;
    HANDLE            tempHandle;


    //
    // Initialize the object for the key.
    //

    RtlInitString(&keyString,
                  KeyName);

    (VOID)RtlAnsiStringToUnicodeString(&unicodeKeyName,
                                       &keyString,
                                       TRUE);

    memset(&objectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));
    InitializeObjectAttributes(&objectAttributes,
                               &unicodeKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    //
    // Setup the unicode class value.
    //

    RtlInitString(&classString,
                  KeyClass);
    (VOID)RtlAnsiStringToUnicodeString(&unicodeClassName,
                                       &classString,
                                       TRUE);

    //
    // Create the key.
    //

    status = ZwCreateKey(&tempHandle,
                         KEY_READ | KEY_WRITE,
                         &objectAttributes,
                         0,
                         &unicodeClassName,
                         REG_OPTION_NON_VOLATILE,
                         &disposition);

    if (NT_SUCCESS(status)) {
        switch (disposition)
        {
        case REG_CREATED_NEW_KEY:
            break;

        case REG_OPENED_EXISTING_KEY:
            break;

        default:
            break;
        }
    }

    //
    // Free all allocated space.
    //

    RtlFreeUnicodeString(&unicodeKeyName);
    RtlFreeUnicodeString(&unicodeClassName);

    if (HandlePtr != NULL) {
        *HandlePtr = tempHandle;
    } else {
        NtClose(tempHandle);
    }
    return status;
}


NTSTATUS
FtOpenKey(
    PHANDLE HandlePtr,
    PUCHAR  KeyName,
    PUCHAR  CreateKeyClass
    )


{
    NTSTATUS          status;
    STRING            keyString;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING    unicodeKeyName;

    RtlInitString(&keyString,
                  KeyName);

    (VOID)RtlAnsiStringToUnicodeString(&unicodeKeyName,
                                       &keyString,
                                       TRUE);

    memset(&objectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));
    InitializeObjectAttributes(&objectAttributes,
                               &unicodeKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = ZwOpenKey(HandlePtr,
                       MAXIMUM_ALLOWED,
                       &objectAttributes);

    RtlFreeUnicodeString(&unicodeKeyName);


    if ((!NT_SUCCESS(status)) && (CreateKeyClass)) {
        status = FtCreateKey(HandlePtr,
                             KeyName,
                             CreateKeyClass);
    }
    return status;
}
NTSTATUS
FtRegistryQuery(
    IN PUCHAR  ValueName,
    OUT PVOID *FreeToken,
    OUT PVOID *Buffer,
    OUT ULONG *LengthReturned,
    OUT PHANDLE HandlePtr
    )

{
    NTSTATUS        status;
    HANDLE          handle;
    ULONG           resultLength;
    STRING          valueString;
    UNICODE_STRING  unicodeValueName;
    PDISK_CONFIG_HEADER         regHeader;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation= NULL;

    *LengthReturned = 0;
    status = FtOpenKey(&handle,
                       DiskRegistryKey,
                       NULL);
    if (NT_SUCCESS(status)) {

        RtlInitString(&valueString,
                      ValueName);
        RtlAnsiStringToUnicodeString(&unicodeValueName,
                                     &valueString,
                                     TRUE);
        resultLength = WORK_BUFFER_SIZE;

        while (1) {
            keyValueInformation = (PKEY_VALUE_FULL_INFORMATION)
                                                       SpMemAlloc(resultLength);
            status = ZwQueryValueKey(handle,
                                     &unicodeValueName,
                                     KeyValueFullInformation,
                                     keyValueInformation,
                                     resultLength,
                                     &resultLength);

            if (status == STATUS_BUFFER_OVERFLOW) {

                TESTANDFREE(keyValueInformation);

                //
                // Loop again and get a larger buffer.
                //

            } else {

                //
                // Either a real error or the information fit.
                //

                break;
            }
        }
        RtlFreeUnicodeString(&unicodeValueName);

        if (HandlePtr != NULL) {
            *HandlePtr = handle;
        } else {
            NtClose(handle);
        }

        if (NT_SUCCESS(status)) {
            if (keyValueInformation->DataLength == 0) {

                //
                // Treat this as if there was not disk information.
                //

                TESTANDFREE(keyValueInformation);
                *FreeToken = (PVOID) NULL;
                return STATUS_OBJECT_NAME_NOT_FOUND;
            } else {

                //
                // Set up the pointers for the caller.
                //

                regHeader = (PDISK_CONFIG_HEADER)
                  ((PUCHAR) keyValueInformation + keyValueInformation->DataOffset);
                *LengthReturned = regHeader->FtInformationOffset +
                                  regHeader->FtInformationSize;
                *Buffer = (PVOID) regHeader;
            }
        }
        *FreeToken = (PVOID) keyValueInformation;
    } else {
        *FreeToken = (PVOID) NULL;
    }

    return status;
}

NTSTATUS
FtSetValue(
    HANDLE KeyHandle,
    PUCHAR ValueName,
    PVOID  DataBuffer,
    ULONG  DataLength,
    ULONG  Type
    )

{
    NTSTATUS          status;
    STRING            valueString;
    UNICODE_STRING    unicodeValueName;

    RtlInitString(&valueString,
                  ValueName);
    RtlAnsiStringToUnicodeString(&unicodeValueName,
                                 &valueString,
                                 TRUE);
    status = ZwSetValueKey(KeyHandle,
                           &unicodeValueName,
                           0,
                           Type,
                           DataBuffer,
                           DataLength);

    RtlFreeUnicodeString(&unicodeValueName);
    return status;
}

NTSTATUS
FtDeleteValue(
    HANDLE KeyHandle,
    PUCHAR ValueName
    )

{
    NTSTATUS       status;
    STRING         valueString;
    UNICODE_STRING unicodeValueName;

    RtlInitString(&valueString,
                  ValueName);
    status = RtlAnsiStringToUnicodeString(&unicodeValueName,
                                          &valueString,
                                          TRUE);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = ZwDeleteValueKey(KeyHandle,
                              &unicodeValueName);

    RtlFreeUnicodeString(&unicodeValueName);
    return status;
}

VOID
FtBackup(
    IN HANDLE KeyHandle
    )

{
    //
    // For the time being (i.e. rename doesn't work), just attempt
    // to delete the value.
    //

    (VOID) FtDeleteValue(KeyHandle,
                         DiskRegistryKey);
}

BOOLEAN
SpDiskRegistryAssignDriveLetter(
    ULONG         Signature,
    LARGE_INTEGER StartingOffset,
    LARGE_INTEGER Length,
    UCHAR         DriveLetter
    )

/*++

Routine Description:

    This routine will get the information from the disk registry
    and update the drive letter assigned for the partition in
    the registry information.  This includes any cleanup for FT
    sets when they change drive letter.

Arguments:

    Signature      - disk signature for disk containing partition for letter.
    StartingOffset - Starting offset of partition for the letter.
    Length         - lenght of affected partition.
    DriveLetter    - New drive letter for affected partition.

Return Value:

    TRUE if all works.

--*/

{
    BOOLEAN                writeRegistry= FALSE;
    PVOID                  freeToken = NULL;
    ULONG                  lengthReturned,
                           i,
                           j,
                           k,
                           l;
    NTSTATUS               status;
    USHORT                 type,
                           group;
    PDISK_CONFIG_HEADER    regHeader;
    PDISK_REGISTRY         diskRegistry;
    PDISK_DESCRIPTION      diskDescription;
    PDISK_PARTITION        diskPartition;
    PUCHAR                 endOfDiskInfo;
    HANDLE                 handle;
    PFT_REGISTRY           ftRegistry;
    PFT_DESCRIPTION        ftDescription;
    PFT_MEMBER_DESCRIPTION ftMember;

    //
    // Get the registry information.
    //

    status = FtRegistryQuery(DiskRegistryValue,
                             &freeToken,
                             (PVOID *) &regHeader,
                             &lengthReturned,
                             &handle);

    if (!NT_SUCCESS(status)) {

        //
        // Could be permission problem, or there is no registry information.
        //

        lengthReturned = 0;

        //
        // Try to open the key for later use when setting the new value.
        //

        status = FtOpenKey(&handle,
                           DiskRegistryKey,
                           NULL);
    }

    if (!NT_SUCCESS(status)) {

        //
        // There is no registry key for the disk information.
        // Return FALSE and force caller to create registry information.
        //

        return FALSE;
    }

    if (lengthReturned == 0) {

        //
        // There is currently no registry information.
        //

        NtClose(handle);
        TESTANDFREE(freeToken);
        return FALSE;
    }

    //
    // Search for the disk signature.
    //

    diskRegistry = (PDISK_REGISTRY)
                         ((PUCHAR)regHeader + regHeader->DiskInformationOffset);
    diskDescription = &diskRegistry->Disks[0];

    for (i = 0; i < diskRegistry->NumberOfDisks; i++) {

        if (diskDescription->Signature == Signature) {

            //
            // Now locate the partition.
            //

            for (j = 0; j < diskDescription->NumberOfPartitions; j++) {

                diskPartition = &diskDescription->Partitions[j];

                if ((StartingOffset.QuadPart == diskPartition->StartingOffset.QuadPart) &&
                    (Length.QuadPart == diskPartition->Length.QuadPart)) {

                    if (diskPartition->FtType == NotAnFtMember) {

                        //
                        // Found the affected partition simple partition
                        // i.e. not a part of an FT set.
                        //

                        writeRegistry= TRUE;
                        if (DriveLetter == ' ') {
                            diskPartition->AssignDriveLetter = FALSE;
                        } else {
                            diskPartition->AssignDriveLetter = TRUE;
                        }
                        diskPartition->DriveLetter = DriveLetter;
                    } else {

                        //
                        // For FT sets work from the FT information area,
                        // not from this partition location.
                        //

                        type = diskPartition->FtType;
                        group = diskPartition->FtGroup;
                        if (!regHeader->FtInformationOffset) {

                            //
                            // This is really a corrupt hive!  The partition
                            // affected is part of an FT set, but there is no
                            // FT information.
                            //

                            NtClose(handle);
                            TESTANDFREE(freeToken);
                            return FALSE;
                        }

                        //
                        // This is an FT set member, must correct the
                        // drive letter for all FT set members in the
                        // registry.
                        //

                        ftRegistry = (PFT_REGISTRY)
                                      ((PUCHAR)regHeader + regHeader->FtInformationOffset);

                        ftDescription = &ftRegistry->FtDescription[0];

                        for (k = 0; k < ftRegistry->NumberOfComponents; k++) {

                            if (ftDescription->Type == type) {

                                //
                                // For each member, chase back to the diskPartition
                                // information and if this is the correct FtGroup
                                // update the drive letter.
                                //

                                for (l = 0; l < ftDescription->NumberOfMembers; l++) {
                                    ftMember = &ftDescription->FtMemberDescription[l];
                                    diskPartition = (PDISK_PARTITION)
                                        ((PUCHAR)regHeader + ftMember->OffsetToPartitionInfo);

                                    //
                                    // This could be a different FtGroup for the
                                    // same FT type.  Check the group before
                                    // changing.
                                    //

                                    if (diskPartition->FtGroup == group) {

                                        writeRegistry= TRUE;
                                        diskPartition->DriveLetter = DriveLetter;

                                        //
                                        // Maintain the AssignDriveLetter flag on
                                        // the zero member of the set only.
                                        //

                                        if (diskPartition->FtMember == 0) {
                                            if (DriveLetter == ' ') {
                                                diskPartition->AssignDriveLetter = FALSE;
                                            } else {
                                                diskPartition->AssignDriveLetter = TRUE;
                                            }
                                        }
                                    } else {

                                        //
                                        // Not the same group, go to the next
                                        // FT set description.
                                        //

                                        break;
                                    }
                                }

                                //
                                // break out to write the registry information
                                // once the correct set has been found.
                                //

                                if (writeRegistry) {
                                    break;
                                }
                            }
                            ftDescription = (PFT_DESCRIPTION)
                                &ftDescription->FtMemberDescription[ftDescription->NumberOfMembers];
                        }

                        //
                        // If this actually falls through as opposed to the
                        // break statement in the for loop above, it indicates a
                        // bad disk information structure.
                        //

                    }

                    //
                    // Only write this back out if it is believed that things
                    // worked correctly.
                    //

                    if (writeRegistry) {

                        //
                        // All done with setting new drive letter in registry.
                        // Backup the previous value.
                        //

                        FtBackup(handle);

                        //
                        // Set the new value.
                        //

                        status = FtSetValue(handle,
                                            DiskRegistryValue,
                                            regHeader,
                                            sizeof(DISK_CONFIG_HEADER) +
                                                regHeader->DiskInformationSize +
                                                regHeader->FtInformationSize,
                                            REG_BINARY);


                        NtClose(handle);
                        TESTANDFREE(freeToken);
                        return TRUE;
                    }
                }
            }
        }

        //
        // Look at the next disk
        //

        diskDescription = (PDISK_DESCRIPTION)
              &diskDescription->Partitions[diskDescription->NumberOfPartitions];
    }

    return TRUE;
}




NTSTATUS
SpDiskRegistryAssignCdRomLetter(
    IN PWSTR CdromName,
    IN WCHAR DriveLetter
    )

{
    NTSTATUS status;
    HANDLE   handle;
    WCHAR    newValue[4];
    UNICODE_STRING unicodeValueName;

    //
    // Try to open the key for later use when setting the new value.
    //

    status = FtOpenKey(&handle,
                       DiskRegistryKey,
                       DiskRegistryClass);

    if (NT_SUCCESS(status)) {
        unicodeValueName.MaximumLength =
            unicodeValueName.Length = (wcslen(CdromName) * sizeof(WCHAR)) + sizeof(WCHAR);

        unicodeValueName.Buffer = CdromName;
        unicodeValueName.Length -= sizeof(WCHAR); // don't count the eos
        newValue[0] = DriveLetter;
        newValue[1] = (WCHAR) ':';
        newValue[2] = 0;

        status = ZwSetValueKey(handle,
                               &unicodeValueName,
                               0,
                               REG_SZ,
                               &newValue,
                               3 * sizeof(WCHAR));
        NtClose(handle);
    }
    return status;
}


//
// This is a modified SppMigrateFtKeys.
//
NTSTATUS
SpMigrateDiskRegistry(
    IN HANDLE hDestSystemHive
    )

/*++

Routine Description:


Arguments:

    hDestSystemHive - Handle to the root of the system hive on the system
                      being upgraded.


Return Value:

    Status value indicating outcome of operation.

--*/

{
    NTSTATUS Status;
    NTSTATUS SavedStatus;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;

    PWSTR   FtDiskKeys[] = {
                           L"Disk"
                           };
    WCHAR   KeyPath[MAX_PATH];
    HANDLE  SrcKey;
    ULONG   i;

    SavedStatus = STATUS_SUCCESS;
    for( i = 0; i < sizeof(FtDiskKeys)/sizeof(PWSTR); i++ ) {
        //
        //  Open the source key
        //
        swprintf( KeyPath, L"\\registry\\machine\\system\\%ls", FtDiskKeys[i] );
        INIT_OBJA(&Obja,&UnicodeString,KeyPath);
        Obja.RootDirectory = NULL;

        Status = ZwOpenKey(&SrcKey,KEY_ALL_ACCESS,&Obja);
        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ls on the setup hive. Status =  %lx \n", KeyPath, Status));
            if( SavedStatus == STATUS_SUCCESS ) {
                SavedStatus = Status;
            }
            continue;
        }
        Status = SppCopyKeyRecursive( SrcKey,
                                      hDestSystemHive,
                                      NULL,
                                      FtDiskKeys[i],
                                      TRUE,
                                      FALSE
                                    );

        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to migrate %ls to SYSTEM\\%ls. Status = %lx\n", KeyPath, FtDiskKeys[i], Status));
            if( SavedStatus == STATUS_SUCCESS ) {
                SavedStatus = Status;
            }
        }
        ZwClose( SrcKey );
    }
    return( SavedStatus );

}


VOID
SpGetPartitionStartingOffsetAndLength(
    IN  DWORD          DiskIndex,
    IN  PDISK_REGION   Region,
    IN  BOOL           ExtendedPartition,
    OUT PLARGE_INTEGER Offset,
    OUT PLARGE_INTEGER Length
    )
{
    ULONGLONG   bytesPerSector;

    bytesPerSector = (ULONGLONG)PartitionedDisks[DiskIndex].HardDisk->Geometry.BytesPerSector;

    //
    // Calculate Offset and Legnth.
    //
    Offset -> QuadPart = Region->StartSector * bytesPerSector;

    Length -> QuadPart = Region->SectorCount * bytesPerSector;

}

BOOL
SpFillInDiskPartitionStructure (
    IN  DWORD           DiskIndex,
    IN  PDISK_REGION    Region,
    IN  USHORT          LogicalNumber,
    IN  BOOL            ExtendedPartition,
    OUT PDISK_PARTITION Partition
    )
{
    LARGE_INTEGER ftLength;

    ftLength.QuadPart = 0;

    RtlZeroMemory(Partition, sizeof(DISK_PARTITION));

    Partition -> FtType          = NotAnFtMember;

    //
    // Set the offset and length.
    //
    SpGetPartitionStartingOffsetAndLength(
        DiskIndex,
        Region,
        ExtendedPartition,
        &(Partition -> StartingOffset),
        &(Partition -> Length)
        );


    //
    // set the Drive Letter to an uninitialized drive letter (for now)
    // Note that this is *NOT* Unicode.
    //
    Partition -> DriveLetter            = ' ';


    Partition -> AssignDriveLetter      = TRUE;
    Partition -> Modified               = TRUE;
    Partition -> ReservedChars[0]       = 0;
    Partition -> ReservedChars[1]       = 0;
    Partition -> ReservedChars[2]       = 0;
    Partition -> ReservedTwoLongs[0]    = 0;
    Partition -> ReservedTwoLongs[1]    = 0;

    Partition -> LogicalNumber          = LogicalNumber;
    return TRUE;
}

//
// cut/copied and modified from SpMigrateFtKeys in spupgcfg.c
//
NTSTATUS
SpCopySetupDiskRegistryToTargetDiskRegistry(
    IN HANDLE hDestSystemHive
    )
{
    NTSTATUS Status;
    NTSTATUS SavedStatus;

    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;

    PWSTR   FtDiskKeys[] = {L"Disk"};
    WCHAR   KeyPath[MAX_PATH];
    HANDLE  SrcKey;
    ULONG   i;

    SavedStatus = STATUS_SUCCESS;
    for( i = 0; i < sizeof(FtDiskKeys)/sizeof(PWSTR); i++ ) {
        //
        //  Open the source key
        //
        swprintf( KeyPath, L"\\registry\\machine\\system\\%ls", FtDiskKeys[i] );
        INIT_OBJA(&Obja,&UnicodeString,KeyPath);
        Obja.RootDirectory = NULL;

        Status = ZwOpenKey(&SrcKey,KEY_ALL_ACCESS,&Obja);
        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ls on the setup hive. Status =  %lx \n", KeyPath, Status));
            if( SavedStatus == STATUS_SUCCESS ) {
                SavedStatus = Status;
            }
            continue;
        }
        Status = SppCopyKeyRecursive( SrcKey,
                                      hDestSystemHive,
                                      NULL,
                                      FtDiskKeys[i],
                                      TRUE,
                                      FALSE
                                    );

        if( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to migrate %ls to SYSTEM\\%ls. Status = %lx\n", KeyPath, FtDiskKeys[i], Status));
            if( SavedStatus == STATUS_SUCCESS ) {
                SavedStatus = Status;
            }
        }
        ZwClose( SrcKey );
    }
    return( SavedStatus );

}

DWORD
SpDetermineNecessarySizeForDiskRegistry(
    VOID
    )
{

    DWORD        rSize;
    PDISK_REGION region;
    DWORD        index;
    DWORD        partitionCount;

    //
    // Need one overall DISK_REGISTRY.
    //
    rSize = sizeof(DISK_REGISTRY);

    //
    // Need HardDiskCount DISK_DESCRIPTIONS.
    //
    rSize += sizeof(DISK_DESCRIPTION) * HardDiskCount;

    //
    // Need One DISK_PARTITION per partition for every disk.
    //
    for (index = 0, partitionCount = 0;index < HardDiskCount; index++) {

        region = SpFirstPartitionedRegion(PartitionedDisks[index].PrimaryDiskRegions, TRUE);
        
        while(region) {
            partitionCount++;
            region = SpNextPartitionedRegion(region, TRUE);
        }
        
        region = SpFirstPartitionedRegion(PartitionedDisks[index].PrimaryDiskRegions, FALSE);
        
        while(region) {
            partitionCount++;
            region = SpNextPartitionedRegion(region, FALSE);
        }

    }
    
    rSize += sizeof(DISK_PARTITION) * partitionCount;

    return rSize;
}

NTSTATUS
SpDiskRegistrySet(
    IN PDISK_REGISTRY Registry
    )

{
    typedef struct _MEMCHAIN {
        PDISK_DESCRIPTION Disk;
        PDISK_PARTITION   Partition;
        ULONG             MemberNumber;
        PVOID             NextMember;
    } MEMCHAIN, *PMEMCHAIN;

    typedef struct _COMPONENT {
        PVOID     NextComponent;
        PMEMCHAIN MemberChain;
        FT_TYPE   Type;
        ULONG     Group;
    } COMPONENT, *PCOMPONENT;

    NTSTATUS            status;
    HANDLE              handle;
    DISK_CONFIG_HEADER  regHeader;
    PDISK_DESCRIPTION   disk;
    PDISK_PARTITION     partition;
    ULONG               outer; // outer loop index
    ULONG               i;     // inner loop index
    PCOMPONENT          ftBase = NULL;
    PCOMPONENT          ftComponent = NULL;
    PCOMPONENT          ftLastComponent = NULL;
    PMEMCHAIN           ftMemChain;
    PVOID               outBuffer = NULL;
    ULONG               countFtComponents = 0;
    ULONG               ftMemberCount = 0;
    ULONG               ftComponentCount = 0;
    PFT_REGISTRY        ftRegistry = NULL;
    PFT_DESCRIPTION     ftComponentDescription = NULL;
    PFT_MEMBER_DESCRIPTION ftMember = NULL;

    status = FtOpenKey(&handle,
                       DiskRegistryKey,
                       DiskRegistryClass);

    if (NT_SUCCESS(status)) {

        //
        // Initialize the registry header.
        //

        regHeader.Version = DISK_INFORMATION_VERSION;
        regHeader.CheckSum = 0;


        regHeader.Reserved[0] = 0;
        regHeader.Reserved[1] = 0;
        regHeader.Reserved[2] = 0;
        regHeader.NameOffset = 0;
        regHeader.NameSize = 0;
        regHeader.FtInformationOffset = 0;
        regHeader.FtInformationSize = 0;
        regHeader.DiskInformationOffset = sizeof(DISK_CONFIG_HEADER);

        //
        // Walk through the disk information provided and count FT items.
        //

        disk = &Registry->Disks[0];

        for (outer = 0; outer < Registry->NumberOfDisks; outer++) {


            //
            // Walk through the partition information.
            //

            for (i = 0; i < disk->NumberOfPartitions; i++) {

                partition = &disk->Partitions[i];
                if (partition->FtType != NotAnFtMember) {

                    //
                    // Have a member of an FT item.
                    //

                    if (ftBase == NULL) {

                        ftBase = (PCOMPONENT) SpMemAlloc(sizeof(COMPONENT));

                        if (ftBase == NULL) {
                            return STATUS_NO_MEMORY;
                        }

                        ftBase->Type = partition->FtType;
                        ftBase->Group = partition->FtGroup;
                        ftBase->NextComponent = NULL;

                        ftMemChain = (PMEMCHAIN) SpMemAlloc(sizeof(MEMCHAIN));
                        if (ftMemChain == NULL) {
                            return STATUS_NO_MEMORY;
                        }

                        ftBase->MemberChain = ftMemChain;
                        ftMemChain->Disk = disk;
                        ftMemChain->Partition = partition;
                        ftMemChain->MemberNumber = partition->FtMember;
                        ftMemChain->NextMember = NULL;

                        ftComponentCount++;
                        ftMemberCount++;
                    } else {

                        //
                        // Search the existing chain to see if this is
                        // a member of a previously encountered FT component.
                        //

                        ftComponent = ftBase;
                        while (ftComponent) {

                            if ((ftComponent->Type == partition->FtType) &&
                                (ftComponent->Group == partition->FtGroup)){

                                //
                                // Member of same group.
                                //

                                ftMemChain = ftComponent->MemberChain;

                                //
                                // Go to end of chain.
                                //

                                while (ftMemChain->NextMember != NULL) {
                                    ftMemChain = ftMemChain->NextMember;
                                }

                                //
                                // Add new member at end.
                                //

                                ftMemChain->NextMember = (PMEMCHAIN) SpMemAlloc(sizeof(MEMCHAIN));
                                if (ftMemChain->NextMember == NULL) {
                                    return STATUS_NO_MEMORY;
                                }


                                ftMemChain = ftMemChain->NextMember;
                                ftMemChain->NextMember = NULL;
                                ftMemChain->Disk = disk;
                                ftMemChain->Partition = partition;
                                ftMemChain->MemberNumber = partition->FtMember;
                                ftMemberCount++;
                                break;
                            }

                            ftLastComponent = ftComponent;
                            ftComponent = ftComponent->NextComponent;
                        }

                        if (ftComponent == NULL) {

                            //
                            // New FT component volume.
                            //

                            ftComponent = (PCOMPONENT)SpMemAlloc(sizeof(COMPONENT));

                            if (ftComponent == NULL) {
                                return STATUS_NO_MEMORY;
                            }

                            if (ftLastComponent != NULL) {
                                ftLastComponent->NextComponent = ftComponent;
                            }
                            ftComponent->Type = partition->FtType;
                            ftComponent->Group = partition->FtGroup;
                            ftComponent->NextComponent = NULL;
                            ftMemChain = (PMEMCHAIN) SpMemAlloc(sizeof(MEMCHAIN));
                            if (ftMemChain == NULL) {
                                return STATUS_NO_MEMORY;
                            }

                            ftComponent->MemberChain = ftMemChain;
                            ftMemChain->Disk = disk;
                            ftMemChain->Partition = partition;
                            ftMemChain->MemberNumber = partition->FtMember;
                            ftMemChain->NextMember = NULL;

                            ftComponentCount++;
                            ftMemberCount++;
                        }
                    }
                }
            }

            //
            // The next disk description occurs immediately after the
            // last partition infomation.
            //

            disk =(PDISK_DESCRIPTION)&disk->Partitions[i];
        }

        //
        // Update the registry header with the length of the disk information.
        //

        regHeader.DiskInformationSize = ((PUCHAR)disk - (PUCHAR)Registry);
        regHeader.FtInformationOffset = sizeof(DISK_CONFIG_HEADER) +
                                        regHeader.DiskInformationSize;

        //
        // Now walk the ftBase chain constructed above and build
        // the FT component of the registry.
        //

        if (ftBase != NULL) {

            //
            // Calculate size needed for the FT portion of the
            // registry information.
            //

            i = (ftMemberCount * sizeof(FT_MEMBER_DESCRIPTION)) +
                (ftComponentCount * sizeof(FT_DESCRIPTION)) +
                sizeof(FT_REGISTRY);

            ftRegistry = (PFT_REGISTRY) SpMemAlloc(i);

            if (ftRegistry == NULL) {
                return STATUS_NO_MEMORY;
            }

            ftRegistry->NumberOfComponents = 0;
            regHeader.FtInformationSize = i;

            //
            // Construct FT entries.
            //

            ftComponentDescription = &ftRegistry->FtDescription[0];

            ftComponent = ftBase;
            while (ftComponent != NULL) {


                ftRegistry->NumberOfComponents++;
                ftComponentDescription->FtVolumeState = FtStateOk;
                ftComponentDescription->Type = ftComponent->Type;
                ftComponentDescription->Reserved = 0;

                //
                // Sort the member list into the ft registry section.
                //

                i = 0;
                while (1) {
                    ftMemChain = ftComponent->MemberChain;
                    while (ftMemChain->MemberNumber != i) {
                        ftMemChain = ftMemChain->NextMember;
                        if (ftMemChain == NULL) {
                            break;
                        }
                    }

                    if (ftMemChain == NULL) {
                        break;
                    }

                    ftMember = &ftComponentDescription->FtMemberDescription[i];

                    ftMember->State = 0;
                    ftMember->ReservedShort = 0;
                    ftMember->Signature = ftMemChain->Disk->Signature;
                    ftMember->OffsetToPartitionInfo = (ULONG)
                                               ((PUCHAR) ftMemChain->Partition -
                                                (PUCHAR) Registry) +
                                                sizeof(DISK_CONFIG_HEADER);
                    ftMember->LogicalNumber =
                                           ftMemChain->Partition->LogicalNumber;
                    i++;
                }

                ftComponentDescription->NumberOfMembers = (USHORT)i;

                //
                // Set up base for next registry component.
                //

                ftComponentDescription = (PFT_DESCRIPTION)
                    &ftComponentDescription->FtMemberDescription[i];

                //
                // Move forward on the chain.
                //

                ftLastComponent = ftComponent;
                ftComponent = ftComponent->NextComponent;

                //
                // Free the member chain and component.
                //


                ftMemChain = ftLastComponent->MemberChain;
                while (ftMemChain != NULL) {
                    PMEMCHAIN nextChain;

                    nextChain = ftMemChain->NextMember;
                    TESTANDFREE(ftMemChain);
                    ftMemChain = nextChain;
                }

                TESTANDFREE(ftLastComponent);
            }
        }


        i = regHeader.FtInformationSize +
            regHeader.DiskInformationSize +
            sizeof(DISK_CONFIG_HEADER);

        outBuffer = SpMemAlloc(i);

        if (outBuffer == NULL) {
            TESTANDFREE(ftRegistry);
            return STATUS_NO_MEMORY;
        }

        //
        // Move all of the pieces together.
        //

        RtlMoveMemory(outBuffer,
                      &regHeader,
                      sizeof(DISK_CONFIG_HEADER));
        RtlMoveMemory((PUCHAR)outBuffer + sizeof(DISK_CONFIG_HEADER),
                      Registry,
                      regHeader.DiskInformationSize);
        RtlMoveMemory((PUCHAR)outBuffer + regHeader.FtInformationOffset,
                      ftRegistry,
                      regHeader.FtInformationSize);
        TESTANDFREE(ftRegistry);


        //
        // Backup the previous value.
        //

        FtBackup(handle);

        //
        // Set the new value.
        //

        status = FtSetValue(handle,
                            DiskRegistryValue,
                            outBuffer,
                            sizeof(DISK_CONFIG_HEADER) +
                                regHeader.DiskInformationSize +
                                regHeader.FtInformationSize,
                            REG_BINARY);
        TESTANDFREE(outBuffer);
        ZwFlushKey(handle);
        ZwClose(handle);
    }

    return status;
}



BOOL
SpBuildDiskRegistry(
    VOID
    )
{

    PDISK_DESCRIPTION      curDisk;
    DWORD                  diskRegistrySize;
    PBYTE                  curOffset;
    PDISK_REGISTRY         diskRegistry;
    PDISK_REGION           region;
    DWORD                  diskIndex;
    USHORT                 logicalNumber;
    NTSTATUS               ntStatus;

    //
    // First, allocate enough space for the DiskRegistry structure.
    //
    diskRegistrySize = SpDetermineNecessarySizeForDiskRegistry();
    diskRegistry = SpMemAlloc(diskRegistrySize);

    if (!diskRegistry) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not allocate enough space to create a disk registry.\n"));
        return FALSE;
    }

    //
    // Set the number of disks in the system into the header.
    //
    diskRegistry -> NumberOfDisks = (USHORT) HardDiskCount;


    diskRegistry -> ReservedShort = 0;

    //
    // Initialize curOffset to the Disks element of diskRegistry.
    //
    curOffset = (PBYTE) diskRegistry -> Disks;

    //
    // Now, enumerate all of these hard disks filling in the information for each of them.
    //
    for (diskIndex = 0;diskIndex < diskRegistry -> NumberOfDisks; diskIndex++) {

        //
        // Claim PDISK_DESCRIPTION worth of data.
        //
        curDisk = (PDISK_DESCRIPTION) curOffset;

        //
        // Set the disk signature and clear the reserved data.
        //
        curDisk -> Signature = PartitionedDisks[diskIndex].HardDisk -> Signature;
        curDisk -> ReservedShort = 0;

        //
        // Initialize the NumberOfPartitions member to 0. This will be bumped for
        // each partition found.
        //
        curDisk -> NumberOfPartitions = 0;


        //
        // Initialize curOffset to the Partitions element of the current disk description.
        //
        curOffset = (PBYTE) curDisk -> Partitions;
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "Creating Disk Description structure in registry.\n"));

        //
        // Initialize the logical number var for this disk.
        //
        logicalNumber = 1;

        //
        // Enumerate the Primary regions, creating a DISK_PARTITION structure for
        // each partition.
        //
        region = SpFirstPartitionedRegion(PartitionedDisks[diskIndex].PrimaryDiskRegions, TRUE);
        
        while(region) {

            SpFillInDiskPartitionStructure(
                diskIndex,
                region,
                logicalNumber,
                FALSE,
                (PDISK_PARTITION) curOffset
                );

            //
            // Increment the partition count and set the curOffset to the next
            // free spot.
            //
            curDisk -> NumberOfPartitions++;
            curOffset += sizeof(DISK_PARTITION);

            region = SpNextPartitionedRegion(region, TRUE);
            logicalNumber++;
        }

        //
        // Enumerate the Extended regions, creating a DISK_PARTITION structure for
        // each partition.
        //
        region = SpFirstPartitionedRegion(PartitionedDisks[diskIndex].PrimaryDiskRegions, FALSE);
        
        while(region) {

            SpFillInDiskPartitionStructure(
                diskIndex,
                region,
                logicalNumber,
                TRUE,
                (PDISK_PARTITION) curOffset
                );

            //
            // Increment the partition count and set the curOffset to the next
            // free spot.
            //
            curDisk -> NumberOfPartitions++;
            curOffset += sizeof(DISK_PARTITION);
            region = SpNextPartitionedRegion(region, FALSE);
            logicalNumber++;
        }

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "Disk contained %u partitions.\n",curDisk -> NumberOfPartitions));

    }

    //
    // Now that the structure has been built, create its registry key and
    // save it. Then free the associated memory.
    //
    ntStatus = SpDiskRegistrySet(diskRegistry);

    if (!NT_SUCCESS(ntStatus)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "Could not set the Disk Registry information. %u (%x)\n",ntStatus,ntStatus));
    }

    return NT_SUCCESS(ntStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\i386\spi386.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spi386.h

Abstract:

    x86-specific header file for text setup.

Author:

    Ted Miller (tedm) 29-October-1993

Revision History:

    03-Oct-1996  jimschm  Split Win95 and Win3.1 stuff
    28-Feb-1997  marcw    SpCopyWin9xFiles and SpDeleteWin9xFiles now declared in
                          this header (was spcopy.h).
                          Also, added SpAssignDriveLettersToMatchWin9x.
    10-Aug-1999  marcw    Added SpWin9xOverrideGuiModeCodePage

--*/

#pragma once

#include "fci.h"

#ifndef _SPi386_DEFN_
#define _SPi386_DEFN_


ENUMNONNTUPRADETYPE
SpLocateWin95(
    OUT PDISK_REGION *InstallRegion,
    OUT PWSTR        *InstallPath,
    OUT PDISK_REGION *SystemPartitionRegion
    );

BOOLEAN
SpLocateWin31(
    IN  PVOID         SifHandle,
    OUT PDISK_REGION *InstallRegion,
    OUT PWSTR        *InstallPath,
    OUT PDISK_REGION *SystemPartitionRegion
    );

BOOLEAN
SpConfirmRemoveWin31(
    VOID
    );

VOID
SpRemoveWin31(
    IN PDISK_REGION NtPartitionRegion,
    IN LPCWSTR      Sysroot
    );

BOOLEAN
SpIsWin31Dir(
    IN PDISK_REGION Region,
    IN PWSTR        PathComponent,
    IN ULONG        MinKB
    );

BOOLEAN
SpIsWin4Dir(
    IN PDISK_REGION Region,
    IN PWSTR        PathComponent
    );

BOOLEAN
SpBackUpWin9xFiles (
    IN PVOID SifHandle,
    IN TCOMP CompressionType
    );

VOID
SpRemoveExtraBootIniEntry (
    VOID
    );

BOOLEAN
SpAddRollbackBootOption (
    BOOLEAN DefaultBootOption
    );

VOID
SpMoveWin9xFiles (
    IN PVOID SifHandle
    );

VOID
SpDeleteWin9xFiles (
    IN PVOID SifHandle
    );

BOOLEAN
SpExecuteWin9xRollback (
    IN PVOID SifHandle,
    IN PWSTR BootDeviceNtPath
    );

VOID
SpMashemSmashem(
    IN HANDLE FileHandle, OPTIONAL
    IN PWSTR  Name1,      OPTIONAL
    IN PWSTR  Name2,      OPTIONAL
    IN PWSTR  Name3       OPTIONAL
    );

NTSTATUS
SpDiskRegistryAssignCdRomLetter(
    IN PWSTR CdromName,
    IN WCHAR DriveLetter
    );

BOOLEAN
SpDiskRegistryAssignDriveLetter(
    ULONG         Signature,
    LARGE_INTEGER StartingOffset,
    LARGE_INTEGER Length,
    UCHAR         DriveLetter
    );

NTSTATUS
SpMigrateDiskRegistry(
    IN HANDLE hDestSystemHive
    );




NTSTATUS
SpMigrateDiskRegistry (
    );



VOID
SpWin9xOverrideGuiModeCodePage (
    HKEY NlsRegKey
    );


BOOLEAN
SpIsWindowsUpgrade(
    IN PVOID    SifFileHandle
    );

#endif // ndef _SPi386_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\spddlang\fe\bootfont.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    bootfint.h

Abstract:

    Header file describing the bootfont.bin file used to provide
    dbcs support during system or setup bootstrap.

Author:

    tedm 11-July-1995

Revision History:

--*/

#pragma pack(1)

//
// Define maximum number of dbcs lead byte ranges we support.
//
#define MAX_DBCS_RANGE  5

//
// Define signature value.
//
#define BOOTFONTBIN_SIGNATURE 0x5465644d

//
// Define structure used as a header for the bootfont.bin file.
//
typedef struct _BOOTFONTBIN_HEADER {

    //
    // Signature. Must be BOOTFONTBIN_SIGNATURE.
    //
    ULONG Signature;

    //
    // Language id of the language supported by this font.
    // This should match the language id of resources in msgs.xxx.
    //
    ULONG LanguageId;

    //
    // Number of sbcs characters and dbcs characters contained in the file.
    //
    unsigned NumSbcsChars;
    unsigned NumDbcsChars;

    //
    // Offsets within the file to the images.
    //
    unsigned SbcsOffset;
    unsigned DbcsOffset;

    //
    // Total sizes of the images.
    //
    unsigned SbcsEntriesTotalSize;
    unsigned DbcsEntriesTotalSize;

    //
    // Dbcs lead byte table. Must contain a pair of 0's to indicate the end.
    //
    UCHAR DbcsLeadTable[(MAX_DBCS_RANGE+1)*2];

    //
    // Height values for the font.
    // CharacterImageHeight is the height in scan lines/pixels of the
    // font image. Each character is drawn with additional 'padding'
    // lines on the top and bottom, whose sizes are also contained here.
    //
    UCHAR CharacterImageHeight;
    UCHAR CharacterTopPad;
    UCHAR CharacterBottomPad;

    //
    // Width values for the font. These values contain the width in pixels
    // of a single byte character and double byte character.
    //
    // NOTE: CURRENTLY THE SINGLE BYTE WIDTH *MUST* BE 8 AND THE DOUBLE BYTE
    // WIDTH *MUST* BE 16!!!
    //
    UCHAR CharacterImageSbcsWidth;
    UCHAR CharacterImageDbcsWidth;

} BOOTFONTBIN_HEADER, *PBOOTFONTBIN_HEADER;

#pragma pack()

//
// Images themselves follow.
//
// First there are SbcsCharacters entries for single-byte chars.
// The first byte in each entry is the ascii char code. The next n bytes are
// the image. n is dependent on the width and height of an sbcs char.
//
// Following these are the dbcs images. The first 2 bytes are the dbcs
// character code (highbyte lowbyte) and the next n bytes are the image.
// n is dependent on the width and height of a dbcs char.
//
// Important note: the characters must be sorted in ascending order!
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\i386\win9xupg.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    win9xupg.c

Abstract:

    Code for detecting a Win9x installation, and code to blow away any
    existing Win9x files.

Author:

    Jim Schmidt (jimschm) 24-Feb-1997

Revision History:

    Marc R. Whitten (marcw) 28-Feb-1997
        Moved Win9x copy and delete functions from spcopy.c to this module
        Added drive letter mapping code.

    Jim Schmidt (JimSchm) November, December 2000
        Win9x uninstall work

    Jay Krell (a-JayK) December 2000
        Win9x uninstall work (cab)
--*/

#include "spprecmp.h"
#pragma hdrstop
#include "ntddscsi.h"
#include "spwin9xuninstall.h"
#include "spcab.h"
#include "spmemory.h"
#include "spprintf.h"
#include "spcabp.h"
#include "bootvar.h"
#include "spwin.h"

extern BOOLEAN DriveAssignFromA; //NEC98

#define STRING_VALUE(s) REG_SZ,(s),(wcslen((s))+1)*sizeof(WCHAR)
#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))


typedef enum {
    BACKUP_DOESNT_EXIST,
    BACKUP_IN_PROGRESS,
    BACKUP_SKIPPED_BY_USER,
    BACKUP_COMPLETE
} JOURNALSTATUS;


// in spdskreg.c
BOOL
SpBuildDiskRegistry(
    VOID
    );

VOID
SpGetPartitionStartingOffsetAndLength(
    IN  DWORD          DiskIndex,
    IN  PDISK_REGION   Region,
    IN  BOOL           ExtendedPartition,
    OUT PLARGE_INTEGER Offset,
    OUT PLARGE_INTEGER Length
    );

VOID
SpDumpDiskRegistry(
    VOID
    );

// in spsetup.c
VOID
SpCompleteBootListConfig(
    WCHAR   DriveLetter
    );

// in win31upg.c
WCHAR
SpExtractDriveLetter(
    IN PWSTR PathComponent
    );

BOOLEAN
SpIsWin9xMsdosSys(
    IN PDISK_REGION Region,
    OUT PSTR*       Win9xPath
    );


VOID
SpAssignDriveLettersToMatchWin9x (
    IN PVOID        WinntSif
    );

VOID
SppMoveWin9xFilesWorker (
    IN PVOID WinntSif,
    IN PCWSTR MoveSection,
    IN BOOLEAN Rollback
    );

VOID
SppDeleteWin9xFilesWorker (
    IN PVOID WinntSif,
    IN PCWSTR FileSection,      OPTIONAL
    IN PCWSTR DirSection,       OPTIONAL
    IN BOOLEAN Rollback
    );

PDISK_REGION
SppRegionFromFullNtName (
    IN      PWSTR NtName,
    IN      PartitionOrdinalType OrdinalType,
    OUT     PWSTR *Path                             OPTIONAL
    );

BOOLEAN
SppCreateTextModeBootEntry (
    IN      PWSTR LoadIdentifierString,
    IN      PWSTR OsLoadOptions,        OPTIONAL
    IN      BOOLEAN Deafult
    );

BOOLEAN
SppDelEmptyDir (
    IN      PCWSTR NtPath
    );

ENUMNONNTUPRADETYPE
SpLocateWin95(
    OUT PDISK_REGION *InstallRegion,
    OUT PWSTR        *InstallPath,
    OUT PDISK_REGION *SystemPartitionRegion
    )

/*++

Routine Description:

    Determine whether we are to continue a Win95 upgrade.
    This is based solely on values found in the parameters file.

Arguments:

    InstallRegion - Returns a pointer to the region to install to.

    InstallPath - Returns a pointer to a buffer containing the path
        on the partition to install to.  The caller must free this
        buffer with SpMemFree().

    SystemPartitionRegion - Returns a pointer to the region for the
        system partition (ie, C:).

Return Value:

    UpgradeWin95 if we are supposed to upgrade win95
    NoWinUpgrade if not.

--*/

{
    PWSTR Win95Drive;
    PWSTR p;
    PWSTR Sysroot;
    PDISK_REGION CColonRegion;
    ENUMNONNTUPRADETYPE UpgradeType = UpgradeWin95;


    //
    // Changed sequence the test migration flag and migrate drive letters,
    // to not migrate drive letters when fresh from Win9x on NEC98.
    //

    //
    // Test the migration flag.
    //
    p = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,WINNT_D_WIN95UPGRADE_W,0);
    Win95Drive = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,WINNT_D_WIN32_DRIVE_W,0);
    Sysroot = SpGetSectionKeyIndex(WinntSifHandle,SIF_DATA,WINNT_D_WIN32_PATH_W,0);

    if (!IsNEC_98) {
        CColonRegion = SpPtValidSystemPartition();
    }

    if(!p || _wcsicmp(p,WINNT_A_YES_W) || !Win95Drive || (!IsNEC_98 && !CColonRegion) || !Sysroot) {
        UpgradeType = NoWinUpgrade;
    }

    //
    // NEC98 must not migrate drive letters, when fresh setup.
    // The drive letter is started from A: on Win9x, but should be started from C:
    // on Win2000 fresh setup.
    //
    // NOTE : Also don't migrate the drive letters for clean installs
    // from winnt32.exe on Win9x machines, since the drive letter migration
    // is a bogus migration. We don't tell the mountmgr to reserve the drive letter
    // and when user creates and deletes a partition then we might end up assigning
    // the existing drive letter to new partition, which is really bad.
    //
    if(UpgradeType == NoWinUpgrade) {
        return  UpgradeType;
    }

    //
    // First, make sure drive letters are correct.
    //
    SpAssignDriveLettersToMatchWin9x(WinntSifHandle);

    if(!IsNEC_98 && (UpgradeType == NoWinUpgrade)) {
        return(UpgradeType);
    }


    //
    // Migration enabled and everything looks OK.
    //


    *InstallRegion = SpRegionFromDosName(Win95Drive);
    *InstallPath = Sysroot;
    //
    // On NEC98, SystemPartitionRegion must be same as InstallRegion.
    //
    *SystemPartitionRegion = (!IsNEC_98) ? CColonRegion : *InstallRegion;


    return(UpgradeType);
}


#if 0
BOOLEAN
SpLocateWin95(
    IN PVOID WinntSif
    )

/*++

Routine Description:

    SpLocateWin95 looks for any installation of Windows 95 on any
    hard disk drive, and returns TRUE if one is found.  When the user
    initiates setup from boot floppies, we alert them that they have
    an option to migrate.

Arguments:

    none

Return Value:

    TRUE if we are migrating Win95.
    FALSE otherwise.

--*/

{
    PDISK_REGION CColonRegion;
    PDISK_REGION Region;
    PUCHAR Win9xPath;

    //
    // If setup was initiated from WINNT95, don't bother telling user
    // about the migrate option--they obviously know.
    //
    if (Winnt95Setup)
        return TRUE;

    //
    // Look at boot sector for Win95 stuff
    //

    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_LOOKING_FOR_WIN95,DEFAULT_STATUS_ATTRIBUTE);

    //
    // See if there is a valid C: already.  If not, then we can't have Win95.
    //
    CColonRegion = SpPtValidSystemPartition();
    if(!CColonRegion) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: no C:, no Win95!\n"));
        return(FALSE);
    }

    //
    // Check the filesystem.  If not FAT, then we don't have Win95.
    //
    if(CColonRegion->Filesystem != FilesystemFat) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: C: is not FAT, no Win95!\n"));
        return(FALSE);
    }

    //
    // Check to see if there is enough free space, etc on C:.
    // If not, don't call attention to the migrate option, because
    // it won't work.
    //
    if(!SpPtValidateCColonFormat(WinntSif,NULL,CColonRegion,TRUE,NULL,NULL)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: C: not acceptable, no Win95!\n"));
        return(FALSE);
    }

    //
    // If msdos.sys is not the Win95 flavor, we do not have Win95
    // on drive C.
    //

    if(!SpIsWin9xMsdosSys(CColonRegion, &Win9xPath) )
        return FALSE;
    SpMemFree(Win9xPath);

    //
    // By this time, we've found a FAT C drive, it has the Win95
    // version of msdos.sys, and it has a valid config.sys.  We
    // now conclude that this drive has Win95 on it!
    //
    // If we were initiated from WINNT32, don't tell the user
    // about this option.
    //

    //
    // We don't tell the user even if they ran 16-bit
    // WINNT.  The only time this will run is if the user throws
    // in a boot floppy.
    //

    if (!WinntSetup)
        SpTellUserAboutMigrationOption();       // may not return!

    return TRUE;
}


VOID
SpTellUserAboutMigrationOption ()
{
    ULONG ValidKeys[3] = { KEY_F3,ASCI_CR,0 };
    ULONG Mnemonics[2] = { MnemonicContinueSetup,0 };

    while(1) {

        SpDisplayScreen(SP_SCRN_WIN95_MIGRATION,
            3,
            HEADER_HEIGHT+1,
            );

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            SP_STAT_F3_EQUALS_EXIT,
            0
            );

        switch(SpWaitValidKey(ValidKeys,NULL,Mnemonics)) {
        case KEY_F3:
            SpConfirmExit();
            break;
        default:
            //
            // must be Enter=continue
            //
            return;
        }
    }

    return;
}


#endif


BOOLEAN
SpIsWin4Dir(
    IN PDISK_REGION Region,
    IN PWSTR        PathComponent
        )
    /*++

Routine Description:

    To find out if the directory indicated on the region contains a
    Microsoft Windows 95 (or later) installation. We do this by looking
    for a set of files in the SYSTEM subdirectory that don't exist under
    Win3.x, and under NT are located in the SYSTEM32 subdirectory.

Arguments:

    Region - supplies pointer to disk region descriptor for region
        containing the directory to be checked.

    PathComponent - supplies a component of the dos path to search
        on the region.  This is assumes to be in the form x:\dir.
        If it is not in this form, this routine will fail.

Return Value:

    TRUE if this path contains a Microsoft Windows 4.x installation.

    FALSE otherwise.

--*/
{
    PWSTR files[] = { L"SHELL32.DLL", L"USER32.DLL", L"KERNEL32.DLL", L"GDI32.DLL" };
    PWCHAR OpenPath;
    BOOLEAN rc;

    //
    // Assume failure.
    //
    rc = FALSE;

    //
    // If the partition is not FAT, then ignore it.
    //
    if(Region->PartitionedSpace &&
       ((Region->Filesystem == FilesystemFat) || (Region->Filesystem == FilesystemFat32))) {

        OpenPath = SpMemAlloc(512*sizeof(WCHAR));

        //
        // Form the name of the partition.
        //
        SpNtNameFromRegion(Region,OpenPath,512*sizeof(WCHAR),PartitionOrdinalCurrent);

        //
        // Slap on the directory part of the path component.
        //
        SpConcatenatePaths(
            OpenPath,
            PathComponent + (SpExtractDriveLetter(PathComponent) ? 2 : 0)
            );

        //
        // Append the SYSTEM subdirectory to the path.
        //
        SpConcatenatePaths(OpenPath, L"SYSTEM");

        //
        // Determine whether all the required files are present.
        //
        rc = SpNFilesExist(OpenPath,files,ELEMENT_COUNT(files),FALSE);

        SpMemFree(OpenPath);
    }

    return(rc);
}


// needed for Win3.1 detection
BOOLEAN
SpIsWin9xMsdosSys(
    IN PDISK_REGION Region,
    OUT PSTR*       Win9xPath
    )
{
    WCHAR OpenPath[512];
    HANDLE FileHandle,SectionHandle;
    ULONG FileSize;
    PVOID ViewBase;
    PUCHAR pFile,pFileEnd,pLineEnd;
    ULONG i;
    NTSTATUS Status;
    ULONG LineLen,KeyLen;
    PCHAR Keyword = "[Paths]";
    PSTR    p;
    ULONG   cbText;


    //
    // Form name of config.sys.
    //
    SpNtNameFromRegion(Region,OpenPath,sizeof(OpenPath),PartitionOrdinalCurrent);
    SpConcatenatePaths(OpenPath,L"msdos.sys");

    //
    // Open and map the file.
    //
    FileHandle = 0;
    Status = SpOpenAndMapFile(
                OpenPath,
                &FileHandle,
                &SectionHandle,
                &ViewBase,
                &FileSize,
                FALSE
                );

    if(!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    pFile = ViewBase;
    pFileEnd = pFile + FileSize;

    //
    // This code must guard access to the msdos.sys buffer because the
    // buffer is memory mapped (an i/o error would raise an exception).
    // This code could be structured better, as it now works by returning
    // from the try body -- but performance isn't an issue so this is acceptable
    // because it is so darned convenient.
    //
    try {
        KeyLen = strlen(Keyword);

        //
        // Search for the [Paths] section
        //
        while (pFile < pFileEnd) {
            if (!_strnicmp(pFile, Keyword, KeyLen)) {
                break;
            }

            pFile++;
        }

        //
        // did we find the section
        //
        if (pFile >= pFileEnd) {
            return  FALSE;
        }

        //
        // parse the [Paths] section
        //
        pFile += KeyLen;

        while(1) {
            //
            // Skip whitespace.  If at end of file, then this is not a Win9x msdos.sys.
            //
            while((pFile < pFileEnd) && strchr(" \r\n\t",*pFile)) {
                pFile++;
            }
            if(pFile == pFileEnd) {
                return(FALSE);
            }

            //
            // Find the end of the current line.
            //
            pLineEnd = pFile;
            while((pLineEnd < pFileEnd) && !strchr("\r\n",*pLineEnd)) {
                pLineEnd++;
            }

            LineLen = pLineEnd - pFile;

            Keyword = "WinDir";
            KeyLen = strlen( Keyword );
            if( _strnicmp(pFile,Keyword,KeyLen) ) {
                pFile = pLineEnd;
                continue;
            }

            pFile += KeyLen;
            while((pFile < pFileEnd) && strchr(" =\r\n\t",*pFile)) {
                pFile++;
            }
            if(pFile == pFileEnd) {
                return(FALSE);
            }
            KeyLen = (ULONG)(pLineEnd - pFile);
            p = SpMemAlloc( KeyLen + 1 );
            for( i = 0; i < KeyLen; i++ ) {
                *(p + i) = *(pFile + i );
            }
            *(p + i ) = '\0';
            *Win9xPath = p;
            return(TRUE);
        }
    } finally {

        SpUnmapFile(SectionHandle,ViewBase);
        ZwClose(FileHandle);
    }
}



/*++

Routine Description:

  SpOpenWin9xDat file is a wrapper routine for opening one of the unicode DAT
  files used for certain win9x file lists.

Arguments:

  DatFile   - The name of the Dat file to enum.
  WinntSif - A pointer to a valid SIF handle object. This is used to
              retrieve information on the location of the DAT file named
              above.

Return Value:

  A valid handle if the file was successfully opened, INVALID_HANDLE_VALUE
  otherwise.

--*/


HANDLE SpOpenWin9xDatFile (
    IN  PCWSTR DatFile,
    IN  PVOID WinntSif
    )
{

    HANDLE              rFile;
    NTSTATUS            status;
    UNICODE_STRING      datFileU;
    OBJECT_ATTRIBUTES   oa;
    IO_STATUS_BLOCK     ioStatusBlock;
    PDISK_REGION        win9xTempRegion;
    PWSTR               win9xTempDir;
    WCHAR               ntName[ACTUAL_MAX_PATH];


    if (DatFile[0] && DatFile[1] == L':') {
        //
        // Convert a DOS path into an NT path
        //

        if (!SpNtNameFromDosPath (
                DatFile,
                ntName,
                sizeof (ntName),
                PartitionOrdinalCurrent
                )) {
            KdPrintEx((
                DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "SETUP: Cannot convert path %ws to an NT path\n",
                DatFile
                ));
            return INVALID_HANDLE_VALUE;
        }

    } else {
        //
        // The location of the win9x.sif file is in the Win9xSif key of the [data] section.
        //

        win9xTempDir = SpGetSectionKeyIndex(WinntSif,SIF_DATA,WINNT_D_WIN9XTEMPDIR_W,0);
        if (!win9xTempDir) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not get Win9x temp dir..\n"));
            return INVALID_HANDLE_VALUE;
        }


        //
        // Get the region from the dos name..
        //
        win9xTempRegion = SpRegionFromDosName (win9xTempDir);
        if (!win9xTempRegion) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpRegionFromDosName failed for %ws\n", win9xTempDir));
            return INVALID_HANDLE_VALUE;
        }

        //
        // Get the NT name from the disk region..
        //
        SpNtNameFromRegion(
                        win9xTempRegion,
                        (PWSTR)TemporaryBuffer,
                        sizeof(TemporaryBuffer),
                        PartitionOrdinalCurrent
                        );


        //
        // build the complete NT path to the win9x sif file..
        //
        SpConcatenatePaths((PWSTR) TemporaryBuffer, &win9xTempDir[2]);
        SpConcatenatePaths((PWSTR) TemporaryBuffer, DatFile);
        wcsncpy (   ntName, 
                    TemporaryBuffer, 
                    MAX_COPY_SIZE(ntName));
        ntName[MAX_COPY_SIZE(ntName)] = L'\0';
    }

    //
    // Open the file.
    //
    RtlInitUnicodeString(&datFileU,ntName);
    InitializeObjectAttributes(&oa,&datFileU,OBJ_CASE_INSENSITIVE,NULL,NULL);
    status = ZwCreateFile(
                &rFile,
                FILE_GENERIC_READ,
                &oa,
                &ioStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ,
                FILE_OPEN,
                0,
                NULL,
                0
                );

    if(!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpOpenWin9xDatFile: unable to open file %ws (%lx)\n",DatFile,status));
        return INVALID_HANDLE_VALUE;
    }

    return rFile;

}

typedef struct {

    HANDLE      FileHandle;
    PWSTR       EndOfFile;
    HANDLE      FileSection;
    PWSTR       NextLine;
    PWSTR       UnMapAddress;
    WCHAR       CurLine[MAX_PATH];

} WIN9XDATFILEENUM, * PWIN9XDATFILEENUM;




/*++

Routine Description:

  SpAbortWin9xFileEnum aborts the current win9x DAT file enumeration.

Arguments:

  None.

Return Value:



--*/


VOID
SpAbortWin9xFileEnum (
    IN PWIN9XDATFILEENUM Enum
    )
{

    SpUnmapFile(Enum -> FileSection,Enum -> UnMapAddress);
    ZwClose(Enum -> FileHandle);
}


/*++

Routine Description:

  SpEnumNextWin9xFile is fills in the enumeration structure with the next
  available data from the DAT file being enumerated.

Arguments:

  Enum - A pointer to a valid enumeration structure for the file currently
         being enumerated.

Return Value:

  TRUE if there was more data to enumerate, FALSE otherwise.

--*/


BOOL
SpEnumNextWin9xFile (
    IN PWIN9XDATFILEENUM Enum
    )
{

    PWSTR endOfLine;
    BOOL result = FALSE;
    PWSTR src;
    PWSTR dest;

    for (;;) {
        //
        // Does another line exist?
        //

        endOfLine = Enum->NextLine;
        if (endOfLine >= Enum->EndOfFile) {
            // no more data in file
            break;
        }

        //
        // Parse the next line
        //

        src = endOfLine;
        while (endOfLine < Enum->EndOfFile &&
               *endOfLine != L'\r' &&
               *endOfLine != L'\n'
               ) {
            endOfLine++;
        }

        // next line starts after \r\n, \r or \n
        Enum->NextLine = endOfLine;
        if (Enum->NextLine < Enum->EndOfFile && *Enum->NextLine == L'\r') {
           Enum->NextLine++;
        }
        if (Enum->NextLine < Enum->EndOfFile && *Enum->NextLine == L'\n') {
           Enum->NextLine++;
        }

        if (endOfLine - src > (MAX_PATH - 1)) {
            WCHAR chEnd = *endOfLine;
            *endOfLine = '\0';

            KdPrintEx ((
                DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "SETUP: Ignoring a configuration file line that is too long - %ws\n", 
                src
                ));
            
            *endOfLine = chEnd;
            continue;
        }

        //
        // Copy the line into the enum struct buffer
        //

        if (src == endOfLine) {
            // ignore blank lines
            continue;
        }

        dest = Enum->CurLine;
        do {
            *dest++ = *src++;
        } while (src < endOfLine);

        *dest = 0;

        result = TRUE;
        break;
    }

    if (!result) {
        //
        // No more files to enum.
        //
        SpAbortWin9xFileEnum(Enum);
        return FALSE;
    }

    return result;

}

/*++

Routine Description:

  SpEnumFirstWin9xFile is responsible for initializing the enumeration of a
  win9x data file. The function then calls EnumNextWin9xFile to fill in the
  rest of the necessary fields of the enumeration structure.

Arguments:

  Enum      - A pointer to a WIN9XDATFILEENUM structure. It is initialized by
              this function.
  WinntSif  - A pointer to a valid Sif File. It is used to retrieve
              information about the location of the dat file to be enumerated.
  DatFile   - The name of the DAT file to be enumerated.

Return Value:

  TRUE if the enumeration was succesffuly initalized and there was something
  to enumerate, FALSE otherwise.

--*/


BOOL
SpEnumFirstWin9xFile (
    IN PWIN9XDATFILEENUM    Enum,
    IN PVOID                WinntSif,
    IN PCWSTR               DatFile
    )
{

    NTSTATUS status;
    UINT fileSize;

    //
    // Open the dat file..
    //
    Enum -> FileHandle = SpOpenWin9xDatFile (DatFile, WinntSif);

    if (Enum -> FileHandle == INVALID_HANDLE_VALUE) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Error opening %ws data file..\n",DatFile));
        return FALSE;
    }

    //
    // Get the file size.
    //
    status = SpGetFileSize (Enum->FileHandle, &fileSize);
    if(!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Error getting file size.\n"));
        ZwClose (Enum -> FileHandle);
        return FALSE;
    }

    //
    // Map the file.
    //
    status = SpMapEntireFile(
        Enum -> FileHandle,
        &(Enum -> FileSection),
        &(Enum -> NextLine),
        TRUE
        );

    if(!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Error attempting to map file.\n"));
        ZwClose (Enum -> FileHandle);
        return FALSE;
    }


    Enum->EndOfFile = (PWSTR) ((PBYTE) Enum->NextLine + fileSize);
    Enum->UnMapAddress = Enum->NextLine;


    //
    // Pass Unicode Signature..
    //
    Enum -> NextLine += 1;



    //
    // Call EnumNext.
    //
    return SpEnumNextWin9xFile (Enum);
}

BOOLEAN
SppWriteToFile (
    IN      HANDLE FileHandle,
    IN      PVOID Data,
    IN      UINT DataSize,
    IN OUT  PLARGE_INTEGER WritePos         OPTIONAL
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;

    if (!DataSize) {
        return TRUE;
    }

    status = ZwWriteFile (
                FileHandle,
                NULL,
                NULL,
                NULL,
                &ioStatusBlock,
                Data,
                DataSize,
                WritePos,
                NULL
                );

    if (!NT_SUCCESS (status)) {
        KdPrintEx ((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: SppWriteToFile failed with status %x\n",
            status
            ));
    } else if (WritePos) {
        ASSERT (ioStatusBlock.Information == DataSize);
        WritePos->QuadPart += (LONGLONG) DataSize;
    }

    return NT_SUCCESS (status);
}


BOOLEAN
SppReadFromFile (
    IN      HANDLE FileHandle,
    OUT     PVOID Data,
    IN      UINT DataBufferSize,
    OUT     PINT BytesRead,
    IN OUT  PLARGE_INTEGER ReadPos          OPTIONAL
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;

    ioStatusBlock.Information = 0;

    status = ZwReadFile (
                FileHandle,
                NULL,
                NULL,
                NULL,
                &ioStatusBlock,
                Data,
                DataBufferSize,
                ReadPos,
                NULL
                );

    if (status != STATUS_END_OF_FILE && !NT_SUCCESS (status)) {
        KdPrintEx ((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: SppReadFromFile failed with status %x\n",
            status
            ));

        return FALSE;
    }

    *BytesRead = ioStatusBlock.Information;
    if (ReadPos) {
        ReadPos->QuadPart += (LONGLONG) ioStatusBlock.Information;
    }

    return TRUE;
}


BOOLEAN
SppCloseBackupImage (
    IN      BACKUP_IMAGE_HANDLE BackupImageHandle,
    IN      PBACKUP_IMAGE_HEADER ImageHeader,       OPTIONAL
    IN      PWSTR JournalFile                       OPTIONAL
    )
{
    BOOLEAN result = FALSE;
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES obja = { 0 };
    UNICODE_STRING unicodeString = { 0 };
    HANDLE journalHandle = NULL;
    JOURNALSTATUS journalStatus;

    if (BackupImageHandle != INVALID_HANDLE_VALUE
        && BackupImageHandle  != NULL
        ) {
        PVOID CabHandle = BackupImageHandle->CabHandle;
        if (CabHandle != NULL && CabHandle != INVALID_HANDLE_VALUE
            ) {
            BackupImageHandle->CabHandle = NULL;
            ASSERT(BackupImageHandle->CloseCabinet != NULL);
            result = BackupImageHandle->CloseCabinet(CabHandle) ? TRUE : FALSE; // ?: to convert BOOL<->BOOLEAN
        }
    }

    if (result) {
        //
        // If JournalFile is specified, mark it as complete.
        //

        if (JournalFile) {
            SpDeleteFile (JournalFile, NULL, NULL);

            INIT_OBJA (&obja, &unicodeString, JournalFile);

            status = ZwCreateFile (
                        &journalHandle,
                        SYNCHRONIZE | FILE_GENERIC_WRITE,
                        &obja,
                        &ioStatusBlock,
                        NULL,
                        FILE_ATTRIBUTE_NORMAL,
                        0,
                        FILE_CREATE,
                        FILE_SYNCHRONOUS_IO_NONALERT|FILE_WRITE_THROUGH,
                        NULL,
                        0
                        );

            if (NT_SUCCESS(status)) {
                journalStatus = BACKUP_COMPLETE;
                SppWriteToFile (journalHandle, &journalStatus, sizeof (journalStatus), NULL);
                ZwClose (journalHandle);
            } else {
                KdPrintEx ((
                    DPFLTR_SETUP_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SETUP: Unable to create %ws\n",
                    JournalFile
                    ));
                return FALSE;
            }
        }
    }

    return result;
}

VOID
SpAppendToBaseName(
    PWSTR  String,
    PCWSTR StringToAppend
    )
/*++
String is assumed to have enough room already.
--*/
{
    const PWSTR Dot = wcsrchr(String, '.');
    if (Dot != NULL) {
        const SIZE_T StringToAppendLen = wcslen(StringToAppend);
        RtlMoveMemory(Dot + 1 + StringToAppendLen, Dot + 1, (wcslen(Dot + 1) + 1) * sizeof(WCHAR));
        RtlMoveMemory(Dot, StringToAppend, StringToAppendLen * sizeof(WCHAR));
        *(Dot + StringToAppendLen) = '.';
    } else {
        wcscat(String, StringToAppend);
    }
}

BACKUP_IMAGE_HANDLE
SppOpenBackupImage (
    IN      BOOLEAN Create,
    OUT     PBACKUP_IMAGE_HEADER Header,
    OUT     PLARGE_INTEGER ImagePos,        OPTIONAL
    OUT     PWSTR JournalFile,              OPTIONAL
    IN      TCOMP CompressionType,
    OUT     BOOLEAN *InvalidHandleMeansFail OPTIONAL
    )
{
    PVOID CabHandle;
    NTSTATUS status = STATUS_SUCCESS;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES obja = { 0 };
    UNICODE_STRING unicodeString = { 0 };
    HANDLE journalHandle = NULL;
    JOURNALSTATUS journalStatus;
    PWSTR p = NULL;
    BOOL success = FALSE;
    BACKUP_IMAGE_HANDLE imageHandle = INVALID_HANDLE_VALUE;
    BOOL Success = FALSE;
    PWSTR subDir = NULL;
    PDISK_REGION region = NULL;
    PWSTR backupDir = NULL;
    PWSTR ntRoot = NULL;
    PWSTR backupFileOb = NULL;
    PWSTR backupJournalOb = NULL;
    UINT dontCare;
    PWSTR backupLeafFile = NULL;
    BOOL  backupDirIsRoot = FALSE;
    PWSTR backupImage = NULL;
    WCHAR CompressionTypeString[sizeof(CompressionType) * 8];

    if (InvalidHandleMeansFail) {
        *InvalidHandleMeansFail = TRUE;
    }

    //
    // Alloc buffers
    //

    ntRoot = SpMemAlloc (ACTUAL_MAX_PATH * sizeof (WCHAR));
    backupDir = SpMemAlloc (ACTUAL_MAX_PATH * sizeof (WCHAR));
    backupFileOb = SpMemAlloc (ACTUAL_MAX_PATH * sizeof (WCHAR));
    backupJournalOb = SpMemAlloc (ACTUAL_MAX_PATH * sizeof (WCHAR));
    backupImage = SpMemAlloc (ACTUAL_MAX_PATH * sizeof (WCHAR));

    if (!ntRoot
        || !backupDir
        || !backupFileOb
        || !backupJournalOb
        || !backupImage
        ) {
        goto cleanup;
    }

    //
    // Obtain the backup image path from winnt.sif. The return ptr points
    // to the SIF parse data structures.
    //

    ASSERT (WinntSifHandle);

    p = SpGetSectionKeyIndex (
            WinntSifHandle,
            WINNT_DATA_W,
            WINNT_D_BACKUP_IMAGE_W,
            0
            );

    if (!p) {
        if (Create) {
            KdPrintEx((
                DPFLTR_SETUP_ID,
                DPFLTR_INFO_LEVEL,
                "SETUP: Backup image is not specified; not creating a backup\n"
                ));
        } else {
            KdPrintEx((
                DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "SETUP: Backup image is not specified; cannot perform a restore\n"
                ));
        }

        goto cleanup;
    }

    SpFormatStringW(CompressionTypeString, RTL_NUMBER_OF(CompressionTypeString), L"%d", (int)CompressionType);
    wcscpy(backupImage, p);
#if TRY_ALL_COMPRESSION_ALGORITHMS
    SpAppendToBaseName(backupImage, CompressionTypeString);
#endif

    //
    // The backup spec is a DOS path. Convert it into an NT object path.
    //

    if (!SpNtNameFromDosPath (
            backupImage,
            backupFileOb,
            ACTUAL_MAX_PATH * sizeof (WCHAR),
            PartitionOrdinalCurrent
            )) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: Cannot convert path %ws to an NT path\n",
            backupImage
            ));

        goto cleanup;
    }

    //
    // Check if backup.$$$ exists
    //

    wcscpy (backupJournalOb, backupFileOb);
    p = wcsrchr (backupJournalOb, L'\\');

    if (p) {
        p = wcsrchr (p, L'.');
    }

    if (!p) {
        KdPrintEx ((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: "__FUNCTION__": Invalid backup path spec: %ws\n",
            backupFileOb
            ));
        goto cleanup;
    }

    wcscpy (p + 1, L"$$$");

    if (JournalFile) {
        wcscpy (JournalFile, backupJournalOb);
    }

    INIT_OBJA (&obja, &unicodeString, backupJournalOb);

    status = ZwCreateFile (
                &journalHandle,
                SYNCHRONIZE | FILE_GENERIC_READ,
                &obja,
                &ioStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                0,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0
                );

    if (NT_SUCCESS (status)) {
        if (!SppReadFromFile (
                journalHandle,
                &journalStatus,
                sizeof (journalStatus),
                &dontCare,
                NULL
                )) {
            journalStatus = BACKUP_DOESNT_EXIST;

            KdPrintEx((
                DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "SETUP: Journal exist but can't be read\n"
                ));
        }

        ZwClose (journalHandle);
    } else {
        journalStatus = BACKUP_DOESNT_EXIST;
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "BUGBUG: Journal doesn't exist\n"
            ));
    }

    if (((journalStatus == BACKUP_COMPLETE) && Create) ||
         (journalStatus == BACKUP_SKIPPED_BY_USER)
        ) {

        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: Backup is done or is disabled\n"
            ));

        if (InvalidHandleMeansFail) {
            *InvalidHandleMeansFail = FALSE;
        }

        goto cleanup;
    }

    //
    // form seperate strings for the directory and leaf
    //
    wcscpy (backupDir, backupFileOb);
    p = wcsrchr (backupDir, L'\\');

    if (p != NULL && p > wcschr (backupDir, L'\\')) {
        *p = 0;
        backupLeafFile = p + 1;
        backupDirIsRoot = FALSE;
    } else if (backupDir[0] == '\\') {
        ASSERTMSG("This is very strange, we got a path in the NT root.", FALSE);
        backupDir[1] = 0;
        backupLeafFile = &backupDir[2];
        backupDirIsRoot = TRUE;
    }

    //
    // Open the source file
    //

    if (Create) {
        //
        // If not the root directory, create the directory now
        //
        if (!backupDirIsRoot) {
            region = SppRegionFromFullNtName (backupDir, PartitionOrdinalCurrent, &subDir);
            if (!region) {
                KdPrintEx ((
                    DPFLTR_SETUP_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SETUP: "__FUNCTION__" - Can't get region for backup image\n"
                    ));
            } else {

                SpNtNameFromRegion (region, ntRoot, ACTUAL_MAX_PATH * sizeof (WCHAR), PartitionOrdinalCurrent);
                SpCreateDirectory (ntRoot, NULL, subDir, 0, 0);
            }
        }

        //
        // If journal pre-existed, then delete the incomplete backup image and
        // journal
        //

        if (journalStatus == BACKUP_IN_PROGRESS) {
            // error ignored for now -- will be caught below
            SpDeleteFile (backupFileOb, NULL, NULL);
            SpDeleteFile (backupJournalOb, NULL, NULL);

            KdPrintEx((
                DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "SETUP: Restarting backup process\n"
                ));

        } else {
            KdPrintEx((
                DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "BUGBUG: Backup doesn't exist\n"
                ));
            ASSERT (journalStatus == BACKUP_DOESNT_EXIST);
        }

        //
        // Create a new journal file
        //

        INIT_OBJA (&obja, &unicodeString, backupJournalOb);

        status = ZwCreateFile (
                    &journalHandle,
                    SYNCHRONIZE | FILE_GENERIC_WRITE,
                    &obja,
                    &ioStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    0,
                    FILE_CREATE,
                    FILE_SYNCHRONOUS_IO_NONALERT|FILE_WRITE_THROUGH,
                    NULL,
                    0
                    );

        if (NT_SUCCESS(status)) {
            journalStatus = BACKUP_IN_PROGRESS;
            SppWriteToFile (journalHandle, &journalStatus, sizeof (journalStatus), NULL);
            ZwClose (journalHandle);
        } else {
            KdPrintEx ((
                DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "SETUP: Unable to create %ws\n",
                backupJournalOb
                ));
            goto cleanup;
        }

    } else {
        //
        // If open attempt and journal exists, then fail
        //

        if (journalStatus != BACKUP_COMPLETE) {
            KdPrintEx ((
                DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "SETUP: Can't restore incomplete backup image %ws\n",
                backupFileOb
                ));
            goto cleanup;
        }
    }

    //
    // Create/Open backup image
    //

    imageHandle = (BACKUP_IMAGE_HANDLE)SpMemAlloc(sizeof(*imageHandle));
    if (imageHandle == NULL) {
        goto cleanup;
    }

    RtlZeroMemory(imageHandle, sizeof(*imageHandle));

    if (Create) {
        CabHandle = SpCabCreateCabinetW(backupDir, backupLeafFile, NULL, 0);
        imageHandle->CloseCabinet = SpCabFlushAndCloseCabinet;
    } else {
        CabHandle = SpCabOpenCabinetW(backupFileOb);
        imageHandle->CloseCabinet = SpCabCloseCabinet;
    }

    if (CabHandle == NULL || CabHandle == INVALID_HANDLE_VALUE) {
        goto cleanup;
    }

    imageHandle->CabHandle = CabHandle;

    Success = TRUE;

cleanup:
    if (!Success) {
        SppCloseBackupImage (imageHandle, NULL, NULL);
        imageHandle = INVALID_HANDLE_VALUE;
    }

    SpMemFree (ntRoot);
    SpMemFree (backupDir);
    SpMemFree (backupFileOb);
    SpMemFree (backupJournalOb);

    return imageHandle;
}


#define BLOCKSIZE       (65536*4)

BOOLEAN
SppPutFileInBackupImage (
    IN      BACKUP_IMAGE_HANDLE ImageHandle,
    IN OUT  PLARGE_INTEGER ImagePos,
    IN OUT  PBACKUP_IMAGE_HEADER ImageHeader,
    IN      PWSTR DosPath
    )
{
    PWSTR ntPath;
    BACKUP_FILE_HEADER fileHeader;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING unicodeString;
    FILE_STANDARD_INFORMATION stdInfo;
    BOOLEAN fail = TRUE;
    BOOLEAN truncate = FALSE;
    BOOLEAN returnValue = FALSE;
    PBYTE block = NULL;
    INT bytesRead;
    FILE_END_OF_FILE_INFORMATION eofInfo;
    PWSTR fileName;

    ntPath = SpMemAlloc (ACTUAL_MAX_PATH * sizeof (WCHAR));
    if (!ntPath) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: Can't allocate buffer\n"
            ));
        goto cleanup;
    }

    eofInfo.EndOfFile.QuadPart = ImagePos->QuadPart;

    KdPrintEx((
        DPFLTR_SETUP_ID,
        DPFLTR_TRACE_LEVEL,
        "SETUP: Backing up %ws\n",
        DosPath
        ));

    fileName = wcsrchr (DosPath, L'\\');
    if (!fileName) {
        fileName = DosPath;
    } else {
        fileName++;
    }

    SpDisplayStatusText (SP_STAT_BACKING_UP_WIN9X_FILE, DEFAULT_STATUS_ATTRIBUTE, fileName);

    //
    // Convert the backup file's DOS path into an NT path
    //

    if (!SpNtNameFromDosPath (
            DosPath,
            ntPath,
            ACTUAL_MAX_PATH * sizeof (WCHAR),
            PartitionOrdinalCurrent
            )) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: Cannot convert path %ws to an NT path\n",
            DosPath
            ));
        goto cleanup;
    }

    status = SpCabAddFileToCabinetW (ImageHandle->CabHandle, ntPath, DosPath);//ntPath

    if (!NT_SUCCESS (status)) {
        goto cleanup;
    }

    returnValue = TRUE;

cleanup:
    if (!returnValue) {
        //
        // File could not be added to the image. Allow user to continue.
        //

        if (status != STATUS_OBJECT_NAME_NOT_FOUND &&
            status != STATUS_OBJECT_NAME_INVALID &&
            status != STATUS_OBJECT_PATH_INVALID &&
            status != STATUS_OBJECT_PATH_NOT_FOUND &&
            status != STATUS_FILE_IS_A_DIRECTORY
            ) {
            KdPrintEx((
                DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "SETUP: Can't add %ws to backup CAB (%08Xh)\n",
                DosPath,
                status
                ));

            if (SpNonCriticalErrorWithContinue (SP_SCRN_BACKUP_SAVE_FAILED, DosPath, (PWSTR) status)) {
                returnValue = TRUE;
            }

            CLEAR_CLIENT_SCREEN();
        } else {
            //
            // Ignore errors that can be caused by users altering the system
            // while setup is running, or by bad migration dll info
            //

            returnValue = TRUE;
        }
    }

    SpMemFree (ntPath);
    return returnValue;
}

#if DBG
VOID
SpDbgPrintElapsedTime(
    PCSTR                Prefix,
    CONST LARGE_INTEGER* ElapsedTime
    )
{
    TIME_FIELDS TimeFields;

    RtlTimeToElapsedTimeFields((PLARGE_INTEGER)ElapsedTime, &TimeFields);
    KdPrint(("%s: %d:%d.%d\n", Prefix, (int)TimeFields.Minute, (int)TimeFields.Second, (int)TimeFields.Milliseconds));
}
#endif



BOOLEAN
SpAddRollbackBootOption (
    BOOLEAN DefaultBootOption
    )
{
    PWSTR data;
    BOOLEAN result;

    data = SpGetSectionKeyIndex (SifHandle, SIF_SETUPDATA, L"LoadIdentifierCancel", 0);
    if (!data) {
        SpFatalSifError (SifHandle, SIF_SETUPDATA, L"LoadIdentifierCancel",0,0);
    }

    result = SppCreateTextModeBootEntry (data, L"/rollback", DefaultBootOption);

    return result;
}


BOOLEAN
SpBackUpWin9xFiles (
    IN PVOID WinntSif,
    IN TCOMP CompressionType
    )
/*++

Routine Description:

  SpBackUpWin9xFiles takes full DOS paths in the BACKUP.TXT file
  and puts them in a temporary location specified in the WINNT.SIF file.

  the format of this file is

  backupfile1.ext
  backupfile2.ext
  ...

Arguments:

    WinntSif:       Handle to Winnt.Sif

Return Value:

    TRUE if a backup image was made, FALSE otherwise.

--*/

{
    WIN9XDATFILEENUM e;
    BACKUP_IMAGE_HANDLE backupImage;
    BACKUP_IMAGE_HEADER header;
    LARGE_INTEGER imagePos;
    PWSTR p;
    BOOLEAN result = FALSE;
    PWSTR journalFile = NULL;
    PWSTR data;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING unicodeString;
    HANDLE journalHandle;
    JOURNALSTATUS journalStatus;
    NTSTATUS status;
    UINT currentFile;
    UINT percentDone;
    UINT fileCount;
    PWSTR srcBootIni;
    PWSTR backupBootIni;
    BOOLEAN askForRetry = FALSE;

    //
    // Get the backup image path
    //

    p = SpGetSectionKeyIndex (
            WinntSifHandle,
            WINNT_DATA_W,
            WINNT_D_BACKUP_LIST_W,
            0
            );

    if (!p) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: Backup file list is not specified; cannot perform a backup\n"
            ));
        goto cleanup;
    }

    journalFile = SpMemAlloc (MAX_PATH * sizeof (WCHAR));
    if (!journalFile) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: Can't allocate journal buffer\n"
            ));
        goto cleanup;
    }

    //
    // Open the backup image
    //

    backupImage = SppOpenBackupImage (
                        TRUE,
                        &header,
                        &imagePos,
                        journalFile,
                        CompressionType,
                        &askForRetry
                        );

    if (backupImage == INVALID_HANDLE_VALUE) {
        goto cleanup;
    }

    askForRetry = TRUE;

    backupImage->CabHandle->CompressionType = CompressionType;

    //
    // Process all files listed in backup.txt
    //

    result = TRUE;

    fileCount = 0;
    if (SpEnumFirstWin9xFile (&e, WinntSif, p)) {
        do {
            fileCount++;
        } while (SpEnumNextWin9xFile (&e));
    }

    SendSetupProgressEvent (BackupEvent, BackupStartEvent, &fileCount);
    currentFile = 0;

    if (SpEnumFirstWin9xFile (&e, WinntSif, p)) {

        do {

            if (!SppPutFileInBackupImage (backupImage, &imagePos, &header, e.CurLine)) {
                result = FALSE;
                break;
            }

            currentFile++;
            percentDone = currentFile * 100 / fileCount;

            SendSetupProgressEvent (
                BackupEvent,
                OneFileBackedUpEvent,
                &percentDone
                );

        } while (SpEnumNextWin9xFile (&e));
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Error in SpBackUpWin9xFiles No files to enumerate.\n"));
    }

    SendSetupProgressEvent (BackupEvent, BackupEndEvent, NULL);

    //
    // Close the backup image. We leave the journal file in all cases.
    //

    if (!SppCloseBackupImage (backupImage, &header, result ? journalFile : NULL)) {
        result = FALSE;
    }

    if (result) {
        //
        // Backup was successful
        //

        askForRetry = FALSE;

        //
        // Remove the MS-DOS boot.ini entry, and add a cancel entry.
        //

        result = SpAddRollbackBootOption (FALSE);

        if (result) {
            data = SpGetSectionKeyIndex (SifHandle, SIF_SETUPDATA, L"LoadIdentifier", 0);
            if (!data) {
                SpFatalSifError (SifHandle, SIF_SETUPDATA, L"LoadIdentifier",0,0);
            }

            result = SppCreateTextModeBootEntry (data, NULL, TRUE);
        }

        if (result) {
            result = SpFlushBootVars();
        }

        //
        // Make a backup of setup in-progress boot.ini in ~BT directory, for
        // use by PSS
        //

        if (!NtBootDevicePath) {
            ASSERT(NtBootDevicePath);
            result = FALSE;
        }

        if (result) {
            wcscpy (TemporaryBuffer, NtBootDevicePath);
            SpConcatenatePaths (TemporaryBuffer, L"boot.ini");
            srcBootIni = SpDupStringW (TemporaryBuffer);

            if (!srcBootIni) {
                result = FALSE;
            }
        }

        if (result) {
            wcscpy (TemporaryBuffer, NtBootDevicePath);
            SpConcatenatePaths (TemporaryBuffer, L"$WIN_NT$.~BT\\bootini.bak");
            backupBootIni = SpDupStringW (TemporaryBuffer);

            if (!backupBootIni) {
                SpMemFree (srcBootIni);
                result = FALSE;
            }
        }

        if (result) {
            //
            // If this fails, keep going.
            //

            SpCopyFileUsingNames (srcBootIni, backupBootIni, 0, COPY_NODECOMP|COPY_NOVERSIONCHECK);

            SpMemFree (srcBootIni);
            SpMemFree (backupBootIni);
        }

    }

cleanup:

    if (askForRetry) {
        //
        // The backup image is bad. Notify the user but allow them continue.
        // Delete the journal file so that any future restarts of textmode
        // cause the backup process to be skipped.
        //
        //

        SpNonCriticalErrorNoRetry (SP_SCRN_BACKUP_IMAGE_FAILED, NULL, NULL);
        CLEAR_CLIENT_SCREEN();

        //
        // Create a new journal file, indicating that backup is disabled
        //

        INIT_OBJA (&obja, &unicodeString, journalFile);

        SpDeleteFile (journalFile, NULL, NULL);

        status = ZwCreateFile (
                    &journalHandle,
                    SYNCHRONIZE | FILE_GENERIC_WRITE,
                    &obja,
                    &ioStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    0,
                    FILE_CREATE,
                    FILE_SYNCHRONOUS_IO_NONALERT|FILE_WRITE_THROUGH,
                    NULL,
                    0
                    );

        if (NT_SUCCESS(status)) {
            journalStatus = BACKUP_SKIPPED_BY_USER;
            SppWriteToFile (journalHandle, &journalStatus, sizeof (journalStatus), NULL);
            ZwClose (journalHandle);
        }
    }

    SpMemFree (journalFile);

    return result;
}


typedef struct tagHASHITEM {
    struct tagHASHITEM *Next;
    PCWSTR String;
} HASHITEM, *PHASHITEM;

typedef struct {
    PHASHITEM HashItem;
    INT BucketNumber;
    BOOLEAN First;
} HASHITEM_ENUM, *PHASHITEM_ENUM;

HASHITEM g_UninstallHashTable[MAX_PATH];

UINT
SppComputeHash (
    IN      PCWSTR String
    )
{
    return MAX_PATH - 1 - (wcslen (String) % MAX_PATH);
}


PHASHITEM
SppFindInHashTable (
    IN      PCWSTR DosFilePath,
    OUT     PUINT OutHashValue,         OPTIONAL
    OUT     PHASHITEM *LastItem         OPTIONAL
    )
{
    UINT hashValue;
    PHASHITEM item;

    hashValue = SppComputeHash (DosFilePath);
    if (OutHashValue) {
        *OutHashValue = hashValue;
    }

    item = &g_UninstallHashTable[hashValue];

    if (LastItem) {
        *LastItem = NULL;
    }

    if (item->String) {
        do {
            if (_wcsicmp (item->String, DosFilePath) == 0) {
                break;
            }

            if (LastItem) {
                *LastItem = item;
            }

            item = item->Next;
        } while (item);
    } else {
        item = NULL;
    }

    return item;
}


BOOLEAN
SppPutInHashTable (
    IN      PCWSTR DosFilePath
    )
{
    PHASHITEM newItem;
    PHASHITEM parentItem;
    UINT hashValue;

    if (SppFindInHashTable (DosFilePath, &hashValue, &parentItem)) {
        return TRUE;
    }

    if (!parentItem) {
        g_UninstallHashTable[hashValue].String = SpDupStringW (DosFilePath);
        return g_UninstallHashTable[hashValue].String != NULL;
    }

    newItem = SpMemAlloc (sizeof (HASHITEM));
    if (!newItem) {
        return FALSE;
    }

    newItem->Next = NULL;
    newItem->String = SpDupStringW (DosFilePath);

    parentItem->Next = newItem;
    return TRUE;
}


BOOLEAN
SppPutParentsInHashTable (
    IN      PCWSTR DosFilePath
    )
{
    PCWSTR s;
    PWSTR subPath;
    PWSTR p;
    BOOLEAN result = FALSE;

    s = SpDupStringW (DosFilePath);
    if (s) {

        subPath = wcschr (s, L'\\');

        if (subPath) {

            subPath++;

            for (;;) {

                p = wcsrchr (subPath, L'\\');
                if (p) {
                    *p = 0;
                    result = SppPutInHashTable (s);
                } else {
                    break;
                }

                break;      // for now, do not go all the way up the tree
            }
        }

        SpMemFree ((PVOID) s);
    }

    return result;
}


PHASHITEM
SppEnumNextHashItem (
    IN OUT  PHASHITEM_ENUM EnumPtr
    )
{
    do {
        if (!EnumPtr->HashItem) {
            EnumPtr->BucketNumber += 1;
            if (EnumPtr->BucketNumber >= MAX_PATH) {
                break;
            }

            EnumPtr->HashItem = &g_UninstallHashTable[EnumPtr->BucketNumber];
            if (EnumPtr->HashItem->String) {
                EnumPtr->First = TRUE;
            } else {
                EnumPtr->HashItem = NULL;
            }
        } else {
            EnumPtr->HashItem = EnumPtr->HashItem->Next;
            EnumPtr->First = FALSE;
        }

    } while (!EnumPtr->HashItem);

    return EnumPtr->HashItem;
}


PHASHITEM
SppEnumFirstHashItem (
    OUT     PHASHITEM_ENUM EnumPtr
    )
{
    EnumPtr->BucketNumber = -1;
    EnumPtr->HashItem = NULL;

    return SppEnumNextHashItem (EnumPtr);
}


VOID
SppEmptyHashTable (
    VOID
    )
{
    HASHITEM_ENUM e;
    PVOID freeMe = NULL;

    if (SppEnumFirstHashItem (&e)) {
        do {
            ASSERT (e.HashItem->String);
            SpMemFree ((PVOID) e.HashItem->String);

            if (freeMe) {
                SpMemFree (freeMe);
                freeMe = NULL;
            }

            if (!e.First) {
                freeMe = (PVOID) e.HashItem;
            }

        } while (SppEnumNextHashItem (&e));
    }

    if (freeMe) {
        SpMemFree (freeMe);
    }

    RtlZeroMemory (g_UninstallHashTable, sizeof (g_UninstallHashTable));
}

/*BOOLEAN
SppIsDotOrDotDot(
    PCWSTR s
    )
{
    return (s[0] == '.' && (s[1] == 0 || (s[1] == '.' && s[2] == 0)));
}*/

BOOLEAN
SppEmptyDirProc (
    IN  PCWSTR Path,
    IN  PFILE_BOTH_DIR_INFORMATION DirInfo,
    OUT PULONG ReturnData,
    IN OUT PVOID DontCare
    )
{
    if (DirInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        return TRUE;
    }

    return FALSE;
}


BOOLEAN
SppIsDirEmpty (
    IN      PCWSTR NtPath
    )
{
    ENUMFILESRESULT result;
    ULONG dontCare;

    result = SpEnumFilesRecursive ((PWSTR) NtPath, SppEmptyDirProc, &dontCare, NULL);

    return result == NormalReturn;
}

BOOLEAN
SppDelEmptyDirProc (
    IN  PCWSTR Path,
    IN  PFILE_BOTH_DIR_INFORMATION DirInfo,
    OUT PULONG ReturnData,
    IN OUT PVOID DontCare
    )
{
    PCWSTR subPath;
    PWSTR p;
    PWSTR end;
    UINT bytesToCopy;

    //
    // If we find a file, fail. This must be checked before any deletion
    // occurs.
    //

    if (!(DirInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
        return TRUE;
    }

    //
    // Join Path with the enumerated directory. Contain the path to MAX_PATH.
    //

    wcscpy (TemporaryBuffer, Path);

    if (DirInfo->FileNameLength) {
        p = wcschr (TemporaryBuffer, 0);

        bytesToCopy = DirInfo->FileNameLength;
        end = (TemporaryBuffer + (ACTUAL_MAX_PATH) - 2) - (bytesToCopy / sizeof (WCHAR));

        if (!p || p > end) {
            KdPrintEx((
                DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "SETUP: Enumeration of %ws became too long\n",
                Path
                ));
            return FALSE;
        }

        *p++ = L'\\';

        RtlCopyMemory (p, DirInfo->FileName, bytesToCopy);
        p[bytesToCopy / sizeof(WCHAR)] = 0;

/*
        //
        // Skip . and .. subdirs
        //

        if (SppIsDotOrDotDot (p)) {
            return TRUE;
        }
*/
    }

    //
    // Duplicate temp buffer and call ourselves recursively to delete
    // any contained subdirs
    //

    subPath = SpDupStringW (TemporaryBuffer);
    if (!subPath) {
        KdPrintEx((
            DPFLTR_SETUP_ID, 
            DPFLTR_ERROR_LEVEL, 
            "SETUP: SpDupStringW failed to allocate memory for %d bytes", 
            wcslen(TemporaryBuffer) * sizeof(WCHAR)));
        return FALSE;
    }

    SppDelEmptyDir (subPath);

    SpMemFree ((PVOID) subPath);
    return TRUE;
}


BOOLEAN
SppDelEmptyDir (
    IN      PCWSTR NtPath
    )
{
    ENUMFILESRESULT result;
    ULONG dontCare;
    NTSTATUS status;

    //
    // Remove any empty subdirectories in NtPath
    //

    result = SpEnumFiles ((PWSTR) NtPath, SppDelEmptyDirProc, &dontCare, NULL);

    if (result != NormalReturn) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: Failed to enumerate contents of %ws - status 0x%08X\n",
            NtPath,
            result
            ));
    }

    //
    // Now remove this subdirectory
    //

    status = SpSetAttributes ((PWSTR) NtPath, FILE_ATTRIBUTE_NORMAL);

    if (!NT_SUCCESS (status)) {

        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: Can't alter attributes of %ws - status 0x%08X\n",
            NtPath,
            status
            ));
    }

    status = SpDeleteFileEx (
                NtPath,
                NULL,
                NULL,
                FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN_FOR_BACKUP_INTENT
                );

    if (!NT_SUCCESS (status)){
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: Can't delete %ws - status 0x%08X\n",
            NtPath,
            status
            ));
    }

    return NT_SUCCESS (status);
}

VOID
SppCleanEmptyDirs (
    VOID
    )
{
    HASHITEM_ENUM e;
    PWSTR ntPath;
    PWSTR p;
    NTSTATUS result;

    //
    // Enumerate the length-sorted hash table
    //

    ntPath = SpMemAlloc (ACTUAL_MAX_PATH * sizeof (WCHAR));
    if (!ntPath) {
        return;
    }

    if (SppEnumFirstHashItem (&e)) {
        do {
            ASSERT (e.HashItem->String);

            //
            // Convert String into NT path
            //

            if (!SpNtNameFromDosPath (
                    (PWSTR) e.HashItem->String,
                    ntPath,
                    ACTUAL_MAX_PATH * sizeof (WCHAR),
                    PartitionOrdinalCurrent
                    )) {
                KdPrintEx((
                    DPFLTR_SETUP_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SETUP: Cannot convert path %ws to an NT path\n",
                    e.HashItem->String
                    ));
                continue;
            }

            //
            // Does it exist? If not, skip it.
            //

            if (!SpFileExists (ntPath, TRUE)) {
                continue;
            }

            //
            // Find the root emtpy dir. Then blow it away, including any empty
            // subdirs it might have.
            //

            if (SppIsDirEmpty (ntPath)) {
                if (!SppDelEmptyDir (ntPath)) {
                    KdPrintEx((
                        DPFLTR_SETUP_ID,
                        DPFLTR_ERROR_LEVEL,
                        "SETUP: Unable to delete empty dir %ws\n",
                        ntPath
                        ));
                }
                else {
                    //
                    // find the first non-empty path
                    //

                    p = wcsrchr (ntPath, L'\\');
                    while (p) {
                        *p = 0;
                        if (!SppIsDirEmpty (ntPath)) {
                            *p = L'\\';
                            break;
                        }
                        else{
                            //
                            // remove this empty tree
                            //

                            if (!SppDelEmptyDir (ntPath)) {
                                KdPrintEx((
                                    DPFLTR_SETUP_ID,
                                    DPFLTR_ERROR_LEVEL,
                                    "SETUP: Unable to delete empty parent dir %ws\n",
                                    ntPath
                                    ));
                                break;
                            }
                        }

                        p = wcsrchr (ntPath, L'\\');
                    }
                }
            }
        } while (SppEnumNextHashItem (&e));
    }

    SpMemFree (ntPath);
}


PDISK_REGION
SppRegionFromFullNtName (
    IN      PWSTR NtName,
    IN      PartitionOrdinalType OrdinalType,
    OUT     PWSTR *Path                             OPTIONAL
    )
{
    WCHAR ntRoot[ACTUAL_MAX_PATH];
    PWSTR p;
    PWSTR end;

    //
    // NtName is in the format of
    //
    // \Device\harddisk<n>\partition<m>\subdir
    //
    // and we need to separate the two.
    //

    wcscpy (ntRoot, NtName);

    // p points to \Device\harddisk<n>\partition<m>\subdir
    p = wcschr (ntRoot + 1, L'\\');

    if (p) {
        // p points to \harddisk<n>\partition<m>\subdir
        p = wcschr (p + 1, L'\\');

        if (p) {
            // p points to \partition<m>\subdir
            end = p;
            p = wcschr (p + 1, L'\\');
            if (!p) {
                p = wcschr (end, 0);
            }
        }
    }

    if (p) {
        // p points to \subdir or '\0'

        *p = 0;

        if (Path) {
            *Path = NtName + (p - ntRoot);
        }

        return SpRegionFromNtName (ntRoot, OrdinalType);
    }

    return NULL;
}


BOOLEAN
SppCreateTextModeBootEntry (
    IN      PWSTR LoadIdentifierString,
    IN      PWSTR OsLoadOptions,     OPTIONAL
    IN      BOOLEAN Default
    )

/*++

Routine Description:

  SppCreateTextModeBootEntry makes another boot.ini entry for textmode.
  This is used to create the boot.ini entry that triggers rollback in
  an incomplete setup scenario.

Arguments:

  LoadIdentifierString - Specifies the localized text to put in the boot menu.
  OsLoadOptions        - Specifies options to associate with the boot option,
                         such as /rollback.
  Default              - Specifies TRUE if the entry should be the default
                         boot option

Return Value:

  TRUE if boot.ini was updated, FALSE otherwise.

--*/

{
    PWSTR bootVars[MAXBOOTVARS];
    PWSTR defaultBootEntry = L"C:\\$WIN_NT$.~BT\\bootsect.dat";
    PWSTR defaultArc = L"C:\\$WIN_NT$.~BT\\";
    PWSTR defaultFile = L"bootsect.dat";
    PDISK_REGION CColonRegion;
    UINT defaultSignature;

    CColonRegion = SpPtValidSystemPartition();

    if (!CColonRegion) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: Unable to find region of drive C."
            ));
    }

    //
    // Create a boot set
    //

    bootVars[OSLOADOPTIONS] = SpDupStringW (OsLoadOptions ? OsLoadOptions : L"");

    bootVars[LOADIDENTIFIER] = SpMemAlloc((wcslen(LoadIdentifierString)+3)*sizeof(WCHAR));
    bootVars[LOADIDENTIFIER][0] = L'\"';
    wcscpy (bootVars[LOADIDENTIFIER] + 1, LoadIdentifierString);
    wcscat (bootVars[LOADIDENTIFIER], L"\"");

    bootVars[OSLOADER] = SpDupStringW (defaultBootEntry);

    bootVars[OSLOADPARTITION] = SpDupStringW (defaultArc);
    bootVars[SYSTEMPARTITION] = SpDupStringW (defaultArc);

    bootVars[OSLOADFILENAME] = SpDupStringW (defaultFile);

    if (CColonRegion->DiskNumber != 0xffffffff) {
        defaultSignature = HardDisks[CColonRegion->DiskNumber].Signature;
    } else {
        defaultSignature = 0;
    }

    SpAddBootSet (bootVars, Default, defaultSignature);
    return TRUE;
}

BOOL
SppRestoreBackedUpFileNotification (
    PCWSTR FileName
    )
{
    //KdPrint((__FUNCTION__" %ls\n", FileName));
    return TRUE;
}

VOID
SppRestoreBackedUpFiles (
    IN PVOID WinntSif
    )
{
    BOOL Success = FALSE;
    BACKUP_IMAGE_HANDLE backupImage = NULL;
    BACKUP_IMAGE_HEADER header = { 0 };
    LARGE_INTEGER imagePos = { 0 };

    backupImage = SppOpenBackupImage (FALSE, &header, &imagePos, NULL, tcompTYPE_MSZIP, NULL);
    if (backupImage == INVALID_HANDLE_VALUE) {
        return;
    }

    Success = SpCabExtractAllFilesExW(backupImage->CabHandle, L"", SppRestoreBackedUpFileNotification);

    SppCloseBackupImage (backupImage, NULL, NULL);
}


DWORD Spwtoi (
    IN LPCWSTR String)
{
    DWORD rVal = 0;

    //
    // While on a number, build up rVal.
    //
    while (String && *String && *String >= L'0' && *String <= L'9') {
        rVal = rVal * 10 + (*String - L'0');
        String++;
    }

    return rVal;
}

BOOL
pParseLineForDirNameAndAttributes(
	IN		PCWSTR LineForParse,
	OUT		PWSTR DirName,
	OUT		DWORD * DirAttributes
	)
{
    int i;
    int iLen;

    if(!LineForParse || !DirName){
        ASSERT(FALSE);
        return FALSE;
    }

    for(i = 0, iLen = wcslen(LineForParse); i < iLen; i++)
    {
        if(LineForParse[i] == ','){
            break;
        }
    }

	if(i == iLen){
		wcscpy(DirName, LineForParse);
	}
    else{
        wcsncpy(DirName, LineForParse, i);DirName[i] = '\0';
        if(DirAttributes){
            *DirAttributes = Spwtoi((PCWSTR)&LineForParse[i + 1]);
	    }
    }

    return TRUE;
}

VOID
SppMkEmptyDirs (
    IN PVOID WinntSif,
    IN PCWSTR DosDirListPath
    )
{
    WIN9XDATFILEENUM e;
    PDISK_REGION region = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    WCHAR ntName[ACTUAL_MAX_PATH];
    WCHAR ntRoot[ACTUAL_MAX_PATH];
    PWSTR subDir = NULL;
    UINT dirAttributes;
    WCHAR dirName[ACTUAL_MAX_PATH];

    //
    // Blow away files or empty directories
    //

    if (SpEnumFirstWin9xFile (&e, WinntSif, DosDirListPath)) {

        do {

            //
            // Convert e.CurLine from a DOS path to an NT path
            //

            dirAttributes = 0;
            if(!pParseLineForDirNameAndAttributes(e.CurLine, dirName, &dirAttributes)){
                ASSERT(FALSE);
                continue;
            }

            if (!SpNtNameFromDosPath (
                    dirName,
                    ntName,
                    sizeof (ntName),
                    PartitionOrdinalCurrent
                    )) {
                KdPrintEx((
                    DPFLTR_SETUP_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SETUP: " __FUNCTION__ ": Cannot convert path %ws to an NT path\n",
                    dirName
                    ));
            } else {
                region = SppRegionFromFullNtName (ntName, PartitionOrdinalCurrent, &subDir);

                if (!region) {
                    KdPrintEx ((
                        DPFLTR_SETUP_ID,
                        DPFLTR_ERROR_LEVEL,
                        "SETUP: "__FUNCTION__" - Can't get region for empty dirs\n"
                        ));
                } else{
                    SpNtNameFromRegion (region, ntRoot, sizeof(ntRoot), PartitionOrdinalCurrent);
                    SpCreateDirectory (ntRoot, NULL, subDir, dirAttributes, 0);
                    SpSetFileAttributesW(ntName, dirAttributes);
                }
            }

        } while (SpEnumNextWin9xFile(&e));

    } else {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: " __FUNCTION__ ": No files to enumerate.\n"
            ));
    }
}


VOID
SpRemoveExtraBootIniEntry (
    VOID
    )
{
    PWSTR bootVars[MAXBOOTVARS];
    PWSTR defaultBootEntry = L"C:\\$WIN_NT$.~BT\\bootsect.dat";
    PWSTR defaultArc = L"C:\\$WIN_NT$.~BT\\";
    PWSTR defaultFile = L"bootsect.dat";
    PDISK_REGION CColonRegion;

    //
    // Remove the boot set for text mode
    //

    RtlZeroMemory (bootVars, sizeof(bootVars));
    bootVars[OSLOADOPTIONS] = L"";

    bootVars[OSLOADER] = defaultBootEntry;

    bootVars[OSLOADPARTITION] = defaultArc;
    bootVars[SYSTEMPARTITION] = defaultArc;

    bootVars[OSLOADFILENAME] = defaultFile;

    SpDeleteBootSet (bootVars, NULL);
}


VOID
SppMakeLegacyBootIni (
    IN      PDISK_REGION TargetRegion
    )
{
    PWSTR data;
    PWSTR bootVars[MAXBOOTVARS];
    WCHAR sysPart[MAX_PATH];
    UINT signature;

    //
    // Reset the entire boot.ini file
    //

    RtlZeroMemory (bootVars, sizeof(bootVars));
    SpDeleteBootSet (bootVars, NULL);

    //
    // Build new boot.ini entry
    //

    // LOADIDENTIFIER - friendly name
    data = SpGetSectionKeyIndex (SifHandle, SIF_SETUPDATA, L"LoadIdentifierWin9x", 0);

    if (!data) {
        SpFatalSifError (SifHandle, SIF_SETUPDATA, L"LoadIdentifierWin9x",0,0);
    }

    bootVars[LOADIDENTIFIER] = SpMemAlloc((wcslen(data)+3)*sizeof(WCHAR));
    bootVars[LOADIDENTIFIER][0] = L'\"';
    wcscpy (bootVars[LOADIDENTIFIER] + 1, data);
    wcscat (bootVars[LOADIDENTIFIER], L"\"");

    // OSLOADER - c:\ntldr (in ARC format)
    SpArcNameFromRegion (
        TargetRegion,
        sysPart,
        sizeof(sysPart),
        PartitionOrdinalCurrent,
        PrimaryArcPath
        );

    data = TemporaryBuffer;
    wcscpy (data, sysPart);
    SpConcatenatePaths (data, L"ntldr");

    bootVars[OSLOADER] = SpDupStringW (data);

    // OSLOADPARTITION - "c:\"
    data[0] = TargetRegion->DriveLetter;
    data[1] = L':';
    data[2] = L'\\';
    data[3] = 0;

    if (data[0] != L'C' && data[0] != L'D' && data[0] != L'c' && data[0] != L'd') {
        data[0] = L'C';
    }
    bootVars[OSLOADPARTITION] = SpDupStringW (data);

    // SYSTEMPARTITION - same as OSLOADPARTITION
    bootVars[SYSTEMPARTITION] = SpDupStringW (data);

    // OSLOADFILENAME - empty
    bootVars[OSLOADFILENAME] = SpDupStringW (L"");

    // OSLOADOPTIONS - empty
    bootVars[OSLOADOPTIONS] = SpDupStringW (L"");

    // signature
    if (TargetRegion->DiskNumber != 0xffffffff) {
        signature = HardDisks[TargetRegion->DiskNumber].Signature;
    } else {
        signature = 0;
    }

    // add to boot.ini (takes ownership of allocations above)
    SpAddBootSet (bootVars, TRUE, signature);

    // flush boot.ini
    SpCompleteBootListConfig (TargetRegion->DriveLetter);
}

BOOLEAN
SpExecuteWin9xRollback (
    IN PVOID WinntSifHandle,
    IN PWSTR BootDeviceNtPath
    )
{
    PWSTR data;
    PDISK_REGION bootRegion;
    ULONG i = 0;
    PCWSTR Directory = NULL;
    PWSTR NtNameFromDosPath = NULL;

    //
    // Perform rollback
    //

    // step 1: delete NT files
    data = SpGetSectionKeyIndex (
                WinntSifHandle,
                SIF_DATA,
                WINNT_D_ROLLBACK_DELETE_W,
                0
                );

    if (data) {
        SppDeleteWin9xFilesWorker (WinntSifHandle, data, NULL, TRUE);
        SppCleanEmptyDirs();
    }

    TESTHOOK(1003); // use 2003 in the answer file to hit this

    // step 2: move Win9x files back to original locations
    data = SpGetSectionKeyIndex (
                WinntSifHandle,
                SIF_DATA,
                WINNT_D_ROLLBACK_MOVE_W,
                0
                );

    if (data) {
        SppMoveWin9xFilesWorker (WinntSifHandle, data, TRUE);
    }

    TESTHOOK(1004); // use 2004 in the answer file to hit this

    // step 3: blow away NT-specific subdirectories
    data = SpGetSectionKeyIndex (
                WinntSifHandle,
                SIF_DATA,
                WINNT_D_ROLLBACK_DELETE_DIR_W,
                0
                );

    if (data) {
        SppDeleteWin9xFilesWorker (WinntSifHandle, NULL, data, TRUE);
    }

    TESTHOOK(1005); // use 2005 in the answer file to hit this

    // step 4: restore files that were backed up
    SppRestoreBackedUpFiles (WinntSifHandle);

    TESTHOOK(1006); // use 2006 in the answer file to hit this

    // step 5: wipe out dirs made empty
    SppCleanEmptyDirs();

    TESTHOOK(1007); // use 2007 in the answer file to hit this

    // step 6: generate original empty dirs
    data = SpGetSectionKeyIndex (
                WinntSifHandle,
                SIF_DATA,
                L"RollbackMkDirs",
                0
                );

    if (data) {
        SppMkEmptyDirs (WinntSifHandle, data);
    }

    TESTHOOK(1008); // use 2008 in the answer file to hit this

    //
    // step 7: clean up boot loader
    //
    bootRegion = SpRegionFromNtName (BootDeviceNtPath, PartitionOrdinalCurrent);
    if (bootRegion) {
        SppMakeLegacyBootIni (bootRegion);
    } else {
        SpBugCheck(SETUP_BUGCHECK_BOOTPATH,0,0,0);
    }

    SppEmptyHashTable();

    return TRUE;
}


VOID
SppMoveWin9xFilesWorker (
    IN PVOID WinntSif,
    IN PCWSTR MoveSection,
    IN BOOLEAN Rollback
    )

/*++

Routine Description:

  SpMoveWin9xFiles takes full DOS paths in the WIN9XMOV.TXT file
  and puts them in a temporary location also specified in this file.

  the format of this file is

  oldpath
  temppath
  ...

  oldpath can be either a directory or file, temppath can only be a directory (which may
  not exist yet).

Arguments:

    WinntSif:       Handle to Winnt.Sif

Return Value:

    None.  Errors ignored.

--*/


{

    WCHAR SourceFileOrDir[ACTUAL_MAX_PATH];
    PWSTR DestFileOrDir;
    WIN9XDATFILEENUM e;

    if (SpEnumFirstWin9xFile(&e,WinntSif, MoveSection)) {

        do {

            wcscpy (SourceFileOrDir, e.CurLine);

            if (!SpEnumNextWin9xFile(&e)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Error moving win9x files. Improper Win9x dat file."));
                return;
            }

            DestFileOrDir = e.CurLine;

            if (Rollback) {
                SppPutParentsInHashTable (SourceFileOrDir);
            }

            // There's little chance for failure, because in Win95 we've already
            // verified the source exists and the destination does not exist.
            // The only way this can fail is if the hard disk craps out.

            SpMigMoveFileOrDir (SourceFileOrDir, DestFileOrDir);

        } while (SpEnumNextWin9xFile(&e));
    }
    else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Error in SpWin9xMovFiles No files to enum in.\n"));
    }
}


VOID
SpMoveWin9xFiles (
    IN PVOID WinntSif
    )
{
    SppMoveWin9xFilesWorker (WinntSif, WINNT32_D_WIN9XMOV_FILE_W, FALSE);
}


VOID
SppDeleteWin9xFilesWorker (
    IN PVOID WinntSif,
    IN PCWSTR FileSection,      OPTIONAL
    IN PCWSTR DirSection,       OPTIONAL
    IN BOOLEAN Rollback
    )

/*++

Routine Description:

  SpDeleteWin9xFiles deletes files/empty directories specified by full DOS
  paths in WIN9XDEL.TXT (install) or DELFILES.TXT (uninstall).

  Each line in this file contains one path and is delimeted by a \r\n.

Arguments:

    WinntSif:       Handle to Winnt.Sif

Return Value:

    None.  Errors ignored.

--*/

{
    WIN9XDATFILEENUM e;
    PDISK_REGION region;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Blow away files or empty directories
    //

    if (FileSection && SpEnumFirstWin9xFile(&e,WinntSif,FileSection)) {

        do {

            if (Rollback) {
                SppPutParentsInHashTable (e.CurLine);
            }

            SpMigDeleteFile (e.CurLine);

        } while (SpEnumNextWin9xFile(&e));

    } else {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: " __FUNCTION__ ": No files to enumerate.\n"
            ));
    }

    //
    // Remove entire subdirectory trees.
    //

    if (DirSection && SpEnumFirstWin9xFile (&e, WinntSif, DirSection)) {
        do {

            region = SpRegionFromDosName (e.CurLine);
            if (region) {

                SpDeleteExistingTargetDir (region, e.CurLine + 2, TRUE, SP_SCRN_CLEARING_OLD_WINNT);

                if (Rollback) {
                    SppPutParentsInHashTable (e.CurLine);
                }
            }

        } while (SpEnumNextWin9xFile (&e));

    } else {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: No Directories to delete for win9xupg.\n"
            ));
    }
}


VOID
SpDeleteWin9xFiles (
    IN PVOID WinntSif
    )
{
    SppDeleteWin9xFilesWorker (WinntSif, WINNT32_D_WIN9XDEL_FILE_W, WINNT32_D_W9XDDIR_FILE_W, FALSE);
}

//
// Win9x Drive Letter mapping specific structs, typedefs, and defines
//
typedef struct _WIN9XDRIVELETTERINFO WIN9XDRIVELETTERINFO,*PWIN9XDRIVELETTERINFO;
struct _WIN9XDRIVELETTERINFO {

    BOOL                  StatusFlag;     // Internal routine use.
    DWORD                 Drive;          // 0 - 25, 0 = 'A', etc.
    DWORD                 Type;           // Media type. Gathered by GetDriveType on Win9x.
    LPCWSTR               Identifier;     // Media type dependent string identifier.
    PWIN9XDRIVELETTERINFO Next;           // Next drive letter.

};

#define NUMDRIVELETTERS 26

#define DEBUGSTATUS(string,status) \
    if (!NT_SUCCESS(status)) KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP (DEBUGSTATUS) %ws %u (%x)\n",(string),(status),(status)))



//
// FALSE indicates a drive letter is available,
// TRUE indicates that a drive letter is already
// assigned to a system resource.
//
BOOL g_DriveLetters[NUMDRIVELETTERS];



PDISK_REGION
SpFirstPartitionedRegion (
    IN PDISK_REGION Region,
    IN BOOLEAN Primary
    )
{
    while (Region) {
        if (Primary) {
            if (SPPT_IS_REGION_PRIMARY_PARTITION(Region)) {
                break;
            }
        } else {
            if (SPPT_IS_REGION_LOGICAL_DRIVE(Region)) {
                break;
            }
        }

        Region = Region -> Next;
    }

    return Region;
}

PDISK_REGION
SpNextPartitionedRegion (
    IN PDISK_REGION Region,
    IN BOOLEAN Primary
    )
{
    if (Region) {
        return SpFirstPartitionedRegion (Region->Next, Primary);
    }

    return NULL;
}


#if 0
VOID
SpOutputDriveLettersToRegionsMap(
    VOID
    )
{
    //
    // This is a debug function. Will be removed.
    //

    DWORD        disk;
    PDISK_REGION pRegion;
    WCHAR        tempBuffer[MAX_PATH];


    for(disk=0; disk<HardDiskCount; disk++) {
        pRegion =                 SpFirstPartitionedRegion(PartitionedDisks[disk].PrimaryDiskRegions, TRUE);

        while(pRegion) {


            SpNtNameFromRegion(pRegion,tempBuffer,MAX_PATH,PartitionOrdinalCurrent);
            if (pRegion -> DriveLetter == 0) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: No drive letter for %ws.\n",tempBuffer));
            }
            else  {

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: %ws maps to drive letter %wc\n",tempBuffer,pRegion -> DriveLetter));
            }

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: %ws Info: Disk Num: %u Start: %u\n",tempBuffer,pRegion -> DiskNumber,pRegion -> StartSector));

            pRegion = SpNextPartitionedRegion(pRegion, TRUE);
        }

        pRegion = SpFirstPartitionedRegion(PartitionedDisks[disk].PrimaryDiskRegions, FALSE);

        while(pRegion) {
            SpNtNameFromRegion(pRegion,tempBuffer,MAX_PATH,PartitionOrdinalCurrent);

            if (pRegion -> DriveLetter == 0) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: No drive letter for %ws.\n",tempBuffer));
            }
            else  {

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: %ws maps to drive letter %wc\n",tempBuffer,pRegion -> DriveLetter));
            }
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: %ws Info: Disk Num: %u Start: %u\n",tempBuffer,pRegion -> DiskNumber,pRegion -> StartSector));

            pRegion = SpNextPartitionedRegion(pRegion, FALSE);
        }
    }
}
#endif


WCHAR
SpGetNextDriveLetter (
    IN     WCHAR LastLetter
    )

{
    WCHAR rChar = 0;
    DWORD index = LastLetter - L'A';

    //
    // Find the next unused drive letter.
    //
    while (index < NUMDRIVELETTERS && g_DriveLetters[index]) {
        index++;

    }

    if (index < NUMDRIVELETTERS) {
        //
        // A valid letter was found.
        // Set it as the return drive letter and mark its place in the table as used
        //
        rChar = (WCHAR) index + L'A';
        g_DriveLetters[index] = TRUE;
    }

    return rChar;
}

VOID
SpAssignDriveLettersToRemainingPartitions (
    VOID
    )
/*++

Routine Description:

    Assigns drive letters to partitions which have not yet received
    the drive letter

    NOTE : This is a modified version of SpGuessDriveLetters().

Arguments:

    None

Return Value:

    None

--*/
{
    ULONG               Disk;
    BOOLEAN             DriveLettersPresent = TRUE;
    PDISK_REGION        *PrimaryPartitions;
    WCHAR               DriveLetter;
    PDISK_REGION        pRegion;
    ULONG               Index;
    PPARTITIONED_DISK   PartDisk;

    //
    // Allocate adequate memory for region pointers to primary partitions
    // on all disks
    //
    PrimaryPartitions = SpMemAlloc(PTABLE_DIMENSION * HardDiskCount * sizeof(PDISK_REGION));

    if(!PrimaryPartitions) {
        KdPrintEx((DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: Can't allocate memory for drive letter assignment\n"));

        return;
    }

    RtlZeroMemory(PrimaryPartitions,PTABLE_DIMENSION * HardDiskCount * sizeof(PDISK_REGION));

    //
    // Go through each disk and fill up the primary partition
    // region(s) in the array
    //
    for(Disk=0; Disk < HardDiskCount; Disk++) {
        ULONG   ActiveIndex = (ULONG)-1;

        PartDisk = PartitionedDisks + Disk;

        //
        // Skip removable media. If a Disk is off-line it's hard to imagine
        // that we'll actually have any partitioned spaces on it so
        // we don't do any special checks here for that condition.
        //
        if(!(PartDisk->HardDisk->Characteristics & FILE_REMOVABLE_MEDIA)) {

            for(pRegion=SPPT_GET_PRIMARY_DISK_REGION(Disk); pRegion; pRegion=pRegion->Next) {
                //
                // We only care about partitioned spaces that have yet to receive
                // a drive letter.
                //
                if (SPPT_IS_REGION_PRIMARY_PARTITION(pRegion) && !pRegion -> DriveLetter) {
                    //
                    // This guy gets a drive letter.
                    //
                    ASSERT(pRegion->TablePosition <= PTABLE_DIMENSION);

                    PrimaryPartitions[(Disk*PTABLE_DIMENSION) + pRegion->TablePosition - 1] = pRegion;

                    //
                    // Do not save active flag on NEC98
                    //
                    if (!IsNEC_98) { //NEC98
                        if (SPPT_IS_REGION_ACTIVE_PARTITION(pRegion) && (ActiveIndex != (ULONG)(-1))) {
                            ActiveIndex = pRegion->TablePosition - 1;
                        }
                    } //NEC98
                }
            }

            //
            // Do not check active flag on NEC98
            //
            if (!IsNEC_98) { //NEC98
                //
                // If we found an active partition, move it to the start of
                // the list for this drive unless it's already at the start.
                //
                if((ActiveIndex != (ULONG)(-1)) && ActiveIndex) {
                    PDISK_REGION ActiveRegion;

                    ASSERT(ActiveIndex < PTABLE_DIMENSION);

                    ActiveRegion = PrimaryPartitions[(Disk*PTABLE_DIMENSION) + ActiveIndex];

                    RtlMoveMemory(
                        &PrimaryPartitions[(Disk*PTABLE_DIMENSION)+1],
                        &PrimaryPartitions[(Disk*PTABLE_DIMENSION)],
                        (ActiveIndex) * sizeof(PDISK_REGION)
                        );

                    PrimaryPartitions[Disk*PTABLE_DIMENSION] = ActiveRegion;
                }
            } //NEC98
        }
    }

    if (IsNEC_98 && DriveAssignFromA) { //NEC98
        DriveLetter = L'A'; // First valid hard dive letter for legacy NEC assign.
    } else {
        DriveLetter = L'C'; // First valid hard dive letter.
    } //NEC98


    //
    // Assign drive letters to the first primary partitions
    // for each non-removable on-line Disk.
    //
    for(Disk=0; Disk<HardDiskCount; Disk++) {
        for(Index=0; Index<PTABLE_DIMENSION; Index++) {
            PDISK_REGION Region = PrimaryPartitions[(Disk*PTABLE_DIMENSION) + Index];

            if(Region) {
                DriveLetter = SpGetNextDriveLetter(DriveLetter);

                if (DriveLetter && !Region->DriveLetter) {
                    Region->DriveLetter = DriveLetter;

                    //
                    // Done with the region
                    //
                    PrimaryPartitions[(Disk*PTABLE_DIMENSION) + Index] = NULL;

                    break;
                } else {
                    DriveLettersPresent = FALSE;

                    break;
                }
            }
        }
    }

    //
    // For each disk, assign drive letters to all the logical drives.
    // For removable drives, we assume a single partition, and that
    // partition gets a drive letter as if it were a logical drive.
    //
    for(Disk=0; DriveLettersPresent && (Disk < HardDiskCount); Disk++) {

        PartDisk = &PartitionedDisks[Disk];

        if(PartDisk->HardDisk->Characteristics & FILE_REMOVABLE_MEDIA) {

            //
            // Give the first primary partition the drive letter
            // and ignore other partitions. Even if there are no
            // partitions, reserve a drive letter.
            //
            for(pRegion=SPPT_GET_PRIMARY_DISK_REGION(Disk); pRegion; pRegion=pRegion->Next) {
                if(SPPT_IS_REGION_PRIMARY_PARTITION(pRegion) && !pRegion->DriveLetter) {
                    DriveLetter = SpGetNextDriveLetter(DriveLetter);

                    if (DriveLetter) {
                        pRegion->DriveLetter = DriveLetter;

                        break;
                    }
                    else {
                        DriveLettersPresent = FALSE;

                        break;
                    }
                }
            }
        } else {
            for(pRegion=SPPT_GET_PRIMARY_DISK_REGION(Disk); pRegion; pRegion=pRegion->Next) {

                if(SPPT_IS_REGION_LOGICAL_DRIVE(pRegion) && pRegion->DriveLetter == 0) {
                    //
                    // This guy gets a drive letter.
                    //
                    DriveLetter = SpGetNextDriveLetter(DriveLetter);

                    if (DriveLetter) {
                        pRegion->DriveLetter = DriveLetter;
                    } else {
                        DriveLettersPresent = FALSE;

                        break;
                    }
                }
            }
        }
    }

    //
    // For each non-removable on-line disk, assign drive letters
    // to all remaining primary partitions.
    //
    for (Disk=0; DriveLettersPresent && (Disk < HardDiskCount); Disk++) {
        for(Index=0; Index<PTABLE_DIMENSION; Index++) {
            PDISK_REGION Region = PrimaryPartitions[(Disk*PTABLE_DIMENSION)+Index];

            if (Region && !Region->DriveLetter) {
                DriveLetter = SpGetNextDriveLetter(DriveLetter);

                if (DriveLetter) {
                    Region->DriveLetter = DriveLetter;
                } else {
                    DriveLettersPresent = FALSE;

                    break;
                }
            }
        }
    }

    SpMemFree(PrimaryPartitions);

#if 0
    SpOutputDriveLettersToRegionsMap();
#endif

}

BOOL
SpCheckRegionForMatchWithWin9xData(
    IN PDISK_REGION Region,
    IN DWORD        DriveToMatch
    )

{
    NTSTATUS                 ntStatus;
    HANDLE                   fileHandle;
    OBJECT_ATTRIBUTES        attributes;
    IO_STATUS_BLOCK          ioStatus;
    UNICODE_STRING           filePath;
    WCHAR                    tempBuffer[MAX_PATH];
    DWORD                    sigFileDrive;


    ASSERT(DriveToMatch < NUMDRIVELETTERS);

    //
    // Initialize sigFileDrive to an invalid drive.
    //
    sigFileDrive = NUMDRIVELETTERS;


    //
    // Create Unicode string for the path to the region.
    SpNtNameFromRegion(Region,tempBuffer,sizeof(tempBuffer),PartitionOrdinalCurrent);

    //
    // Get the file creation times of the $DRVLTR$.~_~ file.
    //
    wcscat(tempBuffer,L"\\");
    wcscat(tempBuffer,WINNT_WIN95UPG_DRVLTR_W);


    RtlInitUnicodeString(&filePath,tempBuffer);

    InitializeObjectAttributes(
        &attributes,
        &filePath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Attempt to open the signature file.
    //
    ntStatus = ZwCreateFile (
        &fileHandle,
        GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
        &attributes,
        &ioStatus,
        0,
        0,
        0,
        FILE_OPEN,
        FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0
        );

    if (NT_SUCCESS(ntStatus)) {

        //
        // Read the drive letter from this signature file, then close it.
        //
        ntStatus = ZwReadFile (
            fileHandle,
            NULL,
            NULL,
            NULL,
            &ioStatus,
            &sigFileDrive,
            sizeof(DWORD),
            NULL,
            NULL
            );

        ZwClose(fileHandle);
    }

    //
    // Print error message if we have a bad status.
    //
    if (!NT_SUCCESS(ntStatus)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "Could not open win9x signature file %ws [Nt Status: %u (%x)]\n",
            tempBuffer,ntStatus,ntStatus));
    }


    return sigFileDrive == DriveToMatch;
}

VOID
SpAssignOtherDriveLettersToMatchWin9x(
    IN PWIN9XDRIVELETTERINFO    Win9xOtherDrives
    )
{
    PWIN9XDRIVELETTERINFO   curDrive;

    if (IsNEC_98) {

    WCHAR                 openPath[MAX_PATH+1];
    HANDLE                fdHandle;
    DWORD                 numberOfFloppys;
    OBJECT_ATTRIBUTES     objectAttributes;
    UNICODE_STRING        unicodeString;
    IO_STATUS_BLOCK       ioStatusBlock;
    NTSTATUS              openStatus;
    NTSTATUS              status;
    DWORD                 index, i;
    PWIN9XDRIVELETTERINFO pOtherDrives[NUMDRIVELETTERS];

    //
    // Encount number of floppy device.
    //
    numberOfFloppys = 0;
    do {
        swprintf(openPath,L"\\device\\floppy%u",numberOfFloppys);

        INIT_OBJA(&objectAttributes,&unicodeString,openPath);

        openStatus = ZwCreateFile(
        &fdHandle,
        SYNCHRONIZE | FILE_READ_ATTRIBUTES,
        &objectAttributes,
        &ioStatusBlock,
        NULL,                           // allocation size
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_VALID_FLAGS,         // full sharing
        FILE_OPEN,
        FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,                           // no EAs
        0
        );

        if(NT_SUCCESS(openStatus)) {

        //
        // Increment count of CdRoms and close this handle.
        //
        numberOfFloppys++;
        ZwClose(fdHandle);

        } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open handle to %ws. %u (%x)\n",openPath,openStatus,openStatus));
        }
    } while (numberOfFloppys < NUMDRIVELETTERS && NT_SUCCESS(openStatus));


    //
    // At first, initialize temporary array.
    //
    for (i = 0;i < NUMDRIVELETTERS; i++) {
        pOtherDrives[i] = NULL;
    }

    for (curDrive = Win9xOtherDrives;curDrive;curDrive = curDrive -> Next) {
        pOtherDrives[curDrive -> Drive] = curDrive;
    }

    //
    // Map floppy letter from begining of OtherDrives.
    // On Win9x, floppy letter should be assigned before the other removables.
    //
    index = 0;
    for (i = 0;i < NUMDRIVELETTERS; i++) {
        if (index < numberOfFloppys) {
        if (pOtherDrives[i]) {

            //
            // Need to map the floppys.
            // It will be migrated by ftdisk.sys.
            //
            swprintf(openPath,L"\\device\\floppy%u",index);

            //
            // We use SpDiskRegistryAssignCdRomLetter() for map Floppy Letter too.
            //
            status = SpDiskRegistryAssignCdRomLetter(
            openPath,
                (WCHAR) ((WCHAR) (pOtherDrives[i] -> Drive) + L'A')
            );

            index++;
        }

        } else {
        break;
        }
    }

    }

    for (curDrive = Win9xOtherDrives;curDrive;curDrive = curDrive -> Next) {
        //
        // Simply reserve the drive letter.
        //
        g_DriveLetters[curDrive -> Drive] = TRUE;

    }

}

VOID
SpAssignCdRomDriveLettersToMatchWin9x(
    IN PWIN9XDRIVELETTERINFO  Win9xCdRoms
    )
{
    PWIN9XDRIVELETTERINFO curDrive;
    SCSI_ADDRESS          win9xAddress;
    SCSI_ADDRESS          ntCdAddresses[NUMDRIVELETTERS];
    BOOL                  cdMapped[NUMDRIVELETTERS];
    PWSTR                 curIdPtr;
    WCHAR                 openPath[MAX_PATH+1];
    HANDLE                cdHandle;
    INT                   numberOfCdRoms;
    OBJECT_ATTRIBUTES     objectAttributes;
    UNICODE_STRING        unicodeString;
    IO_STATUS_BLOCK       ioStatusBlock;
    NTSTATUS              openStatus;
    NTSTATUS              readStatus;
    NTSTATUS              status;
    INT                   index;

    //
    // Clear out the ntCdDescriptions structure.
    //
    RtlZeroMemory(ntCdAddresses,sizeof(ntCdAddresses));
    RtlZeroMemory(cdMapped,sizeof(cdMapped));

    //
    // gather scsi cdrom data.
    //
    numberOfCdRoms = 0;

    for (index=0, openStatus=STATUS_SUCCESS;
        ((index < NUMDRIVELETTERS) && NT_SUCCESS(openStatus));
        index++) {

        swprintf(openPath,L"\\device\\cdrom%u",index);

        INIT_OBJA(&objectAttributes,&unicodeString,openPath);

        openStatus = ZwCreateFile(
                        &cdHandle,
                        SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                        &objectAttributes,
                        &ioStatusBlock,
                        NULL,                           // allocation size
                        FILE_ATTRIBUTE_NORMAL,
                        FILE_SHARE_VALID_FLAGS,         // full sharing
                        FILE_OPEN,
                        FILE_SYNCHRONOUS_IO_NONALERT,
                        NULL,                           // no EAs
                        0
                        );

        if(NT_SUCCESS(openStatus)) {

            //
            // Successfully opened a handle to the device, now, get the address information.
            //
            readStatus = ZwDeviceIoControlFile(
                            cdHandle,
                            NULL,
                            NULL,
                            NULL,
                            &ioStatusBlock,
                            IOCTL_SCSI_GET_ADDRESS,
                            NULL,
                            0,
                            &(ntCdAddresses[numberOfCdRoms]),
                            sizeof(SCSI_ADDRESS)
                            );

            if(!NT_SUCCESS(readStatus)) {
                KdPrintEx((DPFLTR_SETUP_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SETUP: Unable to get scsi address info for cd-rom %u (%x)\n",
                    index,
                    readStatus));
            }

            //
            // Increment count of CdRoms
            //
            numberOfCdRoms++;

            ZwClose(cdHandle);
        } else {
            KdPrintEx((DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "SETUP: Unable to open handle to %ws. (%x)\n",
                openPath,
                openStatus));
        }
    }

    //
    // if we didn't find any CD-ROMs we have nothing to do
    //
    if (!numberOfCdRoms) {
        return;
    }

    //
    // Now, fill in a similar array of win9x drives..
    //
    for (curDrive = Win9xCdRoms;curDrive;curDrive = curDrive -> Next) {

        //
        // assume the drive is not mapped
        //
        curDrive -> StatusFlag = TRUE;

        //
        // Check to see if this is a SCSI device.
        //
        if (curDrive -> Identifier) {
            curIdPtr = (PWSTR) curDrive -> Identifier;

            //
            // Collect the Win9x Address data.
            //
            win9xAddress.PortNumber = (UCHAR) Spwtoi(curIdPtr);
            curIdPtr = wcschr(curIdPtr,L'^');
            curIdPtr++;
            win9xAddress.TargetId   = (UCHAR) Spwtoi(curIdPtr);
            curIdPtr = wcschr(curIdPtr,L'^');
            curIdPtr++;
            win9xAddress.Lun        = (UCHAR) Spwtoi(curIdPtr);

            //
            // Now, loop through SCSI CD-Roms until a matching one is found.
            //
            for (index = 0; index < numberOfCdRoms; index++) {
                if(!ntCdAddresses[index].Length){
                    continue;
                }

                if (win9xAddress.PortNumber == ntCdAddresses[index].PortNumber &&
                    win9xAddress.TargetId   == ntCdAddresses[index].TargetId   &&
                    win9xAddress.Lun        == ntCdAddresses[index].Lun) {

                    if (cdMapped[index]) {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Error: \\device\\cdrom%u already mapped..ignored.\n",index));
                    }

                    //
                    // Map the cdrom.
                    //
                    swprintf(openPath,L"\\device\\cdrom%u",index);

                    status = SpDiskRegistryAssignCdRomLetter(
                        openPath,
                        (WCHAR) ((WCHAR) (curDrive -> Drive) + L'A')
                        );

                    g_DriveLetters[curDrive -> Drive] = TRUE;
                    cdMapped[index] = TRUE;
                    curDrive -> StatusFlag = FALSE;

                    break;
                }
            }
        } else {
            curDrive -> StatusFlag = TRUE;
        }
    }

    index = numberOfCdRoms - 1;
    for (curDrive = Win9xCdRoms;curDrive;curDrive = curDrive -> Next) {

        //
        // If we haven't found a direct map yet, we'll any remaining drives.. This fixes the
        // single IDE cdrom case. It could result in some reordering in multiple IDE CDRom
        // systems. Still, this is the best we can do here.
        //

        if (curDrive -> StatusFlag) {

            while (index >= 0 && cdMapped[index] == TRUE) {
                index--;
            }

            if (index < 0){
                break;
            }

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Forcing Win9x CDRom Mapping for \\device\\cdrom%u, even though a direct match was not found.\n",index));
            swprintf(openPath,L"\\device\\cdrom%u",index);

            status = SpDiskRegistryAssignCdRomLetter(
                openPath,
                (WCHAR) ((WCHAR) (curDrive -> Drive) + L'A')
                );

            g_DriveLetters[curDrive -> Drive] = TRUE;
            cdMapped[index] = TRUE;
            index--;
        }
    }
}

VOID
SpAssignHardDriveLettersToMatchWin9x (
    IN PWIN9XDRIVELETTERINFO    Win9xHardDrives
    )
{
    PWIN9XDRIVELETTERINFO   win9xDrive;
    DWORD                   diskIndex;
    PDISK_REGION            region;
    PPARTITIONED_DISK       disk;
    DWORD                   numMatchingRegions;
    PDISK_REGION            matchingRegion;

    //
    // Clear all partition drive letter informations.
    // Note: This was copypasted from sppartit.c:SpGuessDriveLetters()
    //
    for(diskIndex=0; diskIndex<HardDiskCount; diskIndex++) {
        for(region=PartitionedDisks[diskIndex].PrimaryDiskRegions; region; region=region->Next) {
            region->DriveLetter = 0;
        }
        for(region=PartitionedDisks[diskIndex].ExtendedDiskRegions; region; region=region->Next) {
            region->DriveLetter = 0;
        }
    }

    //
    // Iterate through the drives found in the winnt.sif file.
    //
    for (win9xDrive = Win9xHardDrives; win9xDrive; win9xDrive = win9xDrive -> Next) {


        //
        // find the partition that matches that drive.
        //
        numMatchingRegions      = 0;
        matchingRegion          = NULL;

        for(diskIndex=0; diskIndex<HardDiskCount; diskIndex++) {

            disk = &PartitionedDisks[diskIndex];

            //
            // First, search through primary disk regions.
            //
            region = SpFirstPartitionedRegion(PartitionedDisks[diskIndex].PrimaryDiskRegions, TRUE);

            while(region) {

                if (SpCheckRegionForMatchWithWin9xData(region,win9xDrive -> Drive)) {

                    if (!matchingRegion) {
                        matchingRegion              = region;
                    }
                    numMatchingRegions++;
                }

                region = SpNextPartitionedRegion(region, TRUE);
            }

            //
            // Then, search through secondary disk regions.
            //
            region = SpFirstPartitionedRegion(PartitionedDisks[diskIndex].PrimaryDiskRegions, FALSE);

            while(region) {

                if (SpCheckRegionForMatchWithWin9xData(region,win9xDrive -> Drive)) {

                    if (!matchingRegion) {

                        matchingRegion          = region;
                    }
                    numMatchingRegions++;
                }

                region = SpNextPartitionedRegion(region, FALSE);
            }
        }

        if (numMatchingRegions == 1) {

            //
            // Found what we were looking for. Assign the win9x Drive letter
            // to this region.
            //
            matchingRegion -> DriveLetter = L'A' + (WCHAR) win9xDrive -> Drive;
            g_DriveLetters[win9xDrive -> Drive] = TRUE;

        }
        else if (numMatchingRegions > 1) {

            //
            // We are in trouble. print an error.
            //
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: More than one drive matches Win9x drive.\n"));
        } else {

            //
            // Big trouble. No regions matched the data collected on Windows 95.
            //
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not find a drive matching Win9x.\n"));
        }

    }

}

VOID
SpRegisterHardDriveLetters (
    VOID
    )
{

    BOOL                rf;
    PDISK_REGION        curRegion;
    BOOL                wasExtended;
    DWORD               diskIndex;
    PPARTITIONED_DISK   disk;
    LARGE_INTEGER       startingOffset;
    LARGE_INTEGER       length;
    UCHAR               driveLetter;

    for(diskIndex=0; diskIndex<HardDiskCount; diskIndex++) {


        disk = &PartitionedDisks[diskIndex];

        //
        // Skip removable media. If a disk is off-line it's hard to imagine
        // that we'll actually have any partitioned spaces on it so
        // we don't do any special checks here for that condition.
        //
        if(!(disk->HardDisk->Characteristics & FILE_REMOVABLE_MEDIA)) {

            //
            // First, do all of the primary disk regions for this disk.
            //
            curRegion = SpFirstPartitionedRegion(PartitionedDisks[diskIndex].PrimaryDiskRegions, TRUE);

            while(curRegion) {
                //
                // We only care about partitioned spaces that have drive letters.
                //
                if(curRegion->PartitionedSpace && curRegion -> DriveLetter) {

                    //
                    // Collect information needed for call to DiskRegistryAssignDriveLetter
                    //
                    SpGetPartitionStartingOffsetAndLength(
                        diskIndex,
                        curRegion,
                        FALSE,
                        &startingOffset,
                        &length
                        );


                    driveLetter = (UCHAR) ('A' + (curRegion -> DriveLetter - L'A'));

                    rf = SpDiskRegistryAssignDriveLetter(
                        disk -> HardDisk -> Signature,
                        startingOffset,
                        length,
                        driveLetter
                        );

                    if (!rf) {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: DiskRegistryAssignDriveLetter call failed.\n"));

                    }
                    else {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Added sticky letter %c to Disk Registry.\n",driveLetter));
                    }

                }


                curRegion = SpNextPartitionedRegion(curRegion, TRUE);
            }

            //
            // Now, do all of the extended disk regions.
            //
            curRegion = SpFirstPartitionedRegion(PartitionedDisks[diskIndex].PrimaryDiskRegions, FALSE);

            while(curRegion) {
                //
                // We only care about partitioned spaces that have drive letters.
                //
                if(curRegion->PartitionedSpace && curRegion -> DriveLetter) {

                    //
                    // Collect information needed for call to DiskRegistryAssignDriveLetter
                    //
                    SpGetPartitionStartingOffsetAndLength(
                        diskIndex,
                        curRegion,
                        TRUE,
                        &startingOffset,
                        &length
                        );


                    driveLetter = (UCHAR) ('A' + (curRegion -> DriveLetter - L'A'));

                    rf = SpDiskRegistryAssignDriveLetter(
                        disk -> HardDisk -> Signature,
                        startingOffset,
                        length,
                        driveLetter
                        );

                    if (!rf) {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: DiskRegistryAssignDriveLetter call failed.\n"));

                    }
                    else {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Added sticky letter %c to Disk Registry.\n",driveLetter));
                    }

                }

                curRegion = SpNextPartitionedRegion(curRegion, FALSE);
            }

        }
    }
}


#define WIN9XHARDDRIVES    0
#define WIN9XCDROMS        1
#define WIN9XOTHERS        2
#define WIN9XNUMDRIVETYPES 3

VOID
SpAssignDriveLettersToMatchWin9x (
    IN PVOID        WinntSif
    )
{
    PWIN9XDRIVELETTERINFO   win9xDrive                      = NULL;
    PWIN9XDRIVELETTERINFO   win9xDrives[WIN9XNUMDRIVETYPES];

    DWORD                   index;
    DWORD                   lineCount;
    PWSTR                   driveString;
    PWSTR                   dataString;
    PWSTR                   curString;

    DWORD                   drive;
    DWORD                   type;
    DWORD                   driveType;


    //
    // Read in the data on hard disks that was collected during the Detection
    // phase of Win95 setup. This data is stored in the winnt.sif file
    // in the [Win9x.DriveLetterInfo] section.
    lineCount = SpCountLinesInSection(WinntSif,WINNT_D_WIN9XDRIVES_W);

    if (!lineCount) {
        //
        // No information in the winnt.sif file, so nothing to do. Get out of here early.
        //
        return;
    }

    //
    // build Disk Registry information. This will be used to store
    // sticky drive letters.
    //
    SpBuildDiskRegistry();

    //
    // Build a list of usable drive letters. All drive letters should be
    // initially usable exceptr for 'A' and 'B'
    // For NEC98, hard drive letter usually assigned from 'A'.
    // So we don't set TRUE in that case.
    //
    RtlZeroMemory(g_DriveLetters,sizeof(g_DriveLetters));
    if( !IsNEC_98 || !DriveAssignFromA) {
        g_DriveLetters[0] = g_DriveLetters[1] = TRUE;
    }

    RtlZeroMemory(win9xDrives,sizeof(win9xDrives));

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Win9x Drive Letters to map: %u\n", lineCount));

    for (index = 0;index < lineCount; index++) {

        //
        // The Drive Number is in the key.
        //

        driveString = SpGetKeyName (
            WinntSif,
            WINNT_D_WIN9XDRIVES_W,
            index
            );

        //
        // This conditional _should_ always be true. but, just in case..
        //
        if (driveString) {

            drive = Spwtoi(driveString);

            //
            // Now, get the type of this drive.
            //
            dataString = SpGetSectionKeyIndex (
                WinntSif,
                WINNT_D_WIN9XDRIVES_W,
                driveString,
                0
                );

            if (dataString) {

                curString = dataString;

                if (*curString != L',') {
                    type = Spwtoi(curString);
                }

                //
                // Advance dataString to the start of the identifier string.
                //
                curString = wcschr(curString,L',');
                if (curString) {

                    //
                    // Pass the ','
                    //
                    *curString++;
                }
            }
            else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not retrieve type for Win9x drive %ws\n",driveString));

                type = DOSDEVICE_DRIVE_UNKNOWN;
            }


            //
            // Now, add this drive to the list of win9x drives that we are
            // dealing with.
            //
            win9xDrive = SpMemAlloc(sizeof(WIN9XDRIVELETTERINFO));

            if (win9xDrive) {

                //
                // assign all of the gathered data.
                //
                win9xDrive -> Drive         = drive;
                win9xDrive -> Type          = type;
                win9xDrive -> Identifier    = curString;

                //
                // place this drive into the list of drives of its type.
                //
                switch (type) {
                case DOSDEVICE_DRIVE_FIXED:
                    driveType = WIN9XHARDDRIVES;
                    break;
                case DOSDEVICE_DRIVE_CDROM:
                    driveType = WIN9XCDROMS;
                    break;
                default:
                    driveType = WIN9XOTHERS;
                    break;
                }

                win9xDrive -> Next      = win9xDrives[driveType];
                win9xDrives[driveType]  = win9xDrive;

            }
            else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not allocate memory for Win9x drive letter information.\n"));

                //
                // No use sticking around.
                //
                goto c0;
            }

        }
        else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not find drive string in winnt.sif line.\n"));
            goto c0;
        }

    }

    //
    // First, and most importantly, assign the drive letters for hard disks.
    // If this is done incorrectly, setup may fail.
    //
    if (win9xDrives[WIN9XHARDDRIVES]) {
        SpAssignHardDriveLettersToMatchWin9x (win9xDrives[WIN9XHARDDRIVES]);
    }

    //
    // Secondly, assign drive letters for any CD-Roms.
    //
    if (win9xDrives[WIN9XCDROMS]) {
        SpAssignCdRomDriveLettersToMatchWin9x(win9xDrives[WIN9XCDROMS]);
    }

    //
    // Third, if possible, assign drive letters for other devices.
    //
    if (win9xDrives[WIN9XOTHERS]) {
        SpAssignOtherDriveLettersToMatchWin9x(win9xDrives[WIN9XOTHERS]);
    }

    //
    // Assign drive letters for any HDD partitions that have not been
    // previously mapped. (These are drives unknown to Win9x.)
    //

    SpAssignDriveLettersToRemainingPartitions();

    //
    // Now, write all hard drive information into the disk registry.
    //
    SpRegisterHardDriveLetters();

c0:
    ;

}

VOID
SpWin9xOverrideGuiModeCodePage (
    HKEY NlsRegKey
    )
{
    PWSTR data;
    NTSTATUS status;
    WCHAR fileName[MAX_PATH];


    data = SpGetSectionKeyIndex (
                WinntSifHandle,
                SIF_DATA,
                WINNT_D_GUICODEPAGEOVERRIDE_W,
                0
                );

    if (!data) {
        //
        // Nothing to do.
        //
        return;
    }

    wcscpy (fileName, L"c_");
    wcscat (fileName, data);
    wcscat (fileName, L".nls");

    status = SpOpenSetValueAndClose (NlsRegKey, L"CodePage", data, STRING_VALUE(fileName));

    if(!NT_SUCCESS(status)) {
       KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "Setup: Unable to override the code page for GUI mode. Some strings may be incorrect.\n"));
       return;
    }


    status = SpOpenSetValueAndClose (NlsRegKey, L"CodePage", L"Acp", STRING_VALUE(data));

    if(!NT_SUCCESS(status)) {
       KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "Setup: Unable to override the ACP for GUI mode. Some strings may be incorrect.\n"));
       return;
    }

}

BOOLEAN
SpIsWindowsUpgrade(
    IN PVOID    SifFileHandle
    )
/*++

Routine Description:

    Determines whether we are upgrading Windows 3.x or Windows 9x.

Arguments:

    SifFileHandle : Handle to WINNT.SIF file which has
    the appropriate 3.x/9x upgrade flag value

Return Value:

    TRUE    : if upgrading Windows 3.x or 9X
    FALSE   : otherwise

--*/
{
    BOOLEAN         Result = FALSE;
    PWSTR           Value = 0;

    Value = SpGetSectionKeyIndex(SifFileHandle, SIF_DATA,
                    WINNT_D_WIN95UPGRADE_W, 0);

    if (!Value) {
        Value = SpGetSectionKeyIndex(SifFileHandle, SIF_DATA,
                        WINNT_D_WIN31UPGRADE_W, 0);
    }

    if (Value)
        Result = (_wcsicmp(Value, WINNT_A_YES_W) == 0);

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\i386\win31upg.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    win31upg.c

Abstract:

    Code for checking install into an existing win31 directory.  This is
    only relevant on non ARC machines since Windows NT doesn't allow
    installation of Windows 3.1, therefore DOS is needed to install
    Windows 3.1.

    The Windows 3.1 directory can only exist on FAT volumes.  However
    in the functions below we take care of this fact only implicitly
    by taking advantage of the fact that since the volumes are not
    cached, any file operation below will fail if it is on a non FAT
    volume.

Author:

    Sunil Pai (sunilp) Nov-1992

Revision History:

    Ted Miller (tedm) Sep-1993
        - reworked for new text setup.

--*/


#include "spprecmp.h"
#pragma hdrstop

// in win9xupg.c
BOOLEAN
SpIsWin9xMsdosSys(
    IN PDISK_REGION Region,
    OUT PSTR*       Win9xPath
    );

BOOLEAN
SpIsDosConfigSys(
    IN PDISK_REGION Region
    );

PUCHAR
SpGetDosPath(
    IN PDISK_REGION Region
    );

BOOLEAN
SpIsWin31Dir(
    IN PDISK_REGION Region,
    IN PWSTR        PathComponent,
    IN ULONG        MinKB
    );

VOID
SpWin31DriveFull(
    IN PDISK_REGION Region,
    IN PWSTR        DosPathComponent,
    IN ULONG        MinKB
    );

BOOLEAN
SpConfirmWin31Upgrade(
    IN PDISK_REGION Region,
    IN PWSTR        DosPathComponent
    );

WCHAR
SpExtractDriveLetter(
    IN PWSTR PathComponent
    );

extern BOOLEAN DriveAssignFromA; //NEC98

BOOLEAN
SpLocateWin31(
    IN  PVOID         SifHandle,
    OUT PDISK_REGION *InstallRegion,
    OUT PWSTR        *InstallPath,
    OUT PDISK_REGION *SystemPartitionRegion
    )

/*++

Routine Description:

    High level function to determine whether a windows directory exists
    and whether to install into that directory.  Win31 directories
    can only be on FAT volumes.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    InstallRegion - if this routine returns TRUE, then this returns a pointer
        to the region to install to.

    InstallPath - if this routine returns TRUE, then this returns a pointer
        to a buffer containing the path on the partition to install to.
        The caller must free this buffer with SpMemFree().

    SystemPartitionRegion - if this routine returns TRUE, then this returns
        a pointer to the region for the system partition (ie, C:).

Return Value:

    TRUE if we are going to install into a win3.1 directory.
    FALSE otherwise.

--*/
{
    PDISK_REGION CColonRegion;
    PDISK_REGION Region;
    PDISK_REGION FoundRegion;
    PUCHAR DosPath;
    PWSTR FoundComponent;
    PWSTR *DosPathComponents;
    ULONG ComponentCount;
    ULONG i,j,pass;
    ULONG MinKB;
    BOOLEAN NoSpace;
    ULONG Space;
    BOOLEAN StartsWithDriveLetter;

    WCHAR chDeviceName[128]; //NEC98

    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_LOOKING_FOR_WIN31,DEFAULT_STATUS_ATTRIBUTE);

    if (!IsNEC_98) { //NEC98
        //
        // See if there is a valid C: already.  If not, then silently fail.
        //
        CColonRegion = SpPtValidSystemPartition();
        if(!CColonRegion) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: no C:, no windows 3.1!\n"));
            return(FALSE);
        }

        //
        // This is the system partition.
        //
        *SystemPartitionRegion = CColonRegion;

        //
        // Check the filesystem.  If not FAT, then silently fail.
        //
        if(CColonRegion->Filesystem != FilesystemFat) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: C: is not FAT, no windows 3.1!\n"));
            return(FALSE);
        }

        //
        // Check to see if there is enough free space, etc on C:.
        // If not, silently fail.
        //
        if(!SpPtValidateCColonFormat(SifHandle,NULL,CColonRegion,TRUE,NULL,NULL)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: C: not acceptable, no windows 3.1!\n"));
            return(FALSE);
        }
    } else { //NEC98
        //
        // Don'y see only C: on PC98.
        //
        CColonRegion = NULL;
    } //NEC98

    if (!IsNEC_98) { //NEC98
        //
        // Don't confuse Win95 with Win3.1 - we're looking only for Win3.1
        //

        if(SpIsWin9xMsdosSys(CColonRegion, &DosPath) )
            return(FALSE);

        //
        // Determine whether config.sys is for DOS.
        //
        if(!SpIsDosConfigSys(CColonRegion)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: config.sys not DOS; no windows 3.1!\n"));
            return(FALSE);
        }

        //
        // Get the DOS path.
        //
        DosPath = SpGetDosPath(CColonRegion);
    } else { //NEC98
        DosPath = NULL;
        wcscpy(chDeviceName+1,L":");
        for (i=0; i<(L'Z'-L'A'); i++) {
            chDeviceName[0] = (WCHAR)('A' + i);
            CColonRegion = SpRegionFromDosName(chDeviceName);
            if ( CColonRegion ) {

                if ( (CColonRegion->Filesystem != FilesystemFat) ||
                     (SpIsWin9xMsdosSys(CColonRegion, &DosPath) ) ||
                     (!SpIsDosConfigSys(CColonRegion)) ) {
                    continue;
                }

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: found config.sys on %s\n", chDeviceName));
                DosPath = SpGetDosPath(CColonRegion);
                if (DosPath) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: found dos path on %s\n", chDeviceName));
                    break;
                }
            }
        }
    } //NEC98
    if(!DosPath) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: no dos path; no windows 3.1!\n"));
        return(FALSE);
    }

    //
    // Break up the DOS path into components.
    //
    SpGetEnvVarWComponents(DosPath,&DosPathComponents,&ComponentCount);
    if(!ComponentCount) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: no components in dos path\n"));
        //
        // data structure still built even if no components
        //
        SpFreeEnvVarComponents(DosPathComponents);
        return(FALSE);
    }

    //
    // Search each one of the components and check to see if it is
    // a windows directory
    //
    FoundRegion = NULL;
    for(i=0; DosPathComponents[i] && !FoundRegion; i++) {

        Region = SpPathComponentToRegion(DosPathComponents[i]);
        if(Region) {

            //
            // Fetch the amount of free space required on the windows nt drive.
            //
            SpFetchDiskSpaceRequirements( SifHandle,
                                          Region->BytesPerCluster,
                                          &MinKB,
                                          NULL);

            //
            // See whether windows is in this directory on
            // the drive.
            //
            if(SpIsWin31Dir(Region,DosPathComponents[i],MinKB)) {

                FoundRegion = Region;
                FoundComponent = DosPathComponents[i];
            }
        }
    }

    //
    // The drive letters we are using in NT will not always match
    // those in use by DOS.  So if we have not found the windows directory
    // yet, then try using every path component on every drive.
    //

    if(!FoundRegion) {

        for(i=0; i<HardDiskCount && !FoundRegion; i++) {

            for(pass=0; pass<2; pass++) {

                for( Region= (   pass
                               ? PartitionedDisks[i].ExtendedDiskRegions
                               : PartitionedDisks[i].PrimaryDiskRegions
                             );
                     Region;
                     Region=Region->Next
                   )
                {
                    for(j=0; DosPathComponents[j] && !FoundRegion; j++) {

                        //
                        // Fetch the amount of free space required on the windows nt drive.
                        //
                        SpFetchDiskSpaceRequirements( SifHandle,
                                                      Region->BytesPerCluster,
                                                      &MinKB,
                                                      NULL);

                        if(SpIsWin31Dir(Region,DosPathComponents[j],MinKB)) {

                            FoundRegion = Region;
                            FoundComponent = DosPathComponents[j];
                        }
                    }
                }
            }
        }
    }

    //
    // If directory has been found, check space on the drive and and the
    // user if he wants to install into the directory.
    //

    if(FoundRegion) {

        StartsWithDriveLetter = (BOOLEAN)(SpExtractDriveLetter(FoundComponent) != 0);

        recheck:

        NoSpace = FALSE;

        if(FoundRegion->AdjustedFreeSpaceKB < MinKB) {

            //
            // There is not enough free space on this drive.
            // Determine if NT is there already.  If so, we will
            // allow the user to remove to it make room.
            //

            if(SpIsNtOnPartition(FoundRegion)) {

                NoSpace = TRUE;

            } else {

                //
                // NT not there, no space, bail.
                //
                SpWin31DriveFull(FoundRegion,FoundComponent,MinKB);
                FoundRegion = NULL;
            }
        } else {
            //
            // There is enough free space, so just continue on.
            //
            ;
        }

        if(FoundRegion) {

            //
            // Ask the user if he wishes to install into this path.
            // If not, exit this routine.
            //
            if(SpConfirmWin31Upgrade(FoundRegion,FoundComponent)) {

                //
                // He wants to install into win3.1.  If there's not enough space,
                // he'll have to delete nt installations first.
                //
                if(NoSpace) {

                    WCHAR DriveSpec[3];
                    BOOLEAN b;

                    if(StartsWithDriveLetter) {
                        DriveSpec[0] = FoundComponent[0];
                        DriveSpec[1] = L':';
                        DriveSpec[2] = 0;
                    }

                    b = SpAllowRemoveNt(
                            FoundRegion,
                            StartsWithDriveLetter ? DriveSpec : NULL,
                            TRUE,
                            SP_SCRN_REMOVE_NT_FILES_WIN31,
                            &Space
                            );

                    if(b) {

                        Region->FreeSpaceKB += Space/1024;
                        Region->AdjustedFreeSpaceKB += Space/1024;
                        //
                        // Account for rounding error.
                        //
                        if((Space % 1024) >= 512) {
                            (Region->FreeSpaceKB)++;
                            (Region->AdjustedFreeSpaceKB)++;
                        }
                        goto recheck;
                    } else {
                        FoundRegion = NULL;
                    }
                } else {
                    //
                    // There is enough space.  Accept this partition.
                    //
                    ;
                }
            } else {
                FoundRegion = NULL;
            }
        }

        //
        // Do the disk configuration needed
        //
        if(FoundRegion) {
            if (!IsNEC_98) { //NEC98
                SpPtMakeRegionActive(CColonRegion);
                SpPtDoCommitChanges();
            } else {
                *SystemPartitionRegion = FoundRegion;
            } //NEC98

            *InstallRegion = FoundRegion;

            *InstallPath = SpDupStringW(FoundComponent+(StartsWithDriveLetter ? 2 : 0));

            ASSERT(*InstallPath);
        }
    }

    SpMemFree(DosPath);
    SpFreeEnvVarComponents(DosPathComponents);

    return((BOOLEAN)(FoundRegion != NULL));
}



VOID
SpWin31DriveFull(
    IN PDISK_REGION Region,
    IN PWSTR        DosPathComponent,
    IN ULONG        MinKB
    )

/*++

Routine Description:

    Inform a user that Setup has found a previous Windows installation
    but is unable to install into the same path because the drive is too
    full.  The user has the option to continue on and specify a new path
    or exit and create enough space.

Arguments:

Return Value:

    None.  Function doesn't return if the user chooses to exit setup at
    this point.  If the function returns, it is implicit that the user
    wants to continue on and specify a new path for Microsoft Windows NT.

--*/

{
    ULONG ValidKeys[3] = { KEY_F3,ASCI_CR,0 };

    ASSERT(Region->PartitionedSpace);

    while(1) {

        SpStartScreen(
            SP_SCRN_WIN31_DRIVE_FULL,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            //NEC98: Win3.x for NEC must be assign hard drive from A:
            ((!IsNEC_98 || DriveAssignFromA || (Region->DriveLetter < L'C'))
             ? Region->DriveLetter :
               Region->DriveLetter - 2),
            DosPathComponent + (SpExtractDriveLetter(DosPathComponent) ? 2 : 0),
            MinKB/1024
            );

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_F3_EQUALS_EXIT,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            0
            );

        switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {

        case KEY_F3:
            SpConfirmExit();
            break;
        case ASCI_CR:
            //
            // User wants to continue.
            //
            return;
        }
    }
}


BOOLEAN
SpConfirmWin31Upgrade(
    IN PDISK_REGION Region,
    IN PWSTR        DosPathComponent
    )

/*++

Routine Description:

    Inform a user that Setup has found a previous Windows installation.
    The user has the option to continue on and specify a new path
    or accept the windows 3.1 path.

Arguments:

Return Value:

    TRUE if the user wants to upgrade win3.1, FALSE if he wants
    to select a new path.

--*/

{
    ULONG ValidKeys[3] = { KEY_F3,ASCI_CR,0 };
    ULONG Mnemonics[2] = { MnemonicNewPath,0 };

    ASSERT(Region->PartitionedSpace);

    if(UnattendedOperation) {

        PWSTR p;

        p = SpGetSectionKeyIndex(UnattendedSifHandle,SIF_UNATTENDED,L"Win31Upgrade",0);
        if(p) {
            if(!_wcsicmp(p,L"yes")) {
                return(TRUE);
            } else {
                if(!_wcsicmp(p,L"no")) {
                    return(FALSE);
                }
                // bogus value; user gets attended behavior.
            }
        } else {
            //
            // Not specified; default to no.
            //
            return(FALSE);
        }
    }

    while(1) {

        SpStartScreen(
            SP_SCRN_WIN31_UPGRADE,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE,
            //NEC98: Win3.x for NEC must be assign hard drive from A:
            ((!IsNEC_98 || DriveAssignFromA || (Region->DriveLetter < L'C'))
             ? Region->DriveLetter :
               Region->DriveLetter - 2),
            DosPathComponent + (SpExtractDriveLetter(DosPathComponent) ? 2 : 0)
            );

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_F3_EQUALS_EXIT,
            SP_STAT_ENTER_EQUALS_CONTINUE,
            SP_STAT_N_EQUALS_NEW_PATH,
            0
            );

        switch(SpWaitValidKey(ValidKeys,NULL,Mnemonics)) {

        case KEY_F3:
            SpConfirmExit();
            break;
        case ASCI_CR:
            return(TRUE);
        default:
            //
            // Must have chosen n for new path.
            //
            return(FALSE);
        }
    }
}


BOOLEAN
SpConfirmRemoveWin31(
    VOID
    )

/*++

Routine Description:

    Upgrading NT case:

        Tell the user that the NT he is upgrading is coexistent with the
        win31 path. Since this will remove Win3.1, confirm that this is OK.
        The options are to continue, which removes Win31, or exit setup.

    Not upgrading NT case:

        Tell the user that the path he entered is also the win31 dir.
        Since installing NT in there will remove Win31, confirm that this
        is OK. The options are to continue the win31 upgrade, exit setup,
        or choose a dofferent location.

Arguments:

Return Value:

    TRUE if the user wants to upgrade win3.1, FALSE if he wants
    to select a new path.

--*/

{
    ULONG ValidKeys[4] = { KEY_F3,0 };
    ULONG Mnemonics[3] = { MnemonicUpgrade,0,0 };
    ULONG c;

    if(NTUpgrade != UpgradeFull) {
        Mnemonics[1] = MnemonicNewPath;
    }

    while(1) {

        SpStartScreen(
            SP_SCRN_WIN31_REMOVE,
            3,
            HEADER_HEIGHT+1,
            FALSE,
            FALSE,
            DEFAULT_ATTRIBUTE
            );

        SpDisplayStatusOptions(
            DEFAULT_STATUS_ATTRIBUTE,
            SP_STAT_F3_EQUALS_EXIT,
            SP_STAT_U_EQUALS_UPGRADE,
            0,
            0
            );

        if((c = SpWaitValidKey(ValidKeys,NULL,Mnemonics)) == KEY_F3) {
            SpConfirmExit();
        } else {
            c &= ~KEY_MNEMONIC;
            if(c == MnemonicUpgrade) {
                return(TRUE);
            }
            // new path
            return(FALSE);
        }
    }
}


BOOLEAN
SpIsWin31Dir(
    IN PDISK_REGION Region,
    IN PWSTR        PathComponent,
    IN ULONG        MinKB
    )
/*++

Routine Description:

    To find out if the directory indicated on the region contains a
    Microsoft Windows 3.x installation.

Arguments:

    Region - supplies pointer to disk region descriptor for region
        containing the directory to be checked.

    PathComponent - supplies a component of the dos path to search
        on the region.  This is assumes to be in the form x:\dir.
        If it is not in this form, this routine will fail.

    MinKB - supplies the minimum size of the partition in KB.
        If the partition is not at least this large, then this
        routine will return false.

Return Value:

    TRUE if this path contains a Microsoft Windows 3.x installation.

    FALSE otherwise.

--*/
{
    PWSTR files[] = { L"WIN.COM", L"WIN.INI", L"SYSTEM.INI" };
    PWCHAR OpenPath;
    ULONG SizeKB;
    ULONG remainder;
    BOOLEAN rc;
    LARGE_INTEGER temp;

    //
    // Assume failure.
    //
    rc = FALSE;

    //
    // If the partition is not FAT, then ignore it.
    //
    if(Region->PartitionedSpace && (Region->Filesystem == FilesystemFat)) {

        //
        // If the partition is not large enough, ignore it.
        // Calculate the size of the partition in KB.
        //
        temp.QuadPart = UInt32x32To64(
                            Region->SectorCount,
                            HardDisks[Region->DiskNumber].Geometry.BytesPerSector
                            );

        SizeKB = RtlExtendedLargeIntegerDivide(temp,1024,&remainder).LowPart;

        if(remainder >= 512) {
            SizeKB++;
        }

        if(SizeKB >= MinKB) {

            OpenPath = SpMemAlloc(512*sizeof(WCHAR));

            //
            // Form the name of the partition.
            //
            SpNtNameFromRegion(Region,OpenPath,512*sizeof(WCHAR),PartitionOrdinalCurrent);

            //
            // Slap on the directory part of the path component.
            //
            SpConcatenatePaths(
                OpenPath,
                PathComponent + (SpExtractDriveLetter(PathComponent) ? 2 : 0)
                );

            //
            // Determine whether all the required files are present.
            //
            rc = SpNFilesExist(OpenPath,files,ELEMENT_COUNT(files),FALSE);

            if(rc) {
                //
                // Make sure this isn't a Windows 4.x installation.
                //
                rc = !SpIsWin4Dir(Region, PathComponent);
            }

            SpMemFree(OpenPath);
        }
    }

    return(rc);
}


BOOLEAN
SpIsDosConfigSys(
    IN PDISK_REGION Region
    )
{
    WCHAR OpenPath[512];
    HANDLE FileHandle,SectionHandle;
    ULONG FileSize;
    PVOID ViewBase;
    PUCHAR pFile,pFileEnd,pLineEnd;
    ULONG i;
    NTSTATUS Status;
    ULONG LineLen,KeyLen;
    PCHAR Keywords[] = { "MAXWAIT","PROTSHELL","RMSIZE","THREADS",
                         "SWAPPATH","PROTECTONLY","IOPL", NULL };

    //
    // Form name of config.sys.
    //
    SpNtNameFromRegion(Region,OpenPath,sizeof(OpenPath),PartitionOrdinalCurrent);
    SpConcatenatePaths(OpenPath,L"config.sys");

    //
    // Open and map the file.
    //
    FileHandle = 0;
    Status = SpOpenAndMapFile(
                OpenPath,
                &FileHandle,
                &SectionHandle,
                &ViewBase,
                &FileSize,
                FALSE
                );

    if(!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    pFile = ViewBase;
    pFileEnd = pFile + FileSize;

    //
    // This code must guard access to the config.sys buffer because the
    // buffer is memory mapped (an i/o error would raise an exception).
    // This code could be structured better, as it now works by returning
    // from the try body -- but performance isn't an issue so this is acceptable
    // because it is so darned convenient.
    //
    try {
        while(1) {
            //
            // Skip whitespace.  If at end of file, then this is a DOS config.sys.
            //
            while((pFile < pFileEnd) && strchr(" \r\n\t",*pFile)) {
                pFile++;
            }
            if(pFile == pFileEnd) {
                return(TRUE);
            }

            //
            // Find the end of the current line.
            //
            pLineEnd = pFile;
            while((pLineEnd < pFileEnd) && !strchr("\r\n",*pLineEnd)) {
                pLineEnd++;
            }

            LineLen = pLineEnd - pFile;

            //
            // Now check the line against known non-DOS config.sys keywords.
            //
            for(i=0; Keywords[i]; i++) {

                KeyLen = strlen(Keywords[i]);

                if((KeyLen <= LineLen) && !_strnicmp(pFile,Keywords[i],KeyLen)) {
                    return(FALSE);
                }
            }

            pFile = pLineEnd;
        }
    } finally {

        SpUnmapFile(SectionHandle,ViewBase);
        ZwClose(FileHandle);
    }
}


PUCHAR
SpGetDosPath(
    IN PDISK_REGION Region
    )
{
    WCHAR OpenPath[512];
    HANDLE FileHandle,SectionHandle;
    ULONG FileSize;
    PVOID ViewBase;
    PUCHAR pFile,pFileEnd,pLineEnd;
    PUCHAR PathSpec;
    ULONG l,i;
    NTSTATUS Status;

    //
    // Form name of autoexec.bat.
    //
    SpNtNameFromRegion(Region,OpenPath,sizeof(OpenPath),PartitionOrdinalCurrent);
    SpConcatenatePaths(OpenPath,L"autoexec.bat");

    //
    // Open and map the file.
    //
    FileHandle = 0;
    Status = SpOpenAndMapFile(
                OpenPath,
                &FileHandle,
                &SectionHandle,
                &ViewBase,
                &FileSize,
                FALSE
                );

    if(!NT_SUCCESS(Status)) {
        return(NULL);
    }

    pFile = ViewBase;
    pFileEnd = pFile + FileSize;

    PathSpec = SpMemAlloc(1);
    *PathSpec = 0;

    #define SKIP(s) while((pFile<pFileEnd)&&strchr(s,*pFile))pFile++;if(pFile==pFileEnd)return(PathSpec)
    //
    // This code must guard access to the autoexec.bat buffer because the
    // buffer is memory mapped (an i/o error would raise an exception).
    // This code could be structured better, as it now works by returning
    // from the try body -- but performance isn't an issue so this is acceptable
    // because it is so darned convenient.
    //
    try {
        while(1) {
            //
            // Skip whitespace.  If at end of file, then we're done.
            //
            SKIP(" \t\r\n");

            //
            // Find the end of the current line.
            //
            pLineEnd = pFile;
            while((pLineEnd < pFileEnd) && !strchr("\r\n",*pLineEnd)) {
                pLineEnd++;
            }

            //
            // Skip the no echo symbol if present.
            //
            if(*pFile == '@') {
                pFile++;
            }
            SKIP(" \t");

            //
            // See if the line starts with "set."  If so, skip it.
            // To be meaningful, the line must have at least 10
            // characters ("set path=x" is 10 chars).
            //
            if((pLineEnd - pFile >= 10) && !_strnicmp(pFile,"set",3)) {
                pFile += 3;
            }

            //
            // Skip whitespace.
            //
            SKIP(" \t");

            //
            // See if the line has "path" -- if so, we're in business.
            // To be meaningful, the line must have at least 5 characters
            // ("path x" or "path=x" is 6 chars).
            //
            if((pLineEnd - pFile >= 5) && !_strnicmp(pFile,"path",4)) {

                //
                // Skip PATH
                //
                pFile += 4;

                SKIP(" \t");
                if(*pFile == '=') {
                    pFile++;
                }
                SKIP(" \t");

                //
                // Strip off trailing spaces.
                //
                while(strchr(" \t",*(pLineEnd-1))) {
                    pLineEnd--;
                }

                //
                // The rest of the line is the path.  Append it to
                // what we have so far.
                //
                l = strlen(PathSpec);
                PathSpec = SpMemRealloc(PathSpec,pLineEnd-pFile+l+2);
                if(l) {
                    PathSpec[l++] = ';';
                }
                for(i=0; i<(ULONG)(pLineEnd-pFile); i++) {
                    PathSpec[l+i] = pFile[i];
                }
                PathSpec[l+i] = 0;
            }

            pFile = pLineEnd;
        }
    } finally {

        SpUnmapFile(SectionHandle,ViewBase);
        ZwClose(FileHandle);
    }
}


VOID
SpRemoveWin31(
    IN PDISK_REGION NtPartitionRegion,
    IN LPCWSTR      Sysroot
    )
{
    LPWSTR p,q;

    p = SpMemAlloc(500);
    q = SpMemAlloc(500);

    //
    // Rename win.com to wincom.w31. Delete wincom.w31 first.
    //
    SpNtNameFromRegion(NtPartitionRegion,p,500,PartitionOrdinalCurrent);
    SpConcatenatePaths(p,Sysroot);
    wcscpy(q,p);

    SpConcatenatePaths(p,L"WIN.COM");
    SpConcatenatePaths(q,L"WINCOM.W31");

    SpDeleteFile(q,NULL,NULL);
    SpRenameFile(p,q,FALSE);

    SpMemFree(q);
    SpMemFree(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\spddlang\fe\fefont.h ===
//
// size of the byte aligned DIB bitmap
//

#define CJ_DIB8_SCAN(cx) ((((cx) + 7) & ~7) >> 3)
#define CJ_DIB8( cx, cy ) (CJ_DIB8_SCAN(cx) * (cy))

//
// Public functions in jpnfont.c
//

BOOLEAN
FEDbcsFontInitGlyphs(
    IN PCWSTR BootDevicePath,
    IN PCWSTR DirectoryOnBootDevice,
    IN PVOID BootFontImage,
    IN ULONG BootFontImageLength
    );

VOID
FEDbcsFontFreeGlyphs(
    VOID
    );

PBYTE
DbcsFontGetDbcsFontChar(
    USHORT Word
);

PBYTE
DbcsFontGetSbcsFontChar(
    UCHAR Char
);

PBYTE
DbcsFontGetGraphicsChar(
    UCHAR Char
);

BOOLEAN
DbcsFontIsGraphicsChar(
    UCHAR Char
);

BOOLEAN
DbcsFontIsDBCSLeadByte(
    IN UCHAR c
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\spddlang\fe\fefb.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    fefb.c (was textmode\kernel\spvidgfb.c)

Abstract:

    Text setup display support for Frame Buffer displays.

Author:

    Hideyuki Nagase (hideyukn) 01-July-1994

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

//
// Vector for frame buffer functions.
//

VIDEO_FUNCTION_VECTOR FrameBufferKanjiVideoVector =

    {
        FrameBufferKanjiDisplayString,
        FrameBufferKanjiClearRegion,
        FrameBufferKanjiSpecificInit,
        FrameBufferKanjiSpecificReInit,
        FrameBufferKanjiSpecificTerminate,
        FrameBufferKanjiSpecificInitPalette,
        FrameBufferKanjiSpecificScrollUp
    };


BOOLEAN FrameBufferKanjiInitialized = FALSE;

//
// Number of bytes that make up a row of characters.
// Equal to the screen stride (number of bytes on a scan line)
// multiplies by the height of a char in bytes; double that
// if DoubleCharHeight is TRUE.
//
ULONG KanjiCharRowDelta;
ULONG KanjiBytesPerPixel;
ULONG KanjiCharWidth;

//
// Physical font information
//
extern BOOTFONTBIN_HEADER BootFontHeader;

VOID
FrameBufferKanjiSpecificInit(
    IN PVIDEO_MODE_INFORMATION VideoModes,
    IN ULONG                   NumberOfModes,
    IN ULONG                   ModeSize
    )

/*++

Routine Description:

    Perform frame buffer specific initialization.  This includes

    - setting the desired video mode.

Arguments:

    None.

Return Value:

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    VIDEO_MODE VideoMode;
    PVIDEO_MODE_INFORMATION mode;

    if(FrameBufferKanjiInitialized) {
        return;
    }

    mode = pFrameBufferDetermineModeToUse(VideoModes,NumberOfModes,ModeSize);

    if(mode == 0) {
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_BADMODE, 0);
        while(TRUE);    // loop forever
    }

    //
    // Save away the mode info in a global.
    //
    VideoVariables->VideoModeInfo = *mode;

    //
    // Set the desired mode.
    //
    VideoMode.RequestedMode = VideoVariables->VideoModeInfo.ModeIndex;

    Status = ZwDeviceIoControlFile(
                VideoVariables->hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_SET_CURRENT_MODE,
                &VideoMode,
                sizeof(VideoMode),
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: Unable to set mode %u (status = %lx)\n",VideoMode.RequestedMode,Status));
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_SETMODE, Status);
        while(TRUE);    // loop forever
    }

    //
    // Map the frame buffer.
    //
    pSpvidMapVideoMemory(TRUE);

    FrameBufferKanjiInitialized = TRUE;

    //
    // Logical FontGlyph information
    //
    FEFontCharacterHeight = BootFontHeader.CharacterImageHeight +
                            BootFontHeader.CharacterTopPad +
                            BootFontHeader.CharacterBottomPad;
    FEFontCharacterWidth  = BootFontHeader.CharacterImageSbcsWidth;

    //
    // Determine the width of the screen.  If it's double the size
    // of the minimum number of characters per row (or larger)
    // then we'll double the width of each character as we draw it.
    //
    VideoVariables->ScreenWidth  = VideoVariables->VideoModeInfo.VisScreenWidth  / FEFontCharacterWidth;

    //
    // Determine the height of the screen.  If it's double the size
    // of the minimum number of characters per column (or larger)
    // then we'll double the height of each character as we draw it.
    //
    VideoVariables->ScreenHeight = VideoVariables->VideoModeInfo.VisScreenHeight / FEFontCharacterHeight;

    KanjiCharRowDelta = VideoVariables->VideoModeInfo.ScreenStride * FEFontCharacterHeight;

    KanjiBytesPerPixel = VideoVariables->VideoModeInfo.BitsPerPlane / 8;

    if(KanjiBytesPerPixel == 3) {
        KanjiBytesPerPixel = 4;
    }

    KdPrint(("SETUPDD:KanjiBytesPerPixel = %d\n",KanjiBytesPerPixel));

    KanjiCharWidth = FEFontCharacterWidth * KanjiBytesPerPixel;

    //
    // Allocate the background buffer, if needed
    //
    VideoVariables->ActiveVideoBuffer = VideoVariables->VideoMemoryInfo.FrameBufferBase;

    if (SP_IS_UPGRADE_GRAPHICS_MODE()) {
        VideoVariables->VideoBufferSize = VideoVariables->VideoMemoryInfo.FrameBufferLength;

        VideoVariables->VideoBuffer = SpMemAlloc(VideoVariables->VideoBufferSize);

        if (VideoVariables->VideoBuffer) {
            VideoVariables->ActiveVideoBuffer = VideoVariables->VideoBuffer;
        } else {
            VideoVariables->VideoBufferSize = 0;
            SP_SET_UPGRADE_GRAPHICS_MODE(FALSE);
        }            
    }
}

VOID
FrameBufferKanjiSpecificReInit(
    VOID
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    VIDEO_MODE VideoMode;
    
    if(!FrameBufferKanjiInitialized) {
        return;
    }

    //
    // Set the desired mode.
    //
    VideoMode.RequestedMode = VideoVariables->VideoModeInfo.ModeIndex;

    Status = ZwDeviceIoControlFile(
                VideoVariables->hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_SET_CURRENT_MODE,
                &VideoMode,
                sizeof(VideoMode),
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: Unable to set mode %u (status = %lx)\n",VideoMode.RequestedMode,Status));
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_SETMODE, Status);
        while(TRUE);    // loop forever
    }

    FrameBufferKanjiSpecificInitPalette();

    //
    // Blast the background video information to the
    // foreground
    //
    if (SP_IS_UPGRADE_GRAPHICS_MODE() && VideoVariables->VideoBuffer && 
        VideoVariables->VideoBufferSize) {
        PUCHAR Source = VideoVariables->VideoBuffer;
        PUCHAR Destination = VideoVariables->VideoMemoryInfo.FrameBufferBase;
        ULONG Index;

        for (Index=0; Index < VideoVariables->VideoBufferSize; Index++) {
            WRITE_REGISTER_UCHAR(Destination + Index, *(Source + Index));
        }

        SP_SET_UPGRADE_GRAPHICS_MODE(FALSE);
    }

    VideoVariables->ActiveVideoBuffer = VideoVariables->VideoMemoryInfo.FrameBufferBase;
}


BOOLEAN
FrameBufferKanjiSpecificInitPalette(
    VOID
    )
{
    BOOLEAN rc;
    ULONG NumEntries;
    ULONG BufferSize;
    PVIDEO_CLUT clut;
//  NTSTATUS Status;
//  IO_STATUS_BLOCK IoStatusBlock;
    UCHAR i;

    rc = TRUE;

    //
    // For non-palette-driven displays, we construct a simple palette
    // for use w/ gamma correcting adapters.
    //

    if(!(VideoVariables->VideoModeInfo.AttributeFlags & VIDEO_MODE_PALETTE_DRIVEN)) {

        switch(KanjiBytesPerPixel) {
        case 1:
            NumEntries = 3;
            break;
        case 2:
            NumEntries = 32;
            break;
        default:
            NumEntries = 255;
            break;
        }

        BufferSize = sizeof(VIDEO_CLUT)+(sizeof(VIDEO_CLUTDATA)*NumEntries);    // size is close enough
        clut = SpMemAlloc(BufferSize);

        clut->NumEntries = (USHORT)NumEntries;
        clut->FirstEntry = 0;

        for(i=0; i<NumEntries; i++) {
            clut->LookupTable[i].RgbArray.Red    = i;
            clut->LookupTable[i].RgbArray.Green  = i;
            clut->LookupTable[i].RgbArray.Blue   = i;
            clut->LookupTable[i].RgbArray.Unused = 0;
        }

//        Status = ZwDeviceIoControlFile(
//                    hDisplay,
//                    NULL,
//                    NULL,
//                    NULL,
//                    &IoStatusBlock,
//                    IOCTL_VIDEO_SET_COLOR_REGISTERS,
//                    clut,
//                    BufferSize,
//                    NULL,
//                    0
//                    );

        SpMemFree(clut);

//        if(!NT_SUCCESS(Status)) {
//            KdPrint(("SETUP: Unable to set palette (status = %lx)\n",Status));
//            rc = FALSE;
//        }
    }

    return(rc);
}


VOID
FrameBufferKanjiSpecificTerminate(
    VOID
    )

/*++

Routine Description:

    Perform frame buffer specific termination.  This includes

    - unmapping the frame buffer from memory

Arguments:

    None.

Return Value:

--*/

{
    if(FrameBufferKanjiInitialized) {

        //
        // Clear screen for next video mode.
        //
        FrameBufferKanjiClearRegion(
            0,
            0,
            VideoVariables->ScreenWidth,
            VideoVariables->ScreenHeight,
            ATT_FG_BLACK|ATT_BG_BLACK
            );

        //
        // Unmap video memory
        //
        pSpvidMapVideoMemory(FALSE);

        if (VideoVariables->VideoBuffer && VideoVariables->VideoBufferSize) {
            SpMemFree(VideoVariables->VideoBuffer);
            VideoVariables->VideoBuffer = 0;
            VideoVariables->VideoBufferSize = 0;
        }

        FrameBufferKanjiInitialized = FALSE;
    }
}



VOID
FrameBufferKanjiDisplayString(
    IN PSTR  String,
    IN UCHAR Attribute,
    IN ULONG X,                 // 0-based coordinates (character units)
    IN ULONG Y
    )

/*++

Routine Description:

    Write a string of characters to the display.

Arguments:

    String - supplies a 0-terminated character string in the OEM charset
        to be displayed at the given position.

    Attribute - supplies the attributes for characters in the string.

    X,Y - specify the character-based (0-based) position of the output.

Return Value:

    None.

--*/

{
    ULONG BgColorValue;
    ULONG FgColorValue;
    PUCHAR Destination;
    PUCHAR CharOrigin,LineOrigin,pGlyphRow;
    ULONG Length;
    PUCHAR pch;
    ULONG I,J,K;
    ULONG  CurrentColumn;

    //
    // Eliminate invalid coord.
    //
    if( X >= VideoVariables->ScreenWidth )  X = 0;
    if( Y >= VideoVariables->ScreenHeight ) Y = 3;

    ASSERT(FEFontCharacterWidth == 8);

    //
    // Calculate the bit patterns that yield the foreground and background
    // attributes when poked into the frame buffer.
    //

    FgColorValue = VideoVariables->AttributeToColorValue[Attribute & 0x0f];
    BgColorValue = VideoVariables->AttributeToColorValue[(Attribute >> 4) & 0x0f];

    //
    // Calculate the address of the upper left pixel of the first character
    // to be displayed.
    //

    CharOrigin = (PUCHAR)VideoVariables->ActiveVideoBuffer
               + (Y * KanjiCharRowDelta)
               + (X * KanjiCharWidth);

    //
    // Set current column.
    //
    CurrentColumn = X;

    //
    // Output each character in the string.
    //

    for(pch=String; *pch; pch++) {

        //
        // Initialize line Origin
        //

        LineOrigin = CharOrigin;

        if(DbcsFontIsDBCSLeadByte(*pch)) {

            //
            // This is Full Width Character ( 16 + 1 + 2 * 8 )
            //                                |    |   |   Height
            //                                |    |   Post Leading
            //                                |    Pre Leading
            //                                Real font image body

            USHORT Word;

            if((CurrentColumn+1) >= VideoVariables->ScreenWidth) {
                break;
            }

            Word = ((*pch) << 8) | (*(pch+1));

            pGlyphRow = DbcsFontGetDbcsFontChar(Word);

            //
            // If we can not get image, replace it with full width space.
            //

            if(pGlyphRow == NULL) {
                pGlyphRow = DbcsFontGetDbcsFontChar(FEFontDefaultChar);
            }

            //
            // Draw pre leading lines
            //

            for (I = 0; I < BootFontHeader.CharacterTopPad; I += 1 ) {

                Destination = LineOrigin;

                for( J = 0; J < BootFontHeader.CharacterImageDbcsWidth; J += 1 ) {

                    switch(KanjiBytesPerPixel) {

                    case 1:
                        *Destination++ = (UCHAR)BgColorValue;
                        break;

                    case 2:
                        *(PUSHORT)Destination = (USHORT)BgColorValue;
                        Destination += 2;
                        break;

                    case 4:
                        *(PULONG)Destination = (ULONG)BgColorValue;
                        Destination += 4;
                        break;
                    }
                }

                LineOrigin += VideoVariables->VideoModeInfo.ScreenStride;
            }

            //
            // Draw font glyph body
            //

            for (I = 0; I < BootFontHeader.CharacterImageHeight; I += 1 ) {

                Destination = LineOrigin;

                for( J = 0; J < 2; J += 1 ) {

                    BYTE ShiftMask = 0x80;

                    for( K = 0; K < 8 ; K += 1 ) {

                        ULONG DrawValue;

                        if (pGlyphRow && (*pGlyphRow & ShiftMask))
                            DrawValue = FgColorValue;
                        else
                            DrawValue = BgColorValue;

                        switch(KanjiBytesPerPixel) {

                        case 1:
                            *Destination++ = (UCHAR)DrawValue;
                            break;

                        case 2:
                            *(PUSHORT)Destination = (USHORT)DrawValue;
                            Destination += 2;
                            break;

                        case 4:
                            *(PULONG)Destination = (ULONG)DrawValue;
                            Destination += 4;
                            break;
                        }

                        ShiftMask = ShiftMask >> 1;
                    }

                    pGlyphRow ++;
                }

                LineOrigin += VideoVariables->VideoModeInfo.ScreenStride;
            }

            //
            // Draw post leading lines
            //

            for (I = 0; I < BootFontHeader.CharacterBottomPad; I += 1) {

                Destination = LineOrigin;

                for( J = 0; J < BootFontHeader.CharacterImageDbcsWidth; J += 1 ) {

                    switch(KanjiBytesPerPixel) {

                    case 1:
                        *Destination++ = (UCHAR)BgColorValue;
                        break;

                    case 2:
                        *(PUSHORT)Destination = (USHORT)BgColorValue;
                        Destination += 2;
                        break;

                    case 4:
                        *(PULONG)Destination = (ULONG)BgColorValue;
                        Destination += 4;
                        break;
                    }
                }

                LineOrigin += VideoVariables->VideoModeInfo.ScreenStride;
            }

            CharOrigin += (BootFontHeader.CharacterImageDbcsWidth * KanjiBytesPerPixel);
            CurrentColumn += 2;

            //
            // Move to Next character ( skip Dbcs Trailing byte )
            //

            pch++;

        } else if(DbcsFontIsGraphicsChar(*pch)) {

            BYTE  ShiftMask = 0x80;
            ULONG DrawValue;

            if(CurrentColumn >= VideoVariables->ScreenWidth) {
                break;
            }

            //
            // Graphics Character special
            //

            pGlyphRow = DbcsFontGetGraphicsChar(*pch);

            if(pGlyphRow == NULL) {
                pGlyphRow = DbcsFontGetGraphicsChar(0x0);
            }

            for (I = 0; I < FEFontCharacterHeight; I += 1 ) {

                ShiftMask = 0x80;
                Destination = LineOrigin;

                for( K = 0; K < 8 ; K += 1 ) {

                    if( *pGlyphRow & ShiftMask )
                        DrawValue = BgColorValue;
                     else
                        DrawValue = FgColorValue;

                    switch(KanjiBytesPerPixel) {

                    case 1:
                        *Destination++ = (UCHAR)DrawValue;
                        break;

                    case 2:
                        *(PUSHORT)Destination = (USHORT)DrawValue;
                        Destination += 2;
                        break;

                    case 4:
                        *(PULONG)Destination = (ULONG)DrawValue;
                        Destination += 4;
                            break;
                    }

                    ShiftMask = ShiftMask >> 1;
                }

                pGlyphRow ++;
                LineOrigin += VideoVariables->VideoModeInfo.ScreenStride;
            }

            CharOrigin += (BootFontHeader.CharacterImageSbcsWidth * KanjiBytesPerPixel);
            CurrentColumn += 1;

        } else {

            if(CurrentColumn >= VideoVariables->ScreenWidth) {
                break;
            }

            pGlyphRow = DbcsFontGetSbcsFontChar(*pch);

            //
            // If we can not get image, replace it with half width space.
            //

            if(pGlyphRow == NULL) {
                pGlyphRow = DbcsFontGetSbcsFontChar(0x20);
            }

            for (I = 0; I < BootFontHeader.CharacterTopPad; I += 1 ) {

                Destination = LineOrigin;

                for( J = 0; J < BootFontHeader.CharacterImageSbcsWidth; J += 1 ) {

                    switch(KanjiBytesPerPixel) {

                    case 1:
                        *Destination++ = (UCHAR)BgColorValue;
                        break;

                    case 2:
                        *(PUSHORT)Destination = (USHORT)BgColorValue;
                        Destination += 2;
                        break;

                    case 4:
                        *(PULONG)Destination = (ULONG)BgColorValue;
                        Destination += 4;
                        break;
                    }
                }

                LineOrigin += VideoVariables->VideoModeInfo.ScreenStride;
            }

            for (I = 0; I < BootFontHeader.CharacterImageHeight; I += 1 ) {

                BYTE ShiftMask = 0x80;

                Destination = LineOrigin;

                for( K = 0; K < 8 ; K += 1 ) {

                    ULONG DrawValue;

                    if( *pGlyphRow & ShiftMask )
                        DrawValue = FgColorValue;
                     else
                        DrawValue = BgColorValue;

                    switch(KanjiBytesPerPixel) {

                    case 1:
                        *Destination++ = (UCHAR)DrawValue;
                        break;

                    case 2:
                        *(PUSHORT)Destination = (USHORT)DrawValue;
                        Destination += 2;
                        break;

                    case 4:
                        *(PULONG)Destination = (ULONG)DrawValue;
                        Destination += 4;
                        break;
                    }

                    ShiftMask = ShiftMask >> 1;
                }

                pGlyphRow ++;
                LineOrigin += VideoVariables->VideoModeInfo.ScreenStride;
            }

            for (I = 0; I < BootFontHeader.CharacterBottomPad; I += 1) {

                Destination = LineOrigin;

                for( J = 0; J < BootFontHeader.CharacterImageSbcsWidth; J += 1 ) {

                    switch(KanjiBytesPerPixel) {

                    case 1:
                        *Destination++ = (UCHAR)BgColorValue;
                        break;

                    case 2:
                        *(PUSHORT)Destination = (USHORT)BgColorValue;
                        Destination += 2;
                        break;

                    case 4:
                        *(PULONG)Destination = (ULONG)BgColorValue;
                        Destination += 4;
                        break;
                    }
                }

                LineOrigin += VideoVariables->VideoModeInfo.ScreenStride;
            }

            CharOrigin += (BootFontHeader.CharacterImageSbcsWidth * KanjiBytesPerPixel);
            CurrentColumn += 1;
        }
    }
}



VOID
FrameBufferKanjiClearRegion(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG W,
    IN ULONG H,
    IN UCHAR Attribute
    )

/*++

Routine Description:

    Clear out a screen region to a specific attribute.

Arguments:

    X,Y,W,H - specify rectangle in 0-based character coordinates.

    Attribute - Low nibble specifies attribute to be filled in the rectangle
        (ie, the background color to be cleared to).

Return Value:

    None.

--*/

{
    PUCHAR Destination;
    ULONG  Fill;
    ULONG  i;
    ULONG  FillLength;
    ULONG  x;

    ASSERT(X+W <= VideoVariables->ScreenWidth);
    ASSERT(Y+H <= VideoVariables->ScreenHeight);

    if(X+W > VideoVariables->ScreenWidth) {
        W = VideoVariables->ScreenWidth-X;
    }

    if(Y+H > VideoVariables->ScreenHeight) {
        H = VideoVariables->ScreenHeight-Y;
    }

    Fill = VideoVariables->AttributeToColorValue[Attribute & 0x0f];

    Destination = (PUCHAR)VideoVariables->ActiveVideoBuffer
                + (Y * KanjiCharRowDelta)
                + (X * KanjiCharWidth);

    FillLength = W * KanjiCharWidth;

    for(i=0; i<H*FEFontCharacterHeight; i++) {

        switch(KanjiBytesPerPixel) {

        case 1:
            for(x=0; x<FillLength  ; x++) {
                *(PUCHAR)(Destination+(x)) = (UCHAR)Fill;
            }
            break;

        case 2:
            for(x=0; x<FillLength/2; x++) {
                *(PUSHORT)(Destination+(x*2)) = (USHORT)Fill;
            }
            break;

        case 4:
            for(x=0; x<FillLength/4; x++) {
                *(PULONG)(Destination+(x*4)) = (ULONG)Fill;
            }
            break;
        }

        Destination += VideoVariables->VideoModeInfo.ScreenStride;
    }
}


BOOLEAN
FrameBufferKanjiSpecificScrollUp(
    IN ULONG TopLine,
    IN ULONG BottomLine,
    IN ULONG LineCount,
    IN UCHAR FillAttribute
    )
{
    PUCHAR Source,Target;
    ULONG Count;

    Target = (PUCHAR)VideoVariables->ActiveVideoBuffer
           +         (TopLine * KanjiCharRowDelta);

    Source = Target + (LineCount * KanjiCharRowDelta);

    Count = (((BottomLine - TopLine) + 1) - LineCount) * KanjiCharRowDelta;

    RtlMoveMemory(Target,Source,Count);

    FrameBufferKanjiClearRegion(
        0,
        (BottomLine - LineCount) + 1,
        VideoVariables->ScreenWidth,
        LineCount,
        FillAttribute
        );

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\spddlang\fe\fefont.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    fefont.c

Abstract:

    Text setup display support for FarEast text output.

Author:

    Hideyuki Nagase (hideyukn) 01-July-1994

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

#define FE_FONT_FILE_NAME L"BOOTFONT.BIN"

//
// FontFile image information
//
PVOID  pvFontFileView = NULL;
ULONG  ulFontFileSize = 0L;
BOOLEAN FontFileViewAllocated = FALSE;

//
// Font Glyph information
//
BOOTFONTBIN_HEADER BootFontHeader;
PUCHAR SbcsImages;
PUCHAR DbcsImages;

//
// Graphics Character image 19x8.
//
UCHAR GraphicsCharImage[0x20][19] = { 
/* 0x00 */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x01 */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0xDF,
                   0xD8, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB },
/* 0x02 */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xFB,
                   0x1B, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB },
/* 0x03 */ { 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xD8, 0xDF,
                   0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x04 */ { 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0x1B, 0xFB,
                   0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x05 */ { 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB,
                   0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB },
/* 0x06 */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF,
                   0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x07 */ { 0xFF, 0xFF, 0xFF, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7,
                   0xF7, 0xF7, 0xF7, 0xC1, 0xE3, 0xE3, 0xF7, 0xFF, 0xFF, 0xFF },
/* 0x08 */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x09 */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xDB, 0xDB, 0xBD,
                   0xBD, 0xBD, 0xBD, 0xDB, 0xDB, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x0a */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x0b */ { 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x7D, 0x39, 0x55, 0x55,
                   0x6D, 0x6D, 0x55, 0x55, 0x39, 0x7D, 0x01, 0xFF, 0xFF, 0xFF },
/* 0x0c */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x0d */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x0e */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x01, 0x01, 0x01,
                   0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFF, 0xFF },
/* 0x0f */ { 0xFF, 0xFF, 0xFF, 0xB6, 0xB6, 0xD5, 0xC9, 0xEB, 0xDD,
                   0x1C, 0xDD, 0xEB, 0xC9, 0xD5, 0xB6, 0xB6, 0xFF, 0xFF, 0xFF },
/* 0x10 */ { 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0x18, 0xFF,
                   0x18, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB },
/* 0x11 */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x12 */ { 0xFF, 0xFF, 0xFF, 0xF7, 0xE3, 0xE3, 0xC1, 0xF7, 0xF7,
                   0xF7, 0xF7, 0xF7, 0xC1, 0xE3, 0xE3, 0xF7, 0xFF, 0xFF, 0xFF },
/* 0x13 */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x14 */ { 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,
                   0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55 },
/* 0x15 */ { 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0x18, 0xFF,
                   0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x16 */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF,
                   0x18, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB },
/* 0x17 */ { 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0x1B, 0xFB,
                   0x1B, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB },
/* 0x18 */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x19 */ { 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xD8, 0xDF,
                   0xD8, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB },
/* 0x1a */ { 0xFF, 0xFF, 0xAA, 0xFF, 0x55, 0xFF, 0xAA, 0xFF, 0x55,
                   0xFF, 0xAA, 0xFF, 0x55, 0xFF, 0xAA, 0xFF, 0x55, 0xFF, 0xAA },
/* 0x1b */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFD, 0xFD, 0xFD, 0xDD,
                   0x9D, 0x01, 0x9F, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x1c */ { 0xFF, 0xFF, 0xFF, 0xF7, 0xE3, 0xE3, 0xC1, 0xF7, 0xF7,
                   0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xFF, 0xFF, 0xFF },
/* 0x1d */ { 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7,
                   0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7 },
/* 0x1e */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFB,
                   0xF9, 0x80, 0xF9, 0xfB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
/* 0x1f */ { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF,
                   0x9F, 0x01, 0x9F, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF }
};

BOOLEAN
FEDbcsFontInitGlyphs(
    IN PCWSTR BootDevicePath,
    IN PCWSTR DirectoryOnBootDevice,
    IN PVOID BootFontImage OPTIONAL,
    IN ULONG BootFontImageLength OPTIONAL
    )
{
    WCHAR    NtFEFontPath[129];
    BOOLEAN  bRet;
    NTSTATUS NtStatus;
    PVOID    pvFontFileOnDisk = NULL;
    HANDLE   hFontFile = 0 ,
             hFontSection = 0;

    if (BootFontImage && BootFontImageLength) {
        //
        // Use the loader passed bootfont.bin image as it is (if one exists)
        //
        pvFontFileView = BootFontImage;
        ulFontFileSize = BootFontImageLength;
        FontFileViewAllocated = FALSE;
    } else {        
        //
        // Build FontFile path.
        //
        wcscpy( NtFEFontPath,BootDevicePath);

        if( NtFEFontPath[ wcslen(NtFEFontPath) - 1 ] != L'\\' )
        {
            wcscat( NtFEFontPath , L"\\" );
        }

        wcscat( NtFEFontPath , FE_FONT_FILE_NAME );

        //
        // Check the font is exist
        //
        bRet = SpFileExists( NtFEFontPath , FALSE );

        if( !bRet ) {
        
            //
            // It's not in the root of our BootDevice.  Check the
            // DirectoryOnBootDevice path too before we fail.
            //

            wcscpy( NtFEFontPath,BootDevicePath);
            wcscat( NtFEFontPath,DirectoryOnBootDevice);
        
            if( NtFEFontPath[ wcslen(NtFEFontPath) - 1 ] != L'\\' )
            {
                wcscat( NtFEFontPath , L"\\" );
            }
        
            wcscat( NtFEFontPath , FE_FONT_FILE_NAME );
        
            //
            // Check the font is exist
            //
            bRet = SpFileExists( NtFEFontPath , FALSE );
        
            if( !bRet ) {
                KdPrint(("SETUP:FarEast font file (%ws) is not exist\n",NtFEFontPath));
                return( FALSE );
            }
        }

        //
        // Read and Map fontfile into Memory.
        //
        NtStatus = SpOpenAndMapFile(
                      NtFEFontPath ,     // IN  PWSTR    FileName,
                      &hFontFile ,        // OUT PHANDLE  FileHandle,
                      &hFontSection ,     // OUT PHANDLE  SectionHandle,
                      &pvFontFileOnDisk , // OUT PVOID   *ViewBase,
                      &ulFontFileSize ,   // OUT PULONG   FileSize,
                      FALSE               // IN  BOOLEAN  WriteAccess
                   );

        if( !NT_SUCCESS(NtStatus) ) {
            KdPrint(("SETUP:Fail to map FontFile\n"));
            return( FALSE );
        }

        KdPrint(("FONTFILE ON DISK CHECK\n"));
        KdPrint(("   pvFontFileView - %x\n",pvFontFileOnDisk));
        KdPrint(("   ulFontFileSize - %d\n",ulFontFileSize));

        //
        // Allocate buffer for FontFile image.
        //
        pvFontFileView = SpMemAlloc( ulFontFileSize );

        FontFileViewAllocated = TRUE;
        
        //
        // Copy image to local beffer
        //
        RtlCopyMemory( pvFontFileView , pvFontFileOnDisk , ulFontFileSize );

        //
        // Unmap/Close fontfile.
        //
        SpUnmapFile( hFontSection , pvFontFileOnDisk );
        ZwClose( hFontFile );
    }        

    KdPrint(("FONTFILE ON MEMORY CHECK\n"));
    KdPrint(("   pvFontFileView - %x\n",pvFontFileView));
    KdPrint(("   ulFontFileSize - %d\n",ulFontFileSize));

    //
    // Check fontfile validation (at least, we should have font header).
    //
    if( ulFontFileSize < sizeof(BOOTFONTBIN_HEADER) )
    {
        KdPrint(("SETUPDD:FontFile Size < sizeof(BOOTFONTBIN_HEADER)\n"));
        return( FALSE );
    }

    //
    // Copy header to local...
    //
    RtlCopyMemory((PCHAR)&BootFontHeader,
                  (PCHAR)pvFontFileView,
                  sizeof(BOOTFONTBIN_HEADER));

    //
    // Check font signature.
    //
    if( BootFontHeader.Signature != BOOTFONTBIN_SIGNATURE )
    {
        KdPrint(("SETUPDD:Invalid font signature.\n"));
        return( FALSE );
    }

    SbcsImages = (PUCHAR)pvFontFileView + BootFontHeader.SbcsOffset;
    DbcsImages = (PUCHAR)pvFontFileView + BootFontHeader.DbcsOffset;

    //
    // Dump Physical FontGlyph information
    //
    KdPrint(("FONT GLYPH INFORMATION\n"));
    KdPrint(("   LanguageId - %d\n",BootFontHeader.LanguageId));
    KdPrint(("   Width(S)   - %d\n",BootFontHeader.CharacterImageSbcsWidth));
    KdPrint(("   Width(D)   - %d\n",BootFontHeader.CharacterImageDbcsWidth));
    KdPrint(("   Height     - %d\n",BootFontHeader.CharacterImageHeight));
    KdPrint(("   TopPad     - %d\n",BootFontHeader.CharacterTopPad));
    KdPrint(("   BottomPad  - %d\n",BootFontHeader.CharacterBottomPad));
    KdPrint(("   SbcsOffset - %x\n",BootFontHeader.SbcsOffset));
    KdPrint(("   DbcsOffset - %x\n",BootFontHeader.DbcsOffset));
    KdPrint(("   SbcsImages - %x\n",SbcsImages));
    KdPrint(("   DbcsImages - %x\n",DbcsImages));

    //
    // Check Language ID..
    //
    switch (BootFontHeader.LanguageId) {
        case 0x411:   // Japan
            FEFontDefaultChar = 0x8140;
            break;
        case 0x404:   // Taiwan
        case 0x804:   // PRC
        case 0x412:   // Korea
            FEFontDefaultChar = 0xa1a1;
            break;
        default:      // Illigal language Id
            KdPrint(("SETUPDD:Invalid Language ID\n"));
            return( FALSE );
    }

    //
    // Check font file size, more strictly..
    //
    if( ulFontFileSize < (sizeof(BOOTFONTBIN_HEADER) +
                          BootFontHeader.SbcsEntriesTotalSize +
                          BootFontHeader.DbcsEntriesTotalSize)  ) {
        KdPrint(("SETUPDD:Invalid file size\n"));
        return( FALSE );
    }

    //
    // Check font image size... SBCS 16x8 : DBCS 16x16.
    //
    if( (BootFontHeader.CharacterImageSbcsWidth !=  8 ) ||
        (BootFontHeader.CharacterImageDbcsWidth != 16 ) || 
        (BootFontHeader.CharacterImageHeight    != 16 )    ) {
        KdPrint(("SETUPDD:Invalid font size\n"));
        return( FALSE );
    }

    KdPrint(("Everything is well done...\n"));
    return( TRUE );
}

VOID
FEDbcsFontFreeGlyphs(
    VOID
)
{
    if (FontFileViewAllocated) {
        SpMemFree(pvFontFileView);
    }        
}

PUCHAR
DbcsFontGetDbcsFontChar(
    USHORT Code
    )

/*++

Routine Description:

    Gets the font image for DBCS char.

Arguments:

    Code - DBCS char code.

Return Value:

    Pointer to font image, or else NULL.

--*/

{
    int Min,Max,Mid;
    int Multiplier;
    int Index;
    USHORT code;

    Min = 0;
    Max = BootFontHeader.NumDbcsChars;
    // multiplier = 2 (for index) +
    //              2 * height +
    //              2 (for unicode encoding)
    //
    Multiplier = 2 + (2*BootFontHeader.CharacterImageHeight) + 2;

    //
    // Do a binary search for the image.
    // Format of table:
    //   First 2 bytes contain the DBCS char code.
    //   Next (2 * CharacterImageHeight) bytes are the char image.
    //   Next 2 bytes are for unicode version.
    //
    while(Max >= Min)  {
        Mid = (Max + Min) / 2;
        Index = Mid*Multiplier;
        code = (DbcsImages[Index] << 8) | DbcsImages[Index+1];

        if(Code == code) {
            return(DbcsImages+Index+2);
        }

        if(Code < code) {
            Max = Mid - 1;
        } else {
            Min = Mid + 1;
        }
    }

    //
    // ERROR: No image found.
    //
    return(NULL);
}

PUCHAR
DbcsFontGetSbcsFontChar(
    UCHAR Code
    )

/*++

Routine Description:

    Gets the font image for SBCS char.

Arguments:

    Code - SBCS char code.

Return Value:

    Pointer to font image, or else NULL.

--*/

{
    int Max,Min,Mid;
    int Multiplier;
    int Index;

    Min = 0;
    Max = BootFontHeader.NumSbcsChars;
    // multiplier = 1 (for index) +
    //              height +
    //              2 (for unicode encoding)
    //
    Multiplier = 1 + (BootFontHeader.CharacterImageHeight) + 2;

    //
    // Do a binary search for the image.
    // Format of table:
    //   First byte contains the SBCS char code.
    //   Next (CharacterImageHeight) bytes are the char image.
    //   Next 2 bytes are for unicode version.
    //
    while(Max >= Min) {
        Mid = (Max + Min) / 2;
        Index = Mid*Multiplier;

        if(Code == SbcsImages[Index]) {
            return(SbcsImages+Index+1);
        }

        if(Code < SbcsImages[Index]) {
            Max = Mid - 1;
        } else {
            Min = Mid + 1;
        }
    }

    //
    // ERROR: No image found.
    //
    return(NULL);
}

PBYTE
DbcsFontGetGraphicsChar(
    UCHAR Char
)
{
    if (Char >= 0 && Char < 0x20)
        return(GraphicsCharImage[Char]);
    else
        return(NULL);
}

BOOLEAN
DbcsFontIsGraphicsChar(
    UCHAR Char
)
{
    if (Char >= 0 && Char < 0x20)
        return(TRUE);
    else
        return(FALSE);
}

BOOLEAN
DbcsFontIsDBCSLeadByte(
    IN UCHAR c
    )

/*++

Routine Description:

    Checks to see if a char is a DBCS leadbyte.

Arguments:

    c - char to check if leadbyte or not.

Return Value:

    TRUE  - Leadbyte.
    FALSE - Non-Leadbyte.

--*/

{
    int i;

    //
    // Check to see if char is in leadbyte range.
    //
    // NOTE: If (CHAR)(0) is a valid leadbyte,
    // this routine will fail.
    //

    for( i = 0; BootFontHeader.DbcsLeadTable[i]; i += 2 )  {
        if ( BootFontHeader.DbcsLeadTable[i]   <= c &&
             BootFontHeader.DbcsLeadTable[i+1] >= c    )
            return( TRUE );
    }

    return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\spddlang\fe\fekbd.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    fekbd.c

Abstract:

    Japanese-specific keyboard stuff. For the Japanese market we need
    to detect a keyboard type (AX, 101, 106, IBM, etc) and allow the user
    to confirm. We do this because the keys on the keyboards are different
    and the user has to enter paths during setup. We also install keyboard
    support based on the user's selections here.

Author:

    Ted Miller (tedm) 04-July-1995

Revision History:

    Adapted from hideyukn and others' code in various places in setupldr
    and setupdd.sys.

--*/

#include <precomp.h>
#pragma hdrstop

//
// A note about screen usage:
//
// Screen that asks the user to select a keyboard type
// by pressing henkaku/zenkaku, spacebar, or s is SP_SCRN_LOCALE_SPECIFIC_1.
// Screen that asks the user to select from the master keyboard list
// is SP_SCRN_LOCALE_SPECIFIC_2.
// Screen that asks the user to confirm selection (y/n) is
// SP_SCRN_LOCALE_SPECIFIC_3.
//

PWSTR sz101KeyboardId    = L"STANDARD";
PWSTR sz106KeyboardId    = L"PCAT_106KEY";
PWSTR szAXKeyboardId     = L"AX_105KEY";
PWSTR szIBM002KeyboardId = L"IBM_002_106KEY";

PWSTR SIF_UNATTENDED    = L"Unattended";
PWSTR STF_ACCESSIBILITY = L"accessibility";


#define MENU_LEFT_X     15
#define MENU_WIDTH      (VideoVariables->ScreenWidth-(2*MENU_LEFT_X))
#define MENU_TOP_Y      16
#define MENU_HEIGHT     4

#define CLEAR_CLIENT_AREA()                         \
                                                    \
    SpvidClearScreenRegion(                         \
        0,                                          \
        HEADER_HEIGHT,                              \
        VideoVariables->ScreenWidth,                \
        VideoVariables->ScreenHeight-(HEADER_HEIGHT+STATUS_HEIGHT), \
        DEFAULT_BACKGROUND                          \
        )

#define CLEAR_STATUS_AREA()                         \
                                                    \
    SpvidClearScreenRegion(                         \
        0,                                          \
        VideoVariables->ScreenHeight-STATUS_HEIGHT, \
        VideoVariables->ScreenWidth,                \
        STATUS_HEIGHT,                              \
        DEFAULT_STATUS_BACKGROUND                   \
        )

VOID
FESelectKeyboard(
    IN PVOID SifHandle,
    IN PHARDWARE_COMPONENT *HwComponents,
    IN BOOLEAN bNoEasySelection,
    IN BOOLEAN CmdConsole
    )
{
    ULONG ValidKeys1[7] = { ' ','`','~','s','S',KEY_F3,0 };
    ULONG ValidKeys2[5] = { 'y','Y','n','N',0 };
    ULONG ValidKeys3[3] = { ASCI_CR,KEY_F3,0 };
    BOOLEAN Selected;
    BOOLEAN Done;
    PVOID Menu;
    ULONG Line;
    PWSTR Text,Key;
    ULONG_PTR Selection;
    ULONG Keypress;
    PWSTR SelectedKeyboardId;
    PWSTR Description;
    PHARDWARE_COMPONENT p;

    //
    // The 101 and 106 key keyboards are most popular so we present
    // a screen that is biased to them. It aksks the user to press
    // hankaku/zenkaku key for 106, space for 101, or S for other,
    // at which point they can select either of these or an IBM002 or
    // AX type.
    //
    // Then the user is asked to confirm selection with y or n (which
    // are the same scan code on all keyboards).
    //
    Done = FALSE;
    do {

        if(!bNoEasySelection) {

            //
            // Wait for the user to press henkaku/zenkaku, spacebar, or s.
            // We also give the option to exit Setup.
            //
            for(Selected=FALSE; !Selected; ) {

                CLEAR_CLIENT_AREA();
                CLEAR_STATUS_AREA();
                if (CmdConsole) {
                    SpDisplayScreen(SP_SCRN_LOCALE_SPECIFIC_4,3,HEADER_HEIGHT+3);
                } else {
                    SpDisplayScreen(SP_SCRN_LOCALE_SPECIFIC_1,3,HEADER_HEIGHT+3);
                }

                switch(SpWaitValidKey(ValidKeys1,NULL,NULL)) {

                case ' ':
                    //
                    // User selected 101 key.
                    //
                    Selected = TRUE;
                    SelectedKeyboardId = sz101KeyboardId;
                    break;

                case '`':
                case '~':
                    //
                    // 101 key mapping returns hankaku/zenkaku as ` key.
                    // User selected 106 key.
                    //
                    Selected = TRUE;
                    SelectedKeyboardId = sz106KeyboardId;
                    break;

                case 's':
                case 'S':
                    //
                    // User wants to select from the master list.
                    //
                    Selected = TRUE;
                    SelectedKeyboardId = NULL;
                    break;

                case KEY_F3:
                    //
                    // User wants to exit.
                    //
                    if (!CmdConsole) {
                        SpConfirmExit();
                    }
                    break;
                }
            }
        } else {
           SelectedKeyboardId = NULL;
        }

        //
        // If the user wants to select from the master list, do that here.
        //
        if(!SelectedKeyboardId) {

            Menu = SpMnCreate(MENU_LEFT_X,MENU_TOP_Y,MENU_WIDTH,MENU_HEIGHT);

            if (!Menu) {
                SpOutOfMemory();
                return;             // make prefix happy
            }
            
            Selection = 0;
            for(Line=0; Text=SpGetSectionLineIndex(SifHandle,szKeyboard,Line,0); Line++) {

                if(Key = SpGetKeyName(SifHandle,szKeyboard,Line)) {

                    SpMnAddItem(Menu,Text,MENU_LEFT_X+1,MENU_WIDTH-2,TRUE,(ULONG_PTR)Key);

                    if(!Selection) {
                        Selection = (ULONG_PTR)Key;
                    }
                }
            }

            for(Selected=FALSE; !Selected; ) {

                CLEAR_CLIENT_AREA();

                if (CmdConsole) {
                    SpDisplayScreen(SP_SCRN_LOCALE_SPECIFIC_5,3,HEADER_HEIGHT+3);
                }   else {
                    SpDisplayScreen(SP_SCRN_LOCALE_SPECIFIC_2,3,HEADER_HEIGHT+3);
                }
                if (CmdConsole) {
                    SpDisplayStatusOptions(
                        DEFAULT_STATUS_ATTRIBUTE,
                        SP_STAT_ENTER_EQUALS_SELECT,
                        0);
                } else {
                    SpDisplayStatusOptions(
                        DEFAULT_STATUS_ATTRIBUTE,
                        SP_STAT_ENTER_EQUALS_SELECT,
                        SP_STAT_F3_EQUALS_EXIT,
                        0);
                }

                SpMnDisplay(Menu,Selection,TRUE,ValidKeys3,NULL,NULL,&Keypress,&Selection);

                if(Keypress == ASCI_CR) {
                    //
                    // User made selection.
                    //
                    SelectedKeyboardId = (PWSTR)Selection;
                    Selected = TRUE;
                } else {
                    //
                    // User wants to quit.
                    //
                    if (!CmdConsole) {
                        SpConfirmExit();
                    }
                }
            }

            SpMnDestroy(Menu);

        }

        if(!bNoEasySelection) {

            Description = SpGetSectionKeyIndex(SifHandle,szKeyboard,SelectedKeyboardId,0);

            //
            // Confirm the user's choice of keyboard. He needs to press either y or n.
            //
            CLEAR_CLIENT_AREA();
            CLEAR_STATUS_AREA();

            SpStartScreen(
                SP_SCRN_LOCALE_SPECIFIC_3,
                3,
                HEADER_HEIGHT+3,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE,
                Description
                );

            switch(SpWaitValidKey(ValidKeys2,NULL,NULL)) {
            case 'y':
            case 'Y':
                Done = TRUE;
                break;
            }

        } else {
            Description = SpGetSectionKeyIndex(SifHandle,szKeyboard,SelectedKeyboardId,0);
            Done = TRUE;
        }

    } while(!Done);

    //
    // Reinitialize things in the hardware lists.
    //
    p = HwComponents[HwComponentKeyboard]->Next;
    SpFreeHwComponent(&HwComponents[HwComponentKeyboard],FALSE);

    HwComponents[HwComponentKeyboard] = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
    RtlZeroMemory(HwComponents[HwComponentKeyboard],sizeof(HARDWARE_COMPONENT));

    HwComponents[HwComponentKeyboard]->IdString = SpDupStringW(SelectedKeyboardId);
    HwComponents[HwComponentKeyboard]->Description = SpDupStringW(Description);
    HwComponents[HwComponentKeyboard]->Next = p;
}


VOID
FEUnattendSelectKeyboard(
    IN PVOID UnattendedSifHandle,
    IN PVOID SifHandle,
    IN PHARDWARE_COMPONENT *HwComponents
    )
{
    PWSTR   SelectedKeyboardId;
    PWSTR   Description;
    BOOLEAN DefaultIsUsed = FALSE;

    //
    // Get selected keyboard id from winnt.sif.
    //
    // *** Example for Japanese version ***
    //
    // [Unattended]
    //
    // KeyboardHardware = STANDARD | PCAT_106KEY | AX_105KEY | IBM_002_106KEY
    //
    // !!! NOTE !!!
    //
    // But actually, we should use [KeyboardDrivers] section for OEM-PreInstall.
    // We should not have this redundant data...
    //
    SelectedKeyboardId = SpGetSectionKeyIndex(UnattendedSifHandle,SIF_UNATTENDED,L"KeyboardHardware",0);

    //
    // if we fail to read unattend.txt(actually winnt.sif), use first keyboard as default.
    //
    if(SelectedKeyboardId == NULL) {
        //
        // check if any line in [accesibility]. 
        //
        // SpCountLinesInSection is better, but it doesn't share out.
        //
        if (SpGetSectionLineIndex(UnattendedSifHandle,STF_ACCESSIBILITY,0,0)) {
            if(IS_JAPANESE_VERSION(SifHandle)) {
                FESelectKeyboard(SifHandle, HwComponents, FALSE,FALSE);
            } else if(IS_KOREAN_VERSION(SifHandle)) {
                FESelectKeyboard(SifHandle, HwComponents, TRUE,FALSE);
            }
            return;
        }

        SelectedKeyboardId = SpGetKeyName(SifHandle,szKeyboard,0);
        if (SelectedKeyboardId == NULL) {
            //
            // At least, one line should be existed in [Keyboard] section.
            //
            SpFatalSifError(SifHandle,szKeyboard,NULL,0,0);
        }
        DefaultIsUsed = TRUE;
    }

    //
    // Get its Description from txtsetup.sif. This value will be used Hardware confirmation screen,
    // if "ConfirmHardware" in winnt.sif is "yes".
    //
    Description = SpGetSectionKeyIndex(SifHandle,szKeyboard,SelectedKeyboardId,0);

    //
    // if Description could not be got from txtsetup.sif. we might encounter the problem
    // that selected name from unattend.txt is not listed [Keyboard] section in txtsetup.sif.
    // Just fall into default case, select "106_TYPE keyboard"
    //
    if( Description == NULL ) {
        if( DefaultIsUsed ) {
            //
            // if we are here, default was selected. but there is no entry for default
            // keyboard in txtsetup.sif. just Popup error.
            //
            SpFatalSifError(SifHandle,szKeyboard,SelectedKeyboardId,0,0);
        } else {
            //
            // Get first line from txtsetup.sif...
            //
            SelectedKeyboardId = SpGetSectionLineIndex(SifHandle,szKeyboard,0,0);
            if (SelectedKeyboardId == NULL) {
                //
                // At least, one line should be existed in [Keyboard] section.
                //
                SpFatalSifError(SifHandle,szKeyboard,NULL,0,0);
            }
            //
            // Retry to get description with default.
            //
            Description = SpGetSectionKeyIndex(SifHandle,szKeyboard,SelectedKeyboardId,0);
        }
    }

    //
    // Reinitialize things in the hardware lists.
    //
    SpFreeHwComponent(&HwComponents[HwComponentKeyboard],TRUE);

    HwComponents[HwComponentKeyboard] = SpMemAlloc(sizeof(HARDWARE_COMPONENT));
    RtlZeroMemory(HwComponents[HwComponentKeyboard],sizeof(HARDWARE_COMPONENT));

    HwComponents[HwComponentKeyboard]->IdString = SpDupStringW(SelectedKeyboardId);
    HwComponents[HwComponentKeyboard]->Description = SpDupStringW(Description);
}

VOID
FEReinitializeKeyboard(
    IN  PVOID  SifHandle,
    IN  PWSTR  Directory,
    OUT PVOID *KeyboardVector,
    IN PHARDWARE_COMPONENT *HwComponents,
    IN  PWSTR  KeyboardLayoutDefault
    )
{
    PWSTR LayoutDll;
    PVOID Tables;
    NTSTATUS Status;

    //
    // Determine the correct layout dll.
    //
    LayoutDll = SpGetSectionKeyIndex(
                    SifHandle,
                    szKeyboard,
                    HwComponents[HwComponentKeyboard]->IdString,
                    3
                    );

    //
    // Don't need to load 101 key layout because it's already loaded.
    //
    if(LayoutDll && _wcsicmp(LayoutDll,KeyboardLayoutDefault)) {

        CLEAR_CLIENT_AREA();
        SpDisplayStatusText(
            SP_STAT_LOADING_KBD_LAYOUT,
            DEFAULT_STATUS_ATTRIBUTE,
            LayoutDll
            );

        Status = SpLoadKbdLayoutDll(Directory,LayoutDll,&Tables);
        if(NT_SUCCESS(Status)) {
            *KeyboardVector = Tables;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\spddlang\fe\feldraw.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    jpnldraw.c

Abstract:

    Line-draw related stuff for FarEast locale-specific
    setupdd.sys support module.

Author:

    Ted Miller (tedm) 04-July-1995

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

//
// Define mapping from line draw character index enum to
// unicode value.
//
WCHAR LineCharIndexToUnicodeValue[LineCharMax] = {

        0x0001,          // DoubleUpperLeft
        0x0002,          // DoubleUpperRight
        0x0003,          // DoubleLowerLeft
        0x0004,          // DoubleLowerRight
        0x0006,          // DoubleHorizontal
        0x0005,          // DoubleVertical
        0x0001,          // SingleUpperLeft
        0x0002,          // SingleUpperRight
        0x0003,          // SingleLowerLeft
        0x0004,          // SingleLowerRight
        0x0006,          // SingleHorizontal
        0x0005,          // SingleVertical
        0x0019,          // DoubleVerticalToSingleHorizontalRight,
        0x0017           // DoubleVerticalToSingleHorizontalLeft,
};



WCHAR
FEGetLineDrawChar(
    IN LineCharIndex WhichChar
    )

/*++

Routine Description:

    Retreive a unicode value corresponsing to a particular desired linedraw
    character. The FarEast font we use during Setup does not have these chars
    so they are actually hand-placed into the in-memory image of the font
    and we assign fake values that work during setup.

Arguments:

    WhichChar - indicates which line draw character's unicode value
        is desired.

Return Value:

    Unicode value for desired line draw character.

--*/

{
    ASSERT((ULONG)WhichChar < (ULONG)LineCharMax);

    return(  ((ULONG)WhichChar < (ULONG)LineCharMax)
             ? LineCharIndexToUnicodeValue[WhichChar] : L' '
           );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\spddlang\fe\fetext.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    fefont.c

Abstract:

    Text setup display support for FarEast text output.

Author:

    Hideyuki Nagase (hideyukn) 01-July-1994

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

PWCHAR PaddedString(int size, PWCHAR pwch, PWCHAR buffer);

ULONG
FEGetStringColCount(
    IN PCWSTR String
    )
{
    UNICODE_STRING UnicodeString;

    //
    // Each DBCS char takes 2 columns, and each SBCS char takes 1.
    // Thus each char takes as much space as the number of bytes
    // in its representation in codepage 932.
    //
    RtlInitUnicodeString(&UnicodeString,String);
    return(RtlxUnicodeStringToOemSize(&UnicodeString)-1);
}

PWSTR
FEPadString(
    IN int    Size,
    IN PCWSTR String
    )
{
    return(PaddedString(Size,(PWCHAR)String,NULL));
}

/***************************************************************************\
* BOOL IsFullWidth(WCHAR wch)
*
* Determine if the given Unicode char is fullwidth or not.
*
* History:
* 04-08-92 ShunK       Created.
\***************************************************************************/

BOOL IsFullWidth(WCHAR wch)
{
    if (wch <= 0x007f || (wch >= 0xff60 && wch <= 0xff9f))
        return(FALSE);  // Half width.
    else
        return(TRUE);   // Full width.
}

/***************************************************************************\
* BOOL SizeOfHalfWidthString(PWCHAR pwch)
*
* Determine size of the given Unicode string, adjusting for half-width chars.
*
* History:
* 08-08-93 FloydR      Created.
\***************************************************************************/

int  SizeOfHalfWidthString(PWCHAR pwch)
{
    int     c=0;

    while (*pwch) {
    if (IsFullWidth(*pwch))
        c += 2;
    else
        c++;
    pwch++;
    }
    return c;
}

/***************************************************************************\
* PWCHAR PaddedString(int size, PWCHAR pwch)
*
* Realize the string, left aligned and padded on the right to the field
* width/precision specified.
*
* Limitations:  This uses a static buffer under the assumption that
* no more than one such string is printed in a single 'printf'.
*
* History:
* 11-03-93 FloydR      Created.
\***************************************************************************/

WCHAR   PaddingBuffer[160];

PWCHAR
PaddedString(int size, PWCHAR pwch, PWCHAR buffer)
{
    int realsize;
    int fEllipsis = FALSE;

    if (buffer==NULL) buffer = PaddingBuffer;

    if (size < 0) {
    fEllipsis = TRUE;
    size = -size;
    }
    realsize = _snwprintf(buffer, 160, L"%-*.*ws", size, size, pwch);
    if (realsize == 0)
    return NULL;
    if (SizeOfHalfWidthString(buffer) > size) {
    do {
        buffer[--realsize] = L'\0';
    } while (SizeOfHalfWidthString(buffer) > size);

    if (fEllipsis && buffer[realsize-1] != L' ') {
        WCHAR Trail1 = buffer[realsize-2],
              Trail2 = buffer[realsize-1];
        int Length;

        PWCHAR pwCurrent = &(buffer[realsize-2]);

        if(!IsFullWidth(Trail2)) {
            *pwCurrent++ = L'.';
        } else {
            pwCurrent++;
        }

        if(!IsFullWidth(Trail1)) {
            *pwCurrent++ = L'.';
        } else {
            *pwCurrent++ = L'.';
            *pwCurrent++ = L'.';
        }

        *pwCurrent = L'\0';

        Length = SizeOfHalfWidthString(buffer);

        while( Length++ < size ) {
            *pwCurrent++ = L'.';
            *pwCurrent   = L'\0';
        }
    }
    }
    return buffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\spddlang\fe\fevideo.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    fevideo.h

Abstract:

    Header file for FarEast-specific display routines.

Author:

    Ted Miller (tedm) 4-July-1995

Revision History:

    Adapted from NTJ version of textmode\kernel\spvideop.h

--*/


//
// Vga Grahics mode display routine (spvidgv.c).
//

VOID
VgaGraphicsModeDisplayString(
    IN PSTR  String,
    IN UCHAR Attribute,
    IN ULONG X,                 // 0-based coordinates (character units)
    IN ULONG Y
    );

VOID
VgaGraphicsModeClearRegion(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG W,
    IN ULONG H,
    IN UCHAR Attribute
    );

VOID
VgaGraphicsModeSpecificInit(
    IN PVIDEO_MODE_INFORMATION VideoModes,
    IN ULONG                   NumberOfModes,
    IN ULONG                   ModeSize
    );

VOID
VgaGraphicsModeSpecificReInit(
    VOID
    );

VOID
VgaGraphicsModeSpecificTerminate(
    VOID
    );

BOOLEAN
VgaGraphicsModeSpecificInitPalette(
    VOID
    );

BOOLEAN
VgaGraphicsModeSpecificScrollUp(
    IN ULONG TopLine,
    IN ULONG BottomLine,
    IN ULONG LineCount,
    IN UCHAR FillAttribute
    );

extern VIDEO_FUNCTION_VECTOR VgaGraphicsModeVideoVector;


//
// Frame buffer routines (spvidgfb.c).
//


VOID
FrameBufferKanjiDisplayString(
    IN PSTR  String,
    IN UCHAR Attribute,
    IN ULONG X,                 // 0-based coordinates (character units)
    IN ULONG Y
    );

VOID
FrameBufferKanjiClearRegion(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG W,
    IN ULONG H,
    IN UCHAR Attribute
    );

VOID
FrameBufferKanjiSpecificInit(
    IN PVIDEO_MODE_INFORMATION VideoModes,
    IN ULONG                   NumberOfModes,
    IN ULONG                   ModeSize
    );

VOID
FrameBufferKanjiSpecificReInit(
    VOID
    );

VOID
FrameBufferKanjiSpecificTerminate(
    VOID
    );

BOOLEAN
FrameBufferKanjiSpecificInitPalette(
    VOID
    );

BOOLEAN
FrameBufferKanjiSpecificScrollUp(
    IN ULONG TopLine,
    IN ULONG BottomLine,
    IN ULONG LineCount,
    IN UCHAR FillAttribute
    );

extern VIDEO_FUNCTION_VECTOR FrameBufferKanjiVideoVector;

//
// Stuff shared between fefb.c and fevga.c.
//
extern ULONG FEFontCharacterHeight,FEFontCharacterWidth;
extern PSP_VIDEO_VARS VideoVariables;
extern USHORT FEFontDefaultChar;

#ifdef SP_IS_UPGRADE_GRAPHICS_MODE
#undef SP_IS_UPGRADE_GRAPHICS_MODE
#endif

#define SP_IS_UPGRADE_GRAPHICS_MODE()   (VideoVariables->UpgradeGraphicsMode)

#ifdef SP_SET_UPGRADE_GRAPHICS_MODE
#undef SP_SET_UPGRADE_GRAPHICS_MODE
#endif

#define SP_SET_UPGRADE_GRAPHICS_MODE(_Value)                  \
            (VideoVariables->UpgradeGraphicsMode = (_Value))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\spddlang\fe\fevideo.c ===
#include <precomp.h>
#pragma hdrstop

//
// Some globals
//
ULONG FEFontCharacterHeight,FEFontCharacterWidth;
PSP_VIDEO_VARS VideoVariables;
USHORT FEFontDefaultChar;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\spddlang\fe\fereg.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    fereg.c

Abstract:

    Japanese/korean-specific registry settings.

Author:

    Ted Miller (tedm) 04-July-1995

Revision History:

    Adapted from hideyukn's code in textmode\kernel\spconfig.c.

--*/

#include <precomp.h>
#pragma hdrstop

NTSTATUS
SpDeleteValueKey(
    IN  HANDLE     hKeyRoot,
    IN  PWSTR      KeyName,
    IN  PWSTR      ValueName
    );

NTSTATUS
FESetKeyboardParams(
    IN PVOID  SifHandle,
    IN HANDLE ControlSetKeyHandle,
    IN PHARDWARE_COMPONENT *HwComponents,
    IN PWSTR  LayerDriver
    )

/*++

Routine Description:

    Set parameters in the registry relating to the keyboard type
    selected by the user.

Arguments:

    SifHandle - supplies handle to open/loaded setup info file (txtsetup.sif).

    ControlSetKeyHandle - supplies handle to open registry key for current
        control set (ie, HKEY_LOCAL_MACHINE\CurrentControlSet).

    HwComponents - supplies the address of the master hardware components
        array.

Return Value:

    NT Status code indicating result of operation.

--*/

{
    WCHAR KeyEntryName[100] = L"Services\\";
    NTSTATUS Status;
    PWSTR KeyboardPortDriver;
    PWSTR KeyboardId;
    PWSTR KeyboardDll;
    PWSTR KeyboardPnPId;
    PWSTR KeyboardTypeStr;
    PWSTR KeyboardSubtypeStr;
    ULONG KeyboardType;
    ULONG KeyboardSubtype;
    ULONG val;
    PHARDWARE_COMPONENT hw;

    hw = HwComponents[HwComponentKeyboard];

    //
    // if third party's driver is selected, we don't write LayerDriver data
    // into registry.
    //
    if(hw->ThirdPartyOptionSelected) {

        //
        // [This modification is requested by Japanese hardware provider]
        //
        // if user replace keyboard port driver with thirdpartys one,
        // we should disable build-in keyboard port driver (i8042prt.sys)
        // because if i8042prt is initialized faster than OEM driver and
        // i8042prt can recoganize the port device, the oem driver will fail
        // to initialization due to conflict of hardware resorce.
        //
        // ** BUG BUG **
        //
        // how about mouse? mouse might use i8042prt, we should not disbale
        // it when user only replace keyboard port. this might causes critical
        // error. But I believe, the mouse device also handled by OEM port
        // driver.

        //
        // Disable the built-in port driver.
        //
        if(IS_FILETYPE_PRESENT(hw->FileTypeBits,HwFilePort)) {

            val = SERVICE_DISABLED;

            Status = SpOpenSetValueAndClose(
                        ControlSetKeyHandle,
                        L"Services\\i8042prt",
                        L"Start",
                        REG_DWORD,
                        &val,
                        sizeof(ULONG)
                        );
        } else {
            Status = STATUS_SUCCESS;
        }
    } else {
        //
        // Get keyboard port driver name and layer driver name from txtsetup.sif
        //
        KeyboardId = HwComponents[HwComponentKeyboard]->IdString;
        KeyboardPortDriver = SpGetSectionKeyIndex(SifHandle,szKeyboard,KeyboardId,2);
        KeyboardDll = SpGetSectionKeyIndex(SifHandle,szKeyboard,KeyboardId,3);
        KeyboardTypeStr = SpGetSectionKeyIndex(SifHandle,szKeyboard,KeyboardId,4);
        KeyboardSubtypeStr = SpGetSectionKeyIndex(SifHandle,szKeyboard,KeyboardId,5);
        KeyboardPnPId = SpGetSectionKeyIndex(SifHandle,szKeyboard,KeyboardId,6);

        if(KeyboardPortDriver && KeyboardDll) {
            //
            // Build registry path such as L"Services\\KeyboardPortDriver\\Parameters"
            // and write into registry.
            //
            wcscat(KeyEntryName,KeyboardPortDriver);
            wcscat(KeyEntryName,L"\\Parameters");

            //
            // Save Keyboard layout driver name.
            //
            Status = SpOpenSetValueAndClose(
                        ControlSetKeyHandle,
                        KeyEntryName,
                        LayerDriver,
                        REG_SZ,
                        KeyboardDll,
                        (wcslen(KeyboardDll)+1)*sizeof(WCHAR)
                        );

            if(NT_SUCCESS(Status)) {

                if (KeyboardPnPId) {
                    //
                    // Save Keyboard PnP Id.
                    //
                    Status = SpOpenSetValueAndClose(
                                ControlSetKeyHandle,
                                KeyEntryName,
                                L"OverrideKeyboardIdentifier",
                                REG_SZ,
                                KeyboardPnPId,
                                (wcslen(KeyboardPnPId)+1)*sizeof(WCHAR)
                                );
                }

                if(KeyboardTypeStr && KeyboardSubtypeStr) {
 
                    UNICODE_STRING UnicodeString;

                    //
                    // Convert the string to DWORD value.
                    //
                    RtlInitUnicodeString(&UnicodeString,KeyboardTypeStr);
                    RtlUnicodeStringToInteger(&UnicodeString,10,&KeyboardType);

                    RtlInitUnicodeString(&UnicodeString,KeyboardSubtypeStr);
                    RtlUnicodeStringToInteger(&UnicodeString,10,&KeyboardSubtype);

                    Status = SpOpenSetValueAndClose(
                                ControlSetKeyHandle,
                                KeyEntryName,
                                L"OverrideKeyboardType",
                                REG_DWORD,
                                &KeyboardType,
                                sizeof(ULONG)
                                );

                    if(NT_SUCCESS(Status)) {

                        Status = SpOpenSetValueAndClose(
                                    ControlSetKeyHandle,
                                    KeyEntryName,
                                    L"OverrideKeyboardSubtype",
                                    REG_DWORD,
                                    &KeyboardSubtype,
                                    sizeof(ULONG)
                                    );
                    }
                }
            }
        } else {
            Status = STATUS_SUCCESS;
        }
    }
    return(Status);
}

NTSTATUS
FEUpgradeKeyboardParams(
    IN PVOID  SifHandle,
    IN HANDLE ControlSetKeyHandle,
    IN PHARDWARE_COMPONENT *HwComponents,
    IN PWSTR  LayerDriver
    )
{
    BYTE  DataBuffer[256];
    ULONG LayerDriverLength;
    PWSTR LayerDriverCandidate;

    PWSTR LayerDriverName = NULL;
    PWSTR KeyboardTypeStr = NULL;
    PWSTR KeyboardSubtypeStr = NULL;
    PWSTR KeyboardPnPId = NULL;
    ULONG KeyboardType;
    ULONG KeyboardSubtype;

    NTSTATUS Status;
    ULONG    LineIndex;

    UNICODE_STRING UnicodeString;

    //
    // This code is hardly depended on 'i8042prt.sys'.
    // if the active driver for keyboard is not 'i8042prt.sys',
    // we don't need to do this, but we write down this to registry for just in case.
    //

    //
    // Get current keyboard layout driver name.
    //

    //
    // from NT5, the keyword LayerDriver has been changed to 
    //
    // "LayerDriver JPN" | "LayerDriver KOR" 
    //
    // Since NT5 sets KeyboardType & KeyboardSubtype correctly
    //
    // When new LayerDriver key is opened successfully, 
    //
    // it means system is >= NT5 and we don't need to do more.
    //
    
    Status = SpGetValueKey(ControlSetKeyHandle,
                           L"Services\\i8042prt\\Parameters",
                           LayerDriver,
                           sizeof(DataBuffer),
                           DataBuffer,
                           &LayerDriverLength);

    if (NT_SUCCESS(Status)) {
        return (STATUS_SUCCESS);
    }

    Status = SpGetValueKey(ControlSetKeyHandle,
                           L"Services\\i8042prt\\Parameters",
                           L"LayerDriver",
                           sizeof(DataBuffer),
                           DataBuffer,
                           &LayerDriverLength);

    if (NT_SUCCESS(Status)) {

        //
        // Get pointer to registry data.
        //
        LayerDriverName = (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)DataBuffer)->Data);

        //
        // Search driver name from txtsetup.sif.
        //
        for (LineIndex = 0; ; LineIndex++) {

            //
            // Get candidate layout driver name for this line.
            //
            LayerDriverCandidate = SpGetSectionLineIndex(SifHandle,szKeyboard,LineIndex,3);

            if (LayerDriverCandidate == NULL) {

                //
                // We may reach at end of the list.
                //
                break;
            }

            //
            // Compare this candidate with active layout driver.
            //
            if (_wcsicmp(LayerDriverName,LayerDriverCandidate) == 0) {

                //
                // This is what we want, Get KeyboardType and SubType from Sif.
                //
                KeyboardTypeStr = SpGetSectionLineIndex(SifHandle,szKeyboard,LineIndex,4);
                KeyboardSubtypeStr = SpGetSectionLineIndex(SifHandle,szKeyboard,LineIndex,5);
                KeyboardPnPId = SpGetSectionLineIndex(SifHandle,szKeyboard,LineIndex,6);
            
                break;
            }
        }

        Status = SpOpenSetValueAndClose(
                    ControlSetKeyHandle,
                    L"Services\\i8042prt\\Parameters",
                    LayerDriver,
                    REG_SZ,
                    LayerDriverName,
                    (wcslen(LayerDriverName)+1)*sizeof(WCHAR)
                    );

        if (NT_SUCCESS(Status)) {
            Status = SpDeleteValueKey(
                         ControlSetKeyHandle,
                         L"Services\\i8042prt\\Parameters",
                         L"LayerDriver"
                         );

        }
    }

    if (KeyboardPnPId) {
        //
        // Save Keyboard PnP Id.
        //
        Status = SpOpenSetValueAndClose(
                     ControlSetKeyHandle,
                     L"Services\\i8042prt\\Parameters",
                     L"OverrideKeyboardIdentifier",
                     REG_SZ,
                     KeyboardPnPId,
                     (wcslen(KeyboardPnPId)+1)*sizeof(WCHAR)
                     );
    }

    if ((KeyboardTypeStr == NULL) || (KeyboardSubtypeStr == NULL)) {

        //
        // We could not find the driver from list, just use default..
        //
        KeyboardTypeStr = SpGetSectionKeyIndex(SifHandle,szKeyboard,L"STANDARD",4);
        KeyboardSubtypeStr = SpGetSectionKeyIndex(SifHandle,szKeyboard,L"STANDARD",5);

        if ((KeyboardTypeStr == NULL) || (KeyboardSubtypeStr == NULL)) {

            //
            // if it still has problem. set hardcodeed default (PC/AT Enhanced)...
            //
            KeyboardTypeStr = L"4\0";
            KeyboardSubtypeStr = L"0\0";
        }
    }

    //
    // Convert the string to DWORD value.
    //
    RtlInitUnicodeString(&UnicodeString,KeyboardTypeStr);
    RtlUnicodeStringToInteger(&UnicodeString,10,&KeyboardType);

    RtlInitUnicodeString(&UnicodeString,KeyboardSubtypeStr);
    RtlUnicodeStringToInteger(&UnicodeString,10,&KeyboardSubtype);

    //
    // Updates registry.
    //
    Status = SpOpenSetValueAndClose(
                ControlSetKeyHandle,
                L"Services\\i8042prt\\Parameters",
                L"OverrideKeyboardType",
                REG_DWORD,
                &KeyboardType,
                sizeof(ULONG)
                );

    if(NT_SUCCESS(Status)) {

        Status = SpOpenSetValueAndClose(
                    ControlSetKeyHandle,
                    L"Services\\i8042prt\\Parameters",
                    L"OverrideKeyboardSubtype",
                    REG_DWORD,
                    &KeyboardSubtype,
                    sizeof(ULONG)
                    );
    }

    KdPrint(("KEYBOARD UPGRADE INFORMATION\n"));
    KdPrint(("  Current Keyboard layout     = %ws\n",LayerDriverName));
    KdPrint(("  Upgrade keyboard Type       = %d\n",KeyboardType));
    KdPrint(("  Upgrade keyboard Subtype    = %d\n",KeyboardSubtype));
    KdPrint(("  Upgrade keyboard identifier = %ws\n",KeyboardPnPId));

    return(Status);
}

#define KEYBOARD_LAYOUTS_PATH  L"Control\\Keyboard Layouts"
#define IME_FILE_NAME          L"IME file"
#define LAYOUT_TEXT_NAME       L"Layout Text"

NTSTATUS
FEUpgradeKeyboardLayout(
    IN HANDLE ControlSetKeyHandle,
    IN PWSTR  OldDefaultIMEName,
    IN PWSTR  NewDefaultIMEName,
    IN PWSTR  NewDefaultIMEText
    )
{
    OBJECT_ATTRIBUTES KeyRootObjA;
    OBJECT_ATTRIBUTES KeyNodeObjA;
    HANDLE KeyRoot;
    HANDLE KeyNode;
    NTSTATUS Status;
    DWORD ResultLength;

    UNICODE_STRING KeyboardRoot;
    UNICODE_STRING KeyboardNode;
    UNICODE_STRING IMEFile;
    UNICODE_STRING LayoutText;

    PBYTE DataBuffer[256];
    WCHAR NodeKeyPath[64];
    WCHAR SubKeyName[16];

    ULONG EnumerateIndex = 0;

    //
    // Initalize "IME file" and "Layout Text".
    //
    RtlInitUnicodeString(&IMEFile,IME_FILE_NAME);
    RtlInitUnicodeString(&LayoutText,LAYOUT_TEXT_NAME);

    //
    // Build Registry path for "keyboard Layouts".
    //
    RtlInitUnicodeString(&KeyboardRoot,KEYBOARD_LAYOUTS_PATH);

    //
    // Open "Keyboard Layouts" key.
    //
    InitializeObjectAttributes(&KeyRootObjA,
                               &KeyboardRoot,
                               OBJ_CASE_INSENSITIVE,
                               ControlSetKeyHandle, NULL); 

    Status = ZwOpenKey(&KeyRoot,KEY_ALL_ACCESS,&KeyRootObjA);

    if (!NT_SUCCESS(Status)) {

        KdPrint(("SPDDLANG:Fail to open (%x) (%ws)\n",Status,KeyboardRoot.Buffer));
        //
        // If we fail here, it might be upgrade from NT 3.1 or 3.5... 
        // Then just return as SUCCESS.
        //
        return (STATUS_SUCCESS);
    }

    //
    // Enumerate installed keyboard layouts..
    //
    while (TRUE) {

        Status = ZwEnumerateKey(KeyRoot,
                                EnumerateIndex,
                                KeyBasicInformation,
                                (PKEY_BASIC_INFORMATION)DataBuffer,
                                sizeof(DataBuffer),
                                &ResultLength);

        if (!NT_SUCCESS(Status)) {
            //
            // we might reach end of data...
            //
            break;
        }

        //
        // Initialize subkey buffer.
        //
        RtlZeroMemory(SubKeyName,sizeof(SubKeyName));

        //
        // Get subkey name..
        //
        RtlCopyMemory(SubKeyName,
                      ((PKEY_BASIC_INFORMATION)DataBuffer)->Name,
                      ((PKEY_BASIC_INFORMATION)DataBuffer)->NameLength);

        //
        // We know the key is everytime '8' characters...
        //
        if (((PKEY_BASIC_INFORMATION)DataBuffer)->NameLength != 0x10) {
            SubKeyName[8] = L'\0';
        }

        //
        // Build path for sub keys
        //
        wcscpy(NodeKeyPath,KEYBOARD_LAYOUTS_PATH);

        KeyboardNode.Buffer = NodeKeyPath;
        KeyboardNode.Length = wcslen(NodeKeyPath) * sizeof(WCHAR);
        KeyboardNode.MaximumLength = sizeof(NodeKeyPath);

        RtlAppendUnicodeToString(&KeyboardNode,L"\\");
        RtlAppendUnicodeToString(&KeyboardNode,SubKeyName);

        KdPrint(("SPDDLANG:SubKey = %ws\n",KeyboardNode.Buffer));

        //
        // Open its subkey...
        //
        InitializeObjectAttributes(&KeyNodeObjA,
                                   &KeyboardNode,
                                   OBJ_CASE_INSENSITIVE,
                                   ControlSetKeyHandle, NULL);

        Status = ZwOpenKey(&KeyNode,KEY_ALL_ACCESS,&KeyNodeObjA);

        if (!NT_SUCCESS(Status)) {

            KdPrint(("SPDDLANG:Fail to open (%x) (%ws)\n",Status,KeyboardNode.Buffer));

            //
            // We should not encounter error, because the key should be exist...
            // Anyway, continue to enumerate...
            //
            EnumerateIndex++;
            continue;
        }

        //
        // Find "IME file" value key.
        //
        Status = ZwQueryValueKey(KeyNode,
                                 &IMEFile,
                                 KeyValuePartialInformation,
                                 (PKEY_VALUE_PARTIAL_INFORMATION)DataBuffer,
                                 sizeof(DataBuffer),
                                 &ResultLength);

        if (NT_SUCCESS(Status)) {

            PWSTR IMEFileName = (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)DataBuffer)->Data);

            //
            // Upcases the file name..
            //
            _wcsupr(IMEFileName);

            if (wcsstr(IMEFileName,L".EXE")) {

                KdPrint(("SPDDLANG:Delete IME file = %ws\n",IMEFileName));

                //
                // This is Old "EXE" type IME file, let it deleted.
                //
                ZwDeleteKey(KeyNode);

                //
                // Adjust enumeration number...
                //
                EnumerateIndex--;

            } else {

                KdPrint(("SPDDLANG:Keep IME file = %ws\n",IMEFileName));

                //
                // This might be New "DLL" type IME file. let it be as is..
                //

                if (OldDefaultIMEName && NewDefaultIMEName) {

                    //
                    // if this entry is for 3.x default IME. let it upgrade to new one.
                    //

                    if (wcsstr(IMEFileName,OldDefaultIMEName)) {

                        KdPrint(("SPDDLANG:Upgrade IME file = %ws to %ws\n",
                                                       IMEFileName,NewDefaultIMEName));

                        //
                        // Upgrade IME.
                        //
                        Status = ZwSetValueKey(KeyNode,
                                               &IMEFile,
                                               0,
                                               REG_SZ,
                                               (PVOID) NewDefaultIMEName,
                                               (wcslen(NewDefaultIMEName)+1)*sizeof(WCHAR));

                        //
                        // Upgrade "Layout Text" also ?
                        //
                        if (NewDefaultIMEText) {

                            Status = ZwSetValueKey(KeyNode,
                                                   &LayoutText,
                                                   0,
                                                   REG_SZ,
                                                   (PVOID) NewDefaultIMEText,
                                                   (wcslen(NewDefaultIMEText)+1)*sizeof(WCHAR));
                        }
                    }
                }
            }

        } else {

            KdPrint(("SPDDLANG:no IME file\n"));

            //
            // This layout seems like does not have any IME, just leave it there.
            //
            Status = STATUS_SUCCESS;
        }

        ZwClose(KeyNode);

        //
        // Enumerate next..
        //
        EnumerateIndex++;
    }

    ZwClose(KeyRoot);

    KdPrint(("SPDDLANG:Retcode = %x\n",Status));

    if (Status == STATUS_NO_MORE_ENTRIES) {
        //
        // We enumerate all of sub keys...
        //
        Status = STATUS_SUCCESS;
    }

    return (Status);
}


#define DOSDEV_REG_PATH  L"Control\\Session Manager\\DOS Devices"

NTSTATUS
FEUpgradeRemoveMO(
    IN HANDLE ControlSetKeyHandle)
{
    OBJECT_ATTRIBUTES KeyRootObjA;
    HANDLE KeyRoot;
    NTSTATUS Status;
    DWORD ResultLength;

    UNICODE_STRING DosDevice;
    UNICODE_STRING UnicodeValueName;

    BYTE  DataBuffer[512];
    WCHAR NodeKeyPath[64];
    WCHAR ValueName[256];
    PKEY_VALUE_FULL_INFORMATION ValueInfo;
    PKEY_VALUE_PARTIAL_INFORMATION DataInfo;

    ULONG EnumerateIndex = 0;

    //
    // Build Registry path for "Control\\Session Manager\\DOS Devices".
    //
    RtlInitUnicodeString(&DosDevice,DOSDEV_REG_PATH);

    //
    // Open "DOS Devices" key.
    //
    InitializeObjectAttributes(&KeyRootObjA,
                               &DosDevice,
                               OBJ_CASE_INSENSITIVE,
                               ControlSetKeyHandle, NULL); 

    Status = ZwOpenKey(&KeyRoot,KEY_ALL_ACCESS,&KeyRootObjA);

    if (!NT_SUCCESS(Status)) {

        KdPrint(("SPDDLANG:Fail to open (%x) (%ws)\n",Status,DosDevice.Buffer));
        //
        // If we fail here, it might be upgrade from NT 3.1 or 3.5... 
        // Then just return as SUCCESS.
        //
        return (STATUS_SUCCESS);
    }

    ValueInfo = (PKEY_VALUE_FULL_INFORMATION) DataBuffer;

    //
    // Enumerate all installed devices..
    //
    while (TRUE) {

        Status = ZwEnumerateValueKey(KeyRoot,
                                     EnumerateIndex,
                                     KeyValueFullInformation,
                                     DataBuffer,
                                     sizeof(DataBuffer),
                                     &ResultLength);

        if (!NT_SUCCESS(Status)) {
            //
            // we might reach end of data...
            //
            break;
        }

        //
        // Get subkey name..
        //
        RtlCopyMemory((PBYTE)ValueName,
                      ValueInfo->Name,
                      ValueInfo->NameLength);

        ValueName[ValueInfo->NameLength / sizeof(WCHAR)] = UNICODE_NULL;
        RtlInitUnicodeString(&UnicodeValueName,ValueName);

        Status = ZwQueryValueKey(KeyRoot,
                                 &UnicodeValueName,
                                 KeyValuePartialInformation,
                                 DataBuffer,
                                 sizeof(DataBuffer),
                                 &ResultLength);

        DataInfo = (PKEY_VALUE_PARTIAL_INFORMATION) DataBuffer;
        if (NT_SUCCESS(Status)) {

            PWSTR PathData = (PWSTR)(DataInfo->Data);

            //
            // Upcases the file name..
            //
            _wcsupr(PathData);


            if (wcsstr(PathData,L"\\OPTICALDISK")) {
                KdPrint(("SPDDLANG:Delete MO %ws = %ws\n",ValueName,PathData));
                Status = SpDeleteValueKey(
                             ControlSetKeyHandle,
                             DOSDEV_REG_PATH,
                             ValueName
                             );

            }
        }

        //
        // Enumerate next..
        //
        EnumerateIndex++;
    }

    ZwClose(KeyRoot);

    KdPrint(("SPDDLANG:Retcode = %x\n",Status));

    if (Status == STATUS_NO_MORE_ENTRIES) {
        //
        // We enumerate all of sub keys...
        //
        Status = STATUS_SUCCESS;
    }

    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\spddlang\fe\hw.h ===
/******************************Module*Header*******************************\
* Module Name: hw.h
*
* All the hardware specific driver file stuff.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

//  Miscellaneous Registers used only at EGA/VGA initialization time

#define MISC_OUTPUT         0x0C2       // Miscellaneous Output Register
#define CRTC_ADDR           0x0D4       // CRTC Address Register for color mode
#define CRTC_DATA           0x0D5       // CRTC Data    Register for color mode
#define GRAF_1_POS          0x0CC       // Graphics 1 Address Register
#define GRAF_2_POS          0x0CA       // Graphics 2 Address Register
#define ATTR_READ           0x0DA       // Attribute Controler Read  Address
#define ATTR_WRITE          0x0C0       // Attribute Controler Write Address
#define IN_STAT_0           0x0C2       // Input Status Register 0
#define IN_STAT_1           0x0DA       // Input Status Register 1

//  EGA/VGA Register Definitions.
//
//  The following definitions are the EGA/VGA registers and values
//  used by this driver.  All other registers are set up at
//  when the EGA/VGA is placed into graphics mode and never altered
//  afterwards.
//
//  All unspecified bits in the following registers must be 0.

#define EGA_BASE            0x300       // Base address of the EGA (3xx)
#define VGA_BASE            0x300       // Base address of the VGA (3xx)

//  SEQUencer Registers Used

#define SEQ_ADDR            0xC4        // SEQUencer Address Register
#define SEQ_DATA            0xC5        // SEQUencer Data    Register

#define SEQ_MAP_MASK        0x02        // Write Plane Enable Mask
#define MM_C0               0x01        // C0 plane enable
#define MM_C1               0x02        // C1 plane enable
#define MM_C2               0x04        // C2 plane enable
#define MM_C3               0x08        // C3 plane enable
#define MM_ALL              0x0f        // All planes

#define SEQ_MODE            0x04        // Memory Mode
#define SM_ALPHA            0x01        // Char map select enable
#define SM_EXTENDED         0x02        // Extended memory present
#define SM_ODD_PLANE        0x04        // Odd/even bytes to same plane

//  Graphics Controller Registers Used

#define GRAF_ADDR           0xCE        // Graphics Controller Address Register
#define GRAF_DATA           0xCF        // Graphics Controller Data    Register

#define GRAF_SET_RESET      0x00        // Set/Reset Plane Color
#define GRAF_ENAB_SR        0x01        // Set/Reset Enable
#define GRAF_COL_COMP       0x02        // Color Compare Register

#define GRAF_DATA_ROT       0x03        // Data Rotate Register
#define DR_ROT_CNT          0x07        //   Data Rotate Count
#define DR_SET              0x00        //   Data Unmodified
#define DR_AND              0x08        //   Data ANDed with latches
#define DR_OR               0x10        //   Data ORed  with latches
#define DR_XOR              0x18        //   Data XORed with latches

#define GRAF_READ_MAP       0x04        // Read Map Select Register
#define RM_C0               0x00        //   Read C0 plane
#define RM_C1               0x01        //   Read C1 plane
#define RM_C2               0x02        //   Read C2 plane
#define RM_C3               0x03        //   Read C3 plane

#define GRAF_MODE           0x05        // Mode Register
#define M_PROC_WRITE        0x00        //   Write processor data rotated
#define M_LATCH_WRITE       0x01        //   Write latched data
#define M_COLOR_WRITE       0x02        //   Write processor data as color
#define M_AND_WRITE         0x03        //   Write (procdata AND bitmask)
#define M_DATA_READ         0x00        //   Read selected plane
#define M_COLOR_READ        0x08        //   Read color compare

#define GRAF_MISC           0x06        // Miscellaneous Register
#define MS_NON_ALPHA        0x01        //   Char generator disabled
#define MS_ODD_EVEN         0x02        //   Map odd addresses to even
#define MS_A0000_128K       0x00        //   Memory present at A0000, 128kb
#define MS_A0000_64K        0x04        //   Memory present at A0000, 64kb
#define MS_B0000_32K        0x08        //   Memory present at B0000, 32kb
#define MS_B8000_32K        0x0C        //   Memory present at B8000, 32kb
#define MS_ADDR_MASK        0x0C

#define GRAF_CDC            0x07        // Color Don't Care Register
#define GRAF_BIT_MASK       0x08        // Bit Mask Register

////////////////////////////////////////////////////////////////////////
// Direct access macros
//

#define OUT_WORD(pjBase, addr, w)                           \
{                                                           \
    MEMORY_BARRIER();                                       \
    WRITE_PORT_USHORT((BYTE*) (pjBase) + (addr), (USHORT) (w)); \
}

#define OUT_BYTE(pjBase, addr, j)                           \
{                                                           \
    MEMORY_BARRIER();                                       \
    WRITE_PORT_UCHAR((BYTE*) (pjBase) + (addr), (UCHAR) (j)); \
}

#define WRITE_WORD(pwAddr, w)                               \
    WRITE_REGISTER_USHORT((USHORT*) (pwAddr), (USHORT) (w))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\spddlang\fe\ioaccess.h ===
/*++

Copyright (c) 1989-1995   Microsoft Corporation

Module Name:

    ioaccess.h

Abstract:

    Definitions of function prototypes for accessing I/O ports and
    memory on I/O adapters from display drivers.

    Cloned from parts of nti386.h.

Author:


--*/


//
// Memory barriers on AMD64, X86 and IA64 are not required since the Io
// Operations are always garanteed to be executed in order
//

#if defined(_AMD64_) || defined(_X86_) || defined(_IA64_)

#define MEMORY_BARRIER() 0

#else
#error "No Target Architecture"
#endif

//
// I/O space read and write macros.
//

#if defined(_X86_)

#define READ_REGISTER_UCHAR(Register)          (*(volatile UCHAR *)(Register))
#define READ_REGISTER_USHORT(Register)         (*(volatile USHORT *)(Register))
#define READ_REGISTER_ULONG(Register)          (*(volatile ULONG *)(Register))
#define WRITE_REGISTER_UCHAR(Register, Value)  (*(volatile UCHAR *)(Register) = (Value))
#define WRITE_REGISTER_USHORT(Register, Value) (*(volatile USHORT *)(Register) = (Value))
#define WRITE_REGISTER_ULONG(Register, Value)  (*(volatile ULONG *)(Register) = (Value))
#define READ_PORT_UCHAR(Port)                  inp (Port)
#define READ_PORT_USHORT(Port)                 inpw (Port)
#define READ_PORT_ULONG(Port)                  inpd (Port)
#define WRITE_PORT_UCHAR(Port, Value)          outp ((Port), (Value))
#define WRITE_PORT_USHORT(Port, Value)         outpw ((Port), (Value))
#define WRITE_PORT_ULONG(Port, Value)          outpd ((Port), (Value))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\spddlang\fe\fevga.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    fevga.c (was textmode\kernel\spvidgvg.c)

Abstract:

    Text setup display support for Vga (Graphics mode) displays.

Author:

    Hideyuki Nagase (hideyukn) 01-July-1994

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

#if defined(_X86_)
#undef READ_PORT_UCHAR
#undef READ_PORT_USHORT
#undef READ_PORT_ULONG
#undef WRITE_PORT_UCHAR
#undef WRITE_PORT_USHORT
#undef WRITE_PORT_ULONG
#undef READ_REGISTER_UCHAR
#undef READ_REGISTER_USHORT
#undef READ_REGISTER_ULONG
#undef WRITE_REGISTER_UCHAR
#undef WRITE_REGISTER_USHORT
#undef WRITE_REGISTER_ULONG
#endif

#include "ioaccess.h"

//
// Include VGA hardware header
//
#include "hw.h"

//
// Vector for vga graphics mode functions.
//

#define GET_IMAGE(p)                  (*p)
#define GET_IMAGE_POST_INC(p)         (*p); p++;
#define GET_IMAGE_REVERSE(p)          ((*p) ^ 0xFF)
#define GET_IMAGE_POST_INC_REVERSE(p) ((*p) ^ 0xFF); p++;
#define BIT_OFF_IMAGE         0x00
#define BIT_ON_IMAGE          0xFF

#define WRITE_GRAPHICS_CONTROLLER(x) VgaGraphicsModeWriteController((x))

VIDEO_FUNCTION_VECTOR VgaGraphicsModeVideoVector =

    {
        VgaGraphicsModeDisplayString,
        VgaGraphicsModeClearRegion,
        VgaGraphicsModeSpecificInit,
        VgaGraphicsModeSpecificReInit,
        VgaGraphicsModeSpecificTerminate,
        VgaGraphicsModeSpecificInitPalette,
        VgaGraphicsModeSpecificScrollUp
    };

//
// Number of bytes that make up a row of characters.
// Equal to the screen stride (number of bytes on a scan line)
// multiplies by the height of a char in bytes.
//
ULONG CharRowDelta;
ULONG CharLineFeed;

extern BOOTFONTBIN_HEADER BootFontHeader;

BOOLEAN VgaGraphicsModeInitialized = FALSE;
BOOLEAN VgaGraphicsModeFontInit = FALSE;

PVOID   VgaGraphicsControllerPort = NULL;

VOID
VgaGraphicsModeInitRegs(
    VOID
    );

VOID
VgaGraphicsModeSetAttribute(
    UCHAR Attribute
    );

ULONG
pVgaGraphicsModeDetermineModeToUse(
    IN PVIDEO_MODE_INFORMATION VideoModes,
    IN ULONG                   NumberOfModes
    );

VOID
VgaGraphicsModeWriteController(
    WORD Data
    );

VOID
VgaGraphicsModeSpecificInit(
    IN PVIDEO_MODE_INFORMATION VideoModes,
    IN ULONG                   NumberOfModes,
    IN ULONG                   ModeSize
    )

/*++

Routine Description:

    Perform frame buffer specific initialization.  This includes

    - setting the desired video mode.

Arguments:

    None.

Return Value:

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    VIDEO_MODE VideoMode;
    ULONG mode;
    VIDEO_CURSOR_ATTRIBUTES VideoCursorAttributes;

    PVIDEO_MODE_INFORMATION pVideoMode = &VideoModes[0];

    if(VgaGraphicsModeInitialized) {
        return;
    }

    //
    // Find out our 640*480 graphics mode
    //

    //
    // Try to find VGA standard mode.
    //
    for(mode=0; mode<NumberOfModes; mode++) {

        if( (pVideoMode->AttributeFlags & VIDEO_MODE_GRAPHICS)
        && !(pVideoMode->AttributeFlags & VIDEO_MODE_NO_OFF_SCREEN)
        &&  (pVideoMode->VisScreenWidth == 640)
        &&  (pVideoMode->VisScreenHeight == 480)
        &&  (pVideoMode->BitsPerPlane == 1 )
        &&  (pVideoMode->NumberOfPlanes == 4 ) )
        {
            break;
        }

        pVideoMode = (PVIDEO_MODE_INFORMATION) (((PUCHAR) pVideoMode) + ModeSize);
    }

    if(mode == (ULONG)(-1)) {
        KdPrint(("SETUP: Desired video mode not supported!\n"));
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_BADMODE, 0);
        while(TRUE);    // loop forever
    }

    //
    // Save away the mode info in a global.
    //
    VideoVariables->VideoModeInfo = VideoModes[mode];

    //
    // Set the desired mode.
    //
    VideoMode.RequestedMode = VideoVariables->VideoModeInfo.ModeIndex;

    //
    // Change the video mode
    //
    Status = ZwDeviceIoControlFile(
                VideoVariables->hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_SET_CURRENT_MODE,
                &VideoMode,
                sizeof(VideoMode),
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: Unable to set mode %u (status = %lx)\n",VideoMode.RequestedMode,Status));
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_SETMODE, Status);
        while(TRUE);    // loop forever
    }

    //
    // Set up some global data.
    //
    // 80 * 25 Text screen.
    //
    // ( 8 * 80 = 640 ) , ( 19 * 25 = 475 )
    //
    VideoVariables->ScreenWidth  = 80; // VideoModeInfo.ScreenStride / usSBCSCharWidth;
    VideoVariables->ScreenHeight = 25;

    //
    // Logical FontGlyph information
    //
    FEFontCharacterHeight = BootFontHeader.CharacterImageHeight +
                            BootFontHeader.CharacterTopPad +
                            BootFontHeader.CharacterBottomPad;
    FEFontCharacterWidth  = BootFontHeader.CharacterImageSbcsWidth;

    CharLineFeed = FEFontCharacterHeight;
    CharRowDelta = VideoVariables->VideoModeInfo.ScreenStride * CharLineFeed;

    //
    // Map the video memory.
    //
    pSpvidMapVideoMemory(TRUE);

    //
    // Set initialized flag
    //
    VgaGraphicsModeInitialized = TRUE;

    //
    // Initialize vga registers
    //
    VgaGraphicsModeInitRegs();

    VideoVariables->ActiveVideoBuffer = VideoVariables->VideoMemoryInfo.FrameBufferBase;

    //
    // Allocate background VGA buffer, if needed
    //
    if (SP_IS_UPGRADE_GRAPHICS_MODE()) {
        VideoVariables->VideoBufferSize = VideoVariables->VideoMemoryInfo.FrameBufferLength;

        VideoVariables->VideoBuffer = SpMemAlloc(VideoVariables->VideoBufferSize);

        if (VideoVariables->VideoBuffer) {
            VideoVariables->ActiveVideoBuffer = VideoVariables->VideoBuffer;
        } else {
            //
            // ran out of memory
            //
            VideoVariables->VideoBufferSize = 0;
            SP_SET_UPGRADE_GRAPHICS_MODE(FALSE);
        }
    }

    KdPrint(("NOW - WE ARE WORKING ON VGA GRAPHICS MODE\n"));
    KdPrint(("      Vram Base   - %x\n",VideoVariables->VideoMemoryInfo.FrameBufferBase));
    KdPrint(("      Vram Length - %x\n",VideoVariables->VideoMemoryInfo.FrameBufferLength));
    KdPrint(("      I/O Port    - %x\n",VgaGraphicsControllerPort));
}

VOID
VgaGraphicsModeSpecificReInit(
    VOID
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    VIDEO_MODE VideoMode;
    ULONG mode;
    VIDEO_CURSOR_ATTRIBUTES VideoCursorAttributes;
    
    if (!VgaGraphicsModeInitialized) {
        return;
    }
    
    //
    // Set the desired mode.
    //
    VideoMode.RequestedMode = VideoVariables->VideoModeInfo.ModeIndex;

    //
    // Change the video mode
    //
    Status = ZwDeviceIoControlFile(
                VideoVariables->hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_SET_CURRENT_MODE,
                &VideoMode,
                sizeof(VideoMode),
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: Unable to set mode %u (status = %lx)\n",VideoMode.RequestedMode,Status));
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_SETMODE, Status);
        while(TRUE);    // loop forever
    }

    //
    // Initialize vga registers
    //
    VgaGraphicsModeInitRegs();

    VgaGraphicsModeSpecificInitPalette();


    //
    // Blast the cached data in video buffer to the actual 
    // video memory now
    //
    if (SP_IS_UPGRADE_GRAPHICS_MODE() && VideoVariables->VideoBuffer && 
        VideoVariables->VideoBufferSize) {
        PUCHAR Source = VideoVariables->VideoBuffer;
        PUCHAR Destination = VideoVariables->VideoMemoryInfo.FrameBufferBase;
        ULONG Index;

        for (Index=0; Index < VideoVariables->VideoBufferSize; Index++) {
            WRITE_REGISTER_UCHAR(Destination + Index, *(Source + Index));
        }

        SP_SET_UPGRADE_GRAPHICS_MODE(FALSE);
    }

    VideoVariables->ActiveVideoBuffer = VideoVariables->VideoMemoryInfo.FrameBufferBase;
    

    KdPrint(("NOW - WE ARE WORKING ON VGA GRAPHICS MODE (ReInit)\n"));
    KdPrint(("      Vram Base   - %x\n",VideoVariables->VideoMemoryInfo.FrameBufferBase));
    KdPrint(("      Vram Length - %x\n",VideoVariables->VideoMemoryInfo.FrameBufferLength));
    KdPrint(("      I/O Port    - %x\n",VgaGraphicsControllerPort));
}


BOOLEAN
VgaGraphicsModeSpecificInitPalette(
    VOID
    )
{
    //
    // There is no vga-specific palette initialization.
    //
    return(TRUE);
}



VOID
VgaGraphicsModeSpecificTerminate(
    VOID
    )

/*++

Routine Description:

    Perform frame buffer specific termination.  This includes

    - unmapping the frame buffer from memory

Arguments:

    None.

Return Value:

--*/

{
    if(VgaGraphicsModeInitialized) {

        pSpvidMapVideoMemory(FALSE);

        // !!! LATER !!!
        //
        // We should call ...
        //
        // IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES
        //

        if (VideoVariables->VideoBuffer && VideoVariables->VideoBufferSize) {
            SpMemFree(VideoVariables->VideoBuffer);

            VideoVariables->VideoBuffer = 0;
            VideoVariables->VideoBufferSize = 0;
        }

        VgaGraphicsModeInitialized = FALSE;
    }
}




VOID
VgaGraphicsModeDisplayString(
    IN PSTR  String,
    IN UCHAR Attribute,
    IN ULONG X,                 // 0-based coordinates (character units)
    IN ULONG Y
    )

/*++

Routine Description:

    Write a string of characters to the display.

Arguments:

    String - supplies a string of character in the OEM charset to be displayed
        at the given position.

    Attribute - supplies the attributes for characters in the string.

    X,Y - specify the character-based (0-based) position of the output.

Return Value:

    None.

--*/

{
    PBYTE  Origin,dest,pGlyphRow;
    BYTE   Image;
    USHORT I;
    USHORT J;
    PUCHAR pch;
    ULONG  CurrentColumn;

    //
    // Eliminate invalid coord.
    //
    if( X >= VideoVariables->ScreenWidth )  X = 0;
    if( Y >= VideoVariables->ScreenHeight ) Y = 3;

    //
    // Set current color/attribute.
    //
    VgaGraphicsModeSetAttribute(Attribute);

    //
    // Calculate the address of the upper left pixel of the first character
    // to be displayed.
    //
    Origin = (PUCHAR)VideoVariables->ActiveVideoBuffer
             + (Y * CharRowDelta)
             + ((X * FEFontCharacterWidth) / 8);

    //
    // Set current column.
    //
    CurrentColumn = X;

    //
    // Output each character in the string.
    //
    for(pch=String; *pch; pch++) {

        dest = Origin;

        if(DbcsFontIsDBCSLeadByte(*pch)) {

            USHORT Word;

            if((CurrentColumn+1) >= VideoVariables->ScreenWidth) {
                break;
            }

            Word = ((*pch) << 8) | (*(pch+1));

            pGlyphRow = DbcsFontGetDbcsFontChar(Word);

            if(pGlyphRow == NULL) {
                pGlyphRow = DbcsFontGetDbcsFontChar(FEFontDefaultChar);
            }

            for (I = 0; I < BootFontHeader.CharacterTopPad; I += 1) {

                WRITE_REGISTER_UCHAR(dest  , BIT_OFF_IMAGE);
                WRITE_REGISTER_UCHAR(dest+1, BIT_OFF_IMAGE);

                dest += VideoVariables->VideoModeInfo.ScreenStride;
            }

            for (I = 0; I < BootFontHeader.CharacterImageHeight; I += 1) {

                Image = GET_IMAGE_POST_INC(pGlyphRow);
                WRITE_REGISTER_UCHAR(dest  ,Image);
                Image = GET_IMAGE_POST_INC(pGlyphRow);
                WRITE_REGISTER_UCHAR(dest+1,Image);

                dest += VideoVariables->VideoModeInfo.ScreenStride;
            }

            for (I = 0; I < BootFontHeader.CharacterBottomPad; I += 1) {

                WRITE_REGISTER_UCHAR(dest  , BIT_OFF_IMAGE);
                WRITE_REGISTER_UCHAR(dest+1, BIT_OFF_IMAGE);

                dest += VideoVariables->VideoModeInfo.ScreenStride;
            }

            //
            // Skip Dbcs trailing byte
            //
            pch++;

            Origin += (BootFontHeader.CharacterImageDbcsWidth / 8);
            CurrentColumn += 2;

        } else if(DbcsFontIsGraphicsChar(*pch)) {

            if(CurrentColumn >= VideoVariables->ScreenWidth) {
                break;
            }

            //
            // Graphics Character special
            //

            pGlyphRow = DbcsFontGetGraphicsChar(*pch);

            if(pGlyphRow == NULL) {
                pGlyphRow = DbcsFontGetGraphicsChar(0x0);
            }

            for (I = 0; I < FEFontCharacterHeight; I += 1) {

                Image = GET_IMAGE_POST_INC_REVERSE(pGlyphRow);
                WRITE_REGISTER_UCHAR(dest,Image);

                dest += VideoVariables->VideoModeInfo.ScreenStride;

            }

            Origin += (BootFontHeader.CharacterImageSbcsWidth / 8);
            CurrentColumn += 1;

        } else {

            if(CurrentColumn >= VideoVariables->ScreenWidth) {
                break;
            }

            pGlyphRow = DbcsFontGetSbcsFontChar(*pch);

            if(pGlyphRow == NULL) {
                pGlyphRow = DbcsFontGetSbcsFontChar(0x20);
            }

            for (I = 0; I < BootFontHeader.CharacterTopPad; I += 1) {

                WRITE_REGISTER_UCHAR(dest,BIT_OFF_IMAGE);

                dest += VideoVariables->VideoModeInfo.ScreenStride;

            }

            for (I = 0; I < BootFontHeader.CharacterImageHeight; I += 1) {

                Image = GET_IMAGE_POST_INC(pGlyphRow);
                WRITE_REGISTER_UCHAR(dest,Image);

                dest += VideoVariables->VideoModeInfo.ScreenStride;

            }

            for (I = 0; I < BootFontHeader.CharacterBottomPad; I += 1) {

                WRITE_REGISTER_UCHAR(dest,BIT_OFF_IMAGE);

                dest += VideoVariables->VideoModeInfo.ScreenStride;

            }

            Origin += (BootFontHeader.CharacterImageSbcsWidth / 8);
            CurrentColumn += 1;
        }
    }
}


VOID
VgaGraphicsModeClearRegion(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG W,
    IN ULONG H,
    IN UCHAR Attribute
    )

/*++

Routine Description:

    Clear out a screen region to a specific attribute.

Arguments:

    X,Y,W,H - specify rectangle in 0-based character coordinates.

    Attribute - Low nibble specifies attribute to be filled in the rectangle
        (ie, the background color to be cleared to).

Return Value:

    None.

--*/

{
    PUCHAR Destination,Temp;
    UCHAR  FillOddStart,FillOddEnd;
    ULONG  i,j;
    ULONG  XStartInBits, XEndInBits;
    ULONG  FillLength;

    ASSERT(X+W <= VideoVariables->ScreenWidth);
    ASSERT(Y+H <= VideoVariables->ScreenHeight);

    if(X+W > VideoVariables->ScreenWidth) {
        W = VideoVariables->ScreenWidth-X;
    }

    if(Y+H > VideoVariables->ScreenHeight) {
        H = VideoVariables->ScreenHeight-Y;
    }

    //
    // Set color/attribute
    //
    VgaGraphicsModeSetAttribute(Attribute);

    //
    // Compute destination start address
    //
    Destination = (PUCHAR)VideoVariables->ActiveVideoBuffer
                  + (Y * CharRowDelta)
                  + ((X * FEFontCharacterWidth) / 8);

    //
    // Compute amounts in Byte (including overhang).
    //
    FillLength = (W * FEFontCharacterWidth) / 8;

    //
    // Fill the region.
    //
    for( i = 0 ; i < (H * CharLineFeed) ; i++ ) {

        Temp = Destination;

        //
        // Write bytes in this row
        //
        for( j = 0 ; j < FillLength ; j++ ) {
            WRITE_REGISTER_UCHAR( Temp, BIT_ON_IMAGE );
            Temp ++;
        }

        //
        // Move to next row.
        //
        Destination += VideoVariables->VideoModeInfo.ScreenStride;
    }
}


#pragma optimize("",off)
BOOLEAN
VgaGraphicsModeSpecificScrollUp(
    IN ULONG TopLine,
    IN ULONG BottomLine,
    IN ULONG LineCount,
    IN UCHAR FillAttribute
    )
{
    PUCHAR Source,Target;
    ULONG Count,u;

    //
    // Make sure we're in read mode 0 and write mode 1.
    //
    VgaGraphicsModeWriteController(0x0105);

    Target = (PUCHAR)VideoVariables->ActiveVideoBuffer
           + (TopLine * CharRowDelta);

    Source = Target + (LineCount * CharRowDelta);

    Count = (((BottomLine - TopLine) + 1) - LineCount) * CharRowDelta;

    //
    // The transfer *MUST* be done byte-by-byte because of the way
    // VGA latches work.
    //
    for(u=0; u<Count; u++) {
        *Target++ = *Source++;
    }

    //
    // Reset read and write mode to default value.
    //
    VgaGraphicsModeWriteController(0x0005);

    VgaGraphicsModeClearRegion(
        0,
        (BottomLine - LineCount) + 1,
        VideoVariables->ScreenWidth,
        LineCount,
        FillAttribute
        );

    return(TRUE);
}
#pragma optimize("", on)


VOID
VgaGraphicsModeInitRegs(
    VOID
    )
{
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             IoStatusBlock;
    VIDEO_PUBLIC_ACCESS_RANGES  VideoAccessRange;

    Status = ZwDeviceIoControlFile(
                VideoVariables->hDisplay,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES,
                NULL,
                0,
                &VideoAccessRange,         // output buffer
                sizeof (VideoAccessRange)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: Unable to get VGA public access ranges (%x)\n",Status));
        SpDisplayRawMessage(SP_SCRN_VIDEO_ERROR_RAW, 2, VIDEOBUG_SETMODE, Status);
        while(TRUE);    // loop forever
    }

    VgaGraphicsControllerPort =
        (PVOID)(((BYTE *)VideoAccessRange.VirtualAddress) + (VGA_BASE + GRAF_ADDR));
}

//
// Need to turn off optimization for this
// routine.  Since the write and read to
// GVRAM seem useless to the compiler.
//

#pragma optimize( "", off )

VOID
VgaGraphicsModeSetAttribute(
    UCHAR Attribute
)
/*++

Routine Description:

    Sets the attribute by setting up various VGA registers.
    The comments only say what registers are set to what, so
    to understand the logic, follow the code while looking at
    Figure 5-5 of PC&PS/2 Video Systems by Richard Wilton.
    The book is published by Microsoft Press.

Arguments:

    Attribute - New attribute to set to.
    Attribute:
        High nibble - background attribute.
        Low  nibble - foreground attribute.

Return Value:

    Nothing.

--*/

{
    UCHAR   temp = 0;

    union WordOrByte {
        struct Word { USHORT  ax;     } x;
        struct Byte { UCHAR   al, ah; } h;
    } regs;

    //
    // Address of GVRAM off the screen.
    // Physical memory = (0xa9600);
    //

    PUCHAR  OffTheScreen = ((PUCHAR)VideoVariables->VideoMemoryInfo.FrameBufferBase + 0x9600);

    //
    // TDB : How to handle this with background buffering ?
    //
    if (SP_IS_UPGRADE_GRAPHICS_MODE())
        return; // nop 

    //
    // Reset Data Rotate/Function Select
    // regisger (register 3 with 00 indicating replace bits)
    //

    WRITE_GRAPHICS_CONTROLLER( 0x0003 ); // Need to reset Data Rotate/Function Select.

    //
    // Set Enable Set/Reset toall (0f) 
    // (regsiter 1 with F indicating each pixel is updated
    // with the value in set register (register 0)  using the logical
    // operation in Data Rotate/Function selection register).
    //

    WRITE_GRAPHICS_CONTROLLER( 0x0f01 );

    //
    // Put background color into Set/Reset register.
    // This is done to put the background color into
    // the latches later.
    //

    regs.x.ax = (USHORT)(Attribute & 0x00f0) << 4;
    WRITE_GRAPHICS_CONTROLLER( regs.x.ax );

    //
    // Put the background attribute in temp variable 
    //
    temp = regs.h.ah;

    //
    // Put Set/Reset register value into GVRAM
    // off the screen.
    //

    WRITE_REGISTER_UCHAR( OffTheScreen , temp );

    //
    // Read from screen, so the latches will be
    // updated with the background color.
    //

    temp = READ_REGISTER_UCHAR( OffTheScreen );

    //
    // Set Data Rotate/Function Select register
    // to be XOR.
    //

    WRITE_GRAPHICS_CONTROLLER( 0x1803 );

    //
    // XOR the foreground and background color and
    // put it in Set/Reset register.
    //

    regs.h.ah = (Attribute >> 4) ^ (Attribute & 0x0f);
    regs.h.al = 0;
    WRITE_GRAPHICS_CONTROLLER( regs.x.ax );

    //
    // Put Inverse(~) of the XOR of foreground and
    // ground attribute into Enable Set/Reset register.
    //

    regs.x.ax = ~regs.x.ax & 0x0f01;
    WRITE_GRAPHICS_CONTROLLER( regs.x.ax );
}

//
// Turn optimization on again.
//

#pragma optimize( "", on )

VOID
VgaGraphicsModeWriteController(
    USHORT Data
    )
{
    MEMORY_BARRIER();
    WRITE_PORT_USHORT(VgaGraphicsControllerPort,Data);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\spddlang\fe\precomp.h ===
#include <spprecmp.h>

#include "bootfont.h"
#include "fefont.h"
#include "fevideo.h"

#include "string.h"

extern PWSTR szKeyboard;

NTSTATUS
FESetKeyboardParams(
    IN PVOID  SifHandle,
    IN HANDLE ControlSetKeyHandle,
    IN PHARDWARE_COMPONENT *HwComponents,
    IN PWSTR  LayerDriver
    );

NTSTATUS
FEUpgradeKeyboardParams(
    IN PVOID  SifHandle,
    IN HANDLE ControlSetKeyHandle,
    IN PHARDWARE_COMPONENT *HwComponents,
    IN PWSTR  LayerDriver
    );

NTSTATUS
FEUpgradeKeyboardLayout(
    IN HANDLE ControlSetKeyHandle,
    IN PWSTR  OldDefaultIMEName,
    IN PWSTR  NewDefaultIMEName,
    IN PWSTR  NewDefaultIMEText
    );

NTSTATUS
FEUpgradeRemoveMO(
    IN HANDLE ControlSetKeyHandle
    );

WCHAR
FEGetLineDrawChar(
    IN LineCharIndex WhichChar
    );

ULONG
FEGetStringColCount(
    IN PCWSTR String
    );

PWSTR
FEPadString(
    IN int    Size,
    IN PCWSTR String
    );

VOID
FESelectKeyboard(
    IN PVOID SifHandle,
    IN PHARDWARE_COMPONENT *HwComponents,
    IN BOOLEAN bNoEasySelection,
    IN BOOLEAN CmdConsole

    );

VOID
FEUnattendSelectKeyboard(
    IN PVOID UnattendedSifHandle,
    IN PVOID SifHandle,
    IN PHARDWARE_COMPONENT *HwComponents
    );

VOID
FEReinitializeKeyboard(
    IN PVOID SifHandle,
    IN PWSTR Directory,
    OUT PVOID *KeyboardVector,
    IN PHARDWARE_COMPONENT *HwComponents,
    IN  PWSTR  KeyboardLayoutDefault
    );

extern PWSTR szNLSSection;
extern PWSTR szAnsiCodePage;
extern PWSTR szJapanese;
extern PWSTR szKorean;

__inline
BOOLEAN
IS_LANG_VERSION(
    IN PVOID SifHandle,
    IN PWSTR LangId
    )
{
    PWSTR   NlsValue = SpGetSectionKeyIndex((SifHandle),szNLSSection,szAnsiCodePage,1);

    return (NlsValue && !wcscmp(LangId, NlsValue));
}

#define IS_JAPANESE_VERSION(SifHandle) IS_LANG_VERSION((SifHandle), szJapanese)
#define IS_KOREAN_VERSION(SifHandle) IS_LANG_VERSION((SifHandle), szKorean)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\user\usetup.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    usetup.c

Abstract:

    User-mode text-setup process.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:

--*/



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <fmifs.h>
#include <setupdd.h>


HANDLE hEventRequestReady,hEventRequestServiced;
SETUP_COMMUNICATION Communication;

//
//  Global variables (global to the module) used by the functions
//  that set a security descriptor to a file.
//
BOOLEAN                  _SecurityDescriptorInitialized = FALSE;
SECURITY_DESCRIPTOR      _SecurityDescriptor;
PSID                     _WorldSid;
PSID                     _SystemSid;


BOOLEAN
uSpInitializeDefaultSecurityDescriptor(
    )
/*++

Routine Description:

    Build the security descriptor that will be set in the files, that
    contain bogus security descriptor.

Arguments:

    None

Return Value:

    BOOLEAN - Returns TRUE if the security descriptor was successfully
              initialized. Returns FALSE otherwise.


--*/


{
    NTSTATUS                 NtStatus;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;
    CHAR                     Acl[256];               // 256 is more than big enough
    ULONG                    AclLength=256;
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;

    //
    // Create the SIDs for World and System
    //

    NtStatus = RtlAllocateAndInitializeSid( &WorldSidAuthority,
                                            1,
                                            SECURITY_WORLD_RID,
                                            0, 0, 0, 0, 0, 0, 0,
                                            &_WorldSid
                                          );

    if ( !NT_SUCCESS( NtStatus )) {
        KdPrint(( "uSETUP: Unable to allocate and initialize SID %x \n", NtStatus ));
        return( FALSE );
    }

    NtStatus = RtlAllocateAndInitializeSid( &SystemSidAuthority,
                                            1,
                                            SECURITY_LOCAL_SYSTEM_RID,
                                            0, 0, 0, 0, 0, 0, 0,
                                            &_SystemSid
                                          );

    if ( !NT_SUCCESS( NtStatus )) {
        KdPrint(( "uSETUP: Unable to allocate and initialize SID, status = %x \n", NtStatus ));
        RtlFreeSid( _WorldSid );
        return( FALSE );
    }

    //
    //  Create the ACL
    //

    NtStatus = RtlCreateAcl( (PACL)Acl,
                             AclLength,
                             ACL_REVISION2
                           );

    if ( !NT_SUCCESS( NtStatus )) {
        KdPrint(( "uSETUP: Unable to create Acl, status =  %x \n", NtStatus ));
        RtlFreeSid( _WorldSid );
        RtlFreeSid( _SystemSid );
        return( FALSE );
    }

    //
    //  Copy the World SID into the ACL
    //
    NtStatus = RtlAddAccessAllowedAce( (PACL)Acl,
                                       ACL_REVISION2,
                                       GENERIC_ALL,
                                       _WorldSid
                                     );

    if ( !NT_SUCCESS( NtStatus )) {
        KdPrint(( "uSETUP: Unable to add Access Allowed Ace to Acl, status = %x \n", NtStatus ));
        RtlFreeSid( _WorldSid );
        RtlFreeSid( _SystemSid );
        return( FALSE );
    }

    //
    // Sid has been copied into the ACL
    //
    // RtlFreeSid( WorldSid );

    //
    // Create and initialize the security descriptor
    //

    NtStatus = RtlCreateSecurityDescriptor( &_SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION );

    if ( !NT_SUCCESS( NtStatus )) {
        KdPrint(( "uSETUP: Unable to create security descriptor, status = %x \n", NtStatus ));
        RtlFreeSid( _WorldSid );
        RtlFreeSid( _SystemSid );
        return( FALSE );
    }

    NtStatus = RtlSetDaclSecurityDescriptor ( &_SecurityDescriptor,
                                              TRUE,
                                              (PACL)Acl,
                                              FALSE
                                            );
    if ( !NT_SUCCESS( NtStatus )) {
        KdPrint(( "uSETUP: Unable to set Acl to _SecurityDescriptor, status = %x \n", NtStatus ));
        RtlFreeSid( _WorldSid );
        RtlFreeSid( _SystemSid );
        return( FALSE );
    }

    //
    // Copy the owner into the security descriptor
    //
    NtStatus = RtlSetOwnerSecurityDescriptor( &_SecurityDescriptor,
                                              _SystemSid,
                                              FALSE );

    // RtlFreeSid( SystemSid );

    if ( !NT_SUCCESS( NtStatus )) {
        KdPrint(( "uSETUP: Unable to set Owner to _SecurityDescriptor, status = %x \n", NtStatus ));
        RtlFreeSid( _WorldSid );
        RtlFreeSid( _SystemSid );
        return( FALSE );
    }
    _SecurityDescriptorInitialized = TRUE;
    return( TRUE );
}


NTSTATUS
uSpSetFileSecurity(
    PWSTR                FileName,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    )

/*++

Routine Description:

    This function sets the security of a file.
    It is based on the Win32 API SetFileSecurity.
    This API can be used to set the security of a file or directory
    (process, file, event, etc.).  This call is only successful if the
    following conditions are met:

    o If the object's owner or group is to be set, the caller must
      have WRITE_OWNER permission or have SeTakeOwnershipPrivilege.

    o If the object's DACL is to be set, the caller must have
      WRITE_DAC permission or be the object's owner.

    o If the object's SACL is to be set, the caller must have
      SeSecurityPrivilege.

Arguments:

    lpFileName - Supplies the file name of the file whose security
        is to be set.

    SecurityInformation - A pointer to information describing the
        contents of the Security Descriptor.

    pSecurityDescriptor - A pointer to a well formed Security
        Descriptor.

Return Value:

    NTSTATUS - An NT status code indcating the result of the operation.

--*/
{
    NTSTATUS            Status;
    HANDLE              FileHandle;
    ACCESS_MASK         DesiredAccess;

    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      UnicodeFileName;
    IO_STATUS_BLOCK     IoStatusBlock;


    DesiredAccess = 0;

    if ((SecurityInformation & OWNER_SECURITY_INFORMATION) ||
        (SecurityInformation & GROUP_SECURITY_INFORMATION)   ) {
        DesiredAccess |= WRITE_OWNER;
    }

    if (SecurityInformation & DACL_SECURITY_INFORMATION) {
        DesiredAccess |= WRITE_DAC;
    }

    if (SecurityInformation & SACL_SECURITY_INFORMATION) {
        DesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }

    RtlInitUnicodeString( &UnicodeFileName,
                          FileName );

    InitializeObjectAttributes(
        &Obja,
        &UnicodeFileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(
                 &FileHandle,
                 DesiredAccess,
                 &Obja,
                 &IoStatusBlock,
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                 0
                 );

    if ( NT_SUCCESS( Status ) ) {

        Status = NtSetSecurityObject(
                    FileHandle,
                    SecurityInformation,
                    pSecurityDescriptor
                    );

        NtClose(FileHandle);
    }
    return Status;
}


NTSTATUS
uSpSetDefaultFileSecurity(
    VOID
    )
/*++

Routine Description:

    Set a default security descriptor onto a file.

Arguments:

    None

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                        Status;
    PWSTR                           FileName;
    PSERVICE_DEFAULT_FILE_SECURITY  Params = (PSERVICE_DEFAULT_FILE_SECURITY)Communication.Buffer;

    FileName = Params->FileName;

    if( !_SecurityDescriptorInitialized ) {
        Status = uSpInitializeDefaultSecurityDescriptor();
        if( !NT_SUCCESS( Status ) ) {
            KdPrint(( "uSETUP: Unable to initialize default security descriptor. Status = %x \n", Status ));
            return( Status );
        }
    }

    //
    //  Attempt to write the DACL
    //
    Status = uSpSetFileSecurity( FileName,
                                 DACL_SECURITY_INFORMATION,
                                 &_SecurityDescriptor );

    if( !NT_SUCCESS( Status ) ) {

        //
        //  Make the system the owner of the file
        //
        Status = uSpSetFileSecurity( FileName,
                                     OWNER_SECURITY_INFORMATION,
                                     &_SecurityDescriptor );
#if DBG
        if( !NT_SUCCESS( Status ) ) {
            KdPrint(( "uSETUP: Unable to set file OWNER. Status = %x \n", Status ));
        }
#endif

        if( NT_SUCCESS( Status ) ) {

            //
            //  Write the DACL to the file
            //
            Status = uSpSetFileSecurity( FileName,
                                         DACL_SECURITY_INFORMATION,
                                         &_SecurityDescriptor );
#if DBG
            if( !NT_SUCCESS( Status ) ) {
                KdPrint(( "uSETUP: Unable to set file DACL. Status = %x \n", Status ));
            }
#endif
        }
    }
    return( Status );
}

NTSTATUS
uSpVerifyFileAccess(
    VOID
    )

/*++

Routine Description:

    Check whether or not the security descriptor set in a file allows
    textmode setup to perform some file operation. If textmode setup
    is not allowed to open the file for certain accesses, we assume
    that the security information in the file is not valid.

Arguments:

    FileName - Full path to the file to be examined

Return Value:

    NTSTATUS -

--*/
{
    ACCESS_MASK                  DesiredAccess;
    HANDLE                       FileHandle;
    OBJECT_ATTRIBUTES            ObjectAttributes;
    IO_STATUS_BLOCK              IoStatusBlock;
    NTSTATUS                     Status;
    UNICODE_STRING               UnicodeFileName;
    PWSTR                        FileName;
    PSERVICE_VERIFY_FILE_ACCESS  Params = (PSERVICE_VERIFY_FILE_ACCESS)Communication.Buffer;

    FileName = Params->FileName;


    DesiredAccess = Params->DesiredAccess;

    RtlInitUnicodeString( &UnicodeFileName,
                          FileName );

    InitializeObjectAttributes( &ObjectAttributes,
                                &UnicodeFileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );


    Status = NtOpenFile( &FileHandle,
                         DesiredAccess,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         0,
                         FILE_SYNCHRONOUS_IO_NONALERT );

    if( NT_SUCCESS( Status ) ) {
        NtClose( FileHandle );
    }

#if DBG
    if( !NT_SUCCESS( Status ) ) {
        KdPrint( ("uSETUP: NtOpenFile() failed. File = %ls, Status = %x\n",FileName, Status ) );
    }
#endif
    return( Status );
}



NTSTATUS
uSpLoadKbdLayoutDll(
    VOID
    )
{
    UNICODE_STRING DllNameU;
    PSERVICE_LOAD_KBD_LAYOUT_DLL Params = (PSERVICE_LOAD_KBD_LAYOUT_DLL)Communication.Buffer;
    NTSTATUS Status;
    PVOID DllBaseAddress;
    PVOID (*RoutineAddress)(VOID);

    RtlInitUnicodeString(&DllNameU,Params->DllName);

    Status = LdrLoadDll(NULL,NULL,&DllNameU,&DllBaseAddress);

    if(!NT_SUCCESS(Status)) {
        KdPrint(("uSETUP: Unable to load dll %ws (%lx)\n",Params->DllName,Status));
        return(Status);
    }

    Status = LdrGetProcedureAddress(DllBaseAddress,NULL,1,(PVOID)&RoutineAddress);
    if(NT_SUCCESS(Status)) {
        Params->TableAddress = (*RoutineAddress)();
    } else {
        KdPrint(("uSETUP: Unable to get address of proc 1 from dll %ws (%lx)\n",Params->DllName,Status));
        LdrUnloadDll(DllBaseAddress);
    }

    return(Status);
}


NTSTATUS
uSpExecuteImage(
    VOID
    )
{
    UNICODE_STRING CommandLineU,ImagePathU,CurrentDirectoryU;
    PSERVICE_EXECUTE Params = (PSERVICE_EXECUTE)Communication.Buffer;
    NTSTATUS Status;
    RTL_USER_PROCESS_INFORMATION ProcessInformation;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    WCHAR Env[2] = { 0,0 };
    PROCESS_BASIC_INFORMATION BasicInformation;

    //
    // Initialize unicode strings.
    //
    RtlInitUnicodeString(&CommandLineU,Params->CommandLine);
    RtlInitUnicodeString(&ImagePathU,Params->FullImagePath);
    RtlInitUnicodeString(&CurrentDirectoryU,L"\\");

    //
    // Create process parameters.
    //
    Status = RtlCreateProcessParameters(
                &ProcessParameters,
                &ImagePathU,
                NULL,
                &CurrentDirectoryU,
                &CommandLineU,
                Env,
                NULL,
                NULL,
                NULL,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("uSETUP: Unable to create process params for %ws (%lx)\n",Params->FullImagePath,Status));
        return(Status);
    }

    ProcessParameters->DebugFlags = 0;

    //
    // Create the user process.
    //
    ProcessInformation.Length = sizeof(RTL_USER_PROCESS_INFORMATION);
    Status = RtlCreateUserProcess(
                &ImagePathU,
                OBJ_CASE_INSENSITIVE,
                ProcessParameters,
                NULL,
                NULL,
                NULL,
                FALSE,
                NULL,
                NULL,
                &ProcessInformation
                );

    RtlDestroyProcessParameters(ProcessParameters);

    if(!NT_SUCCESS(Status)) {
        KdPrint(("uSETUP: Unable to create user process %ws (%lx)\n",Params->FullImagePath,Status));
        return(Status);
    }

    //
    // Make sure the image is a native NT image.
    //
    if(ProcessInformation.ImageInformation.SubSystemType != IMAGE_SUBSYSTEM_NATIVE) {

        KdPrint(("uSETUP: %ws is not an NT image\n",Params->FullImagePath));
        NtTerminateProcess(ProcessInformation.Process,STATUS_INVALID_IMAGE_FORMAT);
        NtWaitForSingleObject(ProcessInformation.Thread,FALSE,NULL);
        NtClose(ProcessInformation.Thread);
        NtClose(ProcessInformation.Process);
        return(STATUS_INVALID_IMAGE_FORMAT);
    }

    //
    // Start the process going.
    //
    Status = NtResumeThread(ProcessInformation.Thread,NULL);

    //
    // Wait for the process to finish.
    //
    NtWaitForSingleObject(ProcessInformation.Process,FALSE,NULL);

    //
    // Get process return status
    //
    Status = NtQueryInformationProcess(
                ProcessInformation.Process,
                ProcessBasicInformation,
                &BasicInformation,
                sizeof(BasicInformation),
                NULL
                );

    if ( NT_SUCCESS(Status) ) {
        Params->ReturnStatus = BasicInformation.ExitStatus;
    }

    //
    // Clean up and return.
    //
    NtClose(ProcessInformation.Thread);
    NtClose(ProcessInformation.Process);

    return Status;
}

NTSTATUS
uSpDeleteKey(
    VOID
    )
{
    UNICODE_STRING    KeyName;
    OBJECT_ATTRIBUTES Obja;
    HANDLE            hKey;
    NTSTATUS Status;


    PSERVICE_DELETE_KEY Params = (PSERVICE_DELETE_KEY)Communication.Buffer;

    //
    // Initialize unicode strings and object attributes.
    //
    RtlInitUnicodeString(&KeyName,Params->Key);
    InitializeObjectAttributes(
        &Obja,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        Params->KeyRootDirectory,
        NULL
        );

    //
    // Open the key and delete it
    //

    Status = NtOpenKey(&hKey,KEY_ALL_ACCESS,&Obja);
    if(NT_SUCCESS(Status)) {
        Status = NtDeleteKey(hKey);
        NtClose(hKey);
    }

    return(Status);
}

NTSTATUS
uSpQueryDirectoryObject(
    VOID
    )
{
    PSERVICE_QUERY_DIRECTORY_OBJECT Params = (PSERVICE_QUERY_DIRECTORY_OBJECT)Communication.Buffer;
    NTSTATUS Status;

    Status = NtQueryDirectoryObject(
                Params->DirectoryHandle,
                Params->Buffer,
                sizeof(Params->Buffer),
                TRUE,                       // return single entry
                Params->RestartScan,
                &Params->Context,
                NULL
                );

    if(!NT_SUCCESS(Status) && (Status != STATUS_NO_MORE_ENTRIES)) {
        KdPrint(("uSETUP: Unable to query directory object (%lx)\n",Status));
    }

    return(Status);
}


NTSTATUS
uSpFlushVirtualMemory(
    VOID
    )
{
    PSERVICE_FLUSH_VIRTUAL_MEMORY Params = (PSERVICE_FLUSH_VIRTUAL_MEMORY)Communication.Buffer;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;

    PVOID BaseAddress;
    SIZE_T RangeLength;

    BaseAddress = Params->BaseAddress;
    RangeLength = Params->RangeLength;

    Status = NtFlushVirtualMemory(
                NtCurrentProcess(),
                &BaseAddress,
                &RangeLength,
                &IoStatus
                );

    if(NT_SUCCESS(Status)) {
        if(BaseAddress != Params->BaseAddress) {
            KdPrint((
                "uSETUP: Warning: uSpFlushVirtualMemory: base address %lx changed to %lx\n",
                Params->BaseAddress,
                BaseAddress
                ));
        }
    } else {
        KdPrint((
            "uSETUP: Unable to flush virtual memory @%p length %p (%lx)\n",
            Params->BaseAddress,
            Params->RangeLength,
            Status
            ));
    }

    return(Status);
}


NTSTATUS
uSpShutdownSystem(
    VOID
    )
{
    NTSTATUS Status;

    Status = NtShutdownSystem(ShutdownReboot);

    KdPrint(("uSETUP: NtShutdownSystem returned (%lx)\n",Status));

    return(Status);
}

NTSTATUS
uSpLockUnlockVolume(
    VOID
    )
{
    HANDLE          Handle;
    NTSTATUS        Status;
    BOOLEAN         Locking;
    IO_STATUS_BLOCK IoStatusBlock;

    PSERVICE_LOCK_UNLOCK_VOLUME Params = (PSERVICE_LOCK_UNLOCK_VOLUME)Communication.Buffer;

    Handle = Params->Handle;
    Locking = (BOOLEAN)(Communication.u.RequestNumber == SetupServiceLockVolume);

    Status = NtFsControlFile( Handle,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatusBlock,
                              ( Locking )? FSCTL_LOCK_VOLUME : FSCTL_UNLOCK_VOLUME,
                              NULL,
                              0,
                              NULL,
                              0 );

    if( !NT_SUCCESS( Status ) ) {
        KdPrint((
            "uSETUP: Unable to %ws volume (%lx)\n",
            ( Locking )? L"lock" : L"unlock",
            Status
            ));
    }

    return(Status);
}


NTSTATUS
uSpDismountVolume(
    VOID
    )
{
    HANDLE          Handle;
    NTSTATUS        Status;
    IO_STATUS_BLOCK IoStatusBlock;

    PSERVICE_DISMOUNT_VOLUME Params = (PSERVICE_DISMOUNT_VOLUME)Communication.Buffer;

    Handle = Params->Handle;

    Status = NtFsControlFile( Handle,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatusBlock,
                              FSCTL_DISMOUNT_VOLUME,
                              NULL,
                              0,
                              NULL,
                              0 );

    if( !NT_SUCCESS( Status ) ) {
        KdPrint((
            "uSETUP: Unable to dismount volume (%lx)\n",
            Status
            ));
    }

    return(Status);
}


NTSTATUS
uSpCreatePageFile(
    VOID
    )
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;

    PSERVICE_CREATE_PAGEFILE Params = (PSERVICE_CREATE_PAGEFILE)Communication.Buffer;

    RtlInitUnicodeString(&UnicodeString,Params->FileName);

    Status = NtCreatePagingFile(&UnicodeString,&Params->MinSize,&Params->MaxSize,0);

    if(!NT_SUCCESS(Status)) {

        KdPrint((
            "uSETUP: Unable to create pagefile %ws %x-%x (%x)",
            Params->FileName,
            Params->MinSize.LowPart,
            Params->MaxSize.LowPart,
            Status
            ));
    }

    return(Status);
}


NTSTATUS
uSpGetFullPathName(
    VOID
    )
{
    ULONG len;
    ULONG u;

    PSERVICE_GETFULLPATHNAME Params = (PSERVICE_GETFULLPATHNAME)Communication.Buffer;

    len = wcslen(Params->FileName);

    Params->NameOut = Params->FileName + len + 1;

    u = RtlGetFullPathName_U(
            Params->FileName,
            (sizeof(Communication.Buffer) - ((len+1)*sizeof(WCHAR))) - sizeof(PVOID),
            Params->NameOut,
            NULL
            );

    return(u ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}


NTSTATUS
SpRequestServiceThread(
    PVOID ThreadParameter
    )
{
    NTSTATUS Status;

    while(1) {

        //
        // Wait for the driver to fill the request buffer and indicate
        // that a request requires servicing.
        //
        Status = NtWaitForSingleObject(hEventRequestReady,FALSE,NULL);
        if(!NT_SUCCESS(Status)) {
            KdPrint(("uSETUP: wait on RequestReady event returned %lx\n",Status));
            return(Status);
        }

        switch(Communication.u.RequestNumber) {

        case SetupServiceExecute:

            Status = uSpExecuteImage();
            break;

        case SetupServiceLockVolume:
        case SetupServiceUnlockVolume:

            Status = uSpLockUnlockVolume();
            break;

        case SetupServiceDismountVolume:

            Status = uSpDismountVolume();
            break;

        case SetupServiceQueryDirectoryObject:

            Status = uSpQueryDirectoryObject();
            break;

        case SetupServiceFlushVirtualMemory:

            Status = uSpFlushVirtualMemory();
            break;

        case SetupServiceShutdownSystem:

            Status = uSpShutdownSystem();
            break;

        case SetupServiceDeleteKey:

            Status = uSpDeleteKey();
            break;

        case SetupServiceLoadKbdLayoutDll:

            Status = uSpLoadKbdLayoutDll();
            break;

        case SetupServiceDone:

            return(STATUS_SUCCESS);

        case SetupServiceSetDefaultFileSecurity:

            Status = uSpSetDefaultFileSecurity();
            break;

        case SetupServiceVerifyFileAccess:

            Status = uSpVerifyFileAccess();
            break;

        case SetupServiceCreatePageFile:

            Status = uSpCreatePageFile();
            break;

        case SetupServiceGetFullPathName:

            Status = uSpGetFullPathName();
            break;

        default:

            KdPrint(("uSETUP: unknown service %u requested\n",Communication.u.RequestNumber));
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Store the result status where the driver can get at it.
        //
        Communication.u.Status = Status;

        //
        // Inform the driver that we're done servicing the request.
        //
        Status = NtSetEvent(hEventRequestServiced,NULL);
        if(!NT_SUCCESS(Status)) {
            KdPrint(("uSETUP: set RequestServiced event returned %lx\n",Status));
            return(Status);
        }
    }
}



void
__cdecl
main(
    int argc,
    char *argv[],
    char *envp[],
    ULONG DebugParameter OPTIONAL
    )
{
    HANDLE handle;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Attributes;
    NTSTATUS Status;
    HANDLE hThread;
    SETUP_START_INFO SetupStartInfo;
    BOOLEAN b;

    //
    // Enable several privileges that we will need.
    //
    Status = RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE,TRUE,FALSE,&b);
    if(!NT_SUCCESS(Status)) {
        KdPrint(("uSETUP: Warning: unable to enable backup privilege (%lx)\n",Status));
    }

    Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE,TRUE,FALSE,&b);
    if(!NT_SUCCESS(Status)) {
        KdPrint(("uSETUP: Warning: unable to enable restore privilege (%lx)\n",Status));
    }

    Status = RtlAdjustPrivilege(SE_SHUTDOWN_PRIVILEGE,TRUE,FALSE,&b);
    if(!NT_SUCCESS(Status)) {
        KdPrint(("uSETUP: Warning: unable to enable shutdown privilege (%lx)\n",Status));
    }

    Status = RtlAdjustPrivilege(SE_TAKE_OWNERSHIP_PRIVILEGE,TRUE,FALSE,&b);
    if(!NT_SUCCESS(Status)) {
        KdPrint(("uSETUP: Warning: unable to enable take ownership privilege (%lx)\n",Status));
    }

    //
    // Get the registry going.  Pass a flag indicating that this is a setup boot.
    //
    Status = NtInitializeRegistry(REG_INIT_BOOT_SETUP);
    if(!NT_SUCCESS(Status)) {
        KdPrint(("uSETUP: Unable to initialize registry (%lx)\n",Status));
        goto main0;
    }

    //
    // Query basic system info.
    //
    Status = NtQuerySystemInformation(
                SystemBasicInformation,
                &SetupStartInfo.SystemBasicInfo,
                sizeof(SYSTEM_BASIC_INFORMATION),
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("uSETUP: Unable to query system basic information (%lx)\n",Status));
        goto main0;
    }

    //
    // Create two events for cummunicating with the setup device driver.
    // One event indicates that the request buffer is filled (ie, request service)
    // and the other indicates that the request has been processed.
    // Both events are initially not signalled.
    //
    Status = NtCreateEvent(
                &hEventRequestReady,
                EVENT_ALL_ACCESS,
                NULL,
                SynchronizationEvent,
                FALSE
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("uSETUP: Unable to create event (%lx)\n",Status));
        goto main0;
    }

    Status = NtCreateEvent(
                &hEventRequestServiced,
                EVENT_ALL_ACCESS,
                NULL,
                SynchronizationEvent,
                FALSE
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("uSETUP: Unable to create event (%lx)\n",Status));
        goto main1;
    }

    //
    // Open the setup device.
    //

    RtlInitUnicodeString(&UnicodeString,DD_SETUP_DEVICE_NAME_U);

    InitializeObjectAttributes(
        &Attributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtCreateFile(
                &handle,
                FILE_ALL_ACCESS,
                &Attributes,
                &IoStatusBlock,
                NULL,                   // allocation size
                0,
                FILE_SHARE_READ,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,                   // no EAs
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("uSETUP: Unable to open %ws (%lx)\n",DD_SETUP_DEVICE_NAME_U,Status));
        goto main2;
    }

    //
    // Create a thread to service requests from the text setup device driver.
    //
    Status = RtlCreateUserThread(
                NtCurrentProcess(),
                NULL,                   // security descriptor
                FALSE,                  // not suspended
                0,                      // zero bits
                0,                      // stack reserve
                0,                      // stack commit
                SpRequestServiceThread,
                NULL,                   // parameter
                &hThread,
                NULL                    // client id
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("uSETUP: Unable to create thread (%lx)\n",Status));
        goto main3;
    }

    //
    // Determine the image base of this program.
    //
    RtlPcToFileHeader(main,&SetupStartInfo.UserModeImageBase);
    if(!SetupStartInfo.UserModeImageBase) {
        KdPrint(("uSETUP: Unable to get image base\n"));
        goto main3;
    }

    //
    // Invoke the setup ioctl to get setup going.
    // Note that this is a synchronous call -- so this routine
    // will not return until text setup is done.
    // However the second thread we started above will be servicing
    // requests from the text setup device driver.
    //
    SetupStartInfo.RequestReadyEvent = hEventRequestReady;
    SetupStartInfo.RequestServicedEvent = hEventRequestServiced;
    SetupStartInfo.Communication = &Communication;
    Status = NtDeviceIoControlFile(
                handle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_SETUP_START,
                &SetupStartInfo,
                sizeof(SetupStartInfo),
                NULL,
                0
                );

    if(Status != STATUS_SUCCESS) {
        KdPrint(("uSETUP: Warning: start setup ioctl returned %lx\n",Status));
    }

    //
    // Clean up.
    //
    NtClose(hThread);

main3:

    NtClose(handle);

main2:

    NtClose(hEventRequestServiced);

main1:

    NtClose(hEventRequestReady);

main0:

    NtTerminateProcess(NULL,STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\user\resource.h ===
#define IDB_BACKGROUND1  101
#define IDB_RESTORE_BK   102

#define IDB_WORKING1     501
#define IDB_WORKING2     502
#define IDB_WORKING3     503
#define IDB_WORKING4     504
#define IDB_WORKING5     505
#define IDB_WORKING6     506
#define IDB_WORKING7     507
#define IDB_WORKING8     508
#define IDB_WORKING9     509
#define IDB_WORKING10    510
#define IDB_WORKING11    511
#define IDB_WORKING12    512
#define IDB_WORKING13    513
#define IDB_WORKING14    514
#define IDB_WORKING15    515
#define IDB_WORKING16    516
#define IDB_WORKING17    517
#define IDB_WORKING18    518
#define IDB_WORKING19    519
#define IDB_WORKING20    520

#define IDB_BACKCELL     601
#define IDB_FORECELL     602
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\spddlang\sbcs\spddsbcs.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    spddjpn.c

Abstract:

    Top-level file for single-byte character set locales support
    module for text mode setup.

Author:

    Ted Miller (tedm) 04-July-1995

Revision History:

--*/

#include "spprecmp.h"
#pragma hdrstop
#include <hdlsterm.h>


//
// Mapping from line char enum to unicode characters.
//
WCHAR LineCharIndexToUnicodeValue[LineCharMax] =

          {  0x2554,          // DoubleUpperLeft
             0x2557,          // DoubleUpperRight
             0x255a,          // DoubleLowerLeft
             0x255d,          // DoubleLowerRight
             0x2550,          // DoubleHorizontal
             0x2551,          // DoubleVertical
             0x250c,          // SingleUpperLeft
             0x2510,          // SingleUpperRight
             0x2514,          // SingleLowerLeft
             0x2518,          // SingleLowerRight
             0x2500,          // SingleHorizontal
             0x2502,          // SingleVertical
             0x255f,          // DoubleVerticalToSingleHorizontalRight,
             0x2562           // DoubleVerticalToSingleHorizontalLeft,
          };



ULONG
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine initializes the language-specific portion of
    the setup device driver.

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the Unicode name of the registry path
            for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    UNREFERENCED_PARAMETER(DriverObject);
    UNREFERENCED_PARAMETER(RegistryPath);

    //
    // We don't do too much here.
    //
    return(STATUS_SUCCESS);
}


NTSTATUS
SplangInitializeFontSupport(
    IN PCWSTR BootDevicePath,
    IN PCWSTR DirectoryOnBootDevice,
    IN PVOID BootFontImage OPTIONAL,
    IN ULONG BootFontImageLength OPTIONAL    
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to allow the language-specific
    font support to be initialized. The language-specific driver should
    load any font it requires and perform any additioanl initialization.

Arguments:

    BootDevicePath - supplies the path of the device from which the system
        booted. This is a full NT-style device path.

    DirectoryOnBootDevice - supplies directory relative to root of boot
        device.

    BootFontImage - Bootfont.bin file memory image passed by the loader

    BootFontImageLength - Length of the BootFontImage buffer 
    
Return Value:

    NT Status code indicating outcome. If this routine returns a non-success
    status code, then setupdd.sys will not switch into non-US character mode.
    The implementation of this routine is free to call SpBugCheck or otherwise
    inform the user of any errors if it wishes to halt setup if font
    initialization fails.

--*/

{
    //
    // For SBCS locales we don't do anything other than what the main
    // setup module offers. Return failure indicating that we have no
    // special video or font requirements.
    //
    UNREFERENCED_PARAMETER(BootDevicePath);
    UNREFERENCED_PARAMETER(DirectoryOnBootDevice);
    UNREFERENCED_PARAMETER(BootFontImage);
    UNREFERENCED_PARAMETER(BootFontImageLength);

    return(STATUS_UNSUCCESSFUL);
}


NTSTATUS
SplangTerminateFontSupport(
    VOID
    )

/*++

Routine Description:

    This routine may be called in certain conditions to cause font support
    for a particular language to be terminated. The implementation should
    clean up any resources allocated during SplangInitializeFontSupport().

Arguments:

    None.

Return Value:

    NT Status code indicating outcome.

--*/

{
    //
    // Never initialized anything so nothing to do.
    //
    return(STATUS_SUCCESS);
}


PVIDEO_FUNCTION_VECTOR
SplangGetVideoFunctionVector(
    IN SpVideoType VideoType,
    IN PSP_VIDEO_VARS VideoVariableBlock
    )

/*++

Routine Description:

    This routine is called by setupdd.sys upon successful return from
    SplangInitializeFontSupport, to request a pointer to a vector of
    language-specific display support routines for a given display
    type (vga or frame buffer).

Arguments:

    VideoType - a value from the SpVideoType enum indicating which display
        vector is requested. Currently one of SpVideoVga or SpVideoFrameBuffer.

    VideoVariableBlock - supplies a pointer to a block of video variables that
        are shared between the high-level code in setup\textmode\spvideo.c and
        the display-specific code.

Return Value:

    Pointer to the language-specific video functions vector to use for
    displaying text. NULL if the requested type is not supported. In this case
    the display will not be switched into non-US character mode.

--*/

{
    //
    // Single-byte locales have no special video requirements.
    //
    return(NULL);
}


ULONG
SplangGetColumnCount(
    IN PCWSTR String
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to determine how many columns
    on the screen a particular string will occupy. This may be different
    than the number of characters in the string due to full/half width
    characters in the character set, etc. Full width chars occupy two columns
    whereas half-width chars occupy one column. If the font in use is
    fixed-pitch or does not support DBCS, the number of columns is by
    definition equal to the number of characters in the string.

Arguments:

    String - points to unicode string whose width in columns is desired.

Return Value:

    Number of columns occupied by the string.

--*/

{
    //
    // For sbcs locales the column count is equal to the number of
    // characters in the string.
    //
    return(wcslen(String));
}


PWSTR
SplangPadString(
    IN int    Size,
    IN PCWSTR String
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to generate a padded string
    appropriate for SBCS or DBCS as appropriate.

Arguments:

    Size - specifies the length to which to pad the string.

    String - points to unicode string that needs to be padded.

Return Value:

    Pointer to padded string. Note that this is a static buffer and thus
    the caller must duplicate the string if it is needed across multiple
    calls to this routine.

--*/

{
    //
    // Nothing special is done for SBCS locales. Assume the string is
    // padded correctly already.
    //
    UNREFERENCED_PARAMETER(Size);
    return((PWSTR)String);
}


VOID
SplangSelectKeyboard(
    IN BOOLEAN UnattendedMode,
    IN PVOID UnattendedSifHandle,
    IN ENUMUPGRADETYPE NTUpgrade,
    IN PVOID SifHandle,
    IN PHARDWARE_COMPONENT *HwComponents
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to allow language-specific processing
    for the keyboard selection. The implementation can confirm a keyboard
    type at this time.

Arguments:

    UnattendedMode - supplies a flag indicating whether we are running in
        unattended mode. If so, the implementation may wish to do nothing,
        since the user will not be entering any paths.

    SifHandle - supplies handle to open setup information file (txtsetup.sif).

    HwComponents - supplies the address of the master hardware components
        array.

Return Value:

    None. If a failure occurs, it is up to the implementation to decide whether
    to continue or to SpBugCheck.

--*/

{
    //
    // Nothing to do for SBCS locales.
    //
    UNREFERENCED_PARAMETER(UnattendedMode);
    UNREFERENCED_PARAMETER(UnattendedSifHandle);
    UNREFERENCED_PARAMETER(NTUpgrade);
    UNREFERENCED_PARAMETER(SifHandle);
    UNREFERENCED_PARAMETER(HwComponents);
}


VOID
SplangReinitializeKeyboard(
    IN BOOLEAN UnattendedMode,
    IN PVOID   SifHandle,
    IN PWSTR   Directory,
    OUT PVOID *KeyboardVector,
    IN PHARDWARE_COMPONENT *HwComponents
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to allow language-specific processing
    for the keyboard. The implementation can reinitialize the keyboard layout
    at this time.

    This routine will be called before the user is asked to enter any paths
    or other text that includes typing anything other than keys such as
    ENTER, function keys, backspace, escape, etc.

Arguments:

    UnattendedMode - supplies a flag indicating whether we are running in
        unattended mode. If so, the implementation may wish to do nothing,
        since the user will not be entering any paths.

    SifHandle - supplies handle to open setup information file (txtsetup.sif).

    Directory - supplies the directory on the boot device from which the
        new layout dll is to be loaded.

    KeyboardVector - supplies the address of a pointer to the keyboard
        vector table. The implementation should overwrite this value with
        whatever is returned from SpLoadKbdLayoutDll().

    HwComponents - supplies the address of the master hardware components
        array.

Return Value:

    None. If a failure occurs the implementation must leave the currently active
    keybaord in place.

--*/

{
    //
    // Nothing to do for SBCS locales.
    //
    UNREFERENCED_PARAMETER(UnattendedMode);
    UNREFERENCED_PARAMETER(SifHandle);
    UNREFERENCED_PARAMETER(Directory);
    UNREFERENCED_PARAMETER(KeyboardVector);
    UNREFERENCED_PARAMETER(HwComponents);
}


WCHAR
SplangGetLineDrawChar(
    IN LineCharIndex WhichChar
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to retreive the unicode value for
    a particular line drawing character. An implementation must make these
    characters available in the character set somehow.

Arguments:

    WhichChar - supplies the index of the character desired.

Return Value:

    Unicode value for the character in question. Because the character
    will be displayed using the language-specific module, the implementation
    can materialize this character by playing whatever tricks it needs to,
    such as overlaying a hardcoded glyph into the character set, etc.

--*/

{
    ASSERT((ULONG)WhichChar < (ULONG)LineCharMax);

    return(  ((ULONG)WhichChar < (ULONG)LineCharMax)
             ? LineCharIndexToUnicodeValue[WhichChar] : L' '
           );
}


WCHAR
SplangGetCursorChar(
    VOID
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to retreive the unicode value
    of a character to be used as the cursor when the user is asked to
    enter text.

Arguments:

    None.

Return Value:

    Unicode value for the character to be used as the cursor.

--*/

{
    HEADLESS_CMD_ENABLE_TERMINAL Command;
    NTSTATUS Status;
    
    Command.Enable = TRUE;
    Status = HeadlessDispatch(HeadlessCmdEnableTerminal,
                              &Command,
                              sizeof(HEADLESS_CMD_ENABLE_TERMINAL),
                              NULL,
                              NULL
                             );
    if (NT_SUCCESS(Status)) {
        return(L'_');
    }
    
    //
    // Lower half-block character (oem char #220 in cp 437)
    //
    return(0x2584);
}


NTSTATUS
SplangSetRegistryData(
    IN PVOID  SifHandle,
    IN HANDLE ControlSetKeyHandle,
    IN PHARDWARE_COMPONENT *HwComponents,
    IN BOOLEAN Upgrade
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to cause language-specific
    information to be written into the current control set in the registry.

Arguments:

    SifHandle - supplies a handle to the open setup information file
        (txtsetup.sif).

    ControlSetKeyHandle - supplies a handle to the current control set
        root in the registry (ie, HKEY_LOCAL_MACHINE\CurrentControlSet).

    HwComponents - supplies the address of the master hardware components
        array.

Return Value:

    NT Status value indicating outcome. A non-success status is considered
    critical and causes Setup to abort.

--*/

{
    //
    // Nothing to do for SBCS locales.
    //
    UNREFERENCED_PARAMETER(SifHandle);
    UNREFERENCED_PARAMETER(ControlSetKeyHandle);
    UNREFERENCED_PARAMETER(HwComponents);
    UNREFERENCED_PARAMETER(Upgrade);
    return(STATUS_SUCCESS);
}


BOOLEAN
SplangQueryMinimizeExtraSpacing(
    VOID
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to determine whether to
    eliminate uses of extra spacing on the screen to set off things
    like menus and lists from text. Languages whose text takes up
    a lot of room on the screen might opt to eliminate such spacing
    to allow menus to display more than a couple of items at a time, etc.

    The return value affects numerous screens, such as the partition menu,
    upgrade lists, etc.

Arguments:

    None.

Return Value:

    Boolean value indicating whether the implementation wants unnecessary
    spaces eliminated when text, menu, etc, are displayed.

--*/

{
    //
    // For SBCS locales we want standard spacing.
    //
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\cpu.inc ===
;++
;
;   Copyright (c) 1989  Microsoft Corporation
;
;   Module Name:
;
;       cpu.inc
;
;   Abstract:
;
;       This module contains the assembly structures and definitions
;       for INTEL 80x86 CPU specifiec information.  This include file
;       is mainly used by CPU.ASM to determine CPU type and stepping
;       number.
;
;   Author:
;
;       Shie-Lin (shielint) 1-Oct-1991
;
;   Revision History:
;
;--

;
; The following equates define the control bits of CR0 register
;

CR0_AM          equ     40000h
CR0_ET          equ     00010h

;
; The following equates define the control bits of EFALGS register
;

EFLAGS_AC       equ     40000h
EFLAGS_VM       equ     20000h
EFLAGS_RF       equ     10000h
EFLAGS_NF       equ     4000h
EFLAGS_IOPL     equ     3000h
EFLAGS_IF       equ     200h
EFLAGS_TF       equ     100h


;
; define the structure type for real mode interrupt vectore
;

RealModeVector  struc

VectorOffset    dw      0
VectorSegment   dw      0

RealModeVector  ends

;
; Define the iret frame
;

IretFrame       struc

IretIp         dw      0
IretCs         dw      0
IretFlags      dw      0

IretFrame       ends

;
; Misc. definitions
;

ADDRESS_OVERRIDE        equ     67h
OPERAND_OVERRIDE        equ     66h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\cpu.asm ===
title  "Processor type and stepping detection"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    cpu.asm
;
; Abstract:
;
;    This module implements the assembley code necessary to determine
;    cpu type and stepping information.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 28-Oct-1991.
;        Some of the code is extracted from Cruiser (mainly,
;        the code to determine 386 stepping.)
;
; Environment:
;
;    80x86 Real Mode.
;
; Revision History:
;
;
;--

        .xlist
include cpu.inc
        .list

;
; constant for i386 32-bit multiplication test
;

MULTIPLIER            equ     00000081h
MULTIPLICAND          equ     0417a000h
RESULT_HIGH           equ     00000002h
RESULT_LOW            equ     0fe7a000h

;
; Constants for Floating Point test
;

REALLONG_LOW          equ     00000000
REALLONG_HIGH         equ     3FE00000h
PSEUDO_DENORMAL_LOW   equ     00000000h
PSEUDO_DENORMAL_MID   equ     80000000h
PSEUDO_DENORMAL_HIGH  equ     0000h

.386p

_TEXT   SEGMENT PARA USE16 PUBLIC 'CODE'
        ASSUME  CS: _TEXT, DS:NOTHING, SS:NOTHING


;++
;
; USHORT
; HwGetProcessorType (
;    VOID
;    )
;
; Routine Description:
;
;    This function determines type of processor (80486, 80386, 80286,
;    and even 8086/8088).  it relies on Intel-approved code that takes
;    advantage of the documented behavior of the high nibble of the flag
;    word in the REAL MODE of the various processors.
;
;    For completeness, the code also checks for 8088/8086.  But, it won't
;    work.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    (ax) = x86h or 0 if unrecongnized processor.
;
;--

.8086

        public  _HwGetProcessorType
_HwGetProcessorType      proc    near

        pushf                           ; save entry flags

;
;    The MSB (bit 15) is always a one on the 8086 and 8088 and a zero on
;    the 286, 386 and 486.
;

        pushf
        pop     ax
        and     ax, NOT 08000h          ; clear bit 15 of flags
        push    ax
        popf                            ; try to put that in the flags
        pushf
        pop     ax                      ; look at what really went into flags

        test    ax,08000h               ; Was high bit set ?
        jnz     short x_86              ; if nz, still set, goto x_86

;
;    Bit 14 (NT flag) and bits 13/12 (IOPL bit field) are always zero on
;    the 286, but can be set on the 386 and 486.
;

        or      ax,07000h               ; Try to set the NT/IOPL bits
        push    ax
        popf                            ; Put in to the flags
        sti                             ; (for VDMM/IOPL0)
        pushf
        pop     ax                      ; look at actual flags
        test    ax,07000h               ; Any high bits set ?
        jz      short x_286             ; if z, no, goto x_286

.386p

;
;    The Alignment Check bit in flag can be set on 486 and is always zero
;    on 386.
;

        mov     eax,cr0                 ; test for 486 processor
        push    eax                     ; save CR0 value
        and     eax,not CR0_AM          ; disable alignment check
        mov     cr0,eax
        db      ADDRESS_OVERRIDE
        pushfd                          ; save original EFLAGS
        db      ADDRESS_OVERRIDE
        pushfd                          ; try to set alignment check
        or      dword ptr [esp],EFLAGS_AC ;           bit in EFLAGS
        db      ADDRESS_OVERRIDE
        popfd
        db      ADDRESS_OVERRIDE
        pushfd                          ; copy new flags into ECX
        pop     ecx                     ; [ecx] = new flags word
        db      ADDRESS_OVERRIDE
        popfd                           ; restore original EFLAGS
        pop     eax                     ; restore original CR0 value
        mov     cr0,eax
        and     ecx, EFLAGS_AC          ; did AC bit get set?
        jz      short x_386             ; if z, no, goto x_386

        mov     eax, 4h                 ; if nz, we have a 486 processor

.286p

        jmp     short hpt99

x_286:
        mov     ax, 2h                  ; Return 286 processor type.
        jmp     short hpt99

x_86:
        mov     ax, 0h                  ; Return 86h for 8088/8086 CPU type.
        jmp     short hpt99

x_386:
        mov     ax, 3h                  ; Return 386 processor type.
hpt99:
        popf                            ; restore flags
        ret

_HwGetProcessorType      endp

IFDEF ALLOW_386
.386p

;++
;
; USHORT
; HwGetCpuStepping (
;    UHSORT CpuType
;    )
;
; Routine Description:
;
;    This function determines cpu stepping for the specified CPU type.
;
;    Currently, this routine only determine stepping for 386 and 486.
;
; Arguments:
;
;    CpuType - The Cpu type which its stepping information will be returned.
;              The input value MUST be either 386 or 486.
;
; Return Value:
;
;    [ax] - Cpu stepping.  For example, [ax] = D0h for D0 stepping.
;
;--

if 0
HgcsCpuType     equ     [esp + 2]

        public  _HwGetCpuStepping
_HwGetCpuStepping        proc

        mov     ax, HgcsCpuType         ; [ax] = CpuType
        cmp     ax, 3h                  ; Is cpu = 386?
        jz      short Hgcs00            ; if z, yes, go Hgcs00

        call    Get486Stepping          ; else, check for 486 stepping
        jmp     short Hgcs90            ; [ax] = Stepping information

Hgcs00:
        call    _Get386Stepping         ; [ax] = Stepping information

Hgcs90:
        ret

_HwGetCpuStepping        endp
endif

;++
;
; USHORT
; _Get386Stepping (
;    VOID
;    )
;
; Routine Description:
;
;    This function determines cpu stepping for i386 CPU stepping.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    [ax] - Cpu stepping.  For example, [ax] = D0h for D0 stepping.
;    [ax] = 0 means bad CPU and stepping is not important.
;
;--

        public  _Get386Stepping
_Get386Stepping  proc

        call    MultiplyTest            ; Perform mutiplication test
        jnc     short G3s00             ; if nc, muttest is ok
        mov     ax, 0
        ret
G3s00:
        call    Check386B0              ; Check for B0 stepping
        jnc     short G3s05             ; if nc, it's B1/later
        mov     ax, 0B0h                ; It is B0/earlier stepping
        ret

G3s05:
        call    Check386D1              ; Check for D1 stepping
        jc      short G3s10             ; if c, it is NOT D1
        mov     ax, 0D1h                ; It is D1/later stepping
        ret

G3s10:
        mov     ax, 0B1h                ; assume it is B1 stepping
        ret

_Get386Stepping  endp

if 0
;++
;
; USHORT
; Get486Stepping (
;    VOID
;    )
;
; Routine Description:
;
;    This function determines cpu stepping for i486 CPU type.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    [ax] - Cpu stepping.  For example, [ax] = D0h for D0 stepping.
;
;--

        public  Get486Stepping
Get486Stepping          proc

        call    Check486AStepping       ; Check for A stepping
        jnc     short G4s00             ; if nc, it is NOT A stepping

        mov     ax, 0A0h                ; set to A stepping
        ret

G4s00:  call    Check486BStepping       ; Check for B stepping
        jnc     short G4s10             ; if nc, it is NOT a B stepping

        mov     ax, 0B0h                ; set to B stepping
        ret

;
; Before we test for 486 C/D step, we need to make sure NPX is present.
; Because the test uses FP instruction to do the detection.
;

G4s10:  call    _IsNpxPresent           ; Check if cpu has coprocessor support?
        cmp     ax, 0
        jz      short G4s15             ; it is actually 486sx

        call    Check486CStepping       ; Check for C stepping
        jnc     short G4s20             ; if nc, it is NOT a C stepping
G4s15:
        mov     ax, 0C0h                ; set to C stepping
        ret

G4s20:  mov     ax, 0D0h                ; Set to D stepping
        ret

Get486Stepping          endp

;++
;
; BOOLEAN
; Check486AStepping (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks for 486 A Stepping.
;
;    It takes advantage of the fact that on the A-step of the i486
;    processor, the ET bit in CR0 could be set or cleared by software,
;    but was not used by the hardware.  On B or C -step, ET bit in CR0
;    is now hardwired to a "1" to force usage of the 386 math coprocessor
;    protocol.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if B or later stepping.
;    Carry Flag set if A or earlier stepping.
;
;--
        public  Check486AStepping
Check486AStepping       proc    near
.386p
        mov     eax, cr0                ; reset ET bit in cr0
        and     eax, NOT CR0_ET
        mov     cr0, eax

        mov     eax, cr0                ; get cr0 back
        test    eax, CR0_ET             ; if ET bit still set?
        jnz     short cas10             ; if nz, yes, still set, it's NOT A step
        stc
        ret

cas10:  clc
        ret

        ret
Check486AStepping       endp

;++
;
; BOOLEAN
; Check486BStepping (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks for 486 B Stepping.
;
;    On the i486 processor, the "mov to/from DR4/5" instructions were
;    aliased to "mov to/from DR6/7" instructions.  However, the i486
;    B or earlier steps generate an Invalid opcode exception when DR4/5
;    are used with "mov to/from special register" instruction.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if C or later stepping.
;    Carry Flag set if B stepping.
;
;--
        public  Check486BStepping
Check486BStepping       proc

        push    ds
        push    bx

        xor     ax,ax
        mov     ds,ax                   ; (DS) = 0 (real mode IDT)
        mov     bx,6*4
        push    dword ptr [bx]          ; save old int 6 vector

        mov     word ptr [bx].VectorOffset,offset Temporary486Int6
        mov     [bx].VectorSegment,cs         ; set vector to new int 6 handler

c4bs50: db      0fh, 21h, 0e0h            ; mov eax, DR4
        nop
        nop
        nop
        nop
        nop
        clc                             ; it is C step
        jmp     short c4bs70
c4bs60: stc                             ; it's B step
c4bs70: pop     dword ptr [bx]          ; restore old int 6 vector

        pop     bx
        pop     ds
        ret

        ret

Check486BStepping       endp

;++
;
; BOOLEAN
; Temporary486Int6 (
;    VOID
;    )
;
; Routine Description:
;
;    Temporary int 6 handler - assumes the cause of the exception was the
;    attempted execution of an mov to/from DR4/5 instruction.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    none.
;
;--

Temporary486Int6        proc

        mov     word ptr [esp].IretIp,offset c4bs60 ; set IP to stc instruction
        iret

Temporary486Int6        endp

;++
;
; BOOLEAN
; Check486CStepping (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks for 486 C Stepping.
;
;    This routine takes advantage of the fact that FSCALE produces
;    wrong result with Denormal or Pseudo-denormal operand on 486
;    C and earlier steps.
;
;    If the value contained in ST(1), second location in the floating
;    point stack, is between 1 and 11, and the value in ST, top of the
;    floating point stack, is either a pseudo-denormal number or a
;    denormal number with the underflow exception unmasked, the FSCALE
;    instruction produces an incorrect result.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if D or later stepping.
;    Carry Flag set if C stepping.
;
;--

FpControl       equ     [ebp - 2]
RealLongSt1     equ     [ebp - 10]
PseudoDenormal  equ     [ebp - 20]
FscaleResult    equ     [ebp - 30]

        public  Check486CStepping
Check486CStepping       proc

        push    ebp
        mov     ebp, esp
        sub     esp, 30                 ; Allocate space for temp real variables

;
; Initialize the local FP variables to predefined values.
; RealLongSt1 = 1.0 * (2 ** -1) = 0.5 in normalized double precision FP form
; PseudoDenormal =  a unsupported format by IEEE.
;                   Sign bit = 0
;                   Exponent = 000000000000000B
;                   Significand = 100000...0B
; FscaleResult = The result of FSCALE instruction.  Depending on 486 step,
;                the value will be different:
;                Under C and earlier steps, 486 returns the original value
;                in ST as the result.  The correct returned value should be
;                original significand and an exponent of 0...01.
;

        mov     dword ptr RealLongSt1, REALLONG_LOW
        mov     dword ptr RealLongSt1 + 4, REALLONG_HIGH
        mov     dword ptr PseudoDenormal, PSEUDO_DENORMAL_LOW
        mov     dword ptr PseudoDenormal + 4, PSEUDO_DENORMAL_MID
        mov     word ptr PseudoDenormal + 8, PSEUDO_DENORMAL_HIGH

.387
        fnstcw  FpControl               ; Get FP control word
        or      word ptr FpControl, 0FFh ; Mask all the FP exceptions
        fldcw   FpControl               ; Set FP control

        fld     qword ptr RealLongSt1   ; 0 < ST(1) = RealLongSt1 < 1
        fld     tbyte ptr PseudoDenormal; Denormalized operand. Note, i486
                                        ; won't report denormal exception
                                        ; on 'FLD' instruction.
                                        ; ST(0) = Extended Denormalized operand
        fscale                          ; try to trigger 486Cx errata
        fstp    tbyte ptr FscaleResult  ; Store ST(0) in FscaleResult
        cmp     word ptr FscaleResult + 8, PSEUDO_DENORMAL_HIGH
                                        ; Is Exponent changed?
        jz      short c4ds00            ; if z, no, it is C step
        clc
        jmp     short c4ds10
c4ds00: stc
c4ds10: mov     esp, ebp
        pop     ebp
        ret

Check486CStepping       endp
endif

;++
;
; BOOLEAN
; Check386B0 (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks for 386 B0 or earlier stepping.
;
;    It takes advantage of the fact that the bit INSERT and
;    EXTRACT instructions that existed in B0 and earlier versions of the
;    386 were removed in the B1 stepping.  When executed on the B1, INSERT
;    and EXTRACT cause an int 6 (invalid opcode) exception.  This routine
;    can therefore discriminate between B1/later 386s and B0/earlier 386s.
;    It is intended to be used in sequence with other checks to determine
;    processor stepping by exercising specific bugs found in specific
;    steppings of the 386.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if B1 or later stepping
;    Carry Flag set if B0 or prior
;
;--


    ASSUME ds:nothing, es:nothing, fs:nothing, gs:nothing, ss:nothing

Check386B0      proc

        push    ds
        push    bx

        xor     ax,ax
        mov     ds,ax                   ; (DS) = 0 (real mode IDT)
        mov     bx,6*4
        push    dword ptr [bx]          ; save old int 6 vector

        mov     word ptr [bx].VectorOffset,offset TemporaryInt6
        mov     [bx].VectorSegment,cs         ; set vector to new int 6 handler

;
; Attempt execution of Extract Bit String instruction.  Execution on
; B0 or earlier with length (CL) = 0 will return 0 into the destination
; (CX in this case).  Execution on B1 or later will fail either due to
; taking the invalid opcode trap, or if the opcode is valid, we don't
; expect CX will be zeroed by any new instruction supported by newer
; steppings.  The dummy int 6 handler will clears the Carry Flag and
; returns execution to the appropriate label.  If the instruction
; actually executes, CX will *probably* remain unchanged in any new
; stepping that uses the opcode for something else.  The nops are meant
; to handle newer steppings with an unknown instruction length.
;

        xor     ax,ax
        mov     dx,ax
        mov     cx,0ff00h               ; Extract length (CL) == 0, (CX) != 0

b1c50:  db      0fh, 0a6h, 0cah         ; xbts cx,dx,ax,cl
        nop
        nop
        nop
        nop
        nop
        stc                             ; assume B0
        jcxz    short b1c70             ; jmp if B0
b1c60:  clc
b1c70:  pop     dword ptr [bx]          ; restore old int 6 vector

        pop     bx
        pop     ds
        ret

Check386B0      endp

;++
;
; BOOLEAN
; TemporaryInt6 (
;    VOID
;    )
;
; Routine Description:
;
;    Temporary int 6 handler - assumes the cause of the exception was the
;    attempted execution of an XTBS instruction.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    none.
;
;--

TemporaryInt6    proc

        mov     word ptr [esp].IretIp,offset b1c60 ; set IP to clc instruction
        iret

TemporaryInt6   endp

;++
;
; BOOLEAN
; Check386D1 (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks for 386 D1 Stepping.
;
;    It takes advantage of the fact that on pre-D1 386, if a REPeated
;    MOVS instruction is executed when single-stepping is enabled,
;    a single step trap is taken every TWO moves steps, but should
;    occuu each move step.
;
;    NOTE: This routine cannot distinguish between a D0 stepping and a D1
;    stepping.  If a need arises to make this distinction, this routine
;    will need modification.  D0 steppings will be recognized as D1.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if D1 or later stepping
;    Carry Flag set if B1 or prior
;
;--

    assume ds:nothing, es:nothing, fs:nothing, gs:nothing, ss:nothing

Check386D1      proc

        push    ds
        push    bx

        xor     ax,ax
        mov     ds,ax                   ; (DS) = 0 (real mode IDT)
        mov     bx,1*4
        push    dword ptr [bx]          ; save old int 1 vector

        mov     word ptr [bx].VectorOffset,offset TemporaryInt1
        mov     word ptr [bx].VectorSegment,cs ; set vector to new int 1 handler

;
; Attempt execution of rep movsb instruction with the Trace Flag set.
; Execution on B1 or earlier with length (CX) > 1 will trace over two
; iterations before accepting the trace trap.  Execution on D1 or later
; will accept the trace trap after a single iteration.  The dummy int 1
; handler will return execution to the instruction following the movsb
; instruction.  Examination of (CX) will reveal the stepping.
;

        sub     sp,4                    ; make room for target of movsb
        xor     si,si                   ; (ds:si) = 0:0
        push    ss                      ; (es:di) = ss:sp-4
        pop     es
        mov     di,sp
        mov     cx,2                    ; 2 iterations
        pushf
        or      word ptr [esp], EFLAGS_TF
        popf                            ; cause a single step trap
        rep movsb

d1c60:  add     sp,4                    ; clean off stack
        pop     dword ptr [bx]          ; restore old int 1 vector
        stc                             ; assume B1
        jcxz    short d1cx              ; jmp if <= B1
        clc                             ; else clear carry to indicate >= D1
d1cx:
        pop     bx
        pop     ds
        ret

Check386D1      endp

;++
;
; BOOLEAN
; TemporaryInt1 (
;    VOID
;    )
;
; Routine Description:
;
;    Temporary int 1 handler - assumes the cause of the exception was
;    trace trap at the above rep movs instruction.
;
; Arguments:
;
;    (esp)->eip of trapped instruction
;           cs  of trapped instruction
;           eflags of trapped instruction
;
;--

TemporaryInt1   proc

        and     word ptr [esp].IretFlags,not EFLAGS_TF ; clear caller's Trace Flag
        mov     word ptr [esp].IretIp,offset d1c60     ; set IP to next instruction
        iret

TemporaryInt1   endp

;++
;
; BOOLEAN
; MultiplyTest (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks the 386 32-bit multiply instruction.
;    The reason for this check is because some of the i386 fail to
;    perform this instruction.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear on success
;    Carry Flag set on failure
;
;--
;

    assume ds:nothing, es:nothing, fs:nothing, gs:nothing, ss:nothing

MultiplyTest    proc

        xor     cx,cx                   ; 64K times is a nice round number
mlt00:  push    cx
        call    Multiply                ; does this chip's multiply work?
        pop     cx
        jc      short mltx              ; if c, No, exit
        loop    mlt00                   ; if nc, YEs, loop to try again
        clc
mltx:
        ret

MultiplyTest    endp

;++
;
; BOOLEAN
; Multiply (
;    VOID
;    )
;
; Routine Description:
;
;    This routine performs 32-bit multiplication test which is known to
;    fail on bad 386s.
;
;    Note, the supplied pattern values must be used for consistent results.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear on success.
;    Carry Flag set on failure.
;
;--

Multiply        proc

        mov     ecx, MULTIPLIER
        mov     eax, MULTIPLICAND
        mul     ecx

        cmp     edx, RESULT_HIGH        ; Q: high order answer OK ?
        stc                             ; assume failure
        jnz     short mlpx              ;   N: exit with error

        cmp     eax, RESULT_LOW         ; Q: low order answer OK ?
        stc                             ; assume failure
        jnz     short mlpx              ;   N: exit with error

        clc                             ; indicate success
mlpx:
        ret

Multiply        endp

;++
;
; BOOLEAN
; IsNpxPresent(
;     VOID
;     );
;
; Routine Description:
;
;     This routine determines if there is any Numeric coprocessor
;     present.  If yes, the ET bit in CR0 will be set; otherwise
;     it will be reset.
;
;     Note that we do NOT determine its type (287, 387).
;     This code is extracted from Intel book.
;
; Arguments:
;
;     None.
;
; Return:
;
;     TRUE - If NPX is present.  Else a value of FALSE is returned.
;
;--

if 0
        public  _IsNpxPresent
_IsNpxPresent   proc    near

        push    bp                      ; Save caller's bp
.386p
        mov     eax, cr0
        and     eax, NOT CR0_ET         ; Assume no NPX
        mov     edx, 0
.287
        fninit                          ; Initialize NPX
        mov     cx, 5A5Ah               ; Put non-zero value
        push    cx                      ;   into the memory we are going to use
        mov     bp, sp
        fnstsw  word ptr [bp]           ; Retrieve status - must use non-wait
        cmp     byte ptr [bp], 0        ; All bits cleared by fninit?
        jne     Inp10

        or      eax, CR0_ET
        mov     edx, 1
Inp10:
        mov     cr0, eax
        pop     ax                      ; clear scratch value
        pop     bp                      ; Restore caller's bp
        mov     eax, edx
        ret

_IsNpxPresent   endp
endif

ENDIF ; def ALLOW_386

_TEXT   ENDS
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\spddlang\fe\spddfe.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    spddfe.c

Abstract:

    Top-level file for FarEast-specific language support
    module for text mode setup.

Author:

    Ted Miller (tedm) 04-July-1995

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

//
// String contant.
//
PWSTR szKeyboard       = L"Keyboard";
PWSTR szKeyboardLayout = L"Keyboard Layout";
PWSTR szNLSSection     = L"nls";
PWSTR szAnsiCodePage   = L"AnsiCodepage";
PWSTR szJapanese       = L"932";
PWSTR szKorean         = L"949";

PWSTR szJapaneseIME_NT3x = L"MSIME95.IME";
PWSTR szJapaneseIME_NT40 = L"MSIME97.IME";

PWSTR szKoreanIME_NT3x = L"MSIME95.IME";
PWSTR szKoreanIME_NT40 = L"MSIME95K.IME";


ULONG
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine initializes the language-specific portion of
    the setup device driver.

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the Unicode name of the registry path
            for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    UNREFERENCED_PARAMETER(DriverObject);
    UNREFERENCED_PARAMETER(RegistryPath);

    //
    // We don't do too much here.
    //
    return(STATUS_SUCCESS);
}


NTSTATUS
SplangInitializeFontSupport(
    IN PCWSTR BootDevicePath,
    IN PCWSTR DirectoryOnBootDevice,
    IN PVOID BootFontImage OPTIONAL,
    IN ULONG BootFontImageLength OPTIONAL
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to allow the language-specific
    font support to be initialized. The language-specific driver should
    load any font it requires and perform any additioanl initialization.

Arguments:

    BootDevicePath - supplies the path of the device from which the system
        booted. This is a full NT-style device path.

    DirectoryOnBootDevice - supplies directory relative to root of boot
        device.

    BootFontImage - Bootfont.bin file memory image passed by the loader

    BootFontImageLength - Length of the BootFontImage buffer 

Return Value:

    NT Status code indicating outcome. If this routine returns a non-success
    status code, then setupdd.sys will not switch into non-US character mode.
    The implementation of this routine is free to call SpBugCheck or otherwise
    inform the user of any errors if it wishes to halt setup if font
    initialization fails.

--*/

{
    BOOLEAN b;

    b = FEDbcsFontInitGlyphs(
            BootDevicePath,
            DirectoryOnBootDevice,
            BootFontImage,
            BootFontImageLength
            );

    return(b ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}


NTSTATUS
SplangTerminateFontSupport(
    VOID
    )

/*++

Routine Description:

    This routine may be called in certain conditions to cause font support
    for a particular language to be terminated. The implementation should
    clean up any resources allocated during SplangInitializeFontSupport().

Arguments:

    None.

Return Value:

    NT Status code indicating outcome.

--*/

{
    FEDbcsFontFreeGlyphs();
    return(STATUS_SUCCESS);
}


PVIDEO_FUNCTION_VECTOR
SplangGetVideoFunctionVector(
    IN SpVideoType VideoType,
    IN PSP_VIDEO_VARS VideoVariableBlock
    )

/*++

Routine Description:

    This routine is called by setupdd.sys upon successful return from
    SplangInitializeFontSupport, to request a pointer to a vector of
    language-specific display support routines for a given display
    type (vga or frame buffer).

Arguments:

    VideoType - a value from the SpVideoType enum indicating which display
        vector is requested. Currently one of SpVideoVga or SpVideoFrameBuffer.

    VideoVariableBlock - supplies a pointer to a block of video variables that
        are shared between the high-level code in setup\textmode\spvideo.c and
        the display-specific code.

Return Value:

    Pointer to the language-specific video functions vector to use for
    displaying text. NULL if the requested type is not supported. In this case
    the display will not be switched into non-US character mode.

--*/

{
    VideoVariables = VideoVariableBlock;

    switch(VideoType) {
    case SpVideoVga:
        KdPrint(("SETUP:SpVideoVgaMode\n"));
        return(&VgaGraphicsModeVideoVector);
    case SpVideoFrameBuffer:
        KdPrint(("SETUP:SpVideoFrameBufferMode\n"));
        return(&FrameBufferKanjiVideoVector);
    default:
        return(NULL);
    }
}


ULONG
SplangGetColumnCount(
    IN PCWSTR String
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to determine how many columns
    on the screen a particular string will occupy. This may be different
    than the number of characters in the string due to full/half width
    characters in the character set, etc. Full width chars occupy two columns
    whereas half-width chars occupy one column. If the font in use is
    fixed-pitch or does not support DBCS, the number of columns is by
    definition equal to the number of characters in the string.

Arguments:

    String - points to unicode string whose width in columns is desired.

Return Value:

    Number of columns occupied by the string.

--*/

{
    return(FEGetStringColCount(String));
}


PWSTR
SplangPadString(
    IN int    Size,
    IN PCWSTR String
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to generate a padded string
    appropriate for SBCS or DBCS as appropriate.

Arguments:

    Size - specifies the length to which to pad the string.

    String - points to unicode string that needs to be padded.

Return Value:

    Pointer to padded string. Note that this is a static buffer and thus
    the caller must duplicate the string if it is needed across multiple
    calls to this routine.

--*/

{
    return(FEPadString(Size,String));
}


VOID
SplangSelectKeyboard(
    IN BOOLEAN UnattendedMode,
    IN PVOID UnattendedSifHandle,
    IN ENUMUPGRADETYPE NTUpgrade,
    IN PVOID SifHandle,
    IN PHARDWARE_COMPONENT *HwComponents
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to allow language-specific processing
    for the keyboard selection. The implementation can confirm a keyboard
    type at this time.

Arguments:

    UnattendedMode - supplies a flag indicating whether we are running in
        unattended mode. If so, the implementation may wish to do nothing,
        since the user will not be entering any paths.

    SifHandle - supplies handle to open setup information file (txtsetup.sif).

    HwComponents - supplies the address of the master hardware components
        array.

Return Value:

    None. If a failure occurs, it is up to the implementation to decide whether
    to continue or to SpBugCheck.

--*/

{
    BOOLEAN SelectKeyboard  = FALSE;
    BOOLEAN NoEasySelection = FALSE;

#ifdef _X86_ //NEC98
  //
  // Keyborad selection is not necessary on NEC98
  //
  if (!IsNEC_98) {
#endif //NEC98
    if(IS_JAPANESE_VERSION(SifHandle)) {
        SelectKeyboard  = TRUE;
    } else if(IS_KOREAN_VERSION(SifHandle)) {
        SelectKeyboard  = TRUE;
        NoEasySelection = TRUE;
    }
#ifdef _X86_ //NEC98
  }
#endif //NEC98

    if(SelectKeyboard) {
        if(!UnattendedMode) {
            FESelectKeyboard(SifHandle,HwComponents,NoEasySelection,(BOOLEAN) (NTUpgrade == 0xFF));
        } else if(NTUpgrade != UpgradeFull) {
            FEUnattendSelectKeyboard(UnattendedSifHandle,SifHandle,HwComponents);
        }
    }
}


VOID
SplangReinitializeKeyboard(
    IN BOOLEAN UnattendedMode,
    IN PVOID   SifHandle,
    IN PWSTR   Directory,
    OUT PVOID *KeyboardVector,
    IN PHARDWARE_COMPONENT *HwComponents
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to allow language-specific processing
    for the keyboard. The implementation can reinitialize the keyboard layout
    at this time.

    This routine will be called before the user is asked to enter any paths
    or other text that includes typing anything other than keys such as
    ENTER, function keys, backspace, escape, etc.

Arguments:

    UnattendedMode - supplies a flag indicating whether we are running in
        unattended mode. If so, the implementation may wish to do nothing,
        since the user will not be entering any paths.

    SifHandle - supplies handle to open setup information file (txtsetup.sif).

    Directory - supplies the directory on the boot device from which the
        new layout dll is to be loaded.

    KeyboardVector - supplies the address of a pointer to the keyboard
        vector table. The implementation should overwrite this value with
        whatever is returned from SpLoadKbdLayoutDll().

    HwComponents - supplies the address of the master hardware components
        array.

Return Value:

    None. If a failure occurs the implementation must leave the currently active
    keybaord in place.

--*/

{
    PWSTR   KeyboardLayoutDefault = NULL;
    BOOLEAN ReloadKeyboard  = FALSE;

    if(!UnattendedMode) {
        if(IS_JAPANESE_VERSION(SifHandle)) {
            ReloadKeyboard        = TRUE;
            KeyboardLayoutDefault = L"KBDJPN.DLL";
        } else if(IS_KOREAN_VERSION(SifHandle)) {
            ReloadKeyboard        = TRUE;
            KeyboardLayoutDefault = L"KBDKOR.DLL";
        }

        if(ReloadKeyboard) {
            FEReinitializeKeyboard(SifHandle,Directory,KeyboardVector,HwComponents,KeyboardLayoutDefault);
        }
    }
}


WCHAR
SplangGetLineDrawChar(
    IN LineCharIndex WhichChar
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to retreive the unicode value for
    a particular line drawing character. An implementation must make these
    characters available in the character set somehow.

Arguments:

    WhichChar - supplies the index of the character desired.

Return Value:

    Unicode value for the character in question. Because the character
    will be displayed using the language-specific module, the implementation
    can materialize this character by playing whatever tricks it needs to,
    such as overlaying a hardcoded glyph into the character set, etc.

--*/

{
    return(FEGetLineDrawChar(WhichChar));
}


WCHAR
SplangGetCursorChar(
    VOID
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to retreive the unicode value
    of a character to be used as the cursor when the user is asked to
    enter text.

Arguments:

    None.

Return Value:

    Unicode value for the character to be used as the cursor.

--*/

{
    //
    // For FarEast version, we use the underscore character.
    // The half-block character used in the US build is not present
    // in the FarEast font.
    //
    return(L'_');
}


NTSTATUS
SplangSetRegistryData(
    IN PVOID  SifHandle,
    IN HANDLE ControlSetKeyHandle,
    IN PHARDWARE_COMPONENT *HwComponents,
    IN BOOLEAN Upgrade
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to cause language-specific
    information to be written into the current control set in the registry.

Arguments:

    SifHandle - supplies a handle to the open setup information file
        (txtsetup.sif).

    ControlSetKeyHandle - supplies a handle to the current control set
        root in the registry (ie, HKEY_LOCAL_MACHINE\CurrentControlSet).

    HwComponents - supplies the address of the master hardware components
        array.

Return Value:

    NT Status value indicating outcome. A non-success status is considered
    critical and causes Setup to abort.

--*/

{
    BOOLEAN SaveParameter = FALSE;
    BOOLEAN UpgradeKeyboardLayout = FALSE;
    NTSTATUS Status;
    PWSTR   UpgradeIMEFrom = NULL;
    PWSTR   UpgradeIMETo = NULL;
    PWSTR   UpgradeIMEText = NULL;
    WCHAR   LayoutDriver[20] = L"";

    if(IS_JAPANESE_VERSION(SifHandle)) {
        //
        // For Japanese version.
        //
        SaveParameter   = TRUE;
        //
        // Upgrade IME stuff, (if upgrade).
        //
        UpgradeKeyboardLayout = TRUE;
        //
        // Set Upgrade IME name.
        //
        UpgradeIMEFrom = szJapaneseIME_NT3x;
        UpgradeIMETo   = szJapaneseIME_NT40;
        //
        // Get default layout text name from INF.
        //
        UpgradeIMEText = SpGetSectionKeyIndex(SifHandle,szKeyboardLayout,L"E0010411",0);

        wcscpy(LayoutDriver,L"LayerDriver JPN");

    } else if(IS_KOREAN_VERSION(SifHandle)) {
        //
        // For Korean version.
        //
        SaveParameter   = TRUE;
        //
        // Upgrade IME stuff, (if upgrade).
        //
        UpgradeKeyboardLayout = TRUE;
        //
        // Set Upgrade IME name.
        //
        UpgradeIMEFrom = szKoreanIME_NT3x;
        UpgradeIMETo   = szKoreanIME_NT40;

        wcscpy(LayoutDriver,L"LayerDriver KOR");
    }

    if(IS_JAPANESE_VERSION(SifHandle) && Upgrade) {
        Status = FEUpgradeRemoveMO(ControlSetKeyHandle);
    }

    if(SaveParameter) {
        if (Upgrade) {
            //
            // Upgrade keyboard parameters.
            //
            Status = FEUpgradeKeyboardParams(SifHandle,ControlSetKeyHandle,HwComponents,LayoutDriver);

            if (UpgradeKeyboardLayout) {
                //
                // Upgrade keyboard layout (HKLM\SYSTEM\CurrentControlSet\Control\KeyboardLayouts)
                //
                Status = FEUpgradeKeyboardLayout(
                             ControlSetKeyHandle,
                             UpgradeIMEFrom,
                             UpgradeIMETo,
                             UpgradeIMEText);
            }


            return(Status);
        } else {
            //
            // Set up keyboard parameters for extra FarEast keyboard layer.
            //
            return(FESetKeyboardParams(SifHandle,ControlSetKeyHandle,HwComponents,LayoutDriver));
        }
    } else {
        return(STATUS_SUCCESS);
    }
}


BOOLEAN
SplangQueryMinimizeExtraSpacing(
    VOID
    )

/*++

Routine Description:

    This routine is called by setupdd.sys to determine whether to
    eliminate uses of extra spacing on the screen to set off things
    like menus and lists from text. Languages whose text takes up
    a lot of room on the screen might opt to eliminate such spacing
    to allow menus to display more than a couple of items at a time, etc.

    The return value affects numerous screens, such as the partition menu,
    upgrade lists, etc.

Arguments:

    None.

Return Value:

    Boolean value indicating whether the implementation wants unnecessary
    spaces eliminated when text, menu, etc, are displayed.

--*/

{
    //
    // For FarEast version, we want to minimize spacing because text is pretty big
    // in places.
    //
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\dna.asm ===
; ========================================================

if 0

        REBOOT.ASM

        Copyright (c) 1991 - Microsoft Corp.
        All rights reserved.
        Microsoft Confidential

        johnhe - 12/01/89

endif

;-----------------------------------------------------------------------------;
;       K E Y B O A R D   S C A N   C O D E S                                 ;
;-----------------------------------------------------------------------------;

KB_INTERCEPT    EQU     4fh

DEL_KEY         EQU     53h
ALT_SHIFT       EQU     08h
CTL_SHIFT       EQU     04h

WARM_BOOT_CODE  EQU     1234h

;-----------------------------------------------------------------------------;
;       BIOS DATA AREA LOCATED AT 40:00
;-----------------------------------------------------------------------------;

ROM_DATA SEGMENT AT 040h

        org     17h
KB_FLAG         LABEL BYTE


        org     072h
WarmBootFlag    LABEL WORD

ROM_DATA ENDS

;-----------------------------------------------------------------------------;
;       CPU POWER-ON STARTUP LOCATION AT ffff:00
;-----------------------------------------------------------------------------;

ROM_BIOS SEGMENT AT 0ffffh
        org     0

PowerOnReset    LABEL FAR

ROM_BIOS ENDS

;-----------------------------------------------------------------------------;

;include MODEL.INC

;-----------------------------------------------------------------------------;

;.CODE
    _TEXT segment public 'CODE'
    assume cs:_TEXT,ds:nothing

    public _DnaReboot
_DnaReboot PROC near
;RebootSystem PROC

ifdef NEC_98
DoInt15:
; 
; 37h bit 2 is shutdown bit. 
; 

        mov     al,0bh
        out     37h,al
        mov     al,0fh
        out     37h,al
        mov     al,0h
        out     0f0h,al
        jmp     DoInt15

else ; PC98
        mov     AX,3515h
        int     21h                     ; Get int 15h vector in ES:BX
        mov     AX,ES                   ; AX == Segment
        or      AX,BX                   ; Is this a NULL ptr
        jz      WarmBoot                ; If zero we can't do an int 15h

DoInt15:
        mov     ax, seg WarmBootFlag
        mov     ds, ax
        assume  DS:ROM_DATA

        mov     KB_FLAG,ALT_SHIFT OR CTL_SHIFT
        mov     AX,(KB_INTERCEPT SHL 8) OR DEL_KEY
        int     15h                     ; Put Ctrl/Alt/Del into key buffer

WarmBoot:
        cli
        cld

        mov     ax, seg WarmBootFlag
        mov     ds, ax
        assume  DS:ROM_DATA
        mov     WarmBootFlag, WARM_BOOT_CODE
        jmp     PowerOnReset
                ; Jump to the processor power-on address FFFF:0000h
endif ; NEC_98			` 

_DnaReboot ENDP
;RebootSystem    ENDP

; ========================================================


;++
;
; BOOLEAN
; _far
; _cdecl
; DnAbsoluteSectorIo(
;    IN     unsigned Drive,             //0=A, etc
;    IN     ULONG    StartSector,
;    IN     USHORT   SectorCount,
;    IN OUT PVOID    Buffer,
;    IN     BOOLEAN  Write
;    )
;
;--

        public _DnAbsoluteSectorIo
_DnAbsoluteSectorIo PROC far

; params
Drive equ 6
Int2526Packet equ 8
Write equ 18

; locals
GotLock equ -2


        push    bp
        mov     bp,sp
        sub     sp,2

        push    ds
        push    es
        push    bx
        push    si
        push    di

        mov     byte ptr [bp].GotLock,0 ; initialize lock state flag

        ;
        ; Check for Win9x by checking for version 7 or greater.
        ; The minor version number is 10 for OSR2.
        ;
        ; We might also be running on some other vendor's DOS 7,
        ; so if locking fails we try the i/o anyway.
        ;
        mov     ax,3306h                ; get MS-DOS version
        int     21h
        cmp     bl,8                    ; Is Millenium ?
        je      milljmp                 ; 
        cmp     bl,7                    ; check for DOS7 or above (Win9x)
        jb      dosjmp                  ; not Win9x
        jmp     winjmp                  ; Regular Win9x jmp

dosjmp:        
        mov     bl,8                    ; assume standard ioctl
        jmp     locked                  ; not Win9x

milljmp:
        mov     bl,48h                  ; extended ioctl
        jmp     getlock                     

winjmp:                
        mov     bl,48h                  ; DOS 7 or above, assume extended ioctl
        cmp     bh,10                   ; test OSR2
        jae     getlock                 ; OSR2, leave bl alone, use ext ioctl
        mov     bl,8                    ; Win9x gold, use standard ioctl        

getlock:
        push    bx                      ; standard/extended ioctl
.286
        push    4ah                     ; lock volume ioctl code
.8086
        push    [bp].Drive
        call    LockOrUnlock
        jc      locked                  ; failure, try i/o anyway
        inc     byte ptr [bp].GotLock   ; remember we have level 0 lock

locked:
        ;
        ; Dirty hack -- the int25/26 buffer is laid
        ; out exactly the way the parameters are passed
        ; on the stack.
        ;
        ; In OSR2 or later case, try new int21 first. Int25/26 don't work on FAT32.
        ;
        cmp     bl,48h                  ; OSR2 or later?
        mov     ax,ss
        mov     ds,ax
        push    bx                      ; save OSR2 or later flag
        lea     bx,[bp].Int2526Packet   ; ds:bx = disk i/o param
        mov     cx,0ffffh               ; tell DOS to use param packet
        jne     int2526                 ; don't try new int21 on old system
        mov     ax,7305h                ; new abs disk i/o int21 call
        mov     dl,[bp].Drive           ; fetch drive
        inc     dl                      ; make drive 1-based
        mov     si,0                    ; assume read
        cmp     byte ptr [bp].Write,0   ; write operation?
        je      doint21                 ; no, read op
        inc     si                      ; write op
doint21:
        int     21h                     ; call DOS
        jnc     did_io                  ; no error, done
int2526:
        mov     al,[bp].Drive           ; fetch drive (0-based)
        cmp     byte ptr [bp].Write,0   ; write operation?
        je      @f                      ; no, read op
        int     26h                     ; abs disk write
        jmp     short didio1
@@:     int     25h
didio1: pop     ax                      ; int 25/26 wierdness
did_io:
        pop     bx                      ; restore osr2 flag in bx
.386
        setnc   al                      ; convert carry status to boolean return code
.8086
        push    ax                      ; save return code

        ;
        ; Unlock if necessary, using same lock level
        ; of successful lock.
        ;
        cmp     byte ptr [bp].GotLock,0
        je      done                    ; no lock to undo
        push    bx                      ; osr2 or later flag/ioctl category
.286
        push    6ah                     ; unlock volume ioctl code
.8086
        push    [bp].Drive
        call    LockOrUnlock

done:   pop     ax                      ; restore return code in al
        pop     di                      ; restore caller registers
        pop     si
        pop     bx
        pop     es
        pop     ds

        mov     sp,bp                   ; restore stack frame
        pop     bp
        ret

_DnAbsoluteSectorIo ENDP

LockOrUnlock PROC near

.286
        pusha                           ; pushes 16 bytes
        mov     bp,sp
dolock:
        mov     ch,byte ptr [bp+22]     ; get ioctl category, 8 or 48
        mov     ax,440dh                ; generic ioctl code
.386
        movzx   bx,byte ptr [bp+18]     ; bl = drive, bh = lock level 0
.286
        inc     bl                      ; convert drive to 1-based
        mov     cl,byte ptr [bp+20]     ; lock/unlock ioctl code
        xor     dx,dx                   ; non-format lock
        int     21h
        jnc     lockdone
        cmp     byte ptr [bp+22],8      ; tried regular ioctl? (clobbers carry)
        mov     byte ptr [bp+22],8      ; try regular ioctl on next pass
        jne     dolock                  ; try regular ioctl
        stc                             ; error return
lockdone:
        popa
        ret     6                       ; carry set for return
.8086

LockOrUnlock ENDP

_TEXT ends

        END

; ========================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\dncopy.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dncopy.c

Abstract:

    File copy routines for DOS-hosted NT Setup program.

Author:

    Ted Miller (tedm) 1-April-1992

Revision History:

    4.0 Stephane Plante (t-stepl) 11-Dec-95
        Upgraded for SUR Release

--*/


#include "winnt.h"
#include <dos.h>
#include <fcntl.h>
#include <share.h>
#include <string.h>
#include <direct.h>
#include <ctype.h>

//
// Define size of buffer we initially try to allocate for file copies
// and the size we use if the initial allocation attempt fails.
//
#define COPY_BUFFER_SIZE1 (24*1024)   // 64K - 512
#define COPY_BUFFER_SIZE2 (24*1024)     // 24K
#define COPY_BUFFER_SIZE3 (8*1024)      // 8K



typedef struct _DIRECTORY_NODE {
    struct _DIRECTORY_NODE *Next;
    PCHAR Directory;                    // never starts or ends with \.
    PCHAR Symbol;
} DIRECTORY_NODE, *PDIRECTORY_NODE;

PDIRECTORY_NODE DirectoryList;

PSCREEN CopyingScreen;

BOOLEAN UsingGauge = FALSE;

//
// Total number of files to be copied
//
unsigned TotalFileCount;

//
// Total number of files in the optional directories
//
unsigned TotalOptionalFileCount = 0;

//
// Total number of optional directories
//
unsigned TotalOptionalDirCount = 0;
#if 0
// Debugging purposes
unsigned SaveTotalOptionalDirCount = 0;
#endif

//
// Buffer used for file copying and verifying,
// and the size of the buffer.
//
PVOID CopyBuffer;
unsigned CopyBufferSize;


VOID
DnpCreateDirectoryList(
    IN PCHAR SectionName,
    OUT PDIRECTORY_NODE *ListHead
    );

VOID
DnpCreateDirectories(
    IN PCHAR TargetRootDir
    );

VOID
DnpCreateOneDirectory(
    IN PCHAR Directory
    );

BOOLEAN
DnpOpenSourceFile(
    IN  PCHAR     Filename,
    OUT int      *Handle,
    OUT unsigned *Attribs,
    OUT BOOLEAN  *UsedCompressedName
    );

ULONG
DnpIterateCopyList(
    IN unsigned Flags,
    IN PCHAR    SectionName,
    IN PCHAR    DestinationRoot,
    IN unsigned ClusterSize OPTIONAL
    );

ULONG
DnpIterateCopyListSection(
    IN unsigned Flags,
    IN PCHAR    SectionName,
    IN PCHAR    DestinationRoot,
    IN unsigned ClusterSize OPTIONAL
    );

ULONG
DnpCopyOneFile(
    IN unsigned Flags,
    IN PCHAR    SourceName,
    IN PCHAR    DestName
    );

BOOLEAN
DnpDoCopyOneFile(
    IN  unsigned Flags,
    IN  int      SrcHandle,
    IN  int      DstHandle,
    IN  PCHAR    Filename,
    OUT PBOOLEAN Verified,
    OUT PULONG   BytesWritten
    );

BOOLEAN
DnpLookUpDirectory(
    IN  PCHAR RootDirectory,
    IN  PDIRECTORY_NODE DirList,
    IN  PCHAR Symbol,
    OUT PCHAR PathOut
    );

VOID
DnpInfSyntaxError(
    IN PCHAR Section
    );

VOID
DnpFreeDirectoryList(
    IN OUT PDIRECTORY_NODE *List
    );

VOID
DnpFormatSpaceErrMsg(
    IN ULONG NtSpaceReq,
    IN ULONG CSpaceReq
    );

ULONG
DnpDoIterateOptionalDir(
    IN unsigned Flags,
    IN PCHAR    SourceDir,
    IN PCHAR    DestDir,
    IN unsigned ClusterSize OPTIONAL,
    IN PSPACE_REQUIREMENT SpaceReqArray OPTIONAL,
    IN unsigned ArraySize OPTIONAL
    );

VOID
DnpGenerateCompressedName(
    IN  PCHAR Filename,
    OUT PCHAR CompressedName
    );

BOOLEAN
InDriverCacheInf(
    IN      PVOID InfHandle,
    IN      PCHAR FileName
    );

VOID
DnpConcatPaths(
    IN PCHAR SourceBuffer,
    IN PCHAR AppendString
    ) 
{
    if (SourceBuffer[strlen(SourceBuffer) -1] != '\\') {
        strcat(SourceBuffer, "\\");
    }

    strcat(SourceBuffer,AppendString);
}


#if NEC_98
ULONG
DnpCopyOneFileForFDless(
    IN PCHAR   SourceName,
    IN PCHAR   DestName,
    IN BOOLEAN Verify
    );
#endif // NEC_98

VOID
DnCopyFiles(
    VOID
    )

/*++

Routine Description:

    Top-level file copy entry point.  Creates all directories listed in
    the [Directories] section of the inf.  Copies all files listed in the
    [Files] section of the inf file from the source to the target (which
    becomes the local source).

Arguments:

    None.

Return Value:

    None.

--*/

{
    PCHAR LocalSourceRoot;
    struct diskfree_t DiskFree;
    unsigned ClusterSize;
    ULONG SizeOccupied;
    PCHAR UdfFileName = WINNT_UNIQUENESS_DB;
    PCHAR UdfPath;

    //
    // Do not change this without changing text setup as well
    // (SpPtDetermineRegionSpace()).
    //
    PCHAR SizeFile = "\\size.sif";
    PCHAR Lines[] = { "[Data]\n",
                      "Size = xxxxxxxxxxxxxx\n",
                      //
                      //    Debugging purposes
                      //
                      "TotalFileCount = xxxxxxxxxxxxxx\n",
                      "TotalOptionalFileCount = xxxxxxxxxxxxxx\n",
                      "TotalOptionalDirCount = xxxxxxxxxxxxxx\n",
                      "ClusterSize = xxxxxxxxxxxxxx\n",
                      "Size_512 = xxxxxxxxxxxxxx\n",
                      "Size_1K = xxxxxxxxxxxxxx\n",
                      "Size_2K = xxxxxxxxxxxxxx\n",
                      "Size_4K = xxxxxxxxxxxxxx\n",
                      "Size_8K = xxxxxxxxxxxxxx\n",
                      "Size_16K = xxxxxxxxxxxxxx\n",
                      "Size_32K = xxxxxxxxxxxxxx\n",
#if 0
                      "SaveTotalOptionalDirCount = xxxxxxxxxxxxxx\n",
#endif
                      NULL };

    DnClearClientArea();
    DnDisplayScreen(CopyingScreen = &DnsWaitCopying);
    DnWriteStatusText(NULL);


        
    //
    // Create the linked list of directories.
    //
    DnpCreateDirectoryList(DnfDirectories,&DirectoryList);

    //
    // Generate the full root path of the local source
    //
    LocalSourceRoot = MALLOC(sizeof(LOCAL_SOURCE_DIRECTORY) + strlen(x86DirName) + strlen(SizeFile),TRUE);
    LocalSourceRoot[0] = DngTargetDriveLetter;
    LocalSourceRoot[1] = ':';
    strcpy(LocalSourceRoot+2,LocalSourceDirName);
    DnpCreateOneDirectory(LocalSourceRoot);

    //
    // Yuck.  Create this directory here because when
    // we're running down the main copylist, we're expecting
    // no non-existent directories in the destination name.
    // There can be though.  The right fix is to fix DnCopyOneFile
    // to create directories if he finds them in the destination string
    // sent in.  This is a faster fix though.
    //
    {
    char MyLocalSourceRoot[256];
        strcpy( MyLocalSourceRoot, LocalSourceRoot );
        strcat( MyLocalSourceRoot, x86DirName );
        DnpCreateOneDirectory(MyLocalSourceRoot);
        strcat( MyLocalSourceRoot, "\\System32" );
        DnpCreateOneDirectory(MyLocalSourceRoot);
    }

    if(UniquenessDatabaseFile) {
        UdfPath = MALLOC(strlen(LocalSourceRoot) + strlen(UdfFileName) + 2, TRUE);
        strcpy(UdfPath,LocalSourceRoot);
        DnpConcatPaths(UdfPath,UdfFileName);
        DnpCopyOneFile(CPY_PRESERVE_ATTRIBS,UniquenessDatabaseFile,UdfPath);
        FREE(UdfPath);
    }
    // don't need this appendage anymore - part of changes for 2CD setup.
#if 0
    strcat(LocalSourceRoot,x86DirName);
#endif

    //
    // Determine the cluster size on the drive.
    //
    _dos_getdiskfree(toupper(DngTargetDriveLetter)-'A'+1,&DiskFree);
    ClusterSize = DiskFree.sectors_per_cluster * DiskFree.bytes_per_sector;

    //
    // Pass over the copy list and check syntax.
    // Note that the global variable TotalOptionalFileCount is already set
    // (this was done when we determined the disk space requirements), and we
    // no longer need to call DnpIterateOptionalDirs() in the validation mode
    //
    DnpIterateCopyList(CPY_VALIDATION_PASS | CPY_PRUNE_DRIVERCAB,DnfFiles,LocalSourceRoot,0);

    //
    //  TotalFileCount must indicate the total number of files in the flat
    //  directory and optional directories.
    //
    TotalFileCount += TotalOptionalFileCount;

    //
    // Create the target directories
    //
    DnpCreateDirectories(LocalSourceRoot);

    //
    // Pass over the copy list again and actually perform the copy.
    //
    UsingGauge = TRUE;
    SizeOccupied = DnpIterateCopyList(CPY_PRESERVE_NAME | CPY_PRUNE_DRIVERCAB,DnfFiles,LocalSourceRoot,ClusterSize);
    SizeOccupied += DnpIterateOptionalDirs(0,ClusterSize,NULL,0);
    //
    // Free the copy buffer.
    //
    if(CopyBuffer) {
        FREE(CopyBuffer);
        CopyBuffer = NULL;
    }

    //
    // Free the directory node list
    //
    DnpFreeDirectoryList(&DirectoryList);

    //
    // Make an approximate calculation of the amount of disk space taken up
    // by the local source directory itself, assuming 32 bytes per dirent.
    // Also account for the small ini file that we'll put in the local source
    // directory, to tell text setup how much space the local source takes up.
    //
    //  Takes into consideration the dirent for each file in the flat directory
    //  plust the directories . and .., plus size.sif, plus $win_nt_.~ls and
    //  $win_nt$.~ls\i386
    //
    SizeOccupied += ((((TotalFileCount - TotalOptionalFileCount) + // number of files in the $win_nt$.~ls\i386 directory
                        1 + // $win_nt$.~ls
                        2 + // . and .. on $win_nt$.~ls
                        1 + // size.sif on $win_nt$.~ls
                        1 + // $win_nt$.~ls\i386
                        2   // . and .. on $win_nt$.~ls\i386
                       )*32 + (ClusterSize-1)) / ClusterSize)*ClusterSize;
    //
    //  Now take into consideration the optional directories.
    //
    if(TotalOptionalDirCount != 0) {
        unsigned  AvFilesPerOptionalDir= 0;

        //
        //  We assume a uniform distribution of optional files on optional
        //  directories
        //
        AvFilesPerOptionalDir = (TotalOptionalFileCount + (TotalOptionalDirCount - 1))/TotalOptionalDirCount;
        AvFilesPerOptionalDir  += 2; // . and .. on each optional dir
        SizeOccupied += (TotalOptionalDirCount*((AvFilesPerOptionalDir*32 + (ClusterSize-1))/ClusterSize))*ClusterSize;
        //
        //  Finally take into account each optional directory
        //
        SizeOccupied += ((TotalOptionalDirCount*32 + (ClusterSize-1))/ClusterSize)*ClusterSize;
    }

    //
    // Create a small ini file listing the size occupied by the local source.
    // Account for the ini file in the size.
    //
    strcpy(LocalSourceRoot+2,LocalSourceDirName);
    strcat(LocalSourceRoot,SizeFile);
    sprintf(Lines[1],"Size = %lu\n",SizeOccupied);
    //
    //  Debugging purposes
    //
    sprintf(Lines[2], "TotalFileCount = %u\n"         ,TotalFileCount);
    sprintf(Lines[3], "TotalOptionalFileCount = %u\n" ,TotalOptionalFileCount);
    sprintf(Lines[4], "TotalOptionalDirCount = %u\n"  ,TotalOptionalDirCount);
    sprintf(Lines[5], "ClusterSize = %u\n"  , ClusterSize);
    sprintf(Lines[6], "Size_%u = %lu\n" , SpaceRequirements[0].ClusterSize, SpaceRequirements[0].Clusters * SpaceRequirements[0].ClusterSize);
    sprintf(Lines[7], "Size_%u = %lu\n" , SpaceRequirements[1].ClusterSize, SpaceRequirements[1].Clusters * SpaceRequirements[1].ClusterSize);
    sprintf(Lines[8], "Size_%u = %lu\n" , SpaceRequirements[2].ClusterSize, SpaceRequirements[2].Clusters * SpaceRequirements[2].ClusterSize);
    sprintf(Lines[9], "Size_%u = %lu\n" , SpaceRequirements[3].ClusterSize, SpaceRequirements[3].Clusters * SpaceRequirements[3].ClusterSize);
    sprintf(Lines[10],"Size_%u = %lu\n" , SpaceRequirements[4].ClusterSize, SpaceRequirements[4].Clusters * SpaceRequirements[4].ClusterSize);
    sprintf(Lines[11],"Size_%u = %lu\n" , SpaceRequirements[5].ClusterSize, SpaceRequirements[5].Clusters * SpaceRequirements[5].ClusterSize);
    sprintf(Lines[12],"Size_%u = %lu\n" , SpaceRequirements[6].ClusterSize, SpaceRequirements[6].Clusters * SpaceRequirements[6].ClusterSize);
#if 0
    sprintf(Lines[13],"SaveTotalOptionalDirCount = %u\n"  ,SaveTotalOptionalDirCount);
#endif
    DnWriteSmallIniFile(LocalSourceRoot,Lines,NULL);

    FREE(LocalSourceRoot);
}


VOID
DnCopyFloppyFiles(
    IN PCHAR SectionName,
    IN PCHAR TargetRoot
    )

/*++

Routine Description:

    Top-level entry point to copy files to the setup floppy or hard-disk
    boot root when this routine is called.  Copies all files listed in the
    [FloppyFiles.x] sections of the inf file from the source to TargetRoot.

Arguments:

    SectionName - supplies the name of the section in the inf file
        that contains the list of files to be copied.

    TargetRoot - supplies the target path without trailing \.

Return Value:

    None.

--*/

{
    DnClearClientArea();
    DnDisplayScreen(CopyingScreen = (DngFloppyless ? &DnsWaitCopying : &DnsWaitCopyFlop));
    DnWriteStatusText(NULL);

    //
    // Create the linked list of directories.
    //
    DnpCreateDirectoryList(DnfDirectories,&DirectoryList);

    //
    // Copy the files.
    //
    DnpIterateCopyList(
        CPY_VALIDATION_PASS | CPY_USE_DEST_ROOT,
        SectionName,
        TargetRoot,
        0
        );

    DnpIterateCopyList(
        CPY_USE_DEST_ROOT | CPY_PRESERVE_NAME | (DngFloppyVerify ? CPY_VERIFY : 0),
        SectionName,
        TargetRoot,
        0
        );

    //
    // Free the copy buffer.
    //
    if(CopyBuffer) {
        FREE(CopyBuffer);
        CopyBuffer = NULL;
    }

    //
    // Free the directory node list
    //

    DnpFreeDirectoryList(&DirectoryList);
}


VOID
DnpCreateDirectoryList(
    IN  PCHAR            SectionName,
    OUT PDIRECTORY_NODE *ListHead
    )

/*++

Routine Description:

    Examine a section in the INF file, whose lines are to be in the form
    key = directory and create a linked list describing the key/directory
    pairs found therein.

    If the directory field is empty, it is assumed to be the root.

Arguments:

    SectionName - supplies name of section

    ListHead - receives pointer to head of linked list

Return Value:

    None.  Does not return if syntax error in the inf file section.

--*/

{
    unsigned LineIndex,len;
    PDIRECTORY_NODE DirNode,PreviousNode;
    PCHAR Key;
    PCHAR Dir;
    PCHAR Dir1;

    LineIndex = 0;
    PreviousNode = NULL;
    while(Key = DnGetKeyName(DngInfHandle,SectionName,LineIndex)) {

        Dir1 = DnGetSectionKeyIndex(DngInfHandle,SectionName,Key,0);

        if(Dir1 == NULL) {
            Dir = "";           // use the root if not specified
        }
        else {
            Dir = Dir1;
        }

        // 2CD setup changes - We can't do this relative roots anymore.
        // All of the directories have to be absolute to the LocalSource root.
        // We probably need to enforce that there is a '\' in the front.
#if 0
        //
        // Skip leading backslashes
        //

        while(*Dir == '\\') {
            Dir++;
        }
#endif

        //
        // Clip off trailing backslashes if present
        //

        while((len = strlen(Dir)) && (Dir[len-1] == '\\')) {
            Dir[len-1] = '\0';
        }

        DirNode = MALLOC(sizeof(DIRECTORY_NODE),TRUE);

        DirNode->Next = NULL;
        DirNode->Directory = DnDupString(Dir);
        DirNode->Symbol = DnDupString(Key);

        if(PreviousNode) {
            PreviousNode->Next = DirNode;
        } else {
            *ListHead = DirNode;
        }
        PreviousNode = DirNode;

        LineIndex++;

        FREE (Dir1);
        FREE (Key);
    }
}


VOID
DnpCreateDirectories(
    IN PCHAR TargetRootDir
    )

/*++

Routine Description:

    Create the local source directory, and run down the DirectoryList and
    create directories listed therein relative to the given root dir.

Arguments:

    TargetRootDir - supplies the name of root directory of the target

Return Value:

    None.

--*/

{
    PDIRECTORY_NODE DirNode;
    CHAR TargetDirTemp[128];

    DnpCreateOneDirectory(TargetRootDir);

    for(DirNode = DirectoryList; DirNode; DirNode = DirNode->Next) {

        if ( DngCopyOnlyD1TaggedFiles )
        {
            // symbol will always exist, so we are safe in using it in 
            // the comparision below.
            // We skip this file if the tag is not d1
            if ( strcmpi(DirNode->Symbol, "d1") )
                continue;
        }

        //
        // No need to create the root
        //
        if(*DirNode->Directory) {

            // 2 CD Setup changes - if Directory is of the a\b\c\d then we better make sure 
            // we can create the entire directory structure
            // We run into this when \cmpnents\tabletpc\i386 needs to be created.
            CHAR *pCurDir = DirNode->Directory;
            CHAR *pTargetDir;

            strcpy(TargetDirTemp,TargetRootDir);
            strcat(TargetDirTemp,"\\");
            pCurDir++; // the first character is always bound to be '\'
            pTargetDir = TargetDirTemp + strlen(TargetDirTemp);
#if 0
            strcat(TargetDirTemp,DirNode->Directory);
#else
            for ( ; *pCurDir; pTargetDir++, pCurDir++ )
            {
                if ( *pCurDir == '\\' )
                {
                    *pTargetDir = 0;
                    DnpCreateOneDirectory(TargetDirTemp);
                }
                *pTargetDir = *pCurDir;
            }
            *pTargetDir = 0;
#endif
            DnpCreateOneDirectory(TargetDirTemp);
        }
    }
}


VOID
DnpCreateOneDirectory(
    IN PCHAR Directory
    )

/*++

Routine Description:

    Create a single directory if it does not already exist.

Arguments:

    Directory - directory to create

Return Value:

    None.  Does not return if directory cannot be created.

--*/

{
    struct find_t FindBuf;
    int Status;

    //
    // First, see if there's a file out there that matches the name.
    //

    Status = _dos_findfirst( Directory,
                             _A_RDONLY | _A_HIDDEN | _A_SYSTEM | _A_SUBDIR,
                             &FindBuf
                           );

    if(Status) {

        //
        // file could not be matched so we should be able to create the dir.
        //

        if(mkdir(Directory)) {
            DnFatalError(&DnsCantCreateDir,Directory);
        }

    } else {

        //
        // file matched.  If it's a dir, we're OK.  Otherwise we can't
        // create the dir, a fatal error.
        //

        if(FindBuf.attrib & _A_SUBDIR) {
            return;
        } else {
            DnFatalError(&DnsCantCreateDir,Directory);
        }
    }
}


ULONG
DnpIterateCopyList(
    IN unsigned Flags,
    IN PCHAR    SectionName,
    IN PCHAR    DestinationRoot,
    IN unsigned ClusterSize OPTIONAL
    )

/*++

Routine Description:

    Run through the NtTreeFiles and BootFiles sections, validating their
    syntactic correctness and copying files if directed to do so.

Arguments:

    Flags - Supplies flags controlling various behavior:

        CPY_VALIDATION_PASS: if set, do not actually copy the files.
            If not set, copy the files as they are iterated.

        CPY_USE_DEST_ROOT - if set, ignore the directory symbol and copy
            each file to the DestinationRoot directory. If not set,
            append the directory implied by the directory symbol for a file
            to the DestinationRoot.

        CPY_VERIFY - if set and this is not a validation pass, files will be
            verified after they have been copied by rereading them from the
            copy source and comparing with the local version that was just
            copied.

    SectionName - name of section coptaining the list of files

    DestinationRoot- supplies the root of the destination, to which all
        directories are relative.

    ClusterSize - if specified, supplies the number of bytes in a cluster
        on the destination. If ValidationPass is FALSE, files will be sized as
        they are copied, and the return value of this function will be
        the total size occupied on the target by the files that are copied
        there.

Return Value:

    If ValidationPass is TRUE, then the return value is the number of files
    that will be copied.

    If ClusterSize was specfied and ValidationPass is FALSE,
    the return value is the total space occupied on the target drive
    by the files that were copied. Otherwise the return value is undefined.

    Does not return if a syntax error in encountered in the INF file.

--*/

{
    if(Flags & CPY_VALIDATION_PASS) {
        TotalFileCount = 0;
    } else {
        if(UsingGauge) {
            DnInitGauge(TotalFileCount,CopyingScreen);
        }
    }

    return(DnpIterateCopyListSection(Flags,SectionName,DestinationRoot,ClusterSize));
}


ULONG
DnpIterateOptionalDirs(
    IN unsigned Flags,
    IN unsigned ClusterSize OPTIONAL,
    IN PSPACE_REQUIREMENT SpaceReqArray OPTIONAL,
    IN unsigned ArraySize OPTIONAL
    )
/*++

Routine Description:

    Runs down all optional dir components and add them to the copy
    list

Arguments:

    Flags - supplies flags controlling various behavior:

        CPY_VALIDATION_PASS - If set, then do not actually copy the files.
            If not set, copy the files as they are iterated.

        CPY_VERIFY: if set and this is not a validation pass, files will be
            verified after they have been copied by rereading them from the
            copy source and comparing with the local version that was just
            copied.

    ClusterSize - if specified, supplies the number of bytes in a cluster
        on the destination. If ValidationPass is FALSE, files will be sized as
        they are copied, and the return value of this function will be
        the total size occupied on the target by the files that are copied
        there.

Return Value:

    If CPY_VALIDATION_PASS is set, then the return value is the number of files
    that will be copied.

    If ClusterSize was specfied and CPY_VALIDATION_PASS is not set,
    the return value is the total space occupied on the target drive
    by the files that were copied. Otherwise the return value is undefined.

--*/

{
    PCHAR       Ptr;
    PCHAR       SourceDir;
    PCHAR       DestDir;
    ULONG       rc;
    unsigned    u;
    BOOLEAN     OemOptDirCreated = FALSE;
    struct      find_t  FindData;
    BOOLEAN     OemSysDirExists;

#if 0
    //
    //  Debugging purposes
    //
    SaveTotalOptionalDirCount = TotalOptionalDirCount;
#endif
    TotalOptionalDirCount = 0;


    for (rc=0,u=0; u < OptionalDirCount; u++ ) {

        //
        // For each directory build in the list build up the
        // full path name to both the source and destination
        // directory, then start our recursive copy engine
        //

        //
        // Source Dir Allocation
        //  We want the base dir + '\'
        //  + oem optional dir root + '\'
        //  + optional dir name + '\'
        //  + 8.3 name + '\0'
        //
        if( (OptionalDirFlags[u] & OPTDIR_OEMSYS) &&
            (UserSpecifiedOEMShare              ) ) {
            SourceDir = MALLOC( strlen(UserSpecifiedOEMShare) +
                                strlen(OptionalDirs[u]) + 16, TRUE );
            strcpy(SourceDir,UserSpecifiedOEMShare);
            if( SourceDir[strlen(SourceDir)-1] != '\\' ) {
                strcat(SourceDir,"\\");
            }
        } else {
            SourceDir = MALLOC( strlen(DngSourceRootPath) +
                                strlen(OptionalDirs[u]) + 16, TRUE );
            strcpy(SourceDir,DngSourceRootPath);
            if ((OptionalDirFlags[u] & OPTDIR_PLATFORM_INDEP) == 0) {
                strcat(SourceDir,"\\");
            } else {
                PCHAR LastBackslash = strchr(SourceDir, '\\');
                if (LastBackslash != NULL) {
                    *(LastBackslash + 1) = 0;
                }
            }
        }

#if 0
// No longer supported (matth)
        if (OptionalDirFlags[u] & OPTDIR_OEMOPT) {
            strcat(SourceDir,OemOptionalDirectory);
            strcat(SourceDir,"\\");
        }
#endif
        strcat(SourceDir,OptionalDirs[u]);

        if (OptionalDirFlags[u] & OPTDIR_OEMSYS) {
            //
            //  Remember whether or not $OEM$ exists on the source
            //
            if (_dos_findfirst(SourceDir,_A_HIDDEN|_A_SYSTEM|_A_SUBDIR, &FindData) ) {
                OemSysDirExists = FALSE;
            } else {
                OemSysDirExists = TRUE;
            }
        }

        strcat(SourceDir,"\\");
        //
        // Dest Dir Allocation
        // This depends if the 'SourceOnly' flag is set with the directory
        // If it is, then we want to copy it $win_nt$.~ls\i386\<dir> otherwise
        // we want to stick into $win_nt$.~ls\<dir>
        //
        if ((OptionalDirFlags[u] & OPTDIR_TEMPONLY) && !(OptionalDirFlags[u] & OPTDIR_PLATFORM_INDEP)) {

            //
            // Dest Dir is '<x>:' + LocalSourceDirName + x86dir + '\' +
            // optional dir name + '\' + 8.3 name + '\0'
            //

            DestDir = MALLOC(strlen(LocalSourceDirName) +
                strlen(x86DirName) +strlen(OptionalDirs[u]) + 17, TRUE);
            DestDir[0] = DngTargetDriveLetter;
            DestDir[1] = ':';
            strcpy(DestDir+2,LocalSourceDirName);
            strcat(DestDir,x86DirName);

        } else if (OptionalDirFlags[u] & OPTDIR_OEMOPT) {

            //
            // Dest Dir is '<x>:' + LocalSourceDirName + '\' +
            // $OEMOPT$ + '\' +
            // optional dir name + '\' + 8.3 name + '\0'
            //

            DestDir = MALLOC(strlen(LocalSourceDirName) +
                strlen(OemOptionalDirectory) +
                strlen(OptionalDirs[u]) + 18, TRUE);
            DestDir[0] = DngTargetDriveLetter;
            DestDir[1] = ':';
            strcpy(DestDir+2,LocalSourceDirName);
            strcat(DestDir,"\\");
            strcat(DestDir,OemOptionalDirectory);


            if (!(Flags & CPY_VALIDATION_PASS) && !OemOptDirCreated) {
                DnpCreateOneDirectory(DestDir);
                OemOptDirCreated = TRUE;
                TotalOptionalDirCount++;

            }

        } else if (OptionalDirFlags[u] & OPTDIR_OEMSYS) {

            //
            // Dest Dir is '<x>:' + '\' + '$' + '\' + 8.3 name + '\0'
            //
            // Note that on winnt case the directory $OEM$ goes to
            // <drive letter>\$ directory. This is to avoid hitting the
            // DOS limit of 64 characters on a path, that is more likely to
            // happen if we put $OEM$ under \$win_nt$.~ls
            //

            DestDir = MALLOC(strlen( WINNT_OEM_DEST_DIR ) + 17, TRUE);
            DestDir[0] = DngTargetDriveLetter;
            DestDir[1] = ':';
            DestDir[2] = '\0';

        } else {

            //
            // Dest Dir is '<x>:' + LocalSourceDirName + '\' +
            // optional dir name + '\' + 8.3 name + '\0'
            //

            DestDir = MALLOC(strlen(LocalSourceDirName) +
                strlen(OptionalDirs[u]) + 17, TRUE);
            DestDir[0] = DngTargetDriveLetter;
            DestDir[1] = ':';
            strcpy(DestDir+2,LocalSourceDirName);
        }

        //
        // We need a trailing backslash at this point
        //
        strcat(DestDir,"\\");

        //
        // Keep a pointer to the place we the optional dir part of
        // the string begins
        //
        Ptr = DestDir + strlen(DestDir);

        //
        // Add the optional dir name
        //
        if (OptionalDirFlags[u] & OPTDIR_OEMSYS) {
            strcat(DestDir,WINNT_OEM_DEST_DIR);
        } else {        
            strcat(DestDir,OptionalDirs[u]);
        }

        if (!(Flags & CPY_VALIDATION_PASS)) {

            //
            // Create the Directory now
            //

            while (*Ptr != '\0') {

                //
                // If the current pointer is a backslash then we need to
                // create this subcomponent of the optional dir
                //
                if (*Ptr == '\\') {

                    //
                    // Replace the char with a terminator for now
                    //
                    *Ptr = '\0';

                    //
                    // Create the subdirectory
                    //
                    DnpCreateOneDirectory(DestDir);
                    TotalOptionalDirCount++;

                    //
                    // Restore the seperator
                    //
                    *Ptr = '\\';
                }

                Ptr++;

            }

            //
            // Create the last component in the optional dir path
            //
            DnpCreateOneDirectory(DestDir);
            TotalOptionalDirCount++;

        } else {
            TotalOptionalDirCount++;
        }

        //
        // Concate the trailing backslash now
        //
        strcat(DestDir,"\\");

        //
        //  If the the optional directory is $OEM$ and it doesn't exist on
        //  source, then assume that it exists, but it is empty
        //
        if ( !(OptionalDirFlags[u] & OPTDIR_OEMSYS) ||
             OemSysDirExists ) {
            //
            // Call our recursive tree copy function
            //
            rc += DnpDoIterateOptionalDir(
                    Flags,
                    SourceDir,
                    DestDir,
                    ClusterSize,
                    SpaceReqArray,
                    ArraySize
                    );
        }

        //
        // Free the allocated buffers
        //

        FREE(DestDir);
        FREE(SourceDir);

    } // for

    //
    // return our result code if we aren't a validation pass, otherwise
    // return the total number of files to copy
    //

    return ((Flags & CPY_VALIDATION_PASS) ? (ULONG) TotalOptionalFileCount : rc);
}

ULONG
DnpDoIterateOptionalDir(
    IN unsigned Flags,
    IN PCHAR    SourceDir,
    IN PCHAR    DestDir,
    IN unsigned ClusterSize OPTIONAL,
    IN PSPACE_REQUIREMENT SpaceReqArray OPTIONAL,
    IN unsigned ArraySize OPTIONAL
    )

{
    ULONG       TotalSize = 0;
    ULONG       BytesWritten = 0;
    ULONG       rc = 0;
    PCHAR       SourceEnd;
    PCHAR       DestEnd;
    struct      find_t  FindData;
    unsigned    i;

    //
    // Remember where the last '\' in each of the two paths is.
    // Note: that we assume that all of the dir paths have a
    // terminating '\' when it is passed to us.
    //
    SourceEnd = SourceDir + strlen(SourceDir);
    DestEnd = DestDir + strlen(DestDir);


    //
    // Set the WildCard search string
    //
    strcpy(SourceEnd,"*.*");

    //
    // Do the initial search
    //
    if(_dos_findfirst(SourceDir,_A_HIDDEN|_A_SYSTEM|_A_SUBDIR, &FindData) ) {

        //
        // We couldn't find anything -- return 0
        //
        return (0);
    }

    do {

        //
        // Form the source and dest dirs strings
        //
        strcpy(SourceEnd,FindData.name);
        strcpy(DestEnd,FindData.name);

        
        //
        // Check to see if the entry is a subdir. Recurse into it
        // unless it is '.' or '..'
        //
        if (FindData.attrib & _A_SUBDIR) {

            PCHAR   NewSource;
            PCHAR   NewDest;

            //
            // Check to see if the name is '.' or '..'
            //
            if (!strcmp(FindData.name,".") || !strcmp(FindData.name,"..")) {

                //
                // Ignore these two cases
                //

                continue;
            }

            //
            // Create the new buffers for the source and dest dir names
            //

            NewSource = MALLOC( strlen(SourceDir) + 14, TRUE);
            strcpy(NewSource,SourceDir);
            if (NewSource[strlen(NewSource)-1] != '\\') {
                strcat(NewSource,"\\");
            }

            NewDest = MALLOC( strlen(DestDir) + 14, TRUE);
            strcpy(NewDest,DestDir);
            
            if(!(Flags & CPY_VALIDATION_PASS)) {
                //
                // Create the directory
                //

                DnpCreateOneDirectory(NewDest);
            }
            TotalOptionalDirCount++;

            //
            // Trailing BackSlash
            //
            if (NewDest[strlen(NewDest)-1] != '\\') {
                strcat(NewDest,"\\");
            }

            //
            // Recursive call to ourselves
            //

            BytesWritten = DnpDoIterateOptionalDir(
                                Flags,
                                NewSource,
                                NewDest,
                                ClusterSize,
                                SpaceReqArray,
                                ArraySize
                                );

            if(!(Flags & CPY_VALIDATION_PASS)) {

                //
                // We don't care about the other case since the
                // function is recursive and modifies a global
                // value
                //
                rc += BytesWritten;

            }

            //
            // Free all of the allocated buffers
            //

            FREE(NewSource);
            FREE(NewDest);

            //
            // Continue Processing
            //

            continue;

        } // if ...

        //
        // Mainline case
        //
        if(Flags & CPY_VALIDATION_PASS) {
            TotalOptionalFileCount++;
            if( SpaceReqArray != NULL ) {
                for( i = 0; i < ArraySize; i++ ) {
                    SpaceReqArray[i].Clusters += ( FindData.size + ( SpaceReqArray[i].ClusterSize - 1 ) ) / SpaceReqArray[i].ClusterSize;
                }
            }
        } else {

            BytesWritten = DnpCopyOneFile(
                                Flags | CPY_PRESERVE_ATTRIBS,
                                SourceDir,
                                DestDir
                                );

            //
            // Figure out how much space was taken up by the file on the target.
            //
            if(ClusterSize) {

                TotalSize += BytesWritten;

                if(BytesWritten % ClusterSize) {
                    TotalSize += (ULONG)ClusterSize - (BytesWritten % ClusterSize);
                }

            }

            if(UsingGauge) {
                DnTickGauge();
            }

        }

    } while ( !_dos_findnext(&FindData) );

    DnSetCopyStatusText(DntEmptyString,NULL);

    rc = ((Flags & CPY_VALIDATION_PASS) ? (ULONG)TotalOptionalFileCount : (rc + TotalSize));

    return (rc);
}

ULONG
DnpIterateCopyListSection(
    IN unsigned Flags,
    IN PCHAR    SectionName,
    IN PCHAR    DestinationRoot,
    IN unsigned ClusterSize OPTIONAL
    )

/*++

Routine Description:

    Run down a particular section in the INF file making sure it is
    syntactically correct and copying files if directed to do so.

Arguments:

    Flags - Supplies flags controlling various behavior:

        CPY_VALIDATION_PASS: if set, do not actually copy the files.
            If not set, copy the files as they are iterated.

        CPY_USE_DEST_ROOT - if set, ignore the directory symbol and copy
            each file to the DestinationRoot directory. If not set,
            append the directory implied by the directory symbol for a file
            to the DestinationRoot.

        CPY_VERIFY - if set and this is not a validation pass, files will be
            verified after they have been copied by rereading them from the
            copy source and comparing with the local version that was just
            copied.

    SectionName - supplies name of section in inf file to run down.

    DestinationRoot- supplies the root of the destination, to which all
        directories are relative.

    ClusterSize - if specified, supplies the number of bytes in a cluster
        on the destination. If ValidationPass is FALSE, files will be sized as
        they are copied, and the return value of this function will be
        the total size occupied on the target by the files that are copied
        there.

Return Value:

    If ValidationPass is TRUE, then the return value is the number of files
    that will be copied.

    If ClusterSize was specfied and ValidationPass is FALSE,
    the return value is the total space occupied on the target drive
    by the files that were copied. Otherwise the return value is undefined.

    Does not return if a syntax error in encountered in the INF file.

--*/

{
    unsigned LineIndex;
    PCHAR DirSym,FileName,RenameName;
    CHAR FullSourceName[128],FullDestName[128];
    ULONG TotalSize;
    ULONG BytesWritten;
    char *p;
    char *q;    


    
    TotalSize = 0;
    LineIndex = 0;
    while(DirSym = DnGetSectionLineIndex(DngInfHandle,SectionName,LineIndex,0)) {

        if ( DngCopyOnlyD1TaggedFiles ) 
        {
            // We skip this line if the directory tag is not 'd1'
            if ( strcmpi(DirSym, "d1") )
                goto loop_continue;
        }

        FileName = DnGetSectionLineIndex(DngInfHandle,SectionName,LineIndex,1);

        RenameName = DnGetSectionLineIndex( DngInfHandle,SectionName,LineIndex,2);

        //
        // Make sure the filename was specified.
        //
        if(!FileName) {
            DnpInfSyntaxError(SectionName);
        }

        //_LOG(("File %s - Flags %x\n",FileName, Flags));

        if( Flags & CPY_PRUNE_DRIVERCAB ){

            if( InDriverCacheInf( DngDrvindexInfHandle, FileName )) {

                //_LOG(("%s present in driver cab\n",FileName));

                if( !DnGetSectionEntryExists( DngInfHandle, WINNT_D_FORCECOPYDRIVERCABFILES, FileName)){

                    //_LOG(("%s present in driver cab - skipping\n",FileName));
                    goto next_iteration;

                }


            }

        }

        //
        // If no rename name was specified, use the file name.
        //
        if (!RenameName) {
            RenameName = FileName;
        }
        if (*RenameName == 0) {
            FREE (RenameName);
            RenameName = FileName;
        }

        //
        // Get destination path
        //
        if(Flags & CPY_USE_DEST_ROOT) {
            strcpy(FullDestName,DestinationRoot);
        } else {
            if(!DnpLookUpDirectory(DestinationRoot,DirectoryList,DirSym,FullDestName)) {
                DnpInfSyntaxError(SectionName);
            }
        }

        p = strstr( FullDestName, x86DirName );

        if (p) {
            p +=1;
            // 2 CD Setup changes - instead of getting rid of the second i386 we get rid of the FIRST i386
#if 0
            p = strstr(p, x86DirName );
            if (p) {
                *p = (char)NULL;
            }
#else
            if ( strstr(p, x86DirName) )
            {
                for ( q = p + strlen(x86DirName); *q ; q++, p++ )
                {
                    *p = *q;
                }
                *p = (char)NULL;
            }
#endif
        }

        DnpConcatPaths(FullDestName,RenameName);
        
        //
        // Get source path
        //
        if(!DnpLookUpDirectory(DngSourceRootPath,DirectoryList,DirSym,FullSourceName)) {
            DnpInfSyntaxError(SectionName);
        }

        p = strstr( FullSourceName, x86DirName );
        if (p) {
            p +=1;
            // 2 CD Setup changes - instead of getting rid of the second i386 we get rid of the FIRST i386
#if 0
            p = strstr(p, x86DirName );
            if (p) {
                *p = (char)NULL;
            }
#else
            if ( strstr(p, x86DirName) )
            {
                for ( q = p + strlen(x86DirName) ; *q ; q++, p++ )
                {
                    *p = *q;
                }
                *p = (char)NULL;
            }
#endif
        }

        DnpConcatPaths(FullSourceName,FileName);
        
        if(Flags & CPY_VALIDATION_PASS) {
            TotalFileCount++;
        } else {
            BytesWritten = DnpCopyOneFile(
                                Flags & ~CPY_PRESERVE_ATTRIBS,
                                FullSourceName,
                                FullDestName
                                );

            //
            // Figure out how much space was taken up by the file on the target.
            //
            if(ClusterSize) {

                TotalSize += BytesWritten;

                if(BytesWritten % ClusterSize) {
                    TotalSize += (ULONG)ClusterSize - (BytesWritten % ClusterSize);
                }
            }

            if(UsingGauge) {
                DnTickGauge();
            }
        }

next_iteration:


        if (RenameName != FileName) {
            FREE (RenameName);
        }
        if (FileName) {
            FREE (FileName);
        }

loop_continue:
        LineIndex++;
        FREE (DirSym);
    }
    DnSetCopyStatusText(DntEmptyString,NULL);

    return((Flags & CPY_VALIDATION_PASS) ? (ULONG)TotalFileCount : TotalSize);
}


BOOLEAN
DnpLookUpDirectory(
    IN  PCHAR RootDirectory,
    IN  PDIRECTORY_NODE DirList,
    IN  PCHAR Symbol,
    OUT PCHAR PathOut
    )

/*++

Routine Description:

    Match a symbol to an actual directory.  Scans a give list of symbol/
    directory pairs and if a match is found constructs a fully qualified
    pathname that never ends in '\'.

Arguments:

    RootDirectory - supplies the beginning of the path spec, to be prepended
        to the directory that matches the given Symbol.

    DirList - supplies pointer to head of linked list of dir/symbol pairs.

    Symbol - Symbol to match.

    PathOut - supplies a pointer to a buffer that receives the pathname.

Return Value:

    Boolean value indicating whether a match was found.

--*/

{
    while(DirList) {

        if(!stricmp(DirList->Symbol,Symbol)) {

            strcpy(PathOut,RootDirectory);
            if(*DirList->Directory) {
                // 2 CD setup changes - all directories now start with \ anyway,
                // so we don't need to append this.

                // make sure the current path doesn't end in a '\'
                if ( PathOut[strlen(PathOut)-1] == '\\')
                    PathOut[strlen(PathOut)-1] = '0';

                strcat(PathOut,DirList->Directory);
            }

            return(TRUE);
        }

        DirList = DirList->Next;
    }
    return(FALSE);
}


VOID
DnpInfSyntaxError(
    IN PCHAR Section
    )

/*++

Routine Description:

    Print an error message about a syntax error in the given section and
    terminate.

Arguments:

    SectionName - supplies name of section containing bad syntax.

Return Value:

    None.  Does not return.

--*/

{
    CHAR MsgLine1[128];

    snprintf(MsgLine1,sizeof(MsgLine1),DnsBadInfSection.Strings[BAD_SECTION_LINE],Section);

    DnsBadInfSection.Strings[BAD_SECTION_LINE] = MsgLine1;

    DnFatalError(&DnsBadInfSection);
}


ULONG
DnpCopyOneFile(
    IN unsigned Flags,
    IN PCHAR    SourceName,
    IN PCHAR    DestName
    )

/*++

Routine Description:

    Copies a single file.

Arguments:

    Flags - supplies flags that control various behavior:

        CPY_VERIFY: verify the file will be after it has been copied.

        CPY_PRESERVE_ATTRIBS: preserve the DOS file attributes of
            the source file.

    SourceName - supplies fully qualified name of source file

    DestName - supplies fully qualified name of destination file

Return Value:

    None.  May not return if an error occurs during the copy.

--*/

{
    int SrcHandle,DstHandle;
    BOOLEAN Err,Retry;
    PCHAR FilenamePart;
    BOOLEAN Verified;
    ULONG BytesWritten = 0;
    unsigned attribs;
    BOOLEAN UsedCompName;
    CHAR ActualDestName[128];   

    FilenamePart = strrchr(SourceName,'\\') + 1;

    do {
        DnSetCopyStatusText(DntCopying,FilenamePart);

        Err = TRUE;

        //_LOG(("Copy %s --> %s: ",SourceName,DestName));

        if(DnpOpenSourceFile(SourceName,&SrcHandle,&attribs,&UsedCompName)) {

            if((Flags & CPY_PRESERVE_NAME) && UsedCompName) {
                DnpGenerateCompressedName(DestName,ActualDestName);
            } else {
                strcpy(ActualDestName,DestName);
            }

            _dos_setfileattr(ActualDestName,_A_NORMAL);
            if(!_dos_creat(ActualDestName,_A_NORMAL,&DstHandle)) {
                if(DnpDoCopyOneFile(Flags,SrcHandle,DstHandle,FilenamePart,&Verified,&BytesWritten)) {
                    //_LOG(("success\n"));
                    Err = FALSE;
                }
                _dos_close(DstHandle);
            } else {
                //_LOG(("unable to create target\n"));
            }
            _dos_close(SrcHandle);
        } else {
            //_LOG(("unable to open source file\n"));
        }

        if((Flags & CPY_PRESERVE_ATTRIBS) && (attribs & (_A_HIDDEN | _A_RDONLY | _A_SYSTEM)) && !Err) {
            _dos_setfileattr(ActualDestName,attribs);
        }
        
        if(Err) {
            Retry = DnCopyError(FilenamePart,&DnsCopyError,COPYERR_LINE);            
            if(UsingGauge) {
                DnDrawGauge(CopyingScreen);
            } else {
                DnClearClientArea();
                DnDisplayScreen(CopyingScreen);
            }
            DnWriteStatusText(NULL);
        } else if((Flags & CPY_VERIFY) && !Verified) {
            Retry = DnCopyError(FilenamePart,&DnsVerifyError,VERIFYERR_LINE);            
            if(UsingGauge) {
                DnDrawGauge(CopyingScreen);
            } else {
                DnClearClientArea();
                DnDisplayScreen(CopyingScreen);
            }
            DnWriteStatusText(NULL);
            Err = TRUE;
        }
    } while(Err && Retry);

    return(BytesWritten);
}


BOOLEAN
DnpDoCopyOneFile(
    IN  unsigned Flags,
    IN  int      SrcHandle,
    IN  int      DstHandle,
    IN  PCHAR    Filename,
    OUT PBOOLEAN Verified,
    OUT PULONG   BytesWritten
    )

/*++

Routine Description:

    Perform the actual copy of a single file.

Arguments:

    Flags - supplies various flags controlling behavior of this routine:

        CPY_VERIFY: if set, the copied file will be verified against the
            original copy.

    SrcHandle - supplies the DOS file handle for the open source file.

    DstHandle - supplies the DOS file handle for the open target file.

    Filename  - supplies the base filename of the file being copied.
        This is used in the status bar at the bottom of the screen.

    Verified  - if CPY_VERIFY is set and the copy succeeds, this value will
        receive a flag indicating whether the file verification
        determined that the file was copied correctly.

    BytesWritten - Receives the number of bytes written to
        the target file (ie, the file size).

Return Value:

    TRUE if the copy succeeded, FALSE if it failed for any reason.
    If TRUE and CPY_VERIFY is set, the caller should also check the value
    returned in the Verified variable.

--*/

{
    unsigned BytesRead,bytesWritten;
    BOOLEAN TimestampValid;
    unsigned Date,Time;
    PUCHAR VerifyBuffer;

    //
    // Assume verification will succeed.  If the file is not copied correctly,
    // this value will become irrelevent.
    //
    if(Verified) {
        *Verified = TRUE;
    }

    //
    // If the copy buffer is not already allocated, attempt to allocate it.
    // The first two attempts can fail because we have a fallback size to try.
    // If the third attempt fails, bail.
    //
    if((CopyBuffer == NULL)
    &&((CopyBuffer = MALLOC(CopyBufferSize = COPY_BUFFER_SIZE1,FALSE)) == NULL)
    &&((CopyBuffer = MALLOC(CopyBufferSize = COPY_BUFFER_SIZE2,FALSE)) == NULL)) {
        CopyBuffer = MALLOC(CopyBufferSize = COPY_BUFFER_SIZE3,TRUE);
    }

    //
    // Obtain the timestamp from the source file.
    //
    TimestampValid = (BOOLEAN)(_dos_getftime(SrcHandle,&Date,&Time) == 0);

    //
    // read and write chunks of the file.
    //

    *BytesWritten = 0L;
    do {

        if(_dos_read(SrcHandle,CopyBuffer,CopyBufferSize,&BytesRead)) {
            //_LOG(("read error\n"));
            return(FALSE);
        }

        if(BytesRead) {

            if(_dos_write(DstHandle,CopyBuffer,BytesRead,&bytesWritten)
            || (BytesRead != bytesWritten))
            {
                //_LOG(("write error\n"));
                return(FALSE);
            }

            *BytesWritten += bytesWritten;
        }
    } while(BytesRead == CopyBufferSize);

    //
    // Perserve the original timestamp.
    //
    if(TimestampValid) {
        _dos_setftime(DstHandle,Date,Time);
    }

    if(Flags & CPY_VERIFY) {

        union REGS RegsIn,RegsOut;

        DnSetCopyStatusText(DntVerifying,Filename);

        *Verified = FALSE;      // assume failure

        //
        // Rewind the files.
        //
        RegsIn.x.ax = 0x4200;       // seek to offset from start of file
        RegsIn.x.bx = SrcHandle;
        RegsIn.x.cx = 0;            // offset = 0
        RegsIn.x.dx = 0;

        intdos(&RegsIn,&RegsOut);
        if(RegsOut.x.cflag) {
            goto x1;
        }

        RegsIn.x.bx = DstHandle;
        intdos(&RegsIn,&RegsOut);
        if(RegsOut.x.cflag) {
            goto x1;
        }

        //
        // Files are rewound.  Start the verification process.
        // Use half the buffer for reading the copy and the other half
        // to read the original.
        //
        VerifyBuffer = (PUCHAR)CopyBuffer + (CopyBufferSize/2);
        do {
            if(_dos_read(SrcHandle,CopyBuffer,CopyBufferSize/2,&BytesRead)) {
                goto x1;
            }

            if(_dos_read(DstHandle,VerifyBuffer,CopyBufferSize/2,&bytesWritten)) {
                goto x1;
            }

            if(BytesRead != bytesWritten) {
                goto x1;
            }

            if(memcmp(CopyBuffer,VerifyBuffer,BytesRead)) {
                goto x1;
            }

        } while(BytesRead == CopyBufferSize/2);

        *Verified = TRUE;
    }

    x1:

    return(TRUE);
}


VOID
DnpFreeDirectoryList(
    IN OUT PDIRECTORY_NODE *List
    )

/*++

Routine Description:

    Free a linked list of directory nodes and place NULL in the
    head pointer.

Arguments:

    List - supplies pointer to list head pointer; receives NULL.

Return Value:

    None.

--*/

{
    PDIRECTORY_NODE n,p = *List;

    while(p) {
        n = p->Next;
        FREE(p->Directory);
        FREE(p->Symbol);
        FREE(p);
        p = n;
    }
    *List = NULL;
}


VOID
DnDetermineSpaceRequirements(
    PSPACE_REQUIREMENT  SpaceReqArray,
    unsigned            ArraySize
    )

/*++

Routine Description:

    Read space requirements from the inf file, and initialize SpaceReqArray.
    The 'space requirement' is the amount of free disk space for all files
    listed on dosnet.inf. The size of the files in the optional directories
    are not included in the values specified on dosnet.inf.


Arguments:

    RequiredSpace - receives the number of bytes of free space on a drive
        for it to be a valid local source.

Return Value:

    None.

--*/

{

    PCHAR    RequiredSpaceStr;
    unsigned i;

    for( i = 0; i < ArraySize; i++ ) {
        RequiredSpaceStr = DnGetSectionKeyIndex( DngInfHandle,
                                                 DnfSpaceRequirements,
                                                 SpaceReqArray[i].Key,
                                                 0
                                                 );

        if(!RequiredSpaceStr ||
           !sscanf(RequiredSpaceStr,
                  "%lu",
                  &SpaceReqArray[i].Clusters)) {
            DnpInfSyntaxError(DnfSpaceRequirements);
        }
        SpaceReqArray[i].Clusters /= SpaceReqArray[i].ClusterSize;

        if (RequiredSpaceStr) {
            FREE (RequiredSpaceStr);
        }
    }
}

VOID
DnAdjustSpaceRequirements(
    PSPACE_REQUIREMENT  SpaceReqArray,
    unsigned            ArraySize
    )

/*++

Routine Description:

    Add to the SpaceRequirements array the space occupied by the temporary
    directories

Arguments:

    SpaceReqArray - receives the array that contains the space requirements
                    information.

    ArraySize - Number of elements in the SpaceRequirements Array

Return Value:

    None.

--*/

{
    unsigned i;
    unsigned ClusterSize;
    unsigned AvFilesPerOptionalDir;

    for( i = 0; i < ArraySize; i++ ) {
        ClusterSize = SpaceReqArray[i].ClusterSize;
        //
        //  Takes into consideration the dirent for each file in the flat directory
        //  plust the directories . and .., plus size.sif, plus $win_nt_.~ls and
        //  $win_nt$.~ls\i386
        //
        SpaceReqArray[i].Clusters += (((TotalFileCount - TotalOptionalFileCount) + // number of files in the $win_nt$.~ls\i386 directory
                                        1 + // $win_nt$.~ls
                                        2 + // . and .. on $win_nt$.~ls
                                        1 + // size.sif on $win_nt$.~ls
                                        1 + // $win_nt$.~ls\i386
                                        2   // . and .. on $win_nt$.~ls\i386
                                       )*32 + (ClusterSize-1)) / ClusterSize;
        //
        //  Now take into consideration the optional directories.
        //
        if(TotalOptionalDirCount != 0) {
            //
            //  We assume a uniform distribution of optional files on optional
            //  directories
            //
            AvFilesPerOptionalDir = (TotalOptionalFileCount + (TotalOptionalDirCount - 1))/TotalOptionalDirCount;
            AvFilesPerOptionalDir  += 2; // . and .. on each optional dir
            SpaceReqArray[i].Clusters += TotalOptionalDirCount*((AvFilesPerOptionalDir*32 + (ClusterSize-1))/ClusterSize);
            //
            //  Finally take into account each optional directory
            //
            SpaceReqArray[i].Clusters += (TotalOptionalDirCount*32 + (ClusterSize-1))/ClusterSize;
        }
    }
}


VOID
DnpGenerateCompressedName(
    IN  PCHAR Filename,
    OUT PCHAR CompressedName
    )

/*++

Routine Description:

    Given a filename, generate the compressed form of the name.
    The compressed form is generated as follows:

        Look backwards for a dot.  If there is no dot, append "._" to the name.
        If there is a dot followed by 0, 1, or 2 charcaters, append "_".
        Otherwise assume there is a 3-character extension and replace the
        third character after the dot with "_".

Arguments:

    Filename - supplies filename whose compressed form is desired.

    CompressedName - supplies pointer to a 128-char buffer to
        contain the compressed form.

Return Value:

    None.

--*/

{
    PCHAR p,q;

    strcpy(CompressedName,Filename);
    p = strrchr(CompressedName,'.');
    q = strrchr(CompressedName,'\\');
    if(q < p) {

        //
        // If there are 0, 1, or 2 characters after the dot, just append
        // the underscore.  p points to the dot so include that in the length.
        //
        if(strlen(p) < 4) {
            strcat(CompressedName,"_");
        } else {

            //
            // Assume there are 3 characters in the extension.  So replace
            // the final one with an underscore.
            //

            p[3] = '_';
        }

    } else {

        //
        // No dot, just add ._.
        //

        strcat(CompressedName,"._");
    }
}


BOOLEAN
DnpOpenSourceFile(
    IN  PCHAR     Filename,
    OUT int      *Handle,
    OUT unsigned *Attribs,
    OUT BOOLEAN  *UsedCompressedName
    )

/*++

Routine Description:

    Open a file by name or by compressed name.  If the previous call to
    this function found the compressed name, then try to open the compressed
    name first.  Otherwise try to open the uncompressed name first.

Arguments:

    Filename - supplies full path of file to open. This should be the
        uncompressed form of the filename.

    Handle - If successful, receives the id for the opened file.

    Attribs - if successful receives dos file attributes.

    UsedCompressedName - receives a flag indicating whether we found
        the compressed form of the filename (TRUE) or not (FALSE).

Return Value:

    TRUE if the file was opened successfully.
    FALSE if not.

--*/

{
    static BOOLEAN TryCompressedFirst = FALSE;
    CHAR CompressedName[128];
    PCHAR names[2];
    int OrdCompressed,OrdUncompressed;
    int i;
    BOOLEAN rc;

    //
    // Generate compressed name.
    //
    DnpGenerateCompressedName(Filename,CompressedName);

    //
    // Figure out which name to try to use first.  If the last successful
    // call to this routine opened the file using the compressed name, then
    // try to open the compressed name first.  Otherwise try to open the
    // uncompressed name first.
    //
    if(TryCompressedFirst) {
        OrdCompressed = 0;
        OrdUncompressed = 1;
    } else {
        OrdCompressed = 1;
        OrdUncompressed = 0;
    }

    names[OrdUncompressed] = Filename;
    names[OrdCompressed] = CompressedName;

    for(i=0, rc=FALSE; (i<2) && !rc; i++) {

        if(!_dos_open(names[i],O_RDONLY|SH_DENYWR,Handle)) {
            _dos_getfileattr(names[i],Attribs);
            TryCompressedFirst = (BOOLEAN)(i == OrdCompressed);
            *UsedCompressedName = TryCompressedFirst;
            rc = TRUE;
        }
    }

    return(rc);
}

BOOLEAN
InDriverCacheInf(
    IN      PVOID InfHandle,
    IN      PCHAR FileName
    )
{

    PCHAR SectionName;
    unsigned int i;
    BOOLEAN ret = FALSE;

    if( !InfHandle )
        return FALSE;

    i = 0;


    do{
    
        SectionName = DnGetSectionKeyIndex(InfHandle,"Version","CabFiles",i++);
        //_LOG(("Looking in %s\n",SectionName));
    
        if( SectionName ){
    
            //
            // Search sections for our entry
            //
    
            if( DnGetSectionEntryExists( InfHandle, SectionName, FileName)){

                //_LOG(("Found %s in %s\n",FileName, SectionName));
    
                ret = TRUE;
    
            }

            FREE( SectionName );
            
        }
    }while( !ret && SectionName );

    
    

    //
    // If we got here we did not find the file
    //

    return ret;

}


VOID
DnCopyFilesInSection(
    IN unsigned Flags,
    IN PCHAR    SectionName,
    IN PCHAR    SourcePath,
    IN PCHAR    TargetPath
    )
{
    unsigned line;
    PCHAR FileName;
    PCHAR TargName;
    CHAR p[128],q[128];

    DnClearClientArea();
    DnWriteStatusText(NULL);

    line = 0;
    while(FileName = DnGetSectionLineIndex(DngInfHandle,SectionName,line++,0)) {

        TargName = DnGetSectionLineIndex(DngInfHandle,SectionName,line-1,1);
        if(!TargName) {
            TargName = FileName;
        }

        strcpy(p,SourcePath);
        DnpConcatPaths(p,FileName);
        strcpy(q,TargetPath);
        DnpConcatPaths(q,TargName);
        
        DnpCopyOneFile(Flags,p,q);

        if (TargName != FileName) {
            FREE (TargName);
        }
        FREE (FileName);
    }
}


VOID
DnCopyOemBootFiles(
    PCHAR TargetPath
    )
{
    unsigned Count;
    CHAR p[128],q[128];

    DnClearClientArea();
    DnWriteStatusText(NULL);

    for(Count=0; Count<OemBootFilesCount; Count++) {

        if( UserSpecifiedOEMShare ) {
            strcpy(p, UserSpecifiedOEMShare );
            DnpConcatPaths(p,WINNT_OEM_TEXTMODE_DIR);
            DnpConcatPaths(p,OemBootFiles[Count]);            
        } else {
            strcpy(p, DngSourceRootPath );
            DnpConcatPaths(p,WINNT_OEM_TEXTMODE_DIR);
            DnpConcatPaths(p,OemBootFiles[Count]);
            
        }

        strcpy(q, TargetPath );
        DnpConcatPaths(q, OemBootFiles[Count]);
        
        DnpCopyOneFile(0,p,q);
    }
}

#if NEC_98
VOID
DnCopyFilesInSectionForFDless(
    IN PCHAR SectionName,
    IN PCHAR SourcePath,
    IN PCHAR TargetPath
    )

/*++

Routine Description:

    Copies the file in Section. for FD less setup.
    SourcePath -> TargetPath

Arguments:

    SectionName - [RootBootFiles] in dosnet.inf

    SourcePath  - Root directory.(temporary drive)

    TargetPath  - \$WIN_NT$.~BU(temporary drive)

Return Value:

    None.

--*/

{
    unsigned line;
    PCHAR FileName;
    PCHAR TargName;
    PCHAR p,q;

    DnClearClientArea();
    DnWriteStatusText(NULL);

    line = 0;
    while(FileName = DnGetSectionLineIndex(DngInfHandle,SectionName,line++,0)) {

        TargName = DnGetSectionLineIndex(DngInfHandle,SectionName,line-1,1);
        if(!TargName) {
            TargName = FileName;
        }

        p = MALLOC(strlen(SourcePath) + strlen(FileName) + 2,TRUE);
        q = MALLOC(strlen(TargetPath) + strlen(TargName) + 2,TRUE);

        sprintf(p,"%s\\%s",SourcePath,FileName);
        sprintf(q,"%s\\%s",TargetPath,TargName);

        DnpCopyOneFileForFDless(p,q,FALSE);

        FREE(p);
        FREE(q);

        if (TargName != FileName) {
            FREE (TargName);
        }
        FREE (FileName);
    }
}


ULONG
DnpCopyOneFileForFDless(
    IN PCHAR   SourceName,
    IN PCHAR   DestName,
    IN BOOLEAN Verify
    )

/*++

Routine Description:

    Copies a single file. for FD less setup.

Arguments:

    SourceName - supplies fully qualified name of source file

    DestName - supplies fully qualified name of destination file

    Verify - if TRUE, the file will be verified after it has been copied.

Return Value:

    None.  May not return if an error occurs during the copy.

--*/

{
    int SrcHandle,DstHandle;
    PCHAR FilenamePart;
    BOOLEAN Verified;
    ULONG BytesWritten = 0;
    unsigned attribs, verifyf = 0;
    BOOLEAN UsedCompName;

    FilenamePart = strrchr(SourceName,'\\') + 1;

    DnSetCopyStatusText(DntCopying,FilenamePart);

    if(DnpOpenSourceFile(SourceName, &SrcHandle, &attribs, &UsedCompName)) {
        _dos_setfileattr(DestName,_A_NORMAL);
	if (Verify)
	    verifyf = CPY_VERIFY;
        if(!_dos_creat(DestName,_A_NORMAL,&DstHandle)) {
            DnpDoCopyOneFile(verifyf, SrcHandle,DstHandle,FilenamePart,&Verified,&BytesWritten);
            _dos_close(DstHandle);
        }
        _dos_close(SrcHandle);
    }

    return(BytesWritten);
}
#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\dncompvp.h ===
/***    DRVINFO.H - Definitions for IsDoubleSpaceDrive
 *
#ifdef EXTERNAL
 *      Version 1.00.03 - 5 January 1993
#else
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1992-1993
 *      All Rights Reserved.
 *
 *      History:
 *          27-Sep-1992 bens    Initial version
 *          05-Jan-1993 bens    Update for external release
#endif
 */

#ifndef BOOL
typedef int BOOL;
#endif

#ifndef FALSE
#define FALSE 0
#endif

#ifndef TRUE
#define TRUE  1
#endif

#ifndef BYTE
typedef unsigned char BYTE;
#endif

BOOL IsDoubleSpaceDrive(BYTE drive, BOOL *pfSwapped, BYTE *pdrHost, int *pseq);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\dnboot.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dnboot.c

Abstract:

    Routines for booting to NT text-mode setup.

Author:

    Ted Miller (tedm) 2-April-1992

Revision History:

--*/

#include "winnt.h"
#include <errno.h>
#include <stdlib.h>
#include <dos.h>
#include <string.h>
#include <time.h>
#include <direct.h>
#include <fcntl.h>
#include <share.h>
#if NEC_98
#include <memory.h>
#include <io.h>
extern  USHORT FirstFD;                          // 1'st Floppy Drive No
#endif // NEC_98

//
// This header file contains an array of 512 bytes
// representing the NT FAT boot code, in a variable
// of type unsigned char[] called FatBootCode.
//
#define _FAT32

#if NEC_98
#include <boot98f.h>
#ifdef _FAT32
#include <boot98f2.h>
#endif
#else
#include <bootfat.h>
#ifdef _FAT32
#include <bootf32.h>
#endif
#endif // NEC_98


#if NEC_98
#define FLOPPY_CAPACITY_525 1250304L
#else // NEC_98
#define FLOPPY_CAPACITY_525 1213952L
#endif // NEC_98
#define FLOPPY_CAPACITY_35  1457664L
#ifdef ALLOW_525
#define FLOPPY_CAPACITY FLOPPY_CAPACITY_525
#else
#define FLOPPY_CAPACITY FLOPPY_CAPACITY_35
#endif

#define SECTOR_SIZE 512

//
// Old int13 vector. See Int13Hook(), below.
//
void (_interrupt _far *OldInt13Vector)();


#if NEC_98
extern USHORT Cylinders;    // For Dos 3.x format
extern UCHAR  TargetDA_UA;
#endif // NEC_98
#pragma pack(1)

//
// Define bpb structure.
//
typedef struct _MY_BPB {
    USHORT BytesPerSector;
    UCHAR  SectorsPerCluster;
    USHORT ReservedSectors;
    UCHAR  FatCount;
    USHORT RootDirectoryEntries;
    USHORT SectorCountSmall;
    UCHAR  MediaDescriptor;
    USHORT SectorsPerFat;
    USHORT SectorsPerTrack;
    USHORT HeadCount;
} MY_BPB, *PMY_BPB;

//
// Define device params structure.
//
typedef struct _MY_DEVICE_PARAMS {
    UCHAR  SpecialFunctions;
    UCHAR  DeviceType;
    USHORT DeviceAttributes;
    USHORT CylinderCount;
    UCHAR  MediaType;
    MY_BPB Bpb;
    ULONG  HiddenSectors;
    ULONG  SectorCountLarge;
    ULONG  Padding[5];           // in case the struct grows in later dos versions!
} MY_DEVICE_PARAMS, *PMY_DEVICE_PARAMS;


//
// Define read write block request for ioctl call.
//
typedef struct _MY_READWRITE_BLOCK {
    UCHAR  SpecialFunctions;
    USHORT Head;
    USHORT Cylinder;
    USHORT FirstSector;
    USHORT SectorCount;
    VOID _far *Buffer;
} MY_READWRITE_BLOCK, *PMY_READWRITE_BLOCK;

#pragma pack()

VOID
DnInstallNtBoot(
    IN unsigned Drive       // 0=A, etc
    );

unsigned
DnpScanBootSector(
    IN PUCHAR BootSector,
    IN PUCHAR Pattern
    );

BOOLEAN
DnpAreAllFilesPresent(
    IN CHAR   DriveLetter,
    IN PCHAR  FileList[]
    );

BOOLEAN
DnpHasMZHeader(
    IN CHAR  DriveLetter,
    IN PCHAR Filename
    );

BOOLEAN
DnpInstallNtBootSector(
    IN     unsigned Drive,      // 0=A, etc.
    IN OUT PUCHAR   BootSector,
       OUT PCHAR   *PreviousOsText
    );


#if NEC_98
VOID RestoreBootcode(VOID);
#endif // NEC_98
PCHAR MsDosFileList[] = { "?:\\MSDOS.SYS", "?:\\IO.SYS", NULL };
//
// Some versions of PC-DOS have ibmio.com, others have ibmbio.com.
//
//PCHAR PcDosFileList[] = { "?:\\IBMDOS.COM", "?:\\IBMIO.COM", NULL };
#if NEC_98
#else // NEC_98
PCHAR PcDosFileList[] = { "?:\\IBMDOS.COM", NULL };
#endif
PCHAR Os2FileList[] = { "?:\\OS2LDR", "?:\\OS2KRNL", NULL };

void
_interrupt
_far
Int13Hook(
    unsigned _es,
    unsigned _ds,
    unsigned _di,
    unsigned _si,
    unsigned _bp,
    unsigned _sp,
    unsigned _bx,
    unsigned _dx,
    unsigned _cx,
    unsigned _ax,
    unsigned _ip,
    unsigned _cs,
    unsigned _flags
    )

/*++

Routine Description:

    We have encountered machines which cannot seem to create the floppies
    successfully. The user sees strange error messages about how the disk is
    not blank, etc even when the disk should be perfectly acceptable.

    To compensate for machines with broken change lines, we will hook int13
    to force a disk change error on the very next int13 call after the user
    has inserted a new disk.

    The logic is simple:  when we first start to make the boot floppies, we save
    away the int13 vector.  Then right after the user presses return at
    a disk prompt (ie, when he confirms the presence of a new floppy in the drive),
    which is right before we do a getbpb call, we set a new int13 vector.

    The int13 hook simply unhooks itself and returns the disk change error.
    This should force dos to recognize the new disk at the proper times.

Arguments:

    Registers pushed on stack as per spec of _interrupt-type functions.

Return Value:

    None. We modify the ax and flags registers return values.

--*/

{
    //
    // Unhook ourselves.
    //
#if NEC_98
    _dos_setvect(0x1b,OldInt13Vector);
#else // NEC_98
    _dos_setvect(0x13,OldInt13Vector);
#endif // NEC_98

    //
    // Force disk changed error.
    //
    _asm {
        mov _ax,0x600
        or  word ptr _flags,1
    }
}


VOID
DnpFlushBuffers(
    IN BOOLEAN TellUser
    )

/*++

Routine Description:

    Flush disk buffers.

Arguments:

    TellUser - if TRUE, we clear the screen and put up a message
        telling the user that we are flushing files. Otherwise
        this routine doesn't touch the screen.

Return Value:

    None.

--*/

{
    if(TellUser) {
        DnClearClientArea();
        DnWriteStatusText(DntFlushingData);
    }

    _asm {
        pusha
        mov ah,0xd
        int 21h
        popa
    }
}


VOID
DnToNtSetup(
    VOID
    )

/*++

Routine Description:

    Launch NT text-mode setup.

    Make sure the boot floppy we created is in the drive and reboot the
    machine.

Arguments:

    None.

Return Value:

    None.  Does not return.

--*/

{
    ULONG ValidKey[2];

    DnpFlushBuffers(TRUE);

    //
    // Make sure the setup boot floppy we created is in the drive
    // if necessary.
    //
    if(!DngUnattended) {

        DnClearClientArea();

        if(DngWindows) {
            DnDisplayScreen(
                  DngFloppyless
                ? &DnsAboutToExitX
                : (DngServer ? &DnsAboutToExitS : &DnsAboutToExitW)
                );
        } else {
            DnDisplayScreen(
                  DngFloppyless
                ? &DnsAboutToRebootX
                : (DngServer ? &DnsAboutToRebootS : &DnsAboutToRebootW)
                );
        }

        DnWriteStatusText(DntEnterEqualsContinue);
        ValidKey[0] = ASCI_CR;
        ValidKey[1] = 0;
        DnGetValidKey(ValidKey);
    }

    //
    // Reboot the machine unless we are being run on Windows.
    // In that case, there should be a wrapper program that will shut down
    // the system using the Windows API -- our attempt to shut down using the
    // usual method will fail.
    //
    if(!DngWindows) {
        DnaReboot();
    }
}


BOOLEAN
DnIndicateWinnt(
    IN PCHAR Directory
    )
{
    PCHAR       WinntData       = WINNT_DATA_A;
    PCHAR       WinntAccess     = WINNT_ACCESSIBILITY_A;
    PCHAR       WinntMsdos      = WINNT_D_MSDOS_A;
    PCHAR       WinntSif        = WINNT_SIF_FILE_A;
    PCHAR       WinntFloppy     = WINNT_D_FLOPPY_A;
    PCHAR       WinntUnattended = WINNT_UNATTENDED_A;
    PCHAR       WinntOne        = WINNT_A_ONE;
    PCHAR       WinntZero       = WINNT_A_ZERO;
    PCHAR       WinntUpgrade    = WINNT_U_NTUPGRADE;
    PCHAR       WinntYes        = WINNT_A_YES;
    PVOID       InfHandle;
    PVOID       UnattendHandle;
    PCHAR       FileName;
    PCHAR       p;
    PCHAR       OptionalDirString;
    unsigned    OptionalDirLength = 0;
    unsigned    u,l;
    FILE        *f;
    int         Status;
    PCHAR       SectionName;
    unsigned    LineNumber;
    CHAR        ServerAndShare[128];
    BOOLEAN     AccessibleSetup = FALSE;
    CHAR        AccessibleScriptFile[] = "setupacc.txt";

    //
    // Allocate a new INF file buffer
    //
    InfHandle = DnNewSetupTextFile();
    if (InfHandle == NULL) {
        return (FALSE);
    }

    //
    // Build the default file name
    //
    FileName = MALLOC(strlen(Directory)+strlen(WinntSif)+2,TRUE);
    if(FileName == NULL) {
        DnFreeINFBuffer( InfHandle );
        return FALSE;
    }

    //
    // Display to the user what we are doing
    //
    DnWriteStatusText(DntPreparingData);

    //
    // Build the name of the file we wish to save the INF file as
    //
    strcpy(FileName,Directory);
    strcat(FileName,"\\");
    strcat(FileName,WinntSif);

    //
    // Handle Accessibility utilities
    //

    if(DngMagnifier) {
        DnAddLineToSection(
            InfHandle,
            WinntAccess,
            WINNT_D_ACC_MAGNIFIER,
            &WinntOne,
            1);
        AccessibleSetup = TRUE;
    }

    if(DngTalker) {
        DnAddLineToSection(
            InfHandle,
            WinntAccess,
            WINNT_D_ACC_READER,
            &WinntOne,
            1);
        AccessibleSetup = TRUE;
    }

    if(DngKeyboard) {
        DnAddLineToSection(
            InfHandle,
            WinntAccess,
            WINNT_D_ACC_KEYBOARD,
            &WinntOne,
            1);
        AccessibleSetup = TRUE;
    }

    if(AccessibleSetup && !DngUnattended) {
        DngUnattended = TRUE;
        DngScriptFile = MALLOC(strlen(DngSourceRootPath) +
            strlen(AccessibleScriptFile) + 2, TRUE);
        if(DngScriptFile == NULL) {
            DnFatalError(&DnsOutOfMemory);
        }
        strcpy(DngScriptFile,DngSourceRootPath);
        strcat(DngScriptFile,"\\");
        strcat(DngScriptFile,AccessibleScriptFile);
    }

    //
    // Append script file if necessary.
    // Do this processing first because we want to be able to
    // override anything that the user sets in the unattend file
    // that the user has no business setting
    //
    if(DngUnattended) {

        if(DngScriptFile) {

            //
            // First open the script file as a dos file
            //
            f = fopen(DngScriptFile,"rt");
            if(f == NULL) {
                //
                // fatal error.
                //
                DnFatalError(&DnsOpenReadScript);
            }

            //
            // Now open it as a INF file
            //
            LineNumber = 0;
            Status = DnInitINFBuffer (f, &UnattendHandle, &LineNumber);
            fclose(f);
            if(Status == ENOMEM) {
                DnFatalError(&DnsOutOfMemory);
            } else if(Status) {
                DnFatalError(&DnsParseScriptFile, DngScriptFile, LineNumber);
            }

            //
            // Process all of the section names
            //
            for( SectionName = NULL;
                 ((SectionName = DnGetSectionName( UnattendHandle )) != NULL);
               ) {
                //
                // We won't allow the data section or the [OemBootFiles]
                // to be copied
                //
                if ((strcmpi(WinntData,SectionName) != 0) &&
                    (strcmpi(WINNT_OEMBOOTFILES,SectionName) != 0)
                   ) {

                    //
                    // Copy the sections from the Unattend INF
                    // to the Main INF
                    //
                    DnCopySetupTextSection(
                        UnattendHandle,
                        InfHandle,
                        SectionName);

                }
                FREE (SectionName);
            }

            //
            // We no longer need the unattend inf file at this point
            //
            DnFreeINFBuffer( UnattendHandle );

        }

        if(!DngScriptFile) {
            //
            // No script. Put a dummy [Unattended] section in there.
            //
            DnAddLineToSection(InfHandle,WinntUnattended,"unused",&WinntZero,1);
        }
    }

    //
    // Add the default line to the inf
    //
    DnAddLineToSection(
        InfHandle,
        WinntData,
        WinntMsdos,
        &WinntOne,
        1);

    //
    // Set the floppy flags
    //
    if(DngFloppyless) {

        DnAddLineToSection(
            InfHandle,
            WinntData,
            WinntFloppy,
            &WinntOne,
            1);

    } else {

        DnAddLineToSection(
            InfHandle,
            WinntData,
            WinntFloppy,
            &WinntZero,
            1);

    }

    //
    // Remember udf info
    //
    if(UniquenessId) {

        DnAddLineToSection(
            InfHandle,
            WinntData,
            WINNT_D_UNIQUENESS,
            &UniquenessId,
            1);
    }

    //
    // Write info about original source.
    //
    // We only distinguish here between remote and CD-ROM.
    // If it doesn't appear to be a remote drive, either by
    // being UNC or a redirected local drive, then we assume
    // it's a CD-ROM drive (this behavior is intended to force
    // GUI Setup to locate a valid CD-ROM if one is available).
    // Because we have no idea what the drive letters will be
    // on NT, we always write A: in there.
    //
    #define DRIVE_REMOTE 4
    #define DRIVE_CDROM  5

    u = DRIVE_CDROM;

    if(DngOemPreInstall) {
        //
        // Preinstall case, force GUI Setup to locate a CD-ROM drive
        // and assume the I386 directory is on the root of the CD
        // (that's how we ship the retail CDs).
        //
        strcpy(ServerAndShare,"A:\\I386");
    } else {
        if(DngSourceRootPath[0] == '\\') {
            //
            // UNC path. change drive type to remote and remember
            // the entire path.
            //
            u = DRIVE_REMOTE;
            strcpy(ServerAndShare,DngSourceRootPath);
        } else {
            //
            // Assume fully-qualified path starting with a drive letter.
            //
            if(DnIsDriveRemote((unsigned)DngSourceRootPath[0]+1-(unsigned)'A',ServerAndShare)) {
                //
                // It's a redirected network drive.
                //
                if(ServerAndShare[0]) {
                    //
                    // Change type to remote drive. ServerAndShare has the
                    // \\server\share, to which we append the rest of the path, below.
                    //
                    u = DRIVE_REMOTE;
                } else {
                    //
                    // Strange case where we can't resolve the local drive letter
                    // to its server and share. Leave as CD-ROM.
                    //
                    ServerAndShare[0] = 'A';
                    ServerAndShare[1] = ':';
                    ServerAndShare[2] = 0;
                }

                strcat(ServerAndShare,DngSourceRootPath+2);

            } else {
                //
                // Not a network drive. Assume CD-ROM.
                //
                strcpy(ServerAndShare,DngSourceRootPath);
                ServerAndShare[0] = 'A';
            }
        }
    }

    p = ServerAndShare;
    DnAddLineToSection(InfHandle,WinntData,WINNT_D_ORI_SRCPATH,&p,1);
    sprintf(p,"%u",u);
    DnAddLineToSection(InfHandle,WinntData,WINNT_D_ORI_SRCTYPE,&p,1);

    if(CmdToExecuteAtEndOfGui) {
        DnAddLineToSection(InfHandle,WINNT_SETUPPARAMS,WINNT_S_USEREXECUTE,&CmdToExecuteAtEndOfGui,1);
    }

    if(OptionalDirCount) {
        //
        // If an optional dir string is present then we want to generate
        // and entry in the sif file that contains a line with the dir
        // string in the form of dir1*dir2*...*dirn
        //
        OptionalDirString = NULL;
        for(u=0; u<OptionalDirCount; u++) {
            if( ( OptionalDirFlags[u] & OPTDIR_OEMOPT ) ||
                ( OptionalDirFlags[u] & OPTDIR_OEMSYS ) ) {
                continue;
            }

            if(!(OptionalDirFlags[u] & OPTDIR_TEMPONLY)) {

                p = OptionalDirs[u];
                if(OptionalDirLength == 0) {

                    //
                    // We haven't allocated any memory yet...
                    //
                    OptionalDirString = MALLOC((strlen(p)+2) * sizeof(CHAR),TRUE);
                    strcpy(OptionalDirString,p);

                } else {

                    //
                    // This is the original case that should be used in the
                    // release version of the product. We use a REALLOC because
                    // it is more memory conservative then using 2 MALLOCs
                    //
                    OptionalDirString = REALLOC(
                        OptionalDirString,
                        (strlen(p) + 2 + OptionalDirLength) * sizeof(CHAR),TRUE);
                    strcat(OptionalDirString,p);

                }
                strcat(OptionalDirString,"*");
                OptionalDirLength = strlen(OptionalDirString);
            }
        }

        if(OptionalDirString) {

            //
            // Remove trailing * if any
            //
            l = strlen(OptionalDirString);
            if(l && (OptionalDirString[l-1] == '*')) {
                OptionalDirString[l-1] = 0;
            }

            DnAddLineToSection(
                InfHandle,
                WINNT_SETUPPARAMS,
                WINNT_S_OPTIONALDIRS,
                &OptionalDirString,
                1);

            FREE(OptionalDirString);
        }

        OptionalDirLength = 0;
    }

    //
    // Display a message to the user about what we are doing
    //
    DnWriteStatusText(DngFloppyless ? DntWritingData : DntConfiguringFloppy);

    //
    // Write the file to disk
    //
    Status = (int) DnWriteSetupTextFile(InfHandle,FileName);

    //
    // Free the memory used by the INF structure
    //
    DnFreeINFBuffer(InfHandle);
    FREE(FileName);

    return ((BOOLEAN) Status);

}


VOID
DnPromptAndInspectFloppy(
    IN  PSCREEN FirstPromptScreen,
    IN  PSCREEN SubsequentPromptScreen,
    OUT PMY_BPB Bpb
    )
{
    ULONG ValidKey[3];
    ULONG c;
    MY_DEVICE_PARAMS DeviceParams;
    union REGS RegistersIn,RegistersOut;
    PSCREEN PromptScreen,ErrorScreen;
    struct diskfree_t DiskSpace;
    ULONG FreeSpace;
    struct find_t FindData;
#if NEC_98
    UCHAR FddNo;
    UCHAR TextInf[32];
    UCHAR AlReg;
#endif // NEC_98

    PromptScreen = FirstPromptScreen;

    ValidKey[0] = ASCI_CR;
    ValidKey[1] = DN_KEY_F3;
    ValidKey[2] = 0;

    do {

        DnClearClientArea();
        DnDisplayScreen(PromptScreen);
        DnWriteStatusText("%s  %s",DntEnterEqualsContinue,DntF3EqualsExit);

        PromptScreen = SubsequentPromptScreen;
        ErrorScreen = NULL;

        while(1) {
            c = DnGetValidKey(ValidKey);
            if(c == ASCI_CR) {
                break;
            }
            if(c == DN_KEY_F3) {
                DnExitDialog();
            }
        }

        DnClearClientArea();
        DnWriteStatusText(DntConfiguringFloppy);

#if NEC_98
        FddNo = (UCHAR)FirstFD;
        _asm {
            push ds
            mov  ah,1ch
            mov  dl,FddNo
            int  21h
            pop  ds
            mov  AlReg,al
        }
#endif // NEC_98
        //
        // Hook int13h.  We will force a disk change error
        // at this point to work around broken change lines.
        // The hook will automatically unhook itself as appropriate.
        //
        if(!DngFloppyless) {
#if NEC_98
            if(AlReg == 0xff) {
                ErrorScreen = &DnsFloppyNotFormatted;
                goto FarstFddErr;
            }
            _dos_setvect(0x1b,Int13Hook);
            sprintf(TextInf,"%c:\\*.*\0" ,(UCHAR)(FirstFD + 0x60));
            _dos_findfirst(TextInf,_A_NORMAL,&FindData);
#else // NEC_98
            _dos_setvect(0x13,Int13Hook);
            _dos_findfirst("a:\\*.*",_A_NORMAL,&FindData);
#endif // NEC_98
        }

        //
        // Get the BPB for the disk in the drive.
        //
        DeviceParams.SpecialFunctions = 1;  // set up to get current bpb

        RegistersIn.x.ax = 0x440d;          // ioctl for block device
#if NEC_98
        RegistersIn.x.bx = FirstFD;         // First Floppy Drive
#else // NEC_98
        RegistersIn.x.bx = 1;               // A:
#endif // NEC_98
        RegistersIn.x.cx = 0x860;           // category disk, get device params
        RegistersIn.x.dx = (unsigned)(void _near *)&DeviceParams;  // ds = ss
        intdos(&RegistersIn,&RegistersOut);
        if(RegistersOut.x.cflag) {
            //
            // Unable to get the current BPB for the disk.  Assume
            // Assume not formatted or not formatted correctly.
            //
            ErrorScreen = &DnsFloppyNotFormatted;

        } else {
            //
            // Sanity check on the BPB
            //
            if((DeviceParams.Bpb.BytesPerSector != SECTOR_SIZE)
            || (   (DeviceParams.Bpb.SectorsPerCluster != 1)
                && (DeviceParams.Bpb.SectorsPerCluster != 2))   // for 2.88M disks
            || (DeviceParams.Bpb.ReservedSectors != 1)
            || (DeviceParams.Bpb.FatCount != 2)
            || !DeviceParams.Bpb.SectorCountSmall               // should be < 32M
            || (DeviceParams.Bpb.MediaDescriptor == 0xf8)       // hard disk
            || (DeviceParams.Bpb.HeadCount != 2)
            || !DeviceParams.Bpb.RootDirectoryEntries) {

                ErrorScreen = &DnsFloppyBadFormat;
            } else {

#if NEC_98
                if(_dos_getdiskfree(FirstFD,&DiskSpace)) {
#else // NEC_98
                if(_dos_getdiskfree(1,&DiskSpace)) {
#endif // NEC_98
                    ErrorScreen = &DnsFloppyCantGetSpace;

                } else {
                    FreeSpace = (ULONG)DiskSpace.avail_clusters
                              * (ULONG)DiskSpace.sectors_per_cluster
                              * (ULONG)DiskSpace.bytes_per_sector;

                    if(DngCheckFloppySpace && (FreeSpace < FLOPPY_CAPACITY)) {
                        ErrorScreen = &DnsFloppyNotBlank;
                    }
                }
            }
        }

        //
        // If there is a problem with the disk, inform the user.
        //
        if(ErrorScreen) {
#if NEC_98
FarstFddErr:
#endif // NEC_98

            DnClearClientArea();
            DnDisplayScreen(ErrorScreen);
            DnWriteStatusText("%s  %s",DntEnterEqualsContinue,DntF3EqualsExit);

            while(1) {
                c = DnGetValidKey(ValidKey);
                if(c == ASCI_CR) {
                    break;
                }
                if(c == DN_KEY_F3) {
                    DnExitDialog();
                }
            }
        }
    } while(ErrorScreen);

    //
    // Copy the bpb for the drive into the structure provided
    // by the caller.
    //
    memcpy(Bpb,&DeviceParams.Bpb,sizeof(MY_BPB));
}




VOID
DnCreateBootFloppies(
    VOID
    )

/*++

Routine Description:

    Create a set of 3 boot floppies if we are not in floppyless operation.
    If we are in floppyless operation, place the floppy files on the system
    partition instead.

    Note that we flush buffers after each floppy so the user who has
    write-behind turned on for floppies doesn't get confused as we ask
    him to shuffle floppies around.

Arguments:

    None.

Return Value:

    None.

--*/


{
    ULONG ValidKey[3];
    ULONG c;
    int i;
    PSCREEN ErrorScreen;
    UCHAR SectorBuffer[SECTOR_SIZE],VerifyBuffer[SECTOR_SIZE];
    MY_BPB Bpb;
    union REGS RegistersIn,RegistersOut;
    MY_READWRITE_BLOCK ReadWriteBlock;
    CHAR BootRoot[sizeof(FLOPPYLESS_BOOT_ROOT) + 2];
    CHAR System32Dir[sizeof(FLOPPYLESS_BOOT_ROOT) + sizeof("\\SYSTEM32") + 1];
#if NEC_98
#else // NEC_98
    unsigned HostDrive;
    struct diskfree_t DiskSpace;
#endif // NEC_98

    //
    // Need to determine the system partition.  It is usually C:
    // but if C: is compressed we need to find the host drive.
    //
#if NEC_98
    BootRoot[0] = (CHAR)toupper(DngTargetDriveLetter);
#else // NEC_98
    if(DnIsDriveCompressedVolume(3,&HostDrive)) {
        BootRoot[0] = (CHAR)(HostDrive + (unsigned)'A' - 1);
    } else {
        BootRoot[0] = 'C';
    }
#endif // NEC_98
    BootRoot[1] = ':';
    strcpy(BootRoot+2,FLOPPYLESS_BOOT_ROOT);
#if NEC_98
#else // NEC_98
    DnDelnode(BootRoot);
#endif // NEC_98
    //
    // Create the boot root if necessary.
    //
    if(DngFloppyless) {
#if NEC_98
#else // NEC_98

        //
        // Check free space on the system partition.
        //
        if(_dos_getdiskfree((unsigned)BootRoot[0]-(unsigned)'A'+1,&DiskSpace)
        ||(   ((ULONG)DiskSpace.avail_clusters
             * (ULONG)DiskSpace.sectors_per_cluster
             * (ULONG)DiskSpace.bytes_per_sector) < (3L*FLOPPY_CAPACITY_525)))
        {
            DnFatalError(&DnsNoSpaceOnSyspart);
        }

#endif // NEC_98
        mkdir(BootRoot);

        DnInstallNtBoot((unsigned)BootRoot[0]-(unsigned)'A');

    } else {

        //
        // Remember old int13 vector because we will be hooking int13.
        //
#if NEC_98
        OldInt13Vector = _dos_getvect(0x1b);
#else // NEC_98
        OldInt13Vector = _dos_getvect(0x13);
#endif // NEC_98

        //
        // Boot root is A:.
        //
#if NEC_98
        sprintf(BootRoot,"%c:\0" ,(UCHAR)(FirstFD + 0x60));
#else // NEC_98
        strcpy(BootRoot,"A:");
#endif // NEC_98
    }

    strcpy(System32Dir,BootRoot);
    strcat(System32Dir,"\\SYSTEM32");

    ValidKey[0] = ASCI_CR;
    ValidKey[1] = DN_KEY_F3;
    ValidKey[2] = 0;

    do {

        ErrorScreen = NULL;

        //
        // Get a floppy in the drive -- this will be "Windows NT Setup Disk #3"
        //
        if(!DngFloppyless) {
            DnPromptAndInspectFloppy(
                DngServer ? &DnsNeedSFloppyDsk3_0 : &DnsNeedFloppyDisk3_0,
                DngServer ? &DnsNeedSFloppyDsk3_1 : &DnsNeedFloppyDisk3_1,
                &Bpb
                );
        }

        //
        // Hack: create system 32 directory on the disk.
        // Remove any file called system32.
        //
        _dos_setfileattr(System32Dir,_A_NORMAL);
        remove(System32Dir);
        mkdir(System32Dir);

        //
        // Copy files into the disk.
        //
        DnCopyFloppyFiles(DnfFloppyFiles3,BootRoot);
        if(!DngFloppyless) {
            DnpFlushBuffers(TRUE);
        }

    } while(ErrorScreen);

    //
    // Get a floppy in the drive -- this will be "Windows NT Setup Disk #2"
    //
    if(!DngFloppyless) {
        DnPromptAndInspectFloppy(
            DngServer ? &DnsNeedSFloppyDsk1_0 : &DnsNeedFloppyDisk1_0,
            DngServer ? &DnsNeedSFloppyDsk1_0 : &DnsNeedFloppyDisk1_0,
            &Bpb
            );
    }

    //
    // Copy files into the disk.
    //
    DnCopyFloppyFiles(DnfFloppyFiles2,BootRoot);
    DnCopyFloppyFiles(DnfFloppyFiles1,BootRoot);

    do {

        ErrorScreen = NULL;

        //
        // Get a floppy in the drive -- this will be "Windows NT Setup Boot Disk"
        //
        if(DngFloppyless) {
            DnCopyFloppyFiles(DnfFloppyFiles0,BootRoot);
        } else {

            DnPromptAndInspectFloppy(
                DngServer ? &DnsNeedSFloppyDsk0_0 : &DnsNeedFloppyDisk0_0,
                DngServer ? &DnsNeedSFloppyDsk0_0 : &DnsNeedFloppyDisk0_0,
                &Bpb
                );

#if NEC_98
            memcpy(SectorBuffer,PC98FatBootCode,512);
#else // NEC_98
            memcpy(SectorBuffer,FatBootCode,SECTOR_SIZE);
#endif // NEC_98

            //
            // Copy the BPB we retreived for the disk into the bootcode template.
            // We only care about the original BPB fields, through the head count
            // field.  We will fill in the other fields ourselves.
            //
            strncpy(SectorBuffer+3,"MSDOS5.0",8);
            memcpy(SectorBuffer+11,&Bpb,sizeof(MY_BPB));

            //
            // Set up other fields in the bootsector/BPB/xBPB.
            //
            // Large sector count (4 bytes)
            // Hidden sector count (4 bytes)
            // current head (1 byte, not necessary to set this, but what the heck)
            // physical disk# (1 byte)
            //
            memset(SectorBuffer+28,0,10);

            //
            // Extended BPB signature
            //
            *(PUCHAR)(SectorBuffer+38) = 41;

            //
            // Serial number
            //
            srand((unsigned)clock());
            *(PULONG)(SectorBuffer+39) = (((ULONG)clock() * (ULONG)rand()) << 8) | rand();

            //
            // volume label/system id
            //
            strncpy(SectorBuffer+43,"NO NAME    ",11);
            strncpy(SectorBuffer+54,"FAT12   ",8);

            //
            // Overwrite the 'ntldr' string with 'setupldr.bin' so the right file gets
            // loaded when the floppy is booted.
            //
            if(i = DnpScanBootSector(SectorBuffer,"NTLDR      ")) {
                strncpy(SectorBuffer+i,"SETUPLDRBIN",11);
            }

            //
            // Write the boot sector.
            //
#if NEC_98
            RegistersIn.h.ah = 0x30;
            intdos(&RegistersIn,&RegistersOut);
            if(RegistersOut.h.al < 0x7) {
                RegistersIn.x.ax = FirstFD - 1;
                RegistersIn.x.bx = (unsigned)(void _near *)&SectorBuffer;
                RegistersIn.x.cx = 1;
                RegistersIn.x.dx = 0;
                int86(0x26,&RegistersIn,&RegistersOut);
            } else {
                ReadWriteBlock.SpecialFunctions = 0;
                ReadWriteBlock.Head = 0;                // head
                ReadWriteBlock.Cylinder = 0;            // cylinder
                ReadWriteBlock.FirstSector = 0;         // sector
                ReadWriteBlock.SectorCount = 1;         // sector count
                ReadWriteBlock.Buffer = SectorBuffer;

                RegistersIn.x.ax = 0x440d;          // ioctl for block device
                RegistersIn.x.bx = FirstFD;         // A:
                RegistersIn.x.cx = 0x841;           // category disk; write sectors
                RegistersIn.x.dx = (unsigned)(void _near *)&ReadWriteBlock;
                intdos(&RegistersIn,&RegistersOut);
            }
            if(RegistersOut.x.cflag) {
#else // NEC_98
            ReadWriteBlock.SpecialFunctions = 0;
            ReadWriteBlock.Head = 0;                // head
            ReadWriteBlock.Cylinder = 0;            // cylinder
            ReadWriteBlock.FirstSector = 0;         // sector
            ReadWriteBlock.SectorCount = 1;         // sector count
            ReadWriteBlock.Buffer = SectorBuffer;

            RegistersIn.x.ax = 0x440d;          // ioctl for block device
            RegistersIn.x.bx = 1;               // A:
            RegistersIn.x.cx = 0x841;           // category disk; write sectors
            RegistersIn.x.dx = (unsigned)(void _near *)&ReadWriteBlock;
            intdos(&RegistersIn,&RegistersOut);
            if(RegistersOut.x.cflag) {
#endif // NEC_98
                ErrorScreen = &DnsFloppyWriteBS;
            } else {

                DnpFlushBuffers(FALSE);

                //
                // Read the sector back in and verify that we wrote what we think
                // we wrote.
                //
#if NEC_98
                RegistersIn.h.ah = 0x30;
                intdos(&RegistersIn,&RegistersOut);
                if(RegistersOut.h.al < 0x7) {
                    RegistersIn.x.ax = FirstFD - 1;
                    RegistersIn.x.bx = (unsigned)(void _near *)&VerifyBuffer;
                    RegistersIn.x.cx = 1;
                    RegistersIn.x.dx = 0;
                    int86(0x25,&RegistersIn,&RegistersOut);
                } else {
                    ReadWriteBlock.Buffer = VerifyBuffer;
                    RegistersIn.x.ax = 0x440d;          // ioctl for block device
                    RegistersIn.x.bx = FirstFD;         // A:
                    RegistersIn.x.cx = 0x861;           // category disk; write sectors
                    RegistersIn.x.dx = (unsigned)(void _near *)&ReadWriteBlock;
                    intdos(&RegistersIn,&RegistersOut);
                }
                if(RegistersOut.x.cflag || memcmp(SectorBuffer,VerifyBuffer,512)) {
#else // NEC_98
                ReadWriteBlock.Buffer = VerifyBuffer;
                RegistersIn.x.ax = 0x440d;          // ioctl for block device
                RegistersIn.x.bx = 1;               // A:
                RegistersIn.x.cx = 0x861;           // category disk; write sectors
                RegistersIn.x.dx = (unsigned)(void _near *)&ReadWriteBlock;
                intdos(&RegistersIn,&RegistersOut);
                if(RegistersOut.x.cflag || memcmp(SectorBuffer,VerifyBuffer,SECTOR_SIZE)) {
#endif // NEC_98
                    ErrorScreen = &DnsFloppyVerifyBS;
                } else {

                    //
                    // Copy the relevent files to the floppy.
                    //

                    DnCopyFloppyFiles(DnfFloppyFiles0,BootRoot);
                    //
                    // Flush buffers
                    //
                    DnpFlushBuffers(TRUE);
                }
            }
        }
        if( !ErrorScreen ) {
            //
            // Put a small file on the disk indicating that it's a winnt setup.
            //
            if(DngWinntFloppies) {
                if(!DnIndicateWinnt(BootRoot)) {
                    ErrorScreen = &DnsCantWriteFloppy;
                } else {
                    if(!DngFloppyless) {
                        DnpFlushBuffers(TRUE);
                    }
                }
            }
        }

        if(ErrorScreen) {

            DnClearClientArea();
            DnDisplayScreen(ErrorScreen);
            DnWriteStatusText("%s  %s",DntEnterEqualsContinue,DntF3EqualsExit);

            while(1) {
                c = DnGetValidKey(ValidKey);
                if(c == ASCI_CR) {
                    break;
                }
                if(c == DN_KEY_F3) {
                    DnExitDialog();
                }
            }
        }
    } while(ErrorScreen);

    //
    // Additionally in the floppyless case, we need to copy some files
    // from the boot directory to the root of the system partition drive.
    //
    if(DngFloppyless) {

        DnCopyFloppyFiles(DnfFloppyFilesX,BootRoot);

        System32Dir[0] = BootRoot[0];
        System32Dir[1] = ':';
        System32Dir[2] = 0;

        DnCopyFilesInSection(CPY_PRESERVE_NAME,DnfRootBootFiles,BootRoot,System32Dir);

        if( DngOemPreInstall ) {
            //
            //  If this is an OEM preinstall, then create the directory
            //  $win_nt$.~bt\$OEM$, and copy all files listed in
            //  OemBootFiles to this directory
            //
            PCHAR OEMBootDir;

            OEMBootDir = MALLOC( strlen( BootRoot ) + 1 +
                                 strlen( WINNT_OEM_DIR ) + 1, TRUE );
            strcpy(OEMBootDir, BootRoot);
            strcat(OEMBootDir, "\\");
            strcat(OEMBootDir, WINNT_OEM_DIR);

            //
            // Hack: create $win_nt$.~ls\$oem$ directory on the disk.
            // Remove any file called $oem$.
            //
            _dos_setfileattr(OEMBootDir,_A_NORMAL);
            remove(OEMBootDir);
            mkdir(OEMBootDir);

            //
            // Copy the OEM boot files
            //
            DnCopyOemBootFiles(OEMBootDir);
        }

    }

}


BOOLEAN
DnpWriteOutLine(
    IN int    Handle,
    IN PUCHAR Line
    )
{
    unsigned bw,l;

    l = strlen(Line);

    return((BOOLEAN)((_dos_write(Handle,Line,l,&bw) == 0) && (bw == l)));
}


VOID
DnInstallNtBoot(
    IN unsigned Drive       // 0=A, etc
    )
{
    PUCHAR Buffer,p,next,orig;
    unsigned BootIniSize;
    BOOLEAN b;
    CHAR BootIniName[] = "?:\\BOOT.INI";
    struct find_t FindData;
    BOOLEAN InOsSection;
    BOOLEAN SawPreviousOsLine;
    CHAR c;
    PCHAR PreviousOs;
    int h;

    //
    // This buffer is used to read in boot.ini as well as
    // to hold a bootsector. So make it big enough.
    //
    Buffer = MALLOC(10000,TRUE);
    BootIniName[0] = (CHAR)(Drive + (unsigned)'A');
    b = TRUE;

    if(b = DnpInstallNtBootSector(Drive,Buffer,&PreviousOs)) {

        //
        // Load boot.ini.
        //
        _dos_setfileattr(BootIniName,_A_NORMAL);
        BootIniSize = 0;

        if(!_dos_findfirst(BootIniName,_A_RDONLY|_A_HIDDEN|_A_SYSTEM,&FindData)) {

            if(!_dos_open(BootIniName,O_RDWR|SH_COMPAT,&h)) {

                BootIniSize = (unsigned)max(FindData.size,(16*1024)-1);

                if(_dos_read(h,Buffer,BootIniSize,&BootIniSize)) {

                    BootIniSize = 0;
                }

                _dos_close(h);
            }
        }

        Buffer[BootIniSize] = 0;

        //
        // Truncate at control-z if one exists.
        //
        if(p = strchr(Buffer,26)) {
            *p = 0;
            BootIniSize = p-Buffer;
        }

        //
        // Recreate bootini.
        //
        if(_dos_creat(BootIniName,_A_RDONLY|_A_HIDDEN|_A_SYSTEM,&h)) {
            b = FALSE;
        }

        if(b) {
            b = DnpWriteOutLine(
                    h,
                    "[Boot Loader]\r\n"
                    "Timeout=5\r\n"
                    "Default=C:" FLOPPYLESS_BOOT_ROOT "\\" FLOPPYLESS_BOOT_SEC "\r\n"
                    "[Operating Systems]\r\n"
                    );
        }

        if(b) {

            //
            // Process each line in boot.ini.
            // If it's the previous os line and we have new previous os text,
            // we'll throw out the old text in favor of the new.
            // If it's the setup boot sector line, we'll throw it out.
            //
            InOsSection = FALSE;
            SawPreviousOsLine = FALSE;
            for(p=Buffer; *p && b; p=next) {

                while((*p==' ') || (*p=='\t')) {
                    p++;
                }

                if(*p) {

                    //
                    // Find first byte of next line.
                    //
                    for(next=p; *next && (*next++ != '\n'); );

                    //
                    // Look for start of [operating systems] section
                    // or at each line in that section.
                    //
                    if(InOsSection) {

                        switch(*p) {

                        case '[':   // end of section.
                            *p=0;   // force break out of loop
                            break;

                        case 'C':
                        case 'c':   // potential start of c:\ line

                            if((next-p >= 6) && (p[1] == ':') && (p[2] == '\\')) {

                                orig = p;
                                p += 3;
                                while((*p == ' ') || (*p == '\t')) {
                                    p++;
                                }

                                if(*p == '=') {

                                    //
                                    // Previous os line. Leave intact unless we have
                                    // new text for it.
                                    //
                                    SawPreviousOsLine = TRUE;
                                    if(PreviousOs) {

                                        if((b=DnpWriteOutLine(h,"C:\\ = \""))
                                        && (b=DnpWriteOutLine(h,PreviousOs))) {
                                            b=DnpWriteOutLine(h,"\"\r\n");
                                        }

                                        break;
                                    } else {

                                        //
                                        // The current line in boot.ini is for the previous
                                        // OS but we do not need to write a new previous os
                                        // line.  We want to leave this line alone and write
                                        // it out as is.
                                        //
                                        p = orig;
                                        // falls through to default case
                                    }
                                } else {

                                    //
                                    // See if it's a line for setup boot.
                                    // If so, ignore it.
                                    // If it's not a line for setup boot, write it out as-is.
                                    //
                                    if(strnicmp(orig,"C:" FLOPPYLESS_BOOT_ROOT,sizeof("C:" FLOPPYLESS_BOOT_ROOT)-1)) {
                                        p = orig;
                                    } else {
                                        break;
                                    }
                                }
                            }

                            // may fall through on purpose

                        default:

                            //
                            // Random line. write it out.
                            //
                            c = *next;
                            *next = 0;
                            b = DnpWriteOutLine(h,p);
                            *next = c;

                            break;

                        }

                    } else {

                        if(!strnicmp(p,"[operating systems]",19)) {
                            InOsSection = TRUE;
                        }
                    }
                }
            }

            //
            // If we need to, write out a line for the previous os.
            // We'll need to if there was no previous os line in the existing
            // boot.ini but we discovered that there is a previous os on the machine.
            //
            if(b && PreviousOs && !SawPreviousOsLine) {

                if((b=DnpWriteOutLine(h,"C:\\ = \""))
                && (b=DnpWriteOutLine(h,PreviousOs))) {
                    b=DnpWriteOutLine(h,"\"\r\n");
                }
            }

            //
            // Write out our line
            //
            if(b
            && (b=DnpWriteOutLine(h,"C:" FLOPPYLESS_BOOT_ROOT "\\" FLOPPYLESS_BOOT_SEC " = \""))
            && (b=DnpWriteOutLine(h,DntBootIniLine))) {
                b = DnpWriteOutLine(h,"\"\r\n");
            }
        }

        _dos_close(h);

    } else {
        b = FALSE;
    }

    if(!b) {
        DnFatalError(&DnsNtBootSect);
    }

    FREE(Buffer);
}


BOOLEAN
DnpInstallNtBootSector(
    IN     unsigned Drive,      // 0=A, etc.
    IN OUT PUCHAR   BootSector,
       OUT PCHAR   *PreviousOsText
    )
{
    PUCHAR BootTemplate,p;
    PSCREEN ErrorScreen = NULL;
    CHAR BootsectDosName[] = "?:\\BOOTSECT.DOS";
    int h;
    unsigned BytesWritten;
    unsigned u;
    CHAR DriveLetter;
#ifdef _FAT32
    BOOLEAN Fat32;
#endif
#if NEC_98
    UCHAR Head,Sector;          // For Dos 3.x format
    ULONG Hidden_Sectors,lHead;
    UCHAR AL_Reg;
    CHAR OldBootsectDosName[] = "?:\\BOOTSECT.NEC";
#endif // NEC_98

    *PreviousOsText = NULL;
    DriveLetter = (CHAR)(Drive + (unsigned)'A');

    //
    // Read first sector of the boot drive.
    //
    if(!DnAbsoluteSectorIo(Drive,0L,1,BootSector,FALSE)) {
        return(FALSE);
    }

    //
    // Make sure the disk is formatted.
    //
    if(BootSector[21] != 0xf8) {
        return(FALSE);
    }

#ifdef _FAT32
    //
    // Determine if Fat32. Root dir entry count is 0 on Fat32.
    //
    Fat32 = TRUE;
    if(BootSector[17] || BootSector[18]) {
        Fat32 = FALSE;
    }
#endif

    //
    // Check for NT boot code. If it's there,
    // assume NT boot is already installed and we're done.
    // Also meaning that we assume boot.ini is there
    // and correct, so we don't need to worry about
    // the previous OS selection.
    //
    if( 1 ) {

#if NEC_98
#ifdef _FAT32
        BootTemplate = Fat32 ? PC98Fat32BootCode : PC98FatBootCode;
#else
        BootTemplate = PC98FatBootCode;
#endif
#else //NEC_98
#ifdef _FAT32
        BootTemplate = Fat32 ? Fat32BootCode : FatBootCode;
#else
        BootTemplate = FatBootCode;
#endif
#endif // NEC_98

        if( !DnpScanBootSector( BootSector, "NTLDR" ) ) {
            //
            // Write old boot sector to bootsect.dos.
            //
            BootsectDosName[0] = DriveLetter;
            _dos_setfileattr(BootsectDosName,_A_NORMAL);
    #if NEC_98
            OldBootsectDosName[0] = DriveLetter;
            _dos_setfileattr(OldBootsectDosName,_A_NORMAL);
            remove(OldBootsectDosName);
            _dos_setfileattr(BootsectDosName,_A_NORMAL);
            rename(BootsectDosName, OldBootsectDosName);
    #else
            remove(BootsectDosName);
    #endif

            if(_dos_creatnew(BootsectDosName,_A_SYSTEM | _A_HIDDEN, &h)) {
                return(FALSE);
            }

            u = _dos_write(h,BootSector,SECTOR_SIZE,&BytesWritten);

            _dos_close(h);

            if(u || (BytesWritten != SECTOR_SIZE)) {
                return(FALSE);
            }
        }
        //
        // Transfer bpb of old boot sector to NT boot code.
        //
        memmove(BootTemplate+3,BootSector+3,BootTemplate[1]-1);
#ifndef _FAT32
        //
        // The int13 unit number is elsewhere in fat32
        // No real need to do this in fat16 case either,
        // since the bpb on the disk should have the right value in it!
        //
        BootTemplate[36] = 0x80;
#endif

#ifdef _FAT32
        //
        // If FAT32 then we need to lay down the second boot sector,
        // which in the NT case is at sector 12. We do this first so
        // in case it fails the user isn't left with NT code on sector 0
        // that won't boot because the second part is missing from sector 12.
        //
        if(Fat32) {
            if(!DnAbsoluteSectorIo(Drive,12L,1,BootTemplate+1024,TRUE)) {
                return(FALSE);
            }
        }
#endif

#if NEC_98
        AL_Reg = TargetDA_UA;
        _asm{
            mov   ah,84h
            mov   al,AL_Reg
            int   1bh
            mov   Head,dh
            mov   Sector,dl
        }
        lHead = Head;
        Hidden_Sectors = lHead * Sector * Cylinders;
        (ULONG)BootTemplate[0x1c] = Hidden_Sectors;

        if((USHORT)BootTemplate[0x13] != 0){
            (ULONG)BootTemplate[0x20] = 0L;
        }
#endif // NEC_98

        //
        // Lay NT boot code onto the disk.
        //
        if(!DnAbsoluteSectorIo(Drive,0L,1,BootTemplate,TRUE)) {
            return(FALSE);
        }

        //
        // Determine previous OS if any.
        // We do this such that if the drive has been formatted
        // by another os but the os is not actually installed,
        // the right thing will happen.
        //

        if(DnpScanBootSector(BootSector,"MSDOS   SYS")) {
            if(DnpAreAllFilesPresent(DriveLetter,MsDosFileList)) {
                //
                // Both Chicago and MS-DOS share the same set of signature
                // files in C:\, so we must check IO.SYS to see if it has
                // a Win32 header.
                //
                if(DnpHasMZHeader(DriveLetter, "?:\\IO.SYS")) {  // it's Chicago
                    *PreviousOsText = DntMsWindows;
                } else {    // it's MS-DOS
                    *PreviousOsText = DntMsDos;
                }
            }
        } else {

#if NEC_98
            if(DnpScanBootSector(BootSector,"OS2")) {
                if(DnpAreAllFilesPresent(DriveLetter,Os2FileList)) {
                    *PreviousOsText = DntOs2;
                }
            } else {
                *PreviousOsText = DntPreviousOs;
            }
#else // NEC_98
            if(DnpScanBootSector(BootSector,"IBMDOS  COM")) {
                if(DnpAreAllFilesPresent(DriveLetter,PcDosFileList)) {
                    *PreviousOsText = DntPcDos;
                }
            } else {

                if(DnpScanBootSector(BootSector,"OS2")) {
                    if(DnpAreAllFilesPresent(DriveLetter,Os2FileList)) {
                        *PreviousOsText = DntOs2;
                    }
                } else {
                    *PreviousOsText = DntPreviousOs;
                }
            }
#endif // NEC_98
        }
    }

    //
    // Now we create the boot sector that we will use
    // to load $LDR$ (setupldr.bin) instead of ntldr.
    //
    if(!DnAbsoluteSectorIo(Drive,0L,1,BootSector,FALSE)) {
        return(FALSE);
    }

    //
    // Overwrite the 'NTLDR' string with '$LDR$' so the right file gets
    // loaded at boot time. Make sure to scan for the full 11 chars
    // so we don't find an error message in the bootcode by accident.
    //
    if(u = DnpScanBootSector(BootSector,"NTLDR      ")) {
        strncpy(BootSector+u,"$LDR$",5);
    }

    //
    // Write this into the correct file in the boot directory.
    //
    p = MALLOC(sizeof(FLOPPYLESS_BOOT_ROOT)+sizeof(FLOPPYLESS_BOOT_SEC)+2,TRUE);

    p[0] = DriveLetter;
    p[1] = ':';
    strcpy(p+2,FLOPPYLESS_BOOT_ROOT);
    strcat(p,"\\" FLOPPYLESS_BOOT_SEC);

    _dos_setfileattr(p,_A_NORMAL);
    if(_dos_creat(p,_A_NORMAL,&h)) {
        FREE(p);
        return(FALSE);
    }

    u = _dos_write(h,BootSector,SECTOR_SIZE,&BytesWritten);

    _dos_close(h);
    FREE(p);

    return((BOOLEAN)((u == 0) && (BytesWritten == SECTOR_SIZE)));
}


unsigned
DnpScanBootSector(
    IN PUCHAR BootSector,
    IN PUCHAR Pattern
    )
{
    unsigned len;
    unsigned i;

    len = strlen(Pattern);

    for(i=510-len; i>62; --i) {
        if(!memcmp(Pattern,BootSector+i,len)) {
            return(i);
        }
    }

    return(0);
}


BOOLEAN
DnpAreAllFilesPresent(
    IN CHAR   DriveLetter,
    IN PCHAR  FileList[]
    )
{
    unsigned i;
    struct find_t FindData;

    for(i=0; FileList[i]; i++) {

        FileList[i][0] = DriveLetter;

        if(_dos_findfirst(FileList[i],_A_RDONLY|_A_HIDDEN|_A_SYSTEM,&FindData)) {
            return(FALSE);
        }
    }

    return(TRUE);
}


BOOLEAN
DnpHasMZHeader(
    IN CHAR  DriveLetter,
    IN PCHAR Filename
    )
{
    FILE    *FileHandle;
    CHAR    Buffer[2];
    BOOLEAN Ret = FALSE;

    Filename[0] = DriveLetter;
    if(!(FileHandle = fopen(Filename, "rb"))) {
        return FALSE;
    }
    if(fread(Buffer, sizeof(CHAR), 2, FileHandle) == 2) {
        if((Buffer[0] == 'M') && (Buffer[1] == 'Z')) {
            Ret = TRUE;
        }
    }
    fclose(FileHandle);
    return Ret;
}


#if NEC_98
#else // NEC_98
BOOLEAN
DoPatchBootMessages(
    IN OUT PCHAR    BootCode,
    IN     unsigned OffsetOffset
    )
{
    unsigned Offset;

    //
    // Figure out exactly where in the boot code array the messages go.
    //
    Offset = (unsigned)(unsigned char)BootCode[OffsetOffset] + 256;

    //
    // Lay in the messages. The first message is the no system message.
    // The second is the I/O error message. The third is a common msg
    // instructing the user to hit a key.
    //
    // We also supply cr/lf and a special 255 char as punctuation that
    // is meaningful to the bootcode itself.
    //
    BootCode[OffsetOffset] = (UCHAR)(Offset-256);
    BootCode[Offset++] = 13;
    BootCode[Offset++] = 10;
    strcpy(BootCode+Offset,BootMsgNtldrIsMissing);
    Offset += strlen(BootMsgNtldrIsMissing);
    BootCode[Offset++] = (UCHAR)255;

    BootCode[OffsetOffset+1] = (UCHAR)(Offset-256);
    BootCode[Offset++] = 13;
    BootCode[Offset++] = 10;
    strcpy(BootCode+Offset,BootMsgDiskError);
    Offset += strlen(BootMsgDiskError);
    BootCode[Offset++] = (UCHAR)255;

    BootCode[OffsetOffset+2] = (UCHAR)(Offset-256);
    BootCode[Offset++] = 13;
    BootCode[Offset++] = 10;
    strcpy(BootCode+Offset,BootMsgPressKey);
    Offset += strlen(BootMsgPressKey);
    BootCode[Offset++] = 13;
    BootCode[Offset++] = 10;
    BootCode[Offset] = 0;

    return((BOOLEAN)(Offset < OffsetOffset));
}
#endif // NEC_98

#if NEC_98
#else // NEC_98
BOOLEAN
PatchMessagesIntoBootCode(
    VOID
    )
{
    return((BOOLEAN)(DoPatchBootMessages(FatBootCode,507) && DoPatchBootMessages(Fat32BootCode,505)));
}
#endif // NEC_98

#if NEC_98
VOID
RestoreBootcode(VOID)
/*++

Routine Description:

    On floppyless setup if user have canceled setup or setup be stopped by error
    occurred,previous OS can't boot to be written boot code and boot loader.

Arguments:

    None.

Return Value:

    None.

--*/

{
    CHAR DriveLetter;
    CHAR Drive;
    PCHAR Buffer;
    PCHAR FileName;
    int h;
    CHAR i;
    unsigned line = 0;
    unsigned count;
    UCHAR chDeviceName[127];
    UCHAR TargetPass[127];
    CHAR BootsectDosName[] = "?:\\BOOTSECT.DOS";
    CHAR FloppylessDir[]   = "?:\\$WIN_NT$.~BT";
    CHAR Current_Drv[]     = "?:\0";
    PCHAR DeleteFilesList[] = {"TXTSETUP.SIF","$LDR$","NTDETECT.COM","NTLDR","BOOT.INI"};


    Buffer = MALLOC(2*1024,TRUE);
    memset(Buffer,0,sizeof(2*1024));
    if(DngTargetDriveLetter == 0){ return; }

    DriveLetter = (CHAR)toupper(DngTargetDriveLetter);
    BootsectDosName[0] = DriveLetter;
    FloppylessDir[0]   = DriveLetter;

    if(!DngFloppyless && !(access(FloppylessDir,00) == 0)){ return; }

    if(access(BootsectDosName,00) == 0) {
        _dos_setfileattr(BootsectDosName,_A_NORMAL);
        _dos_open(BootsectDosName,O_RDONLY,&h);
        _dos_read(h,Buffer,512,&count);
        _dos_close(h);

        Drive = (CHAR)(DriveLetter - (unsigned)'A');
        //
        // Recopy bootsect.dos -> Target drive
        //
        DnAbsoluteSectorIo(Drive,0L,1,Buffer,TRUE);
        remove(BootsectDosName);     // Delete bootsect.dos
    }

    //
    // Delete Root Files($LDR$,NTLDR,etc..)
    //
    for(i=0; i < 5; i++){
        //
        // Delete Root Files($LDR$,NTLDR,etc..)
        //
        memset(chDeviceName,0,sizeof(chDeviceName));
        sprintf(chDeviceName,"%c:\\",DriveLetter);
        strcpy(chDeviceName+3,DeleteFilesList[i]);

        if(access(chDeviceName,00) == 0) {
            _dos_setfileattr(chDeviceName,_A_NORMAL);
            remove(chDeviceName);
        }
    }

    //
    // Check: Exist $WIN_NT$.~BU Directry.
    //
    memset(chDeviceName,0,sizeof(chDeviceName));
    chDeviceName[0] = (UCHAR)DriveLetter;
    chDeviceName[1] = (UCHAR)(':');
    strcpy(chDeviceName+2,"\\$WIN_NT$.~BU");

    if(access(chDeviceName,00) == 0) {
        //
        // Copy: $WIN_NT$.~BU -> Root Directry
        //
        Current_Drv[0] = DriveLetter;
        DnCopyFilesInSection(NULL, DnfBackupFiles_PC98,chDeviceName,Current_Drv);

        //
        // Set root files Attribute.
        //
        while(FileName = DnGetSectionLineIndex(DngInfHandle,DnfBackupFiles_PC98,line++,0)) {
            memset(TargetPass,0,sizeof(TargetPass));
            sprintf(TargetPass,"%c:\\",DriveLetter);
            strcpy(TargetPass+3,FileName);
            _dos_setfileattr(TargetPass,_A_ARCH | _A_HIDDEN | _A_RDONLY | _A_SYSTEM);
            FREE (FileName);
        }
        DnDelnode(chDeviceName);
        remove(chDeviceName);
    }
    DnDelnode(FloppylessDir);
}
#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\dndelnod.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dndelnod.c

Abstract:

    Delnode routine for winnt.

Author:

    Ted Miller (tedm) August 1992

--*/

#include "winnt.h"
#include <string.h>
#include <dos.h>
#include <io.h>
#include <direct.h>

#define MAX_PATH 256

//
// This number here is probably a lot larger than necessary; this is
// the static number of find-data blobs below.  Will we ever have a
// path depth larger than 32?  If so, we'll heap allocate.
//
#define FIND_DATA_COUNT ( 32 )

//
// Put this out here to cut stack consumption.
//
CHAR Pattern[MAX_PATH+1];

//
// A static array of these should clean up all stack corruption/overflow
// problems.
// 
struct find_t FindDataList[FIND_DATA_COUNT];
unsigned FindDataIndex;

VOID
DnpDelnodeWorker(
    VOID
    )

/*++

Routine Description:

    Delete all files in a directory, and make recursive calls for any
    directories found in the directory.

Arguments:

    None.  The Pattern variable should contain the name of the directory
    whose files are to be deleted.

Return Value:

    None.

--*/

{
    PCHAR PatternEnd;

    //
    // Pointer into the global pseudostack of find_t structures above.
    //    
    struct find_t *pFindData;

    //
    // Did we allocate the find data off the heap or from the list above?
    //
    BOOLEAN HeapAllocatedFindData = FALSE;

    //
    // Delete each file in the directory, then remove the directory itself.
    // If any directories are encountered along the way recurse to delete
    // them as they are encountered.
    //

    PatternEnd = Pattern+strlen(Pattern);
    strcat(Pattern,"\\*.*");

    //
    // Ensure we've got a find data object for this run.
    //
    if ( FindDataIndex < FIND_DATA_COUNT ) {
    
        //
        // Point the current find data object into the find data list
        // at the next available entry.
        //
        pFindData = FindDataList + FindDataIndex++;
        HeapAllocatedFindData = FALSE;

    } else {

        //
        // Otherwise, try to allocate from the heap.  If this fails, we're
        // up a creek.  (Keep track of whether we did this from the
        // heap or not, as well.)
        //
        pFindData = MALLOC(sizeof(struct find_t), TRUE);
        
        if ( pFindData != NULL ) {
        
            HeapAllocatedFindData = TRUE;

        }

    }
    

    if(!_dos_findfirst(Pattern,_A_HIDDEN|_A_SYSTEM|_A_SUBDIR,pFindData)) {

        do {

            //
            // Form the full name of the file we just found.
            //

            strcpy(PatternEnd+1,pFindData->name);

            //
            // Remove read-only atttribute if it's there.
            //

            if(pFindData->attrib & _A_RDONLY) {
                _dos_setfileattr(Pattern,_A_NORMAL);
            }

            if(pFindData->attrib & _A_SUBDIR) {

                //
                // The current match is a directory.  Recurse into it unless
                // it's . or ...
                //

                if(strcmp(pFindData->name,".") && strcmp(pFindData->name,"..")) {
                    DnpDelnodeWorker();
                }

            } else {

                //
                // The current match is not a directory -- so delete it.
                //
                DnWriteStatusText(DntRemovingFile,Pattern);
                remove(Pattern);
            }

            *(PatternEnd+1) = 0;

        } while(!_dos_findnext(pFindData));
    }

    //
    // Remove the directory we just emptied out.
    //

    *PatternEnd = 0;
    DnWriteStatusText(DntRemovingFile,Pattern);

    _dos_setfileattr(Pattern,_A_NORMAL);

    if(!_dos_findfirst(Pattern,_A_HIDDEN|_A_SYSTEM|_A_SUBDIR,pFindData)
    && (pFindData->attrib & _A_SUBDIR))
    {
        rmdir(Pattern);
    } else {
        remove(Pattern);
    }

    if ( HeapAllocatedFindData && ( pFindData != NULL ) ) {
    
        FREE( pFindData );
        
    } else {
    
        //
        // Pop an entry off the find data array
        //    
        FindDataIndex--;

    }
}



VOID
DnDelnode(
    IN PCHAR Directory
    )

/*++

Routine Description:

    Delete all files in a directory tree rooted at a given path.

Arguments:

    Directory - supplies full path to the root of the subdirectory to be
        removed. If this is actually a file, the file will be deleted.

Return Value:

    None.

--*/

{
    DnClearClientArea();
    DnDisplayScreen(&DnsWaitCleanup);
    
    
    strcpy(Pattern,Directory);
    FindDataIndex = 0;
    
    DnpDelnodeWorker();
}



VOID
DnRemoveLocalSourceTrees(
    VOID
    )

/*++

Routine Description:

    Scan for local source trees on local hard drives and delnode them.

Arguments:

    None.

Return Value:

    None.

--*/

{
    struct find_t FindData;
    CHAR Filename[sizeof(LOCAL_SOURCE_DIRECTORY) + 2];
    unsigned Drive;

    Filename[1] = ':';
    strcpy(Filename+2,LocalSourceDirName);

    DnWriteStatusText(DntInspectingComputer);
    DnClearClientArea();

    for(Filename[0]='A',Drive=1; Filename[0]<='Z'; Filename[0]++,Drive++) {

        if(DnIsDriveValid(Drive)
        && !DnIsDriveRemote(Drive,NULL)
        && !DnIsDriveRemovable(Drive)
        && !_dos_findfirst(Filename,_A_HIDDEN|_A_SYSTEM|_A_SUBDIR,&FindData))
        {
            DnDelnode(Filename);

            DnWriteStatusText(DntInspectingComputer);
            DnClearClientArea();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\dndisp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dndisp.c

Abstract:

    DOS-based NT setup program video display routines.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"
#include <string.h>


#define SCREEN_WIDTH        80
#define SCREEN_HEIGHT       25

#define STATUS_HEIGHT       1
#define STATUS_LEFT_MARGIN  2
#define HEADER_HEIGHT       3

//
// Display attributes
//

#define ATT_FG_BLACK        0
#define ATT_FG_BLUE         1
#define ATT_FG_GREEN        2
#define ATT_FG_CYAN         3
#define ATT_FG_RED          4
#define ATT_FG_MAGENTA      5
#define ATT_FG_YELLOW       6
#define ATT_FG_WHITE        7

#define ATT_BG_BLACK       (ATT_FG_BLACK   << 4)
#define ATT_BG_BLUE        (ATT_FG_BLUE    << 4)
#define ATT_BG_GREEN       (ATT_FG_GREEN   << 4)
#define ATT_BG_CYAN        (ATT_FG_CYAN    << 4)
#define ATT_BG_RED         (ATT_FG_RED     << 4)
#define ATT_BG_MAGENTA     (ATT_FG_MAGENTA << 4)
#define ATT_BG_YELLOW      (ATT_FG_YELLOW  << 4)
#define ATT_BG_WHITE       (ATT_FG_WHITE   << 4)

#define ATT_FG_INTENSE      8
#define ATT_BG_INTENSE     (ATT_FG_INTENSE << 4)

#define DEFAULT_ATTRIBUTE   (ATT_FG_WHITE | ATT_BG_BLUE)
#define STATUS_ATTRIBUTE    (ATT_FG_BLACK | ATT_BG_WHITE)
#define EDIT_ATTRIBUTE      (ATT_FG_BLACK | ATT_BG_WHITE)
#define EXITDLG_ATTRIBUTE   (ATT_FG_RED   | ATT_BG_WHITE)
#define GAUGE_ATTRIBUTE     (ATT_BG_BLUE  | ATT_FG_YELLOW | ATT_FG_INTENSE)


// #define USE_INT10
#ifndef USE_INT10
//
// Far address of the screen buffer.
//
#define SCREEN_BUFFER ((UCHAR _far *)0xb8000000)
#define SCREEN_BUFFER_CHR(x,y)  *(SCREEN_BUFFER + (2*((x)+(SCREEN_WIDTH*(y)))))
#define SCREEN_BUFFER_ATT(x,y)  *(SCREEN_BUFFER + (2*((x)+(SCREEN_WIDTH*(y))))+1)

BOOLEAN CursorIsActuallyOn;
#endif


//
// Make these near because they are used in _asm blocks
//
UCHAR _near CurrentAttribute;
UCHAR _near ScreenX;
UCHAR _near ScreenY;

BOOLEAN CursorOn;


VOID
DnpBlankScreenArea(
    IN UCHAR Attribute,
    IN UCHAR Left,
    IN UCHAR Right,
    IN UCHAR Top,
    IN UCHAR Bottom
    );


VOID
DnInitializeDisplay(
    VOID
    )

/*++

Routine Description:

    Put the display in a known state (80x25 standard text mode) and
    initialize the display package.

Arguments:

    None.

Return Value:

    None.

--*/

{
    CurrentAttribute = DEFAULT_ATTRIBUTE;
    CursorOn = FALSE;

    //
    // Set the display to standard 80x25 mode
    //

    _asm {
        mov ax,3        // set video mode to 3
        int 10h
    }

    //
    // Clear the entire screen
    //

    DnpBlankScreenArea(CurrentAttribute,0,SCREEN_WIDTH-1,0,SCREEN_HEIGHT-1);
    DnPositionCursor(0,0);

#ifndef USE_INT10
    //
    // Shut the cursor off.
    //
    _asm {
        mov ah,2        // function -- position cursor
        mov bh,0        // display page
        mov dh,SCREEN_HEIGHT
        mov dl,0
        int 10h
    }

    CursorIsActuallyOn = FALSE;
#endif
}


VOID
DnClearClientArea(
    VOID
    )

/*++

Routine Description:

    Clear the client area of the screen, ie, the area between the header
    and status line.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DnpBlankScreenArea( CurrentAttribute,
                        0,
                        SCREEN_WIDTH-1,
                        HEADER_HEIGHT,
                        SCREEN_HEIGHT - STATUS_HEIGHT - 1
                      );

    DnPositionCursor(0,HEADER_HEIGHT);
}


VOID
DnSetGaugeAttribute(
    IN BOOLEAN Set
    )

/*++

Routine Description:

    Prepare for drawing the thermometer portion of a gas gauge.

Arguments:

    Set - if TRUE, prepare for drawing the thermometer.  If FALSE, restore
        the state for normal drawing.

Return Value:

    None.

--*/

{
    static UCHAR SavedAttribute = 0;

    if(Set) {
        if(!SavedAttribute) {
            SavedAttribute = CurrentAttribute;
            CurrentAttribute = GAUGE_ATTRIBUTE;
        }
    } else {
        if(SavedAttribute) {
            CurrentAttribute = SavedAttribute;
            SavedAttribute = 0;
        }
    }
}


VOID
DnPositionCursor(
    IN UCHAR X,
    IN UCHAR Y
    )

/*++

Routine Description:

    Position the cursor.

Arguments:

    X,Y - cursor coords

Return Value:

    None.

--*/

{
    if(X >= SCREEN_WIDTH) {
        X = 0;
        Y++;
    }

    if(Y >= SCREEN_HEIGHT) {
        Y = HEADER_HEIGHT;
    }

    ScreenX = X;
    ScreenY = Y;

    //
    // Invoke BIOS
    //

    _asm {
        mov ah,2        // function -- position cursor
        mov bh,0        // display page
        mov dh,ScreenY
        mov dl,ScreenX
        int 10h
    }

#ifndef USE_INT10
    CursorIsActuallyOn = TRUE;
#endif
}


VOID
DnWriteChar(
    IN CHAR chr
    )

/*++

Routine Description:

    Write a character in the current attribute at the current position.

Arguments:

    chr - Character to write

Return Value:

    None.

--*/

{
    if(chr == '\n') {
        ScreenX = 0;
        ScreenY++;
        return;
    }

#ifdef USE_INT10
    //
    // Position the cursor (turns it on)
    //

    DnPositionCursor(ScreenX,ScreenY);

    //
    // Output the character
    //

    _asm {
        mov ah,9        // function -- write char/attribute pair
        mov al,chr
        mov bh,0        // display page
        mov bl,CurrentAttribute
        mov cx,1        // replication factor
        int 10h
    }

    //
    // If the cursor is supposed to be off, shut it off
    //

    if(!CursorOn) {
        _asm {
            mov ah,2        // function -- position cursor
            mov bh,0        // display page
            mov dh,SCREEN_HEIGHT
            mov dl,0
            int 10h
        }
    }
#else

    //
    // Don't draw outside the actual screen boundaries
    //
    if ( ( ScreenX < SCREEN_WIDTH ) && ( ScreenY < SCREEN_HEIGHT ) ) {
        SCREEN_BUFFER_CHR(ScreenX,ScreenY) = chr;
        SCREEN_BUFFER_ATT(ScreenX,ScreenY) = CurrentAttribute;
    }
    

    //
    // shut cursor off if necessary
    //
    if(!CursorOn && CursorIsActuallyOn) {
        CursorIsActuallyOn = FALSE;
        _asm {
            mov ah,2        // function -- position cursor
            mov bh,0        // display page
            mov dh,SCREEN_HEIGHT
            mov dl,0
            int 10h
        }
    }
#endif
}

VOID
DnWriteString(
    IN PCHAR String
    )

/*++

Routine Description:

    Write a string on the client area in the current position and
    adjust the current position.  The string is written in the current
    attribute.

Arguments:

    String - null terminated string to write.

Return Value:

    None.

--*/

{
    PCHAR p;

    for(p=String; *p; p++) {
        DnWriteChar(*p);
        if(*p != '\n') {
            ScreenX++;
        }
    }
}



VOID
DnWriteStatusText(
    IN PCHAR FormatString OPTIONAL,
    ...
    )

/*++

Routine Description:

    Update the status area

Arguments:

    FormatString - if present, supplies a printf format string for the
        rest of the arguments.  Otherwise the status area is cleared out.

Return Value:

    None.

--*/

{
    va_list arglist;
    int StringLength;
    static CHAR String[SCREEN_WIDTH+1];
    UCHAR SavedAttribute;

    //
    // First, clear out the status area.
    //

    DnpBlankScreenArea( STATUS_ATTRIBUTE,
                        0,
                        SCREEN_WIDTH-1,
                        SCREEN_HEIGHT-STATUS_HEIGHT,
                        SCREEN_HEIGHT-1
                      );

    if(FormatString) {

        va_start(arglist,FormatString);
        StringLength = vsnprintf(String,SCREEN_WIDTH+1,FormatString,arglist);
        String[SCREEN_WIDTH] = '\0';

        SavedAttribute = CurrentAttribute;
        CurrentAttribute = STATUS_ATTRIBUTE;

        DnPositionCursor(STATUS_LEFT_MARGIN,SCREEN_HEIGHT - STATUS_HEIGHT);

        DnWriteString(String);

        CurrentAttribute = SavedAttribute;
    }
}


VOID
DnSetCopyStatusText(
    IN PCHAR Caption,
    IN PCHAR Filename
    )

/*++

Routine Description:

    Write or erase a copying message in the lower right part of the screen.

Arguments:

    Filename - name of file currently being copied.  If NULL, erases the
        copy status area.

Return Value:

    None.

--*/

{
    unsigned CopyStatusAreaLen;
    CHAR StatusText[100];

    //
    // The 13 is for 8.3 and a space
    //

    CopyStatusAreaLen = strlen(Caption) + 13;

    //
    // First erase the status area.
    //

    DnpBlankScreenArea( STATUS_ATTRIBUTE,
                        (UCHAR)(SCREEN_WIDTH - CopyStatusAreaLen),
                        SCREEN_WIDTH - 1,
                        SCREEN_HEIGHT - STATUS_HEIGHT,
                        SCREEN_HEIGHT - 1
                      );

    if(Filename) {

        UCHAR SavedAttribute;
        UCHAR SavedX,SavedY;

        SavedAttribute = CurrentAttribute;
        SavedX = ScreenX;
        SavedY = ScreenY;

        CurrentAttribute = STATUS_ATTRIBUTE;
        DnPositionCursor((UCHAR)(SCREEN_WIDTH-CopyStatusAreaLen),SCREEN_HEIGHT-1);

        memset(StatusText,0,sizeof(StatusText));
        strcpy(StatusText,Caption);
        strncpy(StatusText + strlen(StatusText),Filename,12);

        DnWriteString(StatusText);

        CurrentAttribute = SavedAttribute;
        ScreenX = SavedX;
        ScreenY = SavedY;
    }
}



VOID
DnStartEditField(
    IN BOOLEAN CreateField,
    IN UCHAR X,
    IN UCHAR Y,
    IN UCHAR W
    )

/*++

Routine Description:

    Sets up the display package to start handling an edit field.

Arguments:

    CreateField - if TRUE, caller is starting an edit field interaction.
        If FALSE, he is ending one.

    X,Y,W - supply coords and width in chars of the edit field.

Return Value:

    None.

--*/

{
    static UCHAR SavedAttribute = 255;

    CursorOn = CreateField;

    if(CreateField) {

        if(SavedAttribute == 255) {
            SavedAttribute = CurrentAttribute;
            CurrentAttribute = EDIT_ATTRIBUTE;
        }

        DnpBlankScreenArea(EDIT_ATTRIBUTE,X,(UCHAR)(X+W-1),Y,Y);

    } else {

        if(SavedAttribute != 255) {
            CurrentAttribute = SavedAttribute;
            SavedAttribute = 255;
        }
    }
}


VOID
DnExitDialog(
    VOID
    )
{
    unsigned W,H,X,Y,i;
    PUCHAR CharSave;
    PUCHAR AttSave;
    ULONG Key,ValidKeys[3] = { ASCI_CR,DN_KEY_F3,0 };
    UCHAR SavedX,SavedY,SavedAttribute;
#ifndef USE_INT10
    BOOLEAN SavedCursorState = CursorOn;
#endif

    SavedAttribute = CurrentAttribute;
    CurrentAttribute = EXITDLG_ATTRIBUTE;

    SavedX = ScreenX;
    SavedY = ScreenY;

#ifndef USE_INT10
    //
    // Shut the cursor off.
    //
    CursorIsActuallyOn = FALSE;
    CursorOn = FALSE;
    _asm {
        mov ah,2        // function -- position cursor
        mov bh,0        // display page
        mov dh,SCREEN_HEIGHT
        mov dl,0
        int 10h
    }
#endif

    //
    // Count lines in the dialog and determine its width.
    //
    for(H=0; DnsExitDialog.Strings[H]; H++);
    W = strlen(DnsExitDialog.Strings[0]);

    //
    // allocate two buffers for character save and attribute save
    //
    CharSave = MALLOC(W*H,TRUE);
    AttSave = MALLOC(W*H,TRUE);

    //
    // save the screen patch
    //
    for(Y=0; Y<H; Y++) {
        for(X=0; X<W; X++) {

            UCHAR att,chr;
            UCHAR x,y;

            x = (UCHAR)(X + DnsExitDialog.X);
            y = (UCHAR)(Y + DnsExitDialog.Y);

#ifdef USE_INT10
            _asm {

                // first position cursor
                mov ah,2
                mov bh,0
                mov dh,y
                mov dl,x
                int 10h

                // now read the char/att at the cursor
                mov ah,8
                mov bh,0
                int 10h
                mov att,ah
                mov chr,al
            }
#else
            chr = SCREEN_BUFFER_CHR(x,y);
            att = SCREEN_BUFFER_ATT(x,y);
#endif

            CharSave[Y*W+X] = chr;
            AttSave[Y*W+X] = att;
        }
    }

    //
    // Put up the dialog
    //

    for(i=0; i<H; i++) {
        DnPositionCursor(DnsExitDialog.X,(UCHAR)(DnsExitDialog.Y+i));
        DnWriteString(DnsExitDialog.Strings[i]);
    }

    CurrentAttribute = SavedAttribute;

    //
    // Wait for a valid keypress
    //

    Key = DnGetValidKey(ValidKeys);
    if(Key == DN_KEY_F3) {
        DnExit(1);
    }

    //
    // Restore the patch
    //
    for(Y=0; Y<H; Y++) {
        for(X=0; X<W; X++) {

            UCHAR att,chr;
            UCHAR x,y;

            x = (UCHAR)(X + DnsExitDialog.X);
            y = (UCHAR)(Y + DnsExitDialog.Y);

            chr = CharSave[Y*W+X];
            att = AttSave[Y*W+X];

#ifdef USE_INT10
            _asm {

                // first position cursor
                mov ah,2
                mov bh,0
                mov dh,y
                mov dl,x
                int 10h

                // now write the char/att at the cursor
                mov ah,9
                mov al,chr
                mov bh,0
                mov bl,att
                mov cx,1
                int 10h
            }
#else
            SCREEN_BUFFER_CHR(x,y) = chr;
            SCREEN_BUFFER_ATT(x,y) = att;
#endif
        }
    }

    FREE(CharSave);
    FREE(AttSave);

#ifndef USE_INT10
    CursorOn = SavedCursorState;
#endif

    if(CursorOn) {
        DnPositionCursor(SavedX,SavedY);
    } else {
        ScreenX = SavedX;
        ScreenY = SavedY;
        _asm {
            mov ah,2
            mov bh,0
            mov dh,SCREEN_HEIGHT;
            mov dl,0
            int 10h
        }
#ifndef USE_INT10
        CursorIsActuallyOn = FALSE;
#endif
    }
}



//
// Internal support routines
//
VOID
DnpBlankScreenArea(
    IN UCHAR Attribute,
    IN UCHAR Left,
    IN UCHAR Right,
    IN UCHAR Top,
    IN UCHAR Bottom
    )

/*++

Routine Description:

    Invoke the BIOS to blank a region of the screen.

Arguments:

    Attribute - screen attribute to use to blank the region

    Left,Right,Top,Bottom - coords of region to blank

Return Value:

    None.

--*/

{
#ifdef USE_INT10
    //
    // Invoke the BIOS
    //

    _asm {
        mov ah,6                    // function number -- scroll window up
        xor al,al                   // function code -- blank window
        mov bh,Attribute
        mov ch,Top
        mov cl,Left
        mov dh,Bottom
        mov dl,Right
        int 10h
    }
#else
    UCHAR x,y;

    for(y=Top; y<=Bottom; y++) {
        for(x=Left; x<=Right; x++) {
            SCREEN_BUFFER_CHR(x,y) = ' ';
            SCREEN_BUFFER_ATT(x,y) = Attribute;
        }
    }
#endif
}


int
DnGetGaugeChar(
    VOID
    )
{
    return(0xdb);   //inverse square in cp437, 850, etc.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\dncompv.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dncompv.c

Abstract:

    Code for determining whether volumes are compressed (DoubleSpace,
    Stacker, etc).

Author:

    Ted Miller (tedm) 1-April-1993

Revision History:

--*/

#include "winnt.h"
#include "dncompvp.h"


/****************************************************************************
*
*  WORD IsStackerLoaded (uchar *pchSwappedDrives)
*
*      Returns NZ if Stacker driver loaded.
*
*  Parameters:
*      pchSwappedDrives - array[26] to return swapped drives in.
*          To find out if a drive is swapped, look at pchSwappedDrives[Drive].
*          If pchSwappedDrives[Drive] == Drive, drive isn't swapped.
*          Otherwise, pchSwappedDrives[Drive] = drive it's swapped with.
*
*  Return Value:
*      0 if not loaded, else version# * 100.
****************************************************************************/

//uint IsStackerLoaded (uchar *paucSwappedDrives)
unsigned IsStackerLoaded (unsigned char *paucSwappedDrives)
{
    unsigned rc;

   _asm {

    sub     sp, 1024
    mov     ax, 0cdcdh
    mov     bx, sp
    mov     cx, 1
    xor     dx, dx
    mov     word ptr [bx], dx
    push    ds
    pop     es
    push    bp
    mov     bp, bx
    int     25h
    pop     cx                      ; Int25h leaves flags on stack.  Nuke them.
    pop     bp
    xor     ax, ax
    mov     bx, sp
    cmp     word ptr [bx], 0CDCDh
    jnz     sl_exit
    cmp     word ptr 2[bx], 1
    jnz     sl_exit
    les     di, 4[bx]
    cmp     word ptr es:[di], 0A55Ah
    jnz     sl_exit
;    mov     word ptr st_ptr, di
;    mov     word ptr st_ptr+2, es
    mov     ax, es:[di+2]
    cmp     ax, 200d
    jb      sl_exit

    ;
    ; Sanity Check, make sure 'SWAP' is at es:di+52h
    ;
;    cmp     word ptr es:[di+52h],'WS'
    cmp     word ptr es:[di+52h], 05753h
    jnz     sl_exit                         ; AX contains version.

;    cmp     word ptr es:[di+54h],'PA'
    cmp     word ptr es:[di+54h], 05041h
    jnz     sl_exit                         ; AX contains version.

    ;
    ; Copy swapped drive array.
    push    ds                      ; Save DS
    ;
    ; Source is _StackerPointer + 56h.
    ;
    push    es
    pop     ds
    mov     ax, di
    add     ax, 56h
    mov     si, ax

    push    es
    push    di

    ;
    ; Destination is ss:paucSwappedDrives
    ;

    les     di, paucSwappedDrives
    ;mov     di, paucSwappedDrives   ; SwappedDrives array is stack relative.
    ;push    ss
    ;pop     es

    mov     cx, 26d                 ; Copy 26 bytes.
    cld
    rep     movsb                   ; Copy array.

    pop     di                      ; Restore _StackerPointer.
    pop     es
    pop     ds                      ; Restore DS

    mov     ax, es:[di+2]               ; Get version number of stacker, again.

sl_exit:
    mov     word ptr [rc],ax        ; do this to prevent compiler warning
    add     sp, 1024
   }

   return(rc);                      // do this to prevent compiler warning
}


/***    DRVINFO.C - IsDoubleSpaceDrive function
 *
#ifdef EXTERNAL
 *      Version 1.00.03 - 5 January 1993
#else
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1992-1993
 *      All Rights Reserved.
 *
 *      History:
 *          27-Sep-1992 bens    Initial version
 *          06-Nov-1992 bens    Improved comments
 *          05-Jan-1993 bens    Update for external release
#endif
 */

/***    IsDoubleSpaceDrive - Get information on a DoubleSpace drive
 *
 *      Entry:
 *          drive     - Drive to test (0=A, 1=B, etc.)
 *                      NOTE: No parameter checking is done on drive.
 *          pdrHost   - Receives drive number of host drive
 *          pfSwapped - Receives TRUE/FALSE indicating if drive is swapped.
 *          pseq      - Receives CVFs sequence number if DoubleSpace drive
 *
 *      Exit:
 *          returns TRUE, if DoubleSpace drive:
 *              *pdrHost   = current drive number of host drive (0=A,...)
 *              *pfSwapped = TRUE, if drive is swapped with host,
 *                           FALSE, if drive is not swapped with host
 *              *pseq      = CVF sequence number (always zero if swapped
 *                             with host drive)
 *
 *                           NOTE: The full file name of the CVF is:
 *                                   *pdrHost:\DBLSPACE.*pseq
 *
 *                               pdrHost  pseq  Full Path
 *                               -------  ----  -----------
 *                                  0       1   a:\dblspace.001
 *                                  3       0   d:\dblspace.000
 *
 *          returns FALSE, if *not* DoubleSpace drive:
 *              *pdrHost   = drive number of host drive at boot time
 *              *pfSwapped = TRUE, if swapped with a DoubleSpace drive
 *                           FALSE, if not swapped with a DoubleSpace drive
 */
BOOL IsDoubleSpaceDrive(BYTE drive, BOOL *pfSwapped, BYTE *pdrHost, int *pseq)
{
    BYTE        seq;
    BYTE        drHost;
    BOOL        fSwapped;
    BOOL        fDoubleSpace;

    // Assume drive is a normal, non-host drive
    drHost = drive;
    fSwapped = FALSE;
    fDoubleSpace = FALSE;
    seq = 0;

    _asm
    {
        mov     ax,4A11h        ; DBLSPACE.BIN INT 2F number
        mov     bx,1            ; bx = GetDriveMap function
        mov     dl,drive        ;
        int     2Fh             ; (bl AND 80h) == DS drive flag
                                ; (bl AND 7Fh) == host drive

        or      ax,ax           ; Success?
        jnz     gdiExit         ;    NO, DoubleSpace not installed

        test    bl,80h          ; Is the drive compressed?
        jz      gdiHost         ;    NO, could be host drive

        ; We have a DoubleSpace Drive, need to figure out host drive.
        ;
        ; This is tricky because of the manner in which DBLSPACE.BIN
        ; keeps track of drives.
        ;
        ; For a swapped CVF, the current drive number of the host
        ; drive is returned by the first GetDriveMap call.  But for
        ; an unswapped CVF, we must make a second GetDriveMap call
        ; on the "host" drive returned by the first call.  But, to
        ; distinguish between swapped and unswapped CVFs, we must
        ; make both of these calls.  So, we make them, and then check
        ; the results.

        mov     fDoubleSpace,1  ; Drive is DS drive
        mov     seq,bh          ; Save sequence number

        and     bl,7Fh          ; bl = "host" drive number
        mov     drHost,bl       ; Save 1st host drive
        mov     dl,bl           ; Set up for query of "host" drive

        mov     ax,4A11h        ; DBLSPACE.BIN INT 2F number
        mov     bx,1            ; bx = GetDriveMap function
        int     2Fh             ; (bl AND 7Fh) == 2nd host drive

        and     bl,7Fh          ; bl = 2nd host drive
        cmp     bl,drive        ; Is host of host of drive itself?
        mov     fSwapped,1      ; Assume CVF is swapped
        je      gdiExit         ;   YES, CVF is swapped

        mov     fSwapped,0      ;   NO, CVF is not swapped
        mov     drHost,bl       ; True host is 2nd host drive
        jmp     short gdiExit

    gdiHost:
        and     bl,7Fh          ; bl = host drive number
        cmp     bl,dl           ; Is drive swapped?
        je      gdiExit         ;    NO

        mov     fSwapped,1      ;    YES
        mov     drHost,bl       ; Set boot drive number

    gdiExit:
    }

    *pdrHost   = drHost;
    *pfSwapped = fSwapped;
    *pseq      = seq;
    return fDoubleSpace;
}

///////////////////////////////////////////////////////////////////////////////

BOOLEAN
DnIsDriveCompressedVolume(
    IN  unsigned  Drive,
    OUT unsigned *HostDrive
    )

/*++

Routine Description:

    Determine whether a drive is actually a compressed volume.
    Currently we detect Stacker and DoubleSpace volumes.

Arguments:

    Drive - drive (1=A, 2=B, etc).

Return Value:

    TRUE if drive is non-host compressed volume.
    FALSE if not.

--*/

{
    static BOOLEAN StackerMapBuilt = FALSE;
    static unsigned StackerLoaded = 0;
    static unsigned char StackerSwappedDrives[26];
    BOOL Swapped;
    BYTE Host;
    int Seq;

    Drive--;

    if(!StackerMapBuilt) {
        StackerLoaded = IsStackerLoaded(StackerSwappedDrives);
        StackerMapBuilt = TRUE;
    }

    if(StackerLoaded && (StackerSwappedDrives[Drive] != (UCHAR)Drive)) {
        *HostDrive = StackerSwappedDrives[Drive];
        return(TRUE);
    }

    if(IsDoubleSpaceDrive((BYTE)(Drive),&Swapped,&Host,&Seq)) {
        *HostDrive = Host+1;
        return(TRUE);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\dngauge.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dngauge.c

Abstract:

    Code implementing a gas gauge for file copies for DOS-hosted NT Setup.

Author:

    Ted Miller (tedm) 14-April-1992

Revision History:

--*/


#include "winnt.h"
#include <string.h>


unsigned FileCount;
unsigned FilesCopied;
unsigned CurrentPercent;

int GaugeChar;

VOID
DnInitGauge(
    IN unsigned NumberOfFiles,
    IN PSCREEN  AdditionalScreen OPTIONAL
    )

/*++

Routine Description:

    Initialize the gas gauge.  This includes drawing the gas gauge at 0%
    and setting some global variables.

Arguments:

    NumberOfFiles - supplies total number of files that 100% represents.

    Screen - If specified, supplies a screen to display along with the
        gas gauge.

Return Value:

    None.

--*/

{
    FileCount = NumberOfFiles;
    FilesCopied = 0;
    CurrentPercent = 0;
    GaugeChar = DnGetGaugeChar();

    DnDrawGauge(AdditionalScreen);
}


VOID
DnpRepaintGauge(
    IN BOOLEAN ForceRepaint
    )

/*++

Routine Description:

    Draw the entire gauge inits current state.

Arguments:

    ForceRepaint - if TRUE, the gauge is redrawn even if the percentage
        hasn't changed since the last time the gauge was redrawn.

Return Value:

    None.

--*/

{
    unsigned PercentComplete;
    unsigned temp;
    char Therm[GAUGE_WIDTH+1];
    unsigned SpacesOnScreen;
#ifdef CODEPAGE_437
    BOOLEAN HalfSpace;
#endif


    if(!FileCount) {
        return;
    }

    //
    // Figure out the percent complete.
    //

    PercentComplete = (unsigned)(100L * FilesCopied / FileCount);

    if(ForceRepaint || (PercentComplete != CurrentPercent)) {

        CurrentPercent = PercentComplete;

        //
        // Figure out how many spaces this represents on-screen.
        //

        temp = CurrentPercent * GAUGE_WIDTH;

        SpacesOnScreen = temp / 100;

        memset(Therm,GaugeChar,SpacesOnScreen);

        Therm[SpacesOnScreen] = '\0';

        DnPositionCursor(GAUGE_THERM_X,GAUGE_THERM_Y);
        DnSetGaugeAttribute(TRUE);
        DnWriteString(Therm);
        DnSetGaugeAttribute(FALSE);

        sprintf(Therm,"%u%%",CurrentPercent);
        DnPositionCursor(GAUGE_PERCENT_X,GAUGE_PERCENT_Y);
        DnWriteString(Therm);
    }
}


VOID
DnTickGauge(
    VOID
    )

/*++

Routine Description:

    'Tick' the gas gauge, ie, indicate that another file has been copied.
    Adjust the thermometer and percent-complete readouts.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if(FilesCopied < FileCount) {
        FilesCopied++;
    }
    DnpRepaintGauge(FALSE);
}


VOID
DnDrawGauge(
    IN PSCREEN AdditionalScreen OPTIONAL
    )

/*++

Routine Description:

    Clear the client area and redraw the gas gauge in its current state.

Arguments:

    Screen - If specified, supplies a screen to display along with the
        gas gauge.

Return Value:

    None.

--*/


{
    DnClearClientArea();
    if(AdditionalScreen) {
        DnDisplayScreen(AdditionalScreen);
    }
    DnDisplayScreen(&DnsGauge);
    DnpRepaintGauge(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\dndispjp.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dndispjp.c

Abstract:

    DOS-based NT setup program video display routines for DOS/V.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

    Originally dndisp.c.
    Modified 18-Feb-1995 (tedm) for DOS/V support, based on NT-J team's
    adaptation.

--*/

#ifdef JAPAN

#ifdef DOS_V

#include "winnt.h"
#include <string.h>


#define SCREEN_WIDTH        80
#define SCREEN_HEIGHT       25

#define STATUS_HEIGHT       1
#define STATUS_LEFT_MARGIN  2
#define HEADER_HEIGHT       3

#define CHARACTER_MAX       256

#if NEC_98
extern
VOID
RestoreBootcode(VOID);
VOID 
Screen_Buffer_Attr(
    SHORT x,
    SHORT y,
    UCHAR attr
    );

extern CursorOnFlag;        // For Cursor OFF
#endif // NEC_98

//
// Display attributes
//

#if NEC_988

#define ATT_FG_RED          (0x40 | 0x01)
#define ATT_FG_GREEN        (0x80 | 0x01)
#define ATT_FG_BLUE         (0x20 | 0x01)
#define ATT_FG_CYAN         (ATT_FG_BLUE | ATT_FG_GREEN)
#define ATT_FG_MAGENTA      (ATT_FG_RED  | ATT_FG_BLUE)
#define ATT_FG_YELLOW       (ATT_FG_RED  | ATT_FG_GREEN)
#define ATT_FG_WHITE        (ATT_FG_RED  | ATT_FG_GREEN | ATT_FG_BLUE)
#define ATT_FG_BLACK        (0x00 | 0x01)
#define ATT_REVERSE         0x05
#define ATT_BRINK           0x03

#define ATT_BG_RED          0x00
#define ATT_BG_GREEN        0x00
#define ATT_BG_BLUE         0x00
#define ATT_BG_CYAN         0x00
#define ATT_BG_MAGENTA      0x00
#define ATT_BG_YELLOW       0x00
#define ATT_BG_WHITE        0x00
#define ATT_BG_BLACK        0x00

#define ATT_FG_INTENSE      0x00
#define ATT_BG_INTENSE      0x00

#define DEFAULT_ATTRIBUTE   (ATT_FG_CYAN   | ATT_REVERSE)
#define STATUS_ATTRIBUTE    (ATT_FG_WHITE  | ATT_REVERSE)
#define EDIT_ATTRIBUTE      (ATT_FG_WHITE  | ATT_REVERSE)
#define EXITDLG_ATTRIBUTE   (ATT_FG_WHITE  | ATT_REVERSE)
#define GAUGE_ATTRIBUTE     (ATT_FG_YELLOW | ATT_REVERSE)

#else // NEC_98

#define ATT_FG_BLACK        0
#define ATT_FG_BLUE         1
#define ATT_FG_GREEN        2
#define ATT_FG_CYAN         3
#define ATT_FG_RED          4
#define ATT_FG_MAGENTA      5
#define ATT_FG_YELLOW       6
#define ATT_FG_WHITE        7

#define ATT_BG_BLACK       (ATT_FG_BLACK   << 4)
#define ATT_BG_BLUE        (ATT_FG_BLUE    << 4)
#define ATT_BG_GREEN       (ATT_FG_GREEN   << 4)
#define ATT_BG_CYAN        (ATT_FG_CYAN    << 4)
#define ATT_BG_RED         (ATT_FG_RED     << 4)
#define ATT_BG_MAGENTA     (ATT_FG_MAGENTA << 4)
#define ATT_BG_YELLOW      (ATT_FG_YELLOW  << 4)
#define ATT_BG_WHITE       (ATT_FG_WHITE   << 4)

#define ATT_FG_INTENSE      8
#define ATT_BG_INTENSE     (ATT_FG_INTENSE << 4)

#define DEFAULT_ATTRIBUTE   (ATT_FG_WHITE | ATT_BG_BLUE)
#define STATUS_ATTRIBUTE    (ATT_FG_BLACK | ATT_BG_WHITE)
#define EDIT_ATTRIBUTE      (ATT_FG_BLACK | ATT_BG_WHITE)
#define EXITDLG_ATTRIBUTE   (ATT_FG_RED   | ATT_BG_WHITE)
#if NEC_98
#define GAUGE_ATTRIBUTE     (ATT_BG_YELLOW)
#else
#define GAUGE_ATTRIBUTE     (ATT_BG_BLUE  | ATT_FG_YELLOW | ATT_FG_INTENSE)
#endif // NEC_98

#endif // NEC_98

//
// This value gets initialized in DnInitializeDisplay.
//
#if NEC_98

#define SCREEN_BUFFER ((UCHAR _far *)0xa0000000)      // Normal Mode Text Vram

#define SCREEN_BUFFER_CHR1(x,y) *((SCREEN_BUFFER + (2*((x)+(SCREEN_WIDTH*(y)))))+0)
#define SCREEN_BUFFER_CHR2(x,y) *((SCREEN_BUFFER + (2*((x)+(SCREEN_WIDTH*(y)))))+1)
UCHAR SCREEN_BUFFER_ATTRB[80][25];
BOOLEAN CursorIsActuallyOn;

#define IsANK(c)   (!((c >= 0x81 && c <= 0x9f) || (c >= 0xe0 && c <= 0xfe)))

#else // NEC_98
UCHAR _far *ScreenAddress;
#define SCREEN_BUFFER (ScreenAddress)

#define SCREEN_BUFFER_CHR(x,y) *(SCREEN_BUFFER + (2*((x)+(SCREEN_WIDTH*(y)))))
#define SCREEN_BUFFER_ATT(x,y) *(SCREEN_BUFFER + (2*((x)+(SCREEN_WIDTH*(y))))+1)

//
// Macro to update a char location from the Pseudo text RAM to the display.
//
#define UPDATE_SCREEN_BUFFER(x,y,z) DnpUpdateBuffer(&SCREEN_BUFFER_CHR(x,y),z)

BOOLEAN CursorIsActuallyOn;

//
// DBCS support
//
BOOLEAN DbcsTable[CHARACTER_MAX];
#define ISDBCS(chr) DbcsTable[(chr)]
#endif // NEC_98

#if NEC_98
#else // NEC_98
VOID
DnpInitializeDbcsTable(
    VOID
    );
#endif // NEC_98

//
// Make these near because they are used in _asm blocks
//
UCHAR _near CurrentAttribute;
UCHAR _near ScreenX;
UCHAR _near ScreenY;

BOOLEAN CursorOn;

#if NEC_98
#else // NEC_98
UCHAR _far *
DnpGetVideoAddress(
    VOID
    );

VOID
DnpUpdateBuffer(
    UCHAR _far *VideoAddress,
    int         CharNum
    );
#endif // NEC_98

VOID
DnpBlankScreenArea(
    IN UCHAR Attribute,
    IN UCHAR Left,
    IN UCHAR Right,
    IN UCHAR Top,
    IN UCHAR Bottom
    );


VOID
DnInitializeDisplay(
    VOID
    )

/*++

Routine Description:

    Put the display in a known state (80x25 standard text mode) and
    initialize the display package.

Arguments:

    None.

Return Value:

    None.

--*/

{
#if NEC_98
#else // NEC_98
    ScreenAddress = DnpGetVideoAddress();
    DnpInitializeDbcsTable();
#endif // NEC_98
    CurrentAttribute = DEFAULT_ATTRIBUTE;
    CursorOn = FALSE;

    //
    // Set the display to standard 80x25 mode
    //
#if NEC_98
    _asm {
        mov ax,0a00h     // set CRT mode to 80 x 25
        int 18h
        push ds
        push cx
        push bx
        mov ax,0a800h
        mov ds,ax
        mov cx,3fffh
blp:
	mov bx,cx
        mov ds:[bx],0
        loop blp
        mov ax,0b000h
        mov ds,ax
        mov cx,3fffh
rlp:
	mov bx,cx
        mov ds:[bx],0
        loop rlp
        mov ax,0b800h
        mov ds,ax
        mov cx,3fffh
glp:
	mov bx,cx
        mov ds:[bx],0
        loop glp
        mov ax,0e000h
        mov ds,ax
        mov cx,3fffh
ilp:
	mov bx,cx
        mov ds:[bx],0
        loop ilp

	mov ah,042h
        mov ch,0c0h
        int 18h
        mov ax,8
        out 68h,al
        mov ax,1
        out 6ah,al
        mov ax,41h
        out 6ah,al
        mov ax,0dh
        out 0a2h,al
        pop bx
        pop cx
        pop ds
    }
#else // NEC_98
    _asm {
        mov ax,3        // set video mode to 3
        int 10h
    }
#endif // NEC_98
    //
    // Clear the entire screen
    //

    DnpBlankScreenArea(CurrentAttribute,0,SCREEN_WIDTH-1,0,SCREEN_HEIGHT-1);
    DnPositionCursor(0,0);

    //
    // Shut the cursor off.
    //
#if NEC_98
    _asm {
        mov ah,12h      // function -- cursor off
        int 18h
    }
#else // NEC_98
    _asm {
        mov ah,2        // function -- position cursor
        mov bh,0        // display page
        mov dh,SCREEN_HEIGHT
        mov dl,0
        int 10h
    }
#endif // NEC_98

    CursorIsActuallyOn = FALSE;
}


VOID
DnClearClientArea(
    VOID
    )

/*++

Routine Description:

    Clear the client area of the screen, ie, the area between the header
    and status line.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DnpBlankScreenArea( CurrentAttribute,
                        0,
                        SCREEN_WIDTH-1,
                        HEADER_HEIGHT,
                        SCREEN_HEIGHT - STATUS_HEIGHT - 1
                      );

    DnPositionCursor(0,HEADER_HEIGHT);
}


VOID
DnSetGaugeAttribute(
    IN BOOLEAN Set
    )

/*++

Routine Description:

    Prepare for drawing the thermometer portion of a gas gauge.

Arguments:

    Set - if TRUE, prepare for drawing the thermometer.  If FALSE, restore
        the state for normal drawing.

Return Value:

    None.

--*/

{
    static UCHAR SavedAttribute = 0;

    if(Set) {
        if(!SavedAttribute) {
            SavedAttribute = CurrentAttribute;
            CurrentAttribute = GAUGE_ATTRIBUTE;
        }
    } else {
        if(SavedAttribute) {
            CurrentAttribute = SavedAttribute;
            SavedAttribute = 0;
        }
    }
}


VOID
DnPositionCursor(
    IN UCHAR X,
    IN UCHAR Y
    )

/*++

Routine Description:

    Position the cursor.

Arguments:

    X,Y - cursor coords

Return Value:

    None.

--*/

{
#if NEC_98
    USHORT Cursor;
#endif // NEC_98

    if(X >= SCREEN_WIDTH) {
        X = 0;
        Y++;
    }

    if(Y >= SCREEN_HEIGHT) {
        Y = HEADER_HEIGHT;
    }

    ScreenX = X;
    ScreenY = Y;

    //
    // Invoke BIOS
    //

#if NEC_98
    Cursor = ((ScreenX + (SCREEN_WIDTH * ScreenY)) * 2 + (USHORT)SCREEN_BUFFER);
    if(CursorOnFlag) {
        _asm {
            mov ah,13h     // function -- position cursor
            mov dx,Cursor
            int 18h

            mov ah,11h     // function -- cursor on
            int 18h
        }
        CursorIsActuallyOn = TRUE;
    } else {
        _asm {
            mov ah,13h     // function -- position cursor
            mov dx,Cursor
            int 18h

            mov ah,12h     // function -- cursor off
            int 18h
        }
        CursorIsActuallyOn = FALSE;
    }
#else // NEC_98
    _asm {
        mov ah,2        // function -- position cursor
        mov bh,0        // display page
        mov dh,ScreenY
        mov dl,ScreenX
        int 10h
    }

    CursorIsActuallyOn = TRUE;
#endif // NEC_98
}


VOID
DnWriteChar(
    IN CHAR chr
    )

/*++

Routine Description:

    Write a character in the current attribute at the current position.

Arguments:

    chr - Character to write

Return Value:

    None.

--*/

{
    if(chr == '\n') {
        ScreenX = 0;
        ScreenY++;
        return;
    }
#if NEC_98
    if ( ( ScreenX < SCREEN_WIDTH ) && ( ScreenY < SCREEN_HEIGHT ) ) {
        SCREEN_BUFFER_CHR1(ScreenX,ScreenY) = chr;
        SCREEN_BUFFER_CHR2(ScreenX,ScreenY) = 0x00;
        Screen_Buffer_Attr(ScreenX,ScreenY, CurrentAttribute);
    }
    
    if(!CursorOn && CursorIsActuallyOn) {
        CursorIsActuallyOn = FALSE;
        _asm {
            mov ah,12h      // function -- cursor off
            int 18h
        }
    }
#else // NEC_98

    if ( ( ScreenX < SCREEN_WIDTH ) && ( ScreenY < SCREEN_HEIGHT ) ) {
        SCREEN_BUFFER_CHR(ScreenX,ScreenY) = chr;
        SCREEN_BUFFER_ATT(ScreenX,ScreenY) = CurrentAttribute;
        UPDATE_SCREEN_BUFFER(ScreenX, ScreenY,1);
    }

    //
    // shut cursor off if necessary
    //
    if(!CursorOn && CursorIsActuallyOn) {
        CursorIsActuallyOn = FALSE;
        _asm {
            mov ah,2        // function -- position cursor
            mov bh,0        // display page
            mov dh,SCREEN_HEIGHT
            mov dl,0
            int 10h
        }
    }
#endif // NEC_98
}


VOID
DnWriteWChar(
#if NEC_98
    IN PUCHAR chr
#else // NEC_98
    IN PCHAR chr
#endif // NEC_98
    )

/*++

Routine Description:

    Write a DBCS character in the current attribute at the current position.

Arguments:

    wchr - DBCS Character to write

Return Value:

    None.

--*/

{
#if NEC_98
PUCHAR  code = chr;
UCHAR   moji_1st,moji_2nd;
USHORT  sjis;

    moji_1st = *code;
    code++;
    moji_2nd = *code;
    code++;

    //  Make Shift JIS
    sjis = (USHORT)moji_1st;
    sjis = (sjis << 8) + (USHORT)moji_2nd;

    //  Shift JIS -> JIS code exchange
    moji_1st -= ((moji_1st <= 0x9f) ? 0x71 : 0xb1);
    moji_1st = (UCHAR)(moji_1st * 2 + 1);
    if   (moji_2nd  > 0x7f){ moji_2nd--; }
    if   (moji_2nd >= 0x9e){ moji_2nd -= 0x7d; moji_1st++; }
    else                   { moji_2nd -= 0x1f; }

    //  Create custom JIS code
    moji_1st += 0x60;

    //  Grpah Mode Check
    if   (memcmp(&sjis,"\340\340",2) == 0){
         SCREEN_BUFFER_CHR1(ScreenX,ScreenY)   = (UCHAR)(sjis >> 8);
         SCREEN_BUFFER_CHR2(ScreenX,ScreenY)   = 0x00;
         Screen_Buffer_Attr(ScreenX,ScreenY, CurrentAttribute);
         SCREEN_BUFFER_CHR1(ScreenX+1,ScreenY) = (UCHAR)(sjis & 0xff);
         SCREEN_BUFFER_CHR2(ScreenX+1,ScreenY) = 0x00;
         Screen_Buffer_Attr(ScreenX+1,ScreenY, CurrentAttribute);
    }
    else {
         SCREEN_BUFFER_CHR1(ScreenX,ScreenY)   = moji_1st;
         SCREEN_BUFFER_CHR2(ScreenX,ScreenY)   = moji_2nd;
         Screen_Buffer_Attr(ScreenX,ScreenY, CurrentAttribute);
         SCREEN_BUFFER_CHR1(ScreenX+1,ScreenY) = (UCHAR)(moji_1st - 0x80);
         SCREEN_BUFFER_CHR2(ScreenX+1,ScreenY) = moji_2nd;
         Screen_Buffer_Attr(ScreenX+1,ScreenY, CurrentAttribute);
    }
    //
    // shut cursor off if necessary
    //
    if(!CursorOn && CursorIsActuallyOn) {
        CursorIsActuallyOn = FALSE;
        _asm {
            mov ah,12h      // function -- cursor off
            int 18h
        }
    }
#else // NEC_98
    SCREEN_BUFFER_CHR(ScreenX,ScreenY) = *chr;
    SCREEN_BUFFER_ATT(ScreenX,ScreenY) = CurrentAttribute;
    SCREEN_BUFFER_CHR(ScreenX+1,ScreenY) = *(chr+1);
    SCREEN_BUFFER_ATT(ScreenX+1,ScreenY) = CurrentAttribute;
    UPDATE_SCREEN_BUFFER(ScreenX,ScreenY,2);

    //
    // shut cursor off if necessary
    //
    if(!CursorOn && CursorIsActuallyOn) {
        CursorIsActuallyOn = FALSE;
        _asm {
            mov ah,2             // function -- position cursor
            mov bh,0             // display page
            mov dh,SCREEN_HEIGHT // screen height
            mov dl,0
            int 10h
        }
    }
#endif // NEC_98
}


VOID
DnWriteString(
    IN PCHAR String
    )

/*++

Routine Description:

    Write a string on the client area in the current position and
    adjust the current position.  The string is written in the current
    attribute.

Arguments:

    String - null terminated string to write.

Return Value:

    None.

--*/

{
    PCHAR p;

#if NEC_98
    for(p=String; *p; p++) {
        if(!IsANK((UCHAR)*p)) {
            DnWriteWChar((PUCHAR)p);
            p++ ;
            ScreenX += 2 ;
        } else {
            DnWriteChar(*p);
            if(*p != '\n') {
                ScreenX++;
            }
        }
    }
#else // NEC_98

    for(p=String; *p; p++) {
        if(ISDBCS((UCHAR)*p)) {
            DnWriteWChar(p);
            p++;
            ScreenX += 2;
        } else {
            DnWriteChar(*p);
            if(*p != '\n') {
                ScreenX++;
            }
        }
    }
#endif // NEC_98
}


VOID
DnWriteStatusText(
    IN PCHAR FormatString OPTIONAL,
    ...
    )

/*++

Routine Description:

    Update the status area

Arguments:

    FormatString - if present, supplies a printf format string for the
        rest of the arguments.  Otherwise the status area is cleared out.

Return Value:

    None.

--*/

{
    va_list arglist;
    static CHAR String[SCREEN_WIDTH+1];
    int StringLength;
    UCHAR SavedAttribute;

    //
    // First, clear out the status area.
    //

    DnpBlankScreenArea( STATUS_ATTRIBUTE,
                        0,
                        SCREEN_WIDTH-1,
                        SCREEN_HEIGHT-STATUS_HEIGHT,
                        SCREEN_HEIGHT-1
                      );

    if(FormatString) {

        va_start(arglist,FormatString);
        StringLength = vsnprintf(String,sizeof(String),FormatString,arglist);
        String[sizeof(String)-1] = '\0';

        SavedAttribute = CurrentAttribute;
        CurrentAttribute = STATUS_ATTRIBUTE;

        DnPositionCursor(STATUS_LEFT_MARGIN,SCREEN_HEIGHT - STATUS_HEIGHT);

        DnWriteString(String);

        CurrentAttribute = SavedAttribute;
    }
}


VOID
DnSetCopyStatusText(
    IN PCHAR Caption,
    IN PCHAR Filename
    )

/*++

Routine Description:

    Write or erase a copying message in the lower right part of the screen.

Arguments:

    Filename - name of file currently being copied.  If NULL, erases the
        copy status area.

Return Value:

    None.

--*/

{
    unsigned CopyStatusAreaLen;
    CHAR StatusText[100];

    //
    // The 13 is for 8.3 and a space
    //

    CopyStatusAreaLen = strlen(Caption) + 13;

    //
    // First erase the status area.
    //

    DnpBlankScreenArea( STATUS_ATTRIBUTE,
                        (UCHAR)(SCREEN_WIDTH - CopyStatusAreaLen),
                        SCREEN_WIDTH - 1,
                        SCREEN_HEIGHT - STATUS_HEIGHT,
                        SCREEN_HEIGHT - 1
                      );

    if(Filename) {

        UCHAR SavedAttribute;
        UCHAR SavedX,SavedY;

        SavedAttribute = CurrentAttribute;
        SavedX = ScreenX;
        SavedY = ScreenY;

        CurrentAttribute = STATUS_ATTRIBUTE;
        DnPositionCursor((UCHAR)(SCREEN_WIDTH-CopyStatusAreaLen),SCREEN_HEIGHT-1);

        memset(StatusText,0,sizeof(StatusText));
        strcpy(StatusText,Caption);
        strncpy(StatusText + strlen(StatusText),Filename,12);

        DnWriteString(StatusText);

        CurrentAttribute = SavedAttribute;
        ScreenX = SavedX;
        ScreenY = SavedY;
    }
}



VOID
DnStartEditField(
    IN BOOLEAN CreateField,
    IN UCHAR X,
    IN UCHAR Y,
    IN UCHAR W
    )

/*++

Routine Description:

    Sets up the display package to start handling an edit field.

Arguments:

    CreateField - if TRUE, caller is starting an edit field interaction.
        If FALSE, he is ending one.

    X,Y,W - supply coords and width in chars of the edit field.

Return Value:

    None.

--*/

{
    static UCHAR SavedAttribute = 255;

    CursorOn = CreateField;

    if(CreateField) {

        if(SavedAttribute == 255) {
            SavedAttribute = CurrentAttribute;
            CurrentAttribute = EDIT_ATTRIBUTE;
        }

        DnpBlankScreenArea(EDIT_ATTRIBUTE,X,(UCHAR)(X+W-1),Y,Y);

    } else {

        if(SavedAttribute != 255) {
            CurrentAttribute = SavedAttribute;
            SavedAttribute = 255;
        }
    }
}


VOID
DnExitDialog(
    VOID
    )
{
    unsigned W,H,X,Y,i;
    PUCHAR CharSave;
    PUCHAR AttSave;
    ULONG Key,ValidKeys[3] = { ASCI_CR,DN_KEY_F3,0 };
    UCHAR SavedX,SavedY,SavedAttribute;
    BOOLEAN SavedCursorState = CursorOn;

    SavedAttribute = CurrentAttribute;
    CurrentAttribute = EXITDLG_ATTRIBUTE;

    SavedX = ScreenX;
    SavedY = ScreenY;

    //
    // Shut the cursor off.
    //
    CursorIsActuallyOn = FALSE;
    CursorOn = FALSE;
#if NEC_98
    _asm {
            mov ah,12h      // function -- cursor off
            int 18h
         }
#else // NEC_98
    _asm {
        mov ah,2        // function -- position cursor
        mov bh,0        // display page
        mov dh,SCREEN_HEIGHT
        mov dl,0
        int 10h
    }
#endif // NEC_98

    //
    // Count lines in the dialog and determine its width.
    //
    for(H=0; DnsExitDialog.Strings[H]; H++);
    W = strlen(DnsExitDialog.Strings[0]);
#if NEC_98
    W += 2;
#endif // NEC_98

    //
    // allocate two buffers for character save and attribute save
    //
#if NEC_98
    CharSave = MALLOC((W*H+2)*2,TRUE);
    AttSave  = MALLOC((W*H+2)*2,TRUE);
#else // NEC_98
    CharSave = MALLOC(W*H,TRUE);
    AttSave = MALLOC(W*H,TRUE);
#endif // NEC_98

    //
    // save the screen patch
    //
#if NEC_98
    for(Y=0; Y<H; Y++) {
        for(X=0; X < (W+2) ;X++) {

            UCHAR attr,chr1,chr2;
            UCHAR x,y;

            x = (UCHAR)(X + (DnsExitDialog.X - 1));
            y = (UCHAR)(Y + DnsExitDialog.Y);

            chr1 = SCREEN_BUFFER_CHR1(x,y);
            chr2 = SCREEN_BUFFER_CHR2(x,y);
            attr = SCREEN_BUFFER_ATTRB[x][y];

            CharSave[(Y*W*2)+(X*2)] = chr1;
            CharSave[(Y*W*2)+(X*2+1)] = chr2;
            AttSave [(Y*W*2)+(X*2)] = attr;

            if((X == 0) && (chr2 != 0)){
                SCREEN_BUFFER_CHR1(x,y) = ' ';
                SCREEN_BUFFER_CHR2(x,y) = 0x00;
            }
            if((X == (W-1)) && (chr2 != 0)){
                if(((CharSave[(Y*W*2)+((X-1)*2+0)] - (UCHAR)0x80) == chr1) &&
                   ( CharSave[(Y*W*2)+((X-1)*2+1)]                == chr2)){
                    SCREEN_BUFFER_CHR1(x,y) = ' ';
                    SCREEN_BUFFER_CHR2(x,y) = 0x00;
                }
            }
        }
    }
#else // NEC_98
    for(Y=0; Y<H; Y++) {
        for(X=0; X<W; X++) {

            UCHAR att,chr;
            UCHAR x,y;

            x = (UCHAR)(X + DnsExitDialog.X);
            y = (UCHAR)(Y + DnsExitDialog.Y);

            chr = SCREEN_BUFFER_CHR(x,y);
            att = SCREEN_BUFFER_ATT(x,y);

            CharSave[Y*W+X] = chr;
            AttSave[Y*W+X] = att;
        }
    }
#endif // NEC_98

    //
    // Put up the dialog
    //

    for(i=0; i<H; i++) {
        DnPositionCursor(DnsExitDialog.X,(UCHAR)(DnsExitDialog.Y+i));
        DnWriteString(DnsExitDialog.Strings[i]);
    }

    CurrentAttribute = SavedAttribute;

    //
    // Wait for a valid keypress
    //

    Key = DnGetValidKey(ValidKeys);
    if(Key == DN_KEY_F3) {
#if NEC_98
        //
        // On floppyless setup if user have canceled setup or setup be stopped
        // by error occurred,previous OS can't boot to be written boot code
        // and boot loader.
        //
        RestoreBootcode();
#endif // NEC_98
        DnExit(1);
    }

    //
    // Restore the patch
    //
#if NEC_98
    for(Y=0; Y<H; Y++) {
        for(X=0; X < (W+2); X++) {

            UCHAR attr,chr1,chr2;
            UCHAR x,y;

            x = (UCHAR)(X + (DnsExitDialog.X - 1));
            y = (UCHAR)(Y + DnsExitDialog.Y);

            chr1 = CharSave[(Y*W*2)+(X*2)];
            chr2 = CharSave[(Y*W*2)+(X*2+1)];
            attr = AttSave [(Y*W*2)+(X*2)];

            SCREEN_BUFFER_CHR1(x,y) = chr1;
            SCREEN_BUFFER_CHR2(x,y) = chr2;
            Screen_Buffer_Attr(x,y, attr);
        }
    }
#else // NEC_98
    for(Y=0; Y<H; Y++) {
        for(X=0; X<W; X++) {

            UCHAR att,chr;
            UCHAR x,y;

            x = (UCHAR)(X + DnsExitDialog.X);
            y = (UCHAR)(Y + DnsExitDialog.Y);

            chr = CharSave[Y*W+X];
            att = AttSave[Y*W+X];

            SCREEN_BUFFER_CHR(x,y) = chr;
            SCREEN_BUFFER_ATT(x,y) = att;

            if((0 == X) && ISDBCS((UCHAR)SCREEN_BUFFER_CHR(x-1,y))) {
                UPDATE_SCREEN_BUFFER(x-1,y,2);
            } else if (ISDBCS((UCHAR)chr)) {
                X++ ;
                x = (UCHAR)(X + DnsExitDialog.X);
                y = (UCHAR)(Y + DnsExitDialog.Y);
                chr = CharSave[Y*W+X];
                att = AttSave[Y*W+X];
                SCREEN_BUFFER_CHR(x,y) = chr;
                SCREEN_BUFFER_ATT(x,y) = att;
                UPDATE_SCREEN_BUFFER(x-1,y,2);
            } else {
                UPDATE_SCREEN_BUFFER(x,y,1);
            }
        }
    }
#endif // NEC_98

    FREE(CharSave);
    FREE(AttSave);

    CursorOn = SavedCursorState;

    if(CursorOn) {
        DnPositionCursor(SavedX,SavedY);
    } else {
        ScreenX = SavedX;
        ScreenY = SavedY;
#if NEC_98
    _asm {
            mov ah,12h      // function -- cursor off
            int 18h
         }
#else // NEC_98
        _asm {
            mov ah,2
            mov bh,0
            mov dh,SCREEN_HEIGHT;
            mov dl,0
            int 10h
        }
#endif // NEC_98
        CursorIsActuallyOn = FALSE;
    }
}



//
// Internal support routines
//
VOID
DnpBlankScreenArea(
    IN UCHAR Attribute,
    IN UCHAR Left,
    IN UCHAR Right,
    IN UCHAR Top,
    IN UCHAR Bottom
    )

/*++

Routine Description:

    Invoke the BIOS to blank a region of the screen.

Arguments:

    Attribute - screen attribute to use to blank the region

    Left,Right,Top,Bottom - coords of region to blank

Return Value:

    None.

--*/

{
    UCHAR x,y;

#if NEC_98
    for(y=Top; y<=Bottom; y++) {
        for(x=Left; x<=Right; x++) {
            SCREEN_BUFFER_CHR1(x,y) = ' ';
            SCREEN_BUFFER_CHR2(x,y) = 0x00;
            Screen_Buffer_Attr(x,y, Attribute);
        }
    }
#else // NEC_98
    for(y=Top; y<=Bottom; y++) {
        for(x=Left; x<=Right; x++) {
            SCREEN_BUFFER_CHR(x,y) = ' ';
            SCREEN_BUFFER_ATT(x,y) = Attribute;
            UPDATE_SCREEN_BUFFER(x,y,1);
        }
    }
#endif // NEC_98
}


#if NEC_98
#else // NEC_98

//
// Disable 4035 warning - no return value, since
// the register state is set correctly with the
// required return value
//

#pragma warning( disable : 4035 )

UCHAR _far *
DnpGetVideoAddress(
    VOID
    )

/*++

Routine Description:

    This function retrieves the location of the Video Text Ram if one exists,
    else will retrieve the location of the Pseudo (virtual) Text Ram.

Arguments:

    None.

Return Value:

    Either the Video Text RAM or Pseudo Text RAM address.

--*/

{
    _asm {
        push    es
        push    di
        mov     ax, 0b800h
        mov     es, ax
        xor     di, di
        mov     ax, 0fe00h
        int     10h
        mov     dx, es
        mov     ax, di
        pop     di
        pop     es
    }
}


UCHAR _far *
DnpGetDbcsTable(
    VOID
    )
{
    _asm {
        push    ds
        push    si
        mov     ax, 06300h
        int 21h
        mov dx, ds
        mov ax, si
        pop si
        pop ds
    }
}

//
// Reset the 4035 warning state back to the
// default state
//
#pragma warning( default : 4035 )


VOID
DnpUpdateBuffer(
    UCHAR _far *VideoAddress,
    int         CharNum
    )

/*++

Routine Description:

    Updates one character in the Pseudo Text RAM to the display.  This
    function will have NO effect if the address points to the actual
    text RAM, usually B800:0000H+ in US mode.

Arguments:

    The address location of where the character is in the text RAM.

Return Value:

    None.

--*/

{
    _asm {
        push    es
        push    di
        mov     ax, word ptr 6[bp]
        mov     es, ax
        mov     di, word ptr 4[bp]
        mov     cx, CharNum
        mov     ax, 0ff00h
        int     10h
        pop     di
        pop     es
    }
}


VOID
DnpInitializeDbcsTable(
    VOID
    )
{
    UCHAR _far *p;
    UCHAR _far *Table;
    int i;

    Table = DnpGetDbcsTable();
    for(p=Table; *p; p+=2) {
        for(i = (int)*p; i<=(int)*(p+1); i++) {
            DbcsTable[i] = TRUE;
        }
    }
}
#endif // NEC_98

int
DnGetGaugeChar(
    VOID
    )
{
#if NEC_98
    return(0x20);
#else // NEC_98
    return(0x14);   //shaded square in cp932
#endif // NEC_98
}
#if NEC_98
VOID
Screen_Buffer_Attr(
    SHORT x,
    SHORT y,
    UCHAR attr
    )
{
    UCHAR _far *pfgc;
    SHORT fgc;
    SHORT pc98col[] = { 0x5, 0x25, 0x85, 0x0a5, 0x045, 0x65, 0x0c5, 0x0e5};
    

    SCREEN_BUFFER_ATTRB[x][y] = attr;
    *((SCREEN_BUFFER + (2*((x)+(SCREEN_WIDTH*(y)))))+0x2000) = pc98col[((attr & 0x70) >> 4)];
    pfgc = y * 80 * 16  + x;
    fgc = attr & 0x0f;

    _asm {
        push ds
	push cx
        push bx
        mov ax, 0a800h
        mov ds,ax
        mov cx,16
        mov bx, pfgc
        mov ax, fgc
        and ax, 1;
        mov al, 0
        jz bfil
        mov al,0ffh

bfil:
        mov ds:[bx],al
        add bx, 80
        loop bfil

        mov ax, 0b800h
        mov ds,ax
        mov cx,16
        mov bx, pfgc
        mov ax, fgc
        and ax, 2;
        mov al,0
        jz gfil
        mov al,0ffh
gfil:
        mov ds:[bx],al
        add bx, 80
        loop gfil

        mov ax, 0b000h
        mov ds,ax
        mov cx,16
        mov bx, pfgc
        mov ax, fgc
        and ax, 4
        mov al,0
        jz rfil
        mov al,0ffh
rfil:
        mov ds:[bx],al
        add bx, 80
        loop rfil

        mov ax, 0e000h
        mov ds,ax
        mov cx,16
        mov bx, pfgc
        mov ax, fgc
        and ax, 8
        mov al,0
        jz ifil
        mov al,0ffh
ifil:
        mov ds:[bx],0ffh
        add bx, 80
        loop ifil

        pop bx
        pop cx
        pop ds        
    }
    

}

int
WriteBackGrounf(
    SHORT color
    )
{
    return(0);
}
#endif // NEC_98

#else
//
// Not compiling for DOS/V (ie, we're building the Japanese
// version of the 'standard' winnt.exe)
//
#include ".\dndisp.c"
#endif // def DOS_V

#else
#error Trying to use Japanese display routines but not compiling Japanese version!
#endif // def JAPAN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\dnutil.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dnutil.c

Abstract:

    Miscellaneous routines for DOS-hosted NT setup program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/

#include "winnt.h"
#include <string.h>
#include <process.h>
#include <malloc.h>
#include <dos.h>
#include <direct.h>
#include <ctype.h>


BOOLEAN WarnedAboutSkip = FALSE;

ULONG
DnGetKey(
    VOID
    )

/*++

Routine Description:

    Waits for any keypress.

Arguments:

    None.

Return Value:

    Actual key pressed.

--*/

{
    USHORT c;

#if NEC_98
    _asm {
        xor ax,ax                   // function: read char from keyboard
        int 18h
        mov c,ax
    }

    switch(c) {
    case 0x3d00:                    // down arrow
        return(DN_KEY_DOWN);
    case 0x3a00:                    // up arrow
        return(DN_KEY_UP);
    case 0x3e00:                    // home
        return(DN_KEY_HOME);
    case 0x3f00:                    // end
        return(DN_KEY_END);
    case 0x3600:                    // page up
        return(DN_KEY_PAGEUP);
    case 0x3700:                    // page down
        return(DN_KEY_PAGEDOWN);
    case 0x6200:                    // F1
        return(DN_KEY_F1);
    case 0x6300:                    // F2
        return(DN_KEY_F2);
    case 0x6400:                    // F3
        return(DN_KEY_F3);
    case 0x6500:                    // F4
        return(DN_KEY_F4);
    default:
        return((ULONG)(c & ((c & 0x00ff) ? 0x00ff : 0xffff)));
    }
#else // NEC_98
    _asm {
        mov ah,0            // function: read char from keyboard
        int 16h
        mov c,ax
    }

    switch(c) {
    case 0x5000:                    // down arrow
        return(DN_KEY_DOWN);
    case 0x4800:                    // up arrow
        return(DN_KEY_UP);
    case 0x4700:                    // home
        return(DN_KEY_HOME);
    case 0x4f00:                    // end
        return(DN_KEY_END);
    case 0x4900:                    // page up
        return(DN_KEY_PAGEUP);
    case 0x5100:                    // page down
        return(DN_KEY_PAGEDOWN);
    case 0x3b00:                    // F1
        return(DN_KEY_F1);
    case 0x3c00:                    // F2
        return(DN_KEY_F2);
    case 0x3d00:                    // F3
        return(DN_KEY_F3);
    case 0x3e00:                    // F4
        return(DN_KEY_F4);
    default:
        return((ULONG)(c & ((c & 0x00ff) ? 0x00ff : 0xffff)));
    }
#endif // NEC_98
}


ULONG
DnGetValidKey(
    IN PULONG ValidKeyList
    )

/*++

Routine Description:

    Waits for a keypress matching one of the values given in a list.
    The list must be terminated with a 0 entry.

Arguments:

    ValidKeyList - valid keys.

Return Value:

    Actual key pressed.

--*/

{
    ULONG key;
    int i;

    while(1) {
        key = DnGetKey();
        for(i=0; ValidKeyList[i]; i++) {
            if(key == ValidKeyList[i]) {
                return(key);
            }
        }
    }
}


VOID
vDnDisplayScreen(
    IN PSCREEN Screen,
    IN va_list arglist
    )

/*++

Routine Description:

    Displays a screen.

Arguments:

    Screen - supplies pointer to structure describing screen to display.

    arglist - supplies list of arguments for printf-style formatting.

Return Value:

    None.

--*/

{
    UCHAR y;
    PCHAR p;
    PCHAR CurrentLine;
    int i;
    static CHAR FormatString[1600],FormattedString[1600];

    //
    // Take each line in the screen and put in into a buffer, to form
    // one large string.  Place newlines at the end of each string.
    //
    for(FormatString[0]=0,i=0; Screen->Strings[i]; i++) {
        if(strlen(FormatString)+strlen(Screen->Strings[i])+2 < sizeof(FormatString)) {
            strcat(FormatString,Screen->Strings[i]);
            strcat(FormatString,"\n");
        } else {
            break;
        }
    }

    //
    // Format the string using given arguments.
    //
    vsprintf(FormattedString,FormatString,arglist);

    for(y=Screen->Y,CurrentLine=FormattedString; CurrentLine && *CurrentLine; y++) {

        if(p = strchr(CurrentLine,'\n')) {
            *p = 0;
        }

        DnPositionCursor(Screen->X,y);
        DnWriteString(CurrentLine);

        CurrentLine = p ? p+1 : NULL;
    }
}

VOID
DnDisplayScreen(
    IN PSCREEN Screen,
    ...
    )

/*++

Routine Description:

    Displays a screen.

Arguments:

    Screen - supplies pointer to structure describing screen to display.

Return Value:

    None.

--*/

{
    va_list arglist;

    va_start(arglist,Screen);
    vDnDisplayScreen(Screen,arglist);
    va_end(arglist);
}



VOID
DnFatalError(
    IN PSCREEN Screen,
    ...
    )

/*++

Routine Description:

    Displays a fatal error screen and prompts the user to press enter
    to exit.  DOES NOT RETURN.

Arguments:

    Screen - supplies pointer to structure describing screen to display.

Return Value:

    DOES NOT RETURN.

--*/

{
    ULONG ExitOnlyKeyList[2] = { ASCI_CR,0 };
    va_list arglist;
    int i;

    DnClearClientArea();
    DnWriteStatusText(DntEnterEqualsExit);

    va_start(arglist,Screen);
    vDnDisplayScreen(Screen,arglist);
    va_end(arglist);

    for(i=0; Screen->Strings[i]; i++);
    DnPositionCursor(Screen->X,(UCHAR)(Screen->Y + i + 1));
    DnWriteString(DntPressEnterToExit);

    DnGetValidKey(ExitOnlyKeyList);
    DnExit(1);
}


BOOLEAN
DnCopyError(
    IN PCHAR   Filename,
    IN PSCREEN ErrorScreen,
    IN int     FilenameLine
    )

/*++

Routine Description:

    Displays a screen informing the user that there has been an error copying
    a file, and allows the options of continuing or exiting Setup.

Arguments:

    Filename - supplies name of source file which could not be copied.

    ErrorScreen - supplies the text to label the error.

    FilenameLine - supplies line number on the ErrorScreen in which the
        filename should be displayed.

Return Value:

    TRUE if user elects to retry; FALSE if user elects to continue;
    does not return if user chooses to exit.

--*/

{
    ULONG KeyList[4] = { ASCI_CR,DN_KEY_F3,ASCI_ESC,0 };
    ULONG KeyList2[4] = { 0,0,ASCI_CR,0 };

    KeyList2[0] = DniAccelSkip1;
    KeyList2[1] = DniAccelSkip2;

    DnClearClientArea();
    DnWriteStatusText("%s   %s   %s",DntEnterEqualsRetry,DntEscEqualsSkipFile,DntF3EqualsExit);

    ErrorScreen->Strings[FilenameLine] = Filename;
    DnDisplayScreen(ErrorScreen);

    while(1) {
        switch(DnGetValidKey(KeyList)) {

        case DN_KEY_F3:

            DnExitDialog();
            break;

        case ASCI_CR:

            return(TRUE);   // retry

        case ASCI_ESC:

            if(!WarnedAboutSkip) {

                DnClearClientArea();
                DnDisplayScreen(&DnsSureSkipFile);
                DnWriteStatusText("%s   %s",DntEnterEqualsRetry,DntXEqualsSkipFile);

                if(DnGetValidKey(KeyList2) == ASCI_CR) {
                    //
                    // retry
                    //
                    return(TRUE);
                } else {
                    //
                    // User elected to skip: prevent future warnings.
                    //
                    WarnedAboutSkip = TRUE;
                }
            }

            return(FALSE);  // skip file
        }
    }
}


PCHAR
DnDupString(
    IN PCHAR String
    )

/*++

Routine Description:

    Duplicate a string.  Do not return if not enough memory.

Arguments:

    String - string to be duplicated

Return Value:

    Pointer to new string. Does not return if insufficient memory.

--*/

{
    if( String ) {
        PCHAR p = MALLOC(strlen(String)+1,TRUE);
        return(strcpy(p,String));
    } else {
        return( NULL );
    }
}



VOID
DnGetString(
    IN OUT PCHAR String,
    IN UCHAR X,
    IN UCHAR Y,
    IN UCHAR W
    )

/*++

Routine Description:

    Allow the user to type a string in an edit field.  Interpret F3
    to allow him to exit.

Arguments:

    String - on input, supplies the default string.  On output, contains
        the string entered by the user.

    X,Y - coords of leftmost char of edit field.

    W - width of edit field, and maximum length of the string.

Return Value:

    None.

--*/

{
    ULONG key;
    int Position = strlen(String);

    DnStartEditField(TRUE,X,Y,W);

    DnPositionCursor(X,Y);
    DnWriteString(String);
    DnPositionCursor((UCHAR)(X+Position),Y);

    while(1) {

        key = DnGetKey();

        switch(key) {

        case DN_KEY_F3:
            DnExitDialog();
            break;

        case ASCI_BS:
            if(Position) {
                String[--Position] = 0;
                DnPositionCursor((UCHAR)(X+Position),Y);
                DnWriteChar(' ');
            }
            break;

        case ASCI_ESC:
            Position = 0;
            String[0] = 0;
            DnStartEditField(TRUE,X,Y,W);       // blanks edit field
            DnPositionCursor(X,Y);
            break;

        case ASCI_CR:
            DnStartEditField(FALSE,X,Y,W);
            return;

        default:
            if(((UCHAR)Position < W) && !(key & 0xffffff00)) {
                DnWriteChar((CHAR)key);
                String[Position++] = (CHAR)key;
                String[Position] = 0;
                DnPositionCursor((UCHAR)(X+Position),Y);
            }
        }
    }
}


BOOLEAN
DnIsDriveValid(
    IN unsigned Drive
    )

/*++

Routine Description:

    Determine whether a drive is valid (ie, exists and is accessible).

Arguments:

    Drive - drive (1=A, 2=B, etc).

Return Value:

    TRUE if drive is valid.
    FALSE if not.

--*/

{
    int CurrentDrive = _getdrive();
    int Status;

    //
    // We'll make the determination of whether the drive is valid by
    // attempting to switch to it.  If this succeeds, assume the drive
    // is valid.
    //
    Status = _chdrive(Drive);

    _chdrive(CurrentDrive);

    return((BOOLEAN)(Status == 0));
}


BOOLEAN
DnIsDriveRemote(
    IN unsigned Drive,
    OUT PCHAR UncPath   OPTIONAL
    )

/*++

Routine Description:

    Determine whether a drive is remote and optionally retrieve the
    UNC path of the target.

Arguments:

    Drive - drive (1=A, 2=B, etc).

    UncPath - if specified and the drive is a network drive, the
        UNC path the drive is connected to is returned in this buffer.
        The caller must make sure the buffer is large enough (128 bytes).
        If this string is empty then the unc path could not be determined.

Return Value:

    TRUE if drive is remote.
    FALSE if not (or we couldn't determine whether the drive is remote).

--*/

{
    union REGS RegIn,RegOut;
    BOOLEAN OK;
    CHAR LocalBuffer[16];
    unsigned LocalBufferOffset;
    unsigned Index;

    //
    // Call IOCTL function 09.
    // If carry set (error), assume not remote.
    // If no error, bit 12 of dx set if remote.
    //
    RegIn.x.ax = 0x4409;
    RegIn.h.bl = (unsigned char)Drive;

    intdos(&RegIn,&RegOut);

    if(!RegOut.x.cflag && (RegOut.x.dx & 0x1000)) {

        if(UncPath) {

            //
            // If we don't do this and try instead to use
            // offset LocalBuffer inside the _asm block
            // we get the wrong address.
            //
            LocalBufferOffset = (unsigned)LocalBuffer;

            Index = 0;
            do {
                OK = TRUE;

                _asm {

                    push    ds
                    push    es

                    mov     ax,0x5f02
                    mov     bx,Index

                    mov     cx,word ptr [UncPath+2]
                    mov     di,word ptr [UncPath]

                    mov     si,LocalBufferOffset

                    push    ss
                    pop     ds

                    mov     es,cx

                    int     21h

                    pop     es
                    pop     ds

                    jnc     x
                    mov     OK,0
                    x:
                }

                if(OK) {
                    if(((unsigned)toupper(LocalBuffer[0]) == (Drive + (unsigned)'A' - 1))
                    && (LocalBuffer[1] == ':')) {
                        //
                        // Found it. We're done.
                        //
                        return(TRUE);
                    }

                    Index++;
                }

            } while(OK);

            //
            // Couldn't find it.
            //
            UncPath[0] = 0;
        }

        return(TRUE);
    } else {
        return(FALSE);
    }
}


BOOLEAN
DnIsDriveRemovable(
    IN unsigned Drive
    )

/*++

Routine Description:

    Determine whether a drive is removable.

Arguments:

    Drive - drive (1=A, 2=B, etc).

Return Value:

    TRUE if drive is removable.
    FALSE if not removable.

    If an error occurs making the determination, the drive is assumed
    not removable.

--*/

{
    int ax;
    union REGS RegIn,RegOut;

    //
    // Call IOCTL function 08.
    //

    RegIn.x.ax = 0x4408;
    RegIn.h.bl = (unsigned char)Drive;

    ax = intdos(&RegIn,&RegOut);

    //
    // If an error occured, assume not removable.
    // If no error, ax = 0 if removable, ax = 1 if not removable.
    //
    return((BOOLEAN)(!RegOut.x.cflag && !ax));
}


BOOLEAN
DnCanonicalizePath(
    IN PCHAR PathIn,
    OUT PCHAR PathOut
    )

/*++

Routine Description:

    Canonicalize a path. The result is a fully-qualified path
    that always starts with the x:\ for local or local-redirected
    drives, or \\ for remote paths.

Arguments:

    PathIn - supplies the path to be canonicalized. The path must be
        valid (ie, it must be some form of syntactically correct MS-DOS path
        and must actually exist and be accessible) for this function
        to succeed.

    PathOut - receives the canonicalized path if successful. The function
        assumes that the buffer has space for 128 bytes.

Return Value:

    Boolean value indicating outcome. If TRUE, PathOut will be filled in.

--*/

{
    BOOLEAN OK;
    int olddrive;
    char olddir[128];
    int drive;

    //
    // If the input path is UNC then we assume
    // the path is remote and note that the dos canonicalize
    // int21 function will do what we want.
    //
    if((PathIn[0] == '\\') && (PathIn[1] == '\\')) {

        OK = TRUE;

        _asm {
            push    ds
            push    es

            mov     si,word ptr [PathIn]
            mov     ax,word ptr [PathIn+2]

            mov     di,word ptr [PathOut]
            mov     cx,word ptr [PathOut+2]

            mov     ds,ax
            mov     es,cx

            mov     ax,0x6000

            int     21h

            pop     es
            pop     ds

            jnc     x
            mov     OK,0
            x:
        }
    } else {
        //
        // Not UNC. We set and read the cwd to simulate what we want.
        // Preserve current cwd if possible.
        //
        olddrive = _getdrive();
        if(!getcwd(olddir,sizeof(olddir))) {
            olddir[0] = 0;
        }

        //
        // If we have x: at the front, strip it and set the current drive.
        // We do this because chdir does not set the current drive.
        //
        OK = TRUE;
        if(isalpha(PathIn[0]) && (PathIn[1] == ':')) {

            if(_chdrive(toupper(PathIn[0]) + 1 - (int)'A')) {
                OK = FALSE;
            } else {
                PathIn += 2;
            }
        }

        if(OK) {
            OK = (BOOLEAN)(!chdir(PathIn) && (drive = _getdrive()) && _getdcwd(drive,PathOut,128));
        }

        if(olddir[0]) {
            chdir(olddir);
        }
        if(olddrive) {
            _chdrive(olddrive);
        }
    }

    return(OK);
}


#if DBG
long allocated;
long allocs;
#define MEMSIG 0xa3f8
#define callerinfo()    printf("      -- Caller: %s, line %u\n",file,line)
#endif

PVOID
Malloc(
    IN unsigned Size,
    IN BOOLEAN MustSucceed
#if DBG
   ,IN char *file,
    IN int line
#endif
    )

/*++

Routine Description:

    Allocates memory and fatal errors if none is available.

Arguments:

    Size - number of bytes to allocate

    MustSucceed - if true, then the allocation must succeed. If memory
        cannot be allocated to satisfy the request, the program displays
        a fatal error message and exits.

Return Value:

    Pointer to memory.  If MustSucceed is TRUE, DOES NOT RETURN
    if memory is not available.

--*/

{
    unsigned *p;

#if DBG
    p = malloc(Size+(2*sizeof(unsigned)));

    if(p) {

        *p++ = Size;

        *(unsigned *)(((PCHAR)p)+Size) = MEMSIG;

        allocated += Size;
        allocs++;
    } else {
        if(MustSucceed) {
            DnFatalError(&DnsOutOfMemory);
        }
    }
#else
    if((p = malloc(Size)) == NULL) {
        if(MustSucceed) {
            DnFatalError(&DnsOutOfMemory);
        }
    }
#endif
    return(p);
}



VOID
Free(
    IN PVOID Block
#if DBG
   ,IN char *file,
    IN int line
#endif
    )

/*++

Routine Description:

    Free a block of memory previously allocated with Malloc().

Arguments:

    Block - supplies pointer to block to free.

Return Value:

    None.

--*/

{
#if 0
extern char *CommonStrings[];
int i;
    for( i = 0; i < sizeof(CommonStrings)/sizeof(char *); i++ ) {
        if( (char *)Block == CommonStrings[i] ) {
            return;
        }
    }
#endif
#if DBG
    unsigned *p;

    if(!allocs) {
        printf("Free: allocation count going negative!\n");
        callerinfo();
        _asm { int 3 }
    }
    allocs--;

    p = ((unsigned *)Block) - 1;

    allocated -= *p;

    if(allocated < 0) {
        printf("Free: total allocation going negative!\n");
        callerinfo();
        _asm { int 3 }
    }

    if(*(unsigned *)((PCHAR)Block+(*p)) != MEMSIG) {
        printf("Free: memory block lacks MEMSIG!\n");
        callerinfo();
        _asm { int 3 }
    }

    free(p);
#else
    free(Block);
#endif
}


PVOID
Realloc(
    IN PVOID Block,
    IN unsigned Size,
    IN BOOLEAN MustSucceed
#if DBG
   ,IN char *file,
    IN int line
#endif
    )

/*++

Routine Description:

    Reallocates a block of memory previously allocated with Malloc();
    fatal errors if none is available.

Arguments:

    Block - supplies pointer to block to resize

    Size - number of bytes to allocate

    MustSucceed - if true, then the allocation must succeed. If memory
        cannot be allocated to satisfy the request, the program displays
        a fatal error message and exits.

Return Value:

    Pointer to memory. If MustSucceed is TRUE,
    DOES NOT RETURN if memory is not available.

--*/

{
    PVOID p;
#if DBG
    unsigned BlockSize;

    BlockSize = ((unsigned *)Block)[-1];
    allocated -= BlockSize;
    allocated += Size;

    if(*(unsigned *)((PCHAR)Block + BlockSize) != MEMSIG) {
        printf("Realloc: memory block lacks MEMSIG!\n");
        callerinfo();
        _asm { int 3 }
    }

    p = realloc((unsigned *)Block - 1,Size + (2*sizeof(unsigned)));

    if(p == NULL) {
        if(MustSucceed) {
            DnFatalError(&DnsOutOfMemory);
        }
    } else {

        *(unsigned *)p = Size;
        (unsigned *)p += 1;

        *(unsigned *)((PCHAR)p + Size) = MEMSIG;
    }
#else
    if((p = realloc(Block,Size)) == NULL) {
        if(MustSucceed) {
           DnFatalError(&DnsOutOfMemory);
        }
    }
#endif
    return(p);
}


VOID
DnExit(
    IN int ExitStatus
    )

/*++

Routine Description:

    Exits back to DOS in an orderly fashion.

Arguments:

    ExitStatus - supplies value to be passed to exit()

Return Value:

    None.  Does not return.

--*/

{
    unsigned DriveCount;

    //
    // Do a video mode switch to clear the screen.
    //

#if NEC_98
    _asm {
        mov al,5
        out 0a2h,al
        mov ax,0a00h
        int 18h

        mov ah,11h     // function -- cursor on
        int 18h
    }
    if(ExitStatus != 2){
        printf("\x1b[>3l");
        printf("\x1b[>1l");
    }
    else { ExitStatus = 0; }
#else // NEC_98
    _asm {
        mov ax,3
        int 10h
    }
#endif // NEC_98

    // restore current drive
    _dos_setdrive(DngOriginalCurrentDrive,&DriveCount);

    exit(ExitStatus);
}


BOOLEAN
DnWriteSmallIniFile(
    IN  PCHAR  Filename,
    IN  PCHAR *Lines,
    OUT FILE  **FileHandle OPTIONAL
    )
{
    FILE *fileHandle;
    unsigned i,len;
    BOOLEAN rc;

    //
    // If the file is already there, change attributes to normal
    // so we can overwrite it.
    //
    _dos_setfileattr(Filename,_A_NORMAL);

    //
    // Open/truncate the file.
    //
    fileHandle = fopen(Filename,"wt");
    if(fileHandle == NULL) {
        return(FALSE);
    }

    //
    // Assume success.
    //
    rc = TRUE;

    //
    // Write lines into the file indicating that this is
    // a winnt setup. On a doublespaced floppy, there should
    // be room for a single sector outside the CVF.
    //
    for(i=0; Lines[i]; i++) {

        len = strlen(Lines[i]);

        if(fwrite(Lines[i],1,len,fileHandle) != len) {
            rc = FALSE;
            break;
        }
    }

    //
    // Leave the file open if the caller wants the handle.
    //
    if(rc && FileHandle) {
        *FileHandle = fileHandle;
    } else {
        fclose(fileHandle);
    }

    return(rc);
}

int
vsnprintf( char* target, size_t bufsize, const char *format, va_list val )
{
    static CHAR BigFormatBuffer[4096];
    size_t retval;

    //
    // Print into the big format buffer, which we're sure will be large enough
    // to store 99.44% of all strings printed through here.
    //
    retval = vsprintf( BigFormatBuffer, format, val );
    BigFormatBuffer[retval++] = '\0';

    //
    // And then transfer it over to the output buffer, but only as much as they
    // wanted.
    //
    memcpy( target, BigFormatBuffer, retval < bufsize ? retval : bufsize );

    //
    // Zero out the end as well.
    //
    target[bufsize-1] = '\0';

    return retval;
}

int
snprintf( char* target, size_t bufsize, const char *format, ... )
{
    int retval;
    va_list val;
    
    va_start(val, format);
    retval = vsnprintf( target, bufsize, format, val );
    va_end( val );

    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\dninf.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    alinf.c

Abstract:

    This module implements functions to access the parsed INF.

Author:

    Sunil Pai    (sunilp) 13-Nov-1991

Revision History:

    Calin Negreanu (calinn) 03-Sep-1998 - Major parser rewrite to work with a swap file

--*/

#include "winnt.h"
#include <string.h>
#include <ctype.h>
#include <errno.h>
#include <dos.h>
#include <stdio.h>
#include <io.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>


#define MAX_BUFFER_SIZE 0x1680 //7D00
#define SWAP_SIGNATURE 0xAABBCCDD
#define SWAP_SIGN_SIZE 4

#define NULL_HANDLE 0
#define MAX_PATH 256

//
// typedefs exported
//

typedef unsigned *PUNSIGNED;
typedef PVOID SECTION_HANDLE;
typedef unsigned long LINE_HANDLE;
typedef unsigned long VALUE_HANDLE;

typedef struct _SWAP_VALUE {
    unsigned      ValueSize;
    VALUE_HANDLE  NextValue;
    char          ValueName[];
} SWAP_VALUE, *PSWAP_VALUE;

typedef struct _SWAP_LINE {
    unsigned     LineSize;
    LINE_HANDLE  NextLine;
    VALUE_HANDLE FirstValue;
    VALUE_HANDLE LastValue;
    char         LineName[];
} SWAP_LINE, *PSWAP_LINE;

typedef struct _SWAP_SECTION {
    unsigned       SectionSize;
    SECTION_HANDLE NextSection;
    LINE_HANDLE    FirstLine;
    LINE_HANDLE    LastLine;
    char           SectionName[];
} SWAP_SECTION, *PSWAP_SECTION;

typedef struct _SWAP_INF {
    SECTION_HANDLE CurrentSection;
    SECTION_HANDLE FirstSection;
    SECTION_HANDLE LastSection;
    int            SwapFileHandle;
    unsigned long  BufferSize;
    BOOLEAN        BufferDirty;
    PCHAR          Buffer;
    unsigned long  BufferStart;
    unsigned long  BufferEnd;
    SECTION_HANDLE LastSectionHandle;
    unsigned       LastLineIndex;
    LINE_HANDLE    LastLineHandle;
    unsigned       LastValueIndex;
    VALUE_HANDLE   LastValueHandle;
    char           SwapFile[];
} SWAP_INF, *PSWAP_INF;

char    *CommonStrings[] =
    { (char *)("d1")
    };

//
// DEFINES USED FOR THE PARSER INTERNALLY
//
//
// typedefs used
//

typedef enum _tokentype {
    TOK_EOF,
    TOK_EOL,
    TOK_LBRACE,
    TOK_RBRACE,
    TOK_STRING,
    TOK_EQUAL,
    TOK_COMMA,
    TOK_ERRPARSE,
    TOK_ERRNOMEM
    } TOKENTYPE, *PTOKENTTYPE;


typedef struct _token {
    TOKENTYPE Type;
    PCHAR     pValue;
    } TOKEN, *PTOKEN;


//
// Routine defines
//

PSWAP_SECTION
GetSectionPtr (
    IN      PSWAP_INF InfHandle,
    IN      SECTION_HANDLE SectionHandle
    );

PSWAP_LINE
GetLinePtr (
    IN      PSWAP_INF InfHandle,
    IN      LINE_HANDLE LineHandle
    );

PSWAP_VALUE
GetValuePtr (
    IN      PSWAP_INF InfHandle,
    IN      VALUE_HANDLE ValueHandle
    );


SECTION_HANDLE
GetNextSection (
    IN      PSWAP_INF InfHandle,
    IN      SECTION_HANDLE SectionHandle
    );

LINE_HANDLE
GetNextLine (
    IN      PSWAP_INF InfHandle,
    IN      LINE_HANDLE LineHandle
    );

VALUE_HANDLE
GetNextValue (
    IN      PSWAP_INF InfHandle,
    IN      VALUE_HANDLE ValueHandle
    );


SECTION_HANDLE
AddSection (
    IN      PSWAP_INF InfHandle,
    IN      PCHAR SectionName
    );

LINE_HANDLE
AddLine (
    IN      PSWAP_INF InfHandle,
    IN      SECTION_HANDLE Section,
    IN      PCHAR LineName
    );

VALUE_HANDLE
AddValue (
    IN      PSWAP_INF InfHandle,
    IN      LINE_HANDLE Line,
    IN      PCHAR ValueName
    );


SECTION_HANDLE
StoreNewSection (
    IN      PSWAP_INF InfHandle,
    IN      PSWAP_SECTION Section
    );

LINE_HANDLE
StoreNewLine (
    IN      PSWAP_INF InfHandle,
    IN      SECTION_HANDLE Section,
    IN      PSWAP_LINE Line
    );

VALUE_HANDLE
StoreNewValue (
    IN      PSWAP_INF InfHandle,
    IN      LINE_HANDLE Line,
    IN      PSWAP_VALUE Value
    );


BOOLEAN
LoadBuffer (
    IN      PSWAP_INF InfHandle,
    IN      unsigned long Offset
    );

TOKEN
GetToken (
    IN      FILE *File
    );

BOOLEAN
ParseInfBuffer (
    IN      PSWAP_INF InfHandle,
    IN      FILE *File,
    IN OUT  unsigned *LineNumber
    );


//
// Internal Routine declarations for searching in the INF structures
//


VALUE_HANDLE
SearchValueInLineByIndex (
    IN       PSWAP_INF InfHandle,
    IN       LINE_HANDLE Line,
    IN       unsigned ValueIndex
    );

LINE_HANDLE
SearchLineInSectionByName (
    IN       PSWAP_INF InfHandle,
    IN       SECTION_HANDLE Section,
    IN       PCHAR LineName
    );

LINE_HANDLE
SearchLineInSectionByIndex (
    IN       PSWAP_INF InfHandle,
    IN       SECTION_HANDLE Section,
    IN       unsigned LineIndex
    );

SECTION_HANDLE
SearchSectionByName (
    IN       PSWAP_INF InfHandle,
    IN       PCHAR SectionName
    );


//
// ROUTINE DEFINITIONS
//

static unsigned g_Sequencer = 0;

//
// returns a handle to use for further inf parsing
//

int
DnInitINFBuffer (
    IN  FILE     *InfFileHandle,
    OUT PVOID    *pINFHandle,
    OUT unsigned *LineNumber
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    char SwapFilePath[MAX_PATH];
    PSWAP_INF InfHandle = NULL;
    int Status;
    unsigned long SwapSign;

    *LineNumber = 0;

    //
    // Prepare the swap file path
    //
    sprintf (SwapFilePath, "%c:\\INF%03u.SWP", DngSwapDriveLetter, g_Sequencer++);

    //
    // Allocate and populate the SWAP_INF structure
    //
    InfHandle = MALLOC(sizeof(SWAP_INF) + strlen (SwapFilePath) + 1, TRUE);
    InfHandle->CurrentSection = NULL;
    InfHandle->FirstSection   = NULL;
    InfHandle->LastSection    = NULL;
    InfHandle->SwapFileHandle = -1;
    InfHandle->BufferSize     = 0;
    InfHandle->BufferDirty    = FALSE;
    InfHandle->Buffer         = NULL;
    InfHandle->BufferStart    = 0;
    InfHandle->BufferEnd      = 0;
    InfHandle->LastSectionHandle = NULL_HANDLE;
    InfHandle->LastLineIndex     = 0xffff;
    InfHandle->LastLineHandle    = NULL_HANDLE;
    InfHandle->LastValueIndex    = 0xffff;
    InfHandle->LastValueHandle   = NULL_HANDLE;
    strcpy (InfHandle->SwapFile, SwapFilePath);

    //
    // Prepare the swap file
    //
    InfHandle->SwapFileHandle = open (InfHandle->SwapFile, O_BINARY|O_CREAT|O_TRUNC|O_RDWR, S_IREAD|S_IWRITE);
    if (InfHandle->SwapFileHandle == -1) {
        FREE (InfHandle);
        Status = errno;
    }
    else {
        //
        // write down signature
        //
        SwapSign = SWAP_SIGNATURE;
        write (InfHandle->SwapFileHandle, &SwapSign, SWAP_SIGN_SIZE);

        //
        // Prepare the buffer
        //
        InfHandle->BufferSize = MAX_BUFFER_SIZE;
        InfHandle->Buffer = MALLOC (MAX_BUFFER_SIZE, TRUE);
        InfHandle->BufferStart = SWAP_SIGN_SIZE;
        InfHandle->BufferEnd = SWAP_SIGN_SIZE;

        //
        // Parse the file
        //
        if (!ParseInfBuffer (InfHandle, InfFileHandle, LineNumber)) {
            //
            // Free SWAP_INF structure
            //
            DnFreeINFBuffer (InfHandle);
            *pINFHandle = NULL;
            Status = EBADF;
        } else {
            *pINFHandle = InfHandle;
            Status = EZERO;
        }
    }

    //
    // Clean up and return
    //
    return(Status);
}



//
// frees an INF Buffer
//
int
DnFreeINFBuffer (
   IN PVOID INFHandle
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PSWAP_INF pINF;
    PSWAP_SECTION Section;
    SECTION_HANDLE SectionHandle;

    //
    // Valid INF Handle?
    //

    if (INFHandle == (PVOID)NULL) {
       return EZERO;
    }

    //
    // cast the buffer into an INF structure
    //

    pINF = (PSWAP_INF)INFHandle;

    //
    // Close and delete the swap file
    //
    close (pINF->SwapFileHandle);
    remove (pINF->SwapFile);

    //
    // free temporary buffer
    //
    FREE (pINF->Buffer);

    //
    // Free section list
    //
    SectionHandle = pINF->FirstSection;

    while (SectionHandle) {
        Section = GetSectionPtr (pINF, SectionHandle);
        SectionHandle = Section->NextSection;
        FREE (Section);
    }

    //
    // free the inf structure too
    //
    FREE(pINF);

    return( EZERO );
}


SECTION_HANDLE
AddSection (
    IN      PSWAP_INF InfHandle,
    IN      PCHAR SectionName
    )
{
    SECTION_HANDLE SectionHandle;
    PSWAP_SECTION Section;
    unsigned SectionSize;

    //
    // Let's walk through the section structures to make sure that this section does
    // not exist.
    //
    SectionHandle = InfHandle->FirstSection;
    while (SectionHandle) {

        Section = GetSectionPtr (InfHandle, SectionHandle);
        if (stricmp (Section->SectionName, SectionName) == 0) {
            break;
        }
        SectionHandle = GetNextSection (InfHandle, SectionHandle);
    }
    if (!SectionHandle) {
        //
        // Allocate the section structure
        //
        SectionSize = sizeof(SWAP_SECTION) + (SectionName?strlen (SectionName):0) + 1;
        Section = MALLOC (SectionSize, TRUE);
        Section->SectionSize = SectionSize;
        Section->NextSection = NULL;
        Section->FirstLine = NULL_HANDLE;
        Section->LastLine = NULL_HANDLE;
        if (SectionName) {
            strcpy (Section->SectionName, SectionName);
        }
        else {
            Section->SectionName[0] = 0;
        }

        //
        // Store the newly created section
        //
        SectionHandle = StoreNewSection (InfHandle, Section);
    }
    return SectionHandle;
}


LINE_HANDLE
AddLine (
    IN      PSWAP_INF InfHandle,
    IN      SECTION_HANDLE Section,
    IN      PCHAR LineName
    )
{
    LINE_HANDLE LineHandle;
    PSWAP_LINE Line;
    unsigned LineSize;

    //
    // Allocate the line structure
    //
    LineSize = sizeof(SWAP_LINE) + (LineName?strlen (LineName):0) + 1;
    Line = MALLOC (LineSize, TRUE);
    Line->LineSize = LineSize;
    Line->NextLine = NULL_HANDLE;
    Line->FirstValue = NULL_HANDLE;
    Line->LastValue = NULL_HANDLE;
    if (LineName) {
        strcpy (Line->LineName, LineName);
    }
    else {
        Line->LineName[0] = 0;
    }

    //
    // Store the newly created line
    //
    LineHandle = StoreNewLine (InfHandle, Section, Line);
    FREE (Line);
    return LineHandle;
}


VALUE_HANDLE
AddValue (
    IN      PSWAP_INF InfHandle,
    IN      LINE_HANDLE Line,
    IN      PCHAR ValueName
    )
{
    VALUE_HANDLE ValueHandle;
    PSWAP_VALUE Value;
    unsigned ValueSize;

    //
    // Allocate the value structure
    //
    ValueSize = sizeof(SWAP_VALUE) + (ValueName?strlen (ValueName):0) + 1;
    Value = MALLOC (ValueSize, TRUE);
    Value->ValueSize = ValueSize;
    Value->NextValue = NULL_HANDLE;
    if (ValueName) {
        strcpy (Value->ValueName, ValueName);
    }
    else {
        Value->ValueName[0] = 0;
    }

    //
    // Store the newly created line
    //
    ValueHandle = StoreNewValue (InfHandle, Line, Value);
    FREE (Value);
    return ValueHandle;
}


PSWAP_SECTION
GetSectionPtr (
    IN      PSWAP_INF InfHandle,
    IN      SECTION_HANDLE SectionHandle
    )
{
    return (PSWAP_SECTION) SectionHandle;
}


PSWAP_LINE
GetLinePtr (
    IN      PSWAP_INF InfHandle,
    IN      LINE_HANDLE LineHandle
    )
{
    //
    // Verify if the buffer contains the requested line (at least the size of LineSize)
    //
    if ((InfHandle->BufferStart > LineHandle) ||
        (InfHandle->BufferEnd < (LineHandle + sizeof (unsigned))) ||
        (InfHandle->BufferEnd < (LineHandle + *((PUNSIGNED)(InfHandle->Buffer+LineHandle-InfHandle->BufferStart))))
        ) {
        LoadBuffer (InfHandle, LineHandle);
    }
    return (PSWAP_LINE) (InfHandle->Buffer+LineHandle-InfHandle->BufferStart);
}


PSWAP_VALUE
GetValuePtr (
    IN      PSWAP_INF InfHandle,
    IN      VALUE_HANDLE ValueHandle
    )
{
    //
    // Verify if the buffer contains the requested value (at least the size of ValueSize)
    //
    if ((InfHandle->BufferStart > ValueHandle) ||
        (InfHandle->BufferEnd < (ValueHandle + sizeof (unsigned))) ||
        (InfHandle->BufferEnd < (ValueHandle + *((PUNSIGNED)(InfHandle->Buffer+ValueHandle-InfHandle->BufferStart))))
        ) {
        LoadBuffer (InfHandle, ValueHandle);
    }
    return (PSWAP_VALUE) (InfHandle->Buffer+ValueHandle-InfHandle->BufferStart);
}


SECTION_HANDLE
GetNextSection (
    IN      PSWAP_INF InfHandle,
    IN      SECTION_HANDLE SectionHandle
    )
{
    PSWAP_SECTION Section;

    Section = GetSectionPtr (InfHandle, SectionHandle);
    return Section->NextSection;
}


LINE_HANDLE
GetNextLine (
    IN      PSWAP_INF InfHandle,
    IN      LINE_HANDLE LineHandle
    )
{
    PSWAP_LINE Line;

    Line = GetLinePtr (InfHandle, LineHandle);
    return Line->NextLine;
}


VALUE_HANDLE
GetNextValue (
    IN      PSWAP_INF InfHandle,
    IN      VALUE_HANDLE ValueHandle
    )
{
    PSWAP_VALUE Value;

    Value = GetValuePtr (InfHandle, ValueHandle);
    return Value->NextValue;
}


SECTION_HANDLE
StoreNewSection (
    IN      PSWAP_INF InfHandle,
    IN      PSWAP_SECTION Section
    )
{
    PSWAP_SECTION LastSectionPtr;

    if (!InfHandle->FirstSection) {
        InfHandle->FirstSection = (SECTION_HANDLE) Section;
        InfHandle->LastSection = (SECTION_HANDLE) Section;
    }
    else {
        LastSectionPtr = GetSectionPtr (InfHandle, InfHandle->LastSection);
        LastSectionPtr->NextSection = (SECTION_HANDLE) Section;
        InfHandle->LastSection = (SECTION_HANDLE) Section;
    }
    return (SECTION_HANDLE) Section;
}


LINE_HANDLE
StoreNewLine (
    IN      PSWAP_INF InfHandle,
    IN      SECTION_HANDLE Section,
    IN      PSWAP_LINE Line
    )
{
    PSWAP_SECTION SectionPtr;
    LINE_HANDLE LineHandle;
    PSWAP_LINE LastLinePtr;

    //
    // Let's store data in the swap file
    //
    if ((InfHandle->BufferSize-InfHandle->BufferEnd+InfHandle->BufferStart) < Line->LineSize) {
        LoadBuffer (InfHandle, 0);
    }
    memcpy (InfHandle->Buffer+InfHandle->BufferEnd-InfHandle->BufferStart, Line, Line->LineSize);
    InfHandle->BufferDirty = TRUE;
    LineHandle = InfHandle->BufferEnd;
    InfHandle->BufferEnd += Line->LineSize;

    SectionPtr = GetSectionPtr (InfHandle, Section);
    if (!SectionPtr->LastLine) {
        SectionPtr->FirstLine = LineHandle;
        SectionPtr->LastLine = LineHandle;
    }
    else {
        LastLinePtr = GetLinePtr (InfHandle, SectionPtr->LastLine);
        LastLinePtr->NextLine = LineHandle;
        InfHandle->BufferDirty = TRUE;
        SectionPtr = GetSectionPtr (InfHandle, Section);
        SectionPtr->LastLine = LineHandle;
    }
    return LineHandle;
}


VALUE_HANDLE
StoreNewValue (
    IN      PSWAP_INF InfHandle,
    IN      LINE_HANDLE Line,
    IN      PSWAP_VALUE Value
    )
{
    PSWAP_LINE LinePtr;
    VALUE_HANDLE ValueHandle;
    PSWAP_VALUE LastValuePtr;

    //
    // Let's store data in the swap file
    //
    if ((InfHandle->BufferSize-InfHandle->BufferEnd+InfHandle->BufferStart) < Value->ValueSize) {
        LoadBuffer (InfHandle, 0);
    }
    memcpy (InfHandle->Buffer+InfHandle->BufferEnd-InfHandle->BufferStart, Value, Value->ValueSize);
    InfHandle->BufferDirty = TRUE;
    ValueHandle = InfHandle->BufferEnd;
    InfHandle->BufferEnd += Value->ValueSize;

    LinePtr = GetLinePtr (InfHandle, Line);
    if (!LinePtr->LastValue) {
        LinePtr->FirstValue = ValueHandle;
        LinePtr->LastValue = ValueHandle;
        InfHandle->BufferDirty = TRUE;
    }
    else {
        LastValuePtr = GetValuePtr (InfHandle, LinePtr->LastValue);
        LastValuePtr->NextValue = ValueHandle;
        InfHandle->BufferDirty = TRUE;
        LinePtr = GetLinePtr (InfHandle, Line);
        LinePtr->LastValue = ValueHandle;
        InfHandle->BufferDirty = TRUE;
    }
    return ValueHandle;
}


BOOLEAN
LoadBuffer (
    IN      PSWAP_INF InfHandle,
    IN      unsigned long Offset
    )
{
    //
    // See if we need to write the buffer to disk (e.g. is dirty)
    //
    if (InfHandle->BufferDirty) {
        lseek (InfHandle->SwapFileHandle, InfHandle->BufferStart, SEEK_SET);
        write (InfHandle->SwapFileHandle, InfHandle->Buffer, (unsigned int) (InfHandle->BufferEnd-InfHandle->BufferStart));
    }
    if (!Offset) {
        Offset = lseek (InfHandle->SwapFileHandle, 0, SEEK_END);
    }
    InfHandle->BufferStart = lseek (InfHandle->SwapFileHandle, Offset, SEEK_SET);
    InfHandle->BufferEnd = InfHandle->BufferStart + read (InfHandle->SwapFileHandle, InfHandle->Buffer, MAX_BUFFER_SIZE);
    return TRUE;
}


SECTION_HANDLE
SearchSectionByName (
    IN       PSWAP_INF InfHandle,
    IN       PCHAR SectionName
    )
{
    SECTION_HANDLE SectionHandle;
    PSWAP_SECTION Section;

    SectionHandle = InfHandle->FirstSection;
    while (SectionHandle) {

        Section = GetSectionPtr (InfHandle, SectionHandle);
        if (stricmp (Section->SectionName, SectionName?SectionName:"") == 0) {
            break;
        }
        SectionHandle = GetNextSection (InfHandle, SectionHandle);
    }
    if (SectionHandle != InfHandle->LastSectionHandle) {
        InfHandle->LastSectionHandle = SectionHandle;
        InfHandle->LastLineIndex  = 0xffff;
        InfHandle->LastLineHandle = NULL_HANDLE;
        InfHandle->LastValueIndex  = 0xffff;
        InfHandle->LastValueHandle = NULL_HANDLE;
    }
    return SectionHandle;
}


LINE_HANDLE
SearchLineInSectionByName (
    IN       PSWAP_INF InfHandle,
    IN       SECTION_HANDLE Section,
    IN       PCHAR LineName
    )
{
    PSWAP_SECTION SectionPtr;
    LINE_HANDLE LineHandle;
    PSWAP_LINE Line;
    unsigned index;

    if (!Section) {
        return NULL_HANDLE;
    }

    SectionPtr = GetSectionPtr (InfHandle, Section);
    LineHandle = SectionPtr->FirstLine;
    index = 0;
    while (LineHandle) {

        Line = GetLinePtr (InfHandle, LineHandle);
        if (stricmp (Line->LineName, LineName?LineName:"") == 0) {
            break;
        }
        index ++;
        LineHandle = GetNextLine (InfHandle, LineHandle);
    }
    if (LineHandle != InfHandle->LastLineHandle) {
        InfHandle->LastLineIndex  = index;
        InfHandle->LastLineHandle = LineHandle;
        InfHandle->LastValueIndex  = 0xffff;
        InfHandle->LastValueHandle = NULL_HANDLE;
    }
    return LineHandle;
}


LINE_HANDLE
SearchLineInSectionByIndex (
    IN       PSWAP_INF InfHandle,
    IN       SECTION_HANDLE Section,
    IN       unsigned LineIndex
    )
{
    PSWAP_SECTION SectionPtr;
    LINE_HANDLE LineHandle;
    unsigned index;

    if (!Section) {
        return NULL_HANDLE;
    }

    //
    // Optimize access
    //
    if ((InfHandle->LastSectionHandle == Section) &&
        (InfHandle->LastLineIndex <= LineIndex)
        ) {
        LineHandle = InfHandle->LastLineHandle;
        index = InfHandle->LastLineIndex;
    }
    else {
        SectionPtr = GetSectionPtr (InfHandle, Section);
        LineHandle = SectionPtr->FirstLine;
        index = 0;
    }
    while (LineHandle) {

        if (index == LineIndex) {
            break;
        }
        index ++;
        LineHandle = GetNextLine (InfHandle, LineHandle);
    }
    if (LineHandle != InfHandle->LastLineHandle) {
        InfHandle->LastLineIndex  = LineIndex;
        InfHandle->LastLineHandle = LineHandle;
        InfHandle->LastValueIndex  = 0xffff;
        InfHandle->LastValueHandle = NULL_HANDLE;
    }
    return LineHandle;
}


VALUE_HANDLE
SearchValueInLineByIndex (
    IN       PSWAP_INF InfHandle,
    IN       LINE_HANDLE Line,
    IN       unsigned ValueIndex
    )
{
    PSWAP_LINE LinePtr;
    VALUE_HANDLE ValueHandle;
    unsigned index;

    if (!Line) {
        return NULL_HANDLE;
    }

    //
    // Optimize access
    //
    if ((InfHandle->LastLineHandle == Line) &&
        (InfHandle->LastValueIndex <= ValueIndex)
        ) {
        ValueHandle = InfHandle->LastValueHandle;
        index = InfHandle->LastValueIndex;
    }
    else {
        LinePtr = GetLinePtr (InfHandle, Line);
        ValueHandle = LinePtr->FirstValue;
        index = 0;
    }
    while (ValueHandle) {

        if (index == ValueIndex) {
            break;
        }
        index ++;
        ValueHandle = GetNextValue (InfHandle, ValueHandle);
    }
    InfHandle->LastValueIndex  = ValueIndex;
    InfHandle->LastValueHandle = ValueHandle;
    return ValueHandle;
}



//
// Globals used by the token parser
//

// string terminators are the whitespace characters (isspace: space, tab,
// linefeed, formfeed, vertical tab, carriage return) or the chars given below

CHAR  StringTerminators[] = {'[', ']', '=', ',', '\"', ' ', '\t',
                             '\n','\f','\v','\r','\032', 0};

//
// quoted string terminators allow some of the regular terminators to
// appear as characters

CHAR  QStringTerminators[] = {'\"', '\n','\f','\v', '\r','\032', 0};


//
// Main parser routine
//

BOOLEAN
ParseInfBuffer (
    IN      PSWAP_INF InfHandle,
    IN      FILE *File,
    IN OUT  unsigned *LineNumber
    )

/*++

Routine Description:

   Given a character buffer containing the INF file, this routine parses
   the INF into an internal form with Section records, Line records and
   Value records.

Arguments:

   InfHandle - PSWAP_INF structure used to create INF structures

   File - supplies open, rewound CRT handle to file.

   LineNumber - In case of error, this variable will contain the line
                in the file that contains a syntax error.

Return Value:

   TRUE  - the INF file was parsed successfully
   FALSE - otherwise

--*/

{
    PCHAR      pchSectionName, pchValue;
    unsigned   State, InfLine;
    TOKEN      Token;
    BOOLEAN    Done;
    BOOLEAN    Error;
    int        ErrorCode;

    SECTION_HANDLE LastSection = NULL;
    LINE_HANDLE LastLine = NULL_HANDLE;

    *LineNumber = 0;

    //
    // Set initial state
    //
    State     = 1;
    InfLine   = 1;
    Done      = FALSE;
    Error     = FALSE;

    //
    // Enter token processing loop
    //

    while (!Done)       {

       Token = GetToken(File);

       switch (State) {
       //
       // STATE1: Start of file, this state remains till first
       //         section is found
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_LBRACE
       case 1:
           switch (Token.Type) {
              case TOK_EOL:
                  break;
              case TOK_EOF:
                  Done = TRUE;
                  break;
              case TOK_LBRACE:
                  State = 2;
                  break;
              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  break;
           }
           break;

       //
       // STATE 2: Section LBRACE has been received, expecting STRING
       //
       // Valid Tokens: TOK_STRING
       //
       case 2:
           switch (Token.Type) {
              case TOK_STRING:
                  State = 3;
                  pchSectionName = Token.pValue;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  break;

           }
           break;

       //
       // STATE 3: Section Name received, expecting RBRACE
       //
       // Valid Tokens: TOK_RBRACE
       //
       case 3:
           switch (Token.Type) {
              case TOK_RBRACE:
                State = 4;
                break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  break;
           }
           break;
       //
       // STATE 4: Section Definition Complete, expecting EOL
       //
       // Valid Tokens: TOK_EOL, TOK_EOF
       //
       case 4:
           switch (Token.Type) {
              case TOK_EOL:
                  LastSection = AddSection (InfHandle, pchSectionName);
                  FREE (pchSectionName);
                  pchSectionName = NULL;
                  State = 5;
                  break;

              case TOK_EOF:
                  LastSection = AddSection (InfHandle, pchSectionName);
                  FREE (pchSectionName);
                  pchSectionName = NULL;
                  Done = TRUE;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  break;
           }
           break;

       //
       // STATE 5: Expecting Section Lines
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_STRING, TOK_LBRACE
       //
       case 5:
           switch (Token.Type) {
              case TOK_EOL:
                  break;
              case TOK_EOF:
                  Done = TRUE;
                  break;
              case TOK_STRING:
                  pchValue = Token.pValue;
                  State = 6;
                  break;
              case TOK_LBRACE:
                  State = 2;
                  break;
              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  break;
           }
           break;

       //
       // STATE 6: String returned, not sure whether it is key or value
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA, TOK_EQUAL
       //
       case 6:
           switch (Token.Type) {
              case TOK_EOL:
                  LastLine = AddLine (InfHandle, LastSection, NULL);
                  AddValue (InfHandle, LastLine, pchValue);
                  FREE (pchValue);
                  pchValue = NULL;
                  State = 5;
                  break;

              case TOK_EOF:
                  LastLine = AddLine (InfHandle, LastSection, NULL);
                  AddValue (InfHandle, LastLine, pchValue);
                  FREE (pchValue);
                  pchValue = NULL;
                  Done = TRUE;
                  break;

              case TOK_COMMA:
                  LastLine = AddLine (InfHandle, LastSection, NULL);
                  AddValue (InfHandle, LastLine, pchValue);
                  FREE (pchValue);
                  pchValue = NULL;
                  State = 7;
                  break;

              case TOK_EQUAL:
                  LastLine = AddLine (InfHandle, LastSection, pchValue);
                  FREE (pchValue);
                  pchValue = NULL;
                  State = 8;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  break;
           }
           break;

       //
       // STATE 7: Comma received, Expecting another string
       //
       // Valid Tokens: TOK_STRING
       //
       case 7:
           switch (Token.Type) {
              case TOK_STRING:
                  AddValue (InfHandle, LastLine, Token.pValue);
                  State = 9;
                  break;
              case TOK_COMMA:
                  AddValue (InfHandle, LastLine, NULL);
                  State = 7;
                  break;
              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  break;
           }
           break;
       //
       // STATE 8: Equal received, Expecting another string
       //
       // Valid Tokens: TOK_STRING
       //
       case 8:
           switch (Token.Type) {
              case TOK_STRING:
                  AddValue (InfHandle, LastLine, Token.pValue);
                  State = 9;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  break;
           }
           break;
       //
       // STATE 9: String received after equal, value string
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA
       //
       case 9:
           switch (Token.Type) {
              case TOK_EOL:
                  State = 5;
                  break;

              case TOK_EOF:
                  Done = TRUE;
                  break;

              case TOK_COMMA:
                  State = 7;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  break;
           }
           break;
       //
       // STATE 10: Value string definitely received
       //
       // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA
       //
       case 10:
           switch (Token.Type) {
              case TOK_EOL:
                  State =5;
                  break;

              case TOK_EOF:
                  Done = TRUE;
                  break;

              case TOK_COMMA:
                  State = 7;
                  break;

              default:
                  Error = Done = TRUE;
                  ErrorCode = EINVAL;
                  break;
           }
           break;

       default:
           Error = Done = TRUE;
           ErrorCode = EINVAL;
           break;

       } // end switch(State)


       if (Error) {
           switch (ErrorCode) {
               case ENOMEM:
                  DnFatalError(&DnsOutOfMemory);
               default:
                  break;
           }
       }
       else {

          //
          // Keep track of line numbers so that we can display Errors
          //

          if (Token.Type == TOK_EOL)
              InfLine++;
       }

    } // End while

    if (Error) {
        *LineNumber = InfLine;
    }

    return (BOOLEAN) (!Error);
}



BOOLEAN
TokenMatch (
    IN OUT  char **p,
    IN      char *line
    )

/*++

Routine Description:

    This function tries to match to string pointed to be line against
    a set of commonly used stirngs.  If we hit, we'll assign p to
    point to the matched string.

Arguments:

    p - Supplies a char pointer that we'll assign if we find a match.

    line - Supplies the address of the string we're trying to match.

Return Value:

    TRUE - we found a match and have assigned p

    FALSE - we found no match and made no assignment to p

--*/

{
int     i;

    if( (p == NULL) || (line == NULL) ) {
        return( FALSE );
    }

    for( i = 0; i < sizeof(CommonStrings)/sizeof(char *); i++ ) {
        if( !strcmp( line, CommonStrings[i] ) ) {
            //
            // Hit...
            //
            *p = (char *)CommonStrings[i];
            return( TRUE );
        }
    }
    return( FALSE );
}

TOKEN
GetToken(
    IN      FILE *File
    )

/*++

Routine Description:

    This function returns the Next token from the configuration stream.

Arguments:

    Stream - Supplies the address of the configuration stream.  Returns
        the address of where to start looking for tokens within the
        stream.

    MaxStream - Supplies the address of the last character in the stream.


Return Value:

    TOKEN - Returns the next token

--*/

{

    int i;
    unsigned Length;
    TOKEN Token;
    #define _MAXLINE 1024
    static char line[_MAXLINE+1];
    char *p;

    //
    // Skip whitespace (except for eol)
    //
    while(((i = fgetc(File)) != EOF) && (i != '\n') && (isspace(i) || (i == 26))) {
        ;
    }

    //
    // Check for comments and remove them
    //
    if((i != EOF) && ((i == '#') || (i == ';'))) {
        while(((i = fgetc(File)) != EOF) && (i != '\n')) {
            ;
        }
    }

    //
    // Check to see if EOF has been reached, set the token to the right
    // value
    //
    if(i == EOF) {
        Token.Type  = TOK_EOF;
        Token.pValue = NULL;
        return(Token);
    }

    switch(i) {

    case '[' :
        Token.Type  = TOK_LBRACE;
        Token.pValue = NULL;
        break;

    case ']' :
        Token.Type  = TOK_RBRACE;
        Token.pValue = NULL;
        break;

    case '=' :
        Token.Type  = TOK_EQUAL;
        Token.pValue = NULL;
        break;

    case ',' :
        Token.Type  = TOK_COMMA;
        Token.pValue = NULL;
        break;

    case '\n' :
        Token.Type  = TOK_EOL;
        Token.pValue = NULL;
        break;

    case '\"':

        //
        // determine quoted string
        //
        Length = 0;
        while(((i = fgetc(File)) != EOF) && !strchr(QStringTerminators,i)) {
            if(Length < _MAXLINE) {
                line[Length++] = (char)i;
            }
        }

        if((i == EOF) || (i != '\"')) {
            Token.Type   = TOK_ERRPARSE;
            Token.pValue = NULL;
        } else {
            line[Length] = 0;
            p = MALLOC(Length+1,TRUE);
            strcpy(p,line);
            Token.Type = TOK_STRING;
            Token.pValue = p;
        }
        break;

    default:
        //
        // determine regular string
        //
        line[0] = (char)i;
        Length = 1;
        while(((i = fgetc(File)) != EOF) && !strchr(StringTerminators,i)) {
            if(Length < _MAXLINE) {
                line[Length++] = (char)i;
            }
        }

        //
        // Put back the char that terminated the string.
        //
        if(i != EOF) {
            ungetc(i,File);
        }

        line[Length] = 0;

        //
        // See if we can use one of the common strings.
        //
        if( !TokenMatch ( &p, line ) ) {
            //
            // Nope.
            //
            p = MALLOC(Length+1,TRUE);
            strcpy(p,line);
        }
        else {
            char *p1;
            p1 = MALLOC (strlen(p)+1, TRUE);
            strcpy (p1, p);
            p = p1;
        }
        Token.Type = TOK_STRING;
        Token.pValue = p;
        break;
    }

    return(Token);
}


BOOLEAN
DnSearchINFSection (
    IN      PVOID INFHandle,
    IN      PCHAR SectionName
    )
{
    return (BOOLEAN) (SearchSectionByName ((PSWAP_INF)INFHandle, SectionName) != NULL_HANDLE);
}


PCHAR
DnGetSectionLineIndex (
    IN      PVOID INFHandle,
    IN      PCHAR SectionName,
    IN      unsigned LineIndex,
    IN      unsigned ValueIndex
    )
{
    SECTION_HANDLE SectionHandle;
    LINE_HANDLE LineHandle;
    VALUE_HANDLE ValueHandle;
    PSWAP_VALUE Value;
    PCHAR result;

    SectionHandle = SearchSectionByName ((PSWAP_INF)INFHandle, SectionName);

    if (!SectionHandle) {
        return NULL;
    }

    LineHandle = SearchLineInSectionByIndex ((PSWAP_INF)INFHandle, SectionHandle, LineIndex);

    if (!LineHandle) {
        return NULL;
    }

    ValueHandle = SearchValueInLineByIndex ((PSWAP_INF)INFHandle, LineHandle, ValueIndex);

    if (!ValueHandle) {
        return NULL;
    }

    Value = GetValuePtr ((PSWAP_INF)INFHandle, ValueHandle);

    result = MALLOC (Value->ValueSize - sizeof(SWAP_VALUE), TRUE);

    strcpy (result, Value->ValueName);

    return result;
}


BOOLEAN
DnGetSectionKeyExists (
    IN      PVOID INFHandle,
    IN      PCHAR SectionName,
    IN      PCHAR Key
   )
{
    SECTION_HANDLE SectionHandle;

    SectionHandle = SearchSectionByName ((PSWAP_INF)INFHandle, SectionName);

    if (!SectionHandle) {
        return FALSE;
    }

    return (BOOLEAN) (SearchLineInSectionByName ((PSWAP_INF)INFHandle, SectionHandle, Key) != NULL_HANDLE);
}

BOOLEAN
DnGetSectionEntryExists (
    IN      PVOID INFHandle,
    IN      PCHAR SectionName,
    IN      PCHAR Entry
   )
{
    SECTION_HANDLE SectionHandle;
    LINE_HANDLE LineHandle;
    PSWAP_SECTION SectionPtr=NULL;
    PSWAP_LINE LinePtr=NULL;
    PSWAP_VALUE ValuePtr=NULL;
    PCHAR pEntryName;

    SectionHandle = SearchSectionByName ((PSWAP_INF)INFHandle, SectionName);

    if (!SectionHandle) {
        return FALSE;
    }

    //_LOG(("Found [%s]\n", SectionName));

    SectionPtr = GetSectionPtr((PSWAP_INF)INFHandle, SectionHandle);

    LineHandle = SectionPtr->FirstLine;

    while( LineHandle ){

        LinePtr = GetLinePtr((PSWAP_INF)INFHandle, LineHandle);

        pEntryName = NULL;

        if( LinePtr->LineName[0] != 0){
            pEntryName = LinePtr->LineName;
            // _LOG(("Found Line %s\n", pEntryName));
        }else{
            ValuePtr = GetValuePtr((PSWAP_INF)INFHandle, LinePtr->FirstValue);
            if (ValuePtr && (ValuePtr->ValueName[0] != 0)) {
                pEntryName = ValuePtr->ValueName;
            }else
                pEntryName = NULL;

        }
        //_LOG(("Found Entry %s\n", pEntryName));

        if( pEntryName && !stricmp( pEntryName, Entry )){
            return TRUE;
        }

        LineHandle = GetNextLine((PSWAP_INF)INFHandle, LineHandle);

        

    }// while

    return FALSE;
}



PCHAR
DnGetSectionKeyIndex (
    IN      PVOID INFHandle,
    IN      PCHAR SectionName,
    IN      PCHAR Key,
    IN      unsigned ValueIndex
    )
{
    SECTION_HANDLE SectionHandle;
    LINE_HANDLE LineHandle;
    VALUE_HANDLE ValueHandle;
    PSWAP_VALUE Value;
    PCHAR result;

    SectionHandle = SearchSectionByName ((PSWAP_INF)INFHandle, SectionName);

    if (!SectionHandle) {
        return NULL;
    }

    LineHandle = SearchLineInSectionByName ((PSWAP_INF)INFHandle, SectionHandle, Key);

    if (!LineHandle) {
        return NULL;
    }

    ValueHandle = SearchValueInLineByIndex ((PSWAP_INF)INFHandle, LineHandle, ValueIndex);

    if (!ValueHandle) {
        return NULL;
    }

    Value = GetValuePtr ((PSWAP_INF)INFHandle, ValueHandle);

    result = MALLOC (Value->ValueSize - sizeof(SWAP_VALUE), TRUE);

    strcpy (result, Value->ValueName);

    return result;
}


PCHAR
DnGetKeyName (
    IN      PVOID INFHandle,
    IN      PCHAR SectionName,
    IN      unsigned LineIndex
    )
{
    SECTION_HANDLE SectionHandle;
    LINE_HANDLE LineHandle;
    PSWAP_LINE Line;
    PCHAR result;

    SectionHandle = SearchSectionByName ((PSWAP_INF)INFHandle, SectionName);

    if (!SectionHandle) {
        return NULL;
    }

    LineHandle = SearchLineInSectionByIndex ((PSWAP_INF)INFHandle, SectionHandle, LineIndex);

    if (!LineHandle) {
        return NULL;
    }

    Line = GetLinePtr ((PSWAP_INF)INFHandle, LineHandle);

    result = MALLOC (Line->LineSize - sizeof(SWAP_LINE), TRUE);

    strcpy (result, Line->LineName);

    return result;
}


PVOID
DnNewSetupTextFile (
    VOID
    )
{
    char SwapFilePath[MAX_PATH];
    PSWAP_INF InfHandle = NULL;
    unsigned long SwapSign;

    //
    // Prepare the swap file path
    //
    sprintf (SwapFilePath, "%c:\\INF%03u.SWP", DngSwapDriveLetter, g_Sequencer++);

    //
    // Allocate and populate the SWAP_INF structure
    //
    InfHandle = MALLOC(sizeof(SWAP_INF) + strlen (SwapFilePath) + 1, TRUE);
    InfHandle->CurrentSection = NULL;
    InfHandle->FirstSection   = NULL;
    InfHandle->LastSection    = NULL;
    InfHandle->SwapFileHandle = -1;
    InfHandle->BufferSize     = 0;
    InfHandle->BufferDirty    = FALSE;
    InfHandle->Buffer         = NULL;
    InfHandle->BufferStart    = 0;
    InfHandle->BufferEnd      = 0;
    InfHandle->LastSectionHandle = NULL_HANDLE;
    InfHandle->LastLineIndex     = 0xffff;
    InfHandle->LastLineHandle    = NULL_HANDLE;
    InfHandle->LastValueIndex    = 0xffff;
    InfHandle->LastValueHandle   = NULL_HANDLE;
    strcpy (InfHandle->SwapFile, SwapFilePath);

    //
    // Prepare the swap file
    //
    InfHandle->SwapFileHandle = open (InfHandle->SwapFile, O_BINARY|O_CREAT|O_TRUNC|O_RDWR, S_IREAD|S_IWRITE);
    if (InfHandle->SwapFileHandle == -1) {
        FREE (InfHandle);
        return NULL;
    }
    else {
        //
        // write down signature
        //
        SwapSign = SWAP_SIGNATURE;
        write (InfHandle->SwapFileHandle, &SwapSign, SWAP_SIGN_SIZE);

        //
        // Prepare the buffer
        //
        InfHandle->BufferSize = MAX_BUFFER_SIZE;
        InfHandle->Buffer = MALLOC (MAX_BUFFER_SIZE, TRUE);
        InfHandle->BufferStart = SWAP_SIGN_SIZE;
        InfHandle->BufferEnd = SWAP_SIGN_SIZE;
        return InfHandle;
    }
}


BOOLEAN
DnWriteSetupTextFile (
    IN      PVOID INFHandle,
    IN      PCHAR FileName
    )
{
    struct  find_t  FindData;
    FILE            *Handle;
    PSWAP_INF       pInf;
    SECTION_HANDLE Section;
    PSWAP_SECTION SectionPtr;
    LINE_HANDLE Line;
    PSWAP_LINE LinePtr;
    VALUE_HANDLE Value;
    PSWAP_VALUE ValuePtr;

    //
    // See if the file exists and see if it is in read-only mode
    //
    if(!_dos_findfirst(FileName,_A_HIDDEN|_A_SUBDIR|_A_SYSTEM|_A_RDONLY,&FindData)) {

        //
        // The File Exists -- Perform some simple checks
        //
        if (FindData.attrib & _A_RDONLY) {

            //
            // Make it writeable
            //
            _dos_setfileattr(FileName,_A_NORMAL);

        }

        if (FindData.attrib & _A_SUBDIR) {

            //
            // This isn't a valid file that we can work with..
            //
            return FALSE;

        }
    }
    //
    // Obtain a handle to the file in write-only mode
    //
    Handle = fopen(FileName, "w+");
    if (Handle == NULL) {

        //
        // We could not open the file
        //
        return FALSE;
    }

    pInf = (PSWAP_INF) INFHandle;
    if (pInf == NULL) {

        //
        // There isn't anything in the file.
        // That isn't an error since we can empty
        // the file if we so desire, but this is a
        // strange way todo that. However...
        //
        fclose(Handle);
        return TRUE;
    }

    //
    // NOTE - This can't handle > 64k buffers. Which may or may not be
    // important
    //
    Section = pInf->FirstSection;
    while (Section) {
        SectionPtr = GetSectionPtr (pInf, Section);

        fprintf (Handle, "[%s]\n", SectionPtr->SectionName);

        Line = SectionPtr->FirstLine;
        while (Line) {
            LinePtr = GetLinePtr (pInf, Line);

            if ((LinePtr->LineName) && (LinePtr->LineName[0])) {
                if (strchr (LinePtr->LineName, ' ') == NULL) {
                    fprintf (Handle, "%s = ", LinePtr->LineName);
                } else {
                    fprintf (Handle, "\"%s\" = ", LinePtr->LineName);
                }
            }

            Value = LinePtr->FirstValue;
            while (Value) {
                ValuePtr = GetValuePtr (pInf, Value);

                fprintf (Handle,"\"%s\"", ValuePtr->ValueName);

                Value = GetNextValue (pInf, Value);
                if (Value) {
                    fprintf (Handle, ",");
                }
            }
            Line = GetNextLine (pInf, Line);
            fprintf (Handle,"\n");
        }
        Section = GetNextSection (pInf, Section);
    }

    //
    // Flush and Close the file
    //
    fflush(Handle);
    fclose(Handle);
    return TRUE;
}


VOID
DnAddLineToSection (
    IN      PVOID INFHandle,
    IN      PCHAR SectionName,
    IN      PCHAR KeyName,
    IN      PCHAR Values[],
    IN      ULONG ValueCount
    )
{
    SECTION_HANDLE SectionHandle;
    LINE_HANDLE LineHandle;
    VALUE_HANDLE ValueHandle;
    ULONG v;

    SectionHandle = AddSection ((PSWAP_INF)INFHandle, SectionName);
    LineHandle = AddLine ((PSWAP_INF)INFHandle, SectionHandle, KeyName);

    for (v = 0; v<ValueCount; v++) {

        ValueHandle = AddValue ((PSWAP_INF)INFHandle, LineHandle, Values[v]);
    }
}


PCHAR
DnGetSectionName (
    IN      PVOID INFHandle
    )
{
    PSWAP_INF pInf;
    PSWAP_SECTION Section;
    PCHAR result;

    pInf = (PSWAP_INF)INFHandle;
    if (!pInf->CurrentSection) {
        pInf->CurrentSection = pInf->FirstSection;
    }
    else {
        pInf->CurrentSection = GetNextSection (pInf, pInf->CurrentSection);
    }
    if (!pInf->CurrentSection) {
        return NULL;
    }
    Section = GetSectionPtr (pInf, pInf->CurrentSection);

    result = MALLOC (Section->SectionSize - sizeof(SWAP_SECTION), TRUE);

    strcpy (result, Section->SectionName);

    return result;
}


VOID
DnCopySetupTextSection (
    IN      PVOID FromInf,
    IN      PVOID ToInf,
    IN      PCHAR SectionName
    )
{
    PSWAP_INF SourceInf;
    PSWAP_INF DestInf;
    SECTION_HANDLE SourceSection;
    SECTION_HANDLE DestSection;
    PSWAP_SECTION SectionPtr;
    LINE_HANDLE SourceLine;
    LINE_HANDLE DestLine;
    PSWAP_LINE LinePtr;
    VALUE_HANDLE SourceValue;
    VALUE_HANDLE DestValue;
    PSWAP_VALUE ValuePtr;

    SourceInf = (PSWAP_INF)FromInf;
    DestInf   = (PSWAP_INF)ToInf;

    SourceSection = SearchSectionByName (FromInf, SectionName);
    if (SourceSection) {
        SectionPtr = GetSectionPtr (SourceInf, SourceSection);
        DestSection = AddSection (DestInf, SectionPtr->SectionName);
        if (DestSection) {
            SourceLine = SectionPtr->FirstLine;
            while (SourceLine) {
                LinePtr = GetLinePtr (SourceInf, SourceLine);
                DestLine = AddLine (DestInf, DestSection, LinePtr->LineName);
                SourceValue = LinePtr->FirstValue;
                while (SourceValue) {
                    ValuePtr = GetValuePtr (SourceInf, SourceValue);
                    DestValue = AddValue (DestInf, DestLine, ValuePtr->ValueName);
                    SourceValue = GetNextValue (SourceInf, SourceValue);
                }
                SourceLine = GetNextLine (SourceInf, SourceLine);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\nttypes.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    nttypes.h

Abstract:

    Temporary file for defining NT types, etc.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#define IN
#define OUT
#define OPTIONAL


typedef void VOID,*PVOID;

typedef unsigned char UCHAR,*PUCHAR;
typedef char CHAR,*PCHAR;

typedef unsigned long ULONG,*PULONG;
typedef long LONG,*PLONG;

typedef unsigned short USHORT,*PUSHORT;
typedef short SHORT,*PSHORT;

typedef UCHAR BOOLEAN,*PBOOLEAN;

#define TRUE  ((BOOLEAN)1)
#define FALSE ((BOOLEAN)0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\dninf.h ===
#ifndef _DNINF_
#define _DNINF_


//
// returns a handle to use for further inf parsing
//

int
DnInitINFBuffer (
    IN      FILE     *InfFileHandle,
    OUT     PVOID    *pINFHandle,
    OUT     unsigned *LineNumber
    );


//
// frees an INF Buffer
//

int
DnFreeINFBuffer (
    IN      PVOID INFHandle
    );


//
// searches for the existance of a particular section
//

BOOLEAN
DnSearchINFSection (
    IN      PVOID INFHandle,
    IN      PCHAR SectionName
    );


//
// given section name, line number and index return the value.
//

PCHAR
DnGetSectionLineIndex (
    IN      PVOID INFHandle,
    IN      PCHAR SectionName,
    IN      unsigned LineIndex,
    IN      unsigned ValueIndex
    );


//
// given section name, key searches existance
//

BOOLEAN
DnGetSectionKeyExists (
    IN      PVOID INFHandle,
    IN      PCHAR SectionName,
    IN      PCHAR Key
    );

//
// given section name, entry searches existance as key or first value
//


BOOLEAN
DnGetSectionEntryExists (
    IN      PVOID INFHandle,
    IN      PCHAR SectionName,
    IN      PCHAR Entry
   );

//
// given section name, key and index return the value
//

PCHAR
DnGetSectionKeyIndex (
    IN      PVOID INFHandle,
    IN      PCHAR SectionName,
    IN      PCHAR Key,
    IN      unsigned ValueIndex
    );


//
// given section name and line index, return key
//

PCHAR
DnGetKeyName (
    IN      PVOID INFHandle,
    IN      PCHAR SectionName,
    IN      unsigned LineIndex
    );


//
// Return a handle to a new INF handle
//

PVOID
DnNewSetupTextFile (
    VOID
    );


//
// Write an Inf file to disk
//

BOOLEAN
DnWriteSetupTextFile (
    IN      PVOID INFHandle,
    IN      PCHAR FileName
    );


//
// Add a line to a section in the
// inf file
//

VOID
DnAddLineToSection (
    IN      PVOID INFHandle,
    IN      PCHAR SectionName,
    IN      PCHAR KeyName,
    IN      PCHAR Values[],
    IN      ULONG ValueCount
    );


//
// Get the next section name in the inf file
//

PCHAR
DnGetSectionName (
    IN      PVOID INFHandle
    );


//
// Copy a section from one inf to another inf
//

VOID
DnCopySetupTextSection (
    IN      PVOID FromInf,
    IN      PVOID ToInf,
    IN      PCHAR SectionName
    );


#endif // _DNINF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=

SOURCES=
SOURCES_USED=..\sources.inc

!IF $(386)

# cl16's command line exceeds the limit when including public\sdk\inc;
# copy these headers locally.

NTTARGETFILE0=\
    $(O)\setupbat.h    \
    $(O)\bootfat.h     \
    $(O)\bootf32.h

NTTARGETFILE1=\
    $(O)\winnt.exe

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\sptxtcns.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    sptxtcns.h

Abstract:

    Text constant used internally and shared among various
    setupldr-environment programs, gui setup.exe, and DOS net nt setup.

Author:

    Ted Miller (tedm) April-1992

Revision History:

--*/



//
// Define name of the directory used on the local source to hold the
// Windows NT sources
//

#define LOCAL_SOURCE_DIRECTORY "\\$WIN_NT$.~LS"

//
// Floppyless boot root directory for x86
//
#define FLOPPYLESS_BOOT_ROOT "\\$WIN_NT$.~BT"
#define FLOPPYLESS_BOOT_SEC  "BOOTSECT.DAT"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\makefile.inc ===
# Use specific 16-bit compiler/linker/masm
# PATH = $(MAKEDIR)\..\c6\bin;$(PATH)
PATH = $(PATH_TOOLS16);$(PATH)

!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

!IFNDEF DEBUG
DEBUG=0
!ENDIF

!IF $(DEBUG)
C_DBG_FLAGS=-Zi -Od -DDBG=1
ASM_DBG_FLAGS=-Zi
LINK_DBG_FLAGS=/codeview
!ELSE
C_DBG_FLAGS=-DDBG=0
ASM_DBG_FLAGS=
LINK_DBG_FLAGS=
!ENDIF

# Set up define for building dntext.obj
!IFNDEF DNTEXT_C_FILE
DNTEXT_C_FILE= dntext.c
!ENDIF

#
# Compiler and masm flags
#

CC= cl16
CFCOMMON=-WX -W3 -Zel -G2 -AC $(C_DBG_FLAGS)
CINC=-X -I.. -I..\c6\inc -I$(O) -I..\..\..\inc
CFLAGS=$(CFCOMMON) $(CFOPT)

AS=masm
AFLAGS=-Ml $(ASM_DBG_FLAGS)
AINC=-X -I..

#
# Inference rules
#

.SUFFIXES: .h .asm .c

# cl16's command line is approaching the size limit;
# do not add unnecessary spaces or long compiler flags.

{}.c{$(O)}.obj:
    $(CC) $(CFLAGS) $(CINC) -c /Fo$(@D)\ $<

{..}.c{$(O)}.obj:
    $(CC) $(CFLAGS) $(CINC) -c /Fo$(@D)\ $<

{..}.c{$(O)}.cod:
    $(CC) $(CFLAGS) $(CINC) -Fc -c /Fo$(@D)\ $<

{..}.asm{$(O)}.obj:
    $(AS) $(AFLAGS) $(AINC) $< ,$(@D)\;

# Copy .h files from public\sdk\inc locally,
# so that cl16's command line does not exceed the limit.

{$(SDK_INC_PATH)}.h{$(O)}.h:
    copy $** $@

# link16's command line is approaching the size limit;
# do not add unnecessary spaces in defining OBJS.

OBJS =\
 $(O)\winnt.obj\
 $(O)\dnutil.obj\
 $(O)\dntext.obj\
!IFDEF JAPAN
 $(O)\dndispjp.obj\
!ELSE
 $(O)\dndisp.obj\
!ENDIF
 $(O)\dninf.obj\
 $(O)\dncopy.obj\
 $(O)\dnboot.obj\
 $(O)\dngauge.obj\
 $(O)\dndelnod.obj\
 $(O)\dnnttree.obj\
 $(O)\dncompv.obj\
 $(O)\dna.obj\
 $(O)\cpu.obj

LIBS = ..\..\..\c6\lib\clibce

$(O)\winnt.exe: $(OBJS) $(PATH_TOOLS16)\$(CC).exe
    cd $(O)
    link16 @<<
$(OBJS:obj\i386\=) /NOI /STACK:0x1000 $(LINK_DBG_FLAGS)
winnt.exe
nul
$(LIBS)


<<
    cd $(MAKEDIR)
    -binplace $(BINPLACE_OPT) -O $(ALT_PROJECT_TARGET) $@


$(O)\winnt.obj:      ..\winnt.c      ..\winnt.h ..\dninf.h
$(O)\dnutil.obj:     ..\dnutil.c     ..\winnt.h ..\dninf.h
$(O)\dninf.obj:      ..\dninf.c      ..\winnt.h ..\dninf.h
$(O)\dncopy.obj:     ..\dncopy.c     ..\winnt.h ..\dninf.h
$(O)\dnboot.obj:     ..\dnboot.c     ..\winnt.h ..\dninf.h
$(O)\dngauge.obj:    ..\dngauge.c    ..\winnt.h ..\dninf.h
$(O)\dndelnod.obj:   ..\dndelnod.c   ..\winnt.h ..\dninf.h
$(O)\dnnttree.obj:   ..\dnnttree.c   ..\winnt.h ..\dninf.h
$(O)\dncompv.obj:    ..\dncompv.c    ..\winnt.h ..\dncompvp.h
$(O)\dna.obj:        ..\dna.asm
$(O)\cpu.obj:        ..\cpu.asm      ..\cpu.inc

$(O)\dntext.obj:     $(DNTEXT_C_FILE)     ..\winnt.h ..\dninf.h
    $(CC) $(CFLAGS) $(CINC) -c /Fo$(@D)\ $(DNTEXT_C_FILE)

!IFDEF JAPAN
$(O)\dndispjp.obj:   ..\dndispjp.c         ..\winnt.h ..\dninf.h
!ELSE
$(O)\dndisp.obj:     ..\dndisp$(JP_EXT).c  ..\winnt.h ..\dninf.h
!ENDIF

!IFDEF COPY_USA_WINNT
$(O)\winntus.exe: ..\usa\$(O)\winnt.exe
   copy $** $@
   binplace -O $(ALT_PROJECT_TARGET) $@
!ELSE
$(O)\winntus.exe: ..\us2\$(O)\winnt.exe
   copy $** $@
   binplace -O $(ALT_PROJECT_TARGET) $@
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\dnnttree.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dnnttree.c

Abstract:

    Code for manipulating (removing) Windows NT directory trees
    for DOS-based setup.

    This code is highly dependent on the format of repair.inf.

Author:

    Ted Miller (tedm) 30-March-1993

Revision History:

--*/



#include "winnt.h"
#include <string.h>
#include <dos.h>

#if 0  // /D removed
//
// /D is no longer supported
//

#define SETUP_LOG           "setup.log"
#define LINE_BUFFER_SIZE    750
#define REPAIR_SECTION_NAME "Repair.WinntFiles"


PCHAR RegistryFiles[] = { "system",
                          "software",
                          "default",
                          "sam",
                          "security",
                          "userdef",
                          NULL
                        };

PCHAR RegistrySuffixes[] = { "",".log",".alt",NULL };


PCHAR
DnpSectionName(
    IN PCHAR Line
    )

/*++

Routine Description:

    Determine whether a line is an inf section title, and return the
    section name if so.

Arguments:

    Line - supplies line read from inf file.

Return Value:

    NULL if line is not a section title.  Otherwise, returns a buffer
    containing the name of the section, which the caller must free
    via FREE().

--*/

{
    PCHAR End;

    //
    // Skip leading whitespace.
    //
    Line += strspn(Line," \t");

    //
    // If first non-whitepsace char is not [, then this
    // is not a section name.
    //
    if(*Line != '[') {
        return(NULL);
    }

    //
    // Skip the left bracket.
    //
    Line++;

    //
    // Find the end of the section name.  Look backwards for the terminating
    // right bracket.
    //
    if(End = strrchr(Line,']')) {
        *End = 0;
    }

    //
    // Duplicate the section name and return it to the caller.
    //
    return(DnDupString(Line));
}


PCHAR
DnpFileToDelete(
    IN CHAR  Drive,
    IN PCHAR Line
    )

/*++

Routine Description:

    Given a line from an inf file, pull out the second field on it and
    prefix this value with a drive spec.  This forms a full pathname of
    a file contained within the windows nt installation being removed.

Arguments:

    Drive - supplies drive letter of windows nt tree.

    Line - supplies line read from inf file.

Return Value:

    NULL if line has no second field. Otherwise, returns a buffer
    containing the full pathname of the file, which the caller must free
    via FREE().

--*/

{
    BOOLEAN InQuote = FALSE;
    int Field = 0;
    PCHAR WS = " \t";
    PCHAR FieldStart;
    PCHAR FileToDelete;
    unsigned FieldLength;

    while(1) {

        if((Field == 1) && ((*Line == 0) || (!InQuote && (*Line == ',')))) {

            FieldLength = Line - FieldStart - 1;
            if(FileToDelete = MALLOC(FieldLength+3),FALSE) {
                FileToDelete[0] = Drive;
                FileToDelete[1] = ':';
                strncpy(FileToDelete+2,FieldStart+1,FieldLength);
                FileToDelete[FieldLength+2] = 0;
            }

            return(FileToDelete);
        }

        switch(*Line) {
        case 0:
            return(NULL);
        case '\"':
            InQuote = (BOOLEAN)!InQuote;
            break;
        case ',':
            if(!InQuote) {
                Field++;
                FieldStart = Line;
            }
            break;
        }

        Line++;
    }
}


VOID
DnpDoDelete(
    IN PCHAR File
    )

/*++

Routine Description:

    Remove a single file from the windows nt installation,
    providing feedback to the user.

    If the file is in the system directory (as opposed to
    the system32 directory), then we will skip it.  This is
    because the user might have installed into the win3.1
    directory, in which case some files in the system directory
    are shared between nt and 3.1 (like fonts!).

Arguments:

    File - supplies full pathname of the file to be deleted.

Return Value:

    None.

--*/

{
    struct find_t FindData;
    PCHAR p,q;

    p = DnDupString(File);
    strlwr(p);
    q = strstr(p,"\\system\\");
    FREE(p);
    if(q) {
        return;
    }

    DnWriteStatusText(DntRemovingFile,File);

    if(!_dos_findfirst(File,_A_RDONLY|_A_HIDDEN|_A_SYSTEM,&FindData)) {

        _dos_setfileattr(File,_A_NORMAL);

        remove(File);
    }
}


VOID
DnpRemoveRegistryFiles(
    IN PCHAR NtRoot
    )

/*++

Routine Description:

    Remove a known list of registry files from a windows nt tree.

Arguments:

    NtRoot - supplies the full path of the windows nt windows directory,
        such as d:\winnt.

Return Value:

    None.

--*/

{
    unsigned f,s;
    CHAR RegistryFileName[256];

    for(f=0; RegistryFiles[f]; f++) {

        for(s=0; RegistrySuffixes[s]; s++) {

            sprintf(
                RegistryFileName,
                "%s\\system32\\config\\%s%s",
                NtRoot,
                RegistryFiles[f],
                RegistrySuffixes[s]
                );

            DnpDoDelete(RegistryFileName);
        }
    }
}



BOOLEAN
DnpDoDeleteNtTree(
    IN PCHAR NtRoot
    )

/*++

Routine Description:

    Worker routine for removing the Windows NT system files listed in a
    setup.log file in a given windows nt root.

Arguments:

    NtRoot - supplies the full path of the windows nt windows directory,
        such as d:\winnt.

Return Value:

    TRUE if we got to the point of actually attempting to remove at least
    one file.  FALSE otherwise.

--*/

{
    FILE *SetupLog;
    BOOLEAN FoundSection;
    PCHAR SetupLogName;
    PCHAR SectionName;
    PCHAR FileToDelete;
    CHAR LineBuffer[LINE_BUFFER_SIZE];
    BOOLEAN rc = FALSE;

    DnClearClientArea();
    DnDisplayScreen(&DnsRemovingNtFiles);
    DnWriteStatusText(NULL);

    //
    // Form the name of the setup log file.
    //
    SetupLogName = MALLOC(strlen(NtRoot)+sizeof(SETUP_LOG)+1,TRUE);
    strcpy(SetupLogName,NtRoot);
    strcat(SetupLogName,"\\" SETUP_LOG);

    //
    // Open the setup log file.
    //
    SetupLog = fopen(SetupLogName,"rt");
    if(SetupLog == NULL) {

        DnClearClientArea();
        DnDisplayScreen(&DnsCantOpenLogFile,SetupLogName);
        DnWriteStatusText(DntEnterEqualsContinue);
        while(DnGetKey() != ASCI_CR) ;
        goto xx1;
    }

    //
    // Read lines of the setup log file until we find the
    // section containing the list of files to be removed
    // ([Repair.WinntFiles]).
    //
    FoundSection = FALSE;
    while(!FoundSection && fgets(LineBuffer,LINE_BUFFER_SIZE,SetupLog)) {

        SectionName = DnpSectionName(LineBuffer);
        if(SectionName) {
            if(!stricmp(SectionName,REPAIR_SECTION_NAME)) {
                FoundSection = TRUE;
            }
            FREE(SectionName);
        }
    }

    if(FoundSection) {

        //
        // Read lines in this file until we encounter the end
        // of the file or the start of the next section.
        //
        while(fgets(LineBuffer,LINE_BUFFER_SIZE,SetupLog)) {

            //
            // If this line starts a new section, we're done.
            //
            if(SectionName = DnpSectionName(LineBuffer)) {
                FREE(SectionName);
                break;
            }

            //
            // Isolate the second field on the line; this is
            // the name of the file to delete.
            //
            if(FileToDelete = DnpFileToDelete(*NtRoot,LineBuffer)) {

                DnpDoDelete(FileToDelete);

                FREE(FileToDelete);

                rc = TRUE;
            }
        }
    } else {

        DnClearClientArea();
        DnWriteStatusText(DntEnterEqualsContinue);
        DnDisplayScreen(&DnsLogFileCorrupt,REPAIR_SECTION_NAME,SetupLogName);
        while(DnGetKey() != ASCI_CR) ;
    }

    fclose(SetupLog);

  xx1:
    FREE(SetupLogName);

    return(rc);
}


VOID
DnDeleteNtTree(
    IN PCHAR NtRoot
    )

/*++

Routine Description:

    Worker routine for removing the Windows NT system files listed in a
    setup.log file in a given windows nt root.

Arguments:

    NtRoot - supplies the full path of the windows nt windows directory,
        such as d:\winnt.

Return Value:

    None.

--*/

{
    ULONG ValidKeys[] = { 0,0,ASCI_ESC,DN_KEY_F3,0 };
    ULONG Key;

    ValidKeys[0] = DniAccelRemove1;
    ValidKeys[1] = DniAccelRemove2;

    //
    // Get confirmation first.
    //
    DnClearClientArea();
    DnDisplayScreen(&DnsConfirmRemoveNt,NtRoot);
    DnWriteStatusText("%s  %s",DntF3EqualsExit,DntXEqualsRemoveFiles);

    while(1) {

        Key = DnGetValidKey(ValidKeys);

        if((Key == DniAccelRemove1) || (Key == DniAccelRemove2)) {
            break;
        }

        if((Key == ASCI_ESC) || (Key == DN_KEY_F3)) {
            DnExit(1);
        }
    }

    if(DnpDoDeleteNtTree(NtRoot)) {
        DnpRemoveRegistryFiles(NtRoot);
    }
}

#endif // /D removed

VOID
DnRemovePagingFiles(
    VOID
    )

/*++

Routine Description:

    Remove Windows NT page files from root directory of drives we can see.

Arguments:

    None.

Return Value:

    None.

--*/

{
    CHAR Filename[16] = "?:\\pagefile.sys";
    int Drive;
    struct find_t FindData;

    DnClearClientArea();
    DnWriteStatusText(DntInspectingComputer);

    for(Filename[0]='A',Drive=1; Filename[0]<='Z'; Filename[0]++,Drive++) {

        if(DnIsDriveValid(Drive)
        && !DnIsDriveRemote(Drive,NULL)
        && !DnIsDriveRemovable(Drive)
        && !_dos_findfirst(Filename,_A_RDONLY|_A_SYSTEM|_A_HIDDEN, &FindData))
        {
            DnWriteStatusText(DntRemovingFile,Filename);
            remove(Filename);
            DnWriteStatusText(DntInspectingComputer);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\br\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\br\dntext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dntext.c

Abstract:

    Translatable text for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include "winnt.h"


//
// Name of sections in inf file.  If these are translated, the section
// names in dosnet.inf must be kept in sync.
//

CHAR DnfDirectories[]       = "Directories";
CHAR DnfFiles[]             = "Files";
CHAR DnfFloppyFiles0[]      = "FloppyFiles.0";
CHAR DnfFloppyFiles1[]      = "FloppyFiles.1";
CHAR DnfFloppyFiles2[]      = "FloppyFiles.2";
CHAR DnfFloppyFiles3[]      = "FloppyFiles.3";
CHAR DnfFloppyFilesX[]      = "FloppyFiles.x";
CHAR DnfSpaceRequirements[] = "DiskSpaceRequirements";
CHAR DnfMiscellaneous[]     = "Miscellaneous";
CHAR DnfRootBootFiles[]     = "RootBootFiles";
CHAR DnfAssemblyDirectories[] = SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_A;

//
// Names of keys in inf file.  Same caveat for translation.
//

CHAR DnkBootDrive[]     = "BootDrive";      // in [SpaceRequirements]
CHAR DnkNtDrive[]       = "NtDrive";        // in [SpaceRequirements]
CHAR DnkMinimumMemory[] = "MinimumMemory";  // in [Miscellaneous]

CHAR DntMsWindows[]   = "Microsoft Windows";
CHAR DntMsDos[]       = "MS-DOS";
CHAR DntPcDos[]       = "PC-DOS";
CHAR DntOs2[]         = "OS/2";
CHAR DntPreviousOs[]  = "Sistema operacional anterior na unidade C:";

CHAR DntBootIniLine[] = "Instalaao/atualizaao do Windows XP";

//
// Plain text, status msgs.
//

CHAR DntStandardHeader[]      = "\n Instalaao do Windows XP\n";
CHAR DntPersonalHeader[]      = "\n Instalaao do Windows XP Personal\n";
CHAR DntWorkstationHeader[]   = "\n Instalaao do Windows XP Professional\n";
CHAR DntServerHeader[]        = "\n Instalaao do Windows 2002 Server\n";
CHAR DntParsingArgs[]         = "Analisando argumentos...";
CHAR DntEnterEqualsExit[]     = "ENTER=Sair";
CHAR DntEnterEqualsRetry[]    = "ENTER=Repetir";
CHAR DntEscEqualsSkipFile[]   = "ESC=Ignorar arquivo";
CHAR DntEnterEqualsContinue[] = "ENTER=Continuar";
CHAR DntPressEnterToExit[]    = "A instalaao nao pode prosseguir. Pressione ENTER para sair.";
CHAR DntF3EqualsExit[]        = "F3=Sair";
CHAR DntReadingInf[]          = "Lendo o arquivo de informaoes %s...";
CHAR DntCopying[]             = "    Copiando: ";
CHAR DntVerifying[]           = " Verificando: ";
CHAR DntCheckingDiskSpace[]   = "Verificando o espao disponvel no disco...";
CHAR DntConfiguringFloppy[]   = "Configurando o disquete...";
CHAR DntWritingData[]         = "Gravando os parmetros de instalaao...";
CHAR DntPreparingData[]       = "Determinando os parmetros de instalaao...";
CHAR DntFlushingData[]        = "Liberando dados para o disco...";
CHAR DntInspectingComputer[]  = "Examinando o computador...";
CHAR DntOpeningInfFile[]      = "Abrindo o arquivo de informaoes...";
CHAR DntRemovingFile[]        = "Removendo %s";
CHAR DntXEqualsRemoveFiles[]  = "X=Remover arquivos";
CHAR DntXEqualsSkipFile[]     = "X=Ignorar arquivo";

//
// confirmation keystroke for DnsConfirmRemoveNt screen.
// Kepp in sync with DnsConfirmRemoveNt and DntXEqualsRemoveFiles.
//
ULONG DniAccelRemove1 = (ULONG)'x',
      DniAccelRemove2 = (ULONG)'X';

//
// confirmation keystroke for DnsSureSkipFile screen.
// Kepp in sync with DnsSureSkipFile and DntXEqualsSkipFile.
//
ULONG DniAccelSkip1 = (ULONG)'x',
      DniAccelSkip2 = (ULONG)'X';

CHAR DntEmptyString[] = "";

//
// Usage text.
//

PCHAR DntUsage[] = {

    "Instala o Windows 2002 Server ou Windows XP Professional.",
    "",
    "",
    "WINNT [/s[:caminho_origem]] [/t[:unidade_temp]]",
    "      [/u[:arquivo_resposta]] [/udf:id[,arquivo_UDF]]",
    "      [/r:pasta] [/r[x]:pasta] [/e:comando] [/a]",
    "",
    "",
    "/s[:caminho_origem]",
    "   Especifica o local de origem dos arquivos do Windows 2002.",
    "   Deve ser um caminho completo no formato x:\\caminho] ou ",
    "   \\\\servidor\\compartilhamento[\\caminho]. ",
    "",
    "/t[:unidade_temp]",
    "   Especifica a unidade que vai conter os arquivos temporrios ",
    "   e instala o Windows XP nessa unidade. Se voc nao ",
    "   especificar um local, a instalaao tentar localizar",
    "   uma unidade para voc.",
    "",
    "/u[:arquivo_respostas]",
    "   Executa uma instalaao autnoma usando um arquivo de respostas ",
    "   (requer /s). O arquivo de respostas fornece respostas para ",
    "   algumas ou todas as perguntas geralmente feitas ao usurio final ",
    "   durante a instalaao. ",
    "",
    "/udf:id[,arquivo_UDF] ",
    "   Indica uma identificaao (id) que a instalaao usa para ",
    "   especificar como um arquivo de banco de dados de unicidade ",
    "   (UDF) modifica um arquivo de respostas (consulte /u). O ",
    "   parmetro /udf substitui valores no arquivo de respostas e a ",
    "   identificaao determina que valores no arquivo UDF serao usados. ",
    "   Caso nao seja especificado um arquivo_UDF, A instalaao solicitar ",
    "   a inserao de um disco que contenha o arquivo $Unique$.udb.",
    "",
    "/r[:pasta]",
    "   Especifica uma pasta opcional a ser instalada. A pasta ser",
    "   mantida aps ser concluda a instalaao.",
    "",
    "/rx[:pasta]",
    "   Especifica uma pasta opcional a ser copiada. A pasta ser ",
    "   excluda aps ser concluda a instalaao.",
    "",
    "/e Especifica um comando a ser executado ao final da instalaao.",
    "",
    "/a Ativa as opoes de acessibilidade.",
    NULL

};

//
//  Inform that /D is no longer supported
//
PCHAR DntUsageNoSlashD[] = {

    "Instala o Windows XP.",
    "",
    "WINNT [/S[:]caminho_origem] [/T[:]unidade_temp] [/I[:]arquivo_inf]",
    "      [[/U[:arquivo_script]]",
    "      [/R[X]:pasta] [/E:comando] [/A]",
    "",
    "/D[:]winntroot",
    "       Nao h mais suporte para esta opao.",
    NULL
};

//
// out of memory screen
//

SCREEN
DnsOutOfMemory = { 4,6,
                   { "Memria insuficiente para continuar a instalaao.",
                     NULL
                   }
                 };

//
// Let user pick the accessibility utilities to install
//

SCREEN
DnsAccessibilityOptions = { 3, 5,
{   "Selecione os utilitrios de acessibilidade a serem instalados:",
    DntEmptyString,
    "[ ] Pressione F1 para a Lente de aumento da Microsoft",
#if 0
    "[ ] Pressione F3 para o Teclado em tela da Microsoft",
#endif
    NULL
}
};

//
// User did not specify source on cmd line screen
//

SCREEN
DnsNoShareGiven = { 3,5,
{ "A instalaao precisa saber onde estao os arquivos do Windows XP.",
  "Digite o caminho onde esses arquivos podem ser encontrados.",
  NULL
}
};


//
// User specified a bad source path
//

SCREEN
DnsBadSource = { 3,5,
                 { "A origem especificada nao  vlida,  inacessvel ou nao contm uma",
                   "instalaao do Windows XP vlida. Digite novamente o caminho onde se",
                   "encontram os arquivos do Windows XP. Use a tecla BACKSPACE para",
                   "apagar os caracteres e poder digitar o novo caminho.",
                   NULL
                 }
               };


//
// Inf file can't be read, or an error occured parsing it.
//

SCREEN
DnsBadInf = { 3,5,
              { "A instalaao nao conseguiu ler o arquivo de informaoes",
                "ou o arquivo est corrompido. Entre em contato com o administrador do sistema.",
                NULL
              }
            };

//
// The specified local source drive is invalid.
//
// Remember that the first %u will expand to 2 or 3 characters and
// the second one will expand to 8 or 9 characters!
//
SCREEN
DnsBadLocalSrcDrive = { 3,4,
{ "A unidade especificada para os arquivos temporrios",
  "de instalaao nao  vlida ou nao tem pelo menos",
  "%u MB (%lu bytes) de espao disponvel.",
  NULL
}
};

//
// No drives exist that are suitable for the local source.
//
// Remeber that the %u's will expand!
//
SCREEN
DnsNoLocalSrcDrives = { 3,4,
{  "O Windows XP requer um disco rgido com pelo menos %u MB",
   "(%lu bytes) de espao disponvel. A instalaao vai usar",
   "parte desse espao para armazenar os arquivos temporrios",
   "durante a instalaao. A unidade deve estar em um disco rgido",
   "local, permanentemente conectado e para o qual o Windows XP ",
   "d suporte. Essa unidade nao pode estar compactada.",
   DntEmptyString,
   "A instalaao nao encontrou nenhuma unidade com espao",
   "suficiente.",
  NULL
}
};

SCREEN
DnsNoSpaceOnSyspart = { 3,5,
{ "Nao h espao suficiente na unidade de inicializaao (normalmente C:)",
  "para a operaao sem disquetes. A operaao sem disquetes requer pelo",
  "menos 3,5 MB (3.641.856 bytes) de espao disponvel na unidade.",
  NULL
}
};

//
// Missing info in inf file
//

SCREEN
DnsBadInfSection = { 3,5,
                     { "A seao [%s] do arquivo de informaoes da",
                       "instalaao nao foi encontrada ou est corrompida.",
                       "Contate o administrador do sistema.",
                       NULL
                     }
                   };


//
// Couldn't create directory
//

SCREEN
DnsCantCreateDir = { 3,5,
                     { "Nao foi possvel criar a seguinte pasta na unidade de destino:",
                       DntEmptyString,
                       "%s",
                       DntEmptyString,
                       "Verifique se h algum arquivo com o mesmo nome que a pasta de",
                       "destino. Verifique tambm os cabos de conexao da unidade.",
                       NULL
                     }
                   };

//
// Error copying a file
//

SCREEN
DnsCopyError = { 4,5,
{  "A instalaao nao pde copiar o seguinte arquivo:",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Pressione ENTER para tentar copiar o arquivo novamente.",
   "  Pressione ESC para ignorar o erro e continuar a instalaao.",
   "  Pressione F3 para sair da instalaao.",
   DntEmptyString,
   "Obs.: se voc ignorar o erro e continuar a instalaao, outros erros",
   "poderao ocorrer mais adiante.",
   NULL
}
},
DnsVerifyError = { 4,5,
{  "A cpia deste arquivo feita pela instalaao nao  idntica ",
   "original. Isso pode ter sido causado por erros na rede, problemas",
   "na unidade de disquetes ou algum outro problema de hardware.",
   DntEmptyString,
   DntEmptyString,          // see DnCopyError (dnutil.c)
   DntEmptyString,
   DntEmptyString,
   "  Pressione ENTER para tentar copiar o arquivo novamente.",
   "  Pressione ESC para ignorar o erro e continuar a instalaao.",
   "  Pressione F3 para sair da instalaao.",
   DntEmptyString,
   "Obs.: se voc ignorar o erro e continuar a instalaao, outros erros",
   "poderao ocorrer mais adiante.",
   NULL
}
};

SCREEN DnsSureSkipFile = { 4,5,
{  "Se o erro for ignorado, este arquivo nao ser copiado. Esta opao",
   "se destina a usurios avanados, que entendem as implicaoes da",
   "falta de arquivos no sistema.",
   DntEmptyString,
   "  Pressione ENTER para tentar copiar o arquivo novamente.",
   "  Pressione X para ignorar este arquivo.",
   DntEmptyString,
   "Obs.: se voc ignorar este arquivo, a instalaao nao poder",
   "garantir o xito da instalaao ou atualizaao para o Windows XP.",
  NULL
}
};

//
// Wait while setup cleans up previous local source trees.
//

SCREEN
DnsWaitCleanup =
    { 9,6,
        { "Aguarde enquanto os arquivos temporrios antigos sao removidos.",
           NULL
        }
    };

//
// Wait while setup copies files
//

SCREEN
DnsWaitCopying = { 9,6,
                   { "Aguarde enquanto os arquivos sao copiados para o disco rgido.",
                     NULL
                   }
                 },
DnsWaitCopyFlop= { 13,6,
                   { "Aguarde enquanto os arquivos sao copiados para o disquete.",
                     NULL
                   }
                 };

//
// Setup boot floppy errors/prompts.
//
SCREEN
DnsNeedFloppyDisk3_0 = { 4,4,
{  "A instalaao requer quatro disquetes de alta densidade",
   "formatados e vazios. A instalaao chamar esses discos",
   "de \"Disco de inicializaao da instalaao do Windows XP,\"",
   "\"Disco de instalaao do Windows XP 2,\" \"Disco de instalaao",
   "do Windows XP 3\" e \"Disco de instalaao do Windows XP 4.\"",
   DntEmptyString,
   "Insira um dos quatro discos na unidade A:.",
   "Esse ser o \"Disco de instalaao do Windows XP 4.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk3_1 = { 4,4,
{  "Insira um disquete de alta densidade formatado e vazio na unidade A:.",
   "Este ser o \"Disco de instalaao do Windows XP 4.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk2_0 = { 4,4,
{  "Insira um disquete de alta densidade formatado e vazio na unidade A:.",
   "Este ser o \"Disco de instalaao do Windows XP 3.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk1_0 = { 4,4,
{  "Insira um disquete de alta densidade formatado e vazio na unidade A:.",
   "Este ser o \"Disco de instalaao do Windows XP 2.\"",
  NULL
}
};

SCREEN
DnsNeedFloppyDisk0_0 = { 4,4,
{  "Insira um disquete de alta densidade formatado e vazio na unidade A:.",
   "Este ser o \"Disco de inicializaao da instalaao do Windows XP.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_0 = { 4,4,
{  "A instalaao requer quatro disquetes de alta densidade",
   "formatados e vazios. A instalaao chamar esses discos",
   "de \"Disco de inicializaao da instalaao do Windows XP,\"",
   "\"Disco de instalaao do Windows XP 2,\" \"Disco de instalaao",
   "do Windows XP 3\" e \"Disco de instalaao do Windows XP 4.\"",
   DntEmptyString,
   "Insira um dos quatro discos na unidade A:.",
   "Este ser o \"Disco de instalaao do Windows XP 4.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk3_1 = { 4,4,
{  "Insira um disquete de alta densidade formatado e vazio na unidade A:.",
   "Este ser o \"Disco de instalaao do Windows XP 4.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk2_0 = { 4,4,
{  "Insira um disquete de alta densidade formatado e vazio na unidade A:.",
   "Este ser o \"Disco de instalaao do Windows XP 3.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk1_0 = { 4,4,
{  "Insira um disquete de alta densidade formatado e vazio na unidade A:.",
   "Este ser o \"Disco de instalaao do Windows XP 2.\"",
  NULL
}
};

SCREEN
DnsNeedSFloppyDsk0_0 = { 4,4,
{  "Insira um disquete de alta densidade formatado e vazio na unidade A:.",
   "Este ser o \"Disco de inicializaao da instalaao do Windows XP.\"",
  NULL
}
};

//
// The floppy is not formatted.
//
SCREEN
DnsFloppyNotFormatted = { 3,4,
{ "O disquete fornecido nao est formatado para uso com o MS-DOS.",
  "A instalaao nao pode usar esse disco.",
  NULL
}
};

//
// We think the floppy is not formatted with a standard format.
//
SCREEN
DnsFloppyBadFormat = { 3,4,
{ "O disquete fornecido nao est formatado em alta densidade, nao",
  "est formatado para uso com o MS-DOS ou est danificado. A",
  "instalaao nao pode usar esse disco.",
  NULL
}
};

//
// We can't determine the free space on the floppy.
//
SCREEN
DnsFloppyCantGetSpace = { 3,4,
{ "Nao  possvel determinar o espao disponvel no disquete fornecido.",
  "A instalaao nao pode usar esse disco.",
  NULL
}
};

//
// The floppy is not blank.
//
SCREEN
DnsFloppyNotBlank = { 3,4,
{ "O disquete fornecido nao  de alta densidade ou nao est vazio.",
  "A instalaao nao pode usar esse disco.",
  NULL
}
};

//
// Couldn't write the boot sector of the floppy.
//
SCREEN
DnsFloppyWriteBS = { 3,4,
{ "A instalaao nao pde gravar na rea de sistema do disquete",
  "fornecido.  possvel que o disco esteja danificado.",
  NULL
}
};

//
// Verify of boot sector on floppy failed (ie, what we read back is not the
// same as what we wrote out).
//
SCREEN
DnsFloppyVerifyBS = { 3,4,
{ "A instalaao leu dados na rea de sistema do disquete que nao",
  "correspondem aos dados gravados anteriormente ou nao foi",
  "possvel verificar a rea de sistema do disquete.",
  DntEmptyString,
  "Isso pode ter ocorrido devido a uma das seguintes causas:",
  DntEmptyString,
  "  O computador est infectado por um vrus.",
  "  O disquete fornecido est danificado.",
  "  Existe um problema no hardware ou na configuraao da unidade de disquete.",
  NULL
}
};


//
// We couldn't write to the floppy drive to create winnt.sif.
//

SCREEN
DnsCantWriteFloppy = { 3,5,
{ "A instalaao nao pde gravar no disquete na Unidade A:.",
  "O disco pode estar danificado. Tente usar outro disquete.",
  NULL
}
};


//
// Exit confirmation dialog
//

SCREEN
DnsExitDialog = { 13,6,
                  { "",
                    "  O Windows XP nao est completamente instalado     ",
                    "  no computador. Se voc sair da instalaao agora,  ",
                    "  ter de execut-la novamente para instalar o      ",
                    "  Windows XP.                                       ",
                    "                                                    ",
                    "      Pressione ENTER para continuar a instalaao. ",
                    "      Pressione F3 para sair da instalaao.        ",
                    "                                                    ",
                    "",
                    "  F3=Sair  ENTER=Continuar                          ",
                    "",
                    NULL
                  }
                };


//
// About to reboot machine and continue setup
//

SCREEN
DnsAboutToRebootW =
{ 3,5,
{ "A etapa da instalaao baseada em MS-DOS foi concluda. A",
  "instalaao vai reiniciar o computador agora. A instalaao do",
  "Windows XP continuar depois que o computador for reiniciado.",
  DntEmptyString,
  "Antes de prosseguir, verifique se o \"Disco de inicializaao da",
  "instalaao do Windows XP\" que voc forneceu est na unidade A:.",
  DntEmptyString,
  "Pressione ENTER para reiniciar o computador e continuar a instalaao.",
  NULL
}
},
DnsAboutToRebootS =
{ 3,5,
{ "A etapa da instalaao baseada em MS-DOS foi concluda. A",
  "instalaao vai reiniciar o computador agora. A instalaao do",
  "Windows XP continuar depois que o computador for reiniciado.",
  DntEmptyString,
  "Antes de prosseguir, verifique se o \"Disco de inicializaao da",
  "instalaao do Windows XP\" que voc forneceu est na unidade A:.",
  DntEmptyString,
  "Pressione ENTER para reiniciar o computador e continuar a instalaao.",
  NULL
}
},
DnsAboutToRebootX =
{ 3,5,
{ "A etapa da instalaao baseada em MS-DOS foi concluda. A",
  "instalaao vai reiniciar o computador agora. A instalaao do",
  "Windows XP continuar depois que o computador for reiniciado.",
  DntEmptyString,
  "Se houver um disquete na unidade A:, retire-o agora.",
  DntEmptyString,
  "Pressione ENTER para reiniciar o computador e continuar a instalaao.",
  NULL
}
};

//
// Need another set for '/w' switch since we can't reboot from within Windows.
//

SCREEN
DnsAboutToExitW =
{ 3,5,
{ "A etapa da instalaao baseada em MS-DOS foi concluda. Voc deve",
  "reiniciar o computador para continuar a instalaao do Windows XP.",
  DntEmptyString,
  "Antes de prosseguir, verifique se o \"Disco de inicializaao da",
  "instalaao do Windows XP\" que voc forneceu est na unidade A:.",
  DntEmptyString,
  "Pressione ENTER para retornar ao MS-DOS e reinicie o computador",
  "para continuar a instalaao do Windows XP.",
  NULL
}
},
DnsAboutToExitS =
{ 3,5,
{ "A etapa da instalaao baseada em MS-DOS foi concluda. Voc deve",
  "reiniciar o computador para continuar a instalaao do Windows XP.",
  DntEmptyString,
  "Antes de prosseguir, verifique se o \"Disco de inicializaao da",
  "instalaao do Windows XP\" que voc forneceu est na unidade A:.",
  DntEmptyString,
  "Pressione ENTER para retornar ao MS-DOS e reinicie o computador",
  "para continuar a instalaao do Windows XP.",
  NULL
}
},
DnsAboutToExitX =
{ 3,5,
{ "A etapa da instalaao baseada em MS-DOS foi concluda. Voc deve",
  "reiniciar o computador para continuar a instalaao do Windows XP.",
  DntEmptyString,
  "Se houver um disquete na unidade A:, retire-o agora.",
  DntEmptyString,
  "Pressione ENTER para retornar ao MS-DOS e reinicie o computador",
  "para continuar a instalaao do Windows XP.",
  NULL
}
};

//
// Gas gauge
//

SCREEN
DnsGauge = { 7,15,
             { "",
               " A instalaao est copiando os arquivos...                      ",
               "                                                                ",
               "            ",
               "                                                              ",
               "            ",
               "",
               NULL
             }
           };


//
// Error screens for initial checks on the machine environment
//

SCREEN
DnsBadDosVersion = { 3,5,
{ "Este programa precisa da versao 5.0 ou posterior do MS-DOS.",
  NULL
}
},

DnsRequiresFloppy = { 3,5,
#ifdef ALLOW_525
{ "A instalaao verificou que a unidade A: nao existe ou que ela  de",
  "baixa densidade.  necessria uma unidade A: com capacidade mnima",
  "de 1,2 MB para que a instalaao possa ser executada.",
#else
{ "A instalaao verificou que a unidade A: nao existe ou nao  uma",
  "unidade de 3,5\" de alta densidade.  necessria uma unidade A:",
  "com capacidade mnima de 1,44 MB para se executar a instalaao.",
  DntEmptyString,
  "Para instalar o Windows XP sem usar disquetes, reinicie este",
  "programa especificando o argumento /b na linha de comando.",
#endif
  NULL
}
},

DnsRequires486 = { 3,5,
{ "A instalaao verificou que este computador nao possui uma",
  "CPU 80486 ou superior. O Windows XP nao pode ser executado",
  "neste computador.",
  NULL
}
},

DnsCantRunOnNt = { 3,5,
{ "Este programa nao pode ser executado em nenhuma versao de 32 bits",
  "do Windows.",
  DntEmptyString,
  "Use o programa WINNT32.EXE neste caso.",
  NULL
}
},

DnsNotEnoughMemory = { 3,5,
{ "A instalaao verificou que nao h memria suficiente",
  "instalada neste computador para se executar o Windows XP.",
  DntEmptyString,
  "Memria suficiente: %lu%s MB",
  "Memria existente: %lu%s MB",
  NULL
}
};


//
// Screens used when removing existing nt files
//
SCREEN
DnsConfirmRemoveNt = { 5,5,
{   "Voc pediu  instalaao para remover os arquivos do Windows",
    "XP da pasta mostrada abaixo. A instalaao do Windows nessa pasta",
    "ser destruda permanentemente.",
    DntEmptyString,
    "%s",
    DntEmptyString,
    DntEmptyString,
    "  Pressione F3 para sair da instalaao sem remover os arquivos.",
    "  Pressione X para remover os arquivos do Windows da pasta acima.",
    NULL
}
},

DnsCantOpenLogFile = { 3,5,
{ "A instalaao nao conseguiu abrir o arquivo de log da",
  "instalaao abaixo.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "A instalaao nao pode remover os arquivos do Windows da",
  "pasta especificada.",
  NULL
}
},

DnsLogFileCorrupt = { 3,5,
{ "A instalaao nao conseguiu encontrar a seao %s",
  "no arquivo de log da instalaao abaixo.",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "A instalaao nao pde remover os arquivos do Windows da",
  "pasta especificada.",
  NULL
}
},

DnsRemovingNtFiles = { 3,5,
{ "           Aguarde enquanto os arquivos do Windows sao removidos.",
  NULL
}
};

SCREEN
DnsNtBootSect = { 3,5,
{ "A instalaao nao conseguiu instalar o carregador de",
  "inicializaao do Windows.",
  DntEmptyString,
  "Verifique se a unidade C: est formatada e nao apresenta",
  "defeitos.",
  NULL
}
};

SCREEN
DnsOpenReadScript = { 3,5,
{ "Nao foi possvel o acesso ao arquivo de script especificado com o",
  "argumento /u na linha de comando.",
  DntEmptyString,
  "A operaao autnoma nao pode prosseguir.",
  NULL
}
};

SCREEN
DnsParseScriptFile = { 3,5,
{ "O arquivo de script especificado com o argumento /u na linha de comando",
  DntEmptyString,
  "%s",
  DntEmptyString,
  "contm um erro de sintaxe na linha %u.",
  DntEmptyString,
  NULL
}
};

SCREEN
DnsBootMsgsTooLarge = { 3,5,
{ "Erro interno da instalaao.",
  DntEmptyString,
  "As mensagens de inicializaao sao muito longas.",
  NULL
}
};

SCREEN
DnsNoSwapDrive = { 3,5,
{ "Erro interno da instalaao.",
  DntEmptyString,
  "Nao foi possvel encontrar lugar para um arquivo de swap.",
  NULL
}
};

SCREEN
DnsNoSmartdrv = { 3,5,
{ "A instalaao nao detectou o SmartDrive no computador.",
  "Ele melhorar o desempenho desta fase da instalaao do Windows.",
  DntEmptyString,
  "Voc deve sair agora, iniciar o SmartDrive e reiniciar a instalaao.",
  "Consulte a documentaao do DOS para obter detalhes sobre o SmartDrive.",
  DntEmptyString,
    "  Pressione F3 para sair da instalaao.",
    "  Pressione ENTER para continuar sem o SmartDrive.",
  NULL
}
};

//
// Boot messages. These go in the fat and fat32 boot sectors.
//
CHAR BootMsgNtldrIsMissing[] = "Falta NTLDR";
CHAR BootMsgDiskError[] = "Erro/disco";
CHAR BootMsgPressKey[] = "Pressione tecla para reiniciar";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\c6\inc\assert.h ===
/***
*assert.h - define the assert macro
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Defines the assert(exp) macro.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#undef	assert

#ifdef NDEBUG

#define assert(exp)	((void)0)

#else

void _FAR_ _cdecl _assert(void _FAR_ *, void _FAR_ *, unsigned);
#define assert(exp) \
	( (exp) ? (void) 0 : _assert(#exp, __FILE__, __LINE__) )

#endif /* NDEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\c6\inc\conio.h ===
/***
*conio.h - console and port I/O declarations
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This include file contains the function declarations for
*	the MS C V2.03 compatible console and port I/O routines.
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

/* function prototypes */

char _FAR_ * _FAR_ _cdecl cgets(char _FAR_ *);
int _FAR_ _cdecl cprintf(const char _FAR_ *, ...);
int _FAR_ _cdecl cputs(const char _FAR_ *);
int _FAR_ _cdecl cscanf(const char _FAR_ *, ...);
int _FAR_ _cdecl getch(void);
int _FAR_ _cdecl getche(void);
int _FAR_ _cdecl inp(unsigned);
unsigned _FAR_ _cdecl inpw(unsigned);
int _FAR_ _cdecl kbhit(void);
int _FAR_ _cdecl outp(unsigned, int);
unsigned _FAR_ _cdecl outpw(unsigned, unsigned);
int _FAR_ _cdecl putch(int);
int _FAR_ _cdecl ungetch(int);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\c6\inc\ctype.h ===
/***
*ctype.h - character conversion macros and ctype macros
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Defines macros for character classification/conversion.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif


/*
 * This declaration allows the user access to the ctype look-up
 * array _ctype defined in ctype.obj by simply including ctype.h
 */

#ifdef _DLL
extern unsigned char _FAR_ _cdecl _ctype[];
#else
extern unsigned char _near _cdecl _ctype[];
#endif

/* set bit masks for the possible character types */

#define _UPPER		0x1	/* upper case letter */
#define _LOWER		0x2	/* lower case letter */
#define _DIGIT		0x4	/* digit[0-9] */
#define _SPACE		0x8	/* tab, carriage return, newline, */
				/* vertical tab or form feed */
#define _PUNCT		0x10	/* punctuation character */
#define _CONTROL	0x20	/* control character */
#define _BLANK		0x40	/* space char */
#define _HEX		0x80	/* hexadecimal digit */

/* character classification function prototypes */

#ifndef _CTYPE_DEFINED
int _FAR_ _cdecl isalpha(int);
int _FAR_ _cdecl isupper(int);
int _FAR_ _cdecl islower(int);
int _FAR_ _cdecl isdigit(int);
int _FAR_ _cdecl isxdigit(int);
int _FAR_ _cdecl isspace(int);
int _FAR_ _cdecl ispunct(int);
int _FAR_ _cdecl isalnum(int);
int _FAR_ _cdecl isprint(int);
int _FAR_ _cdecl isgraph(int);
int _FAR_ _cdecl iscntrl(int);
int _FAR_ _cdecl toupper(int);
int _FAR_ _cdecl tolower(int);
int _FAR_ _cdecl _tolower(int);
int _FAR_ _cdecl _toupper(int);
int _FAR_ _cdecl isascii(int);
int _FAR_ _cdecl toascii(int);
int _FAR_ _cdecl iscsymf(int);
int _FAR_ _cdecl iscsym(int);
#define _CTYPE_DEFINED
#endif

/* the character classification macro definitions */

#define isalpha(_c)	( (_ctype+1)[_c] & (_UPPER|_LOWER) )
#define isupper(_c)	( (_ctype+1)[_c] & _UPPER )
#define islower(_c)	( (_ctype+1)[_c] & _LOWER )
#define isdigit(_c)	( (_ctype+1)[_c] & _DIGIT )
#define isxdigit(_c)	( (_ctype+1)[_c] & _HEX )
#define isspace(_c)	( (_ctype+1)[_c] & _SPACE )
#define ispunct(_c)	( (_ctype+1)[_c] & _PUNCT )
#define isalnum(_c)	( (_ctype+1)[_c] & (_UPPER|_LOWER|_DIGIT) )
#define isprint(_c)	( (_ctype+1)[_c] & (_BLANK|_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define isgraph(_c)	( (_ctype+1)[_c] & (_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define iscntrl(_c)	( (_ctype+1)[_c] & _CONTROL )
#ifndef NO_EXT_KEYS
#define toupper(_c)	( (islower(_c)) ? _toupper(_c) : (_c) )
#define tolower(_c)	( (isupper(_c)) ? _tolower(_c) : (_c) )
#endif
#define _tolower(_c)	( (_c)-'A'+'a' )
#define _toupper(_c)	( (_c)-'a'+'A' )
#define isascii(_c)	( (unsigned)(_c) < 0x80 )
#define toascii(_c)	( (_c) & 0x7f )

/* MS C version 2.0 extended ctype macros */

#define iscsymf(_c)	(isalpha(_c) || ((_c) == '_'))
#define iscsym(_c)	(isalnum(_c) || ((_c) == '_'))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\winnt.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dos2nt.h

Abstract:

    Local include file for DOS based NT Setup program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/


#include <setupbat.h>
#include "nttypes.h"
#include <stdio.h>
#include "dninf.h"
#include "sptxtcns.h"
#include <stdarg.h>
#include "SetupSxs.h"

//
// Define structure used to hold a text screen.
//

typedef struct _SCREEN {
    UCHAR X;
    UCHAR Y;
    PCHAR Strings[];
} SCREEN, *PSCREEN;

//
//  Define structure that contains information about disk space requirements
//

typedef struct _SPACE_REQUIREMENT {
    PCHAR       Key;
    unsigned    ClusterSize;
    ULONG       Clusters;
} SPACE_REQUIREMENT, *PSPACE_REQUIREMENT;


//
// define virtualized keycodes
//

#define ASCI_BS         8
#define ASCI_CR         13
#define ASCI_ESC        27
#define DN_KEY_UP       0x00010000
#define DN_KEY_DOWN     0x00020000
#define DN_KEY_HOME     0x00030000
#define DN_KEY_END      0x00040000
#define DN_KEY_PAGEUP   0x00050000
#define DN_KEY_PAGEDOWN 0x00060000
#define DN_KEY_F1       0x01000000
#define DN_KEY_F2       0x02000000
#define DN_KEY_F3       0x03000000
#define DN_KEY_F4       0x04000000

//
// define characters for radio buttons
//
#define RADIO_ON    ((CHAR)'X')
#define RADIO_OFF   ((CHAR)' ')

//
// Display functions
//

VOID
DnInitializeDisplay(
    VOID
    );

VOID
DnClearClientArea(
    VOID
    );

VOID
DnSetGaugeAttribute(
    IN BOOLEAN Set
    );

VOID
DnPositionCursor(
    IN UCHAR X,
    IN UCHAR Y
    );

VOID
DnWriteChar(
    IN CHAR chr
    );

VOID
DnWriteString(
    IN PCHAR String
    );

VOID
DnWriteStatusText(
    IN PCHAR FormatString OPTIONAL,
    ...
    );

VOID
DnSetCopyStatusText(
    IN PCHAR Caption,
    IN PCHAR Filename
    );

VOID
DnStartEditField(
    IN BOOLEAN CreateField,
    IN UCHAR X,
    IN UCHAR Y,
    IN UCHAR W
    );

VOID
DnExitDialog(
    VOID
    );

VOID
DnDelnode(
    IN PCHAR Directory
    );

//
// Gas guage functions
//
int
DnGetGaugeChar(
    VOID
    );

VOID
DnInitGauge(
    IN unsigned NumberOfFiles,
    IN PSCREEN  AdditionalScreen OPTIONAL
    );

VOID
DnTickGauge(
    VOID
    );

VOID
DnDrawGauge(
    IN PSCREEN AdditionalScreen OPTIONAL
    );

//
// asm routines in dna.asm
//
VOID
DnaReboot(
    VOID
    );

BOOLEAN
_far
_cdecl
DnAbsoluteSectorIo(
    IN     unsigned Drive,             //0=A, etc
    IN     ULONG    StartSector,
    IN     USHORT   SectorCount,
    IN OUT PVOID    Buffer,
    IN     BOOLEAN  Write
    );

//
// Misc / util functions
//

BOOLEAN
DnWriteSmallIniFile(
    IN  PCHAR  Filename,
    IN  PCHAR *Lines,
    OUT FILE  **FileHandle OPTIONAL
    );

ULONG
DnGetKey(
    VOID
    );

ULONG
DnGetValidKey(
    IN PULONG ValidKeyList
    );

VOID
DnDisplayScreen(
    IN PSCREEN Screen,
    ...
    );

VOID
vDnDisplayScreen(
    IN PSCREEN Screen,
    IN va_list arglist
    );

VOID
DnFatalError(
    IN PSCREEN Screen,
    ...
    );

BOOLEAN
DnCopyError(
    IN PCHAR   Filename,
    IN PSCREEN ErrorScreen,
    IN int     FilenameLine
    );

PCHAR
DnDupString(
    IN PCHAR String
    );

VOID
DnGetString(
    IN OUT PCHAR String,
    IN UCHAR X,
    IN UCHAR Y,
    IN UCHAR W
    );

BOOLEAN
DnIsDriveValid(
    IN unsigned Drive
    );

BOOLEAN
DnIsDriveRemote(
    IN unsigned Drive,
    OUT PCHAR UncPath   OPTIONAL
    );

BOOLEAN
DnIsDriveRemovable(
    IN unsigned Drive
    );

BOOLEAN
DnCanonicalizePath(
    IN PCHAR PathIn,
    OUT PCHAR PathOut
    );

VOID
DnRemoveTrailingSlashes(
    PCHAR Path
    );

VOID
DnRemoveLastPathElement(
    PCHAR Path
    );

VOID
DnpConcatPaths(
    IN PCHAR SourceBuffer,
    IN PCHAR AppendString
    );

BOOLEAN
DnIsDriveCompressedVolume(
    IN  unsigned  Drive,
    OUT unsigned *HostDrive
    );

#if 1
PVOID
Malloc(
    IN unsigned Size,
    IN BOOLEAN MustSucceed
#if DBG
   ,IN char *file,
    IN int line
#endif
    );

VOID
Free(
    IN PVOID Block
#if DBG
   ,IN char *file,
    IN int line
#endif
    );

PVOID
Realloc(
    IN PVOID Block,
    IN unsigned Size,
    IN BOOLEAN MustSucceed
#if DBG
   ,IN char *file,
    IN int line
#endif
    );

#if DBG
#define MALLOC(s,f)     Malloc(s,f,__FILE__,__LINE__)
#define REALLOC(b,s,f)  Realloc(b,s,f,__FILE__,__LINE__)
#define FREE(b)         Free(b,__FILE__,__LINE__)
#else
#define MALLOC(s,f)     Malloc(s,f)
#define REALLOC(b,s,f)  Realloc(b,s,f)
#define FREE(b)         Free(b)
#endif

#else

#include <malloc.h>
#define MALLOC(s,f)     malloc(s)
#define REALLOC(b,s,f)  realloc(b,s)
#define FREE(b)         free(b)

#endif

VOID
DnExit(
    IN int ExitStatus
    );


//
// File copy routines
//
//
// Flags for various routines
//
#define CPY_VALIDATION_PASS     0x0001
#define CPY_USE_DEST_ROOT       0x0002
#define CPY_VERIFY              0x0004
#define CPY_PRESERVE_ATTRIBS    0x0008
#define CPY_PRESERVE_NAME       0x0010
#define CPY_PRUNE_DRIVERCAB     0x0020


VOID
DnCopyFiles(
    VOID
    );

ULONG
DnpIterateOptionalDirs(
    IN unsigned Flags,
    IN unsigned ClusterSize OPTIONAL,
    IN PSPACE_REQUIREMENT SpaceReqArray OPTIONAL,
    IN unsigned ArraySize OPTIONAL
    );

VOID
DnCopyFloppyFiles(
    IN PCHAR SectionName,
    IN PCHAR TargetRoot
    );

VOID
DnCopyFilesInSection(
    IN unsigned Flags,
    IN PCHAR    SectionName,
    IN PCHAR    SourcePath,
    IN PCHAR    TargetPath
    );

#if NEC_98
VOID
DnCopyFilesInSectionForFDless(
    IN PCHAR SectionName,
    IN PCHAR SourcePath,
    IN PCHAR TargetPath
    );
#endif // NEC_98

VOID
DnCopyOemBootFiles(
    PCHAR TargetPath
    );

VOID
DnDetermineSpaceRequirements(
    PSPACE_REQUIREMENT  SpaceReqArray,
    unsigned            ArraySize
    );

VOID
DnAdjustSpaceRequirements(
    PSPACE_REQUIREMENT  SpaceReqArray,
    unsigned            ArraySize
    );

//
// Local source functions.
//
VOID
DnRemoveLocalSourceTrees(
    VOID
    );

VOID
DnRemovePagingFiles(
    VOID
    );

//
// Function to create the setup boot floppy
//

VOID
DnCreateBootFloppies(
    VOID
    );

//
// Function to start NT text mode setup
//

VOID
DnToNtSetup(
    VOID
    );

//
// Global variables
//
extern PCHAR    LocalSourceDirName;         // name of local src root (\$WIN_NT$.~LS)
extern PCHAR    x86DirName;                 // name of x86-specific subdir (\I386")
extern PCHAR    DngSourceRootPath;          // root of source ('x:\foo\bar', '\\foo\bar')
extern PCHAR    UserSpecifiedOEMShare;      // possible alternate location for $OEM$ files.
extern CHAR     DngTargetDriveLetter;       // drive letter of target
extern CHAR     DngSwapDriveLetter;         // drive letter for INF parser swap file
extern PCHAR    DngTargetPath;              // path part of target from leading \.
extern PVOID    DngInfHandle;               // To be passed to INF routines
extern PVOID    DngDrvindexInfHandle;       // To be passed to INF routines
extern BOOLEAN  DngFloppyVerify;            // whether to verify files copied to floppy
extern BOOLEAN  DngWinntFloppies;           // whether floppies are for winnt or cd/floppy
extern BOOLEAN  DngCheckFloppySpace;        // whether to check free space on the floppy
extern unsigned DngOriginalCurrentDrive;    // current drive when we were invoked
extern BOOLEAN  DngFloppyless;              // whether to do floppyless operation
extern BOOLEAN  DngServer;                  // true if setting up server; false for workstation
extern BOOLEAN  DngUnattended;              // skip final reboot screen
extern BOOLEAN  DngWindows;                 // Are we running under Windows?

extern BOOLEAN  DngCopyOnlyD1TaggedFiles;   // TRUE if the files tagged with d1 only need to be copied

extern PCHAR    DngScriptFile;
extern BOOLEAN DngOemPreInstall;
extern PCHAR   OemSystemDirectory;
extern PCHAR   OemOptionalDirectory;

extern PCHAR UniquenessDatabaseFile;
extern PCHAR UniquenessId;

extern BOOLEAN DngMagnifier;                // Accessibility utilities
extern BOOLEAN DngKeyboard;
extern BOOLEAN DngTalker;
extern BOOLEAN DngVoice;

//
// Name of sections and keys in inf file.
//

extern CHAR __far DnfDirectories[];
extern CHAR __far DnfFiles[];
extern CHAR __far DnfFloppyFiles0[];
extern CHAR __far DnfFloppyFiles1[];
extern CHAR __far DnfFloppyFiles2[];
extern CHAR __far DnfFloppyFiles3[];
extern CHAR __far DnfFloppyFilesX[];
extern CHAR __far DnfSpaceRequirements[];
extern CHAR __far DnfMiscellaneous[];
extern CHAR __far DnfRootBootFiles[];
extern CHAR __far DnfAssemblyDirectories[];

#if NEC_98
extern CHAR DnfBackupFiles_PC98[];  // For FD Less Setup
#endif // NEC_98
extern CHAR DnkBootDrive[];
extern CHAR DnkNtDrive[];
extern CHAR __far DnkMinimumMemory[];

//
// Text strings
//

extern CHAR __far DntMsWindows[];             // "Microsoft Windows"
extern CHAR __far DntMsDos[];                 // "MS-DOS"
extern CHAR __far DntPcDos[];                 // "PC-DOS"
extern CHAR __far DntOs2[];                   // "OS/2"
extern CHAR __far DntPreviousOs[];            // "Previous Operating System on C:"
extern CHAR __far DntBootIniLine[];           // "Windows NT 3.5 Installation/Upgrade"
extern CHAR __far DntEmptyString[];           // ""
extern CHAR __far DntStandardHeader[];
extern CHAR __far DntPersonalHeader[];
extern CHAR __far DntServerHeader[];
extern CHAR __far DntWorkstationHeader[];
extern CHAR DntParsingArgs[];           // "Parsing arguments..."
extern CHAR __far DntEnterEqualsExit[];
extern CHAR __far DntEnterEqualsRetry[];
extern CHAR __far DntEscEqualsSkipFile[];
extern CHAR __far DntEnterEqualsContinue[];
extern CHAR __far DntPressEnterToExit[];
extern CHAR __far DntF3EqualsExit[];          // "F3=Exit"
extern CHAR __far DntReadingInf[];            // "Reading INF file..."
extern CHAR __far DntCopying[];               // " Copying: "
extern CHAR __far DntVerifying[];             // " Verifying: "
extern CHAR DntCheckingDiskSpace[];     // "Checking disk space..."
extern CHAR __far DntConfiguringFloppy[];     // "Configuring floppy disk..."
extern CHAR __far DntWritingData[];           // "Writing Setup parameters...";
extern CHAR __far DntPreparingData[];         // "Determining Setup parameters...";
extern CHAR __far DntFlushingData[];          // "Ensuring disk consistency..."
extern CHAR __far DntInspectingComputer[];    // "Inspecting computer..."
extern CHAR __far DntOpeningInfFile[];        // "Opening INF file..."
extern CHAR __far DntRemovingFile[];          // "Removing file %s"
extern CHAR DntXEqualsRemoveFiles[];    // "X=Remove files"
extern CHAR __far DntXEqualsSkipFile[];       // "X=Skip File"

extern ULONG DniAccelRemove1,DniAccelRemove2;
extern ULONG DniAccelSkip1,DniAccelSkip2;

extern PCHAR __far DntUsage[];
extern PCHAR __far DntUsageNoSlashD[];

//
// Screens
//

extern SCREEN DnsOutOfMemory;
extern SCREEN DnsAccessibilityOptions; // choose accessibility utilities
extern SCREEN DnsNoShareGiven;      // user did not give a sharepoint
extern SCREEN DnsBadSource;         // user specified a bad source
extern SCREEN DnsBadInf;            // inf file is bad or couldn't read it
extern SCREEN DnsBadLocalSrcDrive;  // local source drive on cmd line is bad
extern SCREEN DnsNoLocalSrcDrives;  // no drives suitable for local source
extern SCREEN DnsNoSpaceOnSyspart;  // not enough space for floppyless operation
extern SCREEN DnsCantCreateDir;     // couldn't create directory.
extern SCREEN DnsBadInfSection;     // inf section is bad
extern SCREEN DnsCopyError;         // error copying a file
extern SCREEN DnsVerifyError;       // copy of file didn't match original
extern SCREEN DnsWaitCopying;       // wait while setup copies files...
extern SCREEN DnsWaitCopyFlop;      // wait while setup copies files...
extern SCREEN DnsWaitCleanup;       // wait while setup cleans up...
extern SCREEN DnsNeedFloppyDisk0_0; // prompt user to insert a blank floppy
extern SCREEN DnsNeedSFloppyDsk0_0; // prompt user to insert a blank floppy
extern SCREEN DnsNeedFloppyDisk1_0; // prompt user to insert a blank floppy
extern SCREEN DnsNeedFloppyDisk2_0; // prompt user to insert a blank floppy
extern SCREEN DnsNeedFloppyDisk3_0; // prompt user to insert a blank floppy
extern SCREEN DnsNeedFloppyDisk3_1; // prompt user to insert a blank floppy
extern SCREEN DnsNeedSFloppyDsk1_0; // prompt user to insert a blank floppy
extern SCREEN DnsNeedSFloppyDsk2_0; // prompt user to insert a blank floppy
extern SCREEN DnsNeedSFloppyDsk3_0; // prompt user to insert a blank floppy
extern SCREEN DnsNeedSFloppyDsk3_1; // prompt user to insert a blank floppy
extern SCREEN DnsFloppyNotFormatted;// floppy appears to not be formatted
extern SCREEN DnsFloppyCantGetSpace;// can't determine free space on the floppy
extern SCREEN DnsFloppyNotBlank;    // not enough free space on the floppy
extern SCREEN DnsFloppyWriteBS;     // couldn't write floppy's boot sector
extern SCREEN DnsFloppyVerifyBS;    // readback of sector 0 failed or no match
extern SCREEN DnsFloppyBadFormat;   // sanity check of bpb failed
extern SCREEN DnsCantWriteFloppy;   // couldn't append to txtsetup.inf
extern SCREEN DnsExitDialog;        // exit confirmation
extern SCREEN DnsAboutToRebootS;    // about to reboot machine (server)
extern SCREEN DnsAboutToRebootW;    // about to reboot machine (workstation)
extern SCREEN DnsAboutToRebootX;    // about to reboot machine (floppyless)
extern SCREEN DnsAboutToExitS;      // about to exit winnt (server)
extern SCREEN DnsAboutToExitW;      // about to exit winnt (workstation)
extern SCREEN DnsAboutToExitX;      // about to exit winnt (floppyless)

extern SCREEN DnsConfirmRemoveNt;   // confirm remove nt files
extern SCREEN DnsCantOpenLogFile;   // Can't open setup.log
extern SCREEN DnsLogFileCorrupt;    // Log file missing [Repair.WinntFiles]
extern SCREEN DnsRemovingNtFiles;   // removing windows nt files.
extern SCREEN DnsSureSkipFile;      // confirm skip file on copy error.

extern SCREEN DnsGauge;             // gas gauge
extern SCREEN DnsBadDosVersion;     // DOS version < 3.0
extern SCREEN DnsRequiresFloppy;    // no 1.2 meg or greater floppy at a:
extern SCREEN DnsRequires486;       // not 80486 or greater
extern SCREEN DnsNotEnoughMemory;   // insufficient memory
extern SCREEN DnsCantRunOnNt;       // can't run on windows nt

extern SCREEN DnsNtBootSect;        // error installing NT Boot sector, etc.
extern SCREEN DnsOpenReadScript;    // can't open/read script file.

extern SCREEN DnsParseScriptFile;   // can't parse unattended script file
extern SCREEN DnsBootMsgsTooLarge;
extern SCREEN DnsNoSwapDrive;       // can't find a drive for INF swap file
extern SCREEN DnsNoSmartdrv;        // SMARTDRV is not installed

#if NEC_98
extern SCREEN FormatError;          // 256 Sector Error for FDLess Setup.
#endif //NEC_98

//
// Boot code messages. These go in the fat and fat32 boot sectors.
//
extern CHAR __far BootMsgNtldrIsMissing[];
extern CHAR __far BootMsgDiskError[];
extern CHAR __far BootMsgPressKey[];

#if NEC_98
#else
BOOLEAN
PatchMessagesIntoBootCode(
    VOID
    );
#endif

//
// Line number within the DnsReadBootcodeFile message where we will
// print the filename.
//

#define     BOOTCODE_FILENAME_LINE  2

//
// coords for edit field for entering source path when none was
// specified on cmd line.  Keep in sync with DnsNoShareGiven.
//

#define     NO_SHARE_X      8
#define     NO_SHARE_Y      8
#define     NO_SHARE_W      64

#define     BAD_SHARE_Y     10      // sync with DnsBadSource

//
// Keep this in sync with DnsBadInfSection
//

#define     BAD_SECTION_LINE    0

//
// Keep these in sync with DnsGauge
//

#define     GAUGE_WIDTH         50
#define     GAUGE_THERM_X       15
#define     GAUGE_THERM_Y       19
#define     GAUGE_PERCENT_X     39
#define     GAUGE_PERCENT_Y     17


//
// Keep in sync with DntTimeUntilShutdown, DnsAboutToReboot
//

#define SHUTDOWNTIME_X          23
#define SHUTDOWNTIME_Y          15


//
// Keep these in sync with DnsNotEnoughMemory
//

#define NOMEM_LINE1             3
#define NOMEM_LINE2             4

//
// Keep in syns with DnsCopyError, DnsVerifyError
//

#define COPYERR_LINE            2
#define VERIFYERR_LINE          4

//
// The max number of optional directories that can be
// specified
//

#define MAX_OPTIONALDIRS        1024
#define MAX_OEMBOOTFILES        1024
#define OPTDIR_TEMPONLY         0x00000001
#define OPTDIR_OEMSYS           0x00000002
#define OPTDIR_OEMOPT           0x00000004
#define OPTDIR_PLATFORM_INDEP   0x00000008
extern  unsigned    OptionalDirCount;   // The number of Optional Directories
extern  CHAR        *OptionalDirs[MAX_OPTIONALDIRS];    // Pointer to Dir strings
extern  unsigned    OptionalDirFlags[MAX_OPTIONALDIRS]; // Flags for each Dir
extern  unsigned    OptionalDirFileCount;   // How many files in optional dirs?
extern  unsigned    OemBootFilesCount;   // The number of OEM boot files
extern  CHAR        *OemBootFiles[MAX_OEMBOOTFILES];    // Pointer to OEM boot filenames
extern  PCHAR       CmdToExecuteAtEndOfGui;

// slight overestimate, actually 66, but does that include terminal nul?
// 128 is a popular number in the source
#define DOS_MAX_PATH            70

//
// Logging stuff
//
#define LOGGING

#ifdef LOGGING
VOID
__LOG(
    IN PCHAR FormatString,
    ...
    );

#define _LOG(x) __LOG x
#else
#define _LOG(x)
#endif // def LOGGING

extern SPACE_REQUIREMENT    __far SpaceRequirements[];

int snprintf( char* target, size_t bufsize, const char *format, ... );
int vsnprintf( char* target, size_t bufsize, const char *format, va_list val );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\winnt.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    winnt.c

Abstract:

    Top level file for DOS based NT installation program.

Author:

    Ted Miller (tedm) 30-March-1992

Revision History:

--*/

/*

    NOTES:

    The function of this program is to pull down a complete Windows NT
    installation source onto a local partition, and create a setup boot
    floppy.  The machine is then rebooted, starting a Windows NT Setup
    just as if the user had used the real setup floppies or CD-ROM.

    The following assumptions are made:

    -   The floppy must be provided by the user and already formatted.

    -   The files on the network source are in the same directory layout
        structure that will be created in the temp directory on the local
        source (ie, as far as winnt is concerned, the source and target
        directory layout is the same).

    The inf file is expected to be formatted as follows:


    [SpaceRequirements]

    # BootDrive is the # bytes required free on C:.
    # NtDrive   is the # bytes required free on the drive chosen by
    #           the user to contain Windows NT.

    BootDrive =
    NtDrive   =


    [Miscellaneous]

    # misc junk that goes nowhere else.


    [Directories]

    # Specification of the source directory structure.  All directories
    # are relative to the directory where dos2nt.inf was found on the
    # remote source or the temp directory on the local source.
    # Loading and trailing backslashes are ignored -- to specify the root,
    # leave the dirctory field blank or use \.

    d1 =
    d2 = os2
        .
        .
        .


    [Files]

    # List of files to be copied to the local source directory.
    # Format is <srcdir>,<filename> where <srcdir> matches an entry in the
    # Directories section, and <filename> should not contain any path
    # characters.

    d1,ntoskrnl.exe
    d1,ntdll.dll
        .
        .
        .


    [FloppyFiles]

    # List of files that are to be placed on the floppy that Setup creates.
    # Format is same as for lines in the [Files] sections except the directory
    # is only used for the source -- the target path is always a:\.

    d1,aha154x.sys
        .
        .
        .

*/


#include "winnt.h"
#include <errno.h>
#include <string.h>
#include <dos.h>
#include <stdlib.h>
#include <direct.h>
#include <fcntl.h>
#include <ctype.h>
#include <process.h>
#if NEC_98
#include <signal.h>
#include <io.h>
#endif // NEC_98
#include "SetupSxs.h"

//
// define name of default inf file and default source path
//

#define DEFAULT_INF_NAME    "dosnet.inf"
PCHAR DrvindexInfName = "drvindex.inf";
#if NEC_98
//
// Boot Device Information.(for /b)
//
typedef struct _BOOTDISKINF {
    UCHAR    PartitionPosition;    // 0-F
    UCHAR    DA_UA;                // SASI/IDE 80, SCSI A0
    USHORT   DiskSector;           // Device Format Sector Size
} BOOTDISKINF, *PBOOTDISKINF;

PBOOTDISKINF BootDiskInfo;         // Boot Device Information of Pointer(for /b).

BOOLEAN  CursorOnFlag = FALSE;     // For Cursor OFF
USHORT   Cylinders;                // For Dos 3.x format
UCHAR    TargetDA_UA;
//
// Make File Pointer.
//
#define MAKE_FP(p,a)    FP_SEG(p) = (unsigned short)((a) >> 4) & 0xffff; FP_OFF(p) = (unsigned short)((a) & 0x0f)

//
// Connect Device DA_UA.
//
typedef struct _CONNECTDAUA {
    UCHAR    DA_UA;                // SASI/IDE 80, SCSI A0
} CONNECTDAUA, *PCONNECTDAUA;
PCONNECTDAUA DiskDAUA;             // Connect DA_UA of Pointer.

PUCHAR  LPTable;                   // DOS System of LPTable.
UCHAR   SupportDosVersion = 5;     // LPTable Support Dos version;
BOOLEAN SupportDos = TRUE;
#define FLOPPY_SIZE 1457664L

//
// Search First Floppy Disk Drive ( 0:None Drive / 1-26:Drive# )
//
USHORT   FirstFD;
#endif // NEC_98

//
// Command line arguments
//
PCHAR CmdLineSource,CmdLineTarget,CmdLineInf,CmdLineDelete;
BOOLEAN SourceGiven,TargetGiven,InfGiven,DeleteGiven;

//
// If the user gives a script file on the command line,
// if will be appended to winnt.sif.
//
PCHAR DngScriptFile = NULL;

//
// DngSourceRootPath is the drivespec and path to the root of the source,
// and never ends in \ (will be length 2 if source is the root).
//
// Examples:  D:\foo\bar D:\foo D:
//
PCHAR DngSourceRootPath;

PCHAR UserSpecifiedOEMShare = 0;

CHAR  DngTargetDriveLetter;

CHAR  DngSwapDriveLetter;

PVOID DngInfHandle;
PVOID DngDrvindexInfHandle;

PCHAR LocalSourceDirName = LOCAL_SOURCE_DIRECTORY;
#if NEC_98
PCHAR x86DirName = "\\NEC98";
#else  // NEC_98
PCHAR x86DirName = "\\I386";
#endif // NEC_98

//
// If this flag is TRUE, then verify the files that are copied to
// the floppy.  If it is FALSE, don't.  The /f switch overrides.
//
BOOLEAN DngFloppyVerify = TRUE;

//
// If this is FALSE, suppress creation of the boot floppies.
//
BOOLEAN DngCreateFloppies = TRUE;
BOOLEAN DngFloppiesOnly = FALSE;

//
// If TRUE, create winnt floppies.
// If FALSE, create cd/floppy floppies (no winnt.sif)
//
BOOLEAN DngWinntFloppies = TRUE;

//
// If this flag is TRUE, then check the free space on the floppy disk
// before accepting it.  Otherwise don't check free space.
//
BOOLEAN DngCheckFloppySpace = TRUE;

//
// Current drive when program invoked, saved so we can restore it
// if the user exits early.
//
unsigned DngOriginalCurrentDrive;

//
// If this is true, we do floppyless operation,
// installing an nt boot on the system partition (C:)
// and starting setup from there.
//
BOOLEAN DngFloppyless = FALSE;

//
// Unattended mode, ie, skip final reboot screen.
//
BOOLEAN DngUnattended = FALSE;

BOOLEAN DngServer = FALSE;

//
// Flag that indicates that we are running on Windows
// (ie, not bare DOS).
//
BOOLEAN DngWindows = FALSE;

//
// Flag that indicates we want to see the accessiblity options
//
BOOLEAN DngAccessibility = FALSE;
BOOLEAN DngMagnifier = FALSE;
BOOLEAN DngTalker = FALSE;
BOOLEAN DngKeyboard = FALSE;

//
// Flag for the 2nd CD enhancements to setup
//
BOOLEAN DngCopyOnlyD1TaggedFiles = TRUE;

//
// Flag that indicates that we are running OEM preinstall
//
BOOLEAN DngOemPreInstall = FALSE;
PCHAR   OemSystemDirectory = WINNT_OEM_DIR;
PCHAR   OemOptionalDirectory = WINNT_OEM_OPTIONAL_DIR;

PCHAR UniquenessDatabaseFile;
PCHAR UniquenessId;

//
//  Command to execute at the end of GUI setup
//
PCHAR CmdToExecuteAtEndOfGui = NULL;

//
// Keep track of any optional dirs that the user wants
// to copy
//
unsigned    OptionalDirCount;
CHAR    *OptionalDirs[MAX_OPTIONALDIRS];
unsigned    OptionalDirFlags[MAX_OPTIONALDIRS];
unsigned    OptionalDirFileCount;

//
// Keep track of any OEM boot file specified on [OemBootFiles]
// in the script file
//
unsigned    OemBootFilesCount;
CHAR    *OemBootFiles[MAX_OEMBOOTFILES];

//
//  Define the minimum disk space needed in order to copy the temporary
//  directories to drives formatted with all possible cluster sizes
//

SPACE_REQUIREMENT    SpaceRequirements[] = { { "TempDirSpace512", (unsigned)  512, 0 },
                                             {  "TempDirSpace1K", (unsigned) 1024, 0 },
                                             {  "TempDirSpace2K", (unsigned) 2048, 0 },
                                             {  "TempDirSpace4K", (unsigned) 4096, 0 },
                                             {  "TempDirSpace8K", (unsigned) 8192, 0 },
                                             { "TempDirSpace16K", (unsigned)16384, 0 },
                                             { "TempDirSpace32K", (unsigned)32768, 0 }
                                           };

#define TEDM
#ifdef TEDM
BOOLEAN DngAllowNt = FALSE;
#endif

VOID
DnpFetchArguments(
    VOID
    );

BOOLEAN
DnpParseArguments(
    IN int argc,
    IN char *argv[]
    );

VOID
DnpGetAccessibilityOptions(
    VOID
    );

VOID
DnpValidateAndConnectToShare(
    FILE **InfFileHandle,
    FILE **DrvindexInfFileHandle
    );

VOID
DnpValidateAndInspectTarget(
    VOID
    );

VOID
DnpCheckMemory(
    VOID
    );

VOID
DnpCheckSmartdrv(
    VOID
    );

BOOLEAN
DnpIsValidSwapDrive(
    IN  CHAR      Drive,
    IN  ULONG     SpaceRequired
    );

BOOLEAN
DnpIsValidLocalSource(
    IN CHAR Drive,
    IN BOOLEAN CheckLocalSource,
    IN BOOLEAN CheckBootFiles
    );

VOID
DnpDetermineLocalSourceDrive(
    VOID
    );

VOID
DnpDetermineSwapDrive(
    VOID
    );

#if 0
BOOLEAN
DnpConstructLocalSourceList(
    OUT PCHAR DriveList
    );
#endif

ULONG
DnGetMinimumRequiredSpace(
   IN CHAR DriveLetter
   );

VOID
DnpReadInf(
    IN FILE *InfFileHandle,
    IN FILE *DrvindexInfFileHandle
    );

VOID
DnpCheckEnvironment(
    VOID
    );

BOOLEAN
RememberOptionalDir(
    IN PCHAR Dir,
    IN unsigned Flags
    );

void
_far
DnInt24(
    unsigned deverror,
    unsigned errcode,
    unsigned _far *devhdr
    );

VOID
StartLog(
    VOID
    );

// in cpu.asm
#if NEC_98
extern
USHORT
HwGetProcessorType(
    VOID
    );
#else // NEC_98
USHORT
HwGetProcessorType(
    VOID
    );
#endif // NEC_98

#if NEC_98
VOID
CheckTargetDrive(
    VOID
    );

VOID
SetAutoReboot(
    VOID
    );

USHORT
GetSectorValue(
    IN UCHAR CheckDA_UA
    );

BOOLEAN
DiskSectorReadWrite(
    IN  USHORT  HDSector,
    IN  UCHAR   ReadWriteDA_UA,
    IN  BOOLEAN ReadFlag,
    IN  PSHORT  ReadBuffer
    );

VOID
GetLPTable(
    IN  PCHAR pLPTable
    );

VOID
ClearBootFlag(
    VOID
    );

VOID
BootPartitionData(
    VOID
    );

BOOLEAN
CheckBootDosVersion(
    IN UCHAR SupportDosVersion
    );

VOID
GetDaUa(VOID);

VOID
SearchFirstFDD(VOID);

extern
ULONG
DnpCopyOneFile(
    IN PCHAR   SourceName,
    IN PCHAR   DestName,
    IN BOOLEAN Verify
    );

extern
PCHAR
DnGetSectionLineIndex (
   IN PVOID INFHandle,
   IN PCHAR SectionName,
   IN unsigned LineIndex,
   IN unsigned ValueIndex
   );

VOID
DummyRoutine(
    VOID
    );
#endif // NEC_98

VOID
main(
    IN int argc,
    IN char *argv[]
    )
{
    FILE *f, *drvindex;
#ifdef LCP
    USHORT codepage;
#endif // def LCP

#if NEC_98
    DngTargetDriveLetter = 0;
    //
    // CTRL + C Hook
    //
    signal(SIGINT,DummyRoutine);
#else // NEC_98
#ifdef LCP

    // Determine the local code page
    _asm {
        mov ax,06601h
        int 21h
        jnc ok
        xor bx,bx
    ok: mov codepage, bx
    }

    //  If codepage does not correspond to winnt.exe's language,
    //  start US Winnt.exe (winntus.exe)

// Czech
#if CS
    #define LANGCP (852)
#else
// Greek
#if EL
    #define LANGCP (737)
#else
// Japanese
#if JAPAN
    #define LANGCP (932)
#else
// Russian
#if RU
    #define LANGCP (866)
#else
// Polish
#if PL
    #define LANGCP (852)
#else
// Hungarian
#if HU
    #define LANGCP (852)
#else
// Turkish
#if TR
    #define LANGCP (857)
#else
// Pseudo
#if PSU
    #define LANGCP (857)
#else
    #error Unable to define LANGCP as no matching language was found.
#endif // PSU
#endif // TR
#endif // HU
#endif // PL
#endif // RU
#endif // JAPAN
#endif // EL
#endif // CS

    if (codepage != LANGCP) {
        argv[0] = "winntus";
        execv("winntus", argv);
        return;
    }
#endif // def LCP
#endif // NEC_98
    //
    // Parse arguments
    //

    if(!DnpParseArguments(argc,argv)) {

        PCHAR *p;

        //
        // Bad args.  Print usage message and exit.
        //
        // If user specified /D, display message informing that the
        // switch is no longer supported
        //
        for( (p = DeleteGiven ? DntUsageNoSlashD : DntUsage);
             *p;
             p++) {
            puts(*p);
        }
        return;
    }

    //
    // establish int 24 handler
    //
    _harderr(DnInt24);

    //
    // determine current drive
    //

    _dos_getdrive(&DngOriginalCurrentDrive);

    //
    // Initialize screen
    //

    DnInitializeDisplay();

#if NEC_98
#else
    //
    // Patch boot code with translated messages.
    //
    if(!PatchMessagesIntoBootCode()) {
        DnFatalError(&DnsBootMsgsTooLarge);
    }
#endif

    DnWriteString(DntStandardHeader);

    DnpDetermineSwapDrive ();

    if(DngUnattended) {
        //
        // Check to see if we should process the contents of
        // the script file.
        // Note that we need to process the contents of the script file
        // only after the video is initialized. Otherwise, we won't be able
        // to report fatal errors.
        //
        if (DngScriptFile) {
            DnpFetchArguments();
        }
    }

#if 0
    //
    //  /D is no longer supported
    //
    if(DeleteGiven) {
        DnDeleteNtTree(CmdLineDelete);
    }
#endif

    DnpCheckEnvironment();

#if NEC_98
    LPTable = MALLOC(96,TRUE);

    SupportDos = CheckBootDosVersion(SupportDosVersion);

    GetLPTable(LPTable);

    SearchFirstFDD();
#endif // NEC_98

    DnpValidateAndConnectToShare(&f, &drvindex);
    DnpReadInf(f, drvindex);
    fclose(f);
    fclose(drvindex);

    if(DngAccessibility) {
        DnpGetAccessibilityOptions();
    }

    DnpCheckMemory();

    DnpCheckSmartdrv ();

    if(!DngFloppiesOnly) {
        DnpDetermineLocalSourceDrive();
    }

#if NEC_98
    if(!DngFloppiesOnly) {
        BootDiskInfo = MALLOC(sizeof(BOOTDISKINF),TRUE);
        BootPartitionData();
        CheckTargetDrive();
    }
#endif // NEC_98
    if(!DngAllowNt && DngCreateFloppies) {
        DnCreateBootFloppies();
    }

    if(!DngFloppiesOnly) {
        DnCopyFiles();
#if NEC_98
        //
        // Set Auto Reboot Flag
        //
        if(DngFloppyless) {
            ClearBootFlag();
            SetAutoReboot();
        }
        FREE(BootDiskInfo);
        FREE(LPTable);
#endif // NEC_98
        DnFreeINFBuffer (DngInfHandle);
        DnFreeINFBuffer (DngDrvindexInfHandle);
        DnToNtSetup();
    }
    DnFreeINFBuffer (DngInfHandle);
    DnFreeINFBuffer (DngDrvindexInfHandle);
    DnExit(0);
}


BOOLEAN
RememberOptionalDir(
    IN PCHAR Dir,
    IN unsigned Flags
    )
{
    unsigned    u;

    for (u = 0; u < OptionalDirCount; u++) {

        if(!stricmp(OptionalDirs[u],Dir)) {
            OptionalDirFlags[u] = Flags;
            return (TRUE);
        }

    }

    //
    // Not already in there
    //
    if (OptionalDirCount < MAX_OPTIONALDIRS) {

        OptionalDirs[OptionalDirCount] = Dir;
        OptionalDirFlags[OptionalDirCount] = Flags;
        OptionalDirCount++;
        return (TRUE);

    }

    return (FALSE);
}

BOOLEAN
RememberOemBootFile(
    IN PCHAR File
    )
{
    unsigned    u;

    for (u = 0; u < OemBootFilesCount; u++) {

        if(!stricmp(OemBootFiles[u],File)) {
            return (TRUE);
        }

    }

    //
    // Not already in there
    //
    if (OemBootFilesCount < MAX_OEMBOOTFILES) {

        OemBootFiles[OemBootFilesCount] = File;
        OemBootFilesCount++;
        return (TRUE);

    }

    return (FALSE);
}

VOID
DnpFetchArguments(
    VOID
    )
{
    PCHAR   WinntSetupP = WINNT_SETUPPARAMS;
    PCHAR   WinntYes = WINNT_A_YES;
    PCHAR   WinntNo = WINNT_A_NO;
    FILE    *FileHandle;
    int     Status;
    PVOID   ScriptHandle;

    PCHAR   WinntUnattended = WINNT_UNATTENDED;
    PCHAR   WinntOemPreinstall = WINNT_OEMPREINSTALL;
    unsigned    LineNumber;

    //
    // First open the script file as a dos file
    //
    FileHandle = fopen(DngScriptFile,"rt");
    if(FileHandle == NULL) {
        //
        // fatal error.
        //
        DnFatalError(&DnsOpenReadScript);
    }

    //
    // Now open it as a INF file
    //
    LineNumber = 0;
    Status = DnInitINFBuffer (FileHandle, &ScriptHandle, &LineNumber);
    fclose(FileHandle);
    if(Status == ENOMEM) {
        DnFatalError(&DnsOutOfMemory);
    } else if(Status) {
        DnFatalError(&DnsParseScriptFile, DngScriptFile, LineNumber);
    }

    //
    // Find out if this is an OEM preinstall
    //
    if (DnSearchINFSection(ScriptHandle,WinntUnattended)) {

        if (DnGetSectionKeyExists(ScriptHandle,WinntUnattended,WinntOemPreinstall)) {

            PCHAR   Ptr;

            //
            // OEM preinstall key exists
            //
            Ptr = DnGetSectionKeyIndex(ScriptHandle,WinntUnattended,WinntOemPreinstall,0);
            if (Ptr != NULL) {
                if (stricmp(Ptr,WinntYes) == 0) {
                    //
                    // This is an OEM pre-install
                    //
                    DngOemPreInstall = TRUE;
                } else {
                    //
                    // Assume this is not an OEM pre-install
                    //
                    DngOemPreInstall = FALSE;
                }
                FREE (Ptr);
            }
        }

        //
        // See if the user specified a network (or any secondary) path
        // for the $OEM$ files.
        //
        if( DngOemPreInstall ) {
            if (DnGetSectionKeyExists(ScriptHandle,WinntUnattended,WINNT_OEM_DIRLOCATION)) {

                PCHAR   Ptr;
                unsigned i;

                //
                // WINNT_OEM_DIRLOCATION preinstall key exists
                //
                Ptr = DnGetSectionKeyIndex(ScriptHandle,WinntUnattended,WINNT_OEM_DIRLOCATION,0);

                //
                // Now take care of the case whether or not
                // the user actually appended $OEM$ onto the path.
                // For the case of winnt.exe, we don't want it.  We
                // need to remove it if it's there.
                UserSpecifiedOEMShare = DnDupString( Ptr );

                FREE (Ptr);

                for( i = 0; i < strlen(UserSpecifiedOEMShare); i++ ) {
                    UserSpecifiedOEMShare[i] = (UCHAR) toupper(UserSpecifiedOEMShare[i]);
                }
                Ptr = strstr( UserSpecifiedOEMShare, "$OEM$" );
                if( Ptr ) {
                    //
                    // Whack the end off...
                    //
                    *Ptr = 0;
                }
            }
        }

        if( DngOemPreInstall ) {
            //
            //  Always add to the list of optional directories the directory
            //  $OEM$
            //
            RememberOptionalDir(OemSystemDirectory, OPTDIR_OEMSYS);

            //
            //  If this an OEM pre-install, build a list with the name of all
            //  OEM optional directories.
            //

            if (DnSearchINFSection(ScriptHandle, WINNT_OEMOPTIONAL)) {

                unsigned    KeyIndex;
                PCHAR       DirName;

                //
                //  Add the temporary OEM directories to the array of
                //  temporary directories.
                //
                for( KeyIndex = 0;
                     ((DirName = DnGetKeyName(ScriptHandle,WINNT_OEMOPTIONAL,KeyIndex)) != NULL );
                     KeyIndex++ ) {
                    //
                    // We have a valid directory name
                    //

                    PCHAR   p;

                    if((p = DnDupString(DirName)) == NULL) {
                        DnFatalError(&DnsOutOfMemory);
                    }
                    RememberOptionalDir(p, OPTDIR_OEMOPT);

                    FREE (DirName);
                }
            }

            //
            //  If this an OEM pre-install, build a list with the name of all
            //  OEM boot files.
            //
            if (DnSearchINFSection(ScriptHandle, WINNT_OEMBOOTFILES)) {
                unsigned    LineIndex;
                PCHAR       FileName;

                //
                //  Add the OEM boot files to the array of
                //  OEM boot files.
                //
                for( LineIndex = 0;
                     ((FileName = DnGetSectionLineIndex(ScriptHandle,WINNT_OEMBOOTFILES,LineIndex,0)) != NULL );
                     LineIndex++ ) {

                        PCHAR   q;

                        if((q = DnDupString(FileName)) == NULL) {
                            DnFatalError(&DnsOutOfMemory);
                        }
                        RememberOemBootFile(q);

                        FREE (FileName);
                }
            }
        }
    }

    //
    // We are done with the ScriptHandle for now
    //
    DnFreeINFBuffer(ScriptHandle);
}


BOOLEAN
DnpParseArguments(
    IN int argc,
    IN char *argv[]
    )

/*++

Routine Description:

    Parse arguments passed to the program.  Perform syntactic validation
    and fill in defaults where necessary.

    Valid arguments:

    /d:path                 - specify installation to remove
                              (not supported anymore)
    /s:sharepoint[path]     - specify source sharepoint and path on it
    /t:drive[:]             - specify temporary local source drive
    /i:filename             - specify name of inf file
    /o                      - create boot floppies only
                              (not supported anymore)
    /f                      - turn floppy verification off
                              (not supported anymore)
    /c                      - suppress free-space check on the floppy
                              (not supported anymore)
    /x                      - suppress creation of the floppy altogether
    /b                      - floppyless operation
                              (not supported anymore)
    /u                      - unattended (skip final reboot screen)
    /w                      - [undoc'ed] must be specifed when running
                              under windows, chicago, etc.
    /a                      - enable accessibility options

    /2                      - copy the entire source locally - all files irrespective
                              of the d1/d2 tags.  Default is only d1 tagged files.  
                              Introduced for the 2 CD install that is required tablets.
Arguments:

    argc - # arguments

    argv - array of pointers to arguments

Return Value:

    None.

--*/

{
    PCHAR arg;
    CHAR swit;
    PCHAR   ArgSwitches[] = { "E", "D", "T", "I", "RX", "R", "S", NULL };
    PCHAR   RestOfSwitch;
    int     i;
    int     l;

    //
    // Set the variables that are no longer
    // settable via the command line.
    //
    DngFloppyless = TRUE;
    DngCreateFloppies = FALSE;

    //
    // Skip program name
    //
    argv++;

    DeleteGiven = SourceGiven = TargetGiven = FALSE;
    OptionalDirCount = 0;
    CmdLineTarget = CmdLineInf = NULL;

    while(--argc) {

        if((**argv == '-') || (**argv == '/')) {

            swit = argv[0][1];

            //
            // Process switches that take no arguments here.
            //
            switch(swit) {
            case '?':
                return(FALSE);      // force usage

#if 0
            case 'f':
            case 'F':
                argv++;
                DngFloppyVerify = FALSE;
                continue;
#endif
#if 0
            case 'c':
            case 'C':
                argv++;
                DngCheckFloppySpace = FALSE;
                continue;
#endif
#if 0
            case 'x':
            case 'X':
                argv++;
                DngCreateFloppies = FALSE;
                continue;
#endif
#ifdef LOGGING
            case 'l':
            case 'L':
                argv++;
                StartLog();
                continue;
#endif

#if 0
            case 'o':
            case 'O':
                //
                // check for /Ox. /O* is a secret switch that replaces the old /o.
                //
                switch(argv[0][2]) {
                case 'x':
                case 'X':
                    DngWinntFloppies = FALSE;
                case '*':
                    break;
                default:
                    return(FALSE);
                }
                argv++;
                DngFloppiesOnly = TRUE;
                continue;
#endif

#if 0
            case 'b':
            case 'B':
                argv++;
                DngFloppyless = TRUE;
                continue;
#endif

            case 'u':
            case 'U':

                if(((argv[0][2] == 'd') || (argv[0][2] == 'D'))
                && ((argv[0][3] == 'f') || (argv[0][3] == 'F'))) {

                    if((argv[0][4] == ':') && argv[0][5]) {

                        if((arg = strchr(&argv[0][5],',')) == NULL) {
                            arg = strchr(&argv[0][5],0);
                        }

                        l = arg - &argv[0][5];

                        UniquenessId = MALLOC(l+2,TRUE);
                        memcpy(UniquenessId,&argv[0][5],l);
                        UniquenessId[l] = 0;

                        if(*arg++) {
                            if(*arg) {
                                //
                                // Now the rest of the param is the filename of
                                // the uniqueness database
                                //
                                UniquenessDatabaseFile = DnDupString(arg);
                                UniquenessId[l] = '*';
                                UniquenessId[l+1] = 0;

                            } else {
                                return(FALSE);
                            }
                        }

                    } else {
                        return(FALSE);
                    }
                } else {
                    DngUnattended = TRUE;
                    //
                    // User can say -u:<file> also
                    //
                    if(argv[0][2] == ':') {
                        if(argv[0][3] == 0) {
                            return(FALSE);
                        }
                        if((DngScriptFile = DnDupString(&argv[0][3])) == NULL) {
                            DnFatalError(&DnsOutOfMemory);
                        }
                    }
                }
                argv++;
                continue;

            case 'w':
            case 'W':
                //
                // This flag used to force us to run under Windows,
                // when doing a 386 stepping check could crash the system.
                // Now we don't support 386, so this check is never done.
                //
                // However we accept the arg to force us into Windows mode on DOS,
                // which allows someone to avoid the final reboot.
                //
                DngWindows = TRUE;
                argv++;
                continue;

            case 'a':
            case 'A':
                argv++;
                DngAccessibility = TRUE;
                continue;

#ifdef TEDM
            case 'i':
            case 'I':
                if(!stricmp(argv[0]+1,"I_am_TedM")) {
                    argv++;
                    DngAllowNt = TRUE;
                    continue;
                }
#endif

            case '2':
                argv++;
                DngCopyOnlyD1TaggedFiles = FALSE;
                //_LOG(("Going to copy files irrespective of the directory tag\n"));
                continue;
            }


            //
            // Process switches that take arguments here.
            //

            //
            // This code taken from winnt32.c. It has the
            // purpose of validating the switch and determining
            // where the next argument lines
            //

            for (i=0; ArgSwitches[i]; i++) {

                l = strlen(ArgSwitches[i]);
                if (!strnicmp(ArgSwitches[i],&argv[0][1],l)) {

                    //
                    // we have a match. Next char of arg must either
                    // be : or nul. If it's : then arg immediately
                    // follows. Otherwise, if it's null, then arg must
                    // be next argument
                    //

                    if (argv[0][1+l] == ':') {

                        arg = &argv[0][2+l];
                        if (*arg == '\0') {
                            return (FALSE);
                        }
                        RestOfSwitch = &argv[0][2];
                        break;

                    } else {

                        if (argv[0][1+l] == '\0') {
                            if (argc <= 1) {

                                //
                                // no arguments left
                                //
                                return (FALSE);

                            }
                            RestOfSwitch = &argv[0][2];
                            argc--;
                            arg = argv[1];
                            argv++;
                            break;
                        } else {

                            //
                            // Do nothing here
                            //
                            NULL;

                        } // if ... else
                    } // if ... else
                } // if ...
            } // for

            //
            // Check termination condition
            //
            if (!ArgSwitches[i]) {
                return (FALSE);
            }

            switch(swit) {

            case 'r':
            case 'R':

                RememberOptionalDir(
                    DnDupString(arg),
                    ( (RestOfSwitch[0] == 'X' || RestOfSwitch[0] == 'x') ?
                        OPTDIR_TEMPONLY : 0 ) );
                break;

            case 'd':
            case 'D':
                //
                //  /D is no longer supported
                //
                DeleteGiven = TRUE;
                return(FALSE);

#if 0
            case 'd':
            case 'D':
                if(DeleteGiven) {
                    return(FALSE);
                } else {
                    if((CmdLineDelete = DnDupString(arg)) == NULL) {
                        DnFatalError(&DnsOutOfMemory);
                    }
                    DeleteGiven = TRUE;
                }
                break;
#endif
            case 's':
            case 'S':
                if(SourceGiven) {
                    return(FALSE);
                } else {
                    if((CmdLineSource = DnDupString(arg)) == NULL) {
                        DnFatalError(&DnsOutOfMemory);
                    }
                    SourceGiven = TRUE;
                }
                break;

            case 't':
            case 'T':
                if(TargetGiven) {
                    return(FALSE);
                } else {
                    if((CmdLineTarget = DnDupString(arg)) == NULL) {
                        DnFatalError(&DnsOutOfMemory);
                    }
                    TargetGiven = TRUE;
                }
                break;

            case 'i':
            case 'I':
                if(InfGiven) {
                    return(FALSE);
                } else {
                    if((CmdLineInf = DnDupString(arg)) == NULL) {
                        DnFatalError(&DnsOutOfMemory);
                    }
                    InfGiven = TRUE;
                }
                break;

            case 'E':
            case 'e':
                if(CmdToExecuteAtEndOfGui) {
                    return(FALSE);
                } else {
                    if((CmdToExecuteAtEndOfGui = DnDupString(arg)) == NULL) {
                        DnFatalError(&DnsOutOfMemory);
                    }
                }
                break;

            default:
                return(FALSE);
            }

        } else {
            return(FALSE);
        }

        argv++;
    }

    //
    // If /u was specified, make sure /s was also given
    // and force /b.
    //
    if(DngUnattended) {
        if(!SourceGiven) {
            return(FALSE);
        }
        DngFloppyless = TRUE;
    }

    if(DngFloppyless) {
        //
        // Force us into the floppy creation code.
        //
        DngCreateFloppies = TRUE;
        DngWinntFloppies = TRUE;
    }

    return(TRUE);
}


VOID
DnpGetAccessibilityOptions(
    VOID
    )

/*++

Routine Description:

    Ask the user which accessibility utilities to install for GUI Setup.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG   ValidKey[4];
    ULONG   Key;
    CHAR    Mark;

    //
    // Make sure the setup boot floppy we created is in the drive
    // if necessary.
    //
    DnClearClientArea();

    DnDisplayScreen(&DnsAccessibilityOptions);

    DnWriteStatusText(DntEnterEqualsContinue);
    ValidKey[0] = ASCI_CR;
    ValidKey[1] = DN_KEY_F1;
    ValidKey[2] = DN_KEY_F2;
    ValidKey[3] = 0;

    while((Key = DnGetValidKey(ValidKey)) != ASCI_CR) {

        switch(Key) {

        case DN_KEY_F1:
            DngMagnifier = (BOOLEAN)!DngMagnifier;
            Mark = DngMagnifier ? RADIO_ON : RADIO_OFF;
            DnPositionCursor(4,7);
            break;

        case DN_KEY_F2:
            DngTalker = (BOOLEAN)!DngTalker;
            Mark = DngTalker ? RADIO_ON : RADIO_OFF;
            DnPositionCursor(4,8);
            break;
#if 0
        case DN_KEY_F3:
            DngKeyboard = (BOOLEAN)!DngKeyboard;
            Mark = DngKeyboard ? RADIO_ON : RADIO_OFF;
            DnPositionCursor(4,9);
            break;
#endif
        }

        DnWriteChar(Mark);
    }
}


VOID
DnpValidateAndConnectToShare(
    FILE **InfFileHandle,
    FILE **DrvindexInfFileHandle
    )

/*++

Routine Description:

    Split the source given by the user into drive and path
    components.  If the user did not specify a source, prompt him
    for one.  Look for dos2nt.inf on the source (ie, validate the
    source) and keep prompting the user for a share until he enters
    one which appears to be valid.

Arguments:

Return Value:

    None.

--*/

{
    CHAR UserString[256];
    PCHAR InfFullName, DrvindexInfFullName;
    PCHAR q;
    BOOLEAN ValidSourcePath;
    unsigned len;

    DnClearClientArea();
    DnWriteStatusText(NULL);

    //
    // Use default inf file if none specified.
    //
    if(!InfGiven) {
        CmdLineInf = DEFAULT_INF_NAME;
    }

    //
    // If the user did not enter a source, prompt him for one.
    //
    if(SourceGiven) {
        strcpy(UserString,CmdLineSource);
    } else {
#if NEC_98
        CursorOnFlag = TRUE;
#endif // NEC_98
        DnDisplayScreen(&DnsNoShareGiven);
        DnWriteStatusText("%s  %s",DntEnterEqualsContinue,DntF3EqualsExit);
        if(getcwd(UserString,sizeof(UserString)-1) == NULL) {
            UserString[0] = '\0';
        }
#if NEC_98
        CursorOnFlag = FALSE;
#endif // NEC_98
        DnGetString(UserString,NO_SHARE_X,NO_SHARE_Y,NO_SHARE_W);
    }

    ValidSourcePath = FALSE;

    do {

        DnWriteStatusText(DntOpeningInfFile);

        //
        // Make a copy of the path the user typed leaving extra room.
        //
        DngSourceRootPath = MALLOC(256,TRUE);
        if(len = strlen(UserString)) {

            strcpy(DngSourceRootPath,UserString);

            //
            // If the user typed something like x:, then we want to
            // change that to x:. so this does what he expects.
            // Doing so also lets the canonicalize routine work.
            //
            if((DngSourceRootPath[1] == ':') && !DngSourceRootPath[2]) {
                DngSourceRootPath[2] = '.';
                DngSourceRootPath[3] = 0;
            }

            //
            // Now attempt to canonicalize the name. If this doesn't work,
            // then it's definitely not a valid path.
            //
            if(DnCanonicalizePath(DngSourceRootPath,UserString)) {

                strcpy(DngSourceRootPath,UserString);

                //
                // If the path doesn't end with a backslash,
                // append a backslash before appending the inf filename.
                //
                len = strlen(DngSourceRootPath);
                if(DngSourceRootPath[len-1] != '\\') {
                    DngSourceRootPath[len] = '\\';
                    DngSourceRootPath[len+1] = 0;
                    len++;
                }

                InfFullName = MALLOC(len + strlen(CmdLineInf) + 1,TRUE);
                strcpy(InfFullName,DngSourceRootPath);
                strcat(InfFullName,CmdLineInf);

                DrvindexInfFullName = MALLOC(len + strlen(DrvindexInfName) + 1,TRUE);
                strcpy(DrvindexInfFullName,DngSourceRootPath);
                strcat(DrvindexInfFullName,DrvindexInfName);





                //
                // Attempt to open the inf file on the source.
                // If that fails look for it in the i386 subdirectory.
                //
                //_LOG(("Validate source path: trying %s\n",InfFullName));
                //_LOG(("Validate source path: trying %s\n",DrvindexInfFullName));

                if((*InfFileHandle = fopen(InfFullName,"rt")) != NULL){
                    if((*DrvindexInfFileHandle = fopen(DrvindexInfFullName,"rt")) != NULL){
                        ValidSourcePath = TRUE;
                    }
                    else
                        fclose( *InfFileHandle );
                }

                if(*InfFileHandle != NULL ){
                    //_LOG(("%s opened successfully\n",InfFullName));
                }

                if(*DrvindexInfFileHandle != NULL ){
                    //_LOG(("%s opened successfully\n",DrvindexInfFullName));
                }

                
                FREE(InfFullName);
                FREE(DrvindexInfFullName);
                if(!ValidSourcePath) {
                    InfFullName = MALLOC(len+strlen(CmdLineInf)+strlen(x86DirName)+1,TRUE);
                    DrvindexInfFullName = MALLOC(len+strlen(DrvindexInfName)+strlen(x86DirName)+1,TRUE);
                    strcpy(InfFullName,DngSourceRootPath);
                    strcat(InfFullName,x86DirName+1);
                    strcat(InfFullName,"\\");
                    strcpy(DrvindexInfFullName, InfFullName);
                    strcat(InfFullName,CmdLineInf);
                    strcat(DrvindexInfFullName,DrvindexInfName);
                    
                    //_LOG(("Validate source path: trying %s\n",InfFullName));



                    if((*InfFileHandle = fopen(InfFullName,"rt")) != NULL){
                        if((*DrvindexInfFileHandle = fopen(DrvindexInfFullName,"rt")) != NULL){
                            ValidSourcePath = TRUE;
                        }
                        else
                            fclose( *InfFileHandle );
                    }

                    if(*InfFileHandle != NULL ){
                        //_LOG(("%s opened successfully\n",InfFullName));
                    }
    
                    if(*DrvindexInfFileHandle != NULL ){
                        //_LOG(("%s opened successfully\n",DrvindexInfFullName));
                    }

                    FREE(InfFullName);
                    FREE(DrvindexInfFullName);
                    if(ValidSourcePath) {
                        //
                        // Change the source to the i386 subdirectory.
                        //
                        q = DngSourceRootPath;
                        DngSourceRootPath = MALLOC(strlen(q)+strlen(x86DirName),TRUE);
                        strcpy(DngSourceRootPath,q);
                        strcat(DngSourceRootPath,x86DirName+1);
                        FREE(q);
                    }
                }
            }
        }

        

        if(!ValidSourcePath) {
            FREE(DngSourceRootPath);
            DnClearClientArea();
#if NEC_98
            CursorOnFlag = TRUE;
#endif // NEC_98
            DnDisplayScreen(&DnsBadSource);
            DnWriteStatusText("%s  %s",DntEnterEqualsContinue,DntF3EqualsExit);
#if NEC_98
            CursorOnFlag = FALSE;
#endif // NEC_98
            DnGetString(UserString,NO_SHARE_X,BAD_SHARE_Y,NO_SHARE_W);
        }

    } while(!ValidSourcePath);

    //
    // Make sure DngSourceRootPath does not end with a backslash.
    // and trim the buffer down to size.
    //
    len = strlen(DngSourceRootPath);
    if(DngSourceRootPath[len-1] == '\\') {
        DngSourceRootPath[len-1] = 0;
    }
    if(q = DnDupString(DngSourceRootPath)) {
        FREE(DngSourceRootPath);
        DngSourceRootPath = q;
    }

    //_LOG(("Source root path is %s\n",DngSourceRootPath));
}

VOID
DnRemoveTrailingSlashes(
    PCHAR Path
    )
{
    if (Path != NULL && Path[0] != 0) {
        int Length = strlen(Path);
        while (Path[Length - 1] == '\\' || Path[Length - 1] == '/') {
            Length -= 1;
        }
        Path[Length] = 0;
    }
}

VOID
DnRemoveLastPathElement(
    PCHAR Path
    )
{
    PCHAR LastBackSlash = strrchr(Path, '\\');
    if (LastBackSlash != NULL) {
        *(LastBackSlash + 1) = 0;
    }
}

VOID
DnpReadInf(
    IN FILE *InfFileHandle,
    IN FILE *DrvindexInfFileHandle
    )

/*++

Routine Description:

    Read the INF file.  Does not return if error.

Arguments:

    None.

Return Value:

    None.

--*/

{
    int Status;
    PCHAR p;
    PCHAR pchHeader;
    unsigned LineNumber, DLineNumber;


    DnWriteStatusText(DntReadingInf,CmdLineInf);
    DnClearClientArea();

    LineNumber = 0;
    Status = DnInitINFBuffer (InfFileHandle, &DngInfHandle, &LineNumber);
    if(Status == ENOMEM) {
        DnFatalError(&DnsOutOfMemory);
    } else if(Status) {
        DnFatalError(&DnsBadInf);
    }
    
    DLineNumber = 0;
    Status = DnInitINFBuffer (DrvindexInfFileHandle, &DngDrvindexInfHandle, &DLineNumber);
    if(Status == ENOMEM) {
        DnFatalError(&DnsOutOfMemory);
    } else if(Status) {
        DnFatalError(&DnsBadInf);
    }

    //
    // Determine product type (workstation/server)
    //
    p = DnGetSectionKeyIndex(DngInfHandle,DnfMiscellaneous,"ProductType",0);
    pchHeader = DntWorkstationHeader; // default to workstation
    if(p && atoi(p)) {
        switch(atoi(p)) {
        
        case 4:
            pchHeader = DntPersonalHeader;
            break;
        
        case 1: //server
        case 2: //enterprise
        case 3: //datacenter
        default:
            pchHeader = DntServerHeader;
            DngServer = TRUE;
            break;
        }
    }
    if (p) {
        FREE (p);
    }

    DnPositionCursor(0,0);
    DnWriteString(pchHeader);

    //
    // Get mandatory optional components
    //
    LineNumber = 0;
    while(p = DnGetSectionLineIndex(DngInfHandle,"OptionalSrcDirs",LineNumber++,0)) {

        PCHAR   q;

        if((q = DnDupString(p)) == NULL) {
            DnFatalError(&DnsOutOfMemory);
        }
        RememberOptionalDir(q, OPTDIR_TEMPONLY);

        FREE (p);
    }

    //
    // get Fusion Side By Side Assemblies ("sxs_" here for searching)
    //
    {
        struct      find_t  FindData;
        unsigned InfSectionLineNumber = 0;
        PCHAR InfValue;
        unsigned optdirFlags;
        CHAR SourceDir[DOS_MAX_PATH];
        PCHAR   DupInfValue;
        PCHAR   FreeInfValue;

        while(InfValue = DnGetSectionLineIndex(DngInfHandle, DnfAssemblyDirectories, InfSectionLineNumber++, 0)) {
            //
            // convention introduced specifically for side by side, so that
            // x86 files on ia64 might come from \i386\asms instead of \ia64\asms\i386,
            // depending on what dosnet.inf and syssetup.inf say:
            //   a path that does not start with a slash is appended to \$win_nt$.~ls\processor;
            //   a path that does     start with a slash is appended to \$win_nt$.~ls
            //
            // We honor it in x86-only winnt.exe in case anyone decides to use it
            // for other reasons, to keep parity in this area between winnt and winnt32.exe.
            optdirFlags = OPTDIR_TEMPONLY;
            strcpy(SourceDir, DngSourceRootPath); // includes trailing i386
            FreeInfValue = InfValue;
            if (InfValue[0] == '\\' || InfValue[0] == '/') {

                optdirFlags |= OPTDIR_PLATFORM_INDEP;

                // remove trailing i386
                DnRemoveTrailingSlashes(SourceDir);
                DnRemoveLastPathElement(SourceDir);

                // remove leading slash
                InfValue += 1;
            }

            DnpConcatPaths(SourceDir, InfValue);
            //
            // The asms directory is optional because there might just be asms*.cab.
            //
            if (_dos_findfirst(SourceDir, _A_HIDDEN|_A_SYSTEM|_A_SUBDIR, &FindData) == 0
                && (FindData.attrib & _A_SUBDIR)) {

                if((DupInfValue = DnDupString(InfValue)) == NULL) {
                    DnFatalError(&DnsOutOfMemory);
                }
                RememberOptionalDir(DupInfValue, optdirFlags);

                FREE(FreeInfValue);
            }
        }
    }
}

VOID
DnpCheckEnvironment(
    VOID
    )

/*++

Routine Description:

    Verify that the following are true:

    -   DOS major version 5 or greater

    -   there is a floppy drive at a: that is 1.2 meg or greater

    If any of the above are not true, abort with a fatal error.

Arguments:

    None.

Return Value:

    None.

--*/

{
    UCHAR DeviceParams[256];
    unsigned char _near * pDeviceParams = DeviceParams;

    DnWriteStatusText(DntInspectingComputer);

    DeviceParams[0] = 0;        // get default device params

    _asm {
        //
        // Check if we're on NT.
        // The true version on NT is 5.50.
        //
        mov     ax,3306h
        sub     bx,bx
        int     21h
        cmp     bx,3205h                    // check for v. 5.50
        jne     checkwin

#ifdef TEDM
        cmp     DngAllowNt,1
        je      checkflop
#endif

    bados:
        push    seg    DnsCantRunOnNt
        push    offset DnsCantRunOnNt
        call    DnFatalError                // doesn't return

    checkwin:

        //
        // The /w switch used to be necessary since we could crash Windows
        // checking the CPU stepping on a 386. However since we don't support
        // 386 any more, we never do that check and we can simply detect
        // whether we're on Windows. The /w switch is not necessary.
        //
        mov     ax,1600h
        int     2fh
        test    al,7fh
        jz      checkcpu

        mov     DngWindows,1

        //
        // Now check Win95. Issue int2f func 4a33.
        // If ax comes back as 0 then it's win95.
        //
        push    ds
        push    si
        push    dx
        push    bx
        mov     ax,4a33h
        int     2fh
        pop     bx
        pop     dx
        pop     si
        pop     ds
        cmp     ax,0
        jz      bados

    checkcpu:

        //
        // Check CPU type.  Fail if not greater than 386.
        //

        call    HwGetProcessorType
        cmp     ax,3
        ja      checkflop
        push    seg    DnsRequires486
        push    offset DnsRequires486
        call    DnFatalError                // doesn't return

    checkflop:

        //
        // If this is not a floppyless installation, check for 1.2MB
        // or greater A:.  Get the default device params for drive A:
        // and check the device type field.
        //
#if NEC_98
#else // NEC_98
        cmp     DngFloppyless,1             // floppyless installation?
        je      checkdosver                 // yes, no floppy drive required
        mov     ax,440dh                    // ioctl
        mov     bl,1                        // drive a:
        mov     cx,860h                     // category disk, func get params
        mov     dx,pDeviceParams            // ds is already correct
        int     21h
        jnc     gotdevparams

    flopperr:

        push    seg    DnsRequiresFloppy
        push    offset DnsRequiresFloppy
        call    DnFatalError                // doesn't return

    gotdevparams:

        //
        // Check to make sure that the device is removable and perform
        // checks on the media type
        //

        mov     si,pDeviceParams
        test    [si+2],1                    // bit 0 clear if removable
        jnz     flopperr
#ifdef ALLOW_525
        cmp     [si+1],1                    // media type = 1.2meg floppy?
        jz      checkdosver
#endif
        cmp     [si+1],7                    // media type = 1.4meg floppy
        jb      flopperr                    // or greater?

    checkdosver:
#endif // NEC_98

        //
        // Check DOS version >= 5.0
        //
        mov     ax,3000h                    // function 30h -- get DOS version
        int     21h
        cmp     al,5
        jae     checkdone                   // >= 5.0

        //
        // version < 5
        //
        push    seg    DnsBadDosVersion
        push    offset DnsBadDosVersion
        call    DnFatalError

    checkdone:

    }
}

VOID
DnpCheckMemory(
    VOID
    )

/*++

Routine Description:

    Verify that enough memory is installed in the machine.

Arguments:

    None.

Return Value:

    None.  Does not return in there's not enough memory.

--*/

{
    USHORT MemoryK;
    ULONG TotalMemory,RequiredMemory;
    PCHAR RequiredMemoryStr;

    //
    // Now that servers require so much memory (64Mb), just remove this check.
    // We'll catch him in textmode.
    // -matth
    //
    return;

    DnWriteStatusText(DntInspectingComputer);

    //
    // I cannot figure out a reliable way to determine the amount of
    // memory in the machine.  Int 15 func 88 is likely to be hooked by
    // himem.sys or some other memory manager to return 0.  DOS maintains
    // the original amount of extended memory but to get to this value
    // you have to execute the sysvars undocumented int21 ah=52 call, and
    // even then what about versions previous to dos 4?  Calling himem to
    // ask for the total amount of xms memory does not give you the total
    // amount of extended memory, just the amount of xms memory.
    // So we'll short-circuit the memory check code by always deciding that
    // there's 50MB of extended memory.  This should always be big enough,
    // and this way the rest of the code stays intact, ready to work if
    // we figure out a way to make the memory determination.  Just replace
    // the following line with the check, and make sure MemoryK is set to
    // the amount of extended memory in K.
    //
    // Update: one might be able to get the amount of extended memory by
    // looking in CMOS.  See the code below.
    // The only problem with this is that it cannot detect more than 63MB
    // of extended memory. This should be good for now, since this is
    // enough even for NT server.
    //
    _asm {

    //
    // This code access to I/O ports 70H and 71H.
    // But these port are different feature on NEC98.
    // The 70H port is Character Display controller's port.
    // So, if this code running(out 70h, 18h) on NEC98, display
    // setting will be broken and garbage characters displayed.
    //
#if NEC_98
    push    ax
    push    es
    mov     ax, 40h
        mov     es, ax
        xor     ax, ax
        mov     al, es:[1]    // 1M - 16M memories(per 128K)
        shr     ax, 3         // convert MB
        add     ax, es:[194h] // Over 16M memories(per 1M)
        mov     MemoryK,ax
        pop     es
        pop     ax
#else // NEC_98
        push    ax
        cli
        mov     al,     18h // get extended memory high
        out     70h,    al
        jmp     short   $+2
        in      al,     71H
        shl     ax,     08H
        mov     al,     17H // get extended memory low
        out     70H,    al
        jmp     short   $+2
        in      al,     71H
        mov     MemoryK,ax
        sti
        pop     ax
#endif // NEC_98
    }

    //
    // Account for conventional memory.  Simplistic, but good enough.
    //
#if NEC_98
    MemoryK *= 1024;
    MemoryK += 640;
#else // NEC_98
    MemoryK += 1024;
#endif // NEC_98

    TotalMemory = (ULONG)MemoryK * 1024L;
    RequiredMemoryStr = DnGetSectionKeyIndex( DngInfHandle,
                                              DnfMiscellaneous,
                                              DnkMinimumMemory,
                                              0
                                            );

    //
    // If the required memory is not specified in the inf, force an error
    // to get someone's attention so we can fix dosnet.inf.
    //
    RequiredMemory = RequiredMemoryStr ? (ULONG)atol(RequiredMemoryStr) : 0xffffffff;

    if (RequiredMemoryStr) {
        FREE (RequiredMemoryStr);
    }

    if(TotalMemory < RequiredMemory) {

        CHAR Decimal[10];
        ULONG r;
        CHAR Line1[100],Line2[100];

        r = ((RequiredMemory % (1024L*1024L)) * 100L) / (1024L*1024L);
        if(r) {
            sprintf(Decimal,".%lu",r);
        } else {
            Decimal[0] = 0;
        }
        snprintf(Line1,sizeof(Line1),DnsNotEnoughMemory.Strings[NOMEM_LINE1],RequiredMemory/(1024L*1024L),Decimal);
        DnsNotEnoughMemory.Strings[NOMEM_LINE1] = Line1;

        r = ((TotalMemory % (1024L*1024L)) * 100L) / (1024L*1024L);
        if(r) {
            sprintf(Decimal,".%lu",r);
        } else {
            Decimal[0] = 0;
        }
        snprintf(Line2,sizeof(Line2),DnsNotEnoughMemory.Strings[NOMEM_LINE2],TotalMemory/(1024L*1024L),Decimal);
        DnsNotEnoughMemory.Strings[NOMEM_LINE2] = Line2;

        DnFatalError(&DnsNotEnoughMemory);
    }
}


VOID
DnpCheckSmartdrv(
    VOID
    )

/*++

Routine Description:

    Verify that SMARTDRV is installed in the machine.

Arguments:

    None.

Return Value:

    None.  If SMARTDRV is not installed we recommend the user to install it.
    They have a chance to quit setup or to go on without SMARTDRV.

--*/

{
    ULONG ValidKey[3];
    ULONG c;
    USHORT sinst = 0;

    if (!DngUnattended) {
        _asm {
            push ax
            push bx
            push cx
            push dx
            push di
            push si
            push bp
            mov ax, 4a10h
            xor bx, bx
            mov cx, 0ebabh
            int 2fh
            cmp ax, 0babeh
            jne final
            pop bp
            mov sinst, 1
            push bp
        final:
            pop bp
            pop si
            pop di
            pop dx
            pop cx
            pop bx
            pop ax
        }
        if (!sinst) {
            ValidKey[0] = ASCI_CR;
            ValidKey[1] = DN_KEY_F3;
            ValidKey[2] = 0;

            DnClearClientArea();
            DnDisplayScreen(&DnsNoSmartdrv);
            DnWriteStatusText("%s  %s",DntEnterEqualsContinue,DntF3EqualsExit);

            while(1) {
                c = DnGetValidKey(ValidKey);
                if(c == ASCI_CR) {
                    break;
                }
                if(c == DN_KEY_F3) {
                    DnExitDialog();
                }
            }
            DnClearClientArea();
        }
    }
}


void
_far
DnInt24(
    unsigned deverror,
    unsigned errcode,
    unsigned _far *devhdr
    )

/*++

Routine Description:

    Int24 handler.  We do not perform any special actions on a hard error;
    rather we just return FAIL so the caller of the failing api will get
    back an error code and take appropriate action itself.

    This function should never be invoked directly.

Arguments:

    deverror - supplies the device error code.

    errcode - the DI register passed by MS-DOS to int 24 handlers.

    devhdr - supplies pointer to the device header for the device on which
        the hard error occured.

Return Value:

    None.

--*/


{
    _hardresume(_HARDERR_FAIL);
}


VOID
DnpDetermineSwapDrive(
    VOID
    )

/*++

Routine Description:

    Determine the swap drive. We need to be able to write on that drive and
    we need at least 500K free disk space.

Arguments:

    None.

Return Value:

    None.  Sets the global variable DngSwapDriveLetter.

--*/

{
    ULONG CheckingDrive;
    CHAR  SystemPartitionDriveLetter, TheDrive, DriveLetter;

    DngSwapDriveLetter = '?';

#if NEC_98
    SystemPartitionDriveLetter = 'A';
#else
    SystemPartitionDriveLetter = 'C';
#endif

    TheDrive = 0;
    for( CheckingDrive = SystemPartitionDriveLetter - 'A'; CheckingDrive < ('Z' - 'A'); CheckingDrive++ ) {

        DriveLetter = (CHAR)('A' + CheckingDrive);
        if (DnpIsValidSwapDrive (DriveLetter, 1L * 1024 * 1024)) {
            TheDrive = (CHAR)('A' + CheckingDrive);
            break;
        }
    }

    if( TheDrive == 0 ) {
        //
        //  If there is no valid drive for the swap file, put an error message
        //
        DnFatalError (&DnsNoSwapDrive);
    } else {
        DngSwapDriveLetter = TheDrive;
    }
}


BOOLEAN
DnpIsValidSwapDrive(
    IN  CHAR      Drive,
    IN  ULONG     SpaceRequired
    )

/*++

Routine Description:

    Determine if a drive is valid as a swap drive.
    To be valid a drive must be extant, non-removable, local, and have
    enough free space on it (as much as SpaceNeeded specifies).

Arguments:

    Drive - drive letter of drive to check.

Return Value:

    TRUE if Drive is valid as a swap drive.  FALSE otherwise.

--*/

{
    unsigned d = (unsigned)toupper(Drive) - (unsigned)'A' + 1;
    struct diskfree_t DiskSpace;
    ULONG SpaceAvailable;


    if( DnIsDriveValid(d)
    && !DnIsDriveRemote(d,NULL)
    && !DnIsDriveRemovable(d))
    {
        //
        // Check free space on the drive.
        //

        if(!_dos_getdiskfree(d,&DiskSpace)) {

            SpaceAvailable = (ULONG)DiskSpace.avail_clusters
                  * (ULONG)DiskSpace.sectors_per_cluster
                  * (ULONG)DiskSpace.bytes_per_sector;

            return( (BOOLEAN)(SpaceAvailable >= SpaceRequired) );

        }
    }

    return(FALSE);
}


VOID
DnpDetermineLocalSourceDrive(
    VOID
    )

/*++

Routine Description:

    Determine the local source drive, ie, the drive that will contain the
    local copy of the windows nt setup source tree.  The local source could
    have been passed on the command line, in which case we will validate it.
    If there was no drive specified, examine each drive in the system looking
    for a local, fixed drive with enough free space on it (as specified in
    the inf file).

Arguments:

    None.

Return Value:

    None.  Sets the global variable DngTargetDriveLetter.

--*/

{
    ULONG RequiredSpace;
    ULONG CheckWhichDrives = 0, CheckingDrive;
    CHAR    SystemPartitionDriveLetter, TheDrive, DriveLetter;

    DnRemoveLocalSourceTrees();

    DnRemovePagingFiles();

    //
    //  Get the space requirements for the main retail files
    //
    DnDetermineSpaceRequirements( SpaceRequirements,
                                  sizeof( SpaceRequirements ) / sizeof( SPACE_REQUIREMENT ) );

    //
    //  Determine the space requirements for the optional directories
    //  Note that DnpIterateOptionalDirs() will initialize the global variables
    //  TotalOptionalFileCount and TotalOptionalFileCount in dncopy.c with the
    //  total number of files in optional directory, and the total number of
    //  optional directories, respectively.
    //
    DngTargetDriveLetter = '?';
    DnpIterateOptionalDirs(CPY_VALIDATION_PASS,
                           0,
                           SpaceRequirements,
                           sizeof( SpaceRequirements ) / sizeof( SPACE_REQUIREMENT ));

    DnAdjustSpaceRequirements( SpaceRequirements,
                               sizeof( SpaceRequirements ) / sizeof( SPACE_REQUIREMENT ));

    //
    // Which drives do we need to examine?
    //
    if( DngFloppyless ) {
        //
        // Need to determine the system partition.  It is usually C:
        // but if C: is compressed we need to find the host drive.
        //
        unsigned HostDrive;
        if(!DngAllowNt && DnIsDriveCompressedVolume(3,&HostDrive)) {
            CheckWhichDrives |= (0x1 << (HostDrive - 1));
            SystemPartitionDriveLetter = (CHAR)('A' + (HostDrive - 1));
        } else {
            CheckWhichDrives |= (0x1 << 2);
#if NEC_98
            SystemPartitionDriveLetter = 'A';
#else
            SystemPartitionDriveLetter = 'C';
#endif
        }
    }

    if( TargetGiven ) {
        if( DngAllowNt ) {
            DngTargetDriveLetter = (UCHAR) toupper(*CmdLineTarget);
            return;
        }
        CheckWhichDrives |= (0x1 << ((unsigned)toupper(*CmdLineTarget) - 'A'));
    } else {
        CheckWhichDrives = 0xFFFFFFFF;
    }

    TheDrive = 0;
    for( CheckingDrive = 0; CheckingDrive < ('Z' - 'A'); CheckingDrive++ ) {

        //
        // Do we even need to look at this drive?
        //
        if( !(CheckWhichDrives & (0x1 << CheckingDrive))) {
            continue;
        }

        DriveLetter = (CHAR)('A' + CheckingDrive);

        if( DnpIsValidLocalSource( DriveLetter,
                                   TRUE,    // Check for LocalSource
                                   (BOOLEAN)(DriveLetter == SystemPartitionDriveLetter) ) ) {

            if( TargetGiven ) {
                if( DriveLetter == (CHAR)toupper(*CmdLineTarget) ) {
                    TheDrive = DriveLetter;
                }
            } else {
                if( !TheDrive ) {
                    //
                    // Take the first catch.
                    //
                    TheDrive = DriveLetter;
                }
            }

            if( TheDrive ) {
                //
                // We found a suitable drive.  But are we really done?
                //
                if( (DngFloppyless) &&
                    (DriveLetter < SystemPartitionDriveLetter) ) {
                    //
                    // We will be writing some boot files and we haven't checked
                    // the system partition yet.  Cut to the chase.
                    //
                   CheckWhichDrives = (0x1 << (SystemPartitionDriveLetter - 'A'));
                } else {
                    break;
                }
            }
        } else {
            //
            // We need to special-handle failures on the system partition.
            // See if he's capable of at least taking the system boot
            // files.
            //
            if( (DriveLetter == SystemPartitionDriveLetter) &&
                (DngFloppyless) ) {

                if( !DnpIsValidLocalSource( DriveLetter,
                                            FALSE,
                                            TRUE )) {
                    //
                    // Consider ourselves slumped over.
                    //
                    TheDrive = 0;
                    break;
                }
            }
        }
    }

    if( TheDrive == 0 ) {
        //
        //  If there is no valid drive for the local source, put an error
        //  message with the minimum space required for C:
        //
        if( TargetGiven ) {
            RequiredSpace = DnGetMinimumRequiredSpace(*CmdLineTarget);
        } else {
#if NEC_98
             RequiredSpace = DnGetMinimumRequiredSpace('A');
#else
             RequiredSpace = DnGetMinimumRequiredSpace('C');
#endif
        }
        DnFatalError(
            &DnsNoLocalSrcDrives,
            (unsigned)(RequiredSpace/(1024L*1024L)),
            RequiredSpace
            );
    } else {
        //
        // Use the first drive on the list.
        //
        DngTargetDriveLetter = TheDrive;
        return;
    }
}


BOOLEAN
DnpIsValidLocalSource(
    IN  CHAR      Drive,
    IN  BOOLEAN   CheckLocalSource,
    IN  BOOLEAN   CheckBootFiles
    )

/*++

Routine Description:

    Determine if a drive is valid as a local source.
    To be valid a drive must be extant, non-removable, local, and have
    enough free space on it.

Arguments:

    Drive - drive letter of drive to check.

Return Value:

    TRUE if Drive is valid as a local source.  FALSE otherwise.

--*/

{
    unsigned d = (unsigned)toupper(Drive) - (unsigned)'A' + 1;
    struct diskfree_t DiskSpace;
    ULONG SpaceAvailable, SpaceRequired, ClusterSize;
    unsigned DontCare, i;


    if( DnIsDriveValid(d)
    && !DnIsDriveRemote(d,NULL)
    && !DnIsDriveRemovable(d)
    && !DnIsDriveCompressedVolume(d,&DontCare))
    {
        //
        // Check free space on the drive.
        //

        if(!_dos_getdiskfree(d,&DiskSpace)) {

            SpaceAvailable = (ULONG)DiskSpace.avail_clusters
                  * (ULONG)DiskSpace.sectors_per_cluster
                  * (ULONG)DiskSpace.bytes_per_sector;

            ClusterSize = (ULONG)DiskSpace.sectors_per_cluster *
                          (ULONG)DiskSpace.bytes_per_sector;

            SpaceRequired = 0;
            if( CheckLocalSource ) {
                for( i = 0;
                     i < sizeof( SpaceRequirements ) / sizeof( SPACE_REQUIREMENT );
                     i++ ) {
                    if( SpaceRequirements[i].ClusterSize == (unsigned)ClusterSize ) {
#if NEC_98
                        SpaceRequired += (SpaceRequirements[i].Clusters * ClusterSize + 3L * FLOPPY_SIZE);
#else
                        SpaceRequired += (SpaceRequirements[i].Clusters * ClusterSize);
#endif
                        break;
                    }
                }
            }

            if( CheckBootFiles ) {
                CHAR    TmpBuffer[32];
                PCHAR   p;

                sprintf( TmpBuffer, "TempDirSpace%uK", ClusterSize );
                if( p = DnGetSectionKeyIndex( DngInfHandle,
                                                 DnfSpaceRequirements,
                                                 TmpBuffer,
                                                 1 ) ) {
                    SpaceRequired += (ULONG)atol(p);

                    FREE (p);
                } else {
                    // We missed.  Fudge...
                    ULONG FudgeSpace = 7;
                    FudgeSpace *= 1024;
                    FudgeSpace *= 1024;
                    SpaceRequired += FudgeSpace;
                }
            }

            return( (BOOLEAN)(SpaceAvailable >= SpaceRequired) );

        }
    }

    return(FALSE);
}

#if 0

BOOLEAN
DnpConstructLocalSourceList(
    OUT PCHAR DriveList
    )

/*++

Routine Description:

    Construct a list of drives that are valid for use as a local source.
    To be valid a drive must be extant, non-removable, local, and have
    enough free space on it.

    The 'list' is a string with a character for each valid drive, terminated
    by a nul character, ie,

        CDE0

Arguments:

    DriveList - receives the string in the above format.

Return Value:

    FALSE if no valid drives were found.  TRUE if at least one was.

--*/

{
    PCHAR p = DriveList;
    BOOLEAN b = FALSE;
    CHAR Drive;

#if NEC_98
    for(Drive='A'; Drive<='Z'; Drive++) {
#else // NEC_98
    for(Drive='C'; Drive<='Z'; Drive++) {
#endif // NEC_98
        if(DnpIsValidLocalSource(Drive)) {
            *p++ = Drive;
            b = TRUE;
        }
    }
    *p = 0;
    return(b);
}
#endif


#ifdef LOGGING
// FILE *_LogFile;
BOOLEAN LogEnabled = FALSE;

VOID
StartLog(
    VOID
    )
{
      LogEnabled = TRUE;
}

#if 0
VOID
EndLog(
    VOID
    )
{
    if(_LogFile) {
        fclose(_LogFile);
        _LogFile = NULL;
    }
}
#endif

VOID
__LOG(
    IN PCHAR FormatString,
    ...
    )
{
    FILE *LogFile;
    va_list arglist;

    if(LogEnabled) {
        LogFile = fopen("c:\\$winnt.log","at");
        va_start(arglist,FormatString);
        vfprintf(LogFile,FormatString,arglist);
        va_end(arglist);
        fclose(LogFile);
    }
}
#endif // def LOGGING

ULONG
DnGetMinimumRequiredSpace(
   IN CHAR DriveLetter
   )
/*++

Routine Description:

    Determine the minimum required free space for the local source, on a
    particular drive.

Arguments:

    DriveLetter - Indicates the letter of a particular drive.

Return Value:

    Returns the minimum required space on the specified drive.

--*/

{
    struct diskfree_t DiskFree;
    unsigned          ClusterSize;
    unsigned          i;

    _dos_getdiskfree(toupper(DriveLetter)-'A'+1,&DiskFree);
    ClusterSize = DiskFree.sectors_per_cluster * DiskFree.bytes_per_sector;
    for( i = 0;
         i < sizeof( SpaceRequirements ) / sizeof( SPACE_REQUIREMENT );
         i++ ) {
         if( ClusterSize == SpaceRequirements[i].ClusterSize ) {
            return( ClusterSize * SpaceRequirements[i].Clusters );
         }
    }
    //
    //  Return the size assuming 16k cluster
    //
    return ( SpaceRequirements[5].ClusterSize * SpaceRequirements[5].Clusters );
}

#if NEC_98
VOID
DummyRoutine(
    VOID
    )
/*++

This Founction is Dummy Routine.(CTRL + C Signal Hook Routine)

--*/
{
    //
    // It's Dummy Statement
    //
    while(TRUE){
        break;
    }
}

VOID
SearchFirstFDD(VOID)
{
    UCHAR   index;
    UCHAR   ReadPoint = 0;
    UCHAR   ReadCount = 1;


    //
    // Setting Read Data position.
    //
    if(SupportDos) {
        ReadPoint = 27;
        ReadCount = 2;
    }

    //
    // Search First FDD.
    //
    FirstFD = 0;
    for(index=0; index < 26; index++) {
        if(LPTable[ReadPoint+index*ReadCount] == 0x90){
            FirstFD = index + 1;
            break;
        }
    }
    if(FirstFD == 0) { DnFatalError(&DnsRequiresFloppy); }
    return;
}

VOID
CheckTargetDrive(VOID)
{
    UCHAR   Pattern[127];
    UCHAR   TempBuf[1000];
    UCHAR   Current_Drv[3];
    UCHAR   chDeviceName[127];
    UCHAR   TargetPass[127];
    CHAR    Target_Drv[] = "?:\0";
    unsigned line;
    ULONG   ValidKey[2];
    ULONG   c;
    PCHAR   FileName;
    FILE   *fileHandle;
    BOOLEAN ExistNt = TRUE;            // For Back up Directry Flag

    ValidKey[0] = DN_KEY_F3;
    ValidKey[1] = 0;


    //
    // C Drive(Current drive number)
    //
    sprintf(Current_Drv,"%c\0",DngTargetDriveLetter);

    sprintf(TempBuf,DnsNtBootSect.Strings[2]    ,Current_Drv);
    strcpy(DnsNtBootSect.Strings[2]    ,TempBuf);
    Target_Drv[0] = DngTargetDriveLetter;

    if(BootDiskInfo[0].DiskSector == (USHORT)256) {
        DnClearClientArea();
        DnDisplayScreen(&FormatError);
        DnWriteStatusText("%s",DntF3EqualsExit);

        while(1) {
            c = DnGetValidKey(ValidKey);

            if(c == DN_KEY_F3) {
                FREE(BootDiskInfo);
                DnExitDialog();
            }
        }
    }

    if(DngFloppyless) {
        //
        // Clear $WIN_NT$.~BT
        //
        chDeviceName[0] = (UCHAR)DngTargetDriveLetter;
        chDeviceName[1] = (UCHAR)(':');
        strcpy(chDeviceName+2,FLOPPYLESS_BOOT_ROOT);

        if(access(chDeviceName,00) == 0) {

            strcpy(Pattern,chDeviceName);
            DnDelnode(Pattern);
            remove(Pattern);

        }

        //
        // Clear $WIN_NT$.~BU
        //
        memset(chDeviceName,0,sizeof(chDeviceName));

        chDeviceName[0] = (UCHAR)DngTargetDriveLetter;
        chDeviceName[1] = (UCHAR)(':');
        strcpy(chDeviceName+2,"\\$WIN_NT$.~BU");

        if(access(chDeviceName,00) == 0) {
            //
            // copy : \$WIN_NT$.~BU -> root directry
            //
            DnCopyFilesInSectionForFDless(DnfBackupFiles_PC98,chDeviceName,Target_Drv);
            strcpy(Pattern,chDeviceName);
            DnDelnode(Pattern);
            remove(Pattern);
        }

        //
        // Check Root Directry Files.
        //
        line = 0;

        while(FileName = DnGetSectionLineIndex(DngInfHandle,DnfBackupFiles_PC98,line++,0)) {

            memset(chDeviceName,0,sizeof(chDeviceName));

            chDeviceName[0] = (UCHAR)DngTargetDriveLetter;
            chDeviceName[1] = (UCHAR)(':');
            chDeviceName[2] = (UCHAR)('\\');
            strcpy(chDeviceName+3,FileName);

            _dos_setfileattr(chDeviceName,_A_NORMAL);

            if(fileHandle = fopen(chDeviceName,"r")) {

                fclose(fileHandle);

            } else {

                ExistNt = FALSE;

                FREE (FileName);

                break;

            }
            FREE (FileName);
        }

        //
        // Create $WIN_NT$.~BU
        //

        if(ExistNt) {

            memset(chDeviceName,0,sizeof(chDeviceName));
            sprintf(chDeviceName,"%c:\\$WIN_NT$.~BU",(UCHAR)DngTargetDriveLetter);

            mkdir(chDeviceName);

            //
            // copy : root directry -> \$WIN_NT$.~BU
            //

            DnCopyFilesInSectionForFDless(DnfBackupFiles_PC98,Target_Drv,chDeviceName);

            //
            // Set files Attribute.
            //

            line = 0;

            while(FileName = DnGetSectionLineIndex(DngInfHandle,DnfBackupFiles_PC98,line++,0)) {

                memset(TargetPass,0,sizeof(TargetPass));
                sprintf(TargetPass,"%c:\\$WIN_NT$.~BU\\",(UCHAR)DngTargetDriveLetter);

                strcpy(TargetPass+16,FileName);

                _dos_setfileattr(TargetPass,
                                 _A_ARCH | _A_HIDDEN | _A_RDONLY | _A_SYSTEM
                                );

                FREE (FileName);
            }

        }
    }
}

VOID
GetLPTable(
    IN  PCHAR pLPTable
    )
/*

    Get LPTable in the Dos system.

*/
{


    _asm{
        push ax
        push bx
        push cx
        push dx
        push ds
        mov  cx,13h
        push si
        lds  si,pLPTable
        mov  dx,si
        pop  si
        int  0dch
        pop  ds
        pop  dx
        pop  cx
        pop  bx
        pop  ax
    }
}

VOID
ClearBootFlag(
    VOID
    )
{
    USHORT  SectorSize;
    PSHORT  pReadBuffer;
    UCHAR   CNT;


    (PUCHAR)DiskDAUA = MALLOC(sizeof(CONNECTDAUA)*12,TRUE);

    for(CNT = 0; CNT < 12; CNT++) {
        DiskDAUA[CNT].DA_UA = (UCHAR)0x00;
    }

    //
    // Get boot device number.
    //
    GetDaUa();

    for(CNT=0;DiskDAUA[CNT].DA_UA != 0;CNT++) {

        //
        // Get Device sector size.
        //
        SectorSize = GetSectorValue(DiskDAUA[CNT].DA_UA);

        if(SectorSize == 0) {
            continue;
        }

        pReadBuffer = (PSHORT)MALLOC(SectorSize*2,TRUE);

        DiskSectorReadWrite(SectorSize,
                            DiskDAUA[CNT].DA_UA,
                            TRUE,
                            pReadBuffer
                            );

        pReadBuffer[(SectorSize-6)/2] = 0x0000;

        DiskSectorReadWrite(SectorSize,
                            DiskDAUA[CNT].DA_UA,
                            FALSE,
                            pReadBuffer
                            );

        FREE(pReadBuffer);
    }
    FREE(DiskDAUA);
}

VOID
BootPartitionData(
    VOID
    )
/*

    Setting Boot Drive Infomation for BootDiskInfo.

*/
{
    UCHAR   ActivePartition;
    PSHORT  ReadBuffers;
    UCHAR   SystemID;
    UCHAR   BootPartitionNo,CheckDosNo;
    UCHAR   CNT;
    UCHAR   ReadPoint = 0;
    UCHAR   ReadCount = 1;
    UCHAR   EndRoop   = 16;


    //
    // Setting Read Data position.
    //
    if(SupportDos) {
        ReadPoint = 27;
        ReadCount = 2;
        EndRoop   = 52;
    }


    //
    // Set Boot Device DA_UA Data value.
    //
    BootDiskInfo[0].DA_UA = LPTable[ReadPoint+(toupper(DngTargetDriveLetter) - 0x41)*ReadCount];

    //
    // Set Boot Device Sector Size.
    //
    BootDiskInfo[0].DiskSector = GetSectorValue(BootDiskInfo[0].DA_UA);

    //
    // Set Boot Drive Disk Partition Position.
    //
    for(CNT=ActivePartition=0;(LPTable[ReadPoint+CNT] != 0) && (CNT < EndRoop); CNT+=ReadCount) {
        if(CNT > (UCHAR)(toupper(DngTargetDriveLetter)-0x41)*ReadCount)
        { break; }

        if((UCHAR)LPTable[ReadPoint+CNT] == BootDiskInfo[0].DA_UA) {
            ActivePartition++;
        }
    }

    ReadBuffers = (PSHORT)MALLOC(BootDiskInfo[0].DiskSector*2,TRUE);

    DiskSectorReadWrite(BootDiskInfo[0].DiskSector,
                        BootDiskInfo[0].DA_UA,
                        TRUE,
                        ReadBuffers
                        );

    BootPartitionNo = CheckDosNo =0;
    for(CNT=0; (CNT < 16) && (ActivePartition > CheckDosNo); CNT++) {

        SystemID = *((PCHAR)ReadBuffers+(BootDiskInfo[0].DiskSector+1+32*CNT));

        if( (SystemID == 0x81) || // FAT12
            (SystemID == 0x91) || // FAT16
            (SystemID == 0xe1) || // FAT32
           ((SystemID == 0xa1) && // Large partition
             SupportDos))
        {
            CheckDosNo++;
        }
        BootPartitionNo++;
    }

    TargetDA_UA = BootDiskInfo[0].DA_UA;
    Cylinders =(USHORT)*(ReadBuffers+((BootDiskInfo[0].DiskSector+10+32*(CNT-1))/2));

    FREE(ReadBuffers);

    BootDiskInfo[0].PartitionPosition = (UCHAR)(BootPartitionNo - 1);
}

VOID
SetAutoReboot(
    VOID
    )
/*++

Set Auto Reboot Flag.

--*/
{
    PSHORT  pReadBuffer;

    pReadBuffer = (PSHORT)MALLOC(BootDiskInfo[0].DiskSector*2,TRUE);

    DiskSectorReadWrite(BootDiskInfo[0].DiskSector,
                        BootDiskInfo[0].DA_UA,
                        TRUE,
                        pReadBuffer
                       );

    (UCHAR)*((PCHAR)pReadBuffer+BootDiskInfo[0].DiskSector-6) = 0x80;

    *((PCHAR)pReadBuffer+BootDiskInfo[0].DiskSector-5) = BootDiskInfo[0].PartitionPosition;

    *((PCHAR)pReadBuffer+BootDiskInfo[0].DiskSector+32 *
                       BootDiskInfo[0].PartitionPosition) |= 0x80;

    DiskSectorReadWrite(BootDiskInfo[0].DiskSector,
                        BootDiskInfo[0].DA_UA,
                        FALSE,
                        pReadBuffer
                       );

    FREE(pReadBuffer);
}

BOOLEAN
CheckBootDosVersion(
    IN UCHAR SupportDosVersion
    )
/*

    Get Dos Version.

*/
{
    union REGS inregs,outregs;
    int     AXValue;


    inregs.x.ax = (unsigned int)0;
    inregs.x.bx = (unsigned int)0;
    inregs.x.cx = (unsigned int)0;
    inregs.x.dx = (unsigned int)0;

    outregs.x.ax = (unsigned int)0;
    outregs.x.bx = (unsigned int)0;
    outregs.x.cx = (unsigned int)0;
    outregs.x.dx = (unsigned int)0;

    inregs.h.ah = (UCHAR)0x30;
    AXValue = 0;
    AXValue = intdos(&inregs,&outregs);
    AXValue &= 0x00ff;

    if(SupportDosVersion > (UCHAR)AXValue) {
        return(FALSE);
    } else {
        return(TRUE);
    }
}

USHORT
GetSectorValue(
    IN UCHAR CheckDA_UA
    )
/*++

Get Sector Value.

--*/
{
    USHORT PhysicalSectorSize;
    UCHAR  ErrFlg;


    _asm{
        push ax
        push bx
        push cx
        push dx
        mov  ah,84h
        mov  al,CheckDA_UA
        int  1bh
        mov  PhysicalSectorSize,bx
        cmp  ah,00h
        je   break0
        and  ax,0f000h
        cmp  ax,0000h
        je   break0
        mov  ErrFlg,01h
        jmp  break1
    break0:
        mov  ErrFlg,00h
    break1:
        pop  dx
        pop  cx
        pop  bx
        pop  ax
    }

    if(ErrFlg == 0) {
        return(PhysicalSectorSize);
    } else {
        return((USHORT)0);
    }
}

BOOLEAN
DiskSectorReadWrite(
    IN  USHORT  HDSector,
    IN  UCHAR   ReadWriteDA_UA,
    IN  BOOLEAN ReadFlag,
    IN  PSHORT  OrigReadBuffer
    )
{
    UCHAR   ahreg = 0x06;
    UCHAR   ErrorFlag;
    USHORT  ReadSectorSize;
    BOOLEAN HDStatus = TRUE;

    UCHAR   far *pTmp;
    ULONG   pAddr;
    PSHORT  ReadBuffer, p;

    ReadSectorSize = HDSector * 2;

    //
    // INT 1BH does not allow the buffer that beyond 64KB boundary.
    // So we must prepare particular buffer for INT 1BH. Once allocate
    // double size buffer and use half of them that does not on
    // boundary.
    //
    p = MALLOC(ReadSectorSize * 2, TRUE);
    pTmp = (UCHAR far *)p;
    pAddr = (FP_SEG(pTmp)<<4 + FP_OFF(pTmp) & 0xffff);

    //
    // Check half part of buffer is on 64KB boundary.
    //
    if (pAddr > ((pAddr + ReadSectorSize) & 0xffff)){
	ReadBuffer = p + ReadSectorSize; // Use last half part.
    } else {
	ReadBuffer = p; // Use first half part.
    }

    if(!ReadFlag) {
        ahreg = 0x05;
	memcpy(ReadBuffer, OrigReadBuffer, ReadSectorSize);
    }

    _asm{
        push ax
        push bx
        push cx
        push dx
        push es
        push di

        ;
        ; If we're running under Chicago, and we're going to be
        ; writing, then we have to lock the volume before attempting
        ; absolute disk I/O
        ;
        cmp     ReadFlag,1              ; are we reading?
        jae     locked                  ; if so, skip locking step

        ;
        ; Make sure were running under Chicago.
        ;
        mov     ah,30h
        int     21h
        cmp     al,7h
        jb      locked          ; not Chicago

        ;
        ; We're sure we're under Chicago, so issue new
        ; Lock Logical Volume IOCTL
        ;
        mov     ax,440dh
        mov     bh,1            ; level 1 lock
        mov     bl,ReadWriteDA_UA ; fetch drive to lock
        mov     cx,084bh        ; Lock Logical Volume for disk category
        mov     dx,1            ; set permission to allow reads and writes
        int     21h
        ;jc      locked          ; ignore failure - any errors are caught below
        ;mov     word ptr [bp-12],1 ; we successfully locked, so we must unlock

    locked:
        mov  bx,ReadSectorSize
        mov  cx,0000h
        mov  dx,0000h
        mov  ax,0000h
        mov  ah,ahreg
        mov  al,ReadWriteDA_UA
        push bp
        push es
        push ds
        pop  es
        les  di,ReadBuffer
        mov  bp,di
        int  1bh
        pop  es
        pop  bp
	jnc  warp0             	;No error
        cmp  ah,00h
        je   warp0
        add  ax,0f000h
        cmp  ax,0000h
        je   warp0
        mov  ErrorFlag,01h
        jmp  warp1
    warp0:
        mov  ErrorFlag,00h
    warp1:
        ;unlock?
        cmp     ReadFlag,1         ; do we need to unlock?
        jae     done               ; if not, then done.
        mov     ax,440dh
        mov     bl,ReadWriteDA_UA  ; fetch drive to lock
        ;mov     bh,0
        ;inc     bl              ; (this IOCTL uses 1-based drive numbers)
        mov     cx,086bh        ; Unlock Logical Volume for disk category
        mov     dx,0
        int     21h             ; ignore error (hope it never happens)
    done:
        pop  di
        pop  es
        pop  dx
        pop  cx
        pop  bx
        pop  ax
    }

    if(ReadFlag) {
	memcpy(OrigReadBuffer, ReadBuffer, ReadSectorSize);
    }
    FREE(p);

    if(ErrorFlag != 0) {
        HDStatus = FALSE;
    }
    return(HDStatus);
}

VOID
GetDaUa(VOID)
{
    UCHAR   count, i = 0;
    UCHAR   far *ConnectEquip;
    UCHAR   ConnectDevice;

    //
    // IDE/SASI Disk Check Routine
    //

    MAKE_FP(ConnectEquip,(USHORT)0x55d);
    ConnectDevice = *ConnectEquip;

    for(count=0;count < 4;count++) {
        if(ConnectDevice & (1 << count)) {
            DiskDAUA[i].DA_UA = (UCHAR)(0x80 + count);
            i++;
        }
    }

    //
    // SCSI Disk Check Routine
    //

    MAKE_FP(ConnectEquip,(USHORT)0x482);
    ConnectDevice = *ConnectEquip;

    for(count=0;count < 7;count++) {
        if(ConnectDevice & (1 << count)) {
            DiskDAUA[i].DA_UA = (UCHAR)(0xa0 + count);
            i++;
        }
    }
}
#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\c6\inc\bios.h ===
/***
*bios.h - declarations for bios interface functions and supporting definitions
*
*	Copyright (c) 1987-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file declares the constants, structures, and functions
*	used for accessing and using various BIOS interfaces.
*
****/

#ifndef _MT

/* manifest constants for BIOS serial communications (RS-232) support */

/* serial port services */

#define _COM_INIT	0	/* init serial port */
#define _COM_SEND	1	/* send character */
#define _COM_RECEIVE	2	/* receive character */
#define _COM_STATUS	3	/* get serial port status */

/* serial port initializers.  One and only one constant from each of the
 * following four groups - character size, stop bit, parity, and baud rate -
 * must be specified in the initialization byte.
 */

/* character size initializers */

#define _COM_CHR7	2	/* 7 bits characters */
#define _COM_CHR8	3	/* 8 bits characters */

/* stop bit values - on or off */

#define _COM_STOP1	0	/* 1 stop bit */
#define _COM_STOP2	4	/* 2 stop bits */

/*  parity initializers */

#define _COM_NOPARITY	0	/* no parity */
#define _COM_ODDPARITY	8	/* odd parity */
#define _COM_EVENPARITY 24	/* even parity */

/*  baud rate initializers */

#define _COM_110	0	/* 110 baud */
#define _COM_150	32	/* 150 baud */
#define _COM_300	64	/* 300 baud */
#define _COM_600	96	/* 600 baud */
#define _COM_1200	128	/* 1200 baud */
#define _COM_2400	160	/* 2400 baud */
#define _COM_4800	192	/* 4800 baud */
#define _COM_9600	224	/* 9600 baud */


/* manifest constants for BIOS disk support */

/* disk services */

#define _DISK_RESET	0	/* reset disk controller */
#define _DISK_STATUS	1	/* get disk status */
#define _DISK_READ	2	/* read disk sectors */
#define _DISK_WRITE	3	/* write disk sectors */
#define _DISK_VERIFY	4	/* verify disk sectors */
#define _DISK_FORMAT	5	/* format disk track */

/* struct used to send/receive information to/from the BIOS disk services */

#ifndef _DISKINFO_T_DEFINED

struct diskinfo_t {
    unsigned drive;
    unsigned head;
    unsigned track;
    unsigned sector;
    unsigned nsectors;
    void _far *buffer;
    };

#define _DISKINFO_T_DEFINED

#endif


/* manifest constants for BIOS keyboard support */

/* keyboard services */

#define _KEYBRD_READ		0	/* read next character from keyboard */
#define _KEYBRD_READY		1	/* check for keystroke */
#define _KEYBRD_SHIFTSTATUS	2	/* get current shift key status */

/* services for enhanced keyboards */

#define _NKEYBRD_READ		0x10	/* read next character from keyboard */
#define _NKEYBRD_READY		0x11	/* check for keystroke */
#define _NKEYBRD_SHIFTSTATUS	0x12	/* get current shift key status */


/* manifest constants for BIOS printer support */

/* printer services */

#define _PRINTER_WRITE	0	/* write character to printer */
#define _PRINTER_INIT	1	/* intialize printer */
#define _PRINTER_STATUS 2	/* get printer status */


/* manifest constants for BIOS time of day support */

/* time of day services */

#define _TIME_GETCLOCK	0	/* get current clock count */
#define _TIME_SETCLOCK	1	/* set current clock count */


#ifndef _REGS_DEFINED

/* word registers */

struct WORDREGS {
    unsigned int ax;
    unsigned int bx;
    unsigned int cx;
    unsigned int dx;
    unsigned int si;
    unsigned int di;
    unsigned int cflag;
    };

/* byte registers */

struct BYTEREGS {
    unsigned char al, ah;
    unsigned char bl, bh;
    unsigned char cl, ch;
    unsigned char dl, dh;
    };

/* general purpose registers union -
 *  overlays the corresponding word and byte registers.
 */

union REGS {
    struct WORDREGS x;
    struct BYTEREGS h;
    };

/* segment registers */

struct SREGS {
    unsigned int es;
    unsigned int cs;
    unsigned int ss;
    unsigned int ds;
    };

#define _REGS_DEFINED

#endif /* _REGS_DEFINED */


/* function prototypes */

unsigned _cdecl _bios_disk(unsigned, struct diskinfo_t *);
unsigned _cdecl _bios_equiplist(void);
unsigned _cdecl _bios_keybrd(unsigned);
unsigned _cdecl _bios_memsize(void);
unsigned _cdecl _bios_printer(unsigned, unsigned, unsigned);
unsigned _cdecl _bios_serialcom(unsigned, unsigned, unsigned);
unsigned _cdecl _bios_timeofday(unsigned, long *);
int _cdecl int86(int, union REGS *, union REGS *);
int _cdecl int86x(int, union REGS *, union REGS *, struct SREGS *);

#endif /* _MT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\c6\inc\direct.h ===
/***
*direct.h - function declarations for directory handling/creation
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This include file contains the function declarations for the library
*	functions related to directory handling and creation.
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* function prototypes */

int _FAR_ _cdecl chdir(const char _FAR_ *);
int _FAR_ _cdecl _chdrive(int);
char _FAR_ * _FAR_ _cdecl getcwd(char _FAR_ *, int);
char _FAR_ * _FAR_ _cdecl _getdcwd(int, char _FAR_ *, int);
int _FAR_ _cdecl _getdrive(void);
int _FAR_ _cdecl mkdir(const char _FAR_ *);
int _FAR_ _cdecl rmdir(const char _FAR_ *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\c6\inc\dos.h ===
/***
*dos.h - definitions for MS-DOS interface routines
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Defines the structs and unions used for the direct DOS interface
*	routines; includes macros to access the segment and offset
*	values of far pointers, so that they may be used by the routines; and
*	provides function prototypes for direct DOS interface functions.
*
****/


#ifndef _REGS_DEFINED

/* word registers */

struct WORDREGS {
	unsigned int ax;
	unsigned int bx;
	unsigned int cx;
	unsigned int dx;
	unsigned int si;
	unsigned int di;
	unsigned int cflag;
	};


/* byte registers */

struct BYTEREGS {
	unsigned char al, ah;
	unsigned char bl, bh;
	unsigned char cl, ch;
	unsigned char dl, dh;
	};


/* general purpose registers union -
 *  overlays the corresponding word and byte registers.
 */

union REGS {
	struct WORDREGS x;
	struct BYTEREGS h;
	};


/* segment registers */

struct SREGS {
	unsigned int es;
	unsigned int cs;
	unsigned int ss;
	unsigned int ds;
	};

#define _REGS_DEFINED

#endif


/* dosexterror structure */

#ifndef _DOSERROR_DEFINED

struct DOSERROR {
	int exterror;
	char class;
	char action;
	char locus;
	};

#define _DOSERROR_DEFINED

#endif


/* _dos_findfirst structure */

#ifndef _FIND_T_DEFINED

struct find_t {
	char reserved[21];
	char attrib;
	unsigned wr_time;
	unsigned wr_date;
	long size;
	char name[13];
	};

#define _FIND_T_DEFINED

#endif


/* _dos_getdate/_dossetdate and _dos_gettime/_dos_settime structures */

#ifndef _DATETIME_T_DEFINED

struct dosdate_t {
	unsigned char day;		/* 1-31 */
	unsigned char month;		/* 1-12 */
	unsigned int year;		/* 1980-2099 */
	unsigned char dayofweek;	/* 0-6, 0=Sunday */
	};

struct dostime_t {
	unsigned char hour;	/* 0-23 */
	unsigned char minute;	/* 0-59 */
	unsigned char second;	/* 0-59 */
	unsigned char hsecond;	/* 0-99 */
	};

#define _DATETIME_T_DEFINED

#endif


/* _dos_getdiskfree structure */

#ifndef _DISKFREE_T_DEFINED

struct diskfree_t {
	unsigned total_clusters;
	unsigned avail_clusters;
	unsigned sectors_per_cluster;
	unsigned bytes_per_sector;
	};

#define _DISKFREE_T_DEFINED

#endif


/* manifest constants for _hardresume result parameter */

#define _HARDERR_IGNORE 	0	/* Ignore the error */
#define _HARDERR_RETRY		1	/* Retry the operation */
#define _HARDERR_ABORT		2	/* Abort program issuing Interrupt 23h */
#define _HARDERR_FAIL		3	/* Fail the system call in progress */
					/* _HARDERR_FAIL is not supported on DOS 2.x */

/* File attribute constants */

#define _A_NORMAL	0x00	/* Normal file - No read/write restrictions */
#define _A_RDONLY	0x01	/* Read only file */
#define _A_HIDDEN	0x02	/* Hidden file */
#define _A_SYSTEM	0x04	/* System file */
#define _A_VOLID	0x08	/* Volume ID file */
#define _A_SUBDIR	0x10	/* Subdirectory */
#define _A_ARCH 	0x20	/* Archive file */

/* macros to break C "far" pointers into their segment and offset components
 */

#define FP_SEG(fp) (*((unsigned _far *)&(fp)+1))
#define FP_OFF(fp) (*((unsigned _far *)&(fp)))


/* external variable declarations */

extern unsigned int _near _cdecl _osversion;


/* function prototypes */

#ifndef _MT
int _cdecl bdos(int, unsigned int, unsigned int);
void _cdecl _chain_intr(void (_cdecl _interrupt _far *)());
void _cdecl _disable(void);
unsigned _cdecl _dos_allocmem(unsigned, unsigned *);
unsigned _cdecl _dos_close(int);
unsigned _cdecl _dos_creat(const char *, unsigned, int *);
unsigned _cdecl _dos_creatnew(const char *, unsigned, int *);
unsigned _cdecl _dos_findfirst(const char *, unsigned, struct find_t *);
unsigned _cdecl _dos_findnext(struct find_t *);
unsigned _cdecl _dos_freemem(unsigned);
void _cdecl _dos_getdate(struct dosdate_t *);
void _cdecl _dos_getdrive(unsigned *);
unsigned _cdecl _dos_getdiskfree(unsigned, struct diskfree_t *);
unsigned _cdecl _dos_getfileattr(const char *, unsigned *);
unsigned _cdecl _dos_getftime(int, unsigned *, unsigned *);
void _cdecl _dos_gettime(struct dostime_t *);
void (_cdecl _interrupt _far * _cdecl _dos_getvect(unsigned))();
void _cdecl _dos_keep(unsigned, unsigned);
unsigned _cdecl _dos_open(const char *, unsigned, int *);
unsigned _cdecl _dos_read(int, void _far *, unsigned, unsigned *);
unsigned _cdecl _dos_setblock(unsigned, unsigned, unsigned *);
unsigned _cdecl _dos_setdate(struct dosdate_t *);
void _cdecl _dos_setdrive(unsigned, unsigned *);
unsigned _cdecl _dos_setfileattr(const char *, unsigned);
unsigned _cdecl _dos_setftime(int, unsigned, unsigned);
unsigned _cdecl _dos_settime(struct dostime_t *);
void _cdecl _dos_setvect(unsigned, void (_cdecl _interrupt _far *)());
unsigned _cdecl _dos_write(int, const void _far *, unsigned, unsigned *);
int _cdecl dosexterr(struct DOSERROR *);
void _cdecl _enable(void);
void _cdecl _harderr(void (_far *)());
void _cdecl _hardresume(int);
void _cdecl _hardretn(int);
int _cdecl intdos(union REGS *, union REGS *);
int _cdecl intdosx(union REGS *, union REGS *, struct SREGS *);
int _cdecl int86(int, union REGS *, union REGS *);
int _cdecl int86x(int, union REGS *, union REGS *, struct SREGS *);
#endif /* _MT */

void _cdecl segread(struct SREGS *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\c6\inc\fcntl.h ===
/***
*fcntl.h - file control options used by open()
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines constants for the file control options used
*	by the open() function.
*	[System V]
*
****/

#define O_RDONLY	0x0000	/* open for reading only */
#define O_WRONLY	0x0001	/* open for writing only */
#define O_RDWR		0x0002	/* open for reading and writing */
#define O_APPEND	0x0008	/* writes done at eof */

#define O_CREAT 	0x0100	/* create and open file */
#define O_TRUNC 	0x0200	/* open and truncate */
#define O_EXCL		0x0400	/* open only if file doesn't already exist */

/* O_TEXT files have <cr><lf> sequences translated to <lf> on read()'s,
** and <lf> sequences translated to <cr><lf> on write()'s
*/

#define O_TEXT		0x4000	/* file mode is text (translated) */
#define O_BINARY	0x8000	/* file mode is binary (untranslated) */

/* macro to translate the C 2.0 name used to force binary mode for files */

#define O_RAW	O_BINARY

/* Open handle inherit bit */

#define O_NOINHERIT	0x0080	/* child process doesn't inherit file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\c6\inc\errno.h ===
/***
*errno.h - system wide error numbers (set by system calls)
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the system-wide error numbers (set by
*	system calls).	Conforms to the XENIX standard.  Extended
*	for compatibility with Uniforum standard.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

/* declare reference to errno */

#ifdef	_MT
extern int _far * _cdecl _far volatile _errno(void);
#define errno	(*_errno())
#else
extern int _near _cdecl volatile errno;
#endif

/* Error Codes */

#define EZERO		0
#define EPERM		1
#define ENOENT		2
#define ESRCH		3
#define EINTR		4
#define EIO		5
#define ENXIO		6
#define E2BIG		7
#define ENOEXEC 	8
#define EBADF		9
#define ECHILD		10
#define EAGAIN		11
#define ENOMEM		12
#define EACCES		13
#define EFAULT		14
#define ENOTBLK 	15
#define EBUSY		16
#define EEXIST		17
#define EXDEV		18
#define ENODEV		19
#define ENOTDIR 	20
#define EISDIR		21
#define EINVAL		22
#define ENFILE		23
#define EMFILE		24
#define ENOTTY		25
#define ETXTBSY 	26
#define EFBIG		27
#define ENOSPC		28
#define ESPIPE		29
#define EROFS		30
#define EMLINK		31
#define EPIPE		32
#define EDOM		33
#define ERANGE		34
#define EUCLEAN 	35
#define EDEADLOCK	36
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\c6\inc\malloc.h ===
/***
*malloc.h - declarations and definitions for memory allocation functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Contains the function declarations for memory allocation functions;
*	also defines manifest constants and types used by the heap routines.
*	[System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif


/* constants for based heap routines */

#if (_MSC_VER >= 600)
#define _NULLSEG	((_segment)0)
#define _NULLOFF	((void _based(void) *)0xffff)
#endif


/* constants for _heapchk/_heapset/_heapwalk routines */

#define _HEAPEMPTY	(-1)
#define _HEAPOK 	(-2)
#define _HEAPBADBEGIN	(-3)
#define _HEAPBADNODE	(-4)
#define _HEAPEND	(-5)
#define _HEAPBADPTR	(-6)
#define _FREEENTRY	0
#define _USEDENTRY	1


/* maximum heap request that can ever be honored */

#define _HEAP_MAXREQ	0xFFE8


/* types and structures */

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


#ifndef _HEAPINFO_DEFINED
typedef struct _heapinfo {
	int _far * _pentry;
	size_t _size;
	int _useflag;
	} _HEAPINFO;
#define _HEAPINFO_DEFINED
#endif


/* external variable declarations */

#ifdef _DLL
extern unsigned int _FAR_ _cdecl _amblksiz;
#else
extern unsigned int _near _cdecl _amblksiz;
#endif


/* based heap function prototypes */

#if (_MSC_VER >= 600)
void _based(void) * _FAR_ _cdecl _bcalloc(_segment, size_t, size_t);
void _based(void) * _FAR_ _cdecl _bexpand(_segment,
	void _based(void) *, size_t);
void _FAR_ _cdecl _bfree(_segment, void _based(void) *);
int _FAR_ _cdecl _bfreeseg(_segment);
int _FAR_ _cdecl _bheapadd(_segment, void _based(void) *, size_t);
int _FAR_ _cdecl _bheapchk(_segment);
int _FAR_ _cdecl _bheapmin(_segment);
_segment _FAR_ _cdecl _bheapseg(size_t);
int _FAR_ _cdecl _bheapset(_segment, unsigned int);
int _FAR_ _cdecl _bheapwalk(_segment, _HEAPINFO *);
void _based(void) * _FAR_ _cdecl _bmalloc(_segment, size_t);
size_t _FAR_ _cdecl _bmsize(_segment, void _based(void) *);
void _based(void) * _FAR_ _cdecl _brealloc(_segment,
	void _based(void) *, size_t);
#endif


/* function prototypes */

void _FAR_ * _FAR_ _cdecl alloca(size_t);
void _FAR_ * _FAR_ _cdecl calloc(size_t, size_t);
void _FAR_ * _FAR_ _cdecl _expand(void _FAR_ *, size_t);
void _far * _FAR_ _cdecl _fcalloc(size_t, size_t);
void _far * _FAR_ _cdecl _fexpand(void _far *, size_t);
void _FAR_ _cdecl _ffree(void _far *);
int _FAR_ _cdecl _fheapchk(void);
int _FAR_ _cdecl _fheapmin(void);
int _FAR_ _cdecl _fheapset(unsigned int);
int _FAR_ _cdecl _fheapwalk(_HEAPINFO _FAR_ *);
void _far * _FAR_ _cdecl _fmalloc(size_t);
size_t _FAR_ _cdecl _fmsize(void _far *);
void _far * _FAR_ _cdecl _frealloc(void _far *, size_t);
unsigned int _FAR_ _cdecl _freect(size_t);
void _FAR_ _cdecl free(void _FAR_ *);
void _huge * _FAR_ _cdecl halloc(long, size_t);
void _FAR_ _cdecl hfree(void _huge *);
int _FAR_ _cdecl _heapadd(void _far *, size_t);
int _FAR_ _cdecl _heapchk(void);
int _FAR_ _cdecl _heapmin(void);
int _FAR_ _cdecl _heapset(unsigned int);
int _FAR_ _cdecl _heapwalk(_HEAPINFO _FAR_ *);
void _FAR_ * _FAR_ _cdecl malloc(size_t);
size_t _FAR_ _cdecl _memavl(void);
size_t _FAR_ _cdecl _memmax(void);
size_t _FAR_ _cdecl _msize(void _FAR_ *);
void _near * _FAR_ _cdecl _ncalloc(size_t, size_t);
void _near * _FAR_ _cdecl _nexpand(void _near *, size_t);
void _FAR_ _cdecl _nfree(void _near *);
int _FAR_ _cdecl _nheapchk(void);
int _FAR_ _cdecl _nheapmin(void);
int _FAR_ _cdecl _nheapset(unsigned int);
int _FAR_ _cdecl _nheapwalk(_HEAPINFO _FAR_ *);
void _near * _FAR_ _cdecl _nmalloc(size_t);
size_t _FAR_ _cdecl _nmsize(void _near *);
void _near * _FAR_ _cdecl _nrealloc(void _near *, size_t);
void _FAR_ * _FAR_ _cdecl realloc(void _FAR_ *, size_t);
size_t _FAR_ _cdecl stackavail(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\c6\inc\memory.h ===
/***
*memory.h - declarations for buffer (memory) manipulation routines
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This include file contains the function declarations for the
*	buffer (memory) manipulation routines.
*	[System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


/* function prototypes */

void _FAR_ * _FAR_ _cdecl memccpy(void _FAR_ *, const void _FAR_ *,
	int, unsigned int);
void _FAR_ * _FAR_ _cdecl memchr(const void _FAR_ *, int, size_t);
int _FAR_ _cdecl memcmp(const void _FAR_ *, const void _FAR_ *,
	size_t);
void _FAR_ * _FAR_ _cdecl memcpy(void _FAR_ *, const void _FAR_ *,
	size_t);
int _FAR_ _cdecl memicmp(const void _FAR_ *, const void _FAR_ *,
	unsigned int);
void _FAR_ * _FAR_ _cdecl memset(void _FAR_ *, int, size_t);
void _FAR_ _cdecl movedata(unsigned int, unsigned int, unsigned int,
	unsigned int, unsigned int);


/* model independent function prototypes */

void _far * _far _cdecl _fmemccpy(void _far *, const void _far *,
	int, unsigned int);
void _far * _far _cdecl _fmemchr(const void _far *, int, size_t);
int _far _cdecl _fmemcmp(const void _far *, const void _far *,
	size_t);
void _far * _far _cdecl _fmemcpy(void _far *, const void _far *,
	size_t);
int _far _cdecl _fmemicmp(const void _far *, const void _far *,
	unsigned int);
void _far * _far _cdecl _fmemset(void _far *, int, size_t);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\c6\inc\share.h ===
/***
*share.h - defines file sharing modes for sopen
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the file sharing modes for sopen().
*
****/

#define SH_COMPAT	0x00	/* compatibility mode */
#define SH_DENYRW	0x10	/* deny read/write mode */
#define SH_DENYWR	0x20	/* deny write mode */
#define SH_DENYRD	0x30	/* deny read mode */
#define SH_DENYNO	0x40	/* deny none mode */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\c6\inc\process.h ===
/***
*process.h - definition and declarations for process control functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains the declarations and definitions for the
*	spawnxx, execxx, and various other process control routines.
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

/* mode values for spawnxx routines
 * (only P_WAIT and P_OVERLAY are supported on MS-DOS)
 */

#ifndef _MT
extern int _near _cdecl _p_overlay;
#endif

#define P_WAIT		0
#define P_NOWAIT	1
#ifdef _MT
#define P_OVERLAY	2
#else
#define P_OVERLAY	_p_overlay
#endif
#define OLD_P_OVERLAY	2
#define P_NOWAITO	3
#define P_DETACH	4


/* action codes used with cwait() */

#define WAIT_CHILD 0
#define WAIT_GRANDCHILD 1


/* function prototypes */

#ifdef _MT
int _FAR_ _cdecl _beginthread(void(_cdecl _FAR_ *)(void _FAR_ *),
	void _FAR_ *, unsigned, void _FAR_ *);
void _FAR_ _cdecl _endthread(void);
#endif
void _FAR_ _cdecl abort(void);
void _FAR_ _cdecl _cexit(void);
void _FAR_ _cdecl _c_exit(void);
int _FAR_ _cdecl cwait(int _FAR_ *, int, int);
int _FAR_ _cdecl execl(const char _FAR_ *, const char _FAR_ *, ...);
int _FAR_ _cdecl execle(const char _FAR_ *, const char _FAR_ *, ...);
int _FAR_ _cdecl execlp(const char _FAR_ *, const char _FAR_ *, ...);
int _FAR_ _cdecl execlpe(const char _FAR_ *, const char _FAR_ *, ...);
int _FAR_ _cdecl execv(const char _FAR_ *,
	const char _FAR_ * const _FAR_ *);
int _FAR_ _cdecl execve(const char _FAR_ *,
	const char _FAR_ * const _FAR_ *, const char _FAR_ * const _FAR_ *);
int _FAR_ _cdecl execvp(const char _FAR_ *,
	const char _FAR_ * const _FAR_ *);
int _FAR_ _cdecl execvpe(const char _FAR_ *,
	const char _FAR_ * const _FAR_ *, const char _FAR_ * const _FAR_ *);
void _FAR_ _cdecl exit(int);
void _FAR_ _cdecl _exit(int);
int _FAR_ _cdecl getpid(void);
int _FAR_ _cdecl spawnl(int, const char _FAR_ *, const char _FAR_ *,
	...);
int _FAR_ _cdecl spawnle(int, const char _FAR_ *, const char _FAR_ *,
	...);
int _FAR_ _cdecl spawnlp(int, const char _FAR_ *, const char _FAR_ *,
	...);
int _FAR_ _cdecl spawnlpe(int, const char _FAR_ *, const char _FAR_ *,
	...);
int _FAR_ _cdecl spawnv(int, const char _FAR_ *,
	const char _FAR_ * const _FAR_ *);
int _FAR_ _cdecl spawnve(int, const char _FAR_ *,
	const char _FAR_ * const _FAR_ *, const char _FAR_ * const _FAR_ *);
int _FAR_ _cdecl spawnvp(int, const char _FAR_ *,
	const char _FAR_ * const _FAR_ *);
int _FAR_ _cdecl spawnvpe(int, const char _FAR_ *,
	const char _FAR_ * const _FAR_ *, const char _FAR_ * const _FAR_ *);
int _FAR_ _cdecl system(const char _FAR_ *);
int _FAR_ _cdecl wait(int _FAR_ *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\c6\inc\io.h ===
/***
*io.h - declarations for low-level file handling and I/O functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains the function declarations for the low-level
*	file handling and I/O functions.
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

/* function prototypes */

int _FAR_ _cdecl access(const char _FAR_ *, int);
int _FAR_ _cdecl chmod(const char _FAR_ *, int);
int _FAR_ _cdecl chsize(int, long);
int _FAR_ _cdecl close(int);
int _FAR_ _cdecl creat(const char _FAR_ *, int);
int _FAR_ _cdecl dup(int);
int _FAR_ _cdecl dup2(int, int);
int _FAR_ _cdecl eof(int);
long _FAR_ _cdecl filelength(int);
int _FAR_ _cdecl isatty(int);
int _FAR_ _cdecl locking(int, int, long);
long _FAR_ _cdecl lseek(int, long, int);
char _FAR_ * _FAR_ _cdecl mktemp(char _FAR_ *);
int _FAR_ _cdecl open(const char _FAR_ *, int, ...);
int _FAR_ _cdecl _pipe(int _FAR_ *, unsigned int, int);
int _FAR_ _cdecl read(int, void _FAR_ *, unsigned int);
int _FAR_ _cdecl remove(const char _FAR_ *);
int _FAR_ _cdecl rename(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl setmode(int, int);
int _FAR_ _cdecl sopen(const char _FAR_ *, int, int, ...);
long _FAR_ _cdecl tell(int);
int _FAR_ _cdecl umask(int);
int _FAR_ _cdecl unlink(const char _FAR_ *);
int _FAR_ _cdecl write(int, const void _FAR_ *, unsigned int);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\winnt\c6\inc\time.h ===
/***
*time.h - definitions/declarations for time routines
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains the various declarations and definitions
*	for the time routines.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

/* implementation defined time types */

#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif

#ifndef _CLOCK_T_DEFINED
typedef long clock_t;
#define _CLOCK_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* structure for use with localtime(), gmtime(), etc. */

#ifndef _TM_DEFINED
struct tm {
	int tm_sec;	/* seconds after the minute - [0,59] */
	int tm_min;	/* minutes after the hour - [0,59] */
	int tm_hour;	/* hours since midnight - [0,23] */
	int tm_mday;	/* day of the month - [1,31] */
	int tm_mon;	/* months since January - [0,11] */
	int tm_year;	/* years since 1900 */
	int tm_wday;	/* days since Sunday - [0,6] */
	int tm_yday;	/* days since January 1 - [0,365] */
	int tm_isdst;	/* daylight savings time flag */
	};
#define _TM_DEFINED
#endif


/* define NULL pointer value */

#ifndef NULL
#if (_MSC_VER >= 600)
#define NULL	((void *)0)
#elif (defined(M_I86SM) || defined(M_I86MM))
#define NULL	0
#else
#define NULL	0L
#endif
#endif


/* clock ticks macro - ANSI version */

#define CLOCKS_PER_SEC	1000

/* clock ticks macro - archaic version */

#define CLK_TCK 	1000


/* extern declarations for the global variables used by the ctime family of
 * routines.
 */

#ifdef _DLL
extern int _FAR_ _cdecl daylight;     /* non-zero if daylight savings time is used */
extern long _FAR_ _cdecl timezone;    /* difference in seconds between GMT and local time */
extern char _FAR_ * _FAR_ _cdecl tzname[2]; /* standard/daylight savings time zone names */
#else
extern int _near _cdecl daylight;     /* non-zero if daylight savings time is used */
extern long _near _cdecl timezone;    /* difference in seconds between GMT and local time */
extern char * _near _cdecl tzname[2]; /* standard/daylight savings time zone names */
#endif


/* function prototypes */

#ifdef _MT
double _FAR_ _pascal difftime(time_t, time_t);
#else
double _FAR_ _cdecl difftime(time_t, time_t);
#endif

char _FAR_ * _FAR_ _cdecl asctime(const struct tm _FAR_ *);
char _FAR_ * _FAR_ _cdecl ctime(const time_t _FAR_ *);
clock_t _FAR_ _cdecl clock(void);
struct tm _FAR_ * _FAR_ _cdecl gmtime(cons