ileNameSize( ShortNameAttr ),
                           &Fcb->FileReference,
                           NULL,
                           NULL );

        //
        //  Now allocate a full name for the dir notify.
        //

        if (ReportDirNotify) {

            //
            //  Figure out the length of the name.
            //

            FullShortName.Length = ShortName.Length + ParentScb->ScbType.Index.NormalizedName.Length;

            if (ParentScb != Vcb->RootIndexScb) {

                FullShortName.Length += sizeof( WCHAR );
            }

            FullShortName.MaximumLength = FullShortName.Length;
            FullShortName.Buffer = NtfsAllocatePool( PagedPool, FullShortName.Length );

            //
            //  Copy in the full name.  Note we always copy in the '\' separator but will automatically
            //  overwrite in the case where it wasn't needed.
            //

            RtlCopyMemory( FullShortName.Buffer,
                           ParentScb->ScbType.Index.NormalizedName.Buffer,
                           ParentScb->ScbType.Index.NormalizedName.Length );

            *(FullShortName.Buffer + (ParentScb->ScbType.Index.NormalizedName.Length / sizeof( WCHAR ))) = L'\\';

            RtlCopyMemory( Add2Ptr( FullShortName.Buffer, FullShortName.Length - ShortName.Length ),
                           ShortName.Buffer,
                           ShortName.Length );
        }

        //
        //  Write the usn journal entry now if active.  We want to write this log record
        //  before updating the in-memory data structures.
        //

        NtfsPostUsnChange( IrpContext,
                           Fcb,
                           USN_REASON_HARD_LINK_CHANGE );

        //
        //  The on-disk changes are complete.  Checkpoint the transaction now so we don't have to
        //  roll back any in-memory structures if we get a LOG_FILE_FULL when writing to the Usn journal.
        //

        NtfsCheckpointCurrentTransaction( IrpContext );

        //
        //  Update the existing long and short names Lcb with the new names and flags if necessary.
        //

        if (LongNameLcb != NULL) {

            LongNameLcb->FileNameAttr->Flags = FILE_NAME_NTFS;
        }

        if (ShortNameLcb != NULL) {

            NtfsRenameLcb( IrpContext,
                           ShortNameLcb,
                           &ShortName,
                           FILE_NAME_DOS,
                           FALSE );
        }

        if (ReportDirNotify) {

            //
            //  Generate the DirNotify event for the old short name if necessary.
            //

            if (ExistingShortName) {

                NtfsReportDirNotify( IrpContext,
                                     Vcb,
                                     &FullOldShortName,
                                     FullOldShortName.Length - OldShortName.Length,
                                     NULL,
                                     NULL,
                                     IsDirectory( &Fcb->Info ) ? FILE_NOTIFY_CHANGE_DIR_NAME : FILE_NOTIFY_CHANGE_FILE_NAME,
                                     FILE_ACTION_RENAMED_OLD_NAME,
                                     ParentScb->Fcb );
            }

            //
            //  Generate the DirNotify event for the new short name.
            //

            NtfsReportDirNotify( IrpContext,
                                 Vcb,
                                 &FullShortName,
                                 FullShortName.Length - ShortName.Length,
                                 NULL,
                                 NULL,
                                 IsDirectory( &Fcb->Info ) ? FILE_NOTIFY_CHANGE_DIR_NAME : FILE_NOTIFY_CHANGE_FILE_NAME,
                                 FILE_ACTION_RENAMED_NEW_NAME,
                                 ParentScb->Fcb );
        }

        //
        //  Change the time stamps in the parent if we modified the links in this directory.
        //

        NtfsUpdateFcb( ParentScb->Fcb,
                       (FCB_INFO_CHANGED_LAST_CHANGE |
                        FCB_INFO_CHANGED_LAST_MOD |
                        FCB_INFO_UPDATE_LAST_ACCESS) );

        //
        //  Update the last change time and archive bit.  No archive bit change for
        //  directories.
        //

        SetFlag( Ccb->Flags, CCB_FLAG_UPDATE_LAST_CHANGE );

        //
        //  Don't set the archive bit on a directory.  Otherwise we break existing
        //  apps that don't expect to see this flag.
        //

        if (!IsDirectory( &Fcb->Info )) {

            SetFlag( Ccb->Flags, CCB_FLAG_SET_ARCHIVE );
        }

    } finally {

        DebugUnwind( NtfsSetShortNameInfo );

        //
        //  Cleanup the allocations and contexts used.
        //

        if (CleanupAttrContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }

        if (ShortNameAttr != NULL) {

            NtfsFreePool( ShortNameAttr );
        }

        if (OldShortName.Buffer != NULL) {

            NtfsFreePool( OldShortName.Buffer );
        }

        if (FullOldShortName.Buffer != NULL) {

            NtfsFreePool( FullOldShortName.Buffer );
        }

        if (FullShortName.Buffer != NULL) {

            NtfsFreePool( FullShortName.Buffer );
        }

        NtfsUnpinBcb( IrpContext, &IndexEntryBcb );

        DebugTrace( -1, Dbg, ("NtfsSetShortNameInfo:  Exit  ->  %08lx\n", Status) );
    }

    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsSetPositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine performs the set position information function.

Arguments:

    FileObject - Supplies the file object being processed

    Irp - Supplies the Irp being processed

    Scb - Supplies the Scb for the file/directory being modified

Return Value:

    NTSTATUS - The status of the operation

--*/

{
    NTSTATUS Status;

    PFILE_POSITION_INFORMATION Buffer;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_IRP( Irp );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsSetPositionInfo...\n") );

    //
    //  Reference the system buffer containing the user specified position
    //  information record
    //

    Buffer = Irp->AssociatedIrp.SystemBuffer;

    try {

        //
        //  Check if the file does not use intermediate buffering.  If it does
        //  not use intermediate buffering then the new position we're supplied
        //  must be aligned properly for the device
        //

        if (FlagOn( FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING )) {

            PDEVICE_OBJECT DeviceObject;

            DeviceObject = IoGetCurrentIrpStackLocation(Irp)->DeviceObject;

            if ((Buffer->CurrentByteOffset.LowPart & DeviceObject->AlignmentRequirement) != 0) {

                DebugTrace( 0, Dbg, ("Offset missaligned %08lx %08lx\n", Buffer->CurrentByteOffset.LowPart, Buffer->CurrentByteOffset.HighPart) );

                try_return( Status = STATUS_INVALID_PARAMETER );
            }
        }

        //
        //  Set the new current byte offset in the file object
        //

        FileObject->CurrentByteOffset = Buffer->CurrentByteOffset;

        Status = STATUS_SUCCESS;

    try_exit: NOTHING;
    } finally {

        DebugUnwind( NtfsSetPositionInfo );

        NOTHING;
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsSetPositionInfo -> %08lx\n", Status) );

    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsPrepareToShrinkFileSize (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    LONGLONG NewFileSize
    )
/*++

Routine Description:

    Page in the last page of the file so we don't deadlock behind another thread
    trying to access it. (CcSetFileSizes will do a purge that will try to zero
    the cachemap directly when we shrink a file)

    Note: this requires droping and regaining the main resource to not deadlock
    and must be done before a transaction has started

Arguments:

    FileObject - Supplies the file object being processed

    Scb - Supplies the Scb for the file/directory being modified

    NewFileSize - The new size the file will shrink to

Return Value:

    NTSTATUS - The status of the operation

--*/
{
    IO_STATUS_BLOCK Iosb;
    ULONG Buffer;

    if (!MmCanFileBeTruncated( FileObject->SectionObjectPointer,
                               (PLARGE_INTEGER)&NewFileSize )) {

        return STATUS_USER_MAPPED_FILE;
    }

    if ((Scb->NonpagedScb->SegmentObject.DataSectionObject != NULL) &&
        ((NewFileSize % PAGE_SIZE) != 0)) {

        if (NULL == Scb->FileObject) {
            NtfsCreateInternalAttributeStream( IrpContext,
                                               Scb,
                                               FALSE,
                                               &NtfsInternalUseFile[PREPARETOSHRINKFILESIZE_FILE_NUMBER] );
        }

        ASSERT( NtfsIsExclusiveScb( Scb ) );
        NtfsReleaseScb( IrpContext,  Scb  );

        NewFileSize = NewFileSize & ~(PAGE_SIZE - 1);
        if (!CcCopyRead( Scb->FileObject,
                         (PLARGE_INTEGER)&NewFileSize,
                         1,
                         BooleanFlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ),
                         &Buffer,
                         &Iosb )) {

            NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
        }

        NtfsAcquireExclusiveScb( IrpContext, Scb );
    }

    return STATUS_SUCCESS;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsSetAllocationInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine performs the set allocation information function.

Arguments:

    FileObject - Supplies the file object being processed

    Irp - Supplies the Irp being processed

    Scb - Supplies the Scb for the file/directory being modified

    Ccb - This is the Scb for the open operation.  May not be present if
        this is a Mm call.

Return Value:

    NTSTATUS - The status of the operation

--*/

{
    NTSTATUS Status;
    PFCB Fcb = Scb->Fcb;
    BOOLEAN NonResidentPath = FALSE;
    BOOLEAN FileIsCached = FALSE;
    BOOLEAN ClearCheckSizeFlag = FALSE;

    LONGLONG NewAllocationSize;
    LONGLONG PrevAllocationSize;

    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    BOOLEAN CleanupAttrContext = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_IRP( Irp );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsSetAllocationInfo...\n") );

    //
    //  Are we serialized correctly?  In NtfsCommonSetInformation above, we get
    //  paging shared for a lazy writer callback, but we should never end up in
    //  here from a lazy writer callback.
    //

    ASSERT( NtfsIsExclusiveScbPagingIo( Scb ) );

    //
    //  If this attribute has been 'deleted' then we we can return immediately
    //

    if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )) {

        Status = STATUS_SUCCESS;

        DebugTrace( -1, Dbg, ("NtfsSetAllocationInfo:  Attribute is already deleted\n") );

        return Status;
    }

    if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

        NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );
    }

    if (Ccb != NULL) {

        //
        //  Remember the source info flags in the Ccb.
        //

        IrpContext->SourceInfo = Ccb->UsnSourceInfo;
    }

    //
    //  Save the current state of the Scb.
    //

    NtfsSnapshotScb( IrpContext, Scb );

    //
    //  Get the new allocation size.
    //

    NewAllocationSize = ((PFILE_ALLOCATION_INFORMATION)Irp->AssociatedIrp.SystemBuffer)->AllocationSize.QuadPart;
    PrevAllocationSize = Scb->Header.AllocationSize.QuadPart;

    //
    //  Check for a valid input value for the file size.
    //

    ASSERT( NewAllocationSize >= 0 );

    if ((ULONGLONG)NewAllocationSize > MAXFILESIZE) {

        Status = STATUS_INVALID_PARAMETER;
        DebugTrace( -1, Dbg, ("NtfsSetAllocationInfo:  Invalid allocation size\n") );
        return Status;
    }

    //
    //  Do work to prepare for shrinking file if necc.
    //

    if (NewAllocationSize < Scb->Header.FileSize.QuadPart) {

        //
        //  Paging IO should never shrink the file.
        //

        ASSERT( !FlagOn( Irp->Flags, IRP_PAGING_IO ) );

        Status = NtfsPrepareToShrinkFileSize( IrpContext, FileObject, Scb, NewAllocationSize );
        if (Status != STATUS_SUCCESS) {

            DebugTrace( -1, Dbg, ("NtfsSetAllocationInfo -> %08lx\n", Status) );
            return Status;
        }
    }

    //
    //  Use a try-finally so we can update the on disk time-stamps.
    //

    try {

#ifdef SYSCACHE
        //
        //  Let's remember this.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_SYSCACHE_FILE )) {

            PSYSCACHE_EVENT SyscacheEvent;

            SyscacheEvent = NtfsAllocatePool( PagedPool, sizeof( SYSCACHE_EVENT ) );

            SyscacheEvent->EventTypeCode = SYSCACHE_SET_ALLOCATION_SIZE;
            SyscacheEvent->Data1 = NewAllocationSize;
            SyscacheEvent->Data2 = 0L;

            InsertTailList( &Scb->ScbType.Data.SyscacheEventList, &SyscacheEvent->EventList );
        }
#endif

        //
        //  It is extremely expensive to make this call on a file that is not
        //  cached, and Ntfs has suffered stack overflows in addition to massive
        //  time and disk I/O expense (CcZero data on user mapped files!).  Therefore,
        //  if no one has the file cached, we cache it here to make this call cheaper.
        //
        //  Don't create the stream file if called from FsRtlSetFileSize (which sets
        //  IRP_PAGING_IO) because mm is in the process of creating a section.
        //


        if ((NewAllocationSize != Scb->Header.AllocationSize.QuadPart) &&
            (Scb->NonpagedScb->SegmentObject.DataSectionObject != NULL)) {

            FileIsCached = CcIsFileCached( FileObject );

            if (!FileIsCached &&
                !FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE ) &&
                !FlagOn( Irp->Flags, IRP_PAGING_IO )) {

                NtfsCreateInternalAttributeStream( IrpContext,
                                                   Scb,
                                                   FALSE,
                                                   &NtfsInternalUseFile[SETALLOCATIONINFO_FILE_NUMBER] );
                FileIsCached = TRUE;
            }
        }

        //
        //  If the caller is extending the allocation of resident attribute then
        //  we will force it to become non-resident.  This solves the problem of
        //  trying to keep the allocation and file sizes in sync with only one
        //  number to use in the attribute header.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

            NtfsInitializeAttributeContext( &AttrContext );
            CleanupAttrContext = TRUE;

            NtfsLookupAttributeForScb( IrpContext,
                                       Scb,
                                       NULL,
                                       &AttrContext );

            //
            //  Convert if extending.
            //

            if (NewAllocationSize > Scb->Header.AllocationSize.QuadPart) {

                NtfsConvertToNonresident( IrpContext,
                                          Fcb,
                                          NtfsFoundAttribute( &AttrContext ),
                                          (BOOLEAN) (!FileIsCached),
                                          &AttrContext );

                NonResidentPath = TRUE;

            //
            //  Otherwise the allocation is shrinking or staying the same.
            //

            } else {

                NewAllocationSize = QuadAlign( (ULONG) NewAllocationSize );

                //
                //  If the allocation size doesn't change, we are done.
                //

                if ((ULONG) NewAllocationSize == Scb->Header.AllocationSize.LowPart) {

                    try_return( NOTHING );
                }

                //
                //  We are sometimes called by MM during a create section, so
                //  for right now the best way we have of detecting a create
                //  section is IRP_PAGING_IO being set, as in FsRtlSetFileSizes.
                //

                NtfsChangeAttributeValue( IrpContext,
                                          Fcb,
                                          (ULONG) NewAllocationSize,
                                          NULL,
                                          0,
                                          TRUE,
                                          FALSE,
                                          (BOOLEAN) (!FileIsCached),
                                          FALSE,
                                          &AttrContext );

                NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                CleanupAttrContext = FALSE;

                //
                //  Post this to the Usn journal if we are shrinking the data.
                //

                if (NewAllocationSize < Scb->Header.FileSize.QuadPart) {
                    NtfsPostUsnChange( IrpContext, Scb, USN_REASON_DATA_TRUNCATION );
                }

                //
                //  Now update the sizes in the Scb.
                //

                Scb->Header.AllocationSize.LowPart =
                Scb->Header.FileSize.LowPart =
                Scb->Header.ValidDataLength.LowPart = (ULONG) NewAllocationSize;

                Scb->TotalAllocated = NewAllocationSize;

#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb )) {
                    FsRtlLogSyscacheEvent( Scb, SCE_VDL_CHANGE, SCE_FLAG_SET_ALLOC, 0, 0, NewAllocationSize );
                }
#endif
            }

        } else {

            NonResidentPath = TRUE;
        }

        //
        //  We now test if we need to modify the non-resident allocation.  We will
        //  do this in two cases.  Either we're converting from resident in
        //  two steps or the attribute was initially non-resident.
        //

        if (NonResidentPath) {

            NewAllocationSize = LlClustersFromBytes( Scb->Vcb, NewAllocationSize );
            NewAllocationSize = LlBytesFromClusters( Scb->Vcb, NewAllocationSize );


            DebugTrace( 0, Dbg, ("NewAllocationSize -> %016I64x\n", NewAllocationSize) );

            //
            //  Now if the file allocation is being increased then we need to only add allocation
            //  to the attribute
            //

            if (Scb->Header.AllocationSize.QuadPart < NewAllocationSize) {

                //
                //  Add either the true disk allocation or add a hole for a sparse
                //  file.
                //

                if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

                    //
                    //  If there is a compression unit then we could be in the process of
                    //  decompressing.  Allocate precisely in this case because we don't
                    //  want to leave any holes.  Specifically the user may have truncated
                    //  the file and is now regenerating it yet the clear compression operation
                    //  has already passed this point in the file (and dropped all resources).
                    //  No one will go back to cleanup the allocation if we leave a hole now.
                    //

                    if (!FlagOn( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED ) &&
                        (Scb->CompressionUnit != 0)) {

                        ASSERT( FlagOn( Scb->ScbState, SCB_STATE_REALLOCATE_ON_WRITE ));
                        NewAllocationSize += Scb->CompressionUnit - 1;
                        ((PLARGE_INTEGER) &NewAllocationSize)->LowPart &= ~(Scb->CompressionUnit - 1);
                    }

                    NtfsAddAllocation( IrpContext,
                                       FileObject,
                                       Scb,
                                       LlClustersFromBytes( Scb->Vcb, Scb->Header.AllocationSize.QuadPart ),
                                       LlClustersFromBytes( Scb->Vcb, NewAllocationSize - Scb->Header.AllocationSize.QuadPart ),
                                       FALSE,
                                       NULL );

                } else {

                    NtfsAddSparseAllocation( IrpContext,
                                             FileObject,
                                             Scb,
                                             Scb->Header.AllocationSize.QuadPart,
                                             NewAllocationSize - Scb->Header.AllocationSize.QuadPart );
                }

                //
                //  Set the truncate on close flag.
                //

                SetFlag( Scb->ScbState, SCB_STATE_TRUNCATE_ON_CLOSE );

            //
            //  Otherwise delete the allocation as requested.
            //

            } else if (Scb->Header.AllocationSize.QuadPart > NewAllocationSize) {

                //
                //  Check on possible cleanup if the file will shrink.
                //

                if (NewAllocationSize < Scb->Header.FileSize.QuadPart) {

                    //
                    //  If we will shrink FileSize, then write the UsnJournal.
                    //

                    NtfsPostUsnChange( IrpContext, Scb, USN_REASON_DATA_TRUNCATION );

                    Scb->Header.FileSize.QuadPart = NewAllocationSize;

                    //
                    //  Do we need to shrink any of the valid data length values.
                    //

                    if (NewAllocationSize < Scb->Header.ValidDataLength.QuadPart) {

                        Scb->Header.ValidDataLength.QuadPart = NewAllocationSize;
#ifdef SYSCACHE_DEBUG
                        if (ScbIsBeingLogged( Scb )) {
                            FsRtlLogSyscacheEvent( Scb, SCE_VDL_CHANGE, SCE_FLAG_SET_ALLOC, 0, 0, NewAllocationSize );
                        }
#endif
                    }

                    if (NewAllocationSize < Scb->ValidDataToDisk) {

                        Scb->ValidDataToDisk = NewAllocationSize;

#ifdef SYSCACHE_DEBUG
                        if (ScbIsBeingLogged( Scb )) {
                            FsRtlLogSyscacheEvent( Scb, SCE_VDD_CHANGE, SCE_FLAG_SET_ALLOC, 0, 0, NewAllocationSize );
                        }
#endif
                    }
                }

                NtfsDeleteAllocation( IrpContext,
                                      FileObject,
                                      Scb,
                                      LlClustersFromBytes( Scb->Vcb, NewAllocationSize ),
                                      MAXLONGLONG,
                                      TRUE,
                                      TRUE );

            }

            //
            //  If this is the paging file then guarantee that the Mcb is fully loaded.
            //

            if (FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )) {

                NtfsPreloadAllocation( IrpContext,
                                       Scb,
                                       0,
                                       LlClustersFromBytes( Scb->Vcb, Scb->Header.AllocationSize.QuadPart ));
            }
        }

    try_exit:

        if (PrevAllocationSize != Scb->Header.AllocationSize.QuadPart) {

            //
            //  Mark this file object as modified and with a size change in order to capture
            //  all of the changes to the Fcb.
            //

            SetFlag( FileObject->Flags, FO_FILE_SIZE_CHANGED );
            ClearCheckSizeFlag = TRUE;
        }

        //
        //  Always set the file as modified to force a time stamp change.
        //

        if (ARGUMENT_PRESENT( Ccb )) {

            SetFlag( Ccb->Flags,
                     (CCB_FLAG_UPDATE_LAST_MODIFY |
                      CCB_FLAG_UPDATE_LAST_CHANGE |
                      CCB_FLAG_SET_ARCHIVE) );

        } else {

            SetFlag( FileObject->Flags, FO_FILE_MODIFIED );
        }

        //
        //  Now capture any file size changes in this file object back to the Fcb.
        //

        NtfsUpdateScbFromFileObject( IrpContext, FileObject, Scb, TRUE );

        //
        //  Update the standard information if required.
        //

        if (FlagOn( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO )) {

            NtfsUpdateStandardInformation( IrpContext, Fcb );
        }

        ClearFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

        //
        //  We know we wrote out any changes to the file size above so clear the
        //  flag in the Scb to check the attribute size.  This will save us from doing
        //  this unnecessarily at cleanup.
        //

        if (ClearCheckSizeFlag) {

            ClearFlag( Scb->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE );
        }

        NtfsCheckpointCurrentTransaction( IrpContext );

        //
        //  Update duplicated information.
        //

        NtfsUpdateFileDupInfo( IrpContext, Fcb, Ccb );

        //
        //  Update the cache manager if needed.
        //

        if (CcIsFileCached( FileObject )) {
            //
            //  We want to checkpoint the transaction if there is one active.
            //

            if (IrpContext->TransactionId != 0) {

                NtfsCheckpointCurrentTransaction( IrpContext );
            }

#ifdef SYSCACHE_DEBUG
            if (ScbIsBeingLogged( Scb )) {
                FsRtlLogSyscacheEvent( Scb, SCE_CC_SET_SIZE, SCE_FLAG_SET_ALLOC, 0, Scb->Header.ValidDataLength.QuadPart, Scb->Header.FileSize.QuadPart );
            }
#endif

            //
            //  Truncate either stream that is cached.
            //  Cachemap better exist or we will skip notifying cc and not potentially.
            //  purge the data section
            //

            ASSERT( FileObject->SectionObjectPointer->SharedCacheMap != NULL );
            NtfsSetBothCacheSizes( FileObject,
                                   (PCC_FILE_SIZES)&Scb->Header.AllocationSize,
                                   Scb );

            //
            //  Clear out the write mask on truncates to zero.
            //

#ifdef SYSCACHE
            if ((Scb->Header.FileSize.QuadPart == 0) && FlagOn(Scb->ScbState, SCB_STATE_SYSCACHE_FILE) &&
                (Scb->ScbType.Data.WriteMask != NULL)) {
                RtlZeroMemory(Scb->ScbType.Data.WriteMask, (((0x2000000) / PAGE_SIZE) / 8));
            }
#endif

            //
            //  Now cleanup the stream we created if there are no more user
            //  handles.
            //

            if ((Scb->CleanupCount == 0) && (Scb->FileObject != NULL)) {
                NtfsDeleteInternalAttributeStream( Scb, FALSE, FALSE );
            }
        }

        Status = STATUS_SUCCESS;

    } finally {

        DebugUnwind( NtfsSetAllocation );

        if (CleanupAttrContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }

        //
        //  And return to our caller
        //

        DebugTrace( -1, Dbg, ("NtfsSetAllocationInfo -> %08lx\n", Status) );
    }

    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsSetEndOfFileInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PCCB Ccb OPTIONAL,
    IN BOOLEAN VcbAcquired
    )

/*++

Routine Description:

    This routine performs the set end of file information function.

Arguments:

    FileObject - Supplies the file object being processed

    Irp - Supplies the Irp being processed

    Scb - Supplies the Scb for the file/directory being modified

    Ccb - Supplies the Ccb for this operation.  Will always be present if the
        Vcb is acquired.  Otherwise we must test for it.

    AcquiredVcb - Indicates if this request has acquired the Vcb, meaning
        do we have duplicate information to update.

Return Value:

    NTSTATUS - The status of the operation

--*/

{
    NTSTATUS Status;
    PFCB Fcb = Scb->Fcb;
    BOOLEAN NonResidentPath = TRUE;
    BOOLEAN FileSizeChanged = FALSE;
    BOOLEAN FileIsCached = FALSE;

    LONGLONG NewFileSize;
    LONGLONG NewValidDataLength;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_IRP( Irp );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsSetEndOfFileInfo...\n") );

    if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

        NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );
    }

    //
    //  Get the new file size and whether this is coming from the lazy writer.
    //

    NewFileSize = ((PFILE_END_OF_FILE_INFORMATION)Irp->AssociatedIrp.SystemBuffer)->EndOfFile.QuadPart;

    //
    //  If this attribute has been 'deleted' then return immediately.
    //

    if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )) {

        DebugTrace( -1, Dbg, ("NtfsEndOfFileInfo:  No work to do\n") );

        return STATUS_SUCCESS;
    }

    //
    //  Save the current state of the Scb.
    //

    NtfsSnapshotScb( IrpContext, Scb );

    //
    //  If we are called from the cache manager then we want to update the valid data
    //  length if necessary and also perform an update duplicate call if the Vcb
    //  is held.
    //

    if (IoGetCurrentIrpStackLocation(Irp)->Parameters.SetFile.AdvanceOnly) {

#ifdef SYSCACHE_DEBUG
        if (ScbIsBeingLogged( Scb ) && (Scb->CleanupCount == 0)) {
            FsRtlLogSyscacheEvent( Scb, SCE_WRITE, SCE_FLAG_SET_EOF, Scb->Header.ValidDataLength.QuadPart, Scb->ValidDataToDisk, NewFileSize );
        }
#endif

        //
        //  We only have work to do if the file is nonresident.
        //

        if (!FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

            //
            //  Assume this is the lazy writer and set NewValidDataLength to
            //  NewFileSize (NtfsWriteFileSizes never goes beyond what's in the
            //  Fcb).
            //

            NewValidDataLength = NewFileSize;
            NewFileSize = Scb->Header.FileSize.QuadPart;

            //
            //  If this file has a compressed stream, then we have to possibly
            //  reduce NewValidDataLength according to dirty data in the opposite
            //  stream (compressed or uncompressed) from which we were called.
            //

#ifdef  COMPRESS_ON_WIRE
            if (Scb->NonpagedScb->SegmentObjectC.SharedCacheMap != NULL) {

                LARGE_INTEGER FlushedValidData;
                PSECTION_OBJECT_POINTERS SegmentObject = &Scb->NonpagedScb->SegmentObject;

                //
                //  Assume the other stream is not cached.
                //

                FlushedValidData.QuadPart = NewValidDataLength;

                //
                //  If we were called for the compressed stream, then get flushed number
                //  for the normal stream.
                //

                if (FileObject->SectionObjectPointer != SegmentObject) {
                    if (SegmentObject->SharedCacheMap != NULL) {
                        FlushedValidData = CcGetFlushedValidData( SegmentObject, FALSE );
                    }

                //
                //  Else if we were called for the normal stream, get the flushed number
                //  for the compressed stream.
                //

                } else {
                    FlushedValidData = CcGetFlushedValidData( &Scb->NonpagedScb->SegmentObjectC, FALSE );
                }

                if (NewValidDataLength > FlushedValidData.QuadPart) {
                    NewValidDataLength = FlushedValidData.QuadPart;
                }
            }
#endif
            //
            //  NtfsWriteFileSizes will trim the new vdl down to filesize if necc. for on disk updates
            //  so we only need to explicitly trim it ourselfs for cases when its really growing
            //  but cc thinks its gone farther than it really has
            //  E.g in the activevacb case when its replaced cc considers the whole page dirty and
            //  advances valid data goal to the end of the page
            //
            //  3 pts protect us here - cc always trims valid data goal when we shrink so any
            //  callbacks indicate real data from this size file
            //  We inform cc of the new vdl on all unbuffered writes so eventually he will
            //  call us back to update for new disk sizes
            //  if mm and cc are active in a file we will let mm
            //  flush all pages beyond vdl. For the boundary page
            //  cc can flush it but we will move vdl fwd at that time as well
            //

            if ((Scb->Header.ValidDataLength.QuadPart < NewFileSize) &&
                (NewValidDataLength > Scb->Header.ValidDataLength.QuadPart)) {

#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb )) {
                    FsRtlLogSyscacheEvent( Scb, SCE_VDL_CHANGE, SCE_FLAG_SET_EOF, NewValidDataLength, 0, Scb->Header.ValidDataLength.QuadPart );
                }
#endif

                NewValidDataLength = Scb->Header.ValidDataLength.QuadPart;
            } //  endif advancing VDL

            //
            //  Always call writefilesizes in case on disk VDL is less than the
            //  in memory one
            //

            NtfsWriteFileSizes( IrpContext,
                                Scb,
                                &NewValidDataLength,
                                TRUE,
                                TRUE,
                                TRUE );
        }

        //
        //  If we acquired the Vcb then do the update duplicate if necessary.
        //

        if (VcbAcquired) {

            //
            //  Now capture any file size changes in this file object back to the Fcb.
            //

            NtfsUpdateScbFromFileObject( IrpContext, FileObject, Scb, TRUE );

            //
            //  Update the standard information if required.
            //

            if (FlagOn( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO )) {

                NtfsUpdateStandardInformation( IrpContext, Fcb );
                ClearFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
            }

            NtfsCheckpointCurrentTransaction( IrpContext );

            //
            //  Update duplicated information.
            //

            NtfsUpdateFileDupInfo( IrpContext, Fcb, Ccb );
        }

        //
        //  We know the file size for this Scb is now correct on disk.
        //

        NtfsAcquireFsrtlHeader( Scb );
        ClearFlag( Scb->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE );
        NtfsReleaseFsrtlHeader( Scb );

    } else {

        if (Ccb != NULL) {

            //
            //  Remember the source info flags in the Ccb.
            //

            IrpContext->SourceInfo = Ccb->UsnSourceInfo;
        }

        //
        //  Check for a valid input value for the file size.
        //

        if ((ULONGLONG)NewFileSize > MAXFILESIZE) {

            Status = STATUS_INVALID_PARAMETER;
            DebugTrace( -1, Dbg, ("NtfsSetEndOfFileInfo: Invalid file size -> %08lx\n", Status) );
            return Status;
        }

        //
        //  Do work to prepare for shrinking file if necc.
        //

        if (NewFileSize < Scb->Header.FileSize.QuadPart) {

            Status = NtfsPrepareToShrinkFileSize( IrpContext, FileObject, Scb, NewFileSize );
            if (Status != STATUS_SUCCESS) {

                DebugTrace( -1, Dbg, ("NtfsSetEndOfFileInfo -> %08lx\n", Status) );
                return Status;
            }
        }

        //
        //  Check if we really are changing the file size.
        //

        if (Scb->Header.FileSize.QuadPart != NewFileSize) {

            FileSizeChanged = TRUE;

            //
            //  Post the FileSize change to the Usn Journal
            //

            NtfsPostUsnChange( IrpContext,
                               Scb,
                               ((NewFileSize > Scb->Header.FileSize.QuadPart) ?
                                 USN_REASON_DATA_EXTEND :
                                 USN_REASON_DATA_TRUNCATION) );
        }

        //
        //  It is extremely expensive to make this call on a file that is not
        //  cached, and Ntfs has suffered stack overflows in addition to massive
        //  time and disk I/O expense (CcZero data on user mapped files!).  Therefore,
        //  if no one has the file cached, we cache it here to make this call cheaper.
        //
        //  Don't create the stream file if called from FsRtlSetFileSize (which sets
        //  IRP_PAGING_IO) because mm is in the process of creating a section.
        //

        if (FileSizeChanged &&
            (Scb->NonpagedScb->SegmentObject.DataSectionObject != NULL)) {

            FileIsCached = CcIsFileCached( FileObject );

            if (!FileIsCached &&
                !FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE ) &&
                !FlagOn( Irp->Flags, IRP_PAGING_IO )) {

                NtfsCreateInternalAttributeStream( IrpContext,
                                                   Scb,
                                                   FALSE,
                                                   &NtfsInternalUseFile[SETENDOFFILEINFO_FILE_NUMBER] );
                FileIsCached = TRUE;
            }
        }

        //
        //  If this is a resident attribute we will try to keep it resident.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

            ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
            PFILE_RECORD_SEGMENT_HEADER FileRecord;

            if (FileSizeChanged) {

                //
                //  If the new file size is larger than a file record then convert
                //  to non-resident and use the non-resident code below.  Otherwise
                //  call ChangeAttributeValue which may also convert to nonresident.
                //

                NtfsInitializeAttributeContext( &AttrContext );

                try {

                    NtfsLookupAttributeForScb( IrpContext,
                                               Scb,
                                               NULL,
                                               &AttrContext );

                    //
                    //  If we are growing out of the file record then force the non-resident
                    //  path.  We especially need this for sparse files to make sure it
                    //  stays either fully allocated or fully deallocated.  QuadAlign the new
                    //  size to handle the close boundary cases.
                    //

                    FileRecord = NtfsContainingFileRecord( &AttrContext );

                    ASSERT( FileRecord->FirstFreeByte > Scb->Header.FileSize.LowPart );

                    if ((FileRecord->FirstFreeByte - Scb->Header.FileSize.QuadPart + QuadAlign( NewFileSize )) >=
                        Scb->Vcb->BytesPerFileRecordSegment) {

                        NtfsConvertToNonresident( IrpContext,
                                                  Fcb,
                                                  NtfsFoundAttribute( &AttrContext ),
                                                  (BOOLEAN) (!FileIsCached),
                                                  &AttrContext );

                    } else {

                        ULONG AttributeOffset;

                        //
                        //  We are sometimes called by MM during a create section, so
                        //  for right now the best way we have of detecting a create
                        //  section is IRP_PAGING_IO being set, as in FsRtlSetFileSizes.
                        //

                        if ((ULONG) NewFileSize > Scb->Header.FileSize.LowPart) {

                            AttributeOffset = Scb->Header.ValidDataLength.LowPart;

                        } else {

                            AttributeOffset = (ULONG) NewFileSize;
                        }

                        NtfsChangeAttributeValue( IrpContext,
                                                  Fcb,
                                                  AttributeOffset,
                                                  NULL,
                                                  (ULONG) NewFileSize - AttributeOffset,
                                                  TRUE,
                                                  FALSE,
                                                  (BOOLEAN) (!FileIsCached),
                                                  FALSE,
                                                  &AttrContext );

                        Scb->Header.FileSize.QuadPart = NewFileSize;

                        //
                        //  If the file went non-resident, then the allocation size in
                        //  the Scb is correct.  Otherwise we quad-align the new file size.
                        //

                        if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                            Scb->Header.AllocationSize.LowPart = QuadAlign( Scb->Header.FileSize.LowPart );
                            Scb->Header.ValidDataLength.QuadPart = NewFileSize;
                            Scb->TotalAllocated = Scb->Header.AllocationSize.QuadPart;

#ifdef SYSCACHE_DEBUG
                            if (ScbIsBeingLogged( Scb )) {
                                FsRtlLogSyscacheEvent( Scb, SCE_VDL_CHANGE, SCE_FLAG_SET_EOF, 0, 0, NewFileSize );
                            }
#endif

                        }

                        NonResidentPath = FALSE;
                    }

                } finally {

                    NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                }

            } else {

                NonResidentPath = FALSE;
            }
        }

        //
        //  We now test if we need to modify the non-resident Eof.  We will
        //  do this in two cases.  Either we're converting from resident in
        //  two steps or the attribute was initially non-resident.  We can ignore
        //  this step if not changing the file size.
        //

        if (NonResidentPath) {

            //
            //  Now determine where the new file size lines up with the
            //  current file layout.  The two cases we need to consider are
            //  where the new file size is less than the current file size and
            //  valid data length, in which case we need to shrink them.
            //  Or we new file size is greater than the current allocation,
            //  in which case we need to extend the allocation to match the
            //  new file size.
            //

            if (NewFileSize > Scb->Header.AllocationSize.QuadPart) {

                DebugTrace( 0, Dbg, ("Adding allocation to file\n") );

                //
                //  Add either the true disk allocation or add a hole for a sparse
                //  file.
                //

                if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

                    LONGLONG NewAllocationSize = NewFileSize;

                    //
                    //  If there is a compression unit then we could be in the process of
                    //  decompressing.  Allocate precisely in this case because we don't
                    //  want to leave any holes.  Specifically the user may have truncated
                    //  the file and is now regenerating it yet the clear compression operation
                    //  has already passed this point in the file (and dropped all resources).
                    //  No one will go back to cleanup the allocation if we leave a hole now.
                    //

                    if (!FlagOn( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED ) &&
                        (Scb->CompressionUnit != 0)) {

                        ASSERT( FlagOn( Scb->ScbState, SCB_STATE_REALLOCATE_ON_WRITE ));
                        NewAllocationSize += Scb->CompressionUnit - 1;
                        ((PLARGE_INTEGER) &NewAllocationSize)->LowPart &= ~(Scb->CompressionUnit - 1);
                    }

                    NtfsAddAllocation( IrpContext,
                                       FileObject,
                                       Scb,
                                       LlClustersFromBytes( Scb->Vcb, Scb->Header.AllocationSize.QuadPart ),
                                       LlClustersFromBytes(Scb->Vcb, (NewAllocationSize - Scb->Header.AllocationSize.QuadPart)),
                                       FALSE,
                                       NULL );

                } else {

                    NtfsAddSparseAllocation( IrpContext,
                                             FileObject,
                                             Scb,
                                             Scb->Header.AllocationSize.QuadPart,
                                             NewFileSize - Scb->Header.AllocationSize.QuadPart );
                }

            } else {

                LONGLONG DeletePoint;

                //
                //  If this is a sparse file we actually want to leave a hole between
                //  the end of the file and the allocation size.
                //

                if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE ) &&
                    (NewFileSize < Scb->Header.FileSize.QuadPart) &&
                    ((DeletePoint = NewFileSize + Scb->CompressionUnit - 1) < Scb->Header.AllocationSize.QuadPart)) {

                    ((PLARGE_INTEGER) &DeletePoint)->LowPart &= ~(Scb->CompressionUnit - 1);

                    ASSERT( DeletePoint < Scb->Header.AllocationSize.QuadPart );

                    NtfsDeleteAllocation( IrpContext,
                                          FileObject,
                                          Scb,
                                          LlClustersFromBytesTruncate( Scb->Vcb, DeletePoint ),
                                          LlClustersFromBytesTruncate( Scb->Vcb, Scb->Header.AllocationSize.QuadPart ) - 1,
                                          TRUE,
                                          TRUE );
                }

                SetFlag( Scb->ScbState, SCB_STATE_TRUNCATE_ON_CLOSE );
            }

            NewValidDataLength = Scb->Header.ValidDataLength.QuadPart;

            //
            //  If this is a paging file, let the whole thing be valid
            //  so that we don't end up zeroing pages!  Also, make sure
            //  we really write this into the file.
            //

            if (FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )) {

                VCN AllocatedVcns;

                AllocatedVcns = Int64ShraMod32(Scb->Header.AllocationSize.QuadPart, Scb->Vcb->ClusterShift);

                Scb->Header.ValidDataLength.QuadPart =
                NewValidDataLength = NewFileSize;

                //
                //  If this is the paging file then guarantee that the Mcb is fully loaded.
                //

                NtfsPreloadAllocation( IrpContext, Scb, 0, AllocatedVcns );
            }

            if (NewFileSize < NewValidDataLength) {

                Scb->Header.ValidDataLength.QuadPart =
                NewValidDataLength = NewFileSize;

#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb )) {
                   FsRtlLogSyscacheEvent( Scb, SCE_VDL_CHANGE, SCE_FLAG_SET_EOF, 0, 0, NewFileSize );
                }
#endif
            }

            if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) &&
                (NewFileSize < Scb->ValidDataToDisk)) {

                Scb->ValidDataToDisk = NewFileSize;

#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb )) {
                    FsRtlLogSyscacheEvent( Scb, SCE_VDD_CHANGE, SCE_FLAG_SET_EOF, 0, 0, NewFileSize );
                }
#endif

            }

            Scb->Header.FileSize.QuadPart = NewFileSize;

            //
            //  Call our common routine to modify the file sizes.  We are now
            //  done with NewFileSize and NewValidDataLength, and we have
            //  PagingIo + main exclusive (so no one can be working on this Scb).
            //  NtfsWriteFileSizes uses the sizes in the Scb, and this is the
            //  one place where in Ntfs where we wish to use a different value
            //  for ValidDataLength.  Therefore, we save the current ValidData
            //  and plug it with our desired value and restore on return.
            //

            ASSERT( NewFileSize == Scb->Header.FileSize.QuadPart );
            ASSERT( NewValidDataLength == Scb->Header.ValidDataLength.QuadPart );
            NtfsVerifySizes( &Scb->Header );
            NtfsWriteFileSizes( IrpContext,
                                Scb,
                                &Scb->Header.ValidDataLength.QuadPart,
                                BooleanFlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE ),
                                TRUE,
                                TRUE );
        }

        //
        //  If the file size changed then mark this file object as having changed the size.
        //

        if (FileSizeChanged) {

            SetFlag( FileObject->Flags, FO_FILE_SIZE_CHANGED );
        }

        //
        //  Always mark the data stream as modified.
        //

        if (ARGUMENT_PRESENT( Ccb )) {

            SetFlag( Ccb->Flags,
                     (CCB_FLAG_UPDATE_LAST_MODIFY |
                      CCB_FLAG_UPDATE_LAST_CHANGE |
                      CCB_FLAG_SET_ARCHIVE) );

        } else {

            SetFlag( FileObject->Flags, FO_FILE_MODIFIED );
        }

        //
        //  Now capture any file size changes in this file object back to the Fcb.
        //

        NtfsUpdateScbFromFileObject( IrpContext, FileObject, Scb, VcbAcquired );

        //
        //  Update the standard information if required.
        //

        if (FlagOn( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO )) {

            NtfsUpdateStandardInformation( IrpContext, Fcb );
            ClearFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
        }

        //
        //  We know we wrote out any changes to the file size above so clear the
        //  flag in the Scb to check the attribute size.  This will save us from doing
        //  this unnecessarily at cleanup.
        //

        if (FileSizeChanged) {

            ClearFlag( Scb->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE );
        }

        NtfsCheckpointCurrentTransaction( IrpContext );

        //
        //  Update duplicated information.
        //

        if (VcbAcquired) {

            NtfsUpdateFileDupInfo( IrpContext, Fcb, Ccb );
        }

        if (CcIsFileCached( FileObject )) {

            //
            //  We want to checkpoint the transaction if there is one active.
            //

            if (IrpContext->TransactionId != 0) {

                NtfsCheckpointCurrentTransaction( IrpContext );
            }

#ifdef SYSCACHE_DEBUG
            if (ScbIsBeingLogged( Scb )) {
                FsRtlLogSyscacheEvent( Scb, SCE_CC_SET_SIZE, SCE_FLAG_SET_EOF, 0, Scb->Header.ValidDataLength.QuadPart, Scb->Header.FileSize.QuadPart );
            }
#endif

            //
            //  Cache map should still exist or we won't purge the data section
            //

            ASSERT( FileObject->SectionObjectPointer->SharedCacheMap != NULL );
            NtfsSetBothCacheSizes( FileObject,
                                   (PCC_FILE_SIZES)&Scb->Header.AllocationSize,
                                   Scb );

            //
            //  Clear out the write mask on truncates to zero.
            //

#ifdef SYSCACHE
            if ((Scb->Header.FileSize.QuadPart == 0) && FlagOn(Scb->ScbState, SCB_STATE_SYSCACHE_FILE) &&
                (Scb->ScbType.Data.WriteMask != NULL)) {
                RtlZeroMemory(Scb->ScbType.Data.WriteMask, (((0x2000000) / PAGE_SIZE) / 8));
            }
#endif

            //
            //  Now cleanup the stream we created if there are no more user
            //  handles.
            //

            if ((Scb->CleanupCount == 0) && (Scb->FileObject != NULL)) {
                NtfsDeleteInternalAttributeStream( Scb, FALSE, FALSE );
            }
        }
    }

    Status = STATUS_SUCCESS;

    DebugTrace( -1, Dbg, ("NtfsSetEndOfFileInfo -> %08lx\n", Status) );

    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsSetValidDataLengthInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine performs the set valid data length information function.
    Notes: we interact with CC but do not initiate caching ourselves. This is
    only possible if the file is not mapped so we can do purges on the section.

    Also the filetype check that restricts this to fileopens only is done in the
    CommonSetInformation call.

Arguments:

    FileObject - Supplies the file object being processed

    Irp - Supplies the Irp being processed

    Scb - Supplies the Scb for the file/directory being modified

    Ccb - Ccb attached to the file. Contains cached privileges of opener


Return Value:

    NTSTATUS - The status of the operation

--*/

{
    LONGLONG NewValidDataLength;
    LONGLONG NewFileSize;
    PIO_STACK_LOCATION IrpSp;

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  User must have manage volume privilege to explicitly tweak the VDL
    //

    if (!FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS)) {
        return STATUS_PRIVILEGE_NOT_HELD;
    }

    //
    //  We don't support this call for compressed or sparse files
    //

    if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE)) {
        return STATUS_INVALID_PARAMETER;
    }

    NewValidDataLength = ((PFILE_VALID_DATA_LENGTH_INFORMATION)Irp->AssociatedIrp.SystemBuffer)->ValidDataLength.QuadPart;
    NewFileSize = Scb->Header.FileSize.QuadPart;

    //
    //  VDL can only move forward
    //

    if ((NewValidDataLength < Scb->Header.ValidDataLength.QuadPart) ||
        (NewValidDataLength > NewFileSize) ||
        (NewValidDataLength < 0)) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  We only have work to do if the file is nonresident.
    //

    if (!FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

        //
        //  We can't change the VDL without being able to purge. This should stay
        //  constant since we own everything exclusive
        //

        if (!MmCanFileBeTruncated( &Scb->NonpagedScb->SegmentObject, &Li0 )) {
            return STATUS_USER_MAPPED_FILE;
        }

        NtfsSnapshotScb( IrpContext, Scb );

        //
        //  Flush old data out and purge the cache so we can see new data
        //

        NtfsFlushAndPurgeScb( IrpContext, Scb, NULL );

        //
        //  update the scb
        //

        Scb->Header.ValidDataLength.QuadPart = NewValidDataLength;
        if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {
            Scb->ValidDataToDisk = NewValidDataLength;
        }

#ifdef SYSCACHE_DEBUG
        if (ScbIsBeingLogged( Scb )) {
            FsRtlLogSyscacheEvent( Scb, SCE_VDL_CHANGE, SCE_FLAG_SET_VDL, 0, 0, NewValidDataLength );
        }
#endif

        ASSERT( IrpContext->CleanupStructure != NULL );
        NtfsWriteFileSizes( IrpContext,
                            Scb,
                            &NewValidDataLength,
                            TRUE,
                            TRUE,
                            TRUE );

        //
        //  Now capture any file size changes in this file object back to the Fcb.
        //

        NtfsUpdateScbFromFileObject( IrpContext, IrpSp->FileObject, Scb, FALSE );

        //
        //  Inform CC of the new values
        //

        NtfsSetBothCacheSizes( IrpSp->FileObject,
                               (PCC_FILE_SIZES)&Scb->Header.AllocationSize,
                               Scb );

        //
        //  We know the file size for this Scb is now correct on disk.
        //

        NtfsAcquireFsrtlHeader( Scb );
        ClearFlag( Scb->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE );
        NtfsReleaseFsrtlHeader( Scb );

        //
        //  Post a usn record
        //

        NtfsPostUsnChange( IrpContext, Scb, USN_REASON_DATA_OVERWRITE );
        NtfsWriteUsnJournalChanges( IrpContext );
    }

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
NtfsCheckScbForLinkRemoval (
    IN PSCB Scb,
    OUT PSCB *BatchOplockScb,
    OUT PULONG BatchOplockCount
    )

/*++

Routine Description:

    This routine is called to check if a link to an open Scb may be
    removed for rename.  We walk through all the children and
    verify that they have no user opens.

Arguments:

    Scb - Scb whose children are to be examined.

    BatchOplockScb - Address to store Scb which may have a batch oplock.

    BatchOplockCount - Number of files which have batch oplocks on this
        pass through the directory tree.

Return Value:

    NTSTATUS - STATUS_SUCCESS if the link can be removed,
               STATUS_ACCESS_DENIED otherwise.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PSCB NextScb;
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCheckScbForLinkRemoval:  Entered\n") );

    //
    //  Initialize the batch oplock state.
    //

    *BatchOplockCount = 0;
    *BatchOplockScb = NULL;

    //
    //  If this is a directory file and we are removing a link,
    //  we need to examine its descendents.  We may not remove a link which
    //  may be an ancestor path component of any open file.
    //

    //
    //  First look for any descendents with a non-zero unclean count.
    //

    NextScb = Scb;

    while ((NextScb = NtfsGetNextScb( NextScb, Scb )) != NULL) {

        //
        //  Stop if there are open handles.  If there is a batch oplock on
        //  this file then we will try to break the batch oplock.  In this
        //  pass we will just count the number of files with batch oplocks
        //  and remember the first one we encounter.
        //
        //  Skip over the Scb's with a zero cleanup count as we would otherwise
        //  fail this if we encounter them.
        //

        if (NextScb->CleanupCount != 0) {

            if ((NextScb->AttributeTypeCode == $DATA) &&
                (NextScb->Header.NodeTypeCode == NTFS_NTC_SCB_DATA) &&
                FsRtlCurrentBatchOplock( &NextScb->ScbType.Data.Oplock )) {

                *BatchOplockCount += 1;

                if (*BatchOplockScb == NULL) {

                    *BatchOplockScb = NextScb;
                    Status = STATUS_PENDING;
                }

            } else {

                Status = STATUS_ACCESS_DENIED;
                DebugTrace( 0, Dbg, ("NtfsCheckScbForLinkRemoval:  Directory to rename has open children\n") );

                break;
            }
        }
    }

    //
    //
    //  We know there are no opens below this point.  We will remove any prefix
    //  entries later.
    //

    DebugTrace( -1, Dbg, ("NtfsCheckScbForLinkRemoval:  Exit -> %08lx\n") );

    return Status;
}


//
//  Local support routine
//

VOID
NtfsFindTargetElements (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT TargetFileObject,
    IN PSCB ParentScb,
    OUT PSCB *TargetParentScb,
    OUT PUNICODE_STRING FullTargetFileName,
    OUT PUNICODE_STRING TargetFileName
    )

/*++

Routine Description:

    This routine determines the target directory for the rename and the
    target link name.  If these is a target file object, we use that to
    find the target.  Otherwise the target is the same directory as the
    source.

Arguments:

    TargetFileObject - This is the file object which describes the target
        for the link operation.

    ParentScb - This is current directory for the link.

    TargetParentScb - This is the location to store the parent of the target.

    FullTargetFileName - This is a pointer to a unicode string which will point
        to the name from the root.  We clear this if there is no full name
        available.

    TargetFileName - This is a pointer to a unicode string which will point to
        the target name on exit.

Return Value:

    BOOLEAN - TRUE if there is no work to do, FALSE otherwise.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFindTargetElements:  Entered\n") );

    //
    //  We need to find the target parent directory, target file and target
    //  name for the new link.  These three pieces of information allow
    //  us to see if the link already exists.
    //
    //  Check if we have a file object for the target.
    //

    if (TargetFileObject != NULL) {

        PVCB TargetVcb;
        PFCB TargetFcb;
        PCCB TargetCcb;

        USHORT PreviousLength;
        USHORT LastFileNameOffset;

        //
        //  The target directory is given by the TargetFileObject.
        //  The name for the link is contained in the TargetFileObject.
        //
        //  The target must be a user directory and must be on the
        //  current Vcb.
        //

        if ((NtfsDecodeFileObject( IrpContext,
                                   TargetFileObject,
                                   &TargetVcb,
                                   &TargetFcb,
                                   TargetParentScb,
                                   &TargetCcb,
                                   TRUE ) != UserDirectoryOpen) ||

            ((ParentScb != NULL) &&
             (TargetVcb != ParentScb->Vcb))) {

            DebugTrace( -1, Dbg, ("NtfsFindTargetElements:  Target file object is invalid\n") );

            NtfsRaiseStatus( IrpContext, STATUS_INVALID_PARAMETER, NULL, NULL );
        }

        //
        //  Temporarily set the file name to point to the full buffer.
        //

        LastFileNameOffset = PreviousLength = TargetFileObject->FileName.Length;

        TargetFileObject->FileName.Length = TargetFileObject->FileName.MaximumLength;

        *FullTargetFileName = TargetFileObject->FileName;

        //
        //  If the first character at the final component is a backslash, move the
        //  offset ahead by 2.
        //

        if (TargetFileObject->FileName.Buffer[LastFileNameOffset / sizeof( WCHAR )] == L'\\') {

            LastFileNameOffset += sizeof( WCHAR );
        }

        NtfsBuildLastFileName( IrpContext,
                               TargetFileObject,
                               LastFileNameOffset,
                               TargetFileName );

        //
        //  Restore the file object length.
        //

        TargetFileObject->FileName.Length = PreviousLength;

    //
    //  Otherwise the rename occurs in the current directory.  The directory
    //  is the parent of this Fcb, the name is stored in a Rename buffer.
    //

    } else {

        PFILE_RENAME_INFORMATION Buffer;

        Buffer = IrpContext->OriginatingIrp->AssociatedIrp.SystemBuffer;

        *TargetParentScb = ParentScb;

        TargetFileName->MaximumLength =
        TargetFileName->Length = (USHORT)Buffer->FileNameLength;
        TargetFileName->Buffer = (PWSTR) &Buffer->FileName;

        FullTargetFileName->Length =
        FullTargetFileName->MaximumLength = 0;
        FullTargetFileName->Buffer = NULL;
    }

    DebugTrace( -1, Dbg, ("NtfsFindTargetElements:  Exit\n") );

    return;
}


BOOLEAN
NtfsCheckLinkForNewLink (
    IN PFCB Fcb,
    IN PFILE_NAME FileNameAttr,
    IN FILE_REFERENCE FileReference,
    IN PUNICODE_STRING NewLinkName,
    OUT PULONG LinkFlags
    )

/*++

Routine Description:

    This routine checks the source and target directories and files.
    It determines whether the target link needs to be removed and
    whether the target link spans the same parent and file as the
    source link.  This routine may determine that there
    is absolutely no work remaining for this link operation.  This is true
    if the desired link already exists.

Arguments:

    Fcb - This is the Fcb for the link which is being renamed.

    FileNameAttr - This is the file name attribute for the matching link
        on the disk.

    FileReference - This is the file reference for the matching link found.

    NewLinkName - This is the name to use for the rename.

    LinkFlags - Address of flags field to store whether the source link and target
        link traverse the same directory and file.

Return Value:

    BOOLEAN - TRUE if there is no work to do, FALSE otherwise.

--*/

{
    BOOLEAN NoWorkToDo = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCheckLinkForNewLink:  Entered\n") );

    //
    //  Check if the file references match.
    //

    if (NtfsEqualMftRef( &FileReference, &Fcb->FileReference )) {

        SetFlag( *LinkFlags, TRAVERSE_MATCH );
    }

    //
    //  We need to determine if we have an exact match for the link names.
    //

    if (RtlEqualMemory( FileNameAttr->FileName,
                        NewLinkName->Buffer,
                        NewLinkName->Length )) {

        SetFlag( *LinkFlags, EXACT_CASE_MATCH );
    }

    //
    //  We now have to decide whether we will be removing the target link.
    //  The following conditions must hold for us to preserve the target link.
    //
    //      1 - The target link connects the same directory to the same file.
    //
    //      2 - The names are an exact case match.
    //

    if (FlagOn( *LinkFlags, TRAVERSE_MATCH | EXACT_CASE_MATCH ) == (TRAVERSE_MATCH | EXACT_CASE_MATCH)) {

        NoWorkToDo = TRUE;
    }

    DebugTrace( -1, Dbg, ("NtfsCheckLinkForNewLink:  Exit\n") );

    return NoWorkToDo;
}


//
//  Local support routine
//

VOID
NtfsCheckLinkForRename (
    IN PFCB Fcb,
    IN PLCB Lcb,
    IN PFILE_NAME FileNameAttr,
    IN FILE_REFERENCE FileReference,
    IN PUNICODE_STRING TargetFileName,
    IN BOOLEAN IgnoreCase,
    IN OUT PULONG RenameFlags
    )

/*++

Routine Description:

    This routine checks the source and target directories and files.
    It determines whether the target link needs to be removed and
    whether the target link spans the same parent and file as the
    source link.  We also determine if the new link name is an exact case
    match for the existing link name.  The booleans indicating which links
    to remove or add have already been initialized to the default values.

Arguments:

    Fcb - This is the Fcb for the link which is being renamed.

    Lcb - This is the link being renamed.

    FileNameAttr - This is the file name attribute for the matching link
        on the disk.

    FileReference - This is the file reference for the matching link found.

    TargetFileName - This is the name to use for the rename.

    IgnoreCase - Indicates if the user is case sensitive.

    RenameFlags - Flag field which indicates which updates to perform.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCheckLinkForRename:  Entered\n") );

    //
    //  Check if the file references match.
    //

    if (NtfsEqualMftRef( &FileReference, &Fcb->FileReference )) {

        SetFlag( *RenameFlags, TRAVERSE_MATCH );
    }

    //
    //  We need to determine if we have an exact match between the desired name
    //  and the current name for the link.  We already know the length are the same.
    //

    if (RtlEqualMemory( FileNameAttr->FileName,
                        TargetFileName->Buffer,
                        TargetFileName->Length )) {

        SetFlag( *RenameFlags, EXACT_CASE_MATCH );
    }

    //
    //  If this is a traverse match (meaning the desired link and the link
    //  being replaced connect the same directory to the same file) we check
    //  if we can leave the link on the file.
    //
    //  At the end of the rename, there must be an Ntfs name or hard link
    //  which matches the target name exactly.
    //

    if (FlagOn( *RenameFlags, TRAVERSE_MATCH )) {

        //
        //  If we are in the same directory and are renaming between Ntfs and Dos
        //  links then don't remove the link twice.
        //

        if (!FlagOn( *RenameFlags, MOVE_TO_NEW_DIR )) {

            //
            //  If We are renaming from between primary links then don't remove the
            //  source.  It is removed with the target.
            //

            if ((Lcb->FileNameAttr->Flags != 0) && (FileNameAttr->Flags != 0)) {

                ClearFlag( *RenameFlags, ACTIVELY_REMOVE_SOURCE_LINK );
                SetFlag( *RenameFlags, OVERWRITE_SOURCE_LINK );

                //
                //  If this is an exact case match then don't remove the source at all.
                //

                if (FlagOn( *RenameFlags, EXACT_CASE_MATCH )) {

                    ClearFlag( *RenameFlags, REMOVE_SOURCE_LINK );
                }

            //
            //  If we are changing the case of a link only, then don't remove the link twice.
            //

            } else if (RtlEqualMemory( Lcb->ExactCaseLink.LinkName.Buffer,
                                       FileNameAttr->FileName,
                                       Lcb->ExactCaseLink.LinkName.Length )) {

                SetFlag( *RenameFlags, OVERWRITE_SOURCE_LINK );
                ClearFlag( *RenameFlags, ACTIVELY_REMOVE_SOURCE_LINK );
            }
        }

        //
        //  If the names match exactly we can reuse the links if we don't have a
        //  conflict with the name flags.
        //

        if (FlagOn( *RenameFlags, EXACT_CASE_MATCH ) &&
            (FlagOn( *RenameFlags, OVERWRITE_SOURCE_LINK ) ||
             !IgnoreCase ||
             !FlagOn( Lcb->FileNameAttr->Flags, FILE_NAME_DOS | FILE_NAME_NTFS ))) {

            //
            //  Otherwise we are renaming hard links or this is a Posix opener.
            //

            ClearFlag( *RenameFlags, REMOVE_TARGET_LINK | ADD_TARGET_LINK );
        }
    }

    //
    //  The non-traverse case is already initialized.
    //

    DebugTrace( -1, Dbg, ("NtfsCheckLinkForRename:  Exit\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsCleanupLinkForRemoval (
    IN PFCB PreviousFcb,
    IN PSCB ParentScb,
    IN BOOLEAN ExistingFcb
    )

/*++

Routine Description:

    This routine does the cleanup on a file/link which is the target
    of either a rename or set link operation.

Arguments:

    PreviousFcb - Address to store the Fcb for the file whose link is
        being removed.

    ParentScb - This is the parent for the link being removed.

    ExistingFcb - Address to store whether this Fcb already existed.

Return Value:

    None

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCleanupLinkForRemoval:  Entered\n") );

    //
    //  If the Fcb existed, we remove all of the prefix entries for it which
    //  belong to the parent we are given.
    //

    if (ExistingFcb) {

        PLIST_ENTRY Links;
        PLCB ThisLcb;

        for (Links = PreviousFcb->LcbQueue.Flink;
             Links != &PreviousFcb->LcbQueue;
             Links = Links->Flink ) {

            ThisLcb = CONTAINING_RECORD( Links,
                                         LCB,
                                         FcbLinks );

            if (ThisLcb->Scb == ParentScb) {

                ASSERT( NtfsIsExclusiveScb( ThisLcb->Scb ) );
                NtfsRemovePrefix( ThisLcb );
            }

            //
            //  Remove any hash table entries for this Lcb.
            //

            NtfsRemoveHashEntriesForLcb( ThisLcb );

        } // End for each Lcb of Fcb
    }

    DebugTrace( -1, Dbg, ("NtfsCleanupLinkForRemoval:  Exit\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsUpdateFcbFromLinkRemoval (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB Fcb,
    IN UNICODE_STRING FileName,
    IN UCHAR FileNameFlags
    )

/*++

Routine Description:

    This routine is called to update the in-memory part of a link which
    has been removed from a file.  We find the Lcb's for the links and
    mark them as deleted and removed.

Arguments:

    ParentScb - Scb for the directory the was removed from.

    ParentScb - This is the Scb for the new directory.

    Fcb - The Fcb for the file whose link is being renamed.

    FileName - File name for link being removed.

    FileNameFlags - File name flags for link being removed.

Return Value:

    None.

--*/

{
    PLCB Lcb;
    PLCB SplitPrimaryLcb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsUpdateFcbFromLinkRemoval:  Entered\n") );

    SplitPrimaryLcb = NULL;

    //
    //  Find the Lcb for the link which was removed.
    //

    Lcb = NtfsCreateLcb( IrpContext,
                         ParentScb,
                         Fcb,
                         FileName,
                         FileNameFlags,
                         NULL );

    //
    //  If this is a split primary, we need to find the name flags for
    //  the Lcb.
    //

    if (LcbSplitPrimaryLink( Lcb )) {

        SplitPrimaryLcb = NtfsLookupLcbByFlags( Fcb,
                                                (UCHAR) LcbSplitPrimaryComplement( Lcb ));
    }

    //
    //  Mark any Lcb's we have as deleted and removed.
    //

    SetFlag( Lcb->LcbState, (LCB_STATE_DELETE_ON_CLOSE | LCB_STATE_LINK_IS_GONE) );

    if (SplitPrimaryLcb) {

        SetFlag( SplitPrimaryLcb->LcbState,
                 (LCB_STATE_DELETE_ON_CLOSE | LCB_STATE_LINK_IS_GONE) );
    }

    DebugTrace( -1, Dbg, ("NtfsUpdateFcbFromLinkRemoval:  Exit\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsReplaceLinkInDir (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB Fcb,
    IN PUNICODE_STRING NewLinkName,
    IN UCHAR FileNameFlags,
    IN PUNICODE_STRING PrevLinkName,
    IN UCHAR PrevLinkNameFlags
    )

/*++

Routine Description:

    This routine is called to create the in-memory part of a link in a new
    directory.

Arguments:

    ParentScb - Scb for the directory the link is being created in.

    Fcb - The Fcb for the file whose link is being created.

    NewLinkName - Name for the new component.

    FileNameFlags - These are the flags to use for the new link.

    PrevLinkName - File name for link being removed.

    PrevLinkNameFlags - File name flags for link being removed.

Return Value:

    None.

--*/

{
    PLCB TraverseLcb;
    PLCB SplitPrimaryLcb = NULL;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCreateLinkInNewDir:  Entered\n") );

    SplitPrimaryLcb = NULL;

    //
    //  Build the name for the traverse link and call strucsup to
    //  give us an Lcb.
    //

    TraverseLcb = NtfsCreateLcb( IrpContext,
                                 ParentScb,
                                 Fcb,
                                 *PrevLinkName,
                                 PrevLinkNameFlags,
                                 NULL );

    //
    //  If this is a split primary, we need to find the name flags for
    //  the Lcb.
    //

    if (LcbSplitPrimaryLink( TraverseLcb )) {

        SplitPrimaryLcb = NtfsLookupLcbByFlags( Fcb,
                                                (UCHAR) LcbSplitPrimaryComplement( TraverseLcb ));
    }

    //
    //  We now need only to rename and combine any existing Lcb's.
    //

    NtfsRenameLcb( IrpContext,
                   TraverseLcb,
                   NewLinkName,
                   FileNameFlags,
                   FALSE );

    if (SplitPrimaryLcb != NULL) {

        NtfsRenameLcb( IrpContext,
                       SplitPrimaryLcb,
                       NewLinkName,
                       FileNameFlags,
                       FALSE );

        NtfsCombineLcbs( IrpContext,
                         TraverseLcb,
                         SplitPrimaryLcb );

        NtfsDeleteLcb( IrpContext, &SplitPrimaryLcb );
    }

    DebugTrace( -1, Dbg, ("NtfsCreateLinkInNewDir:  Exit\n") );

    return;
}


//
//  Local support routine.
//

VOID
NtfsMoveLinkToNewDir (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING NewFullLinkName,
    IN PUNICODE_STRING NewLinkName,
    IN UCHAR NewLinkNameFlags,
    IN PSCB ParentScb,
    IN PFCB Fcb,
    IN OUT PLCB Lcb,
    IN ULONG RenameFlags,
    IN PUNICODE_STRING PrevLinkName,
    IN UCHAR PrevLinkNameFlags
    )

/*++

Routine Description:

    This routine is called to move the in-memory part of a link to a new
    directory.  We move the link involved and its primary link partner if
    it exists.

Arguments:

    NewFullLinkName - This is the full name for the new link from the root.

    NewLinkName - This is the last component name only.

    NewLinkNameFlags - These are the flags to use for the new link.

    ParentScb - This is the Scb for the new directory.

    Fcb - The Fcb for the file whose link is being renamed.

    Lcb - This is the Lcb which is the base of the rename.

    RenameFlags - Flag field indicating the type of operations to perform
        on file name links.

    PrevLinkName - File name for link being removed.  Only meaningful here
        if this is a traverse match and there are remaining Lcbs for the
        previous link.

    PrevLinkNameFlags - File name flags for link being removed.

Return Value:

    None.

--*/

{
    PLCB TraverseLcb = NULL;
    PLCB SplitPrimaryLcb = NULL;
    BOOLEAN SplitSourceLcb = FALSE;

    UNICODE_STRING TargetDirectoryName;
    UNICODE_STRING SplitLinkName;

    UCHAR SplitLinkNameFlags = NewLinkNameFlags;
    BOOLEAN Found;

    PFILE_NAME FileName;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    BOOLEAN CleanupAttrContext = FALSE;

    ULONG Pass;
    BOOLEAN CheckBufferOnly;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsMoveLinkToNewDir:  Entered\n") );

    //
    //  Use a try-finally to perform cleanup.
    //

    try {

        //
        //  Construct the unicode string for the parent directory.
        //

        TargetDirectoryName = *NewFullLinkName;
        TargetDirectoryName.Length -= NewLinkName->Length;

        if (TargetDirectoryName.Length > sizeof( WCHAR )) {

            TargetDirectoryName.Length -= sizeof( WCHAR );
        }

        //  If the link being moved is a split primary link, we need to find
        //  its other half.
        //

        if (LcbSplitPrimaryLink( Lcb )) {

            SplitPrimaryLcb = NtfsLookupLcbByFlags( Fcb,
                                                    (UCHAR) LcbSplitPrimaryComplement( Lcb ));
            SplitSourceLcb = TRUE;

            //
            //  If we found an existing Lcb we have to update its name as well.  We may be
            //  able to use the new name used for the Lcb passed in.  However we must check
            //  that we don't overwrite a DOS name with an NTFS only name.
            //

            if (SplitPrimaryLcb &&
                (SplitPrimaryLcb->FileNameAttr->Flags == FILE_NAME_DOS) &&
                (NewLinkNameFlags == FILE_NAME_NTFS)) {

                //
                //  Lookup the dos only name on disk.
                //

                NtfsInitializeAttributeContext( &AttrContext );
                CleanupAttrContext = TRUE;

                //
                //  Walk through the names for this entry.  There better
                //  be one which is not a DOS-only name.
                //

                Found = NtfsLookupAttributeByCode( IrpContext,
                                                   Fcb,
                                                   &Fcb->FileReference,
                                                   $FILE_NAME,
                                                   &AttrContext );

                while (Found) {

                    FileName = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

                    if (FileName->Flags == FILE_NAME_DOS) { break; }

                    Found = NtfsLookupNextAttributeByCode( IrpContext,
                                                           Fcb,
                                                           $FILE_NAME,
                                                           &AttrContext );
                }

                //
                //  We should have found the entry.
                //

                if (!Found) {

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                }

                //
                //  Now build the component name.
                //

                SplitLinkName.Buffer = FileName->FileName;
                SplitLinkName.MaximumLength =
                SplitLinkName.Length = FileName->FileNameLength * sizeof( WCHAR );
                SplitLinkNameFlags = FILE_NAME_DOS;

            } else {

                SplitLinkName = *NewLinkName;
            }
        }

        //
        //  If we removed or reused a traverse link, we need to check if there is
        //  an Lcb for it.
        //

        if (FlagOn( RenameFlags, REMOVE_TRAVERSE_LINK | REUSE_TRAVERSE_LINK )) {

            //
            //  Build the name for the traverse link and call strucsup to
            //  give us an Lcb.
            //

            if (FlagOn( RenameFlags, EXACT_CASE_MATCH )) {

                TraverseLcb = NtfsCreateLcb( IrpContext,
                                             ParentScb,
                                             Fcb,
                                             *NewLinkName,
                                             PrevLinkNameFlags,
                                             NULL );

            } else {

                TraverseLcb = NtfsCreateLcb( IrpContext,
                                             ParentScb,
                                             Fcb,
                                             *PrevLinkName,
                                             PrevLinkNameFlags,
                                             NULL );
            }

            if (FlagOn( RenameFlags, REMOVE_TRAVERSE_LINK )) {

                //
                //  If this is a split primary, we need to find the name flags for
                //  the Lcb.
                //

                if (LcbSplitPrimaryLink( TraverseLcb )) {

                    SplitPrimaryLcb = NtfsLookupLcbByFlags( Fcb,
                                                            (UCHAR) LcbSplitPrimaryComplement( TraverseLcb ));
                }
            }
        }

        //
        //  Now move and combine the Lcbs.  We will do this in two passes.  One will allocate buffers
        //  of sufficient size.  The other will store the names in.
        //

        Pass = 0;
        CheckBufferOnly = TRUE;
        do {

            //
            //  Start with the Lcb used for the rename.
            //

            NtfsMoveLcb( IrpContext,
                         Lcb,
                         ParentScb,
                         Fcb,
                         &TargetDirectoryName,
                         NewLinkName,
                         NewLinkNameFlags,
                         CheckBufferOnly );

            //
            //  Next do the split primary if from the source file or the target.
            //

            if (SplitPrimaryLcb && SplitSourceLcb) {

                NtfsMoveLcb( IrpContext,
                             SplitPrimaryLcb,
                             ParentScb,
                             Fcb,
                             &TargetDirectoryName,
                             &SplitLinkName,
                             SplitLinkNameFlags,
                             CheckBufferOnly );

                //
                //  If we are in the second pass then optionally combine these
                //  Lcb's and delete the split.
                //

                if ((SplitLinkNameFlags == NewLinkNameFlags) && !CheckBufferOnly) {

                    NtfsCombineLcbs( IrpContext, Lcb, SplitPrimaryLcb );
                    NtfsDeleteLcb( IrpContext, &SplitPrimaryLcb );
                }
            }

            //
            //  If we have a traverse link and are in the second pass then combine
            //  with the primary Lcb.
            //

            if (!CheckBufferOnly) {

                if (TraverseLcb != NULL) {

                    if (!FlagOn( RenameFlags, REUSE_TRAVERSE_LINK )) {

                        NtfsRenameLcb( IrpContext,
                                       TraverseLcb,
                                       NewLinkName,
                                       NewLinkNameFlags,
                                       CheckBufferOnly );

                        if (SplitPrimaryLcb && !SplitSourceLcb) {

                            NtfsRenameLcb( IrpContext,
                                           SplitPrimaryLcb,
                                           NewLinkName,
                                           NewLinkNameFlags,
                                           CheckBufferOnly );

                            //
                            //  If we are in the second pass then optionally combine these
                            //  Lcb's and delete the split.
                            //

                            if (!CheckBufferOnly) {

                                NtfsCombineLcbs( IrpContext, Lcb, SplitPrimaryLcb );
                                NtfsDeleteLcb( IrpContext, &SplitPrimaryLcb );
                            }
                        }
                    }

                    NtfsCombineLcbs( IrpContext,
                                     Lcb,
                                     TraverseLcb );

                    NtfsDeleteLcb( IrpContext, &TraverseLcb );
                }
            }

            Pass += 1;
            CheckBufferOnly = FALSE;

        } while (Pass < 2);

    } finally {

        if (CleanupAttrContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsMoveLinkToNewDir:  Exit\n") );

    return;
}


//
//  Local support routine.
//

VOID
NtfsCreateLinkInSameDir (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB Fcb,
    IN UNICODE_STRING NewLinkName,
    IN UCHAR NewFileNameFlags,
    IN UNICODE_STRING PrevLinkName,
    IN UCHAR PrevLinkNameFlags
    )

/*++

Routine Description:

    This routine is called when we are replacing a link in a single directory.
    We need to find the link being renamed and any auxilary links and
    then give them their new names.

Arguments:

    ParentScb - Scb for the directory the rename is taking place in.

    Fcb - The Fcb for the file whose link is being renamed.

    NewLinkName - This is the name to use for the new link.

    NewFileNameFlags - These are the flags to use for the new link.

    PrevLinkName - File name for link being removed.

    PrevLinkNameFlags - File name flags for link being removed.

Return Value:

    None.

--*/

{
    PLCB TraverseLcb;
    PLCB SplitPrimaryLcb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCreateLinkInSameDir:  Entered\n") );

    //
    //  Initialize our local variables.
    //

    SplitPrimaryLcb = NULL;

    TraverseLcb = NtfsCreateLcb( IrpContext,
                                 ParentScb,
                                 Fcb,
                                 PrevLinkName,
                                 PrevLinkNameFlags,
                                 NULL );

    //
    //  If this is a split primary, we need to find the name flags for
    //  the Lcb.
    //

    if (LcbSplitPrimaryLink( TraverseLcb )) {

        SplitPrimaryLcb = NtfsLookupLcbByFlags( Fcb,
                                                (UCHAR) LcbSplitPrimaryComplement( TraverseLcb ));
    }

    //
    //  We now need only to rename and combine any existing Lcb's.
    //

    NtfsRenameLcb( IrpContext,
                   TraverseLcb,
                   &NewLinkName,
                   NewFileNameFlags,
                   FALSE );

    if (SplitPrimaryLcb != NULL) {

        NtfsRenameLcb( IrpContext,
                       SplitPrimaryLcb,
                       &NewLinkName,
                       NewFileNameFlags,
                       FALSE );

        NtfsCombineLcbs( IrpContext,
                         TraverseLcb,
                         SplitPrimaryLcb );

        NtfsDeleteLcb( IrpContext, &SplitPrimaryLcb );
    }

    DebugTrace( -1, Dbg, ("NtfsCreateLinkInSameDir:  Exit\n") );

    return;
}


//
//  Local support routine.
//

VOID
NtfsRenameLinkInDir (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB Fcb,
    IN OUT PLCB Lcb,
    IN PUNICODE_STRING NewLinkName,
    IN UCHAR NewLinkNameFlags,
    IN ULONG RenameFlags,
    IN PUNICODE_STRING PrevLinkName,
    IN UCHAR PrevLinkNameFlags
    )

/*++

Routine Description:

    This routine performs the in-memory work of moving renaming a link within
    the same directory.  It will rename an existing link to the
    new name.  It also merges whatever other links need to be joined with
    this link.  This includes the complement of a primary link pair or
    an existing hard link which may be overwritten.  Merging the existing
    links has the effect of moving any of the Ccb's on the stale Links to
    the newly modified link.

Arguments:

    ParentScb - Scb for the directory the rename is taking place in.

    Fcb - The Fcb for the file whose link is being renamed.

    Lcb - This is the Lcb which is the base of the rename.

    NewLinkName - This is the name to use for the new link.

    NewLinkNameFlags - These are the flags to use for the new link.

    RenameFlags - Flag field indicating the type of operations to perform
        on the file name links.

    PrevLinkName - File name for link being removed.  Only meaningful for a traverse link.

    PrevLinkNameFlags - File name flags for link being removed.

Return Value:

    None.

--*/

{
    UNICODE_STRING SplitLinkName;
    UCHAR SplitLinkNameFlags = NewLinkNameFlags;

    PLCB TraverseLcb = NULL;
    PLCB SplitPrimaryLcb = NULL;

    PFILE_NAME FileName;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    BOOLEAN CleanupAttrContext = FALSE;
    BOOLEAN Found;

    ULONG Pass;
    BOOLEAN CheckBufferOnly;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRenameLinkInDir:  Entered\n") );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  We have the Lcb which will be our primary Lcb and the name we need
        //  to perform the rename.  If the current Lcb is a split primary link
        //  or we removed a split primary link, then we need to find any
        //  the other split link.
        //

        if (LcbSplitPrimaryLink( Lcb )) {

            SplitPrimaryLcb = NtfsLookupLcbByFlags( Fcb,
                                                    (UCHAR) LcbSplitPrimaryComplement( Lcb ));

            //
            //  If we found an existing Lcb we have to update its name as well.  We may be
            //  able to use the new name used for the Lcb passed in.  However we must check
            //  that we don't overwrite a DOS name with an NTFS only name.
            //

            if (SplitPrimaryLcb &&
                (SplitPrimaryLcb->FileNameAttr->Flags == FILE_NAME_DOS) &&
                (NewLinkNameFlags == FILE_NAME_NTFS)) {

                //
                //  Lookup the dos only name on disk.
                //

                NtfsInitializeAttributeContext( &AttrContext );
                CleanupAttrContext = TRUE;

                //
                //  Walk through the names for this entry.  There better
                //  be one which is not a DOS-only name.
                //

                Found = NtfsLookupAttributeByCode( IrpContext,
                                                   Fcb,
                                                   &Fcb->FileReference,
                                                   $FILE_NAME,
                                                   &AttrContext );

                while (Found) {

                    FileName = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

                    if (FileName->Flags == FILE_NAME_DOS) { break; }

                    Found = NtfsLookupNextAttributeByCode( IrpContext,
                                                           Fcb,
                                                           $FILE_NAME,
                                                           &AttrContext );
                }

                //
                //  We should have found the entry.
                //

                if (!Found) {

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                }

                //
                //  Now build the component name.
                //

                SplitLinkName.Buffer = FileName->FileName;
                SplitLinkName.MaximumLength =
                SplitLinkName.Length = FileName->FileNameLength * sizeof( WCHAR );
                SplitLinkNameFlags = FILE_NAME_DOS;

            } else {

                SplitLinkName = *NewLinkName;
            }
        }

        //
        //  If we used a traverse link, we need to check if there is
        //  an Lcb for it.  Ignore this for the case where we traversed to
        //  the other half of a primary link.
        //

        if (!FlagOn( RenameFlags, OVERWRITE_SOURCE_LINK ) &&
            FlagOn( RenameFlags, REMOVE_TRAVERSE_LINK | REUSE_TRAVERSE_LINK )) {

            if (FlagOn( RenameFlags, EXACT_CASE_MATCH )) {

                TraverseLcb = NtfsCreateLcb( IrpContext,
                                             ParentScb,
                                             Fcb,
                                             *NewLinkName,
                                             PrevLinkNameFlags,
                                             NULL );

            } else {

                TraverseLcb = NtfsCreateLcb( IrpContext,
                                             ParentScb,
                                             Fcb,
                                             *PrevLinkName,
                                             PrevLinkNameFlags,
                                             NULL );
            }

            if (FlagOn( RenameFlags, REMOVE_TRAVERSE_LINK )) {

                //
                //  If this is a split primary, we need to find the name flags for
                //  the Lcb.
                //

                if (LcbSplitPrimaryLink( TraverseLcb )) {

                    SplitPrimaryLcb = NtfsLookupLcbByFlags( Fcb,
                                                            (UCHAR) LcbSplitPrimaryComplement( TraverseLcb ));

                    SplitLinkName = *NewLinkName;
                }
            }
        }

        //
        //  Now move and combine the Lcbs.  We will do this in two passes.  One will allocate buffers
        //  of sufficient size.  The other will store the names in.
        //

        Pass = 0;
        CheckBufferOnly = TRUE;
        do {

            //
            //  Start with the Lcb used for the rename.
            //

            NtfsRenameLcb( IrpContext,
                           Lcb,
                           NewLinkName,
                           NewLinkNameFlags,
                           CheckBufferOnly );

            //
            //  Next do the split primary if from the source file or the target.
            //

            if (SplitPrimaryLcb) {

                NtfsRenameLcb( IrpContext,
                               SplitPrimaryLcb,
                               &SplitLinkName,
                               SplitLinkNameFlags,
                               CheckBufferOnly );

                //
                //  If we are in the second pass then optionally combine these
                //  Lcb's and delete the split.
                //

                if (!CheckBufferOnly && (SplitLinkNameFlags == NewLinkNameFlags)) {

                    NtfsCombineLcbs( IrpContext, Lcb, SplitPrimaryLcb );
                    NtfsDeleteLcb( IrpContext, &SplitPrimaryLcb );
                }
            }

            //
            //  If we have a traverse link and are in the second pass then combine
            //  with the primary Lcb.
            //

            if (!CheckBufferOnly) {

                if (TraverseLcb != NULL) {

                    if (!FlagOn( RenameFlags, REUSE_TRAVERSE_LINK )) {

                        NtfsRenameLcb( IrpContext,
                                       TraverseLcb,
                                       NewLinkName,
                                       NewLinkNameFlags,
                                       CheckBufferOnly );
                    }

                    NtfsCombineLcbs( IrpContext,
                                     Lcb,
                                     TraverseLcb );

                    NtfsDeleteLcb( IrpContext, &TraverseLcb );
                }
            }

            Pass += 1;
            CheckBufferOnly = FALSE;

        } while (Pass < 2);

    } finally {

        if (CleanupAttrContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }

        DebugTrace( -1, Dbg, ("NtfsRenameLinkInDir:  Exit\n") );
    }

    return;
}


//
//  Local support routine
//

LONG
NtfsFileInfoExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    )

/*++

Routine Description:

    Exception filter for errors during cleanup.  We want to raise if this is
    a retryable condition or fatal error, plow on as best we can if not.

Arguments:

    IrpContext  - IrpContext

    ExceptionPointer - Pointer to the exception context.

    Status - Address to store the error status.

Return Value:

    Exception status - EXCEPTION_CONTINUE_SEARCH if we want to raise to another handler,
        EXCEPTION_EXECUTE_HANDLER if we plan to proceed on.

--*/

{
    NTSTATUS Status = ExceptionPointer->ExceptionRecord->ExceptionCode;

    //
    //  For now break if we catch corruption errors on both free and checked
    //  TODO:  Remove this before we ship
    //

    if (NtfsBreakOnCorrupt &&
        ((Status == STATUS_FILE_CORRUPT_ERROR) ||
         (Status == STATUS_DISK_CORRUPT_ERROR))) {

        if (*KdDebuggerEnabled) {
            DbgPrint("*******************************************\n");
            DbgPrint("NTFS detected corruption on your volume\n");
            DbgPrint("IrpContext=0x%08x, VCB=0x%08x\n",IrpContext,IrpContext->Vcb);
            DbgPrint("Send email to NTFSDEV\n");
            DbgPrint("*******************************************\n");
            DbgBreakPoint();
        }
    }

    if (!FsRtlIsNtstatusExpected( Status )) {
        return EXCEPTION_CONTINUE_SEARCH;
    } else {
        return EXCEPTION_EXECUTE_HANDLER;
    }

    UNREFERENCED_PARAMETER( IrpContext );
}


//
//  Local support routine
//

VOID
NtfsUpdateFileDupInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb OPTIONAL
    )

/*++

Routine Description:

    This routine updates the duplicate information for a file for calls
    to set allocation or EOF on the main data stream.  It is in a separate routine
    so we don't have to put a try-except in the main path.

    We will overlook any expected errors in this path.  If we get any errors we
    will simply leave this update to be performed at some other time.

    We are guaranteed that the current transaction has been checkpointed before this
    routine is called.  We will look to see if the MftScb is on the exclusive list
    for this IrpContext and release it if so.  This is to prevent a deadlock when
    we attempt to acquire the parent of this file.

Arguments:

    Fcb - This is the Fcb to update.

    Ccb - If specified, this is the Ccb for the caller making the call.

Return Value:

    None.

--*/

{
    PLCB Lcb = NULL;
    PSCB ParentScb = NULL;
    ULONG FilterMatch;

    PLIST_ENTRY Links;
    PFCB NextFcb;
    PFCB UnlockFcb = NULL;

    PAGED_CODE();

    ASSERT( IrpContext->TransactionId == 0 );

    //
    //  Check if there is an Lcb in the Ccb.
    //

    if (ARGUMENT_PRESENT( Ccb )) {

        Lcb = Ccb->Lcb;
    }

    //
    //  Use a try-except to catch any errors.
    //

    try {

        //
        //  Check that we don't own the Mft Scb.
        //

        if (Fcb->Vcb->MftScb != NULL) {

            for (Links = IrpContext->ExclusiveFcbList.Flink;
                 Links != &IrpContext->ExclusiveFcbList;
                 Links = Links->Flink) {

                ULONG Count;

                NextFcb = (PFCB) CONTAINING_RECORD( Links,
                                                    FCB,
                                                    ExclusiveFcbLinks );

                //
                //  If this is the Fcb for the Mft then remove it from the list.
                //

                if (NextFcb == Fcb->Vcb->MftScb->Fcb) {

                    //
                    //  Free the snapshots for the Fcb and release the Fcb enough times
                    //  to remove it from the list.
                    //

                    NtfsFreeSnapshotsForFcb( IrpContext, NextFcb );

                    Count = NextFcb->BaseExclusiveCount;

                    while (Count--) {

                        NtfsReleaseFcb( IrpContext, NextFcb );
                    }

                    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_MFT );

                    break;
                }
            }
        }

        //
        //  Check that we don't own the quota table Scb.
        //

        if (Fcb->Vcb->QuotaTableScb != NULL) {

            for (Links = IrpContext->ExclusiveFcbList.Flink;
                 Links != &IrpContext->ExclusiveFcbList;
                 Links = Links->Flink) {

                ULONG Count;

                NextFcb = (PFCB) CONTAINING_RECORD( Links,
                                                    FCB,
                                                    ExclusiveFcbLinks );

                //
                //  If this is the Fcb for the Quota table then remove
                //  it from the list.
                //

                if (NextFcb == Fcb->Vcb->QuotaTableScb->Fcb) {

                    //
                    //  Free the snapshots for the Fcb and release the Fcb enough times
                    //  to remove it from the list.
                    //

                    NtfsFreeSnapshotsForFcb( IrpContext, NextFcb );

                    Count = NextFcb->BaseExclusiveCount;

                    while (Count--) {

                        NtfsReleaseFcb( IrpContext, NextFcb );
                    }

                    break;
                }
            }
        }

        //
        //  Go through and free any Scb's in the queue of shared Scb's
        //  for transactions.
        //

        if (IrpContext->SharedScb != NULL) {

            NtfsReleaseSharedResources( IrpContext );
        }

        NtfsPrepareForUpdateDuplicate( IrpContext, Fcb, &Lcb, &ParentScb, TRUE );
        NtfsUpdateDuplicateInfo( IrpContext, Fcb, Lcb, ParentScb );

        //
        //  Use a try-finally to guarantee we unlock the Fcb we might lock.
        //

        try {

            //
            //  If there is no Ccb then look for one in the Lcb we just got.
            //

            if (!ARGUMENT_PRESENT( Ccb ) &&
                ARGUMENT_PRESENT( Lcb )) {

                PLIST_ENTRY Links;
                PCCB NextCcb;

                Links = Lcb->CcbQueue.Flink;

                while (Links != &Lcb->CcbQueue) {

                    NextCcb = CONTAINING_RECORD( Links, CCB, LcbLinks );

                    NtfsLockFcb( IrpContext, NextCcb->Lcb->Fcb );
                    if (!FlagOn( NextCcb->Flags, CCB_FLAG_CLOSE | CCB_FLAG_OPEN_BY_FILE_ID )) {

                        Ccb= NextCcb;
                        UnlockFcb = NextCcb->Lcb->Fcb;
                        break;
                    }

                    NtfsUnlockFcb( IrpContext, NextCcb->Lcb->Fcb );
                    Links = Links->Flink;
                }
            }

            //
            //  Now perform the dir notify call if there is a Ccb and this is not an
            //  open by FileId.
            //

            if (ARGUMENT_PRESENT( Ccb ) &&
                (Fcb->Vcb->NotifyCount != 0) &&
                (ParentScb != NULL) &&
                !FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID )) {

                FilterMatch = NtfsBuildDirNotifyFilter( IrpContext,
                                                        Fcb->InfoFlags | Lcb->InfoFlags );

                if (FilterMatch != 0) {

                    NtfsReportDirNotify( IrpContext,
                                         Fcb->Vcb,
                                         &Ccb->FullFileName,
                                         Ccb->LastFileNameOffset,
                                         NULL,
                                         ((FlagOn( Ccb->Flags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                                           (Ccb->Lcb != NULL) &&
                                           (Ccb->Lcb->Scb->ScbType.Index.NormalizedName.Length != 0)) ?
                                          &Ccb->Lcb->Scb->ScbType.Index.NormalizedName :
                                          NULL),
                                         FilterMatch,
                                         FILE_ACTION_MODIFIED,
                                         ParentScb->Fcb );
                }
            }

        } finally {

            if (UnlockFcb != NULL) {

                NtfsUnlockFcb( IrpContext, UnlockFcb );
            }
        }

        NtfsUpdateLcbDuplicateInfo( Fcb, Lcb );
        Fcb->InfoFlags = 0;

    } except(NtfsFileInfoExceptionFilter( IrpContext, GetExceptionInformation() )) {

        NtfsMinimumExceptionProcessing( IrpContext );
    }

    return;
}


//
//  Local support routine
//

NTSTATUS
NtfsStreamRename (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PFCB Fcb,
    IN PSCB Scb,
    IN PCCB Ccb,
    IN BOOLEAN ReplaceIfExists,
    IN PUNICODE_STRING NewStreamName
    )

/*++

Routine Description:

    This routine performs a stream rename within a single Fcb.

Arguments:

    IrpContext - Context of the call

    FileObject - File object being used

    Fcb - Fcb of file/directory

    Scb - Stream being renamed.  The parent Fcb is acquired exclusively.

    Ccb - Handle used to perform the rename.  Look here for usn source information.

    ReplaceIfExists - TRUE => overwrite an existing stream

    NewStreamName - name of new stream

Return Value:

    NTSTATUS of the operation.

--*/

{
    NTFS_NAME_DESCRIPTOR Name;
    BOOLEAN FoundIllegalCharacter;
    PSCB TargetScb = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    ATTRIBUTE_TYPE_CODE TypeCode;
    BOOLEAN EmptyFile;
    BOOLEAN NamesSwapped = FALSE;

    PSCB RestoreTargetScb = NULL;
    ULONG TargetScbCompressionUnit;
    USHORT TargetScbAttributeFlags;
    UCHAR TargetScbCompressionUnitShift;
    LONGLONG OldValidDataLengthOnDisk;

    DebugDoit( int Count = 0 );

    PAGED_CODE( );

    DebugTrace( +1, Dbg, (  "NtfsStreamRename\n"
                            "  IrpContext     %x\n"
                            "  Scb            %x\n"
                            "  ReplaceIf      %x\n"
                            "  NewStreamName '%Z'\n",
                            IrpContext, Scb, ReplaceIfExists, NewStreamName ));

    //
    //  Take a snapshot if one doesn't exist because we'll be calling writefilesizes
    //

    NtfsSnapshotScb( IrpContext, Scb );

    //
    //  Capture the ccb source information.
    //

    if (Ccb != NULL) {

        IrpContext->SourceInfo = Ccb->UsnSourceInfo;
    }

    NtfsInitializeAttributeContext( &Context );

    try {

        //
        //  Validate name is just :stream:type.  No file name is specified and
        //  at least a stream or type must be specified.
        //

        RtlZeroMemory( &Name, sizeof( Name ));

        if (!NtfsParseName( *NewStreamName, FALSE, &FoundIllegalCharacter, &Name )
            || FlagOn( Name.FieldsPresent, FILE_NAME_PRESENT_FLAG )
            || (!FlagOn( Name.FieldsPresent, ATTRIBUTE_NAME_PRESENT_FLAG ) &&
                !FlagOn( Name.FieldsPresent, ATTRIBUTE_TYPE_PRESENT_FLAG ))
            || Name.AttributeName.Length > NTFS_MAX_ATTR_NAME_LEN * sizeof( WCHAR )
            ) {

            DebugTrace( 0, Dbg, ("Name is illegal\n"));
            Status = STATUS_INVALID_PARAMETER;
            leave;
        }

        DebugTrace( 0, Dbg, (" Fields: %x\n"
                             " AttributeName %x %x/%x\n",
                             Name.FieldsPresent,
                             Name.AttributeName.Buffer,
                             Name.AttributeName.Length,
                             Name.AttributeName.MaximumLength ));

        //
        //  Find out the attribute type specified
        //

        if (FlagOn( Name.FieldsPresent, ATTRIBUTE_TYPE_PRESENT_FLAG )) {

            NtfsUpcaseName ( IrpContext->Vcb->UpcaseTable,
                             IrpContext->Vcb->UpcaseTableSize,
                             &Name.AttributeType );
            TypeCode = NtfsGetAttributeTypeCode( IrpContext->Vcb, &Name.AttributeType );

        } else {

            TypeCode = Scb->AttributeTypeCode;
        }

        if (TypeCode != Scb->AttributeTypeCode) {
            DebugTrace( 0, Dbg, ("Attribute types don't match %x - %x\n", Scb->AttributeTypeCode, TypeCode));
            Status = STATUS_OBJECT_TYPE_MISMATCH;
            leave;
        }

        //
        //  Verify that the source stream is $DATA
        //

        if (Scb->AttributeTypeCode != $DATA) {
            DebugTrace( 0, Dbg, ("Type code is illegal\n"));
            Status = STATUS_INVALID_PARAMETER;
            leave;
        }

        //
        //  Just to be non-orthogonal, we disallow renaming to default data stream
        //  on directories
        //

        if (TypeCode == $DATA &&
            Name.AttributeName.Length == 0 &&
            IsDirectory( &(Scb->Fcb->Info) )) {
            DebugTrace( 0, Dbg, ("Cannot rename directory stream to ::$Data\n") );
            Status = STATUS_INVALID_PARAMETER;
            leave;
        }


        //
        //  We have a valid source stream and a valid target name.  Take the short cut
        //  if the names match.  Yes, you could argue about sharing violation, or
        //  renaming to non-empty streams.  We just claim success and let it go.
        //

        if (NtfsAreNamesEqual( IrpContext->Vcb->UpcaseTable,
                               &Scb->AttributeName, &Name.AttributeName,
                               TRUE )) {
            DebugTrace( 0, Dbg, ("Names are the same\n"));
            Status = STATUS_SUCCESS;
            leave;
        }

        //
        //  Open / Create the target stream and validate ReplaceIfExists.
        //

        Status = NtOfsCreateAttribute( IrpContext,
                                       Fcb,
                                       Name.AttributeName,
                                       ReplaceIfExists ? CREATE_OR_OPEN : CREATE_NEW,
                                       FALSE,
                                       &TargetScb );

        if (!NT_SUCCESS( Status )) {
            DebugTrace( 0, Dbg, ("Unable to create target stream\n"));
            leave;
        }

        if (TargetScb == Scb) {
            DebugTrace( 0, Dbg, ("Somehow, you've got the same Scb\n"));
            Status = STATUS_SUCCESS;
            leave;
        }

        //
        //  Verify that the target Scb is not in use nor has any allocation
        //  or data.
        //

        NtfsAcquireFsrtlHeader( TargetScb );
        EmptyFile = TargetScb->Header.AllocationSize.QuadPart == 0;
        NtfsReleaseFsrtlHeader( TargetScb );

        if (!EmptyFile) {
            DebugTrace( 0, Dbg, ("Target has allocation\n"));
            Status = STATUS_INVALID_PARAMETER;
            leave;
        }

        if (TargetScb->CleanupCount != 0 ||
            !MmCanFileBeTruncated( FileObject->SectionObjectPointer,
                                   (PLARGE_INTEGER)&Li0 )) {
            DebugTrace( 0, Dbg, ("Target in use\n"));
            Status = STATUS_INVALID_PARAMETER;
            leave;
        }

        NtfsAcquireFsrtlHeader( Scb );
        EmptyFile = Scb->Header.AllocationSize.QuadPart == 0;
        NtfsReleaseFsrtlHeader( Scb );

        NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &Context );

        //
        //  Always force both streams to be non-resident.  Then we will never have
        //  a conflict between the Scb and attribute.  We don't want to take an
        //  empty non-resident stream and point it to a resident attribute.
        //  NOTE: we call with CreateSectionUnderWay set to true which forces
        //  the data to be flushed directly out to the new clusters. We need this
        //  because we explicitly move VDL a little later on.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

            if (NtfsIsAttributeResident( NtfsFoundAttribute( &Context ))) {
                NtfsConvertToNonresident( IrpContext,
                                          Fcb,
                                          NtfsFoundAttribute( &Context ),
                                          TRUE,
                                          &Context );
            }
        }

        //
        //  Cache the old VDL presisted to disk so we can update it in the new location
        //

        OldValidDataLengthOnDisk = NtfsFoundAttribute( &Context )->Form.Nonresident.ValidDataLength;
        NtfsCleanupAttributeContext( IrpContext, &Context );



        if (FlagOn( TargetScb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

            NtfsLookupAttributeForScb( IrpContext, TargetScb, NULL, &Context );

            if (NtfsIsAttributeResident( NtfsFoundAttribute( &Context ))) {
                NtfsConvertToNonresident( IrpContext,
                                          Fcb,
                                          NtfsFoundAttribute( &Context ),
                                          TRUE,
                                          &Context );
            }

            NtfsCleanupAttributeContext( IrpContext, &Context );
        }

        //
        //  Load all Mcb information for the source stream, we'll need it to generate the mapping.
        //

        (VOID)NtfsPreloadAllocation( IrpContext, Scb, 0, MAXLONGLONG );

        //
        //  Make sure the attribute flags on the target match that on the source.
        //

        if (TargetScb->AttributeFlags != Scb->AttributeFlags) {

            RestoreTargetScb = TargetScb;
            TargetScbCompressionUnit = TargetScb->CompressionUnit;
            TargetScbAttributeFlags = TargetScb->AttributeFlags;
            TargetScbCompressionUnitShift = TargetScb->CompressionUnitShift;

            NtfsModifyAttributeFlags( IrpContext, TargetScb, Scb->AttributeFlags );
        }

        //
        //  At this point, we have Scb to the source of
        //  the rename and a target Scb.  The Source has all its allocation loaded
        //  and the target has no allocation.  The only thing that really ties
        //  either Scb to the disk attribute is the AttributeName field.  We swap
        //  the attribute names in order to swap them on disk.
        //

        Name.FileName = TargetScb->AttributeName;
        TargetScb->AttributeName = Scb->AttributeName;
        Scb->AttributeName = Name.FileName;
        NamesSwapped = TRUE;

        //
        //  If there is data in the source attribute
        //

        if (!EmptyFile) {

            VCN AllocationClusters;

            //
            //  Now, we bring the disk image of these attributes up to date with
            //  the Mcb information. First, add the allocation to the new attribute.
            //

            NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &Context );
            AllocationClusters = LlClustersFromBytes( IrpContext->Vcb, Scb->Header.AllocationSize.QuadPart );

            //
            //  Set the original scb to the target's size (This is really the target now)
            //

            ASSERT( Scb->ScbSnapshot != NULL );
            Scb->Header.AllocationSize = TargetScb->Header.AllocationSize;

            NtfsAddAttributeAllocation( IrpContext,
                                        Scb,
                                        &Context,
                                        &Li0.QuadPart,
                                        &AllocationClusters );

            NtfsCleanupAttributeContext( IrpContext, &Context );

            //
            //  We've put the mapping into the new attribute record.  However
            //  the valid data length in the record is probably zero.  Update
            //  it to reflect the data in this stream already written to disk.
            //  Otherwise we may never update the data.
            //

            ASSERT( OldValidDataLengthOnDisk <= Scb->Header.FileSize.QuadPart );

            NtfsVerifySizes( &Scb->Header );
            NtfsWriteFileSizes( IrpContext,
                                Scb,
                                &OldValidDataLengthOnDisk,
                                TRUE,
                                TRUE,
                                TRUE );
        }

        //
        //  Next, find all occurrences of the old attribute and delete them.
        //

        NtfsLookupAttributeForScb( IrpContext, TargetScb, NULL, &Context );

        do {
            DebugDoit(
                      if (Count++ != 0) {
                          DebugTrace( 0, Dbg, ("Deleting attribute record %d\n", Count));
                      } else {
                          DebugTrace( 0, Dbg, ("%x Mcb's\n", Scb->Mcb.NtfsMcbArraySizeInUse ));
                          if (Scb->Mcb.NtfsMcbArray[0].NtfsMcbEntry != NULL) {
                              DebugTrace( 0, Dbg, ("First Mcb has %x entries\n",
                                                   Scb->Mcb.NtfsMcbArray[0].NtfsMcbEntry->LargeMcb.PairCount ));
                          }
                      }
                       );

            NtfsDeleteAttributeRecord( IrpContext,
                                       Fcb,
                                       DELETE_LOG_OPERATION |
                                        DELETE_RELEASE_FILE_RECORD,
                                       &Context );
        } while (NtfsLookupNextAttributeForScb( IrpContext, TargetScb, &Context ));

        NtfsCleanupAttributeContext( IrpContext, &Context );

        //
        //  If we are renaming a stream on a file, we must make sure that
        //  there is a default data stream still on the file.  Check the
        //  TargetScb to see if the name is for the default data stream
        //  and recreate the default data stream if we need to.
        //
        //  We rely on the type code being $DATA and there being NO buffer
        //  in the attribute type name.
        //

        if (TypeCode == $DATA && TargetScb->AttributeName.Buffer == NULL) {

            //
            //  Always create this stream non-resident in case the stream is encrypted.
            //

            NtfsAllocateAttribute( IrpContext,
                                   TargetScb,
                                   $DATA,
                                   &TargetScb->AttributeName,
                                   Scb->AttributeFlags,
                                   TRUE,
                                   TRUE,
                                   0,
                                   NULL );

        } else {
            ASSERT( !FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA ));
        }

        //
        //  Checkpoint the transaction so we know we are done
        //

        NtfsPostUsnChange( IrpContext, Fcb, USN_REASON_STREAM_CHANGE );
        NtfsCommitCurrentTransaction( IrpContext );
        RestoreTargetScb = NULL;


        //
        //  Let cleanup handle updating the standard information for the file
        //

        SetFlag( FileObject->Flags, FO_FILE_MODIFIED );

        //
        //  If either Scb or TargetScb refers to the default data stream, then
        //  bring the Ccb, Scb, and Fcb flags and counts back into sync.  This
        //  is due to the fact that all operations tied to the default data
        //  stream are believed to apply to the file as a whole and not
        //  simply to the stream.
        //

        if (FlagOn( TargetScb->ScbState, SCB_STATE_UNNAMED_DATA )) {

            //
            //  We have renamed *TO* the default data stream.  In this case we
            //  must mark all Ccb's for this stream as being CCB_FLAG_OPEN_AS_FILE
            //  and mark the Scb as the UNNAMED DATA stream
            //
            //  Also, for each Ccb that is opened with DELETE access, we
            //  adjust the Fcb->FcbDeleteFile count and CCB_FLAG_DELETE_FILE.
            //

            PCCB Ccb;

            DebugTrace( 0, Dbg, ("Renaming to default data stream\n"));
            DebugTrace( 0, Dbg, ("Scanning Ccb's.  FcbDeleteFile = %x\n", Fcb->FcbDeleteFile ));

            SetFlag( Scb->ScbState, SCB_STATE_UNNAMED_DATA );

            for (Ccb = NtfsGetFirstCcbEntry( Scb );
                 Ccb != NULL;
                 Ccb = NtfsGetNextCcbEntry( Scb, Ccb )) {

                DebugTrace( 0, Dbg, ("Ccb = %x\n", Ccb));

                //
                //  Mark Ccb as being opened for the file as a whole
                //
                SetFlag( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE );

                //
                //  If deleted access was granted, then we need
                //  to adjust the FCB delete count
                //

                if (FlagOn( Ccb->Flags, CCB_FLAG_DELETE_ACCESS )) {

                    DebugTrace( 0, Dbg, ("Found one\n" ));
                    Fcb->FcbDeleteFile++;
                    SetFlag( Ccb->Flags, CCB_FLAG_DELETE_FILE );
                }

                //
                //  If the stream was marked as delete-on-close,
                //  propagate that to the CCB
                //

                if (FlagOn( Scb->ScbState, SCB_STATE_DELETE_ON_CLOSE )) {
                    SetFlag( Ccb->Flags, CCB_FLAG_DELETE_ON_CLOSE );
                }

            }

            //
            //  Update the file size and allocation size in the Fcb Info field.
            //

            if (Fcb->Info.FileSize != Scb->Header.FileSize.QuadPart) {

                Fcb->Info.FileSize = Scb->Header.FileSize.QuadPart;
                SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_SIZE );
            }

            if (Fcb->Info.AllocatedLength != Scb->TotalAllocated) {

                Fcb->Info.AllocatedLength = Scb->TotalAllocated;
                SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_ALLOC_SIZE );
            }

            DebugTrace( 0, Dbg, ("Done Ccb's.  FcbDeleteFile = %x\n", Fcb->FcbDeleteFile ));

        } else if (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

            //
            //  We have renamed *FROM* the default data stream.  In this case we
            //  must unmark all Ccb's for this stream as being CCB_FLAG_OPEN_AS_FILE
            //
            //  Also, for each Ccb that is opened with DELETE access, we
            //  adjust the Fcb->FcbDeleteFile count and CCB_FLAG_DELETE_FILE.
            //

            PCCB Ccb;

            DebugTrace( 0, Dbg, ("Renaming from default data stream\n"));
            DebugTrace( 0, Dbg, ("Scanning Ccb's.  FcbDeleteFile = %x\n", Fcb->FcbDeleteFile ));

            ClearFlag( Scb->ScbState, SCB_STATE_UNNAMED_DATA );

            for (Ccb = NtfsGetFirstCcbEntry( Scb );
                 Ccb != NULL;
                 Ccb = NtfsGetNextCcbEntry( Scb, Ccb )) {

                DebugTrace( 0, Dbg, ("Ccb = %x\n", Ccb));

                //
                //  Unmark Ccb from representing the file as a whole.
                //

                ClearFlag( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE );

                //
                //  If deleted access was granted, then we need
                //  to unadjust the FCB delete count
                //

                if (FlagOn( Ccb->Flags, CCB_FLAG_DELETE_ACCESS )) {

                    DebugTrace( 0, Dbg, ("Found one\n" ));
                    Fcb->FcbDeleteFile--;
                    ClearFlag( Ccb->Flags, CCB_FLAG_DELETE_FILE );
                }
            }

            //
            //  Update the file size and allocation size in the Fcb Info field.
            //

            if (Fcb->Info.FileSize != 0) {

                Fcb->Info.FileSize = 0;
                SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_SIZE );
            }

            if (Fcb->Info.AllocatedLength != 0) {

                Fcb->Info.AllocatedLength = 0;
                SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_ALLOC_SIZE );
            }

            DebugTrace( 0, Dbg, ("Done Ccb's.  FcbDeleteFile = %x\n", Fcb->FcbDeleteFile ));
        }

        //
        //  Set the Scb flag to indicate that the attribute is gone.  Mark the
        //  Scb so it will never be returned.
        //

        TargetScb->ValidDataToDisk =
        TargetScb->Header.AllocationSize.QuadPart =
        TargetScb->Header.FileSize.QuadPart =
        TargetScb->Header.ValidDataLength.QuadPart = 0;

        TargetScb->AttributeTypeCode = $UNUSED;
        SetFlag( TargetScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );

    } finally {

        if (AbnormalTermination( )) {

            //
            //  Restore the names.
            //

            if (NamesSwapped) {
                Name.FileName = TargetScb->AttributeName;
                TargetScb->AttributeName = Scb->AttributeName;
                Scb->AttributeName = Name.FileName;
            }

            //
            //  Restore the Target Scb flags.
            //

            if (RestoreTargetScb) {

                RestoreTargetScb->CompressionUnit = TargetScbCompressionUnit;
                RestoreTargetScb->AttributeFlags = TargetScbAttributeFlags;
                RestoreTargetScb->CompressionUnitShift = TargetScbCompressionUnitShift;
            }
        }

        if (TargetScb != NULL) {
            NtOfsCloseAttribute( IrpContext, TargetScb );
        }

        NtfsCleanupAttributeContext( IrpContext, &Context );
        DebugTrace( -1, Dbg, ("NtfsStreamRename --> %x\n", Status) );
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsCheckTreeForBatchOplocks (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB DirectoryScb
    )

/*++

Routine Description:

    This routine walks a directory tree and looks for batch oplocks which might
    prevent the rename, link operation or short name operation from taking place.

    This routine will release the Vcb if there are batch oplocks we are waiting on the
    break for.

Arguments:

    Irp - Irp for this request.

    DirectoryScb - Scb for the root of the directory tree.

Return Value:

    NTSTATUS of the operation.  This routine can raise.

--*/

{
    NTSTATUS Status;
    PSCB BatchOplockScb;
    ULONG BatchOplockCount;

    PAGED_CODE();

    ASSERT( NtfsIsSharedVcb( DirectoryScb->Vcb ));

    Status = NtfsCheckScbForLinkRemoval( DirectoryScb, &BatchOplockScb, &BatchOplockCount );

    //
    //  If STATUS_PENDING is returned then we need to check whether
    //  to break a batch oplock.
    //

    if (Status == STATUS_PENDING) {

        //
        //  If the number of batch oplocks has grown then fail the request.
        //

        if ((Irp->IoStatus.Information != 0) &&
            (BatchOplockCount >= Irp->IoStatus.Information)) {

            Status = STATUS_ACCESS_DENIED;

        } else {

            //
            //  Remember the count of batch oplocks in the Irp and
            //  then call the oplock package.
            //

            Irp->IoStatus.Information = BatchOplockCount;

            Status = FsRtlCheckOplock( &BatchOplockScb->ScbType.Data.Oplock,
                                       Irp,
                                       IrpContext,
                                       NtfsOplockComplete,
                                       NtfsPrePostIrp );

            //
            //  If we got back success then raise CANT_WAIT to retry otherwise
            //  clean up.
            //

            if (Status == STATUS_SUCCESS) {

                NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );

            }
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\deviosup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    DevIoSup.c

Abstract:

    This module implements the low lever disk read/write support for Ntfs

Author:

    Brian Andrew    BrianAn
    Tom Miller      TomM

Revision History:

--*/

#include "NtfsProc.h"
#include <ntdskreg.h>
#include <ntddft.h>
#include <ntddvol.h>

#ifdef NTFS_RWC_DEBUG
extern BOOLEAN NtfsBreakOnConflict;
#endif

//
//  Number of pages to allocate a mdl on the stack for
//

#define NTFS_MDL_TRANSFER_PAGES 0x10

#ifdef SYSCACHE
//
//  Debug routines for syscache testing.
//

//
//  Tom's nifty Scsi Analyzer for syscache
//

#define ScsiLines (4096)
ULONG NextLine = 0;
ULONG ScsiAnal[ScsiLines][4];

VOID
CallDisk (
    PIRP_CONTEXT IrpContext,
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    IN ULONG Single
    )

{
    PIO_STACK_LOCATION IrpSp;
    PSCB Scb;
    ULONG i;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    Scb = (PSCB)IrpContext->OriginatingIrp->Tail.Overlay.OriginalFileObject->FsContext;

    if (!FlagOn(Scb->ScbState, SCB_STATE_SYSCACHE_FILE) ||
        (IrpSp->MajorFunction != IRP_MJ_WRITE)) {
        IoCallDriver( DeviceObject, Irp );
        return;
    }

    i = NextLine++;
    if (i >= ScsiLines) {
        i = 0;
        NextLine = 1;
    }

    ScsiAnal[i][0] = IrpSp->Parameters.Write.ByteOffset.LowPart;
    ScsiAnal[i][2] = IrpSp->Parameters.Write.Length;
    ScsiAnal[i][3] = *(PULONG)NtfsMapUserBuffer(Irp);
    IrpSp = IoGetNextIrpStackLocation(Irp);
    ScsiAnal[i][1] = IrpSp->Parameters.Write.ByteOffset.LowPart;

    IoCallDriver( DeviceObject, Irp );

    if (Single) {

        KeWaitForSingleObject( &IrpContext->Union.NtfsIoContext->Wait.SyncEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        ScsiAnal[i][2] += Irp->IoStatus.Status << 16;
    }


}

#endif SYSCACHE

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NTFS_BUG_CHECK_DEVIOSUP)

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DEVIOSUP)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('DFtN')

//
//  We need a special test for success, whenever we are seeing if we should
//  hot fix, because the FT driver returns one of two success codes if a read or
//  write failed to only one of the members.
//

#define FT_SUCCESS(STS) (NT_SUCCESS(STS) &&                                 \
                         ((STS) != STATUS_FT_READ_RECOVERY_FROM_BACKUP) &&  \
                         ((STS) != STATUS_FT_WRITE_RECOVERY))


//
//  Boolean to control whether we output HotFix information to the debugger.
//

#if DBG
BOOLEAN NtfsHotFixTrace = FALSE;
#define HotFixTrace(X) {if (NtfsHotFixTrace) KdPrint(X);}
#else
#define HotFixTrace(X) {NOTHING;}
#endif

//
//  Boolean to indicate whether to break on a decompress error
//

#ifdef SYSCACHE
BOOLEAN NtfsStopOnDecompressError = TRUE;
BOOLEAN VerifySyscacheData = FALSE;
#else
BOOLEAN NtfsStopOnDecompressError = FALSE;
#endif

//
//  Macro to collect the Disk IO stats.
//

#define CollectDiskIoStats(VCB,SCB,FUNCTION,COUNT) {                                           \
    PFILESYSTEM_STATISTICS FsStats = &(VCB)->Statistics[KeGetCurrentProcessorNumber()].Common; \
    ASSERT((SCB)->Fcb != NULL);                                                                \
    if (NtfsIsTypeCodeUserData( (SCB)->AttributeTypeCode ) &&                                  \
        !FlagOn( (SCB)->Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {                              \
        if ((FUNCTION) == IRP_MJ_WRITE) {                                                      \
            FsStats->UserDiskWrites += (COUNT);                                                \
        } else {                                                                               \
            FsStats->UserDiskReads += (COUNT);                                                 \
        }                                                                                      \
    } else if ((SCB) != (VCB)->LogFileScb) {                                                   \
        if ((FUNCTION) == IRP_MJ_WRITE) {                                                      \
            FsStats->MetaDataDiskWrites += (COUNT);                                            \
        } else {                                                                               \
            FsStats->MetaDataDiskReads += (COUNT);                                             \
        }                                                                                      \
    }                                                                                          \
}

//
//  Define a context for holding the context the compression state
//  for buffers.
//

typedef struct COMPRESSION_CONTEXT {

    //
    //  Pointer to allocated compression buffer, and its length
    //

    PUCHAR CompressionBuffer;
    ULONG CompressionBufferLength;

    //
    //  Saved fields from originating Irp
    //

    PMDL SavedMdl;
    PVOID SavedUserBuffer;

    //
    //  System Buffer pointer and offset in the System (user's) buffer
    //

    PVOID SystemBuffer;
    ULONG SystemBufferOffset;

    //
    //  IoRuns array in use.  This array may be extended one time
    //  in NtfsPrepareBuffers.
    //

    PIO_RUN IoRuns;
    ULONG AllocatedRuns;

    //
    //  Workspace pointer, so that cleanup can occur in the caller.
    //

    PVOID WorkSpace;

    //
    //  Write acquires the Scb.
    //

    BOOLEAN ScbAcquired;
    BOOLEAN FinishBuffersNeeded;

    //
    //  If this field is TRUE, it means the data has been copied from the
    //  system buffer to the compression buffer, and further operations,
    //  like compression, should look to the compression buffer for their
    //  source data.
    //

    BOOLEAN DataTransformed;

} COMPRESSION_CONTEXT, *PCOMPRESSION_CONTEXT;

//
//  Local support routines
//

VOID
NtfsAllocateCompressionBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ThisScb,
    IN PIRP Irp,
    IN PCOMPRESSION_CONTEXT CompressionContext,
    IN OUT PULONG CompressionBufferLength
    );

VOID
NtfsDeallocateCompressionBuffer (
    IN PIRP Irp,
    IN PCOMPRESSION_CONTEXT CompressionContext,
    IN BOOLEAN Reinitialize
    );

LONG
NtfsCompressionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    );

ULONG
NtfsPrepareBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PVBO StartingVbo,
    IN ULONG ByteCount,
    IN ULONG StreamFlags,
    IN OUT PBOOLEAN Wait,
    OUT PULONG NumberRuns,
    OUT PCOMPRESSION_CONTEXT CompressionContext
    );

NTSTATUS
NtfsFinishBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PVBO StartingVbo,
    IN ULONG ByteCount,
    IN ULONG NumberRuns,
    IN PCOMPRESSION_CONTEXT CompressionContext,
    IN ULONG StreamFlags
    );

VOID
NtfsMultipleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP MasterIrp,
    IN ULONG MultipleIrpCount,
    IN PIO_RUN IoRuns
    );

VOID
NtfsSingleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT DeviceObject,
    IN LBO StartingLbo,
    IN ULONG ByteCount,
    IN PIRP Irp,
    IN UCHAR MajorFunction
    );

VOID
NtfsWaitSync (
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
NtfsMultiAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

NTSTATUS
NtfsMultiSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

NTSTATUS
NtfsSingleAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

NTSTATUS
NtfsSingleSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

NTSTATUS
NtfsPagingFileCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MasterIrp
    );

NTSTATUS
NtfsPagingFileNoAllocCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
NtfsSingleNonAlignedSync (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN PUCHAR Buffer,
    IN VBO Vbo,
    IN LBO Lbo,
    IN ULONG ByteCount,
    IN PIRP Irp
    );

NTSTATUS
NtfsEncryptBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN VBO StartingVbo,
    IN ULONG NumberRuns,
    IN PCOMPRESSION_CONTEXT CompressionContext
    );

VOID
NtfsFixDataError (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP MasterIrp,
    IN ULONG MultipleIrpCount,
    IN PIO_RUN IoRuns
    );

VOID
NtfsPostHotFix(
    IN PIRP Irp,
    IN PLONGLONG BadVbo,
    IN LONGLONG BadLbo,
    IN ULONG ByteLength,
    IN BOOLEAN DelayIrpCompletion
    );

VOID
NtfsPerformHotFix (
    IN PIRP_CONTEXT IrpContext
    );

BOOLEAN
NtfsGetReservedBuffer (
    IN PFCB ThisFcb,
    OUT PVOID *Buffer,
    OUT PULONG Length,
    IN UCHAR Need2
    );

BOOLEAN
NtfsFreeReservedBuffer (
    IN PVOID Buffer
    );

LONG
NtfsDefragExceptionFilter (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PEXCEPTION_POINTERS ExceptionPointer,
    IN OUT PULONG DeletePendingFailureCountsLeft
    );

#ifdef ALLOC_PRAGMA
//****#pragma alloc_text(PAGE, NtfsCreateMdlAndBuffer)
//****#pragma alloc_text(PAGE, NtfsFixDataError)
//****#pragma alloc_text(PAGE, NtfsMapUserBuffer)
#pragma alloc_text(PAGE, NtfsReadFromPlex)
//****#pragma alloc_text(PAGE, NtfsMultipleAsync)
//****#pragma alloc_text(PAGE, NtfsNonCachedIo)
//****#pragma alloc_text(PAGE, NtfsPrepareBuffers)
//****#pragma alloc_text(PAGE, NtfsFinishBuffers)
//****#pragma alloc_text(PAGE, NtfsNonCachedNonAlignedIo)
//****#pragma alloc_text(PAGE, NtfsPerformHotFix)
//****#pragma alloc_text(PAGE, NtfsSingleAsync)
//****#pragma alloc_text(PAGE, NtfsSingleNonAlignedSync)
//****#pragma alloc_text(PAGE, NtfsTransformUsaBlock)
//****#pragma alloc_text(PAGE, NtfsVerifyAndRevertUsaBlock)
//****#pragma alloc_text(PAGE, NtfsVolumeDasdIo)
//****#pragma alloc_text(PAGE, NtfsWaitSync)
//****#pragma alloc_text(PAGE, NtfsWriteClusters)
#endif


INLINE
BOOLEAN
NtfsZeroEndOfBuffer(
    IN PIRP Irp,
    IN PNTFS_IO_CONTEXT Context
    )

/*++

Routine Description:

    This routine Zeros the end of an async transfer. Because the transfer is done
    in sector sized chunks there will be garbage data from the end of file size to
    the sector boundary.  If there are any errors they will stored in the IoStatus field
    of the irp

Arguments:

    Irp - Pointer to the Irp for which the buffer is to be zeroed

    Device - device which contains the vcb

    Context - io context which has the original operation bounds

Return Value:

    TRUE if successful

--*/

{
    PIO_STACK_LOCATION IrpSp;
    PDEVICE_OBJECT DeviceObject;
    PVCB Vcb;
    PVOID SystemBuffer;
    ULONG RoundedTransfer;
    UCHAR Buffer[sizeof( MDL ) + sizeof( PFN_NUMBER ) * (NTFS_MDL_TRANSFER_PAGES + 1)];
    PMDL PartialMdl = (PMDL) &Buffer;

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    DeviceObject = IrpSp->DeviceObject;

    //
    //  Zero the difference between filesize and data read if necc. on reads
    //

    if ((IrpSp->MajorFunction == IRP_MJ_READ) &&
        (Context->Wait.Async.RequestedByteCount < IrpSp->Parameters.Read.Length)) {


        Vcb = &((PVOLUME_DEVICE_OBJECT) DeviceObject)->Vcb;

        ASSERT( Vcb->NodeTypeCode == NTFS_NTC_VCB );

        RoundedTransfer = BlockAlign( Context->Wait.Async.RequestedByteCount, (LONG)Vcb->BytesPerSector );

        if (RoundedTransfer > Context->Wait.Async.RequestedByteCount) {

            MmInitializeMdl( PartialMdl, NULL, NTFS_MDL_TRANSFER_PAGES * PAGE_SIZE );
            IoBuildPartialMdl( Irp->MdlAddress, PartialMdl, Add2Ptr( MmGetMdlBaseVa( Irp->MdlAddress ), MmGetMdlByteOffset( Irp->MdlAddress ) + Context->Wait.Async.RequestedByteCount ), RoundedTransfer - Context->Wait.Async.RequestedByteCount );

            //
            //  Now map that last page
            //

            SystemBuffer = MmGetSystemAddressForMdlSafe( PartialMdl, NormalPagePriority );
            if (SystemBuffer == NULL) {
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                return FALSE;
            }

            //
            //  Zero the end of the transfer between expected size and read size. If the mdl is not
            //  on a page boundary this will all be offset by the MdlByteOffset
            //

            RtlZeroMemory( SystemBuffer, RoundedTransfer - Context->Wait.Async.RequestedByteCount );

            MmPrepareMdlForReuse( PartialMdl );
        }
    }

    return TRUE;
}


VOID
NtfsLockUserBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PIRP Irp,
    IN LOCK_OPERATION Operation,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine locks the specified buffer for the specified type of
    access.  The file system requires this routine since it does not
    ask the I/O system to lock its buffers for direct I/O.  This routine
    may only be called from the Fsd while still in the user context.

Arguments:

    Irp - Pointer to the Irp for which the buffer is to be locked.

    Operation - IoWriteAccess for read operations, or IoReadAccess for
                write operations.

    BufferLength - Length of user buffer.

Return Value:

    None

--*/

{
    PMDL Mdl = NULL;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    if (Irp->MdlAddress == NULL) {

        //
        // Allocate the Mdl, and Raise if we fail.
        //

        Mdl = IoAllocateMdl( Irp->UserBuffer, BufferLength, FALSE, FALSE, Irp );

        if (Mdl == NULL) {

            NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
        }

        //
        //  Now probe the buffer described by the Irp.  If we get an exception,
        //  deallocate the Mdl and return the appropriate "expected" status.
        //

        try {

            MmProbeAndLockPages( Mdl, Irp->RequestorMode, Operation );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            NTSTATUS Status;

            Status = GetExceptionCode();

            IoFreeMdl( Mdl );
            Irp->MdlAddress = NULL;

            NtfsRaiseStatus( IrpContext,
                             FsRtlIsNtstatusExpected(Status) ? Status : STATUS_INVALID_USER_BUFFER,
                             NULL,
                             NULL );
        }
    }

    //
    //  And return to our caller
    //

    return;
}


PVOID
NtfsMapUserBuffer (
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine conditionally maps the user buffer for the current I/O
    request in the specified mode.  If the buffer is already mapped, it
    just returns its address.

Arguments:

    Irp - Pointer to the Irp for the request.

Return Value:

    Mapped address

--*/

{
    PVOID SystemBuffer;

    //
    // If there is no Mdl, then we must be in the Fsd, and we can simply
    // return the UserBuffer field from the Irp.
    //

    if (Irp->MdlAddress == NULL) {

        return Irp->UserBuffer;

    } else {

        //
        //  MM can return NULL if there are no system ptes.
        //

        if ((SystemBuffer = MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority )) == NULL) {

            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

        return SystemBuffer;
    }
}


NTSTATUS
NtfsVolumeDasdIo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN VBO StartingVbo,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine performs the non-cached disk io for Volume Dasd, as described
    in its parameters.

Arguments:

    IrpContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    Irp - Supplies the requesting Irp.

    Vcb - Supplies the Vcb for the volume

    StartingVbo - Starting offset within the file for the operation.

    ByteCount - The lengh of the operation.

Return Value:

    The result of the Io operation.  STATUS_PENDING if this is an asynchronous
    open.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsVolumeDasdIo\n") );
    DebugTrace( 0, Dbg, ("Irp           = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, ("MajorFunction = %08lx\n", IrpContext->MajorFunction) );
    DebugTrace( 0, Dbg, ("Vcb           = %08lx\n", Vcb) );
    DebugTrace( 0, Dbg, ("StartingVbo   = %016I64x\n", StartingVbo) );
    DebugTrace( 0, Dbg, ("ByteCount     = %08lx\n", ByteCount) );

    //
    // For nonbuffered I/O, we need the buffer locked in all
    // cases.
    //
    // This call may raise.  If this call succeeds and a subsequent
    // condition is raised, the buffers are unlocked automatically
    // by the I/O system when the request is completed, via the
    // Irp->MdlAddress field.
    //

    NtfsLockUserBuffer( IrpContext,
                        Irp,
                        (IrpContext->MajorFunction == IRP_MJ_READ) ?
                        IoWriteAccess : IoReadAccess,
                        ByteCount );

    //
    //  Read the data and wait for the results
    //

    NtfsSingleAsync( IrpContext,
                     Vcb->TargetDeviceObject,
                     StartingVbo,
                     ByteCount,
                     Irp,
                     IrpContext->MajorFunction );

    if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )) {

        //
        //  We can get rid of the IrpContext now.
        //

        IrpContext->Union.NtfsIoContext = NULL;
        NtfsCleanupIrpContext( IrpContext, TRUE );

        DebugTrace( -1, Dbg, ("NtfsVolumeDasdIo -> STATUS_PENDING\n") );
        return STATUS_PENDING;
    }

    NtfsWaitSync( IrpContext );

    DebugTrace( -1, Dbg, ("NtfsVolumeDasdIo -> %08lx\n", Irp->IoStatus.Status) );

    return Irp->IoStatus.Status;
}



VOID
NtfsPagingFileIoWithNoAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN VBO StartingVbo,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine performs the non-cached disk io described in its parameters.
    This routine nevers blocks, and should only be used with the paging
    file since no completion processing is performed. This version does not allocate
    any memory so it guarantees fwd progress

Arguments:

    IrpContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    Irp - Supplies the requesting Irp.

    Scb - Supplies the file to act on.

    StartingVbo - Starting offset within the file for the operation.

    ByteCount - The lengh of the operation.

Return Value:

    None.

--*/

{
    UCHAR Buffer[sizeof( MDL ) + sizeof( PFN_NUMBER ) * (NTFS_MDL_TRANSFER_PAGES + 1)];
    PMDL PartialMdl = (PMDL) &Buffer;
    PMDL MasterMdl = Irp->MdlAddress;

    LONGLONG ThisClusterCount;
    ULONG ThisByteCount;
    LCN ThisLcn;
    LBO ThisLbo;
    VCN ThisVcn;

    PIO_STACK_LOCATION IrpSp;
    ULONG BufferOffset;

    PVCB Vcb = Scb->Vcb;

    ULONG ClusterOffset;
    VCN BeyondLastCluster;

    NTSTATUS Status;
    KEVENT Event;

    //
    //  Initialize some locals.
    //

    BufferOffset = 0;
    ClusterOffset = (ULONG) StartingVbo & Vcb->ClusterMask;
    BeyondLastCluster = LlClustersFromBytes( Vcb, StartingVbo + ByteCount );
    KeInitializeEvent( &Event, SynchronizationEvent, FALSE );
    RtlZeroMemory( Buffer, sizeof( Buffer ) );
    ThisVcn = LlClustersFromBytesTruncate( Vcb, StartingVbo );

    while (ByteCount > 0) {

        //
        //  Try to lookup the next run
        //  Paging files reads/ writes should always be correct.  If
        //  we didn't find the allocation, something bad has happened.
        //

        if (!NtfsLookupNtfsMcbEntry( &Scb->Mcb,
                                     ThisVcn,
                                     &ThisLcn,
                                     &ThisClusterCount,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL )) {;

            NtfsBugCheck( 0, 0, 0 );
        }

        //
        //  Adjust from Lcn to Lbo.
        //

        ThisLbo = LlBytesFromClusters( Vcb, ThisLcn ) + ClusterOffset;

        //
        // If next run is larger than we need, "ya get what you need".
        //

        ThisByteCount = BytesFromClusters( Vcb, (ULONG) ThisClusterCount ) - ClusterOffset;
        if (ThisVcn + ThisClusterCount >= BeyondLastCluster) {

            ThisByteCount = ByteCount;
        }

        //
        //  Now that we have properly bounded this piece of the
        //  transfer, it is time to read/write it NTFS_MDL_TRANSFER_PAGES pages at a time.
        //

        while (ThisByteCount > 0) {

            ULONG TransferSize = min( NTFS_MDL_TRANSFER_PAGES * PAGE_SIZE, ThisByteCount );

            //
            //  The partial mdl is on the stack
            //

            PartialMdl->Size = sizeof( Buffer );
            IoBuildPartialMdl( MasterMdl,
                               PartialMdl,
                               Add2Ptr( Irp->UserBuffer, BufferOffset ),
                               TransferSize );

            Irp->MdlAddress = PartialMdl;
            IrpSp = IoGetNextIrpStackLocation( Irp );

            //
            //  Setup the Stack location to do a read from the disk driver.
            //

            IrpSp->MajorFunction = IrpContext->MajorFunction;
            IrpSp->Parameters.Read.Length = TransferSize;
            IrpSp->Parameters.Read.ByteOffset.QuadPart = ThisLbo;

            IoSetCompletionRoutine( Irp, NtfsPagingFileNoAllocCompletionRoutine, &Event, TRUE, TRUE, TRUE );

            Status = IoCallDriver( Vcb->TargetDeviceObject, Irp );
            if (Status == STATUS_PENDING) {

                KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, NULL );
                Status = Irp->IoStatus.Status;

            }

            ASSERT( Status != STATUS_INSUFFICIENT_RESOURCES );

            if (!FT_SUCCESS( Irp->IoStatus.Status )) {

                BOOLEAN DataLost = TRUE;

                if (!FsRtlIsTotalDeviceFailure( Status ) &&
                    (Status != STATUS_VERIFY_REQUIRED)) {

                    //
                    //  We don't want to try to hotfix READ errors on the paging file
                    //  because of deadlock possibilities with MM. Instead we'll just
                    //  return the error for MM to deal with. Chances are that
                    //  MM (eg. MiWaitForInPageComplete) will bugcheck anyway,
                    //  but it's still nicer than walking right into the deadlock.
                    //

                    if (IrpSp->MajorFunction != IRP_MJ_READ) {

                        if ((Irp->IoStatus.Status == STATUS_FT_READ_RECOVERY_FROM_BACKUP) ||
                            (Irp->IoStatus.Status == STATUS_FT_WRITE_RECOVERY)) {

                            //
                            //  We got the data down on part of the mirror so we can do the fix
                            //  asynchronously
                            //

                            DataLost = FALSE;
                        }

                        //
                        //  Start an async hotfix
                        //

                        try {

                            NtfsPostHotFix( Irp,
                                            &StartingVbo,
                                            ThisLbo,
                                            TransferSize,
                                            FALSE );

                        } except( GetExceptionCode() == STATUS_INSUFFICIENT_RESOURCES ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {

                            //
                            //  If we don't have enough memory to post the hotfix - so be it
                            //  continue on
                            //

                            NtfsMinimumExceptionProcessing( IrpContext );
                        }
                    }
                }

                //
                //  If mm needs to rewrite the data return back the error
                //

                if (DataLost) {
                    Irp->MdlAddress = MasterMdl;
                    NtfsCompleteRequest( NULL, Irp, Irp->IoStatus.Status );
                    return;
                }
            }

            //
            //  Now adjust everything for the next pass through the loop
            //

            StartingVbo += TransferSize;
            BufferOffset += TransferSize;
            ByteCount -= TransferSize;
            ThisByteCount -= TransferSize;
            ThisLbo += TransferSize;
        }

        //
        //  Now adjust everything for the next pass through the loop but
        //  break out now if all the irps have been created for the io.
        //

        ClusterOffset = 0;
        ThisVcn += ThisClusterCount;
    }

    //
    //  Finally restore back the fields and complete the original irp
    //

    Irp->MdlAddress = MasterMdl;
    NtfsCompleteRequest( NULL, Irp, Irp->IoStatus.Status );
}



VOID
NtfsPagingFileIo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN VBO StartingVbo,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine performs the non-cached disk io described in its parameters.
    This routine nevers blocks, and should only be used with the paging
    file since no completion processing is performed.

Arguments:

    IrpContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    Irp - Supplies the requesting Irp.

    Scb - Supplies the file to act on.

    StartingVbo - Starting offset within the file for the operation.

    ByteCount - The lengh of the operation.

Return Value:

    None.

--*/

{
    LONGLONG ThisClusterCount;
    ULONG ThisByteCount;

    LCN ThisLcn;
    LBO ThisLbo;

    VCN ThisVcn;

    PIRP AssocIrp;
    PIRP ContextIrp;
    PIO_STACK_LOCATION IrpSp;
    ULONG BufferOffset;
    PDEVICE_OBJECT DeviceObject;
    PFILE_OBJECT FileObject;
    PDEVICE_OBJECT OurDeviceObject;

    PVCB Vcb = Scb->Vcb;

    LIST_ENTRY AssociatedIrps;
    ULONG AssociatedIrpCount;

    ULONG ClusterOffset;
    VCN BeyondLastCluster;

    VBO OriginalStartingVbo = StartingVbo;
    ULONG OriginalByteCount = ByteCount;

    ClearFlag( Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME ); //****ignore verify for now

    //
    //  Check whether we want to set the low order bit in the Irp to pass
    //  as a context value to the completion routine.
    //

    ContextIrp = Irp;

    if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_HOTFIX_UNDERWAY )) {

        SetFlag( ((ULONG_PTR) ContextIrp), 0x1 );
    }

    //
    //  Check that we are sector aligned.
    //

    ASSERT( (((ULONG)StartingVbo) & (Vcb->BytesPerSector - 1)) == 0 );

    //
    //  Initialize some locals.
    //

    BufferOffset = 0;
    ClusterOffset = (ULONG) StartingVbo & Vcb->ClusterMask;
    DeviceObject = Vcb->TargetDeviceObject;
    BeyondLastCluster = LlClustersFromBytes( Vcb, StartingVbo + ByteCount );

    //
    //  Try to lookup the first run.  If there is just a single run,
    //  we may just be able to pass it on.
    //

    ThisVcn = LlClustersFromBytesTruncate( Vcb, StartingVbo );

    //
    //  Paging files reads/ writes should always be correct.  If we didn't
    //  find the allocation, something bad has happened.
    //

    if (!NtfsLookupNtfsMcbEntry( &Scb->Mcb,
                                 ThisVcn,
                                 &ThisLcn,
                                 &ThisClusterCount,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL )) {

        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
    }

    //
    //  Adjust from Lcn to Lbo.
    //

    ThisLbo = LlBytesFromClusters( Vcb, ThisLcn ) + ClusterOffset;

    //
    //  Now set up the Irp->IoStatus.  It will be modified by the
    //  multi-completion routine in case of error or verify required.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = ByteCount;

    //
    //  Save the FileObject.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FileObject = IrpSp->FileObject;
    OurDeviceObject = IrpSp->DeviceObject;

    //
    //  See if the write covers a single valid run, and if so pass
    //  it on.
    //

    if (ThisVcn + ThisClusterCount >= BeyondLastCluster) {

        DebugTrace( 0, Dbg, ("Passing Irp on to Disk Driver\n") );

        //
        //  We use our stack location to store request information in a
        //  rather strange way, to give us enough context to post a
        //  hot fix on error.  It's ok, because it is our stack location!
        //

        IrpSp->Parameters.Read.ByteOffset.QuadPart = ThisLbo;
        IrpSp->Parameters.Read.Key = ((ULONG)StartingVbo);

        //
        //  Set up the completion routine address in our stack frame.
        //  This is only invoked on error or cancel, and just copies
        //  the error Status into master irp's iosb.
        //

        IoSetCompletionRoutine( Irp,
                                &NtfsPagingFileCompletionRoutine,
                                ContextIrp,
                                (BOOLEAN)!FlagOn(Vcb->VcbState, VCB_STATE_NO_SECONDARY_AVAILABLE),
                                TRUE,
                                TRUE );

        //
        //  Setup the next IRP stack location for the disk driver beneath us.
        //

        IrpSp = IoGetNextIrpStackLocation( Irp );

        //
        //  Setup the Stack location to do a read from the disk driver.
        //

        IrpSp->MajorFunction = IrpContext->MajorFunction;
        IrpSp->Parameters.Read.Length = ByteCount;
        IrpSp->Parameters.Read.ByteOffset.QuadPart = ThisLbo;

        //
        //  Issue the read/write request
        //
        //  If IoCallDriver returns an error, it has completed the Irp
        //  and the error will be dealt with as a normal IO error.
        //

        (VOID)IoCallDriver( DeviceObject, Irp );

        DebugTrace( -1, Dbg, ("NtfsPagingFileIo -> VOID\n") );
        return;
    }

    //
    //  Loop while there are still byte writes to satisfy.  Always keep the
    //  associated irp count one up, so that the master irp won't get
    //  completed prematurly.
    //

    try {

        //
        //  We will allocate and initialize all of the Irps and then send
        //  them down to the driver.  We will queue them off of our
        //  AssociatedIrp queue.
        //

        InitializeListHead( &AssociatedIrps );
        AssociatedIrpCount = 0;

        while (TRUE) {

            //
            //  Reset this for unwinding purposes
            //

            AssocIrp = NULL;

            //
            //  If next run is larger than we need, "ya get what you need".
            //

            ThisByteCount = BytesFromClusters( Vcb, (ULONG) ThisClusterCount ) - ClusterOffset;
            if (ThisVcn + ThisClusterCount >= BeyondLastCluster) {

                ThisByteCount = ByteCount;
            }

            //
            //  Now that we have properly bounded this piece of the
            //  transfer, it is time to read/write it.
            //

            AssocIrp = IoMakeAssociatedIrp( Irp, (CCHAR)(DeviceObject->StackSize + 1) );

            if (AssocIrp == NULL) {
                break;
            }

            //
            //  Now add the Irp to our queue of Irps.
            //

            InsertTailList( &AssociatedIrps, &AssocIrp->Tail.Overlay.ListEntry );

            //
            //  Allocate and build a partial Mdl for the request.
            //

            {
                PMDL Mdl;

                Mdl = IoAllocateMdl( (PCHAR)Irp->UserBuffer + BufferOffset,
                                     ThisByteCount,
                                     FALSE,
                                     FALSE,
                                     AssocIrp );

                if (Mdl == NULL) {
                    break;
                }

                IoBuildPartialMdl( Irp->MdlAddress,
                                   Mdl,
                                   Add2Ptr( Irp->UserBuffer, BufferOffset ),
                                   ThisByteCount );
            }

            AssociatedIrpCount += 1;

            //
            //  Get the first IRP stack location in the associated Irp
            //

            IoSetNextIrpStackLocation( AssocIrp );
            IrpSp = IoGetCurrentIrpStackLocation( AssocIrp );

            //
            //  We use our stack location to store request information in a
            //  rather strange way, to give us enough context to post a
            //  hot fix on error.  It's ok, because it is our stack location!
            //

            IrpSp->MajorFunction = IrpContext->MajorFunction;
            IrpSp->Parameters.Read.Length = ThisByteCount;
            IrpSp->Parameters.Read.ByteOffset.QuadPart = ThisLbo;
            IrpSp->Parameters.Read.Key = ((ULONG)StartingVbo);
            IrpSp->FileObject = FileObject;
            IrpSp->DeviceObject = OurDeviceObject;

            //
            //  Set up the completion routine address in our stack frame.
            //  This is only invoked on error or cancel, and just copies
            //  the error Status into master irp's iosb.
            //

            IoSetCompletionRoutine( AssocIrp,
                                    &NtfsPagingFileCompletionRoutine,
                                    ContextIrp,
                                    (BOOLEAN)!FlagOn(Vcb->VcbState, VCB_STATE_NO_SECONDARY_AVAILABLE),
                                    TRUE,
                                    TRUE );

            //
            //  Setup the next IRP stack location in the associated Irp for the disk
            //  driver beneath us.
            //

            IrpSp = IoGetNextIrpStackLocation( AssocIrp );

            //
            //  Setup the Stack location to do a read from the disk driver.
            //

            IrpSp->MajorFunction = IrpContext->MajorFunction;
            IrpSp->Parameters.Read.Length = ThisByteCount;
            IrpSp->Parameters.Read.ByteOffset.QuadPart = ThisLbo;

            //
            //  Now adjust everything for the next pass through the loop but
            //  break out now if all the irps have been created for the io.
            //

            StartingVbo += ThisByteCount;
            BufferOffset += ThisByteCount;
            ByteCount -= ThisByteCount;
            ClusterOffset = 0;
            ThisVcn += ThisClusterCount;


            if (ByteCount == 0) {

                break;
            }

            //
            //  Try to lookup the next run (if we are not done).
            //  Paging files reads/ writes should always be correct.  If
            //  we didn't find the allocation, something bad has happened.
            //

            if (!NtfsLookupNtfsMcbEntry( &Scb->Mcb,
                                         ThisVcn,
                                         &ThisLcn,
                                         &ThisClusterCount,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL )) {;

                NtfsBugCheck( 0, 0, 0 );
            }

            ThisLbo = LlBytesFromClusters( Vcb, ThisLcn );

        } //  while (ByteCount != 0)

        if (ByteCount == 0) {

            //
            //  We have now created all of the Irps that we need.  We will set the
            //  Irp count in the master Irp and then fire off the associated irps.
            //

            Irp->AssociatedIrp.IrpCount = AssociatedIrpCount;

            while (!IsListEmpty( &AssociatedIrps )) {

                AssocIrp = CONTAINING_RECORD( AssociatedIrps.Flink,
                                              IRP,
                                              Tail.Overlay.ListEntry );

                RemoveHeadList( &AssociatedIrps );

                (VOID) IoCallDriver( DeviceObject, AssocIrp );
            }
        } else {

            NtfsPagingFileIoWithNoAllocation( IrpContext, Irp, Scb, OriginalStartingVbo, OriginalByteCount );
        }
    } finally {

        DebugUnwind( NtfsPagingFileIo );

        //
        //  In the case of an error we must clean up any of the associated Irps
        //  we have created.
        //

        while (!IsListEmpty( &AssociatedIrps )) {

            AssocIrp = CONTAINING_RECORD( AssociatedIrps.Flink,
                                          IRP,
                                          Tail.Overlay.ListEntry );

            RemoveHeadList( &AssociatedIrps );

            if (AssocIrp->MdlAddress != NULL) {

                IoFreeMdl( AssocIrp->MdlAddress );
                AssocIrp->MdlAddress = NULL;
            }

            IoFreeIrp( AssocIrp );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsPagingFileIo -> VOID\n") );
    return;
}


BOOLEAN
NtfsIsReadAheadThread (
    )

/*++

Routine Description:

    This routine returns whether the current thread is doing read ahead.

Arguments:

    None

Return Value:

    FALSE - if the thread is not doing read ahead
    TRUE - if the thread is doing read ahead

--*/

{
    PREAD_AHEAD_THREAD ReadAheadThread;
    PVOID CurrentThread;
    KIRQL OldIrql;

    OldIrql = KeAcquireQueuedSpinLock( LockQueueNtfsStructLock );

    CurrentThread = (PVOID)PsGetCurrentThread();
    ReadAheadThread = (PREAD_AHEAD_THREAD)NtfsData.ReadAheadThreads.Flink;

    //
    //  Scan for our thread, stopping at the end of the list or on the first
    //  NULL.  We can stop on the first NULL, since when we free an entry
    //  we move it to the end of the list.
    //

    while ((ReadAheadThread != (PREAD_AHEAD_THREAD)&NtfsData.ReadAheadThreads) &&
           (ReadAheadThread->Thread != NULL)) {

        //
        //  Get out if we see our thread.
        //

        if (ReadAheadThread->Thread == CurrentThread) {

            KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, OldIrql );
            return TRUE;
        }
        ReadAheadThread = (PREAD_AHEAD_THREAD)ReadAheadThread->Links.Flink;
    }

    KeReleaseQueuedSpinLock( LockQueueNtfsStructLock, OldIrql );
    return FALSE;
}


//
//  Internal support routine
//

VOID
NtfsAllocateCompressionBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ThisScb,
    IN PIRP Irp,
    IN PCOMPRESSION_CONTEXT CompressionContext,
    IN OUT PULONG CompressionBufferLength
    )

/*++

Routine Description:

    This routine allocates a compression buffer of the desired length, and
            describes it with an Mdl.  It updates the Irp to describe the new buffer.
    Note that whoever allocates the CompressionContext must initially zero it.

Arguments:

    ThisScb - The stream where the IO is taking place.

    Irp - Irp for the current request

    CompressionContext - Pointer to the compression context for the request.

    CompressionBufferLength - Supplies length required for the compression buffer.
                              Returns length available.

Return Value:

    None.

--*/

{
    PMDL Mdl;

    //
    //  If no compression buffer is allocated, or it is too small, then we must
    //  take action here.
    //

    if (*CompressionBufferLength > CompressionContext->CompressionBufferLength) {

        //
        //  If there already is an Mdl, then there must also be a compression
        //  buffer (since we are part of main-line processing), and we must
        //  free these first.
        //

        if (CompressionContext->SavedMdl != NULL) {

            //
            //  Restore the byte count for which the Mdl was created, and free it.
            //

            Irp->MdlAddress->ByteCount = CompressionContext->CompressionBufferLength;

            NtfsDeleteMdlAndBuffer( Irp->MdlAddress,
                                    CompressionContext->CompressionBuffer );

            //
            //  Restore the Mdl and UserBuffer fields in the Irp.
            //

            Irp->MdlAddress = CompressionContext->SavedMdl;
            Irp->UserBuffer = CompressionContext->SavedUserBuffer;
            CompressionContext->SavedMdl = NULL;
            CompressionContext->CompressionBuffer = NULL;
        }

        CompressionContext->CompressionBufferLength = *CompressionBufferLength;

        //
        //  Allocate the compression buffer or raise
        //

        NtfsCreateMdlAndBuffer( IrpContext,
                                ThisScb,
                                (UCHAR) ((IrpContext->MajorFunction == IRP_MJ_WRITE) ?
                                         RESERVED_BUFFER_TWO_NEEDED :
                                         RESERVED_BUFFER_ONE_NEEDED),
                                &CompressionContext->CompressionBufferLength,
                                &Mdl,
                                &CompressionContext->CompressionBuffer );

        //
        //  Finally save the Mdl and Buffer fields from the Irp, and replace
        //  with the ones we just allocated.
        //

        CompressionContext->SavedMdl = Irp->MdlAddress;
        CompressionContext->SavedUserBuffer = Irp->UserBuffer;
        Irp->MdlAddress = Mdl;
        Irp->UserBuffer = CompressionContext->CompressionBuffer;
    }

    //
    //  Update the caller's length field in all cases.
    //

    *CompressionBufferLength = CompressionContext->CompressionBufferLength;
}


//
//  Internal support routine
//

VOID
NtfsDeallocateCompressionBuffer (
    IN PIRP Irp,
    IN PCOMPRESSION_CONTEXT CompressionContext,
    IN BOOLEAN Reinitialize
    )

/*++

Routine Description:

    This routine peforms all necessary cleanup for a compressed I/O, as described
    by the compression context.

Arguments:

    Irp - Irp for the current request

    CompressionContext - Pointer to the compression context for the request.

    Reinitialize - TRUE if we plan to continue using this context.

Return Value:

    None.

--*/

{
    //
    //  If there is a saved mdl, then we have to restore the original
    //  byte count it was allocated with and free it.  Then restore the
    //  Irp fields we modified.
    //

    if (CompressionContext->SavedMdl != NULL) {

        Irp->MdlAddress->ByteCount = CompressionContext->CompressionBufferLength;

        NtfsDeleteMdlAndBuffer( Irp->MdlAddress,
                                CompressionContext->CompressionBuffer );

    } else {

        NtfsDeleteMdlAndBuffer( NULL,
                                CompressionContext->CompressionBuffer );
    }

    //
    //  If there is a saved mdl, then we have to restore the original
    //  byte count it was allocated with and free it.  Then restore the
    //  Irp fields we modified.
    //

    if (CompressionContext->SavedMdl != NULL) {

        Irp->MdlAddress = CompressionContext->SavedMdl;
        Irp->UserBuffer = CompressionContext->SavedUserBuffer;
    }

    //
    //  If there is a work space structure allocated, free it.
    //

    if (CompressionContext->WorkSpace != NULL) {

        NtfsDeleteMdlAndBuffer( NULL, CompressionContext->WorkSpace );
    }

    //
    //  If are reinitializing the structure then clear the fields which
    //  we have already cleaned up.
    //

    if (Reinitialize) {

        CompressionContext->SavedMdl = NULL;
        CompressionContext->SavedUserBuffer = NULL;
        CompressionContext->CompressionBuffer = NULL;
        CompressionContext->WorkSpace = NULL;
        CompressionContext->CompressionBufferLength = 0;

    //
    //  Delete any allocate IoRuns array if we are done.
    //

    } else if (CompressionContext->AllocatedRuns != NTFS_MAX_PARALLEL_IOS) {
        NtfsFreePool( CompressionContext->IoRuns );
    }
}


//
//  Internal support routine
//

LONG
NtfsCompressionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    )

{
    UNREFERENCED_PARAMETER( IrpContext );
    UNREFERENCED_PARAMETER( ExceptionPointer );

    ASSERT( FsRtlIsNtstatusExpected( ExceptionPointer->ExceptionRecord->ExceptionCode ) );
    return EXCEPTION_EXECUTE_HANDLER;
}


//
//  Internal support routine
//

ULONG
NtfsPrepareBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PVBO StartingVbo,
    IN ULONG ByteCount,
    IN ULONG StreamFlags,
    IN OUT PBOOLEAN Wait,
    OUT PULONG NumberRuns,
    OUT PCOMPRESSION_CONTEXT CompressionContext
    )

/*++

Routine Description:

    This routine prepares the buffers for a noncached transfer, and fills
    in the IoRuns array to describe all of the separate transfers which must
    take place.

    For compressed reads, the exact size of the compressed data is
    calculated by scanning the run information, and a buffer is allocated
    to receive the compressed data.

    For compressed writes, an estimate is made on how large of a compressed
    buffer will be required.  Then the compression is performed, as much as
    possible, into the compressed buffer which was allocated.

Arguments:

    IrpContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    Irp - Supplies the requesting Irp.

    Scb - Supplies the stream file to act on.

    StartingVbo - The starting point for the operation.

    ByteCount - The lengh of the operation.

    NumberRuns - Returns the number of runs filled in to the IoRuns array.

    CompressionContext - Returns information related to the compression
                         to be cleaned up after the transfer.

    StreamFlags - Supplies either 0 or some combination of COMPRESSED_STREAM
                  and ENCRYPTED_STREAM

Return Value:

    Returns uncompressed bytes remaining to be processed, or 0 if all buffers
    are prepared in the IoRuns and CompressionContext.

--*/

{
    PVOID RangePtr;
    ULONG Index;

    LBO NextLbo;
    LCN NextLcn;
    VBO TempVbo;

    ULONG NextLcnOffset;

    VCN StartingVcn;

    ULONG NextByteCount;
    ULONG ReturnByteCount;
    ULONG TrimmedByteCount;
    LONGLONG NextClusterCount;

    BOOLEAN NextIsAllocated;
    BOOLEAN SparseWrite = FALSE;
    BOOLEAN OriginalSparseWrite = FALSE;

    ULONG BufferOffset;

    ULONG StructureSize;
    ULONG UsaOffset;
    ULONG BytesInIoRuns;
    BOOLEAN StopForUsa;

    PVOID SystemBuffer;

    ULONG CompressionUnit, CompressionUnitInClusters;
    ULONG CompressionUnitOffset;
    ULONG CompressedSize, FinalCompressedSize;
    LONGLONG FinalCompressedClusters;
    ULONG LastStartUsaIoRun;
    LOGICAL ReadRequest;
    PIO_STACK_LOCATION IrpSp;

    PIO_RUN IoRuns;

    NTSTATUS Status;

    VBO StartVbo = *StartingVbo;
    PVCB Vcb = Scb->Vcb;

    PAGED_CODE();

    //
    //  Initialize some locals.
    //

    IoRuns = CompressionContext->IoRuns;
    *NumberRuns = 0;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    ReadRequest = (LOGICAL)((IrpContext->MajorFunction == IRP_MJ_READ) ||
                            ((IrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
                             (IrpContext->MinorFunction == IRP_MN_USER_FS_REQUEST) &&
                             (IrpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_READ_FROM_PLEX)));

    //
    // For nonbuffered I/O, we need the buffer locked in all
    // cases.
    //
    // This call may raise.  If this call succeeds and a subsequent
    // condition is raised, the buffers are unlocked automatically
    // by the I/O system when the request is completed, via the
    // Irp->MdlAddress field.
    //

    ASSERT( FIELD_OFFSET(IO_STACK_LOCATION, Parameters.Read.Length) ==
            FIELD_OFFSET(IO_STACK_LOCATION, Parameters.Write.Length) );

    NtfsLockUserBuffer( IrpContext,
                        Irp,
                        ReadRequest ?
                          IoWriteAccess : IoReadAccess,
                        IrpSp->Parameters.Read.Length );

    //
    //  Normally the Mdl BufferOffset picks up from where we last left off.
    //  However, for those cases where we have called NtfsAllocateCompressionBuffer,
    //  for a scratch buffer, we always reset to offset 0.
    //

    BufferOffset = CompressionContext->SystemBufferOffset;
    if (CompressionContext->SavedMdl != NULL) {
        BufferOffset = 0;
    }

    //
    //  Check if this request wants to drive the IO directly from the Mcb.  This is
    //  the case for all Scb's without a compression unit or for reads of uncompressed
    //  files or compressed reads.  Also proceed with sparse writes optimistically
    //  assuming the compression unit is allocated.
    //

    if ((ReadRequest) ?

         //
         //  Trust Mcb on reads of uncompressed files or reading compressed data.
         //

         ((Scb->CompressionUnit == 0) ||
          !FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) ||
          FlagOn( StreamFlags, COMPRESSED_STREAM )) :

         //
         //  Trust Mcb (optimistically) for writes of uncompressed sparse files.
         //

         ((Scb->CompressionUnit == 0) ||
          (OriginalSparseWrite =
           SparseWrite = FlagOn( Scb->AttributeFlags,
                                  ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE ) == ATTRIBUTE_FLAG_SPARSE))) {

        ASSERT( (ReadRequest) ||
                (IrpContext->MajorFunction == IRP_MJ_WRITE) ||
                FlagOn( StreamFlags, COMPRESSED_STREAM ) );

        ASSERT( (Scb->CompressionUnit == 0) ||
                NtfsIsTypeCodeCompressible( Scb->AttributeTypeCode ) );

        //
        //  If this is a Usa-protected structure and we are reading, figure out
        //  what units we want to access it in.
        //

        TrimmedByteCount = 0;

        if ((Scb->EncryptionContext != NULL) &&
            (IrpContext->MajorFunction == IRP_MJ_WRITE)) {

            //
            //  For an encrypted file, we will be allocating a new buffer in the irp
            //  so the entries in the ioruns array should have offsets relative to
            //  this new buffer.
            //

            if (ByteCount > LARGE_BUFFER_SIZE) {

                //
                //  Trim to LARGE_BUFFER_SIZE and remember the amount trimmed
                //  to add back to byte count later.
                //

                TrimmedByteCount = ByteCount - LARGE_BUFFER_SIZE;
                ByteCount = LARGE_BUFFER_SIZE;

                DebugTrace( 0, Dbg, ("\nTrimming ByteCount by %x", TrimmedByteCount) );
            }
        }

        StructureSize = ByteCount;
        if (FlagOn(Scb->ScbState, SCB_STATE_USA_PRESENT) &&
            (ReadRequest)) {

            //
            //  Get the the number of blocks, based on what type of stream it is.
            //  First check for Mft or Log file.
            //

            if (Scb->Header.NodeTypeCode == NTFS_NTC_SCB_MFT) {

                ASSERT((Scb == Vcb->MftScb) || (Scb == Vcb->Mft2Scb));

                StructureSize = Vcb->BytesPerFileRecordSegment;

            //
            //  Otherwise it is an index, so we can get the count out of the Scb.
            //

            } else if (Scb->Header.NodeTypeCode != NTFS_NTC_SCB_DATA) {

                StructureSize = Scb->ScbType.Index.BytesPerIndexBuffer;
            }

            //
            //  Remember the last index in the IO runs array which will allow us to
            //  read in a full USA structure in the worst case.
            //

            LastStartUsaIoRun = ClustersFromBytes( Vcb, StructureSize );

            if (LastStartUsaIoRun > NTFS_MAX_PARALLEL_IOS) {

                LastStartUsaIoRun = 0;

            } else {

                LastStartUsaIoRun = NTFS_MAX_PARALLEL_IOS - LastStartUsaIoRun;
            }
        }

        BytesInIoRuns = 0;
        UsaOffset = 0;
        StopForUsa = FALSE;

        while ((ByteCount != 0) && (*NumberRuns != NTFS_MAX_PARALLEL_IOS) && !StopForUsa) {

            //
            //  Lookup next run
            //

            StartingVcn = LlClustersFromBytesTruncate( Vcb, StartVbo );

            //
            //  If another writer is modifying the Mcb of a sparse file then we need
            //  to serialize our lookup.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_PROTECT_SPARSE_MCB )) {

                NtfsPurgeFileRecordCache( IrpContext );
                NtfsAcquireSharedScb( IrpContext, Scb );

                try {

                    NextIsAllocated = NtfsLookupAllocation( IrpContext,
                                                            Scb,
                                                            StartingVcn,
                                                            &NextLcn,
                                                            &NextClusterCount,
                                                            &RangePtr,
                                                            &Index );

                } finally {

                    NtfsReleaseScb( IrpContext, Scb );
                }

            } else {

                //
                //  Purge because lookupallocation may acquire the scb main if it needs to load
                //  which will be first main acquire and can be blocked behind an acquireallfiles
                //

                NtfsPurgeFileRecordCache( IrpContext );
                NextIsAllocated = NtfsLookupAllocation( IrpContext,
                                                        Scb,
                                                        StartingVcn,
                                                        &NextLcn,
                                                        &NextClusterCount,
                                                        &RangePtr,
                                                        &Index );
            }

            ASSERT( NextIsAllocated ||
                    FlagOn( Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ) ||
                    FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE ) ||
                    (Scb == Vcb->MftScb) ||
                    FlagOn( StreamFlags, COMPRESSED_STREAM | ENCRYPTED_STREAM ) );

            //
            //  If this is a sparse write we need to deal with cases where
            //  the run is not allocated OR the last run in this transfer
            //  was unallocated but this run is allocated.
            //

            if (SparseWrite) {

                //
                //  If the current run is not allocated then break out of the loop.
                //

                if (!NextIsAllocated) {

                    //
                    //  Convert to synchronous since we need to allocate space
                    //

                    if (*Wait == FALSE) {

                        *Wait = TRUE;
                        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

                        RtlZeroMemory( IrpContext->Union.NtfsIoContext, sizeof( NTFS_IO_CONTEXT ) );

                        //
                        //  Store whether we allocated this context structure in the structure
                        //  itself.
                        //

                        IrpContext->Union.NtfsIoContext->AllocatedContext =
                            BooleanFlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT );

                        KeInitializeEvent( &IrpContext->Union.NtfsIoContext->Wait.SyncEvent,
                                           NotificationEvent,
                                           FALSE );
                    }

                    break;

                }

                //
                //  Deal with the case where the last run in this transfer was not allocated.
                //  In that case we would have allocated a compression buffer and stored
                //  the original Mdl into the compression context.  Since this is an allocated
                //  range we can use the original user buffer and Mdl.  Restore these
                //  back into the original irp now.
                //
                //  If this file is encrypted, we do NOT want to change the buffer offset,
                //  because this offset will be stored as the first IoRun's buffer offset, and
                //  encrypt buffers will add the system buffer offset to that, and end up
                //  passing a bad buffer to the encryption driver.  Besides, it's inefficient
                //  to deallocate the buffer, since encrypt buffers will have to reallocate it.
                //

                if ((CompressionContext->SavedMdl != NULL) &&
                    (Scb->EncryptionContext == NULL)) {

                    NtfsDeallocateCompressionBuffer( Irp, CompressionContext, TRUE );
                    BufferOffset = CompressionContext->SystemBufferOffset;
                }
            }

            //
            //  Adjust from NextLcn to Lbo.  NextByteCount may overflow out of 32 bits
            //  but we will catch that below when we compare clusters.
            //

            NextLcnOffset = ((ULONG)StartVbo) & Vcb->ClusterMask;

            NextByteCount = BytesFromClusters( Vcb, (ULONG)NextClusterCount ) - NextLcnOffset;

            //
            // If next run is larger than we need, "ya get what you need".
            // Note that after this we are guaranteed that the HighPart of
            // NextByteCount is 0.
            //

            if ((ULONG)NextClusterCount >= ClustersFromBytes( Vcb, ByteCount + NextLcnOffset )) {

                NextByteCount = ByteCount;
            }

            //
            //  If the byte count is zero then we will spin indefinitely.  Raise
            //  corrupt here so the system doesn't hang.
            //

            if (NextByteCount == 0) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
            }

            //
            //  If this is a USA-protected structure, broken up in
            //  multiple runs, then we want to guarantee that we do
            //  not end up in the middle of a Usa-protected structure in the read path.
            //  Therefore, on the first run we will calculate the
            //  initial UsaOffset.  Then in the worst case it can
            //  take the remaining four runs to finish the Usa structure.
            //
            //  On the first subsequent run to complete a Usa structure,
            //  we set the count to end exactly on a Usa boundary.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_USA_PRESENT ) &&
                (ReadRequest)) {

                //
                //  So long as we know there are more IO runs left than the maximum
                //  number needed for the USA structure just maintain the current
                //  Usa offset.
                //

                if (*NumberRuns < LastStartUsaIoRun) {

                    UsaOffset = (UsaOffset + NextByteCount) & (StructureSize - 1);

                //
                //  Now we will stop on the next Usa boundary, but we may not
                //  have it yet.
                //

                } else {

                    if ((NextByteCount + UsaOffset) >= StructureSize) {

                        NextByteCount = ((NextByteCount + UsaOffset) & ~(StructureSize - 1)) -
                                        (UsaOffset & (StructureSize - 1));
                        StopForUsa = TRUE;
                    }

                    UsaOffset += NextByteCount;
                }
            }

            //
            //  Only fill in the run array if the run is allocated.
            //

            if (NextIsAllocated) {

                //
                //  Adjust if the Lcn offset (if we have one) and isn't zero.
                //

                NextLbo = LlBytesFromClusters( Vcb, NextLcn );
                NextLbo = NextLbo + NextLcnOffset;

                //
                // Now that we have properly bounded this piece of the
                // transfer, it is time to write it.
                //
                // We remember each piece of a parallel run by saving the
                // essential information in the IoRuns array.  The tranfers
                // are started up in parallel below.
                //

                IoRuns[*NumberRuns].StartingVbo = StartVbo;
                IoRuns[*NumberRuns].StartingLbo = NextLbo;
                IoRuns[*NumberRuns].BufferOffset = BufferOffset;
                IoRuns[*NumberRuns].ByteCount = NextByteCount;
                BytesInIoRuns += NextByteCount;
                *NumberRuns += 1;

            } else if (ReadRequest) {

                SystemBuffer = Add2Ptr( NtfsMapUserBuffer( Irp ), BufferOffset );

                //
                //  If this is not a compressed stream then fill this range with zeroes.
                //  Also if this is a sparse, non-compressed stream then check if we need to
                //  reserve clusters.
                //

                if (!FlagOn( StreamFlags, COMPRESSED_STREAM )) {

                    RtlZeroMemory( SystemBuffer, NextByteCount );

                    if (FlagOn( Irp->Flags, IRP_PAGING_IO ) &&
                        FlagOn( Scb->Header.Flags, FSRTL_FLAG_USER_MAPPED_FILE ) &&
                        (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE ) == ATTRIBUTE_FLAG_SPARSE)) {

                        if (!NtfsReserveClusters( IrpContext,
                                                  Scb,
                                                  StartVbo,
                                                  NextByteCount )) {

                            NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
                        }
                    }

                //
                //  If it is compressed then make sure the range begins with a zero in
                //  case MM passed a non-zeroed buffer.  Then the compressed read/write
                //  routines will know the chunk begins with a zero.
                //

                } else {

                    *((PULONG) SystemBuffer) = 0;
                }
            }

            //
            // Now adjust everything for the next pass through the loop.
            //

            StartVbo = StartVbo + NextByteCount;
            BufferOffset += NextByteCount;
            ByteCount -= NextByteCount;
        }

        //
        //  Let's remember about those bytes we trimmed off above.  We have more
        //  bytes remaining than we think, and we didn't transfer as much, so we
        //  need to back up where we start the next transfer.
        //

        if (TrimmedByteCount != 0) {

            DebugTrace( 0,
                        Dbg,
                        ("\nByteCount + TrimmedByteCount = %x + %x = %x",
                         ByteCount,
                         TrimmedByteCount,
                         ByteCount + TrimmedByteCount) );

            DebugTrace( 0,
                        Dbg,
                        ("\nStartVbo - TrimmedByteCount = %I64x - %x = %I64x",
                         StartVbo,
                         TrimmedByteCount,
                         StartVbo - TrimmedByteCount) );

            ByteCount += TrimmedByteCount;
        }

        //
        //  If this is a sparse write and the start of the write is unallocated then drop
        //  down to the compressed path below.  Otherwise do the IO we found.
        //

        if (!SparseWrite || (BytesInIoRuns != 0)) {

            return ByteCount;
        }
    }

    ASSERT( Scb->Header.NodeTypeCode == NTFS_NTC_SCB_DATA  );

    //
    //  Initialize the compression parameters.
    //

    CompressionUnit = Scb->CompressionUnit;
    CompressionUnitInClusters = ClustersFromBytes(Vcb, CompressionUnit);
    CompressionUnitOffset = 0;
    if (CompressionUnit != 0) {
        CompressionUnitOffset = ((ULONG)StartVbo) & (CompressionUnit - 1);
    }

    //
    //  We want to make sure and wait to get byte count and things correctly.
    //

    if (!FlagOn(IrpContext->State, IRP_CONTEXT_STATE_WAIT)) {
        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
    }

    //
    //  Handle the compressed read case.
    //

    if (IrpContext->MajorFunction == IRP_MJ_READ) {

        //
        //  If we have not already mapped the user buffer, then do it.
        //

        if (CompressionContext->SystemBuffer == NULL) {
            CompressionContext->SystemBuffer = NtfsMapUserBuffer( Irp );
        }

        BytesInIoRuns = 0;

        //
        //  Adjust StartVbo and ByteCount by the offset.
        //

        ((ULONG)StartVbo) -= CompressionUnitOffset;
        ByteCount += CompressionUnitOffset;

        //
        //  Capture this value for maintaining the byte count to
        //  return.
        //

        ReturnByteCount = ByteCount;

        //
        //  Now, the ByteCount we actually have to process has to
        //  be rounded up to the next compression unit.
        //

        ByteCount += CompressionUnit - 1;
        ByteCount &= ~(CompressionUnit - 1);

        //
        //  Make sure we never try to handle more than a LARGE_BUFFER_SIZE
        //  at once, forcing our caller to call back.
        //

        if (ByteCount > LARGE_BUFFER_SIZE) {
            ByteCount = LARGE_BUFFER_SIZE;
        }

        //
        //  In case we find no allocation....
        //

        IoRuns[0].ByteCount = 0;

        while (ByteCount != 0) {

            //
            // Try to lookup the first run.  If there is just a single run,
            // we may just be able to pass it on.
            //

            ASSERT( !FlagOn( ((ULONG) StartVbo), Vcb->ClusterMask ));
            StartingVcn = LlClustersFromBytesTruncate( Vcb, StartVbo );

            NextIsAllocated = NtfsLookupAllocation( IrpContext,
                                                    Scb,
                                                    StartingVcn,
                                                    &NextLcn,
                                                    &NextClusterCount,
                                                    &RangePtr,
                                                    &Index );

#if (defined(NTFS_RWCMP_TRACE) || defined(SYSCACHE))
            ASSERT(!IsSyscache(Scb) || (NextClusterCount < 16) || !NextIsAllocated);
#endif

            //
            //  Adjust from NextLcn to Lbo.
            //
            //  If next run is larger than we need, "ya get what you need".
            //  Note that after this we are guaranteed that the HighPart of
            //  NextByteCount is 0.
            //


            if ((ULONG)NextClusterCount >= ClustersFromBytes( Vcb, ByteCount )) {

                NextByteCount = ByteCount;

            } else {

                NextByteCount = BytesFromClusters( Vcb, (ULONG)NextClusterCount );
            }

            //
            //  Adjust if the Lcn offset isn't zero.
            //

            NextLbo = LlBytesFromClusters( Vcb, NextLcn );

            //
            //  Only fill in the run array if the run is allocated.
            //

            if (NextIsAllocated) {

                //
                //  If the Lbos are contiguous, then we can do a contiguous
                //  transfer, so we just increase the current byte count.
                //

                if ((*NumberRuns != 0) && (NextLbo ==
                                           (IoRuns[*NumberRuns - 1].StartingLbo +
                                            (IoRuns[*NumberRuns - 1].ByteCount)))) {

                    //
                    //  Stop on the first compression unit boundary after the
                    //  the penultimate run in the default io array.
                    //

                    if (*NumberRuns >= NTFS_MAX_PARALLEL_IOS - 1) {

                        //
                        //  First, if we are beyond the penultimate run and we are starting
                        //  a run in a different compression unit than the previous
                        //  run, then we can just break out and not use the current
                        //  run.  (*NumberRuns has not yet been incremented.)
                        //  In order for it to be in the same run it can't begin at
                        //  offset 0 in the compression unit and it must be contiguous
                        //  with the virtual end of the previous run.
                        //  The only case where this can happen in the running system is
                        //  if there is a file record boundary in the middle of the
                        //  compression unit.
                        //

                        if ((*NumberRuns > NTFS_MAX_PARALLEL_IOS - 1) &&
                            (!FlagOn( (ULONG) StartVbo, CompressionUnit - 1 ) ||
                            (StartVbo != (IoRuns[*NumberRuns - 1].StartingVbo +
                                          IoRuns[*NumberRuns - 1].ByteCount)))) {

                            break;

                        //
                        //  Else detect the case where this run ends on or
                        //  crosses a compression unit boundary.  In this case,
                        //  just make sure the run stops on a compression unit
                        //  boundary, and break out to return it.
                        //

                        } else if ((((ULONG) StartVbo & (CompressionUnit - 1)) + NextByteCount) >=
                                   CompressionUnit) {

                            NextByteCount -= (((ULONG)StartVbo) + NextByteCount) & (CompressionUnit - 1);
                            BytesInIoRuns += NextByteCount;

                            if (ReturnByteCount > NextByteCount) {
                                ReturnByteCount -= NextByteCount;
                            } else {
                                ReturnByteCount = 0;
                            }

                            IoRuns[*NumberRuns - 1].ByteCount += NextByteCount;

                            break;
                        }
                    }

                    IoRuns[*NumberRuns - 1].ByteCount += NextByteCount;

                //
                //  Otherwise it is time to start a new run, if there is space for one.
                //

                } else {

                    //
                    //  If we have filled up the current I/O runs array, then we
                    //  will grow it once to a size which would allow the worst
                    //  case compression unit (all noncontiguous clusters) to
                    //  start at index NTFS_MAX_PARALLEL_IOS - 1.
                    //  The following if statement enforces
                    //  this case as the worst case.  With 16 clusters per compression
                    //  unit, the theoretical maximum number of parallel I/Os
                    //  would be 16 + NTFS_MAX_PARALLEL_IOS - 1, since we stop on the
                    //  first compression unit boundary after the penultimate run.
                    //  Normally, of course we will do much fewer.
                    //

                    if ((*NumberRuns == NTFS_MAX_PARALLEL_IOS) &&
                        (CompressionContext->AllocatedRuns == NTFS_MAX_PARALLEL_IOS)) {

                        PIO_RUN NewIoRuns;

                        NewIoRuns = NtfsAllocatePool( NonPagedPool,
                                                       (CompressionUnitInClusters + NTFS_MAX_PARALLEL_IOS - 1) * sizeof(IO_RUN) );

                        RtlCopyMemory( NewIoRuns,
                                       CompressionContext->IoRuns,
                                       NTFS_MAX_PARALLEL_IOS * sizeof(IO_RUN) );

                        IoRuns = CompressionContext->IoRuns = NewIoRuns;
                        CompressionContext->AllocatedRuns = CompressionUnitInClusters + NTFS_MAX_PARALLEL_IOS - 1;
                    }

                    //
                    // We remember each piece of a parallel run by saving the
                    // essential information in the IoRuns array.  The tranfers
                    // will be started up in parallel below.
                    //

                    ASSERT(*NumberRuns < CompressionContext->AllocatedRuns);

                    IoRuns[*NumberRuns].StartingVbo = StartVbo;
                    IoRuns[*NumberRuns].StartingLbo = NextLbo;
                    IoRuns[*NumberRuns].BufferOffset = BufferOffset;
                    IoRuns[*NumberRuns].ByteCount = NextByteCount;
                    if ((*NumberRuns + 1) < CompressionContext->AllocatedRuns) {
                        IoRuns[*NumberRuns + 1].ByteCount = 0;
                    }

                    //
                    //  Stop on the first compression unit boundary after the
                    //  penultimate run in the default array.
                    //

                    if (*NumberRuns >= NTFS_MAX_PARALLEL_IOS - 1) {

                        //
                        //  First, if we are beyond penultimate run and we are starting
                        //  a run in a different compression unit than the previous
                        //  run, then we can just break out and not use the current
                        //  run.  (*NumberRuns has not yet been incremented.)
                        //

                        if ((*NumberRuns > NTFS_MAX_PARALLEL_IOS - 1) &&
                            ((((ULONG)StartVbo) & ~(CompressionUnit - 1)) !=
                             ((((ULONG)IoRuns[*NumberRuns - 1].StartingVbo) +
                               IoRuns[*NumberRuns - 1].ByteCount - 1) &
                               ~(CompressionUnit - 1)))) {

                            break;

                        //
                        //  Else detect the case where this run ends on or
                        //  crosses a compression unit boundary.  In this case,
                        //  just make sure the run stops on a compression unit
                        //  boundary, and break out to return it.
                        //

                        } else if ((((ULONG)StartVbo) & ~(CompressionUnit - 1)) !=
                            ((((ULONG)StartVbo) + NextByteCount) & ~(CompressionUnit - 1))) {

                            NextByteCount -= (((ULONG)StartVbo) + NextByteCount) & (CompressionUnit - 1);
                            IoRuns[*NumberRuns].ByteCount = NextByteCount;
                            BytesInIoRuns += NextByteCount;

                            if (ReturnByteCount > NextByteCount) {
                                ReturnByteCount -= NextByteCount;
                            } else {
                                ReturnByteCount = 0;
                            }

                            *NumberRuns += 1;
                            break;
                        }
                    }
                    *NumberRuns += 1;
                }

                BytesInIoRuns += NextByteCount;
                BufferOffset += NextByteCount;
            }

            //
            //  Now adjust everything for the next pass through the loop.
            //

            StartVbo += NextByteCount;
            ByteCount -= NextByteCount;

            if (ReturnByteCount > NextByteCount) {
                ReturnByteCount -= NextByteCount;
            } else {
                ReturnByteCount = 0;
            }
        }

        //
        //  Allocate the compressed buffer if it is not already allocated.
        //

        if (BytesInIoRuns < CompressionUnit) {
            BytesInIoRuns = CompressionUnit;
        }
        NtfsAllocateCompressionBuffer( IrpContext, Scb, Irp, CompressionContext, &BytesInIoRuns );

        return ReturnByteCount;

    //
    //  Otherwise handle the compressed write case
    //

    } else {

        LONGLONG SavedValidDataToDisk;
        PUCHAR UncompressedBuffer;
        ULONG UncompressedOffset;
        ULONG ClusterOffset;
        BOOLEAN NoopRange;

        ULONG CompressedOffset;
        PBCB Bcb;

        ASSERT(IrpContext->MajorFunction == IRP_MJ_WRITE);

        //
        //  Adjust StartVbo and ByteCount by the offset.
        //

        ((ULONG)StartVbo) -= CompressionUnitOffset;
        ByteCount += CompressionUnitOffset;

        //
        //  Maintain additional bytes to be returned in ReturnByteCount,
        //  and adjust this if we are larger than a LARGE_BUFFER_SIZE.
        //

        ReturnByteCount = 0;
        if (ByteCount > LARGE_BUFFER_SIZE) {
            ReturnByteCount = ByteCount - LARGE_BUFFER_SIZE;
            ByteCount = LARGE_BUFFER_SIZE;
        }

        CompressedSize = ByteCount;
        if (!FlagOn( StreamFlags, COMPRESSED_STREAM ) && (CompressionUnit != 0)) {

            //
            //  To reduce pool consumption, make an educated/optimistic guess on
            //  how much pool we need to store the compressed data.  If we are wrong
            //  we will just have to do some more I/O.
            //

            CompressedSize = (CompressedSize + CompressionUnit - 1) & ~(CompressionUnit - 1);
            CompressedSize += Vcb->BytesPerCluster;

            if (CompressedSize > LARGE_BUFFER_SIZE) {
                CompressedSize = LARGE_BUFFER_SIZE;
            }

            //
            //  Allocate the compressed buffer if it is not already allocated, and this
            //  isn't the compressed stream.
            //

            if (SparseWrite &&
                (CompressionContext->SystemBuffer == NULL)) {

                CompressionContext->SystemBuffer = NtfsMapUserBuffer( Irp );
            }

            //
            //  At this point BufferOffset should always be 0.
            //

            BufferOffset = 0;
            NtfsAllocateCompressionBuffer( IrpContext, Scb, Irp, CompressionContext, &CompressedSize );

            CompressionContext->DataTransformed = TRUE;
        }

        //
        //  Loop to compress the user's buffer.
        //

        CompressedOffset = 0;
        UncompressedOffset = 0;
        Bcb = NULL;

        try {

            BOOLEAN ChangeAllocation;
            ULONG SparseFileBias;

            //
            //  Loop as long as we will not overflow our compressed buffer, and we
            //  are also guanteed that we will not overflow the extended IoRuns array
            //  in the worst case (and as long as we have more write to satisfy!).
            //

            while ((ByteCount != 0) && (*NumberRuns <= NTFS_MAX_PARALLEL_IOS - 1) &&
                   (((CompressedOffset + CompressionUnit) <= CompressedSize) ||
                    FlagOn( StreamFlags, COMPRESSED_STREAM ))) {

                LONGLONG SizeToCompress;

                //
                //  State variables to determine a reallocate range.
                //

                VCN DeleteVcn;
                LONGLONG DeleteCount;
                LONGLONG AllocateCount;

                DeleteCount = 0;
                AllocateCount = 0;

                NoopRange = FALSE;
                SparseFileBias = 0;
                ClusterOffset = 0;

                //
                //  Assume we are only compressing to FileSize, or else
                //  reduce to one compression unit.  The maximum compression size
                //  we can accept is saving at least one cluster.
                //

                NtfsAcquireFsrtlHeader( Scb );

                //
                //  If this is a compressed stream then we may need to go past file size.
                //

                if (FlagOn( StreamFlags, COMPRESSED_STREAM)) {

                    SizeToCompress = Scb->Header.FileSize.QuadPart + CompressionUnit - 1;
                    ((PLARGE_INTEGER) &SizeToCompress)->LowPart &= ~(CompressionUnit - 1);

                    SizeToCompress -= StartVbo;

                } else {

                    SizeToCompress = Scb->Header.FileSize.QuadPart - StartVbo;
                }

                NtfsReleaseFsrtlHeader( Scb );

                //
                //  It is possible that if this is the lazy writer that the file
                //  size was rolled back from a cached write which is aborting.
                //  In that case we either truncate the write or can exit this
                //  loop if there is nothing left to write.
                //

                if (SizeToCompress <= 0) {

                    ByteCount = 0;
                    break;
                }

                //
                //  Note if CompressionUnit is 0, then we do not need SizeToCompress.
                //

                if (SizeToCompress > CompressionUnit) {
                    SizeToCompress = (LONGLONG)CompressionUnit;
                }

#ifdef  COMPRESS_ON_WIRE
                //
                //  For the normal uncompressed stream, map the data and compress it
                //  into the allocated buffer.
                //

                if (!FlagOn( StreamFlags, COMPRESSED_STREAM )) {

#endif

                    //
                    //  If this is a sparse write then we zero the beginning and
                    //  end of the compression unit as needed and copy in the user
                    //  data.
                    //

                    if (SparseWrite) {

                        //
                        //  Use local variables to position ourselves in the
                        //  compression context buffer and user system buffer.
                        //  We'll reuse StructureSize to show the number of
                        //  user bytes copied to the buffer.
                        //

                        SystemBuffer = Add2Ptr( CompressionContext->SystemBuffer,
                                                CompressionContext->SystemBufferOffset + UncompressedOffset );

                        UncompressedBuffer = Add2Ptr( CompressionContext->CompressionBuffer,
                                                      BufferOffset );

                        //
                        //  Zero the beginning of the compression buffer if necessary.
                        //

                        if (CompressionUnitOffset != 0) {

                            RtlZeroMemory( UncompressedBuffer, CompressionUnitOffset );
                            UncompressedBuffer += CompressionUnitOffset;
                        }

                        //
                        //  Now copy the user data into the buffer.
                        //

                        if ((ULONG) SizeToCompress < ByteCount) {

                            StructureSize = (ULONG) BlockAlign( SizeToCompress, (LONG)Vcb->BytesPerSector ) - CompressionUnitOffset;

                        } else {

                            StructureSize = ByteCount - CompressionUnitOffset;
                        }

                        RtlCopyMemory( UncompressedBuffer,
                                       SystemBuffer,
                                       StructureSize );

                        //
                        //  It may be necessary to zero the end of the buffer.
                        //

                        if ((ULONG) SizeToCompress > ByteCount) {

                            RtlZeroMemory( Add2Ptr( UncompressedBuffer, StructureSize ),
                                           (ULONG) SizeToCompress - ByteCount );
                        }

                        FinalCompressedSize = CompressionUnit;
                        Status = STATUS_SUCCESS;

                    } else {

                        UncompressedBuffer = NULL;
                        if (CompressionUnit != 0) {

                            //
                            //  Map the aligned range, set it dirty, and flush.  We have to
                            //  loop, because the Cache Manager limits how much and over what
                            //  boundaries we can map.  Only do this if there a file
                            //  object.  Otherwise we will assume we are writing the
                            //  clusters directly to disk (via NtfsWriteClusters).
                            //

                            if (Scb->FileObject != NULL) {

                                CcMapData( Scb->FileObject,
                                           (PLARGE_INTEGER)&StartVbo,
                                           (ULONG)SizeToCompress,
                                           TRUE,
                                           &Bcb,
                                           &UncompressedBuffer );

#ifdef MAPCOUNT_DBG
                                IrpContext->MapCount++;
#endif

                            } else {

                                UncompressedBuffer = MmGetSystemAddressForMdlSafe( CompressionContext->SavedMdl, NormalPagePriority );

                                if (UncompressedBuffer == NULL) {

                                    NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
                                }
                            }

                            //
                            //  If we have not already allocated the workspace, then do it.  We don't
                            //  need the workspace if the file is not compressed (i.e. sparse).
                            //

                            if ((CompressionContext->WorkSpace == NULL) &&
                                FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                                ULONG CompressWorkSpaceSize;
                                ULONG FragmentWorkSpaceSize;

                                (VOID) RtlGetCompressionWorkSpaceSize( (USHORT)((Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK) + 1),
                                                                       &CompressWorkSpaceSize,
                                                                       &FragmentWorkSpaceSize );

                                //
                                //  It is critical to ask for the work space buffer.  It is the only
                                //  one large enough to hold the bigger ia64 pointers.
                                //

                                NtfsCreateMdlAndBuffer( IrpContext,
                                                        Scb,
                                                        RESERVED_BUFFER_WORKSPACE_NEEDED,
                                                        &CompressWorkSpaceSize,
                                                        NULL,
                                                        &CompressionContext->WorkSpace );
                            }
                        }

                        try {

                            //
                            //  If we are moving an uncompressed file, then do not compress
                            //

                            if (CompressionUnit == 0) {
                                FinalCompressedSize = ByteCount;
                                Status = STATUS_SUCCESS;

                            //
                            //  If we are writing compressed, compress it now.
                            //

                            } else if (!FlagOn(Scb->ScbState, SCB_STATE_WRITE_COMPRESSED) ||
                                ((Status =
                                  RtlCompressBuffer( (USHORT)((Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK) + 1),
                                                     UncompressedBuffer,
                                                     (ULONG)SizeToCompress,
                                                     CompressionContext->CompressionBuffer + CompressedOffset,
                                                     (CompressionUnit - Vcb->BytesPerCluster),
                                                     NTFS_CHUNK_SIZE,
                                                     &FinalCompressedSize,
                                                     CompressionContext->WorkSpace )) ==

                                                    STATUS_BUFFER_TOO_SMALL)) {

                                //
                                //  If it did not compress, just copy it over, sigh.  This looks bad,
                                //  but it should virtually never occur assuming compression is working
                                //  ok.  In the case where FileSize is in this unit, make sure we
                                //  at least copy to a sector boundary.
                                //

                                FinalCompressedSize = CompressionUnit;

                                if (!SparseWrite) {

                                    RtlCopyMemory( CompressionContext->CompressionBuffer + CompressedOffset,
                                                   UncompressedBuffer,
                                                   ((ULONG)SizeToCompress + Vcb->BytesPerSector - 1) &
                                                     ~(Vcb->BytesPerSector - 1));
                                }

                                ASSERT(FinalCompressedSize <= (CompressedSize - CompressedOffset));
                                Status = STATUS_SUCCESS;
                            }

                        //
                        //  Probably Gary's compression routine faulted, but blame it on
                        //  the user buffer!
                        //

                        } except(NtfsCompressionFilter(IrpContext, GetExceptionInformation())) {
                            NtfsRaiseStatus( IrpContext, STATUS_INVALID_USER_BUFFER, NULL, NULL );
                        }
                    }

                //
                //  For the compressed stream, we need to scan the compressed data
                //  to see how much we actually have to write.
                //

#ifdef  COMPRESS_ON_WIRE
                } else {

                    //
                    //  Don't walk off the end of the data being written, because that
                    //  would cause bogus faults in the compressed stream.
                    //

                    if (SizeToCompress > ByteCount) {
                        SizeToCompress = ByteCount;
                    }

                    //
                    //  Map the compressed data.
                    //

                    CcMapData( Scb->Header.FileObjectC,
                               (PLARGE_INTEGER)&StartVbo,
                               (ULONG)SizeToCompress,
                               TRUE,
                               &Bcb,
                               &UncompressedBuffer );

#ifdef MAPCOUNT_DBG
                    IrpContext->MapCount++;
#endif

                    FinalCompressedSize = 0;

                    //
                    //  Loop until we get an error or stop advancing.
                    //

                    RangePtr = UncompressedBuffer + CompressionUnit;
                    do {
                        Status = RtlDescribeChunk( (USHORT)((Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK) + 1),
                                                   &UncompressedBuffer,
                                                   (PUCHAR)RangePtr,
                                                   (PUCHAR *)&SystemBuffer,
                                                   &CompressedSize );

                        //
                        //  Remember if we see any nonzero chunks
                        //

                        FinalCompressedSize |= CompressedSize;

                    } while (NT_SUCCESS(Status));

                    //
                    //  If we terminated on anything but STATUS_NO_MORE_ENTRIES, we
                    //  somehow picked up some bad data.
                    //

                    if (Status != STATUS_NO_MORE_ENTRIES) {
                        ASSERT(Status == STATUS_NO_MORE_ENTRIES);
                        NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
                    }
                    Status = STATUS_SUCCESS;

                    //
                    //  If we got any nonzero chunks, then calculate size of buffer to write.
                    //  (Size does not include terminating Ushort of 0.)
                    //

                    if (FinalCompressedSize != 0) {
                        FinalCompressedSize =
                            (ULONG)((ULONG_PTR)UncompressedBuffer & (CompressionUnit - 1));

                        //
                        //  If the Lazy Writer is writing beyond the end of the compression
                        //  unit (there are dirty pages at the end of the compression unit)
                        //  then we can throw this data away.
                        //

                        if (FinalCompressedSize < CompressionUnitOffset) {

                            //
                            //  Set up to move to the next compression unit.
                            //

                            NoopRange = TRUE;
                            ChangeAllocation = FALSE;

                            //
                            //  Set TempVbo to the compression unit offset.  The
                            //  number of bytes to skip over is the remaining
                            //  bytes in a compression unit.
                            //

                            TempVbo = CompressionUnitOffset;

                        //
                        //  If the Lazy Writer does not have the beginning of the compression
                        //  unit then raise out of here and wait for the write which includes
                        //  the beginning.
                        //

                        } else if (CompressionUnitOffset != 0) {
#ifdef NTFS_RWC_DEBUG
                            ASSERT( !NtfsBreakOnConflict ||
                                    (Scb->LazyWriteThread[1] == PsGetCurrentThread()) );
#endif
                            NtfsRaiseStatus( IrpContext, STATUS_FILE_LOCK_CONFLICT, NULL, NULL );

                        //
                        //  If we saw more chunks than our writer is trying to write (it
                        //  more or less has to be the Lazy Writer), then we need to reject
                        //  this request and assume he will come back later for the entire
                        //  amount.  This could be a problem for WRITE_THROUGH.
                        //

                        } else if (FinalCompressedSize > ByteCount) {
#ifdef NTFS_RWC_DEBUG
                            ASSERT( !NtfsBreakOnConflict ||
                                    (Scb->LazyWriteThread[1] == PsGetCurrentThread()) );
#endif
                            ASSERT( Scb->LazyWriteThread[1] == PsGetCurrentThread() );
                            NtfsRaiseStatus( IrpContext, STATUS_FILE_LOCK_CONFLICT, NULL, NULL );
                        }
                    }
                }
#endif

                NtfsUnpinBcb( IrpContext, &Bcb );

                //
                //  Round the FinalCompressedSize up to a cluster boundary now.
                //

                FinalCompressedSize = (FinalCompressedSize + Vcb->BytesPerCluster - 1) &
                                      ~(Vcb->BytesPerCluster - 1);

                //
                //  If the Status was not success, then we have to do something.
                //

                if (Status != STATUS_SUCCESS) {

                    //
                    //  If it was actually an error, then we will raise out of
                    //  here.
                    //

                    if (!NT_SUCCESS(Status)) {
                        NtfsRaiseStatus( IrpContext, Status, NULL, NULL );

                    //
                    //  If the buffer compressed to all zeros, then we will
                    //  not allocate anything.
                    //

                    } else if (Status == STATUS_BUFFER_ALL_ZEROS) {
                        FinalCompressedSize = 0;
                    }
                }

                if (!NoopRange) {

                    StartingVcn = LlClustersFromBytesTruncate( Vcb, StartVbo );

                    //
                    //  Time to get the Scb if we do not have it already.  We
                    //  need to serialize our changes of the Mcb.
                    //  N.B. -- We may _not_ always be the top level request.
                    //  Converting a compressed stream to nonresident can
                    //  send us down this path with Irp != OriginatingIrp.
                    //

                    if (!CompressionContext->ScbAcquired) {

                        NtfsPurgeFileRecordCache( IrpContext );
                        NtfsAcquireExclusiveScb( IrpContext, Scb );
                        CompressionContext->ScbAcquired = TRUE;
                    }

                    NextIsAllocated = NtfsLookupAllocation( IrpContext,
                                                            Scb,
                                                            StartingVcn,
                                                            &NextLcn,
                                                            &NextClusterCount,
                                                            &RangePtr,
                                                            &Index );

                    //
                    //  If this originally was a sparse write but we were defragging
                    //  then we need to be careful if the range is unallocated.  In
                    //  that case we really need to do the full sparse support.  Break
                    //  out of the loop at this point and perform the IO with
                    //  the ranges we already have.
                    //

                    if (!NextIsAllocated && OriginalSparseWrite && !SparseWrite) {

                        break;
                    }

                    //
                    //  If the StartingVcn is allocated, we always have to check
                    //  if we need to delete something, or if in the unusual case
                    //  there is a hole there smaller than a compression unit.
                    //
                    //  If this is a sparse write then we never have anything to
                    //  deallocate.
                    //

                    FinalCompressedClusters = ClustersFromBytes( Vcb, FinalCompressedSize );
                    ChangeAllocation = FALSE;

                    if (SparseWrite) {

                        //
                        //  It is possible that the compression unit has been allocated since we
                        //  tested allocation when we entered this routine.  If so we can
                        //  write directly to disk in the allocated range.  We need to
                        //  modify the range being written however.
                        //

                        if (NextIsAllocated) {

                            //
                            //  Move forward to the beginning of this write.
                            //

                            SparseFileBias = CompressionUnitOffset;
                            ((ULONG) StartVbo) += CompressionUnitOffset;
                            CompressedOffset += CompressionUnitOffset;
                            BufferOffset += CompressionUnitOffset;
                            FinalCompressedSize -= CompressionUnitOffset;

                            if (FinalCompressedSize > (ByteCount - CompressionUnitOffset)) {

                                FinalCompressedSize = (ByteCount - CompressionUnitOffset);
                            }

                            StartingVcn = LlClustersFromBytesTruncate( Vcb, StartVbo );

                            //
                            //  Remember that we might not be on a cluster boundary at this point.
                            //

                            ClusterOffset = (ULONG) StartVbo & Vcb->ClusterMask;

                            //
                            //  Look up the correct range on the disk.
                            //

                            NextIsAllocated = NtfsLookupAllocation( IrpContext,
                                                                    Scb,
                                                                    StartingVcn,
                                                                    &NextLcn,
                                                                    &NextClusterCount,
                                                                    &RangePtr,
                                                                    &Index );

                            ASSERT( NextIsAllocated );

                        } else {

                            //
                            //  Set the Scb flag to indicate we need to serialize non-cached IO
                            //  with the Mcb.
                            //

                            SetFlag( Scb->ScbState, SCB_STATE_PROTECT_SPARSE_MCB );
                        }

                    } else if (NextIsAllocated || (NextClusterCount < CompressionUnitInClusters)) {

                        VCN TempClusterCount;

                        //
                        //  If we need fewer clusters than allocated, then just allocate them.
                        //  But if we need more clusters, then deallocate all the ones we have
                        //  now, otherwise we could corrupt file data if we back out a write
                        //  after actually having written the sectors.  (For example, we could
                        //  extend from 5 to 6 clusters and write 6 clusters of compressed data.
                        //  If we have to back that out we will have a 6-cluster pattern of
                        //  compressed data with one sector deallocated!).
                        //

                        NextIsAllocated = NextIsAllocated &&
                                          (NextClusterCount >= FinalCompressedClusters);

                        //
                        //  If we are cleaning up a hole, or the next run is unuseable,
                        //  then make sure we just delete it rather than sliding the
                        //  tiny run up with SplitMcb.  Note that we have the Scb exclusive,
                        //  and that since all compressed files go through the cache, we
                        //  know that the dirty pages can't go away even if we spin out
                        //  of here with ValidDataToDisk bumped up too high.
                        //

                        SavedValidDataToDisk = Scb->ValidDataToDisk;
                        if (!NextIsAllocated && ((StartVbo + CompressionUnit) > Scb->ValidDataToDisk)) {
                            Scb->ValidDataToDisk = StartVbo + CompressionUnit;
                        }

                        //
                        //  Also, we need to handle the case where a range within
                        //  ValidDataToDisk is fully allocated.  If we are going to compress
                        //  now, then we have the same problem with failing after writing
                        //  the compressed data out, i.e., because we are fully allocated
                        //  we would see the data as uncompressed after an abort, yet we
                        //  have written compressed data. We do not implement the entire
                        //  loop necessary to really see if the compression unit is fully
                        //  allocated - we just verify that NextClusterCount is less than
                        //  a compression unit and that the next run is not allocated.  Just
                        //  because the next contiguous run is also allocated does not guarantee
                        //  that the compression unit is fully allocated, but maybe we will
                        //  get some small defrag gain by reallocating what we need in a
                        //  single run.
                        //

                        NextIsAllocated = NextIsAllocated &&
                                          ((StartVbo >= Scb->ValidDataToDisk) ||
                                           (FinalCompressedClusters == CompressionUnitInClusters) ||
                                           ((NextClusterCount < CompressionUnitInClusters) &&
                                            (!NtfsLookupAllocation( IrpContext,
                                                                    Scb,
                                                                    StartingVcn + NextClusterCount,
                                                                    &NextLbo,
                                                                    &TempClusterCount,
                                                                    &RangePtr,
                                                                    &Index ) ||
                                             (NextLbo != UNUSED_LCN))));

                        //
                        //  If we are not keeping any allocation, or we need less
                        //  than a compression unit, then call NtfsDeleteAllocation.
                        //


                        if (!NextIsAllocated ||
                            (FinalCompressedClusters < CompressionUnitInClusters)) {

                            //
                            //  Skip this explicit delete if we are rewriting within
                            //  ValidDataToDisk.  We know we won't be doing a SplitMcb.
                            //

                            DeleteVcn = StartingVcn;

                            if (NextIsAllocated) {

                                DeleteVcn += FinalCompressedClusters;
                            }

                            DeleteCount = CompressionUnit;

                            if (CompressionUnit == 0) {

                                DeleteCount = ByteCount;
                            }

                            DeleteCount = LlClustersFromBytes( Vcb, DeleteCount );

                            //
                            //  Take the explicit DeleteAllocation path if there is a chance
                            //  we might do a SplitMcb.  This is true for a compressed write
                            //  which extends into a new compression unit.
                            //

                            if ((CompressionUnit != 0) &&

                                ((StartingVcn + DeleteCount) >
                                 LlClustersFromBytesTruncate( Vcb,
                                                              ((Scb->ValidDataToDisk + CompressionUnit - 1) &
                                                               ~((LONGLONG) (CompressionUnit - 1))) ))) {

                                NtfsDeleteAllocation( IrpContext,
                                                      IrpSp->FileObject,
                                                      Scb,
                                                      DeleteVcn,
                                                      StartingVcn + DeleteCount - 1,
                                                      TRUE,
                                                      FALSE );

                                //
                                //  Set the DeleteCount to 0 so we know there is no other deallocate
                                //  to do.
                                //

                                DeleteCount = 0;

                            //
                            //  Bias the DeleteCount by the number of clusters into the compression
                            //  unit we are beginning.
                            //

                            } else {

                                DeleteCount -= (DeleteVcn - StartingVcn);
                                ASSERT( DeleteCount >= 0 );
                            }

                            ChangeAllocation = TRUE;
                        }

                        Scb->ValidDataToDisk = SavedValidDataToDisk;
                    }

                    //
                    //  Now deal with the case where we do need to allocate space.
                    //

                    TempVbo = StartVbo;
                    if (FinalCompressedSize != 0) {

                        //
                        //  If this compression unit is not (sufficiently) allocated, then
                        //  do it now.
                        //

                        if (!NextIsAllocated ||
                            ((NextClusterCount < FinalCompressedClusters) && !SparseWrite)) {

                            AllocateCount = FinalCompressedClusters;

                        } else {

                            AllocateCount = 0;
                        }

                        //
                        //  Now call our reallocate routine to do the work.
                        //

                        if ((DeleteCount != 0) || (AllocateCount != 0)) {

                            NtfsReallocateRange( IrpContext,
                                                 Scb,
                                                 DeleteVcn,
                                                 DeleteCount,
                                                 StartingVcn,
                                                 AllocateCount,
                                                 NULL );

                            ChangeAllocation = TRUE;
                        }

                        //
                        //  If we added space, something may have moved, so we must
                        //  look up our position and get a new index.
                        //

                        if (ChangeAllocation) {

                            NtfsLookupAllocation( IrpContext,
                                                  Scb,
                                                  StartingVcn,
                                                  &NextLcn,
                                                  &NextClusterCount,
                                                  &RangePtr,
                                                  &Index );
                        }

                        //
                        //  Now loop to update the IoRuns array.
                        //

                        CompressedOffset += FinalCompressedSize;
                        while (FinalCompressedSize != 0) {

                            LONGLONG RunOffset;

                            //
                            //  Get the actual number of clusters being written.
                            //

                            FinalCompressedClusters = ClustersFromBytes( Vcb, FinalCompressedSize );

                            //
                            //  Try to lookup the first run.  If there is just a single run,
                            //  we may just be able to pass it on.  Index into the Mcb directly
                            //  for greater speed.
                            //

                            NextIsAllocated = NtfsGetSequentialMcbEntry( &Scb->Mcb,
                                                                         &RangePtr,
                                                                         Index,
                                                                         &StartingVcn,
                                                                         &NextLcn,
                                                                         &NextClusterCount );

                            //
                            //  It is possible that we could walk across an Mcb boundary and the
                            //  following entry isn't loaded.  In that case we want to look the
                            //  up the allocation specifically to force the Mcb load.
                            //

                            if (Index == MAXULONG) {

                                //
                                //  A failure on NtfsGetSequentialMcbEntry above will modify StartingVcn.
                                //  Recalculate here based on TempVbo.
                                //

                                StartingVcn = LlClustersFromBytesTruncate( Vcb, TempVbo );
                                NextIsAllocated = NtfsLookupAllocation( IrpContext,
                                                                        Scb,
                                                                        StartingVcn,
                                                                        &NextLcn,
                                                                        &NextClusterCount,
                                                                        &RangePtr,
                                                                        &Index );

                                ASSERT( NextIsAllocated );
                                NextIsAllocated = NtfsGetSequentialMcbEntry( &Scb->Mcb,
                                                                             &RangePtr,
                                                                             Index,
                                                                             &StartingVcn,
                                                                             &NextLcn,
                                                                             &NextClusterCount );
                            }

                            Index += 1;

                            ASSERT(NextIsAllocated);
                            ASSERT(NextLcn != UNUSED_LCN);

                            //
                            //  Our desired Vcn could be in the middle of this run, so do
                            //  some adjustments.
                            //

                            RunOffset = Int64ShraMod32(TempVbo, Vcb->ClusterShift) - StartingVcn;

                            ASSERT( ((PLARGE_INTEGER)&RunOffset)->HighPart >= 0 );
                            ASSERT( NextClusterCount > RunOffset );

                            NextLcn = NextLcn + RunOffset;
                            NextClusterCount = NextClusterCount - RunOffset;

                            //
                            //  Adjust from NextLcn to Lbo.  NextByteCount may overflow out of 32 bits
                            //  but we will catch that below when we compare clusters.
                            //

                            NextLbo = LlBytesFromClusters( Vcb, NextLcn ) + ClusterOffset;
                            NextByteCount = BytesFromClusters( Vcb, (ULONG)NextClusterCount );

                            //
                            //  If next run is larger than we need, "ya get what you need".
                            //  Note that after this we are guaranteed that the HighPart of
                            //  NextByteCount is 0.
                            //

                            if (NextClusterCount >= FinalCompressedClusters) {

                                NextByteCount = FinalCompressedSize;
                            }

                            //
                            //  If the Lbos are contiguous, then we can do a contiguous
                            //  transfer, so we just increase the current byte count.
                            //  For compressed streams, note however that the BufferOffset
                            //  may not be contiguous!
                            //

                            if ((*NumberRuns != 0) &&
                                (NextLbo == (IoRuns[*NumberRuns - 1].StartingLbo +
                                                      IoRuns[*NumberRuns - 1].ByteCount)) &&
                                (BufferOffset == (IoRuns[*NumberRuns - 1].BufferOffset +
                                                      IoRuns[*NumberRuns - 1].ByteCount))) {

                                IoRuns[*NumberRuns - 1].ByteCount += NextByteCount;

                            //
                            //  Otherwise it is time to start a new run, if there is space for one.
                            //

                            } else {

                                //
                                //  If we have filled up the current I/O runs array, then we
                                //  will grow it once to a size which would allow the worst
                                //  case compression unit (all noncontiguous clusters) to
                                //  start at the penultimate index.  The following if
                                //  statement enforces this case as the worst case.  With 16
                                //  clusters per compression unit, the theoretical maximum
                                //  number of parallel I/Os would be 16 + NTFS_MAX_PARALLEL_IOS - 1,
                                //  since we stop on the first compression unit
                                //  boundary after the penultimate run.  Normally, of course we
                                //  will do much fewer.
                                //

                                if ((*NumberRuns == NTFS_MAX_PARALLEL_IOS) &&
                                    (CompressionContext->AllocatedRuns == NTFS_MAX_PARALLEL_IOS)) {

                                    PIO_RUN NewIoRuns;

                                    NewIoRuns = NtfsAllocatePool( NonPagedPool,
                                                                   (CompressionUnitInClusters + NTFS_MAX_PARALLEL_IOS - 1) * sizeof(IO_RUN) );

                                    RtlCopyMemory( NewIoRuns,
                                                   CompressionContext->IoRuns,
                                                   NTFS_MAX_PARALLEL_IOS * sizeof(IO_RUN) );

                                    IoRuns = CompressionContext->IoRuns = NewIoRuns;
                                    CompressionContext->AllocatedRuns = CompressionUnitInClusters + NTFS_MAX_PARALLEL_IOS - 1;
                                }

                                //
                                // We remember each piece of a parallel run by saving the
                                // essential information in the IoRuns array.  The tranfers
                                // will be started up in parallel below.
                                //

                                IoRuns[*NumberRuns].StartingVbo = TempVbo;
                                IoRuns[*NumberRuns].StartingLbo = NextLbo;
                                IoRuns[*NumberRuns].BufferOffset = BufferOffset;
                                IoRuns[*NumberRuns].ByteCount = NextByteCount;
                                *NumberRuns += 1;
                            }

                            //
                            // Now adjust everything for the next pass through the loop.
                            //

                            BufferOffset += NextByteCount;
                            TempVbo = TempVbo + NextByteCount;
                            FinalCompressedSize -= NextByteCount;
                            ClusterOffset = 0;
                        }

                    } else if (DeleteCount != 0) {

                        //
                        //  Call our reallocate routine.
                        //

                        NtfsReallocateRange( IrpContext,
                                             Scb,
                                             DeleteVcn,
                                             DeleteCount,
                                             0,
                                             0,
                                             NULL );

                        ChangeAllocation = TRUE;
                    }

                }

                //
                //  For the compressed stream, we need to advance the buffer offset to the
                //  end of a compression unit, so that if adjacent compression units are
                //  being written, we correctly advance over the unused clusters in the
                //  compressed stream.
                //


                if (FlagOn(StreamFlags, COMPRESSED_STREAM)) {
                    BufferOffset += CompressionUnit - (ULONG)(TempVbo & (CompressionUnit - 1));
                }

                //
                //  If this is the unnamed data stream then we need to update
                //  the total allocated size.
                //

                if (ChangeAllocation &&
                    FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA ) &&
                    (Scb->Fcb->Info.AllocatedLength != Scb->TotalAllocated)) {

                    Scb->Fcb->Info.AllocatedLength = Scb->TotalAllocated;
                    SetFlag( Scb->Fcb->InfoFlags, FCB_INFO_CHANGED_ALLOC_SIZE );
                }

                UncompressedOffset += CompressionUnit - CompressionUnitOffset;

                //
                //  Now reduce the byte counts by the compression unit we just
                //  transferred.
                //

                if ((CompressionUnit != 0) && (ByteCount > CompressionUnit)) {
                    StartVbo += (CompressionUnit - SparseFileBias);
                    ByteCount -= CompressionUnit;
                } else {
                    StartVbo += (ByteCount - SparseFileBias);
                    ByteCount = 0;
                    leave;
                }

                CompressionUnitOffset = 0;
            }

        } finally {

            NtfsUnpinBcb( IrpContext, &Bcb );
        }

        //
        //  See if we need to advance ValidDataToDisk.
        //

        if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) &&
            (StartVbo > Scb->ValidDataToDisk)) {

            ASSERT( (Scb->ScbSnapshot != NULL) && (Scb->ScbSnapshot->ValidDataToDisk == Scb->ValidDataToDisk) );
            Scb->ValidDataToDisk = StartVbo;
        }

        return ByteCount + ReturnByteCount;
    }
}


//
//  Internal support routine
//

NTSTATUS
NtfsFinishBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PVBO StartingVbo,
    IN ULONG ByteCount,
    IN ULONG NumberRuns,
    IN PCOMPRESSION_CONTEXT CompressionContext,
    IN ULONG StreamFlags
    )

/*++

Routine Description:

    This routine performs post processing for noncached transfers of
    compressed or encrypted data.  For reads, the decompression actually takes
    place here.  For reads and writes, all necessary cleanup operations are
    performed.

Arguments:

    IrpContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    Irp - Supplies the requesting Irp.

    Scb - Supplies the stream file to act on.

    StartingVbo - The starting point for the operation.

    ByteCount - The lengh of the operation.

    CompressionContext - Supplies information related to the compression
                         filled in by NtfsPrepareBuffers.

    StreamFlags - Supplies either 0 or some combination of COMPRESSED_STREAM
                  and ENCRYPTED_STREAM

Return Value:

    Status from the operation

--*/

{
    VCN CurrentVcn, NextVcn, BeyondLastVcn;
    LCN NextLcn;

    ULONG Run;

    ULONG NextByteCount;
    LONGLONG NextClusterCount;

    LARGE_INTEGER OffsetWithinFile;

    BOOLEAN NextIsAllocated;
    BOOLEAN AlreadyFilled;

    PVOID SystemBuffer = NULL;

    ULONG CompressionUnit, CompressionUnitInClusters;
    ULONG StartingOffset, UncompressedOffset, CompressedOffset;
    ULONG CompressedSize;
    LONGLONG UncompressedSize;

    LONGLONG CurrentAllocatedClusterCount;

    NTSTATUS Status = STATUS_SUCCESS;

    PVCB Vcb = Scb->Vcb;

    PAGED_CODE();

    //
    //  If this is a normal termination of a read, then let's give him the
    //  data...
    //

    ASSERT( (Scb->CompressionUnit != 0) ||
            (Scb->EncryptionContext != NULL) ||
            FlagOn( StreamFlags, COMPRESSED_STREAM ) );

    //
    //  We never want to be here if this is the read raw encrypted data case.
    //

    ASSERT( !FlagOn( StreamFlags, ENCRYPTED_STREAM ) );

    if (IrpContext->MajorFunction == IRP_MJ_READ) {

        //
        //  If there is an encryption context then transform the data.
        //

        if ((Scb->EncryptionContext != NULL) &&
            (NtfsData.EncryptionCallBackTable.AfterReadProcess != NULL)) {

            ASSERT ( NtfsIsTypeCodeEncryptible( Scb->AttributeTypeCode ) );

            //
            //  If the compression context has a buffer then we will use that.
            //

            if (CompressionContext->CompressionBuffer != NULL) {

                SystemBuffer = CompressionContext->CompressionBuffer;

            } else {

                SystemBuffer = NtfsMapUserBuffer( Irp );
            }

            //
            //  Now look at each run of real data heading coming from the disk and
            //  let the encryption driver decrypt it.
            //

            for ( Run = 0; Run < NumberRuns; Run++ ) {

                OffsetWithinFile.QuadPart = CompressionContext->IoRuns[Run].StartingVbo;

                Status = NtfsData.EncryptionCallBackTable.AfterReadProcess(
                                                Add2Ptr(SystemBuffer, CompressionContext->IoRuns[Run].BufferOffset),
                                                &OffsetWithinFile,
                                                CompressionContext->IoRuns[Run].ByteCount,
                                                Scb->EncryptionContext);

                if (!NT_SUCCESS( Status )) {

                    return Status;
                }
            }

            if (!NT_SUCCESS( Status )) {

                return Status;
            }
        }

        //
        //  There may be a compression unit but there is no completion to do
        //  i.e this is an uncompressed sparse file.
        //  We might be operating on an encrypted file as well.
        //  In either case just exit if the file is not compressed.
        //

        if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

            if (SystemBuffer != NULL) {

                KeFlushIoBuffers( Irp->MdlAddress, TRUE, FALSE );
            }

            return STATUS_SUCCESS;
        }

        ASSERT( Scb->CompressionUnit != 0 );
        if (!FlagOn( StreamFlags, COMPRESSED_STREAM )) {

            //
            //  Initialize remaining context for the loop.
            //

            CompressionUnit = Scb->CompressionUnit;
            CompressionUnitInClusters = ClustersFromBytes(Vcb, CompressionUnit);
            CompressedOffset = 0;
            UncompressedOffset = 0;
            Status = STATUS_SUCCESS;

            //
            //  Map the user buffer.
            //

            SystemBuffer = (PVOID)((PCHAR)CompressionContext->SystemBuffer +
                                          CompressionContext->SystemBufferOffset);


            //
            //  Calculate the first Vcn and offset within the compression
            //  unit of the start of the transfer, and lookup the first
            //  run.
            //

            StartingOffset = *((PULONG)StartingVbo) & (CompressionUnit - 1);
            CurrentVcn = LlClustersFromBytes(Vcb, *StartingVbo - StartingOffset);

            NextIsAllocated =
            NtfsLookupAllocation( IrpContext,
                                  Scb,
                                  CurrentVcn,
                                  &NextLcn,
                                  &CurrentAllocatedClusterCount,
                                  NULL,
                                  NULL );

            //
            //  Set NextIsAllocated and NextLcn as the Mcb package would, to show if
            //  we are off the end.
            //

            if (!NextIsAllocated) {
                NextLcn = UNUSED_LCN;
            }

            NextIsAllocated = (BOOLEAN)(CurrentAllocatedClusterCount < (MAXLONGLONG - CurrentVcn));

            //
            //  If this is actually a hole or there was no entry in the Mcb, then
            //  set CurrentAllocatedClusterCount to zero so we will always make the first
            //  pass in the embedded while loop below.
            //

            if (!NextIsAllocated || (NextLcn == UNUSED_LCN)) {
                CurrentAllocatedClusterCount = 0;
            }

            //
            //  Prepare for the initial Mcb scan below by pretending that the
            //  next run has been looked up, and is a contiguous run of 0 clusters!
            //

            NextVcn = CurrentVcn + CurrentAllocatedClusterCount;
            NextClusterCount = 0;

            //
            //  Remember the last Vcn we should look up.
            //

            BeyondLastVcn = *StartingVbo + ByteCount + CompressionUnit - 1;
            ((PLARGE_INTEGER) &BeyondLastVcn)->LowPart &= ~(CompressionUnit - 1);
            BeyondLastVcn = LlClustersFromBytesTruncate( Vcb, BeyondLastVcn );

            //
            //  Loop to return the data.
            //

            while (ByteCount != 0) {

                //
                //  Loop to determine the compressed size of the next compression
                //  unit.  I.e., loop until we either find the end of the current
                //  range of contiguous Vcns, or until we find that the current
                //  compression unit is fully allocated.
                //

                while (NextIsAllocated &&
                       (CurrentAllocatedClusterCount < CompressionUnitInClusters) &&
                       ((CurrentVcn + CurrentAllocatedClusterCount) == NextVcn)) {

                    if ((CurrentVcn + CurrentAllocatedClusterCount) > NextVcn) {

                        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                    }

                    CurrentAllocatedClusterCount = CurrentAllocatedClusterCount + NextClusterCount;

                    //
                    //  Loop to find the next allocated Vcn, or the end of the Mcb.
                    //  None of the interfaces using RangePtr and Index as inputs
                    //  can be used here, such as NtfsGetSequentialMcbEntry, because
                    //  we do not have the Scb main resource acquired, and writers can
                    //  be moving stuff around in parallel.
                    //

                    while (TRUE) {

                        //
                        //  Set up NextVcn for next call
                        //

                        NextVcn += NextClusterCount;

                        //
                        //  Exit if we are past the end of the range being decompressed.
                        //

                        if (NextVcn >= BeyondLastVcn) {

                            NextIsAllocated = TRUE;
                            break;
                        }

                        NextIsAllocated = NtfsLookupAllocation( IrpContext,
                                                                Scb,
                                                                NextVcn,
                                                                &NextLcn,
                                                                &NextClusterCount,
                                                                NULL,
                                                                NULL );

                        //
                        //  Set NextIsAllocated and NextLcn as the Mcb package would, to show if
                        //  we are off the end.
                        //

                        if (!NextIsAllocated) {
                            NextLcn = UNUSED_LCN;
                        }

                        NextIsAllocated = (BOOLEAN)(NextClusterCount < (MAXLONGLONG - NextVcn));

                        //
                        //  Get out if we hit the end or see something allocated.
                        //

                        if (!NextIsAllocated || (NextLcn != UNUSED_LCN)) {
                            break;
                        }
                    }
                }

                //
                //  The compression unit is fully allocated.
                //

                if (CurrentAllocatedClusterCount >= CompressionUnitInClusters) {

                    CompressedSize = CompressionUnit;
                    CurrentAllocatedClusterCount = CurrentAllocatedClusterCount - CompressionUnitInClusters;

                //
                //  Otherwise calculate how much is allocated at the current Vcn
                //  (if any).
                //

                } else {

                    CompressedSize = BytesFromClusters(Vcb, (ULONG)CurrentAllocatedClusterCount);
                    CurrentAllocatedClusterCount = 0;
                }

                //
                //  The next time through this loop, we will be working on the next
                //  compression unit.
                //

                CurrentVcn = CurrentVcn + CompressionUnitInClusters;

                //
                //  Calculate uncompressed size of the desired fragment, or
                //  entire compression unit.
                //

                NtfsAcquireFsrtlHeader( Scb );
                UncompressedSize = Scb->Header.FileSize.QuadPart -
                                   (*StartingVbo + UncompressedOffset);
                NtfsReleaseFsrtlHeader( Scb );

                if (UncompressedSize > CompressionUnit) {
                    (ULONG)UncompressedSize = CompressionUnit;
                }

                //
                //  Calculate how much we want now, based on StartingOffset and
                //  ByteCount.
                //

                NextByteCount = CompressionUnit - StartingOffset;
                if (NextByteCount > ByteCount) {
                    NextByteCount = ByteCount;
                }

                //
                //  Practice safe access
                //

                try {

                    //
                    //  There were no clusters allocated, return 0's.
                    //

                    AlreadyFilled = FALSE;
                    if (CompressedSize == 0) {

                        RtlZeroMemory( (PUCHAR)SystemBuffer + UncompressedOffset,
                                       NextByteCount );

                    //
                    //  The compression unit was fully allocated, just copy.
                    //

                    } else if (CompressedSize == CompressionUnit) {

                        RtlCopyMemory( (PUCHAR)SystemBuffer + UncompressedOffset,
                                       CompressionContext->CompressionBuffer +
                                         CompressedOffset + StartingOffset,
                                       NextByteCount );

#ifdef SYSCACHE
                        if (FlagOn(Scb->ScbState, SCB_STATE_SYSCACHE_FILE)) {

                            FsRtlVerifySyscacheData( IoGetCurrentIrpStackLocation( IrpContext->OriginatingIrp )->FileObject,
                                                     Add2Ptr( SystemBuffer, UncompressedOffset ),
                                                     NextByteCount,
                                                     (ULONG)*StartingVbo + UncompressedOffset );
                        }
#endif

                    //
                    //  Caller does not want the entire compression unit, decompress
                    //  a fragment.
                    //

                    } else if (NextByteCount < CompressionUnit) {

                        //
                        //  If we have not already allocated the workspace, then do it.
                        //

                        if (CompressionContext->WorkSpace == NULL) {
                            ULONG CompressWorkSpaceSize;
                            ULONG FragmentWorkSpaceSize;

                            ASSERT((Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK) != 0);

                            (VOID) RtlGetCompressionWorkSpaceSize( (USHORT)((Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK) + 1),
                                                                   &CompressWorkSpaceSize,
                                                                   &FragmentWorkSpaceSize );

                            //
                            //  Allocate first from non-paged, then paged.  The typical
                            //  size of this workspace is just over a single page so
                            //  if both allocations fail then the system is running
                            //  a reduced capacity.  Return an error to the user
                            //  and let him retry.
                            //

                            CompressionContext->WorkSpace = NtfsAllocatePoolWithTagNoRaise( NonPagedPool, FragmentWorkSpaceSize, 'wftN' );

                            if (CompressionContext->WorkSpace == NULL) {

                                CompressionContext->WorkSpace =
                                    NtfsAllocatePool( PagedPool, FragmentWorkSpaceSize );
                            }
                        }

                        while (TRUE) {

                            Status =
                            RtlDecompressFragment( (USHORT)((Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK) + 1),
                                                   (PUCHAR)SystemBuffer + UncompressedOffset,
                                                   NextByteCount,
                                                   CompressionContext->CompressionBuffer + CompressedOffset,
                                                   CompressedSize,
                                                   StartingOffset,
                                                   (PULONG)&UncompressedSize,
                                                   CompressionContext->WorkSpace );

                            ASSERT(NT_SUCCESS( Status ) || !NtfsStopOnDecompressError);

                            if (NT_SUCCESS(Status)) {

                                RtlZeroMemory( (PUCHAR)SystemBuffer + UncompressedOffset + (ULONG)UncompressedSize,
                                               NextByteCount - (ULONG)UncompressedSize );

#ifdef SYSCACHE
                                if (FlagOn(Scb->ScbState, SCB_STATE_SYSCACHE_FILE)) {

                                    FsRtlVerifySyscacheData( IoGetCurrentIrpStackLocation( IrpContext->OriginatingIrp )->FileObject,
                                                             Add2Ptr( SystemBuffer, UncompressedOffset ),
                                                             NextByteCount,
                                                             (ULONG)*StartingVbo + UncompressedOffset );
                                }
#endif
                                break;

                            } else {

                                //
                                //  The compressed buffer could have been bad.  We need to fill
                                //  it with a pattern and get on with life.  Someone could be
                                //  faulting it in just to overwrite it, or it could be a rare
                                //  case of corruption.  We fill the data with a pattern, but
                                //  we must return success so a pagefault will succeed.  We
                                //  do this once, then loop back to decompress what we can.
                                //

                                Status = STATUS_SUCCESS;

                                if (!AlreadyFilled) {

                                    RtlFillMemory( (PUCHAR)SystemBuffer + UncompressedOffset,
                                                   NextByteCount,
                                                   0xDF );
                                    AlreadyFilled = TRUE;

                                } else {
                                    break;
                                }
                            }
                        }

                    //
                    //  Decompress the entire compression unit.
                    //

                    } else {

                        ASSERT(StartingOffset == 0);

                        while (TRUE) {

                            Status =
                            RtlDecompressBuffer( (USHORT)((Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK) + 1),
                                                 (PUCHAR)SystemBuffer + UncompressedOffset,
                                                 NextByteCount,
                                                 CompressionContext->CompressionBuffer + CompressedOffset,
                                                 CompressedSize,
                                                 (PULONG)&UncompressedSize );

                            ASSERT(NT_SUCCESS( Status ) || !NtfsStopOnDecompressError);

                            if (NT_SUCCESS(Status)) {

                                RtlZeroMemory( (PUCHAR)SystemBuffer + UncompressedOffset + (ULONG)UncompressedSize,
                                               NextByteCount - (ULONG)UncompressedSize );
#ifdef SYSCACHE
                                if (FlagOn(Scb->ScbState, SCB_STATE_SYSCACHE_FILE)) {

                                    FsRtlVerifySyscacheData( IoGetCurrentIrpStackLocation( IrpContext->OriginatingIrp )->FileObject,
                                                             Add2Ptr( SystemBuffer, UncompressedOffset ),
                                                             NextByteCount,
                                                             (ULONG)*StartingVbo + UncompressedOffset );
                                }
#endif
                                break;

                            } else {

                                //
                                //  The compressed buffer could have been bad.  We need to fill
                                //  it with a pattern and get on with life.  Someone could be
                                //  faulting it in just to overwrite it, or it could be a rare
                                //  case of corruption.  We fill the data with a pattern, but
                                //  we must return success so a pagefault will succeed.  We
                                //  do this once, then loop back to decompress what we can.
                                //

                                Status = STATUS_SUCCESS;

                                if (!AlreadyFilled) {

                                    RtlFillMemory( (PUCHAR)SystemBuffer + UncompressedOffset,
                                                   NextByteCount,
                                                   0xDB );
                                    AlreadyFilled = TRUE;

                                } else {
                                    break;
                                }
                            }
                        }
                    }

                //
                //  If its an unexpected error then
                //  Probably Gary's decompression routine faulted, but blame it on
                //  the user buffer!
                //

                } except(NtfsCompressionFilter(IrpContext, GetExceptionInformation())) {

                      Status = GetExceptionCode();
                      if (!FsRtlIsNtstatusExpected( Status )) {
                          Status = STATUS_INVALID_USER_BUFFER;
                      }
                }

                if (!NT_SUCCESS(Status)) {
                    break;
                }

                //
                //  Advance these fields for the next pass through.
                //

                StartingOffset = 0;
                UncompressedOffset += NextByteCount;
                CompressedOffset += CompressedSize;
                ByteCount -= NextByteCount;
            }

            //
            //  We now flush the user's buffer to memory.
            //

            KeFlushIoBuffers( CompressionContext->SavedMdl, TRUE, FALSE );
        }

    //
    //  For compressed writes we just checkpoint the transaction and
    //  free all snapshots and resources, then get the Scb back.  Only do this if the
    //  request is for the same Irp as the original Irp.  We don't want to checkpoint
    //  if called from NtfsWriteClusters.
    //

    } else if (Irp == IrpContext->OriginatingIrp) {

        if (CompressionContext->ScbAcquired) {

            BOOLEAN Reinsert = FALSE;

            NtfsCheckpointCurrentTransaction( IrpContext );

            //
            //  We want to empty the exclusive Fcb list but still hold
            //  the current file.  Go ahead and remove it from the exclusive
            //  list and reinsert it after freeing the other entries.
            //

            while (!IsListEmpty(&IrpContext->ExclusiveFcbList)) {

                //
                //  If this is the Scb for this Fcb then remove it from the list.
                //  We have to preserve the number of times this Fcb may have been
                //  acquired outside of PrepareBuffers.
                //

                if ((PFCB)CONTAINING_RECORD( IrpContext->ExclusiveFcbList.Flink,
                                             FCB,
                                             ExclusiveFcbLinks ) == Scb->Fcb) {

                    RemoveEntryList( &Scb->Fcb->ExclusiveFcbLinks );
                    Reinsert = TRUE;

                } else {

                    NtfsReleaseFcb( IrpContext,
                                    (PFCB)CONTAINING_RECORD(IrpContext->ExclusiveFcbList.Flink,
                                                            FCB,
                                                            ExclusiveFcbLinks ));
                }
            }

            ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_USN_JRNL |
                                          IRP_CONTEXT_FLAG_RELEASE_MFT );

            if (Reinsert) {

                InsertHeadList( &IrpContext->ExclusiveFcbList,
                                &Scb->Fcb->ExclusiveFcbLinks );

                //
                //  Release the Scb if we acquired it in PrepareBuffers.  It is
                //  important that we have released the Scb before going back
                //  and faulting into the data section.  Otherwise we could
                //  hit a collided page fault deadlock.
                //

                NtfsReleaseScb( IrpContext, Scb );
                CompressionContext->ScbAcquired = FALSE;
            }
        }
    }

    return Status;
}


PMDL
NtfsLockFileRange (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG Offset,
    IN ULONG Length
    )

/*++

Routine Description:

    This function maps the given range of file into the cachemanager space and
    then probes and locks it down

Arguments:

    Scb - Supplies the stream file to act on.

    Offset - The starting point to be probed and locked

    Length - The lengh of the operation.

Return Value:

    PMDL - a mdl representing the locked area - this mdl must be unlocked and freed by the caller

--*/

{
    NTSTATUS Status;
    PBCB Bcb;
    PVOID Buffer;
    PMDL Mdl = NULL;

    //
    //  File must be cached
    //

    ASSERT( Scb->FileObject != NULL);

    //
    //  Map the offset into the address space
    //

    CcMapData( Scb->FileObject, (PLARGE_INTEGER)&Offset, Length, TRUE, &Bcb, &Buffer );

#ifdef MAPCOUNT_DBG
    IrpContext->MapCount++;
#endif

    //
    //  Lock the data into memory Don't tell Mm here that we plan to write it, as he sets
    //  dirty now and at the unlock below if we do.
    //

    try {

        //
        //  Now attempt to allocate an Mdl to describe the mapped data.
        //

        Mdl = IoAllocateMdl( Buffer, Length, FALSE, FALSE, NULL );

        if (Mdl == NULL) {
            NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
        }

        MmProbeAndLockPages( Mdl, KernelMode, IoReadAccess );

    //
    //  Catch any raises here and clean up appropriately.
    //

    } except(EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();

        CcUnpinData( Bcb );

#ifdef MAPCOUNT_DBG
        IrpContext->MapCount--;
#endif

        if (Mdl != NULL) {

            IoFreeMdl( Mdl );
            Mdl = NULL;
        }

        NtfsRaiseStatus( IrpContext,
                         FsRtlIsNtstatusExpected(Status) ? Status : STATUS_UNEXPECTED_IO_ERROR,
                         NULL,
                         NULL );
    }

    CcUnpinData( Bcb );

#ifdef MAPCOUNT_DBG
    IrpContext->MapCount--;
#endif

    return Mdl;
}


NTSTATUS
NtfsNonCachedIo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN VBO StartingVbo,
    IN ULONG ByteCount,
    IN ULONG StreamFlags
    )

/*++

Routine Description:

    This routine performs the non-cached disk io described in its parameters.
    The choice of a single run is made if possible, otherwise multiple runs
    are executed.

    Sparse files are supported.  If "holes" are encountered, then the user
    buffer is zeroed over the specified range.  This should only happen on
    reads during normal operation, but it can also happen on writes during
    restart, in which case it is also appropriate to zero the buffer.

Arguments:

    IrpContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    Irp - Supplies the requesting Irp.

    Scb - Supplies the stream file to act on.

    StartingVbo - The starting point for the operation.

    ByteCount - The lengh of the operation.

    StreamFlags - Supplies either 0 or some combination of COMPRESSED_STREAM
                  and ENCRYPTED_STREAM

Return Value:

    None.

--*/

{
    ULONG OriginalByteCount, RemainingByteCount;
    ULONG NumberRuns;
    IO_RUN IoRuns[NTFS_MAX_PARALLEL_IOS];
    COMPRESSION_CONTEXT CompressionContext;
    NTSTATUS Status = STATUS_SUCCESS;
    PMDL Mdl = NULL;
    LONGLONG LfsStartingVbo;

    PVCB Vcb = Scb->Fcb->Vcb;

    BOOLEAN Wait;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsNonCachedIo\n") );
    DebugTrace( 0, Dbg, ("Irp           = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, ("MajorFunction = %08lx\n", IrpContext->MajorFunction) );
    DebugTrace( 0, Dbg, ("Scb           = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("StartingVbo   = %016I64x\n", StartingVbo) );
    DebugTrace( 0, Dbg, ("ByteCount     = %08lx\n", ByteCount) );

    //
    //  Initialize some locals.
    //

    OriginalByteCount = ByteCount;

    Wait = (BOOLEAN) FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  Check if we need to do sequential writes.
    //

    if ((IrpContext->MajorFunction == IRP_MJ_WRITE) &&
        FlagOn( Scb->ScbState, SCB_STATE_MODIFIED_NO_WRITE )) {

        IrpContext->Union.NtfsIoContext->IrpSpFlags = SL_FT_SEQUENTIAL_WRITE | SL_WRITE_THROUGH;
    }

    //
    //  Prepare the (first set) of buffers for I/O.
    //

    RtlZeroMemory( &CompressionContext, sizeof(COMPRESSION_CONTEXT) );
    CompressionContext.IoRuns = IoRuns;
    CompressionContext.AllocatedRuns = NTFS_MAX_PARALLEL_IOS;
    CompressionContext.FinishBuffersNeeded =
        ((Scb->CompressionUnit != 0) || (Scb->EncryptionContext != NULL))
        && !FlagOn( StreamFlags, ENCRYPTED_STREAM );


    try {

        //
        //  If this is a write to a compressed file, we want to make sure here
        //  that any fragments of compression units get locked in memory, so
        //  no one will be reading them into the cache while we are mucking with
        //  the Mcb, etc.  We do this right here at the top so that we have
        //  more stack(!), and we get this over with before we have to acquire
        //  the Scb exclusive.
        //

        if ((IrpContext->MajorFunction == IRP_MJ_WRITE) &&
            (Scb->CompressionUnit != 0) &&
            FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

            LONGLONG TempOffset;
            LONGLONG TempRange;
            ULONG CompressionUnit = Scb->CompressionUnit;

#ifdef  COMPRESS_ON_WIRE

            //
            //  For a compressed stream, just make sure the stream exists.
            //

            if (FlagOn( StreamFlags, COMPRESSED_STREAM )) {

                if (Scb->Header.FileObjectC == NULL) {
                    NtfsCreateInternalCompressedStream( IrpContext, Scb, FALSE, NULL );

                    //
                    //  If there is no one who will cause this stream to
                    //  be dereferenced then add an entry on the delayed
                    //  close queue for this.  We can do this test without
                    //  worrying about synchronization since it is OK to have
                    //  an extra entry in the delayed queue.
                    //

                    if ((Scb->CleanupCount == 0) &&
                        (Scb->Fcb->DelayedCloseCount == 0)) {

                        NtfsAddScbToFspClose( IrpContext, Scb, TRUE );
                    }
                }
            //
            //  This better be paging I/O, because we ignore the caller's buffer
            //  and write the entire compression unit out of the section.
            //
            //  We don't want to map in the data in the case where we are called
            //  from write clusters because MM is creating the section for the
            //  file.  Otherwise we will deadlock when Cc tries to create the
            //  section.
            //

            }

#endif



            if (

#ifdef  COMPRESS_ON_WIRE
                !FlagOn( StreamFlags, COMPRESSED_STREAM ) &&
#endif
                ((Irp == IrpContext->OriginatingIrp) ||
                 (Scb->NonpagedScb->SegmentObject.SharedCacheMap != NULL))) {

                PMDL *TempMdl;

                if (Scb->FileObject == NULL) {
                    NtfsCreateInternalAttributeStream( IrpContext,
                                                       Scb,
                                                       FALSE,
                                                       &NtfsInternalUseFile[NONCACHEDIO_FILE_NUMBER] );

                    //
                    //  If there is no one who will cause this stream to
                    //  be dereferenced then add an entry on the delayed
                    //  close queue for this.  We can do this test without
                    //  worrying about synchronization since it is OK to have
                    //  an extra entry in the delayed queue.
                    //

                    if ((Scb->CleanupCount == 0) &&
                        (Scb->Fcb->DelayedCloseCount == 0)) {

                        NtfsAddScbToFspClose( IrpContext, Scb, TRUE );
                    }
                }

                //
                //  Lock the entire range rounded to its compression unit boundaries
                //  First round the start of the range down to a compression unit and then
                //  round the top of the range up to one
                //

                TempOffset = StartingVbo;
                TempOffset &= ~((LONGLONG)CompressionUnit - 1);

                TempRange = StartingVbo + ByteCount + (CompressionUnit - 1);
                TempRange &= ~((LONGLONG)CompressionUnit - 1);

                TempMdl = &Mdl;

                do {

                    LONGLONG MapBoundary;
                    ULONG Range;

                    MapBoundary = TempOffset + VACB_MAPPING_GRANULARITY;
                    MapBoundary &= ~((LONGLONG)VACB_MAPPING_GRANULARITY - 1);

                    Range = (ULONG) min( TempRange - TempOffset, MapBoundary - TempOffset );

                    *TempMdl = NtfsLockFileRange( IrpContext,
                                                  Scb,
                                                  TempOffset,
                                                  Range );

                    TempOffset += Range;
                    TempMdl = &((*TempMdl)->Next );

                } while ( TempOffset != TempRange );

            } else {

                //
                //  This had better be a convert to non-resident.
                //

                ASSERT( StartingVbo == 0 );
                ASSERT( ByteCount <= Scb->CompressionUnit );
            }
        }

        //
        //  Check if need to trim the write for the log file.
        //

        if ((PAGE_SIZE != LFS_DEFAULT_LOG_PAGE_SIZE) &&
            (Scb == Vcb->LogFileScb) &&
            (IrpContext->MajorFunction == IRP_MJ_WRITE)) {

            LfsStartingVbo = StartingVbo;
            LfsCheckWriteRange( &Vcb->LfsWriteData, &LfsStartingVbo, &ByteCount );

            //
            //  If the byte count is now zero then exit this routine.
            //

            if (ByteCount == 0) {

                Irp->IoStatus.Status = STATUS_SUCCESS;
                Irp->IoStatus.Information = ByteCount;
                DebugTrace( -1, Dbg, ("NtfsNonCachedIo -> %08lx\n", Irp->IoStatus.Status) );
                try_return( Status = Irp->IoStatus.Status );
            }

            //
            //  Adjust the buffer offset in the compression context if necessary.
            //

            CompressionContext.SystemBufferOffset = (ULONG) (LfsStartingVbo - StartingVbo);
            StartingVbo = LfsStartingVbo;
        }

        RemainingByteCount = NtfsPrepareBuffers( IrpContext,
                                                 Irp,
                                                 Scb,
                                                 &StartingVbo,
                                                 ByteCount,
                                                 StreamFlags,
                                                 &Wait,
                                                 &NumberRuns,
                                                 &CompressionContext );

        //
        //  If we are writing to an encrypted stream, now is the
        //  time to do the encryption, before we pass the buffer
        //  down to the disk driver below us.
        //

        if ((Scb->EncryptionContext != NULL) &&
            (IrpContext->MajorFunction == IRP_MJ_WRITE) &&
            (NtfsData.EncryptionCallBackTable.BeforeWriteProcess != NULL) &&
            (!FlagOn( StreamFlags, ENCRYPTED_STREAM ))) {

            ASSERT ( NtfsIsTypeCodeEncryptible( Scb->AttributeTypeCode ) );
            ASSERT( NumberRuns > 0 );

            NtfsEncryptBuffers( IrpContext,
                                Irp,
                                Scb,
                                StartingVbo,
                                NumberRuns,
                                &CompressionContext );
        }

        ASSERT( RemainingByteCount < ByteCount );

        if (FlagOn(Irp->Flags, IRP_PAGING_IO)) {
            CollectDiskIoStats(Vcb, Scb, IrpContext->MajorFunction, NumberRuns);
        }

        //
        //  See if the write covers a single valid run, and if so pass
        //  it on.  Notice that if there is a single run but it does not
        //  begin at the beginning of the buffer then we will still need to
        //  allocate an associated Irp for this.
        //

        if ((RemainingByteCount == 0) &&
            (((NumberRuns == 1)
             && (CompressionContext.IoRuns[0].BufferOffset == 0))

              ||

            (NumberRuns == 0))) {

            DebugTrace( 0, Dbg, ("Passing Irp on to Disk Driver\n") );

            //
            //  See if there is an allocated run
            //

            if (NumberRuns == 1) {

                DebugTrace( 0, Dbg, ("One run\n") );

                //
                //  Now set up the Irp->IoStatus.  It will be modified by the
                //  completion routine in case of error or verify required.
                //

                Irp->IoStatus.Status = STATUS_SUCCESS;

                //
                //  We will continously try the I/O if we get a verify required
                //  back and can verify the volume
                //

                while (TRUE) {

                    //
                    //  Do the I/O and wait for it to finish
                    //

                    NtfsSingleAsync( IrpContext,
                                     Vcb->TargetDeviceObject,
                                     CompressionContext.IoRuns[0].StartingLbo,
                                     CompressionContext.IoRuns[0].ByteCount,
                                     Irp,
                                     IrpContext->MajorFunction );

                    //
                    //  If this is an asynch transfer we return STATUS_PENDING.
                    //

                    if (!Wait) {

                        DebugTrace( -1, Dbg, ("NtfsNonCachedIo -> STATUS_PENDING\n") );
                        try_return(Status = STATUS_PENDING);

                    } else {

                        NtfsWaitSync( IrpContext );
                    }

                    //
                    //  If we didn't get a verify required back then break out of
                    //  this loop
                    //

                    if (Irp->IoStatus.Status != STATUS_VERIFY_REQUIRED) { break; }

                    //
                    //  Otherwise we need to verify the volume, and if it doesn't
                    //  verify correctly the we dismount the volume and raise our
                    //  error
                    //

                    if (!NtfsPerformVerifyOperation( IrpContext, Vcb )) {

                        //**** NtfsPerformDismountOnVcb( IrpContext, Vcb, TRUE, NULL );
                        ClearFlag( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED );

                        NtfsRaiseStatus( IrpContext, STATUS_FILE_INVALID, NULL, NULL );
                    }

                    //
                    //  The volume verified correctly so now clear the verify bit
                    //  and try and I/O again
                    //

                    ClearFlag( Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME );

                    //
                    //  Reset the status before retrying.
                    //

                    Irp->IoStatus.Status = STATUS_SUCCESS;
                }

                //
                //  See if we need to do a hot fix.  Hotfix if the request failed
                //  (except if called from WriteClusters) or we couldn't revert
                //  a USA block.
                //

                if ((!FT_SUCCESS( Irp->IoStatus.Status ) &&
                     ((IrpContext->MajorFunction != IRP_MJ_WRITE) ||
                      (Irp == IrpContext->OriginatingIrp))) ||
                    (FlagOn(Scb->ScbState, SCB_STATE_USA_PRESENT) &&
                     (IrpContext->MajorFunction == IRP_MJ_READ) &&
                     !NtfsVerifyAndRevertUsaBlock( IrpContext,
                                                   Scb,
                                                   NtfsMapUserBuffer( Irp ),
                                                   OriginalByteCount,
                                                   StartingVbo ))) {

                    //
                    //  Try to fix the problem
                    //

                    NtfsFixDataError( IrpContext,
                                      Scb,
                                      Vcb->TargetDeviceObject,
                                      Irp,
                                      1,
                                      CompressionContext.IoRuns );
                }

            //
            //  Show that we successfully read zeros for the deallocated range.
            //

            } else {

                Irp->IoStatus.Status = STATUS_SUCCESS;
                Irp->IoStatus.Information = ByteCount;
            }

            DebugTrace( -1, Dbg, ("NtfsNonCachedIo -> %08lx\n", Irp->IoStatus.Status) );
            try_return( Status = Irp->IoStatus.Status );
        }

        //
        //  If there are bytes remaining and we cannot wait, then we must
        //  post this request unless we are doing paging io.
        //

        if (!Wait && (RemainingByteCount != 0)) {

            if (!FlagOn( Irp->Flags, IRP_PAGING_IO )) {

                NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
            }

            Wait = TRUE;
            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

            RtlZeroMemory( IrpContext->Union.NtfsIoContext, sizeof( NTFS_IO_CONTEXT ));

            //
            //  Store whether we allocated this context structure in the structure
            //  itself.
            //

            IrpContext->Union.NtfsIoContext->AllocatedContext =
                BooleanFlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT );

            KeInitializeEvent( &IrpContext->Union.NtfsIoContext->Wait.SyncEvent,
                               NotificationEvent,
                               FALSE );
        }

        //
        //  Now set up the Irp->IoStatus.  It will be modified by the
        //  multi-completion routine in case of error or verify required.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;

        //
        // Loop while there are still byte writes to satisfy.
        //

        while (TRUE) {

            //
            //  We will continously try the I/O if we get a verify required
            //  back and can verify the volume.  Note that we could have ended
            //  on a hole, and have no runs left.
            //

            if (NumberRuns != 0) {

                while (TRUE) {

                    //
                    //  Do the I/O and wait for it to finish
                    //

                    NtfsMultipleAsync( IrpContext,
                                       Vcb->TargetDeviceObject,
                                       Irp,
                                       NumberRuns,
                                       CompressionContext.IoRuns );

                    //
                    //  If this is an asynchronous transfer, then return STATUS_PENDING.
                    //

                    if (!Wait) {

                        DebugTrace( -1, Dbg, ("NtfsNonCachedIo -> STATUS_PENDING\n") );
                        try_return( Status = STATUS_PENDING );
                    }

                    NtfsWaitSync( IrpContext );

                    //
                    //  If we didn't get a verify required back then break out of
                    //  this loop
                    //

                    if (Irp->IoStatus.Status != STATUS_VERIFY_REQUIRED) { break; }

                    //
                    //  Otherwise we need to verify the volume, and if it doesn't
                    //  verify correctly the we dismount the volume and raise our
                    //  error
                    //

                    if (!NtfsPerformVerifyOperation( IrpContext, Vcb )) {

                        //**** NtfsPerformDismountOnVcb( IrpContext, Vcb, TRUE, NULL );
                        ClearFlag( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED );

                        NtfsRaiseStatus( IrpContext, STATUS_FILE_INVALID, NULL, NULL );
                    }

                    //
                    //  The volume verified correctly so now clear the verify bit
                    //  and try and I/O again
                    //

                    ClearFlag( Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME );

                    //
                    //  Reset the status before retrying.
                    //

                    Irp->IoStatus.Status = STATUS_SUCCESS;
                }

                //
                //  See if we need to do a hot fix.  Hotfix if the request failed
                //  (except if called from WriteClusters) or we couldn't revert
                //  a USA block.
                //

                if ((!FT_SUCCESS( Irp->IoStatus.Status ) &&
                     ((IrpContext->MajorFunction != IRP_MJ_WRITE) ||
                      (Irp == IrpContext->OriginatingIrp))) ||
                    (FlagOn(Scb->ScbState, SCB_STATE_USA_PRESENT) &&
                     (IrpContext->MajorFunction == IRP_MJ_READ) &&
                     !NtfsVerifyAndRevertUsaBlock( IrpContext,
                                                   Scb,
                                                   (PCHAR)NtfsMapUserBuffer( Irp ) +
                                                     CompressionContext.IoRuns[0].BufferOffset,
                                                   OriginalByteCount -
                                                   CompressionContext.IoRuns[0].BufferOffset -
                                                   RemainingByteCount,
                                                   StartingVbo ))) {

                    //
                    //  Try to fix the problem
                    //

                    NtfsFixDataError( IrpContext,
                                      Scb,
                                      Vcb->TargetDeviceObject,
                                      Irp,
                                      NumberRuns,
                                      CompressionContext.IoRuns );
                }
            }

            if (!NT_SUCCESS(Irp->IoStatus.Status) || (RemainingByteCount == 0)) { break; }

            if (CompressionContext.FinishBuffersNeeded) {

                Irp->IoStatus.Status =
                NtfsFinishBuffers( IrpContext,
                                   Irp,
                                   Scb,
                                   &StartingVbo,
                                   ByteCount - RemainingByteCount,
                                   NumberRuns,
                                   &CompressionContext,
                                   StreamFlags );

                if (!NT_SUCCESS(Irp->IoStatus.Status)) { break; }
            }

            StartingVbo = StartingVbo + (ByteCount - RemainingByteCount);
            CompressionContext.SystemBufferOffset += ByteCount - RemainingByteCount;

            ByteCount = RemainingByteCount;

            //
            //  Reset this boolean for each iteration.
            //

            CompressionContext.DataTransformed = FALSE;

            RemainingByteCount = NtfsPrepareBuffers( IrpContext,
                                                     Irp,
                                                     Scb,
                                                     &StartingVbo,
                                                     ByteCount,
                                                     StreamFlags,
                                                     &Wait,
                                                     &NumberRuns,
                                                     &CompressionContext );

            //
            //  If we are writing to an encrypted stream, now is the
            //  time to do the encryption, before we pass the buffer
            //  down to the disk driver below us.
            //
            if ((Scb->EncryptionContext != NULL) &&
                (IrpContext->MajorFunction == IRP_MJ_WRITE) &&
                (NtfsData.EncryptionCallBackTable.BeforeWriteProcess != NULL) &&
                (!FlagOn( StreamFlags, ENCRYPTED_STREAM ))) {

                ASSERT ( NtfsIsTypeCodeEncryptible( Scb->AttributeTypeCode ) );
                ASSERT( NumberRuns > 0 );

                NtfsEncryptBuffers( IrpContext,
                                    Irp,
                                    Scb,
                                    StartingVbo,
                                    NumberRuns,
                                    &CompressionContext );
            }

            ASSERT( RemainingByteCount < ByteCount );

            if (FlagOn(Irp->Flags, IRP_PAGING_IO)) {
                CollectDiskIoStats(Vcb, Scb, IrpContext->MajorFunction, NumberRuns);
            }
        }

        Status = Irp->IoStatus.Status;

    try_exit: NOTHING;

    } finally {

        //
        //  If this is a compressed file and we got success, go do our normal
        //  post processing.
        //

        if (CompressionContext.FinishBuffersNeeded
            && NT_SUCCESS(Status)
            && (Status != STATUS_PENDING)
            && !AbnormalTermination()
            ) {

            Irp->IoStatus.Status =
            Status =
            NtfsFinishBuffers( IrpContext,
                               Irp,
                               Scb,
                               &StartingVbo,
                               ByteCount - RemainingByteCount,
                               NumberRuns,
                               &CompressionContext,
                               StreamFlags );
        }

        //
        //  For writes, free any Mdls which may have been used.
        //

        if (Mdl != NULL) {

            PMDL TempMdl;

            do {

                TempMdl = Mdl->Next;
                MmUnlockPages( Mdl );
                IoFreeMdl( Mdl );
                Mdl = TempMdl;

            } while (Mdl != NULL);
        }

        //
        //  Cleanup the compression context.
        //

        NtfsDeallocateCompressionBuffer( Irp, &CompressionContext, FALSE );
    }

    //
    //  Now set up the final byte count if we got success
    //

    if (Wait && NT_SUCCESS(Status)) {

        Irp->IoStatus.Information = OriginalByteCount;
    }

    DebugTrace( -1, Dbg, ("NtfsNonCachedIo -> %08lx\n", Status) );
    return Status;
}


VOID
NtfsNonCachedNonAlignedIo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN VBO StartingVbo,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine performs the non-cached disk io described in its parameters.
    This routine differs from the above in that the range does not have to be
    sector aligned.  This accomplished with the use of intermediate buffers.

    Currently only read is supported.

Arguments:

    IrpContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    Irp - Supplies the requesting Irp.

    Scb - Provides the stream to act on.

    StartingVbo - The starting point for the operation.

    ByteCount - The lengh of the operation.

Return Value:

    None.

--*/

{
    //
    // Declare some local variables for enumeration through the
    // runs of the file, and an array to store parameters for
    // parallel I/Os
    //

    LBO NextLbo;
    LCN NextLcn;
    ULONG NextLcnOffset;

    LONGLONG NextClusterCount;
    BOOLEAN NextIsAllocated;

    ULONG SectorOffset;
    ULONG SectorSize;
    ULONG BytesToCopy;
    ULONG OriginalByteCount;
    ULONG TailByteCount;
    VBO OriginalStartingVbo;

    PUCHAR UserBuffer;
    PUCHAR DiskBuffer = NULL;

    PMDL Mdl;
    PMDL SavedMdl;
    PVOID SavedUserBuffer;

    PVCB Vcb = Scb->Vcb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsNonCachedNonAlignedRead\n") );
    DebugTrace( 0, Dbg, ("Irp                 = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, ("MajorFunction       = %08lx\n", IrpContext->MajorFunction) );
    DebugTrace( 0, Dbg, ("Scb                 = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("StartingVbo         = %016I64x\n", StartingVbo) );
    DebugTrace( 0, Dbg, ("ByteCount           = %08lx\n", ByteCount) );

    //
    //  Currently only read is supported.
    //

    ASSERT(IoGetCurrentIrpStackLocation(Irp)->MajorFunction != IRP_MJ_WRITE);

    //
    //  This code assumes the file is uncompressed.  Sparse files are supported.
    //  Before we assert that the file is uncompressed, assert that our test is
    //  going to be properly serialized.  We'll also be testing for the sparse
    //  attribute in the main code path, so we really need to be serialized here.
    //

    ASSERT( NtfsIsSharedScb( Scb ) ||
            ((Scb->Header.PagingIoResource != NULL) && NtfsIsSharedScbPagingIo( Scb )) );

    ASSERT( !FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) );

    //
    //  Initialize some locals.
    //

    OriginalByteCount = ByteCount;
    OriginalStartingVbo = StartingVbo;
    SectorSize = Vcb->BytesPerSector;

    //
    // For nonbuffered I/O, we need the buffer locked in all
    // cases.
    //
    // This call may raise.  If this call succeeds and a subsequent
    // condition is raised, the buffers are unlocked automatically
    // by the I/O system when the request is completed, via the
    // Irp->MdlAddress field.
    //

    NtfsLockUserBuffer( IrpContext,
                        Irp,
                        IoWriteAccess,
                        IoGetCurrentIrpStackLocation(Irp)->Parameters.Read.Length );

    UserBuffer = NtfsMapUserBuffer( Irp );

    //
    //  Allocate the local buffer.  Round to pages to avoid any device alignment
    //  problems.
    //

    DiskBuffer = NtfsAllocatePool( NonPagedPool,
                                    (ULONG) ROUND_TO_PAGES( SectorSize ));

    //
    //  We use a try block here to ensure the buffer is freed, and to
    //  fill in the correct byte count in the Iosb.Information field.
    //

    try {

        //
        //  If the beginning of the request was not aligned correctly, read in
        //  the first part first.
        //

        SectorOffset = ((ULONG)StartingVbo) & (SectorSize - 1);

        if (SectorOffset != 0) {

            //
            //  Try to lookup the first run.
            //

            NextIsAllocated = NtfsLookupAllocation( IrpContext,
                                                    Scb,
                                                    Int64ShraMod32( StartingVbo, Vcb->ClusterShift ),
                                                    &NextLcn,
                                                    &NextClusterCount,
                                                    NULL,
                                                    NULL );

            //
            //  If this is a sparse file and we've been asked to read in a
            //  deallocated range, we need to fill in the buffer with some
            //  zeroes and there's nothing to really read from the disk.
            //  If this isn't a sparse file, and this range isn't allocated,
            //  the file and/or mcb is corrupt.
            //

            if (!NextIsAllocated) {

                if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

                    RtlZeroMemory( DiskBuffer + SectorOffset,
                                   SectorSize - SectorOffset );
                } else {

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                }

            } else {

                //
                //  Adjust for any Lcn offset to the start of the sector we want.
                //

                NextLcnOffset = ((ULONG)StartingVbo) & ~(SectorSize - 1);
                NextLcnOffset &= Vcb->ClusterMask;
                NextLbo = Int64ShllMod32(NextLcn, Vcb->ClusterShift);
                NextLbo = NextLbo + NextLcnOffset;

                NtfsSingleNonAlignedSync( IrpContext,
                                          Vcb,
                                          Scb,
                                          DiskBuffer,
                                          StartingVbo + NextLcnOffset,
                                          NextLbo,
                                          SectorSize,
                                          Irp );

                if (!NT_SUCCESS( Irp->IoStatus.Status )) {

                    try_return( NOTHING );
                }
            }

            //
            //  Now copy the part of the first sector that we want to the user
            //  buffer.
            //

            BytesToCopy = (ByteCount >= SectorSize - SectorOffset
                           ? SectorSize - SectorOffset
                           : ByteCount);

            RtlCopyMemory( UserBuffer,
                           DiskBuffer + SectorOffset,
                           BytesToCopy );

            StartingVbo = StartingVbo + BytesToCopy;

            ByteCount -= BytesToCopy;

            if (ByteCount == 0) {

                try_return( NOTHING );
            }
        }

        ASSERT( (((ULONG)StartingVbo) & (SectorSize - 1)) == 0 );

        //
        //  If there is a tail part that is not sector aligned, read it.
        //

        TailByteCount = (ByteCount & (SectorSize - 1));

        if (TailByteCount != 0) {

            VBO LastSectorVbo;

            LastSectorVbo = StartingVbo + (ByteCount & ~((ULONG_PTR)SectorSize - 1));

            //
            //  Try to lookup the last part of the requested range.
            //

            NextIsAllocated = NtfsLookupAllocation( IrpContext,
                                                    Scb,
                                                    Int64ShraMod32( LastSectorVbo, Vcb->ClusterShift ),
                                                    &NextLcn,
                                                    &NextClusterCount,
                                                    NULL,
                                                    NULL );

            //
            //  If this is a sparse file and we've been asked to read in a
            //  deallocated range, we need to fill in the buffer with some
            //  zeroes and there's nothing to really read from the disk.
            //  If this isn't a sparse file, and this range isn't allocated,
            //  the file and/or mcb is corrupt.
            //

            if (!NextIsAllocated) {

                if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

                    RtlZeroMemory( DiskBuffer,
                                   TailByteCount );
                } else {

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                }

            } else {

                //
                //  Adjust for any Lcn offset.
                //

                NextLcnOffset = ((ULONG)LastSectorVbo) & Vcb->ClusterMask;
                NextLbo = Int64ShllMod32(NextLcn, Vcb->ClusterShift);
                NextLbo = NextLbo + NextLcnOffset;

                NtfsSingleNonAlignedSync( IrpContext,
                                          Vcb,
                                          Scb,
                                          DiskBuffer,
                                          LastSectorVbo,
                                          NextLbo,
                                          SectorSize,
                                          Irp );

                if (!NT_SUCCESS( Irp->IoStatus.Status )) {

                    try_return( NOTHING );
                }
            }

            //
            //  Now copy over the part of this last sector that we need.
            //

            BytesToCopy = TailByteCount;

            UserBuffer += (ULONG)(LastSectorVbo - OriginalStartingVbo);

            RtlCopyMemory( UserBuffer, DiskBuffer, BytesToCopy );

            ByteCount -= BytesToCopy;

            if (ByteCount == 0) {

                try_return( NOTHING );
            }
        }

        ASSERT( ((((ULONG)StartingVbo) | ByteCount) & (SectorSize - 1)) == 0 );

        //
        //  Now build a Mdl describing the sector aligned balance of the transfer,
        //  and put it in the Irp, and read that part.
        //

        SavedMdl = Irp->MdlAddress;
        Irp->MdlAddress = NULL;

        SavedUserBuffer = Irp->UserBuffer;

        Irp->UserBuffer = (PUCHAR)MmGetMdlVirtualAddress( SavedMdl ) +
                          (ULONG)(StartingVbo - OriginalStartingVbo);


        Mdl = IoAllocateMdl(Irp->UserBuffer,
                            ByteCount,
                            FALSE,
                            FALSE,
                            Irp);

        if (Mdl == NULL) {

            Irp->MdlAddress = SavedMdl;
            Irp->UserBuffer = SavedUserBuffer;
            NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
        }

        IoBuildPartialMdl(SavedMdl,
                          Mdl,
                          Irp->UserBuffer,
                          ByteCount);

        //
        //  Try to read in the pages.
        //

        try {

            NtfsNonCachedIo( IrpContext,
                             Irp,
                             Scb,
                             StartingVbo,
                             ByteCount,
                             0 );

        } finally {

            IoFreeMdl( Irp->MdlAddress );

            Irp->MdlAddress = SavedMdl;
            Irp->UserBuffer = SavedUserBuffer;
        }

    try_exit: NOTHING;

    } finally {

        NtfsFreePool( DiskBuffer );

        if ( !AbnormalTermination() && NT_SUCCESS(Irp->IoStatus.Status) ) {

            Irp->IoStatus.Information = OriginalByteCount;

            //
            //  We now flush the user's buffer to memory.
            //

            KeFlushIoBuffers( Irp->MdlAddress, TRUE, FALSE );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsNonCachedNonAlignedRead -> VOID\n") );
    return;
}


BOOLEAN
NtfsVerifyAndRevertUsaBlock (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN OUT PVOID Buffer,
    IN ULONG Length,
    IN LONGLONG FileOffset
    )

/*++

Routine Description:

    This routine will revert the bytes in all of the structures protected by
    update sequence arrays.  It copies the bytes from each Usa to the
    separate blocks protected.

    If a structure does not verify correctly, then it's signature is set
    to BaadSignature.

Arguments:

    Buffer - This is the pointer to the start of the buffer to recover.

Return Value:

    FALSE - if at least one block did not verify correctly and received a BaadSignature
    TRUE - if no blocks received a BaadSignature

--*/

{
    PMULTI_SECTOR_HEADER MultiSectorHeader;
    PUSHORT SequenceArray;
    PUSHORT SequenceNumber;
    ULONG StructureSize;
    USHORT CountBlocks;
    PUSHORT ProtectedUshort;
    BOOLEAN Result = TRUE;
    PVCB Vcb = Scb->Vcb;
    ULONG BytesLeft = Length;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsVerifyAndRevertUsaBlock:  Entered\n") );

    //
    //  Cast the buffer pointer to a Multi-Sector-Header and verify that this
    //  block has been initialized.
    //

    MultiSectorHeader = (PMULTI_SECTOR_HEADER) Buffer;

    //
    //  Get the the number of blocks, based on what type of stream it is.
    //  First check for Mft or Log file.
    //

    if (Scb->Header.NodeTypeCode == NTFS_NTC_SCB_MFT) {

        ASSERT((Scb == Vcb->MftScb) || (Scb == Vcb->Mft2Scb));

        StructureSize = Vcb->BytesPerFileRecordSegment;

    } else if (Scb->Header.NodeTypeCode == NTFS_NTC_SCB_DATA) {

        ASSERT( Scb == Vcb->LogFileScb );

        //
        //  On the first pass through the log file, we see all -1,
        //  and we just want to let it go.
        //

        if (*(PULONG)&MultiSectorHeader->Signature == MAXULONG) {

            //
            //  Use the structure size given us by Lfs if present.
            //

            if (Vcb->LfsWriteData.LfsStructureSize == 0) {

                DebugTrace( -1, Dbg, ("NtfsVerifyAndRevertUsaBlock: (Virgin Log)\n") );
                return TRUE;
            }

            StructureSize = Vcb->LfsWriteData.LfsStructureSize;

        //
        //  Use the current size in the USA
        //

        } else {

            CountBlocks = (USHORT)(MultiSectorHeader->UpdateSequenceArraySize - 1);
            StructureSize = CountBlocks * SEQUENCE_NUMBER_STRIDE;

            //
            //  Check for plausibility and otherwise use page size.
            //

            if ((StructureSize != 0x1000)  && (StructureSize != 0x2000) && (StructureSize != PAGE_SIZE)) {

                StructureSize = PAGE_SIZE;
            }
        }

    //
    //  Otherwise it is an index, so we can get the count out of the Scb.
    //

    } else {

        StructureSize = Scb->ScbType.Index.BytesPerIndexBuffer;

        ASSERT((StructureSize == 0x800) || (StructureSize == 0x1000) || (StructureSize == 0x400));
        ASSERT((Length & (StructureSize - 1)) == 0);
    }

    CountBlocks = (USHORT)(StructureSize / SEQUENCE_NUMBER_STRIDE);

    //
    //  Loop through all of the multi-sector blocks in this transfer.
    //

    do {

        //
        //  Uninitialized log file pages always must contain MAXULONG, which is
        //  not a valid signature.  Do not do the check if we see MAXULONG.  Also
        //  since we may have read random uninitialized data, we must check every
        //  possible field that could cause us to fault or go outside of the block,
        //  and also not check in this case.
        //

        //
        //  For 0 or MAXULONG we assume the value is "expected", and we do not
        //  want to replace with the BaadSignature, just move on.
        //

        if ((*(PULONG)&MultiSectorHeader->Signature == MAXULONG) ||
            (*(PULONG)&MultiSectorHeader->Signature == 0)) {

            NOTHING;

        } else if ((CountBlocks == (USHORT)(MultiSectorHeader->UpdateSequenceArraySize - 1)) &&
            !FlagOn(MultiSectorHeader->UpdateSequenceArrayOffset, 1) &&
            ((ULONG)MultiSectorHeader->UpdateSequenceArrayOffset <
              (StructureSize - (CountBlocks + 1) * sizeof(USHORT))) &&
            (StructureSize <= BytesLeft)) {

            ULONG CountToGo;

            CountToGo = CountBlocks;

            //
            //  Compute the array offset and recover the current sequence number.
            //

            SequenceNumber = (PUSHORT)Add2Ptr( MultiSectorHeader,
                                               MultiSectorHeader->UpdateSequenceArrayOffset );

            SequenceArray = SequenceNumber + 1;

            //
            //  We now walk through each block, and insure that the last byte in each
            //  block matches the sequence number.
            //

            ProtectedUshort = (PUSHORT) (Add2Ptr( MultiSectorHeader,
                                                  SEQUENCE_NUMBER_STRIDE - sizeof( USHORT )));

            //
            //  Loop to test for the correct sequence numbers and restore the
            //  sequence numbers.
            //

            do {

                //
                //  If the sequence number does not check, then raise if the record
                //  is not allocated.  If we do not raise, i.e. the routine returns,
                //  then smash the signature so we can easily tell the record is not
                //  allocated.
                //

                if (*ProtectedUshort != *SequenceNumber) {

                    //
                    //  We do nothing except exit if this is the log file and
                    //  the signature is the chkdsk signature.
                    //

                    if ((Scb != Vcb->LogFileScb) ||
                        (*(PULONG)MultiSectorHeader->Signature != *(PULONG)ChkdskSignature)) {

                        //
                        //  If this is the Mft or an index buffer and all of the data for this file
                        //  record is contained in the verified range of the
                        //  record then don't mark it bad.
                        //

                        if ((Scb == Vcb->MftScb) || (Scb == Vcb->Mft2Scb)) {

                            PFILE_RECORD_SEGMENT_HEADER FileRecord;

                            FileRecord = (PFILE_RECORD_SEGMENT_HEADER) MultiSectorHeader;

                            if (FileRecord->FirstFreeByte < ((CountBlocks - CountToGo) * SEQUENCE_NUMBER_STRIDE)) {

                                continue;
                            }
                        } else if (*(PULONG)MultiSectorHeader->Signature == *(PULONG)IndexSignature ) {

                            PINDEX_ALLOCATION_BUFFER IndexBuffer;

                            IndexBuffer = (PINDEX_ALLOCATION_BUFFER) MultiSectorHeader;

                            if (IndexBuffer->IndexHeader.FirstFreeByte < ((CountBlocks - CountToGo) * SEQUENCE_NUMBER_STRIDE)) {

                                continue;
                            }
                        }

                        *(PULONG)MultiSectorHeader->Signature = *(PULONG)BaadSignature;
                        Result = FALSE;
                    }

                    break;

                } else {

                    *ProtectedUshort = *SequenceArray++;
                }

                ProtectedUshort += (SEQUENCE_NUMBER_STRIDE / sizeof( USHORT ));

            } while (--CountToGo != 0);

        //
        //  If this is the log file, we report an error unless the current
        //  signature is the chkdsk signature.
        //

        } else if (Scb == Vcb->LogFileScb) {

            if (*(PULONG)MultiSectorHeader->Signature != *(PULONG)ChkdskSignature) {

                *(PULONG)MultiSectorHeader->Signature = *(PULONG)BaadSignature;
                Result = FALSE;
            }

            break;

        } else {

            VCN Vcn;
            LCN Lcn;
            LONGLONG ClusterCount;
            BOOLEAN IsAllocated;

            Vcn = LlClustersFromBytesTruncate( Vcb, FileOffset );

            IsAllocated = NtfsLookupAllocation( IrpContext,
                                                Scb,
                                                Vcn,
                                                &Lcn,
                                                &ClusterCount,
                                                NULL,
                                                NULL );

            if (!IsAllocated &&
                ( ClusterCount >= LlClustersFromBytes( Vcb, StructureSize))) {

                *(PULONG)MultiSectorHeader->Signature = *(PULONG)HoleSignature;
            } else {
                *(PULONG)MultiSectorHeader->Signature = *(PULONG)BaadSignature;
                Result = FALSE;
            }
        }

        //
        //  Now adjust all pointers and counts before looping back.
        //

        MultiSectorHeader = (PMULTI_SECTOR_HEADER)Add2Ptr( MultiSectorHeader,
                                                           StructureSize );

        if (BytesLeft > StructureSize) {
            BytesLeft -= StructureSize;
        } else {
            BytesLeft = 0;
        }
        FileOffset = FileOffset + StructureSize;

    } while (BytesLeft != 0);

    DebugTrace( -1, Dbg, ("NtfsVerifyAndRevertUsaBlock:  Exit\n") );
    return Result;
}


VOID
NtfsTransformUsaBlock (
    IN PSCB Scb,
    IN OUT PVOID SystemBuffer,
    IN OUT PVOID Buffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine will implement Usa protection for all structures of the
    transfer passed described by the caller.  It does so by copying the last
    short in each block of each Usa-protected structure to the
    Usa and storing the current sequence number into each of these bytes.

    It also increments the sequence number in the Usa.

Arguments:

    Buffer - This is the pointer to the start of the structure to transform.

    Length - This is the maximum size for the structure.

Return Value:

    ULONG - This is the length of the transformed structure.

--*/

{
    PMULTI_SECTOR_HEADER MultiSectorHeader;
    PUSHORT SequenceArray;
    PUSHORT SequenceNumber;
    ULONG StructureSize;
    USHORT CountBlocks;
    PUSHORT ProtectedUshort;
    PVCB Vcb = Scb->Vcb;
    ULONG BytesLeft = Length;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsTransformUsaBlock:  Entered\n") );

    //
    //  Cast the buffer pointer to a Multi-Sector-Header and verify that this
    //  block has been initialized.
    //

    MultiSectorHeader = (PMULTI_SECTOR_HEADER) Buffer;

    //
    //  Get the the number of blocks, based on what type of stream it is.
    //  First check for Mft or Log file.
    //

    if (Scb->Header.NodeTypeCode == NTFS_NTC_SCB_MFT) {

        ASSERT((Scb == Vcb->MftScb) || (Scb == Vcb->Mft2Scb));

        StructureSize = Vcb->BytesPerFileRecordSegment;

    } else if (Scb->Header.NodeTypeCode == NTFS_NTC_SCB_DATA) {

        //
        //  For the log file, use the value that Lfs has stored in the
        //  Lfs WRITE_DATA structure.
        //

        ASSERT( Scb == Vcb->LogFileScb );
        ASSERT( Vcb->LfsWriteData.LfsStructureSize != 0 );

        StructureSize = Vcb->LfsWriteData.LfsStructureSize;

    //
    //  Otherwise it is an index, so we can get the count out of the Scb.
    //

    } else {

        StructureSize = Scb->ScbType.Index.BytesPerIndexBuffer;

        ASSERT((StructureSize == 0x800) || (StructureSize == 0x1000) || (StructureSize == 0x400));
        ASSERT((Length & (StructureSize - 1)) == 0);
    }

    CountBlocks = (USHORT)(StructureSize / SEQUENCE_NUMBER_STRIDE);

    //
    //  Loop through all of the multi-sector blocks in this transfer.
    //

    do {

        //
        //  Any uninitialized structures will begin with BaadSignature or
        //  MAXULONG, as guaranteed by the Revert routine above.
        //

        if ((*(PULONG)&MultiSectorHeader->Signature != *(PULONG)BaadSignature) &&
            (*(PULONG)&MultiSectorHeader->Signature != *(PULONG)HoleSignature) &&
            (*(PULONG)&MultiSectorHeader->Signature != MAXULONG) &&
            ((MultiSectorHeader->UpdateSequenceArrayOffset & 1) == 0) &&
            (MultiSectorHeader->UpdateSequenceArrayOffset < (StructureSize - CountBlocks - CountBlocks))) {

            ULONG CountToGo = CountBlocks;

            //
            //  Compute the array offset and recover the current sequence number.
            //

            SequenceNumber = (PUSHORT)Add2Ptr( MultiSectorHeader,
                                               MultiSectorHeader->UpdateSequenceArrayOffset );

            //
            //  Increment sequence number before the write, both in the buffer
            //  going out and in the original buffer pointed to by SystemBuffer.
            //  Skip numbers with all 0's and all 1's because 0's are produced by
            //  by common failure cases and -1 is used by hot fix.
            //

            do {

                *SequenceNumber += 1;

                *(PUSHORT)Add2Ptr( SystemBuffer,
                                   MultiSectorHeader->UpdateSequenceArrayOffset ) += 1;

            } while ((*SequenceNumber == 0) || (*SequenceNumber == 0xFFFF));

            SequenceArray = SequenceNumber + 1;

            //
            //  We now walk through each block to copy each protected short
            //  to the sequence array, and replacing it by the incremented
            //  sequence number.
            //

            ProtectedUshort = (PUSHORT) (Add2Ptr( MultiSectorHeader,
                                                  SEQUENCE_NUMBER_STRIDE - sizeof( USHORT )));

            //
            //  Loop to test for the correct sequence numbers and restore the
            //  sequence numbers.
            //

            do {

                *SequenceArray++ = *ProtectedUshort;
                *ProtectedUshort = *SequenceNumber;

                ProtectedUshort += (SEQUENCE_NUMBER_STRIDE / sizeof( USHORT ));

            } while (--CountToGo != 0);
        }

        //
        //  Now adjust all pointers and counts before looping back.
        //

        MultiSectorHeader = (PMULTI_SECTOR_HEADER)Add2Ptr( MultiSectorHeader,
                                                           StructureSize );
        SystemBuffer = Add2Ptr( SystemBuffer, StructureSize );
        BytesLeft -= StructureSize;

    } while (BytesLeft != 0);

    DebugTrace( -1, Dbg, ("NtfsTransformUsaBlock:  Exit -> %08lx\n", StructureSize) );
    return;
}


VOID
NtfsCreateMdlAndBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ThisScb,
    IN UCHAR NeedTwoBuffers,
    IN OUT PULONG Length,
    OUT PMDL *Mdl OPTIONAL,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    This routine will allocate a buffer and create an Mdl which describes
    it.  This buffer and Mdl can then be used for an I/O operation, the
    pages will be locked in memory.

    This routine is intended to be used for cases where large I/Os are
    required.  It attempts to avoid allocations errors and bugchecks by
    using a reserved buffer scheme.  In order for this scheme to work without
    deadlocks, the calling thread must have all resources acquired that it
    will need prior to doing the I/O.  I.e., this routine itself may acquire
    a resource which must work as an end resource.

    Examples of callers to this routine are noncached writes to USA streams,
    and noncached reads and writes to compressed streams.  One case to be
    aware of is the case where a noncached compressed write needs to fault
    in the rest of a compression unit, in order to write the entire unit.
    In an extreme case the noncached writer will allocated one reserved buffer,
    and the noncached read of the rest of the compression unit may need to
    recursively acquire the resource in this routine and allocate the other
    reserved buffer.

Arguments:

    ThisScb - Scb for the file where the IO is occurring.

    NeedTwoBuffers - Indicates that this is the request for the a buffer for
        a transaction which may need two buffers.  A value of RESERVED_BUFFER_ONE_NEEDED means only 1
        buffer is needed.  A value of RESERVED_BUFFER_TWO_NEEDED or RESERVED_BUFFER_WORKSPACE_NEEDED
        indicates that we need two buffers and either ReservedBuffer1 or ReservedBuffer2 should be acquired.

    Length - This is the length needed for this buffer, returns (possibly larger)
        length allocated.

    Mdl - This is the address to store the address of the Mdl created.

    Buffer - This is the address to store the address of the buffer allocated.

Return Value:

    None.

--*/

{
    PVOID TempBuffer;
    PMDL TempMdl;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCreateMdlAndBuffer:  Entered\n") );

    ASSERT( (NeedTwoBuffers == RESERVED_BUFFER_WORKSPACE_NEEDED) ?
            (*Length <= WORKSPACE_BUFFER_SIZE) :
            (*Length <= LARGE_BUFFER_SIZE) );

    TempBuffer = NULL;
    TempMdl = NULL;

    //
    //  If this thread already owns a buffer then call to get the second.
    //
    //  If there have been no allocation failures recently, and
    //  we can use at least half of a big buffer, then go for
    //  one of our preallocated buffers first.
    //

    if ((NtfsReservedBufferThread == (PVOID) PsGetCurrentThread()) ||
        ((*Length >= LARGE_BUFFER_SIZE / 2) && !NtfsBufferAllocationFailure)) {

        //
        //  If we didn't get one then try from pool.
        //

        if (!NtfsGetReservedBuffer( ThisScb->Fcb, &TempBuffer, Length, NeedTwoBuffers )) {

            TempBuffer = NtfsAllocatePoolWithTagNoRaise( NonPagedPoolCacheAligned, *Length, '9ftN' );
        }

    //
    //  Otherwise try to allocate from pool and then get a reserved buffer if
    //  there have been no allocation errors recently.
    //

    } else {

        TempBuffer = NtfsAllocatePoolWithTagNoRaise( NonPagedPoolCacheAligned, *Length, '9ftN' );

        if ((TempBuffer == NULL) && !NtfsBufferAllocationFailure) {

            NtfsGetReservedBuffer( ThisScb->Fcb, &TempBuffer, Length, NeedTwoBuffers );
        }
    }

    //
    //  If we could not allocate a buffer from pool, then
    //  we must stake our claim to a reserved buffer.
    //
    //  We would like to queue the requests which need a single buffer because
    //  they won't be completely blocked by the owner of multiple buffers.
    //  But if this thread wants multiple buffers and there is already a
    //  thread with multiple buffers then fail this request with FILE_LOCK_CONFLICT
    //  in case the current thread is holding some resource needed by the
    //  existing owner.
    //

    if (TempBuffer == NULL) {

        ExAcquireResourceExclusiveLite( &NtfsReservedBufferResource, TRUE );

        //
        //  Show that we have gotten an allocation failure
        //

        NtfsBufferAllocationFailure = TRUE;

        //
        //  Loop here until we get a buffer or abort the current request.
        //

        while (TRUE) {

            KeDelayExecutionThread( KernelMode, FALSE, &NtfsShortDelay );

            if (NtfsGetReservedBuffer( ThisScb->Fcb, &TempBuffer, Length, NeedTwoBuffers )) {

                if (ExGetExclusiveWaiterCount( &NtfsReservedBufferResource ) == 0) {

                    NtfsBufferAllocationFailure = FALSE;
                }

                ExReleaseResourceLite( &NtfsReservedBufferResource );
                break;
            }

            //
            //  We will perform some deadlock detection here and raise
            //  STATUS_FILE_LOCK conflict in order to retry this request if
            //  anyone is queued behind the resource.  Deadlocks can occur
            //  under the following circumstances when another thread is
            //  blocked behind this resource:
            //
            //      - Current thread needs two buffers.  We can't block the
            //          Needs1 guy which may need to complete before the
            //          current Needs2 guy can proceed.  Exception is case
            //          where current thread already has a buffer and we
            //          have a recursive 2 buffer case.  In this case we
            //          are only waiting for the third buffer to become
            //          available.
            //
            //      - Current thread is the lazy writer.  Lazy writer will
            //          need buffer for USA transform.  He also can own
            //          the BCB resource that might be needed by the current
            //          owner of a buffer.
            //
            //      - Current thread is operating on the same Fcb as the owner
            //          of any of the buffers.
            //

            //
            //  If the current thread already owns one of the two buffers then
            //  always allow him to loop.  Otherwise perform deadlock detection
            //  if we need 2 buffers or this this is the lazy writer or we
            //  are trying to get the same Fcb already owned by the 2 buffer guy.
            //

            if ((PsGetCurrentThread() != NtfsReservedBufferThread) &&

                (NeedTwoBuffers ||

                (ThisScb->LazyWriteThread[0] == PsGetCurrentThread()) ||
                (ThisScb->LazyWriteThread[1] == PsGetCurrentThread()) ||
                (ThisScb->Fcb == NtfsReserved12Fcb))) {

                //
                //  If no one is waiting then see if we can continue waiting.
                //

                if (ExGetExclusiveWaiterCount( &NtfsReservedBufferResource ) == 0) {

                    //
                    //  If there is no one waiting behind us and there is no current
                    //  multi-buffer owner, then try again here.
                    //

                    if (NtfsReservedBufferThread == NULL) {

                        continue;
                    }

                    NtfsBufferAllocationFailure = FALSE;
                }

                ExReleaseResourceLite( &NtfsReservedBufferResource );

                NtfsRaiseStatus( IrpContext, STATUS_FILE_LOCK_CONFLICT, NULL, NULL );
            }
        }
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        if (ARGUMENT_PRESENT(Mdl)) {

            //
            //  Allocate an Mdl for this buffer.
            //

            TempMdl = IoAllocateMdl( TempBuffer,
                                     *Length,
                                     FALSE,
                                     FALSE,
                                     NULL );

            if (TempMdl == NULL) {

                NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
            }

            //
            //  Lock the new Mdl in memory.
            //

            MmBuildMdlForNonPagedPool( TempMdl );
            *Mdl = TempMdl;
        }

    } finally {

        DebugUnwind( NtfsCreateMdlAndBuffer );

        //
        //  If abnormal termination, back out anything we've done.
        //

        if (AbnormalTermination()) {

            NtfsDeleteMdlAndBuffer( TempMdl, TempBuffer );

        //
        //  Otherwise, give the Mdl and buffer to the caller.
        //

        } else {

            *Buffer = TempBuffer;
        }

        DebugTrace( -1, Dbg, ("NtfsCreateMdlAndBuffer:  Exit\n") );
    }

    return;
}


VOID
NtfsDeleteMdlAndBuffer (
    IN PMDL Mdl OPTIONAL,
    IN PVOID Buffer OPTIONAL
    )

/*++

Routine Description:

    This routine will allocate a buffer and create an Mdl which describes
    it.  This buffer and Mdl can then be used for an I/O operation, the
    pages will be locked in memory.

Arguments:

    Mdl - Address of Mdl to free

    Buffer - This is the address to store the address of the buffer allocated.

Return Value:

    None.

--*/

{
    //
    //  Free Mdl if there is one
    //

    if (Mdl != NULL) {
        IoFreeMdl( Mdl );
    }

    //
    //  Free reserved buffer or pool
    //

    if (Buffer != NULL) {

        if (!NtfsFreeReservedBuffer( Buffer )) {

            NtfsFreePool( Buffer );
        }
    }
}


VOID
NtfsWriteClusters (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN VBO StartingVbo,
    IN PVOID Buffer,
    IN ULONG ClusterCount
    )

/*++

Routine Description:

    This routine is called to write clusters directly to a file.  It is
    needed when converting a resident attribute to non-resident when
    we can't initialize through the cache manager.  This happens when
    we receive a SetEndOfFile from MM when creating a section for
    a resident file.

Arguments:

    Vcb - Vcb for this device.

    StartingVbo - This is the starting offset to write to.

    Buffer - Buffer containing the data to write.

    ClusterCount - This is the number of clusters to write.

Return Value:

    None.  This routine will raise if the operation is unsuccessful.

--*/

{
    PIRP NewIrp;
    UCHAR MajorFunction;
    BOOLEAN LockedUserBuffer;
    PNTFS_IO_CONTEXT PreviousContext;
    ULONG State;

    NTFS_IO_CONTEXT LocalContext;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsWriteClusters:  Entered\n") );
    DebugTrace( 0, Dbg, ("StartingVbo   -> %016I64x\n", StartingVbo) );
    DebugTrace( 0, Dbg, ("Buffer        -> %08lx\n", Buffer) );
    DebugTrace( 0, Dbg, ("ClusterCount  -> %08lx\n", ClusterCount) );

    //
    //  Initialize the local variables.
    //

    NewIrp = NULL;

    MajorFunction = IrpContext->MajorFunction;

    LockedUserBuffer = FALSE;

    //
    //  Force this operation to be synchronous.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  Get an Io context block.
    //

    PreviousContext = IrpContext->Union.NtfsIoContext;

    IrpContext->Union.NtfsIoContext = &LocalContext;
    State = IrpContext->State;
    ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT );

    //
    //  Use a try-finally so we can clean up properly.
    //

    try {

        PIO_STACK_LOCATION IrpSp;

        RtlZeroMemory( IrpContext->Union.NtfsIoContext, sizeof( NTFS_IO_CONTEXT ));

        KeInitializeEvent( &IrpContext->Union.NtfsIoContext->Wait.SyncEvent,
                           NotificationEvent,
                           FALSE );

        NewIrp = IoBuildAsynchronousFsdRequest( IRP_MJ_WRITE,
                                                Vcb->Vpb->DeviceObject,
                                                Buffer,
                                                BytesFromClusters( Vcb, ClusterCount ),
                                                (PLARGE_INTEGER)&StartingVbo,
                                                NULL );

        if (NewIrp == NULL) {

            NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
        }

        //
        //  We now have an Irp, we want to make it look as though it is part of
        //  the current call.  We need to adjust the Irp stack to update this.
        //

        NewIrp->CurrentLocation--;

        IrpSp = IoGetNextIrpStackLocation( NewIrp );

        NewIrp->Tail.Overlay.CurrentStackLocation = IrpSp;

        IrpSp->DeviceObject = Vcb->Vpb->DeviceObject;

        //
        //  Put our buffer in the Irp and lock it as well.
        //

        NewIrp->UserBuffer = Buffer;

        NtfsLockUserBuffer( IrpContext,
                            NewIrp,
                            IoReadAccess,
                            BytesFromClusters( Vcb, ClusterCount ));

        LockedUserBuffer = TRUE;

        //
        //  Put the write code into the IrpContext.
        //

        IrpContext->MajorFunction = IRP_MJ_WRITE;

        //
        //  Write the data to the disk.
        //

        NtfsNonCachedIo( IrpContext,
                         NewIrp,
                         Scb,
                         StartingVbo,
                         BytesFromClusters(Vcb, ClusterCount),
                         0 );

        //
        //  If we encountered an error or didn't write all the bytes, then
        //  raise the error code.  We use the IoStatus in the Irp instead of
        //  our structure since this Irp will not be completed.
        //

        if (!NT_SUCCESS( NewIrp->IoStatus.Status )) {

            DebugTrace( 0, Dbg, ("Couldn't write clusters to disk -> %08lx\n", NewIrp->IoStatus.Status) );

            NtfsRaiseStatus( IrpContext, NewIrp->IoStatus.Status, NULL, NULL );

        } else if (NewIrp->IoStatus.Information != BytesFromClusters( Vcb, ClusterCount )) {

            DebugTrace( 0, Dbg, ("Couldn't write all byes to disk\n") );
            NtfsRaiseStatus( IrpContext, STATUS_UNEXPECTED_IO_ERROR, NULL, NULL );
        }

    } finally {

        DebugUnwind( NtfsWriteClusters );

        //
        //  Recover the Io Context and remember if it is from pool.
        //

        IrpContext->Union.NtfsIoContext = PreviousContext;

        SetFlag( IrpContext->State, FlagOn( State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT ) );

        IrpContext->MajorFunction = MajorFunction;

        //
        //  If we allocated an Irp, we need to deallocate it.  We also
        //  have to return the correct function code to the Irp Context.
        //

        if (NewIrp != NULL) {

            //
            //  If there is an Mdl we free that first.
            //

            if (NewIrp->MdlAddress != NULL) {

                if (LockedUserBuffer) {

                    MmUnlockPages( NewIrp->MdlAddress );
                }

                IoFreeMdl( NewIrp->MdlAddress );
            }

            IoFreeIrp( NewIrp );
        }

        DebugTrace( -1, Dbg, ("NtfsWriteClusters:  Exit\n") );
    }

    return;
}


//
//  Local support routine
//

VOID
NtfsMultipleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP MasterIrp,
    IN ULONG MultipleIrpCount,
    IN PIO_RUN IoRuns
    )

/*++

Routine Description:

    This routine first does the initial setup required of a Master IRP that is
    going to be completed using associated IRPs.  This routine should not
    be used if only one async request is needed, instead the single read/write
    async routines should be called.

    A context parameter is initialized, to serve as a communications area
    between here and the common completion routine.  This initialization
    includes allocation of a spinlock.  The spinlock is deallocated in the
    NtfsWaitSync routine, so it is essential that the caller insure that
    this routine is always called under all circumstances following a call
    to this routine.

    Next this routine reads or writes one or more contiguous sectors from
    a device asynchronously, and is used if there are multiple reads for a
    master IRP.  A completion routine is used to synchronize with the
    completion of all of the I/O requests started by calls to this routine.

    Also, prior to calling this routine the caller must initialize the
    IoStatus field in the Context, with the correct success status and byte
    count which are expected if all of the parallel transfers complete
    successfully.  After return this status will be unchanged if all requests
    were, in fact, successful.  However, if one or more errors occur, the
    IoStatus will be modified to reflect the error status and byte count
    from the first run (by Vbo) which encountered an error.  I/O status
    from all subsequent runs will not be indicated.

Arguments:

    IrpContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    DeviceObject - Supplies the device to be read

    MasterIrp - Supplies the master Irp.

    MulitpleIrpCount - Supplies the number of multiple async requests
        that will be issued against the master irp.

    IoRuns - Supplies an array containing the Vbo, Lbo, BufferOffset, and
        ByteCount for all the runs to executed in parallel.

Return Value:

    None.

--*/

{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;
    PMDL Mdl;
    BOOLEAN Wait;
    PNTFS_IO_CONTEXT Context;
    ULONG TotalByteCount = 0;

    ULONG UnwindRunCount = 0;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsMultipleAsync\n") );
    DebugTrace( 0, Dbg, ("MajorFunction    = %08lx\n", IrpContext->MajorFunction) );
    DebugTrace( 0, Dbg, ("DeviceObject     = %08lx\n", DeviceObject) );
    DebugTrace( 0, Dbg, ("MasterIrp        = %08lx\n", MasterIrp) );
    DebugTrace( 0, Dbg, ("MultipleIrpCount = %08lx\n", MultipleIrpCount) );
    DebugTrace( 0, Dbg, ("IoRuns           = %08lx\n", IoRuns) );

    //
    //  Set up things according to whether this is truely async.
    //

    Wait = (BOOLEAN) FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    Context = IrpContext->Union.NtfsIoContext;

    try {

        //
        //  Initialize Context, for use in Read/Write Multiple Asynch.
        //

        Context->MasterIrp = MasterIrp;

        //
        //  Iterate through the runs, doing everything that can fail
        //

        for ( UnwindRunCount = 0;
              UnwindRunCount < MultipleIrpCount;
              UnwindRunCount++ ) {

            //
            //  Create an associated IRP, making sure there is one stack entry for
            //  us, as well.
            //

            IoRuns[UnwindRunCount].SavedIrp = NULL;

            Irp = IoMakeAssociatedIrp( MasterIrp, (CCHAR)(DeviceObject->StackSize + 1) );

            if (Irp == NULL) {

                NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
            }

            IoRuns[UnwindRunCount].SavedIrp = Irp;

            //
            //  Allocate and build a partial Mdl for the request.
            //

            Mdl = IoAllocateMdl( (PCHAR)MasterIrp->UserBuffer +
                                 IoRuns[UnwindRunCount].BufferOffset,
                                 IoRuns[UnwindRunCount].ByteCount,
                                 FALSE,
                                 FALSE,
                                 Irp );

            if (Mdl == NULL) {

                NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
            }

            //
            //  Sanity Check
            //

            ASSERT( Mdl == Irp->MdlAddress );

            IoBuildPartialMdl( MasterIrp->MdlAddress,
                               Mdl,
                               (PCHAR)MasterIrp->UserBuffer +
                               IoRuns[UnwindRunCount].BufferOffset,
                               IoRuns[UnwindRunCount].ByteCount );

            //
            //  Get the first IRP stack location in the associated Irp
            //

            IoSetNextIrpStackLocation( Irp );
            IrpSp = IoGetCurrentIrpStackLocation( Irp );

            //
            //  Setup the Stack location to describe our read.
            //

            IrpSp->MajorFunction = IrpContext->MajorFunction;
            IrpSp->Parameters.Read.Length = IoRuns[UnwindRunCount].ByteCount;
            IrpSp->Parameters.Read.ByteOffset.QuadPart = IoRuns[UnwindRunCount].StartingVbo;

            //
            //  If this Irp is the result of a WriteThough operation,
            //  tell the device to write it through.
            //

            if (FlagOn(IrpContext->State, IRP_CONTEXT_STATE_WRITE_THROUGH)) {

                SetFlag( IrpSp->Flags, SL_WRITE_THROUGH );
            }

            //
            //  Set up the completion routine address in our stack frame.
            //

            IoSetCompletionRoutine( Irp,
                                    (Wait
                                     ? &NtfsMultiSyncCompletionRoutine
                                     : &NtfsMultiAsyncCompletionRoutine),
                                    Context,
                                    TRUE,
                                    TRUE,
                                    TRUE );

            //
            //  Setup the next IRP stack location in the associated Irp for the disk
            //  driver beneath us.
            //

            IrpSp = IoGetNextIrpStackLocation( Irp );

            //
            //  Setup the Stack location to do a read from the disk driver.
            //

            IrpSp->MajorFunction = IrpContext->MajorFunction;
            IrpSp->Flags = Context->IrpSpFlags;
            IrpSp->Parameters.Read.Length = IoRuns[UnwindRunCount].ByteCount;
            IrpSp->Parameters.Read.ByteOffset.QuadPart = IoRuns[UnwindRunCount].StartingLbo;
            TotalByteCount += IoRuns[UnwindRunCount].ByteCount;
        }

        //
        //  We only need to set the associated IRP count in the master irp to
        //  make it a master IRP.  But we set the count to one more than our
        //  caller requested, because we do not want the I/O system to complete
        //  the I/O.  We also set our own count.
        //

        Context->IrpCount = MultipleIrpCount;
        MasterIrp->AssociatedIrp.IrpCount = MultipleIrpCount;
        IrpSp = IoGetCurrentIrpStackLocation( MasterIrp );
        IrpSp->Parameters.Read.Length = TotalByteCount;


        if (Wait) {

            MasterIrp->AssociatedIrp.IrpCount += 1;
        }

        //
        //  Now that all the dangerous work is done, issue the Io requests
        //

        for (UnwindRunCount = 0;
             UnwindRunCount < MultipleIrpCount;
             UnwindRunCount++) {

            Irp = IoRuns[UnwindRunCount].SavedIrp;

            //
            //  If IoCallDriver returns an error, it has completed the Irp
            //  and the error will be caught by our completion routines
            //  and dealt with as a normal IO error.
            //

            (VOID)IoCallDriver( DeviceObject, Irp );
        }

    } finally {

        ULONG i;

        DebugUnwind( NtfsMultipleAsync );

        //
        //  Only allocating the spinlock, making the associated Irps
        //  and allocating the Mdls can fail.
        //

        if (AbnormalTermination()) {

            //
            //  Unwind
            //

            for (i = 0; i <= UnwindRunCount; i++) {

                if ((Irp = IoRuns[i].SavedIrp) != NULL) {

                    if (Irp->MdlAddress != NULL) {

                        IoFreeMdl( Irp->MdlAddress );
                    }

                    IoFreeIrp( Irp );
                }
            }
        }

        //
        //  And return to our caller
        //

        DebugTrace( -1, Dbg, ("NtfsMultipleAsync -> VOID\n") );
    }

    return;
}


//
//  Local support routine
//

VOID
NtfsSingleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT DeviceObject,
    IN LBO Lbo,
    IN ULONG ByteCount,
    IN PIRP Irp,
    IN UCHAR MajorFunction
    )

/*++

Routine Description:

    This routine reads or writes one or more contiguous sectors from a device
    asynchronously, and is used if there is only one read necessary to
    complete the IRP.  It implements the read by simply filling
    in the next stack frame in the Irp, and passing it on.  The transfer
    occurs to the single buffer originally specified in the user request.

Arguments:

    IrpContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    DeviceObject - Supplies the device to read

    Lbo - Supplies the starting Logical Byte Offset to begin reading from

    ByteCount - Supplies the number of bytes to read from the device

    Irp - Supplies the master Irp to associated with the async
          request.

    MajorFunction - IRP_MJ_READ || IRP_MJ_WRITE

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsSingleAsync\n") );
    DebugTrace( 0, Dbg, ("MajorFunction = %08lx\n", IrpContext->MajorFunction) );
    DebugTrace( 0, Dbg, ("DeviceObject  = %08lx\n", DeviceObject) );
    DebugTrace( 0, Dbg, ("Lbo           = %016I64x\n", Lbo) );
    DebugTrace( 0, Dbg, ("ByteCount     = %08lx\n", ByteCount) );
    DebugTrace( 0, Dbg, ("Irp           = %08lx\n", Irp) );


    //
    //  Set up the completion routine address in our stack frame.
    //

    IoSetCompletionRoutine( Irp,
                            (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )
                             ? &NtfsSingleSyncCompletionRoutine
                             : &NtfsSingleAsyncCompletionRoutine),
                            IrpContext->Union.NtfsIoContext,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Setup the next IRP stack location in the associated Irp for the disk
    //  driver beneath us.
    //

    IrpSp = IoGetNextIrpStackLocation( Irp );

    //
    //  Setup the Stack location to do a read from the disk driver.
    //

    IrpSp->MajorFunction = MajorFunction;
    IrpSp->Parameters.Read.Length = ByteCount;
    IrpSp->Parameters.Read.ByteOffset.QuadPart = Lbo;
    IrpSp->Flags = IrpContext->Union.NtfsIoContext->IrpSpFlags;

    //
    //  If this Irp is the result of a WriteThough operation,
    //  tell the device to write it through.
    //

    if (FlagOn(IrpContext->State, IRP_CONTEXT_STATE_WRITE_THROUGH)) {

        SetFlag( IrpSp->Flags, SL_WRITE_THROUGH );
    }

    //
    //  Issue the Io request
    //

    //
    //  If IoCallDriver returns an error, it has completed the Irp
    //  and the error will be caught by our completion routines
    //  and dealt with as a normal IO error.
    //

    (VOID)IoCallDriver( DeviceObject, Irp );

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsSingleAsync -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsWaitSync (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine waits for one or more previously started I/O requests
    from the above routines, by simply waiting on the event.

Arguments:

    Context - Pointer to Context used in previous call(s) to be waited on.

Return Value:

    None

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsWaitSync:  Entered\n") );

    KeWaitForSingleObject( &IrpContext->Union.NtfsIoContext->Wait.SyncEvent,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

    KeClearEvent( &IrpContext->Union.NtfsIoContext->Wait.SyncEvent );

    DebugTrace( -1, Dbg, ("NtfsWaitSync -> VOID\n") );
}


//
//  Local support routine.
//

NTSTATUS
NtfsMultiAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

/*++

Routine Description:

    This is the completion routine for all asynchronous reads and writes
    started via NtfsMultipleAsynch.  It must synchronize its operation for
    multiprocessor environments with itself on all other processors, via
    a spin lock found via the Context parameter.

    The completion routine has has the following responsibilities:

        If the individual request was completed with an error, then
        this completion routine must see if this is the first error
        (essentially by Vbo), and if so it must correctly reduce the
        byte count and remember the error status in the Context.

        If the IrpCount goes to 1, then it sets the event in the Context
        parameter to signal the caller that all of the asynch requests
        are done.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the associated Irp which is being completed.  (This
          Irp will no longer be accessible after this routine returns.)

    Contxt - The context parameter which was specified for all of
             the multiple asynch I/O requests for this MasterIrp.

Return Value:

    Currently always returns STATUS_SUCCESS.

--*/

{

    PNTFS_IO_CONTEXT Context = Contxt;
    PIRP MasterIrp = Context->MasterIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    BOOLEAN CompleteRequest = TRUE;

    UNREFERENCED_PARAMETER( DeviceObject );

    DebugTrace( +1, Dbg, ("NtfsMultiAsyncCompletionRoutine, Context = %08lx\n", Context) );

    //
    //  If we got an error (or verify required), remember it in the Irp
    //

    MasterIrp = Context->MasterIrp;

    if (!NT_SUCCESS( Irp->IoStatus.Status )) {

        MasterIrp->IoStatus = Irp->IoStatus;
    }

    //
    //  Decrement IrpCount and see if it goes to zero.
    //

    if (InterlockedDecrement( &Context->IrpCount ) == 0) {

        PERESOURCE Resource;
        ERESOURCE_THREAD ResourceThreadId;

        //
        //  Capture the resource values out of the context to prevent
        //  colliding with the Fsp thread if we post this.
        //

        Resource = Context->Wait.Async.Resource;
        ResourceThreadId = Context->Wait.Async.ResourceThreadId;

        //
        //  Mark the master Irp pending
        //

        IoMarkIrpPending( MasterIrp );

        //
        //  If this request was successful or we posted an async paging io
        //  request then complete this irp.
        //

        if (FT_SUCCESS( MasterIrp->IoStatus.Status )) {

            //
            //  Do any necc. zeroing for read requests - if it fails then just complete
            //  the irp ZeroEndOfBuffer will put the error into the irp iostatus
            //

            if (NtfsZeroEndOfBuffer( MasterIrp, Context )) {
                MasterIrp->IoStatus.Information =
                    Context->Wait.Async.RequestedByteCount;

                //
                //  Go ahead an mark the File object to indicate that we performed
                //  either a read or write if this is not a paging io operation.
                //

                if (!Context->PagingIo &&
                    (IrpSp->FileObject != NULL)) {

                    if (IrpSp->MajorFunction == IRP_MJ_READ) {

                        SetFlag( IrpSp->FileObject->Flags, FO_FILE_FAST_IO_READ );

                    } else {

                        SetFlag( IrpSp->FileObject->Flags, FO_FILE_MODIFIED );
                    }
                }
            }

        //
        //  If we had an error and will hot fix, we simply post the entire
        //  request.
        //

        } else if (!Context->PagingIo) {

            PIRP_CONTEXT IrpContext = NULL;

            //
            //  We need an IrpContext and then have to post the request.
            //  Use a try_except in case we fail the request for an IrpContext.
            //

            CompleteRequest = FALSE;
            try {

                NtfsInitializeIrpContext( MasterIrp, TRUE, &IrpContext );
                IrpContext->Union.NtfsIoContext = Context;
                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT );

                NtfsPostRequest( IrpContext, MasterIrp );

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                //
                //  Just give up.
                //

                CompleteRequest = TRUE;

                if (IrpContext) {

                    //
                    //  We cleanup the context below.
                    //


                    IrpContext->Union.NtfsIoContext = NULL;
                    NtfsCleanupIrpContext( IrpContext, TRUE );
                }
            }
        }

        //
        //  Now release the resource
        //

        if (Resource != NULL) {

            ExReleaseResourceForThreadLite( Resource,
                                        ResourceThreadId );
        }

        if (CompleteRequest) {

            //
            //  and finally, free the context record.
            //

            ExFreeToNPagedLookasideList( &NtfsIoContextLookasideList, Context );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsMultiAsyncCompletionRoutine\n") );

    //
    //  Return more processing required if we don't want the Irp to go away.
    //

    if (CompleteRequest) {

        return STATUS_SUCCESS;

    } else {

        //
        //  We need to cleanup the associated Irp and its Mdl.
        //

        IoFreeMdl( Irp->MdlAddress );
        IoFreeIrp( Irp );

        return STATUS_MORE_PROCESSING_REQUIRED;
    }
}


//
//  Local support routine.
//

NTSTATUS
NtfsMultiSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

/*++

Routine Description:

    This is the completion routine for all synchronous reads and writes
    started via NtfsMultipleAsynch.  It must synchronize its operation for
    multiprocessor environments with itself on all other processors, via
    a spin lock found via the Context parameter.

    The completion routine has has the following responsibilities:

        If the individual request was completed with an error, then
        this completion routine must see if this is the first error
        (essentially by Vbo), and if so it must correctly reduce the
        byte count and remember the error status in the Context.

        If the IrpCount goes to 1, then it sets the event in the Context
        parameter to signal the caller that all of the asynch requests
        are done.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the associated Irp which is being completed.  (This
          Irp will no longer be accessible after this routine returns.)

    Contxt - The context parameter which was specified for all of
             the multiple asynch I/O requests for this MasterIrp.

Return Value:

    The routine returns STATUS_MORE_PROCESSING_REQUIRED so that we can
    immediately complete the Master Irp without being in a race condition
    with the IoCompleteRequest thread trying to decrement the IrpCount in
    the Master Irp.

--*/

{

    PNTFS_IO_CONTEXT Context = Contxt;
    PIRP MasterIrp = Context->MasterIrp;

    DebugTrace( +1, Dbg, ("NtfsMultiSyncCompletionRoutine, Context = %08lx\n", Context) );

    //
    //  If we got an error (or verify required), remember it in the Irp
    //

    MasterIrp = Context->MasterIrp;

    if (!NT_SUCCESS( Irp->IoStatus.Status )) {

        MasterIrp->IoStatus = Irp->IoStatus;
    }

    //
    //  We must do this here since IoCompleteRequest won't get a chance
    //  on this associated Irp.
    //

    IoFreeMdl( Irp->MdlAddress );
    IoFreeIrp( Irp );

    if (InterlockedDecrement(&Context->IrpCount) == 0) {

        KeSetEvent( &Context->Wait.SyncEvent, 0, FALSE );
    }

    DebugTrace( -1, Dbg, ("NtfsMultiSyncCompletionRoutine -> STATUS_MORE_PROCESSING_REQUIRED\n") );

    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER( DeviceObject );
}


//
//  Local support routine.
//

NTSTATUS
NtfsSingleAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

/*++

Routine Description:

    This is the completion routine for all asynchronous reads and writes
    started via NtfsSingleAsynch.

    The completion routine has has the following responsibilities:

        Copy the I/O status from the Irp to the Context, since the Irp
        will no longer be accessible.

        It sets the event in the Context parameter to signal the caller
        that all of the asynch requests are done.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the Irp for this request.  (This Irp will no longer
    be accessible after this routine returns.)

    Contxt - The context parameter which was specified in the call to
             NtfsSingleAsynch.

Return Value:

    Currently always returns STATUS_SUCCESS.

--*/

{
    PNTFS_IO_CONTEXT Context = Contxt;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    BOOLEAN CompleteRequest = TRUE;

    PERESOURCE Resource;
    ERESOURCE_THREAD ResourceThreadId;

    UNREFERENCED_PARAMETER( DeviceObject );

    DebugTrace( +1, Dbg, ("NtfsSingleAsyncCompletionRoutine, Context = %08lx\n", Context) );

    //
    //  Capture the resource values out of the context to prevent
    //  colliding with the Fsp thread if we post this.
    //

    Resource = Context->Wait.Async.Resource;
    ResourceThreadId = Context->Wait.Async.ResourceThreadId;

    //
    //  Mark the Irp pending
    //

    IoMarkIrpPending( Irp );

    //
    //  Fill in the information field correctedly if this worked.
    //

    if (FT_SUCCESS( Irp->IoStatus.Status )) {

        //
        //  Zero the difference between filesize and data read if necc. on reads
        //  if it fails just complete the irp - ZeroEndOfBuffer will put the error into the
        //  irp
        //

        if (NtfsZeroEndOfBuffer( Irp, Context )) {
            Irp->IoStatus.Information = Context->Wait.Async.RequestedByteCount;

            //
            //  Go ahead an mark the File object to indicate that we performed
            //  either a read or write.
            //

            if (!Context->PagingIo &&
                (IrpSp->FileObject != NULL)) {

                if (IrpSp->MajorFunction == IRP_MJ_READ) {

                    SetFlag( IrpSp->FileObject->Flags, FO_FILE_FAST_IO_READ );

                } else {

                    SetFlag( IrpSp->FileObject->Flags, FO_FILE_MODIFIED );
                }
            }
        }

    //
    //  If we had an error and will hot fix, we simply post the entire
    //  request.
    //

    } else if (!Context->PagingIo) {

        PIRP_CONTEXT IrpContext = NULL;

        //
        //  We need an IrpContext and then have to post the request.
        //  Use a try_except in case we fail the request for an IrpContext.
        //

        CompleteRequest = FALSE;
        try {

            NtfsInitializeIrpContext( Irp, TRUE, &IrpContext );
            IrpContext->Union.NtfsIoContext = Context;
            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT );

            NtfsPostRequest( IrpContext, Irp );

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            //
            //  Just give up.
            //

            CompleteRequest = TRUE;

            if (IrpContext) {

                //
                //  We cleanup the context below.
                //

                IrpContext->Union.NtfsIoContext = NULL;
                NtfsCleanupIrpContext( IrpContext, TRUE );
            }
        }
    }

    //
    //  Now release the resource
    //

    if (Resource != NULL) {

        ExReleaseResourceForThreadLite( Resource,
                                    ResourceThreadId );
    }

    //
    //  and finally, free the context record.
    //

    DebugTrace( -1, Dbg, ("NtfsSingleAsyncCompletionRoutine -> STATUS_SUCCESS\n") );

    if (CompleteRequest) {

        ExFreeToNPagedLookasideList( &NtfsIoContextLookasideList, Context );
        return STATUS_SUCCESS;

    } else {

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

}


//
//  Local support routine.
//

NTSTATUS
NtfsSingleSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

/*++

Routine Description:

    This is the completion routine for all reads and writes started via
    NtfsSingleAsynch.

    The completion routine has has the following responsibilities:

        Copy the I/O status from the Irp to the Context, since the Irp
        will no longer be accessible.

        It sets the event in the Context parameter to signal the caller
        that all of the asynch requests are done.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the Irp for this request.  (This Irp will no longer
    be accessible after this routine returns.)

    Contxt - The context parameter which was specified in the call to
             NtfsSingleAsynch.

Return Value:

    The routine returns STATUS_MORE_PROCESSING_REQUIRED so that we can
    immediately complete the Master Irp without being in a race condition
    with the IoCompleteRequest thread trying to decrement the IrpCount in
    the Master Irp.

--*/

{
    PNTFS_IO_CONTEXT Context = Contxt;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    UNREFERENCED_PARAMETER( DeviceObject );

    DebugTrace( +1, Dbg, ("NtfsSingleCompletionRoutine, Context = %08lx\n", Context) );

    KeSetEvent( &Context->Wait.SyncEvent, 0, FALSE );

    DebugTrace( -1, Dbg, ("NtfsSingleCompletionRoutine -> STATUS_MORE_PROCESSING_REQUIRED\n") );

    return STATUS_MORE_PROCESSING_REQUIRED;
}



//
//  Local support routine.
//

NTSTATUS
NtfsPagingFileCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MasterIrp
    )

/*++

Routine Description:

    This is the completion routine for all reads and writes started via
    NtfsPagingFileIo.

    The completion routine has has the following responsibility:

        Since the individual request was completed with an error,
        this completion routine must stuff it into the master irp.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the associated Irp which is being completed.  (This
          Irp will no longer be accessible after this routine returns.)

    MasterIrp - Pointer to the master Irp.  The low order bit in this value will
        be set if a higher level call is performing a hot-fix.

Return Value:

    Always returns STATUS_SUCCESS.

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    UNREFERENCED_PARAMETER( DeviceObject );

    DebugTrace( +1, Dbg, ("NtfsPagingFileCompletionRoutine, MasterIrp = %08lx\n", MasterIrp) );

    ASSERT( (Irp->IoStatus.Status != STATUS_INSUFFICIENT_RESOURCES) ||
            (IrpSp->Parameters.Read.Length > PAGE_SIZE) );

    if (!FT_SUCCESS( Irp->IoStatus.Status )) {

        //
        //  Track any lower drivers that fail a paging file operation insuff. resources
        //

        if (Irp->IoStatus.Status == STATUS_INSUFFICIENT_RESOURCES) {
            NtfsFailedHandedOffPagingFileOps += 1;
        }

        if (!FsRtlIsTotalDeviceFailure( Irp->IoStatus.Status ) &&
            (Irp->IoStatus.Status != STATUS_VERIFY_REQUIRED) &&
            !FlagOn( (ULONG_PTR) MasterIrp, 0x1 )) {

            if  (Irp->IoStatus.Status == STATUS_FT_READ_RECOVERY_FROM_BACKUP) {

                //
                //  If the volume manager has actually completed the read
                //  from a backup, there's little point in telling MM about that.
                //

                Irp->IoStatus.Status = STATUS_SUCCESS;
            }

            //
            //  We don't want to try to hotfix READ errors on the paging file
            //  because of deadlock possibilities with MM. Instead we'll just
            //  return the error for MM to deal with. Chances are that
            //  MM (eg. MiWaitForInPageComplete) will bugcheck anyway,
            //  but it's still nicer than walking right into the deadlock.
            //  We also only asynchronously fix write errors and just return the error
            //  back for mm to retry elsewhere
            //

            if (IrpSp->MajorFunction != IRP_MJ_READ) {

                VBO BadVbo;

                BadVbo = IrpSp->Parameters.Read.Key;

                NtfsPostHotFix( Irp,
                                &BadVbo,
                                IrpSp->Parameters.Read.ByteOffset.QuadPart,
                                IrpSp->Parameters.Read.Length,
                                FALSE );
            }
        }

        //
        //  If we got an error (or verify required), remember it in the Irp
        //

        ClearFlag( (ULONG_PTR) MasterIrp, 0x1 );
        ((PIRP) MasterIrp)->IoStatus = Irp->IoStatus;
    }

    DebugTrace( -1, Dbg, ("NtfsPagingFileCompletionRoutine => (STATUS_SUCCESS)\n") );

    return STATUS_SUCCESS;
}


//
//  Local support routine.
//

NTSTATUS
NtfsPagingFileNoAllocCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the completion routine for all reads and writes started via
    NtfsPagingFileIoNoAllocation.

    The completion routine signals back to the main routine and stops processing

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the associated Irp which is being completed.  (This
          Irp will no longer be accessible after this routine returns.)

    Context -  Actually the event to signal

Return Value:

    Always returns STATUS_SUCCESS.

--*/

{
    PKEVENT Event = (PKEVENT) Context;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    ASSERT( (Irp->IoStatus.Status != STATUS_INSUFFICIENT_RESOURCES) ||
            (IrpSp->Parameters.Read.Length > PAGE_SIZE) );

    //
    //  Track any lower drivers that fail a paging file operation insuff. resources
    //

    if (Irp->IoStatus.Status == STATUS_INSUFFICIENT_RESOURCES) {
        NtfsFailedHandedOffPagingFileOps += 1;
    }

    KeSetEvent( Event, IO_NO_INCREMENT, FALSE );
    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );
}


//
//  Local support routine
//

VOID
NtfsSingleNonAlignedSync (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN PUCHAR Buffer,
    IN VBO Vbo,
    IN LBO Lbo,
    IN ULONG ByteCount,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine reads or writes one or more contiguous sectors from a device
    Synchronously, and does so to a buffer that must come from non paged
    pool.  It saves a pointer to the Irp's original Mdl, and creates a new
    one describing the given buffer.  It implements the read by simply filling
    in the next stack frame in the Irp, and passing it on.  The transfer
    occurs to the single buffer originally specified in the user request.

    Currently, only reads are supported.

Arguments:

    IrpContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    Vcb - Supplies the device to read

    Scb - Supplies the Scb to read

    Buffer - Supplies a buffer from non-paged pool.

    Vbo - Supplies the starting Virtual Block Offset to begin reading from

    Lbo - Supplies the starting Logical Block Offset to begin reading from

    ByteCount - Supplies the number of bytes to read from the device

    Irp - Supplies the master Irp to associated with the async
          request.

    Context - Asynchronous I/O context structure

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp;

    PMDL Mdl;
    PMDL SavedMdl;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsSingleNonAlignedSync\n") );
    DebugTrace( 0, Dbg, ("MajorFunction = %08lx\n", IrpContext->MajorFunction) );
    DebugTrace( 0, Dbg, ("Vcb           = %08lx\n", Vcb) );
    DebugTrace( 0, Dbg, ("Buffer        = %08lx\n", Buffer) );
    DebugTrace( 0, Dbg, ("Lbo           = %016I64x\n", Lbo) );
    DebugTrace( 0, Dbg, ("ByteCount     = %08lx\n", ByteCount) );
    DebugTrace( 0, Dbg, ("Irp           = %08lx\n", Irp) );

    //
    //  Create a new Mdl describing the buffer, saving the current one in the
    //  Irp
    //

    SavedMdl = Irp->MdlAddress;

    Irp->MdlAddress = 0;

    Mdl = IoAllocateMdl( Buffer,
                         ByteCount,
                         FALSE,
                         FALSE,
                         Irp );

    if (Mdl == NULL) {

        Irp->MdlAddress = SavedMdl;

        NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
    }

    //
    //  Lock the new Mdl in memory.
    //

    try {

        MmProbeAndLockPages( Mdl, KernelMode, IoWriteAccess );

    } finally {

        if (AbnormalTermination()) {

            IoFreeMdl( Mdl );
            Irp->MdlAddress = SavedMdl;
        }
    }

    //
    // Set up the completion routine address in our stack frame.
    //

    IoSetCompletionRoutine( Irp,
                            &NtfsSingleSyncCompletionRoutine,
                            IrpContext->Union.NtfsIoContext,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Setup the next IRP stack location in the associated Irp for the disk
    //  driver beneath us.
    //

    IrpSp = IoGetNextIrpStackLocation( Irp );

    //
    //  Setup the Stack location to do a read from the disk driver.
    //

    IrpSp->MajorFunction = IrpContext->MajorFunction;
    IrpSp->Parameters.Read.Length = ByteCount;
    IrpSp->Parameters.Read.ByteOffset.QuadPart = Lbo;

    //
    // Initialize the Kernel Event in the context structure so that the
    // caller can wait on it.  Set remaining pointers to NULL.
    //

    KeInitializeEvent( &IrpContext->Union.NtfsIoContext->Wait.SyncEvent,
                       NotificationEvent,
                       FALSE );

    //
    //  Issue the read request
    //
    //  If IoCallDriver returns an error, it has completed the Irp
    //  and the error will be caught by our completion routines
    //  and dealt with as a normal IO error.
    //

    try {

        (VOID)IoCallDriver( Vcb->TargetDeviceObject, Irp );

        NtfsWaitSync( IrpContext );

        //
        //  See if we need to do a hot fix.
        //

        if (!FT_SUCCESS(Irp->IoStatus.Status)) {

            IO_RUN IoRun;

            IoRun.StartingVbo = Vbo;
            IoRun.StartingLbo = Lbo;
            IoRun.BufferOffset = 0;
            IoRun.ByteCount = ByteCount;
            IoRun.SavedIrp = NULL;

            //
            //  Try to fix the problem
            //

            NtfsFixDataError( IrpContext,
                              Scb,
                              Vcb->TargetDeviceObject,
                              Irp,
                              1,
                              &IoRun );
        }

    } finally {

        MmUnlockPages( Mdl );

        IoFreeMdl( Mdl );

        Irp->MdlAddress = SavedMdl;
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsSingleNonAlignedSync -> VOID\n") );

    return;
}


//
//  Local support routine
//

NTSTATUS
NtfsEncryptBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN VBO StartingVbo,
    IN ULONG NumberRuns,
    IN PCOMPRESSION_CONTEXT CompressionContext
    )

/*++

Routine Description:

    This routine is called by NtfsPrepareBuffers during a write
    operation on an encrypted file.  It allocates a compression
    buffer if necessary and calls the encyrption callout routine
    to compress each run of data in the CompressionContext.

Arguments:

    Irp - Supplies the requesting Irp.

    Scb - Supplies the stream file to act on.

    StartingVbo - The starting point for the operation.

    ByteCount - The lengh of the operation.

    NumberRuns - The size of the IoRuns array in the compression context.

    CompressionContext - Supplies the CompressionContext for this stream.

Return Value:

    None.

--*/

{
    ULONG Run;
    ULONG BufferSize;
    LARGE_INTEGER OffsetWithinFile;
    PIO_RUN IoRun;

    PUCHAR SourceBuffer;
    PUCHAR DestinationBuffer;

    NTSTATUS Status;

    ASSERT( NumberRuns > 0 );
    ASSERT( IrpContext->MajorFunction == IRP_MJ_WRITE );

    //
    //  These functions are just for debugging purposes.  We need to call them
    //  somewhere so the compiler doesn't optimize them out as unreferenced functions.
    //

#ifdef EFSDBG
    if (CompressionContext->SystemBufferOffset != 0) {

        DebugTrace( 0, Dbg, ("\nEncryptBuffers: SystemBufferOffset = %x", CompressionContext->SystemBufferOffset) );
    }
#endif

    //
    //  If we have not already mapped the user buffer, then do so.
    //

    if (CompressionContext->SystemBuffer == NULL) {

        CompressionContext->SystemBuffer = NtfsMapUserBuffer( Irp );
    }

    //
    //  For uncompressed files, we may not have a buffer allocated yet.
    //  The buffer needs to be big enough for this entire transfer.
    //  It must be big enough to go from StartingVbo for this
    //  transfer to the end of the last iorun for this transfer.
    //

    BufferSize = (ULONG) ((CompressionContext->IoRuns[NumberRuns-1].StartingVbo +
                            CompressionContext->IoRuns[NumberRuns-1].ByteCount) -
                          StartingVbo);

    if (BufferSize > LARGE_BUFFER_SIZE) {

        BufferSize = LARGE_BUFFER_SIZE;
    }

    //
    //  If the data already got transformed, the buffer should still be allocated.
    //

    ASSERT( (!CompressionContext->DataTransformed) ||
            (CompressionContext->CompressionBuffer != NULL) );

    //
    //  This function conveniently only allocates/reallocates the buffer
    //  if there is not one allocated yet or if the existing one is not
    //  big enough.
    //

    NtfsAllocateCompressionBuffer( IrpContext,
                                   Scb,
                                   Irp,
                                   CompressionContext,
                                   &BufferSize );

    //
    //  If the data has already be transformed into the compression buffer, for
    //  a compressed or sparse file, for instance, we want to work with the
    //  transformed data.  Otherwise, we need to pluck it directly out of the
    //  system buffer.
    //

    if (CompressionContext->DataTransformed) {

        SourceBuffer = DestinationBuffer = CompressionContext->CompressionBuffer;

    } else {

        SourceBuffer = Add2Ptr( CompressionContext->SystemBuffer, CompressionContext->SystemBufferOffset );
        DestinationBuffer = CompressionContext->CompressionBuffer;
    }

    //
    //  Now look at each run of real data heading to the disk and
    //  let the encryption driver encrypt it.
    //

    for (Run = 0; Run < NumberRuns; Run++) {

        IoRun = &CompressionContext->IoRuns[Run];
        OffsetWithinFile.QuadPart = IoRun->StartingVbo;

        Status = NtfsData.EncryptionCallBackTable.BeforeWriteProcess( Add2Ptr(SourceBuffer, IoRun->BufferOffset),
                                                                      Add2Ptr(DestinationBuffer, IoRun->BufferOffset),
                                                                      &OffsetWithinFile,
                                                                      IoRun->ByteCount,
                                                                      Scb->EncryptionContext);
#if DBG
#ifdef SYSCACHE
        //
        //  If we're using the dummy encryption callback, then we didn't really
        //  encrypt anything, so we should be able to verify the syscache
        //  pattern still.
        //

        if (FlagOn(Scb->ScbState, SCB_STATE_SYSCACHE_FILE) &&
            VerifySyscacheData &&
            (NtfsData.EncryptionCallBackTable.BeforeWriteProcess == NtfsDummyEfsWrite)) {

            FsRtlVerifySyscacheData( Scb->FileObject,
                                     Add2Ptr(CompressionContext->CompressionBuffer, IoRun->BufferOffset),
                                     IoRun->ByteCount,
                                     OffsetWithinFile.LowPart );
        }
#endif
#endif
        if (!NT_SUCCESS( Status )) {

            return Status;
        }
    }

    return STATUS_SUCCESS;
}


VOID
NtfsFixDataError (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP MasterIrp,
    IN ULONG MultipleIrpCount,
    IN PIO_RUN IoRuns
    )

/*

Routine Description:

    This routine is called when a read error, write error, or Usa error
    is received when doing noncached I/O on a stream.  It attempts to
    recover from Usa errors if FT is present.  For bad clusters it attempts
    to isolate the error to one or more bad clusters, for which hot fix
    requests are posted.

Arguments:

    Scb - Supplies the Scb for the stream which got the error

    DeviceObject - Supplies the Device Object for the stream

    MasterIrp - Supplies the original master Irp for the failing read or write

    MultipleIrpCount - Supplies the number of runs in which the current
                       was broken into at the time the error occured.

    IoRuns - Supplies an array describing the runs being accessed at the
             time of the error

Return Value:

    None

-*/

{
    PVOID SystemBuffer;
    ULONG RunNumber, ByteOffset, FtCase;
    BOOLEAN SecondaryAvailable;
    BOOLEAN FixingUsaError;
    BOOLEAN FinalPass;
    ULONG ClusterMask;
    ULONG ClustersToRecover;
    ULONG UsaBlockSize;
    PIO_STACK_LOCATION IrpSp;
    PVCB Vcb = Scb->Vcb;
    ULONG BytesPerCluster = Vcb->BytesPerCluster;
    NTSTATUS FinalStatus = STATUS_SUCCESS;
    ULONG AlignedRunNumber = 0;
    ULONG AlignedByteOffset = 0;
    NTSTATUS IrpStatus = MasterIrp->IoStatus.Status;
    PTOP_LEVEL_CONTEXT TopLevelContext;

    PNTFS_IO_CONTEXT Context = IrpContext->Union.NtfsIoContext;

    LONGLONG LlTemp1;
    LONGLONG LlTemp2;

    PAGED_CODE();

    //
    //  First, if the error we got indicates a total device failure, then we
    //  just report it rather than trying to hot fix every sector on the volume!
    //  Also, do not do hot fix for the read ahead thread, because that is a
    //  good way to conceal errors from the App.
    //

    if (FsRtlIsTotalDeviceFailure( MasterIrp->IoStatus.Status ) ||
        (Scb->CompressionUnit != 0)) {

        return;
    }

    //
    //  Get out if we got an error and the current thread is doing read ahead.
    //

    if (!NT_SUCCESS( MasterIrp->IoStatus.Status ) && NtfsIsReadAheadThread()) {

        return;
    }

    //
    //  Also get out if the top level request came from the fast io path.
    //

    TopLevelContext = NtfsGetTopLevelContext();

    if (TopLevelContext->SavedTopLevelIrp == (PIRP) FSRTL_FAST_IO_TOP_LEVEL_IRP) {

        return;
    }

    //
    //  We can't hot fix the mft mirror or the boot file.  If we're in here
    //  for one of those files, we have to get out now.  We'll make sure we
    //  aren't trying to hot fix the beginning of the mft itself just before
    //  we call NtfsPostHotFix down below.
    //

    ASSERT (Scb != NULL);

    if ((Scb == Vcb->Mft2Scb) ||
        (NtfsEqualMftRef( &Scb->Fcb->FileReference, &BootFileReference ) &&
         (Scb->AttributeTypeCode == $DATA))) {

        return;
    }

    //
    //  Determine whether a secondary device is available
    //

    SecondaryAvailable = (BOOLEAN)!FlagOn( Vcb->VcbState, VCB_STATE_NO_SECONDARY_AVAILABLE );

    //
    //  Assume that we are recovering from a Usa error, if the MasterIrp has
    //  the success status.
    //

    FixingUsaError = FT_SUCCESS( MasterIrp->IoStatus.Status );

    //
    //  We cannot fix any Usa errors if there is no secondary.  Even if there is
    //  a secondary, Usa errors should only occur during restart.  If it is not
    //  restart we are probably looking at uninitialized data, so don't try to
    //  "fix" it.
    //

    if (FixingUsaError &&
        (!SecondaryAvailable || !FlagOn( Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ))) {
        return;
    }

    //
    //  If there is no secondary available and this is a user non-cached read then simply
    //  return the error.  Give this user a chance to re-write the sector himself using
    //  non-cached io.
    //

    if (!SecondaryAvailable &&
        (IrpContext->MajorFunction == IRP_MJ_READ) &&
        (FlagOn( MasterIrp->Flags, IRP_PAGING_IO | IRP_NOCACHE ) == IRP_NOCACHE)) {

        return;
    }

    //
    //  No hot fixing at all if the volume is read only.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        return;
    }

    //
    //  Initialize Context, for use in Read/Write Multiple Asynch.
    //

    ASSERT( Context != NULL );

    Context->MasterIrp = MasterIrp;
    KeInitializeEvent( &Context->Wait.SyncEvent, NotificationEvent, FALSE );

    HotFixTrace(("NtfsFixDataError, MasterIrp: %08lx, MultipleIrpCount: %08lx\n", MasterIrp, MultipleIrpCount));
    HotFixTrace(("                  IoRuns: %08lx, UsaError: %02lx\n", IoRuns, FixingUsaError));
    HotFixTrace(("                  Thread: %08lx\n", PsGetCurrentThread()));
    HotFixTrace(("                  Scb:    %08lx   BadClusterScb:  %08lx\n", Scb, Vcb->BadClusterFileScb));

    //
    //  In most cases we will need to access the buffer for this transfer directly,
    //  so map it here.
    //

    SystemBuffer = NtfsMapUserBuffer( MasterIrp );

    //
    //  If this is a Usa-protected structure, get the block size now.
    //

    if (FlagOn( Scb->ScbState, SCB_STATE_USA_PRESENT )) {

        //
        //  Get the the number of blocks, based on what type of stream it is.
        //  First check for Mft or Log file.
        //

        if (Scb->Header.NodeTypeCode == NTFS_NTC_SCB_MFT) {

            ASSERT( (Scb == Vcb->MftScb) || (Scb == Vcb->Mft2Scb) );

            UsaBlockSize = Vcb->BytesPerFileRecordSegment;

        } else if (Scb->Header.NodeTypeCode == NTFS_NTC_SCB_DATA) {

            //
            //  For the log file, we will just go a page at a time, which
            //  is generally what the log file does.  Any USA errors would
            //  tend to be only at the logical end of the log file anyway.
            //

            ASSERT( Scb == Vcb->LogFileScb );

            //
            //  For the log file, assume it is right in the record, use that
            //  if we get a plausible number, else use page size.
            //

            RunNumber = (USHORT)(((PMULTI_SECTOR_HEADER)SystemBuffer)->UpdateSequenceArraySize - 1);
            UsaBlockSize = RunNumber * SEQUENCE_NUMBER_STRIDE;

            if ((UsaBlockSize != 0x1000) && (UsaBlockSize != 0x2000) && (UsaBlockSize != PAGE_SIZE)) {

                UsaBlockSize = PAGE_SIZE;
            }

        //
        //  Otherwise it is an index, so we can get the count out of the Scb.
        //

        } else {

            UsaBlockSize = Scb->ScbType.Index.BytesPerIndexBuffer;
        }

        //
        //  Verify the maximum of UsaBlockSize and cluster size.
        //

        if (BytesPerCluster > UsaBlockSize) {

            //
            //  Determine which is smaller the cluster size or the
            //  size of the buffer being read.
            //

            IrpSp = IoGetCurrentIrpStackLocation( MasterIrp );

            UsaBlockSize = IrpSp->Parameters.Read.Length;
            if (UsaBlockSize > BytesPerCluster) {

                UsaBlockSize = BytesPerCluster;
            }
        }
    }

    //
    //  We know we got a failure in the given transfer, which could be any size.
    //  We first want to localize the error to the failing cluster(s).
    //
    //  We do this in the following nested loops:
    //
    //      do (for the entire transfer, 32 clusters at a time)
    //
    //          for (primary, secondary if available, primary again if necessary)
    //
    //              for (each run)
    //
    //                  for (each cluster)
    //
    //  The inner-most two loops above have the ability to restart on successive
    //  32-cluster boundaries, relative to the first cluster in the transfer.
    //  For the Ft case, where there is a secondary device available, clusters
    //  are blocked out of a mask as errors are found and corrected, so they
    //  do not have to be read in successive passes; Usa errors are blocked out
    //  of the mask immediately, while for I/O errors we force ourselves to read
    //  both copies to locate the error, only reading the primary again if the
    //  secondary contained the error.
    //

    //
    //  Loop through the entire transfer, 32 clusters at a time.  The innermost
    //  loops will terminate on 32 cluster boundaries, so the outermost loop
    //  will simply keep looping until we exhaust the IoRuns array.
    //

    do {

        //
        //  Initialize the clusters to recover to "all".
        //

        ClustersToRecover = MAXULONG;
        FinalPass = FALSE;

        //
        //  For these 32 clusters, loop through primary, secondary (if available),
        //  and primary again (only reading when necessary).
        //

        for (FtCase = 0; !FinalPass; FtCase++) {

            //
            //  Calculate whether this is the final pass or not.
            //

            FinalPass = !SecondaryAvailable ||
                        (FtCase == 2) ||
                        (IrpContext->MajorFunction == IRP_MJ_WRITE);

            //
            //  Initialize the current cluster mask for cluster 0
            //

            ClusterMask = 1;

            //
            //  Loop through all of the runs in the IoRuns array, or until the
            //  ClusterMask indicates that we hit a 32 cluster boundary.
            //

            for (RunNumber = AlignedRunNumber;
                 (RunNumber < MultipleIrpCount) && (ClusterMask != 0);
                 (ClusterMask != 0) ? RunNumber++ : 0) {

                //
                //  Loop through all of the clusters within this run, or until
                //  the ClusterMask indicates that we hit a 32 cluster boundary.
                //

                for (ByteOffset = (RunNumber == AlignedRunNumber) ? AlignedByteOffset : 0;
                     (ByteOffset < IoRuns[RunNumber].ByteCount) && (ClusterMask != 0);
                     ByteOffset += BytesPerCluster, ClusterMask <<= 1) {

                    LONGLONG StartingVbo, StartingLbo;
                    PIRP Irp;
                    PMDL Mdl;
                    BOOLEAN LowFileRecord;
                    FT_SPECIAL_READ SpecialRead;
                    ULONG Length;

                    HotFixTrace(("Doing ByteOffset: %08lx for FtCase: %02lx\n",
                                (((ULONG)IoRuns[RunNumber].StartingVbo) + ByteOffset),
                                FtCase));

                    //
                    //  If this cluster no longer needs to be recovered, we can
                    //  skip it.
                    //

                    if ((ClustersToRecover & ClusterMask) == 0) {
                        continue;
                    }

                    //
                    //  Temporarily get the 64-bit byte offset into StartingVbo, then
                    //  calculate the actual StartingLbo and StartingVbo.
                    //

                    StartingVbo = ByteOffset;

                    StartingLbo = IoRuns[RunNumber].StartingLbo + StartingVbo;
                    StartingVbo = IoRuns[RunNumber].StartingVbo + StartingVbo;

                    //
                    //  If the file is compressed, then NtfsPrepareBuffers builds
                    //  an IoRuns array where it compresses contiguous Lcns, and
                    //  the Vcns do not always line up correctly.  But we know there
                    //  must be a corresponding Vcn for every Lcn in the stream,
                    //  and that that Vcn can only be >= to the Vcn we have just
                    //  calculated from the IoRuns array.  Therefore, since performance
                    //  of hotfix is not the issue here, we use the following simple
                    //  loop to sequentially scan the Mcb for a matching Vcn for
                    //  the current Lcn.
                    //

                    if (Scb->CompressionUnit != 0) {

                        VCN TempVcn;
                        LCN TempLcn, LcnOut;

                        TempLcn = LlClustersFromBytes( Vcb, StartingLbo );
                        TempVcn = LlClustersFromBytes( Vcb, StartingVbo );

                        //
                        //  Scan to the end of the Mcb (we assert below this
                        //  did not happen) or until we find a Vcn with the
                        //  Lcn we currently want to read.
                        //

                        while (NtfsLookupNtfsMcbEntry( &Scb->Mcb,
                                                       TempVcn,
                                                       &LcnOut,
                                                       NULL,
                                                       NULL,
                                                       NULL,
                                                       NULL,
                                                       NULL )

                                 &&

                               (LcnOut != TempLcn)) {

                            TempVcn = TempVcn + 1;
                        }

                        ASSERT(LcnOut == TempLcn);

                        StartingVbo = LlBytesFromClusters( Vcb, TempVcn );
                    }

                    LowFileRecord = (Scb == Vcb->MftScb) && (((PLARGE_INTEGER)&StartingVbo)->HighPart == 0);

                    //
                    //  Calculate the amount to actually read.
                    //


                    Length = IoRuns[RunNumber].ByteCount - ByteOffset;

                    if (Length > BytesPerCluster) {

                        Length = BytesPerCluster;
                    }

                    //
                    //  Loop while verify required, or we find we really
                    //  do not have an FT device.
                    //

                    while (TRUE) {

                        //
                        //  Create an associated IRP, making sure there is one stack entry for
                        //  us, as well.
                        //

                        Irp = IoMakeAssociatedIrp( MasterIrp, (CCHAR)(DeviceObject->StackSize + 1) );

                        if (Irp == NULL) {

                            //
                            //  We return the error status in the Master irp when
                            //  we were called.
                            //

                            MasterIrp->IoStatus.Status = IrpStatus;
                            return;
                        }

                        //
                        // Allocate and build a partial Mdl for the request.
                        //

                        Mdl = IoAllocateMdl( (PCHAR)MasterIrp->UserBuffer + IoRuns[RunNumber].BufferOffset + ByteOffset,
                                             Length,
                                             FALSE,
                                             FALSE,
                                             Irp );

                        if (Mdl == NULL) {

                            IoFreeIrp(Irp);

                            //
                            //  We return the error status in the Master irp when
                            //  we were called.
                            //

                            MasterIrp->IoStatus.Status = IrpStatus;
                            return;
                        }

                        //
                        //  Sanity Check
                        //

                        ASSERT( Mdl == Irp->MdlAddress );

                        IoBuildPartialMdl( MasterIrp->MdlAddress,
                                           Mdl,
                                           (PCHAR)MasterIrp->UserBuffer +
                                             IoRuns[RunNumber].BufferOffset + ByteOffset,
                                           Length );

                        //
                        //  Get the first IRP stack location in the associated Irp
                        //

                        IoSetNextIrpStackLocation( Irp );
                        IrpSp = IoGetCurrentIrpStackLocation( Irp );

                        //
                        //  Setup the Stack location to describe our read.
                        //

                        IrpSp->MajorFunction = IrpContext->MajorFunction;
                        IrpSp->Parameters.Read.Length = Length;
                        IrpSp->Parameters.Read.ByteOffset.QuadPart = StartingVbo;

                        //
                        // Set up the completion routine address in our stack frame.
                        //

                        IoSetCompletionRoutine( Irp,
                                                &NtfsMultiSyncCompletionRoutine,
                                                Context,
                                                TRUE,
                                                TRUE,
                                                TRUE );

                        //
                        //  Setup the next IRP stack location in the associated Irp for the disk
                        //  driver beneath us.
                        //

                        IrpSp = IoGetNextIrpStackLocation( Irp );

                        //
                        //  Setup the Stack location to do a normal read or write.
                        //

                        if ((IrpContext->MajorFunction == IRP_MJ_WRITE) || !SecondaryAvailable) {

                            IrpSp->MajorFunction = IrpContext->MajorFunction;
                            IrpSp->Flags = Context->IrpSpFlags;
                            IrpSp->Parameters.Read.ByteOffset.QuadPart = StartingLbo;
                            IrpSp->Parameters.Read.Length = Length;

                        //
                        //  Otherwise we are supposed to read from the primary or secondary
                        //  on an FT drive.
                        //

                        } else {

                            IrpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;

                            if (FtCase != 1) {
                                IrpSp->Parameters.DeviceIoControl.IoControlCode = FT_PRIMARY_READ;
                            } else {
                                IrpSp->Parameters.DeviceIoControl.IoControlCode = FT_SECONDARY_READ;
                            }

                            Irp->AssociatedIrp.SystemBuffer = &SpecialRead;
                            SpecialRead.ByteOffset.QuadPart = StartingLbo;
                            SpecialRead.Length = Length;
                        }

                        //
                        //  We only need to set the associated IRP count in the master irp to
                        //  make it a master IRP.  But we set the count to one more than our
                        //  caller requested, because we do not want the I/O system to complete
                        //  the I/O.  We also set our own count.
                        //

                        Context->IrpCount = 1;
                        MasterIrp->AssociatedIrp.IrpCount = 2;

                        //
                        //  MtfsMultiCompletionRoutine only modifies the status on errors,
                        //  so we have to reset to success before each call.
                        //

                        MasterIrp->IoStatus.Status = STATUS_SUCCESS;

                        //
                        //  If IoCallDriver returns an error, it has completed the Irp
                        //  and the error will be caught by our completion routines
                        //  and dealt with as a normal IO error.
                        //

                        HotFixTrace(("Calling driver with Irp: %08lx\n", Irp));
                        KeClearEvent( &Context->Wait.SyncEvent );

                        (VOID)IoCallDriver( DeviceObject, Irp );

                        //
                        //  Now wait for it.
                        //

                        NtfsWaitSync( IrpContext );

                        HotFixTrace(("Request completion status: %08lx\n", MasterIrp->IoStatus.Status));

                        //
                        //  If we were so lucky to get a verify required, then
                        //  spin our wheels here a while.
                        //

                        if (MasterIrp->IoStatus.Status == STATUS_VERIFY_REQUIRED) {

                            //
                            //  Otherwise we need to verify the volume, and if it doesn't
                            //  verify correctly then we dismount the volume and report
                            //  our error.
                            //

                            if (!NtfsPerformVerifyOperation( IrpContext, Vcb )) {

                                //**** NtfsPerformDismountOnVcb( IrpContext, Vcb, TRUE, NULL );
                                ClearFlag( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED );

                                MasterIrp->IoStatus.Status = STATUS_FILE_INVALID;
                                return;
                            }

                            //
                            //  The volume verified correctly so now clear the verify bit
                            //  and try and I/O again
                            //

                            ClearFlag( Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME );

                        //
                        //  We may have assumed that there was a secondary available
                        //  and there is not.  We can only tell from getting this code.
                        //  Indicate there is no secondary and that we will be only
                        //  making one pass.
                        //

                        } else if (MasterIrp->IoStatus.Status == STATUS_INVALID_DEVICE_REQUEST) {

                            ASSERT((IrpContext->MajorFunction != IRP_MJ_WRITE) && SecondaryAvailable);

                            SetFlag(Vcb->VcbState, VCB_STATE_NO_SECONDARY_AVAILABLE);
                            SecondaryAvailable = FALSE;
                            FinalPass = TRUE;

                        //
                        //  If the secondary is offline then there is nothing to recover.
                        //

                       } else if (MasterIrp->IoStatus.Status == STATUS_FT_MISSING_MEMBER) {

                           //
                           //  FTDISK will return this error if they are in initialization.
                           //  Then we don't want to set VCB_STATE_NO_SECONDARY_AVAILABLE but
                           //  will need to check whether we really want to hotfix.
                           //

                           SecondaryAvailable = FALSE;
                           FinalPass = TRUE;

                        //
                        //  Otherwise we got success or another error and we should proceed.
                        //

                        } else {
                            break;
                        }
                    }

                    //
                    //  Check again if we really want to perform the hot-fix in the event the status
                    //  of the secondary has changed.
                    //

                    if (!SecondaryAvailable &&
                        (IrpContext->MajorFunction == IRP_MJ_READ) &&
                        (FlagOn( MasterIrp->Flags, IRP_PAGING_IO | IRP_NOCACHE ) == IRP_NOCACHE)) {

                        MasterIrp->IoStatus.Status = IrpStatus;
                        return;
                    }

                    if (!FT_SUCCESS(MasterIrp->IoStatus.Status)) {

                        BOOLEAN IsHotFixPage;

                        //
                        //  Calculate whether or not this is the hot fix thread itself
                        //  (i.e., executing NtfsPerformHotFix).
                        //

                        IsHotFixPage = NtfsIsTopLevelHotFixScb( Scb );

                        LlTemp1 = StartingVbo >> PAGE_SHIFT;                  //**** crock for x86 compiler bug
                        LlTemp2 = NtfsGetTopLevelHotFixVcn() >> PAGE_SHIFT;   //**** crock for x86 compiler bug

                        if (!IsHotFixPage ||
                            LlTemp1 != LlTemp2) {




                            IsHotFixPage = FALSE;
                        }

                        //
                        //  If the entire device manages to fail in the middle of this,
                        //  get out.
                        //

                        if (FsRtlIsTotalDeviceFailure(MasterIrp->IoStatus.Status)) {

                            MasterIrp->IoStatus.Status = IrpStatus;
                            return;
                        }

                        //
                        //  If this is not a write, fill the cluster with -1 for the
                        //  event that we ultimately never find good data.  This is
                        //  for security reasons (cannot show anyone the data that
                        //  happens to be in the buffer now), signature reasons (let
                        //  -1 designate read errors, as opposed to 0's which occur
                        //  on ValidDataLength cases), and finally if we fail to read
                        //  a bitmap, we must consider all clusters allocated if we
                        //  wish to continue to use the volume before chkdsk sees it.
                        //

                        if (IrpContext->MajorFunction == IRP_MJ_READ) {

                            RtlFillMemory( (PCHAR)SystemBuffer +
                                             IoRuns[RunNumber].BufferOffset + ByteOffset,
                                           Length,
                                           0xFF );

                            //
                            //  If this is file system metadata, then we better mark the
                            //  volume corrupt.
                            //

                            if (FinalPass &&
                                FlagOn(Scb->ScbState, SCB_STATE_MODIFIED_NO_WRITE) &&
                                (!LowFileRecord || (((ULONG)StartingVbo >= PAGE_SIZE) &&
                                                    ((ULONG)StartingVbo >= (ULONG)((VOLUME_DASD_NUMBER + 1) << Vcb->MftShift))))) {

                                NtfsPostVcbIsCorrupt( IrpContext, 0, NULL, NULL );
                            }

                            //
                            //  If this is a Usa-protected file, or the bitmap,
                            //  then we will try to procede with our 0xFF pattern
                            //  above rather than returning an error to our caller.
                            //  The Usa guy will get a Usa error, and the bitmap
                            //  will safely say that everything is allocated until
                            //  chkdsk can fix it up.
                            //

                            if (FlagOn(Scb->ScbState, SCB_STATE_USA_PRESENT) ||
                                (Scb == Vcb->BitmapScb)) {

                                MasterIrp->IoStatus.Status = STATUS_SUCCESS;
                            }
                        }

                        //
                        //  If we are not the page being hot fixed, we want to post the
                        //  hot fix and possibly remember the final status.
                        //

                        if (!IsHotFixPage) {

                            //
                            //  If we got a media error, post the hot fix now.  We expect
                            //  to post at most one hot fix in this routine.  When we post
                            //  it it will serialize on the current stream.  Do not attempt
                            //  hot fixes during restart, or if we do not have the bad
                            //  cluster file yet.
                            //

                            if (!FlagOn( Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ) &&
                                (Vcb->BadClusterFileScb != NULL) &&
                                (!LowFileRecord ||
                                 ((ULONG)StartingVbo >= Vcb->Mft2Scb->Header.FileSize.LowPart))) {

                                NtfsPostHotFix( MasterIrp,
                                                &StartingVbo,
                                                StartingLbo,
                                                BytesPerCluster,
                                                FALSE );
                            }

                            //
                            //  Now see if we ended up with an error on this cluster, and handle
                            //  it accordingly.
                            //
                            //  If we are the one actually trying to fix this error,
                            //  then we need to get success so that we can make the page
                            //  valid with whatever good data we have and flush data
                            //  to its new location.
                            //
                            //  Currently we will not try to figure out if the error
                            //  is actually on the Scb (not to mention the sector) that
                            //  we are hot fixing, assuming that the best thing is to
                            //  just try to charge on.
                            //


                            if (FinalPass) {

                                //
                                //  Make sure he gets the error (if we still have an
                                //  error (see above).
                                //

                                if (!FT_SUCCESS(MasterIrp->IoStatus.Status)) {
                                    FinalStatus = MasterIrp->IoStatus.Status;
                                }
                            }
                        }
                    }

                    //
                    //  If this is a Usa-protected stream, we now perform end of
                    //  Usa processing.  (Otherwise do end of cluster processing
                    //  below.)
                    //

                    if (FlagOn(Scb->ScbState, SCB_STATE_USA_PRESENT)) {

                        ULONG NextOffset = IoRuns[RunNumber].BufferOffset + ByteOffset + Length;

                        //
                        //  If we are not at the end of a Usa block, there is no work
                        //  to do now.
                        //

                        if ((NextOffset & (UsaBlockSize - 1)) == 0) {

                            HotFixTrace(("May be verifying UsaBlock\n"));

                            //
                            //  If the Usa block is ok, we may be able to knock the
                            //  corresponding sectors out of the ClustersToRecover mask.
                            //

                            if ((IrpContext->MajorFunction != IRP_MJ_READ) ||
                                 NtfsVerifyAndRevertUsaBlock( IrpContext,
                                                              Scb,
                                                              (PCHAR)SystemBuffer + NextOffset -
                                                                UsaBlockSize,
                                                              UsaBlockSize,
                                                              StartingVbo - (UsaBlockSize - Length) )) {

                                //
                                //  If we are only fixing a Usa error anyway, or this is
                                //  the final pass or at least not the first pass, then
                                //  we can remove these clusters from the recover mask.
                                //

                                if (FixingUsaError || FinalPass || (FtCase != 0)) {

                                    ULONG ShiftCount = UsaBlockSize >> Vcb->ClusterShift;

                                    ClustersToRecover -= (ClusterMask * 2) -
                                                         (ClusterMask >> (ShiftCount - 1));
                                }

                            //
                            //  Note, that even if we get a Usa error, we want to
                            //  update the byte count on the final pass, because
                            //  our reader expects that.
                            //

                            } else if (FinalPass) {

                                HotFixTrace(("Verify may have failed\n"));
                            }
                        }

                    //
                    //  Perform end of cluster processing if not a Usa-protected stream.
                    //

                    } else {

                        //
                        //  If the read succeeded and this is the final pass or at least
                        //  not the first pass, we can take this cluster out of the cluster
                        //  to recover mask.
                        //

                        if (FT_SUCCESS(MasterIrp->IoStatus.Status) && (FinalPass || (FtCase != 0))) {

                            ClustersToRecover -= ClusterMask;
                        }
                    }
                }
            }
        }

        //
        //  Assume we terminated the inner loops because we hit a 32 cluster boundary,
        //  and advance our alignment points.
        //

        AlignedRunNumber = RunNumber;
        AlignedByteOffset = ByteOffset;

    } while (RunNumber < MultipleIrpCount);

    //
    //  Now put the final status in the MasterIrp and return
    //

    MasterIrp->IoStatus.Status = FinalStatus;
    if (!NT_SUCCESS(FinalStatus)) {
        MasterIrp->IoStatus.Information = 0;
    }

    HotFixTrace(("NtfsFixDataError returning IoStatus = %08lx, %08lx\n",
                 MasterIrp->IoStatus.Status,
                 MasterIrp->IoStatus.Information));

}


VOID
NtfsPostHotFix (
    IN PIRP Irp,
    IN PLONGLONG BadVbo,
    IN LONGLONG BadLbo,
    IN ULONG ByteLength,
    IN BOOLEAN DelayIrpCompletion
    )

/*

Routine Description:

    This routine posts a hot fix request to a worker thread.  It has to be posted,
    because we cannot expect to be able to acquire the resources we need exclusive
    when the bad cluster is discovered.

Arguments:

    Irp - The Irp for a read or write request which got the error

    BadVbo - The Vbo of the bad cluster for the read or write request

    BadLbo - The Lbo of the bad cluster

    ByteLength - Length to hot fix

    DelayIrpCompletion - TRUE if the Irp should not be completed until the hot
                         fix is done.

Return Value:

    None

--*/

{
    PIRP_CONTEXT HotFixIrpContext = NULL;
    PVOLUME_DEVICE_OBJECT VolumeDeviceObject;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PFILE_OBJECT FileObject = IrpSp->FileObject;

    HotFixTrace(("NTFS: Posting hotfix on file object: %08lx\n", FileObject));

    //
    //  Allocate an IrpContext to post the hot fix to a worker thread.
    //

    NtfsInitializeIrpContext( Irp, FALSE, &HotFixIrpContext );

    //
    //  First reference the file object so that it will not go away
    //  until the hot fix is done.  (We cannot increment the CloseCount
    //  in the Scb, since we are not properly synchronized.)
    //

    ObReferenceObject( FileObject );

    HotFixIrpContext->OriginatingIrp = (PIRP)FileObject;
    HotFixIrpContext->ScbSnapshot.AllocationSize = *BadVbo;
    HotFixIrpContext->ScbSnapshot.FileSize = BadLbo;
    ((ULONG)HotFixIrpContext->ScbSnapshot.ValidDataLength) = ByteLength;
    if (DelayIrpCompletion) {

#ifdef _WIN64

        //
        // (fcf) The IrpToComplete pointer is stashed into the high half of a
        // LONGLONG.  This is problematic on WIN64, so we have to store it
        // somewhere else on 64-bit platforms.  IrpContext->SharedScb is unused
        // in this codepath (asserted below), so we'll use that.
        //
        // Its possible that this change could be made for 32-bit platforms as
        // well, if only to avoid this conditional compilation, but I would
        // prefer the original authors to sanity-check this first.
        //
        // See also NtfsPerformHotFix() where this pointer is extracted.
        //

        ASSERT(HotFixIrpContext->SharedScbSize == 0);
        ASSERT(HotFixIrpContext->SharedScb == NULL);

        (PIRP)HotFixIrpContext->SharedScb = Irp;

#else // !_WIN64

        ((PLARGE_INTEGER)&HotFixIrpContext->ScbSnapshot.ValidDataLength)->HighPart = (ULONG)Irp;

#endif // _WIN64

    } else {
        ((PLARGE_INTEGER)&HotFixIrpContext->ScbSnapshot.ValidDataLength)->HighPart = 0;
    }

    //
    //  Locate the volume device object and Vcb that we are trying to access
    //

    VolumeDeviceObject = (PVOLUME_DEVICE_OBJECT)IrpSp->DeviceObject;
    HotFixIrpContext->Vcb = &VolumeDeviceObject->Vcb;

    //
    //  Send it off.....
    //

    ExInitializeWorkItem( &HotFixIrpContext->WorkQueueItem,
                          (PWORKER_THREAD_ROUTINE)NtfsPerformHotFix,
                          (PVOID)HotFixIrpContext );

    ExQueueWorkItem( &HotFixIrpContext->WorkQueueItem, CriticalWorkQueue );
}


VOID
NtfsPerformHotFix (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine implements implements a hot fix that was scheduled
    above, extracting its parameters from the IrpContext initialized
    above.  The hot fix must be for a contiguous range of Lcns (usually 1).

Arguments:

    IrpContext - Supplies the IrpContext with the hot fix information

Return Value:

    None.

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    PSCB BadClusterScb;
    VCN BadVcn;
    LCN LcnTemp, BadLcn;
    LONGLONG ClusterCount;
    NTSTATUS Status;
    PVOID Buffer;
    PIRP IrpToComplete;
    ULONG ClustersToFix;
    PBCB Bcb = NULL;
    ERESOURCE_THREAD BcbOwner = 0;
    BOOLEAN PerformFullCleanup = TRUE;
    NTSTATUS CompletionStatus = STATUS_SUCCESS;
    PSCB OriginalScb = NULL;
    PSCB NewScb = NULL;
    BOOLEAN PagingFile;

    //
    //  Extract a description of the cluster to be fixed.
    //

    PFILE_OBJECT FileObject = (PFILE_OBJECT)IrpContext->OriginatingIrp;
    VBO BadVbo = *(PVBO)&IrpContext->ScbSnapshot.AllocationSize;

    PAGED_CODE();

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, TRUE, FALSE );
    ASSERT( ThreadTopLevelContext == &TopLevelContext );
    ASSERT( FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_FROM_POOL ));

    NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

    //
    //  Initialize our local variables
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );
    BadClusterScb = Vcb->BadClusterFileScb;
    BadVcn = LlClustersFromBytesTruncate( Vcb, BadVbo );
    BadLcn = LlClustersFromBytesTruncate( Vcb, IrpContext->ScbSnapshot.FileSize );
    ClustersToFix = ClustersFromBytes( Vcb, ((ULONG)IrpContext->ScbSnapshot.ValidDataLength) );

#ifdef _WIN64

    //
    // See comments in NtfsPostHotFix() regarding the location of IrpToComplete.
    //

    ASSERT(IrpContext->SharedScbSize == 0);
    IrpToComplete = (PIRP)IrpContext->SharedScb;

    //
    // Reset SharedScb back to NULL just to be safe.
    //

    IrpContext->SharedScb = NULL;

#else // !_WIN64

    IrpToComplete = (PIRP)(((PLARGE_INTEGER)&IrpContext->ScbSnapshot.ValidDataLength)->HighPart);

#endif

    //
    //  Remember the status to complete the original Irp with.
    //

    if (IrpToComplete != NULL) {

        CompletionStatus = IrpToComplete->IoStatus.Status;
    }

    NtfsInitializeAttributeContext( &Context );

    //
    //  Set up for synchronous operation
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  Show that we are performing a HotFix.  Note we are not processing
    //  an Irp now.
    //

    IrpContext->OriginatingIrp = NULL;

    TopLevelContext.VboBeingHotFixed = BadVbo;
    TopLevelContext.ScbBeingHotFixed = Scb;

    //
    //  Acquire the Vcb before acquiring the paging Io resource.
    //

    NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
    ASSERT( 1 == ExIsResourceAcquiredSharedLite( &Vcb->Resource ) );

    //
    //  While we're holding the Vcb, let's make sure the volume is still mounted.
    //  If it isn't mounted, we need to clean up and get out.
    //

    if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

        NtfsCleanupAttributeContext( IrpContext, &Context );
        NtfsReleaseVcb( IrpContext, Vcb );

        NtfsCompleteRequest( IrpContext, IrpToComplete, CompletionStatus );
        return;
    }

    //
    //  Acquire the paging io resource for this Fcb if it exists.
    //

    if (Scb->Header.PagingIoResource != NULL) {

        NtfsAcquireExclusivePagingIo( IrpContext, Fcb );
    }

    //
    //  Just because we are hot fixing one file, it is possible that someone
    //  will log to another file and try to lookup Lcns.  So we will acquire
    //  all files.  Example:  Hot fix is in Mft, and SetFileInfo has only the
    //  file acquired, and will log something to the Mft, and cause Lcns to be
    //  looked up.
    //

    NtfsAcquireAllFiles( IrpContext, Vcb, TRUE, FALSE, FALSE );

    //
    //  Don't attempt to hotfix if the scb is deleted
    //

    if (!FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )) {

        //
        //  Catch all exceptions.  Note, we should not get any I/O error exceptions
        //  on our device.
        //

        try {

            PagingFile = FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE ) && FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA );

            //
            //  Hotfixing the paging file is tricky because paging file i/o acquires no resources
            //  So we create a shadow scb to do the work in
            //

            if (PagingFile) {

                UNICODE_STRING Mirror;
                BOOLEAN Existing;
                VCN Vcn;
                LCN Lcn;
                LONGLONG ClusterCount;

    #ifdef BENL_DBG
                KdPrint(( "NTFS: hotfixing pagefile\n "));
    #endif

                Mirror.Length = Mirror.MaximumLength = 12;
                Mirror.Buffer = L"Mirror";

                NewScb = NtfsCreateScb( IrpContext, Scb->Fcb, $DATA, &Mirror, FALSE, &Existing );
                ASSERT( Existing == FALSE );
                ASSERT( FlagOn( NewScb->ScbState, SCB_STATE_NONPAGED ));

                //
                //  Null out the name so we think it points to real unnamed $data
                //

                NewScb->AttributeName.Length = 0;

                //
                //  Now update the mirror from the attribute to get the header info and
                //  snapshot it
                //

                NtfsUpdateScbFromAttribute( IrpContext, NewScb, NULL );
                NtfsSnapshotScb( IrpContext, NewScb );

                //
                //  Load the real scb's mcb cluster info into the mirror
                //

                for (Vcn = 0; Vcn < LlClustersFromBytes( Vcb, Scb->Header.AllocationSize.QuadPart ); Vcn += ClusterCount ) {

                    if (NtfsLookupNtfsMcbEntry( &Scb->Mcb, Vcn, &Lcn, &ClusterCount, NULL, NULL, NULL, NULL )) {

                        NtfsAddNtfsMcbEntry( &NewScb->Mcb, Vcn, Lcn, ClusterCount, FALSE );
                    } else {

                        ASSERTMSG( "Missing range in paging file.\n", FALSE );
                        break;
                    }
                }


                OriginalScb = Scb;
                Scb = NewScb;
            }

            for (; ClustersToFix != 0; ClustersToFix--) {

                //
                //  Lookup the bad cluster to see if it is already in the bad cluster
                //  file, and do nothing if it is.
                //

                if (!NtfsLookupAllocation( IrpContext,
                                           BadClusterScb,
                                           BadLcn,
                                           &LcnTemp,
                                           &ClusterCount,
                                           NULL,
                                           NULL ) &&

                    NtfsLookupAllocation( IrpContext,
                                          Scb,
                                          BadVcn,
                                          &LcnTemp,
                                          &ClusterCount,
                                          NULL,
                                          NULL ) &&

                    (LcnTemp == BadLcn)) {

                    //
                    //  Pin the bad cluster in memory, so that we will not lose whatever data
                    //  we have for it.  (This data will be the correct data if we are talking
                    //  to the FT driver or got a write error, otherwise it may be all -1's.)
                    //
                    //  Do not try to do this if we are holding on to the original Irp, as that
                    //  will cause a collided page wait deadlock.
                    //

                    if (IrpToComplete == NULL) {

                        ULONG Count = 100;

                        NtfsCreateInternalAttributeStream( IrpContext,
                                                           Scb,
                                                           FALSE,
                                                           &NtfsInternalUseFile[PERFORMHOTFIX_FILE_NUMBER] );

                        //
                        //  We loop as long as we get an data error.  We want our
                        //  thread to read from the disk because we will recognize
                        //  an I/O request started in PerformHotFix and ignore the
                        //  data error.  The cases where we do get an error will
                        //  probably be from Mm intercepting this request because
                        //  of a collided read with another thread.
                        //


                        do {

                            Status = STATUS_SUCCESS;

                            try {

                                NtfsPinStream( IrpContext, Scb, BadVbo, Vcb->BytesPerCluster, &Bcb, &Buffer );

                            } except ((!FsRtlIsNtstatusExpected( Status = GetExceptionCode())
                                       || FsRtlIsTotalDeviceFailure( Status ))
                                      ? EXCEPTION_CONTINUE_SEARCH
                                      : EXCEPTION_EXECUTE_HANDLER) {

                                NOTHING;
                            }

                        } while (Count-- && (Status != STATUS_SUCCESS));

                        if (Status != STATUS_SUCCESS) {

                            NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
                        }
                    }

                    //
                    //  If we're hotfixing the logfile set the owner bcb owner to thread & 0x1 so
                    //  we don't run into trouble if the logged changes to it use the same page
                    //  Lfs will also set the bcb owner and our release will fail because the threadowner
                    //  has been changed
                    //

                    if (Scb == Vcb->LogFileScb) {

                        BcbOwner = (ERESOURCE_THREAD) (((ULONG_PTR) PsGetCurrentThread()) | 1);

                        CcSetBcbOwnerPointer( Bcb, (PVOID)BcbOwner );
                    }

                    //
                    //  Now deallocate the bad cluster in this stream in the bitmap only,
                    //  since in general we do not support sparse deallocation in the file
                    //  record.  We will update the allocation below.
                    //

    #if DBG
                    KdPrint(("NTFS:     Freeing Bad Vcn: %08lx, %08lx\n", ((ULONG)BadVcn), ((PLARGE_INTEGER)&BadVcn)->HighPart));
    #endif

                    //
                    //   Deallocate clusters directly - so the change is only in memory
                    //   Because we're not using the normal NtfsDeleteAllocation its necc. to
                    //   manually create the snapshots that will correctly unload the modified range in
                    //   case of a raise
                    //

                    NtfsSnapshotScb( IrpContext, Scb );

                    if (BadVcn < Scb->ScbSnapshot->LowestModifiedVcn) {

                        Scb->ScbSnapshot->LowestModifiedVcn = BadVcn;
                    }

                    if (BadVcn > Scb->ScbSnapshot->HighestModifiedVcn) {

                        Scb->ScbSnapshot->HighestModifiedVcn = BadVcn;
                    }

                    NtfsDeallocateClusters( IrpContext,
                                            Vcb,
                                            Scb,
                                            BadVcn,
                                            BadVcn,
                                            &Scb->TotalAllocated );
                    //
                    //  Look up the bad cluster attribute.
                    //

                    NtfsLookupAttributeForScb( IrpContext, BadClusterScb, NULL, &Context );

                    //
                    //  Now append this cluster to the bad cluster file
                    //

    #if DBG
                    KdPrint(("NTFS:     Retiring Bad Lcn: %08lx, %08lx\n", ((ULONG)BadLcn), ((PLARGE_INTEGER)&BadLcn)->HighPart));
    #endif

                    NtfsAddBadCluster( IrpContext, Vcb, BadLcn );

                    //
                    //  Now update the file record for the bad cluster file to
                    //  show the new cluster.
                    //

                    NtfsAddAttributeAllocation( IrpContext,
                                                BadClusterScb,
                                                &Context,
                                                &BadLcn,
                                                (PVCN)&Li1 );

                    //
                    //  Now reallocate a cluster to the original stream to replace the bad cluster.
                    //

                    HotFixTrace(("NTFS:     Reallocating Bad Vcn\n"));
                    NtfsAddAllocation( IrpContext, NULL, Scb, BadVcn, (LONGLONG)1, FALSE, NULL );

                    //
                    //  Unpin the pages now so that the flush won't block if we are hot-fixing the Mft.
                    //

                    NtfsCleanupAttributeContext( IrpContext, &Context );

                    //
                    //  Now that there is a new home for the data, mark the page dirty, unpin
                    //  it and flush it out to its new home.
                    //

                    if (IrpToComplete == NULL) {

                        LONGLONG BiasedBadVbo = BadVbo;

                        CcSetDirtyPinnedData( Bcb, NULL );

                        if (Scb != Vcb->LogFileScb) {
                            NtfsUnpinBcb( IrpContext, &Bcb );
                        } else {
                            NtfsUnpinBcbForThread( IrpContext, &Bcb, BcbOwner );
                        }

                        //
                        //  Flush the stream.  Ignore the status - if we get something like
                        //  a log file full, the Lazy Writer will eventually write the page.
                        //  Bias the write if this is the Usn Journal.
                        //

                        if (FlagOn( Scb->ScbPersist, SCB_PERSIST_USN_JOURNAL )) {

                            BiasedBadVbo -= Scb->Vcb->UsnCacheBias;
                        }

                        (VOID)NtfsFlushUserStream( IrpContext, Scb, &BiasedBadVbo, 1 );
                    }

                    //
                    //  Commit the transaction.
                    //

                    NtfsCommitCurrentTransaction( IrpContext );

                    //
                    //  Now that the data is flushed to its new location, we will write the
                    //  hot fix record.  We don't write the log record if we are
                    //  fixing the logfile.  Instead we explicitly flush the Mft record
                    //  for the log file.  The log file is one file where we expect
                    //  to be able to read the mapping pairs on restart.
                    //

                    if (Scb == Vcb->LogFileScb) {

                        if (Vcb->MftScb->FileObject != NULL) {

                            CcFlushCache( &Vcb->MftScb->NonpagedScb->SegmentObject,
                                          &Li0,
                                          Vcb->BytesPerFileRecordSegment * ATTRIBUTE_DEF_TABLE_NUMBER,
                                          NULL );
                        }

                    } else {

                        (VOID) NtfsWriteLog( IrpContext,
                                             Scb,
                                             NULL,
                                             HotFix,
                                             NULL,
                                             0,
                                             Noop,
                                             NULL,
                                             0,
                                             LlBytesFromClusters( Vcb, BadVcn ),
                                             0,
                                             0,
                                             Vcb->BytesPerCluster );

                        //
                        //  And we have to commit that one, too.
                        //

                        NtfsCommitCurrentTransaction( IrpContext );
                    }

                    //
                    //  Now flush the log to insure that the hot fix gets remembered,
                    //  especially important if this is the paging file.
                    //

                    LfsFlushToLsn( Vcb->LogHandle, LiMax );

                    HotFixTrace(("NTFS:     Bad Cluster replaced\n"));
                }

                //
                //  Get ready for another possible pass through the loop
                //

                BadVcn = BadVcn + 1;
                BadLcn = BadLcn + 1;

                ASSERT( NULL == Bcb );
            }

            //
            //  Move the in memory allocation from the mirror of the paging file
            //  back to the real scb in an atomic matter
            //

            if (NewScb != NULL) {

                NtfsSwapMcbs( &NewScb->Mcb, &OriginalScb->Mcb );
                NtfsDeleteScb( IrpContext, &NewScb );
                Scb = OriginalScb;
            }

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            NTSTATUS ExceptionCode = GetExceptionCode();

            //
            //  We are not prepared to have our IrpContext requeued, so just
            //  consider these cases to be bad luck.  We will put a status of
            //  data error in the irp context and pass that code to the process
            //  exception routine.
            //

            if ((ExceptionCode == STATUS_LOG_FILE_FULL) ||
                (ExceptionCode == STATUS_CANT_WAIT)) {

                ExceptionCode = IrpContext->ExceptionStatus = STATUS_DATA_ERROR;
            }

            //
            //  We won't be calling ReleaseAllFiles.  Decrement the Acquire count
            //  before releasing the Fcbs.
            //

            ASSERT( Vcb->AcquireFilesCount != 0 );
            Vcb->AcquireFilesCount -= 1;

            //
            //  Cleanup the temporary mirror scb (if there is one) while we have an
            //  irpcontext
            //

            if (NewScb != NULL) {
                NtfsDeleteScb( IrpContext, &NewScb );
                Scb = OriginalScb;
            }

            NtfsProcessException( IrpContext, NULL, ExceptionCode );

            //
            //  The IrpContext is really gone now.
            //

            IrpContext = NULL;
            PerformFullCleanup = FALSE;

            ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
        }
    }

    //
    //  Let any errors be handled in the except clause above, however we
    //  cleanup on the way out, because for example we need the IrpContext
    //  still in the except clause.
    //

    try {

        NtfsCleanupAttributeContext( IrpContext, &Context );

        if (Scb != Vcb->LogFileScb) {
            NtfsUnpinBcb( IrpContext, &Bcb );
        } else {
            NtfsUnpinBcbForThread( IrpContext, &Bcb, BcbOwner );
        }

        //
        //  If we aborted this operation then all of the file resources have
        //  already been released.
        //

        if (PerformFullCleanup) {

            NtfsReleaseAllFiles( IrpContext, Vcb, FALSE );

            NtfsReleaseVcb( IrpContext, Vcb );

        //
        //  The files have been released but not the Vcb or the volume bitmap.
        //

        } else {

            if (Vcb->BitmapScb != NULL
                && NtfsIsExclusiveScb( Vcb->BitmapScb )) {

                NtfsReleaseResource( IrpContext, Vcb->BitmapScb );
            }

            //
            //  We need to release the Vcb twice since we specifically acquire
            //  it once and then again with all the files.
            //

            NtfsReleaseVcb( IrpContext, Vcb );
            NtfsReleaseVcb( IrpContext, Vcb );
        }

        ObDereferenceObject( FileObject );

        //
        //  The IrpContext and Irp will already be NULL if they have been completed already.
        //

        NtfsCompleteRequest( IrpContext, IrpToComplete, CompletionStatus );

    } except(EXCEPTION_EXECUTE_HANDLER) {
        NOTHING;
    }

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
}


BOOLEAN
NtfsGetReservedBuffer (
    IN PFCB ThisFcb,
    OUT PVOID *Buffer,
    OUT PULONG Length,
    IN UCHAR Need2
    )

/*++

Routine Description:

    This routine allocates the reserved buffers depending on the needs of
    the caller.  If the caller might require two buffers then we will allocate
    buffers 1 or 2.  Otherwise we can allocate any of the three.

Arguments:

    ThisFcb - This is the Fcb where the io is occurring.

    Buffer - Address to store the address of the allocated buffer.

    Length - Address to store the length of the returned buffer.

    Need2 - Zero if only one buffer needed.  Either 1 or 2 if two buffers
        might be needed.  Buffer 2 can be acquired recursively.  If buffer
        1 is needed and the current thread already owns buffer 1 then
        grant buffer three instead.

Return Value:

    BOOLEAN - Indicates whether the buffer was acquired.

--*/

{
    BOOLEAN Allocated = FALSE;
    PVOID CurrentThread;

    //
    //  Capture the current thread and the Fcb for the file we are acquiring
    //  the buffer for.
    //

    CurrentThread = (PVOID) PsGetCurrentThread();

    ExAcquireFastMutexUnsafe( &NtfsReservedBufferMutex );

    //
    //  If we need two buffers then allocate either buffer 1 or buffer 2.
    //  We allow this caller to get a buffer if
    //
    //      - He already owns one of these buffers   (or)
    //
    //      - Neither of the 2 buffers are allocated (and)
    //      - No other thread has a buffer on behalf of this file
    //

    if (Need2) {

        if ((NtfsReservedBufferThread == CurrentThread) ||

            (!FlagOn( NtfsReservedInUse, 3 ) &&
             ((NtfsReserved3Fcb != ThisFcb) ||
              (NtfsReserved3Thread == CurrentThread)))) {

            NtfsReservedBufferThread = CurrentThread;
            NtfsReserved12Fcb = ThisFcb;

            //
            //  Check whether the caller wants buffer 1 or buffer 2.
            //

            if (Need2 == RESERVED_BUFFER_TWO_NEEDED) {

                //
                //  If we don't own buffer 1 then reserve it now.
                //

                if (!FlagOn( NtfsReservedInUse, 1 )) {

                    NtfsReserved1Thread = CurrentThread;
                    SetFlag( NtfsReservedInUse, 1 );
                    *Buffer = NtfsReserved1;
                    *Length = LARGE_BUFFER_SIZE;
                    Allocated = TRUE;

                } else if (!FlagOn( NtfsReservedInUse, 4 )) {

                    NtfsReserved3Fcb = ThisFcb;

                    NtfsReserved3Thread = CurrentThread;
                    SetFlag( NtfsReservedInUse, 4 );
                    *Buffer = NtfsReserved3;
                    *Length = LARGE_BUFFER_SIZE;
                    Allocated = TRUE;
                }

            } else {

                ASSERT( Need2 == RESERVED_BUFFER_WORKSPACE_NEEDED );

                NtfsReserved2Thread = CurrentThread;
                SetFlag( NtfsReservedInUse, 2 );
                *Buffer = NtfsReserved2;
                *Length = WORKSPACE_BUFFER_SIZE;
                NtfsReserved2Count += 1;
                Allocated = TRUE;
            }
        }

    //
    //  We only need 1 buffer.  If this thread is the exclusive owner then
    //  we know it is safe to use buffer 2.  The data in this buffer doesn't
    //  need to be preserved across a recursive call.
    //

    } else if (NtfsReservedBufferThread == CurrentThread) {

        NtfsReserved2Thread = CurrentThread;
        SetFlag( NtfsReservedInUse, 2 );
        *Buffer = NtfsReserved2;
        *Length = LARGE_BUFFER_SIZE;
        NtfsReserved2Count += 1;
        Allocated = TRUE;

    //
    //  We only need 1 buffer.  Try for buffer 3 first.
    //

    } else if (!FlagOn( NtfsReservedInUse, 4)) {

        //
        //  Check if the owner of the first two buffers is operating in the
        //  same file but is a different thread.  We can't grant another buffer
        //  for a different stream in the same file.
        //

        if (ThisFcb != NtfsReserved12Fcb) {

            NtfsReserved3Fcb = ThisFcb;

            NtfsReserved3Thread = CurrentThread;
            SetFlag( NtfsReservedInUse, 4 );
            *Buffer = NtfsReserved3;
            *Length = LARGE_BUFFER_SIZE;
            Allocated = TRUE;
        }

    //
    //  If there is no exclusive owner then we can use either of the first
    //  two buffers.  Note that getting one of the first two buffers will
    //  lock out the guy who needs two buffers.
    //

    } else if (NtfsReservedBufferThread == NULL) {

        if (!FlagOn( NtfsReservedInUse, 2 )) {

            NtfsReserved2Thread = CurrentThread;
            SetFlag( NtfsReservedInUse, 2 );
            *Buffer = NtfsReserved2;
            *Length = LARGE_BUFFER_SIZE;
            NtfsReserved2Count += 1;
            Allocated = TRUE;

        } else if (!FlagOn( NtfsReservedInUse, 1 )) {

            NtfsReserved1Thread = CurrentThread;
            SetFlag( NtfsReservedInUse, 1 );
            *Buffer = NtfsReserved1;
            *Length = LARGE_BUFFER_SIZE;
            Allocated = TRUE;
        }
    }

    ExReleaseFastMutexUnsafe(&NtfsReservedBufferMutex);
    return Allocated;
}

BOOLEAN
NtfsFreeReservedBuffer (
    IN PVOID Buffer
    )
{
    BOOLEAN Deallocated = FALSE;

    ExAcquireFastMutexUnsafe(&NtfsReservedBufferMutex);

    if (Buffer == NtfsReserved1) {
        ASSERT( FlagOn( NtfsReservedInUse, 1 ));

        ClearFlag( NtfsReservedInUse, 1 );
        NtfsReserved1Thread = NULL;
        if (!FlagOn( NtfsReservedInUse, 2)) {
            NtfsReservedBufferThread = NULL;
            NtfsReserved12Fcb = NULL;
        }

        Deallocated = TRUE;

    } else if (Buffer == NtfsReserved2) {
        ASSERT( FlagOn( NtfsReservedInUse, 2 ));

        NtfsReserved2Count -= 1;

        if (NtfsReserved2Count == 0) {

            ClearFlag( NtfsReservedInUse, 2 );
            NtfsReserved2Thread = NULL;
            if (!FlagOn( NtfsReservedInUse, 1)) {
                NtfsReservedBufferThread = NULL;
                NtfsReserved12Fcb = NULL;
            }
        }

        Deallocated = TRUE;

    } else if (Buffer == NtfsReserved3) {
        ASSERT( FlagOn( NtfsReservedInUse, 4 ));
        ClearFlag( NtfsReservedInUse, 4 );
        Deallocated = TRUE;
        NtfsReserved3Thread = NULL;
        NtfsReserved3Fcb = NULL;
    }

    ExReleaseFastMutexUnsafe(&NtfsReservedBufferMutex);
    return Deallocated;
}


NTSTATUS
NtfsDefragFile (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    Direct defrag.  This routines modifies the input buffer to track progress. So the
    FSCTL must always be buffered.


Arguments:

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The return status for the operation.

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION NextIrpSp;
    ULONG FsControlCode;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

#if defined( _WIN64 )
    MOVE_FILE_DATA MoveDataLocal;
#endif

    PMOVE_FILE_DATA MoveData;

    LONGLONG FileOffset;
    PMDL Mdl = NULL;
    BOOLEAN AcquiredScb = FALSE;
    BOOLEAN AcquiredAllFiles = FALSE;
    BOOLEAN AcquiredVcb = FALSE;
    ULONG DeletePendingFailureCountsLeft;

    extern POBJECT_TYPE *IoFileObjectType;

    PVOID Buffer = NULL;
    ULONG BufferLength;
    NTFS_IO_CONTEXT NtfsIoContext;
    BOOLEAN AcquiredBitmap = FALSE;
    BOOLEAN AcquiredMft = FALSE;
    BOOLEAN FreeRecentlyDeallocated = FALSE;

    PAGED_CODE( );

    //
    //  Always make this synchronous for MoveFile
    //  We should never be in the FSP for this.  Otherwise the user handle
    //  is invalid.  Also disable quota accounting since defrag doesn't affect it
    //  Otherwise we might trigger it while moving attributes around due to mapping pair
    //  changes and deadlock
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT | IRP_CONTEXT_STATE_QUOTA_DISABLE );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    NextIrpSp = IoGetNextIrpStackLocation( Irp );
    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    DebugTrace( +1, Dbg, ("NtfsMoveFile, FsControlCode = %08lx\n", FsControlCode) );

    //
    //  Extract and decode the file object and check for type of open.
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        return STATUS_ACCESS_DENIED;
    }

#if defined(_WIN64)

    //
    //  Win32/64 thunking code
    //

    if (IoIs32bitProcess( Irp )) {

        PMOVE_FILE_DATA32 MoveData32;

        if (IrpSp->Parameters.FileSystemControl.InputBufferLength < sizeof( MOVE_FILE_DATA32 )) {

            NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
            return STATUS_BUFFER_TOO_SMALL;
        }

        MoveData32 = (PMOVE_FILE_DATA32) Irp->AssociatedIrp.SystemBuffer;
        MoveDataLocal.ClusterCount = MoveData32->ClusterCount;
        MoveDataLocal.FileHandle = (HANDLE)(ULONG_PTR)(LONG) MoveData32->FileHandle;
        MoveDataLocal.StartingLcn.QuadPart = MoveData32->StartingLcn.QuadPart;
        MoveDataLocal.StartingVcn.QuadPart = MoveData32->StartingVcn.QuadPart;
        MoveData = &MoveDataLocal;

    } else {
#endif

    //
    //  Get the input buffer pointer and check its length.
    //

    if (IrpSp->Parameters.FileSystemControl.InputBufferLength < sizeof( MOVE_FILE_DATA )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        return STATUS_BUFFER_TOO_SMALL;
    }

    MoveData = Irp->AssociatedIrp.SystemBuffer;

#if defined(_WIN64)
    }
#endif

    //
    //  Try to get a pointer to the file object from the handle passed in.
    //  Remember that we need to dereference this as some point but don't
    //  do it right away in case some gets in before we acquire it.
    //

    Status = ObReferenceObjectByHandle( MoveData->FileHandle,
                                        0,
                                        *IoFileObjectType,
                                        Irp->RequestorMode,
                                        &FileObject,
                                        NULL );

    if (!NT_SUCCESS(Status)) {

        NtfsCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  Check that this file object is opened on the same volume as the
    //  DASD handle used to call this routine.
    //

    if (FileObject->Vpb != Vcb->Vpb) {

        ObDereferenceObject( FileObject );

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Now decode this FileObject. We don't care to raise on dismounts here
    //  because we check for that further down anyway. Hence, RaiseOnError=FALSE.
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );

    //
    //  Limit the files we will allow defragging to.  We can't defrag a file which needs
    //  its own mapping to write log records (volume bitmap).  We also eliminate the
    //  log file and usn journal. For the MFT we disallow moving the first 16 non-user files
    //

    if (((TypeOfOpen != UserFileOpen) &&
         (TypeOfOpen != UserDirectoryOpen) &&
         (TypeOfOpen != UserViewIndexOpen)) ||
        FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE ) ||
        ((NtfsSegmentNumber( &Fcb->FileReference ) < ATTRIBUTE_DEF_TABLE_NUMBER)  &&
         ((NtfsSegmentNumber( &Fcb->FileReference ) != MASTER_FILE_TABLE_NUMBER) ||
          (MoveData->StartingVcn.QuadPart < LlClustersFromBytes( Vcb, FIRST_USER_FILE_NUMBER * Vcb->BytesPerFileRecordSegment )))) ||
        FlagOn( Fcb->FcbState, FCB_STATE_USN_JOURNAL ) ||
        NtfsEqualMftRef( &Fcb->FileReference, &BitmapFileReference )) {

        ObDereferenceObject( FileObject );
        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Disallow defragging on a read-only volume
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    //
    //  Verify that the start Vcn, Lcn and cluster count are valid values.
    //

    if ((MoveData->StartingVcn.QuadPart < 0) ||
        (MoveData->StartingVcn.QuadPart + MoveData->ClusterCount < MoveData->ClusterCount) ||
        (Vcb->MaxClusterCount < MoveData->StartingVcn.QuadPart + MoveData->ClusterCount) ||
        (MoveData->StartingLcn.QuadPart < 0) ||
        (MoveData->StartingLcn.QuadPart >= Vcb->TotalClusters)) {

        ObDereferenceObject( FileObject );
        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;

    }

    NtfsInitializeAttributeContext( &AttrContext );

    try {

        //
        //  For system files we need the vcb to test for dismounted volumes
        //

        if (FlagOn( Scb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {
            NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
            AcquiredVcb = TRUE;

            if (!FlagOn(Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {
                try_return( Status = STATUS_VOLUME_DISMOUNTED );
            }
        }

        //
        //  We now want to acquire the Scb to check if we can continue.  It is
        //  important to test whether this Scb has a paging io resource, not
        //  whether the Fcb has one.  Consider the case where a directory has
        //  a named data stream in it -- the Fcb will have a paging io resource,
        //  but the index root Scb will not.  In that case it would be a mistake
        //  to acquire the Fcb's paging io resource, since that will not serialize
        //  this operation with NtfsAcquireFileForCcFlush.
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING );
        NtfsAcquireFcbWithPaging( IrpContext, Scb->Fcb, 0 );
        AcquiredScb = TRUE;

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            try_return( Status = STATUS_VOLUME_DISMOUNTED );
        }

        //
        //  Check for the deny defrag being set
        //

        if (FlagOn( Scb->ScbPersist, SCB_PERSIST_DENY_DEFRAG )) {

            try_return( Status = STATUS_ACCESS_DENIED );
        }

        //
        //  Initialize the header if necc. If the attribute doesn't exist
        //  just leave - for instance an index allocation buffer
        //

        if (!NtfsLookupAttributeByName( IrpContext,
                                       Fcb,
                                       &Fcb->FileReference,
                                       Scb->AttributeTypeCode,
                                       &Scb->AttributeName,
                                       0,
                                       FALSE,
                                       &AttrContext )) {

            try_return( Status = STATUS_SUCCESS );
        }

        if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {
            NtfsUpdateScbFromAttribute( IrpContext, Scb, NtfsFoundAttribute( &AttrContext ) );
        }

        if ((TypeOfOpen == UserDirectoryOpen) || (TypeOfOpen == UserViewIndexOpen)) {

            //
            //  Initialize the Index information in the Scb if not done yet for indices.
            //

            if (Scb->ScbType.Index.BytesPerIndexBuffer == 0) {

                NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                NtfsInitializeAttributeContext( &AttrContext );

                if (!NtfsLookupAttributeByName( IrpContext,
                                                Fcb,
                                                &Fcb->FileReference,
                                                $INDEX_ROOT,
                                                &Scb->AttributeName,
                                                0,
                                                FALSE,
                                                &AttrContext )) {

                    ASSERTMSG("Could not find Index Root for Scb\n", FALSE);
                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                }

                NtfsUpdateIndexScbFromAttribute( IrpContext, Scb, NtfsFoundAttribute(&AttrContext), FALSE );
            }

            //
            //  Mark the irpcontext so we don't recursively push the index root while defragging
            //  the index. If we hit this on retry the force push flag will be set and we can safely
            //  pre-push the index
            //

            if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_FORCE_PUSH )) {
                NtfsPushIndexRoot( IrpContext, Scb );
            }
            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_PUSH );
        }

        //
        //  Cleanup the attribute context now to remove bcbs
        //

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        //
        //  If the stream is resident then we can return SUCCESS immediately.
        //  If the starting point is beyond file allocation then we can also
        //  return immediately.
        //

        FileOffset = (LONGLONG) LlBytesFromClusters( Vcb, MoveData->StartingVcn.QuadPart );
        ASSERT( FileOffset >= 0 );

        if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT ) ||
            (Scb->Header.AllocationSize.QuadPart < FileOffset)) {

            try_return( Status = STATUS_SUCCESS );
        }

        //
        //  Setup the intermediate buffer
        //

        ASSERT( LARGE_BUFFER_SIZE >= Vcb->BytesPerCluster );

        if (LARGE_BUFFER_SIZE > Vcb->BytesPerCluster) {
            BufferLength = LARGE_BUFFER_SIZE;
        } else {
            BufferLength = Vcb->BytesPerCluster;
        }

        IrpContext->Union.NtfsIoContext = &NtfsIoContext;
        RtlZeroMemory( IrpContext->Union.NtfsIoContext, sizeof( NTFS_IO_CONTEXT ));
        KeInitializeEvent( &IrpContext->Union.NtfsIoContext->Wait.SyncEvent,
                           NotificationEvent,
                           FALSE );

        DeletePendingFailureCountsLeft = 10;

        NtfsReleaseFcbWithPaging( IrpContext, Scb->Fcb );
        AcquiredScb = FALSE;

        if (AcquiredVcb) {
            NtfsReleaseVcb( IrpContext, Vcb );
            AcquiredVcb = FALSE;
        }

        if (IrpContext->TransactionId != 0) {

            ASSERT( !AcquiredAllFiles );

            //
            //  Complete the request which commits the pending
            //  transaction if there is one and releases of the
            //  acquired resources.  The IrpContext will not
            //  be deleted because the no delete flag is set.
            //

            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE | IRP_CONTEXT_FLAG_RETAIN_FLAGS );
            NtfsCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );
        }

        //
        //  Main loop - while there are more clusters requested to move try to move them
        //

        while (MoveData->ClusterCount > 0) {

            LCN Lcn;
            LONGLONG ClusterCount;
            LONGLONG TransferSize;
            LONGLONG TransferClusters;

            try {

                try {

#ifdef BENL_DBG
//                KdPrint(( "NTFS: defrag currentvcn: 0x%I64x limit: 0x%I64x\n", MoveData->StartingVcn.QuadPart, MoveData->StartingVcn.QuadPart + MoveData->ClusterCount ));
#endif

                    //
                    //  If necc. grab all the files to synchronzie with any transactions
                    //  flush the log and try to free recently deallocated clusters
                    //

                    if (FreeRecentlyDeallocated) {

                        FreeRecentlyDeallocated = FALSE;

                        try {

                            NtfsPurgeFileRecordCache( IrpContext );

                            //
                            //  Acquire all files to flush the log file and free recently deallocated.
                            //  Note the flush may raise, normally log file full, which will get rid of
                            //  the recently deallocated in a less efficient manner.
                            //

                            NtfsAcquireAllFiles( IrpContext, IrpContext->Vcb, FALSE, FALSE, FALSE );
                            AcquiredAllFiles = TRUE;

                            //
                            //  Since we've dropped and reacquired all thes file, we must retest
                            //  whether the volume has been dismounted. Use the vcb since acquireallfiles
                            //  grabs it
                            //

                            if (!FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

                                //
                                //  Raise we don't try to acquire the Scb exclusive in the try-finally
                                //  below.  We only hold this resource shared from the AcquireAllFiles
                                //  above.  It is OK to clear the REALLOCATE_ON_WRITE bit somewhat
                                //  unsynchronized since we will never touch this file again.
                                //

                                NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
                            }

                            LfsFlushToLsn( IrpContext->Vcb->LogHandle, LiMax );
                            NtfsFreeRecentlyDeallocated( IrpContext, IrpContext->Vcb, &LiMax, TRUE );


                        } finally {

                            if (AcquiredAllFiles) {

                                NtfsReleaseAllFiles( IrpContext, IrpContext->Vcb, FALSE );
                                AcquiredAllFiles = FALSE;
                            }
                        }
                    }

                    //
                    //  Purge anything left in cache because we hold nothing at this point
                    //

                    NtfsPurgeFileRecordCache( IrpContext );


                    //
                    //  For system files we need the vcb to test for dismounted volumes
                    //

                    if (FlagOn( Scb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {
                        NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
                        AcquiredVcb = TRUE;

                        if (!FlagOn(Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {
                            try_return( Status = STATUS_VOLUME_DISMOUNTED );
                        }
                    }

                    //
                    //  Reacquire everything for the defrag mft case + the mft flush
                    //  resource so we know lazy writes aren't active while we're doing stuff
                    //

                    if (NtfsSegmentNumber( &Fcb->FileReference ) == MASTER_FILE_TABLE_NUMBER) {

                        NtfsAcquireAllFiles( IrpContext, Vcb, TRUE, FALSE, FALSE );
                        AcquiredAllFiles = TRUE;

                        ExAcquireResourceExclusiveLite( &Vcb->MftFlushResource, TRUE );

                    } else {

                        NtfsAcquireFcbWithPaging( IrpContext, Scb->Fcb, 0 );
                        AcquiredScb = TRUE;

                        //
                        //  Since we've dropped and reacquired the Scb, we must retest
                        //  whether the volume has been dismounted.
                        //

                        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

                            try_return( Status = STATUS_VOLUME_DISMOUNTED );
                        }
                    }

                    //
                    //  If we acquired all the files above now do the work to check for free space in the mft
                    //

                    if (AcquiredAllFiles && (Vcb->MftScb->ScbType.Mft.RecordAllocationContext.NumberOfFreeBits <= 1)) {

                        MFT_SEGMENT_REFERENCE FileNumber;

#ifdef BENL_DBG
                        KdPrint(( "NTFS: too few mft records: 0x%x\n", Vcb->MftScb->ScbType.Mft.RecordAllocationContext.NumberOfFreeBits ));
#endif

                        FileNumber = NtfsAllocateMftRecord( IrpContext, Vcb, FALSE );
                        ASSERT( 0 == FileNumber.SegmentNumberHighPart );

                        NtfsDeallocateMftRecord( IrpContext, Vcb, FileNumber.SegmentNumberLowPart );
                        NtfsCheckpointCurrentTransaction( IrpContext );
#ifdef BENL_DBG
                        KdPrint(( "NTFS: after corection mft records: 0x%x\n", Vcb->MftScb->ScbType.Mft.RecordAllocationContext.NumberOfFreeBits ));
#endif

                        ASSERT( Vcb->MftScb->ScbType.Mft.RecordAllocationContext.NumberOfFreeBits > 1 );
                    }

                    //
                    //  Check if the attribute was deleted in between
                    //

                    if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED)) {
                        try_return( Status = STATUS_FILE_DELETED );
                    }

                    //
                    //  Leave if after regaining the file locks we are out of range
                    //

                    if (MoveData->StartingVcn.QuadPart > LlClustersFromBytes( Vcb, Scb->Header.AllocationSize.QuadPart )) {
                        break;
                    }

                    //
                    //  Check if this range of allocation exists - if not we can skip any work
                    //

                    if (NtfsLookupAllocation( IrpContext, Scb, MoveData->StartingVcn.QuadPart, &Lcn, &ClusterCount, NULL, NULL )) {

                        //
                        //  Now loop over the current range moving pieces of it
                        //

                        while ((MoveData->ClusterCount > 0) && (ClusterCount > 0)) {

                            LONGLONG UpperBound;

                            if (ClusterCount > MoveData->ClusterCount) {
                                TransferSize = LlBytesFromClusters( Vcb, MoveData->ClusterCount );
                            } else {
                                TransferSize = LlBytesFromClusters( Vcb, ClusterCount );
                            }
                            if (TransferSize > BufferLength ) {
                                TransferSize = BufferLength;
                            }
                            TransferClusters = LlClustersFromBytesTruncate( Vcb, TransferSize );

    #ifdef BENL_DBG
    //                        KdPrint(( "NTFS: defrag move vcn 0x%I64x to 0x%I64x for 0x%x\n", MoveData->StartingVcn.QuadPart, MoveData->StartingLcn.QuadPart, TransferClusters ));
    #endif

                            //
                            //  Reserve the new cluster if it falls within volume range
                            //

                            if (MoveData->StartingLcn.QuadPart + TransferClusters > Vcb->TotalClusters) {
                                NtfsRaiseStatus( IrpContext, STATUS_ALREADY_COMMITTED, NULL, NULL );
                            }

                            NtfsPreAllocateClusters( IrpContext, Vcb, MoveData->StartingLcn.QuadPart, TransferClusters, &AcquiredBitmap, &AcquiredMft );

                            //
                            //  Only actually transfer ranges within VDD or VDL - for those between
                            //  VDD and allocation size just reallocate. Use VDD for data streams
                            //  for all others that don't update VDD use VDL
                            //

                            if (($DATA == Scb->AttributeTypeCode) &&
                                !FlagOn( Scb->ScbState, SCB_STATE_MODIFIED_NO_WRITE ) &&
                                FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK)) {

                                //
                                //  Modified no write streams don't use VDD. The only data
                                //  stream currently like this is $Secure and $UsnJrnl which are not
                                //  defraggable
                                //

                                UpperBound = LlClustersFromBytes( Vcb, Scb->ValidDataToDisk );

                            } else {
                                UpperBound = LlClustersFromBytes( Vcb, Scb->Header.ValidDataLength.QuadPart );
                            }

                            if (MoveData->StartingVcn.QuadPart <= UpperBound) {

                                 NtfsCreateMdlAndBuffer( IrpContext,
                                                         Scb,
                                                         RESERVED_BUFFER_ONE_NEEDED,
                                                         &BufferLength,
                                                         &Mdl,
                                                         &Buffer );
                                Irp->MdlAddress = Mdl;

                                //
                                //  First read the cluster
                                //

                                NtfsSingleAsync( IrpContext,
                                                 Vcb->TargetDeviceObject,
                                                 LlBytesFromClusters( Vcb, Lcn ),
                                                 (ULONG)TransferSize,
                                                 Irp,
                                                 IRP_MJ_READ );

                                NtfsWaitSync( IrpContext );

                                NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                                    &Irp->IoStatus.Status,
                                                                    TRUE,
                                                                    STATUS_UNEXPECTED_IO_ERROR );

                                //
                                //  Clear return info field
                                //

                                Irp->IoStatus.Information = 0;

                                //
                                //  Then transfer it to the new location
                                //

                                NtfsSingleAsync( IrpContext,
                                                 Vcb->TargetDeviceObject,
                                                 LlBytesFromClusters( Vcb, MoveData->StartingLcn.QuadPart ),
                                                 (ULONG)TransferSize,
                                                 Irp,
                                                 IRP_MJ_WRITE );

                                NtfsWaitSync( IrpContext );


                                NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                                    &Irp->IoStatus.Status,
                                                                    TRUE,
                                                                    STATUS_UNEXPECTED_IO_ERROR );

                                Irp->IoStatus.Information = 0;

                                //
                                //  Release the buffer before calling lfs which may also need the reserved buffer
                                //

                                NtfsDeleteMdlAndBuffer( Mdl, Buffer );
                                Irp->MdlAddress = NULL;
                                Buffer = NULL;
                            }

                            //
                            //  Finally reallocate the cluster in the scb and checkpoint it
                            //

                            NtfsReallocateRange( IrpContext, Scb, MoveData->StartingVcn.QuadPart, TransferClusters, MoveData->StartingVcn.QuadPart, TransferClusters, &MoveData->StartingLcn.QuadPart );
                            NtfsCheckpointCurrentTransaction( IrpContext );

                            ASSERT( IrpContext->TransactionId == 0 );

                            if (AcquiredBitmap) {
                                NtfsReleaseScb( IrpContext, Vcb->BitmapScb );
                                AcquiredBitmap = FALSE;
                            }

                            if (AcquiredMft) {
                                NtfsReleaseScb( IrpContext, Vcb->MftScb );
                                AcquiredMft = FALSE;
                            }
#ifdef BENL_DBG
//                            KdPrint(( "NTFS: defrag succ. move vcn 0x%I64x to 0x%I64x\n", MoveData->StartingVcn.QuadPart, MoveData->StartingLcn.QuadPart ));
#endif

                            MoveData->StartingLcn.QuadPart += TransferClusters;
                            MoveData->StartingVcn.QuadPart += TransferClusters;
                            MoveData->ClusterCount -= (ULONG)TransferClusters;
                            ClusterCount -= TransferClusters;
                            Lcn += TransferClusters;

                        } // endwhile loop over lcn range

                    } else {

                        //
                        //  This is a hole skip over it
                        //

#ifdef BENL_DBG
    //                    KdPrint(( "NTFS: defrag hole vcn 0x%I64x to 0x%I64x\n", MoveData->StartingVcn.QuadPart, MoveData->StartingLcn.QuadPart ));
#endif

                        MoveData->StartingVcn.QuadPart += ClusterCount;
                        if (ClusterCount > MoveData->ClusterCount) {
                            MoveData->ClusterCount = 0;
                        } else {
                            MoveData->ClusterCount -= (ULONG)ClusterCount;
                        }
                    }

                } except( NtfsDefragExceptionFilter( IrpContext, GetExceptionInformation(), &DeletePendingFailureCountsLeft )) {

                    //
                    //  Cleanup the delete pending failure and next time through the loop
                    //  try to free the recently deallocated clusters to allow the cluster to be deleted
                    //

                    NtfsMinimumExceptionProcessing( IrpContext );
                    IrpContext->ExceptionStatus = STATUS_SUCCESS;

                    FreeRecentlyDeallocated = TRUE;

                }

            } finally {

                //
                //  Unlock the file and let anyone else access the file before
                //  looping back.
                //

                if (Buffer != NULL) {
                    NtfsDeleteMdlAndBuffer( Mdl, Buffer );
                    Irp->MdlAddress = NULL;
                    Buffer = NULL;
                }

                if (AcquiredBitmap) {
                    NtfsReleaseScb( IrpContext, Vcb->BitmapScb );
                    AcquiredBitmap = FALSE;
                }

                if (AcquiredMft) {
                    NtfsReleaseScb( IrpContext, Vcb->MftScb );
                    AcquiredMft = FALSE;
                }

                if (AcquiredScb) {
                    NtfsReleaseFcbWithPaging( IrpContext, Scb->Fcb );
                    AcquiredScb = FALSE;
                }

                if (AcquiredAllFiles) {
                    ExReleaseResourceLite( &Vcb->MftFlushResource );
                    NtfsReleaseAllFiles( IrpContext, Vcb, FALSE );
                    AcquiredAllFiles = FALSE;
                }

                if (AcquiredVcb) {
                    NtfsReleaseVcb( IrpContext, Vcb );
                    AcquiredVcb = FALSE;
                }
            }
        } // endwhile

        Status = STATUS_SUCCESS;

    try_exit: NOTHING;

    } finally {

        DebugUnwind( NtfsDefragFile );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        IrpContext->Union.NtfsIoContext = NULL;

        ASSERT( !AbnormalTermination() || (IrpContext->ExceptionStatus != STATUS_SUCCESS) );

        ASSERT( (Buffer == NULL) &&
                !AcquiredBitmap &&
                !AcquiredMft &&
                !AcquiredAllFiles );

        if (AcquiredScb) {
            NtfsReleaseFcbWithPaging( IrpContext, Scb->Fcb );
        }

        if (AcquiredVcb) {
            NtfsReleaseVcb( IrpContext, Vcb );
            AcquiredVcb = FALSE;
        }

        //
        //  Remove our reference on the users file object.
        //

        ObDereferenceObject( FileObject );
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


LONG
NtfsDefragExceptionFilter (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PEXCEPTION_POINTERS ExceptionPointer,
    IN OUT PULONG DeletePendingFailureCountsLeft
    )

/*++

Routine Description:

    Exception handler for defrag - pass on for all exceptions other than delete pending
    in that case if there the number of retries left is > 0 execute the handler


Arguments:

    ExceptionPointer - Supplies the exception record to being checked.

    DeletePendingFailureCountsLeft - how many more times to retry a delete pending

Return Value:

    ULONG - returns EXCEPTION_EXECUTE_HANDLER or CONTINUE_SEARCH

--*/

{
    UNREFERENCED_PARAMETER( IrpContext );

    if ((STATUS_DELETE_PENDING == ExceptionPointer->ExceptionRecord->ExceptionCode)) {

        *DeletePendingFailureCountsLeft -= 1;
        if ((*DeletePendingFailureCountsLeft) > 0) {
            return EXCEPTION_EXECUTE_HANDLER;
        } else {
            return EXCEPTION_CONTINUE_SEARCH;
        }

    } else {
        return EXCEPTION_CONTINUE_SEARCH;
    }
}

//
//  Because of protocol limitations in CIFS which uses 16 bits,
//  redirector can't currently accept buffer sizes larger than 64K.
//

#define RDR_BUFFER_SIZE_LIMIT    0x00010000L


NTSTATUS
NtfsReadFromPlex(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This implements directed reads from plexes. Given an offset, a length and a plexnumber
    along with a handle to a file or a volume, this coordinates reads from an underlying
    dynamic (mirrored) volume manager.

    Note that we ignore the VcbState flag VCB_STATE_NO_SECONDARY_AVAILABLE altogether
    and let the lower level driver respond.

Arguments:

    IrpContext - Supplies the IrpContext to process
    Irp - Incoming FSCTL IRP.

Return Value:

    Status SUCCESS on success, otherwise the relevant error code.

--*/

{
    PPLEX_READ_DATA_REQUEST ReadData;
    PIO_STACK_LOCATION IrpSp;
    ULONG InputBufferLength;
    ULONG UserBufferLength;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN Wait = TRUE;
    ULONG NumberOfRuns, RemainingByteCount;
    COMPRESSION_CONTEXT CompContext;
    TYPE_OF_OPEN TypeOfOpen;
    IO_RUN IoRuns[NTFS_MAX_PARALLEL_IOS];
    VBO ByteOffset;
    ULONG ByteCount;
    ULONG BytesToEof;
    ULONG LastReadByteCount;
    ULONG CurByteCount;
    LOGICAL AcquiredScb = FALSE;
    VOLUME_READ_PLEX_INPUT NplexRead;
    PVCB Vcb;
    PSCB Scb;
    PFCB Fcb;
    PCCB Ccb;

    //
    //  Extract and decode the file object
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    TypeOfOpen = NtfsDecodeFileObject( IrpContext,
                                       IrpSp->FileObject,
                                       &Vcb,
                                       &Fcb,
                                       &Scb,
                                       &Ccb,
                                       FALSE );

    //
    //  FileOpens and VolumeOpens are allowed.
    //

    if ((TypeOfOpen != UserFileOpen) &&
        (TypeOfOpen != UserVolumeOpen)) {

        Status = STATUS_INVALID_PARAMETER;
        NtfsCompleteRequest( IrpContext, Irp, Status );
        DebugTrace( -1, Dbg, ("NtfsReadFromPlex -> %08lx\n", Status) );
        return Status;
    }

    //
    //  This FSCTL is of type METHOD_OUT_DIRECT. The Io Manager has already
    //  copied the input parameters into the systembuffer field, probed the
    //  output buffer and locked the Mdls for us. So we can access these fields
    //  without fear.
    //

    ReadData = (PPLEX_READ_DATA_REQUEST)Irp->AssociatedIrp.SystemBuffer;

    if (ReadData == NULL) {

        Status = STATUS_INVALID_PARAMETER;
        NtfsCompleteRequest( IrpContext, Irp, Status );
        DebugTrace( -1, Dbg, ("NtfsReadFromPlex -> %08lx\n", Status) );
        return Status;
    }

    ByteOffset = ReadData->ByteOffset.QuadPart;
    ByteCount = ReadData->ByteLength;

    //
    //  Now, do the grunt work and clean up within a try finally.
    //

    try {

        //
        //  Sanity check the read length.
        //

    check_values:

        CurByteCount = 0;
        BytesToEof = 0;
        Irp->IoStatus.Information = 0;

        if ((ByteCount > MAXLONGLONG - ByteOffset) ||

            //
            //  File offsets should be cluster aligned
            //

            ((TypeOfOpen == UserFileOpen) &&
             ((ByteOffset & Vcb->ClusterMask) || (ByteCount & Vcb->ClusterMask))) ||

            //
            //  Volume offsets should be sector aligned
            //

            ((TypeOfOpen == UserVolumeOpen) &&
             (((ULONG)ByteOffset & (Vcb->BytesPerSector - 1)) || (ByteCount & (Vcb->BytesPerSector - 1))))) {

            Status = STATUS_INVALID_PARAMETER;
            leave;
        }

        //
        //  No-op
        //

        if (ByteCount == 0) {

            ASSERT(Status == STATUS_SUCCESS);
            ASSERT(CurByteCount == ByteCount);
            leave;
        }

        //
        //  Because of protocol limitations in CIFS which uses 16 bits,
        //  redirector can't accept buffer sizes larger than 64K.
        //

        if (ByteCount & ~(RDR_BUFFER_SIZE_LIMIT - 1L)) {

            Status = STATUS_INVALID_BUFFER_SIZE;
            leave;
        }

        //
        //  Sanity check input/output parameters.
        //

        InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
        UserBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

        if ((InputBufferLength < sizeof( PLEX_READ_DATA_REQUEST )) ||
            (UserBufferLength < ByteCount)) {

            Status = STATUS_BUFFER_TOO_SMALL;
            leave;
        }

        //
        //  For volume DASD reads, we just send an IOCTL down...
        //

        if (TypeOfOpen == UserVolumeOpen) {

            NplexRead.ByteOffset.QuadPart = ByteOffset;
            NplexRead.Length = ByteCount;
            NplexRead.PlexNumber = ReadData->PlexNumber;

            Status = NtfsDeviceIoControl( IrpContext,
                                          Vcb->TargetDeviceObject,
                                          IOCTL_VOLUME_READ_PLEX,
                                          &NplexRead,
                                          sizeof( VOLUME_READ_PLEX_INPUT ),
                                          NtfsMapUserBuffer( Irp ),
                                          ByteCount,
                                          &Irp->IoStatus.Information );

            ASSERT(!NT_SUCCESS( Status ) || Irp->IoStatus.Information != 0);
            DebugTrace( 0, Dbg, ("NtfsReadFromPlex: VolumeRead\n") );
            leave;
        }

        NtfsAcquireSharedScb( IrpContext, Scb );
        AcquiredScb = TRUE;

        //
        //  If the volume isn't mounted then fail immediately.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  We don't get along with encrypted/compressed/sparse things.
        //  ISSUE: supw: actually sparse should be ok, now that i'm using preparebuffers.
        //

        if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED |
                                         ATTRIBUTE_FLAG_COMPRESSION_MASK |
                                         ATTRIBUTE_FLAG_SPARSE )) {

            DebugTrace( 0, Dbg, ("NtfsReadFromPlex: File encrypted or compressed -> %08lx\n",
                                  STATUS_INVALID_PARAMETER) );
            Status = STATUS_INVALID_PARAMETER;
            leave;
        }

        NtfsAcquireFsrtlHeader( Scb );

        //
        //  Make sure we aren't starting past the end of the file, in which case
        //  we would have nothing to return.
        //

        if (ByteOffset >= Scb->Header.FileSize.QuadPart) {

            DebugTrace( 0, Dbg, ("NtfsReadFromPlex: beyond eof\n") );
            Status = STATUS_END_OF_FILE;
            NtfsReleaseFsrtlHeader( Scb );
            leave;
        }

        //
        //  We can't read beyond filesize.
        //

        if (Scb->Header.FileSize.QuadPart - ByteOffset < ByteCount) {

            BytesToEof = ByteCount = (ULONG)(Scb->Header.FileSize.QuadPart - ByteOffset);
            ByteCount = ClusterAlign( Vcb, ByteCount );

            //
            //  We need to sanity check ByteCount again, since we rounded it up.
            //

            NtfsReleaseFsrtlHeader( Scb );
            ASSERT( AcquiredScb );
            NtfsReleaseScb( IrpContext, Scb );
            goto check_values;
        }

        NtfsReleaseFsrtlHeader( Scb );

        //
        //  Can't deal with resident files.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

            Status = STATUS_NOT_IMPLEMENTED;
            leave;
        }

        //
        //  PrepareBuffers needs a CompressionContext for the IO_RUN array.
        //

        RtlZeroMemory( &CompContext, sizeof(COMPRESSION_CONTEXT) );
        CompContext.IoRuns = IoRuns;
        CompContext.AllocatedRuns = NTFS_MAX_PARALLEL_IOS;
        CompContext.FinishBuffersNeeded = FALSE;

        //
        //  Get the run information, and send the IOCTL down.
        //

        while (TRUE) {

            ULONG RunCount;
            ULONG_PTR SizeOfThisRead;
            Irp->IoStatus.Status = STATUS_SUCCESS;

            //
            //  Build an array of io runs to do our reads from.
            //

            RemainingByteCount = NtfsPrepareBuffers( IrpContext,
                                                     Irp,
                                                     Scb,
                                                     &ByteOffset,
                                                     ByteCount,
                                                     0,
                                                     &Wait,
                                                     &NumberOfRuns,
                                                     &CompContext );

            ASSERT( RemainingByteCount < ByteCount );
            ASSERT( Wait == TRUE );
            ASSERT( NumberOfRuns > 0 );
            ASSERT( NumberOfRuns > 1 || RemainingByteCount == 0 );

            //
            //  Send synchronous IOCTLs down to do the plex reads.
            //

            for (RunCount = 0;
                 RunCount < NumberOfRuns;
                 RunCount += 1) {

                NplexRead.ByteOffset.QuadPart = CompContext.IoRuns[RunCount].StartingLbo;
                NplexRead.Length = CompContext.IoRuns[RunCount].ByteCount;
                NplexRead.PlexNumber = ReadData->PlexNumber;

                //
                //  While CurByteCOunt keeps track of the total amount of bytes read,
                //  SizeOfThisRead carries the size of the last read done. This is usually
                //  equal to the IoRuns[].ByteCount.
                //

                SizeOfThisRead = 0;
                ASSERT(CompContext.IoRuns[RunCount].ByteCount > 0);

                Status = NtfsDeviceIoControl( IrpContext,
                                              Vcb->TargetDeviceObject,
                                              IOCTL_VOLUME_READ_PLEX,
                                              &NplexRead,
                                              sizeof(VOLUME_READ_PLEX_INPUT),
                                              Add2Ptr( NtfsMapUserBuffer( Irp ), CurByteCount ),
                                              CompContext.IoRuns[RunCount].ByteCount,
                                              &SizeOfThisRead);

                if (!NT_SUCCESS( Status )) {

                    //
                    //  Success if we read anything at all.
                    //

                    if (CurByteCount != 0) {

                        Status = STATUS_SUCCESS;
                    }

                    leave;
                }

                //
                //  This value was taken from the Iosb.Information field of the subordinate
                //  IRP, and should contain a nonzero value for successful completions.
                //

                ASSERT( (SizeOfThisRead != 0) && ((ULONG) SizeOfThisRead <= CompContext.IoRuns[RunCount].ByteCount) );
                CurByteCount = CurByteCount + (ULONG) SizeOfThisRead;

                //
                //  We don't have any more space left
                //

                if (UserBufferLength <= (ULONG) SizeOfThisRead) {

                    ASSERT( Status == STATUS_SUCCESS );
                    leave;
                }

                UserBufferLength = UserBufferLength - (ULONG) SizeOfThisRead;
            }

            if (RemainingByteCount == 0) {

                ASSERT( Status == STATUS_SUCCESS );
                break;
            }

            //
            //  We have more to read. Make sure we have enough buffer space.
            //

            LastReadByteCount = ByteCount - RemainingByteCount;

            ByteOffset = ByteOffset + LastReadByteCount;
            CompContext.SystemBufferOffset = CompContext.SystemBufferOffset + LastReadByteCount;
            ByteCount = RemainingByteCount;

        }

    } finally {

        if (AcquiredScb) {

            NtfsReleaseScb( IrpContext, Scb );
        }

        //
        //  If nothing raised then complete the irp.
        //

        if (!AbnormalTermination()) {

            if (NT_SUCCESS( Status )) {

                //
                //  We have to be careful to zero beyond the filesize.
                //

                if (CurByteCount > BytesToEof) {

                    RtlZeroMemory( Add2Ptr( NtfsMapUserBuffer( Irp ), BytesToEof ),
                                   CurByteCount - BytesToEof );
                    Irp->IoStatus.Information = BytesToEof;

                } else {

                    Irp->IoStatus.Information = CurByteCount;

                }
            }

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }

    }

    DebugTrace( -1, Dbg, ("NtfsReadPlex-> %08lx\n", Status) );

    return Status;
}

#if EFSDBG

NTSTATUS
NtfsDummyEfsRead (
    IN OUT PUCHAR InOutBuffer,
    IN PLARGE_INTEGER Offset,
    IN ULONG BufferSize,
    IN PVOID Context
    )
{
#ifndef SYSCACHE
    ULONG LocalOffset = 0;
#endif
    UNREFERENCED_PARAMETER( Context );

    //
    //  Exit cleanly if this is the call that is just there to
    //  make sure the compiler doesn't throw this function out.
    //

    if (BufferSize != 0) {

#ifdef SYSCACHE
        if (FALSE && VerifySyscacheData) {

            FsRtlVerifySyscacheData( NULL,
                                     InOutBuffer,
                                     BufferSize,
                                     Offset->LowPart );
        }
#else
        ASSERT( (Offset->QuadPart & 0x1ff) == 0 );
        ASSERT( (BufferSize & 0x1ff) == 0 );

        while((LocalOffset + 8) < BufferSize) {

            *((PLONGLONG) Add2Ptr(InOutBuffer, LocalOffset)) ^= (Offset->QuadPart + (LONGLONG) LocalOffset);
            LocalOffset += 0x200;
        }
//        UNREFERENCED_PARAMETER( InOutBuffer );
//        UNREFERENCED_PARAMETER( Offset );
//        UNREFERENCED_PARAMETER( BufferSize );
#endif

    }

    //
    //  Not much to do, decryption is done in place, so we can just leave the bits
    //  in the buffer.
    //

    return STATUS_SUCCESS;
}

NTSTATUS
NtfsDummyEfsWrite (
    IN PUCHAR InBuffer,
    OUT PUCHAR OutBuffer,
    IN PLARGE_INTEGER Offset,
    IN ULONG BufferSize,
    IN PUCHAR Context
    )
{
#ifndef SYSCACHE
    ULONG LocalOffset = 0;
#endif
    UNREFERENCED_PARAMETER( Context );

    //
    //  Exit cleanly if this is the call that is just there to
    //  make sure the compiler doesn't throw this function out.
    //

    if (BufferSize != 0) {

        //
        //  Just copy the plaintext to the output buffer.
        //

        RtlCopyMemory( OutBuffer,
                       InBuffer,
                       BufferSize );

#ifdef SYSCACHE
        if (FALSE && VerifySyscacheData) {

            FsRtlVerifySyscacheData( NULL,
                                     OutBuffer,
                                     BufferSize,
                                     Offset->LowPart );
        }
#else
        ASSERT( (Offset->QuadPart & 0x1ff) == 0 );
        ASSERT( (BufferSize & 0x1ff) == 0 );

        while((LocalOffset + 8) < BufferSize) {

            *((PLONGLONG) Add2Ptr(OutBuffer, LocalOffset)) ^= (Offset->QuadPart + (LONGLONG) LocalOffset);
            LocalOffset += 0x200;
        }
//        UNREFERENCED_PARAMETER( Offset );
#endif
    }

    return STATUS_SUCCESS;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\filobsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    FilObSup.c

Abstract:

    This module implements the Ntfs File object support routines.

Author:

    Gary Kimura     [GaryKi]        21-May-1991

Revision History:

--*/

#include "NtfsProc.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILOBSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsSetFileObject)
#endif


VOID
NtfsSetFileObject (
    IN PFILE_OBJECT FileObject,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN PSCB Scb,
    IN PCCB Ccb OPTIONAL
    )

/*++

Routine Description:

    This routine sets the file system pointers within the file object

Arguments:

    FileObject - Supplies a pointer to the file object being modified.

    TypeOfOpen - Supplies the type of open denoted by the file object.
        This is only used by this procedure for sanity checking.

    Scb - Supplies a pointer to Scb for the file object.

    Ccb - Optionally supplies a pointer to a ccb

Return Value:

    None.

--*/

{
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_SCB( Scb );
    ASSERT_OPTIONAL_CCB( Ccb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsSetFileObject, FileObject = %08lx\n", FileObject) );

    //
    //  Load up the FileObject fields.
    //

    FileObject->FsContext = Scb;
    FileObject->FsContext2 = Ccb;
    FileObject->Vpb = Scb->Vcb->Vpb;

    //
    //  Typically the I/O manager has already set this flag correctly.  The notable
    //  exception is when the user did an open by file ID of file record 3, so
    //  we're doing a DASD open, but the I/O manager didn't notice, since it only
    //  checks for a zero length filename.
    //

    if (TypeOfOpen == UserVolumeOpen) {
        SetFlag( FileObject->Flags, FO_VOLUME_OPEN );
    }

    //
    //  Now store TypeOfOpen if there is a Ccb
    //

    ASSERT((Ccb != NULL) || (TypeOfOpen == StreamFileOpen) || (TypeOfOpen == UnopenedFileObject));
    if (Ccb != NULL) {
        Ccb->TypeOfOpen = (UCHAR)TypeOfOpen;
    }

    //
    //  If this file has the temporary attribute bit set, don't lazy
    //  write it unless absolutely necessary.
    //

    if (FlagOn( Scb->ScbState, SCB_STATE_TEMPORARY )) {
        SetFlag( FileObject->Flags, FO_TEMPORARY_FILE );
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsSetFileObject -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsUpdateScbFromFileObject (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN BOOLEAN CheckTimeStamps
    )

/*++

Routine Description:

    This routine is called to update the Scb/Fcb to reflect the changes to
    a file through the fast io path.  It only called with a file object which
    represents a user's handle.

Arguments:

    FileObject - This is the file object used in the fast io path.

    Scb - This is the Scb for this stream.

    CheckTimeStamps - Indicates whether we want to update the time stamps from the
        fast io flags as well.  This will be TRUE if our caller will update the standard information,
        attribute header and duplicate info.  FALSE if only the attribute header and duplicate info.
        The latter case is the valid data length callback from the cache manager.

Return Value:

    None.

--*/

{

    PFCB Fcb = Scb->Fcb;
    ULONG CcbFlags;
    ULONG ScbFlags = 0;
    LONGLONG CurrentTime;

    //
    //  If the size of the main data stream is not part of the Fcb then update it
    //  now and set the correct Fcb flag.
    //

    if (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

        if (Fcb->Info.FileSize != Scb->Header.FileSize.QuadPart) {

            Fcb->Info.FileSize = Scb->Header.FileSize.QuadPart;
            SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_SIZE );
        }

        if (Fcb->Info.AllocatedLength != Scb->TotalAllocated) {

            Fcb->Info.AllocatedLength = Scb->TotalAllocated;
            SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_ALLOC_SIZE );
        }

        if (FlagOn( FileObject->Flags, FO_FILE_SIZE_CHANGED )) {

            SetFlag( ScbFlags, SCB_STATE_CHECK_ATTRIBUTE_SIZE );
        }

    //
    //  Remember to update the size in the attribute header for named streams as well.
    //

    } else if (FlagOn( FileObject->Flags, FO_FILE_SIZE_CHANGED )) {

        SetFlag( ScbFlags, SCB_STATE_NOTIFY_RESIZE_STREAM | SCB_STATE_CHECK_ATTRIBUTE_SIZE );
    }

    ClearFlag( FileObject->Flags, FO_FILE_SIZE_CHANGED );

    //
    //  Check whether to update the time stamps if our caller requested it.
    //

    if (CheckTimeStamps && !FlagOn( FileObject->Flags, FO_CLEANUP_COMPLETE )) {

        BOOLEAN UpdateLastAccess = FALSE;
        BOOLEAN UpdateLastChange = FALSE;
        BOOLEAN UpdateLastModify = FALSE;
        BOOLEAN SetArchive = TRUE;

        //
        //  Copy the Ccb flags to a local variable.  Then we won't have to test
        //  for the existence of the Ccb each time.
        //

        CcbFlags = 0;

        //
        //  Capture the real flags if present and clear them since we will update the Scb/Fcb.
        //

        if (FileObject->FsContext2 != NULL) {

            CcbFlags = ((PCCB) FileObject->FsContext2)->Flags;
            ClearFlag( ((PCCB) FileObject->FsContext2)->Flags,
                       (CCB_FLAG_UPDATE_LAST_MODIFY |
                        CCB_FLAG_UPDATE_LAST_CHANGE |
                        CCB_FLAG_SET_ARCHIVE) );
        }

        NtfsGetCurrentTime( IrpContext, CurrentTime );

        //
        //  If there was a write to the file then update the last change, last access
        //  and last write and the archive bit.
        //

        if (FlagOn( FileObject->Flags, FO_FILE_MODIFIED )) {

            UpdateLastModify =
            UpdateLastAccess =
            UpdateLastChange = TRUE;

        //
        //  Otherwise test each of the individual bits in the file object and
        //  Ccb.
        //

        } else {

            if (FlagOn( FileObject->Flags, FO_FILE_FAST_IO_READ )) {

                UpdateLastAccess = TRUE;
            }

            if (FlagOn( CcbFlags, CCB_FLAG_UPDATE_LAST_CHANGE )) {

                UpdateLastChange = TRUE;

                if (FlagOn( CcbFlags, CCB_FLAG_UPDATE_LAST_MODIFY )) {

                    UpdateLastModify = TRUE;
                }

                if (!FlagOn( CcbFlags, CCB_FLAG_SET_ARCHIVE )) {

                    SetArchive = FALSE;
                }
            }
        }

        //
        //  Now set the correct Fcb bits.
        //

        if (UpdateLastChange) {

            if (SetArchive) {

                ASSERTMSG( "conflict with flush", 
                           ExIsResourceAcquiredSharedLite( Fcb->Resource ) || 
                           (Fcb->PagingIoResource != NULL && 
                            ExIsResourceAcquiredSharedLite( Fcb->PagingIoResource )));

                SetFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_ARCHIVE );
                SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );
                SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
            }

            if (!FlagOn( CcbFlags, CCB_FLAG_USER_SET_LAST_CHANGE_TIME )) {

                Fcb->Info.LastChangeTime = CurrentTime;
                SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_LAST_CHANGE );
                SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
            }

            if (UpdateLastModify) {

                //
                //  Remember a change to a named data stream.
                //

                if (!FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA ) &&
                    (Scb->AttributeTypeCode == $DATA)) {

                    SetFlag( ScbFlags, SCB_STATE_NOTIFY_MODIFY_STREAM );
                }

                if (!FlagOn( CcbFlags, CCB_FLAG_USER_SET_LAST_MOD_TIME )) {

                    Fcb->Info.LastModificationTime = CurrentTime;
                    SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_LAST_MOD );
                    SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
                }
            }
        }

        if (UpdateLastAccess &&
            !FlagOn( CcbFlags, CCB_FLAG_USER_SET_LAST_ACCESS_TIME ) &&
            !FlagOn( NtfsData.Flags, NTFS_FLAGS_DISABLE_LAST_ACCESS )) {

            Fcb->CurrentLastAccess = CurrentTime;
            SetFlag( Fcb->InfoFlags, FCB_INFO_UPDATE_LAST_ACCESS );
        }

        //
        //  Clear all of the fast io flags in the file object.
        //

        ClearFlag( FileObject->Flags, FO_FILE_MODIFIED | FO_FILE_FAST_IO_READ );
    }

    //
    //  Now store the Scb flags into the Scb.
    //

    if (ScbFlags) {

        NtfsAcquireFsrtlHeader( Scb );
        SetFlag( Scb->ScbState, ScbFlags );
        NtfsReleaseFsrtlHeader( Scb );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\flush.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Flush.c

Abstract:

    This module implements the flush buffers routine for Ntfs called by the
    dispatch driver.

Author:

    Tom Miller      [TomM]          18-Jan-1992

Revision History:

--*/

#include "NtfsProc.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NTFS_BUG_CHECK_FLUSH)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_FLUSH)

//
//  Macro to attempt to flush a stream from an Scb.
//

#define FlushScb(IRPC,SCB,IOS) {                                                \
    (IOS)->Status = NtfsFlushUserStream((IRPC),(SCB),NULL,0);                   \
    NtfsNormalizeAndCleanupTransaction( IRPC,                                   \
                                        &(IOS)->Status,                         \
                                        TRUE,                                   \
                                        STATUS_UNEXPECTED_IO_ERROR );           \
    if (FlagOn((SCB)->ScbState, SCB_STATE_FILE_SIZE_LOADED)) {                  \
        NtfsWriteFileSizes( (IRPC),                                             \
                            (SCB),                                              \
                            &(SCB)->Header.ValidDataLength.QuadPart,            \
                            TRUE,                                               \
                            TRUE,                                               \
                            TRUE );                                             \
    }                                                                           \
}

//
//  Local procedure prototypes
//

NTSTATUS
NtfsFlushCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

NTSTATUS
NtfsFlushFcbFileRecords (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

LONG
NtfsFlushVolumeExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer,
    IN NTSTATUS ExceptionCode
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCommonFlushBuffers)
#pragma alloc_text(PAGE, NtfsFlushAndPurgeFcb)
#pragma alloc_text(PAGE, NtfsFlushAndPurgeScb)
#pragma alloc_text(PAGE, NtfsFlushFcbFileRecords)
#pragma alloc_text(PAGE, NtfsFlushLsnStreams)
#pragma alloc_text(PAGE, NtfsFlushVolume)
#pragma alloc_text(PAGE, NtfsFsdFlushBuffers)
#pragma alloc_text(PAGE, NtfsFlushUserStream)
#endif


NTSTATUS
NtfsFsdFlushBuffers (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of flush buffers.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    NTSTATUS Status = STATUS_SUCCESS;
    PIRP_CONTEXT IrpContext = NULL;

    ASSERT_IRP( Irp );

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFsdFlushBuffers\n") );

    //
    //  Call the common flush buffer routine
    //

    FsRtlEnterFileSystem();

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, FALSE, FALSE );

    do {

        try {

            //
            //  We are either initiating this request or retrying it.
            //

            if (IrpContext == NULL) {

                //
                //  Allocate and initialize the Irp.
                //

                NtfsInitializeIrpContext( Irp, CanFsdWait( Irp ), &IrpContext );

                //
                //  Initialize the thread top level structure, if needed.
                //

                NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

            } else if (Status == STATUS_LOG_FILE_FULL) {

                NtfsCheckpointForLogFileFull( IrpContext );
            }

            Status = NtfsCommonFlushBuffers( IrpContext, Irp );
            break;

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error status that we get back from the
            //  execption code
            //

            Status = NtfsProcessException( IrpContext, Irp, GetExceptionCode() );
        }

    } while (Status == STATUS_CANT_WAIT ||
             Status == STATUS_LOG_FILE_FULL);

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsFsdFlushBuffers -> %08lx\n", Status) );

    return Status;
}


NTSTATUS
NtfsCommonFlushBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for flush buffers called by both the fsd and fsp
    threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp;

    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PLCB Lcb = NULL;
    PSCB ParentScb = NULL;

    BOOLEAN VcbAcquired = FALSE;
    BOOLEAN ScbAcquired = FALSE;
    BOOLEAN ParentScbAcquired = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonFlushBuffers\n") );
    DebugTrace( 0, Dbg, ("Irp           = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, ("->FileObject  = %08lx\n", IrpSp->FileObject) );

    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  abort immediately for non files
    //

    if (UnopenedFileObject == TypeOfOpen) {
        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Nuthin-doing if the volume is mounted read only.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        Status = STATUS_MEDIA_WRITE_PROTECTED;
        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( -1, Dbg, ("NtfsCommonFlushBuffers -> %08lx\n", Status) );
        return Status;
    }

    Status = STATUS_SUCCESS;

    try {

        //
        //  Case on the type of open that we are trying to flush
        //

        switch (TypeOfOpen) {

        case UserFileOpen:

            DebugTrace( 0, Dbg, ("Flush User File Open\n") );

            //
            //  Acquire the Vcb so we can update the duplicate information as well.
            //

            NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
            VcbAcquired = TRUE;

            //
            //  While we have the Vcb, let's make sure it's still mounted.
            //

            if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

                try_return( Status = STATUS_VOLUME_DISMOUNTED );
            }

            //
            //  Make sure the data gets out to disk.
            //

            NtfsAcquireExclusivePagingIo( IrpContext, Fcb );

            //
            //  Acquire exclusive access to the Scb and enqueue the irp
            //  if we didn't get access
            //

            NtfsAcquireExclusiveScb( IrpContext, Scb );
            ScbAcquired = TRUE;

            //
            //  Flush the stream and verify there were no errors.
            //

            FlushScb( IrpContext, Scb, &Irp->IoStatus );

            //
            //  Now commit what we've done so far.
            //

            NtfsCheckpointCurrentTransaction( IrpContext );

            //
            //  Update the time stamps and file sizes in the Fcb based on
            //  the state of the File Object.
            //

            NtfsUpdateScbFromFileObject( IrpContext, FileObject, Scb, TRUE );

            //
            //  If we are to update standard information then do so now.
            //

            if (FlagOn( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO )) {

                NtfsUpdateStandardInformation( IrpContext, Fcb );
            }

            //
            //  If this is the system hive there is more work to do.  We want to flush
            //  all of the file records for this file as well as for the parent index
            //  stream.  We also want to flush the parent index stream.  Acquire the
            //  parent stream exclusively now so that the update duplicate call won't
            //  acquire it shared first.
            //

            if (FlagOn( Ccb->Flags, CCB_FLAG_SYSTEM_HIVE )) {

                //
                //  Start by acquiring all of the necessary files to avoid deadlocks.
                //

                if (Ccb->Lcb != NULL) {

                    ParentScb = Ccb->Lcb->Scb;

                    if (ParentScb != NULL) {

                        NtfsAcquireExclusiveScb( IrpContext, ParentScb );
                        ParentScbAcquired = TRUE;
                    }
                }
            }

            //
            //  Update the duplicate information if there are updates to apply.
            //

            if (FlagOn( Fcb->InfoFlags, FCB_INFO_DUPLICATE_FLAGS )) {

                Lcb = Ccb->Lcb;

                NtfsPrepareForUpdateDuplicate( IrpContext, Fcb, &Lcb, &ParentScb, TRUE );
                NtfsUpdateDuplicateInfo( IrpContext, Fcb, Lcb, ParentScb );
                NtfsUpdateLcbDuplicateInfo( Fcb, Lcb );

                if (ParentScbAcquired) {

                    NtfsReleaseScb( IrpContext, ParentScb );
                    ParentScbAcquired = FALSE;
                }
            }

            //
            //  Now flush the file records for this stream.
            //

            if (FlagOn( Ccb->Flags, CCB_FLAG_SYSTEM_HIVE )) {

                //
                //  Flush the file records for this file.
                //

                Status = NtfsFlushFcbFileRecords( IrpContext, Scb->Fcb );

                //
                //  Now flush the parent index stream.
                //

                if (NT_SUCCESS(Status) && (ParentScb != NULL)) {

                    CcFlushCache( &ParentScb->NonpagedScb->SegmentObject, NULL, 0, &Irp->IoStatus );
                    Status = Irp->IoStatus.Status;

                    //
                    //  Finish by flushing the file records for the parent out
                    //  to disk.
                    //

                    if (NT_SUCCESS( Status )) {

                        Status = NtfsFlushFcbFileRecords( IrpContext, ParentScb->Fcb );
                    }
                }
            }

            //
            //  If our status is still success then flush the log file and
            //  report any changes.
            //

            if (NT_SUCCESS( Status )) {

                ULONG FilterMatch;

                LfsFlushToLsn( Vcb->LogHandle, LiMax );

                //
                //  We only want to do this DirNotify if we updated duplicate
                //  info and set the ParentScb.
                //

                if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID ) &&
                    (Vcb->NotifyCount != 0) &&
                    FlagOn( Fcb->InfoFlags, FCB_INFO_DUPLICATE_FLAGS )) {

                    FilterMatch = NtfsBuildDirNotifyFilter( IrpContext, Fcb->InfoFlags );

                    if (FilterMatch != 0) {

                        NtfsReportDirNotify( IrpContext,
                                             Fcb->Vcb,
                                             &Ccb->FullFileName,
                                             Ccb->LastFileNameOffset,
                                             NULL,
                                             ((FlagOn( Ccb->Flags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                                               (Ccb->Lcb != NULL) &&
                                               (Ccb->Lcb->Scb->ScbType.Index.NormalizedName.Length != 0)) ?
                                              &Ccb->Lcb->Scb->ScbType.Index.NormalizedName :
                                              NULL),
                                             FilterMatch,
                                             FILE_ACTION_MODIFIED,
                                             ParentScb->Fcb );
                    }
                }

                ClearFlag( Fcb->InfoFlags,
                           FCB_INFO_NOTIFY_FLAGS | FCB_INFO_DUPLICATE_FLAGS );
            }

            break;

        case UserViewIndexOpen:
        case UserDirectoryOpen:

            //
            //  If the user had opened the root directory then we'll
            //  oblige by flushing the volume.
            //

            if (NodeType(Scb) != NTFS_NTC_SCB_ROOT_INDEX) {

                DebugTrace( 0, Dbg, ("Flush a directory does nothing\n") );
                break;
            }

        case UserVolumeOpen:

            DebugTrace( 0, Dbg, ("Flush User Volume Open\n") );

            NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
            VcbAcquired = TRUE;

            //
            //  While we have the Vcb, let's make sure it's still mounted.
            //

            if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

                try_return( Status = STATUS_VOLUME_DISMOUNTED );
            }

            NtfsFlushVolume( IrpContext,
                             Vcb,
                             TRUE,
                             FALSE,
                             TRUE,
                             FALSE );

            //
            //  Make sure all of the data written in the flush gets to disk.
            //

            LfsFlushToLsn( Vcb->LogHandle, LiMax );
            break;

        case StreamFileOpen:

            //
            //  Nothing to do here.
            //

            break;

        default:

            //
            //  Nothing to do if we have our driver object.
            //

            break;
        }

        //
        //  Abort transaction on error by raising.
        //

        NtfsCleanupTransaction( IrpContext, Status, FALSE );

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( NtfsCommonFlushBuffers );

        //
        //  Release any resources which were acquired.
        //

        if (ScbAcquired) {
            NtfsReleaseScb( IrpContext, Scb );
        }

        if (ParentScbAcquired) {
            NtfsReleaseScb( IrpContext, ParentScb );
        }

        if (VcbAcquired) {
            NtfsReleaseVcb( IrpContext, Vcb );
        }

        //
        //  If this is a normal termination then pass the request on
        //  to the target device object.
        //

        if (!AbnormalTermination()) {

            NTSTATUS DriverStatus;
            PIO_STACK_LOCATION NextIrpSp;

            //
            //  Free the IrpContext now before calling the lower driver.  Do this
            //  now in case this fails so that we won't complete the Irp in our
            //  exception routine after passing it to the lower driver.
            //

            NtfsCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

            ASSERT( Vcb != NULL );

            //
            //  Get the next stack location, and copy over the stack location
            //


            NextIrpSp = IoGetNextIrpStackLocation( Irp );

            *NextIrpSp = *IrpSp;


            //
            //  Set up the completion routine
            //

            IoSetCompletionRoutine( Irp,
                                    NtfsFlushCompletionRoutine,
                                    NULL,
                                    TRUE,
                                    TRUE,
                                    TRUE );

            //
            //  Send the request.
            //

            DriverStatus = IoCallDriver(Vcb->TargetDeviceObject, Irp);

            Status = (DriverStatus == STATUS_INVALID_DEVICE_REQUEST) ?
                     Status : DriverStatus;

        }

        DebugTrace( -1, Dbg, ("NtfsCommonFlushBuffers -> %08lx\n", Status) );
    }

    return Status;
}


NTSTATUS
NtfsFlushVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN FlushCache,
    IN BOOLEAN PurgeFromCache,
    IN BOOLEAN ReleaseAllFiles,
    IN BOOLEAN MarkFilesForDismount
    )

/*++

Routine Description:

    This routine non-recursively flushes a volume.  This routine will always do
    as much of the operation as possible.  It will continue until getting a logfile
    full.  If any of the streams can't be flushed because of corruption then we
    will try to flush the others.  We will mark the volume dirty in this case.

    We will pass the error code back to the caller because they often need to
    proceed as best as possible (i.e. shutdown).

Arguments:

    Vcb - Supplies the volume to flush

    FlushCache - Supplies TRUE if the caller wants to flush the data in the
        cache to disk.

    PurgeFromCache - Supplies TRUE if the caller wants the data purged from
        the Cache (such as for autocheck!)

    ReleaseAllFiles - Indicates that our caller would like to release all Fcb's
        after TeardownStructures.  This will prevent a deadlock when acquiring
        paging io resource after a main resource which is held from a previous
        teardown.

Return Value:

    STATUS_SUCCESS or else the first error status.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PFCB Fcb;
    PFCB NextFcb;
    PSCB Scb;
    PSCB NextScb;
    IO_STATUS_BLOCK IoStatus;

    ULONG Pass;

    BOOLEAN UserDataFile;
    BOOLEAN RemovedFcb = FALSE;
    BOOLEAN DecrementScbCleanup = FALSE;
    BOOLEAN DecrementNextFcbClose = FALSE;
    BOOLEAN DecrementNextScbCleanup = FALSE;

    BOOLEAN AcquiredFcb = FALSE;
    BOOLEAN PagingIoAcquired = FALSE;
    BOOLEAN ReleaseFiles = FALSE;
    LOGICAL MediaRemoved = FALSE;
    LONG ReleaseVcbCount = 0;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFlushVolume, Vcb = %08lx\n", Vcb) );

    //
    //  This operation must be able to wait.
    //

    if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )) {

        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
    }

    //
    //  Make sure there is nothing on the delayed close queue.
    //

    NtfsFspClose( Vcb );

    //
    //  Acquire the Vcb exclusive.  The Raise condition cannot happen.
    //

    NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
    ReleaseVcbCount += 1;

    try {

        //
        //  We won't do any flushes, but we still have to
        //  do the dismount/teardown processing.
        //

        if ((IrpContext->MajorFunction == IRP_MJ_PNP) &&
            (IrpContext->MinorFunction == IRP_MN_SURPRISE_REMOVAL)) {

            MediaRemoved = TRUE;
        }

        //
        //  Don't bother flushing read only volumes
        //

        if (NtfsIsVolumeReadOnly( Vcb )) {
            FlushCache = FALSE;
        }

        //
        //  Set the PURGE_IN_PROGRESS flag if this is a purge operation.
        //

        if (PurgeFromCache) {

            SetFlag( Vcb->VcbState, VCB_STATE_VOL_PURGE_IN_PROGRESS);
        }

        //
        //  Start by flushing the log file to assure Write-Ahead-Logging.
        //

        if (!MediaRemoved) {

            LfsFlushToLsn( Vcb->LogHandle, LiMax );
        }

        //
        //  There will be two passes through the Fcb's for the volume.  On the
        //  first pass we just want to flush/purge the user data streams.  On
        //  the second pass we want to flush the other streams.  We hold off on
        //  several of the system files until after these two passes since they
        //  may be modified during the flush phases.
        //

        Pass = 0;

        do {

            PVOID RestartKey;

            //
            //  Loop through all of the Fcb's in the Fcb table.
            //

            RestartKey = NULL;

            NtfsAcquireFcbTable( IrpContext, Vcb );
            NextFcb = Fcb = NtfsGetNextFcbTableEntry( Vcb, &RestartKey );
            NtfsReleaseFcbTable( IrpContext, Vcb );

            if (NextFcb != NULL) {

                InterlockedIncrement( &NextFcb->CloseCount );
                DecrementNextFcbClose = TRUE;
            }

            while (Fcb != NULL) {

                //
                //  Acquire Paging I/O first, since we may be deleting or truncating.
                //  Testing for the PagingIoResource is not really safe without
                //  holding the main resource, so we correct for that below.
                //

                if (Fcb->PagingIoResource != NULL) {
                    NtfsAcquireExclusivePagingIo( IrpContext, Fcb );
                    PagingIoAcquired = TRUE;
                }

                //
                //  Let's acquire this Scb exclusively.
                //

                NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                AcquiredFcb = TRUE;

                //
                //  We depend on the state of the RemovedFcb flag to tell us that
                //  we can trust the 'Acquired' booleans above.
                //

                ASSERT( !RemovedFcb );

                //
                //  If we now do not see a paging I/O resource we are golden,
                //  othewise we can absolutely release and acquire the resources
                //  safely in the right order, since a resource in the Fcb is
                //  not going to go away.
                //

                if (!PagingIoAcquired && (Fcb->PagingIoResource != NULL)) {
                    NtfsReleaseFcb( IrpContext, Fcb );
                    NtfsAcquireExclusivePagingIo( IrpContext, Fcb );
                    PagingIoAcquired = TRUE;
                    NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                }

                //
                //  If this is not one of the special system files then perform
                //  the flush and purge as requested.  Go ahead and test file numbers
                //  instead of walking through the Scbs in the Vcb just in case they
                //  have been deleted.
                //

                if (NtfsSegmentNumber( &Fcb->FileReference ) != MASTER_FILE_TABLE_NUMBER &&
                    NtfsSegmentNumber( &Fcb->FileReference ) != LOG_FILE_NUMBER &&
                    NtfsSegmentNumber( &Fcb->FileReference ) != VOLUME_DASD_NUMBER &&
                    NtfsSegmentNumber( &Fcb->FileReference ) != BIT_MAP_FILE_NUMBER &&
                    NtfsSegmentNumber( &Fcb->FileReference ) != BOOT_FILE_NUMBER &&
                    NtfsSegmentNumber( &Fcb->FileReference ) != BAD_CLUSTER_FILE_NUMBER &&
                    !FlagOn( Fcb->FcbState, FCB_STATE_USN_JOURNAL )) {

                    //
                    //  We will walk through all of the Scb's for this Fcb.  In
                    //  the first pass we will only deal with user data streams.
                    //  In the second pass we will do the others.
                    //

                    Scb = NULL;

                    while (TRUE) {

                        Scb = NtfsGetNextChildScb( Fcb, Scb );

                        if (Scb == NULL) { break; }

                        //
                        //  Reference the Scb to keep it from going away.
                        //

                        InterlockedIncrement( &Scb->CleanupCount );
                        DecrementScbCleanup = TRUE;

                        //
                        //  Check whether this is a user data file.
                        //

                        UserDataFile = FALSE;

                        if ((NodeType( Scb ) == NTFS_NTC_SCB_DATA) &&
                            (Scb->AttributeTypeCode == $DATA)) {

                            UserDataFile = TRUE;
                        }

                        //
                        //  Process this Scb in the correct loop.
                        //

                        if ((Pass == 0) == (UserDataFile)) {

                            //
                            //  Initialize the state of the Io to SUCCESS.
                            //

                            IoStatus.Status = STATUS_SUCCESS;

                            //
                            //  Don't put this Scb on the delayed close queue.
                            //

                            ClearFlag( Scb->ScbState, SCB_STATE_DELAY_CLOSE );

                            //
                            //  Flush this stream if it is not already deleted.
                            //  Also don't flush resident streams for system attributes.
                            //

                            if (FlushCache &&
                                !FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED ) &&
                                (!FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT) ||
                                 (Scb->AttributeTypeCode == $DATA))) {

                                //
                                //  Enclose the flushes with try-except, so that we can
                                //  react to log file full, and in any case keep on truckin.
                                //

                                try {

                                    FlushScb( IrpContext, Scb, &IoStatus );
                                    NtfsCheckpointCurrentTransaction( IrpContext );

                                //
                                //  We will handle all errors except LOG_FILE_FULL and fatal
                                //  bugcheck errors here.  In the corruption case we will
                                //  want to mark the volume dirty and continue.
                                //

                                } except( NtfsFlushVolumeExceptionFilter( IrpContext,
                                                                          GetExceptionInformation(),
                                                                          (IoStatus.Status = GetExceptionCode()) )) {

                                    //
                                    //  To make sure that we can access all of our streams correctly,
                                    //  we first restore all of the higher sizes before aborting the
                                    //  transaction.  Then we restore all of the lower sizes after
                                    //  the abort, so that all Scbs are finally restored.
                                    //

                                    NtfsRestoreScbSnapshots( IrpContext, TRUE );
                                    NtfsAbortTransaction( IrpContext, IrpContext->Vcb, NULL );
                                    NtfsRestoreScbSnapshots( IrpContext, FALSE );

                                    //
                                    //  Clear the top-level exception status so we won't raise
                                    //  later.
                                    //

                                    NtfsMinimumExceptionProcessing( IrpContext );
                                    IrpContext->ExceptionStatus = STATUS_SUCCESS;

                                    //
                                    //  Remember the first error.
                                    //

                                    if (Status == STATUS_SUCCESS) {

                                        Status = IoStatus.Status;
                                    }

                                    //
                                    //  If the current status is either DISK_CORRUPT or FILE_CORRUPT then
                                    //  mark the volume dirty.  We clear the IoStatus to allow
                                    //  a corrupt file to be purged.  Otherwise it will never
                                    //  leave memory.
                                    //

                                    if ((IoStatus.Status == STATUS_DISK_CORRUPT_ERROR) ||
                                        (IoStatus.Status == STATUS_FILE_CORRUPT_ERROR)) {

                                        NtfsMarkVolumeDirty( IrpContext, Vcb, TRUE );
                                        IoStatus.Status = STATUS_SUCCESS;
                                    }
                                }
                            }

                            //
                            //  Proceed with the purge if there are no failures.  We will
                            //  purge if the flush revealed a corrupt file though.
                            //

                            if (PurgeFromCache
                                && IoStatus.Status == STATUS_SUCCESS) {

                                BOOLEAN DataSectionExists;
                                BOOLEAN ImageSectionExists;

                                DataSectionExists = (BOOLEAN)(Scb->NonpagedScb->SegmentObject.DataSectionObject != NULL);
                                ImageSectionExists = (BOOLEAN)(Scb->NonpagedScb->SegmentObject.ImageSectionObject != NULL);

                                //
                                //  Since purging the data section can cause the image
                                //  section to go away, we will flush the image section first.
                                //

                                if (ImageSectionExists) {

                                    (VOID)MmFlushImageSection( &Scb->NonpagedScb->SegmentObject, MmFlushForWrite );
                                }

                                if (DataSectionExists &&
                                    !CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject,
                                                          NULL,
                                                          0,
                                                          FALSE ) &&
                                    (Status == STATUS_SUCCESS)) {


                                    Status = STATUS_UNABLE_TO_DELETE_SECTION;
                                }
                            }

                            if (MarkFilesForDismount) {

                                //
                                //  Set the dismounted flag for this stream so we
                                //  know we have to fail reads & writes to it.
                                //

                                SetFlag( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED );

                                //  Also mark the Scb as not allowing fast io --
                                //  this ensures that the file system will get a
                                //  chance to see all reads & writes to this stream.
                                //

                                NtfsAcquireFsrtlHeader( Scb );
                                Scb->Header.IsFastIoPossible = FastIoIsNotPossible;
                                NtfsReleaseFsrtlHeader( Scb );
                            }
                        }

                        //
                        //  Move to the next Scb.
                        //

                        InterlockedDecrement( &Scb->CleanupCount );
                        DecrementScbCleanup = FALSE;
                    }
                }

                //
                //  If the current Fcb has a USN journal entry and we are forcing a dismount
                //  then generate the close record.
                //

                if (MarkFilesForDismount &&
                    (IoStatus.Status == STATUS_SUCCESS) &&
                    (NextFcb->FcbUsnRecord != NULL) &&
                    (NextFcb->FcbUsnRecord->UsnRecord.Reason != 0) &&
                    (!NtfsIsVolumeReadOnly( Vcb ))) {

                    //
                    //  Try to post the change but don't fail on an error like DISK_FULL.
                    //

                    try {

                        //
                        //  Now try to actually post the change.
                        //

                        NtfsPostUsnChange( IrpContext, Fcb, USN_REASON_CLOSE );

                        //
                        //  Now write the journal, checkpoint the transaction, and free the UsnJournal to
                        //  reduce contention.  We force the write now, because the Fcb may get deleted
                        //  before we normally would write the changes when the transaction commits.
                        //

                        NtfsWriteUsnJournalChanges( IrpContext );
                        NtfsCheckpointCurrentTransaction( IrpContext );

                    } except( NtfsFlushVolumeExceptionFilter( IrpContext,
                                                              GetExceptionInformation(),
                                                              (IoStatus.Status = GetExceptionCode()) )) {

                        NtfsMinimumExceptionProcessing( IrpContext );
                        IoStatus.Status = STATUS_SUCCESS;

                        if (IrpContext->TransactionId != 0) {

                            //
                            //  We couldn't write the commit record, we clean up as
                            //  best we can.
                            //

                            NtfsCleanupFailedTransaction( IrpContext );
                        }
                    }
                }

                //
                //  Remove our reference to the current Fcb.
                //

                InterlockedDecrement( &NextFcb->CloseCount );
                DecrementNextFcbClose = FALSE;

                //
                //  Get the next Fcb and reference it so it won't go away.
                //

                NtfsAcquireFcbTable( IrpContext, Vcb );
                NextFcb = NtfsGetNextFcbTableEntry( Vcb, &RestartKey );
                NtfsReleaseFcbTable( IrpContext, Vcb );

                if (NextFcb != NULL) {

                    InterlockedIncrement( &NextFcb->CloseCount );
                    DecrementNextFcbClose = TRUE;
                }

                //
                //  Flushing the volume can cause new file objects to be allocated.
                //  If we are in the second pass and the Fcb is for a user file
                //  or directory then try to perform a teardown on this.
                //

                if ((Pass == 1) &&
                    !FlagOn(Fcb->FcbState, FCB_STATE_SYSTEM_FILE)) {

                    ASSERT( IrpContext->TransactionId == 0 );

                    //
                    //  We can actually get failures in this routine if we need to log standard info.
                    //

                    try {

                        NtfsTeardownStructures( IrpContext,
                                                Fcb,
                                                NULL,
                                                FALSE,
                                                0,
                                                &RemovedFcb );

                        //
                        //  TeardownStructures can create a transaction.  Commit
                        //  it if present.
                        //

                        if (IrpContext->TransactionId != 0) {

                            NtfsCheckpointCurrentTransaction( IrpContext );
                        }

                    } except( NtfsFlushVolumeExceptionFilter( IrpContext,
                                                              GetExceptionInformation(),
                                                              GetExceptionCode() )) {

                          NtfsMinimumExceptionProcessing( IrpContext );

                          if (IrpContext->TransactionId != 0) {

                              //
                              //  We couldn't write the commit record, we clean up as
                              //  best we can.
                              //

                              NtfsCleanupFailedTransaction( IrpContext );
                          }
                    }
                }

                //
                //  If the Fcb is still around then free any of the the other
                //  resources we have acquired.
                //

                if (!RemovedFcb) {

                    //
                    //  Free the snapshots for the current Fcb.  This will keep us
                    //  from having a snapshot for all open attributes in the
                    //  system.
                    //

                    NtfsFreeSnapshotsForFcb( IrpContext, Fcb );

                    if (PagingIoAcquired) {
                        ASSERT( IrpContext->TransactionId == 0 );
                        NtfsReleasePagingIo( IrpContext, Fcb );
                    }

                    if (AcquiredFcb) {
                        NtfsReleaseFcb( IrpContext, Fcb );
                    }
                }

                //
                //  If our caller wants to insure that all files are released
                //  between flushes then walk through the exclusive Fcb list
                //  and free everything.
                //

                if (ReleaseAllFiles) {

                    while (!IsListEmpty( &IrpContext->ExclusiveFcbList )) {

                        NtfsReleaseFcb( IrpContext,
                                        (PFCB)CONTAINING_RECORD( IrpContext->ExclusiveFcbList.Flink,
                                                                 FCB,
                                                                 ExclusiveFcbLinks ));
                    }

                    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_USN_JRNL |
                                                  IRP_CONTEXT_FLAG_RELEASE_MFT );
                }

                PagingIoAcquired = FALSE;
                AcquiredFcb = FALSE;

                //
                //  Always set this back to FALSE to indicate that we can trust the
                //  'Acquired' flags above.
                //

                RemovedFcb = FALSE;

                //
                //  Now move to the next Fcb.
                //

                Fcb = NextFcb;
            }

        } while (++Pass < 2);

        //
        //  The root directory is the only fcb with a mixture of user
        //  streams that should be torn down now and system streams that
        //  can't be torn down now.
        //  When we tried to teardown the whole Fcb, we might have run
        //  into the index root attribute and stopped our teardown, in
        //  which case we may leave a close count on the Vcb which will
        //  keep autochk from being able to lock the volume.  We need to
        //  make sure the root directory indeed exists, and this isn't
        //  the call to flush the volume during mount when we haven't yet
        //  opened the root directory.
        //

        if (Vcb->RootIndexScb != NULL) {

            Fcb = Vcb->RootIndexScb->Fcb;

            //
            //  Get the first Scb for the root directory Fcb.
            //

            Scb = NtfsGetNextChildScb( Fcb, NULL );

            while (Scb != NULL) {

                NextScb = NtfsGetNextChildScb( Fcb, Scb );

                if (NextScb != NULL) {

                    InterlockedIncrement( &NextScb->CleanupCount );
                    DecrementNextScbCleanup = TRUE;
                }

                //
                //  We can actually get failures in this routine if we need to log standard info.
                //

                try {

                    if (NtfsIsTypeCodeUserData( Scb->AttributeTypeCode )) {

                        //
                        //  Notice that we don't bother passing RemovedFcb, since
                        //  the root directory Fcb isn't going to go away.
                        //

                        NtfsTeardownStructures( IrpContext,
                                                Scb,
                                                NULL,
                                                FALSE,
                                                0,
                                                NULL );
                    }

                    //
                    //  TeardownStructures can create a transaction.  Commit
                    //  it if present.
                    //

                    if (IrpContext->TransactionId != 0) {

                        NtfsCheckpointCurrentTransaction( IrpContext );
                    }

                } except( NtfsFlushVolumeExceptionFilter( IrpContext,
                                                          GetExceptionInformation(),
                                                          GetExceptionCode() )) {

                    NtfsMinimumExceptionProcessing( IrpContext );

                    if (IrpContext->TransactionId != 0) {

                        //
                        //  We couldn't write the commit record, we clean up as
                        //  best we can.
                        //

                        NtfsCleanupFailedTransaction( IrpContext );
                    }
                }

                //
                //  Decrement the cleanup count of the next Scb if we incremented it.
                //

                if (DecrementNextScbCleanup) {

                    InterlockedDecrement( &NextScb->CleanupCount );
                    DecrementNextScbCleanup = FALSE;
                }

                //
                //  Move to the next Scb.
                //

                Scb = NextScb;
            }
        }

        //
        //  Make sure that all of the delayed or async closes for this Vcb are gone.
        //

        if (PurgeFromCache) {

            NtfsFspClose( Vcb );
        }

        //
        //  If we are to mark the files for dismount then do the Volume Dasd file now.
        //

        if (MarkFilesForDismount) {

            NtfsAcquireExclusiveFcb( IrpContext, Vcb->VolumeDasdScb->Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );
            SetFlag( Vcb->VolumeDasdScb->ScbState, SCB_STATE_VOLUME_DISMOUNTED );
            NtfsReleaseFcb( IrpContext, Vcb->VolumeDasdScb->Fcb );
        }

        //
        //  Now we want to flush/purge the streams for volume bitmap and then the Usn
        //  journal and Scb.
        //

        {
            PFCB SystemFcbs[3];
            PSCB ThisScb;

            //
            //  Store the volume bitmap, usn journal and Mft into the array.
            //

            RtlZeroMemory( SystemFcbs, sizeof( SystemFcbs ));

            if (Vcb->BitmapScb != NULL) {

                SystemFcbs[0] = Vcb->BitmapScb->Fcb;
            }

            if (Vcb->UsnJournal != NULL) {

                SystemFcbs[1] = Vcb->UsnJournal->Fcb;
            }

            if (Vcb->MftScb != NULL) {

                SystemFcbs[2] = Vcb->MftScb->Fcb;
            }

            Pass = 0;

            do {

                Fcb = SystemFcbs[Pass];

                if (Fcb != NULL) {

                    //
                    //  Purge the Mft cache if we are at the Mft.
                    //

                    if (Pass == 2) {

                        //
                        //  If we are operating on the MFT, make sure we don't have any
                        //  cached maps lying around...
                        //

                        NtfsPurgeFileRecordCache( IrpContext );

                        //
                        //  If we are purging the MFT then acquire all files to
                        //  avoid a purge deadlock.  If someone create an MFT mapping
                        //  between the flush and purge then the purge can spin
                        //  indefinitely in CC.
                        //

                        if (PurgeFromCache && !ReleaseFiles) {

                            NtfsAcquireAllFiles( IrpContext, Vcb, TRUE, FALSE, FALSE );
                            ReleaseFiles = TRUE;

                            //
                            //  NtfsAcquireAllFiles acquired the Vcb one more time.
                            //

                            ReleaseVcbCount += 1;
                        }

                    //
                    //  For the other Fcb's we still need to synchronize the flush and
                    //  purge so acquire and drop the Fcb.
                    //

                    } else {

                        NextFcb = Fcb;
                        InterlockedIncrement( &NextFcb->CloseCount );
                        DecrementNextFcbClose = TRUE;

                        NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                        AcquiredFcb = TRUE;
                    }

                    //
                    //  Go through each Scb for each of these Fcb's.
                    //

                    ThisScb = NtfsGetNextChildScb( Fcb, NULL );

                    while (ThisScb != NULL) {

                        Scb = NtfsGetNextChildScb( Fcb, ThisScb );

                        //
                        //  Initialize the state of the Io to SUCCESS.
                        //

                        IoStatus.Status = STATUS_SUCCESS;

                        //
                        //  Reference the next Scb to keep it from going away if
                        //  we purge the current one.
                        //

                        if (Scb != NULL) {

                            InterlockedIncrement( &Scb->CleanupCount );
                            DecrementScbCleanup = TRUE;
                        }

                        if (FlushCache) {

                            //
                            //  Flush the stream.  No need to update file sizes because these
                            //  are all logged streams.
                            //

                            CcFlushCache( &ThisScb->NonpagedScb->SegmentObject, NULL, 0, &IoStatus );

                            if (!NT_SUCCESS( IoStatus.Status )) {

                                Status = IoStatus.Status;
                            }

                            //
                            //  Use a try-except to commit the current transaction.
                            //

                            try {

                                NtfsCleanupTransaction( IrpContext, IoStatus.Status, TRUE );

                                NtfsCheckpointCurrentTransaction( IrpContext );

                            //
                            //  We will handle all errors except LOG_FILE_FULL and fatal
                            //  bugcheck errors here.  In the corruption case we will
                            //  want to mark the volume dirty and continue.
                            //

                            } except( NtfsFlushVolumeExceptionFilter( IrpContext,
                                                                      GetExceptionInformation(),
                                                                      (IoStatus.Status = GetExceptionCode()) )) {

                                //
                                //  To make sure that we can access all of our streams correctly,
                                //  we first restore all of the higher sizes before aborting the
                                //  transaction.  Then we restore all of the lower sizes after
                                //  the abort, so that all Scbs are finally restored.
                                //

                                NtfsRestoreScbSnapshots( IrpContext, TRUE );
                                NtfsAbortTransaction( IrpContext, IrpContext->Vcb, NULL );
                                NtfsRestoreScbSnapshots( IrpContext, FALSE );

                                //
                                //  Clear the top-level exception status so we won't raise
                                //  later.
                                //

                                NtfsMinimumExceptionProcessing( IrpContext );
                                IrpContext->ExceptionStatus = STATUS_SUCCESS;

                                //
                                //  Remember the first error.
                                //

                                if (Status == STATUS_SUCCESS) {

                                    Status = IoStatus.Status;
                                }

                                //
                                //  If the current status is either DISK_CORRUPT or FILE_CORRUPT then
                                //  mark the volume dirty.  We clear the IoStatus to allow
                                //  a corrupt file to be purged.  Otherwise it will never
                                //  leave memory.
                                //

                                if ((IoStatus.Status == STATUS_DISK_CORRUPT_ERROR) ||
                                    (IoStatus.Status == STATUS_FILE_CORRUPT_ERROR)) {

                                    NtfsMarkVolumeDirty( IrpContext, Vcb, TRUE );
                                    IoStatus.Status = STATUS_SUCCESS;
                                }
                            }
                        }

                        //
                        //  Purge this stream if there have been no errors.
                        //

                        if (PurgeFromCache
                            && IoStatus.Status == STATUS_SUCCESS) {

                            if (!CcPurgeCacheSection( &ThisScb->NonpagedScb->SegmentObject,
                                                      NULL,
                                                      0,
                                                      FALSE ) &&
                                (Status == STATUS_SUCCESS)) {

                                Status = STATUS_UNABLE_TO_DELETE_SECTION;
                            }
                        }

                        //
                        //  Remove any reference we have to the next Scb and move
                        //  forward to the next Scb.
                        //

                        if (DecrementScbCleanup) {

                            InterlockedDecrement( &Scb->CleanupCount );
                            DecrementScbCleanup = FALSE;
                        }

                        ThisScb = Scb;
                    }

                    //
                    //  Purge the Mft cache if we are at the Mft.  Do this before and
                    //  after dealing with the Mft.
                    //

                    if (Pass == 2) {

                        //
                        //  If we are operating on the MFT, make sure we don't have any
                        //  cached maps lying around...
                        //

                        NtfsPurgeFileRecordCache( IrpContext );

                        //
                        //  If we are purging the MFT then acquire all files to
                        //  avoid a purge deadlock.  If someone create an MFT mapping
                        //  between the flush and purge then the purge can spin
                        //  indefinitely in CC.
                        //

                        if (PurgeFromCache && !ReleaseFiles) {

                            NtfsAcquireAllFiles( IrpContext, Vcb, TRUE, FALSE, FALSE );
                            ReleaseFiles = TRUE;

                            //
                            //  NtfsAcquireAllFiles acquired the Vcb one more time.
                            //

                            ReleaseVcbCount += 1;
                        }

                    //
                    //  Release the volume bitmap and Usn journal.
                    //

                    } else {

                        InterlockedDecrement( &NextFcb->CloseCount );
                        DecrementNextFcbClose = FALSE;

                        NtfsReleaseFcb( IrpContext, Fcb );
                        AcquiredFcb = FALSE;
                    }
                }

                Pass += 1;

            } while (Pass != 3);

            //
            //  Also flag as dismounted the usnjournal and volume bitmap.
            //

            if (MarkFilesForDismount) {

                if (Vcb->BitmapScb != NULL) {

                    NtfsAcquireExclusiveFcb( IrpContext, Vcb->BitmapScb->Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                    SetFlag( Vcb->BitmapScb->ScbState, SCB_STATE_VOLUME_DISMOUNTED );
                    NtfsReleaseFcb( IrpContext, Vcb->BitmapScb->Fcb );
                }

                if (Vcb->UsnJournal != NULL) {

                    NtfsAcquireExclusiveFcb( IrpContext, Vcb->UsnJournal->Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                    SetFlag( Vcb->UsnJournal->ScbState, SCB_STATE_VOLUME_DISMOUNTED );
                    NtfsReleaseFcb( IrpContext, Vcb->UsnJournal->Fcb );
                }
            }
        }

    } finally {

        //
        //  If this is a purge then clear the purge flag.
        //

        if (PurgeFromCache) {

            ClearFlag( Vcb->VcbState, VCB_STATE_VOL_PURGE_IN_PROGRESS );
        }

        //
        //  Restore any counts we may have incremented to reference
        //  in-memory structures.
        //

        if (DecrementScbCleanup) {

            InterlockedDecrement( &Scb->CleanupCount );
        }

        if (DecrementNextFcbClose) {

            InterlockedDecrement( &NextFcb->CloseCount );
        }

        if (DecrementNextScbCleanup) {

            InterlockedDecrement( &NextScb->CleanupCount );
        }

        //
        //  We would've released our resources if we had
        //  successfully removed the fcb.
        //

        if (!RemovedFcb) {

            if (PagingIoAcquired) {
                NtfsReleasePagingIo( IrpContext, Fcb );
            }

            if (AcquiredFcb) {
                NtfsReleaseFcb( IrpContext, Fcb );
            }
        }

        if (ReleaseFiles) {

            //
            //  NtfsReleaseAllFiles is going to release the Vcb.  We'd
            //  better have it acquired at least once.
            //

            ASSERT( ReleaseVcbCount >= 1 );

            NtfsReleaseAllFiles( IrpContext, Vcb, FALSE );
            ReleaseVcbCount -= 1;
        }

        //
        //  Release the Vcb now.  We'd better have the Vcb acquired at least once.
        //

        ASSERTMSG( "Ignore this assert, 96773 is truly fixed",
                   (ReleaseVcbCount >= 1) );

        if (ReleaseVcbCount >= 1) {

            NtfsReleaseVcb( IrpContext, Vcb );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsFlushVolume -> %08lx\n", Status) );

    return Status;
}


NTSTATUS
NtfsFlushLsnStreams (
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine non-recursively flushes all of the Lsn streams in the open
    attribute table.  It assumes that the files have all been acquired
    exclusive prior to this call.  It also assumes our caller will provide the
    synchronization for the open attribute table.

Arguments:

    Vcb - Supplies the volume to flush

Return Value:

    STATUS_SUCCESS or else the most recent error status

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatus;

    POPEN_ATTRIBUTE_ENTRY AttributeEntry;
    PSCB Scb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFlushLsnStreams, Vcb = %08lx\n", Vcb) );

    //
    //  Start by flushing the log file to assure Write-Ahead-Logging.
    //

    LfsFlushToLsn( Vcb->LogHandle, LiMax );

    //
    //  Loop through to flush all of the streams in the open attribute table.
    //  We skip the Mft and mirror so they get flushed last.
    //

    AttributeEntry = NtfsGetFirstRestartTable( &Vcb->OpenAttributeTable );

    while (AttributeEntry != NULL) {

        Scb = AttributeEntry->OatData->Overlay.Scb;

        //
        //  Skip the Mft, its mirror and any deleted streams.  If the header
        //  is uninitialized for this stream then it means that the
        //  attribute doesn't exist (INDEX_ALLOCATION where the create failed)
        //  or the attribute is now resident.  Streams with paging resources
        //  (except for the volume bitmap) are skipped to prevent a possible
        //  deadlock (normally only seen in the hot fix path -- that's the
        //  only time an ordinary user stream ends up in the open attribute
        //  table) when this routine acquires the main resource without
        //  holding the paging resource.  The easiest way to avoid this is
        //  to skip such files, since it's user data, not logged metadata,
        //  that's going to be flushed anyway, and flushing user data
        //  doesn't help a checkpoint at all.
        //

        if (Scb != NULL
            && Scb != Vcb->MftScb
            && Scb != Vcb->Mft2Scb
            && Scb != Vcb->BadClusterFileScb
            && !FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )
            && FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )
            && ((Scb == Vcb->BitmapScb) || (Scb->Header.PagingIoResource == NULL))) {

            IoStatus.Status = STATUS_SUCCESS;

            //
            //  Now flush the stream.  We don't worry about file sizes because
            //  any logged stream should have the file size already in the log.
            //

            CcFlushCache( &Scb->NonpagedScb->SegmentObject, NULL, 0, &IoStatus );

            if (!NT_SUCCESS( IoStatus.Status )) {

                Status = IoStatus.Status;
            }

        }

        AttributeEntry = NtfsGetNextRestartTable( &Vcb->OpenAttributeTable,
                                                  AttributeEntry );
    }

    //
    //  Now we do the Mft.  Flushing the Mft will automatically update the mirror.
    //

    if (Vcb->MftScb != NULL) {

        IoStatus.Status = STATUS_SUCCESS;

        CcFlushCache( &Vcb->MftScb->NonpagedScb->SegmentObject, NULL, 0, &IoStatus );

        if (!NT_SUCCESS( IoStatus.Status )) {

            Status = IoStatus.Status;
        }
    }

    DebugTrace( -1, Dbg, ("NtfsFlushLsnStreams -> %08lx\n", Status) );

    return Status;
}


VOID
NtfsFlushAndPurgeFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine will flush and purge all of the open streams for an
    Fcb.  It is indended to prepare this Fcb such that a teardown will
    remove this Fcb for the tree.  The caller has guaranteed that the
    Fcb can't go away.

Arguments:

    Fcb - Supplies the Fcb to flush

Return Value:

    None.  The caller calls teardown structures and checks the result.

--*/

{
    IO_STATUS_BLOCK IoStatus;
    BOOLEAN DecrementNextScbCleanup = FALSE;

    PSCB Scb;
    PSCB NextScb;

    PAGED_CODE();

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Get the first Scb for the Fcb.
        //

        Scb = NtfsGetNextChildScb( Fcb, NULL );

        while (Scb != NULL) {

            BOOLEAN DataSectionExists;
            BOOLEAN ImageSectionExists;

            NextScb = NtfsGetNextChildScb( Fcb, Scb );

            //
            //  Save the attribute list for last so we don't purge it
            //  and then bring it back for another attribute.
            //

            if ((Scb->AttributeTypeCode == $ATTRIBUTE_LIST) &&
                (NextScb != NULL)) {

                RemoveEntryList( &Scb->FcbLinks );
                InsertTailList( &Fcb->ScbQueue, &Scb->FcbLinks );

                Scb = NextScb;
                continue;
            }

            if (!FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )) {

                FlushScb( IrpContext, Scb, &IoStatus );
            }

            //
            //  The call to purge below may generate a close call.
            //  We increment the cleanup count of the next Scb to prevent
            //  it from going away in a TearDownStructures as part of that
            //  close.
            //

            DataSectionExists = (BOOLEAN)(Scb->NonpagedScb->SegmentObject.DataSectionObject != NULL);
            ImageSectionExists = (BOOLEAN)(Scb->NonpagedScb->SegmentObject.ImageSectionObject != NULL);

            if (NextScb != NULL) {

                InterlockedIncrement( &NextScb->CleanupCount );
                DecrementNextScbCleanup = TRUE;
            }

            if (ImageSectionExists) {

                (VOID)MmFlushImageSection( &Scb->NonpagedScb->SegmentObject, MmFlushForWrite );
            }

            if (DataSectionExists) {

                CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject,
                                     NULL,
                                     0,
                                     FALSE );
            }

            //
            //  Decrement the cleanup count of the next Scb if we incremented
            //  it.
            //

            if (DecrementNextScbCleanup) {

                InterlockedDecrement( &NextScb->CleanupCount );
                DecrementNextScbCleanup = FALSE;
            }

            //
            //  Move to the next Scb.
            //

            Scb = NextScb;
        }

    } finally {

        //
        //  Restore any counts we may have incremented to reference
        //  in-memory structures.
        //

        if (DecrementNextScbCleanup) {

            InterlockedDecrement( &NextScb->CleanupCount );
        }
    }

    return;
}


VOID
NtfsFlushAndPurgeScb (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PSCB ParentScb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to flush and purge a stream.  It is used
    when there are now only non-cached handles on a file and there is
    a data section.  Flushing and purging the data section will mean that
    the user non-cached io won't have to block for the cache coherency calls.

    We want to remove all of the Fcb's from the exclusive list so that the
    lower level flush will be its own transaction.  We don't want to drop
    any of the resources however so we acquire the Scb's above explicitly
    and then empty the exclusive list.  In all cases we will reacquire the
    Scb's before raising out of this routine.

    Because this routines causes the write out of all data to disk its critical
    that it also updates the filesizes on disk. If NtfsWriteFileSizes raises logfile full
    the caller (create, cleanup etc.) must recall this routine or update the filesizes
    itself. To help with doing this we set the irpcontext state that we attemted a
    flushandpurge. Also note because we purged the section on a retry it may no longer
    be there so a test on (SectionObjectPointer->DataSection != NULL) will miss retrying

Arguments:

    Scb - Scb for the stream to flush and purge.  The reference count on this
        stream will prevent it from going away.

    ParentScb - If specified then this is the parent for the stream being flushed.

Return Value:

    None.

--*/

{
    IO_STATUS_BLOCK Iosb;
    BOOLEAN PurgeResult;

    PAGED_CODE();

    //
    //  Only actually flush and purge if there is a data section
    //

    if (Scb->NonpagedScb->SegmentObject.DataSectionObject) {

        //
        //  Commit the current transaction.
        //

        NtfsCheckpointCurrentTransaction( IrpContext );

        //
        //  Acquire the Scb explicitly. We don't bother to do the same for the
        //  parent SCB here; we'll just acquire it on our way out.
        //

        NtfsAcquireResourceExclusive( IrpContext, Scb, TRUE );

        //
        //  Walk through and release all of the Fcb's in the Fcb list.
        //

        while (!IsListEmpty( &IrpContext->ExclusiveFcbList )) {

            NtfsReleaseFcb( IrpContext,
                            (PFCB)CONTAINING_RECORD( IrpContext->ExclusiveFcbList.Flink,
                                                     FCB,
                                                     ExclusiveFcbLinks ));
        }

        ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_USN_JRNL |
                                      IRP_CONTEXT_FLAG_RELEASE_MFT );

        //
        //  Use a try-finally to reacquire the Scbs.
        //

        try {

            //
            //  Perform the flush, raise on error.
            //

#ifdef  COMPRESS_ON_WIRE
            if (Scb->Header.FileObjectC != NULL) {

                PCOMPRESSION_SYNC CompressionSync = NULL;

                //
                //  Use a try-finally to clean up the compression sync.
                //

                try {

                    Iosb.Status = NtfsSynchronizeUncompressedIo( Scb,
                                                                 NULL,
                                                                 0,
                                                                 TRUE,
                                                                 &CompressionSync );

                } finally {

                    NtfsReleaseCompressionSync( CompressionSync );
                }

                NtfsNormalizeAndCleanupTransaction( IrpContext, &Iosb.Status, TRUE, STATUS_UNEXPECTED_IO_ERROR );
            }
#endif

            //
            //  After doing the work of the flush we must update the ondisk sizes either
            //  here or in close if we fail logfile full
            //

            NtfsPurgeFileRecordCache( IrpContext );
            SetFlag( Scb->ScbState, SCB_STATE_WRITE_FILESIZE_ON_CLOSE );
            CcFlushCache( &Scb->NonpagedScb->SegmentObject, NULL, 0, &Iosb );

#ifdef SYSCACHE_DEBUG
            if (ScbIsBeingLogged( Scb )) {

                ASSERT( Scb->Fcb->PagingIoResource != NULL );
                ASSERT( NtfsIsExclusiveScbPagingIo( Scb ) );

                FsRtlLogSyscacheEvent( Scb, SCE_CC_FLUSH, 0, 0, 0, Iosb.Status );
            }
#endif
            NtfsNormalizeAndCleanupTransaction( IrpContext, &Iosb.Status, TRUE, STATUS_UNEXPECTED_IO_ERROR );

            //
            //  If no error, then purge the section
            //

            PurgeResult = CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject, NULL, 0, FALSE );

#ifdef SYSCACHE_DEBUG
            if (ScbIsBeingLogged( Scb )) {

                ASSERT( (Scb->Fcb->PagingIoResource != NULL) && NtfsIsExclusiveScbPagingIo( Scb ) );

                FsRtlLogSyscacheEvent( Scb, SCE_CC_FLUSH_AND_PURGE, 0, 0, (DWORD_PTR)(Scb->NonpagedScb->SegmentObject.SharedCacheMap), PurgeResult );
            }
#endif

        } finally {

            //
            //  Reacquire the Scb and it's parent..
            //

            NtfsAcquireExclusiveScb( IrpContext, Scb );
            NtfsReleaseResource( IrpContext, Scb );

            if (ARGUMENT_PRESENT( ParentScb )) {

                NtfsAcquireExclusiveScb( IrpContext, ParentScb );
            }
        }
    } //  endif DataSection existed

    //
    //  Write the file sizes to the attribute.  Commit the transaction since the
    //  file sizes must get to disk.
    //

    ASSERT( FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED ) );

    NtfsWriteFileSizes( IrpContext, Scb, &Scb->Header.ValidDataLength.QuadPart, TRUE, TRUE, FALSE );
    NtfsCheckpointCurrentTransaction( IrpContext );
    ClearFlag( Scb->ScbState, SCB_STATE_WRITE_FILESIZE_ON_CLOSE );

    return;
}


//
//  Local support routine
//

NTSTATUS
NtfsFlushCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

{
    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Contxt );

    //
    //  Add the hack-o-ramma to fix formats.
    //

    if ( Irp->PendingReturned ) {

        IoMarkIrpPending( Irp );
    }

    //
    //  If the Irp got STATUS_INVALID_DEVICE_REQUEST, normalize it
    //  to STATUS_SUCCESS.
    //

    if (Irp->IoStatus.Status == STATUS_INVALID_DEVICE_REQUEST) {

        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
NtfsFlushFcbFileRecords (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine is called to flush the file records for a given file.  It is
    intended to flush the critical file records for the system hives.

Arguments:

    Fcb - This is the Fcb to flush.

Return Value:

    NTSTATUS - The status returned from the flush operation.

--*/

{
    IO_STATUS_BLOCK IoStatus;
    BOOLEAN MoreToGo;

    LONGLONG LastFileOffset = MAXLONGLONG;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    PAGED_CODE();

    NtfsInitializeAttributeContext( &AttrContext );

    IoStatus.Status = STATUS_SUCCESS;

    //
    //  Use a try-finally to cleanup the context.
    //

    try {

        //
        //  Find the first.  It should be there.
        //

        MoreToGo = NtfsLookupAttribute( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        &AttrContext );

        if (!MoreToGo) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        while (MoreToGo) {

            if (AttrContext.FoundAttribute.MftFileOffset != LastFileOffset) {

                LastFileOffset = AttrContext.FoundAttribute.MftFileOffset;

                CcFlushCache( &Fcb->Vcb->MftScb->NonpagedScb->SegmentObject,
                              (PLARGE_INTEGER) &LastFileOffset,
                              Fcb->Vcb->BytesPerFileRecordSegment,
                              &IoStatus );

                if (!NT_SUCCESS( IoStatus.Status )) {

                    IoStatus.Status = FsRtlNormalizeNtstatus( IoStatus.Status,
                                                              STATUS_UNEXPECTED_IO_ERROR );
                    break;
                }
            }

            MoreToGo = NtfsLookupNextAttribute( IrpContext,
                                                Fcb,
                                                &AttrContext );
        }

    } finally {

        DebugUnwind( NtfsFlushFcbFileRecords );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
    }

    return IoStatus.Status;
}


NTSTATUS
NtfsFlushUserStream (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PLONGLONG FileOffset OPTIONAL,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine flushes a user stream as a top-level action.  To do so
    it checkpoints the current transaction first and frees all of the
    caller's snapshots.  After doing the flush, it snapshots the input
    Scb again, just in case the caller plans to do any more work on that
    stream.  If the caller needs to modify any other streams (presumably
    metadata), it must know to snapshot them itself after calling this
    routine.

Arguments:

    Scb - Stream to flush

    FileOffset - FileOffset at which the flush is to start, or NULL for
                 entire stream.

    Length - Number of bytes to flush.  Ignored if FileOffset not specified.

Return Value:

    Status of the flush

--*/

{
    IO_STATUS_BLOCK IoStatus;
    BOOLEAN ScbAcquired = FALSE;

    PAGED_CODE();

    //
    //  Checkpoint the current transaction and free all of its snapshots,
    //  in order to treat the flush as a top-level action with his own
    //  snapshots, etc.
    //

    NtfsCheckpointCurrentTransaction( IrpContext );
    NtfsFreeSnapshotsForFcb( IrpContext, NULL );

    //
    //  Set the wait flag in the IrpContext so we don't hit a case where the
    //  reacquire below fails because we can't wait.  If our caller was asynchronous
    //  and we get this far we will continue synchronously.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  We must free the Scb now before calling through MM to prevent
    //  collided page deadlocks.
    //

    //
    //  We are about to flush the stream.  The Scb may be acquired exclusive
    //  and, thus, is linked onto the IrpContext or onto one higher
    //  up in the IoCallDriver stack.  We are about to make a
    //  call back into Ntfs which may acquire the Scb exclusive, but
    //  NOT put it onto the nested IrpContext exclusive queue which prevents
    //  the nested completion from freeing the Scb.
    //
    //  This is only a problem for Scb's without a paging resource.
    //
    //  We acquire the Scb via ExAcquireResourceExclusiveLite, sidestepping
    //  Ntfs bookkeeping, and release it via NtfsReleaseScb.
    //

    ScbAcquired = NtfsIsExclusiveScb( Scb );

    if (ScbAcquired) {
        if (Scb->Header.PagingIoResource == NULL) {
            NtfsAcquireResourceExclusive( IrpContext, Scb, TRUE );
        }
        NtfsReleaseScb( IrpContext, Scb );
    }

#ifdef  COMPRESS_ON_WIRE
    if (Scb->Header.FileObjectC != NULL) {

        PCOMPRESSION_SYNC CompressionSync = NULL;

        //
        //  Use a try-finally to clean up the compression sync.
        //

        try {

            NtfsSynchronizeUncompressedIo( Scb,
                                           NULL,
                                           0,
                                           TRUE,
                                           &CompressionSync );

        } finally {

            NtfsReleaseCompressionSync( CompressionSync );
        }
    }
#endif

    //
    //  Clear the file record cache before doing the flush.  Otherwise FlushVolume may hold this
    //  file and be purging the Mft at the same time this thread has a Vacb in the Mft and is
    //  trying to reacquire the file in the recursive IO thread.
    //

    NtfsPurgeFileRecordCache( IrpContext );

    //
    //  Now do the flush he wanted as a top-level action
    //

    CcFlushCache( &Scb->NonpagedScb->SegmentObject, (PLARGE_INTEGER)FileOffset, Length, &IoStatus );

    //
    //  Now reacquire for the caller.
    //

    if (ScbAcquired) {
        NtfsAcquireExclusiveScb( IrpContext, Scb );
        if (Scb->Header.PagingIoResource == NULL) {
            NtfsReleaseResource( IrpContext, Scb );
        }
    }

    return IoStatus.Status;
}


//
//  Local support routine
//

LONG
NtfsFlushVolumeExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer,
    IN NTSTATUS ExceptionCode
    )

{
    //
    //  Swallow any errors except LOG_FILE_FULL, CANT_WAIT and anything else not expected.
    //

    if ((ExceptionCode == STATUS_LOG_FILE_FULL) ||
        (ExceptionCode == STATUS_CANT_WAIT) ||
        !FsRtlIsNtstatusExpected( ExceptionCode )) {

        return EXCEPTION_CONTINUE_SEARCH;

    } else {

        return EXCEPTION_EXECUTE_HANDLER;
    }

    UNREFERENCED_PARAMETER( IrpContext );
    UNREFERENCED_PARAMETER( ExceptionPointer );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\hashsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    HashSup.c

Abstract:

    This module implements the Ntfs hasing support routines

Author:

    Chris Davis     [CDavis]        2-May-1997
    Brian Andrew    [BrianAn]       29-Dec-1998

Revision History:

--*/

#include "NtfsProc.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NTFS_BUG_CHECK_HASHSUP)

//
//  The debug trace level for this module
//

#define Dbg                              (DEBUG_TRACE_HASHSUP)

/*
    Here are 10 primes slightly greater than 10^9 which may come in handy
    1000000007, 1000000009, 1000000021, 1000000033, 1000000087,
    1000000093, 1000000097, 1000000103, 1000000123, 1000000181
*/

//
//  Local definitions
//

//
//  Hash value is modula this value.
//

#define HASH_PRIME                          (1048583)

//
//  Bucket depth before starting to split.
//

#ifdef NTFS_HASH_DATA
#define HASH_MAX_BUCKET_DEPTH               (7)
ULONG NtfsInsertHashCount = 0;
BOOLEAN NtfsFillHistogram = FALSE;
VOID
NtfsFillHashHistogram (
    PNTFS_HASH_TABLE Table
    );
#else
#define HASH_MAX_BUCKET_DEPTH               (5)
#endif

//
//  VOID
//  NtfsHashBucketFromHash (
//      IN PNTFS_HASH_TABLE Table,
//      IN ULONG Hash,
//      OUT PULONG Index
//      );
//

#define NtfsHashBucketFromHash(T,H,PI) {            \
    *(PI) = (H) & ((T)->MaxBucket - 1);             \
    if (*(PI) < (T)->SplitPoint) {                  \
        *(PI) = (H) & ((2 * (T)->MaxBucket) - 1);   \
    }                                               \
}

//
//  VOID
//  NtfsGetHashSegmentAndIndex (
//      IN ULONG HashBucket,
//      IN PULONG HashSegment,
//      IN PULONG HashIndex
//      );
//

#define NtfsGetHashSegmentAndIndex(B,S,I) { \
    *(S) = (B) >> HASH_INDEX_SHIFT;         \
    *(I) = (B) & (HASH_MAX_INDEX_COUNT - 1);\
}


//
//  Local procedures
//

VOID
NtfsInitHashSegment (
    IN OUT PNTFS_HASH_TABLE Table,
    IN ULONG SegmentIndex
    );

PNTFS_HASH_ENTRY
NtfsLookupHashEntry (
    IN PNTFS_HASH_TABLE Table,
    IN ULONG FullNameLength,
    IN ULONG HashValue,
    IN PNTFS_HASH_ENTRY CurrentEntry OPTIONAL
    );

BOOLEAN
NtfsAreHashNamesEqual (
    IN PSCB StartingScb,
    IN PLCB HashLcb,
    IN PUNICODE_STRING RelativeName
    );

VOID
NtfsExpandHashTable (
    IN OUT PNTFS_HASH_TABLE Table
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsAreHashNamesEqual)
#pragma alloc_text(PAGE, NtfsExpandHashTable)
#pragma alloc_text(PAGE, NtfsFindPrefixHashEntry)
#pragma alloc_text(PAGE, NtfsInitHashSegment)
#pragma alloc_text(PAGE, NtfsInitializeHashTable)
#pragma alloc_text(PAGE, NtfsInsertHashEntry)
#pragma alloc_text(PAGE, NtfsLookupHashEntry)
#pragma alloc_text(PAGE, NtfsRemoveHashEntry)
#pragma alloc_text(PAGE, NtfsUninitializeHashTable)
#endif


VOID
NtfsInitializeHashTable (
    IN OUT PNTFS_HASH_TABLE Table
    )

/*++
Routine Description:

    This routine is called to initialize the hash table.  We set this up with a single
    hash segment. May raise due to InitHashSegment

Arguments:

    Table - Hash table to initialize.

Return Value:

    None

--*/

{
    PAGED_CODE();

    RtlZeroMemory( Table, sizeof( NTFS_HASH_TABLE ));
    NtfsInitHashSegment( Table, 0 );

    Table->MaxBucket = HASH_MAX_INDEX_COUNT;

    return;
}


VOID
NtfsUninitializeHashTable (
    IN OUT PNTFS_HASH_TABLE Table
    )

/*++
Routine Description:

    This routine will uninitialize the hash table.  Note that all of the buckets should be
    empty.

Arguments:

    Table - Hash table.

Return Value:

    None

--*/

{
    PNTFS_HASH_SEGMENT *ThisSegment;
    PNTFS_HASH_SEGMENT *LastSegment;

    PAGED_CODE();

    //
    //  Walk through the array of hash segments.
    //

    ThisSegment = &Table->HashSegments[0];
    LastSegment = &Table->HashSegments[HASH_MAX_SEGMENT_COUNT - 1];

    while (*ThisSegment != NULL) {

        NtfsFreePool( *ThisSegment );
        *ThisSegment = NULL;

        if (ThisSegment == LastSegment) { break; }

        ThisSegment += 1;
    }

    return;
}


PLCB
NtfsFindPrefixHashEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PNTFS_HASH_TABLE Table,
    IN PSCB ParentScb,
    OUT PULONG CreateFlags,
    IN OUT PFCB *CurrentFcb,
    OUT PULONG FileHashValue,
    OUT PULONG FileNameLength,
    OUT PULONG ParentHashValue,
    OUT PULONG ParentNameLength,
    IN OUT PUNICODE_STRING RemainingName
    )

/*++
Routine Description:

    This routine is called to look for a match in the hash table for the given
    starting Scb and remaining name.  We will first look for the full name, if
    we don't find a match on that we will check for a matching parent string.

Arguments:

    Table - Hash table to process.

    ParentScb - The name search begins from this directory.  The Scb is
        initially acquired and its Fcb is stored in *CurrentFcb.

    OwnParentScb - Boolean which indicates if this thread owns the parent Scb.

    CurrentFcb - Points to the last Fcb acquired.  If we need to perform a
        teardown it will begin from this point.

    FileHashValue - Address to store the hash value for the input string.  Applies to
        the full string and starting Scb even if a match wasn't found.

    FileNameLength - Location to store the length of the relative name which
        matches the hash value generated above.  If we didn't generate a hash
        then we will return a 0 for the length.

    ParentHashValue - Address to store the hash value for the parent of the input string.
        Applies to parent of the full string and starting Scb even if a match wasn't found
        for the full string.

    ParentNameLength - Location to store the length of the parent of the full name.
        It corresponds to the parent hash generated above.  Note that our caller
        will have to check the remaining name on return to know if the parent hash
        was computed.  If we didn't generate a hash for the parent above then
        we will return 0 for the length.

    RemainingName - Name relative to the StartingScb above, on return it will be
        the unmatched portion of the name.

Return Value:

    PLCB - Pointer to the Lcb found in the hash lookup or FALSE if no Lcb is found.
        If an Lcb is found then we will own the Fcb for it exclusively on return.

--*/

{
    PVCB Vcb = ParentScb->Vcb;
    PNTFS_HASH_ENTRY FoundEntry;
    PLCB FoundLcb = NULL;
    UNICODE_STRING TempName;
    WCHAR Separator = L'\\';
    ULONG RemainingNameLength;
    PWCHAR RemainingNameBuffer;
    PWCHAR NextChar;

    PAGED_CODE();

    ASSERT( RemainingName->Length != 0 );
    ASSERT( RemainingName->Buffer[0] != L'\\' );
    ASSERT( RemainingName->Buffer[0] != L':' );
    ASSERT( ParentScb->AttributeTypeCode == $INDEX_ALLOCATION );

    //
    //  Compute the hash for the file before acquiring the hash table.
    //

    *ParentHashValue = *FileHashValue = ParentScb->ScbType.Index.HashValue;

    //
    //  Check whether we need to generate the separator.
    //

    if (ParentScb != Vcb->RootIndexScb) {

        NtfsConvertNameToHash( &Separator, sizeof( WCHAR ), Vcb->UpcaseTable, FileHashValue );
    }

    //
    //  Generate the hash for the file name.
    //

    NtfsConvertNameToHash( RemainingName->Buffer,
                           RemainingName->Length,
                           Vcb->UpcaseTable,
                           FileHashValue );

    *FileHashValue = NtfsGenerateHashFromUlong( *FileHashValue );


    NtfsAcquireHashTable( Vcb );

    //
    //  Generate the hash value based on the starting Scb and the string.
    //  Return immediately if there is no parent name.
    //

    if (ParentScb->ScbType.Index.NormalizedName.Length == 0) {

        NtfsReleaseHashTable( Vcb );
        return NULL;
    }

    *ParentNameLength = *FileNameLength = ParentScb->ScbType.Index.NormalizedName.Length;
    *FileNameLength += RemainingName->Length;

#ifdef NTFS_HASH_DATA
    Table->HashLookupCount += 1;
#endif

    //
    //  Check whether to include a separator.
    //

    if (ParentScb != Vcb->RootIndexScb) {

        *FileNameLength += sizeof( WCHAR );
    }

    //
    //  Loop looking for a match on the hash value and then verify the name.
    //

    FoundEntry = NULL;

    while ((FoundEntry = NtfsLookupHashEntry( Table,
                                              *FileNameLength,
                                              *FileHashValue,
                                              FoundEntry )) != NULL) {

        //
        //  If we have a match then verify the name strings.
        //

        if (NtfsAreHashNamesEqual( ParentScb,
                                   FoundEntry->HashLcb,
                                   RemainingName )) {

            //
            //  The name string match.  Adjust the input remaining name to
            //  show there is no name left to process.
            //

            FoundLcb = FoundEntry->HashLcb;

            //
            //  Move to the end of the input string.
            //

            RemainingNameLength = 0;
            RemainingNameBuffer = Add2Ptr( RemainingName->Buffer,
                                           RemainingName->Length );

            //
            //  Show that we never generated a parent hash.  No need to
            //  remember the file hash in this case either.
            //

#ifdef NTFS_HASH_DATA
            Table->FileMatchCount += 1;
#endif
            *ParentNameLength = 0;
            *FileNameLength = 0;
            break;
        }
    }

    //
    //  If we don't have a match then let's look at a possible parent string.
    //

    if (FoundLcb == NULL) {

        //
        //  Search backwards for a '\'.  If it is a '\' then do the
        //  same search for a match on the string based on the parent.
        //

        TempName.Length = RemainingName->Length;
        NextChar = &RemainingName->Buffer[ (TempName.Length - sizeof( WCHAR )) / sizeof( WCHAR ) ];

        while (TRUE) {

            //
            //  Break out if no separator is found.
            //

            if (TempName.Length == 0) {

                *ParentNameLength = 0;
                break;
            }

            if (*NextChar == L'\\') {

                //
                //  We found the separator.  Back up one more character to step over
                //  the '\' character and then complete a hash for the parent.
                //

                TempName.Buffer = RemainingName->Buffer;
                TempName.Length -= sizeof( WCHAR );
                TempName.MaximumLength = TempName.Length;

                //
                //  Drop the mutex while we compute the hash.
                //

                NtfsReleaseHashTable( Vcb );

                if (ParentScb != Vcb->RootIndexScb) {

                    NtfsConvertNameToHash( &Separator, sizeof( WCHAR ), Vcb->UpcaseTable, ParentHashValue );
                    *ParentNameLength += sizeof( WCHAR );
                }

                NtfsConvertNameToHash( TempName.Buffer,
                                       TempName.Length,
                                       Vcb->UpcaseTable,
                                       ParentHashValue );

                *ParentHashValue = NtfsGenerateHashFromUlong( *ParentHashValue );
                *ParentNameLength += TempName.Length;

                NtfsAcquireHashTable( Vcb );

                FoundEntry = NULL;
                while ((FoundEntry = NtfsLookupHashEntry( Table,
                                                          *ParentNameLength,
                                                          *ParentHashValue,
                                                          FoundEntry )) != NULL) {

                    //
                    //  If we have a match then verify the name strings.
                    //

                    if (NtfsAreHashNamesEqual( ParentScb,
                                               FoundEntry->HashLcb,
                                               &TempName )) {

                        //
                        //  The name string match.  Adjust the remaining name to
                        //  swallow the parent string found.
                        //

                        FoundLcb = FoundEntry->HashLcb;

                        RemainingNameLength = RemainingName->Length - (TempName.Length + sizeof( WCHAR ));
                        RemainingNameBuffer = Add2Ptr( RemainingName->Buffer,
                                                       TempName.Length + sizeof( WCHAR ));

#ifdef NTFS_HASH_DATA
                        Table->ParentMatchCount += 1;
#endif
                        *ParentNameLength = 0;
                        break;
                    }

                }

                //
                //  No match found.  Break out in any case.
                //

                break;
            }

            TempName.Length -= sizeof( WCHAR );
            NextChar -= 1;
        }
    }

    //
    //  We now have the Lcb to return.  We need to carefully acquire the Fcb for this Lcb.
    //  We can't acquire it while waiting because of deadlock possibilities.
    //

    if (FoundLcb != NULL) {

        UCHAR LcbFlags;
        BOOLEAN CreateNewLcb = FALSE;
        ULONG RemainingNameOffset;

        //
        //  While we own the hash table it will be safe to copy the exact case of the
        //  names over to our input buffer.  We will work our way backwards through the
        //  remaining name passed to us.
        //

        RemainingNameOffset = RemainingNameLength + FoundLcb->ExactCaseLink.LinkName.Length;

        //
        //  If this was a match on the parent then step back over the '\'.
        //  We know there must be a separator.
        //

        if (RemainingNameLength != 0) {

            RemainingNameOffset += sizeof( WCHAR );
        }

        //
        //  Now back up the length of the name in the Lcb.  Save this location in
        //  case we have to look up the Lcb again.
        //

        TempName.Buffer = Add2Ptr( RemainingName->Buffer,
                                   RemainingName->Length - RemainingNameOffset );

        TempName.MaximumLength = TempName.Length = FoundLcb->ExactCaseLink.LinkName.Length;

        RtlCopyMemory( TempName.Buffer,
                       FoundLcb->ExactCaseLink.LinkName.Buffer,
                       FoundLcb->ExactCaseLink.LinkName.Length );

        //
        //  Now the balance of the name which is part of the Lcb->Scb parent name.
        //

        if (RemainingNameOffset != RemainingName->Length) {

            //
            //  There are prior components in our input string.  We want to back up
            //  over the preceding backslash and then copy over the relevant portion
            //  of the normalized name.
            //

            RemainingNameOffset = RemainingName->Length - (RemainingNameOffset + sizeof( WCHAR ));

            RtlCopyMemory( RemainingName->Buffer,
                           Add2Ptr( FoundLcb->Scb->ScbType.Index.NormalizedName.Buffer,
                                    FoundLcb->Scb->ScbType.Index.NormalizedName.Length - RemainingNameOffset ),
                           RemainingNameOffset );
        }

        if (!NtfsAcquireFcbWithPaging( IrpContext, FoundLcb->Fcb, ACQUIRE_DONT_WAIT )) {

            PFCB ThisFcb = FoundLcb->Fcb;
            PFCB ParentFcb = FoundLcb->Scb->Fcb;
            PSCB ThisScb;

            //
            //  Remember the current Lcb flags.
            //

            LcbFlags = FoundLcb->FileNameAttr->Flags;

            //
            //  Acquire the Fcb table and reference the Fcb.  Then release the hash table, Fcb table
            //  and ParentScb.  We should now be able to acquire the Fcb.  Reacquire the Fcb table
            //  to clean up the Fcb reference count.  Finally verify that the Lcb is still in the
            //  hash table (requires another lookup).
            //

            NtfsAcquireFcbTable( IrpContext, Vcb );
            ThisFcb->ReferenceCount += 1;
            ParentFcb->ReferenceCount += 1;
            NtfsReleaseFcbTable( IrpContext, Vcb );

            NtfsReleaseScb( IrpContext, ParentScb );
            ClearFlag( *CreateFlags, CREATE_FLAG_SHARED_PARENT_FCB );
            *CurrentFcb = NULL;

            NtfsReleaseHashTable( Vcb );

            NtfsAcquireFcbWithPaging( IrpContext, ThisFcb, 0 );
            *CurrentFcb = ThisFcb;
            NtfsAcquireSharedFcb( IrpContext, ParentFcb, NULL, 0 );

            NtfsAcquireFcbTable( IrpContext, Vcb );
            ThisFcb->ReferenceCount -= 1;
            ParentFcb->ReferenceCount -= 1;
            NtfsReleaseFcbTable( IrpContext, Vcb );

            //
            //  Now look for an existing Scb and Lcb.
            //

            ThisScb = NtfsCreateScb( IrpContext,
                                     ParentFcb,
                                     $INDEX_ALLOCATION,
                                     &NtfsFileNameIndex,
                                     TRUE,
                                     NULL );

            if (ThisScb == NULL) {

#ifdef NTFS_HASH_DATA
                Table->CreateScbFails += 1;
#endif
                NtfsReleaseFcb( IrpContext, ParentFcb );
                NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
            }

            FoundLcb = NtfsCreateLcb( IrpContext,
                                      ThisScb,
                                      ThisFcb,
                                      TempName,
                                      LcbFlags,
                                      &CreateNewLcb );

            NtfsReleaseFcb( IrpContext, ParentFcb );

            //
            //  If this wasn't an existing Lcb then reacquire the starting Scb.
            //  This is the rare case so raise CANT_WAIT and retry.
            //

            if (FoundLcb == NULL) {

#ifdef NTFS_HASH_DATA
                Table->CreateLcbFails += 1;
#endif
                NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
            }

        //
        //  Release the starting Scb and remember our current Fcb.
        //

        } else {

            NtfsReleaseHashTable( Vcb );

            NtfsReleaseScb( IrpContext, ParentScb );
            ClearFlag( *CreateFlags, CREATE_FLAG_SHARED_PARENT_FCB );
            *CurrentFcb = FoundLcb->Fcb;
        }

        //
        //  If we still have the Lcb then update the remaining name string.
        //

        if (FoundLcb != NULL) {

            RemainingName->Length = (USHORT) RemainingNameLength;
            RemainingName->Buffer = RemainingNameBuffer;
        }

    } else {

        NtfsReleaseHashTable( Vcb );
    }

    return FoundLcb;
}


VOID
NtfsInsertHashEntry (
    IN PNTFS_HASH_TABLE Table,
    IN PLCB HashLcb,
    IN ULONG NameLength,
    IN ULONG HashValue
    )

/*++
Routine Description:

    This routine will insert a entry into the hash table. May raise due to
    memory allocation.

Arguments:

    Table - Hash table.

    HashLcb - Final target of the hash operation.

    NameLength - Full path used to reach the hash value.

    HashValue - Hash value to insert.

Return Value:

    None

--*/

{
    PNTFS_HASH_ENTRY NewHashEntry;

    ULONG Segment;
    ULONG Index;

    ULONG Bucket;

    PAGED_CODE();

    //
    //  Allocate and initialize the hash entry.  Nothing to do if unsuccessful.
    //

    NewHashEntry = NtfsAllocatePoolNoRaise( PagedPool, sizeof( NTFS_HASH_ENTRY ));

    if (NewHashEntry == NULL) {

        return;
    }

    NewHashEntry->HashValue = HashValue;
    NewHashEntry->FullNameLength = NameLength;
    NewHashEntry->HashLcb = HashLcb;

    //
    //  Find the bucket to insert into and then do the insertion.
    //

    NtfsAcquireHashTable( HashLcb->Fcb->Vcb );

    //
    //  Continue the process of growing the table if needed.
    //

    if (Table->TableState == TABLE_STATE_EXPANDING) {

        NtfsExpandHashTable( Table );
    }

    NtfsHashBucketFromHash( Table, HashValue, &Bucket );
    NtfsGetHashSegmentAndIndex( Bucket, &Segment, &Index );

    NewHashEntry->NextEntry = (*Table->HashSegments[ Segment ])[ Index ];
    (*Table->HashSegments[ Segment ])[ Index ] = NewHashEntry;

#ifdef NTFS_HASH_DATA
    NtfsInsertHashCount += 1;

    if (!FlagOn( NtfsInsertHashCount, 0xff ) && NtfsFillHistogram) {

        NtfsFillHashHistogram( Table );
    }
#endif

    NtfsReleaseHashTable( HashLcb->Fcb->Vcb );

    //
    //  Remember that we've inserted a hash.
    //

    HashLcb->HashValue = HashValue;
    SetFlag( HashLcb->LcbState, LCB_STATE_VALID_HASH_VALUE );

    return;
}


VOID
NtfsRemoveHashEntry (
    IN PNTFS_HASH_TABLE Table,
    IN PLCB HashLcb
    )

/*++
Routine Description:

    This routine will remove all entries with a given hash value for the given Lcb.

Arguments:

    Table - Hash table.

    HashLcb - Final target of the hash operation.

Return Value:

    None

--*/

{
    PNTFS_HASH_ENTRY *NextHashEntry;
    PNTFS_HASH_ENTRY CurrentEntry;

    ULONG Segment;
    ULONG Index;

    ULONG Bucket;

    ULONG BucketDepth = 0;

    PAGED_CODE();

    NtfsAcquireHashTable( HashLcb->Fcb->Vcb );

    //
    //  Find the bucket to remove from and then search for this hash value.
    //

    NtfsHashBucketFromHash( Table, HashLcb->HashValue, &Bucket );
    NtfsGetHashSegmentAndIndex( Bucket, &Segment, &Index );

    //
    //  Get the address of the first entry.
    //

    NextHashEntry = (PNTFS_HASH_ENTRY *) &(*Table->HashSegments[ Segment ])[ Index ];

    while (*NextHashEntry != NULL) {

        //
        //  Look for a match entry.
        //

        if (((*NextHashEntry)->HashValue == HashLcb->HashValue) &&
            ((*NextHashEntry)->HashLcb == HashLcb)) {

            CurrentEntry = *NextHashEntry;

            *NextHashEntry = CurrentEntry->NextEntry;

            NtfsFreePool( CurrentEntry );

        //
        //  Move to the next entry but remember the depth of the bucket.
        //

        } else {

            NextHashEntry = &(*NextHashEntry)->NextEntry;
            BucketDepth += 1;
        }
    }

    //
    //  Check if the bucket depth is greater than our max.
    //

    if ((BucketDepth > HASH_MAX_BUCKET_DEPTH) &&
        (Table->TableState == TABLE_STATE_STABLE) &&
        (Table->MaxBucket < HASH_MAX_BUCKET_COUNT)) {

        ASSERT( Table->SplitPoint == 0 );
        Table->TableState = TABLE_STATE_EXPANDING;
    }

    NtfsReleaseHashTable( HashLcb->Fcb->Vcb );

    HashLcb->HashValue = 0;
    ClearFlag( HashLcb->LcbState, LCB_STATE_VALID_HASH_VALUE );

    return;
}


//
//  Local support routine
//

VOID
NtfsInitHashSegment (
    IN OUT PNTFS_HASH_TABLE Table,
    IN ULONG SegmentIndex
    )

/*++

Routine Description:

    This routine allocates and initializes a new segment in the segment array.
    It may raise out of resources.

Arguments:

    Table - Table with an entry to initialize.

    SegmentIndex - Index to be initialized.

Return Value:

    None

--*/

{
    PAGED_CODE();

    Table->HashSegments[ SegmentIndex ] = NtfsAllocatePool( PagedPool, sizeof( NTFS_HASH_SEGMENT ));
    RtlZeroMemory( Table->HashSegments[ SegmentIndex ], sizeof( NTFS_HASH_SEGMENT ));

    return;
}


//
//  Local support routine
//

PNTFS_HASH_ENTRY
NtfsLookupHashEntry (
    IN PNTFS_HASH_TABLE Table,
    IN ULONG FullNameLength,
    IN ULONG HashValue,
    IN PNTFS_HASH_ENTRY CurrentEntry OPTIONAL
    )

/*++

Routine Description:

    This routine looks up a match in the hash table for a given hash value.
    The entry is uniquely indentified by the hash value, and the full name length.
    This routine also takes a pointer to a hash entry for the case where we are
    resuming a search for the same hash value.

    If the target bucket has more than our optimal number of entries then set
    the state of the table to grow the number of buckets.

Arguments:

    Table - Hash table to search

    FullNameLength - Number of bytes in the name relative to the root.

    HashValue - Precomputed hash value.

    CurrentEntry - NULL if this is the first search for this hash entry.  Otherwise
        it is the last entry returned.

Return Value:

    PNTFS_HASH_ENTRY - this is NULL if no match was found.  Otherwise it points it to
        a hash entry which matches the input value.  NOTE - the caller must then verify
        the name strings.

--*/

{
    ULONG ChainDepth = 0;
    PNTFS_HASH_ENTRY NextEntry;
    ULONG HashBucket;
    ULONG HashSegment;
    ULONG HashIndex;

    PAGED_CODE();

    //
    //  If we weren't passed an initial hash entry then look up the start of
    //  the chain for the bucket containing this hash value.
    //

    if (!ARGUMENT_PRESENT( CurrentEntry )) {

        //
        //  Find the bucket by computing the segment and index to look in.
        //

        NtfsHashBucketFromHash( Table, HashValue, &HashBucket );
        NtfsGetHashSegmentAndIndex( HashBucket, &HashSegment, &HashIndex );

        //
        //  Get the first entry in the bucket.
        //

        NextEntry = (*Table->HashSegments[ HashSegment ])[ HashIndex ];

    //
    //  Otherwise we use the next entry in the chain.
    //

    } else {

        NextEntry = CurrentEntry->NextEntry;
    }

    //
    //  Walk down the chain looking for a match.  Keep track of the depth
    //  of the chain in case we need to grow the table.
    //

    while (NextEntry != NULL) {

        ChainDepth += 1;

        if ((NextEntry->HashValue == HashValue) &&
            (NextEntry->FullNameLength == FullNameLength)) {

            break;
        }

        NextEntry = NextEntry->NextEntry;
    }

    //
    //  If the depth is greater than our optimal value then mark the table
    //  for expansion.  The table may already be growing or at its maximum
    //  value.
    //

    if ((ChainDepth > HASH_MAX_BUCKET_DEPTH) &&
        (Table->TableState == TABLE_STATE_STABLE) &&
        (Table->MaxBucket < HASH_MAX_BUCKET_COUNT)) {

        ASSERT( Table->SplitPoint == 0 );
        Table->TableState = TABLE_STATE_EXPANDING;
    }

    //
    //  Return the value if found.
    //

    return NextEntry;
}


//
//  Local support routine
//

BOOLEAN
NtfsAreHashNamesEqual (
    IN PSCB StartingScb,
    IN PLCB HashLcb,
    IN PUNICODE_STRING RelativeName
    )

/*++
Routine Description:

    This routine is called to verify that the match found in the hash table has the
    same name as the input string.

Arguments:

    StartingScb - The name search begins from this directory.  It is not
        necessarily the parent of the file being opened.

    HashLcb - This is the Lcb found in the hash table.  This Lcb points
        directly to the full string matched.

    StartingName - This is the name we need to match.  It is 1 OR MORE of the
        final components of the name.

Return Value:

    None

--*/

{
    PUNICODE_STRING StartingScbName;
    PUNICODE_STRING HashScbName;
    UNICODE_STRING RemainingHashScbName;
    UNICODE_STRING RemainingRelativeName;
    USHORT SeparatorBias = 0;

    PAGED_CODE();

    //
    //  Start by verifying that there is a '\' separator in the correct positions.
    //  There must be a separator in the Relative name prior to the last component.
    //  There should also be a separator in the normalized name of the Scb in the
    //  HashLcb where the StartingScb ends.
    //

    //
    //  If the HashLcb Scb is not the StartingScb then there must be a separator
    //  where the StartingScb string ends.
    //

    StartingScbName = &StartingScb->ScbType.Index.NormalizedName;
    HashScbName = &HashLcb->Scb->ScbType.Index.NormalizedName;

    //
    //  If there is no normalized name in this Scb then get out.
    //

    if (HashScbName->Length == 0) {

        return FALSE;
    }

    if (StartingScb != HashLcb->Scb) {

        //
        //  Also get out if name in the StartingScb is longer than the one in the
        //  HashScb.  Obviously there is no match if the last component of the
        //  HashScb is longer than the last one or more components in
        //  the input name.  We can use >= as the test because if the lengths
        //  match but they aren't the same Scb then there can be no match either.
        //

        if (StartingScbName->Length >= HashScbName->Length) {

            return FALSE;
        }

        //
        //  Check for the separator provided the starting Scb is not the root.
        //

        if (StartingScb != StartingScb->Vcb->RootIndexScb) {

            if (HashScbName->Buffer[ StartingScbName->Length / sizeof( WCHAR ) ] != L'\\') {

                return FALSE;

            //
            //  Make sure the StartingScbName and the first part of the HashScbName
            //  match.  If not, this is definitely not the right hash entry.
            //

            } else {

                RemainingHashScbName.Buffer = HashScbName->Buffer;
                RemainingHashScbName.MaximumLength =
                RemainingHashScbName.Length = StartingScbName->Length;

                //
                //  OK to do a direct memory compare here because both name fragments
                //  are in the normalized form (exactly as on disk).
                //

                if (!NtfsAreNamesEqual( StartingScb->Vcb->UpcaseTable,
                                        StartingScbName,
                                        &RemainingHashScbName,
                                        FALSE )) {

                    return FALSE;
                }
            }

            SeparatorBias = sizeof( WCHAR );
        }

        //
        //  Set up a unicode string for the remaining portion of the hash scb name.
        //

        RemainingHashScbName.Buffer = Add2Ptr( HashScbName->Buffer,
                                               StartingScbName->Length + SeparatorBias );

        RemainingHashScbName.MaximumLength =
        RemainingHashScbName.Length = HashScbName->Length - (StartingScbName->Length + SeparatorBias);
    }

    RemainingRelativeName.MaximumLength =
    RemainingRelativeName.Length = HashLcb->IgnoreCaseLink.LinkName.Length;
    RemainingRelativeName.Buffer = Add2Ptr( RelativeName->Buffer,
                                            RelativeName->Length - RemainingRelativeName.Length );

    //
    //  Check for a separator between the last component of relative name and its parent.
    //  Verify the parent portion actually exists.
    //

    if (RemainingRelativeName.Length != RelativeName->Length) {

        if (*(RemainingRelativeName.Buffer - 1) != L'\\') {

            return FALSE;
        }
    }

    //
    //  Now verify that the tail of the name matches the name in the Lcb.
    //
    //  OK to do a direct memory compare here because both name fragments
    //  are already upcased.
    //
    //

    if (!NtfsAreNamesEqual( StartingScb->Vcb->UpcaseTable,
                            &HashLcb->IgnoreCaseLink.LinkName,
                            &RemainingRelativeName,
                            FALSE )) {

        return FALSE;
    }

    //
    //  It is possible that the StartingScb matches the Scb in the HashLcb.  If it doesn't
    //  then verify the other names in the name string.
    //

    if (StartingScb != HashLcb->Scb) {

        RemainingRelativeName.MaximumLength =
        RemainingRelativeName.Length = RemainingHashScbName.Length;
        RemainingRelativeName.Buffer = RelativeName->Buffer;

        //
        //  We must to a case-insensitive compare here because the
        //  HashScbName is in normalized form but the RemainingRelativeName
        //  is already upcased.
        //

        if (!NtfsAreNamesEqual( StartingScb->Vcb->UpcaseTable,
                                &RemainingHashScbName,
                                &RemainingRelativeName,
                                TRUE )) {

            return FALSE;
        }
    }

    return TRUE;
}


//
//  Local support routines
//


VOID
NtfsExpandHashTable(
    IN OUT PNTFS_HASH_TABLE Table
    )

/*++
Routine Description:

    This routine is called to add a single bucket to the hash table.  If we are at the
    last bucket then set the hash table state to stable.

Arguments:

    Table - Hash table to add a bucket to.

Return Value:

    None

--*/

{
    PNTFS_HASH_ENTRY *CurrentOldEntry;
    PNTFS_HASH_ENTRY *CurrentNewEntry;
    PNTFS_HASH_ENTRY CurrentEntry;

    ULONG OldSegment;
    ULONG OldIndex;

    ULONG NewSegment;
    ULONG NewIndex;

    ULONG NextBucket;


    PAGED_CODE();

    //
    //  Are we already at the maximum then return.
    //

    if (Table->MaxBucket == HASH_MAX_BUCKET_COUNT) {

        Table->TableState = TABLE_STATE_STABLE;
        return;
    }

    //
    //  If we have completed the split then set the state to stable and quit.
    //

    if (Table->MaxBucket == Table->SplitPoint) {

        Table->TableState = TABLE_STATE_STABLE;
        Table->MaxBucket *= 2;
        Table->SplitPoint = 0;

        return;
    }

    //
    //  Check if we need allocate a new segment.
    //

    if (!FlagOn( Table->SplitPoint, (HASH_MAX_INDEX_COUNT - 1))) {

        //
        //  If we can't allocate a new hash segment leave the table in its
        //  old state and return - we can still use it as is
        //

        try {
            NtfsInitHashSegment( Table, (Table->MaxBucket + Table->SplitPoint) >> HASH_INDEX_SHIFT );
        } except( (GetExceptionCode() == STATUS_INSUFFICIENT_RESOURCES) ?
                  EXCEPTION_EXECUTE_HANDLER :
                  EXCEPTION_CONTINUE_SEARCH ) {

            return;
        }
    }

    //
    //  Now perform the split on the next bucket.
    //

    NtfsGetHashSegmentAndIndex( Table->SplitPoint, &OldSegment, &OldIndex );
    NtfsGetHashSegmentAndIndex( Table->MaxBucket + Table->SplitPoint, &NewSegment, &NewIndex );
    CurrentOldEntry = (PNTFS_HASH_ENTRY *) &(*Table->HashSegments[ OldSegment ])[ OldIndex ];
    CurrentNewEntry = (PNTFS_HASH_ENTRY *) &(*Table->HashSegments[ NewSegment ])[ NewIndex ];

    Table->SplitPoint += 1;

    while (*CurrentOldEntry != NULL) {

        NtfsHashBucketFromHash( Table, (*CurrentOldEntry)->HashValue, &NextBucket );

        //
        //  The entry belongs in the new bucket.  Take it out of the existing
        //  bucket and insert it at the head of the new bucket.
        //

        if (NextBucket >= Table->MaxBucket) {

            ASSERT( NextBucket == (Table->MaxBucket + Table->SplitPoint - 1) );

            CurrentEntry = *CurrentOldEntry;
            *CurrentOldEntry = CurrentEntry->NextEntry;

            CurrentEntry->NextEntry = *CurrentNewEntry;
            *CurrentNewEntry = CurrentEntry;

        //
        //  Move to the next entry in the existing bucket.
        //

        } else {

            CurrentOldEntry = &(*CurrentOldEntry)->NextEntry;
        }
    }

    return;
}

#ifdef NTFS_HASH_DATA
VOID
NtfsFillHashHistogram (
    PNTFS_HASH_TABLE Table
    )

{
    ULONG CurrentBucket = 0;
    ULONG Segment;
    ULONG Index;

    PNTFS_HASH_ENTRY NextEntry;
    ULONG Count;

    //
    //  Zero the current histogram.
    //

    RtlZeroMemory( Table->Histogram, sizeof( Table->Histogram ));
    RtlZeroMemory( Table->ExtendedHistogram, sizeof( Table->ExtendedHistogram ));

    //
    //  Walk through all of the buckets in use.
    //

    while (CurrentBucket < Table->MaxBucket + Table->SplitPoint) {

        Count = 0;

        NtfsGetHashSegmentAndIndex( CurrentBucket, &Segment, &Index );

        NextEntry = (*Table->HashSegments[ Segment ])[ Index ];

        //
        //  Count the number of entries in each bucket.
        //

        while (NextEntry != NULL) {

            Count += 1;
            NextEntry = NextEntry->NextEntry;
        }

        //
        //  Store it into the first histogram set if count is less than 16.
        //

        if (Count < 16) {

            Table->Histogram[Count] += 1;

        //
        //  Store it in the last bucket if larger than our max.
        //

        } else if (Count >= 32) {

            Table->ExtendedHistogram[15] += 1;

        //
        //  Otherwise store it into the extended histogram.
        //

        } else {

            Table->ExtendedHistogram[(Count - 16) / 2] += 1;
        }

        CurrentBucket += 1;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\fsctrl.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    FsCtrl.c

Abstract:

    This module implements the File System Control routines for Ntfs called
    by the dispatch driver.

Author:

    Gary Kimura     [GaryKi]        29-Aug-1991

Revision History:

--*/

#include "NtfsProc.h"
#ifdef NTFSDBG
#include "lockorder.h"
#endif

#ifdef NTFS_CHECK_BITMAP
BOOLEAN NtfsCopyBitmap = TRUE;
#endif

#ifdef SYSCACHE_DEBUG
BOOLEAN NtfsDisableSyscacheLogFile = FALSE;
#endif

ULONG SkipNtOfs = FALSE;

BOOLEAN NtfsForceUpgrade = TRUE;

VOID
NtOfsIndexTest (
    PIRP_CONTEXT IrpContext,
    PFCB TestFcb
    );

//
//  Temporarily reference our local attribute definitions
//

extern ATTRIBUTE_DEFINITION_COLUMNS NtfsAttributeDefinitions[];

//
//**** The following variable is only for debugging and is used to disable NTFS
//**** from mounting any volumes
//

BOOLEAN NtfsDisable = FALSE;

//
//  The following is used to selectively not mount a particular device.  Used for testing.
//

PDEVICE_OBJECT NtfsDisableDevice = NULL;

//
//  The following is used to determine when to move to compressed files.
//

BOOLEAN NtfsDefragMftEnabled = FALSE;

LARGE_INTEGER NtfsLockDelay = {(ULONG)-10000000, -1};   // 1 second

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NTFS_BUG_CHECK_FSCTRL)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_FSCTRL)
#define DbgAcl                           (DEBUG_TRACE_FSCTRL|DEBUG_TRACE_ACLINDEX)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('fFtN')

//
//  Local procedure prototypes
//

NTSTATUS
NtfsMountVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsUpdateAttributeTable (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

NTSTATUS
NtfsVerifyVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsUserFsRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsOplockRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsLockVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsUnlockVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsDismountVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsIsVolumeMounted (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsDirtyVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

BOOLEAN
NtfsGetDiskGeometry (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT DeviceObjectWeTalkTo,
    IN PDISK_GEOMETRY DiskGeometry,
    IN PLONGLONG PartitionSize
    );

VOID
NtfsReadBootSector (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PSCB *BootScb,
    OUT PBCB *BootBcb,
    OUT PVOID *BootSector
    );

BOOLEAN
NtfsIsBootSectorNtfs (
    IN PPACKED_BOOT_SECTOR BootSector,
    IN PVCB Vcb
    );

VOID
NtfsGetVolumeInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PVPB Vpb OPTIONAL,
    IN PVCB Vcb,
    OUT PUSHORT VolumeFlags
    );

VOID
NtfsSetAndGetVolumeTimes (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN MarkDirty,
    IN BOOLEAN UpdateInTransaction
    );

VOID
NtfsOpenSystemFile (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PSCB *Scb,
    IN PVCB Vcb,
    IN ULONG FileNumber,
    IN LONGLONG Size,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN BOOLEAN ModifiedNoWrite
    );

VOID
NtfsOpenRootDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

NTSTATUS
NtfsQueryRetrievalPointers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsGetCompression (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
NtfsChangeAttributeCompression (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PVCB Vcb,
    IN PCCB Ccb,
    IN USHORT CompressionState
    );

NTSTATUS
NtfsSetCompression (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsMarkAsSystemHive (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsGetStatistics (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

LONG
NtfsWriteRawExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    );

#define NtfsMapPageInBitmap(A,B,C,D,E,F) NtfsMapOrPinPageInBitmap(A,B,C,D,E,F,FALSE)

#define NtfsPinPageInBitmap(A,B,C,D,E,F) NtfsMapOrPinPageInBitmap(A,B,C,D,E,F,TRUE)

VOID
NtfsMapOrPinPageInBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN Lcn,
    OUT PLCN StartingLcn,
    IN OUT PRTL_BITMAP Bitmap,
    OUT PBCB *BitmapBcb,
    IN BOOLEAN AlsoPinData
    );

#define BYTES_PER_PAGE (PAGE_SIZE)
#define BITS_PER_PAGE (BYTES_PER_PAGE * 8)

NTSTATUS
NtfsGetVolumeData (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsGetVolumeBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsGetRetrievalPointers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsGetMftRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsIsVolumeDirty (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsSetExtendedDasdIo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsCreateUsnJournal (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsReadFileRecordUsnData (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsReadFileUsnData (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsWriteUsnCloseRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsReadUsnWorker (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVOID Context
    );

NTSTATUS
NtfsBulkSecurityIdCheck (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
NtfsInitializeSecurityFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
NtfsUpgradeSecurity (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
NtfsInitializeQuotaFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
NtfsInitializeObjectIdFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
NtfsInitializeReparseFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
NtfsInitializeUsnJournal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG CreateIfNotExist,
    IN ULONG Restamp,
    IN PCREATE_USN_JOURNAL_DATA NewJournalData
    );

VOID
NtfsInitializeExtendDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

NTSTATUS
NtfsQueryAllocatedRanges (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsSetSparse (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsZeroRange (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsSetReparsePoint (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp );

NTSTATUS
NtfsGetReparsePoint (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp );

NTSTATUS
NtfsDeleteReparsePoint (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp );

NTSTATUS
NtfsEncryptionFsctl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsSetEncryption (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsReadRawEncrypted (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsWriteRawEncrypted (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsFindFilesOwnedBySid (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsFindBySidWorker (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVOID Context
    );

NTSTATUS
NtfsExtendVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsMarkHandle (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsPrefetchFile (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

LONG
NtfsFsctrlExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer,
    IN BOOLEAN AccessingUserData,
    IN OUT PNTSTATUS Status
    );

#ifdef BRIANDBG
LONG
NtfsDismountExceptionFilter (
    IN PEXCEPTION_POINTERS ExceptionPointer
    );
#endif

#ifdef SYSCACHE_DEBUG
VOID
NtfsInitializeSyscacheLogFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsBulkSecurityIdCheck)
#pragma alloc_text(PAGE, NtfsChangeAttributeCompression)
#pragma alloc_text(PAGE, NtfsCommonFileSystemControl)
#pragma alloc_text(PAGE, NtfsCreateUsnJournal)
#pragma alloc_text(PAGE, NtfsDeleteReparsePoint)
#pragma alloc_text(PAGE, NtfsDirtyVolume)
#pragma alloc_text(PAGE, NtfsDismountVolume)
#pragma alloc_text(PAGE, NtfsEncryptionFsctl)
#pragma alloc_text(PAGE, NtfsExtendVolume)
#pragma alloc_text(PAGE, NtfsFindBySidWorker)
#pragma alloc_text(PAGE, NtfsFindFilesOwnedBySid)
#pragma alloc_text(PAGE, NtfsFsdFileSystemControl)
#pragma alloc_text(PAGE, NtfsGetCompression)
#pragma alloc_text(PAGE, NtfsGetDiskGeometry)
#pragma alloc_text(PAGE, NtfsGetMftRecord)
#pragma alloc_text(PAGE, NtfsGetReparsePoint)
#pragma alloc_text(PAGE, NtfsGetRetrievalPointers)
#pragma alloc_text(PAGE, NtfsGetStatistics)
#pragma alloc_text(PAGE, NtfsGetTunneledData)
#pragma alloc_text(PAGE, NtfsGetVolumeBitmap)
#pragma alloc_text(PAGE, NtfsGetVolumeData)
#pragma alloc_text(PAGE, NtfsGetVolumeInformation)
#pragma alloc_text(PAGE, NtfsInitializeExtendDirectory)
#pragma alloc_text(PAGE, NtfsInitializeObjectIdFile)
#pragma alloc_text(PAGE, NtfsInitializeReparseFile)
#pragma alloc_text(PAGE, NtfsInitializeQuotaFile)
#pragma alloc_text(PAGE, NtfsInitializeSecurityFile)
#pragma alloc_text(PAGE, NtfsInitializeUsnJournal)
#pragma alloc_text(PAGE, NtfsIsBootSectorNtfs)
#pragma alloc_text(PAGE, NtfsIsVolumeDirty)
#pragma alloc_text(PAGE, NtfsIsVolumeMounted)
#pragma alloc_text(PAGE, NtfsLockVolume)
#pragma alloc_text(PAGE, NtfsMarkAsSystemHive)
#pragma alloc_text(PAGE, NtfsMarkHandle)
#pragma alloc_text(PAGE, NtfsMountVolume)
#pragma alloc_text(PAGE, NtfsOpenRootDirectory)
#pragma alloc_text(PAGE, NtfsOpenSystemFile)
#pragma alloc_text(PAGE, NtfsOplockRequest)
#pragma alloc_text(PAGE, NtfsPrefetchFile)
#pragma alloc_text(PAGE, NtfsQueryAllocatedRanges)
#pragma alloc_text(PAGE, NtfsQueryRetrievalPointers)
#pragma alloc_text(PAGE, NtfsReadBootSector)
#pragma alloc_text(PAGE, NtfsReadFileRecordUsnData)
#pragma alloc_text(PAGE, NtfsReadFileUsnData)
#pragma alloc_text(PAGE, NtfsReadRawEncrypted)
#pragma alloc_text(PAGE, NtfsReadUsnWorker)
#pragma alloc_text(PAGE, NtfsSetAndGetVolumeTimes)
#pragma alloc_text(PAGE, NtfsSetCompression)
#pragma alloc_text(PAGE, NtfsSetEncryption)
#pragma alloc_text(PAGE, NtfsSetExtendedDasdIo)
#pragma alloc_text(PAGE, NtfsSetReparsePoint)
#pragma alloc_text(PAGE, NtfsSetSparse)
#pragma alloc_text(PAGE, NtfsSetTunneledData)
#pragma alloc_text(PAGE, NtfsUnlockVolume)
#pragma alloc_text(PAGE, NtfsUpdateAttributeTable)
#pragma alloc_text(PAGE, NtfsUpgradeSecurity)
#pragma alloc_text(PAGE, NtfsUserFsRequest)
#pragma alloc_text(PAGE, NtfsVerifyVolume)
#pragma alloc_text(PAGE, NtfsWriteRawEncrypted)
#pragma alloc_text(PAGE, NtfsWriteUsnCloseRecord)
#pragma alloc_text(PAGE, NtfsZeroRange)
#endif

#ifdef BRIANDBG
LONG
NtfsDismountExceptionFilter (
    IN PEXCEPTION_POINTERS ExceptionPointer
    )
{
    UNREFERENCED_PARAMETER( ExceptionPointer );

    ASSERT( ExceptionPointer->ExceptionRecord->ExceptionCode == STATUS_SUCCESS );

    return EXCEPTION_CONTINUE_SEARCH;
}
#endif


NTSTATUS
NtfsFsdFileSystemControl (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of File System Control.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;

    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;
    PIRP_CONTEXT IrpContext = NULL;
    PIO_STACK_LOCATION IrpSp;

    NTSTATUS Status = STATUS_SUCCESS;

    BOOLEAN Wait;
    BOOLEAN Retry = FALSE;

    ASSERT_IRP( Irp );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFsdFileSystemControl\n") );

    //
    //  Call the common File System Control routine, with blocking allowed if
    //  synchronous.  This opeation needs to special case the mount
    //  and verify suboperations because we know they are allowed to block.
    //  We identify these suboperations by looking at the file object field
    //  and seeing if its null.
    //

    if (IoGetCurrentIrpStackLocation(Irp)->FileObject == NULL) {

        Wait = TRUE;

    } else {

        Wait = CanFsdWait( Irp );
    }

    //
    //  Make the callback if this is not our filesystem device object (i.e., !mount)
    //  and thus a regular fsctrl.  Mounts are handled later via a seperate callback.
    //

    if (VolumeDeviceObject->DeviceObject.Size != sizeof(DEVICE_OBJECT) &&
        NtfsData.EncryptionCallBackTable.PreFileSystemControl != NULL) {

        Status = NtfsData.EncryptionCallBackTable.PreFileSystemControl( (PDEVICE_OBJECT) VolumeDeviceObject,
                                                                        Irp,
                                                                        IoGetCurrentIrpStackLocation(Irp)->FileObject );

        //
        //  Raise the status if a failure.
        //

        if (Status != STATUS_SUCCESS) {

            NtfsCompleteRequest( NULL, Irp, Status );
            return Status;
        }
    }

    FsRtlEnterFileSystem();

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, FALSE, FALSE );

    do {

        try {

            //
            //  We are either initiating this request or retrying it.
            //

            if (IrpContext == NULL) {

                //
                //  Allocate and initialize the Irp.
                //

                NtfsInitializeIrpContext( Irp, Wait, &IrpContext );

                //
                //  Initialize the thread top level structure, if needed.
                //

                NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

            } else if (Status == STATUS_LOG_FILE_FULL) {

                Retry = TRUE;
                NtfsCheckpointForLogFileFull( IrpContext );
            }

            IrpSp = IoGetCurrentIrpStackLocation(Irp);

            if (IrpSp->MinorFunction == IRP_MN_MOUNT_VOLUME) {

                Status = NtfsPostRequest( IrpContext, Irp );

            } else {

                //
                //  The SetCompression control is a long-winded function that has
                //  to rewrite the entire stream, and has to tolerate log file full
                //  conditions.  If this is the first pass through we initialize some
                //  fields in the NextIrpSp to allow us to resume the set compression
                //  operation.
                //
                //  David Goebel 1/3/96: Changed to next stack location so that we
                //  don't wipe out buffer length values.  These Irps are never
                //  dispatched, so the next stack location will not be disturbed.
                //

                if ((IrpSp->MinorFunction == IRP_MN_USER_FS_REQUEST) &&
                    (IrpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_SET_COMPRESSION)) {

                    if (!Retry) {

                        PIO_STACK_LOCATION NextIrpSp;
                        NextIrpSp = IoGetNextIrpStackLocation( Irp );

                        NextIrpSp->Parameters.FileSystemControl.OutputBufferLength = MAXULONG;
                        NextIrpSp->Parameters.FileSystemControl.InputBufferLength = MAXULONG;
                    }
                }

                Status = NtfsCommonFileSystemControl( IrpContext, Irp );
            }

            break;

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error status that we get back from the
            //  execption code
            //

            Status = NtfsProcessException( IrpContext, Irp, GetExceptionCode() );
        }

    } while (Status == STATUS_CANT_WAIT ||
             Status == STATUS_LOG_FILE_FULL);

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsFsdFileSystemControl -> %08lx\n", Status) );

    return Status;
}


NTSTATUS
NtfsCommonFileSystemControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for File System Control called by both the
    fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonFileSystemControl\n") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );

    //
    //  We know this is a file system control so we'll case on the
    //  minor function, and call a internal worker routine to complete
    //  the irp.
    //

    switch (IrpSp->MinorFunction) {

    case IRP_MN_MOUNT_VOLUME:

        Status = NtfsMountVolume( IrpContext, Irp );
        break;

    case IRP_MN_USER_FS_REQUEST:
    case IRP_MN_KERNEL_CALL:

        Status = NtfsUserFsRequest( IrpContext, Irp );
        break;

    default:

        DebugTrace( -1, Dbg, ("Invalid Minor Function %08lx\n", IrpSp->MinorFunction) );
        NtfsCompleteRequest( IrpContext, Irp, Status = STATUS_INVALID_DEVICE_REQUEST );
        break;
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsCommonFileSystemControl -> %08lx\n", Status) );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsMountVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the mount volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

    Its job is to verify that the volume denoted in the IRP is an NTFS volume,
    and create the VCB and root SCB/FCB structures.  The algorithm it uses is
    essentially as follows:

    1. Create a new Vcb Structure, and initialize it enough to do cached
       volume file I/O.

    2. Read the disk and check if it is an NTFS volume.

    3. If it is not an NTFS volume then free the cached volume file, delete
       the VCB, and complete the IRP with STATUS_UNRECOGNIZED_VOLUME

    4. Check if the volume was previously mounted and if it was then do a
       remount operation.  This involves freeing the cached volume file,
       delete the VCB, hook in the old VCB, and complete the IRP.

    5. Otherwise create a root SCB, recover the volume, create Fsp threads
       as necessary, and complete the IRP.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    PATTRIBUTE_RECORD_HEADER Attribute;

    PDEVICE_OBJECT DeviceObjectWeTalkTo;
    PVPB Vpb;

    PVOLUME_DEVICE_OBJECT VolDo;
    PVCB Vcb;

    PFILE_OBJECT RootDirFileObject = NULL;
    PBCB BootBcb = NULL;
    PPACKED_BOOT_SECTOR BootSector;
    PSCB BootScb = NULL;
    PSCB QuotaDataScb = NULL;

    POBJECT_NAME_INFORMATION DeviceObjectName = NULL;
    ULONG DeviceObjectNameLength;

    PBCB Bcbs[8] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
    PMDL Mdls[8] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};

    ULONG FirstNonMirroredCluster;
    ULONG MirroredMftRange;

    PLIST_ENTRY MftLinks;
    PSCB AttributeListScb;

    ULONG i;

    IO_STATUS_BLOCK IoStatus;

    BOOLEAN UpdatesApplied;
    BOOLEAN VcbAcquired = FALSE;
    BOOLEAN MountFailed = TRUE;
    BOOLEAN CloseAttributes = FALSE;
    BOOLEAN UpgradeVolume = FALSE;
    BOOLEAN WriteProtected;
    BOOLEAN CurrentVersion = FALSE;
    BOOLEAN UnrecognizedRestart;
    ULONG RetryRestart;

    USHORT VolumeFlags = 0;

    LONGLONG LlTemp1;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    //
    //**** The following code is only temporary and is used to disable NTFS
    //**** from mounting any volumes
    //

    if (NtfsDisable) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_UNRECOGNIZED_VOLUME );
        return STATUS_UNRECOGNIZED_VOLUME;
    }

    //
    //  Reject floppies
    //

    if (FlagOn( IoGetCurrentIrpStackLocation(Irp)->
                Parameters.MountVolume.Vpb->
                RealDevice->Characteristics, FILE_FLOPPY_DISKETTE ) ) {

        Irp->IoStatus.Information = 0;

        NtfsCompleteRequest( IrpContext, Irp, STATUS_UNRECOGNIZED_VOLUME );
        return STATUS_UNRECOGNIZED_VOLUME;
    }

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsMountVolume\n") );

    //
    //  Save some references to make our life a little easier
    //

    DeviceObjectWeTalkTo = IrpSp->Parameters.MountVolume.DeviceObject;
    Vpb = IrpSp->Parameters.MountVolume.Vpb;
    ClearFlag( Vpb->RealDevice->Flags, DO_VERIFY_VOLUME );

    //
    //  TEMPCODE  Perform the following test for chkdsk testing.
    //

    if (NtfsDisableDevice == IrpSp->Parameters.MountVolume.DeviceObject) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_UNRECOGNIZED_VOLUME );
        return STATUS_UNRECOGNIZED_VOLUME;
    }

    //
    //  Acquire exclusive global access
    //

    NtfsAcquireExclusiveGlobal( IrpContext, TRUE );

    //
    //  Now is a convenient time to look through the queue of Vcb's to see if there
    //  are any which can be deleted.
    //

    try {

        PLIST_ENTRY Links;

        for (Links = NtfsData.VcbQueue.Flink;
             Links != &NtfsData.VcbQueue;
             Links = Links->Flink) {

            Vcb = CONTAINING_RECORD( Links, VCB, VcbLinks );

            if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ) &&
                (Vcb->CloseCount == 0) &&
                FlagOn( Vcb->VcbState, VCB_STATE_PERFORMED_DISMOUNT )) {

                //
                //  Now we can check to see if we should perform the teardown
                //  on this Vcb.  The release Vcb routine below can do all of
                //  the checks correctly.  Make this appear to from a close
                //  call since there is no special biasing for this case.
                //

                IrpContext->Vcb = Vcb;
                NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );

                if (!FlagOn( Vcb->VcbState, VCB_STATE_DELETE_UNDERWAY )) {

                    NtfsReleaseGlobal( IrpContext );

                    NtfsReleaseVcbCheckDelete( IrpContext,
                                               Vcb,
                                               IRP_MJ_CLOSE,
                                               NULL );

                    //
                    //  Only do one since we have lost our place in the Vcb list.
                    //

                    NtfsAcquireExclusiveGlobal( IrpContext, TRUE );

                    break;

                } else {

                    NtfsReleaseVcb( IrpContext, Vcb );
                }
            }
        }

    } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  Make sure we own the global resource for mount.  We can only raise above
        //  in the DeleteVcb path when we don't hold the resource.
        //

        NtfsAcquireExclusiveGlobal( IrpContext, TRUE );
    }

    Vcb = NULL;

    try {

        PFILE_RECORD_SEGMENT_HEADER MftBuffer;
        PVOID Mft2Buffer;
        LONGLONG MftMirrorOverlap;

        //
        //  Create a new volume device object.  This will have the Vcb hanging
        //  off of its end, and set its alignment requirement from the device
        //  we talk to.
        //

        if (!NT_SUCCESS(Status = IoCreateDevice( NtfsData.DriverObject,
                                                 sizeof(VOLUME_DEVICE_OBJECT) - sizeof(DEVICE_OBJECT),
                                                 NULL,
                                                 FILE_DEVICE_DISK_FILE_SYSTEM,
                                                 0,
                                                 FALSE,
                                                 (PDEVICE_OBJECT *)&VolDo))) {

            try_return( Status );
        }

        //
        //  Our alignment requirement is the larger of the processor alignment requirement
        //  already in the volume device object and that in the DeviceObjectWeTalkTo
        //

        if (DeviceObjectWeTalkTo->AlignmentRequirement > VolDo->DeviceObject.AlignmentRequirement) {

            VolDo->DeviceObject.AlignmentRequirement = DeviceObjectWeTalkTo->AlignmentRequirement;
        }

        ClearFlag( VolDo->DeviceObject.Flags, DO_DEVICE_INITIALIZING );

        //
        //  Add one more to the stack size requirements for our device
        //

        VolDo->DeviceObject.StackSize = DeviceObjectWeTalkTo->StackSize + 1;

        //
        //  Initialize the overflow queue for the volume
        //

        VolDo->OverflowQueueCount = 0;
        InitializeListHead( &VolDo->OverflowQueue );
        KeInitializeEvent( &VolDo->OverflowQueueEvent, SynchronizationEvent, FALSE );

        //
        //  Get a reference to the Vcb hanging off the end of the volume device object
        //  we just created
        //

        IrpContext->Vcb = Vcb = &VolDo->Vcb;

        //
        //  Set the device object field in the vpb to point to our new volume device
        //  object
        //

        Vpb->DeviceObject = (PDEVICE_OBJECT)VolDo;

        //
        //  Initialize the Vcb.  Set checkpoint
        //  in progress (to prevent a real checkpoint from occuring until we
        //  are done).
        //

        NtfsInitializeVcb( IrpContext, Vcb, DeviceObjectWeTalkTo, Vpb );
        NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
        VcbAcquired= TRUE;

        //
        //  Query the device we talk to for this geometry and setup enough of the
        //  vcb to read in the boot sectors.  This is a temporary setup until
        //  we've read in the actual boot sector and got the real cluster factor.
        //

        {
            DISK_GEOMETRY DiskGeometry;
            LONGLONG Length;
            ULONG BytesPerSector;

            WriteProtected = NtfsGetDiskGeometry( IrpContext,
                                                  DeviceObjectWeTalkTo,
                                                  &DiskGeometry,
                                                  &Length );

            //
            //  If the sector size is greater than the page size, it is probably
            //  a bogus return, but we cannot use the device.  We also verify that
            //  the sector size is a power of two.
            //

            BytesPerSector = DiskGeometry.BytesPerSector;

            if ((BytesPerSector > PAGE_SIZE) ||
                (BytesPerSector == 0)) {
                NtfsRaiseStatus( IrpContext, STATUS_BAD_DEVICE_TYPE, NULL, NULL );
            }

            while (TRUE) {

                if (FlagOn( BytesPerSector, 1 )) {

                    if (BytesPerSector != 1) {
                        NtfsRaiseStatus( IrpContext, STATUS_BAD_DEVICE_TYPE, NULL, NULL );
                    }
                    break;
                }

                BytesPerSector >>= 1;
            }

            Vcb->BytesPerSector = DiskGeometry.BytesPerSector;
            Vcb->BytesPerCluster = Vcb->BytesPerSector;
            Vcb->NumberSectors = Length / DiskGeometry.BytesPerSector;

            //
            //  Fail the mount if the number of sectors is less than 16.  Otherwise our mount logic
            //  won't work.
            //

            if (Vcb->NumberSectors <= 0x10) {

                try_return( Status = STATUS_UNRECOGNIZED_VOLUME );
            }

            Vcb->ClusterMask = Vcb->BytesPerCluster - 1;
            Vcb->InverseClusterMask = ~Vcb->ClusterMask;
            for (Vcb->ClusterShift = 0, i = Vcb->BytesPerCluster; i > 1; i = i / 2) {
                Vcb->ClusterShift += 1;
            }
            Vcb->ClustersPerPage = PAGE_SIZE >> Vcb->ClusterShift;

            //
            //  Set the sector size in our device object.
            //

            VolDo->DeviceObject.SectorSize = (USHORT) Vcb->BytesPerSector;
        }

        //
        //  Read in the Boot sector, or spare boot sector, on exit of this try
        //  body we will have set bootbcb and bootsector.
        //

        NtfsReadBootSector( IrpContext, Vcb, &BootScb, &BootBcb, (PVOID *)&BootSector );

        //
        //  Check if this is an NTFS volume
        //

        if (!NtfsIsBootSectorNtfs( BootSector, Vcb )) {

            DebugTrace( 0, Dbg, ("Not an NTFS volume\n") );
            try_return( Status = STATUS_UNRECOGNIZED_VOLUME );
        }

        //
        //  Media is write protected, so we should try to mount read-only.
        //

        if (WriteProtected) {

            SetFlag( Vcb->VcbState, VCB_STATE_MOUNT_READ_ONLY );
        }

        //
        //  Now that we have a real boot sector on a real NTFS volume we can
        //  really set the proper Vcb fields.
        //

        {
            BIOS_PARAMETER_BLOCK Bpb;

            NtfsUnpackBios( &Bpb, &BootSector->PackedBpb );

            Vcb->BytesPerSector = Bpb.BytesPerSector;
            Vcb->BytesPerCluster = Bpb.BytesPerSector * Bpb.SectorsPerCluster;
            Vcb->NumberSectors = BootSector->NumberSectors;
            Vcb->MftStartLcn = BootSector->MftStartLcn;
            Vcb->Mft2StartLcn = BootSector->Mft2StartLcn;

            Vcb->ClusterMask = Vcb->BytesPerCluster - 1;
            Vcb->InverseClusterMask = ~Vcb->ClusterMask;
            for (Vcb->ClusterShift = 0, i = Vcb->BytesPerCluster; i > 1; i = i / 2) {
                Vcb->ClusterShift += 1;
            }

            //
            //  If the cluster size is greater than the page size then set this value to 1.
            //

            Vcb->ClustersPerPage = PAGE_SIZE >> Vcb->ClusterShift;

            if (Vcb->ClustersPerPage == 0) {

                Vcb->ClustersPerPage = 1;
            }

            //
            //  File records can be smaller, equal or larger than the cluster size.  Initialize
            //  both ClustersPerFileRecordSegment and FileRecordsPerCluster.
            //
            //  If the value in the boot sector is positive then it signifies the
            //  clusters/structure.  If negative then it signifies the shift value
            //  to obtain the structure size.
            //

            if (BootSector->ClustersPerFileRecordSegment < 0) {

                Vcb->BytesPerFileRecordSegment = 1 << (-1 * BootSector->ClustersPerFileRecordSegment);

                //
                //  Initialize the other Mft/Cluster relationship numbers in the Vcb
                //  based on whether the clusters are larger or smaller than file
                //  records.
                //

                if (Vcb->BytesPerFileRecordSegment < Vcb->BytesPerCluster) {

                    Vcb->FileRecordsPerCluster = Vcb->BytesPerCluster / Vcb->BytesPerFileRecordSegment;

                } else {

                    Vcb->ClustersPerFileRecordSegment = Vcb->BytesPerFileRecordSegment / Vcb->BytesPerCluster;
                }

            } else {

                Vcb->BytesPerFileRecordSegment = BytesFromClusters( Vcb, BootSector->ClustersPerFileRecordSegment );
                Vcb->ClustersPerFileRecordSegment = BootSector->ClustersPerFileRecordSegment;
            }

            for (Vcb->MftShift = 0, i = Vcb->BytesPerFileRecordSegment; i > 1; i = i / 2) {
                Vcb->MftShift += 1;
            }

            //
            //  We want to shift between file records and clusters regardless of which is larger.
            //  Compute the shift value here.  Anyone using this value will have to know which
            //  way to shift.
            //

            Vcb->MftToClusterShift = Vcb->MftShift - Vcb->ClusterShift;

            if (Vcb->ClustersPerFileRecordSegment == 0) {

                Vcb->MftToClusterShift = Vcb->ClusterShift - Vcb->MftShift;
            }

            //
            //  Remember the clusters per view section and 4 gig.
            //

            Vcb->ClustersPer4Gig = (ULONG) LlClustersFromBytesTruncate( Vcb, 0x100000000 );

            //
            //  Compute the default index allocation buffer size.
            //

            if (BootSector->DefaultClustersPerIndexAllocationBuffer < 0) {

                Vcb->DefaultBytesPerIndexAllocationBuffer = 1 << (-1 * BootSector->DefaultClustersPerIndexAllocationBuffer);

                //
                //  Determine whether the index allocation buffer is larger/smaller
                //  than the cluster size to determine the block size.
                //

                if (Vcb->DefaultBytesPerIndexAllocationBuffer < Vcb->BytesPerCluster) {

                    Vcb->DefaultBlocksPerIndexAllocationBuffer = Vcb->DefaultBytesPerIndexAllocationBuffer / DEFAULT_INDEX_BLOCK_SIZE;

                } else {

                    Vcb->DefaultBlocksPerIndexAllocationBuffer = Vcb->DefaultBytesPerIndexAllocationBuffer / Vcb->BytesPerCluster;
                }

            } else {

                Vcb->DefaultBlocksPerIndexAllocationBuffer = BootSector->DefaultClustersPerIndexAllocationBuffer;
                Vcb->DefaultBytesPerIndexAllocationBuffer = BytesFromClusters( Vcb, Vcb->DefaultBlocksPerIndexAllocationBuffer );
            }

            //
            //  Now compute our volume specific constants that are stored in
            //  the Vcb.  The total number of clusters is:
            //
            //      (NumberSectors * BytesPerSector) / BytesPerCluster
            //

            Vcb->PreviousTotalClusters =
            Vcb->TotalClusters = LlClustersFromBytesTruncate( Vcb,
                                                              Vcb->NumberSectors * Vcb->BytesPerSector );

            //
            //  Compute the maximum clusters for a file.
            //

            Vcb->MaxClusterCount = LlClustersFromBytesTruncate( Vcb, MAXFILESIZE );

            //
            //  Compute the attribute flags mask for this volume for this volume.
            //

            Vcb->AttributeFlagsMask = 0xffff;

            if (Vcb->BytesPerCluster > 0x1000) {

                ClearFlag( Vcb->AttributeFlagsMask, ATTRIBUTE_FLAG_COMPRESSION_MASK );
            }

            //
            //  For now, an attribute is considered "moveable" if it is at
            //  least 5/16 of the file record.  This constant should only
            //  be changed i conjunction with the MAX_MOVEABLE_ATTRIBUTES
            //  constant.  (The product of the two should be a little less
            //  than or equal to 1.)
            //

            Vcb->BigEnoughToMove = Vcb->BytesPerFileRecordSegment * 5 / 16;

            //
            //  Set the serial number in the Vcb
            //

            Vcb->VolumeSerialNumber = BootSector->SerialNumber;
            Vpb->SerialNumber = ((ULONG)BootSector->SerialNumber);

            //
            //  Compute the sparse file values.
            //

            Vcb->SparseFileUnit = NTFS_SPARSE_FILE_UNIT;
            Vcb->SparseFileClusters = ClustersFromBytes( Vcb, Vcb->SparseFileUnit );

            //
            //  If this is the system boot partition, we need to remember to
            //  not allow this volume to be dismounted.
            //

            if (FlagOn( Vpb->RealDevice->Flags, DO_SYSTEM_BOOT_PARTITION )) {

                SetFlag( Vcb->VcbState, VCB_STATE_DISALLOW_DISMOUNT );
            }

            //
            //  We should never see the BOOT flag in the device we talk to unless it
            //  is in the real device.
            //

            ASSERT( !FlagOn( DeviceObjectWeTalkTo->Flags, DO_SYSTEM_BOOT_PARTITION ) ||
                    FlagOn( Vpb->RealDevice->Flags, DO_SYSTEM_BOOT_PARTITION ));
        }

        //
        //  Initialize recovery state.
        //

        NtfsInitializeRestartTable( sizeof( OPEN_ATTRIBUTE_ENTRY ),
                                    INITIAL_NUMBER_ATTRIBUTES,
                                    &Vcb->OpenAttributeTable );

        NtfsUpdateOatVersion( Vcb, NtfsDefaultRestartVersion );


        NtfsInitializeRestartTable( sizeof( TRANSACTION_ENTRY ),
                                    INITIAL_NUMBER_TRANSACTIONS,
                                    &Vcb->TransactionTable );

        //
        //  Now start preparing to restart the volume.
        //

        //
        //  Create the Mft and Log File Scbs and prepare to read them.
        //  The Mft and mirror length will be the first 4 file records or
        //  the first cluster.
        //

        FirstNonMirroredCluster = ClustersFromBytes( Vcb, 4 * Vcb->BytesPerFileRecordSegment );
        MirroredMftRange = 4 * Vcb->BytesPerFileRecordSegment;

        if (MirroredMftRange < Vcb->BytesPerCluster) {

            MirroredMftRange = Vcb->BytesPerCluster;
        }

        //
        //  Check the case where the boot sector has an invalid value for either the
        //  beginning of the Mft or the beginning of the Mft mirror.  Specifically
        //  check the they don't overlap.  Otherwise we can corrupt the valid one
        //  as we read and possibly try to correct the invalid one.
        //

        if (Vcb->MftStartLcn > Vcb->Mft2StartLcn) {

            MftMirrorOverlap = Vcb->MftStartLcn - Vcb->Mft2StartLcn;

        } else {

            MftMirrorOverlap = Vcb->Mft2StartLcn - Vcb->MftStartLcn;
        }

        MftMirrorOverlap = LlBytesFromClusters( Vcb, MftMirrorOverlap );

        //
        //  Don't raise corrupt since we don't want to attempt to write the
        //  disk in this state.  Someone who knows how will need to
        //  restore the correct boot sector.
        //

        if (MftMirrorOverlap < (LONGLONG) MirroredMftRange) {

            DebugTrace( 0, Dbg, ("Not an NTFS volume\n") );
            try_return( Status = STATUS_UNRECOGNIZED_VOLUME );
        }

        NtfsOpenSystemFile( IrpContext,
                            &Vcb->MftScb,
                            Vcb,
                            MASTER_FILE_TABLE_NUMBER,
                            MirroredMftRange,
                            $DATA,
                            TRUE );

        CcSetAdditionalCacheAttributes( Vcb->MftScb->FileObject, TRUE, TRUE );

        LlTemp1 = FirstNonMirroredCluster;

        (VOID)NtfsAddNtfsMcbEntry( &Vcb->MftScb->Mcb,
                                   (LONGLONG)0,
                                   Vcb->MftStartLcn,
                                   (LONGLONG)FirstNonMirroredCluster,
                                   FALSE );

        //
        //  Now the same for Mft2
        //

        NtfsOpenSystemFile( IrpContext,
                            &Vcb->Mft2Scb,
                            Vcb,
                            MASTER_FILE_TABLE2_NUMBER,
                            MirroredMftRange,
                            $DATA,
                            TRUE );

        CcSetAdditionalCacheAttributes( Vcb->Mft2Scb->FileObject, TRUE, TRUE );


        (VOID)NtfsAddNtfsMcbEntry( &Vcb->Mft2Scb->Mcb,
                                   (LONGLONG)0,
                                   Vcb->Mft2StartLcn,
                                   (LONGLONG)FirstNonMirroredCluster,
                                   FALSE );

        //
        //  Create the dasd system file, we do it here because we need to dummy
        //  up the mcb for it, and that way everything else in NTFS won't need
        //  to know that it is a special file.  We need to do this after
        //  cluster allocation initialization because that computes the total
        //  clusters on the volume.  Also for verification purposes we will
        //  set and get the times off of the volume.
        //
        //  Open it now before the Log File, because that is the first time
        //  anyone may want to mark the volume corrupt.
        //

        NtfsOpenSystemFile( IrpContext,
                            &Vcb->VolumeDasdScb,
                            Vcb,
                            VOLUME_DASD_NUMBER,
                            LlBytesFromClusters( Vcb, Vcb->TotalClusters ),
                            $DATA,
                            FALSE );

        (VOID)NtfsAddNtfsMcbEntry( &Vcb->VolumeDasdScb->Mcb,
                                   (LONGLONG)0,
                                   (LONGLONG)0,
                                   Vcb->TotalClusters,
                                   FALSE );

        SetFlag( Vcb->VolumeDasdScb->Fcb->FcbState, FCB_STATE_DUP_INITIALIZED );

        Vcb->VolumeDasdScb->Fcb->LinkCount =
        Vcb->VolumeDasdScb->Fcb->TotalLinks = 1;

        //
        //  We want to read the first four record segments of each of these
        //  files.  We do this so that we don't have a cache miss when we
        //  look up the real allocation below.
        //

        for (i = 0; i < 4; i++) {

            FILE_REFERENCE FileReference;
            BOOLEAN ValidRecord;
            ULONG CorruptHint;

            NtfsSetSegmentNumber( &FileReference, 0, i );
            if (i > 0) {
                FileReference.SequenceNumber = (USHORT)i;
            } else {
                FileReference.SequenceNumber = 1;
            }

            NtfsReadMftRecord( IrpContext,
                               Vcb,
                               &FileReference,
                               FALSE,
                               &Bcbs[i*2],
                               &MftBuffer,
                               NULL );

            NtfsMapStream( IrpContext,
                           Vcb->Mft2Scb,
                           (LONGLONG)(i * Vcb->BytesPerFileRecordSegment),
                           Vcb->BytesPerFileRecordSegment,
                           &Bcbs[i*2 + 1],
                           &Mft2Buffer );

            //
            //  First validate the record and if its valid and record 0
            //  do an extra check for whether its the mft.
            //

            ValidRecord = NtfsCheckFileRecord( Vcb, MftBuffer, &FileReference, &CorruptHint );
            if (ValidRecord && (i == 0)) {

                ATTRIBUTE_ENUMERATION_CONTEXT Context;

                NtfsInitializeAttributeContext( &Context );

                try {

                    if (!NtfsLookupAttributeByCode( IrpContext, Vcb->MftScb->Fcb, &Vcb->MftScb->Fcb->FileReference, $ATTRIBUTE_LIST, &Context )) {

                        if (NtfsLookupAttributeByCode( IrpContext, Vcb->MftScb->Fcb, &Vcb->MftScb->Fcb->FileReference, $FILE_NAME, &Context )) {

                            PFILE_NAME FileName;

                            FileName = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &Context ) );
                            if ((FileName->FileNameLength != wcslen( L"MFT" )) ||
                                (!RtlEqualMemory( FileName->FileName, L"$MFT", FileName->FileNameLength * sizeof( WCHAR )))) {

                                ValidRecord = FALSE;
                            }
                        }
                    }

                } finally {
                    NtfsCleanupAttributeContext( IrpContext, &Context );
                }
            }

            //
            //  If any of these file records are bad then try the mirror
            //  (unless we are already looking at the mirror).  If we
            //  can't find a valid record then fail the mount.
            //

            if (!ValidRecord) {

                if ((MftBuffer != Mft2Buffer) &&
                    NtfsCheckFileRecord( Vcb, Mft2Buffer, &FileReference, &CorruptHint )) {

                    LlTemp1 = MAXLONGLONG;

                    //
                    //  Put a BaadSignature in this file record,
                    //  mark it dirty and then read it again.
                    //  The baad signature should force us to bring
                    //  in the mirror and we can correct the problem.
                    //

                    NtfsPinMappedData( IrpContext,
                                       Vcb->MftScb,
                                       i * Vcb->BytesPerFileRecordSegment,
                                       Vcb->BytesPerFileRecordSegment,
                                       &Bcbs[i*2] );

                    RtlCopyMemory( MftBuffer, Mft2Buffer, Vcb->BytesPerFileRecordSegment );

                    CcSetDirtyPinnedData( Bcbs[i*2], (PLARGE_INTEGER) &LlTemp1 );

                } else {

                    NtfsMarkVolumeDirty( IrpContext, Vcb, FALSE );
                    try_return( Status = STATUS_DISK_CORRUPT_ERROR );
                }
            }
        }

        //
        //  The last file record was the Volume Dasd, so check the version number.
        //

        Attribute = NtfsFirstAttribute(MftBuffer);

        while (TRUE) {

            Attribute = NtfsGetNextRecord(Attribute);

            if (Attribute->TypeCode == $VOLUME_INFORMATION) {

                PVOLUME_INFORMATION VolumeInformation;

                VolumeInformation = (PVOLUME_INFORMATION)NtfsAttributeValue(Attribute);
                VolumeFlags = VolumeInformation->VolumeFlags;

                //
                //  Upgrading the disk on NT 5.0 will use version number 3.0.  Version
                //  number 2.0 was used temporarily when the upgrade was automatic.
                //
                //  NOTE - We use the presence of the version number to indicate
                //  that the first four file records have been validated.  We won't
                //  flush the MftMirror if we can't verify these records.  Otherwise
                //  we might corrupt a valid mirror.
                //

                Vcb->MajorVersion = VolumeInformation->MajorVersion;
                Vcb->MinorVersion = VolumeInformation->MinorVersion;

                if ((Vcb->MajorVersion < 1) || (Vcb->MajorVersion > 3)) {
                    NtfsRaiseStatus( IrpContext, STATUS_WRONG_VOLUME, NULL, NULL );
                }

                if (Vcb->MajorVersion > 1) {

                    CurrentVersion = TRUE;

                    ASSERT( VolumeInformation->MajorVersion != 2 || !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_VOL_UPGR_FAILED ) );

                    if (NtfsDefragMftEnabled) {
                        SetFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_PERMITTED );
                    }
                }

                break;
            }

            if (Attribute->TypeCode == $END) {
                NtfsRaiseStatus( IrpContext, STATUS_WRONG_VOLUME, NULL, NULL );
            }
        }

        //
        //  Create the log file Scb and really look up its size.
        //

        NtfsOpenSystemFile( IrpContext,
                            &Vcb->LogFileScb,
                            Vcb,
                            LOG_FILE_NUMBER,
                            0,
                            $DATA,
                            TRUE );

        Vcb->LogFileObject = Vcb->LogFileScb->FileObject;

        CcSetAdditionalCacheAttributes( Vcb->LogFileScb->FileObject, TRUE, TRUE );

        //
        //  Lookup the log file mapping now, since we will not go to the
        //  disk for allocation information any more once we set restart
        //  in progress.
        //

        (VOID)NtfsPreloadAllocation( IrpContext, Vcb->LogFileScb, 0, MAXLONGLONG );

        //
        //  Now we have to unpin everything before restart, because it generally
        //  has to uninitialize everything.
        //

        NtfsUnpinBcb( IrpContext, &BootBcb );

        for (i = 0; i < 8; i++) {
            NtfsUnpinBcb( IrpContext, &Bcbs[i] );
        }

        NtfsPurgeFileRecordCache( IrpContext );

        //
        //  Purge the Mft, since we only read the first four file
        //  records, not necessarily an entire page!
        //

        CcPurgeCacheSection( &Vcb->MftScb->NonpagedScb->SegmentObject, NULL, 0, FALSE );

        //
        //  Now start up the log file and perform Restart.  This calls will
        //  unpin and remap the Mft Bcb's.  The MftBuffer variables above
        //  may no longer point to the correct range of bytes.  This is OK
        //  if they are never referenced.
        //
        //  Put a try-except around this to catch any restart failures.
        //  This is important in order to allow us to limp along until
        //  autochk gets a chance to run.
        //
        //  We set restart in progress first, to prevent us from looking up any
        //  more run information (now that we know where the log file is!)
        //

        SetFlag(Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS);

        //
        //  See if we are in the retry process due to an earlier failure
        //  in processing the restart area
        //

        RetryRestart = FlagOn( IrpContext->State, IRP_CONTEXT_STATE_BAD_RESTART );

        if (RetryRestart) {

            //
            //  Pass the bad restart info further down the chain
            //  and mark the volume dirty.
            //  We mark the volume dirty on retry because the
            //  dirty bit will not get flush to the disk thru
            //  NtfsRaiseStatus.  Also LFS calls ExRaiseStatus
            //  directly.
            //

            SetFlag( Vcb->VcbState, VCB_STATE_BAD_RESTART );
            NtfsMarkVolumeDirty( IrpContext, Vcb, FALSE );
        }

        try {

            Status = STATUS_SUCCESS;
            UnrecognizedRestart = FALSE;

            NtfsStartLogFile( Vcb->LogFileScb,
                              Vcb );

            //
            //  We call the cache manager again with the stream files for the Mft and
            //  Mft mirror as we didn't have a log handle for the first call.
            //

            CcSetLogHandleForFile( Vcb->MftScb->FileObject,
                                   Vcb->LogHandle,
                                   &LfsFlushToLsn );

            CcSetLogHandleForFile( Vcb->Mft2Scb->FileObject,
                                   Vcb->LogHandle,
                                   &LfsFlushToLsn );

            CloseAttributes = TRUE;

            if (!NtfsIsVolumeReadOnly( Vcb )) {

                UpdatesApplied = NtfsRestartVolume( IrpContext, Vcb, &UnrecognizedRestart );
            }

        //
        //  For right now, we will charge ahead with a dirty volume, no
        //  matter what the exception was.  Later we will have to be
        //  defensive and use a filter.
        //

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            Status = GetExceptionCode();

            if ((Status == STATUS_DISK_CORRUPT_ERROR) ||
                (Status == STATUS_FILE_CORRUPT_ERROR)) {

                //
                //  If this is the first time we hit this error during restart,
                //  we will remember it in the irp context so that we can retry
                //  from the top by raising STATUS_CANT_WAIT.
                //

                if (!RetryRestart) {

                    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_BAD_RESTART );
                    NtfsFailedLfsRestart += 1;
                }
            }

            //
            //  If the error is STATUS_LOG_FILE_FULL then it means that
            //  we couldn't complete the restart.  Mark the volume dirty in
            //  this case.  Don't return this error code.
            //

            if (Status == STATUS_LOG_FILE_FULL) {

                Status = STATUS_DISK_CORRUPT_ERROR;
                IrpContext->ExceptionStatus = STATUS_DISK_CORRUPT_ERROR;
            }
        }

        //
        //  If we hit a corruption exception while processing the
        //  logfile, we need to retry and avoid those errors.
        //

        if (!RetryRestart &&
            FlagOn( IrpContext->State, IRP_CONTEXT_STATE_BAD_RESTART )) {

            IrpContext->ExceptionStatus = STATUS_CANT_WAIT;
            NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
        }

        //
        //  If we hit an error trying to mount this as a readonly volume,
        //  fail the mount. We don't want to do any writes.
        //

        if (Status == STATUS_MEDIA_WRITE_PROTECTED) {

            ASSERT(FlagOn( Vcb->VcbState, VCB_STATE_MOUNT_READ_ONLY ));
            ClearFlag( Vcb->VcbState, VCB_STATE_MOUNT_READ_ONLY );
            try_return( Status );
        }

        //
        //  Mark the volume dirty if we hit an error during restart or if we didn't
        //  recognize the restart area.  In that case also mark the volume dirty but
        //  continue to run.
        //

        if (!NT_SUCCESS( Status ) || UnrecognizedRestart) {

            LONGLONG VolumeDasdOffset;

            NtfsSetAndGetVolumeTimes( IrpContext, Vcb, TRUE, FALSE );

            //
            //  Now flush it out, so chkdsk can see it with Dasd.
            //  Clear the error in the IrpContext so that this
            //  flush will succeed.  Otherwise CommonWrite will
            //  return FILE_LOCK_CONFLICT.
            //

            IrpContext->ExceptionStatus = STATUS_SUCCESS;

            VolumeDasdOffset = VOLUME_DASD_NUMBER << Vcb->MftShift;

            CcFlushCache( &Vcb->MftScb->NonpagedScb->SegmentObject,
                          (PLARGE_INTEGER)&VolumeDasdOffset,
                          Vcb->BytesPerFileRecordSegment,
                          NULL );

            if (!NT_SUCCESS( Status )) {

                try_return( Status );
            }
        }

        //
        //  Now flush the Mft copies, because we are going to shut the real
        //  one down and reopen it for real.
        //

        CcFlushCache( &Vcb->Mft2Scb->NonpagedScb->SegmentObject, NULL, 0, &IoStatus );

        if (NT_SUCCESS( IoStatus.Status )) {
            CcFlushCache( &Vcb->MftScb->NonpagedScb->SegmentObject, NULL, 0, &IoStatus );
        }

        if (!NT_SUCCESS( IoStatus.Status )) {

            NtfsNormalizeAndRaiseStatus( IrpContext,
                                         IoStatus.Status,
                                         STATUS_UNEXPECTED_IO_ERROR );
        }

        //
        //  Show that the restart is complete, and it is safe to go to
        //  the disk for the Mft allocation.
        //

        ClearFlag( Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS );

        //
        //  Set the Mft sizes back down to the part which is guaranteed to
        //  be contiguous for now.  Important on large page size systems!
        //

        Vcb->MftScb->Header.AllocationSize.QuadPart =
        Vcb->MftScb->Header.FileSize.QuadPart =
        Vcb->MftScb->Header.ValidDataLength.QuadPart = FirstNonMirroredCluster << Vcb->ClusterShift;

        //
        //  Pin the first four file records.  We need to lock the pages to
        //  absolutely guarantee they stay in memory, otherwise we may
        //  generate a recursive page fault, forcing MM to block.
        //

        for (i = 0; i < 4; i++) {

            FILE_REFERENCE FileReference;
            ULONG CorruptHint;

            NtfsSetSegmentNumber( &FileReference, 0, i );
            if (i > 0) {
                FileReference.SequenceNumber = (USHORT)i;
            } else {
                FileReference.SequenceNumber = 1;
            }

            NtfsPinStream( IrpContext,
                           Vcb->MftScb,
                           (LONGLONG)(i << Vcb->MftShift),
                           Vcb->BytesPerFileRecordSegment,
                           &Bcbs[i*2],
                           (PVOID *)&MftBuffer );

            Mdls[i*2] = IoAllocateMdl( MftBuffer,
                                       Vcb->BytesPerFileRecordSegment,
                                       FALSE,
                                       FALSE,
                                       NULL );

            //
            //  Verify that we got an Mdl.
            //

            if (Mdls[i*2] == NULL) {

                NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
            }

            MmProbeAndLockPages( Mdls[i*2], KernelMode, IoReadAccess );

            NtfsPinStream( IrpContext,
                           Vcb->Mft2Scb,
                           (LONGLONG)(i << Vcb->MftShift),
                           Vcb->BytesPerFileRecordSegment,
                           &Bcbs[i*2 + 1],
                           &Mft2Buffer );

            Mdls[i*2 + 1] = IoAllocateMdl( Mft2Buffer,
                                           Vcb->BytesPerFileRecordSegment,
                                           FALSE,
                                           FALSE,
                                           NULL );

            //
            //  Verify that we got an Mdl.
            //

            if (Mdls[i*2 + 1] == NULL) {

                NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
            }

            MmProbeAndLockPages( Mdls[i*2 + 1], KernelMode, IoReadAccess );

            //
            //  If any of these file records are bad then try the mirror
            //  (unless we are already looking at the mirror).  If we
            //  can't find a valid record then fail the mount.
            //

            if (!NtfsCheckFileRecord( Vcb, MftBuffer, &FileReference, &CorruptHint )) {

                if ((MftBuffer != Mft2Buffer) &&
                    NtfsCheckFileRecord( Vcb, Mft2Buffer, &FileReference, &CorruptHint )) {

                    LlTemp1 = MAXLONGLONG;

                    //
                    //  Put a BaadSignature in this file record,
                    //  mark it dirty and then read it again.
                    //  The baad signature should force us to bring
                    //  in the mirror and we can correct the problem.
                    //

                    RtlCopyMemory( MftBuffer, Mft2Buffer, Vcb->BytesPerFileRecordSegment );
                    CcSetDirtyPinnedData( Bcbs[i*2], (PLARGE_INTEGER) &LlTemp1 );

                } else {

                    NtfsMarkVolumeDirty( IrpContext, Vcb, FALSE );
                    try_return( Status = STATUS_DISK_CORRUPT_ERROR );
                }
            }
        }

        //
        //  Now we need to uninitialize and purge the Mft and Mft2.  This is
        //  because we could have only a partially filled page at the end, and
        //  we need to do real reads of whole pages now.
        //

        //
        //  Uninitialize and reinitialize the large mcbs so that we can reload
        //  it from the File Record.
        //

        NtfsUnloadNtfsMcbRange( &Vcb->MftScb->Mcb, (LONGLONG) 0, MAXLONGLONG, TRUE, FALSE );
        NtfsUnloadNtfsMcbRange( &Vcb->Mft2Scb->Mcb, (LONGLONG) 0, MAXLONGLONG, TRUE, FALSE );

        //
        //  Mark both of them as uninitialized.
        //

        ClearFlag( Vcb->MftScb->ScbState, SCB_STATE_FILE_SIZE_LOADED );
        ClearFlag( Vcb->Mft2Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED );

        //
        //  We need to deal with a rare case where the Scb for a non-resident attribute
        //  list for the Mft has been created but the size is not correct.  This could
        //  happen if we logged part of the stream but not the whole stream.  In that
        //  case we really want to load the correct numbers into the Scb.  We will need the
        //  full attribute list if we are to look up the allocation for the Mft
        //  immediately after this.
        //

        MftLinks = Vcb->MftScb->Fcb->ScbQueue.Flink;

        while (MftLinks != &Vcb->MftScb->Fcb->ScbQueue) {

            AttributeListScb = CONTAINING_RECORD( MftLinks,
                                                  SCB,
                                                  FcbLinks );

            if (AttributeListScb->AttributeTypeCode == $ATTRIBUTE_LIST) {

                //
                //  Clear the flags so we can reload the information from disk.
                //  Also unload the allocation.  If we have a log record for a
                //  change to the attribute list for the Mft then the allocation
                //  may only be partially loaded.  Looking up the allocation for the
                //  Mft below could easily hit one of the holes.  This way we will
                //  reload all of the allocation.
                //

                NtfsUnloadNtfsMcbRange( &AttributeListScb->Mcb, 0, MAXLONGLONG, TRUE, FALSE );
                ClearFlag( AttributeListScb->ScbState, SCB_STATE_FILE_SIZE_LOADED | SCB_STATE_HEADER_INITIALIZED );
                NtfsUpdateScbFromAttribute( IrpContext, AttributeListScb, NULL );

                //
                //  Let the cache manager know the sizes if this is cached.
                //

                if (AttributeListScb->FileObject != NULL) {

                    CcSetFileSizes( AttributeListScb->FileObject,
                                    (PCC_FILE_SIZES) &AttributeListScb->Header.AllocationSize );
                }

                break;
            }

            MftLinks = MftLinks->Flink;
        }

        //
        //  Now load up the real allocation from just the first file record.
        //

        if (Vcb->FileRecordsPerCluster == 0) {

            NtfsPreloadAllocation( IrpContext,
                                   Vcb->MftScb,
                                   0,
                                   (FIRST_USER_FILE_NUMBER - 1) << Vcb->MftToClusterShift );

        } else {

            NtfsPreloadAllocation( IrpContext,
                                   Vcb->MftScb,
                                   0,
                                   (FIRST_USER_FILE_NUMBER - 1) >> Vcb->MftToClusterShift );
        }

        NtfsPreloadAllocation( IrpContext, Vcb->Mft2Scb, 0, MAXLONGLONG );

        //
        //  We update the Mft and the Mft mirror before we delete the current
        //  stream file for the Mft.  We know we can read the true attributes
        //  for the Mft and the Mirror because we initialized their sizes
        //  above through the first few records in the Mft.
        //

        NtfsUpdateScbFromAttribute( IrpContext, Vcb->MftScb, NULL );

        //
        //  We will attempt to upgrade the version only if this isn't already
        //  a version 2 or 3 volume, the upgrade bit is set, and we aren't
        //  retrying the mount because the upgrade failed last time.
        //  We will always upgrade a new volume
        //

        if ((Vcb->MajorVersion == 1) &&
            !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_VOL_UPGR_FAILED ) &&
           (NtfsForceUpgrade ?
            (!FlagOn( NtfsData.Flags, NTFS_FLAGS_DISABLE_UPGRADE ) ||
             (Vcb->MftScb->Header.FileSize.QuadPart <= FIRST_USER_FILE_NUMBER * Vcb->BytesPerFileRecordSegment))
                                                                        :
            FlagOn( VolumeFlags, VOLUME_UPGRADE_ON_MOUNT ))) {

            //
            //  We can't upgrade R/O volumes, so we can't proceed either.
            //

            if (NtfsIsVolumeReadOnly( Vcb )) {

                Status = STATUS_MEDIA_WRITE_PROTECTED;
                try_return( Status );
            }

            UpgradeVolume = TRUE;
        }

        ClearFlag( Vcb->MftScb->ScbState, SCB_STATE_WRITE_COMPRESSED );
        ClearFlag( Vcb->MftScb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK );

        if (!FlagOn( Vcb->MftScb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

            Vcb->MftScb->CompressionUnit = 0;
            Vcb->MftScb->CompressionUnitShift = 0;
        }

        NtfsUpdateScbFromAttribute( IrpContext, Vcb->Mft2Scb, NULL );
        ClearFlag( Vcb->Mft2Scb->ScbState, SCB_STATE_WRITE_COMPRESSED );
        ClearFlag( Vcb->Mft2Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK );

        if (!FlagOn( Vcb->Mft2Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

            Vcb->Mft2Scb->CompressionUnit = 0;
            Vcb->Mft2Scb->CompressionUnitShift = 0;
        }

        //
        //  Unpin the Bcb's for the Mft files before uninitializing.
        //

        for (i = 0; i < 8; i++) {

            NtfsUnpinBcb( IrpContext, &Bcbs[i] );

            //
            //  Now we can get rid of these Mdls.
            //

            MmUnlockPages( Mdls[i] );
            IoFreeMdl( Mdls[i] );
            Mdls[i] = NULL;
        }

        //
        //  Before we call CcSetAdditionalCacheAttributes to disable write behind,
        //  we need to flush what we can now.
        //

        CcFlushCache( &Vcb->MftScb->NonpagedScb->SegmentObject, NULL, 0, &IoStatus );

        //
        //  Now close and purge the Mft, and recreate its stream so that
        //  the Mft is in a normal state, and we can close the rest of
        //  the attributes from restart.  We need to bump the close count
        //  to keep the scb around while we do this little bit of trickery
        //

        {
            Vcb->MftScb->CloseCount += 1;

            NtfsPurgeFileRecordCache( IrpContext );

            NtfsDeleteInternalAttributeStream( Vcb->MftScb, TRUE, FALSE );

            NtfsCreateInternalAttributeStream( IrpContext,
                                               Vcb->MftScb,
                                               FALSE,
                                               &NtfsSystemFiles[MASTER_FILE_TABLE_NUMBER] );

            //
            //  Tell the cache manager the file sizes for the MFT.  It is possible
            //  that the shared cache map did not go away on the DeleteInternalAttributeStream
            //  call above.  In that case the Cache Manager has the file sizes from
            //  restart.
            //

            CcSetFileSizes( Vcb->MftScb->FileObject,
                            (PCC_FILE_SIZES) &Vcb->MftScb->Header.AllocationSize );

            CcSetAdditionalCacheAttributes( Vcb->MftScb->FileObject, TRUE, FALSE );

            Vcb->MftScb->CloseCount -= 1;
        }

        //
        //  We want to read all of the file records for the Mft to put
        //  its complete mapping into the Mcb.
        //

        SetFlag( Vcb->VcbState, VCB_STATE_PRELOAD_MFT );
        NtfsPreloadAllocation( IrpContext, Vcb->MftScb, 0, MAXLONGLONG );
        ClearFlag( Vcb->VcbState, VCB_STATE_PRELOAD_MFT );

        //
        //  Close the boot file (get rid of it because we do not know its proper
        //  size, and the Scb may be inconsistent).
        //

        NtfsDeleteInternalAttributeStream( BootScb, TRUE, FALSE );
        BootScb = NULL;

        //
        //  Closing the attributes from restart has to occur here after
        //  the Mft is clean, because flushing these files will cause
        //  file size updates to occur, etc.
        //

        Status = NtfsCloseAttributesFromRestart( IrpContext, Vcb );
        CloseAttributes = FALSE;

        if (!NT_SUCCESS( Status )) {

            NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
        }

        //
        //  The CHECKPOINT flags function the same way whether the volume is mounted
        //  read-only or not. We just ignore the actual checkpointing process.
        //

        NtfsAcquireCheckpoint( IrpContext, Vcb );

        //
        //  Show that it is ok to checkpoint now.
        //

        ClearFlag( Vcb->CheckpointFlags, VCB_CHECKPOINT_SYNC_FLAGS | VCB_LAST_CHECKPOINT_CLEAN );

        //
        //  Clear the flag indicating that we won't defrag the volume.
        //

        ClearFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_ENABLED );

        NtfsSetCheckpointNotify( IrpContext, Vcb );
        NtfsReleaseCheckpoint( IrpContext, Vcb );

        //
        //  We always need to write a checkpoint record so that we have
        //  a checkpoint on the disk before we modify any files.
        //

        NtfsCheckpointVolume( IrpContext,
                              Vcb,
                              FALSE,
                              UpdatesApplied,
                              UpdatesApplied,
                              0,
                              Vcb->LastRestartArea );

        //
        //  Now set the defrag enabled flag.
        //

        NtfsAcquireCheckpoint( IrpContext, Vcb );
        SetFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_ENABLED );
        NtfsReleaseCheckpoint( IrpContext, Vcb );

/*      Format is using wrong attribute definitions

        //
        //  At this point we are ready to use the volume normally.  We could
        //  open the remaining system files by name, but for now we will go
        //  ahead and open them by file number.
        //

        NtfsOpenSystemFile( IrpContext,
                            &Vcb->AttributeDefTableScb,
                            Vcb,
                            ATTRIBUTE_DEF_TABLE_NUMBER,
                            0,
                            $DATA,
                            FALSE );

        //
        //  Read in the attribute definitions.
        //

        {
            IO_STATUS_BLOCK IoStatus;
            PSCB Scb = Vcb->AttributeDefTableScb;

            if ((Scb->Header.FileSize.HighPart != 0) || (Scb->Header.FileSize.LowPart == 0)) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            Vcb->AttributeDefinitions = NtfsAllocatePool(PagedPool, Scb->Header.FileSize.LowPart );

            CcCopyRead( Scb->FileObject,
                        &Li0,
                        Scb->Header.FileSize.LowPart,
                        TRUE,
                        Vcb->AttributeDefinitions,
                        &IoStatus );

            if (!NT_SUCCESS(IoStatus.Status)) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }
        }
*/
        //
        //  Just point to our own attribute definitions for now.
        //

        Vcb->AttributeDefinitions = NtfsAttributeDefinitions;

        //
        //  Open the upcase table.
        //

        NtfsOpenSystemFile( IrpContext,
                            &Vcb->UpcaseTableScb,
                            Vcb,
                            UPCASE_TABLE_NUMBER,
                            0,
                            $DATA,
                            FALSE );

        //
        //  Read in the upcase table.
        //

        {
            IO_STATUS_BLOCK IoStatus;
            PSCB Scb = Vcb->UpcaseTableScb;

            if ((Scb->Header.FileSize.HighPart != 0) || (Scb->Header.FileSize.LowPart < 512)) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            Vcb->UpcaseTable = NtfsAllocatePool(PagedPool, Scb->Header.FileSize.LowPart );
            Vcb->UpcaseTableSize = Scb->Header.FileSize.LowPart / sizeof( WCHAR );

            CcCopyRead( Scb->FileObject,
                        &Li0,
                        Scb->Header.FileSize.LowPart,
                        TRUE,
                        Vcb->UpcaseTable,
                        &IoStatus );

            if (!NT_SUCCESS(IoStatus.Status)) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            //
            //  If we do not have a global upcase table yet then make this one the global one
            //

            if (NtfsData.UpcaseTable == NULL) {

                NtfsData.UpcaseTable = Vcb->UpcaseTable;
                NtfsData.UpcaseTableSize = Vcb->UpcaseTableSize;

            //
            //  Otherwise if this one perfectly matches the global upcase table then throw
            //  this one back and use the global one
            //

            } else if ((NtfsData.UpcaseTableSize == Vcb->UpcaseTableSize)

                            &&

                       (RtlCompareMemory( NtfsData.UpcaseTable,
                                          Vcb->UpcaseTable,
                                          Vcb->UpcaseTableSize) == Vcb->UpcaseTableSize)) {

                NtfsFreePool( Vcb->UpcaseTable );
                Vcb->UpcaseTable = NtfsData.UpcaseTable;
            }
        }

        NtfsOpenSystemFile( IrpContext,
                            &Vcb->BitmapScb,
                            Vcb,
                            BIT_MAP_FILE_NUMBER,
                            0,
                            $DATA,
                            TRUE );

        NtfsOpenSystemFile( IrpContext,
                            &Vcb->BadClusterFileScb,
                            Vcb,
                            BAD_CLUSTER_FILE_NUMBER,
                            0,
                            $DATA,
                            TRUE );

        NtfsOpenSystemFile( IrpContext,
                            &Vcb->MftBitmapScb,
                            Vcb,
                            MASTER_FILE_TABLE_NUMBER,
                            0,
                            $BITMAP,
                            TRUE );

        //
        //  Initialize the bitmap support
        //

        NtfsInitializeClusterAllocation( IrpContext, Vcb );

        NtfsSetAndGetVolumeTimes( IrpContext, Vcb, FALSE, TRUE );

        //
        //  Initialize the Mft record allocation
        //

        {
            ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
            BOOLEAN FoundAttribute;
            ULONG ExtendGranularity;

            //
            //  Lookup the bitmap allocation for the Mft file.
            //

            NtfsInitializeAttributeContext( &AttrContext );

            //
            //  Use a try finally to cleanup the attribute context.
            //

            try {

                //
                //  CODENOTE    Is the Mft Fcb fully initialized at this point??
                //

                FoundAttribute = NtfsLookupAttributeByCode( IrpContext,
                                                            Vcb->MftScb->Fcb,
                                                            &Vcb->MftScb->Fcb->FileReference,
                                                            $BITMAP,
                                                            &AttrContext );
                //
                //  Error if we don't find the bitmap
                //

                if (!FoundAttribute) {

                    DebugTrace( 0, 0, ("Couldn't find bitmap attribute for Mft\n") );

                    NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
                }

                //
                //  If there is no file object for the Mft Scb, we create it now.
                //

                if (Vcb->MftScb->FileObject == NULL) {

                    NtfsCreateInternalAttributeStream( IrpContext, Vcb->MftScb, TRUE, NULL );
                }

                //
                //  TEMPCODE    We need a better way to determine the optimal
                //              truncate and extend granularity.
                //

                ExtendGranularity = MFT_EXTEND_GRANULARITY;

                if ((ExtendGranularity * Vcb->BytesPerFileRecordSegment) < Vcb->BytesPerCluster) {

                    ExtendGranularity = Vcb->FileRecordsPerCluster;
                }

                NtfsInitializeRecordAllocation( IrpContext,
                                                Vcb->MftScb,
                                                &AttrContext,
                                                Vcb->BytesPerFileRecordSegment,
                                                ExtendGranularity,
                                                ExtendGranularity,
                                                &Vcb->MftScb->ScbType.Index.RecordAllocationContext );

            } finally {

                NtfsCleanupAttributeContext( IrpContext, &AttrContext );
            }
        }

        //
        //  Get the serial number and volume label for the volume
        //

        NtfsGetVolumeInformation( IrpContext, Vpb, Vcb, &VolumeFlags );

        //
        //  Get the Device Name for this volume.
        //

        Status = ObQueryNameString( Vpb->RealDevice,
                                    NULL,
                                    0,
                                    &DeviceObjectNameLength );

        ASSERT( Status != STATUS_SUCCESS );

        //
        //  Unlike the rest of the system, ObQueryNameString returns
        //  STATUS_INFO_LENGTH_MISMATCH instead of STATUS_BUFFER_TOO_SMALL when
        //  passed too small a buffer.
        //
        //  We expect to get this error here.  Anything else we can't handle.
        //

        if (Status == STATUS_INFO_LENGTH_MISMATCH) {

            DeviceObjectName = NtfsAllocatePool( PagedPool, DeviceObjectNameLength );

            Status = ObQueryNameString( Vpb->RealDevice,
                                        DeviceObjectName,
                                        DeviceObjectNameLength,
                                        &DeviceObjectNameLength );
        }

        if (!NT_SUCCESS( Status )) {

            try_return( NOTHING );
        }

        //
        //  Now that we are successfully mounting, let us see if we should
        //  enable balanced reads.
        //

        if (!FlagOn(Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED_DIRTY)) {

            FsRtlBalanceReads( DeviceObjectWeTalkTo );
        }

        ASSERT( DeviceObjectName->Name.Length != 0 );

        Vcb->DeviceName.MaximumLength =
        Vcb->DeviceName.Length = DeviceObjectName->Name.Length;

        Vcb->DeviceName.Buffer = NtfsAllocatePool( PagedPool, DeviceObjectName->Name.Length );

        RtlCopyMemory( Vcb->DeviceName.Buffer,
                       DeviceObjectName->Name.Buffer,
                       DeviceObjectName->Name.Length );

        //
        //  Now we want to initialize the remaining defrag status values.
        //

        Vcb->MftHoleGranularity = MFT_HOLE_GRANULARITY;
        Vcb->MftClustersPerHole = Vcb->MftHoleGranularity << Vcb->MftToClusterShift;

        if (MFT_HOLE_GRANULARITY < Vcb->FileRecordsPerCluster) {

            Vcb->MftHoleGranularity = Vcb->FileRecordsPerCluster;
            Vcb->MftClustersPerHole = 1;
        }

        Vcb->MftHoleMask = Vcb->MftHoleGranularity - 1;
        Vcb->MftHoleInverseMask = ~(Vcb->MftHoleMask);

        Vcb->MftHoleClusterMask = Vcb->MftClustersPerHole - 1;
        Vcb->MftHoleClusterInverseMask = ~(Vcb->MftHoleClusterMask);

        //
        //  Our maximum reserved Mft space is 0x140, we will try to
        //  get an extra 40 bytes if possible.
        //

        Vcb->MftReserved = Vcb->BytesPerFileRecordSegment / 8;

        if (Vcb->MftReserved > 0x140) {

            Vcb->MftReserved = 0x140;
        }

        Vcb->MftCushion = Vcb->MftReserved - 0x20;

        NtfsScanMftBitmap( IrpContext, Vcb );

#ifdef NTFS_CHECK_BITMAP
        {
            ULONG BitmapSize;
            ULONG Count;

            BitmapSize = Vcb->BitmapScb->Header.FileSize.LowPart;

            //
            //  Allocate a buffer for the bitmap copy and each individual bitmap.
            //

            Vcb->BitmapPages = (BitmapSize + PAGE_SIZE - 1) / PAGE_SIZE;

            Vcb->BitmapCopy = NtfsAllocatePool(PagedPool, Vcb->BitmapPages * sizeof( RTL_BITMAP ));
            RtlZeroMemory( Vcb->BitmapCopy, Vcb->BitmapPages * sizeof( RTL_BITMAP ));

            //
            //  Now get a buffer for each page.
            //

            for (Count = 0; Count < Vcb->BitmapPages; Count += 1) {

                (Vcb->BitmapCopy + Count)->Buffer = NtfsAllocatePool(PagedPool, PAGE_SIZE );
                RtlInitializeBitMap( Vcb->BitmapCopy + Count, (Vcb->BitmapCopy + Count)->Buffer, PAGE_SIZE * 8 );
            }

            if (NtfsCopyBitmap) {

                PUCHAR NextPage;
                PBCB BitmapBcb = NULL;
                ULONG BytesToCopy;
                LONGLONG FileOffset = 0;

                Count = 0;

                while (BitmapSize) {

                    BytesToCopy = PAGE_SIZE;

                    if (BytesToCopy > BitmapSize) {

                        BytesToCopy = BitmapSize;
                    }

                    NtfsUnpinBcb( IrpContext, &BitmapBcb );

                    NtfsMapStream( IrpContext, Vcb->BitmapScb, FileOffset, BytesToCopy, &BitmapBcb, &NextPage );

                    RtlCopyMemory( (Vcb->BitmapCopy + Count)->Buffer,
                                   NextPage,
                                   BytesToCopy );

                    BitmapSize -= BytesToCopy;
                    FileOffset += BytesToCopy;
                    Count += 1;
                }

                NtfsUnpinBcb( IrpContext, &BitmapBcb );

            //
            //  Otherwise we will want to scan the entire Mft and compare the mapping pairs
            //  with the current volume bitmap.
            //

            }
        }
#endif

        //
        //  Whether this was already an upgraded volume or we want it to
        //  be one now, we need to open all the new indices.
        //

        if ((CurrentVersion || UpgradeVolume) &&
            !SkipNtOfs) {

            BOOLEAN UpdatedVolumeVersion = FALSE;

            try {

                //
                //  Create/open the security file and initialize security on the volume.
                //

                NtfsInitializeSecurityFile( IrpContext, Vcb );

                //
                //  Open the Root Directory.
                //

                NtfsOpenRootDirectory( IrpContext, Vcb );

                //
                //  Create/open the $Extend directory.
                //

                NtfsInitializeExtendDirectory( IrpContext, Vcb );

                //
                //  Create/open the Quota File and initialize quotas.
                //

                NtfsInitializeQuotaFile( IrpContext, Vcb );

                //
                //  Create/open the Object Id File and initialize object ids.
                //

                NtfsInitializeObjectIdFile( IrpContext, Vcb );

                //
                //  Create/open the Mount Points File and initialize it.
                //

                NtfsInitializeReparseFile( IrpContext, Vcb );

                //
                //  Open the Usn Journal only if it is there.  If the volume was mounted
                //  on a 4.0 system then we want to restamp the journal.  Skip the
                //  initialization if the volume flags indicate that the journal
                //  delete has started.
                //  No USN journal if we're mounting Read Only.
                //

                if (FlagOn( VolumeFlags, VOLUME_DELETE_USN_UNDERWAY )) {

                    SetFlag( Vcb->VcbState, VCB_STATE_USN_DELETE );

                } else if (!NtfsIsVolumeReadOnly( Vcb )) {

                    NtfsInitializeUsnJournal( IrpContext,
                                              Vcb,
                                              FALSE,
                                              FlagOn( VolumeFlags, VOLUME_MOUNTED_ON_40 ),
                                              (PCREATE_USN_JOURNAL_DATA) &Vcb->UsnJournalInstance.MaximumSize );

                    if (FlagOn( VolumeFlags, VOLUME_MOUNTED_ON_40 )) {

                        NtfsSetVolumeInfoFlagState( IrpContext,
                                                    Vcb,
                                                    VOLUME_MOUNTED_ON_40,
                                                    FALSE,
                                                    TRUE );
                    }
                }

                //
                //  Upgrade all security information
                //

                NtfsUpgradeSecurity( IrpContext, Vcb );

                //
                //  If we haven't opened the root directory, do so
                //

                if (Vcb->RootIndexScb == NULL) {
                    NtfsOpenRootDirectory( IrpContext, Vcb );
                }

                NtfsCleanupTransaction( IrpContext, STATUS_SUCCESS, FALSE );

                //
                //  Update version numbers in volinfo
                //

                if (!NtfsIsVolumeReadOnly( Vcb )) {
                    UpdatedVolumeVersion = NtfsUpdateVolumeInfo( IrpContext, Vcb, NTFS_MAJOR_VERSION, NTFS_MINOR_VERSION );
                }

                //
                //  If we've gotten this far during the mount, it's safe to
                //  update the version number on disk if necessary.
                //

                if (UpgradeVolume) {

                    //
                    //  Now enable defragging.
                    //

                    if (NtfsDefragMftEnabled) {

                        NtfsAcquireCheckpoint( IrpContext, Vcb );
                        SetFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_PERMITTED );
                        NtfsReleaseCheckpoint( IrpContext, Vcb );
                    }

                    //
                    //  Update the on-disk attribute definition table to include the
                    //  new attributes for an upgraded volume.
                    //

                    NtfsUpdateAttributeTable( IrpContext, Vcb );
                }

            } finally {

                if (!NT_SUCCESS( IrpContext->ExceptionStatus ) && UpgradeVolume) {
                    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_VOL_UPGR_FAILED );
                }
            }

            if (UpdatedVolumeVersion) {

                //
                //  If we've upgraded successfully, we should clear the upgrade
                //  bit now so we can use it again in the future.
                //

                NtfsSetVolumeInfoFlagState( IrpContext,
                                            Vcb,
                                            VOLUME_UPGRADE_ON_MOUNT,
                                            FALSE,
                                            TRUE );
            }

        } else {

            //
            //  If we haven't opened the root directory, do so
            //

            if (Vcb->RootIndexScb == NULL) {
                NtfsOpenRootDirectory( IrpContext, Vcb );
            }

            NtfsCleanupTransaction( IrpContext, STATUS_SUCCESS, FALSE );
        }

        //
        //  Start the usn journal delete operation if the vcb flag is specified.
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_USN_DELETE )) {

            NtfsPostSpecial( IrpContext, Vcb, NtfsDeleteUsnSpecial, &Vcb->DeleteUsnData );
        }

        //
        //  If the last mount was on a 4.0 volume then we need to clean up the quota
        //  and object id indices.
        //

        if ((Vcb->MajorVersion >= 3) &&
            FlagOn( VolumeFlags, VOLUME_MOUNTED_ON_40 )) {

            NtfsSetVolumeInfoFlagState( IrpContext,
                                        Vcb,
                                        VOLUME_REPAIR_OBJECT_ID,
                                        TRUE,
                                        TRUE );

            SetFlag( VolumeFlags, VOLUME_REPAIR_OBJECT_ID );

            //
            //  Fire off the quota cleanup if quotas are enabled.
            //

            if (FlagOn( Vcb->QuotaFlags, (QUOTA_FLAG_TRACKING_REQUESTED |
                                      QUOTA_FLAG_TRACKING_ENABLED |
                                      QUOTA_FLAG_ENFORCEMENT_ENABLED ))) {

                NtfsMarkQuotaCorrupt( IrpContext, Vcb );
            }
        }

        //
        //  Start the object ID cleanup if we were mounted on 4.0 or had started
        //  in a previous mount.
        //

        if (FlagOn( VolumeFlags, VOLUME_REPAIR_OBJECT_ID )) {

            NtfsPostSpecial( IrpContext, Vcb, NtfsRepairObjectId, NULL );
        }

        //
        //  Clear the MOUNTED_ON_40 and CHKDSK_MODIFIED flags if set.
        //

        if (FlagOn( VolumeFlags, VOLUME_MOUNTED_ON_40 | VOLUME_MODIFIED_BY_CHKDSK )) {

            NtfsSetVolumeInfoFlagState( IrpContext,
                                        Vcb,
                                        VOLUME_MOUNTED_ON_40 | VOLUME_MODIFIED_BY_CHKDSK,
                                        FALSE,
                                        TRUE );
        }

        //
        //  Looks like this mount will succeed.  Remember the root directory fileobject
        //  so we can use it for the notification later.
        //

        RootDirFileObject = Vcb->RootIndexScb->FileObject;

        //
        //  Dereference the root file object if present.  The absence of this doesn't
        //  indicate whether the volume was upgraded.  Older 4K Mft records can contain
        //  all of the new streams.
        //

        if (RootDirFileObject != NULL) {

            ObReferenceObject( RootDirFileObject );
        }

        //
        //
        //  Set our return status and say that the mount succeeded
        //

        Status = STATUS_SUCCESS;
        MountFailed = FALSE;
        SetFlag( Vcb->VcbState, VCB_STATE_MOUNT_COMPLETED );

#ifdef SYSCACHE_DEBUG
        if (!NtfsIsVolumeReadOnly( Vcb ) && !NtfsDisableSyscacheLogFile) {
            NtfsInitializeSyscacheLogFile( IrpContext, Vcb );
        }
#endif


    try_exit: NOTHING;
    } finally {

        DebugUnwind( NtfsMountVolume );

        NtfsUnpinBcb( IrpContext, &BootBcb );

        if (DeviceObjectName != NULL) {

            NtfsFreePool( DeviceObjectName );
        }

        if (CloseAttributes) { NtfsCloseAttributesFromRestart( IrpContext, Vcb ); }

        for (i = 0; i < 8; i++) {

            NtfsUnpinBcb( IrpContext, &Bcbs[i] );

            //
            //  Get rid of the Mdls, if we haven't already.
            //

            if (Mdls[i] != NULL) {

                if (FlagOn(Mdls[i]->MdlFlags, MDL_PAGES_LOCKED )) {
                    MmUnlockPages( Mdls[i] );
                }
                IoFreeMdl( Mdls[i] );
                Mdls[i] = NULL;
            }
        }

        if (BootScb != NULL) {  NtfsDeleteInternalAttributeStream( BootScb, TRUE, FALSE ); }

        if (Vcb != NULL) {

            if (Vcb->MftScb != NULL)               { NtfsReleaseScb( IrpContext, Vcb->MftScb ); }
            if (Vcb->Mft2Scb != NULL)              { NtfsReleaseScb( IrpContext, Vcb->Mft2Scb ); }
            if (Vcb->LogFileScb != NULL)           { NtfsReleaseScb( IrpContext, Vcb->LogFileScb ); }
            if (Vcb->VolumeDasdScb != NULL)        { NtfsReleaseScb( IrpContext, Vcb->VolumeDasdScb ); }
            if (Vcb->AttributeDefTableScb != NULL) { NtfsReleaseScb( IrpContext, Vcb->AttributeDefTableScb );
                                                     NtfsDeleteInternalAttributeStream( Vcb->AttributeDefTableScb, TRUE, FALSE );
                                                     Vcb->AttributeDefTableScb = NULL;}
            if (Vcb->UpcaseTableScb != NULL)       { NtfsReleaseScb( IrpContext, Vcb->UpcaseTableScb );
                                                     NtfsDeleteInternalAttributeStream( Vcb->UpcaseTableScb, TRUE, FALSE );
                                                     Vcb->UpcaseTableScb = NULL;}
            if (Vcb->RootIndexScb != NULL)         { NtfsReleaseScb( IrpContext, Vcb->RootIndexScb ); }
            if (Vcb->BitmapScb != NULL)            { NtfsReleaseScb( IrpContext, Vcb->BitmapScb ); }
            if (Vcb->BadClusterFileScb != NULL)    { NtfsReleaseScb( IrpContext, Vcb->BadClusterFileScb ); }
            if (Vcb->MftBitmapScb != NULL)         { NtfsReleaseScb( IrpContext, Vcb->MftBitmapScb ); }

            //
            //  Drop the security  data
            //

            if (Vcb->SecurityDescriptorStream != NULL) { NtfsReleaseScb( IrpContext, Vcb->SecurityDescriptorStream ); }
            if (Vcb->UsnJournal != NULL) { NtfsReleaseScb( IrpContext, Vcb->UsnJournal ); }
            if (Vcb->ExtendDirectory != NULL) { NtfsReleaseScb( IrpContext, Vcb->ExtendDirectory ); }
            if (QuotaDataScb != NULL) {
                NtfsReleaseScb( IrpContext, QuotaDataScb );
                NtfsDeleteInternalAttributeStream( QuotaDataScb, TRUE, FALSE );
            }

            if (MountFailed) {

                PVPB NewVpb;

                NtfsPerformDismountOnVcb( IrpContext, Vcb, TRUE, &NewVpb );

                //
                //  If the version upgrade failed, we will be coming back in here soon
                //  and we need to have the right vpb when we do.  This is true if the
                //  upgrade failed or if we are processing a log file full condition.
                //

                if ((FlagOn( IrpContext->State, IRP_CONTEXT_STATE_VOL_UPGR_FAILED ) ||
                     (IrpContext->TopLevelIrpContext->ExceptionStatus == STATUS_LOG_FILE_FULL) ||
                     (IrpContext->TopLevelIrpContext->ExceptionStatus == STATUS_CANT_WAIT)) &&

                    (NewVpb != NULL)) {

                    IrpSp->Parameters.MountVolume.Vpb = NewVpb;
                }

                //
                //  On abnormal termination, someone will try to abort a transaction on
                //  this Vcb if we do not clear these fields.
                //

                IrpContext->TransactionId = 0;
                IrpContext->Vcb = NULL;
            }
        }

        if (VcbAcquired) {

            NtfsReleaseVcbCheckDelete( IrpContext, Vcb, IRP_MJ_FILE_SYSTEM_CONTROL, NULL );
        }

        NtfsReleaseGlobal( IrpContext );
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );

    if (RootDirFileObject != NULL) {

        FsRtlNotifyVolumeEvent( RootDirFileObject, FSRTL_VOLUME_MOUNT );
        ObDereferenceObject( RootDirFileObject );
    }

    if (NT_SUCCESS( Status )) {

        //
        //  Remove the extra object reference to the target device object
        //  because I/O system has already made one for this mount.
        //

        ObDereferenceObject( Vcb->TargetDeviceObject );
    }

    DebugTrace( -1, Dbg, ("NtfsMountVolume -> %08lx\n", Status) );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsUpdateAttributeTable (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine updates the on-disk attribute definition table.

Arguments:

    Vcb - Supplies the Vcb whose attribute table should be updated.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    PATTRIBUTE_DEFINITION_COLUMNS AttrDefs = NULL;
    PFCB AttributeTableFcb;
    BOOLEAN FoundAttribute;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );
    ASSERT( Vcb->AttributeDefTableScb == NULL );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsUpdateAttributeTable\n") );

    NtfsOpenSystemFile( IrpContext,
                        &Vcb->AttributeDefTableScb,
                        Vcb,
                        ATTRIBUTE_DEF_TABLE_NUMBER,
                        0,
                        $DATA,
                        FALSE );

    AttributeTableFcb = Vcb->AttributeDefTableScb->Fcb;

    NtfsInitializeAttributeContext( &AttrContext );

    try {

        //
        //  First, we find and delete the old attribute definition table.
        //

        FoundAttribute = NtfsLookupAttributeByCode( IrpContext,
                                                    AttributeTableFcb,
                                                    &AttributeTableFcb->FileReference,
                                                    $DATA,
                                                    &AttrContext );

        if (!FoundAttribute) {

            try_return( Status = STATUS_DISK_CORRUPT_ERROR );
        }

        NtfsDeleteAttributeRecord( IrpContext,
                                   AttributeTableFcb,
                                   DELETE_LOG_OPERATION | DELETE_RELEASE_ALLOCATION,
                                   &AttrContext );

        //
        //  Now we write the current attribute definition table to disk.
        //

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        NtfsInitializeAttributeContext( &AttrContext );

        //
        //  chkdsk for whistler doesn't recognize the attribute table in its current state
        //  so munge it so it does - move the last entry $EFS into the unused piece of the
        //  table 0xF0
        //

        AttrDefs = NtfsAllocatePool( PagedPool, sizeof( ATTRIBUTE_DEFINITION_COLUMNS ) * NtfsAttributeDefinitionsCount );
        RtlCopyMemory( AttrDefs, NtfsAttributeDefinitions, sizeof( ATTRIBUTE_DEFINITION_COLUMNS ) * NtfsAttributeDefinitionsCount );
        RtlMoveMemory( &AttrDefs[ NtfsAttributeDefinitionsCount - 3], &AttrDefs[ NtfsAttributeDefinitionsCount - 2], sizeof( ATTRIBUTE_DEFINITION_COLUMNS ) * 2);

        NtfsCreateAttributeWithValue( IrpContext,
                                      AttributeTableFcb,
                                      $DATA,
                                      NULL,
                                      AttrDefs,
                                      (NtfsAttributeDefinitionsCount - 1) * sizeof(*NtfsAttributeDefinitions),
                                      0,
                                      NULL,
                                      TRUE,
                                      &AttrContext );

    try_exit: NOTHING;
    } finally {

        if (AttrDefs != NULL) {
            NtfsFreePool( AttrDefs );
        }

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsUpdateAttributeTable -> %08lx\n", Status) );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsVerifyVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the verify volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsVerifyVolume\n") );

    //
    //  Do nothing for now
    //

    KdPrint(("NtfsVerifyVolume is not yet implemented\n")); //**** DbgBreakPoint();

    NtfsCompleteRequest( IrpContext, Irp, Status = STATUS_NOT_IMPLEMENTED );

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsVerifyVolume -> %08lx\n", Status) );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsUserFsRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for implementing the user's requests made
    through NtFsControlFile.

Arguments:

    Irp - Supplies the Irp being processed

    Wait - Indicates if the thread can block for a resource or I/O

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    ULONG FsControlCode;
    PIO_STACK_LOCATION IrpSp;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    //
    //  Get the current Irp stack location, and save some references
    //  to make our life a little easier.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    DebugTrace( +1, Dbg, ("NtfsUserFsRequest, FsControlCode = %08lx\n", FsControlCode) );

    //
    //  Case on the control code.
    //

    switch ( FsControlCode ) {

    case FSCTL_REQUEST_OPLOCK_LEVEL_1:
    case FSCTL_REQUEST_OPLOCK_LEVEL_2:
    case FSCTL_REQUEST_BATCH_OPLOCK:
    case FSCTL_REQUEST_FILTER_OPLOCK:
    case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
    case FSCTL_OPLOCK_BREAK_NOTIFY:
    case FSCTL_OPBATCH_ACK_CLOSE_PENDING :
    case FSCTL_OPLOCK_BREAK_ACK_NO_2:

        Status = NtfsOplockRequest( IrpContext, Irp );
        break;

    case FSCTL_LOCK_VOLUME:

        Status = NtfsLockVolume( IrpContext, Irp );
        break;

    case FSCTL_UNLOCK_VOLUME:

        Status = NtfsUnlockVolume( IrpContext, Irp );
        break;

    case FSCTL_DISMOUNT_VOLUME:

        Status = NtfsDismountVolume( IrpContext, Irp );
        break;

    case FSCTL_IS_VOLUME_MOUNTED:

        Status = NtfsIsVolumeMounted( IrpContext, Irp );
        break;

    case FSCTL_MARK_VOLUME_DIRTY:

        Status = NtfsDirtyVolume( IrpContext, Irp );
        break;

    case FSCTL_IS_PATHNAME_VALID:

        //
        //  All names are potentially valid NTFS names
        //

        NtfsCompleteRequest( IrpContext, Irp, Status = STATUS_SUCCESS );
        break;

    case FSCTL_QUERY_RETRIEVAL_POINTERS:
        Status = NtfsQueryRetrievalPointers( IrpContext, Irp );
        break;

    case FSCTL_GET_COMPRESSION:
        Status = NtfsGetCompression( IrpContext, Irp );
        break;

    case FSCTL_SET_COMPRESSION:

        //
        //  Post this request if we can't wait.
        //

        if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )) {

            Status = NtfsPostRequest( IrpContext, Irp );

        } else {

            Status = NtfsSetCompression( IrpContext, Irp );
        }

        break;

    case FSCTL_MARK_AS_SYSTEM_HIVE:
        Status = NtfsMarkAsSystemHive( IrpContext, Irp );
        break;

    case FSCTL_FILESYSTEM_GET_STATISTICS:
        Status = NtfsGetStatistics( IrpContext, Irp );
        break;

    case FSCTL_GET_NTFS_VOLUME_DATA:
        Status = NtfsGetVolumeData( IrpContext, Irp );
        break;

    case FSCTL_GET_VOLUME_BITMAP:
        Status = NtfsGetVolumeBitmap( IrpContext, Irp );
        break;

    case FSCTL_GET_RETRIEVAL_POINTERS:
        Status = NtfsGetRetrievalPointers( IrpContext, Irp );
        break;

    case FSCTL_GET_NTFS_FILE_RECORD:
        Status = NtfsGetMftRecord( IrpContext, Irp );
        break;

    case FSCTL_MOVE_FILE:
        Status = NtfsDefragFile( IrpContext, Irp );
        break;

    case FSCTL_IS_VOLUME_DIRTY:
        Status = NtfsIsVolumeDirty( IrpContext, Irp );
        break;

    case FSCTL_ALLOW_EXTENDED_DASD_IO:
        Status = NtfsSetExtendedDasdIo( IrpContext, Irp );
        break;

    case FSCTL_SET_REPARSE_POINT:
        Status = NtfsSetReparsePoint( IrpContext, Irp );
        break;

    case FSCTL_GET_REPARSE_POINT:
        Status = NtfsGetReparsePoint( IrpContext, Irp );
        break;

    case FSCTL_DELETE_REPARSE_POINT:
        Status = NtfsDeleteReparsePoint( IrpContext, Irp );
        break;

    case FSCTL_SET_OBJECT_ID:
        Status = NtfsSetObjectId( IrpContext, Irp );                // In ObjIdSup.c
        break;

    case FSCTL_GET_OBJECT_ID:
        Status = NtfsGetObjectId( IrpContext, Irp );                // In ObjIdSup.c
        break;

    case FSCTL_DELETE_OBJECT_ID:
        Status = NtfsDeleteObjectId( IrpContext, Irp );             // In ObjIdSup.c
        break;

    case FSCTL_SET_OBJECT_ID_EXTENDED:
        Status = NtfsSetObjectIdExtendedInfo( IrpContext, Irp );    // In ObjIdSup.c
        break;

    case FSCTL_CREATE_OR_GET_OBJECT_ID:
        Status = NtfsCreateOrGetObjectId( IrpContext, Irp );
        break;

    case FSCTL_READ_USN_JOURNAL:
        Status = NtfsReadUsnJournal( IrpContext, Irp, TRUE );     //  In UsnSup.c
        break;

    case FSCTL_CREATE_USN_JOURNAL:
        Status = NtfsCreateUsnJournal( IrpContext, Irp );
        break;

    case FSCTL_ENUM_USN_DATA:
        Status = NtfsReadFileRecordUsnData( IrpContext, Irp );
        break;

    case FSCTL_READ_FILE_USN_DATA:
        Status = NtfsReadFileUsnData( IrpContext, Irp );
        break;

    case FSCTL_WRITE_USN_CLOSE_RECORD:
        Status = NtfsWriteUsnCloseRecord( IrpContext, Irp );
        break;

    case FSCTL_QUERY_USN_JOURNAL:
        Status = NtfsQueryUsnJournal( IrpContext, Irp );
        break;

    case FSCTL_DELETE_USN_JOURNAL:
        Status = NtfsDeleteUsnJournal( IrpContext, Irp );
        break;

    case FSCTL_MARK_HANDLE:
        Status = NtfsMarkHandle( IrpContext, Irp );
        break;

    case FSCTL_SECURITY_ID_CHECK:
        Status = NtfsBulkSecurityIdCheck( IrpContext, Irp );
        break;

    case FSCTL_FIND_FILES_BY_SID:
        Status = NtfsFindFilesOwnedBySid( IrpContext, Irp );
        break;

    case FSCTL_SET_SPARSE :
        Status = NtfsSetSparse( IrpContext, Irp );
        break;

    case FSCTL_SET_ZERO_DATA :
        Status = NtfsZeroRange( IrpContext, Irp );
        break;

    case FSCTL_QUERY_ALLOCATED_RANGES :
        Status = NtfsQueryAllocatedRanges( IrpContext, Irp );
        break;

    case FSCTL_ENCRYPTION_FSCTL_IO :
        Status = NtfsEncryptionFsctl( IrpContext, Irp );
        break;

    case FSCTL_SET_ENCRYPTION :
        Status = NtfsSetEncryption( IrpContext, Irp );
        break;

    case FSCTL_READ_RAW_ENCRYPTED:
        Status = NtfsReadRawEncrypted( IrpContext, Irp );
        break;

    case FSCTL_WRITE_RAW_ENCRYPTED:
        Status = NtfsWriteRawEncrypted( IrpContext, Irp );
        break;

    case FSCTL_EXTEND_VOLUME:
        Status = NtfsExtendVolume( IrpContext, Irp );
        break;

    case FSCTL_READ_FROM_PLEX:
        Status = NtfsReadFromPlex( IrpContext, Irp );
        break;

    case FSCTL_FILE_PREFETCH:
        Status = NtfsPrefetchFile( IrpContext, Irp );
        break;

    default :
        DebugTrace( 0, Dbg, ("Invalid control code -> %08lx\n", FsControlCode) );
        NtfsCompleteRequest( IrpContext, Irp, Status = STATUS_INVALID_DEVICE_REQUEST );
        break;
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsUserFsRequest -> %08lx\n", Status) );

    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsOplockRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine to handle oplock requests made via the
    NtFsControlFile call.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    ULONG FsControlCode;
    ULONG OplockCount = 0;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    //
    //  Get the current Irp stack location, and save some reference to
    //  make life easier
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    DebugTrace( +1, Dbg, ("NtfsOplockRequest, FsControlCode = %08lx\n", FsControlCode) );

    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  We only permit oplock requests on files.
    //

    if ((TypeOfOpen != UserFileOpen) ||
        (SafeNodeType( Scb ) == NTFS_NTC_SCB_MFT)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace( -1, Dbg, ("NtfsOplockRequest -> STATUS_INVALID_PARAMETER\n") );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  There should be no output buffer
    //

    if (IrpSp->Parameters.FileSystemControl.OutputBufferLength > 0) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace( -1, Dbg, ("NtfsOplockRequest -> STATUS_INVALID_PARAMETER\n") );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  We jam Wait to TRUE in the IrpContext.  This prevents us from returning
    //  STATUS_PENDING if we can't acquire the file.  The caller would
    //  interpret that as having acquired an oplock.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  Switch on the function control code.  We grab the Fcb exclusively
    //  for oplock requests, shared for oplock break acknowledgement.
    //

    switch ( FsControlCode ) {

    case FSCTL_REQUEST_OPLOCK_LEVEL_1:
    case FSCTL_REQUEST_BATCH_OPLOCK:
    case FSCTL_REQUEST_FILTER_OPLOCK:
    case FSCTL_REQUEST_OPLOCK_LEVEL_2:

        NtfsAcquireExclusiveFcb( IrpContext, Fcb, Scb, 0 );

        if (FsControlCode == FSCTL_REQUEST_OPLOCK_LEVEL_2) {

            if (Scb->ScbType.Data.FileLock != NULL) {

                OplockCount = (ULONG) FsRtlAreThereCurrentFileLocks( Scb->ScbType.Data.FileLock );
            }

        } else {

            OplockCount = Scb->CleanupCount;
        }

        break;

    case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
    case FSCTL_OPBATCH_ACK_CLOSE_PENDING :
    case FSCTL_OPLOCK_BREAK_NOTIFY:
    case FSCTL_OPLOCK_BREAK_ACK_NO_2:

        NtfsAcquireSharedFcb( IrpContext, Fcb, Scb, 0 );
        break;

    default:

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace( -1, Dbg, ("NtfsOplockRequest -> STATUS_INVALID_PARAMETER\n") );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Use a try finally to free the Fcb.
    //

    try {

        //
        //  Call the FsRtl routine to grant/acknowledge oplock.
        //

        Status = FsRtlOplockFsctrl( &Scb->ScbType.Data.Oplock,
                                    Irp,
                                    OplockCount );

        //
        //  Set the flag indicating if Fast I/O is possible
        //

        NtfsAcquireFsrtlHeader( Scb );
        Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );
        NtfsReleaseFsrtlHeader( Scb );

    } finally {

        DebugUnwind( NtfsOplockRequest );

        //
        //  Release all of our resources
        //

        NtfsReleaseFcb( IrpContext, Fcb );

        //
        //  If this is not an abnormal termination then complete the irp
        //

        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, NULL, 0 );
        }

        DebugTrace( -1, Dbg, ("NtfsOplockRequest -> %08lx\n", Status) );
    }

    return Status;
}



NTSTATUS
NtfsLockVolumeInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObjectWithVcbLocked,
    IN OUT PULONG Retrying
    )

/*++

Routine Description:

    This routine performs the lock volume operation.  You should be synchronized
    with checkpoints before calling it

Arguments:

    Vcb - Supplies the Vcb to lock

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN VcbAcquired = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsLockVolumeInternal...\n") );


    try {
#ifdef SYSCACHE_DEBUG
        ULONG SystemHandleCount = 0;
#endif

        NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
        VcbAcquired = TRUE;

#ifdef SYSCACHE_DEBUG
        if (Vcb->SyscacheScb != NULL) {
            SystemHandleCount = Vcb->SyscacheScb->CleanupCount;
        }
#endif

        //
        //  Check if the Vcb is already locked, or if the open file count
        //  is greater than 1 (which implies that someone else also is
        //  currently using the volume, or a file on the volume).  We also fail
        //  this request if the volume has already gone through the dismount
        //  vcb process.
        //

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ) ||
#ifdef SYSCACHE_DEBUG
            (Vcb->CleanupCount > 1 + SystemHandleCount)) {
#else
            (Vcb->CleanupCount > 1)) {
#endif

            DebugTrace( 0, Dbg, ("Volume is currently in use\n") );

            Status = STATUS_ACCESS_DENIED;

        //
        //  If the volume is already locked then it might have been the result of an
        //  exclusive DASD open.  Allow that user to explictly lock the volume.
        //

        } else if (FlagOn( Vcb->VcbState, VCB_STATE_LOCKED )) {

            if (FlagOn( Vcb->VcbState, VCB_STATE_EXPLICIT_LOCK )) {

                DebugTrace( 0, Dbg, ("User has already locked volume\n") );

                Status = STATUS_ACCESS_DENIED;

            } else {

                SetFlag( Vcb->VcbState, VCB_STATE_EXPLICIT_LOCK );
                Status = STATUS_SUCCESS;
            }

        //
        //  We can take this path if the volume has already been locked via
        //  create but has not taken the PerformDismountOnVcb path.  We checked
        //  for this above by looking at the VOLUME_MOUNTED flag in the Vcb.
        //

        } else {

            //
            //  There better be system files objects only at this point.
            //

            SetFlag( Vcb->VcbState, VCB_STATE_LOCK_IN_PROGRESS );

            if (!NT_SUCCESS( NtfsFlushVolume( IrpContext, Vcb, TRUE, TRUE, TRUE, FALSE ))) {

                DebugTrace( 0, Dbg, ("Volume has user file objects\n") );

                Status = STATUS_ACCESS_DENIED;

            //
            //  If there are still user files then try another flush.  We're just being kind
            //  here.  If the lazy writer has a flush queued then the file object can't go
            //  away.  Let's raise CANT_WAIT and try one more time.
            //

            } else if (Vcb->CloseCount - Vcb->SystemFileCloseCount > 1) {

                //
                //  Fail this request if we have already gone through before.
                //  Use the next stack location in the Irp as a convenient
                //  place to store this information.
                //

                if (*Retrying != 0) {

                    DebugTrace( 0, Dbg, ("Volume has user file objects\n") );
                    Status = STATUS_ACCESS_DENIED;

                } else {

                    *Retrying = 1;
                    NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                }

            } else {

                //
                //  We don't really want to do all of the perform dismount here because
                //  that will cause us to remount a new volume before we're ready.
                //  At this time we only want to stop the log file and close up our
                //  internal attribute streams.  When the user (i.e., chkdsk) does an
                //  unlock then we'll finish up with the dismount call
                //

                NtfsPerformDismountOnVcb( IrpContext, Vcb, FALSE, NULL );

                SetFlag( Vcb->VcbState, VCB_STATE_LOCKED | VCB_STATE_EXPLICIT_LOCK );
                Vcb->FileObjectWithVcbLocked = FileObjectWithVcbLocked;

                Status = STATUS_SUCCESS;
            }
        }

    } finally {

        DebugUnwind( NtfsLockVolumeInternal );

        if (VcbAcquired) {

            ClearFlag( Vcb->VcbState, VCB_STATE_LOCK_IN_PROGRESS );
            NtfsReleaseVcb( IrpContext, Vcb );
        }

        DebugTrace( -1, Dbg, ("NtfsLockVolumeInternal -> %08lx\n", Status) );
    }

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsLockVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the lock volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION NextIrpSp;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsLockVolume...\n") );

    //
    //  Extract and decode the file object, and only permit user volume opens
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );

        DebugTrace( -1, Dbg, ("NtfsLockVolume -> %08lx\n", STATUS_ACCESS_DENIED) );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  If this is the retry path then perform a short delay so that the
    //  lazy writer can finish any queued writes.
    //

    NextIrpSp = IoGetNextIrpStackLocation( Irp );

    if (NextIrpSp->Parameters.FileSystemControl.FsControlCode != 0) {

        DebugTrace( 0, Dbg, ("Pausing for retry\n") );
        KeDelayExecutionThread( KernelMode, FALSE, &NtfsLockDelay );

    } else {

        //
        //  Notify anyone who wants to close their handles when a lock operation
        //  is attempted.  We should only do this once per lock request, so don't
        //  do it in the retry case.
        //

        DebugTrace( 0, Dbg, ("Sending lock notification\n") );
        FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_LOCK );
    }

    try {

        NtfsAcquireCheckpointSynchronization( IrpContext, Vcb );

        Status = NtfsLockVolumeInternal( IrpContext,
                                         Vcb,
                                         ((PFILE_OBJECT)(((UINT_PTR)IrpSp->FileObject) + 1)),
                                         &(NextIrpSp->Parameters.FileSystemControl.FsControlCode) );

    } finally {

        DebugUnwind( NtfsLockVolume );

        NtfsReleaseCheckpointSynchronization( IrpContext, Vcb );

        if ((AbnormalTermination() &&
             IrpContext->ExceptionStatus != STATUS_CANT_WAIT &&
             IrpContext->ExceptionStatus != STATUS_LOG_FILE_FULL) ||

            !NT_SUCCESS( Status )) {

            //
            //  This lock operation has failed either by raising a status that
            //  will keep us from retrying, or else by returning an unsuccessful
            //  status.  Notify anyone who wants to reopen their handles now.
            //  If we're about to retry the lock, we can notify everyone when/if
            //  the retry fails.
            //

            DebugTrace( 0, Dbg, ("Sending lock_failed notification\n") );
            FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_LOCK_FAILED );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsLockVolume -> %08lx\n", Status) );

    NtfsCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


NTSTATUS
NtfsUnlockVolumeInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine performs the unlock volume operation.

Arguments:

    Vcb - Supplies the Vcb to unlock

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    //
    //  Acquire exclusive access to the Vcb
    //

    NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );

    try {

        if (FlagOn( Vcb->VcbState, VCB_STATE_EXPLICIT_LOCK )) {

            NtfsPerformDismountOnVcb( IrpContext, Vcb, TRUE, NULL );

            //
            //  Unlock the volume and complete the Irp
            //

            ClearFlag( Vcb->VcbState, VCB_STATE_LOCKED | VCB_STATE_EXPLICIT_LOCK );
            Vcb->FileObjectWithVcbLocked = NULL;

            Status = STATUS_SUCCESS;

        } else {

            Status = STATUS_NOT_LOCKED;
        }

    } finally {

        DebugUnwind( NtfsUnlockVolumeInternal );

        //
        //  Release all of our resources
        //

        NtfsReleaseVcb( IrpContext, Vcb );

        DebugTrace( -1, Dbg, ("NtfsUnlockVolumeInternal -> %08lx\n", Status) );
    }

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsUnlockVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the unlock volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsUnlockVolume...\n") );

    //
    //  Extract and decode the file object, and only permit user volume opens
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );

        DebugTrace( -1, Dbg, ("NtfsUnlockVolume -> %08lx\n", STATUS_ACCESS_DENIED) );
        return STATUS_ACCESS_DENIED;
    }


    Status = NtfsUnlockVolumeInternal( IrpContext, Vcb );

    //
    //  Notify anyone who wants to reopen their handles when after the
    //  volume is unlocked.
    //

    if (NT_SUCCESS(Status)) {

        FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_UNLOCK );
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );
    DebugTrace( -1, Dbg, ("NtfsUnlockVolume -> %08lx\n", Status) );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsDismountVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the dismount volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    PIO_STACK_LOCATION IrpSp;

    BOOLEAN VcbAcquired = FALSE;
    BOOLEAN ExplicitDismount = FALSE;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    BOOLEAN ClearCheckpointActive = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsDismountVolume...\n") );

    //
    //  Extract and decode the file object, and only permit user volume opens
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );

        DebugTrace( -1, Dbg, ("NtfsDismountVolume -> %08lx\n", STATUS_ACCESS_DENIED) );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Don't notify if we are retrying due to log file full.
    //

    if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_DISMOUNT_LOG_FLUSH )) {

        FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_DISMOUNT );
    }

    try {

        //
        //  Serialize this with the volume checkpoints.
        //

        NtfsAcquireCheckpoint( IrpContext, Vcb );

        while (FlagOn( Vcb->CheckpointFlags, VCB_STOP_LOG_CHECKPOINT )) {

            //
            //  Release the checkpoint event because we cannot stop the log file now.
            //

            NtfsReleaseCheckpoint( IrpContext, Vcb );
            NtfsWaitOnCheckpointNotify( IrpContext, Vcb );
            NtfsAcquireCheckpoint( IrpContext, Vcb );
        }

        SetFlag( Vcb->CheckpointFlags, VCB_STOP_LOG_CHECKPOINT );
        NtfsResetCheckpointNotify( IrpContext, Vcb );
        NtfsReleaseCheckpoint( IrpContext, Vcb );
        ClearCheckpointActive = TRUE;

        //
        //  Acquire the Vcb exclusively.
        //

        NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
        VcbAcquired = TRUE;

        //
        //  Take special action if there's a pagefile on this volume, or if this is the
        //  system volume.
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_DISALLOW_DISMOUNT )) {

            //
            //  If the volume is not locked then fail immediately.
            //

            if (!FlagOn( Vcb->VcbState, VCB_STATE_LOCKED )) {

                try_return( Status = STATUS_ACCESS_DENIED );

            //
            //  If there are read-only files only then noop the request.  This
            //  allows autochk to access the root volume.
            //

            } else if (Vcb->ReadOnlyCloseCount == ((Vcb->CloseCount - Vcb->SystemFileCloseCount) - 1)) {

                DebugTrace( 0, Dbg, ("Volume has readonly files opened\n") );
                try_return( Status = STATUS_SUCCESS );
            }
        }

        //
        //  Remember that this is an explicit dismount.
        //

        ExplicitDismount = TRUE;

        //
        //  Naturally, we can't dismount the volume if it's already dismounted.
        //

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            //
            //  Return success if the user hasn't done an explicit dismount.
            //

            if (!FlagOn( Vcb->VcbState, VCB_STATE_EXPLICIT_DISMOUNT )) {

                Status = STATUS_SUCCESS;

            } else {

                Status = STATUS_VOLUME_DISMOUNTED;
            }

            try_return( NOTHING );
        }

        //
        //  Raise LogFile full once per dismount to force a clean checkpoint
        //  freeing logfile space.
        //
        if ((!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_DISMOUNT_LOG_FLUSH )) &&
            (!NtfsIsVolumeReadOnly( Vcb ))) {

            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_DISMOUNT_LOG_FLUSH );
            NtfsRaiseStatus( IrpContext, STATUS_LOG_FILE_FULL, NULL, NULL );
        }

        //
        //  Get as many cached writes out to disk as we can and mark
        //  all the streams for dismount.
        //

#ifdef BRIANDBG
        try {
#endif

           NtfsFlushVolume( IrpContext, Vcb, TRUE, TRUE, TRUE, TRUE );

           //
           //  Call the function that does the real work. We leave the volume locked
           //  so the complete teardown occurs when the handle closes
           //

           NtfsPerformDismountOnVcb( IrpContext, Vcb, FALSE, NULL );

#ifdef BRIANDBG
        } except( NtfsDismountExceptionFilter( GetExceptionInformation() )) {

            NOTHING
        }
#endif

        SetFlag( Vcb->VcbState, VCB_STATE_LOCKED );
        Vcb->FileObjectWithVcbLocked = (PFILE_OBJECT)(((ULONG_PTR)FileObject)+1);

        //
        //  Once we get this far the volume is really dismounted.  We
        //  can ignore errors generated by recursive failures.
        //

        Status = STATUS_SUCCESS;

        //
        //  Mark the volume as needs to be verified.
        //

        SetFlag( Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME );

    try_exit: NOTHING;

        //
        //  Remember that the user did an explicit dismount.
        //

        if ((Status == STATUS_SUCCESS) && ExplicitDismount) {

            SetFlag( Vcb->VcbState, VCB_STATE_EXPLICIT_DISMOUNT );
        }

    } finally {

        DebugUnwind( NtfsDismountVolume );

        if (ClearCheckpointActive) {

            NtfsAcquireCheckpoint( IrpContext, Vcb );
            ClearFlag( Vcb->CheckpointFlags, VCB_STOP_LOG_CHECKPOINT );
            NtfsSetCheckpointNotify( IrpContext, Vcb );
            NtfsReleaseCheckpoint( IrpContext, Vcb );
        }

        //
        //  Release all of our resources
        //

        if (VcbAcquired) {

            NtfsReleaseVcb( IrpContext, Vcb );
        }

        if (!NT_SUCCESS( Status ) &&
            (Status != STATUS_VOLUME_DISMOUNTED)) {

            //
            //  No need to report the error if this is a retryable error.
            //

            if (!AbnormalTermination() ||
                !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_DISMOUNT_LOG_FLUSH ) ||
                ((IrpContext->ExceptionStatus != STATUS_LOG_FILE_FULL) &&
                 (IrpContext->ExceptionStatus != STATUS_CANT_WAIT))) {

                FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_DISMOUNT_FAILED );
            }
        }

        //
        //  If this is an abnormal termination then undo our work, otherwise
        //  complete the irp
        //

        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }

        DebugTrace( -1, Dbg, ("NtfsDismountVolume -> %08lx\n", Status) );
    }

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsIsVolumeMounted (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns whether the volume is mounted.  It is responsible for
    either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PFILE_OBJECT FileObject;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    BOOLEAN AcquiredVcb = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsIsVolumeMounted...\n") );

    //
    //  Extract and decode the file object.
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if (TypeOfOpen == UnopenedFileObject) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Use a try-finally to release the Vcb if necessary.
    //

    try {

        //
        //  If we know the volume is dismounted, we're all done.
        //  OK to do this without synchronization as the state can
        //  change to unmounted on return to the user.
        //

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

             try_return( Status = STATUS_VOLUME_DISMOUNTED );
        }

        //
        //  Verify the volume if necessary.
        //

        NtfsPingVolume( IrpContext, Vcb, &AcquiredVcb );

    try_exit: NOTHING;
    } finally {

        DebugUnwind( NtfsIsVolumeMounted );

        //
        //  Release the Vcb.
        //

        if (AcquiredVcb) {
            NtfsReleaseVcb( IrpContext, Vcb );
        }

        DebugTrace( -1, Dbg, ("NtfsIsVolumeMounted -> %08lx\n", Status) );
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsDirtyVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine marks the specified volume dirty.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status = STATUS_SUCCESS;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsDirtyVolume...\n") );

    //
    //  Extract and decode the file object, and only permit user volume opens
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );

        DebugTrace( -1, Dbg, ("NtfsDirtyVolume -> %08lx\n", STATUS_ACCESS_DENIED) );
        return STATUS_ACCESS_DENIED;
    }

    NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

    try {
        //
        //  Fail this request if the volume is not mounted.
        //

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;

        }  else if (NtfsIsVolumeReadOnly( Vcb )) {

            Status = STATUS_MEDIA_WRITE_PROTECTED;

        } else {

            NtfsPostVcbIsCorrupt( IrpContext, 0, NULL, NULL );
        }

    } finally {

        NtfsReleaseVcb( IrpContext, Vcb );
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );

    DebugTrace( -1, Dbg, ("NtfsDirtyVolume -> STATUS_SUCCESS\n") );

    return Status;
}


//
//  Local support routine
//

BOOLEAN
NtfsGetDiskGeometry (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT RealDevice,
    IN PDISK_GEOMETRY DiskGeometry,
    IN PLONGLONG Length
    )

/*++

Routine Description:

    This procedure gets the disk geometry of the specified device

Arguments:

    RealDevice - Supplies the real device that is being queried

    DiskGeometry - Receives the disk geometry

    Length - Receives the number of bytes in the partition

Return Value:

    BOOLEAN - TRUE if the media is write protected, FALSE otherwise

--*/

{
    NTSTATUS Status;
    PREVENT_MEDIA_REMOVAL Prevent;
    BOOLEAN WriteProtected = FALSE;
    GET_LENGTH_INFORMATION LengthInfo;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsGetDiskGeometry:\n") );
    DebugTrace( 0, Dbg, ("RealDevice = %08lx\n", RealDevice) );
    DebugTrace( 0, Dbg, ("DiskGeometry = %08lx\n", DiskGeometry) );

    //
    //  Attempt to lock any removable media, ignoring status.
    //

    Prevent.PreventMediaRemoval = TRUE;
    (VOID)NtfsDeviceIoControl( IrpContext,
                                RealDevice,
                                IOCTL_DISK_MEDIA_REMOVAL,
                                &Prevent,
                                sizeof(PREVENT_MEDIA_REMOVAL),
                                NULL,
                                0,
                                NULL );

    //
    //  See if the media is write protected.  On success or any kind
    //  of error (possibly illegal device function), assume it is
    //  writeable, and only complain if he tells us he is write protected.
    //

    Status = NtfsDeviceIoControl( IrpContext,
                                  RealDevice,
                                  IOCTL_DISK_IS_WRITABLE,
                                  NULL,
                                  0,
                                  NULL,
                                  0,
                                  NULL );

    //
    //  Remember if the media is write protected but don't raise the error now.
    //  If the volume is not Ntfs then let another filesystem try.
    //
    if (Status == STATUS_MEDIA_WRITE_PROTECTED) {

        WriteProtected = TRUE;
        Status = STATUS_SUCCESS;
    }

    Status = NtfsDeviceIoControl( IrpContext,
                                  RealDevice,
                                  IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                  NULL,
                                  0,
                                  DiskGeometry,
                                  sizeof(DISK_GEOMETRY),
                                  NULL );

    if (!NT_SUCCESS(Status)) {
        NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
    }

    Status = NtfsDeviceIoControl( IrpContext,
                                  RealDevice,
                                  IOCTL_DISK_GET_LENGTH_INFO,
                                  NULL,
                                  0,
                                  &LengthInfo,
                                  sizeof( LengthInfo ),
                                  NULL );

    if (!NT_SUCCESS(Status)) {
        NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
    }

    *Length = LengthInfo.Length.QuadPart;

    DebugTrace( -1, Dbg, ("NtfsGetDiskGeometry->VOID\n") );
    return WriteProtected;
}


NTSTATUS
NtfsDeviceIoControl (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG IoCtl,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PULONG_PTR IosbInformation OPTIONAL
    )

/*++

Routine Description:

    This procedure issues an Ioctl to the lower device, and waits
    for the answer.

Arguments:

    DeviceObject - Supplies the device to issue the request to

    IoCtl - Gives the IoCtl to be used

    XxBuffer - Gives the buffer pointer for the ioctl, if any

    XxBufferLength - Gives the length of the buffer, if any

Return Value:

    None.

--*/

{
    PIRP Irp;
    KEVENT Event;
    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    Irp = IoBuildDeviceIoControlRequest( IoCtl,
                                         DeviceObject,
                                         InputBuffer,
                                         InputBufferLength,
                                         OutputBuffer,
                                         OutputBufferLength,
                                         FALSE,
                                         &Event,
                                         &Iosb );

    if (Irp == NULL) {

        NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
    }

    Status = IoCallDriver( DeviceObject, Irp );

    if (Status == STATUS_PENDING) {

        (VOID)KeWaitForSingleObject( &Event,
                                     Executive,
                                     KernelMode,
                                     FALSE,
                                     (PLARGE_INTEGER)NULL );

        Status = Iosb.Status;
    }

    //
    //  Get the information field from the completed Irp.
    //

    if ((NT_SUCCESS( Status )) && ARGUMENT_PRESENT( IosbInformation )) {

        *IosbInformation = Iosb.Information;
    }

    return Status;
}


//
//  Local support routine
//

VOID
NtfsReadBootSector (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PSCB *BootScb,
    OUT PBCB *BootBcb,
    OUT PVOID *BootSector
    )

/*++

Routine Description:

    This routine reads and returns a pointer to the boot sector for the volume.

    Volumes formatted under 3.51 and earlier will have a boot sector at sector
    0 and another halfway through the disk.  Volumes formatted with NT 4.0
    will have a boot sector at the end of the disk, in the sector beyond the
    stated size of the volume in the boot sector.  When this call is made the
    Vcb has the sector count from the device driver so we subtract one to find
    the last sector.

Arguments:

    Vcb - Supplies the Vcb for the operation

    BootScb - Receives the Scb for the boot file

    BootBcb - Receives the bcb for the boot sector

    BootSector - Receives a pointer to the boot sector

Return Value:

    None.

--*/

{
    PSCB Scb = NULL;
    BOOLEAN Error = FALSE;

    FILE_REFERENCE FileReference = { BOOT_FILE_NUMBER, 0, BOOT_FILE_NUMBER };

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsReadBootSector:\n") );
    DebugTrace( 0, Dbg, ("Vcb = %08lx\n", Vcb) );

    //
    //  Create a temporary scb for reading in the boot sector and initialize the
    //  mcb for it.
    //

    Scb = NtfsCreatePrerestartScb( IrpContext,
                                   Vcb,
                                   &FileReference,
                                   $DATA,
                                   NULL,
                                   0 );

    *BootScb = Scb;

    Scb->Header.AllocationSize.QuadPart =
    Scb->Header.FileSize.QuadPart =
    Scb->Header.ValidDataLength.QuadPart = (PAGE_SIZE * 2) + Vcb->BytesPerSector;

    //
    //  We don't want to look up the size for this Scb.
    //

    NtfsCreateInternalAttributeStream( IrpContext, Scb, FALSE, NULL );

    SetFlag( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED );

    (VOID)NtfsAddNtfsMcbEntry( &Scb->Mcb,
                               (LONGLONG)0,
                               (LONGLONG)0,
                               (LONGLONG)Vcb->ClustersPerPage,
                               FALSE );


    (VOID)NtfsAddNtfsMcbEntry( &Scb->Mcb,
                               (LONGLONG)Vcb->ClustersPerPage,
                               Vcb->NumberSectors >> 1,
                               (LONGLONG)Vcb->ClustersPerPage,
                               FALSE );

    (VOID)NtfsAddNtfsMcbEntry( &Scb->Mcb,
                               Int64ShllMod32( (LONGLONG) Vcb->ClustersPerPage, 1 ),
                               Vcb->NumberSectors - 1,
                               1,
                               FALSE );

    //
    //  Try reading in the first boot sector
    //

    try {

        NtfsMapStream( IrpContext,
                       Scb,
                       (LONGLONG)0,
                       Vcb->BytesPerSector,
                       BootBcb,
                       BootSector );

    //
    //  If we got an exception trying to read the first boot sector,
    //  then handle the exception by trying to read the second boot
    //  sector.  If that faults too, then we just allow ourselves to
    //  unwind and return the error.
    //

    } except (FsRtlIsNtstatusExpected(GetExceptionCode()) ?
              EXCEPTION_EXECUTE_HANDLER :
              EXCEPTION_CONTINUE_SEARCH) {

        Error = TRUE;
    }

    //
    //  Get out if we didn't get an error.  Otherwise try the middle sector.
    //  We want to read this next because we know that 4.0 format will clear
    //  this before writing the last sector.  Otherwise we could see a
    //  stale boot sector in the last sector even though a 3.51 format was
    //  the last to run.
    //

    if (!Error) { return; }

    Error = FALSE;

    try {

        NtfsMapStream( IrpContext,
                       Scb,
                       (LONGLONG)PAGE_SIZE,
                       Vcb->BytesPerSector,
                       BootBcb,
                       BootSector );

        //
        //  Ignore this sector if not Ntfs.  This could be the case for
        //  a bad sector 0 on a FAT volume.
        //

        if (!NtfsIsBootSectorNtfs( *BootSector, Vcb )) {

            NtfsUnpinBcb( IrpContext, BootBcb );
            Error = TRUE;
        }

    //
    //  If we got an exception trying to read the first boot sector,
    //  then handle the exception by trying to read the second boot
    //  sector.  If that faults too, then we just allow ourselves to
    //  unwind and return the error.
    //

    } except (FsRtlIsNtstatusExpected(GetExceptionCode()) ?
              EXCEPTION_EXECUTE_HANDLER :
              EXCEPTION_CONTINUE_SEARCH) {

        Error = TRUE;
    }

    //
    //  Get out if we didn't get an error.  Otherwise try the middle sector.
    //

    if (!Error) { return; }

    NtfsMapStream( IrpContext,
                   Scb,
                   (LONGLONG) (PAGE_SIZE * 2),
                   Vcb->BytesPerSector,
                   BootBcb,
                   BootSector );

    //
    //  Clear the header flag in the Scb.
    //

    ClearFlag( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED );

    //
    //  And return to our caller
    //

    DebugTrace( 0, Dbg, ("BootScb > %08lx\n", *BootScb) );
    DebugTrace( 0, Dbg, ("BootBcb > %08lx\n", *BootBcb) );
    DebugTrace( 0, Dbg, ("BootSector > %08lx\n", *BootSector) );
    DebugTrace( -1, Dbg, ("NtfsReadBootSector->VOID\n") );
    return;
}


//
//  Local support routine
//

//
//  First define a local macro to number the tests for the debug case.
//

#ifdef NTFSDBG
#define NextTest ++CheckNumber &&
#else
#define NextTest TRUE &&
#endif

BOOLEAN
NtfsIsBootSectorNtfs (
    IN PPACKED_BOOT_SECTOR BootSector,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine checks the boot sector to determine if it is an NTFS partition.

    The Vcb must alread be initialized from the device object to contain the
    parts of the device geometry we care about here: bytes per sector and
    total number of sectors in the partition.

Arguments:

    BootSector - Pointer to the boot sector which has been read in.

    Vcb - Pointer to a Vcb which has been initialized with sector size and
          number of sectors on the partition.

Return Value:

    FALSE - If the boot sector is not for Ntfs.
    TRUE - If the boot sector is for Ntfs.

--*/

{
#ifdef NTFSDBG
    ULONG CheckNumber = 0;
#endif

    //  PULONG l;
    //  ULONG Checksum = 0;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsIsBootSectorNtfs\n") );
    DebugTrace( 0, Dbg, ("BootSector = %08lx\n", BootSector) );

    //
    //  First calculate the boot sector checksum
    //

    //
    //  for (l = (PULONG)BootSector; l < (PULONG)&BootSector->Checksum; l++) {
    //      Checksum += *l;
    //  }

    //
    //  Now perform all the checks, starting with the Name and Checksum.
    //  The remaining checks should be obvious, including some fields which
    //  must be 0 and other fields which must be a small power of 2.
    //

    if (NextTest
        (BootSector->Oem[0] == 'N') &&
        (BootSector->Oem[1] == 'T') &&
        (BootSector->Oem[2] == 'F') &&
        (BootSector->Oem[3] == 'S') &&
        (BootSector->Oem[4] == ' ') &&
        (BootSector->Oem[5] == ' ') &&
        (BootSector->Oem[6] == ' ') &&
        (BootSector->Oem[7] == ' ')

            &&

        //  NextTest
        //  (BootSector->Checksum == Checksum)
        //
        //      &&

        //
        //  Check number of bytes per sector.  The low order byte of this
        //  number must be zero (smallest sector size = 0x100) and the
        //  high order byte shifted must equal the bytes per sector gotten
        //  from the device and stored in the Vcb.  And just to be sure,
        //  sector size must be less than page size.
        //

        NextTest
        (BootSector->PackedBpb.BytesPerSector[0] == 0)

            &&

        NextTest
        ((ULONG)(BootSector->PackedBpb.BytesPerSector[1] << 8) == Vcb->BytesPerSector)

            &&

        NextTest
        (BootSector->PackedBpb.BytesPerSector[1] << 8 <= PAGE_SIZE)

            &&

        //
        //  Sectors per cluster must be a power of 2.
        //

        NextTest
        ((BootSector->PackedBpb.SectorsPerCluster[0] == 0x1) ||
         (BootSector->PackedBpb.SectorsPerCluster[0] == 0x2) ||
         (BootSector->PackedBpb.SectorsPerCluster[0] == 0x4) ||
         (BootSector->PackedBpb.SectorsPerCluster[0] == 0x8) ||
         (BootSector->PackedBpb.SectorsPerCluster[0] == 0x10) ||
         (BootSector->PackedBpb.SectorsPerCluster[0] == 0x20) ||
         (BootSector->PackedBpb.SectorsPerCluster[0] == 0x40) ||
         (BootSector->PackedBpb.SectorsPerCluster[0] == 0x80))

            &&

        //
        //  These fields must all be zero.  For both Fat and HPFS, some of
        //  these fields must be nonzero.
        //

        NextTest
        (BootSector->PackedBpb.ReservedSectors[0] == 0) &&
        (BootSector->PackedBpb.ReservedSectors[1] == 0) &&
        (BootSector->PackedBpb.Fats[0] == 0) &&
        (BootSector->PackedBpb.RootEntries[0] == 0) &&
        (BootSector->PackedBpb.RootEntries[1] == 0) &&
        (BootSector->PackedBpb.Sectors[0] == 0) &&
        (BootSector->PackedBpb.Sectors[1] == 0) &&
        (BootSector->PackedBpb.SectorsPerFat[0] == 0) &&
        (BootSector->PackedBpb.SectorsPerFat[1] == 0) &&
        //  (BootSector->PackedBpb.HiddenSectors[0] == 0) &&
        //  (BootSector->PackedBpb.HiddenSectors[1] == 0) &&
        //  (BootSector->PackedBpb.HiddenSectors[2] == 0) &&
        //  (BootSector->PackedBpb.HiddenSectors[3] == 0) &&
        (BootSector->PackedBpb.LargeSectors[0] == 0) &&
        (BootSector->PackedBpb.LargeSectors[1] == 0) &&
        (BootSector->PackedBpb.LargeSectors[2] == 0) &&
        (BootSector->PackedBpb.LargeSectors[3] == 0)

            &&

        //
        //  Number of Sectors cannot be greater than the number of sectors
        //  on the partition.
        //

        NextTest
        (BootSector->NumberSectors <= Vcb->NumberSectors)

            &&

        //
        //  Check that both Lcn values are for sectors within the partition.
        //

        NextTest
        ((BootSector->MftStartLcn * BootSector->PackedBpb.SectorsPerCluster[0]) <=
            Vcb->NumberSectors)

            &&

        NextTest
        ((BootSector->Mft2StartLcn * BootSector->PackedBpb.SectorsPerCluster[0]) <=
            Vcb->NumberSectors)

            &&

        //
        //  Clusters per file record segment and default clusters for Index
        //  Allocation Buffers must be a power of 2.  A zero indicates that the
        //  size of these structures is the default size.
        //

        NextTest
        (((BootSector->ClustersPerFileRecordSegment >= -31) &&
          (BootSector->ClustersPerFileRecordSegment <= -9)) ||
         (BootSector->ClustersPerFileRecordSegment == 0x1) ||
         (BootSector->ClustersPerFileRecordSegment == 0x2) ||
         (BootSector->ClustersPerFileRecordSegment == 0x4) ||
         (BootSector->ClustersPerFileRecordSegment == 0x8) ||
         (BootSector->ClustersPerFileRecordSegment == 0x10) ||
         (BootSector->ClustersPerFileRecordSegment == 0x20) ||
         (BootSector->ClustersPerFileRecordSegment == 0x40))

            &&

        NextTest
        (((BootSector->DefaultClustersPerIndexAllocationBuffer >= -31) &&
          (BootSector->DefaultClustersPerIndexAllocationBuffer <= -9)) ||
         (BootSector->DefaultClustersPerIndexAllocationBuffer == 0x1) ||
         (BootSector->DefaultClustersPerIndexAllocationBuffer == 0x2) ||
         (BootSector->DefaultClustersPerIndexAllocationBuffer == 0x4) ||
         (BootSector->DefaultClustersPerIndexAllocationBuffer == 0x8) ||
         (BootSector->DefaultClustersPerIndexAllocationBuffer == 0x10) ||
         (BootSector->DefaultClustersPerIndexAllocationBuffer == 0x20) ||
         (BootSector->DefaultClustersPerIndexAllocationBuffer == 0x40))) {

        DebugTrace( -1, Dbg, ("NtfsIsBootSectorNtfs->TRUE\n") );

        return TRUE;

    } else {

        //
        //  If a check failed, print its check number with Debug Trace.
        //

        DebugTrace( 0, Dbg, ("Boot Sector failed test number %08lx\n", CheckNumber) );
        DebugTrace( -1, Dbg, ("NtfsIsBootSectorNtfs->FALSE\n") );

        return FALSE;
    }
}


//
//  Local support routine
//

VOID
NtfsGetVolumeInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PVPB Vpb OPTIONAL,
    IN PVCB Vcb,
    OUT PUSHORT VolumeFlags
    )

/*++

Routine Description:

    This routine gets the serial number and volume label for an NTFS volume.  It also
    returns the current volume flags for the volume.

Arguments:

    Vpb - Supplies the Vpb for the volume.  The Vpb will receive a copy of
        the volume label and serial number, if a Vpb is specified.

    Vcb - Supplies the Vcb for the operation.

    VolumeFlags - Address to store the current volume flags.

Return Value:

    None.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
    PVOLUME_INFORMATION VolumeInformation;

    PAGED_CODE();

    DebugTrace( 0, Dbg, ("NtfsGetVolumeInformation...\n") );

    *VolumeFlags = 0;

    //
    //  We read in the volume label attribute to get the volume label.
    //

    try {

        if (ARGUMENT_PRESENT(Vpb)) {

            NtfsInitializeAttributeContext( &AttributeContext );

            if (NtfsLookupAttributeByCode( IrpContext,
                                           Vcb->VolumeDasdScb->Fcb,
                                           &Vcb->VolumeDasdScb->Fcb->FileReference,
                                           $VOLUME_NAME,
                                           &AttributeContext )) {

                Vpb->VolumeLabelLength = (USHORT)
                NtfsFoundAttribute( &AttributeContext )->Form.Resident.ValueLength;

                if ( Vpb->VolumeLabelLength > MAXIMUM_VOLUME_LABEL_LENGTH) {

                     Vpb->VolumeLabelLength = MAXIMUM_VOLUME_LABEL_LENGTH;
                }

                RtlCopyMemory( &Vpb->VolumeLabel[0],
                               NtfsAttributeValue( NtfsFoundAttribute( &AttributeContext ) ),
                               Vpb->VolumeLabelLength );

            } else {

                Vpb->VolumeLabelLength = 0;
            }

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
        }

        NtfsInitializeAttributeContext( &AttributeContext );

        //
        //  Remember if the volume is dirty when we are mounting it.
        //

        if (NtfsLookupAttributeByCode( IrpContext,
                                       Vcb->VolumeDasdScb->Fcb,
                                       &Vcb->VolumeDasdScb->Fcb->FileReference,
                                       $VOLUME_INFORMATION,
                                       &AttributeContext )) {

            VolumeInformation =
              (PVOLUME_INFORMATION)NtfsAttributeValue( NtfsFoundAttribute( &AttributeContext ));

            if (FlagOn(VolumeInformation->VolumeFlags, VOLUME_DIRTY)) {
                SetFlag( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED_DIRTY );
            } else {
                ClearFlag( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED_DIRTY );
            }

            *VolumeFlags = VolumeInformation->VolumeFlags;
        }

    } finally {

        DebugUnwind( NtfsGetVolumeInformation );

        NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Local support routine
//

VOID
NtfsSetAndGetVolumeTimes (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN MarkDirty,
    IN BOOLEAN UpdateInTransaction
    )

/*++

Routine Description:

    This routine reads in the volume times from the standard information attribute
    of the volume file and also updates the access time to be the current
    time

Arguments:

    Vcb - Supplies the vcb for the operation.

    MarkDirty - Supplies TRUE if volume is to be marked dirty

    UpdateInTransaction - Indicates if we should mark the volume dirty in a transaction.

Return Value:

    None.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
    PSTANDARD_INFORMATION StandardInformation;

    LONGLONG MountTime;

    PAGED_CODE();

    DebugTrace( 0, Dbg, ("NtfsSetAndGetVolumeTimes...\n") );

    try {

        //
        //  Lookup the standard information attribute of the dasd file
        //

        NtfsInitializeAttributeContext( &AttributeContext );

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Vcb->VolumeDasdScb->Fcb,
                                        &Vcb->VolumeDasdScb->Fcb->FileReference,
                                        $STANDARD_INFORMATION,
                                        &AttributeContext )) {

            NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
        }

        StandardInformation = (PSTANDARD_INFORMATION)NtfsAttributeValue( NtfsFoundAttribute( &AttributeContext ));

        //
        //  Get the current time and make sure it differs from the time stored
        //  in last access time and then store the new last access time
        //

        NtfsGetCurrentTime( IrpContext, MountTime );

        if (MountTime == StandardInformation->LastAccessTime) {

            MountTime = MountTime + 1;
        }

        //****
        //****  Hold back on the update for now.
        //****
        //**** NtfsChangeAttributeValue( IrpContext,
        //****                           Vcb->VolumeDasdScb->Fcb,
        //****                           FIELD_OFFSET(STANDARD_INFORMATION, LastAccessTime),
        //****                           &MountTime,
        //****                           sizeof(MountTime),
        //****                           FALSE,
        //****                           FALSE,
        //****                           &AttributeContext );

        //
        //  Now save all the time fields in our vcb
        //

        Vcb->VolumeCreationTime = StandardInformation->CreationTime;
        Vcb->VolumeLastModificationTime = StandardInformation->LastModificationTime;
        Vcb->VolumeLastChangeTime = StandardInformation->LastChangeTime;
        Vcb->VolumeLastAccessTime = StandardInformation->LastAccessTime; //****Also hold back = MountTime;

        NtfsCleanupAttributeContext( IrpContext, &AttributeContext );

        //
        //  If the volume was mounted dirty, then set the dirty bit here.
        //

        if (MarkDirty) {

            NtfsMarkVolumeDirty( IrpContext, Vcb, UpdateInTransaction );
        }

    } finally {

        NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Local support routine
//

VOID
NtfsOpenSystemFile (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PSCB *Scb,
    IN PVCB Vcb,
    IN ULONG FileNumber,
    IN LONGLONG Size,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN BOOLEAN ModifiedNoWrite
    )

/*++

Routine Description:

    This routine is called to open one of the system files by its file number
    during the mount process.  An initial allocation is looked up for the file,
    unless the optional initial size is specified (in which case this size is
    used).

Parameters:

    Scb - Pointer to where the Scb pointer is to be stored.  If Scb pointer
          pointed to is NULL, then a PreRestart Scb is created, otherwise the
          existing Scb is used and only the stream file is set up.

    FileNumber - Number of the system file to open.

    Size - If nonzero, this size is used as the initial size, rather
           than consulting the file record in the Mft.

    AttributeTypeCode - Supplies the attribute to open, e.g., $DATA or $BITMAP

    ModifiedNoWrite - Indicates if the Memory Manager is not to write this
                      attribute to disk.  Applies to streams under transaction
                      control.

Return Value:

    None.

--*/

{
    FILE_REFERENCE FileReference;
    UNICODE_STRING $BadName;
    PUNICODE_STRING AttributeName = NULL;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsOpenSystemFile:\n") );
    DebugTrace( 0, Dbg, ("*Scb = %08lx\n", *Scb) );
    DebugTrace( 0, Dbg, ("FileNumber = %08lx\n", FileNumber) );
    DebugTrace( 0, Dbg, ("ModifiedNoWrite = %04x\n", ModifiedNoWrite) );

    //
    //  The Bad Cluster data attribute has a name.
    //

    if (FileNumber == BAD_CLUSTER_FILE_NUMBER) {

        RtlInitUnicodeString( &$BadName, L"$Bad" );
        AttributeName = &$BadName;
    }

    //
    //  If the Scb does not already exist, create it.
    //

    if (*Scb == NULL) {

        NtfsSetSegmentNumber( &FileReference, 0, FileNumber );
        FileReference.SequenceNumber = (FileNumber == 0 ? 1 : (USHORT)FileNumber);

        //
        //  Create the Scb.
        //

        *Scb = NtfsCreatePrerestartScb( IrpContext,
                                        Vcb,
                                        &FileReference,
                                        AttributeTypeCode,
                                        AttributeName,
                                        0 );

        NtfsAcquireExclusiveScb( IrpContext, *Scb );
    }

    //
    //  Set the modified-no-write bit in the Scb if necessary.
    //

    if (ModifiedNoWrite) {

        SetFlag( (*Scb)->ScbState, SCB_STATE_MODIFIED_NO_WRITE );
    }

    //
    //  Lookup the file sizes.
    //

    if (Size == 0) {

        NtfsUpdateScbFromAttribute( IrpContext, *Scb, NULL );

        //
        //  Make sure the file size isn't larger than allocation size.
        //

        if ((*Scb)->Header.FileSize.QuadPart > (*Scb)->Header.AllocationSize.QuadPart) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, (*Scb)->Fcb );
        }

    //
    //  Otherwise, just set the size we were given.
    //

    } else {

        (*Scb)->Header.FileSize.QuadPart =
        (*Scb)->Header.ValidDataLength.QuadPart = Size;

        (*Scb)->Header.AllocationSize.QuadPart = LlClustersFromBytes( Vcb, Size );
        (*Scb)->Header.AllocationSize.QuadPart = LlBytesFromClusters( Vcb,
                                                                      (*Scb)->Header.AllocationSize.QuadPart );

        SetFlag( (*Scb)->ScbState, SCB_STATE_HEADER_INITIALIZED );
    }

    //
    //  Make sure that our system streams are not marked as compressed.
    //

    if (AttributeTypeCode != $INDEX_ALLOCATION) {

        ClearFlag( (*Scb)->ScbState, SCB_STATE_WRITE_COMPRESSED );
        ClearFlag( (*Scb)->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK );

        if (!FlagOn( (*Scb)->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

            (*Scb)->CompressionUnit = 0;
            (*Scb)->CompressionUnitShift = 0;
        }
    }

    //
    //  Finally, create the stream, if not already there.
    //  And check if we should increment the counters
    //  If this is the volume file or the bad cluster file, we only increment the counts.
    //

    if ((FileNumber == VOLUME_DASD_NUMBER) ||
        (FileNumber == BAD_CLUSTER_FILE_NUMBER)) {

        if ((*Scb)->FileObject == 0) {

            NtfsIncrementCloseCounts( *Scb, TRUE, FALSE );

            (*Scb)->FileObject = (PFILE_OBJECT) 1;
        }

    } else {

        NtfsCreateInternalAttributeStream( IrpContext,
                                           *Scb,
                                           TRUE,
                                           &NtfsSystemFiles[FileNumber] );
    }

    DebugTrace( 0, Dbg, ("*Scb > %08lx\n", *Scb) );
    DebugTrace( -1, Dbg, ("NtfsOpenSystemFile -> VOID\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsOpenRootDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine opens the root directory by file number, and fills in the
    related pointers in the Vcb.

Arguments:

    Vcb - Pointer to the Vcb for the volume

Return Value:

    None.

--*/

{
    PFCB RootFcb;
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    FILE_REFERENCE FileReference;
    BOOLEAN MustBeFalse;

    PAGED_CODE();

    //
    //  Put special code here to do initial open of Root Index.
    //

    RootFcb = NtfsCreateRootFcb( IrpContext, Vcb );

    NtfsSetSegmentNumber( &FileReference, 0, ROOT_FILE_NAME_INDEX_NUMBER );
    FileReference.SequenceNumber = ROOT_FILE_NAME_INDEX_NUMBER;

    //
    //  Now create its Scb and acquire it exclusive.
    //

    Vcb->RootIndexScb = NtfsCreateScb( IrpContext,
                                       RootFcb,
                                       $INDEX_ALLOCATION,
                                       &NtfsFileNameIndex,
                                       FALSE,
                                       &MustBeFalse );

    //
    //  Now allocate a buffer to hold the normalized name for the root.
    //

    Vcb->RootIndexScb->ScbType.Index.NormalizedName.Buffer = NtfsAllocatePool( PagedPool, 2 );
    Vcb->RootIndexScb->ScbType.Index.NormalizedName.MaximumLength =
    Vcb->RootIndexScb->ScbType.Index.NormalizedName.Length = 2;
    Vcb->RootIndexScb->ScbType.Index.NormalizedName.Buffer[0] = '\\';

    Vcb->RootIndexScb->ScbType.Index.HashValue = 0;
    NtfsConvertNameToHash( Vcb->RootIndexScb->ScbType.Index.NormalizedName.Buffer,
                           sizeof( WCHAR ),
                           Vcb->UpcaseTable,
                           &Vcb->RootIndexScb->ScbType.Index.HashValue );

    NtfsAcquireExclusiveScb( IrpContext, Vcb->RootIndexScb );

    //
    //  Lookup the attribute and it better be there
    //

    NtfsInitializeAttributeContext( &Context );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        RootFcb,
                                        &FileReference,
                                        $INDEX_ROOT,
                                        &Context ) ) {

            NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
        }

        //
        //  We need to update the duplicated information in the
        //  Fcb.

        NtfsUpdateFcbInfoFromDisk( IrpContext, TRUE, RootFcb, NULL );

        //
        //  Initialize the Scb.  Force it to refer to a file name.
        //

        NtfsUpdateIndexScbFromAttribute( IrpContext,
                                         Vcb->RootIndexScb,
                                         NtfsFoundAttribute( &Context ),
                                         TRUE );

    } finally {

        NtfsCleanupAttributeContext( IrpContext, &Context );
    }

    return;
}


//
//  Local support routine
//

VOID
NtfsInitializeSecurityFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine creates/opens the security file, and initializes the security
    support.

Arguments:

    Vcb - Pointer to the Vcb for the volume

Return Value:

    None.

--*/

{
    PFCB Fcb;
    FILE_REFERENCE FileReference;

    //
    //  Set the file number for the security file.
    //

    NtfsSetSegmentNumber( &FileReference, 0, SECURITY_FILE_NUMBER );
    FileReference.SequenceNumber = SECURITY_FILE_NUMBER;

    //
    //  Create the Fcb.
    //

    Fcb = NtfsCreateFcb( IrpContext,
                         Vcb,
                         FileReference,
                         FALSE,
                         TRUE,
                         NULL );

    NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Now call the Security system to initialize itself.
        //

        NtfsInitializeSecurity( IrpContext, Vcb, Fcb );

    } finally {

        //
        //  If some error caused him to not get any Scbs created, then delete
        //  the Fcb, because we are the only ones who will.
        //

        if (IsListEmpty(&Fcb->ScbQueue)) {

            BOOLEAN AcquiredFcbTable = TRUE;

            NtfsAcquireFcbTable( IrpContext, Vcb );
            NtfsDeleteFcb( IrpContext, &Fcb, &AcquiredFcbTable );

            ASSERT(!AcquiredFcbTable);
        }
    }
}


//
//  Local support routine
//

VOID
NtfsUpgradeSecurity (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine upgrades the security descriptors and names for system
    scbs.

Arguments:

    Vcb - Pointer to the Vcb for the volume

Return Value:

    None.

--*/

{
    PFCB Fcb = Vcb->SecurityDescriptorStream->Fcb;
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    PSCB *ScbPtr;

    //
    //  Get set for some attribute lookups/creates
    //

    NtfsInitializeAttributeContext( &Context );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        struct {
            FILE_NAME FileName;
            WCHAR FileNameChars[10];
        } FileNameAttr;
        PFILE_NAME CurrentFileName;
        UNICODE_STRING NoName = CONSTANT_UNICODE_STRING( L"" );

        //
        //  Initialize a FileName attribute for this file.
        //

        RtlZeroMemory( &FileNameAttr, sizeof(FileNameAttr) );
        FileNameAttr.FileName.ParentDirectory = Fcb->FileReference;
        FileNameAttr.FileName.FileNameLength = 7;
        RtlCopyMemory( FileNameAttr.FileName.FileName, L"$Secure", 14 );

        ASSERT_EXCLUSIVE_FCB( Fcb );

        //
        //  If this file still has an unnamed data attribute from format, delete it.
        //

        if (NtfsLookupAttributeByName( IrpContext,
                                       Fcb,
                                       &Fcb->FileReference,
                                       $DATA,
                                       &NoName,
                                       NULL,
                                       FALSE,
                                       &Context ) ) {

            NtfsDeleteAttributeRecord( IrpContext,
                                       Fcb,
                                       DELETE_LOG_OPERATION |
                                        DELETE_RELEASE_FILE_RECORD |
                                        DELETE_RELEASE_ALLOCATION,
                                       &Context );
        }

        NtfsCleanupAttributeContext( IrpContext, &Context );

        //
        //  If there is an old name from format, remove it and put the right one there.
        //

        NtfsInitializeAttributeContext( &Context );
        if (NtfsLookupAttributeByCode( IrpContext,
                                       Fcb,
                                       &Fcb->FileReference,
                                       $FILE_NAME,
                                       &Context ) &&

            (((CurrentFileName = (PFILE_NAME)NtfsAttributeValue(NtfsFoundAttribute(&Context)))->FileNameLength != 7) ||
             (RtlCompareMemory(CurrentFileName->FileName, FileNameAttr.FileName.FileName, 14) != 14))) {

            UCHAR FileNameFlags;
            UNICODE_STRING LinkName;

            LinkName.Length = LinkName.MaximumLength = CurrentFileName->FileNameLength * sizeof( WCHAR );
            LinkName.Buffer = CurrentFileName->FileName;

            //
            //  Yank the old name.
            //

            NtfsRemoveLink( IrpContext, Fcb, Vcb->RootIndexScb, LinkName, NULL, NULL );

            //
            //  Create the new name.
            //

            NtfsAddLink( IrpContext,
                         TRUE,
                         Vcb->RootIndexScb,
                         Fcb,
                         (PFILE_NAME)&FileNameAttr,
                         NULL,
                         &FileNameFlags,
                         NULL,
                         NULL,
                         NULL );

        }

    } finally {

        NtfsCleanupAttributeContext( IrpContext, &Context );

    }

    //
    //  To free some space in our system file records, let's verify that their security
    //  is converted.
    //
    //  ****    conditionalize now until chkdsk supports the new security.
    //

    for (ScbPtr = &Vcb->MftScb; ScbPtr < &Vcb->MftBitmapScb; ScbPtr++) {

        PFCB SystemFcb;

        //
        //  Do only Scb's that are currently open
        //

        if (*ScbPtr == NULL)
            continue;

        SystemFcb = (*ScbPtr)->Fcb;

        //
        //  Skip the root index and volume dasd for backwards compatibility.
        //

        if (SystemFcb == NULL ||
            ScbPtr == &Vcb->RootIndexScb ||
            ScbPtr == &Vcb->VolumeDasdScb) {

            continue;

        }

        //
        //  Initialize the Fcb and load the security descriptor.
        //

        NtfsUpdateFcbInfoFromDisk( IrpContext, TRUE, SystemFcb, NULL );

        //
        //  Skip this Fcb if we've already given it an Id or if it has no
        //  security whatsoever.
        //

        if (SystemFcb->SecurityId != SECURITY_ID_INVALID ||
            SystemFcb->SharedSecurity == NULL) {

            continue;

        }

        //
        //  Delete the $SECURITY_DESCRIPTOR attribute if it has one
        //

        NtfsInitializeAttributeContext( &Context );

        try {

            //
            //  Find the $SECURITY_DESCRIPTOR attribute.
            //

            if (NtfsLookupAttributeByCode( IrpContext,
                                                 SystemFcb,
                                                 &SystemFcb->FileReference,
                                                 $SECURITY_DESCRIPTOR,
                                                 &Context )) {

                UNICODE_STRING NoName = CONSTANT_UNICODE_STRING( L"" );
                PSCB Scb;

                DebugTrace( 0, DbgAcl, ("NtfsUpgradeSecurity deleting existing Security Descriptor\n") );

                NtfsDeleteAttributeRecord( IrpContext,
                                           SystemFcb,
                                           DELETE_LOG_OPERATION |
                                            DELETE_RELEASE_FILE_RECORD |
                                            DELETE_RELEASE_ALLOCATION,
                                           &Context );

                //
                //  If the $SECURITY_DESCRIPTOR was non resident, the above
                //  delete call created one for us under the covers.  We
                //  need to mark it as deleted otherwise, we detect the
                //  volume as being corrupt.
                //

                Scb = NtfsCreateScb( IrpContext,
                                     SystemFcb,
                                     $SECURITY_DESCRIPTOR,
                                     &NoName,
                                     TRUE,
                                     NULL );

                if (Scb != NULL) {
                    ASSERT_EXCLUSIVE_SCB( Scb );
                    SetFlag( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );
                }
            }

        } finally {

            NtfsCleanupAttributeContext( IrpContext, &Context );
        }

        //
        //  Make sure we have a large $STANDARD_INFORMATION for this file
        //

        if (!FlagOn( SystemFcb->FcbState, FCB_STATE_LARGE_STD_INFO) ) {

            DebugTrace( 0, DbgAcl, ("NtfsUpgradeSecurity growing standard information\n") );

            NtfsGrowStandardInformation( IrpContext, SystemFcb );
        }

        //
        //  Assign a security Id if we don't have one already
        //

        if (SystemFcb->SharedSecurity->Header.HashKey.SecurityId == SECURITY_ID_INVALID) {

            NtfsAcquireFcbSecurity( Vcb );
            try {
                GetSecurityIdFromSecurityDescriptorUnsafe( IrpContext, SystemFcb->SharedSecurity );
            } finally {
                NtfsReleaseFcbSecurity( Vcb );
            }
            ASSERT( SystemFcb->SharedSecurity->Header.HashKey.SecurityId != SECURITY_ID_INVALID );
        }

        //
        //  Copy the security Id into the Fcb so we can store it out
        //

        SystemFcb->SecurityId = SystemFcb->SharedSecurity->Header.HashKey.SecurityId;

        //
        //  Update the $STANDARD_INFORMATION for the operation
        //

        NtfsUpdateStandardInformation( IrpContext, SystemFcb );

    }

}


//
//  Local support routine
//

VOID
NtfsInitializeExtendDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine opens the $Extend directory by file number, and fills in the
    related pointers in the Vcb.

Arguments:

    Vcb - Pointer to the Vcb for the volume

Return Value:

    None.

--*/

{
    struct {
        FILE_NAME FileName;
        WCHAR FileNameChars[10];
    } FileNameAttr;
    PFCB Fcb;
    PFCB PreviousFcb = NULL;
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    FILE_REFERENCE FileReference;
    PBCB FileRecordBcb = NULL;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    LONGLONG FileRecordOffset;
    UNICODE_STRING NoName = CONSTANT_UNICODE_STRING( L"" );

    UNICODE_STRING ExtendName;
    PFILE_NAME ExtendFileNameAttr;
    USHORT ExtendFileNameAttrLength;

    PINDEX_ENTRY IndexEntry;
    PBCB IndexEntryBcb = NULL;

    PSTANDARD_INFORMATION StandardInformation;
    ULONG CorruptHint;

    //
    //  Initialize with the known FileReference and name.
    //

    FileReference = ExtendFileReference;

    //
    //  Now create the Fcb.
    //

    Fcb = NtfsCreateFcb( IrpContext,
                         Vcb,
                         FileReference,
                         FALSE,
                         TRUE,
                         NULL );

    NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );

    //
    //  Get ready for some attribute lookups/creates.
    //

    NtfsInitializeAttributeContext( &Context );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Check to see if there is an existing $Extend entry in the root.
        //

        RtlZeroMemory( &FileNameAttr, sizeof(FileNameAttr) );
        RtlCopyMemory( FileNameAttr.FileName.FileName, NtfsExtendName.Buffer, NtfsExtendName.Length );

        ExtendName.MaximumLength = ExtendName.Length = NtfsExtendName.Length;
        ExtendName.Buffer = FileNameAttr.FileName.FileName;

        ExtendFileNameAttr = (PFILE_NAME) &FileNameAttr;
        ExtendFileNameAttrLength = sizeof( FileNameAttr );

        if (NtfsLookupEntry( IrpContext,
                             Vcb->RootIndexScb,
                             TRUE,
                             &ExtendName,
                             &ExtendFileNameAttr,
                             &ExtendFileNameAttrLength,
                             NULL,
                             &IndexEntry,
                             &IndexEntryBcb,
                             NULL )) {

            //
            //  If this is not for file record 11 then we want to orphan this entry.
            //  The user will have to use chkdsk to recover to a FOUND directory.
            //

            if (NtfsSegmentNumber( &IndexEntry->FileReference ) != EXTEND_NUMBER) {

                //
                //  Now create the Fcb for the previous link.
                //

                PreviousFcb = NtfsCreateFcb( IrpContext,
                                             Vcb,
                                             IndexEntry->FileReference,
                                             FALSE,
                                             FALSE,
                                             NULL );

                ExtendName.Buffer = ((PFILE_NAME) NtfsFoundIndexEntry( IndexEntry ))->FileName;
                NtfsRemoveLink( IrpContext,
                                PreviousFcb,
                                Vcb->RootIndexScb,
                                ExtendName,
                                NULL,
                                NULL );
            }
        }

        //
        //  We better not be trying to deallocate the file name attribute on the stack.
        //

        ASSERT( ExtendFileNameAttr == (PFILE_NAME) &FileNameAttr );

        //
        //  Reinitialize the file name attribute for the FileRecord fixup.
        //

        //
        //  If this file still has an unnamed data attribute from format, delete it.
        //

        if (NtfsLookupAttributeByName( IrpContext,
                                       Fcb,
                                       &FileReference,
                                       $DATA,
                                       &NoName,
                                       NULL,
                                       FALSE,
                                       &Context ) ) {

            NtfsDeleteAttributeRecord( IrpContext,
                                       Fcb,
                                       DELETE_LOG_OPERATION |
                                        DELETE_RELEASE_FILE_RECORD |
                                        DELETE_RELEASE_ALLOCATION,
                                       &Context );
        }

        NtfsCleanupAttributeContext( IrpContext, &Context );

        //
        //  Capture the standard information values in the Fcb and set the file name index
        //  flag if necessary.
        //

        NtfsInitializeAttributeContext( &Context );
        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &FileReference,
                                        $STANDARD_INFORMATION,
                                        &Context )) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, &FileReference, NULL );
        }

        //
        //  Check that the $Extend file record is valid.
        //

        if (!NtfsCheckFileRecord( Vcb, NtfsContainingFileRecord( &Context ), &FileReference, &CorruptHint)) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, &FileReference, NULL );
        }

        //
        //  Copy the existing standard information into the Fcb and set the file name
        //  index flag.
        //

        StandardInformation = (PSTANDARD_INFORMATION) NtfsAttributeValue( NtfsFoundAttribute( &Context ));

        Fcb->Info.CreationTime = StandardInformation->CreationTime;
        Fcb->Info.LastModificationTime = StandardInformation->LastModificationTime;
        Fcb->Info.LastChangeTime = StandardInformation->LastChangeTime;
        Fcb->Info.LastAccessTime = StandardInformation->LastAccessTime;
        Fcb->CurrentLastAccess = Fcb->Info.LastAccessTime;
        Fcb->Info.FileAttributes = StandardInformation->FileAttributes;
        NtfsCleanupAttributeContext( IrpContext, &Context );

        SetFlag( Fcb->Info.FileAttributes, DUP_FILE_NAME_INDEX_PRESENT );

        //
        //  If the name isn't there yet, add it.
        //

        NtfsInitializeAttributeContext( &Context );
        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &FileReference,
                                        $FILE_NAME,
                                        &Context )) {

            UCHAR FileNameFlags;

            //
            //  Update the file name attribute for the create.
            //

            RtlZeroMemory( &FileNameAttr, sizeof(FileNameAttr) );
            FileNameAttr.FileName.FileNameLength = NtfsExtendName.Length/2;
            RtlCopyMemory( FileNameAttr.FileName.FileName, NtfsExtendName.Buffer, NtfsExtendName.Length );

            NtfsAddLink( IrpContext,
                         TRUE,
                         Vcb->RootIndexScb,
                         Fcb,
                         (PFILE_NAME)&FileNameAttr,
                         NULL,
                         &FileNameFlags,
                         NULL,
                         NULL,
                         NULL );
        }

        //
        //  Now see if the file name index is there, and if not create it.
        //

        NtfsCleanupAttributeContext( IrpContext, &Context );
        NtfsInitializeAttributeContext( &Context );

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &FileReference,
                                        $INDEX_ROOT,
                                        &Context ) ) {

            NtfsCreateIndex( IrpContext,
                             Fcb,
                             $FILE_NAME,
                             COLLATION_FILE_NAME,
                             Vcb->DefaultBytesPerIndexAllocationBuffer,
                             (UCHAR)Vcb->DefaultBlocksPerIndexAllocationBuffer,
                             NULL,
                             0,
                             TRUE,
                             TRUE );

            //
            //  We have to set the index present bit, so read it, save the old data
            //  and set the flag here.
            //

            NtfsPinMftRecord( IrpContext,
                              Vcb,
                              &FileReference,
                              FALSE,
                              &FileRecordBcb,
                              &FileRecord,
                              &FileRecordOffset );

            //
            //  We have to be very careful when using the InitialzeFileRecordSegment
            //  log record.  This action is applied unconditionally.  DoAction doesn't
            //  check the previous LSN in the page.  It may be garbage on a newly initialized
            //  file record.  We log the entire file record to avoid the case where we
            //  might overwrite a later Lsn with this earlier Lsn during restart.
            //

            //
            //  Log the existing file record as the undo action.
            //

            FileRecord->Lsn = NtfsWriteLog( IrpContext,
                                            Vcb->MftScb,
                                            FileRecordBcb,
                                            Noop,
                                            NULL,
                                            0,
                                            InitializeFileRecordSegment,
                                            FileRecord,
                                            FileRecord->FirstFreeByte,
                                            FileRecordOffset,
                                            0,
                                            0,
                                            Vcb->BytesPerFileRecordSegment );

            //
            //  Now update the record in place.
            //

            SetFlag( FileRecord->Flags, FILE_FILE_NAME_INDEX_PRESENT );

            //
            //  Log the new file record.
            //

            FileRecord->Lsn = NtfsWriteLog( IrpContext,
                                            Vcb->MftScb,
                                            FileRecordBcb,
                                            InitializeFileRecordSegment,
                                            FileRecord,
                                            FileRecord->FirstFreeByte,
                                            Noop,
                                            NULL,
                                            0,
                                            FileRecordOffset,
                                            0,
                                            0,
                                            Vcb->BytesPerFileRecordSegment );

            //
            //  Reload it so we can pass the attribute when initializing the Scb.
            //

            NtfsCleanupAttributeContext( IrpContext, &Context );
            NtfsInitializeAttributeContext( &Context );

            NtfsLookupAttributeByCode( IrpContext,
                                       Fcb,
                                       &FileReference,
                                       $INDEX_ROOT,
                                       &Context );
        }

        //
        //  Initialize the Fcb and load the security descriptor.
        //

        NtfsUpdateFcbInfoFromDisk( IrpContext, TRUE, Fcb, NULL );

        if (Fcb->SharedSecurity == NULL) {

            NtfsLoadSecurityDescriptor( IrpContext, Fcb );
        }

        ASSERT( Fcb->SharedSecurity != NULL );

        //
        //  Now create its Scb and store it.
        //

        Vcb->ExtendDirectory = NtfsCreateScb( IrpContext,
                                              Fcb,
                                              $INDEX_ALLOCATION,
                                              &NtfsFileNameIndex,
                                              FALSE,
                                              NULL );

        NtfsUpdateIndexScbFromAttribute( IrpContext,
                                         Vcb->ExtendDirectory,
                                         NtfsFoundAttribute( &Context ),
                                         TRUE );

        NtfsCreateInternalAttributeStream( IrpContext,
                                           Vcb->ExtendDirectory,
                                           FALSE,
                                           NULL );

    } finally {

        NtfsCleanupAttributeContext( IrpContext, &Context );
        NtfsUnpinBcb( IrpContext, &FileRecordBcb );
        NtfsUnpinBcb( IrpContext, &IndexEntryBcb );

        //
        //  If some error caused us to not get the Scb created, then delete
        //  the Fcb, because we are the only ones who will.
        //

        if (Vcb->ExtendDirectory == NULL) {

            BOOLEAN AcquiredFcbTable = TRUE;

            NtfsAcquireFcbTable( IrpContext, Vcb );
            NtfsDeleteFcb( IrpContext, &Fcb, &AcquiredFcbTable );

            ASSERT(!AcquiredFcbTable);
        }
    }
}


//
//  Local support routine
//

VOID
NtfsInitializeQuotaFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine creates/opens the quota file, and initializes the quota support.

Arguments:

    Vcb - Pointer to the Vcb for the volume

Return Value:

    None.

--*/

{
    PFCB Fcb;

    //
    //  Create/open the quota file in $Extend
    //


    Fcb = NtfsInitializeFileInExtendDirectory( IrpContext, Vcb, &NtfsQuotaName, TRUE, TRUE );

    try {

        //
        //  Initialize the Quota subsystem.
        //

        NtfsInitializeQuotaIndex( IrpContext, Fcb, Vcb );

    } finally {

        //
        //  If some error caused him to not get any Scbs created, then delete
        //  the Fcb, because we are the only ones who will.
        //

        if (IsListEmpty(&Fcb->ScbQueue)) {

            BOOLEAN AcquiredFcbTable = TRUE;

            NtfsAcquireFcbTable( IrpContext, Vcb );
            NtfsDeleteFcb( IrpContext, &Fcb, &AcquiredFcbTable );

            ASSERT(!AcquiredFcbTable);
        }
    }
}


//
//  Local support routine
//

VOID
NtfsInitializeObjectIdFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine creates/opens the object Id table, and initializes Object Ids.

Arguments:

    Vcb - Pointer to the Vcb for the volume

Return Value:

    None.

--*/

{
    PFCB Fcb;

    //
    //  Create/open the quota file in $Extend
    //

    Fcb = NtfsInitializeFileInExtendDirectory( IrpContext, Vcb, &NtfsObjectIdName, TRUE, TRUE );

    try {

        //
        //  Initialize the Object Id subsystem.
        //

        NtfsInitializeObjectIdIndex( IrpContext, Fcb, Vcb );

    } finally {

        //
        //  If some error caused him to not get any Scbs created, then delete
        //  the Fcb, because we are the only ones who will.
        //

        if (IsListEmpty(&Fcb->ScbQueue)) {

            BOOLEAN AcquiredFcbTable = TRUE;

            NtfsAcquireFcbTable( IrpContext, Vcb );
            NtfsDeleteFcb( IrpContext, &Fcb, &AcquiredFcbTable );

            ASSERT(!AcquiredFcbTable);
        }
    }
}


//
//  Local support routine
//

VOID
NtfsInitializeReparseFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine creates/opens the mount file table, creating it if it does not exist.

Arguments:

    Vcb - Pointer to the Vcb for the volume

Return Value:

    None.

--*/

{
    PFCB Fcb;

    //
    //  Create/open the quota file in $Extend
    //

    Fcb = NtfsInitializeFileInExtendDirectory( IrpContext, Vcb, &NtfsMountTableName, TRUE, TRUE );

    try {

        //
        //  Initialize the Object Id subsystem.
        //

        NtfsInitializeReparsePointIndex( IrpContext, Fcb, Vcb );

    } finally {

        //
        //  If some error caused her to not get any Scbs created, then delete
        //  the Fcb, because we are the only ones who will.
        //

        if (IsListEmpty(&Fcb->ScbQueue)) {

            BOOLEAN AcquiredFcbTable = TRUE;

            NtfsAcquireFcbTable( IrpContext, Vcb );
            NtfsDeleteFcb( IrpContext, &Fcb, &AcquiredFcbTable );

            ASSERT(!AcquiredFcbTable);
        }
    }
}


//
//  Local support routine
//

VOID
NtfsInitializeUsnJournal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG CreateIfNotExist,
    IN ULONG Restamp,
    IN PCREATE_USN_JOURNAL_DATA JournalData
    )

/*++

Routine Description:

    This routine creates/opens the Usn journal, and initializes it.

Arguments:

    Vcb - Pointer to the Vcb for the volume

    CreateIfNotExist - Supplies TRUE if file should be created if it does not
        already exist, or FALSE if file should not be created.

    Restamp - Indicates if we want to restamp the journal.

    JournalData - This is the allocation and delta to use for the journal, unless
        we read it from disk.

Return Value:

    None.

--*/

{
    FILE_REFERENCE PriorFileReference;
    PFCB Fcb = NULL;
    BOOLEAN ReleaseExtend = FALSE;

    PriorFileReference = Vcb->UsnJournalReference;

    try {

        //
        //  Acquire Mft now to preserve locking order
        //

        NtfsAcquireExclusiveScb( IrpContext, Vcb->MftScb );

        //
        //  Create/open the USN file in $Extend
        //

        if ( Vcb->UsnJournal) {

            Fcb = Vcb->UsnJournal->Fcb;

            //
            //  Acquire in canonical order
            //

            NtfsAcquireExclusiveScb( IrpContext, Vcb->UsnJournal );

        } else {

            NtfsAcquireExclusiveScb( IrpContext, Vcb->ExtendDirectory );
            ReleaseExtend = TRUE;

            Fcb = NtfsInitializeFileInExtendDirectory( IrpContext, Vcb, &NtfsUsnJrnlName, FALSE, CreateIfNotExist );

    #ifdef NTFSDBG

            //
            //  Compensate for misclassification of usnjournal during real create
            //

            if (IrpContext->OwnershipState == NtfsOwns_ExVcb_Mft_Extend_File) {
                IrpContext->OwnershipState = NtfsOwns_ExVcb_Mft_Extend_Journal;
            }
    #endif

        }

        //
        //  We are done if it is not there.
        //

        if (Fcb != NULL) {

            Vcb->UsnJournalReference = Fcb->FileReference;

            //
            //  If we only want to open an existing journal then this is mount.  Make sure
            //  to note that there is a journal on the disk.  We can't depend on the next
            //  call to succeed in that case.
            //

            if (!CreateIfNotExist) {

                ASSERT( (IrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
                        (IrpContext->MinorFunction == IRP_MN_MOUNT_VOLUME) );

                SetFlag( Vcb->VcbState, VCB_STATE_USN_JOURNAL_PRESENT );
            }

            //
            //  Open or create the the Usn Journal.
            //

            NtfsSetupUsnJournal( IrpContext, Vcb, Fcb, CreateIfNotExist, Restamp, JournalData );
        }

    } finally {

        if (ReleaseExtend) {
            NtfsReleaseScb( IrpContext, Vcb->ExtendDirectory );
        }

        NtfsReleaseScb( IrpContext, Vcb->MftScb );

        if (AbnormalTermination()) {
            Vcb->UsnJournalReference = PriorFileReference;
        }
    }
}


//
//  Local Support Routine
//

NTSTATUS
NtfsQueryRetrievalPointers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the query retrieval pointers operation.
    It returns the retrieval pointers for the specified input
    file from the start of the file to the request map size specified
    in the input buffer.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp;

    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PLONGLONG RequestedMapSize;
    PLONGLONG *MappingPairs;

    PVOID RangePtr;
    ULONG Index;
    ULONG i;
    LONGLONG SectorCount;
    LONGLONG Lbo;
    LONGLONG Vbo;
    LONGLONG Vcn;
    LONGLONG MapSize;

    //
    //  Always make this synchronous.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    //
    //  Only Kernel mode clients may query retrieval pointer information about
    //  a file, and then only the paging file.  Ensure that this is the case
    //  for this caller.
    //

    if (Irp->RequestorMode != KernelMode) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Get the current stack location and extract the input and output
    //  buffer information.  The input contains the requested size of
    //  the mappings in terms of VBO.  The output parameter will receive
    //  a pointer to nonpaged pool where the mapping pairs are stored.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    ASSERT( IrpSp->Parameters.FileSystemControl.InputBufferLength == sizeof(LARGE_INTEGER) );
    ASSERT( IrpSp->Parameters.FileSystemControl.OutputBufferLength == sizeof(PVOID) );

    RequestedMapSize = (PLONGLONG)IrpSp->Parameters.FileSystemControl.Type3InputBuffer;
    MappingPairs = (PLONGLONG *)Irp->UserBuffer;

    //
    //  Decode the file object and assert that it is the paging file
    //
    //

    (VOID)NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if (!FlagOn(Fcb->FcbState, FCB_STATE_PAGING_FILE)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Acquire exclusive access to the Scb
    //

    NtfsAcquireExclusiveScb( IrpContext, Scb );

    try {

        //
        //  Check if the mapping the caller requested is too large
        //

        if (*RequestedMapSize > Scb->Header.FileSize.QuadPart) {

            try_return( Status = STATUS_INVALID_PARAMETER );
        }

        //
        //  Now get the index for the mcb entry that will contain the
        //  callers request and allocate enough pool to hold the
        //  output mapping pairs.
        //

        //
        //  Compute the Vcn which contains the byte just before the offset size
        //  passed in.
        //

        MapSize = *RequestedMapSize - 1;

        if (*RequestedMapSize == 0) {

            Index = 0;

        } else {

            Vcn = Int64ShraMod32( MapSize, Vcb->ClusterShift );
            (VOID)NtfsLookupNtfsMcbEntry( &Scb->Mcb, Vcn, NULL, NULL, NULL, NULL, &RangePtr, &Index );
        }

        *MappingPairs = NtfsAllocatePool( NonPagedPool, (Index + 2) * (2 * sizeof(LARGE_INTEGER)) );

        //
        //  Now copy over the mapping pairs from the mcb
        //  to the output buffer.  We store in [sector count, lbo]
        //  mapping pairs and end with a zero sector count.
        //

        MapSize = *RequestedMapSize;

        i = 0;

        if (MapSize != 0) {

            for (; i <= Index; i += 1) {

                (VOID)NtfsGetNextNtfsMcbEntry( &Scb->Mcb, &RangePtr, i, &Vbo, &Lbo, &SectorCount );

                SectorCount = LlBytesFromClusters( Vcb, SectorCount );

                if (SectorCount > MapSize) {
                    SectorCount = MapSize;
                }

                (*MappingPairs)[ i*2 + 0 ] = SectorCount;
                (*MappingPairs)[ i*2 + 1 ] = LlBytesFromClusters( Vcb, Lbo );

                MapSize = MapSize - SectorCount;
            }
        }

        (*MappingPairs)[ i*2 + 0 ] = 0;

        Status = STATUS_SUCCESS;

    try_exit: NOTHING;
    } finally {

        DebugUnwind( NtfsQueryRetrievalPointers );

        //
        //  Release all of our resources
        //

        NtfsReleaseScb( IrpContext, Scb );

        //
        //  If this is an abnormal termination then undo our work, otherwise
        //  complete the irp
        //

        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }
    }

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsGetCompression (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the compression state of the opened file/directory

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PUSHORT CompressionState;

    PAGED_CODE();

    //
    //  Get the current stack location and extract the output
    //  buffer information.  The output parameter will receive
    //  the compressed state of the file/directory.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Get a pointer to the output buffer.  Look at the system buffer field in th
    //  irp first.  Then the Irp Mdl.
    //

    if (Irp->AssociatedIrp.SystemBuffer != NULL) {

        CompressionState = Irp->AssociatedIrp.SystemBuffer;

    } else if (Irp->MdlAddress != NULL) {

        CompressionState = MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority );

        if (CompressionState == NULL) {

            NtfsCompleteRequest( IrpContext, Irp, STATUS_INSUFFICIENT_RESOURCES );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_USER_BUFFER );
        return STATUS_INVALID_USER_BUFFER;
    }

    //
    //  Make sure the output buffer is large enough and then initialize
    //  the answer to be that the file isn't compressed
    //

    if (IrpSp->Parameters.FileSystemControl.OutputBufferLength < sizeof(USHORT)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    *CompressionState = 0;

    //
    //  Decode the file object
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if ((TypeOfOpen != UserFileOpen) &&
        (TypeOfOpen != UserDirectoryOpen)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Acquire shared access to the Scb
    //

    NtfsAcquireSharedScb( IrpContext, Scb );

    //
    //  If this is the index allocation Scb and it has not been initialized then
    //  lookup the index root and perform the initialization.
    //

    if ((Scb->AttributeTypeCode == $INDEX_ALLOCATION) &&
        (Scb->ScbType.Index.BytesPerIndexBuffer == 0)) {

        ATTRIBUTE_ENUMERATION_CONTEXT Context;

        NtfsInitializeAttributeContext( &Context );

        //
        //  Use a try-finally to perform cleanup.
        //

        try {

            if (!NtfsLookupAttributeByName( IrpContext,
                                            Scb->Fcb,
                                            &Scb->Fcb->FileReference,
                                            $INDEX_ROOT,
                                            &Scb->AttributeName,
                                            NULL,
                                            FALSE,
                                            &Context )) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
            }

            NtfsUpdateIndexScbFromAttribute( IrpContext,
                                             Scb,
                                             NtfsFoundAttribute( &Context ),
                                             FALSE );

        } finally {

            NtfsCleanupAttributeContext( IrpContext, &Context );

            if (AbnormalTermination()) { NtfsReleaseScb( IrpContext, Scb ); }
        }
    }

    //
    //  Return the compression state and the size of the returned data.
    //

    *CompressionState = (USHORT)(Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK);
    if (*CompressionState != 0) {
        *CompressionState += 1;
    }

    Irp->IoStatus.Information = sizeof( USHORT );

    //
    //  Release all of our resources
    //

    NtfsReleaseScb( IrpContext, Scb );

    //
    //  If this is an abnormal termination then undo our work, otherwise
    //  complete the irp
    //

    NtfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

    return STATUS_SUCCESS;
}


//
//  Local Support Routine
//

VOID
NtfsChangeAttributeCompression (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PVCB Vcb,
    IN PCCB Ccb,
    IN USHORT CompressionState
    )

/*++

Routine Description:

    This routine changes the compression state of an attribute on disk,
    from not compressed to compressed, or visa versa.

    To turn compression off, the caller must already have the Scb acquired
    exclusive, and guarantee that the entire file is not compressed.

Arguments:

    Scb - Scb for affected stream

    Vcb - Vcb for volume

    Ccb - Ccb for the open handle

    CompressionState - 0 for no compression or nonzero for Rtl compression code - 1

Return Value:

    None.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    ATTRIBUTE_RECORD_HEADER NewAttribute;
    PATTRIBUTE_RECORD_HEADER Attribute;
    ULONG AttributeSizeChange;
    ULONG OriginalFileAttributes;
    UCHAR OriginalCompressionUnitShift;
    ULONG OriginalCompressionUnit;

    PFCB Fcb = Scb->Fcb;

    ULONG NewCompressionUnit;
    UCHAR NewCompressionUnitShift;

    PAGED_CODE( );

    //
    //  Prepare to lookup and change attribute.
    //

    NtfsInitializeAttributeContext( &AttrContext );

    ASSERT( (Scb->Header.PagingIoResource == NULL) ||
            (IrpContext->CleanupStructure == Fcb) ||
            (IrpContext->CleanupStructure == Scb) );

    NtfsAcquireExclusiveScb( IrpContext, Scb );

    OriginalFileAttributes = Fcb->Info.FileAttributes;
    OriginalCompressionUnitShift = Scb->CompressionUnitShift;
    OriginalCompressionUnit = Scb->CompressionUnit;

    //
    //  Capture the ccb source information.
    //

    if (Ccb != NULL) {

        IrpContext->SourceInfo = Ccb->UsnSourceInfo;
    }

    try {

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
        }

        //
        //  Post the change to the Usn Journal (on errors change is backed out)
        //

        NtfsPostUsnChange( IrpContext, Scb, USN_REASON_COMPRESSION_CHANGE );

        //
        //  Lookup the attribute and pin it so that we can modify it.
        //

        if ((Scb->Header.NodeTypeCode == NTFS_NTC_SCB_INDEX) ||
            (Scb->Header.NodeTypeCode == NTFS_NTC_SCB_ROOT_INDEX)) {

            //
            //  Lookup the attribute record from the Scb.
            //

            if (!NtfsLookupAttributeByName( IrpContext,
                                            Fcb,
                                            &Fcb->FileReference,
                                            $INDEX_ROOT,
                                            &Scb->AttributeName,
                                            NULL,
                                            FALSE,
                                            &AttrContext )) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, NULL );
            }

        } else {

            NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &AttrContext );
        }

        NtfsPinMappedAttribute( IrpContext, Vcb, &AttrContext );

        Attribute = NtfsFoundAttribute( &AttrContext );

        if ((CompressionState != 0) &&
            !NtfsIsAttributeResident(Attribute) &&
            !FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

            LONGLONG Temp;
            ULONG CompressionUnitInClusters;

            //
            //  If we are turning compression on, then we need to fill out the
            //  allocation of the compression unit containing file size, or else
            //  it will be interpreted as compressed when we fault it in.  This
            //  is peanuts compared to the dual copies of clusters we keep around
            //  in the loop below when we rewrite the file.  We don't do this
            //  work if the file is sparse because the allocation has already
            //  been rounded up.
            //

            CompressionUnitInClusters =
              ClustersFromBytes( Vcb, Vcb->BytesPerCluster << NTFS_CLUSTERS_PER_COMPRESSION );

            Temp = LlClustersFromBytes(Vcb, Scb->Header.AllocationSize.QuadPart);

            //
            //  If FileSize is not already at a cluster boundary, then add
            //  allocation.
            //

            if ((ULONG)Temp & (CompressionUnitInClusters - 1)) {

                NtfsAddAllocation( IrpContext,
                                   NULL,
                                   Scb,
                                   Temp,
                                   CompressionUnitInClusters - ((ULONG)Temp & (CompressionUnitInClusters - 1)),
                                   FALSE,
                                   NULL );

                if (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

                    Scb->Fcb->Info.AllocatedLength = Scb->TotalAllocated;
                    SetFlag( Scb->Fcb->InfoFlags, FCB_INFO_CHANGED_ALLOC_SIZE );
                }

                NtfsWriteFileSizes( IrpContext,
                                    Scb,
                                    &Scb->Header.ValidDataLength.QuadPart,
                                    FALSE,
                                    TRUE,
                                    TRUE );

                //
                //  The attribute may have moved.  We will cleanup the attribute
                //  context and look it up again.
                //

                NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                NtfsInitializeAttributeContext( &AttrContext );

                NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &AttrContext );
                NtfsPinMappedAttribute( IrpContext, Vcb, &AttrContext );
                Attribute = NtfsFoundAttribute( &AttrContext );
            }
        }

        //
        //  Remember the current compression values.
        //

        NewCompressionUnit = Scb->CompressionUnit;
        NewCompressionUnitShift = Scb->CompressionUnitShift;

        //
        //  If the attribute is resident, copy it here and remember its
        //  header size.
        //

        if (NtfsIsAttributeResident(Attribute)) {

            RtlCopyMemory( &NewAttribute, Attribute, SIZEOF_RESIDENT_ATTRIBUTE_HEADER );

            AttributeSizeChange = SIZEOF_RESIDENT_ATTRIBUTE_HEADER;

            //
            //  Set the correct compression unit but only for data streams.  We
            //  don't want to change this value for the Index Root.
            //

            if (NtfsIsTypeCodeCompressible( Attribute->TypeCode ) &&
                !FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

                if (CompressionState != 0) {

                    NewCompressionUnit = BytesFromClusters( Scb->Vcb, 1 << NTFS_CLUSTERS_PER_COMPRESSION );
                    NewCompressionUnitShift = NTFS_CLUSTERS_PER_COMPRESSION;

                } else {

                    NewCompressionUnit = 0;
                    NewCompressionUnitShift = 0;
                }
            }

        //
        //  Else if it is nonresident, copy it here, set the compression parameter,
        //  and remember its size.
        //

        } else {

            AttributeSizeChange = Attribute->Form.Nonresident.MappingPairsOffset;

            if (Attribute->NameOffset != 0) {

                AttributeSizeChange = Attribute->NameOffset;
            }

            RtlCopyMemory( &NewAttribute, Attribute, AttributeSizeChange );

            //
            //  The compression numbers are already correct if the file is compressed.
            //

            if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

                if (CompressionState != 0) {

                    NewAttribute.Form.Nonresident.CompressionUnit = NTFS_CLUSTERS_PER_COMPRESSION;
                    NewCompressionUnit = Vcb->BytesPerCluster << NTFS_CLUSTERS_PER_COMPRESSION;
                    NewCompressionUnitShift = NTFS_CLUSTERS_PER_COMPRESSION;

                } else {

                    NewAttribute.Form.Nonresident.CompressionUnit = 0;
                    NewCompressionUnit = 0;
                    NewCompressionUnitShift = 0;
                }
            }

            ASSERT((NewCompressionUnit == 0) ||
                   (Scb->AttributeTypeCode == $INDEX_ALLOCATION) ||
                   NtfsIsTypeCodeCompressible( Scb->AttributeTypeCode ));
        }

        //
        //  Turn compression on/off.
        //

        NewAttribute.Flags = Scb->AttributeFlags & ~ATTRIBUTE_FLAG_COMPRESSION_MASK;
        SetFlag( NewAttribute.Flags, CompressionState );

        //
        //  Now, log the changed attribute.
        //

        (VOID)NtfsWriteLog( IrpContext,
                            Vcb->MftScb,
                            NtfsFoundBcb(&AttrContext),
                            UpdateResidentValue,
                            &NewAttribute,
                            AttributeSizeChange,
                            UpdateResidentValue,
                            Attribute,
                            AttributeSizeChange,
                            NtfsMftOffset( &AttrContext ),
                            PtrOffset(NtfsContainingFileRecord(&AttrContext), Attribute),
                            0,
                            Vcb->BytesPerFileRecordSegment );

        //
        //  Change the attribute by calling the same routine called at restart.
        //

        NtfsRestartChangeValue( IrpContext,
                                NtfsContainingFileRecord(&AttrContext),
                                PtrOffset(NtfsContainingFileRecord(&AttrContext), Attribute),
                                0,
                                &NewAttribute,
                                AttributeSizeChange,
                                FALSE );

        //
        //  If this is the main stream for a file we want to change the file attribute
        //  for this stream in both the standard information and duplicate
        //  information structure.
        //

        if (FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE )) {

            if (CompressionState != 0) {

                SetFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_COMPRESSED );

            } else {

                ClearFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_COMPRESSED );
            }

            ASSERTMSG( "conflict with flush",
                       ExIsResourceAcquiredSharedLite( Fcb->Resource ) ||
                       (Fcb->PagingIoResource != NULL &&
                        ExIsResourceAcquiredSharedLite( Fcb->PagingIoResource )));

            SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );
            SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
        }

        //
        //  Now lets add or remove the total allocated field in the attribute
        //  header.  Add if going to uncompressed, non-sparse.  Remove if going
        //  to compressed and non-sparse.
        //

        if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

            NtfsSetTotalAllocatedField( IrpContext, Scb, CompressionState );
        }

        //
        //  At this point we will change the compression unit in the Scb.
        //

        Scb->CompressionUnit = NewCompressionUnit;
        Scb->CompressionUnitShift = NewCompressionUnitShift;

        if (FlagOn( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO )) {

            NtfsUpdateStandardInformation( IrpContext, Fcb );
            ClearFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
        }

        //
        //  Checkpoint the transaction now to secure this change.
        //

        NtfsCheckpointCurrentTransaction( IrpContext );

        //
        //  Update the FastIoField.
        //

        NtfsAcquireFsrtlHeader( Scb );
        Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );
        NtfsReleaseFsrtlHeader( Scb );

    //
    //  Cleanup on the way out.
    //

    } finally {

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        //
        //  If this requests aborts then we want to back out any changes to the
        //  in-memory structures.
        //

        if (AbnormalTermination()) {

            Fcb->Info.FileAttributes = OriginalFileAttributes;
            SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

            Scb->CompressionUnitShift = OriginalCompressionUnitShift;
            Scb->CompressionUnit = OriginalCompressionUnit;
        }

        //
        //  This routine is self contained - it commits a transaction and we don't
        //  want to leave with anything extra acquired
        //

        NtfsReleaseScb( IrpContext, Scb );
    }
}


//
//  Local Support Routine
//

NTSTATUS
NtfsSetCompression (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine compresses or decompresses an entire stream in place,
    by walking through the stream and forcing it to be written with the
    new compression parameters.  As it writes the stream it sets a flag
    in the Scb to tell NtfsCommonWrite to delete all allocation at the
    outset, to force the space to be reallocated.

Arguments:

    Irp - Irp describing the compress or decompress change.

Return Value:

    NSTATUS - Status of the request.

--*/

{
    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION NextIrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PUSHORT CompressionStatePtr;

    PFILE_OBJECT FileObject;
    LONGLONG FileOffset;
    LONGLONG ByteCount;
    USHORT CompressionState = 0;
    BOOLEAN PagingIoAcquired = FALSE;
    BOOLEAN FsRtlHeaderLocked = FALSE;
    ULONG ScbRestoreState = SCB_STATE_WRITE_COMPRESSED;
    IO_STATUS_BLOCK Iosb;
    PMDL ReadMdl;
    PMDL WriteMdl;

    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    PAGED_CODE( );

    //
    //  Get the current stack location and extract the output
    //  buffer information.  The output parameter will receive
    //  the compressed state of the file/directory.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    NextIrpSp = IoGetNextIrpStackLocation( Irp );

    FileObject = IrpSp->FileObject;
    CompressionStatePtr = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Make sure the input buffer is big enough
    //

    if (IrpSp->Parameters.FileSystemControl.InputBufferLength < sizeof(USHORT)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Decode the file object. We don't care to raise on dismounts here
    //  because we check for that further down anyway. So send FALSE.
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );

    if (((TypeOfOpen != UserFileOpen) &&
         (TypeOfOpen != UserDirectoryOpen)) ||
        FlagOn(Fcb->FcbState, FCB_STATE_PAGING_FILE)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  See if we are compressing, and only accept the default case or
    //  lznt1.
    //

    if (*CompressionStatePtr != 0) {

        if ((*CompressionStatePtr == COMPRESSION_FORMAT_DEFAULT) ||
            (*CompressionStatePtr == COMPRESSION_FORMAT_LZNT1)) {

            CompressionState = COMPRESSION_FORMAT_LZNT1 - 1;

            //
            //  Check that we can compress on this volume.
            //

            if (!FlagOn( Vcb->AttributeFlagsMask, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
                return STATUS_INVALID_DEVICE_REQUEST;
            }

        } else {

            NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    //  Readonly mount should be just that: read only.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    try {

        //
        //  We now want to acquire the Scb to check if we can continue.
        //

        if (Scb->Header.PagingIoResource != NULL) {

            NtfsAcquireExclusivePagingIo( IrpContext, Fcb );
            PagingIoAcquired = TRUE;
        }

        NtfsAcquireExclusiveScb( IrpContext, Scb );

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            try_return( Status = STATUS_VOLUME_DISMOUNTED );
        }

        //
        //  compression not allowed on encrypted streams - this mirrors
        //  the error code efs gives for this kind of attempt - initially we
        //  precall efs to weed these out but that still leaves a race that this
        //  plugs
        //

        if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED )) {

            try_return( Status = STATUS_INVALID_DEVICE_REQUEST );
        }

        //
        //  Handle the simple directory case here.
        //

        if ((Scb->Header.NodeTypeCode == NTFS_NTC_SCB_INDEX) ||
            (Scb->Header.NodeTypeCode == NTFS_NTC_SCB_ROOT_INDEX)) {

            NtfsChangeAttributeCompression( IrpContext, Scb, Vcb, Ccb, CompressionState );

            ClearFlag( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK );
            SetFlag( Scb->AttributeFlags, CompressionState );

            try_return( Status = STATUS_SUCCESS );
        }

        if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

            NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );
        }

        //
        //  Set the WRITE_ACCESS_SEEN flag so that we will enforce the
        //  reservation strategy.
        //

        if (!FlagOn( Scb->ScbState, SCB_STATE_WRITE_ACCESS_SEEN )) {

            LONGLONG ClusterCount;

            NtfsAcquireReservedClusters( Vcb );

            //
            //  Does this Scb have reserved space that causes us to exceed the free
            //  space on the volume?
            //

            ClusterCount = LlClustersFromBytesTruncate( Vcb, Scb->ScbType.Data.TotalReserved );

            if ((Scb->ScbType.Data.TotalReserved != 0) &&
                ((ClusterCount + Vcb->TotalReserved) > Vcb->FreeClusters)) {

                NtfsReleaseReservedClusters( Vcb );

                try_return( Status = STATUS_DISK_FULL );
            }

            //
            //  Otherwise tally in the reserved space now for this Scb, and
            //  remember that we have seen write access.
            //

            Vcb->TotalReserved += ClusterCount;
            SetFlag( Scb->ScbState, SCB_STATE_WRITE_ACCESS_SEEN );

            NtfsReleaseReservedClusters( Vcb );
        }

        //
        //  If this is the first pass through SetCompression we need to set this
        //  request up as the top-level change compression operation.  This means
        //  setting the REALLOCATE_ON_WRITE flag, changing the attribute state
        //  and putting the SCB_STATE_WRITE_COMPRESSED flag in the correct state.
        //

        if (NextIrpSp->Parameters.FileSystemControl.OutputBufferLength == MAXULONG) {

            //
            //  If the REALLOCATE_ON_WRITE flag is set it means that someone is
            //  already changing the compression state.  Return STATUS_SUCCESS in
            //  that case.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_REALLOCATE_ON_WRITE )) {

                try_return( Status = STATUS_SUCCESS );
            }

            //
            //  If we are turning off compression and the file is uncompressed then
            //  we can just get out.
            //

            if ((CompressionState == 0) && ((Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK) == 0)) {

                try_return( Status = STATUS_SUCCESS );
            }

            //
            //  If we are compressing, change the compressed state now.
            //

            if (CompressionState != 0) {

                //
                //  See if we have to create an internal attribute stream.  Do this first even though
                //  we don't need it for the next operation.  We want to find out if we can't
                //  create the stream object (maybe the file is so large mm can't cache it) before
                //  changing the compression state.  Otherwise the user will never be able to
                //  access the file.
                //

                if (Scb->FileObject == NULL) {
                    NtfsCreateInternalAttributeStream( IrpContext, Scb, FALSE, NULL );
                }

                NtfsChangeAttributeCompression( IrpContext, Scb, Vcb, Ccb, CompressionState );
                Scb->AttributeFlags = (USHORT)((Scb->AttributeFlags & ~ATTRIBUTE_FLAG_COMPRESSION_MASK) |
                                               CompressionState);
                SetFlag( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED );

            //
            //  Otherwise, we must clear the compress flag in the Scb to
            //  start writing decompressed.
            //

            } else {

                ClearFlag( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED );
            }

            //
            //  Set ourselves up as the top level request.
            //

            SetFlag( Scb->ScbState, SCB_STATE_REALLOCATE_ON_WRITE | SCB_STATE_COMPRESSION_CHANGE );
            NextIrpSp->Parameters.FileSystemControl.OutputBufferLength = 0;
            NextIrpSp->Parameters.FileSystemControl.InputBufferLength = 0;

        //
        //  If we are turning off compression and the file is uncompressed then
        //  we can just get out.  Even if we raised while decompressing.  If
        //  the state is now uncompressed then we have committed the change.
        //

        } else if (CompressionState == 0) {

            ASSERT( !FlagOn( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED ));

            //
            //  If the flag is set then make sure to start back at offset zero in
            //  the file.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED )) {

                ClearFlag( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED );
                NextIrpSp->Parameters.FileSystemControl.OutputBufferLength = 0;
                NextIrpSp->Parameters.FileSystemControl.InputBufferLength = 0;
            }

            if ((Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK) == 0) {

                try_return( Status = STATUS_SUCCESS );
            }
        }

        //
        //  In the Fsd entry we clear the following two parameter fields in the Irp,
        //  and then we update them to our current position on all abnormal terminations.
        //  That way if we get a log file full, we only have to resume where we left
        //  off.
        //

        ((PLARGE_INTEGER)&FileOffset)->LowPart = NextIrpSp->Parameters.FileSystemControl.OutputBufferLength;
        ((PLARGE_INTEGER)&FileOffset)->HighPart = NextIrpSp->Parameters.FileSystemControl.InputBufferLength;

        //
        //  Make sure to flush and purge the compressed stream if present.
        //

#ifdef  COMPRESS_ON_WIRE
        if (Scb->Header.FileObjectC != NULL) {

            PCOMPRESSION_SYNC CompressionSync = NULL;

            //
            //  Use a try-finally to clean up the compression sync.
            //

            try {

                Status = NtfsSynchronizeUncompressedIo( Scb,
                                                        NULL,
                                                        0,
                                                        TRUE,
                                                        &CompressionSync );

            } finally {

                NtfsReleaseCompressionSync( CompressionSync );
            }

            NtfsNormalizeAndCleanupTransaction( IrpContext, &Status, TRUE, STATUS_UNEXPECTED_IO_ERROR );

            NtfsDeleteInternalAttributeStream( Scb, TRUE, TRUE );
            ASSERT( Scb->Header.FileObjectC == NULL );
        }
#endif

        //
        //  If the stream is resident there is no need rewrite any of the data.
        //

        if (!FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

            //
            //  Release all of the files held by this Irp Context.  The Mft
            //  may have been grabbed to make space for the TotalAllocated field.
            //  This will automatically also release the pageingio
            //

            ASSERT(IrpContext->TransactionId == 0);
            NtfsReleaseAllResources( IrpContext );
            PagingIoAcquired = FALSE;

            while (TRUE) {

                //
                //  We must throttle our writes.
                //

                CcCanIWrite( FileObject, 0x40000, TRUE, FALSE );

                //
                //  Lock the FsRtl header so we can freeze FileSize.
                //  Acquire paging io exclusive if uncompressing so
                //  we can guarantee that all of the pages get written
                //  before we mark the file as uncompressed.  Otherwise a
                //  a competing LazyWrite in a range may block after
                //  going through Mm and Mm will report to this routine
                //  that the flush has occurred.
                //

                if (CompressionState == 0) {

                    ExAcquireResourceExclusiveLite( Scb->Header.PagingIoResource, TRUE );

                } else {

                    ExAcquireResourceSharedLite( Scb->Header.PagingIoResource, TRUE );
                }

                FsRtlLockFsRtlHeader( &Scb->Header );
                IrpContext->CleanupStructure = Scb;
                FsRtlHeaderLocked = TRUE;

                //
                //  Also check if the volume is mounted.
                //

                if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

                    try_return( Status = STATUS_VOLUME_DISMOUNTED );
                }

                //
                //  Jump out right here if the attribute is resident.
                //

                if (FlagOn(Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT)) {
                    break;
                }

                //
                //  Let's round the file offset down to a sparse unit boundary to
                //  clean up the sparse file support.
                //

                if (Scb->CompressionUnit != 0) {

                    ((PLARGE_INTEGER)&FileOffset)->LowPart &= ~(Vcb->SparseFileUnit - 1);
                }

                //
                //  See if we have to create an internal attribute stream.  We do
                //  it in the loop, because the Scb must be acquired.
                //

                if (Scb->FileObject == NULL) {
                    NtfsCreateInternalAttributeStream( IrpContext, Scb, FALSE, NULL );
                }

                //
                //  Loop through the current view looking for deallocated ranges.
                //

                do {

                    //
                    //  Calculate the bytes left in the file to write.
                    //

                    ByteCount = Scb->Header.FileSize.QuadPart - FileOffset;

                    //
                    //  This is how we exit, seeing that we have finally rewritten
                    //  everything.  It is possible that the file was truncated
                    //  between passes through this loop so we test for 0 bytes or
                    //  a negative value.
                    //
                    //  Note that we exit with the Scb still acquired,
                    //  so that we can reliably turn compression off.
                    //

                    if (ByteCount <= 0) {

                        break;
                    }

                    //
                    //  If there is more than our max, then reduce the byte count for this
                    //  pass to our maximum.
                    //

                    if (((ULONG)FileOffset & 0x3ffff) + ByteCount > 0x40000) {

                        ByteCount = 0x40000 - ((ULONG)FileOffset & 0x3ffff);
                    }

                    //
                    //  If the file is sparse then skip any deallocated regions.  Note that
                    //  this is safe even if there are dirty pages in the data section.
                    //  Space will be correctly allocated when the writes occur at some point.
                    //  We are only concerned with ranges that need to be reallocated.
                    //

                    if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

                        VCN RangeStartVcn;
                        LONGLONG RangeClusterCount;
                        VCN RangeFinalVcn;
                        ULONG RangeByteCount;

                        RangeStartVcn = LlClustersFromBytesTruncate( Vcb, FileOffset );
                        RangeFinalVcn = LlClustersFromBytes( Vcb, FileOffset + ByteCount );

                        //
                        //  Preload the allocation to check for sparse ranges.
                        //

                        NtfsAcquireExclusiveScb( IrpContext, Scb );

                        NtfsPreloadAllocation( IrpContext,
                                               Scb,
                                               RangeStartVcn,
                                               RangeFinalVcn - 1 );

                        do {

                            BOOLEAN IsAllocated;

                            //
                            //  If the current block is allocated then perform
                            //  the compression operation on this range.
                            //

                            IsAllocated = NtfsIsRangeAllocated( Scb,
                                                                RangeStartVcn,
                                                                RangeFinalVcn,
                                                                TRUE,
                                                                &RangeClusterCount );

                            RangeByteCount = BytesFromClusters( Vcb, (ULONG) RangeClusterCount );

                            //
                            //  Remember if the number of bytes to change
                            //  the compression on has shrunk.
                            //
                            if (IsAllocated) {

                                if (ByteCount > RangeByteCount) {
                                    ByteCount = RangeByteCount;
                                }

                                //
                                //  Break out to the outer loop.
                                //

                                break;
                            }

                            //
                            //  Extend ValidDataLength if we the current range leaves no
                            //  gaps.  This will prevent the next write from reallocating
                            //  a previous range in a ZeroData call.
                            //

                            if ((FileOffset + RangeByteCount > Scb->Header.ValidDataLength.QuadPart) &&
                                (FileOffset <= Scb->Header.ValidDataLength.QuadPart)) {

                                Scb->Header.ValidDataLength.QuadPart = FileOffset + RangeByteCount;
                                if (Scb->Header.ValidDataLength.QuadPart > Scb->Header.FileSize.QuadPart) {

                                    Scb->Header.ValidDataLength.QuadPart = Scb->Header.FileSize.QuadPart;
                                }

#ifdef SYSCACHE_DEBUG
                                if (ScbIsBeingLogged( Scb )) {
                                    FsRtlLogSyscacheEvent( Scb, SCE_SETCOMPRESS, SCE_FLAG_SET_VDL, FileOffset, RangeByteCount, Scb->Header.ValidDataLength.QuadPart );
                                }
#endif

                            }

                            //
                            //  If we have found the last requested cluster then break out.
                            //

                            if ((RangeFinalVcn - RangeStartVcn) <= RangeClusterCount) {

                                ByteCount = 0;
                                FileOffset += LlBytesFromClusters( Vcb, RangeFinalVcn - RangeStartVcn );
                                break;

                            //
                            //  The range is not allocated but we need to check whether
                            //  there are any dirty pages in this range.
                            //

                            } else if (NtfsCheckForReservedClusters( Scb,
                                                                     RangeStartVcn,
                                                                     &RangeClusterCount ) &&
                                       (RangeClusterCount < Vcb->SparseFileClusters)) {

                                if (ByteCount > Vcb->SparseFileUnit) {
                                    ByteCount = Vcb->SparseFileUnit;
                                }

                                break;
                            }

                            //
                            //  There is a hole at the current location.  Move
                            //  to the next block to consider.
                            //

                            RangeStartVcn += RangeClusterCount;
                            RangeByteCount = BytesFromClusters( Vcb, (ULONG) RangeClusterCount );
                            ByteCount -= RangeByteCount;
                            FileOffset += RangeByteCount;

                        } while (ByteCount != 0);

                        NtfsReleaseScb( IrpContext, Scb );
                    }

                } while (ByteCount == 0);

                //
                //  Check if have reached the end of the file.
                //  Note that we exit with the Scb still acquired,
                //  so that we can reliably turn compression off.
                //

                if (ByteCount <= 0) {

                    break;
                }

                //
                //  Make sure there are enough available clusters in the range
                //  we want to rewrite.
                //

                NtfsPurgeFileRecordCache( IrpContext );
                if (!NtfsReserveClusters( IrpContext, Scb, FileOffset, (ULONG) ByteCount )) {

                    //
                    //  If this transaction has already deallocated clusters
                    //  then raise log file full to allow those to become
                    //  available.
                    //

                    if (IrpContext->DeallocatedClusters != 0) {

                        NtfsRaiseStatus( IrpContext, STATUS_LOG_FILE_FULL, NULL, NULL );

                    //
                    //  Otherwise there is insufficient space to guarantee
                    //  we can perform the compression operation.
                    //

                    } else {

                        NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
                    }
                }

                //
                //  Map the next range of the file, and make the pages dirty.
                //

#ifdef BENL_DBG
                ASSERT( (FileOffset % Scb->CompressionUnit == 0) && (ByteCount % Scb->CompressionUnit == 0 || FileOffset + ByteCount == Scb->Header.FileSize.QuadPart) );
#endif

                //
                //  Do an empty MDL read and write to lock the range down and set it dirty for the subsequent flushcache
                //

                try {

                    ReadMdl = NULL;
                    WriteMdl = NULL;

                    //
                    //  Page it all in
                    //

                    CcMdlRead( Scb->FileObject, (PLARGE_INTEGER)&FileOffset, (ULONG)ByteCount, &ReadMdl, &Iosb );
                    ASSERT( STATUS_SUCCESS == Iosb.Status );

                    //
                    //  Mark it as modified
                    //

                    CcPrepareMdlWrite( Scb->FileObject, (PLARGE_INTEGER)&FileOffset, (ULONG)ByteCount, &WriteMdl, &Iosb );
                    ASSERT( STATUS_SUCCESS == Iosb.Status );

                } finally {

                    if (WriteMdl) {
                        CcMdlWriteComplete( Scb->FileObject, (PLARGE_INTEGER)&FileOffset, WriteMdl );
                    }
                    if (ReadMdl) {
                        CcMdlReadComplete(  Scb->FileObject, ReadMdl );
                    }
                }

#ifdef SYSCACHE

                //
                //  Clear write mask before the flush
                //

                {
                    PULONG WriteMask;
                    ULONG Len;
                    ULONG Off = (ULONG)FileOffset;

                    WriteMask = Scb->ScbType.Data.WriteMask;
                    if (WriteMask == NULL) {
                        WriteMask = NtfsAllocatePool( NonPagedPool, (((0x2000000) / PAGE_SIZE) / 8) );
                        Scb->ScbType.Data.WriteMask = WriteMask;
                        RtlZeroMemory(WriteMask, (((0x2000000) / PAGE_SIZE) / 8));
                    }

                    if (Off < 0x2000000) {
                        Len = (ULONG)ByteCount;
                        if ((Off + Len) > 0x2000000) {
                            Len = 0x2000000 - Off;
                        }
                        while (Len != 0) {

                            ASSERT( !FlagOn( Scb->ScbState, SCB_STATE_SYSCACHE_FILE ) ||
                                    (WriteMask[(Off / PAGE_SIZE)/32] & (1 << ((Off / PAGE_SIZE) % 32))));

                            Off += PAGE_SIZE;
                            if (Len <= PAGE_SIZE) {
                                break;
                            }
                            Len -= PAGE_SIZE;
                        }
                    }
#endif

                //
                //  Now flush these pages to reallocate them.
                //

                Irp->IoStatus.Status = NtfsFlushUserStream( IrpContext,
                                                            Scb,
                                                            &FileOffset,
                                                            (ULONG)ByteCount );

                //
                //  On error get out.
                //

                NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                    &Irp->IoStatus.Status,
                                                    TRUE,
                                                    STATUS_UNEXPECTED_IO_ERROR );

#ifdef SYSCACHE

                //
                //  Verify writes occurred after the flush
                //

                    Off = (ULONG)FileOffset;

                    WriteMask = Scb->ScbType.Data.WriteMask;

                    if (Off < 0x2000000) {
                        Len = (ULONG)ByteCount;
                        if ((Off + Len) > 0x2000000) {
                            Len = 0x2000000 - Off;
                        }
                        while (Len != 0) {
                            ASSERT(WriteMask[(Off / PAGE_SIZE)/32] & (1 << ((Off / PAGE_SIZE) % 32)));

                            Off += PAGE_SIZE;
                            if (Len <= PAGE_SIZE) {
                                break;
                            }
                            Len -= PAGE_SIZE;
                        }
                    }
                }
#endif

                //
                //  Release any remaing reserved clusters in this range.
                //

                NtfsFreeReservedClusters( Scb, FileOffset, (ULONG) ByteCount );

                //
                //  Advance the FileOffset.
                //

                FileOffset += ByteCount;

                //
                //  If we hit the end of the file then exit while holding the
                //  resource so we can turn compression off.
                //

                if (FileOffset == Scb->Header.FileSize.QuadPart) {

                    break;
                }

                //
                //  Unlock the header an let anyone else access the file before
                //  looping back.
                //

                FsRtlUnlockFsRtlHeader( &Scb->Header );
                ExReleaseResourceLite( Scb->Header.PagingIoResource );
                IrpContext->CleanupStructure = NULL;
                FsRtlHeaderLocked = FALSE;
            }
        }

        //
        //  We have finished the conversion.  Now is the time to turn compression
        //  off.  Note that the compression flag in the Scb is already off.
        //

        if (CompressionState == 0) {

            VCN StartingCluster;

            //
            //  The paging Io resource may already be acquired.
            //

            if (!PagingIoAcquired && !FsRtlHeaderLocked) {
                if (Scb->Header.PagingIoResource != NULL) {
                    NtfsAcquireExclusivePagingIo( IrpContext, Fcb );
                    PagingIoAcquired = TRUE;
                }
            }

            NtfsAcquireExclusiveScb( IrpContext, Scb );

            if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

                try_return( Status = STATUS_VOLUME_DISMOUNTED );
            }

            //
            //  Changing the compression state to uncompressed is a ticklish thing.
            //  We need to make sure that all of the compression units are valid for
            //  the entire allocation for the file.  For non-sparse files all compression
            //  units should be fully allocation.  For sparse files all compression
            //  units should be either fully allocated or fully unallocated.  The interesting
            //  case is typically when the file size of a compressed file is dropped but
            //  the allocation remains.  The allocation in that range may be in the compressed
            //  format.  We need to proactively remove it.
            //
            //  In the non-sparse case we have already rewritten the data all the way
            //  through file size.  We only have to remove the allocation past the
            //  cluster containing Eof.
            //
            //  In the sparse case we actually have to deal with allocated ranges
            //  in the range between valid data length and file size as well.  We
            //  didn't rewrite this in the flush path above because we don't want
            //  to allocate clusters for zeroes.
            //
            //  The action of deallocating the clusters past file size must be tied
            //  in with the transaction of flipping the compression state.
            //

            if (!FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                //
                //  In all cases we can remove the clusters in the compression
                //  units past that containing Eof.
                //

                StartingCluster = Scb->Header.FileSize.QuadPart + Scb->CompressionUnit - 1;
                ((PLARGE_INTEGER) &StartingCluster)->LowPart &= ~(Scb->CompressionUnit - 1);

                if (StartingCluster < Scb->Header.AllocationSize.QuadPart) {

                    //
                    //  Deallocate the space past the filesize
                    //

                    NtfsDeleteAllocation( IrpContext,
                                          IoGetCurrentIrpStackLocation( IrpContext->OriginatingIrp )->FileObject,
                                          Scb,
                                          LlClustersFromBytesTruncate( Vcb, StartingCluster ),
                                          MAXLONGLONG,
                                          TRUE,
                                          TRUE );
                }

                //
                //  For sparse files we need to handle the allocation between valid data length
                //  and allocation size.
                //

                if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

                    //
                    //  Assume that the data up to either ValidDataLength or ValidDataToDisk
                    //  is valid.  Start at the compression unit after that.
                    //

                    StartingCluster = Scb->Header.ValidDataLength.QuadPart;

                    if (Scb->ValidDataToDisk > StartingCluster) {
                        StartingCluster = Scb->ValidDataToDisk;
                    }

                    StartingCluster += Scb->CompressionUnit - 1;

                    ((PLARGE_INTEGER) &StartingCluster)->LowPart &= ~(Scb->CompressionUnit - 1);

                    if (StartingCluster < Scb->Header.AllocationSize.QuadPart) {

                        NtfsDeleteAllocation( IrpContext,
                                              IoGetCurrentIrpStackLocation( IrpContext->OriginatingIrp )->FileObject,
                                              Scb,
                                              LlClustersFromBytesTruncate( Vcb, StartingCluster ),
                                              LlClustersFromBytesTruncate( Vcb, Scb->Header.AllocationSize.QuadPart ) - 1,
                                              TRUE,
                                              TRUE );
                    }
                }

                //
                //  If total allocated has changed then remember to report it.
                //

                if (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA ) &&
                    (Scb->Fcb->Info.AllocatedLength != Scb->TotalAllocated)) {

                    Scb->Fcb->Info.AllocatedLength = Scb->TotalAllocated;
                    SetFlag( Scb->Fcb->InfoFlags, FCB_INFO_CHANGED_ALLOC_SIZE );
                }

                //
                //  Check whether there is more to be truncated when the handle is closed.
                //

                SetFlag( Scb->ScbState, SCB_STATE_TRUNCATE_ON_CLOSE );
            }

            NtfsChangeAttributeCompression( IrpContext, Scb, Vcb, Ccb, 0 );
            Scb->AttributeFlags &= (USHORT)~ATTRIBUTE_FLAG_COMPRESSION_MASK;

            //
            //  Reset the VDD since its not used for uncompressed files
            //

            Scb->ValidDataToDisk = 0;

            //
            //  No need to set the WRITE_COMPRESSED flag on error.
            //

            ClearFlag( ScbRestoreState, SCB_STATE_WRITE_COMPRESSED );

            if (!FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT ) &&
                (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE ))) {

                if (Scb->ScbType.Data.ReservedBitMap != NULL) {

                    NtfsDeleteReservedBitmap( Scb );
                }
            }

            //
            //  Now clear the REALLOCATE_ON_WRITE flag while holding both resources.
            //

            ClearFlag( Scb->ScbState, SCB_STATE_REALLOCATE_ON_WRITE | SCB_STATE_COMPRESSION_CHANGE );
        }

        //
        //  Unlock the header if we locked it.
        //

        if (FsRtlHeaderLocked) {
            FsRtlUnlockFsRtlHeader( &Scb->Header );
            ExReleaseResourceLite( Scb->Header.PagingIoResource );
            IrpContext->CleanupStructure = NULL;
            FsRtlHeaderLocked = FALSE;
        }

        Status = STATUS_SUCCESS;

#ifdef SYSCACHE_DEBUG
        if (ScbIsBeingLogged( Scb )) {
            FsRtlLogSyscacheEvent( Scb, SCE_SETCOMPRESS, 0, Scb->ValidDataToDisk, Scb->Header.ValidDataLength.QuadPart, 0 );
        }
#endif

    try_exit: NOTHING;

        //
        //  Now clear the reallocate flag in the Scb if we set it.
        //

        if (NextIrpSp->Parameters.FileSystemControl.OutputBufferLength != MAXULONG) {

            ClearFlag( Scb->ScbState, SCB_STATE_REALLOCATE_ON_WRITE | SCB_STATE_COMPRESSION_CHANGE );
        }

    } finally {

        DebugUnwind( NtfsSetCompression );

        //
        //  NtfsCompleteRequest will clean up the Fsrtl header but
        //  we still need to release the paging resource if held.
        //

        if (FsRtlHeaderLocked) {

            ExReleaseResourceLite( Scb->Header.PagingIoResource );
        }

        //
        //  If this is an abnormal termination then undo our work
        //

        if (AbnormalTermination()) {

            //
            //  If we have started the transformation and are in the exception path
            //  we are either going to continue the operation after a clean
            //  checkpoint or we are done.
            //

            if (NextIrpSp->Parameters.FileSystemControl.OutputBufferLength != MAXULONG) {

                //
                //  If we are continuing the operation, save the current file offset.
                //

                if (IrpContext->ExceptionStatus == STATUS_LOG_FILE_FULL ||
                    IrpContext->ExceptionStatus == STATUS_CANT_WAIT) {

                    NextIrpSp->Parameters.FileSystemControl.OutputBufferLength = (ULONG)FileOffset;
                    NextIrpSp->Parameters.FileSystemControl.InputBufferLength = ((PLARGE_INTEGER)&FileOffset)->HighPart;

                //
                //  Otherwise clear the REALLOCATE_ON_WRITE flag and set the
                //  COMPRESSED flag if needed.
                //

                } else {

                    ClearFlag( Scb->ScbState, SCB_STATE_REALLOCATE_ON_WRITE | SCB_STATE_COMPRESSION_CHANGE );
                    SetFlag( Scb->ScbState, ScbRestoreState );

                    ASSERT( !FlagOn( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED ) ||
                            (Scb->CompressionUnit != 0) );
                }
            }
        }
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );

    ASSERT( !NT_SUCCESS( Status ) ||
            (CompressionState != 0) ||
            !FlagOn( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED ) ||
            (Scb->CompressionUnit != 0) );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsMarkAsSystemHive (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the registry to identify the registry handles.  We
    will mark this in the Ccb and use it during FlushBuffers to know to do a
    careful flush.

Arguments:

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Always make this synchronous.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    //
    //  Extract and decode the file object
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  We only permit this request on files and we must be called from kernel mode.
    //

    if (Irp->RequestorMode != KernelMode ||
        TypeOfOpen != UserFileOpen) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace( -1, Dbg, ("NtfsOplockRequest -> STATUS_INVALID_PARAMETER\n") );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Now acquire the file and mark the Ccb and return SUCCESS.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    NtfsAcquireExclusiveScb( IrpContext, Scb );

    SetFlag( Ccb->Flags, CCB_FLAG_SYSTEM_HIVE );

    NtfsReleaseScb( IrpContext, Scb );

    NtfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

    return STATUS_SUCCESS;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsGetStatistics (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the filesystem performance counters for the
    volume referred to.

Arguments:

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PFILE_SYSTEM_STATISTICS Buffer;
    ULONG BufferLength;
    ULONG StatsSize;
    ULONG BytesToCopy;

    PAGED_CODE();

    //
    //  Get the current stack location and extract the output
    //  buffer information.  The output parameter will receive
    //  the performance counters.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // Extract the buffer
    //

    Buffer = Irp->AssociatedIrp.SystemBuffer;
    BufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

    //
    //  Get a pointer to the output buffer.
    //

    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Make sure the buffer is big enough for at least the common part.
    //

    if (BufferLength < sizeof(FILESYSTEM_STATISTICS)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  Now see how many bytes we can copy.
    //

    StatsSize = sizeof(FILE_SYSTEM_STATISTICS) * KeNumberProcessors;

    if (BufferLength < StatsSize) {

        BytesToCopy = BufferLength;
        Status = STATUS_BUFFER_OVERFLOW;

    } else {

        BytesToCopy = StatsSize;
        Status = STATUS_SUCCESS;
    }

    //
    //  Decode the file object
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb,
                                       &Fcb, &Scb, &Ccb, TRUE );

    if (TypeOfOpen == UnopenedFileObject) {

        Status = STATUS_INVALID_PARAMETER;

    } else {

        //
        //  Fill in the output buffer
        //

        RtlCopyMemory( Buffer, Vcb->Statistics, BytesToCopy );

        Irp->IoStatus.Information = BytesToCopy;
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsGetVolumeData (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    Returns a filled in VOLUME_DATA structure in the user output buffer.

Arguments:

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The return status for the operation.

--*/

{
    PIO_STACK_LOCATION IrpSp;
    ULONG FsControlCode;
    NTSTATUS Status = STATUS_SUCCESS;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    BOOLEAN AcquiredScb = FALSE;
    BOOLEAN AcquiredVcb = FALSE;

    PNTFS_VOLUME_DATA_BUFFER VolumeData;
    PNTFS_EXTENDED_VOLUME_DATA ExtendedBuffer;
    ULONG ExtendedBufferLength;
    ULONG VolumeDataLength;

    //
    // Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    DebugTrace( +1, Dbg, ("NtfsGetVolumeData, FsControlCode = %08lx\n", FsControlCode) );

    //
    // Extract and decode the file object and check for type of open.
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if (TypeOfOpen == UnopenedFileObject) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Get the output buffer length and pointer.
    //

    VolumeDataLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;
    VolumeData = (PNTFS_VOLUME_DATA_BUFFER)Irp->AssociatedIrp.SystemBuffer;

    //
    //  Check for a minimum length on the ouput buffer.
    //

    if (VolumeDataLength < sizeof(NTFS_VOLUME_DATA_BUFFER)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        return STATUS_BUFFER_TOO_SMALL;
    }

    NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
    AcquiredVcb = TRUE;

    try {

        //
        //  Make sure the volume is still mounted.
        //

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  Acquire the volume bitmap and fill in the volume data structure.
        //

        NtfsAcquireExclusiveScb( IrpContext, Vcb->BitmapScb );
        AcquiredScb = TRUE;

        NtfsReleaseVcb( IrpContext, Vcb );
        AcquiredVcb = FALSE;

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  We may need to rescan the bitmap if there is a chance we have
        //  performed the upgrade to get an accurate count of free clusters.
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_RELOAD_FREE_CLUSTERS ) &&
            FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            NtfsScanEntireBitmap( IrpContext, Vcb, FALSE );
        }

        VolumeData->VolumeSerialNumber.QuadPart = Vcb->VolumeSerialNumber;
        VolumeData->NumberSectors.QuadPart = Vcb->NumberSectors;
        VolumeData->TotalClusters.QuadPart = Vcb->TotalClusters;
        VolumeData->FreeClusters.QuadPart = Vcb->FreeClusters;
        VolumeData->TotalReserved.QuadPart = Vcb->TotalReserved;
        VolumeData->BytesPerSector = Vcb->BytesPerSector;
        VolumeData->BytesPerCluster = Vcb->BytesPerCluster;
        VolumeData->BytesPerFileRecordSegment = Vcb->BytesPerFileRecordSegment;
        VolumeData->ClustersPerFileRecordSegment = Vcb->ClustersPerFileRecordSegment;
        VolumeData->MftValidDataLength = Vcb->MftScb->Header.ValidDataLength;
        VolumeData->MftStartLcn.QuadPart = Vcb->MftStartLcn;
        VolumeData->Mft2StartLcn.QuadPart = Vcb->Mft2StartLcn;
        VolumeData->MftZoneStart.QuadPart = Vcb->MftZoneStart;
        VolumeData->MftZoneEnd.QuadPart = Vcb->MftZoneEnd;

        if (VolumeData->MftZoneEnd.QuadPart > Vcb->TotalClusters) {

            VolumeData->MftZoneEnd.QuadPart = Vcb->TotalClusters;
        }

        //
        //  Check if there is anything to add in the extended data.
        //

        ExtendedBufferLength = VolumeDataLength - sizeof( NTFS_VOLUME_DATA_BUFFER );
        VolumeDataLength = sizeof( NTFS_VOLUME_DATA_BUFFER );
        ExtendedBuffer = (PNTFS_EXTENDED_VOLUME_DATA) Add2Ptr( VolumeData, sizeof( NTFS_VOLUME_DATA_BUFFER ));

        if (ExtendedBufferLength >= sizeof( NTFS_EXTENDED_VOLUME_DATA )) {

            ExtendedBuffer->ByteCount = sizeof( NTFS_EXTENDED_VOLUME_DATA );
            ExtendedBuffer->MajorVersion = Vcb->MajorVersion;
            ExtendedBuffer->MinorVersion = Vcb->MinorVersion;

        } else if (ExtendedBufferLength >= FIELD_OFFSET( NTFS_EXTENDED_VOLUME_DATA, MinorVersion )) {

            ExtendedBuffer->ByteCount = FIELD_OFFSET( NTFS_EXTENDED_VOLUME_DATA, MinorVersion );
            ExtendedBuffer->MajorVersion = Vcb->MajorVersion;

        } else if (ExtendedBufferLength >= FIELD_OFFSET( NTFS_EXTENDED_VOLUME_DATA, MajorVersion )) {

            ExtendedBuffer->ByteCount = FIELD_OFFSET( NTFS_EXTENDED_VOLUME_DATA, MajorVersion );

        } else {

            leave;
        }

        VolumeDataLength += ExtendedBuffer->ByteCount;

    } finally {

        if (AcquiredScb) {

            NtfsReleaseScb( IrpContext, Vcb->BitmapScb );
        }

        if (AcquiredVcb) {

            NtfsReleaseVcb( IrpContext, Vcb );
        }
    }

    //
    //  If nothing raised then complete the irp.
    //

    Irp->IoStatus.Information = VolumeDataLength;

    NtfsCompleteRequest( IrpContext, Irp, Status );

    DebugTrace( -1, Dbg, ("NtfsGetVolumeData -> VOID\n") );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsGetVolumeBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine scans volume bitmap and returns the requested range.

        Input = the GET_BITMAP data structure is passed in through the input buffer.
        Output = the VOLUME_BITMAP data structure is returned through the output buffer.

Arguments:

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    ULONG FsControlCode;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PSTARTING_LCN_INPUT_BUFFER GetBitmap;
    ULONG GetBitmapLength;

    PVOLUME_BITMAP_BUFFER VolumeBitmap;
    ULONG VolumeBitmapLength;

    ULONG BitsWritten;

    LCN Lcn;
    LCN StartingLcn;
    ULONG Offset;

    RTL_BITMAP Bitmap;
    PBCB BitmapBcb = NULL;
    BOOLEAN AccessingUserBuffer = FALSE;
    BOOLEAN ReleaseScb = FALSE;

    //
    //  Don't post this request, we can't lock both input and output buffers.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    DebugTrace( +1, Dbg, ("NtfsGetVolumeBitmap, FsControlCode = %08lx\n", FsControlCode) );

    //
    //  Extract and decode the file object and check for type of open.
    //  Send FALSE to indicate that we don't want to raise on dismounts
    //  because we'll check for that further down anyway.
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );

    //
    //  Get the input & output buffer lengths and pointers.
    //

    GetBitmapLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    GetBitmap = (PSTARTING_LCN_INPUT_BUFFER)IrpSp->Parameters.FileSystemControl.Type3InputBuffer;

    VolumeBitmapLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;
    VolumeBitmap = (PVOLUME_BITMAP_BUFFER)NtfsMapUserBuffer( Irp );

    //
    //  Check the type of open and minimum requirements for the IO buffers.
    //

    if ((Ccb == NULL) ||
        !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        DebugTrace( -1, Dbg, ("NtfsGetVolumeBitmap -> STATUS_ACCESS_DENIED\n") );
        return STATUS_ACCESS_DENIED;

    } else if (VolumeBitmapLength < sizeof( VOLUME_BITMAP_BUFFER )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        DebugTrace( -1, Dbg, ("NtfsGetVolumeBitmap -> STATUS_BUFFER_TOO_SMALL\n") );
        return STATUS_BUFFER_TOO_SMALL;

    } else if (GetBitmapLength < sizeof( STARTING_LCN_INPUT_BUFFER )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        DebugTrace( -1, Dbg, ("NtfsGetVolumeBitmap -> STATUS_INVALID_PARAMETER\n") );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Probe the user's buffers and capture the input values.
    //

    try {

        if (Irp->RequestorMode != KernelMode) {

            ProbeForRead( GetBitmap, GetBitmapLength, sizeof( UCHAR ));
            ProbeForWrite( VolumeBitmap, VolumeBitmapLength, sizeof( UCHAR ));
        }

        StartingLcn = GetBitmap->StartingLcn.QuadPart;

    } except(EXCEPTION_EXECUTE_HANDLER) {

        NtfsRaiseStatus( IrpContext, STATUS_INVALID_USER_BUFFER, NULL, NULL);
    }

    //
    //  Acquire the volume bitmap and check for a valid requested Lcn.
    //

    NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

    if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

        NtfsReleaseVcb( IrpContext, Vcb );
        NtfsCompleteRequest( IrpContext, Irp, STATUS_VOLUME_DISMOUNTED );
        DebugTrace( -1, Dbg, ("NtfsGetVolumeBitmap -> STATUS_VOLUME_DISMOUNTED\n") );
        return STATUS_VOLUME_DISMOUNTED;
    }

    try {

        //
        //  Acquire the volume bitmap and check for a valid requested Lcn.
        //  We no longer care about the Scb we were called with.
        //

        Scb = Vcb->BitmapScb;
        NtfsAcquireSharedScb( IrpContext, Scb );
        NtfsReleaseVcb( IrpContext, Vcb );

        //
        //  Setting this flag to TRUE indicates we have the Scb but not the Vcb.
        //

        ReleaseScb = TRUE;

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        if ((StartingLcn < 0L) ||
            (StartingLcn >= Vcb->TotalClusters)) {

            Status = STATUS_INVALID_PARAMETER;
            leave;
        }

        //
        //  Read in the volume bitmap page by page and copy it into the UserBuffer.
        //

        VolumeBitmapLength -= FIELD_OFFSET(VOLUME_BITMAP_BUFFER, Buffer);

        //
        //  Use a try-except to catch user buffer problems.
        //

        try {

            for (Lcn = StartingLcn, BitsWritten = 0;
                 Lcn < Vcb->TotalClusters;
                 Lcn = Lcn + Bitmap.SizeOfBitMap) {

                ULONG BytesToCopy;

                //
                //  Read in the bitmap page and make sure that we haven't messed up the math.
                //

                DebugTrace( 0, Dbg, ("Mapping bitmap from Lcn %I64x\n", (LONGLONG) Lcn) );

                NtfsUnpinBcb( IrpContext, &BitmapBcb );
                NtfsMapPageInBitmap( IrpContext, Vcb, Lcn, &Lcn, &Bitmap, &BitmapBcb );

                //
                //  If this is first iteration, update StartingLcn with actual
                //  starting cluster returned.
                //

                if (BitsWritten == 0) {

                    Offset = (ULONG)(StartingLcn - Lcn) / 8;

                }

                //
                //  Check to see if we have enough user buffer.  If have some but
                //  not enough, copy what we can and return STATUS_BUFFER_OVERFLOW.
                //  If we are down to 0 (i.e. previous iteration used all the
                //  buffer), break right now.
                //

                BytesToCopy = ((Bitmap.SizeOfBitMap + 7) / 8) - Offset;

                if (BytesToCopy > VolumeBitmapLength) {

                    BytesToCopy = VolumeBitmapLength;
                    Status = STATUS_BUFFER_OVERFLOW;

                    if (BytesToCopy == 0) {
                        break;
                    }
                }

                //
                //  Now copy it into the UserBuffer.
                //

                AccessingUserBuffer = TRUE;
                RtlCopyMemory(&VolumeBitmap->Buffer[BitsWritten / 8], (PUCHAR)Bitmap.Buffer + Offset, BytesToCopy);
                AccessingUserBuffer = FALSE;

                //
                //  If this was an overflow, bump up bits written and continue
                //

                if (Status != STATUS_BUFFER_OVERFLOW) {

                    BitsWritten += Bitmap.SizeOfBitMap - (Offset * 8);
                    VolumeBitmapLength -= BytesToCopy;

                } else {

                    BitsWritten += BytesToCopy * 8;
                    break;
                }

                Offset = 0;
            }

            AccessingUserBuffer = TRUE;

            //
            //  Lower StartingLcn to the byte we started on
            //

            VolumeBitmap->StartingLcn.QuadPart = StartingLcn & ~7L;
            VolumeBitmap->BitmapSize.QuadPart = Vcb->TotalClusters - VolumeBitmap->StartingLcn.QuadPart;
            AccessingUserBuffer = FALSE;

            Irp->IoStatus.Information =
                FIELD_OFFSET(VOLUME_BITMAP_BUFFER, Buffer) + (BitsWritten + 7) / 8;

        } except( NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), AccessingUserBuffer, &Status ) ) {

            //
            //  Convert any unexpected error to INVALID_USER_BUFFER if we
            //  are writing in the user's buffer.
            //

            NtfsRaiseStatus( IrpContext,
                             STATUS_INVALID_USER_BUFFER,
                             NULL,
                             NULL );
        }

    } finally {

        DebugUnwind( NtfsGetVolumeBitmap );

        NtfsUnpinBcb( IrpContext, &BitmapBcb );

        if (ReleaseScb) {

            NtfsReleaseScb( IrpContext, Scb );

        } else {

            NtfsReleaseVcb( IrpContext, Vcb );
        }
    }

    //
    //  If nothing raised then complete the irp.
    //

    NtfsCompleteRequest( IrpContext, Irp, Status );

    DebugTrace( -1, Dbg, ("NtfsGetVolumeBitmap -> VOID\n") );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsGetRetrievalPointers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine scans the array of MCBs for the given SCB and builds an extent
    list.  The first run in the output extent list will start at the begining
    of the contiguous run specified by the input parameter.

        Input = STARTING_VCN_INPUT_BUFFER;
        Output = RETRIEVAL_POINTERS_BUFFER.

Arguments:

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    VCN Vcn;
    VCN LastVcnInFile;
    LCN Lcn;
    LONGLONG ClusterCount;
    LONGLONG CountFromStartingVcn;
    LONGLONG StartingVcn;

    ULONG FileRunIndex = 0;
    ULONG RangeRunIndex;

    ULONG InputBufferLength;
    ULONG OutputBufferLength;

    PVOID RangePtr;

    PRETRIEVAL_POINTERS_BUFFER OutputBuffer;
    BOOLEAN AccessingUserBuffer = FALSE;

    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
    BOOLEAN CleanupAttributeContext = FALSE;


    //
    //  Don't post this request, we can't lock both input and output buffers.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsGetRetrievalPointers\n") );

    //
    //  Extract and decode the file object and check for type of open.
    //  If we ever decide to support UserDirectoryOpen also, make sure
    //  to check for Scb->AttributeTypeCode != $INDEX_ALLOCATION when
    //  checking whether the Scb header is initialized.  Otherwise we'll
    //  have trouble with phantom Scbs created for small directories.
    //

    //
    //  Get the input and output buffer lengths and pointers.
    //  Initialize some variables.
    //

    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    OutputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

    OutputBuffer = (PRETRIEVAL_POINTERS_BUFFER)NtfsMapUserBuffer( Irp );

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );

    if (((TypeOfOpen != UserFileOpen) &&
         (TypeOfOpen != UserDirectoryOpen) &&
         (TypeOfOpen != UserViewIndexOpen)) ||
        (InputBufferLength < sizeof( STARTING_VCN_INPUT_BUFFER ))) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    if (OutputBufferLength < sizeof( RETRIEVAL_POINTERS_BUFFER )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  Acquire exclusive access to the Scb.  We don't want other threads
    //  to extend or move the file while we're trying to return the
    //  retrieval pointers for it.  We need it exclusve to call PreloadAllocation.
    //

    NtfsAcquireExclusiveScb( IrpContext, Scb );

    try {

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
        }

        //
        //  There are three separate places inside this try/except where we
        //  access the user-supplied buffer.  We want to handle exceptions
        //  differently if they happen while we are trying to access the user
        //  buffer than if they happen elsewhere in the try/except.  We set
        //  this boolean immediately before touching the user buffer, and
        //  clear it immediately after.
        //

        try {

            AccessingUserBuffer = TRUE;
            if (Irp->RequestorMode != KernelMode) {

                ProbeForRead( IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                              InputBufferLength,
                              sizeof(UCHAR) );

                ProbeForWrite( OutputBuffer, OutputBufferLength, sizeof(UCHAR) );
            }

            StartingVcn = ((PSTARTING_VCN_INPUT_BUFFER)IrpSp->Parameters.FileSystemControl.Type3InputBuffer)->StartingVcn.QuadPart;

            //
            //  While we have AccessingUserBuffer set to TRUE, let's initialize the
            //  extentcount.  We increment this for each run in the mcb, so we need
            //  to initialize it outside the main do while loop.
            //

            OutputBuffer->ExtentCount = 0;
            OutputBuffer->StartingVcn.QuadPart = 0;
            AccessingUserBuffer = FALSE;

            //
            //  If the Scb is uninitialized, we initialize it now.
            //

            if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

                //
                //  Non-index Scb's are trivial to initialize;  index Scb's
                //  do not necessarily have an attribute to back them up:
                //  the index Scb is for the index allocation attribute which
                //  may not be present if the entire index fits in the $INDEX_ROOT.
                //
                //  We look for the attribute on disk.  If it is there, we
                //  update from it.  Otherwise, if it is $INDEX_ALLOCATION we
                //  treat it as a resident attribute.  Finally, we fail it.
                //

                NtfsInitializeAttributeContext( &AttributeContext );
                CleanupAttributeContext = TRUE;

                if (!NtfsLookupAttributeByName( IrpContext,
                                                Scb->Fcb,
                                                &Scb->Fcb->FileReference,
                                                Scb->AttributeTypeCode,
                                                &Scb->AttributeName,
                                                NULL,
                                                FALSE,
                                                &AttributeContext )) {

                    //
                    //  Verify that this is an index allocation attribute.
                    //  If not, raise an error.
                    //

                    if (Scb->AttributeTypeCode != $INDEX_ALLOCATION) {
                        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                    }

                    Irp->IoStatus.Information = 0;
                    Status = STATUS_SUCCESS;
                    leave;

                } else {
                    NtfsUpdateScbFromAttribute( IrpContext,
                                                Scb,
                                                NtfsFoundAttribute( &AttributeContext ));
                }
            }

            //
            //  If the data attribute is resident (typically for a small file),
            //  it is not safe to call NtfsPreloadAllocation.  There won't be
            //  any runs, and we've already set ExtentCount to 0, so we're done.
            //  FAT returns STATUS_END_OF_FILE for a zero-length file, so for
            //  consistency's sake, we'll return that in the resident case.
            //

            if (FlagOn(Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT)) {

                Irp->IoStatus.Information = 0;
                Status = STATUS_END_OF_FILE;
                leave;
            }

            //
            //  Check if a starting cluster was specified.
            //

            LastVcnInFile = LlClustersFromBytesTruncate( Vcb, Scb->Header.AllocationSize.QuadPart ) - 1;

            if (StartingVcn > LastVcnInFile) {

                //
                //  It's possible that the Vcn we were given is past the end of the file.
                //

                Status = STATUS_END_OF_FILE;
                leave;

            } else if (StartingVcn < 0) {

                //
                //  It's possible that the Vcn we were given is negative, and
                //  NtfsMcbLookupArrayIndex doesn't handle that very well.
                //

                Status = STATUS_INVALID_PARAMETER;
                leave;

            } else {

                //
                //  We need to call NtfsPreloadAllocation to make sure all the
                //  ranges in this NtfsMcb are loaded.
                //

                NtfsPreloadAllocation( IrpContext,
                                       Scb,
                                       StartingVcn,
                                       LastVcnInFile );

                //
                //  Decide which Mcb contains the starting Vcn.
                //

                (VOID)NtfsLookupNtfsMcbEntry( &Scb->Mcb,
                                              StartingVcn,
                                              NULL,
                                              &CountFromStartingVcn,
                                              &Lcn,
                                              &ClusterCount,
                                              &RangePtr,
                                              &RangeRunIndex );
            }

            //
            //  Fill in the Vcn where the run containing StartingVcn truly starts.
            //

            AccessingUserBuffer = TRUE;
            OutputBuffer->StartingVcn.QuadPart = Vcn = StartingVcn - (ClusterCount - CountFromStartingVcn);
            AccessingUserBuffer = FALSE;

            //
            //  FileRunIndex is the index of a given run within an entire
            //  file, as opposed to RangeRunIndex which is the index of a
            //  given run within its range.  RangeRunIndex is reset to 0 for
            //  each range, where FileRunIndex is set to 0 once out here.
            //

            FileRunIndex = 0;

            do {

                //
                //  Now copy over the mapping pairs from the mcb
                //  to the output buffer.  We store in [sector count, lbo]
                //  mapping pairs and end with a zero sector count.
                //

                //
                //  Check for an exhausted output buffer.
                //

                if ((ULONG)FIELD_OFFSET(RETRIEVAL_POINTERS_BUFFER, Extents[FileRunIndex+1]) > OutputBufferLength) {

                    //
                    //  We know that we're out of room in the output buffer, so we won't be looking up
                    //  any more runs.  ExtentCount currently reflects how many runs we stored in the
                    //  user buffer, so we can safely quit.  There are indeed ExtentCount extents stored
                    //  in the array, and returning STATUS_BUFFER_OVERFLOW informs our caller that we
                    //  didn't have enough room to return all the runs.
                    //

                    Irp->IoStatus.Information = FIELD_OFFSET(RETRIEVAL_POINTERS_BUFFER, Extents[FileRunIndex]);
                    Status = STATUS_BUFFER_OVERFLOW;
                    leave;
                }

                //
                //  Here's the interesting part -- we fill in the next array element in the ouput buffer
                //  with the current run's information.
                //

                AccessingUserBuffer = TRUE;
                OutputBuffer->Extents[FileRunIndex].NextVcn.QuadPart = Vcn + ClusterCount;
                OutputBuffer->Extents[FileRunIndex].Lcn.QuadPart = Lcn;

                OutputBuffer->ExtentCount += 1;
                AccessingUserBuffer = FALSE;

                FileRunIndex += 1;

                RangeRunIndex += 1;

            } while (NtfsGetSequentialMcbEntry( &Scb->Mcb, &RangePtr, RangeRunIndex, &Vcn, &Lcn, &ClusterCount));

            //
            //  We successfully retrieved extent info to the end of the allocation.
            //

            Irp->IoStatus.Information = FIELD_OFFSET(RETRIEVAL_POINTERS_BUFFER, Extents[FileRunIndex]);
            Status = STATUS_SUCCESS;

        } except( NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), AccessingUserBuffer, &Status ) ) {

            NtfsRaiseStatus( IrpContext,
                             STATUS_INVALID_USER_BUFFER,
                             NULL,
                             NULL );
        }

    } finally {

        DebugUnwind( NtfsGetRetrievalPointers );

        //
        //  Release resources.
        //

        NtfsReleaseScb( IrpContext, Scb );

        if (CleanupAttributeContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
        }

        DebugTrace( -1, Dbg, ("NtfsGetRetrievalPointers -> VOID\n") );
    }

    //
    //  If nothing raised then complete the irp.
    //

    NtfsCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsGetMftRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns a copy of the requested File Record Segment. A
    hint File Reference Number is passed in. If the hint File Record
    Segment is "not in use" then the MFT bitmap is scanned backwards
    from the hint until an "in use" File Record Segment is found. This
    File Record Segment is then returned along with the identifying File Reference Number.

        Input = the LONGLONG File Reference Number is passed in through the input buffer.
        Output = the FILE_RECORD data structure is returned through the output buffer.

Arguments:

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The return status for the operation.

--*/

{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PIO_STACK_LOCATION IrpSp;
    ULONG FsControlCode;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PNTFS_FILE_RECORD_INPUT_BUFFER GetFileRecord;
    ULONG GetFileRecordLength;

    PNTFS_FILE_RECORD_OUTPUT_BUFFER FileRecord;
    ULONG FileRecordLength;

    ULONG FileReferenceNumber;

    PFILE_RECORD_SEGMENT_HEADER MftBuffer;

    PBCB Bcb = NULL;
    PBCB BitmapBcb = NULL;

    BOOLEAN AcquiredMft = FALSE;
    RTL_BITMAP Bitmap;
    LONG BaseIndex;
    LONG Index;
    LONGLONG StartingByte;
    PUCHAR BitmapBuffer;
    ULONG SizeToMap;
    ULONG BytesToCopy;

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    DebugTrace( +1, Dbg, ("NtfsGetMftRecord, FsControlCode = %08lx\n", FsControlCode) );

    //
    //  Extract and decode the file object and check for type of open.
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Get the input & output buffer lengths and pointers.
    //

    GetFileRecordLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    GetFileRecord = (PNTFS_FILE_RECORD_INPUT_BUFFER)Irp->AssociatedIrp.SystemBuffer;

    FileRecordLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;
    FileRecord = (PNTFS_FILE_RECORD_OUTPUT_BUFFER)Irp->AssociatedIrp.SystemBuffer;;

    //
    //  Check for a minimum length on the input and ouput buffers.
    //

    if ((GetFileRecordLength < sizeof(NTFS_FILE_RECORD_INPUT_BUFFER)) ||
        (FileRecordLength < sizeof(NTFS_FILE_RECORD_OUTPUT_BUFFER))) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        return STATUS_BUFFER_TOO_SMALL;
    }

    FileRecordLength -= FIELD_OFFSET(NTFS_FILE_RECORD_OUTPUT_BUFFER, FileRecordBuffer);
    FileReferenceNumber = GetFileRecord->FileReferenceNumber.LowPart;

    //
    //  Make this request synchronous.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  Acquire the vcb to test for dismounted volume
    //

    NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

    try {

        LONGLONG ValidDataLength;

        //
        //  Synchronize the lookup by acquiring the Mft.  First test the  vcb we were
        //  called with in order to check for dismount.  The MftScb may have already been
        //  torn down.
        //

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
        }

        NtfsAcquireSharedScb( IrpContext, Vcb->MftScb );
        AcquiredMft = TRUE;

        //
        //  Raise if the File Reference Number is not within the MFT valid data length.
        //

        ValidDataLength = Vcb->MftScb->Header.ValidDataLength.QuadPart;

        if (FileReferenceNumber >= (ValidDataLength / Vcb->BytesPerFileRecordSegment)) {

            NtfsRaiseStatus( IrpContext, STATUS_INVALID_PARAMETER, NULL, NULL );
        }

        //
        //  Fill in the record size and determine how much of it we can copy.
        //

        FileRecord->FileRecordLength = Vcb->BytesPerFileRecordSegment;

        if (FileRecordLength >= Vcb->BytesPerFileRecordSegment) {

            BytesToCopy = Vcb->BytesPerFileRecordSegment;
            Status = STATUS_SUCCESS;

        } else {

            BytesToCopy = FileRecordLength;
            Status = STATUS_BUFFER_OVERFLOW;
        }

        //
        //  If it is the MFT file record then just get it and we are done.
        //

        if (FileReferenceNumber == 0) {

            NTSTATUS ErrorStatus;

            try {
                NtfsMapStream( IrpContext,
                               Vcb->MftScb,
                               0,
                               Vcb->BytesPerFileRecordSegment,
                               &Bcb,
                               (PVOID *)&MftBuffer );

            } except ( NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), TRUE, &ErrorStatus )) {

                //
                //  Clear the status field in the IrpContext. We're going to retry in the mirror
                //

                IrpContext->ExceptionStatus = STATUS_SUCCESS;

                NtfsMapStream( IrpContext,
                               Vcb->Mft2Scb,
                               0,
                               Vcb->BytesPerFileRecordSegment,
                               &Bcb,
                               (PVOID *)&MftBuffer );
            }

            //
            //  Return the File Reference Number and the File Record.
            //

            RtlCopyMemory(FileRecord->FileRecordBuffer, MftBuffer, BytesToCopy);
            FileRecord->FileReferenceNumber.QuadPart = 0;

            try_return( Status );
        }

        //
        //  Scan through the MFT Bitmap to find an "in use" file.
        //

        while (FileReferenceNumber > 0) {

            //
            //  Compute some values for the bitmap, convert the index to the offset of
            //  this page and get the base index for the File Reference number. Then
            //  map the page in the bitmap that contains the file record. Note we have to convert
            //  from bits to bytes to find it.
            //

            Index = FileReferenceNumber & (BITS_PER_PAGE - 1);
            BaseIndex = FileReferenceNumber - Index;

            StartingByte = BlockAlignTruncate( FileReferenceNumber / 8 , PAGE_SIZE );
            SizeToMap = min( PAGE_SIZE, (ULONG)(Vcb->MftBitmapScb->Header.ValidDataLength.QuadPart - StartingByte) );

            NtfsMapStream( IrpContext,
                           Vcb->MftBitmapScb,
                           StartingByte,
                           SizeToMap,
                           &BitmapBcb,
                           &BitmapBuffer );

            RtlInitializeBitMap(&Bitmap, (PULONG)BitmapBuffer, SizeToMap * 8);

            //
            //  Scan thru this page for an "in use" File Record.
            //

            for (; Index >= 0; Index --) {

                if (RtlCheckBit(&Bitmap, Index)) {

                    NTSTATUS ErrorStatus;

                    //
                    //  Found one "in use" on this page so get it and we are done.
                    //

                    try {
                        NtfsMapStream( IrpContext,
                                       Vcb->MftScb,
                                       Int64ShllMod32(BaseIndex + Index, Vcb->MftShift),
                                       Vcb->BytesPerFileRecordSegment,
                                       &Bcb,
                                       (PVOID *)&MftBuffer );

                    } except (NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), TRUE, &ErrorStatus)) {

                        //
                        //  Reset status for retry in the mirror
                        //

                        IrpContext->ExceptionStatus = STATUS_SUCCESS;
                        NtfsMapStream( IrpContext,
                                       Vcb->Mft2Scb,
                                       Int64ShllMod32(BaseIndex + Index, Vcb->MftShift),
                                       Vcb->BytesPerFileRecordSegment,
                                       &Bcb,
                                       (PVOID *)&MftBuffer );
                    }

                    //
                    //  Return the File Reference Number and the File Record.
                    //

                    RtlCopyMemory(FileRecord->FileRecordBuffer, MftBuffer, BytesToCopy);
                    FileRecord->FileReferenceNumber.QuadPart = BaseIndex + Index;

                    try_return( Status );
                }
            }

            //
            //  Cleanup for next time through and decrement the File Reference Number.
            //

            NtfsUnpinBcb( IrpContext, &BitmapBcb );
            FileReferenceNumber = BaseIndex - 1;
        }

    try_exit:  NOTHING;

    Irp->IoStatus.Information =
        FIELD_OFFSET(NTFS_FILE_RECORD_OUTPUT_BUFFER, FileRecordBuffer) +
        BytesToCopy;

    } finally {

        //
        //  Release resources and exit.
        //

        NtfsUnpinBcb( IrpContext, &BitmapBcb );
        NtfsUnpinBcb( IrpContext, &Bcb );

        if (AcquiredMft) {

            NtfsReleaseScb( IrpContext, Vcb->MftScb );
        }

        NtfsReleaseVcb( IrpContext, Vcb );

        DebugTrace( -1, Dbg, ("NtfsGetMftRecord:  Exit\n") );
    }

    //
    //  If nothing raised then complete the Irp.
    //

    NtfsCompleteRequest( IrpContext, Irp, Status );

    DebugTrace( -1, Dbg, ("NtfsGetMftRecord -> VOID\n") );

    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsIsVolumeDirty (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the dirty state of the volume.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PULONG VolumeState;
    PVOLUME_INFORMATION VolumeInfo;

    ATTRIBUTE_ENUMERATION_CONTEXT Context;

    //
    //  Get the current stack location and extract the output
    //  buffer information.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Get a pointer to the output buffer.  Look at the system buffer field in the
    //  irp first.  Then the Irp Mdl.
    //

    if (Irp->AssociatedIrp.SystemBuffer != NULL) {

        VolumeState = Irp->AssociatedIrp.SystemBuffer;

    } else if (Irp->MdlAddress != NULL) {

        VolumeState = MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority );

        if (VolumeState == NULL) {

            NtfsCompleteRequest( IrpContext, Irp, STATUS_INSUFFICIENT_RESOURCES );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_USER_BUFFER );
        return STATUS_INVALID_USER_BUFFER;
    }

    //
    //  Make sure the output buffer is large enough and then initialize
    //  the answer to be that the volume isn't corrupt.
    //

    if (IrpSp->Parameters.FileSystemControl.OutputBufferLength < sizeof(ULONG)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    *VolumeState = 0;

    //
    //  Decode the file object. We don't care to raise on dismounts here
    //  because we check for that further down anyway. Hence, RaiseOnError=FALSE.
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );

    if (TypeOfOpen != UserVolumeOpen) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Acquire the Scb shared.
    //

    NtfsAcquireSharedScb( IrpContext, Scb );

    //
    //  Make sure the volume is still mounted.
    //

    if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

        NtfsReleaseScb( IrpContext, Scb );
        NtfsCompleteRequest( IrpContext, Irp, STATUS_VOLUME_DISMOUNTED );
        return STATUS_VOLUME_DISMOUNTED;
    }

    //
    //  Look up the VOLUME_INFORMATION attribute.
    //

    NtfsInitializeAttributeContext( &Context );

    //
    //  Use a try-finally to perform cleanup.
    //

    try {

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Vcb->VolumeDasdScb->Fcb,
                                        &Vcb->VolumeDasdScb->Fcb->FileReference,
                                        $VOLUME_INFORMATION,
                                        &Context )) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        //
        //  Return the volume state and the size of the returned data.
        //

        VolumeInfo = (PVOLUME_INFORMATION) NtfsAttributeValue( NtfsFoundAttribute( &Context ));

        if (FlagOn( VolumeInfo->VolumeFlags, VOLUME_DIRTY )) {

            SetFlag( *VolumeState, VOLUME_IS_DIRTY );
        }

        if (FlagOn( VolumeInfo->VolumeFlags, VOLUME_UPGRADE_ON_MOUNT )) {

            SetFlag( *VolumeState, VOLUME_UPGRADE_SCHEDULED );
        }

        Irp->IoStatus.Information = sizeof( ULONG );

    } finally {

        NtfsReleaseScb( IrpContext, Scb );
        NtfsCleanupAttributeContext( IrpContext, &Context );
        DebugUnwind( NtfsIsVolumeDirty );
    }

    //
    //  If this is an abnormal termination then undo our work, otherwise
    //  complete the irp
    //

    NtfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
NtfsSetExtendedDasdIo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine will mark a Dasd handle to perform IO outside the logical bounds of
    the partition.  Any subsequent IO will be passed to the driver which can either
    complete it or return an error.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Decode the file object
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  Make sure this is a volume open.
    //

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Mark the Ccb for extended Io and return.
    //

    SetFlag( Ccb->Flags, CCB_FLAG_ALLOW_XTENDED_DASD_IO );

    NtfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
NtfsSetReparsePoint (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the reparse point attribute at the file object entry
    specified in the IRP.

    NtfsSetReparsePoint does not care whether the base file object is a user file or a
    user directory.

    If the file object has the FILE_ATTRIBUTE_REPARSE_POINT bit set then the
    $REPARSE_POINT attribute is expected to be in the file.

    If this file object already is a reparse point, and the tag of the incomming
    reparse point request coincides with that present in existing $REPARSE_POINT,
    then the contents of the $REPARSE_POINT attribute present will be overwritten.

    There is to be an IN buffer to bring the caller's data for the call.

    This function inserts an entry into the reparse point table.

Arguments:

    IrpContext - Supplies the Irp context of the call

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    ULONG FsControlCode;

    TYPE_OF_OPEN TypeOfOpen;

    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    PBCB Bcb = NULL;    //  does not get initialized below in NtfsDecodeFileObject

    PREPARSE_DATA_BUFFER ReparseBuffer = NULL;
    PREPARSE_GUID_DATA_BUFFER ReparseGuidBuffer = NULL;
    ULONG ReparseTag;
    USHORT ReparseDataLength = 0;   //  invalid value as it denotes no data
    ULONG InputBufferLength = 0;    //  invalid value as we need an input buffer
    ULONG OutputBufferLength = 0;   //  only valid value as we have no output buffer

    ULONG IncomingFileAttributes = 0;                               //  invalid value
    ULONG IncomingReparsePointTag = IO_REPARSE_TAG_RESERVED_ZERO;   //  invalid value

    BOOLEAN CleanupAttributeContext = FALSE;
    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
    BOOLEAN PagingIoAcquired = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    DebugTrace( +1, Dbg, ("NtfsSetReparsePoint, FsControlCode = %08lx\n", FsControlCode) );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );

    //
    //  Decode all the relevant File System data structures.
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext,
                                       IrpSp->FileObject,
                                       &Vcb,
                                       &Fcb,
                                       &Scb,
                                       &Ccb,
                                       TRUE );  // Raise an exeption if error is encountered

    //
    //  Check for the correct type of open.
    //

    //
    //  See that we have a file or a directory open.
    //

    if ((TypeOfOpen != UserFileOpen) && (TypeOfOpen != UserDirectoryOpen)) {

        //
        //  Return an invalid parameter error.
        //

        Status = STATUS_INVALID_PARAMETER;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Invalid parameter passed by caller.\n") );
        DebugTrace( -1, Dbg, ("NtfsSetReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  The caller has FILE_SPECIAL_ACCESS. The NTFS driver enforces access checks more stringent
    //  than FILE_ANY_ACCESS:
    //  (a) FILE_WRITE_DATA or FILE_WRITE_ATTRIBUTES_ACCESS
    //

    if (!FlagOn( Ccb->AccessFlags, WRITE_DATA_ACCESS | WRITE_ATTRIBUTES_ACCESS ) &&

        //
        //  Temporary KLUDGE for DavePr.
        //  The Ccb->AccessFlags and the FileObject->WriteAccess may not coincide as a
        //  filter may change the "visible" file object after the open. The Ccb flags do
        //  not change after open.
        //

        !IrpSp->FileObject->WriteAccess) {


        //
        //  Return access denied.
        //

        Status = STATUS_ACCESS_DENIED;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Ccb->AccessFlags %x\n", Ccb->AccessFlags) );
        DebugTrace( 0, Dbg, ("Caller did not have the appropriate access rights.\n") );
        DebugTrace( -1, Dbg, ("NtfsSetReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    ASSERT_VCB( Vcb );
    ASSERT_FCB( Fcb );
    ASSERT_SCB( Scb );
    ASSERT_CCB( Ccb );

    //
    //  Read only volumes stay read only.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        Status = STATUS_MEDIA_WRITE_PROTECTED;
        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( -1, Dbg, ("NtfsSetReparsePoint -> %08lx\n", Status) );
        return Status;
    }

    if (!NtfsVolumeVersionCheck( Vcb, NTFS_REPARSE_POINT_VERSION )) {

        //
        //  Return a volume not upgraded error.
        //

        Status = STATUS_VOLUME_NOT_UPGRADED;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Non-upgraded volume passed by caller.\n") );
        DebugTrace( -1, Dbg, ("NtfsSetReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  Get the length of the input and output buffers.
    //

    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    OutputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

    DebugTrace( 0, Dbg, ("InputBufferLength %08lx [d]%08d OutputBufferLength %08lx\n", InputBufferLength, InputBufferLength, OutputBufferLength) );

    //
    //  Do not allow output buffer in the set command.
    //

    if (OutputBufferLength > 0) {

        //
        //  Return an invalid parameter error.
        //

        Status = STATUS_INVALID_PARAMETER;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Non-null output buffer.\n") );
        DebugTrace( -1, Dbg, ("NtfsSetReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  Zero the Information field in IoStatus.
    //

    Irp->IoStatus.Information = 0;

    //
    //  Verify that we have the required system input buffer.
    //

    if (Irp->AssociatedIrp.SystemBuffer == NULL) {

        //
        //  Return an invalid buffer error.
        //

        Status = STATUS_INVALID_BUFFER_SIZE;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Null buffer passed by system.\n") );
        DebugTrace( -1, Dbg, ("NtfsSetReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  Be defensive about the length of the incomming buffer before re-referencing it.
    //

    ASSERT( REPARSE_DATA_BUFFER_HEADER_SIZE < REPARSE_GUID_DATA_BUFFER_HEADER_SIZE );

    if (InputBufferLength < REPARSE_DATA_BUFFER_HEADER_SIZE) {

        //
        //  Return invalid buffer parameter error.
        //

        Status = STATUS_IO_REPARSE_DATA_INVALID;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Data in input buffer is too short.\n") );
        DebugTrace( -1, Dbg, ("NtfsSetReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  Return if the input buffer is too long.
    //

    if (InputBufferLength > MAXIMUM_REPARSE_DATA_BUFFER_SIZE) {

        //
        //  Return invalid buffer parameter error.
        //

        Status = STATUS_IO_REPARSE_DATA_INVALID;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Data in system buffer is too long.\n") );
        DebugTrace( -1, Dbg, ("NtfsSetReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  Get the header information brought in the input buffer.
    //  While all the headers coincide in the layout of the first three fields we are home free.
    //

    ASSERT( FIELD_OFFSET(REPARSE_DATA_BUFFER, ReparseTag) == FIELD_OFFSET(REPARSE_GUID_DATA_BUFFER, ReparseTag) );
    ASSERT( FIELD_OFFSET(REPARSE_DATA_BUFFER, ReparseDataLength) == FIELD_OFFSET(REPARSE_GUID_DATA_BUFFER, ReparseDataLength) );
    ASSERT( FIELD_OFFSET(REPARSE_DATA_BUFFER, Reserved) == FIELD_OFFSET(REPARSE_GUID_DATA_BUFFER, Reserved) );

    ReparseBuffer = (PREPARSE_DATA_BUFFER)Irp->AssociatedIrp.SystemBuffer;
    ReparseTag = ReparseBuffer->ReparseTag;
    ReparseDataLength = ReparseBuffer->ReparseDataLength;
    ReparseGuidBuffer = (PREPARSE_GUID_DATA_BUFFER)Irp->AssociatedIrp.SystemBuffer;

    DebugTrace( 0, Dbg, ("ReparseTag = %08lx, ReparseDataLength = [x]%08lx [d]%08ld\n", ReparseTag, ReparseDataLength, ReparseDataLength) );

    //
    //  Check for invalid conditions in the parameters.
    //  First, parameter validation for the amounts of user-controlled data.
    //

    //
    //  Verify that the user buffer and the data length in its header are
    //  internally consistent. We need to have a REPARSE_DATA_BUFFER or a
    //  REPARSE_GUID_DATA_BUFFER.
    //

    if (((ULONG)(ReparseDataLength + REPARSE_DATA_BUFFER_HEADER_SIZE) != InputBufferLength) &&
        ((ULONG)(ReparseDataLength + REPARSE_GUID_DATA_BUFFER_HEADER_SIZE) != InputBufferLength)) {

        //
        //  Return invalid buffer parameter error.
        //

        Status = STATUS_IO_REPARSE_DATA_INVALID;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("User-controlled data in buffer is not self-consistent.\n") );
        DebugTrace( -1, Dbg, ("NtfsSetReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  Sanity check the buffer size combination reserved for Microsoft tags.
    //

    if ((ULONG)(ReparseDataLength + REPARSE_DATA_BUFFER_HEADER_SIZE) == InputBufferLength) {

        //
        //  This buffer length can only be used with Microsoft tags.
        //

        if (!IsReparseTagMicrosoft( ReparseTag )) {

            //
            //  Return invalid buffer parameter error.
            //

            Status = STATUS_IO_REPARSE_DATA_INVALID;

            //
            //  Return to caller.
            //

            NtfsCompleteRequest( IrpContext, Irp, Status );

            DebugTrace( 0, Dbg, ("Wrong tag in Microsoft buffer.\n") );
            DebugTrace( -1, Dbg, ("NtfsSetReparsePoint -> %08lx\n", Status) );

            return Status;
        }
    }

    //
    //  Sanity check the buffer size combination that has a GUID.
    //

    if ((ULONG)(ReparseDataLength + REPARSE_GUID_DATA_BUFFER_HEADER_SIZE) == InputBufferLength) {

        //
        //  If the tag is a non-Microsoft tag, then the GUID cannot be NULL
        //

        if (!IsReparseTagMicrosoft( ReparseTag )) {

            if ((ReparseGuidBuffer->ReparseGuid.Data1 == 0) &&
                (ReparseGuidBuffer->ReparseGuid.Data2 == 0) &&
                (ReparseGuidBuffer->ReparseGuid.Data3 == 0) &&
                (ReparseGuidBuffer->ReparseGuid.Data4[0] == 0) &&
                (ReparseGuidBuffer->ReparseGuid.Data4[1] == 0) &&
                (ReparseGuidBuffer->ReparseGuid.Data4[2] == 0) &&
                (ReparseGuidBuffer->ReparseGuid.Data4[3] == 0) &&
                (ReparseGuidBuffer->ReparseGuid.Data4[4] == 0) &&
                (ReparseGuidBuffer->ReparseGuid.Data4[5] == 0) &&
                (ReparseGuidBuffer->ReparseGuid.Data4[6] == 0) &&
                (ReparseGuidBuffer->ReparseGuid.Data4[7] == 0)) {

                //
                //  Return invalid buffer parameter error.
                //

                Status = STATUS_IO_REPARSE_DATA_INVALID;

                //
                //  Return to caller.
                //

                NtfsCompleteRequest( IrpContext, Irp, Status );

                DebugTrace( 0, Dbg, ("The GUID is null for a non-Microsoft tag.\n") );
                DebugTrace( -1, Dbg, ("NtfsSetReparsePoint -> %08lx\n", Status) );

                return Status;
            }
        }

        //
        //  This kind of buffer cannot be used for name grafting operations.
        //

        if (ReparseTag == IO_REPARSE_TAG_MOUNT_POINT) {

            //
            //  Return invalid buffer parameter error.
            //

            Status = STATUS_IO_REPARSE_DATA_INVALID;

            //
            //  Return to caller.
            //

            NtfsCompleteRequest( IrpContext, Irp, Status );

            DebugTrace( 0, Dbg, ("Attempt to use the GUID buffer for name grafting.\n") );
            DebugTrace( -1, Dbg, ("NtfsSetReparsePoint -> %08lx\n", Status) );

            return Status;
        }
    }

    //
    //  We verify that the caller has zeroes in all the reserved bits and that she
    //  sets one of the non-reserved tags.  Also fail if the tag is the retired NSS
    //  flag.
    //

    if ((ReparseTag & ~IO_REPARSE_TAG_VALID_VALUES)  ||
        (ReparseTag == IO_REPARSE_TAG_RESERVED_ZERO) ||
        (ReparseTag == IO_REPARSE_TAG_RESERVED_ONE)) {

        Status = STATUS_IO_REPARSE_TAG_INVALID;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Caller passed in a reserved tag for the reparse data.\n") );
        DebugTrace( -1, Dbg, ("NtfsSetReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  NTFS directory junctions are only to be set at directories and have a valid buffer.
    //

    if (ReparseTag == IO_REPARSE_TAG_MOUNT_POINT) {

        HANDLE TestHandle;
        OBJECT_ATTRIBUTES Oa;
        IO_STATUS_BLOCK Iosb;
        UNICODE_STRING Path;

        //
        //  The tag needs to come together with a UserDirectoryOpen mode.
        //

        if (TypeOfOpen != UserDirectoryOpen) {

            Status = STATUS_NOT_A_DIRECTORY;

            //
            //  Return to caller.
            //

            NtfsCompleteRequest( IrpContext, Irp, Status );

            DebugTrace( 0, Dbg, ("Cannot set a mount point at a non-directory.\n") );
            DebugTrace( -1, Dbg, ("NtfsSetReparsePoint -> %08lx\n", Status) );

            return Status;
        }

        //
        //  Valid MountPointBuffer must have
        //
        //  1)  Enough space for the length fields
        //  2)  A correct substitute name offset
        //  3)  A print name offset following the substitute name
        //  4)  enough space for the path name and substitute name
        //

        if ((ReparseBuffer->ReparseDataLength <
             (FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer[0]) - REPARSE_DATA_BUFFER_HEADER_SIZE)) ||

            (ReparseBuffer->MountPointReparseBuffer.SubstituteNameOffset != 0) ||

            (ReparseBuffer->MountPointReparseBuffer.PrintNameOffset !=
             (ReparseBuffer->MountPointReparseBuffer.SubstituteNameLength + sizeof( UNICODE_NULL ))) ||

            (ReparseBuffer->ReparseDataLength !=
             (FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer[0]) - REPARSE_DATA_BUFFER_HEADER_SIZE) +
              ReparseBuffer->MountPointReparseBuffer.SubstituteNameLength +
              ReparseBuffer->MountPointReparseBuffer.PrintNameLength +
              2 * sizeof( UNICODE_NULL ))) {

            Status = STATUS_IO_REPARSE_DATA_INVALID;

        } else {

            //
            //  While we don't hold any of our resources open the target path to
            //  check what it points to. We only allow mount points to local
            //  disks and cdroms
            //

            Path.Length = Path.MaximumLength = ReparseBuffer->MountPointReparseBuffer.SubstituteNameLength;
            Path.Buffer = &ReparseBuffer->MountPointReparseBuffer.PathBuffer[0];

            if (Path.Buffer[ (Path.Length / sizeof( WCHAR )) - 1] == L'\\') {
                Path.Length -= sizeof( WCHAR );
            }

            //
            //  Set the call self flag so status can't wait is handled in the create and
            //  not returned back
            //

            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_CALL_SELF );

            InitializeObjectAttributes( &Oa, &Path, OBJ_CASE_INSENSITIVE, NULL, NULL );
            Status = ZwCreateFile( &TestHandle,
                                   FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                                   &Oa,
                                   &Iosb,
                                   NULL,
                                   FILE_ATTRIBUTE_NORMAL,
                                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                                   FILE_OPEN,
                                   FILE_SYNCHRONOUS_IO_NONALERT,
                                   NULL,
                                   0 );

            ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_CALL_SELF );

            if (NT_SUCCESS( Status )) {

                PFILE_OBJECT TestFileObject;

                Status = ObReferenceObjectByHandle( TestHandle,
                                                    FILE_READ_ATTRIBUTES,
                                                    *IoFileObjectType,
                                                    KernelMode,
                                                    (PVOID *) &TestFileObject,
                                                    NULL );

                if (NT_SUCCESS( Status )) {

                    if ((TestFileObject->DeviceObject->DeviceType != FILE_DEVICE_DISK) &&
                        (TestFileObject->DeviceObject->DeviceType != FILE_DEVICE_CD_ROM) &&
                        (TestFileObject->DeviceObject->DeviceType != FILE_DEVICE_TAPE)) {

                        Status = STATUS_IO_REPARSE_DATA_INVALID;
                    }
                    ObDereferenceObject( TestFileObject );
                }
                ZwClose( TestHandle );

            } else if (FlagOn( Ccb->AccessFlags, RESTORE_ACCESS)) {

                //
                //  Allow restore operators to create a reparse point - even if the target doesn't
                //  exist
                //

                Status = STATUS_SUCCESS;

            }
        }

        if (!NT_SUCCESS( Status )) {

            //
            //  Return to caller.
            //

            NtfsCompleteRequest( IrpContext, Irp, STATUS_IO_REPARSE_DATA_INVALID );

            DebugTrace( 0, Dbg, ("Name grafting data buffer is incorrect.\n") );
            DebugTrace( -1, Dbg, ("NtfsSetReparsePoint -> %08lx\n", Status) );

            return STATUS_IO_REPARSE_DATA_INVALID;
        }
    }

    //
    //  We set the IrpContext flag to indicate that we can wait, making this a synchronous
    //  call.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  Capture the source information.
    //

    IrpContext->SourceInfo = Ccb->UsnSourceInfo;

    //
    //  The parameters look good. We begin real work.
    //
    //  Now it is time ot use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If there is a paging io resource then acquire it exclusively.  This is to
        //  protect us from a collided page wait if we go to convert another stream
        //  to non-resident at the same time a different thread is faulting into it.
        //

        if (Scb->Header.PagingIoResource != NULL) {

            ExAcquireResourceExclusiveLite( Scb->Header.PagingIoResource, TRUE );
            PagingIoAcquired = TRUE;
        }

        //
        //  Acquire the Fcb exclusively. The volume could've gotten dismounted,
        //  so check that too.
        //

        NtfsAcquireExclusiveScb( IrpContext, Scb );
        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            try_return( Status = STATUS_VOLUME_DISMOUNTED );
        }

        //
        //  If the file object is a directory, we want it to be empty and to remain
        //  empty. Thus our check after the Fcb has been acquired. As reparse points
        //  impede the normal flow down through the name hierarchy we want to make
        //  it difficult for a caller to inadvertently block a name subtree by
        //  establishing a reparse point.
        //

        if (TypeOfOpen == UserDirectoryOpen) {

            BOOLEAN NonEmptyIndex;

            //
            //  The directory is deleteable if all the $INDEX_ROOT attributes are empty.
            //  Just what we need to establish a reparse point.
            //

            if (!NtfsIsFileDeleteable( IrpContext, Fcb, &NonEmptyIndex )) {

                //
                //  This directory is not empty.  Do not establish a reparse point in it.
                //  Return to caller an invalid parameter error.
                //

                DebugTrace( 0, Dbg, ("Non-empty directory used by caller.\n") );
                Status = STATUS_DIRECTORY_NOT_EMPTY;

                //
                //  Return to caller.
                //

                try_return( Status );
            }
        }

        //
        //  EA attributes and reparse points are not to exist simultaneously.
        //  If the non-reparse point file object has EA attributes, we do not set
        //  a reparse point.
        //  We verify this condition after the Fcb resource has been acquired to
        //  impede a change in this state till we complete.
        //

        if ((!FlagOn( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT )) &&
            (Fcb->Info.PackedEaSize > 0)) {

            //
            //  This non-reparse point file object has EAs.  Do not establish a
            //  reparse point in it.
            //  Return to caller STATUS_EAS_NOT_SUPPORTED.
            //

            DebugTrace( 0, Dbg, ("EAs present, cannot establish reparse point.\n") );
            Status = STATUS_EAS_NOT_SUPPORTED;

            //
            //  Return to caller.
            //

            try_return( Status );
        }

        //
        //  Remember the values of the file attribute flags and of the reparse tag
        //  for abnormal termination recovery.
        //

        IncomingFileAttributes = Fcb->Info.FileAttributes;
        IncomingReparsePointTag = Fcb->Info.ReparsePointTag;

        //
        //  Initialize the context structure to search for the attribute.
        //

        NtfsInitializeAttributeContext( &AttributeContext );
        CleanupAttributeContext = TRUE;

        //
        //  Establish whether the file has the $REPARSE_POINT attribute.
        //  If it exists, it will be updated with the new data.
        //

        if (NtfsLookupAttributeByCode( IrpContext,
                                       Fcb,
                                       &Fcb->FileReference,
                                       $REPARSE_POINT,
                                       &AttributeContext )) {

            ULONG ValueLength = 0;

            if (!FlagOn( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT )) {

                DebugTrace( 0, Dbg, ("The FILE_ATTRIBUTE_REPARSE_POINT flag is not set.\n") );

                //
                //  Should not happen. Raise an exeption as we are in an inconsistent state.
                //  The presence of the $REPARSE_POINT attribute says that the flag has to
                //  be set.
                //

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            //
            //  Verify that the incomming tag value matches the tag value present in
            //  the $REPARSE_POINT attribute.
            //

            {
                PREPARSE_GUID_DATA_BUFFER ReparseBufferTwo = NULL;
                PATTRIBUTE_RECORD_HEADER AttributeHeader = NULL;
                PVOID AttributeData = NULL;

                AttributeHeader = NtfsFoundAttribute( &AttributeContext );

                //
                //  Map the reparse point if the attribute is non-resident.  Otherwise
                //  the attribute is already mapped and we have a Bcb in the attribute
                //  context.
                //

                if (NtfsIsAttributeResident( AttributeHeader )) {

                    //
                    //  Point to the value of the arribute.
                    //

                    AttributeData = NtfsAttributeValue( AttributeHeader );
                    ValueLength = AttributeHeader->Form.Resident.ValueLength;
                    DebugTrace( 0, Dbg, ("Existing attribute is resident.\n") );

                } else {


                    if (AttributeHeader->Form.Nonresident.FileSize > MAXIMUM_REPARSE_DATA_BUFFER_SIZE) {
                        NtfsRaiseStatus( IrpContext,STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                    }

                    DebugTrace( 0, Dbg, ("Existing attribute is non-resident.\n") );
                    NtfsMapAttributeValue( IrpContext,
                                           Fcb,
                                           &AttributeData,       //  point to the value
                                           &ValueLength,
                                           &Bcb,
                                           &AttributeContext );
                }

                //
                //  Verify that the two tag values match.
                //

                ReparseBufferTwo = (PREPARSE_GUID_DATA_BUFFER)AttributeData;

                DebugTrace( 0, Dbg, ("Existing tag is [d]%03ld - New tag is [d]%03ld\n", ReparseTag, ReparseBufferTwo->ReparseTag) );

                if (ReparseTag != ReparseBufferTwo->ReparseTag) {

                    //
                    //  Return status STATUS_IO_REPARSE_TAG_MISMATCH
                    //

                    DebugTrace( 0, Dbg, ("Tag mismatch with the existing reparse point.\n") );
                    Status = STATUS_IO_REPARSE_TAG_MISMATCH;

                    try_return( Status );
                }

                //
                //  For non-Microsoft tags, verify that the GUIDs match.
                //

                if (!IsReparseTagMicrosoft( ReparseTag )) {

                    if (!((ReparseGuidBuffer->ReparseGuid.Data1 == ReparseBufferTwo->ReparseGuid.Data1) &&
                          (ReparseGuidBuffer->ReparseGuid.Data2 == ReparseBufferTwo->ReparseGuid.Data2) &&
                          (ReparseGuidBuffer->ReparseGuid.Data3 == ReparseBufferTwo->ReparseGuid.Data3) &&
                          (ReparseGuidBuffer->ReparseGuid.Data4[0] == ReparseBufferTwo->ReparseGuid.Data4[0]) &&
                          (ReparseGuidBuffer->ReparseGuid.Data4[1] == ReparseBufferTwo->ReparseGuid.Data4[1]) &&
                          (ReparseGuidBuffer->ReparseGuid.Data4[2] == ReparseBufferTwo->ReparseGuid.Data4[2]) &&
                          (ReparseGuidBuffer->ReparseGuid.Data4[3] == ReparseBufferTwo->ReparseGuid.Data4[3]) &&
                          (ReparseGuidBuffer->ReparseGuid.Data4[4] == ReparseBufferTwo->ReparseGuid.Data4[4]) &&
                          (ReparseGuidBuffer->ReparseGuid.Data4[5] == ReparseBufferTwo->ReparseGuid.Data4[5]) &&
                          (ReparseGuidBuffer->ReparseGuid.Data4[6] == ReparseBufferTwo->ReparseGuid.Data4[6]) &&
                          (ReparseGuidBuffer->ReparseGuid.Data4[7] == ReparseBufferTwo->ReparseGuid.Data4[7]))) {

                        //
                        //  Return status STATUS_REPARSE_ATTRIBUTE_CONFLICT
                        //

                        DebugTrace( 0, Dbg, ("GUID mismatch with the existing reparse point.\n") );
                        Status = STATUS_REPARSE_ATTRIBUTE_CONFLICT;

                        try_return( Status );
                    }
                }

                //
                //  Unpin the Bcb. The unpin routine checks for NULL.
                //

                NtfsUnpinBcb( IrpContext, &Bcb );
            }

            //
            //  If we're growing throttle ourselves through cc, we can't wait because we own resources
            //  here and this would deadlock
            //

            if (InputBufferLength > ValueLength) {
                if (!CcCanIWrite(IrpSp->FileObject,
                                 InputBufferLength - ValueLength,
                                 FALSE,
                                 BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_WRITE))) {

                    BOOLEAN Retrying = BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_WRITE);

                    //
                    //  PrePosting the irp will free the resources so fcb will not be acquired afterwards
                    //

                    NtfsPrePostIrp( IrpContext, Irp );

                    ASSERT( !NtfsIsExclusiveFcb( Fcb ) );

                    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_WRITE );

                    CcDeferWrite( IrpSp->FileObject,
                                  (PCC_POST_DEFERRED_WRITE)NtfsAddToWorkque,
                                  IrpContext,
                                  Irp,
                                  InputBufferLength - ValueLength,
                                  Retrying );

                    try_return( Status = STATUS_PENDING );
                }
            }

            //
            //  Update the value of the attribute.
            //

            NtfsChangeAttributeValue( IrpContext,
                                      Fcb,
                                      (ULONG) 0,                   //  ValueOffset
                                      (PVOID)(Irp->AssociatedIrp.SystemBuffer),    //  Value
                                      InputBufferLength,           //  ValueLength
                                      TRUE,                        //  SetNewLength
                                      TRUE,                        //  LogNonresidentToo
                                      FALSE,                       //  CreateSectionUnderway
                                      FALSE,                       //  PreserveContext
                                      &AttributeContext );         //  Context

            //
            //  Cleanup the attribute context state
            //

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
            CleanupAttributeContext = FALSE;

        } else {

            //
            //  The $REPARSE_POINT attribute is not present.
            //

            if (FlagOn( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT )) {

                DebugTrace( 0, Dbg, ("The FILE_ATTRIBUTE_REPARSE_POINT flag is set.\n") );

                //
                //  Should not happen. Raise an exeption as we are in an inconsistent state.
                //  The absence of the $REPARSE_POINT attribute says that the flag has to
                //  not be set.
                //

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            //
            //  throttle ourselves throuch cc
            //

            if (!CcCanIWrite(IrpSp->FileObject,
                             InputBufferLength,
                             FALSE,
                             BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_WRITE))) {

                BOOLEAN Retrying = BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_WRITE);

                //
                //  PrePosting the irp will free the resources so fcb will not be acquired afterwards
                //

                NtfsPrePostIrp( IrpContext, Irp );

                ASSERT( !NtfsIsExclusiveFcb( Fcb ) );

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_WRITE );

                CcDeferWrite( IrpSp->FileObject,
                              (PCC_POST_DEFERRED_WRITE)NtfsAddToWorkque,
                              IrpContext,
                              Irp,
                              InputBufferLength,
                              Retrying );

                try_return( Status = STATUS_PENDING );
            }

            //
            //  Insert the record into the reparse point index.
            //

            {
                INDEX_KEY IndexKey;
                INDEX_ROW IndexRow;
                REPARSE_INDEX_KEY KeyValue;

                //
                //  Acquire the ReparsePointIndex Scb. We still hold the target fcb resource,
                //  so the volume couldn't have gotten dismounted under us.
                //

                NtfsAcquireExclusiveScb( IrpContext, Vcb->ReparsePointTableScb );
                ASSERT( NtfsIsExclusiveFcb( Fcb ));
                ASSERT( !FlagOn( Vcb->ReparsePointTableScb->ScbState, SCB_STATE_VOLUME_DISMOUNTED ));

                //
                //  Add the file Id to the reparse point index.
                //

                KeyValue.FileReparseTag = ReparseTag;
                KeyValue.FileId = *(PLARGE_INTEGER)&Scb->Fcb->FileReference;

                IndexKey.Key = (PVOID)&KeyValue;
                IndexKey.KeyLength = sizeof(KeyValue);

                IndexRow.KeyPart = IndexKey;
                IndexRow.DataPart.DataLength = 0;
                IndexRow.DataPart.Data = NULL;

                //
                //  NtOfsAddRecords will raise if the file id already belongs in the index.
                //

                NtOfsAddRecords( IrpContext,
                                 Vcb->ReparsePointTableScb,
                                 1,          // adding one record to the index
                                 &IndexRow,
                                 FALSE );    // sequential insert
            }

            //
            //  Create the $REPARSE_POINT attribute with the data being sent in.
            //

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
            NtfsInitializeAttributeContext( &AttributeContext );

            NtfsCreateAttributeWithValue( IrpContext,
                                          Fcb,
                                          $REPARSE_POINT,
                                          NULL,
                                          (PVOID) ( Irp->AssociatedIrp.SystemBuffer ),
                                          InputBufferLength,
                                          (USHORT) 0,         //  Attribute flags
                                          NULL,
                                          TRUE,               //  LogIt
                                          &AttributeContext );

            //
            //  Cleanup the attribute context state
            //

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
            CleanupAttributeContext = FALSE;

            //
            //  Set the duplicate file attribute to Reparse Point.
            //

            SetFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT );

            //
            //  Set the ReparsePointTag field.
            //

            Fcb->Info.ReparsePointTag = ReparseTag;

            //
            //  Set the change attribute flag.
            //

            ASSERTMSG( "conflict with flush",
                       NtfsIsSharedFcb( Fcb ) ||
                       (Fcb->PagingIoResource != NULL &&
                        NtfsIsSharedFcbPagingIo( Fcb )) );

            SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );
        }

        //
        //  Set the archive bit in the Ccb.
        //

        if (!IsDirectory( &Fcb->Info )) {
            SetFlag( Ccb->Flags, CCB_FLAG_SET_ARCHIVE );
        }

        //
        //  Flag to set the change time in the Ccb.
        //

        SetFlag( Ccb->Flags, CCB_FLAG_UPDATE_LAST_CHANGE );

        //
        //  Update the standard information in the file record to reflect its a reparse pt.
        //

        NtfsUpdateStandardInformation( IrpContext, Fcb );

        //
        //  Post the change to the Usn Journal (on errors change is backed out)
        //

        NtfsPostUsnChange( IrpContext, Scb, USN_REASON_REPARSE_POINT_CHANGE );

        //
        //  Checkpoint the Txn to commit the changes.
        //

        NtfsCleanupTransactionAndCommit( IrpContext, STATUS_SUCCESS, TRUE );

    try_exit:  NOTHING;

    } finally {

        DebugUnwind( NtfsSetReparsePoint );

        //
        //  Unpin the Bcb. The unpin routine checks for NULL.
        //

        NtfsUnpinBcb( IrpContext, &Bcb );

        //
        //  Clean-up all the pertinent state.
        //

        if (CleanupAttributeContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
        }

        //
        //  Need to roll-back the value of the reparse point flag in case of
        //  problems. I leave the archive bit set anyway.
        //

        if (AbnormalTermination()) {

            Fcb->Info.FileAttributes = IncomingFileAttributes;
            Fcb->Info.ReparsePointTag = IncomingReparsePointTag;
        }

        //
        //  Release the paging io resource if held.
        //

        if (PagingIoAcquired) {
            ExReleaseResourceLite( Fcb->PagingIoResource );
        }
    }

    if (Status != STATUS_PENDING) {
        NtfsCompleteRequest( IrpContext, Irp, Status );
    }

    DebugTrace( -1, Dbg, ("NtfsSetReparsePoint -> %08lx\n", Status) );

    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsGetReparsePoint (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine finds the specified reparse point returning the value
    of the corresponding attribute.

    The value of the reparse point attribute is the linearized version of
    the buffer sent in the NtfsSetReparsePoint call including the header
    fields ReparseTag and ReparseDataLength. We retrieve all fields, unmodified,
    so that the caller can decode it using the same buffer template used in the
    set operation.

Arguments:

    IrpContext - Supplies the Irp context of the call

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    ULONG FsControlCode;

    TYPE_OF_OPEN TypeOfOpen;

    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    PBCB Bcb = NULL;    //  does not get initialized below in NtfsDecodeFileObject

    PCHAR OutputBuffer = NULL;
    ULONG OutputBufferLength = 0;   //  invalid value as we need an output buffer
    ULONG InputBufferLength = 0;    //  invalid value as we need an input buffer

    BOOLEAN CleanupAttributeContext = FALSE;
    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
    PATTRIBUTE_RECORD_HEADER AttributeHeader = NULL;
    PATTRIBUTE_LIST_ENTRY AttributeListEntry = NULL;
    ULONG AttributeLengthInBytes = 0;
    PVOID AttributeData = NULL;

    BOOLEAN ScbAcquired = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    DebugTrace( +1, Dbg, ("NtfsGetReparsePoint, FsControlCode = %08lx\n", FsControlCode) );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );

    //
    //  Decode all the relevant File System data structures.
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext,
                                       IrpSp->FileObject,
                                       &Vcb,
                                       &Fcb,
                                       &Scb,
                                       &Ccb,
                                       TRUE );  //  Raise an exeption if error is encountered

    //
    //  Check for the correct type of open.
    //

    //
    //  See that we have a file or a directory open.
    //

    if ((TypeOfOpen != UserFileOpen) && (TypeOfOpen != UserDirectoryOpen)) {

        //
        //  Return an invalid parameter error
        //

        Status = STATUS_INVALID_PARAMETER;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Invalid parameter passed by caller\n") );
        DebugTrace( -1, Dbg, ("NtfsGetReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    ASSERT_VCB( Vcb );
    ASSERT_FCB( Fcb );
    ASSERT_SCB( Scb );
    ASSERT_CCB( Ccb );

    if (!NtfsVolumeVersionCheck( Vcb, NTFS_REPARSE_POINT_VERSION )) {

        //
        //  Return a volume not upgraded error.
        //

        Status = STATUS_VOLUME_NOT_UPGRADED;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Non-upgraded volume passed by caller.\n") );
        DebugTrace( -1, Dbg, ("NtfsGetReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  Get the length of the output buffer.
    //

    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    OutputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

    DebugTrace( 0, Dbg, ("InputBufferLength %08lx [d]%08d OutputBufferLength %08lx\n", InputBufferLength, InputBufferLength, OutputBufferLength) );

    //
    //  Do not allow input buffer in the get command.
    //

    if (InputBufferLength > 0) {

        //
        //  Return an invalid parameter error.
        //

        Status = STATUS_INVALID_PARAMETER;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Non-null input buffer.\n") );
        DebugTrace( -1, Dbg, ("NtfsGetReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  Get a pointer to the output buffer.  First look at the system buffer field in
    //  the IRP.  Then look in the IRP Mdl.
    //

    if (Irp->AssociatedIrp.SystemBuffer != NULL) {

        OutputBuffer = (PCHAR)Irp->AssociatedIrp.SystemBuffer;

    } else if (Irp->MdlAddress != NULL) {

        OutputBuffer = (PCHAR)MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority );

        if (OutputBuffer == NULL) {

            NtfsCompleteRequest( IrpContext, Irp, STATUS_INSUFFICIENT_RESOURCES );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        //
        //  Return an invalid user buffer error.
        //

        Status = STATUS_INVALID_USER_BUFFER;

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_USER_BUFFER );

        DebugTrace( 0, Dbg, ("User buffer is not good.\n") );
        DebugTrace( -1, Dbg, ("NtfsGetReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  Zero the Information field in IoStatus.
    //

    Irp->IoStatus.Information = 0;

    //
    //  We set the IrpContext flag to indicate that we can wait, making htis a synchronous
    //  call.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  Now it is time ot use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  We acquire the Scb in shared mode so that the underlying Fcb remains stable.
        //

        NtfsAcquireSharedScb( IrpContext, Scb );
        ScbAcquired = TRUE;

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            try_return( Status = STATUS_VOLUME_DISMOUNTED );
        }

        //
        //  The parameters and boundary conditions look good and we have a reparse point.
        //  We begin real work.
        //
        //  Find the reparse point attribute.
        //

        NtfsInitializeAttributeContext( &AttributeContext );
        CleanupAttributeContext = TRUE;

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        $REPARSE_POINT,
                                        &AttributeContext )) {

            DebugTrace( 0, Dbg, ("Can't find the $REPARSE_POINT attribute.\n") );

            //
            //  Verify that the information in FileAttributes is consistent.
            //

            if (FlagOn( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT )) {

                DebugTrace( 0, Dbg, ("The Fcb says this IS a reparse point.\n") );

                //
                //  Should not happen. Raise an exeption as we are in an inconsistent state.
                //  The attribute flag says that $REPARSE_POINT has to be present.
                //

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            //
            //  Return STATUS_NOT_A_REPARSE_POINT
            //

            Status = STATUS_NOT_A_REPARSE_POINT;

            try_return( Status );
        }

        //
        //  Find the size of the attribute.
        //  Determine whether we have enough buffer to return it to the caller.
        //

        AttributeHeader = NtfsFoundAttribute( &AttributeContext );

        if (NtfsIsAttributeResident( AttributeHeader )) {

            AttributeLengthInBytes = AttributeHeader->Form.Resident.ValueLength;
            DebugTrace( 0, Dbg, ("Resident attribute with length %05lx\n", AttributeLengthInBytes) );

            if (AttributeLengthInBytes > MAXIMUM_REPARSE_DATA_BUFFER_SIZE) {

                //
                //  Return STATUS_IO_REPARSE_DATA_INVALID
                //

                Status = STATUS_IO_REPARSE_DATA_INVALID;
                DebugTrace( 0, Dbg, ("AttributeLengthInBytes is [x]%08lx is too long.\n", AttributeLengthInBytes) );

                try_return( Status );
            }

            //
            //  Point to the value of the arribute.
            //

            AttributeData = NtfsAttributeValue( AttributeHeader );
            ASSERT( Bcb == NULL );

        } else {

            ULONG Length;

            if (AttributeHeader->Form.Nonresident.FileSize > MAXIMUM_REPARSE_DATA_BUFFER_SIZE) {

                //
                //  Return STATUS_IO_REPARSE_DATA_INVALID
                //

                Status = STATUS_IO_REPARSE_DATA_INVALID;
                DebugTrace( 0, Dbg, ("Nonresident.FileSize is too long.\n") );

                try_return( Status );
            }

            //
            //  Note that we coerse different LENGTHs
            //

            AttributeLengthInBytes = (ULONG)AttributeHeader->Form.Nonresident.FileSize;
            DebugTrace( 0, Dbg, ("Non-resident attribute with length %05lx\n", AttributeLengthInBytes) );

            //
            //  Map the attribute list if the attribute is non-resident.  Otherwise the
            //  attribute is already mapped and we have a Bcb in the attribute context.
            //

            NtfsMapAttributeValue( IrpContext,
                                   Fcb,
                                   &AttributeData,      //  point to the value
                                   &Length,
                                   &Bcb,
                                   &AttributeContext );

            if (AttributeLengthInBytes != Length) {
                DebugTrace( 0, Dbg, ("AttributeLengthInBytes %05lx and Length %05lx differ.\n", AttributeLengthInBytes, Length) );
            }
            ASSERT( AttributeLengthInBytes == Length );
        }

        DebugTrace( 0, Dbg, ("AttributeLengthInBytes is [d]%06ld %05lx\n", AttributeLengthInBytes, AttributeLengthInBytes) );

        if (AttributeLengthInBytes > OutputBufferLength) {

            DebugTrace( 0, Dbg, ("Insufficient output buffer passed by caller.\n") );

            //
            //  Check whether the fixed portion will fit.
            //

            if (OutputBufferLength < sizeof( REPARSE_GUID_DATA_BUFFER )) {

                //
                //  This is the error path.  Don't return anything.
                //

                try_return( Status = STATUS_BUFFER_TOO_SMALL );

            } else {

                Status = STATUS_BUFFER_OVERFLOW;
            }

            //
            //  Remember the smaller number of returned bytes.
            //

            AttributeLengthInBytes = OutputBufferLength;
        }

        //
        //  Copy the value of the reparse point attribute to the buffer.
        //  Return all the value including the system header fields (e.g., Tag and Length)
        //  stored at the beginning of the value of the reparse point attribute.
        //

        RtlCopyMemory( OutputBuffer,
                       AttributeData,
                       AttributeLengthInBytes );

        //
        //  Set the information field to the length of the buffer returned.
        //  This tells the re-director to do the corresponding data transmission.
        //

        Irp->IoStatus.Information = AttributeLengthInBytes;

        //
        //  Cleanup the attribute context state.
        //

        NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
        CleanupAttributeContext = FALSE;

    try_exit:  NOTHING;

    } finally {

        //
        //  Clean-up all the pertinent state.
        //

        DebugUnwind( NtfsGetReparsePoint );

        if (CleanupAttributeContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
        }

        //
        //  Unpin the Bcb ... in case you needed to pin it above.
        //  The unpin routine checks for NULL.
        //

        NtfsUnpinBcb( IrpContext, &Bcb );

        //
        //  Relase the Fcb.
        //

        if (ScbAcquired) {

            NtfsReleaseScb( IrpContext, Scb );
        } else {

            //
            //  We must have raised an exception in NtfsAcquireSharedFcb.
            //  Because we check for the existence of the file this must mean
            //  that it has been deleted from under us.
            //
            //  Nothing is to be done as exception processing sets the correct
            //  return code.
            //
        }
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );

    DebugTrace( -1, Dbg, ("NtfsGetReparsePoint -> %08lx\n", Status) );

    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsDeleteReparsePoint (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine deletes a reparse point at the file object entry
    specified in the IRP.

    The IN buffer specified by the caller has the value of the Tag of the reparse point
    being deleted, and no data, thus needing to have a value of zero for DataLength.
    If the tags do not match the delete fails.

    If the file object has the FILE_ATTRIBUTE_REPARSE_POINT bit set then the
    $REPARSE_POINT attribute is expected to be in the file.

    There is no OUT buffer sent by the caller.

    This function deletes the corresponding entry from the reparse point table.

Arguments:

    IrpContext - Supplies the Irp context of the call

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    ULONG FsControlCode;

    TYPE_OF_OPEN TypeOfOpen;

    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PSCB NonResidentScb = NULL;
    PCCB Ccb;
    PBCB Bcb = NULL;    //  does not get initialized below in NtfsDecodeFileObject

    PREPARSE_DATA_BUFFER ReparseBuffer = NULL;
    ULONG ReparseTag;
    USHORT ReparseDataLength = 0;   //  only valid value
    ULONG InputBufferLength = 0;    //  invalid value as the header is needed
    ULONG OutputBufferLength = 2;   //  invalid value as no output buffer is used

    ULONG IncomingFileAttributes = 0;                              //  invalid value
    ULONG IncomingReparsePointTag = IO_REPARSE_TAG_RESERVED_ZERO;  //  invalid value

    BOOLEAN CleanupAttributeContext = FALSE;
    PATTRIBUTE_RECORD_HEADER AttributeHeader = NULL;
    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;

    MAP_HANDLE MapHandle;

    BOOLEAN NonResidentScbAcquired = FALSE;
    BOOLEAN InitializedMapHandle = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    DebugTrace( +1, Dbg, ("NtfsDeleteReparsePoint, FsControlCode = %08lx\n", FsControlCode) );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );

    //
    //  Get the length of the input and output buffers.
    //

    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    OutputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

    DebugTrace( 0, Dbg, ("InputBufferLength = %08lx, OutputBufferLength = %08lx\n", InputBufferLength, OutputBufferLength) );

    //
    //  Do not allow output buffer in the delete command.
    //

    if (OutputBufferLength > 0) {

        //
        //  Return an invalid parameter error.
        //

        Status = STATUS_INVALID_PARAMETER;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Non-null output buffer.\n") );
        DebugTrace( -1, Dbg, ("NtfsDeleteReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  Decode all the relevant File System data structures.
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext,
                                       IrpSp->FileObject,
                                       &Vcb,
                                       &Fcb,
                                       &Scb,
                                       &Ccb,
                                       TRUE );  // Raise an exeption if error is encountered

    //
    //  Check for the correct type of open.
    //

    if (
        //
        //  See that we have a file or a directory.
        //

        ((TypeOfOpen != UserFileOpen) && (TypeOfOpen != UserDirectoryOpen))) {

        //
        //  Return an invalid parameter error
        //

        Status = STATUS_INVALID_PARAMETER;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Invalid TypeOfOpen\n") );
        DebugTrace( -1, Dbg, ("NtfsDeleteReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  The caller has FILE_SPECIAL_ACCESS. The NTFS driver enforces access checks more stringent
    //  than FILE_ANY_ACCESS:
    //  (a) FILE_WRITE_DATA or FILE_WRITE_ATTRIBUTES_ACCESS
    //

    if (!FlagOn( Ccb->AccessFlags, WRITE_DATA_ACCESS | WRITE_ATTRIBUTES_ACCESS ) &&

        //
        //  Temporary KLUDGE for DavePr.
        //  The Ccb->AccessFlags and the FileObject->WriteAccess may not coincide as a
        //  filter may change the "visible" file object after the open. The Ccb flags do
        //  not change after open.
        //

        !(IrpSp->FileObject->WriteAccess == TRUE)) {

        //
        //  Return access denied.
        //

        Status = STATUS_ACCESS_DENIED;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Ccb->AccessFlags %x\n", Ccb->AccessFlags) );
        DebugTrace( 0, Dbg, ("Caller did not have the appropriate access rights.\n") );
        DebugTrace( -1, Dbg, ("NtfsDeleteReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    ASSERT_VCB( Vcb );
    ASSERT_FCB( Fcb );
    ASSERT_SCB( Scb );
    ASSERT_CCB( Ccb );

    //
    //  Read only volumes stay read only.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        Status = STATUS_MEDIA_WRITE_PROTECTED;
        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( -1, Dbg, ("NtfsDeleteReparsePoint -> %08lx\n", Status) );
        return Status;
    }

    if (!NtfsVolumeVersionCheck( Vcb, NTFS_REPARSE_POINT_VERSION )) {

        //
        //  Return a volume not upgraded error.
        //

        Status = STATUS_VOLUME_NOT_UPGRADED;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Non-upgraded volume passed by caller.\n") );
        DebugTrace( -1, Dbg, ("NtfsDeleteReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  Check for invalid conditions in the parameters.
    //

    if (
        //
        //  Verify that we have the required system input buffer.
        //

        (Irp->AssociatedIrp.SystemBuffer == NULL)) {

        //
        //  Return an invalid buffer error.
        //

        Status = STATUS_INVALID_BUFFER_SIZE;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Null buffer passed by system.\n") );
        DebugTrace( -1, Dbg, ("NtfsDeleteReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  See that the buffer sent in by the caller is the exact header.
    //

    if ((InputBufferLength != REPARSE_DATA_BUFFER_HEADER_SIZE) &&
        (InputBufferLength != REPARSE_GUID_DATA_BUFFER_HEADER_SIZE)) {

        //
        //  Return an invalid reparse data.
        //

        Status = STATUS_IO_REPARSE_DATA_INVALID;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Invalid parameter reparse data passed by caller\n") );
        DebugTrace( -1, Dbg, ("NtfsDeleteReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  Get the header information brought in the input buffer.
    //  While the first two fields coincide in REPARSE_DATA_BUFFER and REPARSE_GUID_DATA_BUFFER,
    //  a common assignment can be used below.
    //

    ASSERT( FIELD_OFFSET(REPARSE_DATA_BUFFER, ReparseTag) == FIELD_OFFSET(REPARSE_GUID_DATA_BUFFER, ReparseTag) );
    ASSERT( FIELD_OFFSET(REPARSE_DATA_BUFFER, ReparseDataLength) == FIELD_OFFSET(REPARSE_GUID_DATA_BUFFER, ReparseDataLength) );
    ASSERT( FIELD_OFFSET(REPARSE_DATA_BUFFER, Reserved) == FIELD_OFFSET(REPARSE_GUID_DATA_BUFFER, Reserved) );

    ReparseBuffer = (PREPARSE_DATA_BUFFER)Irp->AssociatedIrp.SystemBuffer;
    ReparseTag = ReparseBuffer->ReparseTag;
    ReparseDataLength = ReparseBuffer->ReparseDataLength;

    DebugTrace( 0, Dbg, ("ReparseTag = %08lx, ReparseDataLength = %05lx [d]%d\n", ReparseTag, ReparseDataLength, ReparseDataLength) );

    //
    // We verify that ReparseDataLength is zero.
    //

    if (ReparseDataLength != 0) {

        //
        //  Return an invalid reparse data.
        //

        Status = STATUS_IO_REPARSE_DATA_INVALID;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Invalid header value passed by caller\n") );
        DebugTrace( -1, Dbg, ("NtfsDeleteReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  We verify that the caller uses one of the non-reserved tags.
    //

    if ((ReparseTag == IO_REPARSE_TAG_RESERVED_ZERO) ||
        (ReparseTag == IO_REPARSE_TAG_RESERVED_ONE)) {

        //
        //  Return an invalid reparse tag.
        //

        Status = STATUS_IO_REPARSE_TAG_INVALID;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Caller passed in a reserved tag for the reparse data.\n") );
        DebugTrace( -1, Dbg, ("NtfsDeleteReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  We verify that for non-Microsoft tags the caller has the GUID header.
    //

    if (!IsReparseTagMicrosoft( ReparseTag ) &&
        (InputBufferLength != REPARSE_GUID_DATA_BUFFER_HEADER_SIZE)) {

        //
        //  Return an invalid reparse data.
        //

        Status = STATUS_IO_REPARSE_DATA_INVALID;

        //
        //  Return to caller.
        //

        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( 0, Dbg, ("Caller used non-Microsoft tag and did not use the GUID buffer.\n") );
        DebugTrace( -1, Dbg, ("NtfsDeleteReparsePoint -> %08lx\n", Status) );

        return Status;
    }

    //
    //  We set the IrpContext flag to indicate that we can wait, making this a synchronous
    //  call.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  Capture the source information.
    //

    IrpContext->SourceInfo = Ccb->UsnSourceInfo;

    //
    //  Now it is time ot use a try-finally to facilitate cleanup.
    //

    try {
        //
        //  Acquire exclusive the Fcb.
        //

        NtfsAcquireExclusiveFcb( IrpContext, Fcb, Scb, 0 );

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            try_return( Status = STATUS_VOLUME_DISMOUNTED );
        }

        //
        //  Remember the value of the file attribute flags and of the reparse point.
        //

        IncomingFileAttributes = Fcb->Info.FileAttributes;
        IncomingReparsePointTag = Fcb->Info.ReparsePointTag;

        //
        //  All the parameters and boundary conditions look good. We begin real work.
        //
        //  Delete the appropriate system defined reparse point attribute.
        //  First point to it and then nuke it.
        //

        NtfsInitializeAttributeContext( &AttributeContext );
        CleanupAttributeContext = TRUE;

        if (!(NtfsLookupAttributeByCode( IrpContext,
                                         Fcb,
                                         &Fcb->FileReference,
                                         $REPARSE_POINT,
                                         &AttributeContext ) ) ) {

            DebugTrace( 0, Dbg, ("Can't find the $REPARSE_POINT attribute\n") );

            //
            //  See if FileAttributes agrees that we do not have a reparse point.
            //

            if (FlagOn( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT )) {

                DebugTrace( 0, Dbg, ("The Fcb says this IS a reparse point.\n") );

                //
                //  Should not happen. Raise an exeption as we are in an
                //  inconsistent state. The attribute flag says that
                //  $REPARSE_POINT has to be present.
                //

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            //
            //  Return STATUS_NOT_A_REPARSE_POINT
            //

            Status = STATUS_NOT_A_REPARSE_POINT;

            try_return( Status );
        }

        //
        //  Verify that the incomming tag value matches the tag value present in
        //  the $REPARSE_POINT attribute.
        //

        {
            PREPARSE_GUID_DATA_BUFFER ReparseBufferTwo = NULL;
            PVOID AttributeData = NULL;
            ULONG Length = 0;

            AttributeHeader = NtfsFoundAttribute( &AttributeContext );

            if (NtfsIsAttributeResident( AttributeHeader )) {

                //
                //  Point to the value of the arribute.
                //

                AttributeData = NtfsAttributeValue( AttributeHeader );
                DebugTrace( 0, Dbg, ("Existing attribute is resident.\n") );

            } else {

                //
                //  Map the attribute list if the attribute is non-resident.  Otherwise the
                //  attribute is already mapped and we have a Bcb in the attribute context.
                //

                DebugTrace( 0, Dbg, ("Existing attribute is non-resident.\n") );
                NtfsMapAttributeValue( IrpContext,
                                       Fcb,
                                       &AttributeData,      //  point to the value
                                       &Length,
                                       &Bcb,
                                       &AttributeContext );
            }

            //
            //  Verify that the two tag values match.
            //

            ReparseBufferTwo = (PREPARSE_GUID_DATA_BUFFER)AttributeData;

            DebugTrace( 0, Dbg, ("Existing tag is [d]%03ld - New tag is [d]%03ld\n", ReparseBufferTwo->ReparseTag, ReparseBuffer->ReparseTag) );

            if (ReparseBuffer->ReparseTag != ReparseBufferTwo->ReparseTag) {

                //
                //  Return status STATUS_IO_REPARSE_TAG_MISMATCH
                //

                DebugTrace( 0, Dbg, ("Tag mismatch with the existing reparse point.\n") );
                Status = STATUS_IO_REPARSE_TAG_MISMATCH;

                try_return( Status );
            }

            //
            //  For non-Microsoft tags, verify that the GUIDs match.
            //

            if (!IsReparseTagMicrosoft( ReparseTag )) {

                PREPARSE_GUID_DATA_BUFFER ReparseGuidBuffer = NULL;

                ReparseGuidBuffer = (PREPARSE_GUID_DATA_BUFFER)ReparseBuffer;

                if (!((ReparseGuidBuffer->ReparseGuid.Data1 == ReparseBufferTwo->ReparseGuid.Data1) &&
                      (ReparseGuidBuffer->ReparseGuid.Data2 == ReparseBufferTwo->ReparseGuid.Data2) &&
                      (ReparseGuidBuffer->ReparseGuid.Data3 == ReparseBufferTwo->ReparseGuid.Data3) &&
                      (ReparseGuidBuffer->ReparseGuid.Data4[0] == ReparseBufferTwo->ReparseGuid.Data4[0]) &&
                      (ReparseGuidBuffer->ReparseGuid.Data4[1] == ReparseBufferTwo->ReparseGuid.Data4[1]) &&
                      (ReparseGuidBuffer->ReparseGuid.Data4[2] == ReparseBufferTwo->ReparseGuid.Data4[2]) &&
                      (ReparseGuidBuffer->ReparseGuid.Data4[3] == ReparseBufferTwo->ReparseGuid.Data4[3]) &&
                      (ReparseGuidBuffer->ReparseGuid.Data4[4] == ReparseBufferTwo->ReparseGuid.Data4[4]) &&
                      (ReparseGuidBuffer->ReparseGuid.Data4[5] == ReparseBufferTwo->ReparseGuid.Data4[5]) &&
                      (ReparseGuidBuffer->ReparseGuid.Data4[6] == ReparseBufferTwo->ReparseGuid.Data4[6]) &&
                      (ReparseGuidBuffer->ReparseGuid.Data4[7] == ReparseBufferTwo->ReparseGuid.Data4[7]))) {

                    //
                    //  Return status STATUS_REPARSE_ATTRIBUTE_CONFLICT
                    //

                    DebugTrace( 0, Dbg, ("GUID mismatch with the existing reparse point.\n") );
                    Status = STATUS_REPARSE_ATTRIBUTE_CONFLICT;

                    try_return( Status );
                }
            }

            //
            //  Unpin the Bcb. The unpin routine checks for NULL.
            //

            NtfsUnpinBcb( IrpContext, &Bcb );
        }

        //
        //  Delete the record from the reparse point index.
        //

        {
            INDEX_KEY IndexKey;
            INDEX_ROW IndexRow;
            REPARSE_INDEX_KEY KeyValue;

            //
            //  Acquire the mount table index so that the following two operations on it
            //  are atomic for this call.
            //

            NtfsAcquireExclusiveScb( IrpContext, Vcb->ReparsePointTableScb );

            //
            //  Verify that this file is in the reparse point index and delete it.
            //

            KeyValue.FileReparseTag = ReparseTag;
            KeyValue.FileId = *(PLARGE_INTEGER)&Scb->Fcb->FileReference;

            IndexKey.Key = (PVOID)&KeyValue;
            IndexKey.KeyLength = sizeof(KeyValue);

            NtOfsInitializeMapHandle( &MapHandle );
            InitializedMapHandle = TRUE;

            //
            //  NtOfsFindRecord will return an error status if the key is not found.
            //

            Status = NtOfsFindRecord( IrpContext,
                                      Vcb->ReparsePointTableScb,
                                      &IndexKey,
                                      &IndexRow,
                                      &MapHandle,
                                      NULL );

            if (!NT_SUCCESS(Status)) {

                //
                //  Should not happen. The reparse point should be in the index.
                //

                DebugTrace( 0, Dbg, ("Record not found in the reparse point index.\n") );
                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            //
            //  Remove the entry from the reparse point index.
            //

            NtOfsDeleteRecords( IrpContext,
                                Vcb->ReparsePointTableScb,
                                1,            // deleting one record from the index
                                &IndexKey );
        }

        //
        //  If the stream is non-resident, then get hold of an Scb for it.
        //

        if (!NtfsIsAttributeResident( AttributeHeader )) {

            NonResidentScb = NtfsCreateScb( IrpContext,
                                            Fcb,
                                            $REPARSE_POINT,
                                            &NtfsEmptyString,
                                            FALSE,
                                            NULL );

            NtfsAcquireExclusiveScb( IrpContext, NonResidentScb );
            NonResidentScbAcquired = TRUE;
        }

        //
        //  Nuke the attribute.
        //

        NtfsDeleteAttributeRecord( IrpContext,
                                   Fcb,
                                   DELETE_LOG_OPERATION |
                                    DELETE_RELEASE_FILE_RECORD |
                                    DELETE_RELEASE_ALLOCATION,
                                   &AttributeContext );

        //
        //  Cleanup the attribute context.
        //

        NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
        CleanupAttributeContext = FALSE;

        //
        //  Set the change attribute flag.
        //

        ASSERTMSG( "conflict with flush",
                   NtfsIsSharedFcb( Fcb ) ||
                   (Fcb->PagingIoResource != NULL &&
                    NtfsIsSharedFcbPagingIo( Fcb )) );

        SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );

        //
        //  Clear the reparse point bit in the duplicate file attribute.
        //

        ClearFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT );

        //
        //  Clear the ReparsePointTag field in the duplicate file attribute.
        //

        Fcb->Info.ReparsePointTag = IO_REPARSE_TAG_RESERVED_ZERO;

        //
        //  Update the standard information in the file record.
        //

        NtfsUpdateStandardInformation( IrpContext, Fcb );

        //
        //  Post the change to the Usn Journal (on errors change is backed out)
        //

        NtfsPostUsnChange( IrpContext, Scb, USN_REASON_REPARSE_POINT_CHANGE );

        //
        //  Checkpoint the Txn to commit the changes.
        //

        NtfsCleanupTransactionAndCommit( IrpContext, STATUS_SUCCESS, TRUE );

        //
        //  Flag the change time change in the Ccb.
        //

        SetFlag( Ccb->Flags, CCB_FLAG_UPDATE_LAST_CHANGE );

        //
        //  Don't set the archive bit on a directory.  Otherwise we break existing
        //  apps that don't expect to see this flag.
        //

        if (!IsDirectory( &Fcb->Info )) {

            SetFlag( Ccb->Flags, CCB_FLAG_SET_ARCHIVE );
        }

        //
        //  Reflect that the attribute is gone in the corresponding Scb.
        //

        if (NonResidentScbAcquired) {

            NonResidentScb->AttributeTypeCode = $UNUSED;

            //
            //  If we have acquired the Scb then set the sizes back to zero.
            //  Flag that the attribute has been deleted.
            //

            NonResidentScb->Header.FileSize =
            NonResidentScb->Header.ValidDataLength =
            NonResidentScb->Header.AllocationSize = Li0;

            //
            //  Set the Scb flag to indicate that the attribute is gone.
            //

            SetFlag( NonResidentScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );

            //
            //  Go ahead and dereference any internal file object.  No sense in keeping it around.
            //

            NtfsDeleteInternalAttributeStream( NonResidentScb, FALSE, 0 );
        }

    try_exit:  NOTHING;

    } finally {

        DebugUnwind( NtfsDeleteReparsePoint );

        //
        //  Unpin the Bcb. The unpin routine checks for NULL.
        //

        NtfsUnpinBcb( IrpContext, &Bcb );

        if (CleanupAttributeContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
        }

        //
        //  Need to roll-back the value of the reparse point flag in case of
        //  problems. I leave the archive bit set anyway.
        //

        if (AbnormalTermination()) {

           Fcb->Info.FileAttributes = IncomingFileAttributes;
           Fcb->Info.ReparsePointTag = IncomingReparsePointTag;
        }

        //
        //  Release the reparse point index Scb and the map handle.
        //

        if (InitializedMapHandle) {

            NtOfsReleaseMap( IrpContext, &MapHandle );
        }
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );

    DebugTrace( -1, Dbg, ("NtfsDeleteReparsePoint -> %08lx\n", Status) );

    return Status;
}



NTSTATUS
NtfsGetTunneledData (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PNTFS_TUNNELED_DATA TunneledData
    )

/*++

Routine Description:

    This routine will get the tunneled data for the
    given Fcb.  Currently, this means getting the Fcb's
    creation time.

Arguments:

    Fcb - Supplies the Fcb for which to get the data.

    TunneledData - Where to store the tunneled data.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PAGED_CODE();

    UNREFERENCED_PARAMETER( IrpContext );

    TunneledData->CreationTime = Fcb->Info.CreationTime;

    return STATUS_SUCCESS;
}


NTSTATUS
NtfsSetTunneledData (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PNTFS_TUNNELED_DATA TunneledData
    )

/*++

Routine Description:

    This routine will set the tunneled data for the
    given Fcb.  Currently, this means setting the Fcb's
    creation time and setting its object id, if any.

Arguments:

    Fcb - Supplies the Fcb whose tunneled data should be set.

    TunneledData - Supplies the data to set for the Fcb.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    Fcb->Info.CreationTime = TunneledData->CreationTime;

    if (TunneledData->HasObjectId) {

        try {

            Status = NtfsSetObjectIdInternal( IrpContext,
                                              Fcb,
                                              Fcb->Vcb,
                                              &TunneledData->ObjectIdBuffer );

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
            NtfsMinimumExceptionProcessing( IrpContext );

            //
            //  If setting the object id failed just because the id is in use
            //  for another file, or if the file already has an object id,
            //  there's no point in failing the entire create operation.
            //  We'll just say that all went well in that case, and only raise
            //  if something unexpected happened.
            //

            if ((Status == STATUS_DUPLICATE_NAME) ||
                (Status == STATUS_OBJECT_NAME_COLLISION)) {

                //
                //  We notify anyone watching the object id index that this
                //  object id couldn't be tunnelled.  This lets a link tracking
                //  service decide for itself how to handle this case.
                //

                if (Fcb->Vcb->ViewIndexNotifyCount != 0) {

                    FILE_OBJECTID_INFORMATION FileObjectIdInfo;

                    RtlCopyMemory( &FileObjectIdInfo.FileReference,
                                   &Fcb->FileReference,
                                   sizeof(FILE_REFERENCE) );

                    RtlCopyMemory( FileObjectIdInfo.ObjectId,
                                   TunneledData->ObjectIdBuffer.ObjectId,
                                   OBJECT_ID_KEY_LENGTH );

                    RtlCopyMemory( FileObjectIdInfo.ExtendedInfo,
                                   TunneledData->ObjectIdBuffer.ExtendedInfo,
                                   OBJECT_ID_EXT_INFO_LENGTH );

                    NtfsReportViewIndexNotify( Fcb->Vcb,
                                               Fcb->Vcb->ObjectIdTableScb->Fcb,
                                               FILE_NOTIFY_CHANGE_FILE_NAME,
                                               (Status == STATUS_DUPLICATE_NAME ?
                                                FILE_ACTION_ID_NOT_TUNNELLED :
                                                FILE_ACTION_TUNNELLED_ID_COLLISION),
                                               &FileObjectIdInfo,
                                               sizeof(FILE_OBJECTID_INFORMATION) );
                }

                IrpContext->ExceptionStatus = Status = STATUS_SUCCESS;

            } else {

                NtfsRaiseStatus( IrpContext, Status, NULL, NULL);
            }
        }
    }

    return Status;
}

//
//  Local Support Routine
//

NTSTATUS
NtfsCreateUsnJournal (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine creates the Usn journal for the first time, and is a noop
    if Usn journal already exists.

Arguments:

    IrpContext - context of the call

    Irp - request being serviced

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status = STATUS_SUCCESS;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    CREATE_USN_JOURNAL_DATA CapturedData;

    //
    //  Don't post this request, we can't lock the input buffer.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Extract and decode the file object and check for type of open.
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        return STATUS_ACCESS_DENIED;
    }

    if (NtfsIsVolumeReadOnly( Vcb )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    if (Vcb->ExtendDirectory == NULL) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_VOLUME_NOT_UPGRADED );
        return STATUS_VOLUME_NOT_UPGRADED;
    }

    //
    //  Check for a minimum length on the input buffer.
    //

    if (IrpSp->Parameters.FileSystemControl.InputBufferLength < sizeof( CREATE_USN_JOURNAL_DATA )) {
        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Do the work, if needed.  Acquire the VCB exclusive to lock out creates which
    //  have a locking order vis a vis the usn journal / extend directory / mft opposed
    //  to this path
    //

    NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );

    try {

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
        }

        //
        //  Also fail if the journal is currently being deleted.
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_USN_DELETE )) {

            NtfsRaiseStatus( IrpContext, STATUS_JOURNAL_DELETE_IN_PROGRESS, NULL, NULL );
        }

        //
        //  Capture the JournalData from the unsafe user buffer.
        //

        try {

            if (Irp->RequestorMode != KernelMode) {

                ProbeForRead( IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                              IrpSp->Parameters.FileSystemControl.InputBufferLength,
                              NTFS_TYPE_ALIGNMENT( CREATE_USN_JOURNAL_DATA ));

            } else if (!IsTypeAligned( IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                                       CREATE_USN_JOURNAL_DATA )){

                Status = STATUS_INVALID_USER_BUFFER;
                leave;
            }

            CapturedData = *(PCREATE_USN_JOURNAL_DATA)IrpSp->Parameters.FileSystemControl.Type3InputBuffer;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            NtfsRaiseStatus( IrpContext, STATUS_INVALID_USER_BUFFER, NULL, NULL);
        }

        //
        //  Create or change the Usn Journal parameters.
        //

        NtfsInitializeUsnJournal( IrpContext, Vcb, TRUE, FALSE, &CapturedData );

    } finally {

        NtfsReleaseVcb( IrpContext, Vcb );
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


//
//  Local Support Routine
//

typedef struct _USN_DATA_CONTEXT {
    USN_RECORD UNALIGNED *UsnRecord;
    ULONG RoomLeft;
    ULONG BytesUsed;
    USN LowUsn;
    USN HighUsn;
    FILE_REFERENCE FileReference;
} USN_DATA_CONTEXT, *PUSN_DATA_CONTEXT;

NTSTATUS
NtfsReadUsnWorker (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine reads the USN data from the file record and returns
    it in the user's buffer.

Arguments:

    Fcb - Fcb for the file to be processed.

    Context - Pointer to USN_DATA_CONTEXT.

Return Value:

    STATUS_SUCCESS if a record was successfully stored
    STATUS_BUFFER_OVERFLOW if buffer was not big enough for record

--*/
{
    ATTRIBUTE_ENUMERATION_CONTEXT NameContext;
    PUSN_DATA_CONTEXT UsnContext = (PUSN_DATA_CONTEXT) Context;

    PFILE_NAME FileName;
    ULONG RecordLength;
    ULONG FileAttributes;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN MoreToGo;

    //
    //  Find name record; Initialize the context structure.
    //

    try {

        NtfsInitializeAttributeContext( &NameContext );

        //
        //  Locate a file name with the FILE_NAME_NTFS bit set
        //

        MoreToGo = NtfsLookupAttributeByCode( IrpContext,
                                              Fcb,
                                              &Fcb->FileReference,
                                              $FILE_NAME,
                                              &NameContext );
        //
        //  While we've found an attribute
        //

        while (MoreToGo) {

            FileName = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &NameContext ));

            //
            //  See if the NTFS name is set for this name.
            //

            if (FlagOn( FileName->Flags, FILE_NAME_NTFS )) {

                break;

            }

            //
            //  The last one wasn't it.  Let's try again.
            //

            MoreToGo = NtfsLookupNextAttributeByCode( IrpContext,
                                                      Fcb,
                                                      $FILE_NAME,
                                                      &NameContext );
        }

        if (!MoreToGo) {

            NtfsCleanupAttributeContext( IrpContext, &NameContext );
            NtfsInitializeAttributeContext( &NameContext );

            //
            //  Couldn't find an Ntfs name, check for any hard link.
            //

            MoreToGo = NtfsLookupAttributeByCode( IrpContext,
                                                  Fcb,
                                                  &Fcb->FileReference,
                                                  $FILE_NAME,
                                                  &NameContext );
            //
            //  While we've found an attribute
            //

            while (MoreToGo) {

                FileName = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &NameContext ));

                //
                //  See if the DOS name is not set for this name.
                //

                if (!FlagOn( FileName->Flags, FILE_NAME_DOS )) {

                    break;

                }

                //
                //  The last one wasn't it.  Let's try again.
                //

                MoreToGo = NtfsLookupNextAttributeByCode( IrpContext,
                                                          Fcb,
                                                          $FILE_NAME,
                                                          &NameContext );
            }

            if (!MoreToGo) {

                ASSERTMSG( "Couldn't find a name string for file\n", FALSE );
                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }
        }

        //
        //  Check there's enough room for a USN record.
        //
        //  Record length is a function of the filename length and the structure the
        //  user expects.
        //

        RecordLength = FIELD_OFFSET( USN_RECORD, FileName ) + (FileName->FileNameLength * sizeof( WCHAR ));

        RecordLength = QuadAlign( RecordLength );
        if (RecordLength > UsnContext->RoomLeft) {
            Status = STATUS_BUFFER_TOO_SMALL;
            leave;
        }

        if (Fcb->Usn < UsnContext->LowUsn ||
            Fcb->Usn > UsnContext->HighUsn ) {

            leave;
        }

        //
        //  Set up fixed portion of USN record.  The following fields are the
        //  same for either version.
        //

        UsnContext->UsnRecord->RecordLength = RecordLength;
        UsnContext->UsnRecord->FileReferenceNumber = *(PULONGLONG)&Fcb->FileReference;
        UsnContext->UsnRecord->ParentFileReferenceNumber = *(PULONGLONG)&FileName->ParentDirectory;
        UsnContext->UsnRecord->Usn = Fcb->Usn;

        //
        //  Presumably the caller is not interested in the TimeStamp while scanning the Mft,
        //  but if he is, then he may need to go read the Usn we are returning.
        //

        UsnContext->UsnRecord->TimeStamp.QuadPart = 0;
        UsnContext->UsnRecord->Reason = 0;

        //
        //  Build the FileAttributes from the Fcb.
        //

        FileAttributes = Fcb->Info.FileAttributes & FILE_ATTRIBUTE_VALID_FLAGS;

        //
        //  We have to generate the DIRECTORY attribute.
        //

        if (IsDirectory( &Fcb->Info ) || IsViewIndex( &Fcb->Info )) {
            SetFlag( FileAttributes, FILE_ATTRIBUTE_DIRECTORY );
        }

        //
        //  If there are no flags set then explicitly set the NORMAL flag.
        //

        if (FileAttributes == 0) {
            FileAttributes = FILE_ATTRIBUTE_NORMAL;
        }

        //
        //  Now set the other fields.
        //

        UsnContext->UsnRecord->MajorVersion = 2;
        UsnContext->UsnRecord->MinorVersion = 0;

        UsnContext->UsnRecord->SourceInfo = 0;
        UsnContext->UsnRecord->SecurityId = (ULONG) Fcb->SecurityId;
        UsnContext->UsnRecord->FileAttributes = FileAttributes;

        //
        //  Copy file name to Usn record
        //

        UsnContext->UsnRecord->FileNameLength = (USHORT)(FileName->FileNameLength * sizeof( WCHAR ));
        UsnContext->UsnRecord->FileNameOffset = FIELD_OFFSET( USN_RECORD, FileName );
        RtlCopyMemory( &UsnContext->UsnRecord->FileName[0],
                       &FileName->FileName[0],
                       FileName->FileNameLength * sizeof( WCHAR ));

        //
        //  Adjust context for next record
        //

        UsnContext->UsnRecord = (PUSN_RECORD) Add2Ptr( UsnContext->UsnRecord, RecordLength );
        UsnContext->RoomLeft -= RecordLength;
        UsnContext->BytesUsed += RecordLength;

    } finally {

        NtfsCleanupAttributeContext( IrpContext, &NameContext );

    }

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsReadFileRecordUsnData (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine enumerates base file records beginning at a specified
    one and returns USN data from the found records.

Arguments:

    IrpContext - context of the call

    Irp - request being serviced

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS Status = STATUS_SUCCESS;
    USN_DATA_CONTEXT Context;
    MFT_ENUM_DATA UNALIGNED *EnumData = (PMFT_ENUM_DATA) IrpSp->Parameters.FileSystemControl.Type3InputBuffer;
    BOOLEAN LockedMdl = FALSE;

    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    TYPE_OF_OPEN TypeOfOpen;

    //
    //  Don't post this request.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    //
    //  We'll catch dismounted volumes explicitly in iterate mft so don't raise on error
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext,
                                       IrpSp->FileObject,
                                       &Vcb,
                                       &Fcb,
                                       &Scb,
                                       &Ccb,
                                       FALSE );

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Check for a minimum length on the input and output buffers.
    //

    if (IrpSp->Parameters.FileSystemControl.InputBufferLength < sizeof( MFT_ENUM_DATA )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    if (IrpSp->Parameters.FileSystemControl.OutputBufferLength < sizeof( FILE_REFERENCE )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        return STATUS_BUFFER_TOO_SMALL;
    }

    try {

        //
        //  Probe the input and output buffers.
        //

        if (Irp->RequestorMode != KernelMode) {

            ProbeForRead( EnumData,
                          IrpSp->Parameters.FileSystemControl.InputBufferLength,
                          NTFS_TYPE_ALIGNMENT( MFT_ENUM_DATA ));

            ProbeForWrite( Irp->UserBuffer,
               IrpSp->Parameters.FileSystemControl.OutputBufferLength,
               NTFS_TYPE_ALIGNMENT( FILE_REFERENCE ));

        } else if (!IsTypeAligned( IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                                   MFT_ENUM_DATA ) ||
                   !IsTypeAligned( Irp->UserBuffer, FILE_REFERENCE )) {

            Status = STATUS_INVALID_USER_BUFFER;
            leave;
        }

        //
        //  Capture the starting file reference
        //

        Context.FileReference = *(PFILE_REFERENCE) &EnumData->StartFileReferenceNumber;

        if (NtfsFullSegmentNumber( &Context.FileReference ) < FIRST_USER_FILE_NUMBER) {

            NtfsSetSegmentNumber( &Context.FileReference, 0, FIRST_USER_FILE_NUMBER );
        }

        //
        //  Set up for filling output records
        //

        Context.RoomLeft = IrpSp->Parameters.FileSystemControl.OutputBufferLength - sizeof( FILE_REFERENCE );
        Context.UsnRecord = (PUSN_RECORD) Add2Ptr( Irp->UserBuffer, sizeof( FILE_REFERENCE ));
        Context.BytesUsed = sizeof( FILE_REFERENCE );
        Context.LowUsn = EnumData->LowUsn;
        Context.HighUsn = EnumData->HighUsn;

        //
        //  Iterate through the Mft beginning at the specified file reference
        //

        Status = NtfsIterateMft( IrpContext,
                                 Vcb,
                                 &Context.FileReference,
                                 NtfsReadUsnWorker,
                                 &Context );

        if ((Status == STATUS_BUFFER_TOO_SMALL) ||
            ((Status == STATUS_END_OF_FILE) && (Context.BytesUsed != sizeof( FILE_REFERENCE )))) {

            Status = STATUS_SUCCESS;
        }

        if (NT_SUCCESS( Status )) {

            //
            //  Set the returned file reference number and bytes used. Note: UserBuffer
            //  is a raw user mode ptr and must be in a try-except
            //

            Irp->IoStatus.Information = Context.BytesUsed;
            *((PFILE_REFERENCE) Irp->UserBuffer) = Context.FileReference;
        }

    } except( NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), TRUE, &Status ) ) {

        NtfsRaiseStatus( IrpContext,
                         STATUS_INVALID_USER_BUFFER,
                         NULL,
                         NULL);
    }

    NtfsCompleteRequest( IrpContext, Irp, Status);
    return Status;
}


//
//  Local Support Routine
//

typedef struct _SID_MATCH_CONTEXT {
    FILE_NAME_INFORMATION UNALIGNED *FileNames;
    ULONG RoomLeft;
    ULONG BytesUsed;
    ULONG OwnerId;
    FILE_REFERENCE Parent;
} SID_MATCH_CONTEXT, *PSID_MATCH_CONTEXT;

NTSTATUS
NtfsFindBySidWorker (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine finds files owned by a Sid in a given context.

Arguments:

    Fcb - Fcb for the file to be processed.

    Context - Pointer to SID_MATCH_CONTEXT.

Return Value:

    STATUS_SUCCESS if file did not match SID or
        matched sid but wasn't in scope or
        matched sid and was in scope and was stored.
    STATUS_BUFFER_OVERFLOW if buffer was not big enough for record

--*/
{
    PSID_MATCH_CONTEXT SidContext = (PSID_MATCH_CONTEXT) Context;
    SCOPE_CONTEXT ScopeContext;

    NTSTATUS Status;

    //
    //  See if the file is owned by the specified Sid
    //

    if (Fcb->OwnerId != SidContext->OwnerId) {
        return STATUS_SUCCESS;
    }

    //
    //  Find name record; Initialize the context structure.
    //

    try {

        //
        //  If we're at the root of the scope, then build the name directly
        //

        if (NtfsEqualMftRef( &SidContext->Parent, &Fcb->FileReference )) {

            ScopeContext.Name.Buffer = NtfsAllocatePool(PagedPool, 2 );
            ScopeContext.Name.MaximumLength = ScopeContext.Name.Length = 2;
            ScopeContext.Name.Buffer[0] = '\\';

            Status = STATUS_NO_MORE_FILES;

        //
        //  Otherwise, walk up the tree
        //

        } else {
            ScopeContext.IsRoot = NtfsEqualMftRef( &RootIndexFileReference, &SidContext->Parent );
            ScopeContext.Name.Buffer = NULL;
            ScopeContext.Name.Length = 0;
            ScopeContext.Name.MaximumLength = 0;
            ScopeContext.Scope = SidContext->Parent;

            Status = NtfsWalkUpTree( IrpContext, Fcb, NtfsBuildRelativeName, &ScopeContext );
        }

        //
        //  If we either received SUCCESS (i.e., walked to root successfully)
        //  or NO_MORE_FILES (walked to scope successfully)
        //

        if (Status == STATUS_SUCCESS || Status == STATUS_NO_MORE_FILES) {

            ULONG Length =
                QuadAlign( ScopeContext.Name.Length - sizeof( WCHAR ) +
                           sizeof( FILE_NAME_INFORMATION ) - sizeof( WCHAR ));

            //
            //  Verify that there is enough room for this file name
            //

            if (Length > SidContext->RoomLeft) {
                Status = STATUS_BUFFER_TOO_SMALL;
                leave;
            }

            //
            //  Emit the file name to the caller's buffer
            //

            SidContext->FileNames->FileNameLength = ScopeContext.Name.Length - sizeof( WCHAR );
            RtlCopyMemory( SidContext->FileNames->FileName,
                           ScopeContext.Name.Buffer + 1,
                           ScopeContext.Name.Length - sizeof( WCHAR ));

            //
            //  Adjust for next name
            //

            SidContext->BytesUsed += Length;
            SidContext->RoomLeft -= Length;
            SidContext->FileNames = (PFILE_NAME_INFORMATION) Add2Ptr( SidContext->FileNames, Length );
        }

        Status = STATUS_SUCCESS;

    } finally {

        if (ScopeContext.Name.Buffer != NULL) {
            NtfsFreePool( ScopeContext.Name.Buffer );
        }

    }

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsFindFilesOwnedBySid (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine enumerates file records, finds entries owned by a
    specified Sid and returns the path relative to the called-on Fcb
    of the found file.

    We hide the details of this Mft-based scan by encapsulating this
    a find-first/next structure.

Arguments:

    IrpContext - context of the call.  The input buffer contains a ULONG
        followed by a SID:
            0 = continue enumeration
            1 = start enumeration

    Irp - request being serviced

Return Value:

    NTSTATUS - The return status for the operation



--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FILE_REFERENCE FileReference;
    NTSTATUS Status = STATUS_SUCCESS;
    SID_MATCH_CONTEXT Context;
    PFIND_BY_SID_DATA FindData =
        (PFIND_BY_SID_DATA)IrpSp->Parameters.FileSystemControl.Type3InputBuffer;
    PFIND_BY_SID_DATA CapturedFindData = NULL;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    BOOLEAN ReleaseVcb = FALSE;

    PAGED_CODE();

    //
    //  Don't post this request, we can't lock both input and output buffers.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    //
    //  Decode the file object, fail this request if not a user data stream.
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext,
                                       IoGetCurrentIrpStackLocation( Irp )->FileObject,
                                       &Vcb,
                                       &Fcb,
                                       &Scb,
                                       &Ccb,
                                       TRUE );

    if (TypeOfOpen != UserDirectoryOpen || Ccb == NULL) {

        Status = STATUS_INVALID_PARAMETER;
        NtfsCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    try {
        try {

            NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
            ReleaseVcb = TRUE;

            if (Irp->RequestorMode != KernelMode) {
                ProbeForRead( IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                              IrpSp->Parameters.FileSystemControl.InputBufferLength,
                              NTFS_TYPE_ALIGNMENT( FIND_BY_SID_DATA ));
                ProbeForWrite( Irp->UserBuffer,
                               IrpSp->Parameters.FileSystemControl.OutputBufferLength,
                               NTFS_TYPE_ALIGNMENT( FILE_NAME_INFORMATION ));
            }

            if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {
                Status = STATUS_VOLUME_DISMOUNTED;
                leave;
            }

            if (Vcb->OwnerIdTableScb == NULL) {
                Status = STATUS_VOLUME_NOT_UPGRADED;
                leave;
            }

            if (IrpSp->Parameters.FileSystemControl.InputBufferLength < sizeof( ULONG )) {

                Status = STATUS_INVALID_USER_BUFFER;
                leave;
            }

            //
            //  Allocate a buffer to capture the input buffer.
            //

            CapturedFindData = NtfsAllocatePool( PagedPool,
                                                 IrpSp->Parameters.FileSystemControl.InputBufferLength );

            RtlCopyMemory( CapturedFindData,
                           FindData,
                           IrpSp->Parameters.FileSystemControl.InputBufferLength );

            //
            //  Do some final checks on the input and output buffers.
            //

            if (
                //
                //  The input and output buffers must be aligned
                //

                !IsTypeAligned( IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                                FIND_BY_SID_DATA )
                    DebugDoit( && DebugPrint(( "Input buffer not long aligned" ))) ||
                !IsTypeAligned( Irp->UserBuffer, FILE_NAME_INFORMATION )
                    DebugDoit( && DebugPrint(( "Output buffer not long aligned" ))) ||

                //
                //  There must be enough room in the output buffer.
                //  (Input buffer is already verified).
                //

                IrpSp->Parameters.FileSystemControl.OutputBufferLength <
                    sizeof( FILE_NAME_INFORMATION )
                    DebugDoit( && DebugPrint(( "Output buffer shorter than FILE_NAME_INFORMATION" ))) ||

                //
                //  The input flag must be 0 or 1
                //

                CapturedFindData->Restart > 1
                    DebugDoit( && DebugPrint(( "Restart not 0/1" ))) ||

                //
                //  There must be enough room for a SID in the input
                //

                sizeof( ULONG ) + RtlLengthSid( &FindData->Sid ) >
                    IrpSp->Parameters.FileSystemControl.InputBufferLength
                    DebugDoit( && DebugPrint(( "Not enough room for input SID" ))) ||

                //
                //  Also verify the captured data in case our caller is playing games.
                //

                sizeof( ULONG ) + RtlLengthSid( &CapturedFindData->Sid ) >
                    IrpSp->Parameters.FileSystemControl.InputBufferLength
                    DebugDoit( && DebugPrint(( "Not enough room for captured input SID" )))

                ) {

                Status = STATUS_INVALID_USER_BUFFER;
                leave;
            }

            //
            //  Set up starting file reference either from where the user left off
            //  or from the next position
            //

            if (CapturedFindData->Restart) {
                NtfsSetSegmentNumber( &FileReference, 0, ROOT_FILE_NAME_INDEX_NUMBER );
            } else {
                ASSERT( Ccb->NodeByteSize == sizeof( CCB ) );
                FileReference = Ccb->MftScanFileReference;
                if (NtfsSegmentNumber( &FileReference ) < ROOT_FILE_NAME_INDEX_NUMBER) {
                    NtfsSetSegmentNumber( &FileReference, 0, ROOT_FILE_NAME_INDEX_NUMBER );
                }
            }

            //
            //  Set up for filling output records
            //

            Context.RoomLeft = IrpSp->Parameters.FileSystemControl.OutputBufferLength;
            Context.FileNames = (PFILE_NAME_INFORMATION) Irp->UserBuffer;
            Context.BytesUsed = 0;

            //
            //  Convert input Sid into OWNER_ID.  If we haven't seen this SID before
            //  then we are done!  We use the copy of the Sid so we don't take an access
            //  violation in the user frees the memory.  Some of our internal routines
            //  never expect a failure touching this buffer.
            //

            Context.OwnerId = NtfsGetOwnerId( IrpContext, &CapturedFindData->Sid, FALSE, NULL );

            if (Context.OwnerId == QUOTA_INVALID_ID) {
                Status = STATUS_SUCCESS;
                leave;
            }

            Context.Parent = Fcb->FileReference;

            //
            //  Iterate through the Mft beginning at the specified file reference.
            //  Release the Vcb now because the worker routine will acquire and
            //  drop as necessary.  We don't want to block out critical operations
            //  like clean checkpoints during a full Mft scan.
            //

            NtfsReleaseVcb( IrpContext, Vcb );
            ReleaseVcb = FALSE;

            Status = NtfsIterateMft( IrpContext,
                                     Vcb,
                                     &FileReference,
                                     NtfsFindBySidWorker,
                                     &Context );

            //
            //  If we failed due to running out of space and we stored something or
            //  if we ran off the end of the MFT, then this is really a successful
            //  return.
            //

            Irp->IoStatus.Information = Context.BytesUsed;

            if (!NT_SUCCESS( Status )) {
                if ((Status == STATUS_BUFFER_TOO_SMALL && Context.BytesUsed != 0)
                    || Status == STATUS_END_OF_FILE) {
                    Status = STATUS_SUCCESS;
                } else {
                    leave;
                }
            }

            Ccb->MftScanFileReference = FileReference;

        } except( NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), TRUE, &Status ) ) {

            NtfsRaiseStatus( IrpContext,
                             STATUS_INVALID_USER_BUFFER,
                             NULL,
                             NULL);
        }
    } finally {

        //
        //  Free the Vcb if still held.
        //

        if (ReleaseVcb) {

            NtfsReleaseVcb( IrpContext, Vcb );
        }

        //
        //  Free the captured input buffer if allocated.
        //

        if (CapturedFindData != NULL) {

            NtfsFreePool( CapturedFindData );
        }
    }

    //
    //  If nothing raised then complete the irp.
    //

    NtfsCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsReadFileUsnData (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine enumerates base file records beginning at a specified
    one and returns USN data from the found records.

Arguments:

    IrpContext - context of the call

    Irp - request being serviced

    RecordVersion - format for the usn record to return

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS Status = STATUS_SUCCESS;
    USN_DATA_CONTEXT Context;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    //
    //  Don't post this request.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Extract and decode the file object and check for type of open.
    //  We don't want to raise on dismounts here because we check for that further down
    //  anyway. So send FALSE.
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );

    if ((TypeOfOpen != UserFileOpen) && (TypeOfOpen != UserDirectoryOpen)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Check that the user's buffer is large enough.
    //

    if (IrpSp->Parameters.FileSystemControl.OutputBufferLength < sizeof( USN_RECORD )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  Set up for filling output records
    //

    Context.RoomLeft = IrpSp->Parameters.FileSystemControl.OutputBufferLength;
    Context.UsnRecord = Irp->UserBuffer;
    Context.BytesUsed = 0;
    Context.LowUsn = 0;
    Context.HighUsn = MAXLONGLONG;

    NtfsAcquireSharedScb( IrpContext, Scb );

    try {

        //
        //  Verify the volume is mounted.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  Careful access to the user's buffer.
        //

        try {

            //
            //  Probe the output buffer.
            //

            if (Irp->RequestorMode != KernelMode) {

                ProbeForWrite( Irp->UserBuffer,
                               IrpSp->Parameters.FileSystemControl.OutputBufferLength,
                               NTFS_TYPE_ALIGNMENT( USN_DATA_CONTEXT ));

            } else if (!IsTypeAligned( Irp->UserBuffer, USN_DATA_CONTEXT )) {

                Status = STATUS_INVALID_USER_BUFFER;
                leave;
            }

            //
            //  Now read the Usn data.
            //

            Status = NtfsReadUsnWorker( IrpContext, Fcb, &Context );

        } except( NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), TRUE, &Status ) ) {

            NtfsRaiseStatus( IrpContext,
                             STATUS_INVALID_USER_BUFFER,
                             NULL,
                             NULL );
        }

    } finally {

        NtfsReleaseScb( IrpContext, Scb );
    }

    //
    //  On success return bytes in Usn Record.
    //

    if (NT_SUCCESS(Status)) {
        Irp->IoStatus.Information = Context.BytesUsed;
    }

    NtfsCompleteRequest( IrpContext, Irp, Status);

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsWriteUsnCloseRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine writes a close Usn record for the current file, and returns
    its Usn.

Arguments:

    IrpContext - context of the call

    Irp - request being serviced

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS Status = STATUS_SUCCESS;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PVOID UserBuffer;
    BOOLEAN AccessingUserBuffer = FALSE;

    //
    //  Go ahead and make this operation synchronous.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Extract and decode the file object and check for type of open.
    //  We check for dismount further below, so send FALSE to not raise here.
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );

    if ((TypeOfOpen != UserFileOpen) && (TypeOfOpen != UserDirectoryOpen)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    if (NtfsIsVolumeReadOnly( Vcb )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    //
    //  There must be room in the output buffer.
    //

    if (IrpSp->Parameters.FileSystemControl.OutputBufferLength < sizeof(USN)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    UserBuffer = NtfsMapUserBuffer( Irp );
    NtfsAcquireExclusiveScb( IrpContext, Scb );

    try {

        //
        //  Verify the volume is mounted.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  Fail this request if the journal is being deleted or is not running.
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_USN_DELETE )) {

            Status = STATUS_JOURNAL_DELETE_IN_PROGRESS;
            leave;
        }

        if (!FlagOn( Vcb->VcbState, VCB_STATE_USN_JOURNAL_ACTIVE )) {

            Status = STATUS_JOURNAL_NOT_ACTIVE;
            leave;
        }

        //
        //  Use a try-except to check our access to the user buffer.
        //

        try {

            //
            //  Probe the output buffer.
            //

            if (Irp->RequestorMode != KernelMode) {

                AccessingUserBuffer = TRUE;
                ProbeForWrite( Irp->UserBuffer,
                               IrpSp->Parameters.FileSystemControl.OutputBufferLength,
                               NTFS_TYPE_ALIGNMENT( USN ));
                AccessingUserBuffer = FALSE;

            } else if (!IsTypeAligned( Irp->UserBuffer, USN )) {

                Status = STATUS_INVALID_USER_BUFFER;
                leave;
            }

            //
            //  Now write the close record.
            //

            NtfsPostUsnChange( IrpContext, Scb, USN_REASON_CLOSE );

            //
            //  Now, if anything at all is posted to the Usn Journal, we must write it now
            //  so that we do not get a log file full later.
            //

            ASSERT( IrpContext->Usn.NextUsnFcb == NULL );
            if (IrpContext->Usn.CurrentUsnFcb != NULL) {

                //
                //  Now write the journal, checkpoint the transaction, and free the UsnJournal to
                //  reduce contention.
                //

                NtfsWriteUsnJournalChanges( IrpContext );
                NtfsCheckpointCurrentTransaction( IrpContext );
            }

            //
            //  Set the returned Usn.
            //

            AccessingUserBuffer = TRUE;
            *(USN *)UserBuffer = Fcb->Usn;
            AccessingUserBuffer = FALSE;

        } except( NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), AccessingUserBuffer, &Status ) ) {

            NtfsRaiseStatus( IrpContext,
                             STATUS_INVALID_USER_BUFFER,
                             NULL,
                             NULL );
        }

    } finally {

        NtfsReleaseScb( IrpContext, Scb );
    }

    //
    //  On success return bytes in Usn Record.
    //

    if (NT_SUCCESS(Status)) {
        Irp->IoStatus.Information = sizeof(USN);
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsBulkSecurityIdCheck (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs a check to see if the current subject is granted access by
    the security descriptors identified by the security Ids.


Arguments:

    IrpContext - context of the call

    Irp - request being serviced

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS Status = STATUS_SUCCESS;
    PBULK_SECURITY_TEST_DATA SecurityData =
        (PBULK_SECURITY_TEST_DATA) IrpSp->Parameters.FileSystemControl.Type3InputBuffer;
    PNTSTATUS OutputStatus = (PNTSTATUS) Irp->UserBuffer;
    ACCESS_MASK DesiredAccess;
    BOOLEAN AccessGranted;
    ACCESS_MASK GrantedAccess;
    ULONG i, SecurityIdCount;
    SECURITY_SUBJECT_CONTEXT SecurityContext;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsBulkSecurityIdCheck...\n") );

    //
    //  Don't post this request, we can't lock both input and output buffers.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    //
    //  Verify this is a valid type of open.
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext,
                                       IrpSp->FileObject,
                                       &Vcb,
                                       &Fcb,
                                       &Scb,
                                       &Ccb,
                                       TRUE );

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

        Status = STATUS_ACCESS_DENIED;
        DebugTrace( -1, Dbg, ("NtfsBulkSecurityIdCheck -> %08lx\n", Status) );
        NtfsCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    try {

        NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {
            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        try {

            if (Irp->RequestorMode != KernelMode) {
                ProbeForRead( IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                              IrpSp->Parameters.FileSystemControl.InputBufferLength,
                              NTFS_TYPE_ALIGNMENT( BULK_SECURITY_TEST_DATA ));
                ProbeForWrite( Irp->UserBuffer,
                               IrpSp->Parameters.FileSystemControl.OutputBufferLength,
                               sizeof(ULONG));
            }

            SecurityIdCount =
                (IrpSp->Parameters.FileSystemControl.InputBufferLength
                 - FIELD_OFFSET( BULK_SECURITY_TEST_DATA, SecurityIds )) / sizeof( SECURITY_ID );

            if (
                //
                //  The input and output buffers must be aligned
                //

                   !IsTypeAligned( SecurityData, BULK_SECURITY_TEST_DATA )
                || !IsLongAligned( OutputStatus )

                //
                //  The output buffer must contain the same number of NTSTATUS
                //  as SECURITY_IDs
                //

                || SecurityIdCount * sizeof( NTSTATUS ) !=
                      IrpSp->Parameters.FileSystemControl.OutputBufferLength

                ) {

                NtfsRaiseStatus( IrpContext, STATUS_INVALID_USER_BUFFER, NULL, NULL );
            }

            //
            //  Capture the desired access so we can modify it
            //

            DesiredAccess = SecurityData->DesiredAccess;
            RtlMapGenericMask( &DesiredAccess, IoGetFileObjectGenericMapping() );

            SeCaptureSubjectContext( &SecurityContext );
            SeLockSubjectContext( &SecurityContext );

            try {
                for (i = 0; i < SecurityIdCount; i++) {

                    PSHARED_SECURITY SharedSecurity;

                    SharedSecurity = NtfsCacheSharedSecurityBySecurityId( IrpContext,
                                                                          Vcb,
                                                                          SecurityData->SecurityIds[i] );

                    //
                    //  Do the access check
                    //

                    AccessGranted = SeAccessCheck( SharedSecurity->SecurityDescriptor,
                                                   &SecurityContext,
                                                   TRUE,                           // Tokens are locked
                                                   DesiredAccess,
                                                   0,
                                                   NULL,
                                                   IoGetFileObjectGenericMapping(),
                                                   (KPROCESSOR_MODE)(FlagOn( IrpSp->Flags, SL_FORCE_ACCESS_CHECK ) ?
                                                                     UserMode :
                                                                     Irp->RequestorMode),
                                                   &GrantedAccess,
                                                   &OutputStatus[i] );

                    NtfsAcquireFcbSecurity( Vcb );
                    RemoveReferenceSharedSecurityUnsafe( &SharedSecurity );
                    NtfsReleaseFcbSecurity( Vcb );
                }

            } finally {

                SeUnlockSubjectContext( &SecurityContext );
                SeReleaseSubjectContext( &SecurityContext );
            }

        } except( NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), TRUE, &Status ) ) {

            NtfsRaiseStatus( IrpContext,
                             STATUS_INVALID_USER_BUFFER,
                             NULL,
                             NULL );
        }

    } finally {
        NtfsReleaseVcb( IrpContext, Vcb );
    }

    NtfsCompleteRequest( IrpContext, Irp, Status);

    return Status;
}


//
//  Local support routine.
//

NTSTATUS
NtfsQueryAllocatedRanges (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routines scans the allocation of the file looking for allocated ranges
    starting from some offset given by our caller.  An allocated range is one
    which either has any allocation within the defined sparse block size (64K) or
    has any clusters reserved within this same block.  Sparse file support is meant
    to optimize the case where the user has a large unallocated range.  We will
    force him to read zeroes from the file where the deallocated ranges are
    smaller than 64K.

    If the file is not marked as sparse then we will return the entire file as
    allocated even for the compressed stream case where large blocks of
    zeroes are represented by holes.

    The Irp contains the input and output buffers for this request.  This fsctrl
    specifies METHOD_NEITHER so we must carefully access these buffers.

Arguments:

    Irp - Request being serviced

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS Status = STATUS_SUCCESS;

    BOOLEAN AcquiredScb = FALSE;

    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    BOOLEAN AccessingUserBuffer = FALSE;
    BOOLEAN Allocated;

    ULONG RemainingBytes;

    LONGLONG StartingOffset;
    LONGLONG Length;

    PFILE_ALLOCATED_RANGE_BUFFER OutputBuffer;
    PFILE_ALLOCATED_RANGE_BUFFER CurrentBuffer;

    VCN NextVcn;
    VCN CurrentVcn;
    LONGLONG RemainingClusters;
    LONGLONG ThisClusterCount;
    LONGLONG TwoGigInClusters;
    BOOLEAN UserMappedView;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    Irp->IoStatus.Information = 0;

    //
    //  Don't post this request, we can't lock both input and output buffers.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    //
    //  Extract and decode the file object.
    //  We only allow this operation on user data files.
    //  We check for dismount further below, so send FALSE to not raise here.
    //

    if (NtfsDecodeFileObject( IrpContext,
                              IrpSp->FileObject,
                              &Vcb,
                              &Fcb,
                              &Scb,
                              &Ccb,
                              FALSE ) != UserFileOpen) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Acquired exclusive access to the paging Io resource because we might
    //  need to extend the file when flushing the cache
    //

    NtfsAcquireExclusivePagingIo( IrpContext, Scb->Fcb );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If the volume isn't mounted then fail immediately.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  Check the length of the input buffer.
        //


        if (IrpSp->Parameters.FileSystemControl.InputBufferLength < sizeof( FILE_ALLOCATED_RANGE_BUFFER )) {

            Status = STATUS_INVALID_PARAMETER;
            leave;
        }

        //
        //  Use a try-except to catch any errors accessing the user's buffers.
        //  We will maintain a boolean which indicates if we are accessing
        //  the user's buffer.
        //

        AccessingUserBuffer = TRUE;

        try {

            //
            //  If our caller is not kernel mode then probe the input and
            //  output buffers.
            //

            RemainingBytes = IrpSp->Parameters.FileSystemControl.OutputBufferLength;
            OutputBuffer = (PFILE_ALLOCATED_RANGE_BUFFER) NtfsMapUserBuffer( Irp );
            CurrentBuffer = OutputBuffer - 1;


            if (Irp->RequestorMode != KernelMode) {

                ProbeForRead( IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                              IrpSp->Parameters.FileSystemControl.InputBufferLength,
                              NTFS_TYPE_ALIGNMENT( FILE_ALLOCATED_RANGE_BUFFER ));

                ProbeForWrite( OutputBuffer,
                               RemainingBytes,
                               NTFS_TYPE_ALIGNMENT( FILE_ALLOCATED_RANGE_BUFFER ));

            } else if (!IsTypeAligned( IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                                       FILE_ALLOCATED_RANGE_BUFFER ) ||
                       !IsTypeAligned( OutputBuffer, FILE_ALLOCATED_RANGE_BUFFER )) {

                Status = STATUS_INVALID_USER_BUFFER;
                leave;
            }

            //
            //  Carefully extract the starting offset and length from
            //  the input buffer.  If we are beyond the end of the file
            //  or the length is zero then return immediately.  Otherwise
            //  trim the length to file size.
            //

            StartingOffset = ((PFILE_ALLOCATED_RANGE_BUFFER) IrpSp->Parameters.FileSystemControl.Type3InputBuffer)->FileOffset.QuadPart;
            Length = ((PFILE_ALLOCATED_RANGE_BUFFER) IrpSp->Parameters.FileSystemControl.Type3InputBuffer)->Length.QuadPart;
            AccessingUserBuffer = FALSE;

            //
            //  Check that the input parameters are valid.
            //

            if ((Length < 0) ||
                (StartingOffset < 0) ||
                (Length > MAXLONGLONG - StartingOffset)) {

                Status = STATUS_INVALID_PARAMETER;
                leave;
            }

            //
            //  Check that the requested range is within file size
            //  and has a non-zero length.
            //

            if (Length == 0) {

                leave;
            }

            //
            //  Lets acquire the Scb for the file as well.
            //

            NtfsAcquireExclusiveScb( IrpContext, Scb );
            AcquiredScb = TRUE;

            NtfsAcquireFsrtlHeader( Scb );

            if (StartingOffset >= Scb->Header.FileSize.QuadPart) {

                NtfsReleaseFsrtlHeader( Scb );
                leave;
            }

            if (Scb->Header.FileSize.QuadPart - StartingOffset < Length) {

                Length = Scb->Header.FileSize.QuadPart - StartingOffset;
            }

            NtfsReleaseFsrtlHeader( Scb );

            //
            //  If the file is not sparse or is resident then show that
            //  the entire requested range is allocated.
            //

            if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE ) ||
                FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                if (RemainingBytes < sizeof( FILE_ALLOCATED_RANGE_BUFFER )) {

                    Status = STATUS_BUFFER_TOO_SMALL;

                } else {

                    CurrentBuffer += 1;
                    AccessingUserBuffer = TRUE;
                    CurrentBuffer->FileOffset.QuadPart = StartingOffset;
                    CurrentBuffer->Length.QuadPart = Length;
                    Irp->IoStatus.Information = sizeof( FILE_ALLOCATED_RANGE_BUFFER );
                }

                leave;
            }

            //
            //  Convert the range to check to Vcns so we can use the
            //  allocation routines.
            //

            NextVcn = -1;

            CurrentVcn = LlClustersFromBytesTruncate( Vcb, StartingOffset );
            ((PLARGE_INTEGER) &CurrentVcn)->LowPart &= ~(Vcb->SparseFileClusters - 1);

            RemainingClusters = LlClustersFromBytesTruncate( Vcb,
                                                             StartingOffset + Length + Vcb->SparseFileUnit - 1 );

            ((PLARGE_INTEGER) &RemainingClusters)->LowPart &= ~(Vcb->SparseFileClusters - 1);
            RemainingClusters -= CurrentVcn;

            TwoGigInClusters = LlClustersFromBytesTruncate( Vcb, (LONGLONG) 0x80000000 );

            //
            //  We will walk through the file in two gigabyte chunks.
            //

            do {

                //
                //  We will try to swallow two gig at a time.
                //

                ThisClusterCount = TwoGigInClusters;

                if (ThisClusterCount > RemainingClusters) {

                    ThisClusterCount = RemainingClusters;
                }

                RemainingClusters -= ThisClusterCount;

                //
                //  Preload two gigabytes of allocation information at our Current Vcn.
                //

                NtfsPreloadAllocation( IrpContext,
                                       Scb,
                                       CurrentVcn,
                                       CurrentVcn + ThisClusterCount );

                //
                //  If the file is mapped then flush the data so we can simply
                //  trust the Mcb.  There is a performance cost here but otherwise
                //  we would be returning the entire file as allocated.
                //

                if (FlagOn( Scb->Header.Flags, FSRTL_FLAG_USER_MAPPED_FILE ) &&
                    FlagOn( Scb->ScbState, SCB_STATE_WRITE_ACCESS_SEEN ) &&
                    (Scb->NonpagedScb->SegmentObject.DataSectionObject != NULL)) {

                    LONGLONG CheckClusterCount;
                    LONGLONG RemainingCheckClusterCount = ThisClusterCount;
                    LONGLONG FlushOffset;
                    VCN CheckVcn = CurrentVcn;
                    BOOLEAN ReloadAllocation = FALSE;

                    PRESERVED_BITMAP_RANGE BitMap = Scb->ScbType.Data.ReservedBitMap;

                    ASSERT( Scb->Header.NodeTypeCode == NTFS_NTC_SCB_DATA );

                    while (TRUE) {

                        //
                        //  Check to see if this range is allocated.
                        //

                        Allocated = NtfsIsRangeAllocated( Scb,
                                                          CheckVcn,
                                                          CheckVcn + RemainingCheckClusterCount,
                                                          TRUE,
                                                          &CheckClusterCount );

                        if (!Allocated) {

                            if (Scb->FileObject == NULL) {
                                NtfsCreateInternalAttributeStream( IrpContext, Scb, FALSE, NULL );
                            }

                            NtfsReleaseScb( IrpContext, Scb );
                            AcquiredScb = FALSE;

                            FlushOffset = LlBytesFromClusters( Vcb, CheckVcn );
                            CcFlushCache( &Scb->NonpagedScb->SegmentObject,
                                          (PLARGE_INTEGER) &FlushOffset,
                                          (ULONG) LlBytesFromClusters( Vcb, CheckClusterCount ),
                                          &Irp->IoStatus );

                            NtfsAcquireExclusiveScb( IrpContext, Scb );
                            AcquiredScb = TRUE;

                            //
                            //  On error get out.
                            //

                            NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                                &Irp->IoStatus.Status,
                                                                TRUE,
                                                                STATUS_UNEXPECTED_IO_ERROR );

                            ReloadAllocation = TRUE;
                        }

                        if (RemainingCheckClusterCount <= CheckClusterCount) {

                            break;
                        }

                        RemainingCheckClusterCount -= CheckClusterCount;
                        CheckVcn += CheckClusterCount;
                    }

                    //
                    //  Reload two gigabytes of allocation information at our Current Vcn.
                    //

                    if (ReloadAllocation) {

                        NtfsPreloadAllocation( IrpContext,
                                               Scb,
                                               CurrentVcn,
                                               CurrentVcn + ThisClusterCount );
                    }
                }

                //
                //  Loop while we have more clusters to look for.  We will load
                //  two gigabytes of allocation at a time into the Mcb.
                //

                UserMappedView = !(MmCanFileBeTruncated( &(Scb->NonpagedScb->SegmentObject), NULL ));

                do {

                    LONGLONG CurrentClusterCount;

                    //
                    //  Check to see if this range is allocated.
                    //

                    Allocated = NtfsIsRangeAllocated( Scb,
                                                      CurrentVcn,
                                                      CurrentVcn + ThisClusterCount,
                                                      TRUE,
                                                      &CurrentClusterCount );

                    //
                    //  If we have an unallocated range then we need to trim it by any
                    //  sparse units which have reservation. This is possible if it we haven't flushed because
                    //  its never been mapped or its still being user mapped so our flush is unreliable.
                    //  If the first unit has reservation then change the state of the range to 'Allocated'.
                    //

                    if ((UserMappedView || !FlagOn( Scb->Header.Flags, FSRTL_FLAG_USER_MAPPED_FILE )) &&
                        !Allocated &&
                        NtfsCheckForReservedClusters( Scb, CurrentVcn, &CurrentClusterCount ) &&
                        (CurrentClusterCount < Vcb->SparseFileClusters)) {

                        Allocated = TRUE;
                        CurrentClusterCount = Vcb->SparseFileClusters;
                    }

                    //
                    //  If allocated check and see whether to extend a previous
                    //  run or start a new run.
                    //

                    if (Allocated) {

                        //
                        //  Extend the previous run if contiguous.
                        //

                        AccessingUserBuffer = TRUE;
                        if (NextVcn == CurrentVcn) {

                            CurrentBuffer->Length.QuadPart += LlBytesFromClusters( Vcb, CurrentClusterCount );

                        //
                        //  Otherwise use the next buffer location.
                        //

                        } else {

                            //
                            //  Check that there is space.
                            //

                            if (RemainingBytes < sizeof( FILE_ALLOCATED_RANGE_BUFFER )) {

                                //
                                //  We may already have some entries in the buffer.  Return
                                //  a different code if we were able to store at least one
                                //  entry in the output buffer.
                                //

                                if (CurrentBuffer + 1 == OutputBuffer) {

                                    Status = STATUS_BUFFER_TOO_SMALL;

                                } else {

                                    Status = STATUS_BUFFER_OVERFLOW;
                                }

                                RemainingClusters = 0;
                                break;
                            }

                            RemainingBytes -= sizeof( FILE_ALLOCATED_RANGE_BUFFER );

                            //
                            //  Move to the next position in the buffer and
                            //  fill in the current position.
                            //

                            CurrentBuffer += 1;

                            CurrentBuffer->FileOffset.QuadPart = LlBytesFromClusters( Vcb, CurrentVcn );
                            CurrentBuffer->Length.QuadPart = LlBytesFromClusters( Vcb, CurrentClusterCount );
                        }

                        AccessingUserBuffer = FALSE;

                        CurrentVcn += CurrentClusterCount;
                        NextVcn = CurrentVcn;

                    //
                    //  Otherwise move forward to the next range.
                    //

                    } else {

                        CurrentVcn += CurrentClusterCount;
                    }

                    //
                    //  Break out of the loop if we have processed all of the user's
                    //  clusters.
                    //
                    //
                    //  Grab the FsRtl header lock to check if we are beyond
                    //  file size.  If so then trim the last entry in the
                    //  output buffer to file size if necessary and break out.
                    //

                    NtfsAcquireFsrtlHeader( Scb );

                    if (((LONGLONG) LlBytesFromClusters( Vcb, CurrentVcn )) >= Scb->Header.FileSize.QuadPart) {

                        NtfsReleaseFsrtlHeader( Scb );
                        RemainingClusters = 0;
                        break;
                    }

                    NtfsReleaseFsrtlHeader( Scb );

                    ThisClusterCount -= CurrentClusterCount;

                } while (ThisClusterCount > 0);

            } while (RemainingClusters != 0);

            //
            //  If we have at least one entry then check and see if we
            //  need to bias either the starting value or final
            //  length based on the user's input values.
            //

            if (CurrentBuffer != OutputBuffer - 1) {

                AccessingUserBuffer = TRUE;
                if (OutputBuffer->FileOffset.QuadPart < StartingOffset) {

                    OutputBuffer->Length.QuadPart -= (StartingOffset - OutputBuffer->FileOffset.QuadPart);
                    OutputBuffer->FileOffset.QuadPart = StartingOffset;
                }

                if ((CurrentBuffer->FileOffset.QuadPart + CurrentBuffer->Length.QuadPart) >
                    (StartingOffset + Length)) {

                    CurrentBuffer->Length.QuadPart = StartingOffset + Length - CurrentBuffer->FileOffset.QuadPart;
                }
                AccessingUserBuffer = FALSE;
            }

        } except( NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), AccessingUserBuffer, &Status ) ) {

            //
            //  Convert any unexpected error to INVALID_USER_BUFFER if we
            //  are writing in the user's buffer.
            //

            NtfsRaiseStatus( IrpContext,
                             STATUS_INVALID_USER_BUFFER,
                             NULL,
                             NULL );
        }

        //
        //  If we were successful then update the output information.
        //

        Irp->IoStatus.Information = PtrOffset( OutputBuffer, (CurrentBuffer + 1) );

    } finally {

        DebugUnwind( NtfsQueryAllocatedRanges );

        //
        //  Release resources.
        //

        NtfsReleasePagingIo( IrpContext, Scb->Fcb );

        if (AcquiredScb) {

            NtfsReleaseScb( IrpContext, Scb );
        }

        //
        //  If nothing raised then complete the irp.
        //

        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }
    }

    return Status;
}


//
//  Local support routine.
//

NTSTATUS
NtfsSetSparse (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called to set the state of a stream to sparse.  We only allow
    this on user data streams.  There is no input or output buffer needed for this call.

Arguments:

    Irp - Request being serviced

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    PIO_STACK_LOCATION IrpSp;
    BOOLEAN SetSparse = TRUE;

    PAGED_CODE();

    //
    //  Decode the file object, fail this request if not a user data stream.
    //  We check for dismount further below, so send FALSE to not raise here.
    //

    if (NtfsDecodeFileObject( IrpContext,
                              IoGetCurrentIrpStackLocation( Irp )->FileObject,
                              &Vcb,
                              &Fcb,
                              &Scb,
                              &Ccb,
                              FALSE ) != UserFileOpen) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  For now accept a zero length input buffer meaning set sparse
    //  remove this before shipping nt5
    //

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    if (IrpSp->Parameters.FileSystemControl.InputBufferLength != 0 &&
        IrpSp->Parameters.FileSystemControl.InputBufferLength < sizeof( FILE_SET_SPARSE_BUFFER )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Fsctrl is buffered so we don't need to probe etc. the input
    //

    if ((Irp->RequestorMode != KernelMode) && (IrpSp->Parameters.FileSystemControl.InputBufferLength != 0) ) {
        SetSparse = ((PFILE_SET_SPARSE_BUFFER)Irp->AssociatedIrp.SystemBuffer)->SetSparse;
    }

    //
    //  For this release we don't support unsparsifying files
    //

    if (SetSparse == FALSE) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_NOT_IMPLEMENTED );
        return STATUS_NOT_IMPLEMENTED;

    }

    //
    //  Only upgraded volumes can have sparse files.
    //

    if (!NtfsVolumeVersionCheck( Vcb, NTFS_SPARSE_FILE_VERSION )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_VOLUME_NOT_UPGRADED );
        return STATUS_VOLUME_NOT_UPGRADED;
    }

    //
    //  Readonly mount should be just that: read only.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }


    //
    //  Remember the source info flags in the Ccb.
    //

    IrpContext->SourceInfo = Ccb->UsnSourceInfo;

    //
    //  Acquire the paging Io resource.  User data streams should always have
    //  a paging io resource.
    //

    ASSERT( Scb->Header.PagingIoResource != NULL );
    NtfsAcquireExclusivePagingIo( IrpContext, Fcb );

    //
    //  Acquire the main resource as well.
    //

    NtfsAcquireExclusiveScb( IrpContext, Scb );

    //
    //  Check that the volume is still mounted.
    //

    if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_VOLUME_DISMOUNTED );
        return STATUS_VOLUME_DISMOUNTED;
    }

    //
    //  Make sure the caller has the appropriate access to this stream.
    //

    if (!(FlagOn( Ccb->AccessFlags, WRITE_DATA_ACCESS | WRITE_ATTRIBUTES_ACCESS )) &&
        !IrpSp->FileObject->WriteAccess) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Change the sparse state of the file.
    //

    NtfsSetSparseStream( IrpContext, NULL, Scb );

    //
    //  There is no data returned in an output buffer for this.
    //

    Irp->IoStatus.Information = 0;

    //
    //  Go ahead and complete the request.
    //

    NtfsCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local support routine.
//

NTSTATUS
NtfsZeroRange (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called to zero a range of a file.  We will also deallocate any convenient
    allocation on a sparse file.

Arguments:

    Irp - Request being serviced

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PFILE_ZERO_DATA_INFORMATION ZeroRange;

    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Make sure the input buffer is large enough for the ZeroRange request.
    //

    if (IoGetCurrentIrpStackLocation( Irp )->Parameters.FileSystemControl.InputBufferLength < sizeof( FILE_ZERO_DATA_INFORMATION )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Verify the ZeroRange request is properly formed.
    //

    ZeroRange = (PFILE_ZERO_DATA_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

    if ((ZeroRange->FileOffset.QuadPart < 0) ||
        (ZeroRange->BeyondFinalZero.QuadPart < 0) ||
        (ZeroRange->FileOffset.QuadPart > ZeroRange->BeyondFinalZero.QuadPart)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Decode the file object, fail this request if not a user data stream.
    //

    if (NtfsDecodeFileObject( IrpContext,
                              IoGetCurrentIrpStackLocation( Irp )->FileObject,
                              &Vcb,
                              &Fcb,
                              &Scb,
                              &Ccb,
                              TRUE ) != UserFileOpen) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    if (NtfsIsVolumeReadOnly( Vcb )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    //
    //  Capture the source information.
    //

    IrpContext->SourceInfo = Ccb->UsnSourceInfo;

    //
    //  Zero this range of the stream.
    //

    Status = NtfsZeroRangeInStream( IrpContext,
                                    IoGetCurrentIrpStackLocation( Irp )->FileObject,
                                    Scb,
                                    &ZeroRange->FileOffset.QuadPart,
                                    ZeroRange->BeyondFinalZero.QuadPart );

    if (Status != STATUS_PENDING) {

        //
        //  There is no data returned in an output buffer for this.
        //

        Irp->IoStatus.Information = 0;

        //
        //  Go ahead and complete the request.  Raise any error
        //  status to make sure to unwind any Usn reasons.
        //

        if (NT_SUCCESS( Status )) {

            NtfsCompleteRequest( IrpContext, Irp, Status );

        } else {

            NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
        }
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsEncryptionFsctl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called to pass the request through to the installed encryption
    driver if present.

Arguments:

    Irp - Request being serviced

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    TYPE_OF_OPEN TypeOfOpen;

    PVOID InputBuffer;
    ULONG InputBufferLength = 0;
    PVOID OutputBuffer;
    ULONG OutputBufferLength = 0;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    BOOLEAN ReleasePagingIo = FALSE;
    BOOLEAN ReleaseScb = FALSE;
    BOOLEAN ReleaseVcb = FALSE;

    PAGED_CODE();

    //
    //  This call should always be synchronous.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  Decode the file object, fail this request if not a user data stream or directory.
    //  We check for dismount further below, so send FALSE to not raise here.
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext,
                                       IrpSp->FileObject,
                                       &Vcb,
                                       &Fcb,
                                       &Scb,
                                       &Ccb,
                                       FALSE );

    //
    //  This is only legal for files and directories, and not for anything
    //  that's compressed.
    //

   if (((TypeOfOpen != UserFileOpen) &&
        (TypeOfOpen != UserDirectoryOpen)) ||

        (FlagOn( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED ))) {

       NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
       return STATUS_INVALID_PARAMETER;
    }

    //
    //  This is also only supported on upgraded volumes.
    //

    if (!NtfsVolumeVersionCheck( Vcb, NTFS_ENCRYPTION_VERSION )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_VOLUME_NOT_UPGRADED );
        return STATUS_VOLUME_NOT_UPGRADED;
    }

    OutputBuffer = NtfsMapUserBuffer( Irp );
    OutputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

    InputBuffer = IrpSp->Parameters.FileSystemControl.Type3InputBuffer;
    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;

    //
    //  Probe the user's buffers if necessary.
    //

    if (Irp->RequestorMode != KernelMode) {

        try {

            ProbeForRead( InputBuffer,
                          InputBufferLength,
                          sizeof(UCHAR) );

            ProbeForWrite( OutputBuffer, OutputBufferLength, sizeof(UCHAR) );

        } except( NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), TRUE, &Status ) ) {

            NtfsRaiseStatus( IrpContext,
                             STATUS_INVALID_USER_BUFFER,
                             NULL,
                             NULL );
        }
    }

    //
    //  Use a try-finally to free the resource.
    //

    try {

        //
        //  Acquire both resources if present on the file.
        //

        if (Fcb->PagingIoResource != NULL) {

            ExAcquireResourceExclusiveLite( Fcb->PagingIoResource, TRUE );
            ReleasePagingIo = TRUE;
        }

        NtfsAcquireExclusiveScb( IrpContext, Scb );
        ReleaseScb = TRUE;

        //
        //  Check that the volume is still mounted.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  Call the EFS routine if specified.
        //

        if (NtfsData.EncryptionCallBackTable.FileSystemControl_2 != NULL) {

            ULONG EncryptionFlag = 0;

            if (IsEncrypted( &Fcb->Info )) {

                SetFlag( EncryptionFlag, FILE_ENCRYPTED );

                if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED )) {

                    SetFlag( EncryptionFlag, STREAM_ENCRYPTED );
                }
            }

            Status = NtfsData.EncryptionCallBackTable.FileSystemControl_2(
                                InputBuffer,
                                InputBufferLength,
                                OutputBuffer,
                                &OutputBufferLength,
                                EncryptionFlag,
                                Ccb->AccessFlags,
                                (NtfsIsVolumeReadOnly( Vcb )) ? READ_ONLY_VOLUME : 0,
                                IrpSp->Parameters.FileSystemControl.FsControlCode,
                                Fcb,
                                IrpContext,
                                (PDEVICE_OBJECT) CONTAINING_RECORD( Vcb, VOLUME_DEVICE_OBJECT, Vcb ),
                                Scb,
                                &Scb->EncryptionContext,
                                &Scb->EncryptionContextLength);

            Irp->IoStatus.Information = OutputBufferLength;

        //
        //  There is no encryption driver present.
        //

        } else {

            Status = STATUS_INVALID_DEVICE_REQUEST;
            Irp->IoStatus.Information = 0;
        }

        NtfsCleanupTransaction( IrpContext, Status, TRUE );

    } finally {

        DebugUnwind( NtfsEncryptionPassThrough );

        //
        //  Acquire both resources if present on the file.
        //

        if (ReleasePagingIo) {

            ExReleaseResourceLite( Fcb->PagingIoResource );
        }

        if (ReleaseScb) {

            NtfsReleaseScb( IrpContext, Scb );
        }

        if (ReleaseVcb) {

            NtfsReleaseVcb( IrpContext, Vcb );
        }
    }

    //
    //  Go ahead and complete the request.
    //

    NtfsCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


//
//  Local support routine
//

VOID
NtfsEncryptStream (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB Scb OPTIONAL,
    IN PATTRIBUTE_ENUMERATION_CONTEXT AttrContext
    )

/*++

Routine Description:

    This routine is called to mark a user data stream as encrypted.  It sets
    the encryption bit in the filerecord (handling logging, etc.) and in the
    Scb if one is provided..

Arguments:

    Fcb - The Fcb containing the stream to mark as encrypted.

    Scb - The Scb (if one exists) to mark as ancrypted.

    AttrContext - The attribute context that indicates where the stream is
                  within the file record.

Return Value:

    None

--*/

{
    ATTRIBUTE_RECORD_HEADER NewAttribute;
    PATTRIBUTE_RECORD_HEADER Attribute;

    NtfsPinMappedAttribute( IrpContext, Fcb->Vcb, AttrContext );
    Attribute = NtfsFoundAttribute( AttrContext );

    //
    //  We only need enough of the attribute to modify the bit.
    //

    RtlCopyMemory( &NewAttribute, Attribute, SIZEOF_RESIDENT_ATTRIBUTE_HEADER );

    SetFlag( NewAttribute.Flags, ATTRIBUTE_FLAG_ENCRYPTED );

    //
    //  Now, log the changed attribute.
    //

    (VOID)NtfsWriteLog( IrpContext,
                        Fcb->Vcb->MftScb,
                        NtfsFoundBcb( AttrContext ),
                        UpdateResidentValue,
                        &NewAttribute,
                        SIZEOF_RESIDENT_ATTRIBUTE_HEADER,
                        UpdateResidentValue,
                        Attribute,
                        SIZEOF_RESIDENT_ATTRIBUTE_HEADER,
                        NtfsMftOffset( AttrContext ),
                        PtrOffset(NtfsContainingFileRecord( AttrContext ), Attribute),
                        0,
                        Fcb->Vcb->BytesPerFileRecordSegment );

    //
    //  Change the attribute by calling the same routine called at restart.
    //

    NtfsRestartChangeValue( IrpContext,
                            NtfsContainingFileRecord( AttrContext ),
                            PtrOffset( NtfsContainingFileRecord( AttrContext ), Attribute ),
                            0,
                            &NewAttribute,
                            SIZEOF_RESIDENT_ATTRIBUTE_HEADER,
                            FALSE );

    if (ARGUMENT_PRESENT( Scb )) {

        SetFlag( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED );
    }

    //
    //  Now update the Fcb if this is the first of the streams.
    //

    if (!IsEncrypted( &Fcb->Info )) {

        //
        //  Set the flag in the Fcb info field and let ourselves know to
        //  update the standard information.
        //

        ASSERTMSG( "conflict with flush",
                   NtfsIsSharedFcb( Fcb ) ||
                   (Fcb->PagingIoResource != NULL &&
                    NtfsIsSharedFcbPagingIo( Fcb )) );

        SetFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_ENCRYPTED );
        SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
        SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );

        //
        //  If this is a directory, remember to set the appropriate bit in its Fcb.
        //

        if (IsDirectory( &Fcb->Info )) {

            SetFlag( Fcb->FcbState, FCB_STATE_DIRECTORY_ENCRYPTED );
        }
    }
}


//
//  Local support routine
//

NTSTATUS
NtfsSetEncryption (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called to initiate a set encryption operation.  The input buffer specifies
    whether we are accessing a file or a directory.

Arguments:

    Irp - Request being serviced

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    PLCB Lcb;

    PSCB ParentScb = NULL;

    TYPE_OF_OPEN TypeOfOpen;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    BOOLEAN ReleasePagingIo = FALSE;
    BOOLEAN ReleaseVcb = FALSE;

    ULONG EncryptionFlag = 0;
    ULONG EncryptionOperation;
    ULONG InputBufferLength;
    ULONG OutputBufferLength;

    ULONG FilterMatch;

    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    BOOLEAN CleanupAttrContext = FALSE;
    BOOLEAN FoundAttribute;

    ATTRIBUTE_RECORD_HEADER NewAttribute;
    PATTRIBUTE_RECORD_HEADER Attribute;

    BOOLEAN UpdateCcbFlags = FALSE;
    BOOLEAN ClearFcbUpdateFlag = FALSE;
    BOOLEAN ClearFcbInfoFlags = FALSE;
    BOOLEAN RestoreEncryptionFlag = FALSE;
    BOOLEAN DirectoryFileEncrypted = FALSE;

    PENCRYPTION_BUFFER EncryptionBuffer;
    PDECRYPTION_STATUS_BUFFER DecryptionStatusBuffer;

    PAGED_CODE();

    //
    //  This call should always be synchronous.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  Decode the file object, fail this request if not a user data stream or directory.
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext,
                                       IrpSp->FileObject,
                                       &Vcb,
                                       &Fcb,
                                       &Scb,
                                       &Ccb,
                                       TRUE );

    //
    //  This is only legal for files and directories.
    //

    if ((TypeOfOpen != UserFileOpen) &&
        (TypeOfOpen != UserDirectoryOpen)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Readonly mount should be just that: read only.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    //
    //  Get the input and output buffer lengths and pointers.  Remember that the output
    //  buffer is optional.
    //

    EncryptionBuffer = (PENCRYPTION_BUFFER)IrpSp->Parameters.FileSystemControl.Type3InputBuffer;
    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;

    DecryptionStatusBuffer = (PDECRYPTION_STATUS_BUFFER)NtfsMapUserBuffer( Irp );
    OutputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

    //
    //  Check for a minimum length on the input and ouput buffers.  The output buffer
    //  only needs to be a certain length if one was specified.
    //

    if ((InputBufferLength < sizeof(ENCRYPTION_BUFFER)) ||

        ((DecryptionStatusBuffer != NULL) && (OutputBufferLength < sizeof(DECRYPTION_STATUS_BUFFER)))) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        DebugTrace( -1, Dbg, ("NtfsSetEncryption -> %08lx\n", STATUS_BUFFER_TOO_SMALL) );
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  Probe the user's buffers.
    //

    try {

        if (Irp->RequestorMode != KernelMode) {
            ProbeForRead( EncryptionBuffer, InputBufferLength, sizeof(UCHAR) );
            if (DecryptionStatusBuffer != NULL) ProbeForWrite( DecryptionStatusBuffer, OutputBufferLength, sizeof(UCHAR) );
        }

        EncryptionOperation = EncryptionBuffer->EncryptionOperation;
        Irp->IoStatus.Information = 0;

        if (DecryptionStatusBuffer != NULL) {

            DecryptionStatusBuffer->NoEncryptedStreams = FALSE;
        }

    } except( NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), TRUE, &Status ) ) {

        DebugTrace( -1, Dbg, ("NtfsSetEncryption -> %08lx\n", FsRtlIsNtstatusExpected(Status) ? Status : STATUS_INVALID_USER_BUFFER) );
        NtfsRaiseStatus( IrpContext,
                         STATUS_INVALID_USER_BUFFER,
                         NULL,
                         NULL );
    }

    //
    //  Verify that the user didn't specify any illegal flags.
    //

    if (EncryptionOperation > MAXIMUM_ENCRYPTION_VALUE) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Capture the source information.
    //

    IrpContext->SourceInfo = Ccb->UsnSourceInfo;

    //
    //  It's okay to mark the file encryption bit if this stream is compressed,
    //  but we do want to prevent setting the stream encrypted bit for a
    //  compressed stream.  In some future release when we have a chance to
    //  test compression & encryption together (perhaps with some third-party
    //  encryption engine) we can relax/remove this restriction.
    //

    if ((EncryptionOperation == STREAM_SET_ENCRYPTION) &&
        (FlagOn( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED ))) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  This is also only supported on upgraded volumes.
    //

    if (!NtfsVolumeVersionCheck( Vcb, NTFS_ENCRYPTION_VERSION )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_VOLUME_NOT_UPGRADED );
        return STATUS_VOLUME_NOT_UPGRADED;
    }

    //
    //  Use a try-finally to free the resource.
    //

    try {

        //
        //  Acquire the Vcb shared in case we need to update the parent directory entry.
        //

        ReleaseVcb = NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

        //
        //  Acquire both resources if present on the file.
        //

        if (Fcb->PagingIoResource != NULL) {

            ExAcquireResourceExclusiveLite( Fcb->PagingIoResource, TRUE );
            ReleasePagingIo = TRUE;
        }

        NtfsAcquireExclusiveScb( IrpContext, Scb );

        //
        //  Check that the volume is still mounted.
        //

        if ( !FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  We can't go on if there isn't an encryption driver loaded.  We did our best
        //  to get it loaded above.  If that didn't work, we need to leave now.
        //

        if (!FlagOn( NtfsData.Flags, NTFS_FLAGS_ENCRYPTION_DRIVER )) {

            Status = STATUS_INVALID_DEVICE_REQUEST;
            leave;
        }

        //
        //  Update the Scb from disk if necessary.
        //

        if (Scb->AttributeTypeCode == $INDEX_ALLOCATION) {

            if (Scb->ScbType.Index.BytesPerIndexBuffer == 0) {

                NtfsInitializeAttributeContext( &AttrContext );
                CleanupAttrContext = TRUE;

                if (!NtfsLookupAttributeByName( IrpContext,
                                                Scb->Fcb,
                                                &Scb->Fcb->FileReference,
                                                $INDEX_ROOT,
                                                &Scb->AttributeName,
                                                NULL,
                                                FALSE,
                                                &AttrContext )) {

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                }

                NtfsUpdateIndexScbFromAttribute( IrpContext,
                                                 Scb,
                                                 NtfsFoundAttribute( &AttrContext ),
                                                 FALSE );

                NtfsCleanupAttributeContext( IrpContext, &AttrContext );
            }

        } else if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

            NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );
        }

        //
        //  Remember the starting encryption state for this operation.
        //

        if (IsEncrypted( &Fcb->Info )) {

            SetFlag( EncryptionFlag, FILE_ENCRYPTED );

            if (FlagOn( Fcb->FcbState, FCB_STATE_DIRECTORY_ENCRYPTED )) {

                DirectoryFileEncrypted = TRUE;
            }

            if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED )) {

                SetFlag( EncryptionFlag, STREAM_ENCRYPTED );
            }
        }

        RestoreEncryptionFlag = TRUE;

        //
        //  If the caller wants to clear the encryption bit on the file then there should
        //  be no encrypted streams on the file.
        //

        if ((EncryptionOperation == FILE_CLEAR_ENCRYPTION) && IsEncrypted( &Fcb->Info )) {

            NtfsInitializeAttributeContext( &AttrContext );
            CleanupAttrContext = TRUE;

            FoundAttribute = NtfsLookupAttributeByCode( IrpContext,
                                                        Fcb,
                                                        &Fcb->FileReference,
                                                        $DATA,
                                                        &AttrContext );

            while (FoundAttribute) {

                //
                //  We only want to look at this attribute if it is resident or the
                //  first attribute header for a non-resident attribute.
                //

                Attribute = NtfsFoundAttribute( &AttrContext );

                if (NtfsIsAttributeResident( Attribute ) ||
                    (Attribute->Form.Nonresident.LowestVcn == 0)) {

                    if (FlagOn( Attribute->Flags, ATTRIBUTE_FLAG_ENCRYPTED )) {

                        break;
                    }
                }

                FoundAttribute = NtfsLookupNextAttributeByCode( IrpContext,
                                                                Fcb,
                                                                $DATA,
                                                                &AttrContext );
            }

            if (FoundAttribute) {

                Status = STATUS_INVALID_DEVICE_REQUEST;
                leave;
            }

            //
            //  If this is a directory then we need to check the index root as well.
            //

            if (IsDirectory( &Fcb->Info )) {

                NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                NtfsInitializeAttributeContext( &AttrContext );

                FoundAttribute = NtfsLookupAttributeByName( IrpContext,
                                                            Fcb,
                                                            &Fcb->FileReference,
                                                            $INDEX_ROOT,
                                                            &NtfsFileNameIndex,
                                                            NULL,
                                                            FALSE,
                                                            &AttrContext );

                //
                //  We should always find this attribute in this case.
                //

                if (!FoundAttribute) {

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                }

                Attribute = NtfsFoundAttribute( &AttrContext );

                if (FlagOn( Attribute->Flags, ATTRIBUTE_FLAG_ENCRYPTED )) {

                    Status = STATUS_INVALID_DEVICE_REQUEST;
                    leave;
                }
            }

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
            CleanupAttrContext = FALSE;
        }

        //
        //  It's a pretty rare case that we'll decide we don't need to update
        //  the duplicate info below, so let's go ahead and prepare now.  We
        //  can't wait until after the convert to nonresident, as that will
        //  acquire the quota resources before we've acquired the parent scb,
        //  resulting in a potential deadlock.
        //

        Lcb = Ccb->Lcb;

        NtfsPrepareForUpdateDuplicate( IrpContext, Fcb, &Lcb, &ParentScb, TRUE );

        //
        //  Now let's go ahead and modify the bit on the file/stream.
        //

        if (EncryptionOperation == FILE_SET_ENCRYPTION) {

            if (!IsEncrypted( &Fcb->Info )) {

                //
                //  Set the flag in the Fcb info field and let ourselves know to
                //  update the standard information.
                //

                ASSERTMSG( "conflict with flush",
                           NtfsIsSharedFcb( Fcb ) ||
                           (Fcb->PagingIoResource != NULL &&
                            NtfsIsSharedFcbPagingIo( Fcb )) );

                SetFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_ENCRYPTED );
                SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
                SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );
                UpdateCcbFlags = TRUE;
            }

        } else if (EncryptionOperation == FILE_CLEAR_ENCRYPTION) {

            if (IsEncrypted( &Fcb->Info )) {

                //
                //  Clear the flag in the Fcb info field and let ourselves know to
                //  update the standard information.  Also clear the directory
                //  encrypted bit, even though it may not even be set.
                //

                ASSERTMSG( "conflict with flush",
                           NtfsIsSharedFcb( Fcb ) ||
                           (Fcb->PagingIoResource != NULL &&
                            NtfsIsSharedFcbPagingIo( Fcb )) );

                ClearFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_ENCRYPTED );
                ClearFlag( Fcb->FcbState, FCB_STATE_DIRECTORY_ENCRYPTED );
                SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
                SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );
                UpdateCcbFlags = TRUE;
            }

        } else if (EncryptionOperation == STREAM_SET_ENCRYPTION) {

            if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED )) {

                NtfsInitializeAttributeContext( &AttrContext );
                CleanupAttrContext = TRUE;

                //
                //  If we're being called to set the encyrption bit on a new named stream
                //  and we created the unnamed stream silently without calling out to the
                //  encryption engine, this is the best time to set the encryption bit on
                //  the unnamed stream and convert it to nonresident, too.  Some encryption
                //  engines may not want this behavior, so we check the ImplementationFlags.
                //

                if (!FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA ) &&
                    FlagOn( Fcb->FcbState, FCB_STATE_ENCRYPTION_PENDING) &&
                    FlagOn( NtfsData.EncryptionCallBackTable.ImplementationFlags, ENCRYPTION_ALL_STREAMS ) &&
                    NtfsIsTypeCodeUserData( Scb->AttributeTypeCode )) {

                    if (NtfsLookupAttributeByCode( IrpContext,
                                                   Fcb,
                                                   &Fcb->FileReference,
                                                   $DATA,
                                                   &AttrContext )) {
                        //
                        //  If there is an the unnamed data attribute, it will be the
                        //  first data attribute we find.  There may be no unnamed data
                        //  attribute in the case where we've been asked to encrypt a
                        //  named data stream on a directory.
                        //

                        Attribute = NtfsFoundAttribute( &AttrContext );

                        if (Attribute->NameLength == 0) {

                            PSCB DefaultStreamScb = NULL;

                            ASSERT( NtfsIsAttributeResident( Attribute ) &&
                                    Attribute->Form.Resident.ValueLength == 0 );

                            NtfsConvertToNonresident( IrpContext,
                                                      Fcb,
                                                      Attribute,
                                                      TRUE,
                                                      &AttrContext );

                            while (TRUE) {

                                DefaultStreamScb = NtfsGetNextChildScb( Fcb, DefaultStreamScb );

                                //
                                //  If we've reached the end of the list of Scbs, or else
                                //  found the unnamed data stream's Scb, we're done.
                                //

                                if ((DefaultStreamScb == NULL) ||
                                    FlagOn( DefaultStreamScb->ScbState, SCB_STATE_UNNAMED_DATA )) {

                                    break;
                                }
                            }

                            NtfsEncryptStream( IrpContext, Fcb, DefaultStreamScb, &AttrContext );
                        }
                    }

                    //
                    //  Get the AttrContext ready for reuse.
                    //

                    NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                    NtfsInitializeAttributeContext( &AttrContext );
                }

                //
                //  If the stream is a data stream we can look up the attribute
                //  from the Scb.
                //

                if (TypeOfOpen == UserFileOpen) {

                    NtfsLookupAttributeForScb( IrpContext,
                                               Scb,
                                               NULL,
                                               &AttrContext );
                    //
                    //  Convert to non-resident if necessary.  It's entirely possible
                    //  that our caller will not have read or write access to this
                    //  file and won't have a key.  Therefore we don't want to create
                    //  a cache section for this stream during the convert, as we
                    //  may not have a key with which to do flushes later.
                    //

                    if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                        NtfsConvertToNonresident( IrpContext,
                                                  Fcb,
                                                  NtfsFoundAttribute( &AttrContext ),
                                                  TRUE,
                                                  &AttrContext );
                    }

                } else {

                    FoundAttribute = NtfsLookupAttributeByName( IrpContext,
                                                                Fcb,
                                                                &Fcb->FileReference,
                                                                $INDEX_ROOT,
                                                                &NtfsFileNameIndex,
                                                                NULL,
                                                                FALSE,
                                                                &AttrContext );

                    //
                    //  We should always find this attribute in this case.
                    //

                    if (!FoundAttribute) {

                        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                    }
                }

                NtfsEncryptStream( IrpContext, Fcb, Scb, &AttrContext );

                UpdateCcbFlags = TRUE;
            }

        } else { // EncryptionOperation == STREAM_CLEAR_ENCRYPTION

            if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED )) {

                NtfsInitializeAttributeContext( &AttrContext );
                CleanupAttrContext = TRUE;

                //
                //  If the stream is a data stream we can look up the attribute
                //  from the Scb.
                //

                if (TypeOfOpen == UserFileOpen) {

                    NtfsLookupAttributeForScb( IrpContext,
                                               Scb,
                                               NULL,
                                               &AttrContext );
                } else {

                    FoundAttribute = NtfsLookupAttributeByName( IrpContext,
                                                                Fcb,
                                                                &Fcb->FileReference,
                                                                $INDEX_ROOT,
                                                                &NtfsFileNameIndex,
                                                                NULL,
                                                                FALSE,
                                                                &AttrContext );

                    //
                    //  We should always find this attribute in this case.
                    //

                    if (!FoundAttribute) {

                        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                    }
                }

                NtfsPinMappedAttribute( IrpContext, Vcb, &AttrContext );
                Attribute = NtfsFoundAttribute( &AttrContext );

                //
                //  We only need enough of the attribute to modify the bit.
                //

                RtlCopyMemory( &NewAttribute, Attribute, SIZEOF_RESIDENT_ATTRIBUTE_HEADER );

                ClearFlag( NewAttribute.Flags, ATTRIBUTE_FLAG_ENCRYPTED );

                //
                //  Now, log the changed attribute.
                //

                (VOID)NtfsWriteLog( IrpContext,
                                    Vcb->MftScb,
                                    NtfsFoundBcb( &AttrContext ),
                                    UpdateResidentValue,
                                    &NewAttribute,
                                    SIZEOF_RESIDENT_ATTRIBUTE_HEADER,
                                    UpdateResidentValue,
                                    Attribute,
                                    SIZEOF_RESIDENT_ATTRIBUTE_HEADER,
                                    NtfsMftOffset( &AttrContext ),
                                    PtrOffset(NtfsContainingFileRecord( &AttrContext ), Attribute),
                                    0,
                                    Vcb->BytesPerFileRecordSegment );


                //
                //  Change the attribute by calling the same routine called at restart.
                //

                NtfsRestartChangeValue( IrpContext,
                                        NtfsContainingFileRecord( &AttrContext ),
                                        PtrOffset( NtfsContainingFileRecord( &AttrContext ), Attribute ),
                                        0,
                                        &NewAttribute,
                                        SIZEOF_RESIDENT_ATTRIBUTE_HEADER,
                                        FALSE );

                ClearFlag( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED );

                //
                //  Now check if this is the last stream on the file with the encryption
                //  bit set.
                //

                NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                NtfsInitializeAttributeContext( &AttrContext );

                FoundAttribute = NtfsLookupAttributeByCode( IrpContext,
                                                            Fcb,
                                                            &Fcb->FileReference,
                                                            $DATA,
                                                            &AttrContext );

                while (FoundAttribute) {

                    //
                    //  We only want to look at this attribute if it is resident or the
                    //  first attribute header for a non-resident attribute.
                    //

                    Attribute = NtfsFoundAttribute( &AttrContext );

                    if (NtfsIsAttributeResident( Attribute ) ||
                        (Attribute->Form.Nonresident.LowestVcn == 0)) {

                        if (FlagOn( Attribute->Flags, ATTRIBUTE_FLAG_ENCRYPTED )) {

                            break;
                        }
                    }

                    FoundAttribute = NtfsLookupNextAttributeByCode( IrpContext,
                                                                    Fcb,
                                                                    $DATA,
                                                                    &AttrContext );
                }

                //
                //  If this is a directory then we need to check the index root as well.
                //

                if (!FoundAttribute && IsDirectory( &Fcb->Info )) {

                    NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                    NtfsInitializeAttributeContext( &AttrContext );

                    FoundAttribute = NtfsLookupAttributeByName( IrpContext,
                                                                Fcb,
                                                                &Fcb->FileReference,
                                                                $INDEX_ROOT,
                                                                &NtfsFileNameIndex,
                                                                NULL,
                                                                FALSE,
                                                                &AttrContext );

                    //
                    //  We should always find this attribute in this case.
                    //

                    if (!FoundAttribute) {

                        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                    }

                    Attribute = NtfsFoundAttribute( &AttrContext );

                    if (!FlagOn( Attribute->Flags, ATTRIBUTE_FLAG_ENCRYPTED )) {

                        FoundAttribute = FALSE;
                    }
                }

                //
                //  If our caller is interested, let it know if we have decrypted the
                //  last encrypted stream.  Since this is the only place we touch this
                //  buffer, we'll just wrap a little try/except around it here.
                //

                if (DecryptionStatusBuffer != NULL) {

                    try {

                        DecryptionStatusBuffer->NoEncryptedStreams = TRUE;
                        Irp->IoStatus.Information = sizeof(DECRYPTION_STATUS_BUFFER);

                    } except( NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), TRUE, &Status ) ) {

                        DebugTrace( -1, Dbg, ("NtfsSetEncryption -> %08lx\n", FsRtlIsNtstatusExpected(Status) ? Status : STATUS_INVALID_USER_BUFFER) );
                        NtfsRaiseStatus( IrpContext,
                                         STATUS_INVALID_USER_BUFFER,
                                         NULL,
                                         NULL );
                    }
                }

                UpdateCcbFlags = TRUE;
            }
        }

        //
        //  Now let's update the on-disk structures.
        //

        if (FlagOn( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO )) {

            NtfsUpdateStandardInformation( IrpContext, Fcb  );
            ClearFcbUpdateFlag = TRUE;

            NtfsUpdateDuplicateInfo( IrpContext, Fcb, Lcb, ParentScb );

            //
            //  Now perform the dir notify call if this is not an
            //  open by FileId.
            //

            if ((Vcb->NotifyCount != 0) &&
                (ParentScb != NULL) &&
                !FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID )) {

                FilterMatch = NtfsBuildDirNotifyFilter( IrpContext,
                                                        Fcb->InfoFlags | Lcb->InfoFlags );

                if (FilterMatch != 0) {

                    NtfsReportDirNotify( IrpContext,
                                         Fcb->Vcb,
                                         &Ccb->FullFileName,
                                         Ccb->LastFileNameOffset,
                                         NULL,
                                         ((FlagOn( Ccb->Flags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                                           (Ccb->Lcb != NULL) &&
                                           (Ccb->Lcb->Scb->ScbType.Index.NormalizedName.Length != 0)) ?
                                          &Ccb->Lcb->Scb->ScbType.Index.NormalizedName :
                                          NULL),
                                         FilterMatch,
                                         FILE_ACTION_MODIFIED,
                                         ParentScb->Fcb );
                }
            }

            NtfsUpdateLcbDuplicateInfo( Fcb, Lcb );
            ClearFcbInfoFlags = TRUE;
        }

        //
        //  Call the EFS routine if specified.
        //

        if (NtfsData.EncryptionCallBackTable.FileSystemControl_1 != NULL) {

            Status = NtfsData.EncryptionCallBackTable.FileSystemControl_1(
                                EncryptionBuffer,
                                InputBufferLength,
                                NULL,
                                NULL,
                                EncryptionFlag,
                                Ccb->AccessFlags,
                                (NtfsIsVolumeReadOnly( Vcb )) ? READ_ONLY_VOLUME : 0,
                                IrpSp->Parameters.FileSystemControl.FsControlCode,
                                Fcb,
                                IrpContext,
                                (PDEVICE_OBJECT) CONTAINING_RECORD( Vcb, VOLUME_DEVICE_OBJECT, Vcb ),
                                Scb,
                                &Scb->EncryptionContext,
                                &Scb->EncryptionContextLength);
        }

        //
        //  Post the change to the Usn Journal (on errors change is backed out)
        //

        NtfsPostUsnChange( IrpContext, Scb, USN_REASON_ENCRYPTION_CHANGE );

        NtfsCleanupTransaction( IrpContext, Status, TRUE );

        ASSERT( NT_SUCCESS( Status ));

        //
        //  Clear the flags in the Fcb if the update is complete.
        //

        if (ClearFcbUpdateFlag) {

            ClearFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
        }

        if (ClearFcbInfoFlags) {

            Fcb->InfoFlags = 0;
        }

        if (UpdateCcbFlags) {

            SetFlag( Ccb->Flags, CCB_FLAG_UPDATE_LAST_CHANGE | CCB_FLAG_SET_ARCHIVE );
        }

        RestoreEncryptionFlag = FALSE;

    } finally {

        DebugUnwind( NtfsSetEncryption );

        //
        //  In the error path we need to restore the correct encryption bit in
        //  the Fcb and Scb.
        //

        if (RestoreEncryptionFlag) {

            DebugTrace( 0, Dbg, ("Error in NtfsSetEncryption, restoring encryption flags\n") );

            if (FlagOn( EncryptionFlag, FILE_ENCRYPTED )) {

                SetFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_ENCRYPTED );

                if (DirectoryFileEncrypted) {

                    SetFlag( Fcb->FcbState, FCB_STATE_DIRECTORY_ENCRYPTED );
                }

            } else {

                ClearFlag( Fcb->FcbState, FCB_STATE_DIRECTORY_ENCRYPTED );
                ClearFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_ENCRYPTED );
            }

            if (FlagOn( EncryptionFlag, STREAM_ENCRYPTED )) {

                SetFlag( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED );

            } else {

                ClearFlag( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED );
            }
        }

        //
        //  Acquire both resources if present on the file.
        //

        if (ReleasePagingIo) {

            ExReleaseResourceLite( Fcb->PagingIoResource );
        }

        if (ReleaseVcb) {

            NtfsReleaseVcb( IrpContext, Vcb );
        }

        if (CleanupAttrContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }
    }

    //
    //  Go ahead and complete the request.
    //

    NtfsCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsReadRawEncrypted (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs a 'raw' read of encrypted data.  By 'raw', we
    mean without attempting to unencrypt.  This is useful for backup
    operations, and also for data recovery in the event the key stream
    is somehow lost.  Since this fsctrl works with any access, we have
    to fail the request for unencrypted files.  This routine is
    responsible for either completing or enqueuing the input Irp.

    Notes: DataUnit is the size of each peice written out in the buffer
           ChunkUnit is the size of a compression chunk (not used yet)

           For Sparse files DataUnit == CompressionUnit

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/
{

    LONGLONG StartingVbo;
    LONGLONG RequestedOffset;
    LONGLONG RoundedFileSize;
    ULONG TotalByteCount;
    ULONG ByteCount;
    ULONG BytesRead;

    PIRP ReadIrp = NULL;
    PDEVICE_OBJECT DeviceObject;
    PFILE_OBJECT FileObject;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION ReadIrpSp;
    TYPE_OF_OPEN TypeOfOpen;

    ULONG InputBufferLength;
    ULONG OutputBufferLength;
    ULONG ReadLength;
    PREQUEST_RAW_ENCRYPTED_DATA RequestRawEncryptedData;
    PENCRYPTED_DATA_INFO EncryptedDataInfo;

    USHORT BlockIndex;
    USHORT BlockCount = 0;

    PUCHAR RawDataDestination;

    NTFS_IO_CONTEXT LocalContext;

    BOOLEAN PagingAcquired = FALSE;
    BOOLEAN LockedReadIrpPages = FALSE;
    BOOLEAN SparseFile = FALSE;
    BOOLEAN RangeAllocated = TRUE;
    BOOLEAN AccessingUserBuffer = FALSE;
    ULONG OutputBufferOffset;
    ULONG BytesWithinValidDataLength = 0;
    ULONG BytesWithinFileSize = 0;
    ULONG i;
    LONG BytesPerSectorMask;

    NTSTATUS Status = STATUS_SUCCESS;
    UCHAR TotalShift;
    UCHAR DataUnitShift;

    PAGED_CODE();

    //
    //  Don't post this request, we can't lock both input and output buffers.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    DebugTrace( +1, Dbg, ("NtfsReadRawEncrypted:\n") );

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    FileObject = IrpSp->FileObject;

    TypeOfOpen = NtfsDecodeFileObject( IrpContext,
                                       FileObject,
                                       &Vcb,
                                       &Fcb,
                                       &Scb,
                                       &Ccb,
                                       TRUE );

    //
    //  This operation only applies to files, not indexes,
    //  or volumes.
    //

    if (TypeOfOpen != UserFileOpen) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        DebugTrace( -1, Dbg, ("NtfsReadRawEncrypted -> %08lx\n", STATUS_INVALID_PARAMETER) );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  We can't allow reads of unencrypted data, as that would let any
    //  user read any file's contents..
    //

    if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED ) ||

        //
        //  Even for an encrypted file, we should only allow this if the
        //  user is a backup operator or has read access.
        //

        !FlagOn( Ccb->AccessFlags, BACKUP_ACCESS | READ_DATA_ACCESS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        DebugTrace( -1, Dbg, ("NtfsReadRawEncrypted -> %08lx\n", STATUS_ACCESS_DENIED) );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Get the input and output buffer lengths and pointers.
    //  Initialize some variables.
    //

    RequestRawEncryptedData = (PREQUEST_RAW_ENCRYPTED_DATA)IrpSp->Parameters.FileSystemControl.Type3InputBuffer;
    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;

    EncryptedDataInfo = (PENCRYPTED_DATA_INFO)NtfsMapUserBuffer( Irp );
    OutputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

    //
    //  Check for a minimum length on the input and ouput buffers.
    //

    if ((InputBufferLength < sizeof(REQUEST_RAW_ENCRYPTED_DATA)) ||
        (OutputBufferLength < sizeof(ENCRYPTED_DATA_INFO))) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        DebugTrace( -1, Dbg, ("NtfsReadRawEncrypted -> %08lx\n", STATUS_BUFFER_TOO_SMALL) );
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  Probe the user's buffers.
    //

    try {

        if (Irp->RequestorMode != KernelMode) {
            ProbeForRead( RequestRawEncryptedData, InputBufferLength, sizeof(UCHAR) );
            ProbeForWrite( EncryptedDataInfo, OutputBufferLength, sizeof(UCHAR) );
        }

        RequestedOffset = RequestRawEncryptedData->FileOffset;

        ReadLength = RequestRawEncryptedData->Length;

        //
        //  Zero the buffer.
        //

        RtlZeroMemory( EncryptedDataInfo, OutputBufferLength );

    } except( NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), TRUE, &Status ) ) {

        DebugTrace( -1, Dbg, ("NtfsReadRawEncrypted -> %08lx\n", FsRtlIsNtstatusExpected(Status) ? Status : STATUS_INVALID_USER_BUFFER) );
        NtfsRaiseStatus( IrpContext,
                         STATUS_INVALID_USER_BUFFER,
                         NULL,
                         NULL );
    }

    try {

        //
        //  Make sure we aren't starting past the end of the file, in which case
        //  we would have nothing to return.
        //

        if ((RequestedOffset > Scb->Header.FileSize.QuadPart) || (RequestedOffset >= Scb->Header.AllocationSize.QuadPart)) {

            try_return( Status = STATUS_END_OF_FILE );
        }

        //
        //  Sanity check the read length.
        //

        if (0 == ReadLength) {

            try_return( Status = STATUS_INVALID_PARAMETER );
        }

        RoundedFileSize = (Scb->Header.FileSize.QuadPart + Vcb->BytesPerSector) & ~((LONGLONG)Vcb->BytesPerSector);
        if (RequestedOffset + ReadLength > RoundedFileSize) {
            ReadLength = (ULONG)(RoundedFileSize - RequestedOffset);
        }

        try {

            if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

                //
                //  File is not compressed or sparse.
                //

                AccessingUserBuffer = TRUE;
                EncryptedDataInfo->CompressionFormat = COMPRESSION_FORMAT_NONE;
                AccessingUserBuffer = FALSE;

                //
                //  For a simple uncompressed, nonsparse file, we can start on any
                //  cluster boundary.  We like to start on a cluster boundary
                //  since the cluster size is always >= the size of a cipher block,
                //  and a recovery agent will always need to work with whole cipher
                //  blocks.  Notice that the StartingVbo is rounded _down_ to the
                //  previous cluster boundary, while TotalByteCount is rounded _up_ to
                //  the next larger cluster multiple.
                //

                StartingVbo = RequestedOffset & Vcb->InverseClusterMask;

                TotalByteCount = ClusterAlign( Vcb, ReadLength );

                //
                //  We will do the transfer in one block for this simple case.
                //

                BlockCount = 1;
                ByteCount = TotalByteCount;

                //
                //  For an uncompressed file, we'll pick a data unit size so
                //  that it's some convenient power of two.
                //

                for (DataUnitShift = 0, i = TotalByteCount - 1;
                     i > 0;
                     i = i / 2) {

                    DataUnitShift += 1;
                }

                AccessingUserBuffer = TRUE;

                EncryptedDataInfo->DataUnitShift = DataUnitShift;
                EncryptedDataInfo->ChunkShift = DataUnitShift;
                AccessingUserBuffer = FALSE;

            } else if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                //
                //  File is sparse and not compressed.
                //

                SparseFile = TRUE;
                ASSERT( Vcb->ClusterShift + Scb->CompressionUnitShift <= MAXUCHAR );
                TotalShift = (UCHAR)(Scb->CompressionUnitShift + Vcb->ClusterShift);

                AccessingUserBuffer = TRUE;
                EncryptedDataInfo->CompressionFormat = COMPRESSION_FORMAT_NONE;
                EncryptedDataInfo->ChunkShift = TotalShift;
                AccessingUserBuffer = FALSE;

                //
                //  For a sparse file, we can start on any compression unit
                //  boundary.  Notice that the StartingVbo is rounded _down_ to the
                //  previous compression unit boundary, while TotalByteCount is rounded
                //  _up_ to the next larger compression unit multiple.
                //

                StartingVbo = RequestedOffset & ~(ULONG_PTR)(Scb->CompressionUnit - 1);
                TotalByteCount = (ReadLength + (Scb->CompressionUnit - 1)) & ~(Scb->CompressionUnit - 1);

                //
                //  BlockCount is the number of blocks needed to describe this range
                //  of the file.  It is simply the number of bytes we're reading on
                //  this request divided by the size of a compression unit.
                //  (Literally, we're shifting, but semantically, we're dividing).
                //

                BlockCount = (USHORT) (TotalByteCount >> TotalShift);

                //
                //  Since BlockCount is derived from a user-supplied value, we need
                //  to make sure we aren't about to divide by zero.
                //

                if (BlockCount == 0) {

                    Status = STATUS_INVALID_PARAMETER;
                    leave;
                }

                //
                //  ByteCount is the number of bytes to read per Irp, while TotalByteCount
                //  is how many bytes to try to read during this call into NtfsReadRawEncrypted.
                //

                ByteCount = TotalByteCount / BlockCount;

                AccessingUserBuffer = TRUE;
                EncryptedDataInfo->DataUnitShift = TotalShift;
                AccessingUserBuffer = FALSE;

            } else {

                //
                //  We do not support compressed encrypted files yet.
                //

                Status = STATUS_NOT_IMPLEMENTED;
                leave;
            }

            //
            //  The actual file contents will start after the fixed length part
            //  of the encrypted data info struct plus one ulong per block that
            //  specifies the length of that block.  We also need to round
            //  OutputBufferOffset up so that the buffer we pass to the underlying
            //  driver(s) is sector aligned, since that is required for all
            //  unbuffered I/O.
            //

            BytesPerSectorMask = Vcb->BytesPerSector - 1;
            OutputBufferOffset = sizeof(ENCRYPTED_DATA_INFO) + (BlockCount * sizeof(ULONG));
            OutputBufferOffset = PtrOffset(EncryptedDataInfo,
                                           (((UINT_PTR) EncryptedDataInfo + OutputBufferOffset + BytesPerSectorMask) & ~BytesPerSectorMask));

            AccessingUserBuffer = TRUE;
            EncryptedDataInfo->OutputBufferOffset = OutputBufferOffset;
            EncryptedDataInfo->NumberOfDataBlocks = BlockCount;
            AccessingUserBuffer = FALSE;

            //
            //  Now that we know how much data we're going to try to read, and the
            //  offset into the user's buffer where we will start putting it, we
            //  can test one last time that the buffer is big enough.
            //

            if ((OutputBufferOffset + TotalByteCount) > OutputBufferLength) {

                Status = STATUS_BUFFER_TOO_SMALL;
                leave;
            }

            //
            //  Acquire paging io before we do the flush.
            //

            ExAcquireResourceSharedLite( Scb->Header.PagingIoResource, TRUE );
            PagingAcquired = TRUE;

            //
            //  While we have something acquired, let's take this opportunity to make sure
            //  that the volume hasn't been dismounted.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

                Status = STATUS_VOLUME_DISMOUNTED;
                leave;
            }

#ifdef  COMPRESS_ON_WIRE
            if (Scb->Header.FileObjectC != NULL) {

                PCOMPRESSION_SYNC CompressionSync = NULL;

                //
                //  Use a try-finally to clean up the compression sync.
                //

                try {

                    NtfsSynchronizeUncompressedIo( Scb,
                                                   NULL,
                                                   0,
                                                   TRUE,
                                                   &CompressionSync );

                } finally {

                    NtfsReleaseCompressionSync( CompressionSync );
                }
            }
#endif

            //
            //  Get any cached changes flushed to disk.
            //

            CcFlushCache( FileObject->SectionObjectPointer,
                          (PLARGE_INTEGER)&StartingVbo,
                          TotalByteCount,
                          &Irp->IoStatus );

            //
            //  Make sure the data got out to disk.  The above call is asynchronous,
            //  but Cc will hold the paging shared while it does the flush.  When
            //  we are able to acquire paging exclusively, we know the flush
            //  has completed.
            //

            ExReleaseResourceLite( Scb->Header.PagingIoResource );
            ExAcquireResourceExclusiveLite( Scb->Header.PagingIoResource, TRUE );
            ExReleaseResourceLite( Scb->Header.PagingIoResource );
            PagingAcquired = FALSE;

            //
            //  Check for errors in the flush.
            //

            NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                &Irp->IoStatus.Status,
                                                TRUE,
                                                STATUS_UNEXPECTED_IO_ERROR );

            //
            //  Now get paging & main exclusively again to keep eof from changing
            //  beneath us, and so we can safely query the mapping info below.
            //

            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING );
            NtfsAcquireFcbWithPaging( IrpContext, Scb->Fcb, 0 );

            //
            //  Store where we really started in the file.
            //

            AccessingUserBuffer = TRUE;
            EncryptedDataInfo->StartingFileOffset = StartingVbo;
            EncryptedDataInfo->ClusterShift = (UCHAR) Vcb->ClusterShift;
            EncryptedDataInfo->EncryptionFormat = ENCRYPTION_FORMAT_DEFAULT;
            AccessingUserBuffer = FALSE;

            //
            //  Begin by getting a pointer to the device object that the file resides
            //  on.
            //

            DeviceObject = IoGetRelatedDeviceObject( FileObject );

            //
            //  This IrpContext probably isn't ready to do noncached I/O yet,
            //  so let's set up its NtfsIoContext.  We know we will be doing
            //  this operation synchronously, so it is safe to use the
            //  local context.
            //

            if (IrpContext->Union.NtfsIoContext == NULL) {

                IrpContext->Union.NtfsIoContext = &LocalContext;
                RtlZeroMemory( IrpContext->Union.NtfsIoContext, sizeof( NTFS_IO_CONTEXT ));

                //
                //  Store the fact that we did _not_ allocate this context structure
                //  in the structure itself.
                //

                IrpContext->Union.NtfsIoContext->AllocatedContext = FALSE;
                ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT );

                //
                //  And make sure the world knows we want this done synchronously.
                //

                ASSERT( FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ) );
                ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

                //
                //  Create an event so we can do synchronous I/O.
                //

                KeInitializeEvent( &IrpContext->Union.NtfsIoContext->Wait.SyncEvent,
                                   NotificationEvent,
                                   FALSE );
            }

            //
            //  Now we just loop through for each block and do the actual read(s).
            //

            DebugTrace( 0, Dbg, ("BlockCount     %08lx\n", BlockCount) );
            DebugTrace( 0, Dbg, ("TotalByteCount %08lx\n", TotalByteCount) );
            DebugTrace( 0, Dbg, ("ByteCount      %08lx\n", ByteCount) );

            for (BlockIndex = 0; BlockIndex < BlockCount; BlockIndex += 1) {

                //
                //  Compute the address to which we will start copying raw data.
                //

                RawDataDestination = Add2Ptr( EncryptedDataInfo, OutputBufferOffset );
                DebugTrace( 0, Dbg, ("RawDataDestination %p\n", (ULONG_PTR)RawDataDestination) );

                //
                //  If this is a sparse file, we need to determine whether this compression
                //  unit is allocated.
                //

                if (SparseFile) {

                    VCN StartVcn = LlClustersFromBytes( Vcb, StartingVbo );
                    VCN FinalCluster = LlClustersFromBytes( Vcb, (StartingVbo + ByteCount) ) - 1;
                    LONGLONG ClusterCount;

                    DebugTrace( 0, Dbg, ("SparseFile block  %08lx\n",    BlockIndex) );
                    DebugTrace( 0, Dbg, ("     StartingVbo  %016I64x\n", StartingVbo) );
                    DebugTrace( 0, Dbg, ("     StartVcn     %016I64x\n", StartVcn) );
                    DebugTrace( 0, Dbg, ("     FinalCluster %016I64x\n", FinalCluster) );

                    //
                    //  We need to call NtfsPreloadAllocation to make sure all the
                    //  ranges in this NtfsMcb are loaded.
                    //

                    NtfsPreloadAllocation( IrpContext,
                                           Scb,
                                           StartVcn,
                                           FinalCluster );

                    RangeAllocated = NtfsIsRangeAllocated( Scb,
                                                           StartVcn,
                                                           FinalCluster,
                                                           FALSE,
                                                           &ClusterCount );

                    if (!RangeAllocated) { DebugTrace( 0, Dbg, ("Deallocated range at Vcn %016I64x\n", StartVcn) ); }

                } else {

                    //
                    //  If this isn't a sparse file, we can skip the potentially expensive
                    //  mapping lookup.
                    //

                    ASSERT( BlockCount == 1 );
                    ASSERT( RangeAllocated );
                }

                if (RangeAllocated) {

                    //
                    //  Allocate an I/O Request Packet (IRP) for this raw read operation.
                    //

                    AccessingUserBuffer = TRUE;
                    ReadIrp = IoBuildAsynchronousFsdRequest( IRP_MJ_READ,
                                                             Vcb->Vpb->DeviceObject,
                                                             RawDataDestination,
                                                             ByteCount,
                                                             (PLARGE_INTEGER)&StartingVbo,
                                                             NULL );
                    AccessingUserBuffer = FALSE;

                    if (ReadIrp == NULL) {

                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        leave;
                    }

                    //
                    //  We now have an Irp, we want to make it look as though it is part of
                    //  the current call.  We need to adjust the Irp stack to update this.
                    //

                    ReadIrp->CurrentLocation--;

                    ReadIrpSp = IoGetNextIrpStackLocation( ReadIrp );

                    ReadIrp->Tail.Overlay.CurrentStackLocation = ReadIrpSp;

                    ReadIrpSp->DeviceObject = DeviceObject;

                    //
                    //  Put our buffer in the Irp and lock it as well.
                    //

                    ReadIrp->UserBuffer = RawDataDestination;

                    AccessingUserBuffer = TRUE;
                    NtfsLockUserBuffer( IrpContext,
                                        ReadIrp,
                                        IoWriteAccess,
                                        ByteCount );

                    LockedReadIrpPages = TRUE;

                    //
                    //  Put the read code into the IrpContext.
                    //

                    IrpContext->MajorFunction = IRP_MJ_READ;

                    //
                    //  Actually read the raw data from the disk.
                    //
                    //  N.B. -- If the file is compressed, also pass the COMPRESSED_STREAM flag.
                    //

                    NtfsNonCachedIo( IrpContext,
                                     ReadIrp,
                                     Scb,
                                     StartingVbo,
                                     ByteCount,
                                     ENCRYPTED_STREAM );

                    //
                    //  Fill in how many bytes we actually read.
                    //

                    BytesRead = (ULONG) ReadIrp->IoStatus.Information;

                    ASSERT( OutputBufferLength >
                            ((BlockIndex * sizeof(ULONG)) + FIELD_OFFSET(ENCRYPTED_DATA_INFO, DataBlockSize)));

                    EncryptedDataInfo->DataBlockSize[BlockIndex] = BytesRead;
                    AccessingUserBuffer = FALSE;
                    OutputBufferOffset += BytesRead;

                } else {

                    //
                    //  We didn't really read anything, so we want to set the
                    //  size of this block to 0, but we want to pretend we
                    //  read a whole compression unit so that BytesWithinXXX
                    //  get updated correctly.
                    //

                    ASSERT( ReadIrp == NULL );

                    AccessingUserBuffer = TRUE;
                    EncryptedDataInfo->DataBlockSize[BlockIndex] = 0;
                    AccessingUserBuffer = FALSE;
                    BytesRead = Scb->CompressionUnit;
                }

                //
                //  Fill in the fields that let our caller know whether any of
                //  the file size or valid data length boundaries occured in
                //  the range of this transfer.
                //

                if ((StartingVbo + BytesRead) > Scb->Header.FileSize.QuadPart) {

                    //
                    //  Only increment if we start before filesize
                    //

                    if (StartingVbo < Scb->Header.FileSize.QuadPart) {
                        BytesWithinFileSize += (ULONG)(Scb->Header.FileSize.QuadPart -
                                                       StartingVbo);
                    }

                    //
                    //  If we're at the end of the file, and it isn't compressed, we can save
                    //  the user a ton of space on the tape if we truncate to the first 512 byte
                    //  boundary beyond the end of the data.
                    //  512 is the maximum cipher block size an encryption engine can rely on the
                    //  file system to allow..
                    //

                    if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

                        ASSERT( OutputBufferLength >
                                ((BlockIndex * sizeof(ULONG)) + FIELD_OFFSET(ENCRYPTED_DATA_INFO, DataBlockSize)));

                        AccessingUserBuffer = TRUE;
                        EncryptedDataInfo->DataBlockSize[BlockIndex] = ((BytesWithinFileSize + (ULONG)0x200) & (ULONG)(~0x1ff));
                        AccessingUserBuffer = FALSE;
                    }

                } else {

                    BytesWithinFileSize += BytesRead;
                }

                if ((StartingVbo + BytesRead) > Scb->Header.ValidDataLength.QuadPart) {

                    //
                    //  Make sure BytesWithinValidDataLength can't go negative.
                    //

                    if (Scb->Header.ValidDataLength.QuadPart > StartingVbo) {

                        BytesWithinValidDataLength += (ULONG)(Scb->Header.ValidDataLength.QuadPart -
                                                              StartingVbo);

                    }

                } else {

                    BytesWithinValidDataLength += BytesRead;
                }

                StartingVbo += ByteCount;

                //
                //  We need to clean up the irp before we go around again.
                //

                if (ReadIrp != NULL) {

                    //
                    //  If there is an Mdl we free that first.
                    //

                    if (ReadIrp->MdlAddress != NULL) {

                        if (LockedReadIrpPages) {

                            MmUnlockPages( ReadIrp->MdlAddress );
                            LockedReadIrpPages = FALSE;
                        }

                        IoFreeMdl( ReadIrp->MdlAddress );
                        ReadIrp->MdlAddress = NULL;
                    }

                    IoFreeIrp( ReadIrp );
                    ReadIrp = NULL;
                }
            }  //  endfor

            AccessingUserBuffer = TRUE;
            EncryptedDataInfo->BytesWithinFileSize = BytesWithinFileSize;
            EncryptedDataInfo->BytesWithinValidDataLength = BytesWithinValidDataLength;
            AccessingUserBuffer = FALSE;

        } except( NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), AccessingUserBuffer, &Status ) ) {

            DebugTrace( -1, Dbg, ("NtfsReadRawEncrypted raising %08lx\n", Status) );
            NtfsRaiseStatus( IrpContext,
                             STATUS_INVALID_USER_BUFFER,
                             NULL,
                             NULL );
        }

    try_exit: NOTHING;

    } finally {

        if (PagingAcquired) {
            ExReleaseResourceLite( Scb->Header.PagingIoResource );
        }

        if (ReadIrp != NULL) {

            //
            //  If there is an Mdl we free that first.
            //

            if (ReadIrp->MdlAddress != NULL) {

                if (LockedReadIrpPages) {

                    MmUnlockPages( ReadIrp->MdlAddress );
                }

                IoFreeMdl( ReadIrp->MdlAddress );
            }

            IoFreeIrp( ReadIrp );
        }
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );
    DebugTrace( -1, Dbg, ("NtfsReadRawEncrypted -> %08lx\n", Status) );

    return Status;
}

LONG
NtfsWriteRawExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    )

/*++

Routine Description:

    Exception filter for errors during cleanup.  We want to raise if this is
    a retryable condition or fatal error, plow on as best we can if not.

Arguments:

    IrpContext  - IrpContext

    ExceptionPointer - Pointer to the exception context.

    Status - Address to store the error status.

Return Value:

    Exception status - EXCEPTION_CONTINUE_SEARCH if we want to raise to another handler,
        EXCEPTION_EXECUTE_HANDLER if we plan to proceed on.

--*/

{
    UNREFERENCED_PARAMETER( IrpContext );
    UNREFERENCED_PARAMETER( ExceptionPointer );

    ASSERT( FsRtlIsNtstatusExpected( ExceptionPointer->ExceptionRecord->ExceptionCode ) );
    return EXCEPTION_EXECUTE_HANDLER;
}



NTSTATUS
NtfsWriteRawEncrypted (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs a 'raw' write of encrypted data.  By 'raw', we
    mean without attempting to encrypt.  This is useful for restore
    operations, where the restore operator does not have a key with which
    to read the plaintext.  This routine is responsible for either
    completing or enqueuing the input Irp.

    NOTE: there is a strong assumption that the encrypted data info blocks
    are ordered monotonically from the beginning to end of the file

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/
{

    LONGLONG StartingVbo;
    LONGLONG EndingVbo;
    LONGLONG TotalBytesWritten = 0;
    LONGLONG FirstZero;
    LONGLONG OriginalStartingVbo;
    ULONG ByteCount;
    ULONG BytesWithinValidDataLength;
    ULONG BytesWithinFileSize;
    USHORT CompressionFormat;

    PIRP WriteIrp = NULL;
    PDEVICE_OBJECT DeviceObject;
    PFILE_OBJECT FileObject;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION WriteIrpSp;
    TYPE_OF_OPEN TypeOfOpen;

    ULONG InputBufferLength;
    PENCRYPTED_DATA_INFO EncryptedDataInfo;
    ULONG InputBufferOffset;
    USHORT BlockIndex;
    USHORT BlockCount;

    PUCHAR RawDataSource;

    BOOLEAN AccessingUserBuffer = FALSE;
    UCHAR EncryptionFormat;
    UCHAR ChunkShift;
    KEVENT Event;
    IO_STATUS_BLOCK Iosb;

    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    //  Don't post this request, we can't lock both input and output buffers.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    DebugTrace( +1, Dbg, ("NtfsWriteRawEncrypted:\n") );

    KeInitializeEvent( &Event, SynchronizationEvent, FALSE );

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    FileObject = IrpSp->FileObject;

    TypeOfOpen = NtfsDecodeFileObject( IrpContext,
                                       FileObject,
                                       &Vcb,
                                       &Fcb,
                                       &Scb,
                                       &Ccb,
                                       TRUE );

    //
    //  This operation only applies to files, not indexes,
    //  or volumes.
    //

    if (TypeOfOpen != UserFileOpen) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        DebugTrace( -1, Dbg, ("NtfsWriteRawEncrypted not a UserFileOpen -> %08lx\n", STATUS_INVALID_PARAMETER) );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Readonly mount should be just that: read only.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );
        DebugTrace( -1, Dbg, ("SetCompression returning WRITE_PROTECTED\n") );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    //
    //  Remember the source info flags in the Ccb.
    //

    IrpContext->SourceInfo = Ccb->UsnSourceInfo;

    //
    //  We can't allow writes to unencrypted files, as that could let any
    //  user write to any file..
    //

    if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED ) ||

        //
        //  Even for an encrypted file, we should only allow this if the
        //  user has write access.
        //

        (!(FlagOn( Ccb->AccessFlags, WRITE_DATA_ACCESS | WRITE_ATTRIBUTES_ACCESS )))) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        DebugTrace( -1, Dbg, ("NtfsWriteRawEncrypted -> %08lx\n", STATUS_ACCESS_DENIED) );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Get the input buffer length and pointer.
    //

    EncryptedDataInfo = (PENCRYPTED_DATA_INFO)IrpSp->Parameters.FileSystemControl.Type3InputBuffer;
    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;

    //
    //  Check for a minimum length on the input buffer.
    //

    if (InputBufferLength < sizeof(ENCRYPTED_DATA_INFO)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        DebugTrace( -1, Dbg, ("NtfsWriteRawEncrypted -> %08lx\n", STATUS_BUFFER_TOO_SMALL) );
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  Probe the user's buffer.
    //

    try {

        ProbeForRead( EncryptedDataInfo, InputBufferLength, sizeof(UCHAR) );

        InputBufferOffset = EncryptedDataInfo->OutputBufferOffset;
        BytesWithinValidDataLength = EncryptedDataInfo->BytesWithinValidDataLength;
        BytesWithinFileSize = EncryptedDataInfo->BytesWithinFileSize;
        BlockCount = EncryptedDataInfo->NumberOfDataBlocks;
        EncryptionFormat = EncryptedDataInfo->EncryptionFormat;
        OriginalStartingVbo = StartingVbo = EncryptedDataInfo->StartingFileOffset;
        ChunkShift = EncryptedDataInfo->ChunkShift;
        CompressionFormat = EncryptedDataInfo->CompressionFormat;

    } except( NtfsWriteRawExceptionFilter( IrpContext, GetExceptionInformation() ) ) {

        Status = GetExceptionCode();

        DebugTrace( -1, Dbg, ("NtfsWriteRawEncrypted raising %08lx\n", Status) );
        NtfsRaiseStatus( IrpContext,
                         FsRtlIsNtstatusExpected(Status) ? Status : STATUS_INVALID_USER_BUFFER,
                         NULL,
                         NULL );
    }

    //
    //  See whether the data we're being given is valid.
    //

    if ((EncryptionFormat != ENCRYPTION_FORMAT_DEFAULT) ||
        (BytesWithinValidDataLength > BytesWithinFileSize) ||
        (CompressionFormat != COMPRESSION_FORMAT_NONE) ||
        (BlockCount == 0) ||
        (InputBufferOffset > InputBufferLength)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        DebugTrace( -1, Dbg, ("NtfsWriteRawEncrypted bad input data -> %08lx\n", STATUS_INVALID_PARAMETER) );
        return STATUS_INVALID_PARAMETER;
    }


    try {

        //
        //  Serialize with anyone who might be changing file sizes. Acquire main directly
        //  because we call CommonWrite mult times and want to hold the resource across the calls
        //

        NtfsAcquireExclusivePagingIo( IrpContext, Fcb );
        NtfsAcquireExclusiveScb( IrpContext, Scb );

#ifdef  COMPRESS_ON_WIRE

        //
        //  Before we proceed, let's make sure this file is not cached.
        //

        if (Scb->Header.FileObjectC != NULL) {

            PCOMPRESSION_SYNC CompressionSync = NULL;

            //
            //  Use a try-finally to clean up the compression sync.
            //

            try {

                NtfsSynchronizeUncompressedIo( Scb,
                                               NULL,
                                               0,
                                               TRUE,
                                               &CompressionSync );

            } finally {

                NtfsReleaseCompressionSync( CompressionSync );
            }
        }
#endif

        CcFlushCache( &Scb->NonpagedScb->SegmentObject, NULL, 0, &Irp->IoStatus );

        NtfsNormalizeAndCleanupTransaction( IrpContext, &Irp->IoStatus.Status, TRUE, STATUS_UNEXPECTED_IO_ERROR );

        if (!CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject, NULL, 0, FALSE )) {

            DebugTrace( 0, Dbg, ("Can't purge cache section in write raw...aborting\n") );
            Status = STATUS_UNABLE_TO_DELETE_SECTION;
            leave;
        }

//  **** TIGHTEN THIS ASSERT ****
//            ASSERT( Scb->NonpagedScb->SegmentObject.SharedCacheMap == NULL );

        //
        //  Since we can't add zeroes in the middle of the file (since we may not
        //  have a key with which to encrypt them) it's illegal to try to write
        //  at some arbitrary offset beyond the current eof.
        //

        if (StartingVbo != Scb->Header.FileSize.QuadPart) {

            DebugTrace( 0, Dbg, ("Attempting to begin a write raw beyond EOF...aborting\n") );
            Status = STATUS_INVALID_PARAMETER;
            leave;
        }

        //
        //  Add any allocation necc. to reach the new filesize
        //

        if (OriginalStartingVbo + BytesWithinFileSize >  Scb->Header.AllocationSize.QuadPart) {

            LONGLONG EndingVbo;

            EndingVbo = OriginalStartingVbo + BytesWithinFileSize;

            //
            //  Always add in compression units for sparse files
            //

            if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

                EndingVbo += Scb->CompressionUnit - 1;
                EndingVbo &= ~(LONGLONG)(Scb->CompressionUnit - 1);
            }

            NtfsAddAllocation( IrpContext,
                               NULL,
                               Scb,
                               LlClustersFromBytes( Vcb,
                                                    Scb->Header.AllocationSize.QuadPart ),
                               LlClustersFromBytes( Vcb, EndingVbo - Scb->Header.AllocationSize.QuadPart ),
                               FALSE,
                               NULL );
        }

        //
        //  Now we just loop through for each block and do the actual write(s).
        //

        DebugTrace( 0, Dbg, ("BlockCount     %08lx\n", BlockCount) );

        for (BlockIndex = 0; BlockIndex < BlockCount; BlockIndex += 1) {

            AccessingUserBuffer = TRUE;
            ByteCount = EncryptedDataInfo->DataBlockSize[BlockIndex];
            AccessingUserBuffer = FALSE;
            EndingVbo = StartingVbo + ByteCount;

            DebugTrace( 0, Dbg, ("BlockIndex     %08lx\n", BlockIndex) );
            DebugTrace( 0, Dbg, ("ByteCount      %08lx\n", ByteCount) );


            if (ByteCount != 0 && BytesWithinValidDataLength > 0) {

                //
                //  Compute the address from which we will start copying raw data.
                //

                RawDataSource = Add2Ptr( EncryptedDataInfo, InputBufferOffset );

                //
                //  Make sure we aren't about to touch memory beyond that part of the
                //  user's buffer that we probed above.
                //

                if ((InputBufferOffset + ByteCount) > InputBufferLength) {

                    DebugTrace( 0, Dbg, ("Going beyond InputBufferLength...aborting\n") );
                    Status = STATUS_INVALID_PARAMETER;
                    leave;
                }

                InputBufferOffset += ByteCount;

                //
                //  Begin by getting a pointer to the device object that the file resides
                //  on.
                //

                DeviceObject = IoGetRelatedDeviceObject( FileObject );

                //
                //  Allocate an I/O Request Packet (IRP) for this raw write operation.
                //  It has to be synchronous so that it completes before we adjust
                //  filesize and valid data length.
                //

                AccessingUserBuffer = TRUE;
                WriteIrp = IoBuildSynchronousFsdRequest( IRP_MJ_WRITE,
                                                         Vcb->Vpb->DeviceObject,
                                                         RawDataSource,
                                                         ByteCount,
                                                         (PLARGE_INTEGER)&StartingVbo,
                                                         &Event,
                                                         &Iosb );
                AccessingUserBuffer = FALSE;

                if (WriteIrp == NULL) {

                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    leave;
                }

                //
                //  Put our buffer in the Irp and set some other irp fields.
                //

                WriteIrp->UserBuffer = RawDataSource;
                SetFlag( WriteIrp->Flags, IRP_NOCACHE );

                //
                //  We now have an Irp, we want to make it look as though it came from
                //  IoCallDriver and need  to adjust the Irp stack to update this.
                //

                WriteIrpSp = IoGetNextIrpStackLocation( WriteIrp );

                WriteIrpSp->DeviceObject = DeviceObject;
                WriteIrpSp->Parameters.Write.ByteOffset.QuadPart = StartingVbo;
                WriteIrpSp->Parameters.Write.Length = ByteCount;
                WriteIrpSp->FileObject = FileObject;

                ASSERT( NtfsIsExclusiveScb( Scb ) );

                //
                //  Callback directly into ourselfs - don't confuse filters with
                //  an extra write
                //

                Status = IoCallDriver( Vcb->Vpb->DeviceObject, WriteIrp );

                if (Status == STATUS_PENDING) {
                    Status = KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, NULL );
                    if (Status == STATUS_SUCCESS) {
                        Status = Iosb.Status;
                    }
                }

                //
                //  The write should always be done synchronously, we should still own
                //  the resource and all our cleanup structures and snapshots should be good
                //

                ASSERT(Status != STATUS_PENDING && Status != STATUS_CANT_WAIT);
                ASSERT( NtfsIsExclusiveScb( Scb ) );
                ASSERT( (IrpContext->CleanupStructure == Fcb) && (Scb->ScbSnapshot != NULL) );

                NtfsNormalizeAndCleanupTransaction( IrpContext, &Status, TRUE, STATUS_UNEXPECTED_IO_ERROR );

                TotalBytesWritten += ByteCount;

            } else if (ByteCount == 0) {

                //
                //  This is a sparse hole, so there's nothing to actually write.
                //  We just need to make sure this stream is sparse, and zero this
                //  range.  We can't ask our caller to mark the file as sparse,
                //  since they just opened the handle and don't have write
                //  access to this file.
                //

                DebugTrace( 0, Dbg, ("Deallocated range for block %x\n", BlockIndex) );

                //
                //  Make sure our test of the attribute flag is safe.
                //

                ASSERT_SHARED_RESOURCE( Scb->Header.PagingIoResource );

                if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

                    DebugTrace( 0, Dbg, ("Marking stream as sparse\n") );
                    NtfsSetSparseStream( IrpContext, NULL, Scb );
                }

                ByteCount = (1 << ChunkShift);
                EndingVbo = StartingVbo + ByteCount;

                //
                //  Add any allocation necc. to back this. Ie we have a sparse region
                //  beyond filesize
                //

                if (Scb->Header.AllocationSize.QuadPart < EndingVbo) {

                    //
                    //  Round up to a compression unit
                    //

                    EndingVbo += Scb->CompressionUnit - 1;
                    EndingVbo &= ~(LONGLONG)(Scb->CompressionUnit - 1);

                    NtfsAddAllocation( IrpContext,
                                       NULL,
                                       Scb,
                                       LlClustersFromBytes( Vcb,
                                                            Scb->Header.AllocationSize.QuadPart ),
                                       LlClustersFromBytes( Vcb,
                                                            EndingVbo - Scb->Header.AllocationSize.QuadPart ),
                                       FALSE,
                                       NULL );
                }

                DebugTrace( 0, Dbg, ("Zeroing range from %I64x\n", StartingVbo) );
                DebugTrace( 0, Dbg, ("to %I64x\n", (StartingVbo + ByteCount - 1)) );

                //
                //  We can't synthesize partial sparse holes, since our caller may
                //  not have a key with which to encrypt a buffer full of zeroes.
                //  Therefore, we can't do this restore if the volume we're restoring
                //  to requires sparse holes to be bigger than the hole we're
                //  trying to restore now.
                //

                if (ByteCount < Scb->CompressionUnit) {

                    DebugTrace( 0, Dbg, ("Can't synthesize partial sparse hole\n") );
                    Status = STATUS_INVALID_PARAMETER;
                    leave;
                }

                //
                //  Copy StartingVbo in case ZeroRangeInStream modifies it.
                //  NtfsZeroRangeInStream uses the cleanupstructure so always
                //  return it back to its original value afterwards
                //

                FirstZero = StartingVbo;

                Status = NtfsZeroRangeInStream( IrpContext,
                                                FileObject,
                                                Scb,
                                                &FirstZero,
                                                (StartingVbo + ByteCount - 1) );

                ASSERT( (PFCB)IrpContext->CleanupStructure == Fcb );

                if (!NT_SUCCESS( Status )) {

                    leave;
                }

                //
                //  Let's move the filesize up now, just like NtfsCommonWrite does in
                //  the other half of this if statement.
                //

                {
                    LONGLONG NewFileSize = StartingVbo + ByteCount;

                    DebugTrace( 0, Dbg, ("Adjusting sparse file size to %I64x\n", NewFileSize) );

                    Scb->Header.FileSize.QuadPart = NewFileSize;

                    NtfsWriteFileSizes( IrpContext, Scb, &NewFileSize, FALSE, TRUE, TRUE );

                    if (Scb->FileObject != NULL) {

                        CcSetFileSizes( Scb->FileObject, (PCC_FILE_SIZES) &Scb->Header.AllocationSize );
                    }
                }
                TotalBytesWritten += ByteCount;
            }
            StartingVbo += ByteCount;
        }

        DebugTrace( 0, Dbg, ("TotalBytesWritten %I64x\n", TotalBytesWritten) );

        //
        //  Only adjust the filesizes if the write succeeded.  If the write failed
        //  the IrpContext has been freed already. Note: startyingvbo must be <= original eof
        //

        if (NT_SUCCESS( Status ) &&
            ((LONGLONG)BytesWithinFileSize != TotalBytesWritten ||
             (LONGLONG)BytesWithinValidDataLength < TotalBytesWritten)) {

            LONGLONG NewValidDataLength = OriginalStartingVbo + BytesWithinValidDataLength;

            Scb->Header.FileSize.QuadPart = OriginalStartingVbo + BytesWithinFileSize;
            if (NewValidDataLength < Scb->Header.ValidDataLength.QuadPart) {
                Scb->Header.ValidDataLength.QuadPart = NewValidDataLength;
            }

            //
            //  WriteFileSizes will only move the VDL back since we set AdvanceOnly to False
            //

            ASSERT( IrpContext->CleanupStructure != NULL );

            NtfsWriteFileSizes( IrpContext, Scb, &NewValidDataLength, FALSE, TRUE, TRUE );

            //
            //  Readjust VDD - for non compressed files this is a noop since vdd is not updated for them
            //

            if (Scb->ValidDataToDisk > Scb->Header.ValidDataLength.QuadPart) {
                Scb->ValidDataToDisk = Scb->Header.ValidDataLength.QuadPart;
            }

            if (Scb->FileObject != NULL) {

                CcSetFileSizes( Scb->FileObject, (PCC_FILE_SIZES) &Scb->Header.AllocationSize );
            }
        }
    } except( NtfsWriteRawExceptionFilter( IrpContext, GetExceptionInformation() ) ) {

        Status = GetExceptionCode();

        DebugTrace( -1, Dbg, ("NtfsReadRawEncrypted raising %08lx\n", Status) );
        NtfsRaiseStatus( IrpContext,
                         ((FsRtlIsNtstatusExpected(Status) || !AccessingUserBuffer) ? Status : STATUS_INVALID_USER_BUFFER),
                         NULL,
                         NULL );
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );

    DebugTrace( -1, Dbg, ("NtfsWriteRawEncrypted -> %08lx\n", Status) );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsExtendVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine extends an Ntfs volume.  We will take the number of sectors
    passed to this routine and extend the volume provided that this will grow
    the volume by at least one cluster.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    TYPE_OF_OPEN TypeOfOpen;

    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    FILE_REFERENCE FileReference = { BOOT_FILE_NUMBER, 0, BOOT_FILE_NUMBER };
    PSCB BootFileScb = NULL;
    BOOLEAN RemovedBootFileFcb = FALSE;

    BOOLEAN UnloadMcb = FALSE;

    LONGLONG NewVolumeSize;
    LONGLONG NewTotalClusters;

    PVOID ZeroBuffer = NULL;

    LONGLONG NewBitmapSize;
    LONGLONG NewBitmapAllocation;
    LONGLONG AddBytes;
    LONGLONG AddClusters = 0;

    LONGLONG PreviousBitmapAllocation;

    LCN NewLcn;
    LCN Lcn;
    LONGLONG ClusterCount;
    LONGLONG FileOffset;
    LONGLONG BeyondBitsToModify;
    LONGLONG NewSectors;

    IO_STATUS_BLOCK Iosb;

    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    DISK_GEOMETRY DiskGeometry;
    LONGLONG DiskBytes;

    PBCB PrimaryBootBcb = NULL;
    PBCB BackupBootBcb = NULL;

    PPACKED_BOOT_SECTOR PrimaryBootSector;
    PPACKED_BOOT_SECTOR BackupBootSector;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsExtendVolume...\n") );

    //
    //  Make sure the input parameters are valid.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  The input buffer is a LONGLONG and it should not be zero.
    //

    if (IrpSp->Parameters.FileSystemControl.InputBufferLength < sizeof( LONGLONG )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace( -1, Dbg, ("NtfsExtendVolume -> %08lx\n", STATUS_INVALID_PARAMETER) );
        return STATUS_INVALID_PARAMETER;
    }

    RtlCopyMemory( &NewSectors, Irp->AssociatedIrp.SystemBuffer, sizeof( LONGLONG ));

    if (NewSectors <= 0) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace( -1, Dbg, ("NtfsExtendVolume -> %08lx\n", STATUS_INVALID_PARAMETER) );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Extract and decode the file object, and only permit user volume opens
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext,
                                       IrpSp->FileObject,
                                       &Vcb,
                                       &Fcb,
                                       &Scb,
                                       &Ccb,
                                       TRUE );

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );

        DebugTrace( -1, Dbg, ("NtfsExtendVolume -> %08lx\n", STATUS_ACCESS_DENIED) );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Readonly mount should be just that: read only.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );
        DebugTrace( -1, Dbg, ("SetCompression returning WRITE_PROTECTED\n") );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    //
    //  We don't want to rewind back to a different value than what we currently have
    //

    ASSERT( Vcb->PreviousTotalClusters == Vcb->TotalClusters );

    //
    //  Lets set the Scb to the volume bitmap scb at this point.  We no longer care about
    //  the volume Dasd Scb from here on.
    //

    Scb = NULL;

    //
    //  Compute the new volume size.  Don't forget to allow one sector for the backup
    //  boot sector.
    //

    NewVolumeSize = (NewSectors - 1) * Vcb->BytesPerSector;
    NewTotalClusters = LlClustersFromBytesTruncate( Vcb, NewVolumeSize );

    //
    //  Make sure the volume size didn't wrap and that we don't have more than 2^32 - 2 clusters.
    //  We make this 2^32 - 2 so that we can generate a cluster for the backup boot sector in
    //  order to write it.
    //

    if ((NewVolumeSize < NewSectors) ||
        (NewTotalClusters > (0x100000000 - 2))) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace( -1, Dbg, ("NtfsExtendVolume -> %08lx\n", STATUS_INVALID_PARAMETER) );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  We hold the Vcb exclusively for this operation.  Make sure the wait flag is
    //  set in the IrpContext.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    NtfsInitializeAttributeContext( &AttrContext );
    NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Make sure the volume is mounted.
        //

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  We only need the Mft and volume bitmap for this operation.
        //  Lets set the Scb to the volume bitmap scb at this point.  We no longer care about
        //  the volume Dasd Scb from here on.  We acquire it here solely to be able to
        //  update the size when we are done.
        //

        Scb = Vcb->BitmapScb;
        NtfsAcquireExclusiveFcb( IrpContext, Vcb->VolumeDasdScb->Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );
        NtfsAcquireExclusiveFcb( IrpContext, Vcb->MftScb->Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );

        ExAcquireResourceExclusiveLite( Scb->Header.PagingIoResource, TRUE );
        NtfsAcquireExclusiveFcb( IrpContext, Scb->Fcb, NULL, ACQUIRE_NO_DELETE_CHECK | ACQUIRE_HOLD_BITMAP );
        ASSERT( Scb->Fcb->ExclusiveFcbLinks.Flink != NULL );

        //
        //  Make sure we are adding at least one cluster.
        //

        if ((Vcb->TotalClusters >= NewTotalClusters) &&
            (NewTotalClusters >= 0)) {

            Status = STATUS_INVALID_PARAMETER;
            leave;
        }

        //
        //  Also check that the driver supports a drive of this size.
        //  Total size in use == NewVolumeSize + the last copy of the boot sector
        //  NewVolumeSize is already biased for the boot sector copy
        //

        NtfsGetDiskGeometry( IrpContext, Vcb->TargetDeviceObject, &DiskGeometry, &DiskBytes );

        if ((Vcb->BytesPerSector != DiskGeometry.BytesPerSector) ||
            (NewVolumeSize + Vcb->BytesPerSector > DiskBytes)) {

            Status = STATUS_INVALID_PARAMETER;
            leave;
        }

        //
        //  Go ahead and create an Fcb and Scb for the BootFile.
        //

        BootFileScb = NtfsCreatePrerestartScb( IrpContext, Vcb, &FileReference, $DATA, NULL, 0 );

        //
        //  Acquire this Fcb exclusively but don't put it our exclusive lists or snapshot it.
        //

        NtfsAcquireResourceExclusive( IrpContext, BootFileScb, TRUE );
        if (!FlagOn( BootFileScb->ScbState, SCB_STATE_FILE_SIZE_LOADED )) {

            NtfsUpdateScbFromAttribute( IrpContext, BootFileScb, NULL );
        }

        //
        //  Lets flush and purge the volume bitmap.  We want to make sure there are no
        //  partial pages at the end of the bitmap.
        //

        CcFlushCache( &Scb->NonpagedScb->SegmentObject,
                      NULL,
                      0,
                      &Iosb );

        NtfsNormalizeAndCleanupTransaction( IrpContext, &Iosb.Status, TRUE, STATUS_UNEXPECTED_IO_ERROR );

        if (!CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject,
                                  NULL,
                                  0,
                                  FALSE )) {

            NtfsRaiseStatus( IrpContext, STATUS_UNABLE_TO_DELETE_SECTION, NULL, NULL );
        }

        //
        //  We want to snapshot the volume bitmap.
        //

        NtfsSnapshotScb( IrpContext, Scb );

        //
        //  Unload the Mcb in case of errors.
        //

        ASSERT( Scb->ScbSnapshot != NULL );
        Scb->ScbSnapshot->LowestModifiedVcn = 0;
        Scb->ScbSnapshot->HighestModifiedVcn = MAXLONGLONG;

        //
        //  Round the bitmap size up to an 8 byte boundary.
        //

        NewBitmapSize = Int64ShraMod32( NewTotalClusters + 7, 3 ) + 7;
        NewBitmapSize &= ~(7);

        NewBitmapAllocation = LlBytesFromClusters( Vcb, LlClustersFromBytes( Vcb, NewBitmapSize ));

        PreviousBitmapAllocation = Scb->Header.AllocationSize.QuadPart;

        //
        //  Store the new total clusters in the Vcb now.  Several of our routines
        //  check that a cluster being used lies within the volume.  We will temporarily round
        //  this up to an 8 byte boundary so we can set any unused bits in the tail of
        //  the bitmap.
        //

        Vcb->TotalClusters = Int64ShllMod32( NewBitmapSize, 3 );

        //
        //  If we are growing the allocation for the volume bitmap then
        //  we want to make sure the entire new clusters are zeroed and
        //  then added to the volume bitmap.
        //

        if (NewBitmapAllocation > PreviousBitmapAllocation) {

            AddBytes = NewBitmapAllocation - PreviousBitmapAllocation;
            AddClusters = LlClustersFromBytesTruncate( Vcb, AddBytes );

            ZeroBuffer = NtfsAllocatePool( NonPagedPoolCacheAligned,
                                           (ULONG) ROUND_TO_PAGES( (ULONG) AddBytes ));

            RtlZeroMemory( ZeroBuffer, (ULONG) AddBytes );

            //
            //  Add the entry to Mcb.  We would prefer not to overwrite the existing
            //  backup boot sector if possible.
            //

            NewLcn = Vcb->PreviousTotalClusters + 1;
            if (NewLcn + AddClusters > NewTotalClusters) {

                NewLcn -= 1;
            }

            NtfsAddNtfsMcbEntry( &Scb->Mcb,
                                 LlClustersFromBytesTruncate( Vcb, PreviousBitmapAllocation ),
                                 NewLcn,
                                 AddClusters,
                                 FALSE );

            //
            //  We may need to unload the Mcb by hand if we get a failure before the first log record.
            //

            UnloadMcb = TRUE;

            //
            //  Now write zeroes into these clusters.
            //

            NtfsWriteClusters( IrpContext,
                               Vcb,
                               Scb,
                               PreviousBitmapAllocation,
                               ZeroBuffer,
                               (ULONG) AddClusters );

            //
            //  Go ahead and write the new mapping pairs for the larger allocation.
            //

            NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &AttrContext );
            NtfsAddAttributeAllocation( IrpContext, Scb, &AttrContext, NULL, NULL );

            //
            //  Our transaction handling will deal with the Mcb now.
            //

            UnloadMcb = FALSE;

            //
            //  Now tell the cache manager about the larger section.
            //

            CcSetFileSizes( Scb->FileObject, (PCC_FILE_SIZES) &Scb->Header.AllocationSize );
        }

        //
        //  We now have allocated enough space for the new clusters.  The next step is to mark them
        //  allocated in the new volume bitmap.  Start by updating the file size in the Scb and
        //  on disk for the new size.  We can make the whole new range valid.  We will explicitly
        //  update any bytes that may still be incorrect on disk.
        //

        Scb->Header.ValidDataLength.QuadPart =
        Scb->Header.FileSize.QuadPart = NewBitmapSize;

        Scb->TotalAllocated = Scb->Header.AllocationSize.QuadPart;

        NtfsWriteFileSizes( IrpContext, Scb, &NewBitmapSize, TRUE, TRUE, TRUE );
        CcSetFileSizes( Scb->FileObject, (PCC_FILE_SIZES) &Scb->Header.AllocationSize );

        //
        //  The file size is now correct in the Scb and on disk.  The next thing to do is
        //  to zero out any bits between the previous end of the bitmap and the end of the previous
        //  allocation (or the current total clusters, whichever is smaller).
        //

        BeyondBitsToModify = Int64ShllMod32( PreviousBitmapAllocation, 3 );

        if (Vcb->TotalClusters < BeyondBitsToModify) {

            BeyondBitsToModify = Vcb->TotalClusters;
        }

        if (BeyondBitsToModify != Vcb->PreviousTotalClusters) {

            NtfsModifyBitsInBitmap( IrpContext,
                                    Vcb,
                                    Vcb->PreviousTotalClusters,
                                    BeyondBitsToModify,
                                    ClearBitsInNonresidentBitMap,
                                    SetBitsInNonresidentBitMap );
        }

        //
        //  Now we need to set bits for all of the new clusters which are part of
        //  the extension of the volume bitmap.
        //

        if (AddClusters != 0) {

            NtfsModifyBitsInBitmap( IrpContext,
                                    Vcb,
                                    NewLcn,
                                    NewLcn + AddClusters,
                                    SetBitsInNonresidentBitMap,
                                    ClearBitsInNonresidentBitMap );
        }

        //
        //  Finally we need to set all of the bits in the new bitmap which lie beyond
        //  the end of the actual on-disk clusters.
        //

        BeyondBitsToModify = Int64ShllMod32( NewBitmapSize, 3 );
        if (BeyondBitsToModify != NewTotalClusters) {

            NtfsModifyBitsInBitmap( IrpContext,
                                    Vcb,
                                    NewTotalClusters,
                                    BeyondBitsToModify,
                                    SetBitsInNonresidentBitMap,
                                    Noop );
        }

        //
        //  Now set to the exact clusters on the disk.
        //

        Vcb->TotalClusters = NewTotalClusters;

        //
        //  Now it is time to modify the boot sectors for the volume.  We want to:
        //
        //      o Remove the allocation for the n/2 boot sector if present (3.51 format)
        //      o Copy the current boot sector to the end of the volume (with the new sector count)
        //      o Update the primary boot sector at the beginning of the volume.
        //
        //  Start by purging the stream.
        //

        NtfsCreateInternalAttributeStream( IrpContext, BootFileScb, TRUE, NULL );

        //
        //  Don't let the lazy writer touch this stream.
        //

        CcSetAdditionalCacheAttributes( BootFileScb->FileObject, TRUE, TRUE );

        //
        //  Now look to see if the file has more than one run.  If so we want to truncate
        //  it to the end of the first run.
        //

        if (NtfsLookupAllocation( IrpContext, BootFileScb, 0, &Lcn, &ClusterCount, NULL, NULL )) {

            NtfsDeleteAllocation( IrpContext,
                                  BootFileScb->FileObject,
                                  BootFileScb,
                                  ClusterCount,
                                  MAXLONGLONG,
                                  TRUE,
                                  FALSE );
        }

        //
        //  Now create mapping for this stream where the first page (or cluster) will be used for the
        //  primary boot sector and we will have the additional sectors to be able to write to the
        //  last sector.
        //

        BootFileScb->Header.FileSize.QuadPart = PAGE_SIZE;

        if (PAGE_SIZE < Vcb->BytesPerCluster) {

            BootFileScb->Header.FileSize.QuadPart = Vcb->BytesPerCluster;
        }

        BootFileScb->Header.FileSize.QuadPart += (NewVolumeSize + Vcb->BytesPerSector) - LlBytesFromClusters( Vcb, NewTotalClusters );

        BootFileScb->Header.ValidDataLength.QuadPart = BootFileScb->Header.FileSize.QuadPart;

        BootFileScb->Header.AllocationSize.QuadPart = LlBytesFromClusters( Vcb, LlClustersFromBytes( Vcb, BootFileScb->Header.FileSize.QuadPart ));

        CcSetFileSizes( BootFileScb->FileObject, (PCC_FILE_SIZES) &BootFileScb->Header.AllocationSize );

        //
        //  Go ahead purge any existing data and empty the Mcb.
        //

        CcPurgeCacheSection( &BootFileScb->NonpagedScb->SegmentObject,
                             NULL,
                             0,
                             FALSE );

        NtfsUnloadNtfsMcbRange( &BootFileScb->Mcb,
                                0,
                                MAXLONGLONG,
                                FALSE,
                                FALSE );

        //
        //  Lets create the Mcb by hand for this.
        //

        NtfsAddNtfsMcbEntry( &BootFileScb->Mcb,
                             0,
                             0,
                             LlClustersFromBytes( Vcb, PAGE_SIZE ),
                             FALSE );

        NtfsAddNtfsMcbEntry( &BootFileScb->Mcb,
                             LlClustersFromBytes( Vcb, PAGE_SIZE ),
                             NewTotalClusters,
                             1,
                             FALSE );

        //
        //  Now lets pin the two boot sectors.
        //

        FileOffset = 0;
        NtfsPinStream( IrpContext,
                       BootFileScb,
                       0,
                       Vcb->BytesPerSector,
                       &PrimaryBootBcb,
                       &PrimaryBootSector );

        FileOffset = BootFileScb->Header.FileSize.QuadPart - Vcb->BytesPerSector;

        NtfsPinStream( IrpContext,
                       BootFileScb,
                       FileOffset,
                       Vcb->BytesPerSector,
                       &BackupBootBcb,
                       &BackupBootSector );

        //
        //  Remember thge new sector count is 1 less than what we were given
        //

        NewSectors -= 1;

        //
        //  Copy the primary boot sector to the backup location.
        //

        RtlCopyMemory( BackupBootSector, PrimaryBootSector, Vcb->BytesPerSector );

        //
        //  Now copy the sector count into the boot sectors and flush to disk.
        //  Use RtlCopy to avoid alignment faults.
        //

        RtlCopyMemory( &BackupBootSector->NumberSectors, &NewSectors, sizeof( LONGLONG ));

        CcSetDirtyPinnedData( BackupBootBcb, NULL );

        CcFlushCache( &BootFileScb->NonpagedScb->SegmentObject,
                      (PLARGE_INTEGER) &FileOffset,
                      Vcb->BytesPerSector,
                      &Iosb );

        //
        //  Make sure the flush worked.
        //

        NtfsNormalizeAndCleanupTransaction( IrpContext, &Iosb.Status, TRUE, STATUS_UNEXPECTED_IO_ERROR );

        //
        //  Now do the primary.
        //

        FileOffset = 0;
        RtlCopyMemory( &PrimaryBootSector->NumberSectors, &NewSectors, sizeof( LONGLONG ));
        CcSetDirtyPinnedData( PrimaryBootBcb, NULL );

        CcFlushCache( &BootFileScb->NonpagedScb->SegmentObject,
                      (PLARGE_INTEGER) &FileOffset,
                      Vcb->BytesPerSector,
                      &Iosb );

        //
        //  Make sure the flush worked.
        //

        NtfsNormalizeAndCleanupTransaction( IrpContext, &Iosb.Status, TRUE, STATUS_UNEXPECTED_IO_ERROR );

        //
        //  Let's get rid of the pages for this stream now.
        //

        NtfsUnpinBcb( IrpContext, &PrimaryBootBcb );
        NtfsUnpinBcb( IrpContext, &BackupBootBcb );

        CcPurgeCacheSection( &BootFileScb->NonpagedScb->SegmentObject,
                             NULL,
                             0,
                             FALSE );

        NtfsCleanupTransaction( IrpContext, Status, TRUE );

        //
        //  Commit the transaction now so we can update some of the in-memory structures.
        //

        NtfsCheckpointCurrentTransaction( IrpContext );
        LfsFlushToLsn( Vcb->LogHandle, LiMax );

        //
        //  We know this request has succeeded.  Go ahead and remember the new total cluster count
        //  and sector count.
        //

        Vcb->PreviousTotalClusters = Vcb->TotalClusters;
        Vcb->NumberSectors = NewSectors;

        //
        //  Also update the volume dasd size.
        //

        Vcb->VolumeDasdScb->Header.ValidDataLength.QuadPart =
        Vcb->VolumeDasdScb->Header.FileSize.QuadPart =
        Vcb->VolumeDasdScb->Header.AllocationSize.QuadPart = LlBytesFromClusters( Vcb, Vcb->TotalClusters );

        //
        //  Set the flag in the Vcb to cause a rescan of the bitmap for free clusters.  This will also
        //  let the bitmap package use the larger blocks of available disk space.
        //

        SetFlag( Vcb->VcbState, VCB_STATE_RELOAD_FREE_CLUSTERS );

    } finally {

        DebugUnwind( NtfsExtendVolume );

        NtfsUnpinBcb( IrpContext, &PrimaryBootBcb );
        NtfsUnpinBcb( IrpContext, &BackupBootBcb );

        //
        //  Remove the boot file Fcb if we created it.
        //

        if (BootFileScb != NULL) {

            //
            //  Let's know the sizes to zero and get rid of the pages.
            //

            BootFileScb->Header.AllocationSize.QuadPart =
            BootFileScb->Header.FileSize.QuadPart =
            BootFileScb->Header.ValidDataLength.QuadPart = 0;

            ClearFlag( BootFileScb->ScbState, SCB_STATE_FILE_SIZE_LOADED );

            NtfsUnloadNtfsMcbRange( &BootFileScb->Mcb,
                                    0,
                                    MAXLONGLONG,
                                    FALSE,
                                    FALSE );

            if (BootFileScb->FileObject != NULL) {

                //
                //  Deleting the internal attribute stream should automatically
                //  trigger teardown since its the last ref count
                //

                CcSetFileSizes( BootFileScb->FileObject, (PCC_FILE_SIZES) &BootFileScb->Header.AllocationSize );
                NtfsIncrementCloseCounts( BootFileScb, TRUE, FALSE );
                NtfsDeleteInternalAttributeStream( BootFileScb, TRUE, FALSE );
                NtfsDecrementCloseCounts( IrpContext, BootFileScb, NULL, TRUE, FALSE, TRUE );
            }

            NtfsTeardownStructures( IrpContext,
                                    BootFileScb->Fcb,
                                    NULL,
                                    FALSE,
                                    0,
                                    &RemovedBootFileFcb );

            if (!RemovedBootFileFcb) {

                NtfsReleaseResource( IrpContext, BootFileScb );
            }
        }


        if (UnloadMcb) {

            NtfsUnloadNtfsMcbRange( &Scb->Mcb,
                                    0,
                                    MAXLONGLONG,
                                    FALSE,
                                    FALSE );
        }

        //
        //  Release the file resources if we hold them.
        //

        if (Scb != NULL) {

            NtfsReleaseFcb( IrpContext, Scb->Fcb );
            ExReleaseResourceLite( Scb->Header.PagingIoResource );
            NtfsReleaseFcb( IrpContext, Vcb->MftScb->Fcb );
            NtfsReleaseFcb( IrpContext, Vcb->VolumeDasdScb->Fcb );
        }

        NtfsReleaseVcb( IrpContext, Vcb );

        if (ZeroBuffer) { NtfsFreePool( ZeroBuffer ); }

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        DebugTrace( -1, Dbg, ("NtfsExtendVolume -> %08lx\n", Status) );
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsMarkHandle (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used to attach special properties to a user handle.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    PMARK_HANDLE_INFO HandleInfo;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFILE_OBJECT DasdFileObject;
    PFCB DasdFcb, Fcb;
    PSCB DasdScb, Scb;
    PCCB DasdCcb, Ccb;
    BOOLEAN ReleaseScb = FALSE;
#if defined(_WIN64)
    MARK_HANDLE_INFO LocalMarkHandleInfo;
#endif

    extern POBJECT_TYPE *IoFileObjectType;

    PAGED_CODE();

    //
    //  Always make this synchronous.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Extract and decode the file object and check for type of open.
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  We currently support this call for files and directories only.
    //

    if ((TypeOfOpen != UserFileOpen) &&
        (TypeOfOpen != UserDirectoryOpen) &&
        (TypeOfOpen != UserViewIndexOpen)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

#if defined(_WIN64)

    //
    //  Win32/64 thunking code
    //

    if (IoIs32bitProcess( Irp )) {

        PMARK_HANDLE_INFO32 MarkHandle32;

        if (IrpSp->Parameters.FileSystemControl.InputBufferLength < sizeof( MARK_HANDLE_INFO32 )) {

            NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
            return STATUS_BUFFER_TOO_SMALL;
        }

        MarkHandle32 = (PMARK_HANDLE_INFO32) Irp->AssociatedIrp.SystemBuffer;
        LocalMarkHandleInfo.HandleInfo = MarkHandle32->HandleInfo;
        LocalMarkHandleInfo.UsnSourceInfo = MarkHandle32->UsnSourceInfo;
        LocalMarkHandleInfo.VolumeHandle = (HANDLE)(ULONG_PTR)(LONG) MarkHandle32->VolumeHandle;

        HandleInfo = &LocalMarkHandleInfo;

    } else {

#endif

    //
    //  Get the input buffer pointer and check its length.
    //

    if (IrpSp->Parameters.FileSystemControl.InputBufferLength < sizeof( MARK_HANDLE_INFO )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        return STATUS_BUFFER_TOO_SMALL;
    }

    HandleInfo = (PMARK_HANDLE_INFO) Irp->AssociatedIrp.SystemBuffer;

#if defined(_WIN64)
    }
#endif

    //
    //  Check that only legal bits are being set.  We currently only support certain bits in the
    //  UsnSource reasons.
    //

    if (FlagOn( HandleInfo->HandleInfo, ~(MARK_HANDLE_PROTECT_CLUSTERS)) ||
        FlagOn( HandleInfo->UsnSourceInfo,
                ~(USN_SOURCE_DATA_MANAGEMENT |
                  USN_SOURCE_AUXILIARY_DATA |
                  USN_SOURCE_REPLICATION_MANAGEMENT) )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Check that the user has a valid volume handle or the manage volume
    //  privilege or is a kerbel mode caller
    //

    if ((Irp->RequestorMode != KernelMode) && !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

        if (HandleInfo->VolumeHandle == 0) {
            NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
            return STATUS_ACCESS_DENIED;
        }

        Status = ObReferenceObjectByHandle( HandleInfo->VolumeHandle,
                                            0,
                                            *IoFileObjectType,
                                            Irp->RequestorMode,
                                            &DasdFileObject,
                                            NULL );

        if (!NT_SUCCESS(Status)) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
            return Status;
        }

        //  Check that this file object is opened on the same volume as the
        //  handle used to call this routine.
        //

        if (DasdFileObject->Vpb != Vcb->Vpb) {

            ObDereferenceObject( DasdFileObject );

            NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
            return STATUS_INVALID_PARAMETER;
        }

        //
        //  Now decode this FileObject and verify it is a volume handle.
        //  We don't care to raise on dismounts here because
        //  we check for that further down anyway. So send FALSE.
        //

        TypeOfOpen = NtfsDecodeFileObject( IrpContext, DasdFileObject, &Vcb, &DasdFcb, &DasdScb, &DasdCcb, FALSE );

        ObDereferenceObject( DasdFileObject );

        if ((DasdCcb == NULL) || !FlagOn( DasdCcb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

            NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
            return STATUS_ACCESS_DENIED;
        }
    }

    //
    //  Acquire the paging io resource exclusively if present.
    //

    if (Scb->Header.PagingIoResource != NULL) {

        ExAcquireResourceExclusiveLite( Scb->Header.PagingIoResource, TRUE );
    }

    try {

        //
        //  Acquire the file exclusively to serialize changes to the Ccb.
        //

        NtfsAcquireExclusiveScb( IrpContext, Scb );
        ReleaseScb = TRUE;

        //
        //  Verify the volume is still mounted.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  Set these new bits in the Ccb.
        //

        if (FlagOn( HandleInfo->HandleInfo, MARK_HANDLE_PROTECT_CLUSTERS )) {

            //
            //  We can't deny defrag if anyone else already has
            //

            if (FlagOn( Scb->ScbPersist, SCB_PERSIST_DENY_DEFRAG )) {
                Status = STATUS_ACCESS_DENIED;
                leave;
            }

            SetFlag( Ccb->Flags, CCB_FLAG_DENY_DEFRAG );
            SetFlag( Scb->ScbPersist, SCB_PERSIST_DENY_DEFRAG );
        }
        SetFlag( Ccb->UsnSourceInfo, HandleInfo->UsnSourceInfo );

    } finally {

        DebugUnwind( NtfsMarkHandle );

        //
        //  Release the Scb.
        //

        if (ReleaseScb) {

            NtfsReleaseScb( IrpContext, Scb );
        }

        if (Scb->Header.PagingIoResource != NULL) {

            ExReleaseResourceLite( Scb->Header.PagingIoResource );
        }
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local Support routine
//

NTSTATUS
NtfsPrefetchFile (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called to perform the requested prefetch on a system file.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS MmStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;

    PFILE_PREFETCH FilePrefetch;
    PREAD_LIST ReadList = NULL;
    PULONGLONG NextFileId;
    ULONG Count;

    ULONGLONG FileOffset;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    BOOLEAN ReleaseMft = FALSE;

    PAGED_CODE();

    //
    //  Always make this synchronous.  There isn't much advantage to posting this work to a
    //  worker thread.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Extract and decode the file object and check for type of open.
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  We currently support this call only for the Mft (accessed through a volume handle).
    //

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Get the input buffer pointer and check its length.  It needs to be sufficient to
    //  contain the fixed portion of structure plus whatever optional fields passed in.
    //

    FilePrefetch = (PFILE_PREFETCH) Irp->AssociatedIrp.SystemBuffer;
    if (IrpSp->Parameters.FileSystemControl.InputBufferLength < FIELD_OFFSET( FILE_PREFETCH, Prefetch )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  Make sure the type and cound fields are valid.
    //

    if ((FilePrefetch->Type != FILE_PREFETCH_TYPE_FOR_CREATE) ||
        (FilePrefetch->Count > 0x300)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Finally verify that the variable length data is of valid length.
    //

    if (IrpSp->Parameters.FileSystemControl.InputBufferLength <
        (FIELD_OFFSET( FILE_PREFETCH, Prefetch ) + (sizeof( ULONGLONG ) * FilePrefetch->Count))) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  If the user didn't specify any entries we are done.
    //

    if (FilePrefetch->Count == 0) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  Acquire the volume dasd file shared to do this.
    //

    NtfsAcquireSharedScb( IrpContext, Scb );

    try {

        //
        //  Verify the volume is still mounted.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  Allocate the necessary pool to pass to MM.
        //

        ReadList = NtfsAllocatePool( PagedPool,
                                     FIELD_OFFSET( READ_LIST, List ) + (FilePrefetch->Count * sizeof( FILE_SEGMENT_ELEMENT )));

        //
        //  Initialize the read list.
        //

        ReadList->FileObject = Vcb->MftScb->FileObject;
        ASSERT( Vcb->MftScb->FileObject != NULL );

        ReadList->NumberOfEntries = 0;
        ReadList->IsImage = FALSE;

        //
        //  Walk through and load the list.  We won't bother to check sequence numbers
        //  as they don't really change the correctness of this call.  We do check for the
        //  valid length of the Mft though.
        //

        NtfsAcquireSharedScb( IrpContext, Vcb->MftScb );
        ReleaseMft = TRUE;

        NextFileId = &FilePrefetch->Prefetch[0];
        Count = FilePrefetch->Count;

        while (Count > 0) {

            FileOffset = NtfsFullSegmentNumber( NextFileId );
            FileOffset = LlBytesFromFileRecords( Vcb, FileOffset );

            //
            //  Round down to page boundary.  This will reduce the number of entries
            //  passed to MM.
            //

            ((PLARGE_INTEGER) &FileOffset)->LowPart &= ~(PAGE_SIZE - 1);

            //
            //  Check if we are beyond the end of the Mft.  Treat this as a ULONGLONG
            //  so we can catch the case where the ID generates a negative number.
            //

            if (FileOffset >= (ULONGLONG) Vcb->MftScb->Header.ValidDataLength.QuadPart) {

                Status = STATUS_END_OF_FILE;

            //
            //  If not then add to the buffer to pass to mm.
            //

            } else {

                ULONG Index;

                //
                //  Position ourselves in the output array.  Look in reverse
                //  order in case our caller has already sorted this.
                //

                Index = ReadList->NumberOfEntries;

                while (Index != 0) {

                    //
                    //  If the prior entry is less than the current entry we are done.
                    //

                    if (ReadList->List[Index - 1].Alignment < FileOffset) {

                        break;
                    }

                    //
                    //  If the prior entry equals the current entry then skip it.
                    //

                    if (ReadList->List[Index - 1].Alignment == FileOffset) {

                        Index = MAXULONG;
                        break;
                    }

                    //
                    //  Move backwards to the previous entry.
                    //

                    Index -= 1;
                }

                //
                //  Index now points to the insert point, except if MAXULONG.  Insert the entry
                //  and shift any existing entries necessary if we are doing the insert.
                //

                if (Index != MAXULONG) {

                    if (Index != ReadList->NumberOfEntries) {

                        RtlMoveMemory( &ReadList->List[Index + 1],
                                       &ReadList->List[Index],
                                       sizeof( LONGLONG ) * (ReadList->NumberOfEntries - Index) );
                    }

                    ReadList->NumberOfEntries += 1;
                    ReadList->List[Index].Alignment = FileOffset;
                }
            }

            //
            //  Move to the next entry.
            //

            Count -= 1;
            NextFileId += 1;
        }

        //
        //  We're done with the Mft.  If we ever support shrinking the Mft we will have to close
        //  the hole here.
        //

        NtfsReleaseScb( IrpContext, Vcb->MftScb );
        ReleaseMft = FALSE;

        //
        //  Now call mm to do the IO.
        //

        if (ReadList->NumberOfEntries != 0) {

            MmStatus = MmPrefetchPages( 1, &ReadList );

            //
            //  Use the Mm status if we don't already have one.
            //

            if (Status == STATUS_SUCCESS) {

                Status = MmStatus;
            }
        }

    } finally {

        DebugUnwind( NtfsPrefetchFile );

        //
        //  Free the read list if allocated.
        //

        if (ReadList != NULL) {

            NtfsFreePool( ReadList );
        }

        //
        //  Release any Scb acquired.
        //

        if (ReleaseMft) {

            NtfsReleaseScb( IrpContext, Vcb->MftScb );
        }

        NtfsReleaseScb( IrpContext, Scb );
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local Support routine
//

LONG
NtfsFsctrlExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer,
    IN BOOLEAN AccessingUserData,
    OUT PNTSTATUS Status
    )

/*++

Routine Description:

    Generic Exception filter for errors during fsctrl processing. Raise invalid user buffer
    directly or let it filter on to the top level try-except


Arguments:

    IrpContext  - IrpContext

    ExceptionPointer - Pointer to the exception context.

    AccessingUserData - if false always let the exception filter up

    Status - Address to store the error status.

Return Value:

    Exception status - EXCEPTION_CONTINUE_SEARCH if we want to raise to another handler,
        EXCEPTION_EXECUTE_HANDLER if we plan to proceed on.

--*/

{
    *Status = ExceptionPointer->ExceptionRecord->ExceptionCode;

    if (!FsRtlIsNtstatusExpected( *Status ) && AccessingUserData) {

        NtfsMinimumExceptionProcessing( IrpContext );
        return EXCEPTION_EXECUTE_HANDLER;
    } else {
        return EXCEPTION_CONTINUE_SEARCH;
    }
}

#ifdef SYSCACHE_DEBUG

//
//  Local support routine
//

VOID
NtfsInitializeSyscacheLogFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine creates the syscache logfile in the root directory.

Arguments:

    Vcb - Pointer to the Vcb for the volume

Return Value:

    None.

--*/

{
    UNICODE_STRING AttrName;
    struct {
        FILE_NAME FileName;
        WCHAR FileNameChars[10];
    } FileNameAttr;
    FILE_REFERENCE FileReference;
    LONGLONG FileRecordOffset;
    PINDEX_ENTRY IndexEntry;
    PBCB FileRecordBcb = NULL;
    PBCB IndexEntryBcb = NULL;
    PBCB ParentSecurityBcb = NULL;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    UCHAR FileNameFlags;
    BOOLEAN FoundEntry;
    PFCB Fcb = NULL;
    BOOLEAN AcquiredFcbTable = FALSE;
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    ULONG DesiredAccess = GENERIC_READ | GENERIC_WRITE;
    NTSTATUS Status = STATUS_SUCCESS;

    NtfsAcquireExclusiveScb( IrpContext, Vcb->RootIndexScb );

    //
    //  Initialize the FileName.
    //

    RtlZeroMemory( &FileNameAttr, sizeof(FileNameAttr) );
    FileNameAttr.FileName.ParentDirectory = Vcb->RootIndexScb->Fcb->FileReference;
    FileNameAttr.FileName.FileNameLength = (UCHAR)(9); // 9 unicode characters long
    RtlCopyMemory( FileNameAttr.FileName.FileName, L"$ntfs.log", 9 * sizeof( WCHAR ) );

    NtfsInitializeAttributeContext( &Context );

    try {

        //
        //  Does the file already exist?
        //

        FoundEntry = NtfsFindIndexEntry( IrpContext,
                                         Vcb->RootIndexScb,
                                         &FileNameAttr,
                                         FALSE,
                                         NULL,
                                         &IndexEntryBcb,
                                         &IndexEntry,
                                         NULL );

        //
        //  If we did not find it, then start creating the file.
        //

        if (!FoundEntry) {

            //
            //  We will now try to do all of the on-disk operations.  This means first
            //  allocating and initializing an Mft record.  After that we create
            //  an Fcb to use to access this record.
            //

            FileReference = NtfsAllocateMftRecord( IrpContext, Vcb, FALSE );

            //
            //  Pin the file record we need.
            //

            NtfsPinMftRecord( IrpContext,
                              Vcb,
                              &FileReference,
                              TRUE,
                              &FileRecordBcb,
                              &FileRecord,
                              &FileRecordOffset );

            //
            //  Initialize the file record header.
            //

            NtfsInitializeMftRecord( IrpContext,
                                     Vcb,
                                     &FileReference,
                                     FileRecord,
                                     FileRecordBcb,
                                     FALSE );

        //
        //  If we found the file, then just get its FileReference out of the
        //  IndexEntry.
        //

        } else {

            FileReference = IndexEntry->FileReference;
        }

        //
        //  Now that we know the FileReference, we can create the Fcb.
        //

        NtfsAcquireFcbTable( IrpContext, Vcb );
        AcquiredFcbTable = TRUE;

        Fcb = NtfsCreateFcb( IrpContext,
                             Vcb,
                             FileReference,
                             FALSE,
                             FALSE,
                             NULL );

        //
        //  Reference the Fcb so it doesn't go away.
        //

        Fcb->ReferenceCount += 1;
        NtfsReleaseFcbTable( IrpContext, Vcb );
        AcquiredFcbTable = FALSE;

        //
        //  Acquire the main resource
        //

        NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );

        NtfsAcquireFcbTable( IrpContext, Vcb );
        Fcb->ReferenceCount -= 1;
        NtfsReleaseFcbTable( IrpContext, Vcb );

        //
        //  If we are creating this file, then carry on.
        //

        if (!FoundEntry) {

            BOOLEAN LogIt = FALSE;

            //
            //  Just copy the Security Id from the parent. (Load it first if necc.)
            //

            if (Vcb->RootIndexScb->Fcb->SharedSecurity == NULL) {
                NtfsLoadSecurityDescriptor( IrpContext, Vcb->RootIndexScb->Fcb );
            }

            NtfsAcquireFcbSecurity( Fcb->Vcb );
            Fcb->SecurityId = Vcb->RootIndexScb->Fcb->SecurityId;

            ASSERT( Fcb->SharedSecurity == NULL );
            Fcb->SharedSecurity = Vcb->RootIndexScb->Fcb->SharedSecurity;
            Fcb->SharedSecurity->ReferenceCount++;
            NtfsReleaseFcbSecurity( Fcb->Vcb );

            //
            //  The changes to make on disk are first to create a standard information
            //  attribute.  We start by filling the Fcb with the information we
            //  know and creating the attribute on disk.
            //

            NtfsInitializeFcbAndStdInfo( IrpContext,
                                         Fcb,
                                         FALSE,
                                         FALSE,
                                         FALSE,
                                         FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM,
                                         NULL );

            //
            //  Now link the file into the $Extend directory.
            //

            NtfsAddLink( IrpContext,
                         TRUE,
                         Vcb->RootIndexScb,
                         Fcb,
                         (PFILE_NAME)&FileNameAttr,
                         &LogIt,
                         &FileNameFlags,
                         NULL,
                         NULL,
                         NULL );
/*

            //
            //  Set this flag to indicate that the file is to be locked via the Scb
            //  pointers in the Vcb.
            //

            SetFlag( FileRecord->Flags, FILE_SYSTEM_FILE );

*/

            //
            //  Log the file record.
            //

            FileRecord->Lsn = NtfsWriteLog( IrpContext,
                                            Vcb->MftScb,
                                            FileRecordBcb,
                                            InitializeFileRecordSegment,
                                            FileRecord,
                                            FileRecord->FirstFreeByte,
                                            Noop,
                                            NULL,
                                            0,
                                            FileRecordOffset,
                                            0,
                                            0,
                                            Vcb->BytesPerFileRecordSegment );

        //
        //  Verify that the file record for this file is valid.
        //

        } else {

            ULONG CorruptHint;

            if (!NtfsLookupAttributeByCode( IrpContext,
                                            Fcb,
                                            &Fcb->FileReference,
                                            $STANDARD_INFORMATION,
                                            &Context ) ||

                !NtfsCheckFileRecord( Vcb, NtfsContainingFileRecord( &Context ), &Fcb->FileReference, &CorruptHint )) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, &Fcb->FileReference, NULL );
            }
        }

        //
        //  Update Fcb fields from disk.
        //

        SetFlag( Fcb->FcbState, FCB_STATE_SYSTEM_FILE );
        NtfsUpdateFcbInfoFromDisk( IrpContext, TRUE, Fcb, NULL );

        //
        //  Open/Create the data stream
        //

        memset( &AttrName, 0, sizeof( AttrName ) );

        NtOfsCreateAttribute( IrpContext,
                              Fcb,
                              AttrName,
                              CREATE_OR_OPEN,
                              FALSE,
                              &Vcb->SyscacheScb );

        RtlMapGenericMask( &DesiredAccess, IoGetFileObjectGenericMapping() );
        IoSetShareAccess( DesiredAccess, FILE_SHARE_READ, Vcb->SyscacheScb->FileObject, &Vcb->SyscacheScb->ShareAccess );

        do {

            if (STATUS_LOG_FILE_FULL == Status) {

                NtfsCleanCheckpoint( IrpContext->Vcb );
                Status = STATUS_SUCCESS;
            }

            try {
                LONGLONG Length = PAGE_SIZE * 0x1d00; // approx 30mb

                NtOfsSetLength( IrpContext, Vcb->SyscacheScb, Length );

                //
                //  Make this look like it came from a write so ioateof is not done
                //  we must do a writefilesizes to update VDL by hand
                //

                SetFlag(IrpContext->TopLevelIrpContext->Flags, IRP_CONTEXT_FLAG_WRITE_SEEN);
                NtfsZeroData( IrpContext, Vcb->SyscacheScb, Vcb->SyscacheScb->FileObject, 0, Length, NULL );
                NtfsWriteFileSizes( IrpContext, Vcb->SyscacheScb, &Vcb->SyscacheScb->Header.ValidDataLength.QuadPart, TRUE, TRUE, TRUE );

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                  Status = GetExceptionCode();
                  ASSERT( Status == STATUS_DISK_FULL || Status == STATUS_LOG_FILE_FULL );

                  NtfsMinimumExceptionProcessing( IrpContext );
                  IrpContext->ExceptionStatus = 0;
            }

            ClearFlag(IrpContext->TopLevelIrpContext->Flags, IRP_CONTEXT_FLAG_WRITE_SEEN);
            NtfsReleaseScb( IrpContext, Vcb->SyscacheScb );

        } while ( STATUS_LOG_FILE_FULL == Status   );

        //
        //  Increment cleanup counts to enforce the sharing we set up
        //

        NtfsIncrementCleanupCounts( Vcb->SyscacheScb, NULL, FALSE );

    } finally {

        NtfsCleanupAttributeContext( IrpContext, &Context );
        NtfsUnpinBcb( IrpContext, &FileRecordBcb );
        NtfsUnpinBcb( IrpContext, &IndexEntryBcb );
        NtfsUnpinBcb( IrpContext, &ParentSecurityBcb );

        //
        //  On any kind of error, nuke the Fcb.
        //

        if (AbnormalTermination()) {

            //
            //  If some error caused us to abort, then delete
            //  the Fcb, because we are the only ones who will.
            //

            if (Fcb) {

                if (!AcquiredFcbTable) {

                    NtfsAcquireFcbTable( IrpContext, Vcb );
                    AcquiredFcbTable = TRUE;
                }
                NtfsDeleteFcb( IrpContext, &Fcb, &AcquiredFcbTable );

                ASSERT(!AcquiredFcbTable);
            }

            if (AcquiredFcbTable) {

                NtfsReleaseFcbTable( IrpContext, Vcb );
            }
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\fspdisp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    FspDisp.c

Abstract:

    This module implements the main dispatch procedure/thread for the Ntfs
    Fsp

Author:

    Gary Kimura     [GaryKi]        21-May-1991

Revision History:

--*/

#include "NtfsProc.h"

#define BugCheckFileId                   (NTFS_BUG_CHECK_FSPDISP)

#pragma alloc_text(PAGE, NtfsSpecialDispatch)
#pragma alloc_text(PAGE, NtfsPostSpecial)

//
//  Define our local debug trace level
//

#define Dbg                              (DEBUG_TRACE_FSP_DISPATCHER)

extern PETHREAD NtfsDesignatedTimeoutThread;


VOID
NtfsFspDispatch (
    IN PVOID Context
    )

/*++

Routine Description:

    This is the main FSP thread routine that is executed to receive
    and dispatch IRP requests.  Each FSP thread begins its execution here.
    There is one thread created at system initialization time and subsequent
    threads created as needed.

Arguments:


    Context - Supplies the thread id.

Return Value:

    None - This routine never exits

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;
    OPLOCK_CLEANUP OplockCleanup; 

    PIRP Irp;
    PIRP_CONTEXT IrpContext;
    PIO_STACK_LOCATION IrpSp;
    ULONG LogFileFullCount = 0;

    PVOLUME_DEVICE_OBJECT VolDo;
    BOOLEAN Retry;
    NTSTATUS Status = STATUS_SUCCESS;
    IrpContext = (PIRP_CONTEXT)Context;

    Irp = IrpContext->OriginatingIrp;

    if (Irp != NULL) {

        IrpSp = IoGetCurrentIrpStackLocation( Irp );
    }

    //
    //  Now because we are the Fsp we will force the IrpContext to
    //  indicate true on Wait.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  If this request has an associated volume device object, remember it.
    //

    if ((Irp != NULL) &&
        (IrpSp->FileObject != NULL)) {

        VolDo = CONTAINING_RECORD( IrpSp->DeviceObject,
                                   VOLUME_DEVICE_OBJECT,
                                   DeviceObject );
    } else {

        VolDo = NULL;
    }

    //
    //  Now case on the function code.  For each major function code,
    //  either call the appropriate FSP routine or case on the minor
    //  function and then call the FSP routine.  The FSP routine that
    //  we call is responsible for completing the IRP, and not us.
    //  That way the routine can complete the IRP and then continue
    //  post processing as required.  For example, a read can be
    //  satisfied right away and then read can be done.
    //
    //  We'll do all of the work within an exception handler that
    //  will be invoked if ever some underlying operation gets into
    //  trouble (e.g., if NtfsReadSectorsSync has trouble).
    //

    while (TRUE) {

        FsRtlEnterFileSystem();

        ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );

        ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, TRUE, TRUE );
        ASSERT( ThreadTopLevelContext == &TopLevelContext );

        NtfsPostRequests += 1;

        do {

            //
            //  If this is the initial try with this Irp Context, update the
            //  top level Irp fields.
            //
    
            NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );
    
            Retry = FALSE;
    
            try {

                //
                //  Always clear the exception code in the IrpContext so we respond
                //  correctly to errors encountered in the Fsp.
                //

                IrpContext->ExceptionStatus = 0;
                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP );

                //
                //  See if we were posted due to a log file full condition, and
                //  if so, then do a clean volume checkpoint if we are the
                //  first ones to get there.  If we see a different Lsn and do
                //  not do the checkpoint, the worst that can happen is that we
                //  will get posted again if the log file is still full.
                //

                if (IrpContext->LastRestartArea.QuadPart != 0) {

                    NtfsCheckpointForLogFileFull( IrpContext );

                    if (++LogFileFullCount >= 2) {

                        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_EXCESS_LOG_FULL );
                    }
                }

                //
                //  If we have an Irp then proceed with our normal processing.
                //

                if (Irp != NULL) {

                    switch ( IrpContext->MajorFunction ) {

                        //
                        //  For Create Operation,
                        //

                        case IRP_MJ_CREATE:

                            ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_EFS_CREATE );
                            
                            if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_DASD_OPEN )) {

                                Status = NtfsCommonVolumeOpen( IrpContext, Irp );

                            } else {

                                RtlZeroMemory( &OplockCleanup, sizeof( OplockCleanup ) );
                                Status = NtfsCommonCreate( IrpContext, Irp, &OplockCleanup, NULL );
                            }
                            break;

                        //
                        //  For close operations
                        //

                        case IRP_MJ_CLOSE:

                            //
                            //  We should never post closes to this workqueue.
                            //

                            NtfsBugCheck( 0, 0, 0 );
                            break;

                        //
                        //  For read operations
                        //

                        case IRP_MJ_READ:

                            (VOID) NtfsCommonRead( IrpContext, Irp, TRUE );
                            break;

                        //
                        //  For write operations,
                        //

                        case IRP_MJ_WRITE:

                            (VOID) NtfsCommonWrite( IrpContext, Irp );
                            break;

                        //
                        //  For Query Information operations,
                        //

                        case IRP_MJ_QUERY_INFORMATION:

                            (VOID) NtfsCommonQueryInformation( IrpContext, Irp );
                            break;

                        //
                        //  For Set Information operations,
                        //

                        case IRP_MJ_SET_INFORMATION:

                            (VOID) NtfsCommonSetInformation( IrpContext, Irp );
                            break;

                        //
                        //  For Query EA operations,
                        //

                        case IRP_MJ_QUERY_EA:

                            (VOID) NtfsCommonQueryEa( IrpContext, Irp );
                            break;

                        //
                        //  For Set EA operations,
                        //

                        case IRP_MJ_SET_EA:

                            (VOID) NtfsCommonSetEa( IrpContext, Irp );
                            break;


                        //
                        //  For Flush buffers operations,
                        //

                        case IRP_MJ_FLUSH_BUFFERS:

                            (VOID) NtfsCommonFlushBuffers( IrpContext, Irp );
                            break;

                        //
                        //  For Query Volume Information operations,
                        //

                        case IRP_MJ_QUERY_VOLUME_INFORMATION:

                            (VOID) NtfsCommonQueryVolumeInfo( IrpContext, Irp );
                            break;

                        //
                        //  For Set Volume Information operations,
                        //

                        case IRP_MJ_SET_VOLUME_INFORMATION:

                            (VOID) NtfsCommonSetVolumeInfo( IrpContext, Irp );
                            break;

                        //
                        //  For File Cleanup operations,
                        //

                        case IRP_MJ_CLEANUP:

                            (VOID) NtfsCommonCleanup( IrpContext, Irp );
                            break;

                        //
                        //  For Directory Control operations,
                        //

                        case IRP_MJ_DIRECTORY_CONTROL:

                            (VOID) NtfsCommonDirectoryControl( IrpContext, Irp );
                            break;

                        //
                        //  For File System Control operations,
                        //

                        case IRP_MJ_FILE_SYSTEM_CONTROL:

                            (VOID) NtfsCommonFileSystemControl( IrpContext, Irp );
                            break;

                        //
                        //  For Lock Control operations,
                        //

                        case IRP_MJ_LOCK_CONTROL:

                            (VOID) NtfsCommonLockControl( IrpContext, Irp );
                            break;

                        //
                        //  For Device Control operations,
                        //

                        case IRP_MJ_DEVICE_CONTROL:

                            (VOID) NtfsCommonDeviceControl( IrpContext, Irp );
                            break;

                        //
                        //  For Query Security Information operations,
                        //

                        case IRP_MJ_QUERY_SECURITY:

                            (VOID) NtfsCommonQuerySecurityInfo( IrpContext, Irp );
                            break;

                        //
                        //  For Set Security Information operations,
                        //

                        case IRP_MJ_SET_SECURITY:

                            (VOID) NtfsCommonSetSecurityInfo( IrpContext, Irp );
                            break;

                        //
                        //  For Query Quota operations,
                        //

                        case IRP_MJ_QUERY_QUOTA:

                            (VOID) NtfsCommonQueryQuota( IrpContext, Irp );
                            break;

                        //
                        //  For Set Quota operations,
                        //

                        case IRP_MJ_SET_QUOTA:

                            (VOID) NtfsCommonSetQuota( IrpContext, Irp );
                            break;

                        //
                        //  For any other major operations, return an invalid
                        //  request.
                        //

                        default:

                            NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
                            break;
                    }

                //
                //  Otherwise complete the request to clean up this Irp Context.
                //

                } else {

                    NtfsCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );
                    IrpContext = NULL;
                }

                ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
        
            } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

                PIO_STACK_LOCATION IrpSp;

                //
                //  We had some trouble trying to perform the requested
                //  operation, so we'll abort the I/O request with
                //  the error status that we get back from the
                //  execption code
                //

                if (Irp != NULL) {

                    IrpSp = IoGetCurrentIrpStackLocation( Irp );

                    Status = GetExceptionCode();

                    if ((Status == STATUS_FILE_DELETED) && 
                        ((IrpContext->MajorFunction == IRP_MJ_READ) || 
                         (IrpContext->MajorFunction == IRP_MJ_WRITE) || 
                         ((IrpContext->MajorFunction == IRP_MJ_SET_INFORMATION) &&
                          (IrpSp->Parameters.SetFile.FileInformationClass == FileEndOfFileInformation)))) {

                        IrpContext->ExceptionStatus = Status = STATUS_SUCCESS;
                    }
                }
                
                //
                //  If we failed to upgrade the volume's version during mount, we may
                //  not have put the right exception code into the irp context yet.
                //
                
                if ((IrpContext != NULL) &&
                    (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_VOL_UPGR_FAILED )) &&
                    (IrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
                    (IrpContext->MinorFunction == IRP_MN_MOUNT_VOLUME)) {

                    IrpContext->ExceptionStatus = Status;
                }

                //  
                //  This is the return status code that we want the Irp Completion routine to receive.
                //

                Status = NtfsProcessException( IrpContext, Irp, Status );

                if ((Status == STATUS_CANT_WAIT) || (Status == STATUS_LOG_FILE_FULL)) {

                    Retry = TRUE;
                }
            }

        } while (Retry);

        FsRtlExitFileSystem();

        //
        //  If there are any entries on this volume's overflow queue, service
        //  them.
        //

        if (VolDo != NULL) {

            KIRQL SavedIrql;
            PLIST_ENTRY Entry = NULL;

            //
            //  We have a volume device object so see if there is any work
            //  left to do in its overflow queue.
            //

            KeAcquireSpinLock( &VolDo->OverflowQueueSpinLock, &SavedIrql );

            while (VolDo->OverflowQueueCount > 0) {

                //
                //  There is overflow work to do in this volume so we'll
                //  decrement the Overflow count, dequeue the IRP, and release
                //  the Event
                //

                Entry = VolDo->OverflowQueue.Flink;
                IrpContext = CONTAINING_RECORD( Entry,
                                                IRP_CONTEXT,
                                                WorkQueueItem.List );
                Irp = IrpContext->OriginatingIrp;

                //
                //  If the cancel routine thinks it owns the irp ignore it
                //  

                if (NtfsSetCancelRoutine( Irp, NULL, 0, FALSE )) {
                    
                    VolDo->OverflowQueueCount -= 1;
                    RemoveEntryList( (PLIST_ENTRY)Entry );
                    break;
                
                } else {

                    //
                    //  Release the spinlock to let the cancel routine gain it and finish
                    //  its action
                    //  

                    KeReleaseSpinLock( &VolDo->OverflowQueueSpinLock, SavedIrql );
                    KeAcquireSpinLock( &VolDo->OverflowQueueSpinLock, &SavedIrql );
                    Entry = NULL;
                }
            } //  endwhile

            KeReleaseSpinLock( &VolDo->OverflowQueueSpinLock, SavedIrql );

            //
            //  There wasn't an entry, break out of the loop and return to
            //  the Ex Worker thread.
            //

            if ( Entry == NULL ) {

                break;
            }

            if (VolDo->OverflowQueueCount < OVERFLOW_QUEUE_LIMIT) {
                KeSetEvent( &VolDo->OverflowQueueEvent, IO_NO_INCREMENT, FALSE );
            }

            //
            //  set wait to TRUE, and loop.
            //

            LogFileFullCount = 0;
            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
            continue;

        } else {

            break;
        }
    }

    //
    //  Decrement the PostedRequestCount.
    //

    if (VolDo) {

        ExInterlockedAddUlong( &VolDo->PostedRequestCount,
                               0xffffffff,
                               &VolDo->OverflowQueueSpinLock );
    }

    return;
}

VOID
NtfsPostSpecial (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN POST_SPECIAL_CALLOUT PostSpecialCallout,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine posts a special request to a worker thread.  The function
    to be called is passed in.  The Vcb is referenced to ensure it is not
    deleted while the posted request is excuting.

Arguments:

    Vcb - Volume control block for volume to post to.

    PostSpecialCallout - Function to be called from the worker thread.

    Context - Context point to pass to the function.

Return Value:

    None

--*/

{
    PIRP_CONTEXT NewIrpContext = NULL;

    UNREFERENCED_PARAMETER( IrpContext );

    PAGED_CODE();

    //
    //  Create an IrpContext for use to post the request.
    //

    NtfsInitializeIrpContext( NULL, TRUE, &NewIrpContext );
    NewIrpContext->Vcb = Vcb;

    NewIrpContext->Union.PostSpecialCallout = PostSpecialCallout;
    NewIrpContext->OriginatingIrp = Context;

    //
    //  Updating the CloseCount and SystemFileCloseCount allows the volume
    //  to be locked or dismounted, but the Vcb will not be deleted.  This
    //  routine will only be called with non-zero close counts so it is ok
    //  to increment theses counts.
    //

    ASSERT( Vcb->CloseCount > 0 );
    InterlockedIncrement( &Vcb->CloseCount );
    InterlockedIncrement( &Vcb->SystemFileCloseCount );

    ExInitializeWorkItem( &NewIrpContext->WorkQueueItem,
                          NtfsSpecialDispatch,
                          NewIrpContext );

    //
    //  Determine if the scavenger is already running.
    //

    ExAcquireFastMutexUnsafe( &NtfsScavengerLock );

    if (NtfsScavengerRunning) {

        //
        //  Add this item to the scavanger work list.
        //

        NewIrpContext->WorkQueueItem.List.Flink = NULL;

        if (NtfsScavengerWorkList == NULL) {

            NtfsScavengerWorkList = NewIrpContext;
        } else {
            PIRP_CONTEXT WorkIrpContext;

            WorkIrpContext = NtfsScavengerWorkList;

            while (WorkIrpContext->WorkQueueItem.List.Flink != NULL) {
                WorkIrpContext = (PIRP_CONTEXT)
                            WorkIrpContext->WorkQueueItem.List.Flink;
            }

            WorkIrpContext->WorkQueueItem.List.Flink = (PLIST_ENTRY)
                                                            NewIrpContext;
        }

    } else {

        //
        //  Start a worker thread to do scavenger work.
        //

        ExQueueWorkItem( &NewIrpContext->WorkQueueItem, DelayedWorkQueue );
        NtfsScavengerRunning = TRUE;
    }

    ExReleaseFastMutexUnsafe( &NtfsScavengerLock);
}


VOID
NtfsSpecialDispatch (
    PVOID Context
    )

/*++

Routine Description:

    This routine is called when a special operation needs to be posted.
    It is called indirectly by NtfsPostSpecial.  It is assumes that the
    Vcb is protected from going away by incrementing the volemue close
    counts for a file.  If this routine fails nothing is done except
    to clean up the Vcb.  This routine also handles issues log file full
    and can't wait.

    The function to be called is stored in the PostSpecialCallout field
    of the Irp Context, and the context is stored int he OriginatingIrp.
    Both fields are zeroed before the the callout function is called.

Arguments:

    Context - Supplies a pointer to an IrpContext.

Return Value:

--*/

{
    PVCB Vcb;
    PIRP_CONTEXT IrpContext = Context;
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;
    POST_SPECIAL_CALLOUT PostSpecialCallout;
    PVOID SpecialContext;
    ULONG LogFileFullCount;
    BOOLEAN Retry;

    PAGED_CODE();

    FsRtlEnterFileSystem();

    do {

        Vcb = IrpContext->Vcb;
        LogFileFullCount = 0;

        //
        //  Capture the funciton pointer and context before using the IrpContext.
        //

        PostSpecialCallout = IrpContext->Union.PostSpecialCallout;
        SpecialContext = IrpContext->OriginatingIrp;
        IrpContext->Union.PostSpecialCallout = NULL;
        IrpContext->OriginatingIrp = NULL;

        ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, TRUE, TRUE );
        ASSERT( ThreadTopLevelContext == &TopLevelContext );
        ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));
        ASSERT( FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_FROM_POOL ));

        //
        //  Initialize the thread top level structure, if needed.
        //

        ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
        NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

        //
        //  Don't let this IrpContext be deleted.
        //

        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_PERSISTENT );

        do {

            Retry = FALSE;

            try {

                //
                //  See if we failed due to a log file full condition, and
                //  if so, then do a clean volume checkpoint if we are the
                //  first ones to get there.  If we see a different Lsn and do
                //  not do the checkpoint, the worst that can happen is that we
                //  will fail again if the log file is still full.
                //

                if (IrpContext->LastRestartArea.QuadPart != 0) {

                    NtfsCheckpointForLogFileFull( IrpContext );

                    if (++LogFileFullCount >= 2) {

                        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_EXCESS_LOG_FULL );
                    }
                }

                //
                //  Call the requested function.
                //

                ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));
                PostSpecialCallout( IrpContext, SpecialContext );

                NtfsCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

            } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

                NTSTATUS ExceptionCode;

                ExceptionCode = GetExceptionCode();
                ExceptionCode = NtfsProcessException( IrpContext, NULL, ExceptionCode );

                if ((ExceptionCode == STATUS_CANT_WAIT) ||
                    (ExceptionCode == STATUS_LOG_FILE_FULL)) {

                    Retry = TRUE;
                }
            }

        } while (Retry);

        //
        //  Ok to let this IrpContext be deleted.
        //

        ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_PERSISTENT );

        //
        //  At this point regardless of the status the volume needs to
        //  be cleaned up and the IrpContext freed.
        //  Dereference the Vcb and check to see if it needs to be deleted.
        //  since this call might raise wrap it with a try/execpt.
        //

        try {

            //
            //  Acquire the volume exclusive so the counts can be
            //  updated.
            //

            ASSERT( FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ));
            NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );

            InterlockedDecrement( &Vcb->SystemFileCloseCount );
            InterlockedDecrement( &Vcb->CloseCount );

            NtfsReleaseVcb( IrpContext, Vcb );

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            ASSERT( FsRtlIsNtstatusExpected( GetExceptionCode() ) );
        }

        //
        //  Free the irp context.
        //

        NtfsCleanupIrpContext( IrpContext, TRUE );

        //
        //  See if there is more work on the scavenger list.
        //

        ExAcquireFastMutexUnsafe( &NtfsScavengerLock );

        ASSERT( NtfsScavengerRunning );

        IrpContext = NtfsScavengerWorkList;

        if (IrpContext != NULL) {

            //
            //  Remove the entry from the list.
            //

            NtfsScavengerWorkList = (PIRP_CONTEXT) IrpContext->WorkQueueItem.List.Flink;
            IrpContext->WorkQueueItem.List.Flink = NULL;

        } else {

            NtfsScavengerRunning = FALSE;

        }

        ExReleaseFastMutexUnsafe( &NtfsScavengerLock );

    } while ( IrpContext != NULL );

    FsRtlExitFileSystem();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\index.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Index.h

Abstract:

    This module contains definitions common to only indexsup.c and viewsup.c

Author:

    Tom Miller      [TomM]          8-Jan-1996

Revision History:

--*/

//
//  Define all private support routines.  Documentation of routine interface
//  is with the routine itself.
//

VOID
NtfsGrowLookupStack (
    IN PSCB Scb,
    IN OUT PINDEX_CONTEXT IndexContext,
    IN PINDEX_LOOKUP_STACK *Sp
    );

BOOLEAN
ReadIndexBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG IndexBlock,
    IN BOOLEAN Reread,
    OUT PINDEX_LOOKUP_STACK Sp
    );

PINDEX_ALLOCATION_BUFFER
GetIndexBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    OUT PINDEX_LOOKUP_STACK Sp,
    OUT PLONGLONG EndOfValidData
    );

VOID
DeleteIndexBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN VCN IndexBlockNumber
    );

VOID
FindFirstIndexEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PVOID Value,
    IN OUT PINDEX_CONTEXT IndexContext
    );

BOOLEAN
FindNextIndexEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PVOID Value,
    IN BOOLEAN ValueContainsWildcards,
    IN BOOLEAN IgnoreCase,
    IN OUT PINDEX_CONTEXT IndexContext,
    IN BOOLEAN NextFlag,
    OUT PBOOLEAN MustRestart OPTIONAL
    );

PATTRIBUTE_RECORD_HEADER
FindMoveableIndexRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN OUT PINDEX_CONTEXT IndexContext
    );

PINDEX_ENTRY
BinarySearchIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PINDEX_LOOKUP_STACK Sp,
    IN PVOID Value
    );

BOOLEAN
AddToIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PINDEX_ENTRY InsertIndexEntry,
    IN OUT PINDEX_CONTEXT IndexContext,
    OUT PQUICK_INDEX QuickIndex OPTIONAL,
    IN BOOLEAN FindRoot
    );

VOID
InsertSimpleRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PINDEX_ENTRY InsertIndexEntry,
    IN OUT PINDEX_CONTEXT IndexContext
    );

VOID
PushIndexRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN OUT PINDEX_CONTEXT IndexContext
    );

VOID
InsertSimpleAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PINDEX_ENTRY InsertIndexEntry,
    IN PINDEX_LOOKUP_STACK Sp,
    OUT PQUICK_INDEX QuickIndex OPTIONAL
    );

PINDEX_ENTRY
InsertWithBufferSplit (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PINDEX_ENTRY InsertIndexEntry,
    IN OUT PINDEX_CONTEXT IndexContext,
    OUT PQUICK_INDEX QuickIndex OPTIONAL
    );

VOID
DeleteFromIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN OUT PINDEX_CONTEXT IndexContext
    );

VOID
DeleteSimple (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PINDEX_ENTRY IndexEntry,
    IN OUT PINDEX_CONTEXT IndexContext
    );

VOID
PruneIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN OUT PINDEX_CONTEXT IndexContext,
    OUT PINDEX_ENTRY *DeleteEntry
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\fstiosup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    FstIoSup.c

Abstract:

    This module implements the fast I/O routines for Ntfs.

Author:

    Tom Miller      [TomM]          16-May-96

Revision History:

--*/

#include "NtfsProc.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCopyReadA)
#pragma alloc_text(PAGE, NtfsCopyWriteA)
#pragma alloc_text(PAGE, NtfsMdlReadA)
#pragma alloc_text(PAGE, NtfsPrepareMdlWriteA)
#pragma alloc_text(PAGE, NtfsWaitForIoAtEof)
#pragma alloc_text(PAGE, NtfsFinishIoAtEof)
#endif

#ifdef NTFS_RWC_DEBUG

PRWC_HISTORY_ENTRY
NtfsGetHistoryEntry (
    IN PSCB Scb
    );
#endif


BOOLEAN
NtfsCopyReadA (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine does a fast cached read bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy read
    of a cached file object.  For a complete description of the arguments
    see CcCopyRead.

Arguments:

    FileObject - Pointer to the file object being read.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Wait - FALSE if caller may not block, TRUE otherwise

    Buffer - Pointer to output buffer to which data should be copied.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

Return Value:

    FALSE - if Wait was supplied as FALSE and the data was not delivered, or
        if there is an I/O error.

    TRUE - if the data is being delivered

--*/

{
    PNTFS_ADVANCED_FCB_HEADER Header;
    LARGE_INTEGER BeyondLastByte;
    PDEVICE_OBJECT targetVdo;
#ifdef COMPRESS_ON_WIRE
    PCOMPRESSION_SYNC CompressionSync = NULL;
#endif
    BOOLEAN WasDataRead = TRUE;
    ULONG PageCount = ADDRESS_AND_SIZE_TO_SPAN_PAGES( FileOffset->QuadPart, Length );
    BOOLEAN DoingIoAtEof = FALSE;

    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

#ifdef NTFS_NO_FASTIO
    UNREFERENCED_PARAMETER( FileObject );
    UNREFERENCED_PARAMETER( FileOffset );
    UNREFERENCED_PARAMETER( Length );
    UNREFERENCED_PARAMETER( Wait );
    UNREFERENCED_PARAMETER( LockKey );
    UNREFERENCED_PARAMETER( Buffer );
    UNREFERENCED_PARAMETER( IoStatus );

    return FALSE;
#endif

    //
    //  Don't take the fast io path if someone is already active in this thread.
    //

    if (IoGetTopLevelIrp() != NULL) {

        return FALSE;
    }

    //
    //  Special case a read of zero length
    //

    if (Length != 0) {

        //
        //  Get a real pointer to the common fcb header. Check for overflow.
        //

        if (MAXLONGLONG - FileOffset->QuadPart < (LONGLONG)Length) {

            return FALSE;
        }

        BeyondLastByte.QuadPart = FileOffset->QuadPart + (LONGLONG)Length;
        Header = (PNTFS_ADVANCED_FCB_HEADER)FileObject->FsContext;

        //
        //  Enter the file system
        //

        FsRtlEnterFileSystem();

        //
        //  Make our best guess on whether we need the file exclusive
        //  or shared.  Note that we do not check FileOffset->HighPart
        //  until below.
        //

        if (Wait) {
            FsRtlIncrementCcFastReadWait();
        } else {
            FsRtlIncrementCcFastReadNoWait();
        }
        
        if ((Header->PagingIoResource == NULL) ||
            !ExAcquireResourceSharedLite(Header->PagingIoResource, Wait)) {
            FsRtlIncrementCcFastReadResourceMiss();
            WasDataRead = FALSE;
            goto Done2;
        }

        //
        //  Now synchronize with the FsRtl Header
        //

        NtfsAcquireFsrtlHeader( (PSCB)Header );
        
        //
        //  Now see if we are reading beyond ValidDataLength.  We have to
        //  do it now so that our reads are not nooped.
        //

        if (BeyondLastByte.QuadPart > Header->ValidDataLength.QuadPart) {

            //
            //  We must serialize with anyone else doing I/O at beyond
            //  ValidDataLength, and then remember if we need to declare
            //  when we are done.
            //

            DoingIoAtEof = !FlagOn( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE ) ||
                           NtfsWaitForIoAtEof( Header, FileOffset, Length );

            //
            //  Set the Flag if we are in fact beyond ValidDataLength.
            //

            if (DoingIoAtEof) {
                SetFlag( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE );

#if (DBG || defined( NTFS_FREE_ASSERTS ))
                ((PSCB) Header)->IoAtEofThread = (PERESOURCE_THREAD) ExGetCurrentResourceThread();

            } else {

                ASSERT( ((PSCB) Header)->IoAtEofThread != (PERESOURCE_THREAD) ExGetCurrentResourceThread() );
#endif
            }
        }

        NtfsReleaseFsrtlHeader( (PSCB)Header );
        
        //
        //  Now that the File is acquired shared, we can safely test if it
        //  is really cached and if we can do fast i/o and if not, then
        //  release the fcb and return.
        //

        if ((FileObject->PrivateCacheMap == NULL) ||
            (Header->IsFastIoPossible == FastIoIsNotPossible)) {

            FsRtlIncrementCcFastReadNotPossible();

            WasDataRead = FALSE;
            goto Done;
        }

        //
        //  Check if fast I/O is questionable and if so then go ask the
        //  file system the answer
        //

        if (Header->IsFastIoPossible == FastIoIsQuestionable) {

            PFAST_IO_DISPATCH FastIoDispatch;

            targetVdo = IoGetRelatedDeviceObject( FileObject );
            FastIoDispatch = targetVdo->DriverObject->FastIoDispatch;


            //
            //  All file systems that set "Is Questionable" had better support
            // fast I/O
            //

            ASSERT(FastIoDispatch != NULL);
            ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

            //
            //  Call the file system to check for fast I/O.  If the answer is
            //  anything other than GoForIt then we cannot take the fast I/O
            //  path.
            //

            if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                        FileOffset,
                                                        Length,
                                                        Wait,
                                                        LockKey,
                                                        TRUE, // read operation
                                                        IoStatus,
                                                        targetVdo )) {

                //
                //  Fast I/O is not possible so release the Fcb and return.
                //

                FsRtlIncrementCcFastReadNotPossible();
                
                WasDataRead = FALSE;
                goto Done;
            }
        }

        //
        //  Check for read past file size.
        //

        if ( BeyondLastByte.QuadPart > Header->FileSize.QuadPart ) {

            if ( FileOffset->QuadPart >= Header->FileSize.QuadPart ) {
                IoStatus->Status = STATUS_END_OF_FILE;
                IoStatus->Information = 0;

                goto Done;
            }

            Length = (ULONG)( Header->FileSize.QuadPart - FileOffset->QuadPart );
        }

        //
        //  We can do fast i/o so call the cc routine to do the work and then
        //  release the fcb when we've done.  If for whatever reason the
        //  copy read fails, then return FALSE to our caller.
        //
        //  Also mark this as the top level "Irp" so that lower file system
        //  levels will not attempt a pop-up
        //

        IoSetTopLevelIrp( (PIRP) FSRTL_FAST_IO_TOP_LEVEL_IRP );
                          
        try {

            //
            //  If there is a compressed section, then synchronize with that cache.
            //

            IoStatus->Status = STATUS_SUCCESS;

#ifdef  COMPRESS_ON_WIRE

            //
            //  If there is a compressed section, then we have to synchronize with
            //  the data out there.  Note the FileObjectC better also be there, or else
            //  we would have made the fast I/O not possible.
            //

            if (((PSCB)Header)->NonpagedScb->SegmentObjectC.DataSectionObject != NULL) {

                LONGLONG LocalOffset = FileOffset->QuadPart;
                ULONG LocalLength;
                ULONG LengthLeft = Length;

                ASSERT(Header->FileObjectC != NULL);

                //
                //  If we are doing DoingIoAtEof then take the long path.  Otherwise a recursive
                //  flush will try to reacquire DoingIoAtEof and deadlock.
                //

                if (DoingIoAtEof) {

                    WasDataRead = FALSE;

                } else {

                    do {

                        ULONG ViewOffset;

                        //
                        //  Calculate length left in view.
                        //

                        ViewOffset = ((ULONG) LocalOffset & (VACB_MAPPING_GRANULARITY - 1));
                        LocalLength = LengthLeft;

                        if (LocalLength > VACB_MAPPING_GRANULARITY - ViewOffset) {
                            LocalLength = VACB_MAPPING_GRANULARITY - ViewOffset;
                        }

                        //
                        //  Trim the read so we don't inadvertently go beyond the end of the 
                        //  view because of the MM read ahead.
                        //

                        PageCount = ADDRESS_AND_SIZE_TO_SPAN_PAGES(((PVOID)(ULONG_PTR)((ULONG)LocalOffset)), LocalLength);

                        if (LocalLength > (VACB_MAPPING_GRANULARITY - ((PageCount - 1) * PAGE_SIZE) - ViewOffset)) {

#ifdef NTFS_RWC_DEBUG
                            {
                                PRWC_HISTORY_ENTRY NextBuffer;

                                NextBuffer = NtfsGetHistoryEntry( (PSCB) Header );

                                NextBuffer->Operation = TrimCopyRead;
                                NextBuffer->Information = PageCount;
                                NextBuffer->FileOffset = (ULONG) LocalOffset;
                                NextBuffer->Length = (ULONG) LocalLength;
                            }
#endif
                            LocalLength = (VACB_MAPPING_GRANULARITY - ((PageCount - 1) * PAGE_SIZE) - ViewOffset);
                            PageCount = ADDRESS_AND_SIZE_TO_SPAN_PAGES(((PVOID)(ULONG_PTR)((ULONG)LocalOffset)), LocalLength);

                            ASSERT( LocalLength <= (VACB_MAPPING_GRANULARITY - ((PageCount - 1) * PAGE_SIZE) - ViewOffset) );
                        }

                        IoStatus->Status = NtfsSynchronizeUncompressedIo( (PSCB)Header,
                                                                          &LocalOffset,
                                                                          LocalLength,
                                                                          FALSE,
                                                                          &CompressionSync );

                        if (NT_SUCCESS(IoStatus->Status)) {

                            if (Wait && ((BeyondLastByte.HighPart | Header->FileSize.HighPart) == 0)) {

                                CcFastCopyRead( FileObject,
                                                (ULONG)LocalOffset,
                                                LocalLength,
                                                PageCount,
                                                Buffer,
                                                IoStatus );

                                ASSERT( (IoStatus->Status == STATUS_END_OF_FILE) ||
                                        ((FileOffset->LowPart + IoStatus->Information) <= Header->FileSize.LowPart));

                            } else {

                                WasDataRead = CcCopyRead( FileObject,
                                                     (PLARGE_INTEGER)&LocalOffset,
                                                     LocalLength,
                                                     Wait,
                                                     Buffer,
                                                     IoStatus );

                                ASSERT( !WasDataRead || (IoStatus->Status == STATUS_END_OF_FILE) ||
                                        ((LocalOffset + (LONG_PTR) IoStatus->Information) <= Header->FileSize.QuadPart));
                            }

                            LocalOffset += LocalLength;
                            LengthLeft -= LocalLength;
                            Buffer = Add2Ptr( Buffer, LocalLength );
                        }

                    } while ((LengthLeft != 0) && WasDataRead && NT_SUCCESS(IoStatus->Status));

                    //
                    //  Remember the full amount of the read.
                    //

                    if (WasDataRead) {

                        IoStatus->Information = Length;
                    }
                }

            } else {

#endif

                if (Wait && ((BeyondLastByte.HighPart | Header->FileSize.HighPart) == 0)) {

                    CcFastCopyRead( FileObject,
                                    FileOffset->LowPart,
                                    Length,
                                    PageCount,
                                    Buffer,
                                    IoStatus );

                    ASSERT( (IoStatus->Status == STATUS_END_OF_FILE) ||
                            ((FileOffset->LowPart + IoStatus->Information) <= Header->FileSize.LowPart));

                } else {

                    WasDataRead = CcCopyRead( FileObject,
                                         FileOffset,
                                         Length,
                                         Wait,
                                         Buffer,
                                         IoStatus );

                    ASSERT( !WasDataRead || (IoStatus->Status == STATUS_END_OF_FILE) ||
                            ((FileOffset->QuadPart + (LONG_PTR) IoStatus->Information) <= Header->FileSize.QuadPart));
                }

#ifdef  COMPRESS_ON_WIRE
            }
#endif

            FileObject->Flags |= FO_FILE_FAST_IO_READ;

            if (WasDataRead) {

                FileObject->CurrentByteOffset.QuadPart = FileOffset->QuadPart + IoStatus->Information;
            }

        } except( FsRtlIsNtstatusExpected(GetExceptionCode())
                                        ? EXCEPTION_EXECUTE_HANDLER
                                        : EXCEPTION_CONTINUE_SEARCH ) {

            WasDataRead = FALSE;
        }

        IoSetTopLevelIrp( NULL );
        
#ifdef  COMPRESS_ON_WIRE
        if (CompressionSync != NULL) {
            NtfsReleaseCompressionSync( CompressionSync );
        }
#endif

Done:

        if (DoingIoAtEof) {
            FsRtlUnlockFsRtlHeader( Header );
        }
        ExReleaseResourceLite( Header->PagingIoResource );

Done2:

        FsRtlExitFileSystem();

    } else {

        //
        //  A zero length transfer was requested.
        //

        IoStatus->Status = STATUS_SUCCESS;
        IoStatus->Information = 0;
    }

    return WasDataRead;
}


BOOLEAN
NtfsCopyWriteA (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine does a fast cached write bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy write
    of a cached file object.  For a complete description of the arguments
    see CcCopyWrite.

Arguments:

    FileObject - Pointer to the file object being write.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Wait - FALSE if caller may not block, TRUE otherwise

    Buffer - Pointer to output buffer to which data should be copied.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

Return Value:

    FALSE - if Wait was supplied as FALSE and the data was not delivered, or
        if there is an I/O error.

    TRUE - if the data is being delivered

--*/

{
    PNTFS_ADVANCED_FCB_HEADER Header;
    LARGE_INTEGER Offset;
    LARGE_INTEGER NewFileSize;
    LARGE_INTEGER OldFileSize;
#ifdef COMPRESS_ON_WIRE
    PCOMPRESSION_SYNC CompressionSync = NULL;
#endif
    PDEVICE_OBJECT targetVdo = IoGetRelatedDeviceObject( FileObject );
    PFAST_IO_DISPATCH FastIoDispatch = targetVdo->DriverObject->FastIoDispatch;
    ULONG DoingIoAtEof = FALSE;
    BOOLEAN WasDataWritten = TRUE;

#ifdef SYSCACHE_DEBUG
    PSCB Scb = (PSCB) FileObject->FsContext;
#endif

    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

#ifdef NTFS_NO_FASTIO
    UNREFERENCED_PARAMETER( FileObject );
    UNREFERENCED_PARAMETER( FileOffset );
    UNREFERENCED_PARAMETER( Length );
    UNREFERENCED_PARAMETER( Wait );
    UNREFERENCED_PARAMETER( LockKey );
    UNREFERENCED_PARAMETER( Buffer );
    UNREFERENCED_PARAMETER( IoStatus );

    return FALSE;
#endif

    //
    //  Don't take the fast io path if someone is already active in this thread.
    //

    if (IoGetTopLevelIrp() != NULL) {

        return FALSE;
    }

    //
    //  Get a real pointer to the common fcb header
    //

    Header = (PNTFS_ADVANCED_FCB_HEADER)FileObject->FsContext;

    //
    //  Do we need to verify the volume?  If so, we must go to the file
    //  system.  Also return FALSE if FileObject is write through, the
    //  File System must do that.
    //

    if (!FlagOn( FileObject->Flags, FO_WRITE_THROUGH ) &&
        CcCanIWrite( FileObject, Length, Wait, FALSE ) &&
        CcCopyWriteWontFlush( FileObject, FileOffset, Length ) &&
        (Header->PagingIoResource != NULL)) {

        //
        //  Assume our transfer will work
        //

        IoStatus->Status = STATUS_SUCCESS;
        IoStatus->Information = Length;

        //
        //  Special case the zero byte length
        //

        if (Length != 0) {

            //
            //  Enter the file system
            //

            FsRtlEnterFileSystem();

            //
            //  Split into separate paths for increased performance.  First
            //  we have the faster path which only supports Wait == TRUE and
            //  32 bits.  We will make an unsafe test on whether the fast path
            //  is ok, then just return FALSE later if we were wrong.  This
            //  should virtually never happen.
            //
            //  IMPORTANT NOTE: It is very important that any changes mad to
            //                  this path also be applied to the 64-bit path
            //                  which is the else of this test!
            //

            NewFileSize.QuadPart = FileOffset->QuadPart + Length;
            Offset = *FileOffset;

            if (Wait && (Header->AllocationSize.HighPart == 0)) {

                //
                //  Prevent truncates by acquiring paging I/O
                //

                ExAcquireResourceSharedLite( Header->PagingIoResource, TRUE );

                //
                //  Now synchronize with the FsRtl Header
                //

                NtfsAcquireFsrtlHeader( (PSCB) Header );
                
                //
                //  Now see if we will change FileSize.  We have to do it now
                //  so that our reads are not nooped.
                //

                if ((FileOffset->HighPart < 0) || (NewFileSize.LowPart > Header->ValidDataLength.LowPart)) {

                    //
                    //  We can change FileSize and ValidDataLength if either, no one
                    //  else is now, or we are still extending after waiting.
                    //

                    DoingIoAtEof = !FlagOn( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE ) ||
                                   NtfsWaitForIoAtEof( Header, FileOffset, Length );

                    //
                    //  Set the Flag if we are changing FileSize or ValidDataLength,
                    //  and save current values.
                    //

                    if (DoingIoAtEof) {

                        SetFlag( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE );

#if (DBG || defined( NTFS_FREE_ASSERTS ))
                        ((PSCB) Header)->IoAtEofThread = (PERESOURCE_THREAD) ExGetCurrentResourceThread();
#endif

                        //
                        //  Now that we are synchronized for end of file cases,
                        //  we can calculate the real offset for this transfer and
                        //  the new file size (if we succeed).
                        //


                        if ((FileOffset->HighPart < 0)) {
                            Offset = Header->FileSize;
                        }

                        //
                        //  Above we allowed any negative .HighPart for the 32-bit path,
                        //  but now we are counting on the I/O system to have thrown
                        //  any negative number other than write to end of file.
                        //

                        ASSERT(Offset.HighPart >= 0);

                        //
                        //  Now calculate the new FileSize and see if we wrapped the
                        //  32-bit boundary.
                        //

                        NewFileSize.QuadPart = Offset.QuadPart + Length;

                        //
                        //  Update Filesize now so that we do not truncate reads.
                        //

                        OldFileSize.QuadPart = Header->FileSize.QuadPart;
                        if (NewFileSize.QuadPart > Header->FileSize.QuadPart) {

                            //
                            //  If we are beyond AllocationSize, make sure we will
                            //  ErrOut below, and don't modify FileSize now!
                            //

                            if (NewFileSize.QuadPart > Header->AllocationSize.QuadPart) {
                                NewFileSize.QuadPart = (LONGLONG)0x7FFFFFFFFFFFFFFF;
                            } else {
                                Header->FileSize.QuadPart = NewFileSize.QuadPart;
                            }
                        }

#if (DBG || defined( NTFS_FREE_ASSERTS ))
                    } else {

                        ASSERT( ((PSCB) Header)->IoAtEofThread != (PERESOURCE_THREAD) ExGetCurrentResourceThread() );
#endif
                    }
                }

                NtfsReleaseFsrtlHeader( (PSCB) Header );
                
                //
                //  Now that the File is acquired shared, we can safely test
                //  if it is really cached and if we can do fast i/o and we
                //  do not have to extend. If not then release the fcb and
                //  return.
                //
                //  Get out if we have too much to zero.  This case is not important
                //  for performance, and a file system supporting sparseness may have
                //  a way to do this more efficiently.
                //
                //  If there is a compressed stream and we are DoingIoAtEof, then get
                //  out because we could deadlock on a recursive flush from the synchronize.
                //

                if ((FileObject->PrivateCacheMap == NULL) ||
                    (Header->IsFastIoPossible == FastIoIsNotPossible) ||
/* Remove? */       (NewFileSize.LowPart > Header->AllocationSize.QuadPart) ||
                    (Offset.LowPart >= (Header->ValidDataLength.LowPart + 0x2000)) ||
                    (NewFileSize.HighPart != 0) ||
#ifdef  COMPRESS_ON_WIRE
                    ((((PSCB)Header)->NonpagedScb->SegmentObjectC.DataSectionObject != NULL) && 
                     DoingIoAtEof)
#else
                    FALSE
#endif                    
                    ) {

                    goto ErrOut;
                }
                
                //
                //  Check if fast I/O is questionable and if so then go ask
                //  the file system the answer
                //

                if (Header->IsFastIoPossible == FastIoIsQuestionable) {

                    targetVdo = IoGetRelatedDeviceObject( FileObject );
                    FastIoDispatch = targetVdo->DriverObject->FastIoDispatch;

                    //
                    //  All file system then set "Is Questionable" had better
                    //  support fast I/O
                    //

                    ASSERT(FastIoDispatch != NULL);
                    ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

                    //
                    //  Call the file system to check for fast I/O.  If the
                    //  answer is anything other than GoForIt then we cannot
                    //  take the fast I/O path.
                    //

                    if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                                &Offset,
                                                                Length,
                                                                TRUE,
                                                                LockKey,
                                                                FALSE, // write operation
                                                                IoStatus,
                                                                targetVdo )) {

                        //
                        //  Fast I/O is not possible so cleanup and return.
                        //

                        goto ErrOut;
                    }
                }

                //
                //  Update both caches with EOF.
                //
    
                if (DoingIoAtEof) {
                    NtfsSetBothCacheSizes( FileObject,
                                           (PCC_FILE_SIZES)&Header->AllocationSize,
                                           (PSCB)Header );
                }
    
                //
                //  We can do fast i/o so call the cc routine to do the work
                //  and then release the fcb when we've done.  If for whatever
                //  reason the copy write fails, then return FALSE to our
                //  caller.
                //
                //  Also mark this as the top level "Irp" so that lower file
                //  system levels will not attempt a pop-up
                //

                IoSetTopLevelIrp( (PIRP) FSRTL_FAST_IO_TOP_LEVEL_IRP );

                try {

                    //
                    //  See if we have to do some zeroing
                    //

                    if (Offset.LowPart > Header->ValidDataLength.LowPart) {

                        CcZeroData( FileObject,
                                    &Header->ValidDataLength,
                                    &Offset,
                                    TRUE );
#ifdef SYSCACHE_DEBUG
                        if (ScbIsBeingLogged( Scb )) {
                            FsRtlLogSyscacheEvent( Scb, SCE_ZERO_FST, 0, Header->ValidDataLength.QuadPart, Offset.QuadPart - Header->ValidDataLength.QuadPart, 0 );
                        }
#endif
                    }


#ifdef  COMPRESS_ON_WIRE
                    //
                    //  If there is a compressed section, update its FileSize here
                    //

                    if ((Header->FileObjectC != NULL) && DoingIoAtEof) {
                        CcSetFileSizes( Header->FileObjectC, (PCC_FILE_SIZES)&Header->AllocationSize );
                    }
#endif

                    //
                    //  If there is a compressed section, then synchronize with that cache.
                    //

                    IoStatus->Status = STATUS_SUCCESS;

                    //
                    //  If there is a compressed section, then we have to synchronize with
                    //  the data out there.  Note the FileObjectC better also be there, or else
                    //  we would have made the fast I/O not possible.
                    //

                    WasDataWritten = FALSE;

#ifdef  COMPRESS_ON_WIRE
                    if (((PSCB)Header)->NonpagedScb->SegmentObjectC.DataSectionObject != NULL) {

                        LONGLONG LocalOffset = Offset.QuadPart;
                        ULONG LocalLength;
                        ULONG LengthLeft = Length;

                        ASSERT( Header->FileObjectC != NULL );

                        do {

                             //
                             //  Calculate length left in view.
                             //

                             LocalLength = LengthLeft;
                             if (LocalLength > (ULONG)(VACB_MAPPING_GRANULARITY - (LocalOffset & (VACB_MAPPING_GRANULARITY - 1)))) {
                                 LocalLength = (ULONG)(VACB_MAPPING_GRANULARITY - (LocalOffset & (VACB_MAPPING_GRANULARITY - 1)));
                             }

                             IoStatus->Status = NtfsSynchronizeUncompressedIo( (PSCB)Header,
                                                                               &LocalOffset,
                                                                               LocalLength,
                                                                               TRUE,
                                                                               &CompressionSync );

                             if (NT_SUCCESS(IoStatus->Status)) {

                                 WasDataWritten = TRUE;

                                 CcFastCopyWrite( FileObject,
                                                  (ULONG)LocalOffset,
                                                  LocalLength,
                                                  Buffer );

                                 LocalOffset += LocalLength;
                                 LengthLeft -= LocalLength;
                                 Buffer = Add2Ptr( Buffer, LocalLength );
                             }

                        } while ((LengthLeft != 0) && NT_SUCCESS( IoStatus->Status ));

                    } else {

#endif

                        CcFastCopyWrite( FileObject,
                                         Offset.LowPart,
                                         Length,
                                         Buffer );
                        WasDataWritten = TRUE;

#ifdef  COMPRESS_ON_WIRE
                    }
#endif

                } except( FsRtlIsNtstatusExpected(GetExceptionCode())
                                                ? EXCEPTION_EXECUTE_HANDLER
                                                : EXCEPTION_CONTINUE_SEARCH ) {

                    WasDataWritten = FALSE;
                }

                IoSetTopLevelIrp( NULL );
                
#ifdef COMPRESS_ON_WIRE
                if (CompressionSync != NULL) {
                    NtfsReleaseCompressionSync( CompressionSync );
                }
#endif

                //
                //  If we succeeded, see if we have to update FileSize or
                //  ValidDataLength.
                //

                if (WasDataWritten) {

                    //
                    //  Set this handle as having modified the file and update
                    //  the current file position pointer
                    //

                    FileObject->Flags |= FO_FILE_MODIFIED;
                    FileObject->CurrentByteOffset.QuadPart = Offset.QuadPart + Length;

                    if (DoingIoAtEof) {

                        CC_FILE_SIZES CcFileSizes;

                        //
                        //  Make sure Cc knows the current FileSize, as set above,
                        //  (we may not have changed it).  Update ValidDataLength
                        //  and finish EOF.
                        //

                        FileObject->Flags |= FO_FILE_SIZE_CHANGED;

                        NtfsAcquireFsrtlHeader( (PSCB) Header );
                        CcGetFileSizePointer(FileObject)->LowPart = Header->FileSize.LowPart;
                        Header->ValidDataLength = NewFileSize;

#ifdef SYSCACHE_DEBUG
                        if (ScbIsBeingLogged( Scb )) {
                            FsRtlLogSyscacheEvent( Scb, SCE_VDL_CHANGE, SCE_FLAG_WRITE | SCE_FLAG_FASTIO, 0, 0, NewFileSize.QuadPart );
                        }
#endif

                        CcFileSizes = *(PCC_FILE_SIZES)&Header->AllocationSize;
                        NtfsVerifySizes( Header );
                        NtfsFinishIoAtEof( Header );
                        NtfsReleaseFsrtlHeader( (PSCB) Header );

#ifdef  COMPRESS_ON_WIRE

                        //
                        //  Update the CompressedCache with ValidDataLength.
                        //
            
                        if (Header->FileObjectC != NULL) {
                            CcSetFileSizes( Header->FileObjectC, &CcFileSizes );
                        }
#endif
                    }

                    goto Done1;
                }

            //
            //  Here is the 64-bit or no-wait path.
            //

            } else {

                //
                //  Prevent truncates by acquiring paging I/O
                //

                WasDataWritten = ExAcquireResourceSharedLite( Header->PagingIoResource, Wait );
                if (!WasDataWritten) {
                    goto Done2;
                }

                //
                //  Now synchronize with the FsRtl Header
                //

                NtfsAcquireFsrtlHeader( (PSCB) Header );
                
                //
                //  Now see if we will change FileSize.  We have to do it now
                //  so that our reads are not nooped.
                //

                if ((FileOffset->QuadPart < 0) || (NewFileSize.QuadPart > Header->ValidDataLength.QuadPart)) {

                    //
                    //  We can change FileSize and ValidDataLength if either, no one
                    //  else is now, or we are still extending after waiting.
                    //

                    DoingIoAtEof = !FlagOn( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE ) ||
                                   NtfsWaitForIoAtEof( Header, FileOffset, Length );

                    //
                    //  Set the Flag if we are changing FileSize or ValidDataLength,
                    //  and save current values.
                    //

                    if (DoingIoAtEof) {

                        SetFlag( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE );

#if (DBG || defined( NTFS_FREE_ASSERTS ))
                        ((PSCB) Header)->IoAtEofThread = (PERESOURCE_THREAD) ExGetCurrentResourceThread();
#endif

                        //
                        //  Now that we are synchronized for end of file cases,
                        //  we can calculate the real offset for this transfer and
                        //  the new file size (if we succeed).
                        //

                        if ((FileOffset->QuadPart < 0)) {
                            Offset = Header->FileSize;
                        }

                        //
                        //  Now calculate the new FileSize and see if we wrapped the
                        //  32-bit boundary.
                        //

                        NewFileSize.QuadPart = Offset.QuadPart + Length;

                        //
                        //  Update Filesize now so that we do not truncate reads.
                        //

                        OldFileSize.QuadPart = Header->FileSize.QuadPart;
                        if (NewFileSize.QuadPart > Header->FileSize.QuadPart) {

                            //
                            //  If we are beyond AllocationSize, make sure we will
                            //  ErrOut below, and don't modify FileSize now!
                            //

                            if (NewFileSize.QuadPart > Header->AllocationSize.QuadPart) {
                                NewFileSize.QuadPart = (LONGLONG)0x7FFFFFFFFFFFFFFF;
                            } else {
                                Header->FileSize.QuadPart = NewFileSize.QuadPart;
                            }
                        }

#if (DBG || defined( NTFS_FREE_ASSERTS ))
                    } else {

                        ASSERT( ((PSCB) Header)->IoAtEofThread != (PERESOURCE_THREAD) ExGetCurrentResourceThread() );
#endif
                    }
                }

                NtfsReleaseFsrtlHeader( (PSCB) Header );
                
                //
                //  Now that the File is acquired shared, we can safely test
                //  if it is really cached and if we can do fast i/o and we
                //  do not have to extend. If not then release the fcb and
                //  return.
                //
                //  Get out if we are about to zero too much as well, as commented above.
                //
                //  If there is a compressed stream and we are DoingIoAtEof, then get
                //  out because we could deadlock on a recursive flush from the synchronize.
                //

                if ((FileObject->PrivateCacheMap == NULL) ||
                    (Header->IsFastIoPossible == FastIoIsNotPossible) ||
/* Remove? */       (NewFileSize.QuadPart > Header->AllocationSize.QuadPart) ||
                    (Offset.QuadPart >= (Header->ValidDataLength.QuadPart + 0x2000)) ||
#ifdef  COMPRESS_ON_WIRE
                    ((((PSCB)Header)->NonpagedScb->SegmentObjectC.DataSectionObject != NULL) && 
                     DoingIoAtEof)
#else
                    FALSE
#endif
                    ) {

                    goto ErrOut;
                }

                //
                //  Check if fast I/O is questionable and if so then go ask
                //  the file system the answer
                //

                if (Header->IsFastIoPossible == FastIoIsQuestionable) {

                    targetVdo = IoGetRelatedDeviceObject( FileObject );
                    FastIoDispatch = targetVdo->DriverObject->FastIoDispatch;

                    //
                    //  All file system then set "Is Questionable" had better
                    //  support fast I/O
                    //

                    ASSERT(FastIoDispatch != NULL);
                    ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

                    //
                    //  Call the file system to check for fast I/O.  If the
                    //  answer is anything other than GoForIt then we cannot
                    //  take the fast I/O path.
                    //

                    if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                                &Offset,
                                                                Length,
                                                                Wait,
                                                                LockKey,
                                                                FALSE, // write operation
                                                                IoStatus,
                                                                targetVdo )) {

                        //
                        //  Fast I/O is not possible so cleanup and return.
                        //

                        goto ErrOut;
                    }
                }

                //
                //  Update both caches with EOF.
                //
    
                if (DoingIoAtEof) {
                    NtfsSetBothCacheSizes( FileObject,
                                           (PCC_FILE_SIZES)&Header->AllocationSize,
                                           (PSCB)Header );
                }
    
                //
                //  We can do fast i/o so call the cc routine to do the work
                //  and then release the fcb when we've done.  If for whatever
                //  reason the copy write fails, then return FALSE to our
                //  caller.
                //
                //  Also mark this as the top level "Irp" so that lower file
                //  system levels will not attempt a pop-up
                //

                IoSetTopLevelIrp( (PIRP) FSRTL_FAST_IO_TOP_LEVEL_IRP );
                
                try {

                    //
                    //  See if we have to do some zeroing
                    //

                    if ( Offset.QuadPart > Header->ValidDataLength.QuadPart ) {

#ifdef SYSCACHE_DEBUG
                        if (ScbIsBeingLogged( Scb )) {
                            FsRtlLogSyscacheEvent( Scb, SCE_ZERO_FST, SCE_FLAG_ASYNC, Header->ValidDataLength.QuadPart, Offset.QuadPart, 0 );
                        }
#endif

                        WasDataWritten = CcZeroData( FileObject,
                                             &Header->ValidDataLength,
                                             &Offset,
                                             Wait );
                    }

                    if (WasDataWritten) {

                        //
                        //  If there is a compressed section, update its FileSize here
                        //

#ifdef  COMPRESS_ON_WIRE
                        if ((Header->FileObjectC != NULL) && DoingIoAtEof) {
                            CcSetFileSizes( Header->FileObjectC, (PCC_FILE_SIZES)&Header->AllocationSize );
                        }
#endif

                        //
                        //  If there is a compressed section, then synchronize with that cache.
                        //

                        IoStatus->Status = STATUS_SUCCESS;

                        //
                        //  If there is a compressed section, then we have to synchronize with
                        //  the data out there.  Note the FileObjectC better also be there, or else
                        //  we would have made the fast I/O not possible.
                        //

                        WasDataWritten = FALSE;

#ifdef  COMPRESS_ON_WIRE
                        if (((PSCB)Header)->NonpagedScb->SegmentObjectC.DataSectionObject != NULL) {

                            LONGLONG LocalOffset = Offset.QuadPart;
                            ULONG LocalLength;
                            ULONG LengthLeft = Length;

                            ASSERT(Header->FileObjectC != NULL);

                            do {

                                //
                                //  Calculate length left in view.
                                //

                                LocalLength = LengthLeft;
                                if (LocalLength > (ULONG)(VACB_MAPPING_GRANULARITY - (LocalOffset & (VACB_MAPPING_GRANULARITY - 1)))) {
                                    LocalLength = (ULONG)(VACB_MAPPING_GRANULARITY - (LocalOffset & (VACB_MAPPING_GRANULARITY - 1)));
                                }

                                IoStatus->Status = NtfsSynchronizeUncompressedIo( (PSCB)Header,
                                                                                  &LocalOffset,
                                                                                  LocalLength,
                                                                                  TRUE,
                                                                                  &CompressionSync );

                                
                                if (NT_SUCCESS(IoStatus->Status)) {

                                    WasDataWritten = CcCopyWrite( FileObject,
                                                          (PLARGE_INTEGER)&LocalOffset,
                                                          LocalLength,
                                                          Wait,
                                                          Buffer );

                                    LocalOffset += LocalLength;
                                    LengthLeft -= LocalLength;
                                    Buffer = Add2Ptr( Buffer, LocalLength );
                                }

                            } while ((LengthLeft != 0) && WasDataWritten && NT_SUCCESS(IoStatus->Status));

                        } else {

#endif

                            WasDataWritten = CcCopyWrite( FileObject,
                                                  &Offset,
                                                  Length,
                                                  Wait,
                                                  Buffer );
                        }

#ifdef  COMPRESS_ON_WIRE
                    }
#endif

                } except( FsRtlIsNtstatusExpected(GetExceptionCode())
                                                ? EXCEPTION_EXECUTE_HANDLER
                                                : EXCEPTION_CONTINUE_SEARCH ) {

                    WasDataWritten = FALSE;
                }

                IoSetTopLevelIrp( NULL );
                
#ifdef COMPRESS_ON_WIRE
                if (CompressionSync != NULL) {
                    NtfsReleaseCompressionSync( CompressionSync );
                }
#endif

                //
                //  If we succeeded, see if we have to update FileSize ValidDataLength.
                //

                if (WasDataWritten) {

                    //
                    //  Set this handle as having modified the file and update
                    //  the current file position pointer
                    //

                    FileObject->Flags |= FO_FILE_MODIFIED;
                    FileObject->CurrentByteOffset.QuadPart = Offset.QuadPart + Length;

                    if (DoingIoAtEof) {

                        CC_FILE_SIZES CcFileSizes;
            
                        //
                        //  Make sure Cc knows the current FileSize, as set above,
                        //  (we may not have changed it).  Update ValidDataLength
                        //  and finish EOF.
                        //

                        NtfsAcquireFsrtlHeader( (PSCB) Header );
                        CcGetFileSizePointer(FileObject)->QuadPart = Header->FileSize.QuadPart;
                        FileObject->Flags |= FO_FILE_SIZE_CHANGED;
                        Header->ValidDataLength = NewFileSize;
                        CcFileSizes = *(PCC_FILE_SIZES)&Header->AllocationSize;
                        NtfsVerifySizes( Header );
                        NtfsFinishIoAtEof( Header );
                        NtfsReleaseFsrtlHeader( (PSCB) Header );

#ifdef  COMPRESS_ON_WIRE
                        //
                        //  Update the CompressedCache with ValidDataLength.
                        //
            
                        if (Header->FileObjectC != NULL) {
                            CcSetFileSizes( Header->FileObjectC, &CcFileSizes );
                        }
#endif
                    }

                    goto Done1;
                }
            }

ErrOut:

            WasDataWritten = FALSE;
            if (DoingIoAtEof) {
                NtfsAcquireFsrtlHeader( (PSCB) Header ); 
#ifdef  COMPRESS_ON_WIRE
                if (Header->FileObjectC != NULL) {
                    *CcGetFileSizePointer(Header->FileObjectC) = OldFileSize;
                }
#endif
                Header->FileSize = OldFileSize;
                NtfsFinishIoAtEof( Header );
                NtfsReleaseFsrtlHeader( (PSCB) Header );
            }

Done1: 
            ExReleaseResourceLite( Header->PagingIoResource );

Done2:
            FsRtlExitFileSystem();
        }

    } else {

        //
        //  We could not do the I/O now.
        //

        WasDataWritten = FALSE;
    }

    return WasDataWritten;
}


BOOLEAN
NtfsMdlReadA (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine does a fast cached mdl read bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy read
    of a cached file object.  For a complete description of the arguments
    see CcMdlRead.

Arguments:

    FileObject - Pointer to the file object being read.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    MdlChain - On output it returns a pointer to an MDL chain describing
        the desired data.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

Return Value:

    FALSE - if the data was not delivered, or if there is an I/O error.

    TRUE - if the data is being delivered

--*/

{
    PNTFS_ADVANCED_FCB_HEADER Header;
#ifdef COMPRESS_ON_WIRE
    PCOMPRESSION_SYNC CompressionSync = NULL;
#endif
    BOOLEAN DoingIoAtEof = FALSE;
    BOOLEAN WasDataRead = TRUE;
    LARGE_INTEGER BeyondLastByte;

    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

    //
    //  Special case a read of zero length
    //

    if (Length == 0) {

        IoStatus->Status = STATUS_SUCCESS;
        IoStatus->Information = 0;

    //
    //  Get a real pointer to the common fcb header
    //

    } else {

        BeyondLastByte.QuadPart = FileOffset->QuadPart + (LONGLONG)Length;

        //
        //  Overflows should've been handled by the caller.
        //

        ASSERT(MAXLONGLONG - FileOffset->QuadPart >= (LONGLONG)Length);
        
        Header = (PNTFS_ADVANCED_FCB_HEADER)FileObject->FsContext;

        //
        //  Enter the file system
        //

        FsRtlEnterFileSystem();

#ifdef _WIN64
        //
        //  The following should work for either 64 or 32 bits.
        //  Remove the 32 bit-only version in the #else clause
        //  after NT2K ships.
        //

        **((PULONG *)&CcFastMdlReadWait) += 1;
#else
        *(PULONG)CcFastMdlReadWait += 1;
#endif

        //
        //  Acquired shared on the common fcb header
        //

        if (Header->PagingIoResource == NULL) {
            WasDataRead = FALSE;
            goto Done2;
        }

        (VOID)ExAcquireResourceSharedLite( Header->PagingIoResource, TRUE );

        //
        //  Now synchronize with the FsRtl Header
        //

        NtfsAcquireFsrtlHeader( (PSCB) Header );
        
        //
        //  Now see if we are reading beyond ValidDataLength.  We have to
        //  do it now so that our reads are not nooped.
        //

        if (BeyondLastByte.QuadPart > Header->ValidDataLength.QuadPart) {

            //
            //  We must serialize with anyone else doing I/O at beyond
            //  ValidDataLength, and then remember if we need to declare
            //  when we are done.
            //

            DoingIoAtEof = !FlagOn( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE ) ||
                           NtfsWaitForIoAtEof( Header, FileOffset, Length );

            //
            //  Set the Flag if we are in fact beyond ValidDataLength.
            //

            if (DoingIoAtEof) {
                SetFlag( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE );

#if (DBG || defined( NTFS_FREE_ASSERTS ))
                ((PSCB) Header)->IoAtEofThread = (PERESOURCE_THREAD) ExGetCurrentResourceThread();

            } else {

                ASSERT( ((PSCB) Header)->IoAtEofThread != (PERESOURCE_THREAD) ExGetCurrentResourceThread() );
#endif
            }
        }

        NtfsReleaseFsrtlHeader( (PSCB) Header );
        
        //
        //  Now that the File is acquired shared, we can safely test if it is
        //  really cached and if we can do fast i/o and if not
        //  then release the fcb and return.
        //

        if ((FileObject->PrivateCacheMap == NULL) ||
            (Header->IsFastIoPossible == FastIoIsNotPossible)) {

            WasDataRead = FALSE;
            goto Done;
        }

        //
        //  Check if fast I/O is questionable and if so then go ask the file system
        //  the answer
        //

        if (Header->IsFastIoPossible == FastIoIsQuestionable) {

            PFAST_IO_DISPATCH FastIoDispatch;

            FastIoDispatch = IoGetRelatedDeviceObject( FileObject )->DriverObject->FastIoDispatch;

            //
            //  All file system then set "Is Questionable" had better support fast I/O
            //

            ASSERT(FastIoDispatch != NULL);
            ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

            //
            //  Call the file system to check for fast I/O.  If the answer is anything
            //  other than GoForIt then we cannot take the fast I/O path.
            //

            if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                        FileOffset,
                                                        Length,
                                                        TRUE,
                                                        LockKey,
                                                        TRUE, // read operation
                                                        IoStatus,
                                                        IoGetRelatedDeviceObject( FileObject ) )) {

                //
                //  Fast I/O is not possible so release the Fcb and return.
                //

                WasDataRead = FALSE;
                goto Done;
            }
        }

        //
        //  Check for read past file size.
        //

        if ( BeyondLastByte.QuadPart > Header->FileSize.QuadPart ) {

            if ( FileOffset->QuadPart >= Header->FileSize.QuadPart ) {

                IoStatus->Status = STATUS_END_OF_FILE;
                IoStatus->Information = 0;

                goto Done;
            }

            Length = (ULONG)( Header->FileSize.QuadPart - FileOffset->QuadPart );
        }

        //
        //  We can do fast i/o so call the cc routine to do the work and then
        //  release the fcb when we've done.  If for whatever reason the
        //  mdl read fails, then return FALSE to our caller.
        //
        //
        //  Also mark this as the top level "Irp" so that lower file system levels
        //  will not attempt a pop-up
        //

        IoSetTopLevelIrp( (PIRP) FSRTL_FAST_IO_TOP_LEVEL_IRP );
        
        try {

            //
            //  If there is a compressed section, then synchronize with that cache.
            //

            IoStatus->Status = STATUS_SUCCESS;

            //
            //  If there is a compressed section, then we have to synchronize with
            //  the data out there.  Note the FileObjectC better also be there, or else
            //  we would have made the fast I/O not possible.
            //

            WasDataRead = FALSE;

#ifdef  COMPRESS_ON_WIRE
            if (((PSCB)Header)->NonpagedScb->SegmentObjectC.DataSectionObject != NULL) {

                LONGLONG LocalOffset = FileOffset->QuadPart;
                ULONG LengthRemaining = Length;
                ULONG LocalLength;

                ASSERT(Header->FileObjectC != NULL);

                //
                //  If we are doing DoingIoAtEof then take the long path.  Otherwise a recursive
                //  flush will try to reacquire DoingIoAtEof and deadlock.
                //

                if (DoingIoAtEof) {

                    WasDataRead = FALSE;

                } else {

                    do {

                        //
                        //  Calculate length left in view.
                        //

                        LocalLength = LengthRemaining;
                        if (LocalLength > (ULONG)(VACB_MAPPING_GRANULARITY - (LocalOffset & (VACB_MAPPING_GRANULARITY - 1)))) {
                            LocalLength = (ULONG)(VACB_MAPPING_GRANULARITY - (LocalOffset & (VACB_MAPPING_GRANULARITY - 1)));
                        }

                        IoStatus->Status = NtfsSynchronizeUncompressedIo( (PSCB)Header,
                                                                          &LocalOffset,
                                                                          LocalLength,
                                                                          FALSE,
                                                                          &CompressionSync );

                        if (NT_SUCCESS(IoStatus->Status)) {

#ifdef NTFS_RWCMP_TRACE
                            if (NtfsCompressionTrace && IsSyscache(Header)) {
                                DbgPrint("CcMdlRead(F): FO = %08lx, Len = %08lx\n", (ULONG)LocalOffset, LocalLength );
                            }
#endif
                        
                            CcMdlRead( FileObject,
                                       (PLARGE_INTEGER)&LocalOffset,
                                       LocalLength,
                                       MdlChain,
                                       IoStatus );

                            LocalOffset += LocalLength;
                            LengthRemaining -= LocalLength;
                        }

                    } while ((LengthRemaining != 0) && NT_SUCCESS(IoStatus->Status));

                    //
                    //  Store final return byte count.
                    //
    
                    if (NT_SUCCESS( IoStatus->Status )) {
                        IoStatus->Information = Length;
                    }
                }

            } else {

#endif

#ifdef NTFS_RWCMP_TRACE
                if (NtfsCompressionTrace && IsSyscache(Header)) {
                    DbgPrint("CcMdlRead(F): FO = %08lx, Len = %08lx\n", FileOffset->LowPart, Length );
                }
#endif

                CcMdlRead( FileObject, FileOffset, Length, MdlChain, IoStatus );

                WasDataRead = TRUE;

#ifdef  COMPRESS_ON_WIRE
            }
#endif

            FileObject->Flags |= FO_FILE_FAST_IO_READ;

        } except( FsRtlIsNtstatusExpected(GetExceptionCode())
                                       ? EXCEPTION_EXECUTE_HANDLER
                                       : EXCEPTION_CONTINUE_SEARCH ) {

            WasDataRead = FALSE;
        }

        IoSetTopLevelIrp( NULL );
        
#ifdef COMPRESS_ON_WIRE
        if (CompressionSync != NULL) {
            NtfsReleaseCompressionSync( CompressionSync );
        }
#endif

    Done: NOTHING;

        if (DoingIoAtEof) {
            FsRtlUnlockFsRtlHeader( Header );
        }
        ExReleaseResourceLite( Header->PagingIoResource );

    Done2: NOTHING;
        FsRtlExitFileSystem();
    }

    return WasDataRead;
}


BOOLEAN
NtfsPrepareMdlWriteA (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine does a fast cached mdl read bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy read
    of a cached file object.  For a complete description of the arguments
    see CcMdlRead.

Arguments:

    FileObject - Pointer to the file object being read.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    MdlChain - On output it returns a pointer to an MDL chain describing
        the desired data.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

Return Value:

    FALSE - if the data was not written, or if there is an I/O error.

    TRUE - if the data is being written

--*/

{
    PNTFS_ADVANCED_FCB_HEADER Header;
    LARGE_INTEGER Offset, NewFileSize;
    LARGE_INTEGER OldFileSize;
#ifdef COMPRESS_ON_WIRE
    PCOMPRESSION_SYNC CompressionSync = NULL;
#endif
    ULONG DoingIoAtEof = FALSE;
    BOOLEAN WasDataWritten = TRUE;

    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

    //
    //  Get a real pointer to the common fcb header
    //

    Header = (PNTFS_ADVANCED_FCB_HEADER)FileObject->FsContext;

    //
    //  Do we need to verify the volume?  If so, we must go to the file
    //  system.  Also return FALSE if FileObject is write through, the
    //  File System must do that.
    //

    if (CcCanIWrite( FileObject, Length, TRUE, FALSE ) &&
        !FlagOn(FileObject->Flags, FO_WRITE_THROUGH) &&
        CcCopyWriteWontFlush(FileObject, FileOffset, Length) &&
        (Header->PagingIoResource != NULL)) {

        //
        //  Assume our transfer will work
        //

        IoStatus->Status = STATUS_SUCCESS;

        //
        //  Special case the zero byte length
        //

        if (Length != 0) {

            //
            //  Enter the file system
            //

            FsRtlEnterFileSystem();

            //
            //  Make our best guess on whether we need the file exclusive or
            //  shared.
            //

            NewFileSize.QuadPart = FileOffset->QuadPart + (LONGLONG)Length;
            Offset = *FileOffset;

            //
            //  Prevent truncates by acquiring paging I/O
            //

            ExAcquireResourceSharedLite( Header->PagingIoResource, TRUE );

            //
            //  Now synchronize with the FsRtl Header
            //

            NtfsAcquireFsrtlHeader( (PSCB) Header );
            
            //
            //  Now see if we will change FileSize.  We have to do it now
            //  so that our reads are not nooped.
            //

            if ((FileOffset->QuadPart < 0) || (NewFileSize.QuadPart > Header->ValidDataLength.QuadPart)) {

                //
                //  We can change FileSize and ValidDataLength if either, no one
                //  else is now, or we are still extending after waiting.
                //

                DoingIoAtEof = !FlagOn( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE ) ||
                               NtfsWaitForIoAtEof( Header, FileOffset, Length );

                //
                //  Set the Flag if we are changing FileSize or ValidDataLength,
                //  and save current values.
                //

                if (DoingIoAtEof) {

                    SetFlag( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE );

#if (DBG || defined( NTFS_FREE_ASSERTS ))
                    ((PSCB) Header)->IoAtEofThread = (PERESOURCE_THREAD) ExGetCurrentResourceThread();
#endif
                    //
                    //  Now that we are synchronized for end of file cases,
                    //  we can calculate the real offset for this transfer and
                    //  the new file size (if we succeed).
                    //

                    if ((FileOffset->QuadPart < 0)) {
                        Offset = Header->FileSize;
                    }

                    //
                    //  Now calculate the new FileSize and see if we wrapped the
                    //  32-bit boundary.
                    //

                    NewFileSize.QuadPart = Offset.QuadPart + Length;

                    //
                    //  Update Filesize now so that we do not truncate reads.
                    //

                    OldFileSize.QuadPart = Header->FileSize.QuadPart;
                    if (NewFileSize.QuadPart > Header->FileSize.QuadPart) {

                        //
                        //  If we are beyond AllocationSize, make sure we will
                        //  ErrOut below, and don't modify FileSize now!
                        //

                        if (NewFileSize.QuadPart > Header->AllocationSize.QuadPart) {
                            NewFileSize.QuadPart = (LONGLONG)0x7FFFFFFFFFFFFFFF;
                        } else {
                            Header->FileSize.QuadPart = NewFileSize.QuadPart;
                        }
                    }

#if (DBG || defined( NTFS_FREE_ASSERTS ))
                } else {

                    ASSERT( ((PSCB) Header)->IoAtEofThread != (PERESOURCE_THREAD) ExGetCurrentResourceThread() );
#endif
                }
            }

            NtfsReleaseFsrtlHeader( (PSCB) Header );

            //
            //  Now that the File is acquired shared, we can safely test
            //  if it is really cached and if we can do fast i/o and we
            //  do not have to extend. If not then release the fcb and
            //  return.
            //
            //  Get out if we are about to zero too much as well, as commented above.
            //

            if ((FileObject->PrivateCacheMap == NULL) ||
                (Header->IsFastIoPossible == FastIoIsNotPossible) ||
/* Remove? */   (NewFileSize.QuadPart > Header->AllocationSize.QuadPart) ||
                (Offset.QuadPart >= (Header->ValidDataLength.QuadPart + 0x2000))) {

                goto ErrOut;
            }

            //
            //  Check if fast I/O is questionable and if so then go ask the file system
            //  the answer
            //

            if (Header->IsFastIoPossible == FastIoIsQuestionable) {

                PFAST_IO_DISPATCH FastIoDispatch = IoGetRelatedDeviceObject( FileObject )->DriverObject->FastIoDispatch;

                //
                //  All file system then set "Is Questionable" had better support fast I/O
                //

                ASSERT(FastIoDispatch != NULL);
                ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

                //
                //  Call the file system to check for fast I/O.  If the answer is anything
                //  other than GoForIt then we cannot take the fast I/O path.
                //

                if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                            &Offset,
                                                            Length,
                                                            TRUE,
                                                            LockKey,
                                                            FALSE, // write operation
                                                            IoStatus,
                                                            IoGetRelatedDeviceObject( FileObject ) )) {

                    //
                    //  Fast I/O is not possible so release the Fcb and return.
                    //

                    goto ErrOut;
                }
            }

            //
            //  Update both caches with EOF.
            //

            if (DoingIoAtEof) {
                NtfsSetBothCacheSizes( FileObject,
                                       (PCC_FILE_SIZES)&Header->AllocationSize,
                                       (PSCB)Header );
            }

            //
            //  We can do fast i/o so call the cc routine to do the work and then
            //  release the fcb when we've done.  If for whatever reason the
            //  copy write fails, then return FALSE to our caller.
            //
            //
            //  Also mark this as the top level "Irp" so that lower file system levels
            //  will not attempt a pop-up
            //

            IoSetTopLevelIrp( (PIRP) FSRTL_FAST_IO_TOP_LEVEL_IRP );
            
            try {

                //
                //  See if we have to do some zeroing
                //

                if ( Offset.QuadPart > Header->ValidDataLength.QuadPart ) {

                    WasDataWritten = CcZeroData( FileObject,
                                         &Header->ValidDataLength,
                                         &Offset,
                                         TRUE );
                }

                if (WasDataWritten) {

#ifdef  COMPRESS_ON_WIRE

                    //
                    //  If there is a compressed section, update its FileSize here
                    //

                    if ((Header->FileObjectC != NULL) && DoingIoAtEof) {
                        CcSetFileSizes( Header->FileObjectC, (PCC_FILE_SIZES)&Header->AllocationSize );
                    }
#endif

                    //
                    //  If there is a compressed section, then synchronize with that cache.
                    //

                    IoStatus->Status = STATUS_SUCCESS;

                    //
                    //  If there is a compressed section, then we have to synchronize with
                    //  the data out there.  Note the FileObjectC better also be there, or else
                    //  we would have made the fast I/O not possible.
                    //

#ifdef  COMPRESS_ON_WIRE
                    if (((PSCB)Header)->NonpagedScb->SegmentObjectC.DataSectionObject != NULL) {

                        LONGLONG LocalOffset = Offset.QuadPart;
                        ULONG LocalLength;
                        ULONG LengthLeft = Length;

                        ASSERT(Header->FileObjectC != NULL);

                        //
                        //  If we are doing DoingIoAtEof then take the long path.  Otherwise a recursive
                        //  flush will try to reacquire DoingIoAtEof and deadlock.
                        //
        
                        if (DoingIoAtEof) {
        
                            WasDataWritten = FALSE;
        
                        } else {
        
                            do {

                                //
                                //  Calculate length left in view.
                                //

                                LocalLength = LengthLeft;
                                if (LocalLength > (ULONG)(VACB_MAPPING_GRANULARITY - (LocalOffset & (VACB_MAPPING_GRANULARITY - 1)))) {
                                    LocalLength = (ULONG)(VACB_MAPPING_GRANULARITY - (LocalOffset & (VACB_MAPPING_GRANULARITY - 1)));
                                }

                                IoStatus->Status = NtfsSynchronizeUncompressedIo( (PSCB)Header,
                                                                                  &LocalOffset,
                                                                                  LocalLength,
                                                                                  TRUE,
                                                                                  &CompressionSync );

                                if (NT_SUCCESS(IoStatus->Status)) {

#ifdef NTFS_RWCMP_TRACE
                                    if (NtfsCompressionTrace && IsSyscache(Header)) {
                                        DbgPrint("CcMdlWrite(F): FO = %08lx, Len = %08lx\n", (ULONG)LocalOffset, LocalLength );
                                    }
#endif

                                    CcPrepareMdlWrite( FileObject,
                                                       (PLARGE_INTEGER)&LocalOffset,
                                                       LocalLength,
                                                       MdlChain,
                                                       IoStatus );

                                    LocalOffset += LocalLength;
                                    LengthLeft -= LocalLength;
                                }

                            } while ((LengthLeft != 0) && NT_SUCCESS(IoStatus->Status));
                            WasDataWritten = TRUE;
                        }

                    } else {

#endif

#ifdef NTFS_RWCMP_TRACE
                        if (NtfsCompressionTrace && IsSyscache(Header)) {
                            DbgPrint("CcMdlWrite(F): FO = %08lx, Len = %08lx\n", Offset.LowPart, Length );
                        }
#endif

                        CcPrepareMdlWrite( FileObject, &Offset, Length, MdlChain, IoStatus );
                        WasDataWritten = TRUE;
                    }

#ifdef  COMPRESS_ON_WIRE
                }
#endif

            } except( FsRtlIsNtstatusExpected(GetExceptionCode())
                                            ? EXCEPTION_EXECUTE_HANDLER
                                            : EXCEPTION_CONTINUE_SEARCH ) {

                WasDataWritten = FALSE;
            }

            IoSetTopLevelIrp( NULL );
            
#ifdef COMPRESS_ON_WIRE
            if (CompressionSync != NULL) {
                NtfsReleaseCompressionSync( CompressionSync );
            }
#endif

            //
            //  If we succeeded, see if we have to update FileSize ValidDataLength.
            //

            if (WasDataWritten) {

                //
                //  Set this handle as having modified the file
                //

                FileObject->Flags |= FO_FILE_MODIFIED;
                IoStatus->Information = Length;

                if (DoingIoAtEof) {

                    CC_FILE_SIZES CcFileSizes;
        
                    //
                    //  Make sure Cc knows the current FileSize, as set above,
                    //  (we may not have changed it).  Update ValidDataLength
                    //  and finish EOF.
                    //

                    NtfsAcquireFsrtlHeader( (PSCB) Header );
                    CcGetFileSizePointer(FileObject)->QuadPart = Header->FileSize.QuadPart;
                    FileObject->Flags |= FO_FILE_SIZE_CHANGED;
                    Header->ValidDataLength = NewFileSize;
                    CcFileSizes = *(PCC_FILE_SIZES)&Header->AllocationSize;
                    NtfsVerifySizes( Header );
                    NtfsFinishIoAtEof( Header );
                    NtfsReleaseFsrtlHeader( (PSCB) Header );
                    
#ifdef  COMPRESS_ON_WIRE

                    //
                    //  Update the CompressedCache with ValidDataLength.
                    //
        
                    if (Header->FileObjectC != NULL) {
                        CcSetFileSizes( Header->FileObjectC, &CcFileSizes );
                    }
#endif
                }

                goto Done1;
            }

        ErrOut: NOTHING;

            WasDataWritten = FALSE;
            if (DoingIoAtEof) {
                NtfsAcquireFsrtlHeader( (PSCB) Header );
#ifdef  COMPRESS_ON_WIRE
                if (Header->FileObjectC != NULL) {
                    *CcGetFileSizePointer(Header->FileObjectC) = OldFileSize;
                }
#endif
                Header->FileSize = OldFileSize;
                NtfsFinishIoAtEof( Header );
                NtfsReleaseFsrtlHeader( (PSCB) Header );
            }

        Done1: ExReleaseResourceLite( Header->PagingIoResource );

            FsRtlExitFileSystem();
        }

    } else {

        //
        // We could not do the I/O now.
        //

        WasDataWritten = FALSE;
    }

    return WasDataWritten;
}


BOOLEAN
NtfsWaitForIoAtEof (
    IN PNTFS_ADVANCED_FCB_HEADER Header,
    IN OUT PLARGE_INTEGER FileOffset,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine may be called while synchronized for cached write, to
    test for a possible Eof update, and return with a status if Eof is
    being updated and with the previous FileSize to restore on error.
    All updates to Eof are serialized by waiting in this routine.  If
    this routine returns TRUE, then NtfsFinishIoAtEof must be called.

    This routine must be called while synchronized with the FsRtl header.

Arguments:

    Header - Pointer to the FsRtl header for the file

    FileOffset - Pointer to FileOffset for the intended write

    Length - Length for the intended write

    EofWaitBlock - Uninitialized structure used only to serialize Eof updates

Return Value:

    FALSE - If the write does not extend Eof (OldFileSize not returned)
    TRUE - If the write does extend Eof OldFileSize returned and caller
           must eventually call NtfsFinishIoAtEof

--*/

{
    EOF_WAIT_BLOCK EofWaitBlock;

    PAGED_CODE();
    
    ASSERT( Header->FileSize.QuadPart >= Header->ValidDataLength.QuadPart );

    //
    //  Initialize the event and queue our block
    //

    KeInitializeEvent( &EofWaitBlock.Event, NotificationEvent, FALSE );
    InsertTailList( Header->PendingEofAdvances, &EofWaitBlock.EofWaitLinks );

    //
    //  Free the mutex and wait
    //

    NtfsReleaseFsrtlHeader( (PSCB) Header );
    
    KeWaitForSingleObject( &EofWaitBlock.Event,
                           Executive,
                           KernelMode,
                           FALSE,
                           (PLARGE_INTEGER)NULL);

    //
    //  Now, resynchronize and get on with it.
    //

    NtfsAcquireFsrtlHeader( (PSCB) Header );

#if (DBG || defined( NTFS_FREE_ASSERTS ))
    ASSERT( ((PSCB) Header)->IoAtEofThread == NULL );
    ((PSCB) Header)->IoAtEofThread = (PERESOURCE_THREAD) ExGetCurrentResourceThread();
#endif

    //
    //  Now we have to check again, and actually catch the case
    //  where we are no longer extending!
    //

    if ((FileOffset->QuadPart >= 0) &&
        ((FileOffset->QuadPart + Length) <= Header->ValidDataLength.QuadPart)) {

        NtfsFinishIoAtEof( Header );

        return FALSE;
    }

    return TRUE;
}


VOID
NtfsFinishIoAtEof (
    IN PNTFS_ADVANCED_FCB_HEADER Header
    )

/*++

Routine Description:

    This routine must be called if NtfsWaitForIoAtEof returned
    TRUE, or we otherwise set EOF_ADVANCE_ACTIVE.

    This routine must be called while synchronized with the FsRtl header.

Arguments:

    Header - Pointer to the FsRtl header for the file

Return Value:

    None

--*/

{
    PEOF_WAIT_BLOCK EofWaitBlock;

    PAGED_CODE();

#if (DBG || defined( NTFS_FREE_ASSERTS ))
    ((PSCB) Header)->IoAtEofThread = NULL;
#endif

    //
    //  If anyone is waiting, just let them go.
    //

    if (!IsListEmpty(Header->PendingEofAdvances)) {

        EofWaitBlock = (PEOF_WAIT_BLOCK)RemoveHeadList( Header-> PendingEofAdvances );
        KeSetEvent( &EofWaitBlock->Event, 0, FALSE );

    //
    //  Otherwise, show there is no active extender now.
    //

    } else {
        ClearFlag( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\indexsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    IndexSup.c

Abstract:

    This module implements the Index management routines for Ntfs

Author:

    Tom Miller      [TomM]          14-Jul-1991

Revision History:

--*/

#include "NtfsProc.h"
#include "Index.h"

//
//  This constant affects the logic in NtfsRetrieveOtherFileName.
//  If an index is greater than this size, then we retrieve the other
//  name by reading the file record.  The number is arbitrary, but the
//  below value should normally kick in for directories of around 150
//  to 200 files, or fewer if the names are quite large.
//

#define MAX_INDEX_TO_SCAN_FOR_NAMES      (0x10000)

#if DBG
BOOLEAN NtfsIndexChecks = TRUE;
#endif

#if DBG

#define CheckRoot() {                                               \
if (NtfsIndexChecks) {                                              \
    NtfsCheckIndexRoot(Scb->Vcb,                                    \
                       (PINDEX_ROOT)NtfsAttributeValue(Attribute),  \
                       Attribute->Form.Resident.ValueLength);       \
    }                                                               \
}

#define CheckBuffer(IB) {                                           \
if (NtfsIndexChecks) {                                              \
    NtfsCheckIndexBuffer(Scb,                                       \
                         (IB));                                     \
    }                                                               \
}

#else

#define CheckRoot() {NOTHING;}
#define CheckBuffer(IB) {NOTHING;}

#endif

#define BINARY_SEARCH_ENTRIES           (128)

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_INDEXSUP)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('IFtN')

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsReinitializeIndexContext)
#pragma alloc_text(PAGE, NtfsGrowLookupStack)
#pragma alloc_text(PAGE, AddToIndex)
#pragma alloc_text(PAGE, BinarySearchIndex)
#pragma alloc_text(PAGE, DeleteFromIndex)
#pragma alloc_text(PAGE, DeleteIndexBuffer)
#pragma alloc_text(PAGE, DeleteSimple)
#pragma alloc_text(PAGE, FindFirstIndexEntry)
#pragma alloc_text(PAGE, FindMoveableIndexRoot)
#pragma alloc_text(PAGE, FindNextIndexEntry)
#pragma alloc_text(PAGE, GetIndexBuffer)
#pragma alloc_text(PAGE, InsertSimpleAllocation)
#pragma alloc_text(PAGE, InsertSimpleRoot)
#pragma alloc_text(PAGE, InsertWithBufferSplit)
#pragma alloc_text(PAGE, NtfsAddIndexEntry)
#pragma alloc_text(PAGE, NtfsCleanupAfterEnumeration)
#pragma alloc_text(PAGE, NtfsCleanupIndexContext)
#pragma alloc_text(PAGE, NtfsContinueIndexEnumeration)
#pragma alloc_text(PAGE, NtfsCreateIndex)
#pragma alloc_text(PAGE, NtfsDeleteIndex)
#pragma alloc_text(PAGE, NtfsDeleteIndexEntry)
#pragma alloc_text(PAGE, NtfsFindIndexEntry)
#pragma alloc_text(PAGE, NtfsInitializeIndexContext)
#pragma alloc_text(PAGE, NtfsIsIndexEmpty)
#pragma alloc_text(PAGE, NtfsPushIndexRoot)
#pragma alloc_text(PAGE, NtfsRestartDeleteSimpleAllocation)
#pragma alloc_text(PAGE, NtfsRestartDeleteSimpleRoot)
#pragma alloc_text(PAGE, NtfsRestartIndexEnumeration)
#pragma alloc_text(PAGE, NtfsRestartInsertSimpleAllocation)
#pragma alloc_text(PAGE, NtfsRestartInsertSimpleRoot)
#pragma alloc_text(PAGE, NtfsRestartSetIndexBlock)
#pragma alloc_text(PAGE, NtfsRestartUpdateFileName)
#pragma alloc_text(PAGE, NtfsRestartWriteEndOfIndex)
#pragma alloc_text(PAGE, NtfsRetrieveOtherFileName)
#pragma alloc_text(PAGE, NtfsUpdateFileNameInIndex)
#pragma alloc_text(PAGE, NtfsUpdateIndexScbFromAttribute)
#pragma alloc_text(PAGE, PruneIndex)
#pragma alloc_text(PAGE, PushIndexRoot)
#pragma alloc_text(PAGE, ReadIndexBuffer)
#pragma alloc_text(PAGE, NtOfsRestartUpdateDataInIndex)
#endif


VOID
NtfsCreateIndex (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PFCB Fcb,
    IN ATTRIBUTE_TYPE_CODE IndexedAttributeType,
    IN COLLATION_RULE CollationRule,
    IN ULONG BytesPerIndexBuffer,
    IN UCHAR BlocksPerIndexBuffer,
    IN PATTRIBUTE_ENUMERATION_CONTEXT Context OPTIONAL,
    IN USHORT AttributeFlags,
    IN BOOLEAN NewIndex,
    IN BOOLEAN LogIt
    )

/*++

Routine Description:

    This routine may be called to create (or reinitialize) an index
    within a given file over a given attribute.  For example, to create
    a normal directory, an index over the FILE_NAME attribute is created
    within the desired (directory) file.

Arguments:

    Fcb - File in which the index is to be created.

    IndexedAttributeType - Type code of attribute to be indexed.

    CollationRule - Collation Rule for this index.

    BytesPerIndexBuffer - Number of bytes in an index buffer.

    BlocksPerIndexBuffer - Number of contiguous blocks to allocate for each
        index buffer allocated from the index allocation.

    Context - If reinitializing an existing index, this context must
              currently describe the INDEX_ROOT attribute.  Must be
              supplied if NewIndex is FALSE.

    NewIndex - Supplied as FALSE to reinitialize an existing index, or
               TRUE if creating a new index.

    LogIt - May be supplied as FALSE by Create or Cleanup when already
            logging the creation or deletion of an entire file record.
            Otherwise must be specified as TRUE to allow logging.

Return Value:

    None

--*/

{
    UNICODE_STRING AttributeName;
    WCHAR NameBuffer[10];
    ATTRIBUTE_ENUMERATION_CONTEXT LocalContext;
    ULONG idx;

    struct {
        INDEX_ROOT IndexRoot;
        INDEX_ENTRY EndEntry;
    } R;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT( NewIndex || ARGUMENT_PRESENT(Context) );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCreateIndex\n") );
    DebugTrace( 0, Dbg, ("Fcb = %08lx\n", Fcb) );
    DebugTrace( 0, Dbg, ("CollationRule = %08lx\n", CollationRule) );
    DebugTrace( 0, Dbg, ("BytesPerIndexBuffer = %08lx\n", BytesPerIndexBuffer) );
    DebugTrace( 0, Dbg, ("BlocksPerIndexBuffer = %08lx\n", BlocksPerIndexBuffer) );
    DebugTrace( 0, Dbg, ("Context = %08lx\n", Context) );
    DebugTrace( 0, Dbg, ("NewIndex = %02lx\n", NewIndex) );
    DebugTrace( 0, Dbg, ("LogIt = %02lx\n", LogIt) );

    //
    //  First we will initialize the Index Root structure which is the value
    //  of the attribute we need to create.  We initialize it with 0 free bytes,
    //  which means the first insert will have to expand the record
    //

    RtlZeroMemory( &R, sizeof(INDEX_ROOT) + sizeof(INDEX_ENTRY) );

    R.IndexRoot.IndexedAttributeType = IndexedAttributeType;
    R.IndexRoot.CollationRule = CollationRule;
    R.IndexRoot.BytesPerIndexBuffer = BytesPerIndexBuffer;
    R.IndexRoot.BlocksPerIndexBuffer = BlocksPerIndexBuffer;

    R.IndexRoot.IndexHeader.FirstIndexEntry = QuadAlign(sizeof(INDEX_HEADER));
    R.IndexRoot.IndexHeader.FirstFreeByte =
    R.IndexRoot.IndexHeader.BytesAvailable = QuadAlign(sizeof(INDEX_HEADER)) +
                                             QuadAlign(sizeof(INDEX_ENTRY));

    //
    //  Now we need to put in the special End entry.
    //

    R.EndEntry.Length = sizeof(INDEX_ENTRY);
    SetFlag( R.EndEntry.Flags, INDEX_ENTRY_END );

    //
    //  Now calculate the name which will be used to name the Index Root and
    //  Index Allocation attributes for this index.  It is $Ixxx, where "xxx"
    //  is the attribute number being indexed in hex with leading 0's suppressed.
    //

    if (NewIndex) {

        //
        //  First, there are some illegal values for the attribute code being indexed.
        //

        ASSERT( IndexedAttributeType < 0x10000000 );
        ASSERT( IndexedAttributeType != $UNUSED );

        //
        //  Initialize the attribute name.
        //

        NameBuffer[0] = (WCHAR)'$';
        NameBuffer[1] = (WCHAR)'I';
        idx = 2;

        //
        //  Now shift a "marker" into the low order nibble, so we know when to stop
        //  shifting below.
        //

        IndexedAttributeType = (IndexedAttributeType << 4) + 0xF;

        //
        //  Outer loop strips leading 0's
        //

        while (TRUE) {

            if ((IndexedAttributeType & 0xF0000000) == 0) {
                IndexedAttributeType <<= 4;
            } else {

                //
                //  The inner loop forms the name until the marker is in the high
                //  nibble.
                //

                while (IndexedAttributeType != 0xF0000000) {
                    NameBuffer[idx] = (WCHAR)(IndexedAttributeType / 0x10000000 + '0');
                    idx += 1;
                    IndexedAttributeType <<= 4;
                }
                NameBuffer[idx] = UNICODE_NULL;
                break;
            }
        }

        RtlInitUnicodeString( &AttributeName, NameBuffer );

        //
        //  Now, just create the Index Root Attribute.
        //

        Context = &LocalContext;
        NtfsInitializeAttributeContext( Context );
    }

    try {

        if (NewIndex) {

            LONGLONG Delta = NtfsResidentStreamQuota( Fcb->Vcb );

            NtfsConditionallyUpdateQuota( IrpContext,
                                          Fcb,
                                          &Delta,
                                          LogIt,
                                          TRUE );

            NtfsCreateAttributeWithValue( IrpContext,
                                          Fcb,
                                          $INDEX_ROOT,
                                          &AttributeName,
                                          &R,
                                          sizeof( INDEX_ROOT ) + sizeof( INDEX_ENTRY ),
                                          AttributeFlags,
                                          NULL,
                                          LogIt,
                                          Context );
        } else {

            NtfsChangeAttributeValue( IrpContext,
                                      Fcb,
                                      0,
                                      &R,
                                      sizeof( INDEX_ROOT ) + sizeof( INDEX_ENTRY ),
                                      TRUE,
                                      FALSE,
                                      FALSE,
                                      TRUE,
                                      Context );
        }

    } finally {

        DebugUnwind( NtfsCreateIndex );

        if (NewIndex) {
            NtfsCleanupAttributeContext( IrpContext, Context );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsCreateIndex -> VOID\n") );

    return;
}


VOID
NtfsUpdateIndexScbFromAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PATTRIBUTE_RECORD_HEADER IndexRootAttr,
    IN ULONG MustBeFileName
    )

/*++

Routine Description:

    This routine is called when an Index Scb needs initialization.  Typically
    once in the life of the Scb.  It will update the Scb out of the $INDEX_ROOT
    attribute.

Arguments:

    Scb - Supplies the Scb for the index.

    IndexRootAttr - Supplies the $INDEX_ROOT attribute.

    MustBeFileName - Force this to be a filename.  Mark the volume dirty if
        the attribute isn't currently marked as such but let processing continue.
        This is used to continue mounting a volume where either the root directory or
        the $Extend directory is incorrectly marked.

Return Value:

    None

--*/

{
    PINDEX_ROOT IndexRoot = (PINDEX_ROOT) NtfsAttributeValue( IndexRootAttr );
    PAGED_CODE();

    //
    //  Update the Scb out of the attribute.
    //

    SetFlag( Scb->AttributeFlags,
             IndexRootAttr->Flags & (ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_ENCRYPTED) );

    //
    //  Capture the values out of the attribute.  Note that we load the
    //  BytesPerIndexBuffer last as a flag to indicate that the Scb is
    //  loaded.
    //

    Scb->ScbType.Index.CollationRule = IndexRoot->CollationRule;
    Scb->ScbType.Index.BlocksPerIndexBuffer = IndexRoot->BlocksPerIndexBuffer;

    //
    //  Check if we must collate on the file name.
    //

    if (MustBeFileName) {

        Scb->ScbType.Index.AttributeBeingIndexed = $FILE_NAME;

    } else if (!FlagOn( Scb->ScbState, SCB_STATE_VIEW_INDEX )) {

        Scb->ScbType.Index.AttributeBeingIndexed = IndexRoot->IndexedAttributeType;
    }

    //
    //  If the type code is $FILE_NAME then make sure the collation type
    //  is FILE_NAME.
    //

    if (Scb->ScbType.Index.AttributeBeingIndexed == $FILE_NAME) {

        if (IndexRoot->CollationRule != COLLATION_FILE_NAME) {

            ASSERTMSG( "Invalid collation rule", FALSE );
            ASSERT( !FlagOn( Scb->ScbState, SCB_STATE_VIEW_INDEX ));
            NtfsMarkVolumeDirty( IrpContext, Scb->Vcb, TRUE );

            Scb->ScbType.Index.CollationRule = COLLATION_FILE_NAME;
        }
    }

    //
    //  Compute the shift count for this index.
    //

    if (IndexRoot->BytesPerIndexBuffer >= Scb->Vcb->BytesPerCluster) {

        Scb->ScbType.Index.IndexBlockByteShift = (UCHAR) Scb->Vcb->ClusterShift;

    } else {

        Scb->ScbType.Index.IndexBlockByteShift = DEFAULT_INDEX_BLOCK_BYTE_SHIFT;
    }

    Scb->ScbType.Index.BytesPerIndexBuffer = IndexRoot->BytesPerIndexBuffer;

    return;
}


BOOLEAN
NtfsFindIndexEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PVOID Value,
    IN BOOLEAN IgnoreCase,
    OUT PQUICK_INDEX QuickIndex OPTIONAL,
    OUT PBCB *Bcb,
    OUT PINDEX_ENTRY *IndexEntry,
    OUT PINDEX_CONTEXT IndexContext OPTIONAL
    )

/*++

Routine Description:

    This routine may be called to look up a given value in a given index
    and return the file reference of the indexed file record.

Arguments:

    Scb - Supplies the Scb for the index.

    Value - Supplies a pointer to the value to lookup.

    IgnoreCase - For indices with collation rules where character case
                 may be relevant, supplies whether character case is
                 to be ignored.  For example, if supplied as TRUE, then
                 'T' and 't' are treated as equivalent.

    QuickIndex - If specified, supplies a pointer to a quick lookup structure
                 to be updated by this routine.

    Bcb - Returns a Bcb pointer which must be unpinned by the caller

    IndexEntry - Returns a pointer to the actual Index Entry, valid until
                 the Bcb is unpinned.

    IndexContext - If specified then this is an initialized index context.
                   It is used to insert a new entry later if this search
                   doesn't find a match.

Return Value:

    FALSE - if no match was found.
    TRUE - if a match was found and being returned in FileReference.

--*/

{
    PINDEX_CONTEXT LocalIndexContext;
    BOOLEAN Result = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );
    ASSERT_SHARED_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFindIndexEntry\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("Value = %08lx\n", Value) );
    DebugTrace( 0, Dbg, ("IgnoreCase = %02lx\n", IgnoreCase) );

    //
    //  Check if we need to initialize a local structure.
    //

    if (ARGUMENT_PRESENT( IndexContext )) {

        LocalIndexContext = IndexContext;

    } else {

        LocalIndexContext = NtfsAllocateFromStack( sizeof( INDEX_CONTEXT ));
        NtfsInitializeIndexContext( LocalIndexContext );
    }

    try {

        //
        //  Position to first possible match.
        //

        FindFirstIndexEntry( IrpContext,
                             Scb,
                             Value,
                             LocalIndexContext );

        //
        //  We are doing a direct compare in FindNextIndexEntry below
        //  so we don't have to upcase Value.  The name compare routine
        //  called later will upcase both.
        //

        if (FindNextIndexEntry( IrpContext,
                                Scb,
                                Value,
                                FALSE,
                                IgnoreCase,
                                LocalIndexContext,
                                FALSE,
                                NULL )) {

            //
            //  Return our outputs, clearing the Bcb so it won't get
            //  unpinned.
            //

            *IndexEntry = LocalIndexContext->Current->IndexEntry;

            //
            //  Now return the correct Bcb.
            //

            if (LocalIndexContext->Current == LocalIndexContext->Base) {

                *Bcb = NtfsFoundBcb(&LocalIndexContext->AttributeContext);
                NtfsFoundBcb(&LocalIndexContext->AttributeContext) = NULL;

                if (ARGUMENT_PRESENT( QuickIndex )) {

                    QuickIndex->BufferOffset = 0;
                }

            } else {

                PINDEX_LOOKUP_STACK Sp = LocalIndexContext->Current;

                *Bcb = Sp->Bcb;
                Sp->Bcb = NULL;

                if (ARGUMENT_PRESENT( QuickIndex )) {

                    QuickIndex->ChangeCount = Scb->ScbType.Index.ChangeCount;
                    QuickIndex->BufferOffset = PtrOffset( Sp->StartOfBuffer, Sp->IndexEntry );
                    QuickIndex->CapturedLsn = ((PINDEX_ALLOCATION_BUFFER) Sp->StartOfBuffer)->Lsn;
                    QuickIndex->IndexBlock = ((PINDEX_ALLOCATION_BUFFER) Sp->StartOfBuffer)->ThisBlock;
                }
            }

            try_return(Result = TRUE);

        } else {

            try_return(Result = FALSE);
        }

    try_exit: NOTHING;

    } finally{

        DebugUnwind( NtfsFindIndexEntry );

        if (!ARGUMENT_PRESENT( IndexContext )) {

            NtfsCleanupIndexContext( IrpContext, LocalIndexContext );
        }
    }

    DebugTrace( 0, Dbg, ("Bcb < %08lx\n", *Bcb) );
    DebugTrace( 0, Dbg, ("IndexEntry < %08lx\n", *IndexEntry) );
    DebugTrace( -1, Dbg, ("NtfsFindIndexEntry -> %08lx\n", Result) );

    return Result;
}


VOID
NtfsUpdateFileNameInIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PFILE_NAME FileName,
    IN PDUPLICATED_INFORMATION Info,
    IN OUT PQUICK_INDEX QuickIndex OPTIONAL
    )

/*++

Routine Description:

    This routine may be called to look up a given value in a given index
    and pin it for modification.

Arguments:

    Scb - Supplies the Scb for the index.

    FileName - Supplies a pointer to the file name to lookup.

    Info - Supplies a pointer to the information for the update

    QuickIndex - If present, this is the fast lookup information for this index entry.

Return Value:

    None.

--*/

{
    INDEX_CONTEXT IndexContext;
    PINDEX_ENTRY IndexEntry;
    PFILE_NAME FileNameInIndex;
    PVCB Vcb = Scb->Vcb;
    PINDEX_LOOKUP_STACK Sp;
    PINDEX_ALLOCATION_BUFFER IndexBuffer;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsUpdateFileNameInIndex\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("FileName = %08lx\n", FileName) );
    DebugTrace( 0, Dbg, ("Info = %08lx\n", Info) );

    NtfsInitializeIndexContext( &IndexContext );

    try {

        //
        //  If the index entry for this filename hasn't moved we can go
        //  directly to the location in the buffer.  For this to be the case the
        //  following must be true.
        //
        //      - The entry must already be in an index buffer
        //      - The index stream may not have been truncated
        //      - The Lsn in the page can't have changed
        //

        if (ARGUMENT_PRESENT( QuickIndex ) &&
            QuickIndex->BufferOffset != 0 &&
            QuickIndex->ChangeCount == Scb->ScbType.Index.ChangeCount) {

            //
            //  Use the top location in the index context to perform the
            //  read.
            //

            Sp = IndexContext.Base;

            ReadIndexBuffer( IrpContext,
                             Scb,
                             QuickIndex->IndexBlock,
                             FALSE,
                             Sp );

            //
            //  If the Lsn matches then we can use this buffer directly.
            //

            if (QuickIndex->CapturedLsn.QuadPart == Sp->CapturedLsn.QuadPart) {

                IndexBuffer = (PINDEX_ALLOCATION_BUFFER) Sp->StartOfBuffer;
                IndexEntry = (PINDEX_ENTRY) Add2Ptr( Sp->StartOfBuffer,
                                                     QuickIndex->BufferOffset );

                FileNameInIndex = (PFILE_NAME)(IndexEntry + 1);

                //
                //  Pin the index buffer
                //

                NtfsPinMappedData( IrpContext,
                                   Scb,
                                   LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                                   Scb->ScbType.Index.BytesPerIndexBuffer,
                                   &Sp->Bcb );

                //
                //  Write a log record to change our ParentIndexEntry.
                //

                //
                //  Write the log record, but do not update the IndexBuffer Lsn,
                //  since nothing moved and we don't want to force index contexts
                //  to have to rescan.
                //
                //  Indexbuffer->Lsn =
                //

                NtfsWriteLog( IrpContext,
                              Scb,
                              Sp->Bcb,
                              UpdateFileNameAllocation,
                              Info,
                              sizeof(DUPLICATED_INFORMATION),
                              UpdateFileNameAllocation,
                              &FileNameInIndex->Info,
                              sizeof(DUPLICATED_INFORMATION),
                              LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                              0,
                              (ULONG)((PCHAR)IndexEntry - (PCHAR)IndexBuffer),
                              Scb->ScbType.Index.BytesPerIndexBuffer );

                //
                //  Now call the Restart routine to do it.
                //

                NtfsRestartUpdateFileName( IndexEntry,
                                           Info );

                try_return( NOTHING );

            //
            //  Otherwise we need to reinitialize the index context and take
            //  the long path below.
            //

            } else {

                NtfsReinitializeIndexContext( IrpContext, &IndexContext );
            }
        }

        //
        //  Position to first possible match.
        //

        FindFirstIndexEntry( IrpContext,
                             Scb,
                             (PVOID)FileName,
                             &IndexContext );

        //
        //  See if there is an actual match.
        //

        if (FindNextIndexEntry( IrpContext,
                                Scb,
                                (PVOID)FileName,
                                FALSE,
                                FALSE,
                                &IndexContext,
                                FALSE,
                                NULL )) {

            //
            //  Point to the index entry and the file name within it.
            //

            IndexEntry = IndexContext.Current->IndexEntry;
            FileNameInIndex = (PFILE_NAME)(IndexEntry + 1);

            //
            //  Now pin the entry.
            //

            if (IndexContext.Current == IndexContext.Base) {

                PFILE_RECORD_SEGMENT_HEADER FileRecord;
                PATTRIBUTE_RECORD_HEADER Attribute;
                PATTRIBUTE_ENUMERATION_CONTEXT Context = &IndexContext.AttributeContext;

                //
                //  Pin the root
                //

                NtfsPinMappedAttribute( IrpContext,
                                        Vcb,
                                        Context );

                //
                //  Write a log record to change our ParentIndexEntry.
                //

                FileRecord = NtfsContainingFileRecord(Context);
                Attribute = NtfsFoundAttribute(Context);

                //
                //  Write the log record, but do not update the FileRecord Lsn,
                //  since nothing moved and we don't want to force index contexts
                //  to have to rescan.
                //
                //  FileRecord->Lsn =
                //

                NtfsWriteLog( IrpContext,
                              Vcb->MftScb,
                              NtfsFoundBcb(Context),
                              UpdateFileNameRoot,
                              Info,
                              sizeof(DUPLICATED_INFORMATION),
                              UpdateFileNameRoot,
                              &FileNameInIndex->Info,
                              sizeof(DUPLICATED_INFORMATION),
                              NtfsMftOffset( Context ),
                              (ULONG)((PCHAR)Attribute - (PCHAR)FileRecord),
                              (ULONG)((PCHAR)IndexEntry - (PCHAR)Attribute),
                              Vcb->BytesPerFileRecordSegment );

                if (ARGUMENT_PRESENT( QuickIndex )) {

                    QuickIndex->BufferOffset = 0;
                }

            } else {

                PINDEX_ALLOCATION_BUFFER IndexBuffer;

                Sp = IndexContext.Current;
                IndexBuffer = (PINDEX_ALLOCATION_BUFFER)Sp->StartOfBuffer;

                //
                //  Pin the index buffer
                //

                NtfsPinMappedData( IrpContext,
                                   Scb,
                                   LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                                   Scb->ScbType.Index.BytesPerIndexBuffer,
                                   &Sp->Bcb );

                //
                //  Write a log record to change our ParentIndexEntry.
                //

                //
                //  Write the log record, but do not update the IndexBuffer Lsn,
                //  since nothing moved and we don't want to force index contexts
                //  to have to rescan.
                //
                //  Indexbuffer->Lsn =
                //

                NtfsWriteLog( IrpContext,
                              Scb,
                              Sp->Bcb,
                              UpdateFileNameAllocation,
                              Info,
                              sizeof(DUPLICATED_INFORMATION),
                              UpdateFileNameAllocation,
                              &FileNameInIndex->Info,
                              sizeof(DUPLICATED_INFORMATION),
                              LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                              0,
                              (ULONG)((PCHAR)Sp->IndexEntry - (PCHAR)IndexBuffer),
                              Scb->ScbType.Index.BytesPerIndexBuffer );

                if (ARGUMENT_PRESENT( QuickIndex )) {

                    QuickIndex->ChangeCount = Scb->ScbType.Index.ChangeCount;
                    QuickIndex->BufferOffset = PtrOffset( Sp->StartOfBuffer, Sp->IndexEntry );
                    QuickIndex->CapturedLsn = ((PINDEX_ALLOCATION_BUFFER) Sp->StartOfBuffer)->Lsn;
                    QuickIndex->IndexBlock = ((PINDEX_ALLOCATION_BUFFER) Sp->StartOfBuffer)->ThisBlock;
                }
            }

            //
            //  Now call the Restart routine to do it.
            //

            NtfsRestartUpdateFileName( IndexEntry,
                                       Info );

        //
        //  If the file name is not in the index, this is a bad file.
        //

        } else {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
        }

    try_exit:  NOTHING;
    } finally{

        DebugUnwind( NtfsUpdateFileNameInIndex );

        NtfsCleanupIndexContext( IrpContext, &IndexContext );
    }

    DebugTrace( -1, Dbg, ("NtfsUpdateFileNameInIndex -> VOID\n") );

    return;
}


VOID
NtfsAddIndexEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN PFILE_REFERENCE FileReference,
    IN PINDEX_CONTEXT IndexContext OPTIONAL,
    OUT PQUICK_INDEX QuickIndex OPTIONAL
    )

/*++

Routine Description:

    This routine may be called to add an entry to an index.  This routine
    always allows duplicates.  If duplicates are not allowed, it is the
    caller's responsibility to detect and eliminate any duplicate before
    calling this routine.

Arguments:

    Scb - Supplies the Scb for the index.

    Value - Supplies a pointer to the value to add to the index

    ValueLength - Supplies the length of the value in bytes.

    FileReference - Supplies the file reference to place with the index entry.

    QuickIndex - If specified we store the location of the index added.

    IndexContext - If specified, previous result of doing the lookup for the name in the index.

Return Value:

    None

--*/

{
    INDEX_CONTEXT IndexContextStruct;
    PINDEX_CONTEXT LocalIndexContext;
    struct {
        INDEX_ENTRY IndexEntry;
        PVOID Value;
        PVOID MustBeNull;
    } IE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );
    ASSERT_EXCLUSIVE_SCB( Scb );
    ASSERT( (Scb->ScbType.Index.CollationRule != COLLATION_FILE_NAME) ||
            ( *(PLONGLONG)&((PFILE_NAME)Value)->ParentDirectory ==
              *(PLONGLONG)&Scb->Fcb->FileReference ) );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAddIndexEntry\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("Value = %08lx\n", Value) );
    DebugTrace( 0, Dbg, ("ValueLength = %08lx\n", ValueLength) );
    DebugTrace( 0, Dbg, ("FileReference = %08lx\n", FileReference) );

    //
    //  Remember if we are using the local or input IndexContext.
    //

    if (ARGUMENT_PRESENT( IndexContext )) {

        LocalIndexContext = IndexContext;

    } else {

        LocalIndexContext = &IndexContextStruct;
        NtfsInitializeIndexContext( LocalIndexContext );
    }

    try {

        //
        //  Do the lookup again if we don't have a context.
        //

        if (!ARGUMENT_PRESENT( IndexContext )) {

            //
            //  Position to first possible match.
            //

            FindFirstIndexEntry( IrpContext,
                                 Scb,
                                 Value,
                                 LocalIndexContext );

            //
            //  See if there is an actual match.
            //

            if (FindNextIndexEntry( IrpContext,
                                    Scb,
                                    Value,
                                    FALSE,
                                    FALSE,
                                    LocalIndexContext,
                                    FALSE,
                                    NULL )) {

                ASSERTMSG( "NtfsAddIndexEntry already exists", FALSE );

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
            }
        }

        //
        //  Initialize the Index Entry in pointer form.
        //

        IE.IndexEntry.FileReference = *FileReference;
        IE.IndexEntry.Length = (USHORT)(sizeof(INDEX_ENTRY) + QuadAlign(ValueLength));
        IE.IndexEntry.AttributeLength = (USHORT)ValueLength;
        IE.IndexEntry.Flags = INDEX_ENTRY_POINTER_FORM;
        IE.IndexEntry.Reserved = 0;
        IE.Value = Value;
        IE.MustBeNull = NULL;

        //
        //  Now add it to the index.  We can only add to a leaf, so force our
        //  position back to the correct spot in a leaf first.
        //

        LocalIndexContext->Current = LocalIndexContext->Top;
        AddToIndex( IrpContext, Scb, (PINDEX_ENTRY)&IE, LocalIndexContext, QuickIndex, FALSE );

    } finally{

        DebugUnwind( NtfsAddIndexEntry );

        if (!ARGUMENT_PRESENT( IndexContext )) {

            NtfsCleanupIndexContext( IrpContext, LocalIndexContext );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsAddIndexEntry -> VOID\n") );

    return;
}


VOID
NtfsDeleteIndexEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PVOID Value,
    IN PFILE_REFERENCE FileReference
    )

/*++

Routine Description:

    This routine may be called to delete a specified index entry.  The
    first entry is removed which matches the value exactly (including in Case,
    if relevant) and the file reference.

Arguments:

    Scb - Supplies the Scb for the index.

    Value - Supplies a pointer to the value to delete from the index.

    FileReference - Supplies the file reference of the index entry.

Return Value:

    None

--*/

{
    INDEX_CONTEXT IndexContext;
    PINDEX_ENTRY IndexEntry;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );
    ASSERT_EXCLUSIVE_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsDeleteIndexEntry\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("Value = %08lx\n", Value) );
    DebugTrace( 0, Dbg, ("FileReference = %08lx\n", FileReference) );

    NtfsInitializeIndexContext( &IndexContext );

    try {

        //
        //  Position to first possible match.
        //

        FindFirstIndexEntry( IrpContext,
                             Scb,
                             Value,
                             &IndexContext );

        //
        //  See if there is an actual match.
        //

        if (!FindNextIndexEntry( IrpContext,
                                 Scb,
                                 Value,
                                 FALSE,
                                 FALSE,
                                 &IndexContext,
                                 FALSE,
                                 NULL )) {

            ASSERTMSG( "NtfsDeleteIndexEntry does not exist", FALSE );

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
        }

        //
        //  Extract the found index entry pointer.
        //

        IndexEntry = IndexContext.Current->IndexEntry;

        //
        //  If the file reference also matches, then this is the one we
        //  are supposed to delete.
        //

        if (!NtfsEqualMftRef(&IndexEntry->FileReference, FileReference)) {

            ASSERTMSG( "NtfsDeleteIndexEntry unexpected file reference", FALSE );

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
        }

        DeleteFromIndex( IrpContext, Scb, &IndexContext );

    } finally{

        DebugUnwind( NtfsDeleteIndexEntry );

        NtfsCleanupIndexContext( IrpContext, &IndexContext );
    }

    DebugTrace( -1, Dbg, ("NtfsDeleteIndexEntry -> VOID\n") );

    return;
}


VOID
NtfsPushIndexRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine may be called to "push" the index root, i.e., add another
    level to the BTree, to make more room in the file record.

Arguments:

    Scb - Supplies the Scb for the index.

Return Value:

    None

--*/

{
    INDEX_CONTEXT IndexContext;
    PINDEX_LOOKUP_STACK Sp;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );
    ASSERT_EXCLUSIVE_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsPushIndexRoot\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );

    NtfsInitializeIndexContext( &IndexContext );

    try {

        //
        //  Position to first possible match.
        //

        FindFirstIndexEntry( IrpContext,
                             Scb,
                             NULL,
                             &IndexContext );

        //
        //  See if the stack will have to be grown to do the push
        //

        Sp = IndexContext.Top + 1;

        if (Sp >= IndexContext.Base + (ULONG)IndexContext.NumberEntries) {
            NtfsGrowLookupStack( Scb,
                                 &IndexContext,
                                 &Sp );
        }

        PushIndexRoot( IrpContext, Scb, &IndexContext );

    } finally{

        DebugUnwind( NtfsPushIndexRoot );

        NtfsCleanupIndexContext( IrpContext, &IndexContext );
    }

    DebugTrace( -1, Dbg, ("NtfsPushIndexRoot -> VOID\n") );

    return;
}


BOOLEAN
NtfsRestartIndexEnumeration (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb,
    IN PSCB Scb,
    IN PVOID Value,
    IN BOOLEAN IgnoreCase,
    IN BOOLEAN NextFlag,
    OUT PINDEX_ENTRY *IndexEntry,
    IN PFCB AcquiredFcb
    )

/*++

Routine Description:

    This routine may be called to start or restart an index enumeration,
    according to the parameters as described below.  The first matching
    entry, if any, is returned by this call.  Subsequent entries, if any,
    may be returned by subsequent calls to NtfsContinueIndexEnumeration.

    For each entry found, a pointer is returned to a copy of the entry, in
    dynamically allocated pool pointed to by the Ccb.  Therefore, there is
    nothing for the caller to unpin.

    Note that the Value, ValueLength, and IgnoreCase parameters on the first
    call for a given Ccb fix what will be returned for this Ccb forever.  A
    subsequent call to this routine may also specify these parameters, but
    in this case these parameters will be used for positioning only; all
    matches returned will continue to match the value and IgnoreCase flag
    specified on the first call for the Ccb.

    Note that all calls to this routine must be from within a try-finally,
    and the finally clause must include a call to NtfsCleanupAfterEnumeration.

Arguments:

    Ccb - Pointer to the Ccb for this enumeration.

    Scb - Supplies the Scb for the index.

    Value - Pointer to the value containing the pattern which is to match
            all returns for enumerations on this Ccb.

    IgnoreCase - If FALSE, all returns will match the pattern value with
                 exact case (if relevant).  If TRUE, all returns will match
                 the pattern value ignoring case.  On a second or subsequent
                 call for a Ccb, this flag may be specified differently just
                 for positioning.  For example, an IgnoreCase TRUE enumeration
                 may be restarted at a previously returned value found by exact
                 case match.

    NextFlag - FALSE if the first match of the enumeration is to be returned.
               TRUE if the next match after the first one is to be returned.

    IndexEntry - Returns a pointer to a copy of the index entry.

    AcquiredFcb - Supplies a pointer to an Fcb which has been preacquired to
                  potentially aide NtfsRetrieveOtherFileName

Return Value:

    FALSE - If no match is being returned, and the output pointer is undefined.
    TRUE - If a match is being returned.

--*/

{
    PINDEX_ENTRY FoundIndexEntry;
    INDEX_CONTEXT OtherContext;
    BOOLEAN WildCardsInExpression;
    BOOLEAN SynchronizationError;
    PWCH UpcaseTable = IrpContext->Vcb->UpcaseTable;
    PINDEX_CONTEXT IndexContext = NULL;
    BOOLEAN CleanupOtherContext = FALSE;
    BOOLEAN Result = FALSE;
    BOOLEAN ContextJustCreated = FALSE;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_CCB( Ccb );
    ASSERT_SCB( Scb );
    ASSERT_SHARED_SCB( Scb );
    ASSERT( ARGUMENT_PRESENT(Value) || (Ccb->IndexContext != NULL) );

    DebugTrace( +1, Dbg, ("NtfsRestartIndexEnumeration\n") );
    DebugTrace( 0, Dbg, ("Ccb = %08lx\n", Ccb) );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("Value = %08lx\n", Value) );
    DebugTrace( 0, Dbg, ("IgnoreCase = %02lx\n", IgnoreCase) );
    DebugTrace( 0, Dbg, ("NextFlag = %02lx\n", NextFlag) );

    try {

        //
        //  If the Ccb does not yet have an index context, then we must
        //  allocate one and initialize this Context and the Ccb as well.
        //

        if (Ccb->IndexContext == NULL) {

            //
            //  Allocate and initialize the index context.
            //

            Ccb->IndexContext = (PINDEX_CONTEXT)ExAllocateFromPagedLookasideList( &NtfsIndexContextLookasideList );

            NtfsInitializeIndexContext( Ccb->IndexContext );
            ContextJustCreated = TRUE;

            //
            //  Capture the caller's IgnoreCase flag.
            //

            if (IgnoreCase) {
                SetFlag( Ccb->Flags, CCB_FLAG_IGNORE_CASE );
            }
        }

        //
        //  Pick up the pointer to the index context, and save the current
        //  change count from the Scb.
        //

        IndexContext = Ccb->IndexContext;

        //
        //  The first step of enumeration is to position our IndexContext.
        //

        FindFirstIndexEntry( IrpContext,
                             Scb,
                             Value,
                             IndexContext );

        //
        //  The following code only applies to file name indices.
        //

        if (!FlagOn( Scb->ScbState, SCB_STATE_VIEW_INDEX )) {

            //
            //  Remember if there are wild cards.
            //

            if ((*NtfsContainsWildcards[Scb->ScbType.Index.CollationRule])
                                        ( Value )) {

                WildCardsInExpression = TRUE;

            } else {

                WildCardsInExpression = FALSE;
            }

            //
            //  If the operation is caseinsensitive, upcase the string.
            //

            if (IgnoreCase) {

                (*NtfsUpcaseValue[Scb->ScbType.Index.CollationRule])
                                  ( UpcaseTable,
                                    IrpContext->Vcb->UpcaseTableSize,
                                    Value );
            }
        } else {

            //
            //  For view indices, it is implied that all searches
            //  are wildcard searches.
            //

            WildCardsInExpression = TRUE;
        }

        //
        //  If this is not actually the first call, then we have to
        //  position exactly to the Value specified, and set NextFlag
        //  correctly.  The first call can either the initial call
        //  to query or the first call after a restart.
        //

        if (!ContextJustCreated && NextFlag) {

            PIS_IN_EXPRESSION MatchRoutine;
            PFILE_NAME NameInIndex;
            BOOLEAN ItsThere;

            //
            //  See if the specified value is actually there, because
            //  we are not allowed to resume from a Dos-only name.
            //

            ItsThere = FindNextIndexEntry( IrpContext,
                                           Scb,
                                           Value,
                                           WildCardsInExpression,
                                           IgnoreCase,
                                           IndexContext,
                                           FALSE,
                                           NULL );

            //
            //  We will set up pointers from our returns, but we must
            //  be careful only to use them if we found something.
            //

            FoundIndexEntry = IndexContext->Current->IndexEntry;
            NameInIndex = (PFILE_NAME)(FoundIndexEntry + 1);

            //
            //  Figure out which match routine to use.
            //

            if (FlagOn(Ccb->Flags, CCB_FLAG_WILDCARD_IN_EXPRESSION)) {
                MatchRoutine = NtfsIsInExpression[COLLATION_FILE_NAME];
            } else {
                MatchRoutine = (PIS_IN_EXPRESSION)NtfsIsEqual[COLLATION_FILE_NAME];
            }

            //
            //  If we are trying to resume from a Ntfs-only or Dos-Only name, then
            //  we take action here.  Do not do this on the internal
            //  call from NtfsContinueIndexEnumeration, which is the
            //  only one who would point at the index entry in the Ccb.
            //
            //  We can think of this code this way.  No matter what our search
            //  expression is, we traverse the index only one way.  For each
            //  name we find, we will only return the file name once - either
            //  from an Ntfs-only match or from a Dos-only match if the Ntfs-only
            //  name does not match.  Regardless of whether resuming from the
            //  Ntfs-Only or Dos-only name, we still can determine a unique
            //  position in the directory.  That unique position is the Ntfs-only
            //  name if it matches the expression, or else the Dos-only name if
            //  it only matches.  In the illegal case that neither matches, we
            //  arbitrarily resume from the Ntfs-only name.
            //
            //      This code may be read aloud to the tune
            //          "While My Heart Gently Weeps"
            //

            if (ItsThere &&
                (Value != (PVOID)(Ccb->IndexEntry + 1)) &&
                (Scb->ScbType.Index.CollationRule == COLLATION_FILE_NAME) &&

                //
                //  Is it a Dos-only or Ntfs-only name?
                //

                (BooleanFlagOn( NameInIndex->Flags, FILE_NAME_DOS ) !=
                  BooleanFlagOn( NameInIndex->Flags, FILE_NAME_NTFS )) &&

                //
                //  Try to resume from the other name if he either gave
                //  us a Dos-only name, or he gave us an Ntfs-only name
                //  that does not fit in the search expression.
                //

                (FlagOn( NameInIndex->Flags, FILE_NAME_DOS ) ||
                 !(*MatchRoutine)( UpcaseTable,
                                   Ccb->QueryBuffer,
                                   FoundIndexEntry,
                                   IgnoreCase ))) {

                PFILE_NAME FileNameBuffer;
                ULONG FileNameLength;

                NtfsInitializeIndexContext( &OtherContext );
                CleanupOtherContext = TRUE;

                FileNameBuffer = NtfsRetrieveOtherFileName( IrpContext,
                                                            Ccb,
                                                            Scb,
                                                            FoundIndexEntry,
                                                            &OtherContext,
                                                            AcquiredFcb,
                                                            &SynchronizationError );

                //
                //  We have to position to the long name and actually
                //  resume from there.  To do this we have to cleanup and initialize
                //  the IndexContext in the Ccb, and lookup the long name we just
                //  found.
                //
                //  If the other index entry is not there, there is some minor
                //  corruption going on, but we will just charge on in that event.
                //  Also, if the other index entry is there, but it does not match
                //  our expression, then we are supposed to resume from the short
                //  name, so we carry on.
                //

                ItsThere = (FileNameBuffer != NULL);

                if (!ItsThere && SynchronizationError) {
                    NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                }

                if (ItsThere &&

                    (FlagOn(Ccb->Flags, CCB_FLAG_WILDCARD_IN_EXPRESSION)  ?

                     NtfsFileNameIsInExpression(UpcaseTable,
                                                (PFILE_NAME)Ccb->QueryBuffer,
                                                FileNameBuffer,
                                                IgnoreCase) :



                     NtfsFileNameIsEqual(UpcaseTable,
                                         (PFILE_NAME)Ccb->QueryBuffer,
                                         FileNameBuffer,
                                         IgnoreCase))) {

                    ULONG SizeOfFileName = FIELD_OFFSET( FILE_NAME, FileName );

                    NtfsReinitializeIndexContext( IrpContext, IndexContext );

                    //
                    //  Extract a description of the file name from the found index
                    //  entry.
                    //

                    FileNameLength = FileNameBuffer->FileNameLength * sizeof( WCHAR );

                    //
                    //  Call FindFirst/FindNext to position our context to the corresponding
                    //  long name.
                    //

                    FindFirstIndexEntry( IrpContext,
                                         Scb,
                                         (PVOID)FileNameBuffer,
                                         IndexContext );

                    ItsThere = FindNextIndexEntry( IrpContext,
                                                   Scb,
                                                   (PVOID)FileNameBuffer,
                                                   FALSE,
                                                   FALSE,
                                                   IndexContext,
                                                   FALSE,
                                                   NULL );

                    if (!ItsThere) {

                        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                    }
                }
            }

            //
            //  NextFlag should only remain TRUE, if the specified value
            //  is actually there, and NextFlag was specified as TRUE
            //  on input.  In particular, it is important to make
            //  NextFlag FALSE if the specified value is not actually
            //  there.  (Experience shows this behavior is important to
            //  implement "delnode" correctly for the Lan Manager Server!)
            //

            NextFlag = (BOOLEAN)(NextFlag && ItsThere);

        //
        //  If we created the context then we need to remember if the
        //  expression has wildcards.
        //

        } else {

            //
            //  We may not handle correctly an initial enumeration with
            //  NextFlag TRUE, because the context is initially sitting
            //  in the root.  Dirctrl must always pass NextFlag FALSE
            //  on the initial enumeration.
            //

            ASSERT(!NextFlag);

            //
            //  Remember if the value has wild cards.
            //

            if (WildCardsInExpression) {

                SetFlag( Ccb->Flags, CCB_FLAG_WILDCARD_IN_EXPRESSION );
            }
        }

        //
        //  Now we are correctly positioned.  See if there is an actual
        //  match at our current position.  If not, return FALSE.
        //
        //  (Note, FindFirstIndexEntry always leaves us positioned in
        //  some leaf of the index, and it is the first FindNext that
        //  actually positions us to the first match.)
        //

        if (!FindNextIndexEntry( IrpContext,
                                 Scb,
                                 Ccb->QueryBuffer,
                                 BooleanFlagOn( Ccb->Flags, CCB_FLAG_WILDCARD_IN_EXPRESSION ),
                                 BooleanFlagOn( Ccb->Flags, CCB_FLAG_IGNORE_CASE ),
                                 IndexContext,
                                 NextFlag,
                                 NULL )) {

            try_return( Result = FALSE );
        }

        //
        //  If we get here, then we have a match that we want to return.
        //  We always copy the complete IndexEntry away and pass a pointer
        //  back to the copy.  See if our current buffer for the index entry
        //  is large enough.
        //

        FoundIndexEntry = IndexContext->Current->IndexEntry;

        if (Ccb->IndexEntryLength < (ULONG)FoundIndexEntry->Length) {

            //
            //  If there is a buffer currently allocated, deallocate it before
            //  allocating a larger one.  (Clear Ccb fields in case we get an
            //  allocation error.)
            //

            if (Ccb->IndexEntry != NULL) {

                NtfsFreePool( Ccb->IndexEntry );
                Ccb->IndexEntry = NULL;
                Ccb->IndexEntryLength = 0;
            }

            //
            //  Allocate a new buffer for the index entry we just found, with
            //  some "padding" in case the next match is larger.
            //

            Ccb->IndexEntry = (PINDEX_ENTRY)NtfsAllocatePool(PagedPool, (ULONG)FoundIndexEntry->Length + 16 );

            Ccb->IndexEntryLength = (ULONG)FoundIndexEntry->Length + 16;
        }

        //
        //  Now, save away our copy of the IndexEntry, and return a pointer
        //  to it.
        //

        RtlMoveMemory( Ccb->IndexEntry,
                       FoundIndexEntry,
                       (ULONG)FoundIndexEntry->Length );

        *IndexEntry = Ccb->IndexEntry;

        try_return( Result = TRUE );

    try_exit: NOTHING;

    } finally {

        DebugUnwind( NtfsRestartIndexEnumeration );

        if (CleanupOtherContext) {
            NtfsCleanupIndexContext( IrpContext, &OtherContext );
        }
        //
        //  If we died during the first call, then deallocate everything
        //  that we might have allocated.
        //

        if (AbnormalTermination() && ContextJustCreated) {

            if (Ccb->IndexEntry != NULL) {
                NtfsFreePool( Ccb->IndexEntry );
                Ccb->IndexEntry = NULL;
            }

            if (Ccb->IndexContext != NULL) {
                NtfsCleanupIndexContext( IrpContext, Ccb->IndexContext );
                ExFreeToPagedLookasideList( &NtfsIndexContextLookasideList, Ccb->IndexContext );
                Ccb->IndexContext = NULL;
            }
        }

        //
        //  Remember if we are not returning anything, to save work later.
        //

        if (!Result && (Ccb->IndexEntry != NULL)) {
            Ccb->IndexEntry->Length = 0;
        }
    }

    DebugTrace( 0, Dbg, ("*IndexEntry < %08lx\n", *IndexEntry) );
    DebugTrace( -1, Dbg, ("NtfsRestartIndexEnumeration -> %08lx\n", Result) );

    return Result;
}


BOOLEAN
NtfsContinueIndexEnumeration (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb,
    IN PSCB Scb,
    IN BOOLEAN NextFlag,
    OUT PINDEX_ENTRY *IndexEntry
    )

/*++

Routine Description:

    This routine may be called to return again the last match on an active
    enumeration, or to return the next match.  Enumerations must always be
    started or restarted via a call to NtfsRestartIndexEnumeration.

    Note that all calls to this routine must be from within a try-finally,
    and the finally clause must include a call to NtfsCleanupAfterEnumeration.

Arguments:

    Ccb - Pointer to the Ccb for this enumeration.

    Scb - Supplies the Scb for the index.

    NextFlag - FALSE if the last returned match is to be returned again.
               TRUE if the next match is to be returned.

    IndexEntry - Returns a pointer to a copy of the index entry.

Return Value:

    FALSE - If no match is being returned, and the output pointer is undefined.
    TRUE - If a match is being returned.

--*/

{
    PINDEX_ENTRY FoundIndexEntry;
    PINDEX_CONTEXT IndexContext;
    BOOLEAN MustRestart;
    BOOLEAN Result = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_CCB( Ccb );
    ASSERT_SCB( Scb );
    ASSERT_SHARED_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsContinueIndexEnumeration\n") );
    DebugTrace( 0, Dbg, ("Ccb = %08lx\n", Ccb) );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("NextFlag = %02lx\n", NextFlag) );

    //
    //  It seems many apps like to come back one more time and really get
    //  an error status, so if we did not return anything last time, we can
    //  get out now too.
    //
    //  There also may be no index entry, in the case of an empty directory
    //  and dirctrl is cycling through with "." and "..".
    //

    if ((Ccb->IndexEntry == NULL) || (Ccb->IndexEntry->Length == 0)) {

        DebugTrace( -1, Dbg, ("NtfsContinueIndexEnumeration -> FALSE\n") );
        return FALSE;
    }

    IndexContext = Ccb->IndexContext;

    try {

        //
        //  Lookup the next match.
        //

        if (!FindNextIndexEntry( IrpContext,
                                 Scb,
                                 Ccb->QueryBuffer,
                                 BooleanFlagOn( Ccb->Flags, CCB_FLAG_WILDCARD_IN_EXPRESSION ),
                                 BooleanFlagOn( Ccb->Flags, CCB_FLAG_IGNORE_CASE ),
                                 IndexContext,
                                 NextFlag,
                                 &MustRestart )) {

            //
            //  If he is saying we must restart, then that means something changed
            //  in our saved enumeration context across two file system calls.
            //  Reestablish our position in the tree by looking up the last entry
            //  we returned.
            //

            if (MustRestart) {

                NtfsReinitializeIndexContext( IrpContext, Ccb->IndexContext );

                try_return( Result = NtfsRestartIndexEnumeration( IrpContext,
                                                                  Ccb,
                                                                  Scb,
                                                                  (PVOID)(Ccb->IndexEntry + 1),
                                                                  FALSE,
                                                                  NextFlag,
                                                                  IndexEntry,
                                                                  NULL ));

            //
            //  Otherwise, there is nothing left to return.
            //

            } else {

                try_return( Result = FALSE );
            }
        }

        //
        //  If we get here, then we have a match that we want to return.
        //  We always copy the complete IndexEntry away and pass a pointer
        //  back to the copy.  See if our current buffer for the index entry
        //  is large enough.
        //

        FoundIndexEntry = IndexContext->Current->IndexEntry;

        if (Ccb->IndexEntryLength < (ULONG)FoundIndexEntry->Length) {

            //
            //  If there is a buffer currently allocated, deallocate it before
            //  allocating a larger one.
            //

            if (Ccb->IndexEntry != NULL) {

                NtfsFreePool( Ccb->IndexEntry );
                Ccb->IndexEntry = NULL;
                Ccb->IndexEntryLength = 0;
            }

            //
            //  Allocate a new buffer for the index entry we just found, with
            //  some "padding".
            //

            Ccb->IndexEntry = (PINDEX_ENTRY)NtfsAllocatePool(PagedPool, (ULONG)FoundIndexEntry->Length + 16 );

            Ccb->IndexEntryLength = (ULONG)FoundIndexEntry->Length + 16;
        }

        //
        //  Now, save away our copy of the IndexEntry, and return a pointer
        //  to it.
        //

        RtlMoveMemory( Ccb->IndexEntry,
                       FoundIndexEntry,
                       (ULONG)FoundIndexEntry->Length );

        *IndexEntry = Ccb->IndexEntry;

        try_return( Result = TRUE );

    try_exit: NOTHING;

    } finally {

        DebugUnwind( NtfsContinueIndexEnumeration );

        //
        //  Remember if we are not returning anything, to save work later.
        //

        if (!Result && (Ccb->IndexEntry != NULL)) {
            Ccb->IndexEntry->Length = 0;
        }
    }

    DebugTrace( 0, Dbg, ("*IndexEntry < %08lx\n", *IndexEntry) );
    DebugTrace( -1, Dbg, ("NtfsContinueIndexEnumeration -> %08lx\n", Result) );

    return Result;
}


PFILE_NAME
NtfsRetrieveOtherFileName (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb,
    IN PSCB Scb,
    IN PINDEX_ENTRY IndexEntry,
    IN OUT PINDEX_CONTEXT OtherContext,
    IN PFCB AcquiredFcb OPTIONAL,
    OUT PBOOLEAN SynchronizationError
    )

/*++

Routine Description:

    This routine may be called to retrieve the other index entry for a given
    index entry.  I.e., for an input Ntfs-only index entry it will find the
    Dos-only index entry for the same file referenced, or visa versa.  This
    is a routine which clearly is relevant only to file name indices, but it
    is located here because it uses the Index Context in the Ccb.

    The idea is that nearly always the other name for a given index entry will
    be very near to the given name.

    This routine first scans the leaf index buffer described by the index
    context for the Dos name.  If this fails, this routine attempts to look
    the other name up in the index.  Currently there will always be a Dos name,
    however if one does not exist, we treat that as benign, and simply return
    FALSE.


Arguments:

    Ccb - Pointer to the Ccb for this enumeration.

    Scb - Supplies the Scb for the index.

    IndexEntry - Suppliess a pointer to an index entry, for which the Dos name
                 is to be retrieved.


    OtherContext - Must be initialized on input, and subsequently cleaned up
                   by the caller after the information has been extracted from
                   the other index entry.

    AcquiredFcb - An Fcb which has been acquired so that its file record may be
                  read

    SynchronizationError - Returns TRUE if no file name is being returned because
                           of an error trying to acquire an Fcb to read its file
                           record.

Return Value:

    Pointer to the other desired file name.

--*/

{
    PINDEX_CONTEXT IndexContext;
    PINDEX_HEADER IndexHeader;
    PINDEX_ENTRY IndexTemp, IndexLast;
    PINDEX_LOOKUP_STACK Top;

    struct {
        FILE_NAME FileName;
        WCHAR NameBuffer[2];
    }OtherFileName;

    UNICODE_STRING OtherName;
    USHORT OtherFlag;
    PVCB Vcb = Scb->Vcb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_CCB( Ccb );
    ASSERT_SCB( Scb );
    ASSERT_SHARED_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRetrieveOtherFileName\n") );
    DebugTrace( 0, Dbg, ("Ccb = %08lx\n", Ccb) );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );

    *SynchronizationError = FALSE;

    //
    //  Calculate the other name space flag.
    //

    OtherFlag = ((PFILE_NAME)(IndexEntry + 1))->Flags;
    ClearFlag( OtherFlag, ~(FILE_NAME_NTFS | FILE_NAME_DOS) );
    OtherFlag ^= FILE_NAME_NTFS | FILE_NAME_DOS;

    ASSERT( (OtherFlag == FILE_NAME_NTFS) || (OtherFlag == FILE_NAME_DOS) );

    //
    //  Point to the IndexContext in the Ccb.
    //

    IndexContext = Ccb->IndexContext;

    //
    //  We can only scan the top of the index if it is safe
    //  to read it.
    //

    Top = IndexContext->Top;

    if ((Top->Bcb != NULL) ||
        (Top == IndexContext->Base) ||
        ReadIndexBuffer(IrpContext, Scb, 0, TRUE, Top)) {

        //
        //  Point to the first index entry in the index buffer at the bottom of
        //  the index.
        //

        IndexHeader = Top->IndexHeader;
        IndexTemp = Add2Ptr(IndexHeader, IndexHeader->FirstIndexEntry);
        IndexLast = Add2Ptr(IndexHeader, IndexHeader->FirstFreeByte);

        //
        //  Now scan this buffer for a matching Dos name.
        //

        while (IndexTemp < IndexLast) {

            //
            //  If we find an entry with the same file reference and the Dos flag
            //  set, then we can return it and get out.
            //

            if (NtfsEqualMftRef(&IndexTemp->FileReference, &IndexEntry->FileReference) &&
                FlagOn(((PFILE_NAME)(IndexTemp + 1))->Flags, OtherFlag)) {

                DebugTrace( -1, Dbg, ("NtfsRetrieveOtherFileName -> %08lx\n", IndexTemp) );

                return (PFILE_NAME)(IndexTemp + 1);
            }

            IndexTemp = Add2Ptr(IndexTemp, IndexTemp->Length);
        }
    }

    //
    //  If this is a pretty large directory, then it may be too expensive to
    //  scan for the other name in the directory.  Note in the degenerate
    //  case, we have actually do a sequential scan of the entire directory,
    //  and if all the files in the directory start with the same 6 characters,
    //  which is unfortunately common, then even our "pie-wedge" scan reads
    //  the entire directory.
    //
    //  Thus we will just try to go read the file record in this case to get
    //  the other name.  This is complicated from a synchronization standpoint -
    //  if the file is open, we need to acquire it shared before we can read
    //  it to get the other name.  Here is a summary of the strategy implemented
    //  primarily here and in dirctrl:
    //
    //      1.  Read the file record, in an attempt to avoid a fault while
    //          being synchronized.
    //      2.  If the file reference we need to synchronize is the same as
    //          in the optional AcquiredFcb parameter, go ahead and find/return
    //          the other name.
    //      3.  Else, acquire the Fcb Table to try to look up the Fcb.
    //      4.  If there is no Fcb, hold the table while returning the name.
    //      5.  If there is an Fcb, try to acquire it shared with Wait = FALSE,
    //          and hold it while returning the name.
    //      6.  If we cannot get the Fcb, and AcquiredFcb was not specified, then
    //          store the File Reference we are trying to get and return
    //          *SynchronizationError = TRUE.  Dirctrl must figure out how to
    //          call us back with the FcbAcquired, by forcing a resume of the
    //          enumeration.
    //      7.  If we could not get the Fcb and there *was* a different AcquiredFcb
    //          specified, then this is the only case where we give up and fall
    //          through to find the other name in the directory.  This should be
    //          extremely rare, but if we try to return *SynchronizationError = TRUE,
    //          and force a resume, we could be unlucky and loop forever, essentially
    //          toggling between synchronizing on two Fcbs.  Presumably this could
    //          only happen if we have some kind of dumb client who likes to back
    //          up a few files when he resumes.
    //

    if (Scb->Header.AllocationSize.QuadPart > MAX_INDEX_TO_SCAN_FOR_NAMES) {

        FCB_TABLE_ELEMENT Key;
        PFCB_TABLE_ELEMENT Entry;
        PFCB FcbWeNeed;
        PFILE_RECORD_SEGMENT_HEADER FileRecord;
        PATTRIBUTE_RECORD_HEADER Attribute;
        BOOLEAN Synchronized = TRUE;

        //
        //  Get the base file record active and valid before synchronizing.
        //  Don't verify it since we aren't syncrhonized
        //

        NtfsReadMftRecord( IrpContext,
                           Vcb, 
                           &IndexEntry->FileReference,
                           FALSE,
                           &OtherContext->AttributeContext.FoundAttribute.Bcb,
                           &FileRecord,
                           NULL );
        //
        //  If we are not synchronized with the correct Fcb, then try to
        //  synchronize.
        //

        if (!ARGUMENT_PRESENT(AcquiredFcb) ||
            !NtfsEqualMftRef(&AcquiredFcb->FileReference, &IndexEntry->FileReference)) {

            //
            //  Now look up the Fcb, and if it is there, reference it
            //  and remember it.
            //

            Key.FileReference = IndexEntry->FileReference;
            NtfsAcquireFcbTable( IrpContext, Vcb );
            Entry = RtlLookupElementGenericTable( &Vcb->FcbTable, &Key );

            if (Entry != NULL) {

                FcbWeNeed = Entry->Fcb;

                //
                //  Now that it cannot go anywhere, try to acquire it.
                //

                Synchronized = NtfsAcquireResourceShared( IrpContext, FcbWeNeed, FALSE );

                //
                //  If we manage to acquire it, then increment its reference count
                //  and remember it for subsequent cleanup.
                //

                if (Synchronized) {

                    FcbWeNeed->ReferenceCount += 1;
                    OtherContext->AcquiredFcb = FcbWeNeed;
                }

                NtfsReleaseFcbTable( IrpContext, Vcb );

            } else {

                SetFlag( OtherContext->Flags, INDX_CTX_FLAG_FCB_TABLE_ACQUIRED );
            }
        }

        if (Synchronized) {

            ULONG CorruptHint = 0;

            if (!NtfsCheckFileRecord( Vcb, FileRecord, &IndexEntry->FileReference, &CorruptHint ) ||
                (!FlagOn( FileRecord->Flags, FILE_RECORD_SEGMENT_IN_USE ))) {

                if (FlagOn( OtherContext->Flags, INDX_CTX_FLAG_FCB_TABLE_ACQUIRED )) {
                    ClearFlag( OtherContext->Flags, INDX_CTX_FLAG_FCB_TABLE_ACQUIRED );
                    NtfsReleaseFcbTable( IrpContext, Vcb );
                }

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, &IndexEntry->FileReference, NULL );
            }

            Attribute = (PATTRIBUTE_RECORD_HEADER)Add2Ptr(FileRecord, FileRecord->FirstAttributeOffset);

            while (((PVOID)Attribute < Add2Ptr(FileRecord, FileRecord->FirstFreeByte)) &&
                   (Attribute->TypeCode <= $FILE_NAME)) {

                if ((Attribute->TypeCode == $FILE_NAME) &&
                    FlagOn(((PFILE_NAME)NtfsAttributeValue(Attribute))->Flags, OtherFlag)) {

                    return (PFILE_NAME)NtfsAttributeValue(Attribute);
                }

                Attribute = NtfsGetNextRecord(Attribute);
            }

        } else if (!ARGUMENT_PRESENT(AcquiredFcb)) {

            Ccb->FcbToAcquire.FileReference = IndexEntry->FileReference;
            *SynchronizationError = TRUE;
            return NULL;
        }

        //
        //  Cleanup from above before proceding.
        //

        NtfsReinitializeIndexContext( IrpContext, OtherContext );
    }

    //
    //  Well, we were unlucky, and did not find the other name yet, form
    //  a name to scan a range of the index.
    //

    RtlZeroMemory( &OtherFileName, sizeof(OtherFileName) );
    OtherName.MaximumLength = 6;
    OtherName.Buffer = (PWCHAR) &OtherFileName.FileName.FileName[0];
    OtherName.Buffer[0] = ((PFILE_NAME)(IndexEntry + 1))->FileName[0];

    //
    //  Name generation is complicated enough, that we are only going to
    //  guess the other name using the first two (special case is one)
    //  characters followed by *.
    //

    if (((PFILE_NAME)(IndexEntry + 1))->FileNameLength > 1) {

        OtherName.Buffer[1] = ((PFILE_NAME)(IndexEntry + 1))->FileName[1];
        OtherName.Buffer[2] = L'*';
        OtherFileName.FileName.FileNameLength = 3;
        OtherName.Length = 6;

    } else {

        OtherName.Buffer[1] = L'*';
        OtherFileName.FileName.FileNameLength = 2;
        OtherName.Length = 4;
    }

    //
    //  Now we think we have formed a pretty good name fairly tightly
    //  encompasses the range of possible Dos names we expect for the
    //  given Ntfs name.  We will enumerate all of the files which match
    //  the pattern we have formed, and see if any of them are the Dos
    //  name for the same file.  If this expression still doesn't work,
    //  (extremely unlikely), then we will substitute the pattern with
    //  "*" and make one final attempt.
    //
    //  Note many names are the same in Dos and Ntfs, and for them this
    //  routine is never called.  Of the ones that do have separate names,
    //  the pattern we formed above should really match it and will probably
    //  scan parts of the directory already in the cache.  The last loop is
    //  a terrible sequential scan of the entire directory.  It should never,
    //  never happen, but it is here so that in the worst case we do not
    //  break, we just take a bit longer.
    //

    while (TRUE) {

        BOOLEAN NextFlag;
        ULONG NameLength;

        NameLength = sizeof(FILE_NAME) + OtherFileName.FileName.FileNameLength - 1;

        //
        //  The first step of enumeration is to position our IndexContext.
        //

        FindFirstIndexEntry( IrpContext,
                             Scb,
                             &OtherFileName,
                             OtherContext );

        NextFlag = FALSE;

        //
        //  Now scan through all of the case insensitive matches.
        //  Upcase our name structure.
        //

        NtfsUpcaseName( Vcb->UpcaseTable, Vcb->UpcaseTableSize, &OtherName );

        while (FindNextIndexEntry( IrpContext,
                                   Scb,
                                   &OtherFileName,
                                   TRUE,
                                   TRUE,
                                   OtherContext,
                                   NextFlag,
                                   NULL )) {

            IndexTemp = OtherContext->Current->IndexEntry;

            //
            //  If we find an entry with the same file reference and the Dos flag
            //  set, then we can return it and get out.
            //

            if (NtfsEqualMftRef(&IndexTemp->FileReference, &IndexEntry->FileReference) &&
                FlagOn(((PFILE_NAME)(IndexTemp + 1))->Flags, OtherFlag)) {

                DebugTrace( -1, Dbg, ("NtfsRetrieveOtherFileName -> %08lx\n", IndexTemp) );

                return (PFILE_NAME)(IndexTemp + 1);
            }

            NextFlag = TRUE;
        }

        //
        //  Give up if we have already scanned everything.
        //

        if ((OtherName.Buffer[0] == '*') && (OtherName.Length == 2)) {
            break;
        }


        NtfsReinitializeIndexContext( IrpContext, OtherContext );

        OtherName.Buffer[0] = '*';
        OtherName.Length = 2;
        OtherFileName.FileName.FileNameLength = 1;
    }

    return NULL;
}


VOID
NtfsCleanupAfterEnumeration (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb
    )

/*++

Routine Description:

    A call to this routine must exist within the finally clause of any routine
    which calls either NtfsRestartIndexEnumeration or NtfsContinueIndexEnumeration.

Arguments:

    Ccb - Pointer to the Ccb for this enumeration.

Return Value:

    None

--*/


{
    PAGED_CODE();

    if (Ccb->IndexContext != NULL) {
        NtfsReinitializeIndexContext( IrpContext, Ccb->IndexContext );
    }
}


BOOLEAN
NtfsIsIndexEmpty (
    IN PIRP_CONTEXT IrpContext,
    IN PATTRIBUTE_RECORD_HEADER Attribute
    )

/*++

Routine Description:

    This routine may be called to see if the specified index is empty.

Arguments:

    Attribute - Pointer to the attribute record header of an INDEX_ROOT
                attribute.

Return Value:

    FALSE - if the index is not empty.
    TRUE - if the index is empty.

--*/

{
    PINDEX_ROOT IndexRoot;
    PINDEX_ENTRY IndexEntry;
    BOOLEAN Result;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsIsIndexEmpty\n") );
    DebugTrace( 0, Dbg, ("Attribute = %08lx\n", Attribute) );

    IndexRoot = (PINDEX_ROOT)NtfsAttributeValue( Attribute );
    IndexEntry = NtfsFirstIndexEntry( &IndexRoot->IndexHeader );

    Result = (BOOLEAN)(!FlagOn( IndexEntry->Flags, INDEX_ENTRY_NODE ) &&
                       FlagOn( IndexEntry->Flags, INDEX_ENTRY_END ));

    DebugTrace( -1, Dbg, ("NtfsIsIndexEmpty -> %02lx\n", Result) );

    return Result;
}


VOID
NtfsDeleteIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PUNICODE_STRING AttributeName
    )

/*++

Routine Description:

    This routine may be called to delete the specified index.  The index
    must be empty.

    NOTE: This routine is not required until we can separately create/delete
          indices, therefore it is not implemented.  Use NtfsDeleteFile
          to delete a "directory" (or a normal file).

Arguments:

    Fcb - Supplies the Fcb for the index.

    AttributeName - Name of the index attributes: $Ixxx

Return Value:

    None

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    UNREFERENCED_PARAMETER( IrpContext );
    UNREFERENCED_PARAMETER( Fcb );
    UNREFERENCED_PARAMETER( AttributeName );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsDeleteIndex\n") );
    DebugTrace( 0, Dbg, ("Fcb = %08lx\n", Fcb) );
    DebugTrace( 0, Dbg, ("AttributeName = %08lx\n", AttributeName) );

    DbgDoit( DbgPrint("NtfsDeleteIndex is not yet implemented\n"); DbgBreakPoint(); );

    DebugTrace( -1, Dbg, ("NtfsDeleteIndex -> VOID\n") );
}


VOID
NtfsInitializeIndexContext (
    OUT PINDEX_CONTEXT IndexContext
    )

/*++

Routine Description:

    This routine may be called to initialize the specified index context.

Arguments:

    IndexContext - Index context to initialize.

Return Value:

    None

--*/

{
    PAGED_CODE();

    RtlZeroMemory( IndexContext, sizeof(INDEX_CONTEXT) );
    NtfsInitializeAttributeContext( &IndexContext->AttributeContext );

    //
    //  Describe the resident lookup stack
    //

    IndexContext->Base = IndexContext->LookupStack;
    IndexContext->NumberEntries = INDEX_LOOKUP_STACK_SIZE;
}


VOID
NtfsCleanupIndexContext (
    IN PIRP_CONTEXT IrpContext,
    OUT PINDEX_CONTEXT IndexContext
    )

/*++

Routine Description:

    This routine may be called to cleanup the specified index context,
    typically during finally processing.

Arguments:

    IndexContext - Index context to clean up.

Return Value:

    None

--*/

{
    ULONG i;

    PAGED_CODE();

    //
    //  Release the Fcb Table and/or an acquired Fcb.
    //

    if (FlagOn(IndexContext->Flags, INDX_CTX_FLAG_FCB_TABLE_ACQUIRED)) {
        NtfsReleaseFcbTable( IrpContext, IrpContext->Vcb );
        ClearFlag( IndexContext->Flags, INDX_CTX_FLAG_FCB_TABLE_ACQUIRED );
    }

    if (IndexContext->AcquiredFcb != NULL) {

        NtfsAcquireFcbTable( IrpContext, IrpContext->Vcb );
        ASSERT(IndexContext->AcquiredFcb->ReferenceCount > 0);
        IndexContext->AcquiredFcb->ReferenceCount -= 1;
        NtfsReleaseFcbTable( IrpContext, IrpContext->Vcb );

        NtfsReleaseResource( IrpContext, IndexContext->AcquiredFcb );
        IndexContext->AcquiredFcb = NULL;
    }

    for (i = 0; i < IndexContext->NumberEntries; i++) {
        NtfsUnpinBcb( IrpContext, &IndexContext->Base[i].Bcb );
    }

    //
    //  See if we need to deallocate a lookup stack.  Point to the embedded
    //  lookup stack if we deallocate to handle the case where cleanup is
    //  called twice in a row.  We will have to zero the stack so the
    //  subsequent cleanup won't find any Bcb's in the stack.
    //

    if (IndexContext->Base != IndexContext->LookupStack) {
        NtfsFreePool( IndexContext->Base );
    }

    NtfsCleanupAttributeContext( IrpContext, &IndexContext->AttributeContext );
}


VOID
NtfsReinitializeIndexContext (
    IN PIRP_CONTEXT IrpContext,
    OUT PINDEX_CONTEXT IndexContext
    )

/*++

Routine Description:

    This routine may be called to cleanup the specified index context,
    and reinitialize it, preserving fields that should not be zeroed.

Arguments:

    IndexContext - Index context to clean up.

Return Value:

    None

--*/

{
    ULONG i;

    PAGED_CODE();

    //
    //  Release the Fcb Table and/or an acquired Fcb.
    //

    if (FlagOn(IndexContext->Flags, INDX_CTX_FLAG_FCB_TABLE_ACQUIRED)) {
        NtfsReleaseFcbTable( IrpContext, IrpContext->Vcb );
        ClearFlag( IndexContext->Flags, INDX_CTX_FLAG_FCB_TABLE_ACQUIRED );
    }

    if (IndexContext->AcquiredFcb != NULL) {

        NtfsAcquireFcbTable( IrpContext, IrpContext->Vcb );
        ASSERT(IndexContext->AcquiredFcb->ReferenceCount > 0);
        IndexContext->AcquiredFcb->ReferenceCount -= 1;
        NtfsReleaseFcbTable( IrpContext, IrpContext->Vcb );

        NtfsReleaseResource( IrpContext, IndexContext->AcquiredFcb );

        IndexContext->AcquiredFcb = NULL;
    }

    for (i = 0; i < IndexContext->NumberEntries; i++) {
        NtfsUnpinBcb( IrpContext, &IndexContext->Base[i].Bcb );
    }

    NtfsCleanupAttributeContext( IrpContext, &IndexContext->AttributeContext );
    NtfsInitializeAttributeContext( &IndexContext->AttributeContext );
}


VOID
NtfsGrowLookupStack (
    IN PSCB Scb,
    IN OUT PINDEX_CONTEXT IndexContext,
    IN PINDEX_LOOKUP_STACK *Sp
    )

/*++

Routine Description:

    This routine grows and index lookup stack to contain the specified number
    of entries.

Arguments:

    Scb - Scb for index

    IndexContext - Index context to grow.

    Sp - Caller's local stack pointer to be updated

Return Value:

    None

--*/

{
    PINDEX_LOOKUP_STACK NewLookupStack;
    ULONG_PTR Relocation;
    USHORT NumberEntries;

    PAGED_CODE();

    //
    //  Extract current index hint, if there is one.
    //

    NumberEntries = Scb->ScbType.Index.IndexDepthHint;

    //
    //  If there was no hint, or it was too small, then
    //  calculate a new hint.
    //

    if (NumberEntries <= IndexContext->NumberEntries) {

        Scb->ScbType.Index.IndexDepthHint =
        NumberEntries = IndexContext->NumberEntries + 3;
    }

    //
    //  Allocate (may fail), initialize and copy over the old one.
    //

    NewLookupStack = NtfsAllocatePool( PagedPool, NumberEntries * sizeof(INDEX_LOOKUP_STACK) );

    RtlZeroMemory( NewLookupStack, NumberEntries * sizeof(INDEX_LOOKUP_STACK) );

    RtlCopyMemory( NewLookupStack,
                   IndexContext->Base,
                   IndexContext->NumberEntries * sizeof(INDEX_LOOKUP_STACK) );

    //
    //  Free the old one unless we were using the local stack.
    //

    if (IndexContext->Base != IndexContext->LookupStack) {
        NtfsFreePool( IndexContext->Base );
    }

    //
    //  Now relocate all pointers to the old stack
    //

    Relocation = ((PCHAR)NewLookupStack - (PCHAR)IndexContext->Base);
    IndexContext->Current = (PINDEX_LOOKUP_STACK)((PCHAR)IndexContext->Current + Relocation);
    IndexContext->Top = (PINDEX_LOOKUP_STACK)((PCHAR)IndexContext->Top + Relocation);
    *Sp = (PINDEX_LOOKUP_STACK)((PCHAR)*Sp + Relocation);

    //
    //  Finally update context to describe new stack
    //

    IndexContext->Base = NewLookupStack;
    IndexContext->NumberEntries = NumberEntries;
}


BOOLEAN
ReadIndexBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG IndexBlock,
    IN BOOLEAN Reread,
    OUT PINDEX_LOOKUP_STACK Sp
    )

/*++

Routine Description:

    This routine reads the index buffer at the specified Vcn, and initializes
    the stack pointer to describe it.

Arguments:

    Scb - Supplies the Scb for the index.

    IndexBlock - Supplies the index block of this index buffer, ignored if
                 Reread is TRUE.

    Reread - Supplies TRUE if buffer is being reread, and the CapturedLsn
             should be checked.

    Sp - Returns a description of the index buffer read.

Return Value:

    FALSE - if Reread was supplied as TRUE and the Lsn changed
    TRUE - if the buffer was read successfully (or did not change)

--*/

{
    PINDEX_ALLOCATION_BUFFER IndexBuffer;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("ReadIndexBuffer\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("Sp = %08lx\n", Sp) );

    ASSERT(Sp->Bcb == NULL);

    //
    //  If the attribute stream does not already exist, create it.
    //

    if (Scb->FileObject == NULL) {

        NtfsCreateInternalAttributeStream( IrpContext,
                                           Scb,
                                           TRUE,
                                           &NtfsInternalUseFile[DIRECTORY_FILE_NUMBER] );
    }

    //
    // If Reread is TRUE, then convert the directory entry pointer in the
    // buffer to an offset (to be relocated later) and overwrite the Lbn
    // input parameter with the Lbn in the stack location.
    //

    if (Reread) {
        Sp->IndexEntry = (PINDEX_ENTRY)((PCHAR)Sp->IndexEntry - (PCHAR)Sp->StartOfBuffer);
        IndexBlock = Sp->IndexBlock;
    }

    Sp->IndexBlock = IndexBlock;

    //
    //  The vcn better only have 32 bits, other wise the the test in NtfsMapStream
    //  may not catch this error.
    //

    if (((PLARGE_INTEGER) &IndexBlock)->HighPart != 0) {

        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
    }

    NtfsMapStream( IrpContext,
                   Scb,
                   LlBytesFromIndexBlocks( IndexBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                   Scb->ScbType.Index.BytesPerIndexBuffer,
                   &Sp->Bcb,
                   &Sp->StartOfBuffer );

    IndexBuffer = (PINDEX_ALLOCATION_BUFFER)Sp->StartOfBuffer;

    if (!NtfsCheckIndexBuffer( Scb, IndexBuffer ) ||
        (IndexBuffer->ThisBlock != IndexBlock)) {

        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
    }

    Sp->IndexHeader = &IndexBuffer->IndexHeader;
    if (Reread) {

        if (IndexBuffer->Lsn.QuadPart != Sp->CapturedLsn.QuadPart) {

            NtfsUnpinBcb( IrpContext, &Sp->Bcb );
            DebugTrace( -1, Dbg, ("ReadIndexBuffer->TRUE\n") );
            return FALSE;
        }

        Sp->IndexEntry = (PINDEX_ENTRY)((PCHAR)Sp->IndexEntry + ((PCHAR)Sp->StartOfBuffer - (PCHAR)NULL));

    } else {

        Sp->IndexEntry = NtfsFirstIndexEntry(Sp->IndexHeader);
        Sp->CapturedLsn = IndexBuffer->Lsn;
    }


    DebugTrace( -1, Dbg, ("ReadIndexBuffer->VOID\n") );

    return TRUE;
}


PINDEX_ALLOCATION_BUFFER
GetIndexBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    OUT PINDEX_LOOKUP_STACK Sp,
    OUT PLONGLONG EndOfValidData
    )

/*++

Routine Description:

    This routine allocates and initializes an index buffer, and initializes
    the stack pointer to describe it.

Arguments:

    Scb - Supplies the Scb for the index.

    Sp - Returns a description of the index buffer allocated.

    EndOfValidData - This is the file offset of the end of the allocated buffer.
        This is used to update the valid data length of the stream when the
        block is written.

Return Value:

    Pointer to the Index Buffer allocated.

--*/

{
    PINDEX_ALLOCATION_BUFFER IndexBuffer;
    ATTRIBUTE_ENUMERATION_CONTEXT BitMapContext;
    ULONG RecordIndex;
    LONGLONG BufferOffset;

    PUSHORT UsaSequenceNumber;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("GetIndexBuffer\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("Sp = %08lx\n", Sp) );

    //
    //  Initialize the BitMap attribute context and insure cleanup on the
    //  way out.
    //

    NtfsInitializeAttributeContext( &BitMapContext );

    try {

        //
        //  Lookup the BITMAP attribute.
        //

        if (!NtfsLookupAttributeByName( IrpContext,
                                        Scb->Fcb,
                                        &Scb->Fcb->FileReference,
                                        $BITMAP,
                                        &Scb->AttributeName,
                                        NULL,
                                        FALSE,
                                        &BitMapContext )) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
        }

        //
        //  If the attribute stream does not already exist, create it.
        //

        if (Scb->FileObject == NULL) {

            NtfsCreateInternalAttributeStream( IrpContext,
                                               Scb,
                                               TRUE,
                                               &NtfsInternalUseFile[DIRECTORY_FILE_NUMBER] );
        }

        //
        //  If the allocation for this index has not been initialized yet,
        //  then we must initialize it first.
        //

        if (!Scb->ScbType.Index.AllocationInitialized) {

            ULONG ExtendGranularity = 1;
            ULONG TruncateGranularity = 4;

            if (Scb->ScbType.Index.BytesPerIndexBuffer < Scb->Vcb->BytesPerCluster) {

                ExtendGranularity = Scb->Vcb->BytesPerCluster / Scb->ScbType.Index.BytesPerIndexBuffer;

                if (ExtendGranularity > 4) {

                    TruncateGranularity = ExtendGranularity;
                }
            }

            NtfsInitializeRecordAllocation( IrpContext,
                                            Scb,
                                            &BitMapContext,
                                            Scb->ScbType.Index.BytesPerIndexBuffer,
                                            ExtendGranularity,
                                            TruncateGranularity,
                                            &Scb->ScbType.Index.RecordAllocationContext );

            Scb->ScbType.Index.AllocationInitialized = TRUE;
        }

        //
        //  Now allocate a record.  We always "hint" from the front to keep the
        //  index compact.
        //

        RecordIndex = NtfsAllocateRecord( IrpContext,
                                          &Scb->ScbType.Index.RecordAllocationContext,
                                          &BitMapContext );

        //
        //  Calculate the IndexBlock.
        //

        BufferOffset = Int32x32To64( RecordIndex, Scb->ScbType.Index.BytesPerIndexBuffer );

        //
        //  Now remember the offset of the end of the added record.
        //

        *EndOfValidData = BufferOffset + Scb->ScbType.Index.BytesPerIndexBuffer;

        //
        //  Now pin and zero the buffer, in order to initialize it.
        //

        NtfsPreparePinWriteStream( IrpContext,
                                   Scb,
                                   BufferOffset,
                                   Scb->ScbType.Index.BytesPerIndexBuffer,
                                   TRUE,
                                   &Sp->Bcb,
                                   (PVOID *)&IndexBuffer );


        //
        //  Now we can fill in the lookup stack.
        //

        Sp->StartOfBuffer = (PVOID)IndexBuffer;
        Sp->IndexHeader = &IndexBuffer->IndexHeader;
        Sp->IndexEntry = (PINDEX_ENTRY)NULL;

        //
        //  Initialize the Index Allocation Buffer and return.
        //

        *(PULONG)IndexBuffer->MultiSectorHeader.Signature = *(PULONG)IndexSignature;

        IndexBuffer->MultiSectorHeader.UpdateSequenceArrayOffset =
          (USHORT)FIELD_OFFSET( INDEX_ALLOCATION_BUFFER, UpdateSequenceArray );
        IndexBuffer->MultiSectorHeader.UpdateSequenceArraySize =
            (USHORT)UpdateSequenceArraySize( Scb->ScbType.Index.BytesPerIndexBuffer );

        UsaSequenceNumber = Add2Ptr( IndexBuffer,
                                     IndexBuffer->MultiSectorHeader.UpdateSequenceArrayOffset );
        *UsaSequenceNumber = 1;


        IndexBuffer->ThisBlock = RecordIndex * Scb->ScbType.Index.BlocksPerIndexBuffer;

        IndexBuffer->IndexHeader.FirstIndexEntry =
        IndexBuffer->IndexHeader.FirstFreeByte =
          QuadAlign((ULONG)IndexBuffer->MultiSectorHeader.UpdateSequenceArrayOffset +
            (ULONG)IndexBuffer->MultiSectorHeader.UpdateSequenceArraySize * sizeof(USHORT)) -
            FIELD_OFFSET(INDEX_ALLOCATION_BUFFER, IndexHeader);;
        IndexBuffer->IndexHeader.BytesAvailable =
          Scb->ScbType.Index.BytesPerIndexBuffer -
          FIELD_OFFSET(INDEX_ALLOCATION_BUFFER, IndexHeader);;

    } finally {

        DebugUnwind( GetIndexBuffer );

        NtfsCleanupAttributeContext( IrpContext, &BitMapContext );
    }

    DebugTrace( -1, Dbg, ("GetIndexBuffer -> %08lx\n", IndexBuffer) );
    return IndexBuffer;
}


VOID
DeleteIndexBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN VCN IndexBlockNumber
    )

/*++

Routine Description:

    This routine deletes the specified index buffer.

Arguments:

    Scb - Supplies the Scb for the index.

    IndexBuffer - Pointer to the index buffer to delete.

Return Value:

    None.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT BitMapContext;
    LONGLONG RecordIndex;
    PATTRIBUTE_RECORD_HEADER BitmapAttribute;
    BOOLEAN AttributeWasResident = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("DeleteIndexBuffer\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("IndexBlockNumber = %08lx\n", IndexBlockNumber) );

    //
    //  Initialize the BitMap attribute context and insure cleanup on the
    //  way out.
    //

    NtfsInitializeAttributeContext( &BitMapContext );

    try {

        //
        //  Lookup the BITMAP attribute.
        //

        if (!NtfsLookupAttributeByName( IrpContext,
                                        Scb->Fcb,
                                        &Scb->Fcb->FileReference,
                                        $BITMAP,
                                        &Scb->AttributeName,
                                        NULL,
                                        FALSE,
                                        &BitMapContext )) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
        }

        //
        //  Remember if the bitmap attribute is currently resident,
        //  in case it changes.
        //

        BitmapAttribute = NtfsFoundAttribute(&BitMapContext);
        AttributeWasResident = BitmapAttribute->FormCode == RESIDENT_FORM;

        //
        //  If the allocation for this index has not been initialized yet,
        //  then we must initialize it first.
        //

        if (!Scb->ScbType.Index.AllocationInitialized) {

            ULONG ExtendGranularity = 1;
            ULONG TruncateGranularity = 4;

            if (Scb->ScbType.Index.BytesPerIndexBuffer < Scb->Vcb->BytesPerCluster) {

                ExtendGranularity = Scb->Vcb->BytesPerCluster / Scb->ScbType.Index.BytesPerIndexBuffer;

                if (ExtendGranularity > 4) {

                    TruncateGranularity = ExtendGranularity;
                }
            }

            NtfsInitializeRecordAllocation( IrpContext,
                                            Scb,
                                            &BitMapContext,
                                            Scb->ScbType.Index.BytesPerIndexBuffer,
                                            ExtendGranularity,
                                            TruncateGranularity,
                                            &Scb->ScbType.Index.RecordAllocationContext );

            Scb->ScbType.Index.AllocationInitialized = TRUE;
        }

        //
        //  Calculate the record index for this buffer.
        //

        RecordIndex = IndexBlockNumber / Scb->ScbType.Index.BlocksPerIndexBuffer;


        if (((PLARGE_INTEGER)&RecordIndex)->HighPart != 0) {
            ASSERT( ((PLARGE_INTEGER)&RecordIndex)->HighPart == 0 );

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
        }

        //
        //  Now deallocate the record.
        //

        NtfsDeallocateRecord( IrpContext,
                              &Scb->ScbType.Index.RecordAllocationContext,
                              (ULONG)RecordIndex,
                              &BitMapContext );

    } finally {

        DebugUnwind( DeleteIndexBuffer );

        //
        //  In the extremely rare case that the bitmap attribute was resident
        //  and now became nonresident, we will uninitialize it here so that
        //  the next time we will find the bitmap Scb, etc.
        //

        if (AttributeWasResident) {

            BitmapAttribute = NtfsFoundAttribute(&BitMapContext);

            if (BitmapAttribute->FormCode != RESIDENT_FORM) {

                NtfsUninitializeRecordAllocation( IrpContext,
                                                  &Scb->ScbType.Index.RecordAllocationContext );

                Scb->ScbType.Index.AllocationInitialized = FALSE;
            }
        }

        NtfsCleanupAttributeContext( IrpContext, &BitMapContext );
    }
    DebugTrace( -1, Dbg, ("DeleteIndexBuffer -> VOID\n") );
}


VOID
FindFirstIndexEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PVOID Value,
    IN OUT PINDEX_CONTEXT IndexContext
    )

/*++

Routine Description:

    This routine finds the the first entry in a leaf buffer of an Index Btree
    which could possibly be a match for the input value.  Another way to state
    this is that this routine establishes a position in the Btree from which a
    tree walk should begin to find the desired value or all desired values which
    match the input value specification.

    As stated, the context on return will always describe a pointer in a leaf
    buffer.  This is occassionally inefficient in the 2% case where a specific
    value is being looked up that happens to reside in an intermediate node buffer.
    However, for index adds and deletes, this pointer is always very interesting.
    For an add, this pointer always describes the exact spot at which the add should
    occur (adds must always occur in leafs).  For deletes, this pointer is either
    to the exact index entry which is to be deleted, or else it points to the best
    replacement for the target to delete, when the actual target is at an intermediate
    spot in the tree.

    So this routine descends from the root of the index to the correct leaf, doing
    a binary search in each index buffer along the way (via an external routine).

Arguments:

    Scb - Supplies the Scb for the index.

    Value - Pointer to a value or value expression which should be used to position
            the IndexContext, or NULL to just describe the root for pushing.

    IndexContext - Address of the initialized IndexContext, to return the desired
                   position.

Return Value:

    None.

--*/

{
    PINDEX_LOOKUP_STACK Sp;
    PATTRIBUTE_RECORD_HEADER Attribute;
    PINDEX_ROOT IndexRoot;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("FindFirstIndexEntry\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("Value = %08lx\n", Value) );
    DebugTrace( 0, Dbg, ("IndexContext = %08lx\n", IndexContext) );

    //
    //  Lookup the attribute record from the Scb.
    //

    if (!NtfsLookupAttributeByName( IrpContext,
                                    Scb->Fcb,
                                    &Scb->Fcb->FileReference,
                                    $INDEX_ROOT,
                                    &Scb->AttributeName,
                                    NULL,
                                    FALSE,
                                    &IndexContext->AttributeContext )) {

        DebugTrace( -1, 0, ("FindFirstIndexEntry - Could *not* find attribute\n") );

        NtfsRaiseStatus( IrpContext, STATUS_OBJECT_PATH_NOT_FOUND, NULL, NULL );
    }

    //
    //  Save Lsn of file record containing Index Root so that later
    //  we can tell if we need to re-find it.
    //

    IndexContext->IndexRootFileRecordLsn =
        IndexContext->AttributeContext.FoundAttribute.FileRecord->Lsn;

    //
    //  Now Initialize some local pointers and the rest of the context
    //

    Sp = IndexContext->Base;
    Sp->StartOfBuffer = NtfsContainingFileRecord( &IndexContext->AttributeContext );
    Sp->CapturedLsn = ((PFILE_RECORD_SEGMENT_HEADER)Sp->StartOfBuffer)->Lsn;
    IndexContext->ScbChangeCount = Scb->ScbType.Index.ChangeCount;
    IndexContext->OldAttribute =
    Attribute = NtfsFoundAttribute( &IndexContext->AttributeContext );
    IndexRoot = (PINDEX_ROOT)NtfsAttributeValue( Attribute );
    Sp->IndexHeader = &IndexRoot->IndexHeader;

    //
    //  The Index part of the Scb may not yet be initialized.  If so, do it
    //  here.
    //

    if (Scb->ScbType.Index.BytesPerIndexBuffer == 0) {

        NtfsUpdateIndexScbFromAttribute( IrpContext, Scb, Attribute, FALSE );
    }

    //
    //  If Value is not specified, this is a special call from NtfsPushIndexRoot.
    //

    if (!ARGUMENT_PRESENT(Value)) {

        Sp->IndexEntry = NtfsFirstIndexEntry(Sp->IndexHeader);
        IndexContext->Top =
        IndexContext->Current = Sp;
        DebugTrace( -1, 0, ("FindFirstIndexEntry - No Value specified\n") );
        return;
    }

    //
    //  Loop through the Lookup stack as we descend the binary tree doing an
    //  IgnoreCase lookup of the specified value.
    //

    while (TRUE) {

        //
        //  Binary search in the current buffer for the first entry <= value.
        //

        Sp->IndexEntry = BinarySearchIndex( IrpContext,
                                            Scb,
                                            Sp,
                                            Value );

        //
        //  If this entry is not a node, then we are done.
        //

        if (!FlagOn( Sp->IndexEntry->Flags, INDEX_ENTRY_NODE )) {

            IndexContext->Top =
            IndexContext->Current = Sp;

            //
            //  Check for and mark corrupt if we find an empty leaf.
            //

            if ((Sp != IndexContext->Base)

                    &&

                FlagOn(NtfsFirstIndexEntry(Sp->IndexHeader)->Flags, INDEX_ENTRY_END)) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, NULL );
            }

            DebugTrace( -1, Dbg, ("FindFirstIndexEntry -> VOID\n") );

            return;
        }

        //
        //  Check for special case where we preemptively push the root.
        //  Otherwise we can find ourselves recursively in NtfsAllocateRecord
        //  and NtfsAddAllocation, etc., on a buffer split which needs to push
        //  the root to add to the index allocation.
        //
        //  First off, we only need to check this the first time through
        //  the loop, and only if the caller has the Scb exclusive.
        //

        if ((Sp == IndexContext->Base) &&
            NtfsIsExclusiveScb(Scb) &&
            !FlagOn( Scb->Vcb->VcbState, VCB_STATE_VOL_PURGE_IN_PROGRESS)) {

            PFILE_RECORD_SEGMENT_HEADER FileRecord;

            FileRecord = NtfsContainingFileRecord(&IndexContext->AttributeContext);

            //
            //  Only do the push if there are not enough bytes to allocate a
            //  record, and the root is already a node with down pointers, and
            //  the root is "big enough to move".
            //
            //  This means this path will typically only kick in with directories
            //  with at least 200 files or so!
            //

            if (((FileRecord->BytesAvailable - FileRecord->FirstFreeByte) < (sizeof( ATTRIBUTE_LIST_ENTRY ) - sizeof( WCHAR ) + Scb->AttributeName.Length)) &&
                FlagOn(IndexRoot->IndexHeader.Flags, INDEX_NODE) &&
                (Attribute->RecordLength >= Scb->Vcb->BigEnoughToMove)) {

                //
                //  Check if we want to defer pushing the root.
                //

                if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_FORCE_PUSH )) {

                    //
                    //  Our insertion point will now also be pushed, so we
                    //  have to increment the stack pointer.
                    //

                    Sp += 1;

                    if (Sp >= IndexContext->Base + (ULONG)IndexContext->NumberEntries) {
                        NtfsGrowLookupStack( Scb,
                                             IndexContext,
                                             &Sp );
                    }

                    PushIndexRoot( IrpContext, Scb, IndexContext );

                } else {

                    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_PUSH );
                }
            }
        }

        //
        //  If the lookup stack is exhausted, grow the lookup stack.
        //

        Sp += 1;
        if (Sp >= IndexContext->Base + (ULONG)IndexContext->NumberEntries) {
            NtfsGrowLookupStack( Scb,
                                 IndexContext,
                                 &Sp );
        }

        //
        //  Otherwise, read the index buffer pointed to by the current
        //  Index Entry.
        //

        ReadIndexBuffer( IrpContext,
                         Scb,
                         NtfsIndexEntryBlock((Sp-1)->IndexEntry),
                         FALSE,
                         Sp );
    }
}


BOOLEAN
FindNextIndexEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PVOID Value,
    IN BOOLEAN ValueContainsWildcards,
    IN BOOLEAN IgnoreCase,
    IN OUT PINDEX_CONTEXT IndexContext,
    IN BOOLEAN NextFlag,
    OUT PBOOLEAN MustRestart OPTIONAL
    )

/*++

Routine Description:

    This routine performs a pre-order traversal of an index, starting from the
    current position described by the index context, looking for the next match
    for the input value, or the first value that indicates no further matches are
    possible.  Pre-order refers to the fact that starting at any given index entry,
    we visit any descendents of that index entry first before visiting the index
    entry itself, since all descendent index entries are lexigraphically less than
    their parent index entry.  A visit to an index entry is defined as either
    detecting that the given index entry is the special end entry, or else testing
    whether the index entry is a match for the input value expression.

    The traversal either terminates successfully (returning TRUE) or unsuccessfully
    (returning FALSE).  It terminates successfully if a match is found and being
    returned; in this case FindNextIndexEntry may be called again to look for the
    next match.  It terminates unsuccessfully if either the End entry is encountered
    in the index root, or if an entry is found which is lexigraphically greater than
    the input value, when compared ignoring case (if relevant).

    The traversal is driven like a state machine driven by the index context, as
    initialized from the preceding call to FindFirstIndexEntry, or as left from the
    last call to this routine.  The traversal algorithm is explained in comments
    below.

    The caller may specify whether it wants the current match to be returned (or
    returned again), as described by the current state of the index context.  Or it
    may specify (with NextFlag TRUE) that it wishes to get the next match.  Even if
    NextFlag is FALSE, the currently described index entry will not be returned if
    it is not a match.

Arguments:

    Scb - Supplies the Scb for the index.

    Value - Pointer to a value or value expression which should be used to position
            the IndexContext.  This value is already upcased if we are doing
            an IgnoreCase compare and the value contains wildcards.  Otherwise
            the direct compare routine will upcase both values.

    ValueContainsWildCards - Indicates if the value expression contains wild
                             cards.  We can do a direct compare if it
                             doesn't.

    IgnoreCase - Specified as TRUE if a case-insensitive match is desired (if
                 relevant for the collation rule).

    IndexContext - Address of the initialized IndexContext, to return the desired
                   position.

    NextFlag - Specified as FALSE if the currently described entry should be returned
               if it is a match, or TRUE if the next entry should first be considered
               for a match.

    MustRestart - If specified and returning FALSE, returns TRUE if enumeration must
                  be restarted.

Return Value:

    FALSE - if no entry is being returned, and there are no more matches.
    TRUE - if an entry is being returned, and the caller may wish to call for further
           matches.

--*/

{
    PINDEX_ENTRY IndexEntry;
    PINDEX_LOOKUP_STACK Sp;
    FSRTL_COMPARISON_RESULT BlindResult;
    BOOLEAN LocalMustRestart;
    PWCH UpcaseTable = IrpContext->Vcb->UpcaseTable;
    ULONG UpcaseTableSize = IrpContext->Vcb->UpcaseTableSize;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("FindNextIndexEntry\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("Value = %08lx\n", Value) );
    DebugTrace( 0, Dbg, ("IgnoreCase = %02lx\n", IgnoreCase) );
    DebugTrace( 0, Dbg, ("IndexContext = %08lx\n", IndexContext) );
    DebugTrace( 0, Dbg, ("NextFlag = %02lx\n", NextFlag) );

    if (!ARGUMENT_PRESENT(MustRestart)) {
        MustRestart = &LocalMustRestart;
    }

    *MustRestart = FALSE;

    if (IndexContext->ScbChangeCount != Scb->ScbType.Index.ChangeCount) {

        DebugTrace( -1, Dbg, ("FindNextIndexEntry -> FALSE (must restart)\n") );

        *MustRestart = TRUE;
        return FALSE;
    }

    Sp = IndexContext->Current;

    //
    //  If there is no Bcb for the current buffer, then we are continuing
    //  an enumeration.
    //

    if (Sp->Bcb == NULL) {

        //
        //  Index Root case.
        //

        if (Sp == IndexContext->Base) {

            //
            //  Lookup the attribute record from the Scb.
            //

            FindMoveableIndexRoot( IrpContext, Scb, IndexContext );

            //
            //  Get out if someone has changed the file record.
            //

            if (Sp->CapturedLsn.QuadPart !=
                NtfsContainingFileRecord(&IndexContext->AttributeContext)->Lsn.QuadPart) {

                DebugTrace( -1, Dbg, ("FindNextIndexEntry -> FALSE (must restart)\n") );

                *MustRestart = TRUE;
                return FALSE;
            }

        //
        //  Index Buffer case.
        //

        } else {

            //
            //  If the index buffer is unpinned, then see if we can read it and if it is
            //  unchanged.
            //

            if (!ReadIndexBuffer( IrpContext, Scb, 0, TRUE, Sp )) {

                DebugTrace( -1, Dbg, ("FindNextIndexEntry -> FALSE (must restart)\n") );

                *MustRestart = TRUE;
                return FALSE;
            }
        }
    }

    //
    //  Load up some locals.
    //

    IndexEntry = Sp->IndexEntry;

    //
    //  Loop until we hit a non-end record which is case-insensitive
    //  lexicgraphically greater than the target string.  We also pop
    //  out the middle if we encounter the end record in the Index Root.
    //

    do {

        //
        //  We last left our hero potentially somewhere in the middle of the
        //  Btree.  If he is asking for the next record, we advance one entry
        //  in the current Index Buffer.  If we are in an intermediate
        //  Index Buffer (there is a Btree Vcn), then we must move down
        //  through the first record in each intermediate Buffer until we hit
        //  the first leaf buffer (no Btree Vcn).
        //

        if (NextFlag) {

            LONGLONG IndexBlock;

            if (IndexEntry->Length == 0) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
            }

            Sp->IndexEntry =
            IndexEntry = NtfsNextIndexEntry( IndexEntry );

            NtfsCheckIndexBound( IndexEntry, Sp->IndexHeader );

            while (FlagOn(IndexEntry->Flags, INDEX_ENTRY_NODE)) {

                IndexBlock = NtfsIndexEntryBlock(IndexEntry);
                Sp += 1;

                //
                //  If the tree is balanced we cannot go too far here.
                //

                if (Sp >= IndexContext->Base + (ULONG)IndexContext->NumberEntries) {

                    ASSERT(Sp < IndexContext->Base + (ULONG)IndexContext->NumberEntries);

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                }

                NtfsUnpinBcb( IrpContext, &Sp->Bcb );

                ReadIndexBuffer( IrpContext,
                                 Scb,
                                 IndexBlock,
                                 FALSE,
                                 Sp );

                IndexEntry = Sp->IndexEntry;
                NtfsCheckIndexBound( IndexEntry, Sp->IndexHeader );
            }

            //
            //  Check for and mark corrupt if we find an empty leaf.
            //

            if ((Sp != IndexContext->Base)

                    &&

                FlagOn(NtfsFirstIndexEntry(Sp->IndexHeader)->Flags, INDEX_ENTRY_END)) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
            }
        }

        //
        //  We could be pointing to an end record, either because of
        //  FindFirstIndexEntry or because NextFlag was TRUE, and we
        //  bumped our pointer to an end record.  At any rate, if so, we
        //  move up the tree, rereading as required, until we find an entry
        //  which is not an end record, or until we hit the end record in the
        //  root, which means we hit the end of the Index.
        //

        while (FlagOn(IndexEntry->Flags, INDEX_ENTRY_END)) {

            if (Sp == IndexContext->Base) {

                DebugTrace( -1, Dbg, ("FindNextIndexEntry -> FALSE (End of Index)\n") );

                return FALSE;
            }

            Sp -= 1;

            //
            //  If there is no Bcb for the current buffer, then we are continuing
            //  an enumeration.
            //

            if (Sp->Bcb == NULL) {

                //
                //  Index Root case.
                //

                if (Sp == IndexContext->Base) {

                    //
                    //  Lookup the attribute record from the Scb.
                    //

                    FindMoveableIndexRoot( IrpContext, Scb, IndexContext );

                    //
                    //  Get out if someone has changed the file record.
                    //

                    if (Sp->CapturedLsn.QuadPart !=
                        NtfsContainingFileRecord(&IndexContext->AttributeContext)->Lsn.QuadPart) {

                        DebugTrace( -1, Dbg, ("FindNextIndexEntry -> FALSE (must restart)\n") );

                        *MustRestart = TRUE;
                        return FALSE;
                    }

                //
                //  Index Buffer case.
                //

                } else {

                    //
                    //  If the index buffer is unpinned, then see if we can read it and if it is
                    //  unchanged.
                    //

                    if (!ReadIndexBuffer( IrpContext, Scb, 0, TRUE, Sp )) {

                        DebugTrace( -1, Dbg, ("FindNextIndexEntry -> FALSE (must restart)\n") );

                        *MustRestart = TRUE;
                        return FALSE;
                    }
                }
            }

            IndexEntry = Sp->IndexEntry;
            NtfsCheckIndexBound( IndexEntry, Sp->IndexHeader );
        }

        //
        //  For a view Index, we either need to call the MatchFunction in the Index
        //  Context (if ValueContainsWildCards is TRUE), or else we look for equality
        //  from the CollateFunction in the Scb.
        //

        if (FlagOn(Scb->ScbState, SCB_STATE_VIEW_INDEX)) {

            INDEX_ROW IndexRow;
            NTSTATUS Status;

            IndexRow.KeyPart.Key = IndexEntry + 1;
            IndexRow.KeyPart.KeyLength = IndexEntry->AttributeLength;

            //
            //  Now, if ValueContainsWildcards is TRUE, then we are doing multiple
            //  returns via the match function (for NtOfsReadRecords).
            //

            if (ValueContainsWildcards) {

                IndexRow.DataPart.Data = Add2Ptr( IndexEntry, IndexEntry->DataOffset );
                IndexRow.DataPart.DataLength = IndexEntry->DataLength;

                if ((Status = IndexContext->MatchFunction(&IndexRow,
                                                          IndexContext->MatchData)) == STATUS_SUCCESS) {

                    IndexContext->Current = Sp;
                    Sp->IndexEntry = IndexEntry;

                    return TRUE;

                //
                //  Get out if no more matches.
                //

                } else if (Status == STATUS_NO_MORE_MATCHES) {
                    return FALSE;
                }
                BlindResult = GreaterThan;

            //
            //  Otherwise, we are looking for an exact match via the CollateFunction.
            //

            } else {

                if ((BlindResult =
                     Scb->ScbType.Index.CollationFunction((PINDEX_KEY)Value,
                                                          &IndexRow.KeyPart,
                                                          Scb->ScbType.Index.CollationData)) == EqualTo) {

                    IndexContext->Current = Sp;
                    Sp->IndexEntry = IndexEntry;

                    return TRUE;
                }
            }

        //
        //  At this point, we have a real live entry that we have to check
        //  for a match.  Describe its name, see if its a match, and return
        //  TRUE if it is.
        //

        } else if (ValueContainsWildcards) {

            if ((*NtfsIsInExpression[Scb->ScbType.Index.CollationRule])
                                     ( UpcaseTable,
                                       Value,
                                       IndexEntry,
                                       IgnoreCase )) {

                IndexContext->Current = Sp;
                Sp->IndexEntry = IndexEntry;

                DebugTrace( 0, Dbg, ("IndexEntry < %08lx\n", IndexEntry) );
                DebugTrace( -1, Dbg, ("FindNextIndexEntry -> TRUE\n") );

                return TRUE;
            }

        } else {

            if ((*NtfsIsEqual[Scb->ScbType.Index.CollationRule])
                              ( UpcaseTable,
                                Value,
                                IndexEntry,
                                IgnoreCase )) {

                IndexContext->Current = Sp;
                Sp->IndexEntry = IndexEntry;

                DebugTrace( 0, Dbg, ("IndexEntry < %08lx\n", IndexEntry) );
                DebugTrace( -1, Dbg, ("FindNextIndexEntry -> TRUE\n") );

                return TRUE;
            }
        }

        //
        //  If we loop back up, we must set NextFlag to TRUE.  We are
        //  currently on a valid non-end entry now.  Before looping back,
        //  check to see if we are beyond end of Target string by doing
        //  a case blind compare (IgnoreCase == TRUE).
        //

        NextFlag = TRUE;

        //
        //  For enumerations in view indices, keep going and only terminate
        //  on the MatchFunction (BlindResult was set to GreaterThan above).
        //  If it is not an enumeration (no wild cards), we already set BlindResult
        //  when we called the colation routine above.
        //

        if (!FlagOn(Scb->ScbState, SCB_STATE_VIEW_INDEX)) {

            BlindResult = (*NtfsCompareValues[Scb->ScbType.Index.CollationRule])
                                              ( UpcaseTable,
                                                UpcaseTableSize,
                                                Value,
                                                IndexEntry,
                                                GreaterThan,
                                                TRUE );
        }

    //
    //  The following while clause is not as bad as it looks, and it will
    //  evaluate quickly for the IgnoreCase == TRUE case.  We have
    //  already done an IgnoreCase compare above, and stored the result
    //  in BlindResult.
    //
    //  If we are doing an IgnoreCase TRUE find, we should keep going if
    //  BlindResult is either GreaterThan or EqualTo.
    //
    //  If we are doing an IgnoreCase FALSE scan, then also continue if
    //  BlindResult is GreaterThan, but if BlindResult is EqualTo, we
    //  can only proceed if we are also GreaterThan or EqualTo case
    //  sensitive (i.e. != LessThan).  This means that the Compare Values
    //  call in the following expresssion will never occur in an IgnoreCase
    //  TRUE scan (Windows default).
    //

    } while ((BlindResult == GreaterThan)

                    ||

             ((BlindResult == EqualTo)

                        &&

                (IgnoreCase

                            ||

                ((*NtfsCompareValues[Scb->ScbType.Index.CollationRule])
                                                         ( UpcaseTable,
                                                           UpcaseTableSize,
                                                           Value,
                                                           IndexEntry,
                                                           GreaterThan,
                                                           FALSE ) != LessThan))));

    DebugTrace( -1, Dbg, ("FindNextIndexEntry -> FALSE (end of expression)\n") );

    return FALSE;
}


//
//  Internal routine
//

PATTRIBUTE_RECORD_HEADER
FindMoveableIndexRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN OUT PINDEX_CONTEXT IndexContext
    )

/*++

Routine Description:

    This routine looks up the index root attribute again after it has potentially
    moved.  As a side effect it reloads any other fields in the index context that
    could have changed, so callers should always call this routine first before
    accessing the other values.

Arguments:

    Scb - Scb for the index

    IndexContext - The index context assumed to already be pointing to the
                   active search path

Return Value:

    The address of the Index Root attribute record header.

--*/

{
    PATTRIBUTE_RECORD_HEADER OldAttribute, Attribute;
    PINDEX_ROOT IndexRoot;
    PBCB SavedBcb;
    BOOLEAN Found;

    PAGED_CODE();

    //
    //  Check to see if the captured Lsn in the IndexContext matches
    //  the one currently in the file record.  If it does match, then
    //  we know that the Index Root cannot possibly have moved and that
    //  the information in IndexContext->AttributeContext is up-to-date.
    //

    if (
        //
        //  There's a pointer to a file record
        //

        IndexContext->AttributeContext.FoundAttribute.FileRecord != NULL &&

        //
        //  Quad parts of Lsn match
        //

        IndexContext->IndexRootFileRecordLsn.QuadPart ==
            IndexContext->AttributeContext.FoundAttribute.FileRecord->Lsn.QuadPart) {

        return NtfsFoundAttribute(&IndexContext->AttributeContext);

    }

    OldAttribute = IndexContext->OldAttribute;

    //
    //  Temporarily save the Bcb for the index root, and unpin at the end,
    //  so that it does not get unexpectedly unmapped and remapped when our
    //  caller knows it can't actually move.
    //

    SavedBcb = IndexContext->AttributeContext.FoundAttribute.Bcb;
    IndexContext->AttributeContext.FoundAttribute.Bcb = NULL;

    NtfsCleanupAttributeContext( IrpContext, &IndexContext->AttributeContext );
    NtfsInitializeAttributeContext( &IndexContext->AttributeContext );

    try {

        Found =
        NtfsLookupAttributeByName( IrpContext,
                                   Scb->Fcb,
                                   &Scb->Fcb->FileReference,
                                   $INDEX_ROOT,
                                   &Scb->AttributeName,
                                   NULL,
                                   FALSE,
                                   &IndexContext->AttributeContext );

        ASSERT(Found);

        //
        //  Now we have to reload our attribute pointer and point to the root
        //

        IndexContext->OldAttribute =
            Attribute = NtfsFoundAttribute(&IndexContext->AttributeContext);
        IndexRoot = (PINDEX_ROOT)NtfsAttributeValue(Attribute);

        //
        //  Reload start of buffer and index header appropriately.
        //

        IndexContext->Base->StartOfBuffer =
          (PVOID)NtfsContainingFileRecord(&IndexContext->AttributeContext);

        IndexContext->Base->IndexHeader = &IndexRoot->IndexHeader;

        //
        //  Relocate the index entry on the search path by moving its pointer the
        //  same number of bytes that the attribute moved.
        //

        IndexContext->Base->IndexEntry = (PINDEX_ENTRY)((PCHAR)IndexContext->Base->IndexEntry +
                                                        ((PCHAR)Attribute - (PCHAR)OldAttribute));
        //
        //  Save Lsn of file record containing Index Root so that later
        //  we can tell if we need to re-find it.
        //

        IndexContext->IndexRootFileRecordLsn =
            IndexContext->AttributeContext.FoundAttribute.FileRecord->Lsn;

    } finally {

        NtfsUnpinBcb( IrpContext, &SavedBcb );
    }

    return Attribute;
}


PINDEX_ENTRY
BinarySearchIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN OUT PINDEX_LOOKUP_STACK Sp,
    IN PVOID Value
    )

/*++

Routine Description:

    This routine does a binary search of the current index buffer, for the first entry
    in the buffer which is lexigraphically less than or equal to the input value, when
    compared case-insensitive (if relevant).

Arguments:

    Scb - Supplies the Scb for the index.

    Sp - Supplies a pointer to a lookup stack entry describing the current buffer.

    Value - Pointer to a value or value expression which should be used to position
            the IndexContext.

Return Value:

    None.

--*/

{
    PINDEX_HEADER IndexHeader;
    PINDEX_ENTRY IndexTemp, IndexLast;
    ULONG LowIndex, HighIndex, TryIndex;
    PINDEX_ENTRY LocalEntries[BINARY_SEARCH_ENTRIES];
    PINDEX_ENTRY *Table = LocalEntries;
    ULONG SizeOfTable = BINARY_SEARCH_ENTRIES;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("BinarySearchIndex\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("Sp = %08lx\n", Sp) );
    DebugTrace( 0, Dbg, ("Value = %08lx\n", Value) );

    //
    //  Set up to fill in our binary search vector.
    //

    IndexHeader = Sp->IndexHeader;
    IndexTemp = (PINDEX_ENTRY)((PCHAR)IndexHeader + IndexHeader->FirstIndexEntry);
    IndexLast = (PINDEX_ENTRY)((PCHAR)IndexHeader + IndexHeader->FirstFreeByte);

    //
    //  Check that there will be at least 1 entry in the index.
    //

    if (IndexHeader->FirstIndexEntry >= IndexHeader->FirstFreeByte) {

        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
    }

    //
    //  Fill in the binary search vector, first trying our local vector, and
    //  allocating a larger one if we need to.
    //

    HighIndex = 0;
    while (TRUE) {

        while (IndexTemp < IndexLast) {

            //
            //  See if we are about to store off the end of the table.  If
            //  so we will have to go allocate a bigger one.
            //

            if (HighIndex >= SizeOfTable) {
                break;
            }

            Table[HighIndex] = IndexTemp;

            //
            //  Check for a corrupt IndexEntry where the length is zero.  Since
            //  Length is unsigned, we can't test for it being negative.
            //

            if (IndexTemp->Length == 0) {
                if (Table != LocalEntries) {
                    NtfsFreePool( Table );
                }
                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
            }

            IndexTemp = (PINDEX_ENTRY)((PCHAR)IndexTemp + IndexTemp->Length);
            HighIndex += 1;
        }

        //
        //  If we got them all, then get out.
        //

        if (IndexTemp >= IndexLast) {
            break;
        }

        if (Table != LocalEntries) {

            ASSERT( Table != LocalEntries );
            NtfsFreePool( Table );

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
        }

        //
        //  Otherwise we have to allocate one.  Calculate the worst case
        //  and allocate it.
        //

        SizeOfTable = (IndexHeader->BytesAvailable /
                        (sizeof(INDEX_ENTRY) + sizeof(LARGE_INTEGER))) + 2;
        Table = (PINDEX_ENTRY *)NtfsAllocatePool(PagedPool, SizeOfTable * sizeof(PINDEX_ENTRY));
        RtlMoveMemory( Table, LocalEntries, BINARY_SEARCH_ENTRIES * sizeof(PINDEX_ENTRY) );
    }

    //
    //  Now do a binary search of the buffer to find the lowest entry
    //  (ignoring case) that is <= to the search value.  During the
    //  binary search, LowIndex is always maintained as the lowest
    //  possible Index Entry that is <=, and HighIndex is maintained as
    //  the highest possible Index that could be the first <= match.
    //  Thus the loop exits when LowIndex == HighIndex.
    //

    ASSERT(HighIndex);

    HighIndex -= 1;
    LowIndex = 0;

    //
    //  For view indices, we collate via the CollationFunction in the Scb.
    //

    if (FlagOn(Scb->ScbState, SCB_STATE_VIEW_INDEX)) {

        INDEX_KEY IndexKey;

        while (LowIndex != HighIndex) {

            TryIndex = LowIndex + (HighIndex - LowIndex) / 2;

            IndexKey.Key = Table[TryIndex] + 1;
            IndexKey.KeyLength = Table[TryIndex]->AttributeLength;

            if (!FlagOn( Table[TryIndex]->Flags, INDEX_ENTRY_END )

                    &&

                (Scb->ScbType.Index.CollationFunction((PINDEX_KEY)Value,
                                                      &IndexKey,
                                                      Scb->ScbType.Index.CollationData) == GreaterThan)) {
                LowIndex = TryIndex + 1;
            }
            else {
                HighIndex = TryIndex;
            }
        }

    } else {

        while (LowIndex != HighIndex) {

            PWCH UpcaseTable = IrpContext->Vcb->UpcaseTable;
            ULONG UpcaseTableSize = IrpContext->Vcb->UpcaseTableSize;

            TryIndex = LowIndex + (HighIndex - LowIndex) / 2;

            if (!FlagOn( Table[TryIndex]->Flags, INDEX_ENTRY_END )

                    &&

                (*NtfsCompareValues[Scb->ScbType.Index.CollationRule])
                                    ( UpcaseTable,
                                      UpcaseTableSize,
                                      Value,
                                      Table[TryIndex],
                                      LessThan,
                                      TRUE ) == GreaterThan) {
                LowIndex = TryIndex + 1;
            }
            else {
                HighIndex = TryIndex;
            }
        }
    }

    //
    //  Capture the return pointer and free our binary search table.
    //

    IndexTemp = Table[LowIndex];

    if (Table != LocalEntries) {
        NtfsFreePool( Table );
    }

    //
    //  When we exit the loop, we have the answer.
    //

    DebugTrace( -1, Dbg, ("BinarySearchIndex -> %08lx\n", IndexTemp) );

    return IndexTemp;
}


BOOLEAN
AddToIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PINDEX_ENTRY InsertIndexEntry,
    IN OUT PINDEX_CONTEXT IndexContext,
    OUT PQUICK_INDEX QuickIndex OPTIONAL,
    IN BOOLEAN FindRoot
    )

/*++

Routine Description:

    This routine inserts an index entry into the Btree, possibly performing
    one or more buffer splits as required.

    The caller has positioned the index context to point to the correct
    insertion point in a leaf buffer, via calls to FindFirstIndexEntry and
    FindNextIndexEntry.  The index context thus not only points to the
    insertion point, but it also shows where index entries will have to be
    promoted in the event of buffer splits.

    This routine employs tail-end recursion, to eliminate the cost of nested
    calls.  For the first insert and all potential subsequent inserts due to
    bucket splits, all work is completed at the current level in the Btree,
    and then the InsertIndexEntry input parameter is reloaded (and the lookup
    stack pointer is adjusted), before looping back in the while loop to do
    any necessary insert at the next level in the tree.

    Each pass through the loop dispatches to one of four routines to handle
    the following cases:

        Simple insert in the root
        Push the root down (add one level to the tree) if the root is full
        Simple insert in an index allocation buffer
        Buffer split of a full index allocation buffer

Arguments:

    Scb - Supplies the Scb for the index.

    InsertIndexEntry - pointer to the index entry to insert.

    IndexContext - Index context describing the path to the insertion point.

    QuickIndex - If specified we store the location of the index added.

    FindRoot - Supplies TRUE if the context cannot be trusted and we should find
               the root first.

Return Value:

    FALSE -- if the stack did not have to be pushed
    TRUE -- if the stack was pushed

--*/

{
    PFCB Fcb = Scb->Fcb;
    PINDEX_LOOKUP_STACK Sp = IndexContext->Current;
    BOOLEAN DeleteIt = FALSE;
    BOOLEAN FirstPass = TRUE;
    BOOLEAN StackWasPushed = FALSE;
    BOOLEAN ReturnValue;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("AddToIndex\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("InsertIndexEntry = %08lx\n", InsertIndexEntry) );
    DebugTrace( 0, Dbg, ("IndexContext = %08lx\n", IndexContext) );

    try {

        //
        //  This routine uses "tail-end" recursion, so we just want to keep looping
        //  until we do an insert (either in the Index Root or the Index Allocation)
        //  that does not require a split.
        //

        while (TRUE) {

            IndexContext->Current = Sp;

            //
            //  First see if this is an insert in the root or a leaf.
            //

            if (Sp == IndexContext->Base) {

                PFILE_RECORD_SEGMENT_HEADER FileRecord;
                PATTRIBUTE_RECORD_HEADER Attribute;

                FileRecord = (PFILE_RECORD_SEGMENT_HEADER)Sp->StartOfBuffer;
                Attribute = NtfsFoundAttribute(&IndexContext->AttributeContext);

                //
                //  If the caller is telling us we need to look up the root again,
                //  then do so.
                //

                if (FindRoot) {
                    Attribute = FindMoveableIndexRoot( IrpContext, Scb, IndexContext );
                }

                //
                //  Now see if there is enough room to do a simple insert, or if
                //  there is not enough room, see if we are small enough ourselves
                //  to demand the room be made anyway.
                //

                if ((InsertIndexEntry->Length <=
                     (USHORT) (FileRecord->BytesAvailable - FileRecord->FirstFreeByte))

                        ||

                    ((InsertIndexEntry->Length + Attribute->RecordLength) <
                     Scb->Vcb->BigEnoughToMove)) {

                    //
                    //  If FALSE is returned, then the space was not allocated and
                    //  we have too loop back and try again.  Second time must work.
                    //

                    while (!NtfsChangeAttributeSize( IrpContext,
                                                     Fcb,
                                                     Attribute->RecordLength + InsertIndexEntry->Length,
                                                     &IndexContext->AttributeContext )) {

                        //
                        //  Lookup the attribute again.
                        //

                        Attribute = FindMoveableIndexRoot( IrpContext, Scb, IndexContext );
                    }

                    InsertSimpleRoot( IrpContext,
                                      Scb,
                                      InsertIndexEntry,
                                      IndexContext );

                    //
                    //  If we have a quick index then store a buffer offset of zero
                    //  to indicate the root index.
                    //

                    if (ARGUMENT_PRESENT( QuickIndex )) {

                        QuickIndex->BufferOffset = 0;
                    }

                    DebugTrace( -1, Dbg, ("AddToIndex -> VOID\n") );

                    ReturnValue = StackWasPushed;
                    leave;

                //
                //  Otherwise we have to push the current root down a level into
                //  the allocation, and try our insert again by looping back.
                //

                } else {

                    //
                    //  Our insertion point will now also be pushed, so we
                    //  have to increment the stack pointer.
                    //

                    Sp += 1;

                    if (Sp >= IndexContext->Base + (ULONG)IndexContext->NumberEntries) {
                        NtfsGrowLookupStack( Scb,
                                             IndexContext,
                                             &Sp );
                    }

                    PushIndexRoot( IrpContext, Scb, IndexContext );
                    StackWasPushed = TRUE;
                    continue;
                }

            //
            //  Otherwise this insert is in the Index Allocation, not the Index
            //  Root.
            //

            } else {

                //
                //  See if there is enough room to do a simple insert.
                //

                if (InsertIndexEntry->Length <=
                    (USHORT)(Sp->IndexHeader->BytesAvailable - Sp->IndexHeader->FirstFreeByte)) {

                    InsertSimpleAllocation( IrpContext,
                                            Scb,
                                            InsertIndexEntry,
                                            Sp,
                                            QuickIndex );

                    DebugTrace( -1, Dbg, ("AddToIndex -> VOID\n") );

                    ReturnValue = StackWasPushed;
                    leave;

                //
                //  Otherwise, we have to do a buffer split in the allocation.
                //

                } else {

                    //
                    //  Call this local routine to do the buffer split.  It
                    //  returns a pointer to a new entry to insert, which is
                    //  allocated in the nonpaged pool.
                    //

                    PINDEX_ENTRY NewInsertIndexEntry;

                    NewInsertIndexEntry =
                        InsertWithBufferSplit( IrpContext,
                                               Scb,
                                               InsertIndexEntry,
                                               IndexContext,
                                               QuickIndex );

                    //
                    //  Remove the old key being inserted if we've
                    //  allocated it.
                    //

                    if (DeleteIt) {

                        NtfsFreePool( InsertIndexEntry );

                    }

                    //
                    //  Clear the QuickIndex pointer so we don't corrupt the captured
                    //  information.
                    //

                    QuickIndex = NULL;

                    //
                    //  Now we have to delete this index entry, since it was dynamically
                    //  allocated by InsertWithBufferSplit.
                    //

                    InsertIndexEntry = NewInsertIndexEntry;
                    DeleteIt = TRUE;

                    //
                    //  The middle entry from the old buffer must now get
                    //  inserted at the insertion point in its parent.
                    //

                    Sp -= 1;
                    continue;
                }
            }
        }
    } finally {

        if (DeleteIt) {

            NtfsFreePool( InsertIndexEntry );

        }
    }

    return ReturnValue;
}


VOID
InsertSimpleRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PINDEX_ENTRY InsertIndexEntry,
    IN OUT PINDEX_CONTEXT IndexContext
    )

/*++

Routine Description:

    This routine is called to do a simple insertion of a new index entry into the
    root, when it is known that it will fit.  It calls a routine common wiht
    restart to do the insert, and then logs the insert.

Arguments:

    Scb - Supplies the Scb for the index.

    InsertIndexEntry - Pointer to the index entry to insert.

    IndexContext - Index context describing the position in the root at which
                   the insert is to occur.

Return Value:

    None

--*/

{
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PATTRIBUTE_RECORD_HEADER Attribute;
    PINDEX_ENTRY BeforeIndexEntry;
    PATTRIBUTE_ENUMERATION_CONTEXT Context = &IndexContext->AttributeContext;
    PVCB Vcb;
    BOOLEAN Inserted = FALSE;

    PAGED_CODE();

    Vcb = Scb->Vcb;

    DebugTrace( +1, Dbg, ("InsertSimpleRoot\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("InsertIndexEntry = %08lx\n", InsertIndexEntry) );
    DebugTrace( 0, Dbg, ("IndexContext = %08lx\n", IndexContext) );

    try {

        //
        //  Extract all of the updates required by the restart routine we
        //  will call.
        //

        FileRecord = NtfsContainingFileRecord( Context );
        Attribute = NtfsFoundAttribute( Context );
        BeforeIndexEntry = IndexContext->Base->IndexEntry;

        //
        //  Pin the page
        //

        NtfsPinMappedAttribute( IrpContext, Vcb, Context );

        //
        //  Call the same routine used by restart to actually apply the
        //  update.
        //

        NtfsRestartInsertSimpleRoot( IrpContext,
                                     InsertIndexEntry,
                                     FileRecord,
                                     Attribute,
                                     BeforeIndexEntry );

        Inserted = TRUE;

        CheckRoot();

        //
        //  Now that the Index Entry is guaranteed to be in place, log
        //  this update.  Note that the new record is now at the address
        //  we calculated in BeforeIndexEntry.
        //

        FileRecord->Lsn =
        NtfsWriteLog( IrpContext,
                      Vcb->MftScb,
                      NtfsFoundBcb(Context),
                      AddIndexEntryRoot,
                      BeforeIndexEntry,
                      BeforeIndexEntry->Length,
                      DeleteIndexEntryRoot,
                      NULL,
                      0,
                      NtfsMftOffset( Context ),
                      (ULONG)((PCHAR)Attribute - (PCHAR)FileRecord),
                      (ULONG)((PCHAR)BeforeIndexEntry - (PCHAR)Attribute),
                      Vcb->BytesPerFileRecordSegment );

    } finally {

        DebugUnwind( InsertSimpleRoot );

        //
        //  If we failed after inserting the record, it must be because we failed to write the
        //  log record.  If that happened, then the record will not be
        //  deleted by the transaction abort, so we have to do it here
        //  by hand.
        //

        if (AbnormalTermination() && Inserted) {

            NtfsRestartDeleteSimpleRoot( IrpContext,
                                         BeforeIndexEntry,
                                         FileRecord,
                                         Attribute );
        }

    }

    DebugTrace( -1, Dbg, ("InsertSimpleRoot -> VOID\n") );
}


VOID
NtfsRestartInsertSimpleRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PINDEX_ENTRY InsertIndexEntry,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PATTRIBUTE_RECORD_HEADER Attribute,
    IN PINDEX_ENTRY BeforeIndexEntry
    )

/*++

Routine Description:

    This is a restart routine used both in normal operation and during restart.
    It is called to do a simple insertion of a new index entry into the
    root, when it is known that it will fit.  It does no logging.

Arguments:

    InsertIndexEntry - Pointer to the index entry to insert.

    FileRecord - Pointer to the file record in which the insert is to occur.

    Attribute - Pointer to the attribute record header for the index root.

    BeforeIndexEntry - Pointer to the index entry which is currently sitting
                       at the point at which the insert is to occur.


Return Value:

    None

--*/

{
    PINDEX_ROOT IndexRoot;
    PINDEX_HEADER IndexHeader;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRestartInsertSimpleRoot\n") );
    DebugTrace( 0, Dbg, ("InsertIndexEntry = %08lx\n", InsertIndexEntry) );
    DebugTrace( 0, Dbg, ("FileRecord = %08lx\n", FileRecord) );
    DebugTrace( 0, Dbg, ("Attribute = %08lx\n", Attribute) );
    DebugTrace( 0, Dbg, ("BeforeIndexEntry = %08lx\n", BeforeIndexEntry) );

    //
    //  Form some pointers within the attribute value.
    //

    IndexRoot = (PINDEX_ROOT)NtfsAttributeValue(Attribute);
    IndexHeader = &IndexRoot->IndexHeader;

    //
    //  Grow the space for our attribute record as required.
    //

    NtfsRestartChangeAttributeSize( IrpContext,
                                    FileRecord,
                                    Attribute,
                                    Attribute->RecordLength +
                                      InsertIndexEntry->Length );

    //
    //  Now move the tail end of the index to make room for the new entry.
    //

    RtlMoveMemory( (PCHAR)BeforeIndexEntry + InsertIndexEntry->Length,
                   BeforeIndexEntry,
                   ((PCHAR)IndexHeader + IndexHeader->FirstFreeByte) -
                    (PCHAR)BeforeIndexEntry );

    //
    //  Move the new Index Entry into place.  The index entry may either
    //  be a complete index entry, or it may be in pointer form.
    //

    if (FlagOn(InsertIndexEntry->Flags, INDEX_ENTRY_POINTER_FORM)) {

        RtlMoveMemory( BeforeIndexEntry, InsertIndexEntry, sizeof(INDEX_ENTRY) );
        RtlMoveMemory( (PVOID)(BeforeIndexEntry + 1),
                       *(PVOID *)(InsertIndexEntry + 1),
                       InsertIndexEntry->AttributeLength );

        //
        //  In pointer form the Data Pointer follows the key pointer, but there is
        //  none for normal directory indices.
        //

        if (*(PVOID *)((PCHAR)InsertIndexEntry + sizeof(INDEX_ENTRY) + sizeof(PVOID)) != NULL) {
            RtlMoveMemory( (PVOID)((PCHAR)BeforeIndexEntry + InsertIndexEntry->DataOffset),
                           *(PVOID *)((PCHAR)InsertIndexEntry + sizeof(INDEX_ENTRY) + sizeof(PVOID)),
                           InsertIndexEntry->DataLength );
        }

        ClearFlag( BeforeIndexEntry->Flags, INDEX_ENTRY_POINTER_FORM );

    } else {

        RtlMoveMemory( BeforeIndexEntry, InsertIndexEntry, InsertIndexEntry->Length );
    }

    //
    //  Update the index header by the space we grew by.
    //

    Attribute->Form.Resident.ValueLength += InsertIndexEntry->Length;
    IndexHeader->FirstFreeByte += InsertIndexEntry->Length;
    IndexHeader->BytesAvailable += InsertIndexEntry->Length;

    DebugTrace( -1, Dbg, ("NtfsRestartInsertSimpleRoot -> VOID\n") );
}


VOID
PushIndexRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN OUT PINDEX_CONTEXT IndexContext
    )

/*++

Routine Description:

    This routine is called to push the index root down a level, thus adding a
    level to the Btree.  If the Index Allocation and Bitmap attributes for this
    index do not already exist, then they are created here prior to pushing the
    root down.  This routine performs the push down and logs the changes (either
    directly or by calling routines which log their own changes).

Arguments:

    Scb - Supplies the Scb for the index.

    IndexContext - Index context describing the position in the root at which
                   the insert is to occur.

Return Value:

    None

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AllocationContext;
    ATTRIBUTE_ENUMERATION_CONTEXT BitMapContext;
    LARGE_MCB Mcb;
    PINDEX_ALLOCATION_BUFFER IndexBuffer;
    PINDEX_HEADER IndexHeaderR, IndexHeaderA;
    PINDEX_LOOKUP_STACK Sp;
    ULONG SizeToMove;
    USHORT AttributeFlags;
    LONGLONG EndOfValidData;

    struct {
        INDEX_ROOT IndexRoot;
        INDEX_ENTRY IndexEntry;
        LONGLONG IndexBlock;
    } R;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("PushIndexRoot\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("IndexContext = %08lx\n", IndexContext) );

    //
    //  Initialize everything (only Mcb can fail), then set up to cleanup
    //  on the way out.
    //

    RtlZeroMemory( &R, sizeof(R) );
    FsRtlInitializeLargeMcb( &Mcb, NonPagedPool );
    NtfsInitializeAttributeContext( &AllocationContext );
    NtfsInitializeAttributeContext( &BitMapContext );

    //
    //  Allocate a buffer to save away the current index root, as we will
    //  have to start by deleting it.
    //

    SizeToMove = IndexContext->Base->IndexHeader->FirstFreeByte;
    IndexHeaderR = NtfsAllocatePool(PagedPool, SizeToMove );

    try {

        //
        //  Save away the current index root, then delete it.  This should
        //  insure that we have enough space to create/extend the index allocation
        //  and bitmap attributes.
        //

        AttributeFlags = NtfsFoundAttribute(&IndexContext->AttributeContext)->Flags;
        RtlMoveMemory( IndexHeaderR,
                       IndexContext->Base->IndexHeader,
                       SizeToMove );

        NtfsDeleteAttributeRecord( IrpContext,
                                   Scb->Fcb,
                                   DELETE_LOG_OPERATION |
                                    DELETE_RELEASE_FILE_RECORD |
                                    DELETE_RELEASE_ALLOCATION,
                                   &IndexContext->AttributeContext );

        //
        //  If the IndexAllocation isn't there, then we have to create both
        //  the Index Allocation and Bitmap attributes.
        //

        if (!NtfsLookupAttributeByName( IrpContext,
                                        Scb->Fcb,
                                        &Scb->Fcb->FileReference,
                                        $INDEX_ALLOCATION,
                                        &Scb->AttributeName,
                                        NULL,
                                        FALSE,
                                        &AllocationContext )) {

            //
            //  Allocate the Index Allocation attribute.  Always allocate at
            //  least one cluster.
            //

            EndOfValidData = Scb->ScbType.Index.BytesPerIndexBuffer;

            if ((ULONG) EndOfValidData < Scb->Vcb->BytesPerCluster) {

                EndOfValidData = Scb->Vcb->BytesPerCluster;
            }

            NtfsAllocateAttribute( IrpContext,
                                   Scb,
                                   $INDEX_ALLOCATION,
                                   &Scb->AttributeName,
                                   0,
                                   TRUE,
                                   TRUE,
                                   EndOfValidData,
                                   NULL );

            Scb->Header.AllocationSize.QuadPart = EndOfValidData;

            SetFlag( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED );

            //
            //  Now create the BitMap attribute.
            //

            NtfsCreateAttributeWithValue( IrpContext,
                                          Scb->Fcb,
                                          $BITMAP,
                                          &Scb->AttributeName,
                                          &Li0,
                                          sizeof(LARGE_INTEGER),
                                          0,
                                          NULL,
                                          TRUE,
                                          &BitMapContext );
        }

        //
        //  Take some pains here to preserve the IndexContext for the case that
        //  we are called from AddToIndex, when it is called from DeleteFromIndex,
        //  because we still need some of the stack then.  The caller must have
        //  insured the stack is big enough for him.  Move all but two entries,
        //  because we do not need to move the root, and we cannot move the last
        //  entry since it would go off the end of the structure!
        //

        ASSERT(IndexContext->NumberEntries > 2);

        //
        //  Do an unpin on the entry that will be overwritten.
        //

        NtfsUnpinBcb( IrpContext, &IndexContext->Base[IndexContext->NumberEntries - 1].Bcb );

        RtlMoveMemory( IndexContext->Base + 2,
                       IndexContext->Base + 1,
                       (IndexContext->NumberEntries - 2) * sizeof(INDEX_LOOKUP_STACK) );

        //
        //  Now point our local pointer to where the root will be pushed to, and
        //  clear the Bcb pointer in the stack there, since it was copied above.
        //  Advance top and current because of the move.
        //

        Sp = IndexContext->Base + 1;
        Sp->Bcb = NULL;
        IndexContext->Top += 1;
        IndexContext->Current += 1;

        //
        //  Allocate a buffer to hold the pushed down entries.
        //

        IndexBuffer = GetIndexBuffer( IrpContext, Scb, Sp, &EndOfValidData );

        //
        //  Point now to the new index header.
        //

        IndexHeaderA = Sp->IndexHeader;

        //
        //  Now do the push down and fix up the IndexEntry pointer for
        //  the new buffer.
        //

        SizeToMove = IndexHeaderR->FirstFreeByte - IndexHeaderR->FirstIndexEntry;
        RtlMoveMemory( NtfsFirstIndexEntry(IndexHeaderA),
                       NtfsFirstIndexEntry(IndexHeaderR),
                       SizeToMove );

        Sp->IndexEntry = (PINDEX_ENTRY)((PCHAR)(Sp-1)->IndexEntry +
                         ((PCHAR)IndexHeaderA - (PCHAR)((Sp-1)->IndexHeader)) +
                         (IndexHeaderA->FirstIndexEntry -
                           IndexHeaderR->FirstIndexEntry));

        IndexHeaderA->FirstFreeByte += SizeToMove;
        IndexHeaderA->Flags = IndexHeaderR->Flags;

        //
        //  Finally, log the pushed down buffer.
        //

        CheckBuffer(IndexBuffer);

        IndexBuffer->Lsn =
        NtfsWriteLog( IrpContext,
                      Scb,
                      Sp->Bcb,
                      UpdateNonresidentValue,
                      IndexBuffer,
                      FIELD_OFFSET( INDEX_ALLOCATION_BUFFER,IndexHeader ) +
                        IndexHeaderA->FirstFreeByte,
                      Noop,
                      NULL,
                      0,
                      LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                      0,
                      0,
                      Scb->ScbType.Index.BytesPerIndexBuffer );

        //
        //  Remember if we extended the valid data for this Scb.
        //

        if (EndOfValidData > Scb->Header.ValidDataLength.QuadPart) {

            Scb->Header.ValidDataLength.QuadPart = EndOfValidData;

            NtfsWriteFileSizes( IrpContext,
                                Scb,
                                &Scb->Header.ValidDataLength.QuadPart,
                                TRUE,
                                TRUE,
                                TRUE );
        }

        //
        //  Now initialize an image of the new root.
        //

        if (!FlagOn(Scb->ScbState, SCB_STATE_VIEW_INDEX)) {
            R.IndexRoot.IndexedAttributeType = Scb->ScbType.Index.AttributeBeingIndexed;
        } else {
            R.IndexRoot.IndexedAttributeType = $UNUSED;
        }
        R.IndexRoot.CollationRule = (COLLATION_RULE)Scb->ScbType.Index.CollationRule;
        R.IndexRoot.BytesPerIndexBuffer = Scb->ScbType.Index.BytesPerIndexBuffer;
        R.IndexRoot.BlocksPerIndexBuffer = Scb->ScbType.Index.BlocksPerIndexBuffer;
        R.IndexRoot.IndexHeader.FirstIndexEntry = (ULONG)((PCHAR)&R.IndexEntry -
                                                  (PCHAR)&R.IndexRoot.IndexHeader);
        R.IndexRoot.IndexHeader.FirstFreeByte =
        R.IndexRoot.IndexHeader.BytesAvailable = QuadAlign(sizeof(INDEX_HEADER)) +
                                                 QuadAlign(sizeof(INDEX_ENTRY)) +
                                                 sizeof(LONGLONG);
        SetFlag( R.IndexRoot.IndexHeader.Flags, INDEX_NODE );

        R.IndexEntry.Length = sizeof(INDEX_ENTRY) + sizeof(LONGLONG);
        R.IndexEntry.Flags = INDEX_ENTRY_NODE | INDEX_ENTRY_END;
        R.IndexBlock = IndexBuffer->ThisBlock;

        //
        //  Now recreate the index root.
        //

        NtfsCleanupAttributeContext( IrpContext, &IndexContext->AttributeContext );
        NtfsCreateAttributeWithValue( IrpContext,
                                      Scb->Fcb,
                                      $INDEX_ROOT,
                                      &Scb->AttributeName,
                                      (PVOID)&R,
                                      sizeof(R),
                                      AttributeFlags,
                                      NULL,
                                      TRUE,
                                      &IndexContext->AttributeContext );

        //
        //  We just pushed the index root, so let's find it again and
        //  fix up the caller's context.  Note that he will try to
        //  recalculate the IndexEntry pointer, but we know that it
        //  has to change to point to the single entry in the new root.
        //

        FindMoveableIndexRoot( IrpContext, Scb, IndexContext );
        (Sp-1)->IndexEntry = NtfsFirstIndexEntry((Sp-1)->IndexHeader);

    } finally {

        DebugUnwind( PushIndexRoot );

        NtfsFreePool( IndexHeaderR );
        FsRtlUninitializeLargeMcb( &Mcb );
        NtfsCleanupAttributeContext( IrpContext, &AllocationContext );
        NtfsCleanupAttributeContext( IrpContext, &BitMapContext );
    }

    DebugTrace( -1, Dbg, ("PushIndexRoot -> VOID\n") );
}


VOID
InsertSimpleAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PINDEX_ENTRY InsertIndexEntry,
    IN PINDEX_LOOKUP_STACK Sp,
    OUT PQUICK_INDEX QuickIndex OPTIONAL
    )

/*++

Routine Description:

    This routine does a simple insert in an index buffer in the index
    allocation.  It calls a routine common with restart to do the insert,
    and then it logs the change.

Arguments:

    Scb - Supplies the Scb for the index.

    InsertIndexEntry - Address of the index entry to be inserted.

    Sp - Pointer to the lookup stack location describing the insertion
         point.

    QuickIndex - If specified we store the location of the index added.

Return Value:

    None

--*/

{
    PINDEX_ALLOCATION_BUFFER IndexBuffer;
    PINDEX_ENTRY BeforeIndexEntry;
    BOOLEAN Inserted = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("InsertSimpleAllocation\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("InsertIndexEntry = %08lx\n", InsertIndexEntry) );
    DebugTrace( 0, Dbg, ("Sp = %08lx\n", Sp) );

    try {

        //
        //  Extract all of the updates required by the restart routine we
        //  will call.
        //

        IndexBuffer = (PINDEX_ALLOCATION_BUFFER)Sp->StartOfBuffer;
        BeforeIndexEntry = Sp->IndexEntry;

        //
        //  Pin the page
        //

        NtfsPinMappedData( IrpContext,
                           Scb,
                           LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                           Scb->ScbType.Index.BytesPerIndexBuffer,
                           &Sp->Bcb );

        //
        //  Call the same routine used by restart to actually apply the
        //  update.
        //

        NtfsRestartInsertSimpleAllocation( InsertIndexEntry,
                                           IndexBuffer,
                                           BeforeIndexEntry );
        Inserted = TRUE;

        CheckBuffer(IndexBuffer);

        //
        //  Now that the Index Entry is guaranteed to be in place, log
        //  this update.  Note that the new record is now at the address
        //  we calculated in BeforeIndexEntry.
        //

        IndexBuffer->Lsn =
        NtfsWriteLog( IrpContext,
                      Scb,
                      Sp->Bcb,
                      AddIndexEntryAllocation,
                      BeforeIndexEntry,
                      BeforeIndexEntry->Length,
                      DeleteIndexEntryAllocation,
                      NULL,
                      0,
                      LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                      0,
                      (ULONG)((PCHAR)BeforeIndexEntry - (PCHAR)IndexBuffer),
                      Scb->ScbType.Index.BytesPerIndexBuffer );

        //
        //  Update the quick index buffer if we have it.
        //

        if (ARGUMENT_PRESENT( QuickIndex )) {

            QuickIndex->ChangeCount = Scb->ScbType.Index.ChangeCount;
            QuickIndex->BufferOffset = PtrOffset( Sp->StartOfBuffer, Sp->IndexEntry );
            QuickIndex->CapturedLsn = ((PINDEX_ALLOCATION_BUFFER) Sp->StartOfBuffer)->Lsn;
            QuickIndex->IndexBlock = ((PINDEX_ALLOCATION_BUFFER) Sp->StartOfBuffer)->ThisBlock;
        }

    } finally {

        DebugUnwind( InsertSimpleAllocation );

        //
        //  If we failed and already inserted the item,
        //  it must be because we failed to write the log record.  If that happened,
        //  then the record will not be deleted by the transaction abort,
        //  so we have to do it here by hand.
        //

        if (AbnormalTermination() && Inserted) {

            NtfsRestartDeleteSimpleAllocation( BeforeIndexEntry,
                                               IndexBuffer );
        }

    }

    DebugTrace( -1, Dbg, ("InsertSimpleAllocation -> VOID\n") );
}


VOID
NtfsRestartInsertSimpleAllocation (
    IN PINDEX_ENTRY InsertIndexEntry,
    IN PINDEX_ALLOCATION_BUFFER IndexBuffer,
    IN PINDEX_ENTRY BeforeIndexEntry
    )

/*++

Routine Description:

    This routine does a simple insert in an index buffer in the index
    allocation.  It performs this work either in the running system, or
    when called by restart.  It does no logging.

Arguments:

    InsertIndexEntry - Address of the index entry to be inserted.

    IndexBuffer - Pointer to the index buffer into which the insert is to
                  occur.

    BeforeIndexEntry - Pointer to the index entry currently residing at
                       the insertion point.

Return Value:

    None

--*/

{
    PINDEX_HEADER IndexHeader;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRestartInsertSimpleAllocation\n") );
    DebugTrace( 0, Dbg, ("InsertIndexEntry = %08lx\n", InsertIndexEntry) );
    DebugTrace( 0, Dbg, ("IndexBuffer = %08lx\n", IndexBuffer) );
    DebugTrace( 0, Dbg, ("BeforeIndexEntry = %08lx\n", BeforeIndexEntry) );

    //
    //  Form some pointers within the attribute value.
    //

    IndexHeader = &IndexBuffer->IndexHeader;

    //
    //  Now move the tail end of the index to make room for the new entry.
    //

    RtlMoveMemory( (PCHAR)BeforeIndexEntry + InsertIndexEntry->Length,
                   BeforeIndexEntry,
                   ((PCHAR)IndexHeader + IndexHeader->FirstFreeByte) -
                    (PCHAR)BeforeIndexEntry );

    //
    //  Move the new Index Entry into place.  The index entry may either
    //  be a complete index entry, or it may be in pointer form.
    //

    if (FlagOn(InsertIndexEntry->Flags, INDEX_ENTRY_POINTER_FORM)) {

        RtlMoveMemory( BeforeIndexEntry, InsertIndexEntry, sizeof(INDEX_ENTRY) );
        RtlMoveMemory( (PVOID)(BeforeIndexEntry + 1),
                       *(PVOID *)(InsertIndexEntry + 1),
                       InsertIndexEntry->AttributeLength );

        //
        //  In pointer form the Data Pointer follows the key pointer, but there is
        //  none for normal directory indices.
        //

        if (*(PVOID *)((PCHAR)InsertIndexEntry + sizeof(INDEX_ENTRY) + sizeof(PVOID)) != NULL) {
            RtlMoveMemory( (PVOID)((PCHAR)BeforeIndexEntry + InsertIndexEntry->DataOffset),
                           *(PVOID *)((PCHAR)InsertIndexEntry + sizeof(INDEX_ENTRY) + sizeof(PVOID)),
                           InsertIndexEntry->DataLength );
        }

        ClearFlag( BeforeIndexEntry->Flags, INDEX_ENTRY_POINTER_FORM );

    } else {

        RtlMoveMemory( BeforeIndexEntry, InsertIndexEntry, InsertIndexEntry->Length );
    }

    //
    //  Update the index header by the space we grew by.
    //

    IndexHeader->FirstFreeByte += InsertIndexEntry->Length;

    DebugTrace( -1, Dbg, ("NtfsRestartInsertSimpleAllocation -> VOID\n") );
}


PINDEX_ENTRY
InsertWithBufferSplit (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PINDEX_ENTRY InsertIndexEntry,
    IN OUT PINDEX_CONTEXT IndexContext,
    OUT PQUICK_INDEX QuickIndex OPTIONAL
    )

/*++

Routine Description:

    This routine is called to perform an insert in the index allocation, when
    it is known that a buffer split is necessary.  It splits the buffer in
    half, inserts the new entry in the appropriate half, fixes the Vcn pointer
    in the current parent, and returns a pointer to a new entry which is being
    promoted to insert at the next level up.

Arguments:

    Scb - Supplies the Scb for the index.

    InsertIndexEntry - Address of the index entry to be inserted.

    IndexContext - Index context describing the position in the stack at which
                   the insert with split is to occur.

    QuickIndex - If specified we store the location of the index added.

Return Value:

    Pointer to the index entry which must now be inserted at the next level.

--*/

{
    PINDEX_ALLOCATION_BUFFER IndexBuffer, IndexBuffer2;
    PINDEX_HEADER IndexHeader, IndexHeader2;
    PINDEX_ENTRY BeforeIndexEntry, MiddleIndexEntry, MovingIndexEntry;
    PINDEX_ENTRY ReturnIndexEntry = NULL;
    INDEX_LOOKUP_STACK Stack2;
    PINDEX_LOOKUP_STACK Sp;
    ULONG LengthToMove;
    ULONG Buffer2Length;
    LONGLONG EndOfValidData;

    struct {
        INDEX_ENTRY IndexEntry;
        LONGLONG IndexBlock;
    } NewEnd;

    PVCB Vcb;

    Vcb = Scb->Vcb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("InsertWithBufferSplit\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("InsertIndexEntry = %08lx\n", InsertIndexEntry) );
    DebugTrace( 0, Dbg, ("IndexContext = %08lx\n", IndexContext) );

    Stack2.Bcb = NULL;
    Sp = IndexContext->Current;

    try {

        //
        //  Extract all of the updates required by the restart routine we
        //  will call.
        //

        IndexBuffer = (PINDEX_ALLOCATION_BUFFER)Sp->StartOfBuffer;
        IndexHeader = &IndexBuffer->IndexHeader;
        BeforeIndexEntry = Sp->IndexEntry;

        //
        //  Pin the page
        //

        NtfsPinMappedData( IrpContext,
                           Scb,
                           LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                           Scb->ScbType.Index.BytesPerIndexBuffer,
                           &Sp->Bcb );

        //
        //  Allocate an index buffer to take the second half of the splitting
        //  one.
        //

        IndexBuffer2 = GetIndexBuffer( IrpContext,
                                       Scb,
                                       &Stack2,
                                       &EndOfValidData );

        IndexHeader2 = &IndexBuffer2->IndexHeader;

        //
        //  Scan to find the middle index entry that we will promote to
        //  the next level up, and the next one after him.
        //

        MiddleIndexEntry = NtfsFirstIndexEntry(IndexHeader);
        NtfsCheckIndexBound( MiddleIndexEntry, IndexHeader );

        if (MiddleIndexEntry->Length == 0) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
        }

        while (((ULONG)((PCHAR)MiddleIndexEntry - (PCHAR)IndexHeader) +
                 (ULONG)MiddleIndexEntry->Length) < IndexHeader->BytesAvailable / 2) {

            MovingIndexEntry = MiddleIndexEntry;
            MiddleIndexEntry = NtfsNextIndexEntry(MiddleIndexEntry);

            NtfsCheckIndexBound( MiddleIndexEntry, IndexHeader );

            if (MiddleIndexEntry->Length == 0) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
            }
        }

        //
        //  We found an entry to elevate but if the next entry is the end
        //  record we want to go back one entry.
        //

        if (FlagOn( NtfsNextIndexEntry(MiddleIndexEntry)->Flags, INDEX_ENTRY_END )) {

            MiddleIndexEntry = MovingIndexEntry;
        }
        MovingIndexEntry = NtfsNextIndexEntry(MiddleIndexEntry);

        NtfsCheckIndexBound( MovingIndexEntry, IndexHeader );

        if (MovingIndexEntry->Length == 0) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
        }
        //
        //  Allocate space to hold this middle entry, and copy it out.
        //

        ReturnIndexEntry = NtfsAllocatePool( NonPagedPool,
                                              MiddleIndexEntry->Length +
                                                sizeof(LONGLONG) );
        RtlMoveMemory( ReturnIndexEntry,
                       MiddleIndexEntry,
                       MiddleIndexEntry->Length );

        if (!FlagOn(ReturnIndexEntry->Flags, INDEX_ENTRY_NODE)) {
            SetFlag( ReturnIndexEntry->Flags, INDEX_ENTRY_NODE );
            ReturnIndexEntry->Length += sizeof(LONGLONG);
        }

        //
        //  Now move the second half of the splitting buffer over to the
        //  new one, and fix it up.
        //

        LengthToMove = IndexHeader->FirstFreeByte - (ULONG)((PCHAR)MovingIndexEntry -
                                                     (PCHAR)IndexHeader);

        RtlMoveMemory( NtfsFirstIndexEntry(IndexHeader2),
                       MovingIndexEntry,
                       LengthToMove );

        IndexHeader2->FirstFreeByte += LengthToMove;
        IndexHeader2->Flags = IndexHeader->Flags;

        //
        //  Now the new Index Buffer is done, so lets log its contents.
        //

        Buffer2Length = FIELD_OFFSET( INDEX_ALLOCATION_BUFFER,IndexHeader ) +
                        IndexHeader2->FirstFreeByte;

        CheckBuffer(IndexBuffer2);

        IndexBuffer2->Lsn =
        NtfsWriteLog( IrpContext,
                      Scb,
                      Stack2.Bcb,
                      UpdateNonresidentValue,
                      IndexBuffer2,
                      Buffer2Length,
                      Noop,
                      NULL,
                      0,
                      LlBytesFromIndexBlocks( IndexBuffer2->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                      0,
                      0,
                      Scb->ScbType.Index.BytesPerIndexBuffer );

        //
        //  Remember if we extended the valid data for this Scb.
        //

        if (EndOfValidData > Scb->Header.ValidDataLength.QuadPart) {

            Scb->Header.ValidDataLength.QuadPart = EndOfValidData;

            NtfsWriteFileSizes( IrpContext,
                                Scb,
                                &Scb->Header.ValidDataLength.QuadPart,
                                TRUE,
                                TRUE,
                                TRUE );
        }

        //
        //  Now let's create the image of the new end record for the
        //  splitting index buffer.
        //

        RtlZeroMemory( &NewEnd.IndexEntry, sizeof(INDEX_ENTRY) );
        NewEnd.IndexEntry.Length = sizeof(INDEX_ENTRY);
        NewEnd.IndexEntry.Flags = INDEX_ENTRY_END;

        if (FlagOn(MiddleIndexEntry->Flags, INDEX_ENTRY_NODE)) {
            NewEnd.IndexEntry.Length += sizeof(LONGLONG);
            SetFlag( NewEnd.IndexEntry.Flags, INDEX_ENTRY_NODE );
            NewEnd.IndexBlock = NtfsIndexEntryBlock(MiddleIndexEntry);
        }

        //
        //  Write a log record to set the new end of the splitting buffer.
        //

        IndexBuffer->Lsn =
        NtfsWriteLog( IrpContext,
                      Scb,
                      Sp->Bcb,
                      WriteEndOfIndexBuffer,
                      &NewEnd,
                      NewEnd.IndexEntry.Length,
                      WriteEndOfIndexBuffer,
                      MiddleIndexEntry,
                      MiddleIndexEntry->Length + LengthToMove,
                      LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                      0,
                      (ULONG)((PCHAR)MiddleIndexEntry - (PCHAR)IndexBuffer),
                      Scb->ScbType.Index.BytesPerIndexBuffer );

        //
        //  Now call the restart routine to write the new end of the index
        //  buffer.
        //

        NtfsRestartWriteEndOfIndex( IndexHeader,
                                    MiddleIndexEntry,
                                    (PINDEX_ENTRY)&NewEnd,
                                    NewEnd.IndexEntry.Length );

        CheckBuffer(IndexBuffer);

        //
        //  Now that we are done splitting IndexBuffer and IndexBuffer2, we
        //  need to figure out which one our original entry was inserting into,
        //  and do the simple insert.  Going into the first half is trivial,
        //  and follows:
        //

        if (BeforeIndexEntry < MovingIndexEntry) {

            InsertSimpleAllocation( IrpContext, Scb, InsertIndexEntry, Sp, QuickIndex );

        //
        //  If it is going into the second half, we just have to fix up the
        //  stack descriptor for the buffer we allocated, and do the insert
        //  there.  To fix it up we just have to do a little arithmetic to
        //  find the insert position.
        //

        } else {

            Stack2.IndexEntry = (PINDEX_ENTRY)((PCHAR)BeforeIndexEntry +
                                  ((PCHAR)NtfsFirstIndexEntry(IndexHeader2) -
                                   (PCHAR)MovingIndexEntry));
            InsertSimpleAllocation( IrpContext,
                                    Scb,
                                    InsertIndexEntry,
                                    &Stack2,
                                    QuickIndex );
        }

        //
        //  Now we just have to set the correct Vcns in the two index entries
        //  that point to IndexBuffer and IndexBuffer2 after the split.  The
        //  first one is easy; its Vcn goes into the IndexEntry we are
        //  returning with to insert in our parent.  The second one we have
        //  have to fix up is the index entry pointing to the buffer that
        //  split, since it must now point to the new buffer.  It should look
        //  like this:
        //
        //      ParentIndexBuffer: ...(ReturnIndexEntry) (ParentIndexEntry)...
        //                                   |                  |
        //                                   |                  |
        //                                   V                  V
        //                               IndexBuffer        IndexBuffer2
        //

        NtfsSetIndexEntryBlock( ReturnIndexEntry, IndexBuffer->ThisBlock );

        //
        //  Decrement our stack pointer to point to the stack entry describing
        //  our parent.
        //

        Sp -= 1;

        //
        //  First handle the case where our parent is the Index Root.
        //

        if (Sp == IndexContext->Base) {

            PFILE_RECORD_SEGMENT_HEADER FileRecord;
            PATTRIBUTE_RECORD_HEADER Attribute;
            PATTRIBUTE_ENUMERATION_CONTEXT Context = &IndexContext->AttributeContext;

            Attribute = FindMoveableIndexRoot( IrpContext, Scb, IndexContext );

            //
            //  Pin the page
            //

            NtfsPinMappedAttribute( IrpContext, Vcb, Context );

            //
            //  Write a log record to change our ParentIndexEntry.
            //

            FileRecord = NtfsContainingFileRecord(Context);

            FileRecord->Lsn =
            NtfsWriteLog( IrpContext,
                          Vcb->MftScb,
                          NtfsFoundBcb(Context),
                          SetIndexEntryVcnRoot,
                          &IndexBuffer2->ThisBlock,
                          sizeof(LONGLONG),
                          SetIndexEntryVcnRoot,
                          &IndexBuffer->ThisBlock,
                          sizeof(LONGLONG),
                          NtfsMftOffset( Context ),
                          (ULONG)((PCHAR)Attribute - (PCHAR)FileRecord),
                          (ULONG)((PCHAR)Sp->IndexEntry - (PCHAR)Attribute),
                          Vcb->BytesPerFileRecordSegment );

        //
        //  Otherwise, our parent is also an Index Buffer.
        //

        } else {

            PINDEX_ALLOCATION_BUFFER ParentIndexBuffer;

            ParentIndexBuffer = (PINDEX_ALLOCATION_BUFFER)Sp->StartOfBuffer;

            //
            //  Pin the page
            //

            NtfsPinMappedData( IrpContext,
                               Scb,
                               LlBytesFromIndexBlocks( ParentIndexBuffer->ThisBlock,
                                                       Scb->ScbType.Index.IndexBlockByteShift ),
                               Scb->ScbType.Index.BytesPerIndexBuffer,
                               &Sp->Bcb );

            //
            //  Write a log record to change our ParentIndexEntry.
            //

            ParentIndexBuffer->Lsn =
            NtfsWriteLog( IrpContext,
                          Scb,
                          Sp->Bcb,
                          SetIndexEntryVcnAllocation,
                          &IndexBuffer2->ThisBlock,
                          sizeof(LONGLONG),
                          SetIndexEntryVcnAllocation,
                          &IndexBuffer->ThisBlock,
                          sizeof(LONGLONG),
                          LlBytesFromIndexBlocks( ParentIndexBuffer->ThisBlock,
                                                  Scb->ScbType.Index.IndexBlockByteShift ),
                          0,
                          (ULONG)((PCHAR)Sp->IndexEntry - (PCHAR)ParentIndexBuffer),
                          Scb->ScbType.Index.BytesPerIndexBuffer );
        }

        //
        //  Now call the Restart routine to do it.
        //

        NtfsRestartSetIndexBlock( Sp->IndexEntry,
                                  IndexBuffer2->ThisBlock );

    } finally {

        DebugUnwind( InsertWithBufferSplit );

        if (AbnormalTermination( )) {

            if (ReturnIndexEntry != NULL) {

                NtfsFreePool( ReturnIndexEntry );

            }

        }

        NtfsUnpinBcb( IrpContext, &Stack2.Bcb );

    }

    DebugTrace( -1, Dbg, ("InsertWithBufferSplit -> VOID\n") );

    return ReturnIndexEntry;
}


VOID
NtfsRestartWriteEndOfIndex (
    IN PINDEX_HEADER IndexHeader,
    IN PINDEX_ENTRY OverwriteIndexEntry,
    IN PINDEX_ENTRY FirstNewIndexEntry,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine is used both in normal operation and at restart to
    update the end of an index buffer, as one of the consequences of
    a buffer split.  Since it is called at restart, it does no logging.

Arguments:

    IndexHeader - Supplies a pointer to the IndexHeader of the buffer
                  whose end is being rewritten.

    OverWriteIndexEntry - Points to the index entry in the buffer at which
                          the overwrite of the end is to occur.

    FirstNewIndexEntry - Points to the first entry in the buffer which is
                         to overwrite the end of the current buffer.

    Length - Supplies the length of the index entries being written to the
             end of the buffer, in bytes.

Return Value:

    None

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRestartWriteEndOfIndex\n") );
    DebugTrace( 0, Dbg, ("IndexHeader = %08lx\n", IndexHeader) );
    DebugTrace( 0, Dbg, ("OverwriteIndexEntry = %08lx\n", OverwriteIndexEntry) );
    DebugTrace( 0, Dbg, ("FirstNewIndexEntry = %08lx\n", FirstNewIndexEntry) );
    DebugTrace( 0, Dbg, ("Length = %08lx\n", Length) );

    IndexHeader->FirstFreeByte = (ULONG)((PCHAR)OverwriteIndexEntry - (PCHAR)IndexHeader) +
                                 Length;
    RtlMoveMemory( OverwriteIndexEntry, FirstNewIndexEntry, Length );

    DebugTrace( -1, Dbg, ("NtfsRestartWriteEndOfIndex -> VOID\n") );
}


VOID
NtfsRestartSetIndexBlock(
    IN PINDEX_ENTRY IndexEntry,
    IN LONGLONG IndexBlock
    )

/*++

Routine Description:

    This routine updates the IndexBlock in an index entry, for both normal operation and
    restart.  Therefore it does no logging.

Arguments:

    IndexEntry - Supplies a pointer to the index entry whose Vcn is to be overwritten.

    IndexBlock - The index block which is to be written to the index entry.

Return Value:

    None

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRestartSetIndexBlock\n") );
    DebugTrace( 0, Dbg, ("IndexEntry = %08lx\n", IndexEntry) );
    DebugTrace( 0, Dbg, ("IndexBlock = %016I64x\n", IndexBlock) );

    NtfsSetIndexEntryBlock( IndexEntry, IndexBlock );

    DebugTrace( -1, Dbg, ("NtfsRestartSetIndexEntryBlock -> VOID\n") );
}


VOID
NtfsRestartUpdateFileName(
    IN PINDEX_ENTRY IndexEntry,
    IN PDUPLICATED_INFORMATION Info
    )

/*++

Routine Description:

    This routine updates the duplicated information in a file name index entry,
    for both normal operation and restart.  Therefore it does no logging.

Arguments:

    IndexEntry - Supplies a pointer to the index entry whose Vcn is to be overwritten.

    Info - Pointer to the duplicated information for the update.

Return Value:

    None

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRestartUpdateFileName\n") );
    DebugTrace( 0, Dbg, ("IndexEntry = %08lx\n", IndexEntry) );
    DebugTrace( 0, Dbg, ("Info = %08lx\n", Info) );

    RtlMoveMemory( &((PFILE_NAME)(IndexEntry + 1))->Info,
                   Info,
                   sizeof(DUPLICATED_INFORMATION) );

    DebugTrace( -1, Dbg, ("NtfsRestartUpdateFileName -> VOID\n") );
}


VOID
DeleteFromIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN OUT PINDEX_CONTEXT IndexContext
    )

/*++

Routine Description:

    This routine deletes an entry from an index, deleting any empty index buffers
    as required.

    The steps are as follows:

        1.  If the entry to be deleted is not a leaf, then find a leaf entry to
            delete which can be used to replace the entry we want to delete.

        2.  Delete the desired index entry, or the replacement we found.  If we
            delete a replacement, remember it for reinsertion later, in step 4 or
            6 below.

        3.  Now prune empty buffers from the tree, if any, starting with the buffer
            we just deleted an entry from.

        4.  If the original target was an intermediate entry, then delete it now,
            and replace it with the entry we deleted in its place in 2 above.  As
            a special case, if all of the descendent buffers of the target went away,
            then we do not have to replace it, so we hang onto the replacement for
            reinsertion.

        5.  When we pruned the index back, we may have stopped on an entry which is
            now childless.  If this is the case, then we have to delete this childless
            entry and reinsert it in the next step.  (If this is the case, then we
            are guaranteed to not still have another entry to reinsert from 2 above!)

        6.  Finally, at this point we may have an entry that needs to be reinserted
            from either step 2 or 5 above.  If so, we do this reinsert now, and we
            are done.

Arguments:

    Scb - Supplies the Scb for the index.

    IndexContext - Describes the entry to delete, including the entire path through
                   it from root to leaf.

Return Value:

    None

--*/

{
    //
    //  It is possible that one or two Index Entries will have to be reinserted.
    //  However, we need to remember at most one at once.
    //

    PINDEX_ENTRY ReinsertEntry = NULL;

    //
    //  A pointer to keep track of where we are in the Index Lookup Stack.
    //

    PINDEX_LOOKUP_STACK Sp = IndexContext->Current;

    //
    //  Some Index entry pointers to remember the next entry to delete, and
    //  the original target if it is an intermediate node.
    //

    PINDEX_ENTRY TargetEntry = NULL;
    PINDEX_ENTRY DeleteEntry;

    //
    //  Two other Lookup Stack pointers we may have to remember.
    //

    PINDEX_LOOKUP_STACK TargetSp;
    PINDEX_LOOKUP_STACK DeleteSp;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("DeleteFromIndex\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("IndexContext = %08lx\n", IndexContext) );

    //
    //  Use try-finally to free pool on the way out.
    //

    try {

        //
        //  Step 1.
        //
        //  If we are supposed to delete an entry in an intermediate buffer,
        //  then we have to find in index entry lower in the tree to replace
        //  him.  (In fact we will delete the lower entry first, and get around
        //  to deleting the one we really want to delete later after possibly
        //  pruning the tree back.)  For right now just find the replacement
        //  to delete first, and save him away.
        //

        DeleteEntry = Sp->IndexEntry;
        if (FlagOn(DeleteEntry->Flags, INDEX_ENTRY_NODE)) {

            PINDEX_ALLOCATION_BUFFER IndexBuffer;
            PINDEX_HEADER IndexHeader;
            PINDEX_ENTRY NextEntry;

            //
            //  Remember the real target we need to delete.
            //

            TargetEntry = DeleteEntry;
            TargetSp = Sp;

            //
            //  Go to the top of the stack (bottom of the index) and find the
            //  largest index entry in that buffer to be our replacement.
            //

            Sp =
            IndexContext->Current = IndexContext->Top;

            IndexBuffer = (PINDEX_ALLOCATION_BUFFER)Sp->StartOfBuffer;
            IndexHeader = &IndexBuffer->IndexHeader;
            NextEntry = NtfsFirstIndexEntry(IndexHeader);
            NtfsCheckIndexBound( NextEntry, IndexHeader );

            do {

                DeleteEntry = NextEntry;
                NextEntry = NtfsNextIndexEntry(NextEntry);

                NtfsCheckIndexBound( NextEntry, IndexHeader );
                if (NextEntry->Length == 0) {

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                }

            } while (!FlagOn(NextEntry->Flags, INDEX_ENTRY_END));

            //
            //  Now we have to save this guy away because we will have to
            //  reinsert him later.
            //

            ReinsertEntry = (PINDEX_ENTRY)NtfsAllocatePool( NonPagedPool,
                                                             DeleteEntry->Length +
                                                               sizeof(LONGLONG) );

            RtlMoveMemory( ReinsertEntry, DeleteEntry, DeleteEntry->Length );
        }

        //
        //  Step 2.
        //
        //  Now it's time to delete either our target or replacement entry at
        //  DeleteEntry.
        //

        DeleteSimple( IrpContext, Scb, DeleteEntry, IndexContext );
        DeleteEntry = NULL;

        //
        //  Step 3.
        //
        //  Now we need to see if the tree has to be "pruned" back some to
        //  eliminate any empty buffers.  In the extreme case this routine
        //  returns the root to the state of being an empty directory.  This
        //  routine returns a pointer to DeleteEntry if it leaves an entry
        //  in the tree somewhere which is pointing to a deleted buffer, and
        //  has to be reinserted elsewhere.  We only have to prune if we are
        //  not currently in the root anyway.
        //
        //  Remember the DeleteSp, which is where PruneIndex left the stack
        //  pointer.
        //

        if (Sp != IndexContext->Base) {
            PruneIndex( IrpContext, Scb, IndexContext, &DeleteEntry );
            DeleteSp = IndexContext->Current;
        }

        //
        //  Step 4.
        //
        //  Now we have deleted someone, and possibly pruned the tree back.
        //  It is time to see if our original target has not yet been deleted
        //  yet and deal with that.  First we just delete it, then we see if
        //  we really need to replace it.  If the whole tree under it went
        //  empty (TargetEntry == DeleteEntry), then we do not have to replace
        //  it and we will reinsert its replacement below.  Otherwise, do the
        //  replace now.
        //

        if (TargetEntry != NULL) {

            LONGLONG SavedBlock;

            //
            //  Reload in case root moved
            //

            if (TargetSp == IndexContext->Base) {
                TargetEntry = TargetSp->IndexEntry;
            }

            //
            //  Save the Vcn in case we need it for the reinsert.
            //

            SavedBlock = NtfsIndexEntryBlock(TargetEntry);

            //
            //  Delete it.
            //

            IndexContext->Current = TargetSp;
            DeleteSimple( IrpContext, Scb, TargetEntry, IndexContext );

            //
            //  See if this is exactly the same guy who went childless anyway
            //  when we pruned the tree.  If not replace him now.
            //

            if (TargetEntry != DeleteEntry) {

                //
                //  We know the replacement entry was a leaf, so give him the
                //  block number now.
                //

                SetFlag( ReinsertEntry->Flags, INDEX_ENTRY_NODE );
                ReinsertEntry->Length += sizeof(LONGLONG);
                NtfsSetIndexEntryBlock( ReinsertEntry, SavedBlock );

                //
                //  Now we are all set up to just call our local routine to
                //  go insert our replacement.  If the stack gets pushed,
                //  we have to increment our DeleteSp.
                //

                if (AddToIndex( IrpContext, Scb, ReinsertEntry, IndexContext, NULL, TRUE )) {
                    DeleteSp += 1;
                }

                //
                //  We may need to save someone else away below, but it could
                //  be a different size anyway, so let's just delete the
                //  current ReinsertEntry now.
                //

                NtfsFreePool( ReinsertEntry );
                ReinsertEntry = NULL;

            //
            //  Otherwise, we just deleted the same index entry who went
            //  childless during pruning, so clear our pointer to show that we
            //  so not have to deal with him later.
            //

            } else {

                DeleteEntry = NULL;
            }
        }

        //
        //  Step 5.
        //
        //  Now there may still be a childless entry to deal with after the
        //  pruning above, if it did not turn out to be the guy we were deleting
        //  anyway.  Note that if we have to do this delete, the ReinsertEntry
        //  pointer is guaranteed to be NULL.  If our original target was not
        //  an intermediate node, then we never allocated one to begin with.
        //  Otherwise we passed through the preceding block of code, and either
        //  cleared ReinsertEntry or DeleteEntry.
        //

        if (DeleteEntry != NULL) {

            ASSERT( ReinsertEntry == NULL );

            //
            //  Now we have to save this guy away because we will have to
            //  reinsert him later.
            //

            ReinsertEntry = (PINDEX_ENTRY)NtfsAllocatePool( NonPagedPool,
                                                             DeleteEntry->Length );
            RtlMoveMemory( ReinsertEntry, DeleteEntry, DeleteEntry->Length );

            //
            //  We know the guy we are saving is an intermediate node, and that
            //  we no longer need his Vcn, since we deleted that buffer.  Make
            //  the guy a leaf entry now.  (We don't actually care about the
            //  Vcn, but we do this cleanup here in case the interface to
            //  NtfsAddIndexEntry were to change to take an initialized
            //  index entry.)
            //

            ClearFlag( ReinsertEntry->Flags, INDEX_ENTRY_NODE );
            ReinsertEntry->Length -= sizeof(LONGLONG);

            //
            //  Delete it.
            //

            IndexContext->Current = DeleteSp;
            DeleteSimple( IrpContext, Scb, DeleteEntry, IndexContext );
        }

        //
        //  Step 6.
        //
        //  Finally, we may have someone to reinsert now.  This will either be
        //  someone we deleted as a replacement for our actual target, and then
        //  found out we did not need, or it could be just some entry that we
        //  had to delete just above, because the index buffers below him went
        //  empty and got deleted.
        //
        //  In any case, we can no longer use the IndexContext we were called
        //  with because it no longer indicates where the replacement goes.  We
        //  solve this by calling our top most external entry to do the insert.
        //

        if (ReinsertEntry != NULL) {

            if (!FlagOn(Scb->ScbState, SCB_STATE_VIEW_INDEX)) {

                NtfsAddIndexEntry( IrpContext,
                                   Scb,
                                   (PVOID)(ReinsertEntry + 1),
                                   NtfsFileNameSize((PFILE_NAME)(ReinsertEntry + 1)),
                                   &ReinsertEntry->FileReference,
                                   NULL,
                                   NULL );

            } else {

                INDEX_ROW IndexRow;

                IndexRow.KeyPart.Key = ReinsertEntry + 1;
                IndexRow.KeyPart.KeyLength = ReinsertEntry->AttributeLength;
                IndexRow.DataPart.Data = Add2Ptr(ReinsertEntry, ReinsertEntry->DataOffset);
                IndexRow.DataPart.DataLength = ReinsertEntry->DataLength;

                NtOfsAddRecords( IrpContext,
                                 Scb,
                                 1,
                                 &IndexRow,
                                 FALSE );
            }
        }

    //
    //  Use the finally clause to free a potential ReinsertEntry we may
    //  have allocated.
    //

    } finally {

        DebugUnwind( DeleteFromIndex );

        if (ReinsertEntry != NULL) {

            NtfsFreePool( ReinsertEntry );
        }
    }

    DebugTrace( -1, Dbg, ("DeleteFromIndex -> VOID\n") );
}


VOID
DeleteSimple (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PINDEX_ENTRY IndexEntry,
    IN OUT PINDEX_CONTEXT IndexContext
    )

/*++

Routine Description:

    This routine does a simple insertion of an index entry, from either the
    root or from an index allocation buffer.  It writes the appropriate log
    record first and then calls a routine in common with restart.

Arguments:

    Scb - Supplies the Scb for the index.

    IndexEntry - Points to the index entry to delete.

    IndexContext - Describes the path to the index entry we are deleting.

Return Value:

    None

--*/

{
    PVCB Vcb = Scb->Vcb;
    PINDEX_LOOKUP_STACK Sp = IndexContext->Current;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("DeleteSimple\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("IndexEntry = %08lx\n", IndexEntry) );
    DebugTrace( 0, Dbg, ("IndexContext = %08lx\n", IndexContext) );

    //
    //  Our caller never checks if he is deleting in the root or in the
    //  index allocation, so the first thing we do is check that.
    //
    //  First we will handle the root case.
    //

    if (Sp == IndexContext->Base) {

        PFILE_RECORD_SEGMENT_HEADER FileRecord;
        PATTRIBUTE_RECORD_HEADER Attribute;
        PATTRIBUTE_ENUMERATION_CONTEXT Context;

        //
        //  Initialize pointers for the root case.
        //

        Attribute = FindMoveableIndexRoot( IrpContext, Scb, IndexContext );

        Context = &IndexContext->AttributeContext;
        FileRecord = NtfsContainingFileRecord( Context );

        //
        //  Pin the page before we start to modify it.
        //

        NtfsPinMappedAttribute( IrpContext, Vcb, Context );

        //
        //  Write the log record first while we can still see the attribute
        //  we are going to delete.
        //

        FileRecord->Lsn =
        NtfsWriteLog( IrpContext,
                      Vcb->MftScb,
                      NtfsFoundBcb(Context),
                      DeleteIndexEntryRoot,
                      NULL,
                      0,
                      AddIndexEntryRoot,
                      IndexEntry,
                      IndexEntry->Length,
                      NtfsMftOffset( Context ),
                      (ULONG)((PCHAR)Attribute - (PCHAR)FileRecord),
                      (ULONG)((PCHAR)IndexEntry - (PCHAR)Attribute),
                      Vcb->BytesPerFileRecordSegment );

        //
        //  Now call the same routine as Restart to actually delete it.
        //

        NtfsRestartDeleteSimpleRoot( IrpContext, IndexEntry, FileRecord, Attribute );

        CheckRoot();

    //
    //  Otherwise we are deleting in the index allocation, so do that here.
    //

    } else {

        PINDEX_ALLOCATION_BUFFER IndexBuffer;

        //
        //  Get the Index Buffer pointer from the stack.
        //

        IndexBuffer = (PINDEX_ALLOCATION_BUFFER)Sp->StartOfBuffer;

        //
        //  Pin the page before we start to modify it.
        //

        NtfsPinMappedData( IrpContext,
                           Scb,
                           LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                           Scb->ScbType.Index.BytesPerIndexBuffer,
                           &Sp->Bcb );

        //
        //  Write the log record now while the entry we are deleting is still
        //  there.
        //

        IndexBuffer->Lsn =
        NtfsWriteLog( IrpContext,
                      Scb,
                      Sp->Bcb,
                      DeleteIndexEntryAllocation,
                      NULL,
                      0,
                      AddIndexEntryAllocation,
                      IndexEntry,
                      IndexEntry->Length,
                      LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                      0,
                      (ULONG)((PCHAR)IndexEntry - (PCHAR)IndexBuffer),
                      Scb->ScbType.Index.BytesPerIndexBuffer );

        //
        //  Now call the same routine as Restart to delete the entry.
        //

        NtfsRestartDeleteSimpleAllocation( IndexEntry, IndexBuffer );

        CheckBuffer(IndexBuffer);
    }

    DebugTrace( -1, Dbg, ("DeleteSimple -> VOID\n") );
}


VOID
NtfsRestartDeleteSimpleRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PINDEX_ENTRY IndexEntry,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PATTRIBUTE_RECORD_HEADER Attribute
    )

/*++

Routine Description:

    This is a restart routine which does a simple deletion of an index entry
    from the Index Root, without logging.  It is also used at run time.

Arguments:

    IndexEntry - Points to the index entry to delete.

    FileRecord - Points to the file record in which the index root resides.

    Attribute - Points to the attribute record header for the index root.

Return Value:

    None

--*/

{
    PINDEX_ROOT IndexRoot;
    PINDEX_HEADER IndexHeader;
    PINDEX_ENTRY EntryAfter;
    ULONG SavedLength;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRestartDeleteSimpleRoot\n") );
    DebugTrace( 0, Dbg, ("IndexEntry = %08lx\n", IndexEntry) );
    DebugTrace( 0, Dbg, ("FileRecord = %08lx\n", FileRecord) );
    DebugTrace( 0, Dbg, ("Attribute = %08lx\n", Attribute) );

    //
    //  Form some pointers within the attribute value.
    //

    IndexRoot = (PINDEX_ROOT)NtfsAttributeValue(Attribute);
    IndexHeader = &IndexRoot->IndexHeader;
    SavedLength = (ULONG)IndexEntry->Length;
    EntryAfter = NtfsNextIndexEntry(IndexEntry);

    //
    //  Now move the tail end of the index to make room for the new entry.
    //

    RtlMoveMemory( IndexEntry,
                   EntryAfter,
                   ((PCHAR)IndexHeader + IndexHeader->FirstFreeByte) -
                     (PCHAR)EntryAfter );

    //
    //  Update the index header by the space we grew by.
    //

    Attribute->Form.Resident.ValueLength -= SavedLength;
    IndexHeader->FirstFreeByte -= SavedLength;
    IndexHeader->BytesAvailable -= SavedLength;

    //
    //  Now shrink the attribute record.
    //

    NtfsRestartChangeAttributeSize( IrpContext,
                                    FileRecord,
                                    Attribute,
                                    Attribute->RecordLength - SavedLength );

    DebugTrace( -1, Dbg, ("NtfsRestartDeleteSimpleRoot -> VOID\n") );
}


VOID
NtfsRestartDeleteSimpleAllocation (
    IN PINDEX_ENTRY IndexEntry,
    IN PINDEX_ALLOCATION_BUFFER IndexBuffer
    )

/*++

Routine Description:

    This is a restart routine which does a simple deletion of an index entry
    from an index allocation buffer, without logging.  It is also used at run time.

Arguments:

    IndexEntry - Points to the index entry to delete.

    IndexBuffer - Pointer to the index allocation buffer in which the delete is to
                  occur.

Return Value:

    None

--*/

{
    PINDEX_HEADER IndexHeader;
    PINDEX_ENTRY EntryAfter;
    ULONG SavedLength;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRestartDeleteSimpleAllocation\n") );
    DebugTrace( 0, Dbg, ("IndexEntry = %08lx\n", IndexEntry) );
    DebugTrace( 0, Dbg, ("IndexBuffer = %08lx\n", IndexBuffer) );

    //
    //  Form some pointers within the attribute value.
    //

    IndexHeader = &IndexBuffer->IndexHeader;
    EntryAfter = NtfsNextIndexEntry(IndexEntry);
    SavedLength = (ULONG)IndexEntry->Length;

    //
    //  Now move the tail end of the index to make room for the new entry.
    //

    RtlMoveMemory( IndexEntry,
                   EntryAfter,
                   ((PCHAR)IndexHeader + IndexHeader->FirstFreeByte) -
                    (PCHAR)EntryAfter );

    //
    //  Update the index header by the space we grew by.
    //

    IndexHeader->FirstFreeByte -= SavedLength;

    DebugTrace( -1, Dbg, ("NtfsRestartDeleteSimpleAllocation -> VOID\n") );
}


VOID
PruneIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN OUT PINDEX_CONTEXT IndexContext,
    OUT PINDEX_ENTRY *DeleteEntry
    )

/*++

Routine Description:

    This routine checks if any index buffers need to be deallocated, as the result
    of just having deleted an entry.  The logic of the main loop is described in
    detail below.  All changes are logged.

Arguments:

    Scb - Supplies the Scb of the index.

    IndexContext - describes the path to the index buffer in which the delete just
                   occured.

    DeleteEntry - Returns a pointer to an entry which must be deleted, because all
                  of the buffers below it were deleted.

Return Value:

    None

--*/

{
    PATTRIBUTE_ENUMERATION_CONTEXT Context;
    PINDEX_ALLOCATION_BUFFER IndexBuffer;
    PINDEX_HEADER IndexHeader;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PATTRIBUTE_RECORD_HEADER Attribute = NULL;
    PINDEX_LOOKUP_STACK Sp = IndexContext->Current;
    PVCB Vcb = Scb->Vcb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("PruneIndex\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("IndexContext = %08lx\n", IndexContext) );
    DebugTrace( 0, Dbg, ("DeleteEntry = %08lx\n", DeleteEntry) );

    //
    //  We do not allow ourselves to be called if the index has no
    //  allocation.
    //

    ASSERT( Sp != IndexContext->Base );

    IndexBuffer = (PINDEX_ALLOCATION_BUFFER)Sp->StartOfBuffer;
    IndexHeader = &IndexBuffer->IndexHeader;

    //
    //  Initialize pointers for the root.
    //

    Context = &IndexContext->AttributeContext;

    //
    //  Assume returning NULL.
    //

    *DeleteEntry = NULL;

    //
    //  A pruning we will go...
    //

    while (TRUE) {

        //
        //  The Index Buffer is empty if its first entry is the end record.
        //  If so, delete it, otherwise get out.
        //

        if (FlagOn(NtfsFirstIndexEntry(IndexHeader)->Flags, INDEX_ENTRY_END)) {

            VCN IndexBlockNumber = IndexBuffer->ThisBlock;

            NtfsUnpinBcb( IrpContext, &Sp->Bcb );
            DeleteIndexBuffer( IrpContext, Scb, IndexBlockNumber );

        } else {
            break;
        }

        //
        // We just deleted an Index Buffer, so we have to go up a level
        // in the stack and take care of the Entry that was pointing to it.
        // There are these cases:
        //
        //      1.  If the Entry pointing to the one we deleted is not
        //          an End Entry, then we will remember its address in
        //          *DeleteEntry to cause it to be deleted and reinserted
        //          later.
        //      2.  If the Entry pointing to the one we deleted is an
        //          End Entry, and it is not the Index Root, then we
        //          cannot delete the End Entry, so we get the Vcn
        //          from the entry before the End, store it in the End
        //          record, and make the Entry before the End record
        //          the one returned in *DeleteEntry.
        //      3.  If the current Index Buffer has gone empty, and it is
        //          the index root, then we have an Index just gone
        //          empty.  We have to catch this special case and
        //          transition the Index root back to an empty leaf by
        //          by calling NtfsCreateIndex to reinitialize it.
        //      4.  If there is no Entry before the end record, then the
        //          current Index Buffer is empty.  If it is not the
        //          root, we just let ourselves loop back and delete the
        //          empty buffer in the while statement above.
        //

        Sp -= 1;

        //
        //  When we get back to the root, look it up again because it may
        //  have moved.
        //

        if (Sp == IndexContext->Base) {
            Attribute = FindMoveableIndexRoot( IrpContext, Scb, IndexContext );
        }

        IndexHeader = Sp->IndexHeader;
        IndexBuffer = (PINDEX_ALLOCATION_BUFFER)Sp->StartOfBuffer;

        //
        //  Remember potential entry to delete.
        //

        IndexContext->Current = Sp;
        *DeleteEntry = Sp->IndexEntry;

        //
        //  If the current delete entry is not an end entry, then we have
        //  Case 1 above, and we can break out.
        //

        if (!FlagOn((*DeleteEntry)->Flags, INDEX_ENTRY_END)) {
            break;
        }

        //
        //  If we are pointing to the end record, but it is not the first in
        //  the buffer, then we have Case 2.  We need to find the predecessor
        //  index entry, choose it for deletion, and copy its Vcn to the end
        //  record.
        //

        if (*DeleteEntry != NtfsFirstIndexEntry(IndexHeader)) {

            PINDEX_ENTRY NextEntry;

            NextEntry = NtfsFirstIndexEntry(IndexHeader);
            NtfsCheckIndexBound( NextEntry, IndexHeader );
            do {
                *DeleteEntry = NextEntry;
                NextEntry = NtfsNextIndexEntry(NextEntry);

                NtfsCheckIndexBound( NextEntry, IndexHeader );
                if (NextEntry->Length == 0) {

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                }

            } while (!FlagOn(NextEntry->Flags, INDEX_ENTRY_END));

            //
            //  First handle the case where our parent is the Index Root.
            //

            if (Sp == IndexContext->Base) {

                //
                //  Pin the page
                //

                NtfsPinMappedAttribute( IrpContext, Vcb, Context );

                //
                //  Write a log record to change our ParentIndexEntry.
                //

                FileRecord = NtfsContainingFileRecord(Context);

                FileRecord->Lsn =
                NtfsWriteLog( IrpContext,
                              Vcb->MftScb,
                              NtfsFoundBcb(Context),
                              SetIndexEntryVcnRoot,
                              &NtfsIndexEntryBlock(*DeleteEntry),
                              sizeof(LONGLONG),
                              SetIndexEntryVcnRoot,
                              &NtfsIndexEntryBlock(NextEntry),
                              sizeof(LONGLONG),
                              NtfsMftOffset( Context ),
                              (ULONG)((PCHAR)Attribute - (PCHAR)FileRecord),
                              (ULONG)((PCHAR)NextEntry - (PCHAR)Attribute),
                              Vcb->BytesPerFileRecordSegment );

            //
            //  Otherwise, our parent is also an Index Buffer.
            //

            } else {

                //
                //  Pin the page
                //

                NtfsPinMappedData( IrpContext,
                                   Scb,
                                   LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                                   Scb->ScbType.Index.BytesPerIndexBuffer,
                                   &Sp->Bcb );

                //
                //  Write a log record to change our ParentIndexEntry.
                //

                IndexBuffer->Lsn =
                NtfsWriteLog( IrpContext,
                              Scb,
                              Sp->Bcb,
                              SetIndexEntryVcnAllocation,
                              &NtfsIndexEntryBlock(*DeleteEntry),
                              sizeof(LONGLONG),
                              SetIndexEntryVcnAllocation,
                              &NtfsIndexEntryBlock(NextEntry),
                              sizeof(LONGLONG),
                              LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                              0,
                              (ULONG)((PCHAR)NextEntry - (PCHAR)IndexBuffer),
                              Scb->ScbType.Index.BytesPerIndexBuffer );
            }

            //
            //  Now call the Restart routine to do it.
            //

            NtfsRestartSetIndexBlock( NextEntry,
                                      NtfsIndexEntryBlock(*DeleteEntry) );

            break;

        //
        //  Otherwise we are looking at an empty buffer.  If it is the root
        //  then we have Case 3.  We are returning an IndexRoot to the
        //  empty leaf case by reinitializing it.
        //

        } else if (Sp == IndexContext->Base) {

            ATTRIBUTE_TYPE_CODE IndexedAttributeType = $UNUSED;

            if (!FlagOn(Scb->ScbState, SCB_STATE_VIEW_INDEX)) {
                IndexedAttributeType = Scb->ScbType.Index.AttributeBeingIndexed;
            }

            NtfsCreateIndex( IrpContext,
                             Scb->Fcb,
                             IndexedAttributeType,
                             (COLLATION_RULE)Scb->ScbType.Index.CollationRule,
                             Scb->ScbType.Index.BytesPerIndexBuffer,
                             Scb->ScbType.Index.BlocksPerIndexBuffer,
                             Context,
                             Scb->AttributeFlags,
                             FALSE,
                             TRUE );

            //
            //  Nobody should use this context anymore, so set to crash
            //  if they try to use this index entry pointer.
            //

            IndexContext->OldAttribute = NtfsFoundAttribute(Context);
            IndexContext->Base->IndexEntry = (PINDEX_ENTRY)NULL;

            //
            //  In this case our caller has nothing to delete.
            //

            *DeleteEntry = NULL;

            break;

        //
        //  Otherwise, this is just some intermediate empty buffer, which
        //  is Case 4.  Just continue back and keep on pruning.
        //

        } else {
            continue;
        }
    }

    //
    //  If it looks like we did some work, and did not already find the root again,
    //  then make sure the stack is correct for return.
    //

    if ((*DeleteEntry != NULL) && (Attribute == NULL)) {
        FindMoveableIndexRoot( IrpContext, Scb, IndexContext );
    }

    DebugTrace( -1, Dbg, ("PruneIndex -> VOID\n") );
}


VOID
NtOfsRestartUpdateDataInIndex(
    IN PINDEX_ENTRY IndexEntry,
    IN PVOID IndexData,
    IN ULONG Length )

/*++

Routine Description:

    This is the restart routine used to apply updates to the data in a row,
    both in run time and at restart.

Arguments:

    IndexEntry - Supplies a pointer to the IndexEntry to be updated.

    IndexData - Supplies the data for the update.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    RtlMoveMemory( Add2Ptr(IndexEntry, IndexEntry->DataOffset),
                   IndexData,
                   Length );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\lockorder.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lockorder.h

Abstract:

    This module defines all data associated with lock order enforcement.
    
    If you define a new resource add it to the NTFS_RESOURCE_NAME enum. If you hit
    an unknown state transition run tests\analyze which shows what makes up the state
    Then see if you're releasing / acquiring the resource and if its a safe or unsafe transition.
    An unsafe transition is a non-blocking one. If the transition makes sense then you should add
    it to one of 4 tables. 1st it may be neccessary to create a new state. Scan the list 
    which is aorganized in mostly ordered fashion to make sure the state doesn't already
    exist. Then if the transition is a normal 2 way one add it to the OwnershipTransitionTable.
    If its a release only transition (usually caused by out of order resource releases) add it
    to the OwnershipTransitionTableRelease. If its an acquire only transiton add it to 
    OwnershipTransitionTableAcquire. These only included transitions involving the wild card
    resource NtfsResourceAny and are used to model the ExclusiveVcb resource chains. Finally if
    its only an unsafe transition ex. acquire parent and then acquire child add it to
    the OwnershipTransitionTableUnsafe. After you're donw recompile analyze and check to
    make sure it doesn't warn about anything invalid in the total rule set. Finally compile with
    NTFSDBG defined and the new rule will be in place.
    
    
Author:
    
    Benjamin Leis   [benl]          20-Mar-2000

Revision History:

--*/

#ifndef _NTFSLOCKORDER_
#define _NTFSLOCKORDER_

//
//  Data for the lock order enforcement package. This includes names for resources
//  and the resource ownership states
//  

typedef enum _NTFS_RESOURCE_NAME  {
    NtfsResourceAny               = 0x1,  
    NtfsResourceExVcb             = 0x2,
    NtfsResourceSharedVcb         = 0x4,
    NtfsResourceFile              = 0x8, 
    NtfsResourceRootDir           = 0x10,  
    NtfsResourceObjectIdTable     = 0x20,
    NtfsResourceSecure            = 0x40,
    NtfsResourceQuotaTable        = 0x80,
    NtfsResourceReparseTable      = 0x100,
    NtfsResourceExtendDir         = 0x200,
    NtfsResourceBadClust          = 0x400,  
    NtfsResourceUpCase            = 0x800,  
    NtfsResourceAttrDefTable      = 0x1000,
    NtfsResourceVolume            = 0x2000,  
    NtfsResourceLogFile           = 0x4000,
    NtfsResourceMft2              = 0x8000,
    NtfsResourceMft               = 0x10000,
    NtfsResourceUsnJournal        = 0x20000, 
    NtfsResourceBitmap            = 0x40000,
    NtfsResourceBoot              = 0x80000,

    NtfsResourceMaximum           = 0x100000

} NTFS_RESOURCE_NAME, *PNTFS_RESOURCE_NAME;


typedef enum _NTFS_OWNERSHIP_STATE {
    None = 0,
    NtfsOwns_File = NtfsResourceFile,
    NtfsOwns_ExVcb = NtfsResourceExVcb,
    NtfsOwns_Vcb = NtfsResourceSharedVcb, 
    NtfsOwns_BadClust = NtfsResourceBadClust,
    NtfsOwns_Boot = NtfsResourceBoot,
    NtfsOwns_Bitmap = NtfsResourceBitmap,
    NtfsOwns_Extend = NtfsResourceExtendDir,
    NtfsOwns_Journal = NtfsResourceUsnJournal,
    NtfsOwns_LogFile = NtfsResourceLogFile,
    NtfsOwns_Mft = NtfsResourceMft,
    NtfsOwns_Mft2 = NtfsResourceMft2,
    NtfsOwns_ObjectId = NtfsResourceObjectIdTable,
    NtfsOwns_Quota = NtfsResourceQuotaTable,
    NtfsOwns_Reparse = NtfsResourceReparseTable,
    NtfsOwns_Root = NtfsResourceRootDir,
    NtfsOwns_Secure = NtfsResourceSecure,
    NtfsOwns_Upcase = NtfsResourceUpCase,
    NtfsOwns_Volume = NtfsResourceVolume,  
    
    NtfsOwns_Root_File = NtfsResourceRootDir | NtfsResourceFile,
    NtfsOwns_Root_File_Bitmap = NtfsResourceRootDir | NtfsResourceFile | NtfsResourceBitmap,
    NtfsOwns_Root_File_ObjectId = NtfsResourceRootDir | NtfsResourceFile | NtfsResourceObjectIdTable,
    NtfsOwns_Root_File_ObjectId_Extend = NtfsResourceRootDir | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceExtendDir,
    NtfsOwns_Root_File_ObjectId_Extend_Bitmap = NtfsResourceRootDir | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceExtendDir | NtfsResourceBitmap,
    NtfsOwns_Root_File_Quota = NtfsResourceRootDir | NtfsResourceFile | NtfsResourceQuotaTable,
    NtfsOwns_Root_BadClust = NtfsResourceRootDir | NtfsResourceBadClust,
    NtfsOwns_Root_Bitmap = NtfsResourceRootDir | NtfsResourceBitmap,
    NtfsOwns_Root_Extend = NtfsResourceRootDir | NtfsResourceExtendDir,
    NtfsOwns_Root_LogFile = NtfsResourceRootDir | NtfsResourceLogFile,
    NtfsOwns_Root_Mft2 = NtfsResourceRootDir | NtfsResourceMft2,
    NtfsOwns_Root_Quota = NtfsResourceRootDir | NtfsResourceQuotaTable,
    NtfsOwns_Root_ObjectId = NtfsResourceRootDir | NtfsResourceObjectIdTable,
    NtfsOwns_Root_Upcase = NtfsResourceRootDir | NtfsResourceUpCase,
    NtfsOwns_Root_Secure = NtfsResourceRootDir | NtfsResourceSecure,
    NtfsOwns_Root_Mft = NtfsResourceRootDir | NtfsResourceMft,
    NtfsOwns_Root_Mft_Bitmap = NtfsResourceRootDir | NtfsResourceMft | NtfsResourceBitmap,
    NtfsOwns_Root_Mft_File = NtfsResourceRootDir | NtfsResourceMft | NtfsResourceFile,
    NtfsOwns_Root_Mft_File_Bitmap = NtfsResourceRootDir | NtfsResourceMft | NtfsResourceFile | NtfsResourceBitmap,
    NtfsOwns_Root_Mft_File_Quota = NtfsResourceRootDir | NtfsResourceMft | NtfsResourceFile | NtfsResourceQuotaTable,
    NtfsOwns_Root_Mft_File_Journal = NtfsResourceRootDir | NtfsResourceMft | NtfsResourceFile | NtfsResourceUsnJournal,
    NtfsOwns_Root_Mft_File_Journal_Bitmap = NtfsResourceRootDir | NtfsResourceMft | NtfsResourceFile | NtfsResourceUsnJournal | NtfsResourceBitmap,
    NtfsOwns_Root_Mft_File_ObjectId = NtfsResourceRootDir | NtfsResourceMft | NtfsResourceFile | NtfsResourceObjectIdTable,
    NtfsOwns_Root_Mft_File_ObjectId_Quota = NtfsResourceRootDir | NtfsResourceMft | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceQuotaTable,
    NtfsOwns_Root_Mft_Journal = NtfsResourceRootDir | NtfsResourceMft | NtfsResourceUsnJournal,
    NtfsOwns_Root_Mft_Journal_Bitmap = NtfsResourceRootDir | NtfsResourceMft | NtfsResourceUsnJournal | NtfsResourceBitmap,
    NtfsOwns_Root_Mft_ObjectId = NtfsResourceRootDir | NtfsResourceMft | NtfsResourceObjectIdTable,

    NtfsOwns_Vcb_BadClust = NtfsResourceSharedVcb | NtfsResourceBadClust,
    NtfsOwns_Vcb_Bitmap = NtfsResourceSharedVcb | NtfsResourceBitmap,
    NtfsOwns_Vcb_Boot = NtfsResourceSharedVcb | NtfsResourceBoot,
    NtfsOwns_Vcb_Journal = NtfsResourceSharedVcb | NtfsResourceUsnJournal,
    NtfsOwns_Vcb_LogFile = NtfsResourceSharedVcb | NtfsResourceLogFile,
    NtfsOwns_Vcb_Quota = NtfsResourceSharedVcb | NtfsResourceQuotaTable,
    NtfsOwns_Vcb_Reparse = NtfsResourceSharedVcb | NtfsResourceReparseTable,
    NtfsOwns_Vcb_Root = NtfsResourceSharedVcb | NtfsResourceRootDir,   
    NtfsOwns_Vcb_Upcase = NtfsResourceSharedVcb | NtfsResourceUpCase,
    NtfsOwns_Vcb_Volume = NtfsResourceSharedVcb | NtfsResourceVolume,

    NtfsOwns_Vcb_Mft = NtfsResourceSharedVcb | NtfsResourceMft,
    NtfsOwns_Vcb_Mft_BadClust = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceBadClust,
    NtfsOwns_Vcb_Mft_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_Boot = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceBoot,
    NtfsOwns_Vcb_Mft_LogFile = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceLogFile,
    NtfsOwns_Vcb_Mft_Mft2 = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceMft2,
    NtfsOwns_Vcb_Mft_Upcase = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceUpCase,
    NtfsOwns_Vcb_Mft_Secure = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceSecure,
    NtfsOwns_Vcb_Mft_Volume = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceVolume,
    NtfsOwns_Vcb_Mft_Volume_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceVolume | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_Volume_Bitmap_Boot = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceVolume | NtfsResourceBitmap | NtfsResourceBoot,
    NtfsOwns_Vcb_Mft_Extend = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceExtendDir,
    NtfsOwns_Vcb_Mft_File = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile,
    NtfsOwns_Vcb_Mft_File_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_File_Journal = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceUsnJournal,
    NtfsOwns_Vcb_Mft_File_Journal_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceUsnJournal | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_File_Secure = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceSecure,
    NtfsOwns_Vcb_Mft_File_Reparse = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceReparseTable,
    NtfsOwns_Vcb_Mft_File_Reparse_Journal = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceReparseTable | NtfsResourceUsnJournal,
    NtfsOwns_Vcb_Mft_File_Quota = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceQuotaTable,
    NtfsOwns_Vcb_Mft_File_Quota_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceQuotaTable | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_File_ObjectId = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceObjectIdTable,
    NtfsOwns_Vcb_Mft_File_ObjectId_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_File_ObjectId_Quota = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceQuotaTable,  
    NtfsOwns_Vcb_Mft_File_ObjectId_Reparse = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceReparseTable,
    NtfsOwns_Vcb_Mft_File_ObjectId_Journal = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceUsnJournal,
    NtfsOwns_Vcb_Mft_File_ObjectId_Journal_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceUsnJournal | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_Journal = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceUsnJournal,
    NtfsOwns_Vcb_Mft_Journal_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceUsnJournal | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_Root = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir,
    NtfsOwns_Vcb_Mft_Root_Quota = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceQuotaTable,
    NtfsOwns_Vcb_Mft_Root_Journal = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceUsnJournal,
    NtfsOwns_Vcb_Mft_Root_Journal_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceUsnJournal | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_Root_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_Root_File = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceFile,
    NtfsOwns_Vcb_Mft_Root_File_Quota = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceQuotaTable,
    NtfsOwns_Vcb_Mft_Root_File_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_Root_File_Journal = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceUsnJournal,
    NtfsOwns_Vcb_Mft_Root_File_Journal_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceUsnJournal | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_Root_File_ObjectId = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceObjectIdTable,
    NtfsOwns_Vcb_Mft_Root_File_ObjectId_Journal = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceUsnJournal,
    NtfsOwns_Vcb_Mft_Root_File_ObjectId_Quota = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceQuotaTable,
    NtfsOwns_Vcb_Mft_Root_ObjectId = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceObjectIdTable,
    NtfsOwns_Vcb_Mft_ObjectId = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceObjectIdTable,
    NtfsOwns_Vcb_Mft_Quota = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceQuotaTable,
    NtfsOwns_Vcb_Mft_Reparse = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceReparseTable,

    NtfsOwns_Vcb_Extend = NtfsResourceSharedVcb | NtfsResourceExtendDir,
    NtfsOwns_Vcb_Extend_Reparse = NtfsResourceSharedVcb | NtfsResourceExtendDir | NtfsResourceReparseTable,
    NtfsOwns_Vcb_Extend_Reparse_Secure = NtfsResourceSharedVcb | NtfsResourceExtendDir | NtfsResourceReparseTable | NtfsResourceSecure,     
    NtfsOwns_Vcb_Extend_ObjectId = NtfsResourceSharedVcb | NtfsResourceExtendDir | NtfsResourceObjectIdTable,
    NtfsOwns_Vcb_Extend_ObjectId_Secure = NtfsResourceSharedVcb | NtfsResourceExtendDir | NtfsResourceObjectIdTable | NtfsResourceSecure,
    NtfsOwns_Vcb_Extend_Quota = NtfsResourceSharedVcb | NtfsResourceExtendDir | NtfsResourceQuotaTable,
    NtfsOwns_Vcb_Extend_Journal = NtfsResourceSharedVcb | NtfsResourceExtendDir | NtfsResourceUsnJournal,
    NtfsOwns_Vcb_ObjectId = NtfsResourceSharedVcb | NtfsResourceObjectIdTable,
    NtfsOwns_Vcb_Mft2 = NtfsResourceSharedVcb | NtfsResourceMft2,
    NtfsOwns_Vcb_Secure = NtfsResourceSharedVcb | NtfsResourceSecure,
    NtfsOwns_Vcb_Root_Bitmap = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceBitmap,
    NtfsOwns_Vcb_Root_Mft2 = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceMft2,
    NtfsOwns_Vcb_Root_Upcase = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceUpCase,
    NtfsOwns_Vcb_Root_Extend = NtfsResourceSharedVcb |  NtfsResourceRootDir | NtfsResourceExtendDir,     
    NtfsOwns_Vcb_Root_Quota = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceQuotaTable,
    NtfsOwns_Vcb_Root_ObjectId = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceObjectIdTable,
    NtfsOwns_Vcb_Root_Secure = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceSecure,
    NtfsOwns_Vcb_Root_Secure_Bitmap = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceSecure | NtfsResourceBitmap,
    NtfsOwns_Vcb_Root_Boot = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceBoot,
    NtfsOwns_Vcb_Root_LogFile = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceLogFile,
    NtfsOwns_Vcb_Root_BadClust = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceBadClust,
    NtfsOwns_Vcb_Root_File = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceFile,
    NtfsOwns_Vcb_Root_File_Secure = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceSecure, 
    NtfsOwns_Vcb_Root_File_Bitmap = NtfsResourceSharedVcb |  NtfsResourceRootDir | NtfsResourceFile | NtfsResourceBitmap,
    NtfsOwns_Vcb_Root_File_ObjectId = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceObjectIdTable,
    NtfsOwns_Vcb_Root_File_ObjectId_Quota = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceQuotaTable,
    NtfsOwns_Vcb_Root_File_ObjectId_Bitmap = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceBitmap,
    NtfsOwns_Vcb_Root_File_Quota = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceQuotaTable,
    NtfsOwns_Vcb_Root_File_Quota_Bitmap = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceQuotaTable | NtfsResourceBitmap,
    NtfsOwns_Vcb_File = NtfsResourceSharedVcb | NtfsResourceFile,
    NtfsOwns_Vcb_File_Quota = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceQuotaTable,
    NtfsOwns_Vcb_File_Quota_Bitmap = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceQuotaTable | NtfsResourceBitmap,
    NtfsOwns_Vcb_File_Bitmap = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceBitmap,
    NtfsOwns_Vcb_File_Secure = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceSecure,     
    NtfsOwns_Vcb_File_Extend = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceExtendDir,     
    NtfsOwns_Vcb_File_ObjectId = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceObjectIdTable,
    NtfsOwns_Vcb_File_ObjectId_Bitmap = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceBitmap,
    NtfsOwns_Vcb_File_ObjectId_Quota = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceQuotaTable,
    NtfsOwns_Vcb_File_ObjectId_Reparse = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceReparseTable,
    NtfsOwns_Vcb_File_ObjectId_Reparse_Bitmap = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceReparseTable | NtfsResourceBitmap,
    NtfsOwns_Vcb_File_Reparse = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceReparseTable,
    NtfsOwns_Vcb_File_Reparse_Bitmap = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceReparseTable | NtfsResourceBitmap,
    NtfsOwns_Vcb_File_Extend_Secure = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceExtendDir | NtfsResourceSecure,     
    NtfsOwns_Vcb_File_Secure_Bitmap = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceSecure | NtfsResourceBitmap,

    NtfsOwns_Extend_Reparse = NtfsResourceExtendDir | NtfsResourceReparseTable,
    NtfsOwns_Extend_ObjectId = NtfsResourceExtendDir | NtfsResourceObjectIdTable,
    NtfsOwns_Extend_Journal = NtfsResourceExtendDir | NtfsResourceUsnJournal,
    NtfsOwns_Extend_Quota = NtfsResourceExtendDir | NtfsResourceQuotaTable,

    NtfsOwns_Mft_Bitmap = NtfsResourceMft | NtfsResourceBitmap,
    NtfsOwns_Mft_Journal = NtfsResourceMft | NtfsResourceUsnJournal,
    NtfsOwns_Mft_Journal_Bitmap = NtfsResourceMft | NtfsResourceUsnJournal | NtfsResourceBitmap,
    NtfsOwns_Mft_Volume = NtfsResourceMft | NtfsResourceVolume,
    NtfsOwns_Mft_Volume_Bitmap = NtfsResourceMft | NtfsResourceVolume | NtfsResourceBitmap,
    NtfsOwns_Mft_Extend = NtfsResourceMft | NtfsResourceExtendDir,
    NtfsOwns_Mft_Extend_Journal = NtfsResourceMft | NtfsResourceExtendDir | NtfsResourceUsnJournal,
    NtfsOwns_Mft_File = NtfsResourceMft | NtfsResourceFile,
    NtfsOwns_Mft_File_Journal = NtfsResourceMft | NtfsResourceFile | NtfsResourceUsnJournal,
    NtfsOwns_Mft_File_Journal_Bitmap = NtfsResourceMft | NtfsResourceFile | NtfsResourceUsnJournal | NtfsResourceBitmap,
    NtfsOwns_Mft_File_Bitmap = NtfsResourceMft | NtfsResourceFile | NtfsResourceBitmap,
    NtfsOwns_Mft_File_Quota = NtfsResourceMft | NtfsResourceFile | NtfsResourceQuotaTable,
    NtfsOwns_Mft_File_Reparse = NtfsResourceMft | NtfsResourceFile | NtfsResourceReparseTable,
    NtfsOwns_Mft_File_Reparse_Journal = NtfsResourceMft | NtfsResourceFile | NtfsResourceReparseTable | NtfsResourceUsnJournal,
    NtfsOwns_Mft_File_Secure = NtfsResourceMft | NtfsResourceFile | NtfsResourceSecure,
    NtfsOwns_Mft_File_Secure_Journal = NtfsResourceMft | NtfsResourceFile | NtfsResourceSecure | NtfsResourceUsnJournal,
    NtfsOwns_Mft_File_ObjectId = NtfsResourceMft | NtfsResourceFile | NtfsResourceObjectIdTable,
    NtfsOwns_Mft_File_ObjectId_Quota = NtfsResourceMft | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceQuotaTable,
    NtfsOwns_Mft_File_ObjectId_Reparse = NtfsResourceMft | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceReparseTable,
    NtfsOwns_Mft_File_ObjectId_Journal = NtfsResourceMft | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceUsnJournal,
    NtfsOwns_Mft_ObjectId = NtfsResourceMft | NtfsResourceObjectIdTable,
    NtfsOwns_Mft_ObjectId_Journal = NtfsResourceMft | NtfsResourceObjectIdTable | NtfsResourceUsnJournal,
    NtfsOwns_Mft_ObjectId_Bitmap = NtfsResourceMft | NtfsResourceObjectIdTable | NtfsResourceBitmap,
    NtfsOwns_Mft_Upcase = NtfsResourceMft | NtfsResourceUpCase,
    NtfsOwns_Mft_Upcase_Bitmap = NtfsResourceMft | NtfsResourceUpCase | NtfsResourceBitmap,
    NtfsOwns_Mft_Secure = NtfsResourceMft | NtfsResourceSecure,
    NtfsOwns_Mft_Secure_Bitmap = NtfsResourceMft | NtfsResourceSecure | NtfsResourceBitmap,
    NtfsOwns_Mft_Quota = NtfsResourceMft | NtfsResourceQuotaTable,
    NtfsOwns_Mft_Quota_Bitmap = NtfsResourceMft | NtfsResourceQuotaTable | NtfsResourceBitmap,
    NtfsOwns_Mft_Reparse = NtfsResourceMft | NtfsResourceReparseTable,
    NtfsOwns_Mft_Reparse_Bitmap = NtfsResourceMft | NtfsResourceReparseTable | NtfsResourceBitmap,
    
    NtfsOwns_File_Secure = NtfsResourceFile | NtfsResourceSecure,
    NtfsOwns_File_Secure_Bitmap = NtfsResourceFile | NtfsResourceSecure | NtfsResourceBitmap,
    NtfsOwns_File_Quota = NtfsResourceFile | NtfsResourceQuotaTable,
    NtfsOwns_File_Quota_Bitmap = NtfsResourceFile | NtfsResourceQuotaTable | NtfsResourceBitmap ,
    NtfsOwns_File_Bitmap = NtfsResourceFile | NtfsResourceBitmap,
    NtfsOwns_File_ObjectId = NtfsResourceFile | NtfsResourceObjectIdTable,
    NtfsOwns_File_ObjectId_Bitmap = NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceBitmap,
    NtfsOwns_File_ObjectId_Reparse = NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceReparseTable,
    NtfsOwns_File_Reparse = NtfsResourceFile | NtfsResourceReparseTable,
    NtfsOwns_File_Reparse_Bitmap = NtfsResourceFile | NtfsResourceReparseTable | NtfsResourceBitmap,
    
    NtfsOwns_Volume_Quota = NtfsResourceVolume | NtfsResourceQuotaTable,
    NtfsOwns_Volume_ObjectId = NtfsResourceVolume | NtfsResourceObjectIdTable,
    
    NtfsOwns_ExVcb_File = NtfsResourceExVcb | NtfsResourceFile,
    NtfsOwns_ExVcb_File_Volume = NtfsResourceExVcb | NtfsResourceFile | NtfsResourceVolume,
    NtfsOwns_ExVcb_File_Volume_Bitmap = NtfsResourceExVcb | NtfsResourceFile | NtfsResourceVolume | NtfsResourceBitmap,
    NtfsOwns_ExVcb_File_Volume_ObjectId = NtfsResourceExVcb | NtfsResourceFile | NtfsResourceVolume | NtfsResourceObjectIdTable,
    NtfsOwns_ExVcb_File_Secure = NtfsResourceExVcb | NtfsResourceFile | NtfsResourceSecure,
    NtfsOwns_ExVcb_File_ObjectId_Secure = NtfsResourceExVcb | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceSecure,

    
    NtfsOwns_ExVcb_Extend = NtfsResourceExVcb | NtfsResourceExtendDir,
    NtfsOwns_ExVcb_Extend_Journal = NtfsResourceExVcb | NtfsResourceExtendDir | NtfsResourceUsnJournal,
    NtfsOwns_ExVcb_Extend_Journal_Bitmap = NtfsResourceExVcb | NtfsResourceExtendDir | NtfsResourceUsnJournal | NtfsResourceBitmap,

    NtfsOwns_ExVcb_Journal = NtfsResourceExVcb | NtfsResourceUsnJournal,

    NtfsOwns_ExVcb_Mft = NtfsResourceExVcb | NtfsResourceMft,
    NtfsOwns_ExVcb_Mft_Extend = NtfsResourceExVcb | NtfsResourceMft | NtfsResourceExtendDir,
    NtfsOwns_ExVcb_Mft_Extend_File = NtfsResourceExVcb | NtfsResourceMft | NtfsResourceExtendDir | NtfsResourceFile,
    NtfsOwns_ExVcb_Mft_Extend_Journal = NtfsResourceExVcb | NtfsResourceMft | NtfsResourceExtendDir | NtfsResourceUsnJournal,
    NtfsOwns_ExVcb_Mft_File = NtfsResourceExVcb | NtfsResourceMft | NtfsResourceFile,  //  flush vol + write journal when release all
    NtfsOwns_ExVcb_Mft_File_Journal = NtfsResourceExVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceUsnJournal,
    NtfsOwns_ExVcb_Mft_File_Volume = NtfsResourceExVcb | NtfsResourceFile | NtfsResourceVolume | NtfsResourceMft,
    NtfsOwns_ExVcb_Mft_File_Volume_Journal = NtfsResourceExVcb | NtfsResourceFile | NtfsResourceVolume | NtfsResourceMft | NtfsResourceUsnJournal,
    NtfsOwns_ExVcb_Mft_Journal = NtfsResourceExVcb | NtfsResourceMft | NtfsResourceUsnJournal,
    NtfsOwns_ExVcb_Mft_Root = NtfsResourceExVcb | NtfsResourceMft | NtfsResourceRootDir,
    NtfsOwns_ExVcb_Mft_Root_File = NtfsResourceExVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceFile,
    NtfsOwns_ExVcb_Mft_Root_File_Bitmap = NtfsResourceExVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceBitmap,
    NtfsOwns_ExVcb_Mft_Root_File_Journal = NtfsResourceExVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceUsnJournal,
    
    NtfsOwns_ExVcb_ObjectId = NtfsResourceExVcb | NtfsResourceObjectIdTable,
    NtfsOwns_ExVcb_ObjectId_Extend = NtfsResourceExVcb | NtfsResourceObjectIdTable | NtfsResourceExtendDir,
    NtfsOwns_ExVcb_ObjectId_Secure = NtfsResourceExVcb | NtfsResourceObjectIdTable | NtfsResourceSecure,

    NtfsOwns_ExVcb_Quota = NtfsResourceExVcb | NtfsResourceQuotaTable,
    NtfsOwns_ExVcb_Quota_Reparse = NtfsResourceExVcb | NtfsResourceQuotaTable | NtfsResourceReparseTable,
    NtfsOwns_ExVcb_Quota_Reparse_Extend = NtfsResourceExVcb | NtfsResourceQuotaTable | NtfsResourceReparseTable | NtfsResourceExtendDir,
    NtfsOwns_ExVcb_Quota_Reparse_ObjectId = NtfsResourceExVcb | NtfsResourceQuotaTable | NtfsResourceReparseTable | NtfsResourceObjectIdTable,
    NtfsOwns_ExVcb_Quota_ObjectId = NtfsResourceExVcb | NtfsResourceQuotaTable | NtfsResourceObjectIdTable,
    NtfsOwns_ExVcb_Quota_ObjectId_Extend = NtfsResourceExVcb | NtfsResourceQuotaTable | NtfsResourceObjectIdTable | NtfsResourceExtendDir,
    NtfsOwns_ExVcb_Quota_Extend = NtfsResourceExVcb | NtfsResourceQuotaTable | NtfsResourceExtendDir,
    
    NtfsOwns_ExVcb_Root = NtfsResourceExVcb | NtfsResourceRootDir,             
    NtfsOwns_ExVcb_Root_Extend = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceExtendDir, 
    NtfsOwns_ExVcb_Root_File = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceFile,
    NtfsOwns_ExVcb_Root_File_Secure = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceSecure,
    NtfsOwns_ExVcb_Root_File_Bitmap = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceBitmap,
    NtfsOwns_ExVcb_Root_File_Quota = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceQuotaTable,
    NtfsOwns_ExVcb_Root_File_Quota_Bitmap = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceQuotaTable | NtfsResourceBitmap,
    NtfsOwns_ExVcb_Root_File_Quota_Mft = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceQuotaTable | NtfsResourceMft,
    NtfsOwns_ExVcb_Root_File_ObjectId = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceObjectIdTable,
    NtfsOwns_ExVcb_Root_File_ObjectId_Extend = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceExtendDir,  
    NtfsOwns_ExVcb_Root_File_ObjectId_Secure = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceSecure,
    NtfsOwns_ExVcb_Root_File_Volume = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceVolume,
    NtfsOwns_ExVcb_Root_File_Volume_Bitmap = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceVolume | NtfsResourceBitmap,
    NtfsOwns_ExVcb_Root_File_Volume_ObjectId = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceVolume | NtfsResourceObjectIdTable,
    
    NtfsOwns_ExVcb_Root_ObjectId = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceObjectIdTable,
    NtfsOwns_ExVcb_Root_ObjectId_Extend = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceObjectIdTable | NtfsResourceExtendDir, 
    NtfsOwns_ExVcb_Root_ObjectId_Secure = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceObjectIdTable | NtfsResourceSecure,
    NtfsOwns_ExVcb_Root_ObjectId_Secure_Bitmap = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceObjectIdTable | NtfsResourceSecure | NtfsResourceBitmap,
    NtfsOwns_ExVcb_Root_Volume = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceVolume,
    NtfsOwns_ExVcb_Root_Volume_ObjectId = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceVolume | NtfsResourceObjectIdTable,
    
    NtfsOwns_ExVcb_Volume = NtfsResourceExVcb | NtfsResourceVolume,
    NtfsOwns_ExVcb_Volume_ObjectId = NtfsResourceExVcb | NtfsResourceVolume | NtfsResourceObjectIdTable,  // set vol objectid
    NtfsOwns_ExVcb_Volume_ObjectId_Bitmap = NtfsResourceExVcb | NtfsResourceVolume | NtfsResourceObjectIdTable | NtfsResourceBitmap,
    
    NtfsStateMaximum = NtfsResourceMaximum - 1

} NTFS_OWNERSHIP_STATE, *PNTFS_OWNERSHIP_STATE;

typedef struct _NTFS_OWNERSHIP_TRANSITION {
    NTFS_OWNERSHIP_STATE Begin;
    NTFS_RESOURCE_NAME Acquired;
    NTFS_OWNERSHIP_STATE End;
} NTFS_OWNERSHIP_TRANSITION, *PNTFS_OWNERSHIP_TRANSITION;

//
//  Transition table definitions
//  

#ifdef _NTFS_NTFSDBG_DEFINITIONS_

//
//  Two way transitions
//  

NTFS_OWNERSHIP_TRANSITION OwnershipTransitionTable[] = 
{
    {None, NtfsResourceFile, NtfsOwns_File},
    {None, NtfsResourceMft, NtfsOwns_Mft},
    {None, NtfsResourceExVcb, NtfsOwns_ExVcb},
    {None, NtfsResourceSharedVcb, NtfsOwns_Vcb},
    {None, NtfsResourceVolume, NtfsOwns_Volume},
    {None, NtfsResourceRootDir, NtfsOwns_Root},
    {None, NtfsResourceReparseTable, NtfsOwns_Reparse},
    {None, NtfsResourceBitmap, NtfsOwns_Bitmap},
    {None, NtfsResourceUsnJournal, NtfsOwns_Journal},
    {None, NtfsResourceObjectIdTable, NtfsOwns_ObjectId},
    {None, NtfsResourceMft2, NtfsOwns_Mft2},
    {None, NtfsResourceUpCase, NtfsOwns_Upcase},
    {None, NtfsResourceExtendDir, NtfsOwns_Extend},
    {None, NtfsResourceSecure, NtfsOwns_Secure},
    {None, NtfsResourceQuotaTable, NtfsOwns_Quota},
    {None, NtfsResourceReparseTable, NtfsOwns_Reparse},
    
    {NtfsOwns_Mft, NtfsResourceUsnJournal, NtfsOwns_Mft_Journal},
    {NtfsOwns_Mft, NtfsResourceBitmap, NtfsOwns_Mft_Bitmap},  // proocess exception
    {NtfsOwns_Mft_Journal, NtfsResourceBitmap, NtfsOwns_Mft_Journal_Bitmap},
    {NtfsOwns_Mft_File, NtfsResourceUsnJournal, NtfsOwns_Mft_File_Journal},
    {NtfsOwns_Mft_File, NtfsResourceBitmap, NtfsOwns_Mft_File_Bitmap},
    {NtfsOwns_Mft_File_Journal, NtfsResourceBitmap, NtfsOwns_Mft_File_Journal_Bitmap},
    
    {NtfsOwns_Root, NtfsResourceBitmap, NtfsOwns_Root_Bitmap},
    {NtfsOwns_Root, NtfsResourceQuotaTable, NtfsOwns_Root_Quota},
    {NtfsOwns_Root, NtfsResourceMft, NtfsOwns_Root_Mft},  //  usnjrnl entry for root data strm
    {NtfsOwns_Root_File, NtfsResourceBitmap, NtfsOwns_Root_File_Bitmap}, //  process exception
    {NtfsOwns_Root_Mft, NtfsResourceUsnJournal, NtfsOwns_Root_Mft_Journal},
    {NtfsOwns_Root_File_ObjectId_Extend, NtfsResourceBitmap, NtfsOwns_Root_File_ObjectId_Extend_Bitmap}, // process exception from defrag
    {NtfsOwns_Root_Mft_Journal, NtfsResourceBitmap, NtfsOwns_Root_Mft_Journal_Bitmap},
    {NtfsOwns_Root_Mft_File, NtfsResourceBitmap, NtfsOwns_Root_Mft_File_Bitmap}, //  process exception
    {NtfsOwns_Root_Mft_File_Journal, NtfsResourceBitmap, NtfsOwns_Root_Mft_File_Journal_Bitmap},  //  process exception

    //
    //  Defrag paths
    //
    
    {NtfsOwns_Root_Mft, NtfsResourceBitmap, NtfsOwns_Root_Mft_Bitmap},  
    {NtfsOwns_Upcase, NtfsResourceMft, NtfsOwns_Mft_Upcase},  
    {NtfsOwns_Mft_Upcase, NtfsResourceBitmap, NtfsOwns_Mft_Upcase_Bitmap},
    {NtfsOwns_Secure, NtfsResourceMft, NtfsOwns_Mft_Secure}, 
    {NtfsOwns_Mft_Secure, NtfsResourceBitmap, NtfsOwns_Mft_Secure_Bitmap}, 
    {NtfsOwns_ObjectId, NtfsResourceMft, NtfsOwns_Mft_ObjectId}, 
    {NtfsOwns_Mft_ObjectId, NtfsResourceBitmap, NtfsOwns_Mft_ObjectId_Bitmap}, 
    {NtfsOwns_Mft_ObjectId, NtfsResourceUsnJournal, NtfsOwns_Mft_ObjectId_Journal},
    {NtfsOwns_Quota, NtfsResourceMft, NtfsOwns_Mft_Quota}, 
    {NtfsOwns_Mft_Quota, NtfsResourceBitmap, NtfsOwns_Mft_Quota_Bitmap}, 
    {NtfsOwns_Reparse, NtfsResourceMft, NtfsOwns_Mft_Reparse}, 
    {NtfsOwns_Mft_Reparse, NtfsResourceBitmap, NtfsOwns_Mft_Reparse_Bitmap},
     
    {NtfsOwns_Volume, NtfsResourceQuotaTable, NtfsOwns_Volume_Quota},
    {NtfsOwns_Volume, NtfsResourceMft, NtfsOwns_Mft_Volume},

    {NtfsOwns_File, NtfsResourceSecure, NtfsOwns_File_Secure},
    {NtfsOwns_File_Secure, NtfsResourceBitmap, NtfsOwns_File_Secure_Bitmap},
    {NtfsOwns_File_Secure, NtfsResourceMft, NtfsOwns_Mft_File_Secure},
    {NtfsOwns_Mft_File_Secure, NtfsResourceUsnJournal, NtfsOwns_Mft_File_Secure_Journal},
    
    {NtfsOwns_File, NtfsResourceBitmap, NtfsOwns_File_Bitmap},
    {NtfsOwns_File, NtfsResourceQuotaTable, NtfsOwns_File_Quota},
    {NtfsOwns_File, NtfsResourceObjectIdTable, NtfsOwns_File_ObjectId},
    {NtfsOwns_File, NtfsResourceMft, NtfsOwns_Mft_File},
    {NtfsOwns_File, NtfsResourceReparseTable, NtfsOwns_File_Reparse},
    {NtfsOwns_File_Quota, NtfsResourceBitmap, NtfsOwns_File_Quota_Bitmap},
    {NtfsOwns_File_Quota, NtfsResourceMft, NtfsOwns_Mft_File_Quota},
    {NtfsOwns_File_ObjectId, NtfsResourceBitmap, NtfsOwns_File_ObjectId_Bitmap},
    {NtfsOwns_File_ObjectId, NtfsResourceMft, NtfsOwns_Mft_File_ObjectId},
    {NtfsOwns_Mft_File_ObjectId, NtfsResourceUsnJournal, NtfsOwns_Mft_File_ObjectId_Journal},  //  SetOrGetObjid
    {NtfsOwns_File_Reparse, NtfsResourceBitmap, NtfsOwns_File_Reparse_Bitmap},
    {NtfsOwns_File_Reparse, NtfsResourceMft, NtfsOwns_Mft_File_Reparse},
    {NtfsOwns_Mft_File_Reparse, NtfsResourceUsnJournal, NtfsOwns_Mft_File_Reparse_Journal},
    
    {NtfsOwns_Vcb, NtfsResourceVolume, NtfsOwns_Vcb_Volume},
    {NtfsOwns_Vcb, NtfsResourceRootDir, NtfsOwns_Vcb_Root},
    {NtfsOwns_Vcb, NtfsResourceFile, NtfsOwns_Vcb_File},
    {NtfsOwns_Vcb, NtfsResourceMft, NtfsOwns_Vcb_Mft},
    {NtfsOwns_Vcb, NtfsResourceReparseTable, NtfsOwns_Vcb_Reparse},
    {NtfsOwns_Vcb, NtfsResourceObjectIdTable, NtfsOwns_Vcb_ObjectId},
    {NtfsOwns_Vcb, NtfsResourceQuotaTable, NtfsOwns_Vcb_Quota},
    {NtfsOwns_Vcb, NtfsResourceExtendDir, NtfsOwns_Vcb_Extend},
    {NtfsOwns_Vcb, NtfsResourceBitmap, NtfsOwns_Vcb_Bitmap},
    {NtfsOwns_Vcb, NtfsResourceUpCase, NtfsOwns_Vcb_Upcase},
    {NtfsOwns_Vcb, NtfsResourceBoot, NtfsOwns_Vcb_Boot},
    {NtfsOwns_Vcb, NtfsResourceExtendDir, NtfsOwns_Vcb_Extend},
    {NtfsOwns_Vcb, NtfsResourceUsnJournal, NtfsOwns_Vcb_Journal},
    {NtfsOwns_Vcb, NtfsResourceMft2, NtfsOwns_Vcb_Mft2},
    {NtfsOwns_Vcb, NtfsResourceSecure, NtfsOwns_Vcb_Secure},
    
    {NtfsOwns_Vcb_Volume, NtfsResourceMft, NtfsOwns_Vcb_Mft_Volume},  //  extend vol.
    
    {NtfsOwns_Vcb_Upcase, NtfsResourceRootDir, NtfsOwns_Vcb_Root_Upcase},
    
    {NtfsOwns_Vcb_File, NtfsResourceRootDir, NtfsOwns_Vcb_Root_File},
    {NtfsOwns_Vcb_File, NtfsResourceSecure, NtfsOwns_Vcb_File_Secure},
    {NtfsOwns_Vcb_File, NtfsResourceBitmap, NtfsOwns_Vcb_File_Bitmap},
    {NtfsOwns_Vcb_File, NtfsResourceMft, NtfsOwns_Vcb_Mft_File},
    {NtfsOwns_Vcb_File, NtfsResourceQuotaTable, NtfsOwns_Vcb_File_Quota},
    {NtfsOwns_Vcb_File, NtfsResourceObjectIdTable, NtfsOwns_Vcb_File_ObjectId},
    {NtfsOwns_Vcb_File, NtfsResourceReparseTable, NtfsOwns_Vcb_File_Reparse},
    {NtfsOwns_Vcb_File_Extend, NtfsResourceSecure, NtfsOwns_Vcb_File_Extend_Secure},
    {NtfsOwns_Vcb_File_Secure, NtfsResourceBitmap, NtfsOwns_Vcb_File_Secure_Bitmap},
    {NtfsOwns_Vcb_File_Secure, NtfsResourceMft, NtfsOwns_Vcb_Mft_File_Secure}, //  split during security grow
    {NtfsOwns_Vcb_File_Quota, NtfsResourceMft, NtfsOwns_Vcb_Mft_File_Quota},
    {NtfsOwns_Vcb_File_Quota, NtfsResourceBitmap, NtfsOwns_Vcb_File_Quota_Bitmap},
    {NtfsOwns_Vcb_File_Reparse, NtfsResourceMft, NtfsOwns_Vcb_Mft_File_Reparse},
    {NtfsOwns_Vcb_File_Reparse, NtfsResourceBitmap, NtfsOwns_Vcb_File_Reparse_Bitmap},
    {NtfsOwns_Vcb_File_ObjectId, NtfsResourceMft, NtfsOwns_Vcb_Mft_File_ObjectId,},  //  DeleteFilePath - CreateFile for tunneling
    {NtfsOwns_Vcb_File_ObjectId, NtfsResourceBitmap, NtfsOwns_Vcb_File_ObjectId_Bitmap},  
    {NtfsOwns_Vcb_File_ObjectId, NtfsResourceQuotaTable, NtfsOwns_Vcb_File_ObjectId_Quota},  
    {NtfsOwns_Vcb_File_ObjectId, NtfsResourceReparseTable, NtfsOwns_Vcb_File_ObjectId_Reparse},  
    {NtfsOwns_Vcb_File_ObjectId_Reparse, NtfsResourceBitmap, NtfsOwns_Vcb_File_ObjectId_Reparse_Bitmap},
    {NtfsOwns_Vcb_File_ObjectId_Reparse, NtfsResourceMft, NtfsOwns_Vcb_Mft_File_ObjectId_Reparse},
    {NtfsOwns_Vcb_File_ObjectId_Quota, NtfsResourceMft, NtfsOwns_Vcb_Mft_File_ObjectId_Quota},

    {NtfsOwns_Vcb_Root, NtfsResourceQuotaTable, NtfsOwns_Vcb_Root_Quota},
    {NtfsOwns_Vcb_Root, NtfsResourceObjectIdTable, NtfsOwns_Vcb_Root_ObjectId},
    {NtfsOwns_Vcb_Root, NtfsResourceSecure, NtfsOwns_Vcb_Root_Secure},
    {NtfsOwns_Vcb_Root, NtfsResourceMft, NtfsOwns_Vcb_Mft_Root},
    {NtfsOwns_Vcb_Root, NtfsResourceMft2, NtfsOwns_Vcb_Root_Mft2},
    {NtfsOwns_Vcb_Root, NtfsResourceBitmap, NtfsOwns_Vcb_Root_Bitmap},
    {NtfsOwns_Vcb_Root_Quota, NtfsResourceMft, NtfsOwns_Vcb_Mft_Root_Quota},
    {NtfsOwns_Vcb_Root_ObjectId, NtfsResourceMft, NtfsOwns_Vcb_Mft_Root_ObjectId},
    {NtfsOwns_Vcb_Root_File, NtfsResourceSecure, NtfsOwns_Vcb_Root_File_Secure},
    {NtfsOwns_Vcb_Root_File, NtfsResourceMft, NtfsOwns_Vcb_Mft_Root_File},  
    {NtfsOwns_Vcb_Root_File, NtfsResourceBitmap, NtfsOwns_Vcb_Root_File_Bitmap},
    {NtfsOwns_Vcb_Root_File, NtfsResourceObjectIdTable, NtfsOwns_Vcb_Root_File_ObjectId},
    {NtfsOwns_Vcb_Root_File, NtfsResourceQuotaTable, NtfsOwns_Vcb_Root_File_Quota},
    {NtfsOwns_Vcb_Root_File_Quota, NtfsResourceBitmap, NtfsOwns_Vcb_Root_File_Quota_Bitmap},
    {NtfsOwns_Vcb_Root_File_Quota, NtfsResourceMft, NtfsOwns_Vcb_Mft_Root_File_Quota},
    {NtfsOwns_Vcb_Root_File_ObjectId, NtfsResourceBitmap, NtfsOwns_Vcb_Root_File_ObjectId_Bitmap},
    {NtfsOwns_Vcb_Root_File_ObjectId, NtfsResourceMft, NtfsOwns_Vcb_Mft_Root_File_ObjectId},
    {NtfsOwns_Vcb_Root_File_ObjectId, NtfsResourceQuotaTable, NtfsOwns_Vcb_Root_File_ObjectId_Quota},
    {NtfsOwns_Vcb_Root_File_ObjectId_Quota, NtfsResourceMft, NtfsOwns_Vcb_Mft_Root_File_ObjectId_Quota},
    {NtfsOwns_Vcb_Root_Secure, NtfsResourceBitmap, NtfsOwns_Vcb_Root_Secure_Bitmap},
    
    {NtfsOwns_Vcb_Mft, NtfsResourceUsnJournal, NtfsOwns_Vcb_Mft_Journal},
    {NtfsOwns_Vcb_Mft, NtfsResourceBitmap, NtfsOwns_Vcb_Mft_Bitmap},
    {NtfsOwns_Vcb_Mft_Journal, NtfsResourceBitmap, NtfsOwns_Vcb_Mft_Journal_Bitmap},

    {NtfsOwns_Vcb_Mft_Root, NtfsResourceUsnJournal, NtfsOwns_Vcb_Mft_Root_Journal},
    {NtfsOwns_Vcb_Mft_Root, NtfsResourceBitmap, NtfsOwns_Vcb_Mft_Root_Bitmap},
    {NtfsOwns_Vcb_Mft_Root_Journal, NtfsResourceBitmap, NtfsOwns_Vcb_Mft_Root_Journal_Bitmap},
    {NtfsOwns_Vcb_Mft_Root_File, NtfsResourceBitmap, NtfsOwns_Vcb_Mft_Root_File_Bitmap},
    {NtfsOwns_Vcb_Mft_Root_File, NtfsResourceUsnJournal, NtfsOwns_Vcb_Mft_Root_File_Journal},
    {NtfsOwns_Vcb_Mft_Root_File_Journal, NtfsResourceBitmap, NtfsOwns_Vcb_Mft_Root_File_Journal_Bitmap},
    {NtfsOwns_Vcb_Mft_Root_File_ObjectId, NtfsResourceUsnJournal, NtfsOwns_Vcb_Mft_Root_File_ObjectId_Journal},
    
    {NtfsOwns_Vcb_Mft_File_Quota, NtfsResourceBitmap, NtfsOwns_Vcb_Mft_File_Quota_Bitmap},
    {NtfsOwns_Vcb_Mft_File_ObjectId, NtfsResourceBitmap, NtfsOwns_Vcb_Mft_File_ObjectId_Bitmap},
    {NtfsOwns_Vcb_Mft_File_ObjectId, NtfsResourceUsnJournal, NtfsOwns_Vcb_Mft_File_ObjectId_Journal},
    {NtfsOwns_Vcb_Mft_File_ObjectId_Journal, NtfsResourceBitmap, NtfsOwns_Vcb_Mft_File_ObjectId_Journal_Bitmap},
    {NtfsOwns_Vcb_Mft_File, NtfsResourceBitmap, NtfsOwns_Vcb_Mft_File_Bitmap},
    {NtfsOwns_Vcb_Mft_File, NtfsResourceUsnJournal, NtfsOwns_Vcb_Mft_File_Journal},
    {NtfsOwns_Vcb_Mft_File_Journal, NtfsResourceBitmap, NtfsOwns_Vcb_Mft_File_Journal_Bitmap},
    {NtfsOwns_Vcb_Mft_File_Reparse, NtfsResourceUsnJournal, NtfsOwns_Vcb_Mft_File_Reparse_Journal},
    {NtfsOwns_Vcb_Mft_Volume_Bitmap, NtfsResourceBoot, NtfsOwns_Vcb_Mft_Volume_Bitmap_Boot},
    {NtfsOwns_Vcb_Mft_Volume, NtfsResourceBitmap, NtfsOwns_Vcb_Mft_Volume_Bitmap},
    
    {NtfsOwns_Vcb_Extend, NtfsResourceFile, NtfsOwns_Vcb_File_Extend},
    {NtfsOwns_Vcb_Extend, NtfsResourceRootDir, NtfsOwns_Vcb_Root_Extend},
    {NtfsOwns_Vcb_Extend_Reparse, NtfsResourceSecure, NtfsOwns_Vcb_Extend_Reparse_Secure},
    {NtfsOwns_Vcb_Extend_ObjectId, NtfsResourceSecure, NtfsOwns_Vcb_Extend_ObjectId_Secure},
    
    {NtfsOwns_Vcb_Reparse, NtfsResourceExtendDir, NtfsOwns_Vcb_Extend_Reparse},
    {NtfsOwns_Vcb_ObjectId, NtfsResourceExtendDir, NtfsOwns_Vcb_Extend_ObjectId},  //  cleanup of objid
    {NtfsOwns_Vcb_Quota, NtfsResourceExtendDir, NtfsOwns_Vcb_Extend_Quota},  //  cleanup of quota
    
    //
    //  Flush Volume for vol. open
    //  

    {NtfsOwns_ExVcb_Volume, NtfsResourceRootDir, NtfsOwns_ExVcb_Root_Volume},
    {NtfsOwns_ExVcb_Volume, NtfsResourceFile, NtfsOwns_ExVcb_File_Volume}, // fsp close
    {NtfsOwns_ExVcb_File_Volume, NtfsResourceRootDir, NtfsOwns_ExVcb_Root_File_Volume}, // fsp close
    {NtfsOwns_ExVcb_Root_Volume, NtfsResourceFile, NtfsOwns_ExVcb_Root_File_Volume},
    {NtfsOwns_ExVcb_Root_File_Volume, NtfsResourceBitmap, NtfsOwns_ExVcb_Root_File_Volume_Bitmap},
    {NtfsOwns_ExVcb_Root_File_Volume, NtfsResourceObjectIdTable, NtfsOwns_ExVcb_Root_File_Volume_ObjectId},
    

    {NtfsOwns_ExVcb, NtfsResourceVolume, NtfsOwns_ExVcb_Volume},
    {NtfsOwns_ExVcb_Volume, NtfsResourceObjectIdTable, NtfsOwns_ExVcb_Volume_ObjectId}, //  set vol objid
    {NtfsOwns_ExVcb_Volume_ObjectId, NtfsResourceBitmap, NtfsOwns_ExVcb_Volume_ObjectId_Bitmap},
    {NtfsOwns_ExVcb_File_Volume, NtfsResourceMft, NtfsOwns_ExVcb_Mft_File_Volume},
    {NtfsOwns_ExVcb_File_Volume, NtfsResourceBitmap, NtfsOwns_ExVcb_File_Volume_Bitmap},
    {NtfsOwns_ExVcb_Mft_File_Volume, NtfsResourceUsnJournal, NtfsOwns_ExVcb_Mft_File_Volume_Journal},
    {NtfsOwns_ExVcb_Root_Volume, NtfsResourceObjectIdTable, NtfsOwns_ExVcb_Root_Volume_ObjectId}, 
    {NtfsOwns_ExVcb, NtfsResourceRootDir, NtfsOwns_ExVcb_Root},
    {NtfsOwns_ExVcb, NtfsResourceFile, NtfsOwns_ExVcb_File},
    {NtfsOwns_ExVcb, NtfsResourceExtendDir, NtfsOwns_ExVcb_Extend},
    {NtfsOwns_ExVcb, NtfsResourceUsnJournal, NtfsOwns_ExVcb_Journal},  //  delete usn jrnl
    {NtfsOwns_ExVcb, NtfsResourceQuotaTable, NtfsOwns_ExVcb_Quota}, //  dismount
    {NtfsOwns_ExVcb_Quota, NtfsResourceReparseTable, NtfsOwns_ExVcb_Quota_Reparse},
    {NtfsOwns_ExVcb_Quota, NtfsResourceObjectIdTable, NtfsOwns_ExVcb_Quota_ObjectId},
    {NtfsOwns_ExVcb_Quota_ObjectId, NtfsResourceExtendDir, NtfsOwns_ExVcb_Quota_ObjectId_Extend},
    {NtfsOwns_ExVcb_Quota_Reparse, NtfsResourceExtendDir, NtfsOwns_ExVcb_Quota_Reparse_Extend},
    {NtfsOwns_ExVcb_Quota_Reparse, NtfsResourceObjectIdTable, NtfsOwns_ExVcb_Quota_Reparse_ObjectId},
    
    {NtfsOwns_ExVcb, NtfsResourceMft, NtfsOwns_ExVcb_Mft},
    {NtfsOwns_ExVcb_Mft, NtfsResourceUsnJournal, NtfsOwns_ExVcb_Mft_Journal},  //  Create existing jrnl
    {NtfsOwns_ExVcb_Mft, NtfsResourceExtendDir, NtfsOwns_ExVcb_Mft_Extend},  //  CreateUnsJrnl  new
    {NtfsOwns_ExVcb_Mft_Root_File, NtfsResourceUsnJournal, NtfsOwns_ExVcb_Mft_Root_File_Journal},
    {NtfsOwns_ExVcb_Mft_Root_File, NtfsResourceBitmap, NtfsOwns_ExVcb_Mft_Root_File_Bitmap},
    {NtfsOwns_ExVcb_Extend, NtfsResourceRootDir, NtfsOwns_ExVcb_Root_Extend},
    {NtfsOwns_ExVcb_Journal, NtfsResourceExtendDir, NtfsOwns_ExVcb_Extend_Journal}, //  delete usnjrnl special
    {NtfsOwns_ExVcb_Extend_Journal, NtfsResourceBitmap, NtfsOwns_ExVcb_Extend_Journal_Bitmap}, //  DeleteJournalSpecial
    {NtfsOwns_ExVcb_Extend_Journal, NtfsResourceMft, NtfsOwns_ExVcb_Mft_Extend_Journal}, //  DeleteJournal
    
    {NtfsOwns_ExVcb_Root, NtfsResourceFile, NtfsOwns_ExVcb_Root_File},
    {NtfsOwns_ExVcb_Root, NtfsResourceMft, NtfsOwns_ExVcb_Mft_Root},
    {NtfsOwns_ExVcb_Root, NtfsResourceObjectIdTable, NtfsOwns_ExVcb_Root_ObjectId},
    {NtfsOwns_ExVcb_Root_ObjectId, NtfsResourceExtendDir, NtfsOwns_ExVcb_Root_ObjectId_Extend},
    {NtfsOwns_ExVcb_Root_ObjectId, NtfsResourceSecure, NtfsOwns_ExVcb_Root_ObjectId_Secure},
    {NtfsOwns_ExVcb_Root_ObjectId_Secure, NtfsResourceBitmap, NtfsOwns_ExVcb_Root_ObjectId_Secure_Bitmap},
    {NtfsOwns_ExVcb_File, NtfsResourceSecure, NtfsOwns_ExVcb_File_Secure},
    {NtfsOwns_ExVcb_File, NtfsResourceMft, NtfsOwns_ExVcb_Mft_File},
    {NtfsOwns_ExVcb_Mft_File, NtfsResourceUsnJournal, NtfsOwns_ExVcb_Mft_File_Journal},
    {NtfsOwns_ExVcb_Root_File, NtfsResourceSecure, NtfsOwns_ExVcb_Root_File_Secure},
    {NtfsOwns_ExVcb_Root_File, NtfsResourceBitmap, NtfsOwns_ExVcb_Root_File_Bitmap},
    {NtfsOwns_ExVcb_Root_File, NtfsResourceQuotaTable, NtfsOwns_ExVcb_Root_File_Quota},
    {NtfsOwns_ExVcb_Root_File, NtfsResourceMft, NtfsOwns_ExVcb_Mft_Root_File},
    {NtfsOwns_ExVcb_Root_File_Quota, NtfsResourceMft, NtfsOwns_ExVcb_Root_File_Quota_Mft},
    {NtfsOwns_ExVcb_Root_File_Quota, NtfsResourceBitmap, NtfsOwns_ExVcb_Root_File_Quota_Bitmap},
    
    //
    //  AcquireAllFilesPath
    //  

    {NtfsOwns_ExVcb_Root_File, NtfsResourceObjectIdTable, NtfsOwns_ExVcb_Root_File_ObjectId}, 
    {NtfsOwns_ExVcb_Root_File_ObjectId, NtfsResourceSecure, NtfsOwns_ExVcb_Root_File_ObjectId_Secure}, 
};

//
//  These are release only possible transitions
//  

NTFS_OWNERSHIP_TRANSITION OwnershipTransitionTableRelease[] = 
{
    
    //
    //  Teardowns created by out of order vcb release
    //

    {NtfsOwns_BadClust, NtfsResourceBadClust, None},
    {NtfsOwns_Boot, NtfsResourceBoot, None},
    {NtfsOwns_Root_BadClust, NtfsResourceBadClust, NtfsOwns_Root},
    {NtfsOwns_Root_File, NtfsResourceRootDir, NtfsOwns_File},
    {NtfsOwns_Root_File, NtfsResourceFile, NtfsOwns_Root},
    {NtfsOwns_Root_File_ObjectId, NtfsResourceObjectIdTable, NtfsOwns_Root_File},
    {NtfsOwns_Root_File_ObjectId_Extend, NtfsResourceExtendDir, NtfsOwns_Root_File_ObjectId},
    {NtfsOwns_Root_File_Quota, NtfsResourceQuotaTable, NtfsOwns_Root_File},
    {NtfsOwns_Root_LogFile, NtfsResourceLogFile, NtfsOwns_Root},
    {NtfsOwns_Root_Mft2, NtfsResourceMft2, NtfsOwns_Root},
    {NtfsOwns_Root_ObjectId, NtfsResourceObjectIdTable, NtfsOwns_Root},
    {NtfsOwns_Root_Secure, NtfsResourceSecure, NtfsOwns_Root},
    {NtfsOwns_Root_Upcase, NtfsResourceUpCase, NtfsOwns_Root},
    {NtfsOwns_Root_Mft, NtfsResourceMft, NtfsOwns_Root},
    {NtfsOwns_Root_Mft, NtfsResourceRootDir, NtfsOwns_Mft},  //  after teardown in create
    {NtfsOwns_Root_Mft_File, NtfsResourceMft, NtfsOwns_Root_File},
    {NtfsOwns_Root_Mft_File, NtfsResourceFile, NtfsOwns_Root_Mft},
    {NtfsOwns_Root_Mft_File_Quota, NtfsResourceQuotaTable, NtfsOwns_Root_Mft_File},
    {NtfsOwns_Root_Mft_File_Journal, NtfsResourceRootDir, NtfsOwns_Mft_File_Journal},
    {NtfsOwns_Root_Mft_File_Journal, NtfsResourceUsnJournal, NtfsOwns_Root_Mft_File},
    {NtfsOwns_Root_Mft_File_ObjectId, NtfsResourceFile, NtfsOwns_Root_Mft_ObjectId},
    {NtfsOwns_Root_Mft_File_ObjectId, NtfsResourceMft, NtfsOwns_Root_File_ObjectId},
    {NtfsOwns_Root_Mft_Journal, NtfsResourceUsnJournal, NtfsOwns_Root_Mft},
    {NtfsOwns_Root_Mft_ObjectId, NtfsResourceMft, NtfsOwns_Root_ObjectId},
    {NtfsOwns_Root_Extend, NtfsResourceExtendDir, NtfsOwns_Root},
    {NtfsOwns_Root_Extend, NtfsResourceRootDir, NtfsOwns_Extend},
    {NtfsOwns_Extend_Reparse, NtfsResourceReparseTable, NtfsOwns_Extend},
    {NtfsOwns_Extend_Reparse, NtfsResourceExtendDir, NtfsOwns_Reparse},
    {NtfsOwns_Extend_ObjectId, NtfsResourceObjectIdTable, NtfsOwns_Extend},
    {NtfsOwns_Extend_ObjectId, NtfsResourceExtendDir, NtfsOwns_ObjectId},
    {NtfsOwns_Extend_Quota, NtfsResourceQuotaTable, NtfsOwns_Extend},
    {NtfsOwns_Extend_Quota, NtfsResourceExtendDir, NtfsOwns_Quota},
    {NtfsOwns_File_Quota, NtfsResourceFile, NtfsOwns_Quota},
    {NtfsOwns_File_ObjectId_Reparse, NtfsResourceReparseTable, NtfsOwns_File_ObjectId},
    {NtfsOwns_LogFile, NtfsResourceLogFile, None},
    {NtfsOwns_Mft_File, NtfsResourceFile, NtfsOwns_Mft},
    {NtfsOwns_Mft_File_Quota, NtfsResourceMft, NtfsOwns_File_Quota},
    {NtfsOwns_Mft_File_Quota, NtfsResourceQuotaTable, NtfsOwns_Mft_File},
    {NtfsOwns_Mft_File_ObjectId_Quota, NtfsResourceQuotaTable, NtfsOwns_Mft_File_ObjectId},
    {NtfsOwns_Mft_File_Secure, NtfsResourceSecure, NtfsOwns_Mft_File},
    {NtfsOwns_Mft_File_ObjectId_Reparse, NtfsResourceMft, NtfsOwns_File_ObjectId_Reparse},
    {NtfsOwns_Mft_Volume_Bitmap, NtfsResourceBitmap, NtfsOwns_Mft_Volume},
    {NtfsOwns_Mft_Extend_Journal, NtfsResourceUsnJournal, NtfsOwns_Mft_Extend},  //  CreateNew or Delete Journal
    {NtfsOwns_Mft_Extend_Journal, NtfsResourceMft, NtfsOwns_Extend_Journal},  //  "Create" Existing journal 
    {NtfsOwns_Mft_Extend, NtfsResourceMft, NtfsOwns_Extend},
    {NtfsOwns_Mft_Extend, NtfsResourceExtendDir, NtfsOwns_Mft},
    {NtfsOwns_Extend_Journal, NtfsResourceUsnJournal, NtfsOwns_Extend},
    {NtfsOwns_Volume_ObjectId, NtfsResourceObjectIdTable, NtfsOwns_Volume},
    
    //
    //  Result of teardown
    //  

    {NtfsOwns_Vcb_Root_File, NtfsResourceFile, NtfsOwns_Vcb_Root},
    {NtfsOwns_Vcb_Root_Upcase, NtfsResourceUpCase, NtfsOwns_Vcb_Root},
    {NtfsOwns_Vcb_Root_Boot, NtfsResourceBoot, NtfsOwns_Vcb_Root},
    {NtfsOwns_Vcb_Mft_File, NtfsResourceFile, NtfsOwns_Vcb_Mft},
    {NtfsOwns_Vcb_Mft_Root, NtfsResourceRootDir, NtfsOwns_Vcb_Mft},
    {NtfsOwns_Vcb_Mft_Root_File, NtfsResourceFile, NtfsOwns_Vcb_Mft_Root},
    {NtfsOwns_Vcb_Mft_Root_File_Journal, NtfsResourceFile, NtfsOwns_Vcb_Mft_Root_Journal},
    {NtfsOwns_Vcb_File_Quota, NtfsResourceFile, NtfsOwns_Vcb_Quota}, // reepair quota index
    
    
    {NtfsOwns_ExVcb_Mft_Extend_Journal, NtfsResourceUsnJournal, NtfsOwns_ExVcb_Mft_Extend},
    {NtfsOwns_ExVcb_Quota_Reparse_Extend, NtfsResourceReparseTable, NtfsOwns_ExVcb_Quota_Extend},
    {NtfsOwns_ExVcb_Quota_ObjectId_Extend, NtfsResourceObjectIdTable, NtfsOwns_ExVcb_Quota_Extend},
    {NtfsOwns_ExVcb_Quota_Extend, NtfsResourceExtendDir, NtfsOwns_ExVcb_Quota},
    {NtfsOwns_ExVcb_Root_File_Volume, NtfsResourceFile, NtfsOwns_ExVcb_Root_Volume},
    {NtfsOwns_ExVcb_Mft_Root_File, NtfsResourceFile, NtfsOwns_ExVcb_Mft_Root},
    
    //
    //  Interlocked create release 
    //

    {NtfsOwns_Vcb_Root_File, NtfsResourceRootDir, NtfsOwns_Vcb_File},
    {NtfsOwns_Vcb_Root_Extend, NtfsResourceRootDir, NtfsOwns_Vcb_Extend},
    {NtfsOwns_Vcb_Mft_File, NtfsResourceMft, NtfsOwns_Vcb_File},
    {NtfsOwns_Vcb_Mft_Root_File, NtfsResourceRootDir, NtfsOwns_Vcb_Mft_File},
    {NtfsOwns_Vcb_Extend, NtfsResourceExtendDir, NtfsOwns_Vcb},
    {NtfsOwns_Vcb_Mft_BadClust, NtfsResourceMft, NtfsOwns_Vcb_BadClust},  //  openbyid
    {NtfsOwns_Vcb_Mft_Bitmap, NtfsResourceMft, NtfsOwns_Vcb_Bitmap},  //  openbyid
    {NtfsOwns_Vcb_Mft_Boot, NtfsResourceMft, NtfsOwns_Vcb_Boot},  //  openbyid
    {NtfsOwns_Vcb_Mft_Extend, NtfsResourceMft, NtfsOwns_Vcb_Extend},  //  byid
    {NtfsOwns_Vcb_Mft_LogFile, NtfsResourceMft, NtfsOwns_Vcb_LogFile},
    {NtfsOwns_Vcb_Mft_Mft2, NtfsResourceMft, NtfsOwns_Vcb_Mft2},  // openbyid
    {NtfsOwns_Vcb_Mft_ObjectId, NtfsResourceMft, NtfsOwns_Vcb_ObjectId},
    {NtfsOwns_Vcb_Mft_Quota, NtfsResourceMft, NtfsOwns_Vcb_Quota},
    {NtfsOwns_Vcb_Mft_Reparse, NtfsResourceMft, NtfsOwns_Vcb_Reparse},
    {NtfsOwns_Vcb_Mft_Secure, NtfsResourceMft, NtfsOwns_Vcb_Secure},
    {NtfsOwns_Vcb_Mft_Upcase, NtfsResourceMft, NtfsOwns_Vcb_Upcase},  //  openbyid
    
    {NtfsOwns_ExVcb_Root_File, NtfsResourceRootDir, NtfsOwns_ExVcb_File},
    
    //
    //  vcb releases
    // 
    
    {NtfsOwns_Vcb_File, NtfsResourceSharedVcb, NtfsOwns_File},
    {NtfsOwns_Vcb_File_Quota, NtfsResourceSharedVcb, NtfsOwns_File_Quota},
    {NtfsOwns_Vcb_File_ObjectId, NtfsResourceSharedVcb, NtfsOwns_File_ObjectId},
    {NtfsOwns_Vcb_File_Reparse, NtfsResourceSharedVcb, NtfsOwns_File_Reparse},
    {NtfsOwns_Vcb_File_Secure, NtfsResourceSharedVcb, NtfsOwns_File_Secure},
    {NtfsOwns_Vcb_Volume, NtfsResourceSharedVcb, NtfsOwns_Volume},
    {NtfsOwns_Vcb_Root, NtfsResourceSharedVcb, NtfsOwns_Root},
    {NtfsOwns_Vcb_Root_Extend, NtfsResourceSharedVcb, NtfsOwns_Root_Extend},
    {NtfsOwns_Vcb_Mft, NtfsResourceSharedVcb, NtfsOwns_Mft},
    {NtfsOwns_Vcb_Reparse, NtfsResourceSharedVcb, NtfsOwns_Reparse},
    {NtfsOwns_Vcb_ObjectId, NtfsResourceSharedVcb, NtfsOwns_ObjectId},
    {NtfsOwns_Vcb_Root_File, NtfsResourceSharedVcb, NtfsOwns_Root_File},
    {NtfsOwns_Vcb_Root_File_Quota, NtfsResourceSharedVcb, NtfsOwns_Root_File_Quota},
    {NtfsOwns_Vcb_Root_Quota, NtfsResourceSharedVcb, NtfsOwns_Root_Quota},
    {NtfsOwns_Vcb_Mft_Root, NtfsResourceSharedVcb, NtfsOwns_Root_Mft},
    {NtfsOwns_Vcb_Mft_Root_File_Journal, NtfsResourceSharedVcb, NtfsOwns_Root_Mft_File_Journal},
    {NtfsOwns_Vcb_Mft_Root_File_Quota, NtfsResourceSharedVcb, NtfsOwns_Root_Mft_File_Quota},
    {NtfsOwns_Vcb_Mft_Root_File_ObjectId, NtfsResourceSharedVcb, NtfsOwns_Root_Mft_File_ObjectId},
    {NtfsOwns_Vcb_Mft_Root_File_ObjectId_Quota, NtfsResourceSharedVcb, NtfsOwns_Root_Mft_File_ObjectId_Quota},
    {NtfsOwns_Vcb_Mft_Root_File, NtfsResourceSharedVcb, NtfsOwns_Root_Mft_File},
    {NtfsOwns_Vcb_Mft_Root_Journal, NtfsResourceSharedVcb, NtfsOwns_Root_Mft_Journal},
    {NtfsOwns_Vcb_Mft_File_Quota, NtfsResourceSharedVcb, NtfsOwns_Mft_File_Quota},
    {NtfsOwns_Vcb_Mft_File, NtfsResourceSharedVcb, NtfsOwns_Mft_File},
    {NtfsOwns_Vcb_Mft_File_ObjectId, NtfsResourceSharedVcb, NtfsOwns_Mft_File_ObjectId},
    {NtfsOwns_Vcb_Mft_File_Secure, NtfsResourceSharedVcb, NtfsOwns_Mft_File_Secure},
    {NtfsOwns_Vcb_Mft_File_Reparse, NtfsResourceSharedVcb, NtfsOwns_Mft_File_Reparse},
    {NtfsOwns_Vcb_Mft_File_Journal, NtfsResourceSharedVcb, NtfsOwns_Mft_File_Journal},
    {NtfsOwns_Vcb_Mft_File_Journal, NtfsResourceSharedVcb, NtfsOwns_Mft_File_Journal},
    {NtfsOwns_Vcb_Mft_File_ObjectId_Quota, NtfsResourceSharedVcb, NtfsOwns_Mft_File_ObjectId_Quota},
    {NtfsOwns_Vcb_Mft_File_ObjectId_Journal, NtfsResourceSharedVcb, NtfsOwns_Mft_File_ObjectId_Journal},
    {NtfsOwns_Vcb_Mft_File_ObjectId_Reparse, NtfsResourceSharedVcb, NtfsOwns_Mft_File_ObjectId_Reparse},
    {NtfsOwns_Vcb_Mft_Volume_Bitmap, NtfsResourceSharedVcb, NtfsOwns_Mft_Volume_Bitmap},
    {NtfsOwns_Vcb_Extend_Reparse, NtfsResourceSharedVcb, NtfsOwns_Extend_Reparse},
    {NtfsOwns_Vcb_Extend_ObjectId, NtfsResourceSharedVcb, NtfsOwns_Extend_ObjectId},
    {NtfsOwns_Vcb_Extend_Quota, NtfsResourceSharedVcb, NtfsOwns_Extend_Quota},
    {NtfsOwns_Vcb_Extend_Journal, NtfsResourceSharedVcb, NtfsOwns_Extend_Journal},
    {NtfsOwns_Vcb_BadClust, NtfsResourceSharedVcb, NtfsOwns_BadClust},
    {NtfsOwns_Vcb_Bitmap, NtfsResourceSharedVcb, NtfsOwns_Bitmap},
    {NtfsOwns_Vcb_Boot, NtfsResourceSharedVcb, NtfsOwns_Boot},
    {NtfsOwns_Vcb_Quota, NtfsResourceSharedVcb, NtfsOwns_Quota},
    {NtfsOwns_Vcb_Root_Mft2, NtfsResourceSharedVcb, NtfsOwns_Root_Mft2},
    {NtfsOwns_Vcb_Mft2, NtfsResourceSharedVcb, NtfsOwns_Mft2},
    {NtfsOwns_Vcb_Root_Upcase, NtfsResourceSharedVcb, NtfsOwns_Root_Upcase},
    {NtfsOwns_Vcb_Root_LogFile, NtfsResourceSharedVcb, NtfsOwns_Root_LogFile},
    {NtfsOwns_Vcb_Root_Secure, NtfsResourceSharedVcb, NtfsOwns_Root_Secure},
    {NtfsOwns_Vcb_Root_BadClust, NtfsResourceSharedVcb, NtfsOwns_Root_BadClust},
    {NtfsOwns_Vcb_Upcase, NtfsResourceSharedVcb, NtfsOwns_Upcase},
    {NtfsOwns_Vcb_Secure, NtfsResourceSharedVcb, NtfsOwns_Secure},
    {NtfsOwns_Vcb_Extend, NtfsResourceSharedVcb, NtfsOwns_Extend},
    {NtfsOwns_Vcb_Journal, NtfsResourceSharedVcb, NtfsOwns_Journal},
    {NtfsOwns_Vcb_LogFile, NtfsResourceSharedVcb, NtfsOwns_LogFile},
    {NtfsOwns_Vcb_ObjectId, NtfsResourceSharedVcb, NtfsOwns_ObjectId},
    
    {NtfsOwns_ExVcb_File, NtfsResourceExVcb, NtfsOwns_File},
    {NtfsOwns_ExVcb_Root_File, NtfsResourceExVcb, NtfsOwns_Root_File},
    {NtfsOwns_ExVcb_Root_File_ObjectId_Extend, NtfsResourceExVcb, NtfsOwns_Root_File_ObjectId_Extend},
    {NtfsOwns_ExVcb_Root_File_Quota, NtfsResourceExVcb, NtfsOwns_Root_File_Quota}, 
    {NtfsOwns_ExVcb_Root_File_Quota_Mft, NtfsResourceExVcb, NtfsOwns_Root_Mft_File_Quota},
    {NtfsOwns_ExVcb_Mft, NtfsResourceExVcb, NtfsOwns_Mft},
    {NtfsOwns_ExVcb_Mft_Root, NtfsResourceExVcb, NtfsOwns_Root_Mft},
    {NtfsOwns_ExVcb_Mft_Root_File, NtfsResourceExVcb, NtfsOwns_Root_Mft_File},
    {NtfsOwns_ExVcb_Mft_File_Journal, NtfsResourceExVcb, NtfsOwns_Mft_File_Journal},
    {NtfsOwns_ExVcb_Mft_Extend_Journal, NtfsResourceExVcb, NtfsOwns_Mft_Extend_Journal},
    {NtfsOwns_ExVcb_Mft_Extend, NtfsResourceExVcb, NtfsOwns_Mft_Extend},
    {NtfsOwns_ExVcb_Mft_Journal, NtfsResourceExVcb, NtfsOwns_Mft_Journal},
    {NtfsOwns_ExVcb_Journal, NtfsResourceExVcb, NtfsOwns_Journal},
    {NtfsOwns_ExVcb_Volume, NtfsResourceExVcb, NtfsOwns_Volume},
    {NtfsOwns_ExVcb_Volume_ObjectId, NtfsResourceExVcb, NtfsOwns_Volume_ObjectId},

    //
    //  ReleaseAllFiles
    // 
    
    {NtfsOwns_ExVcb_ObjectId_Extend, NtfsResourceExtendDir, NtfsOwns_ExVcb_ObjectId},
    {NtfsOwns_ExVcb_ObjectId, NtfsResourceObjectIdTable, NtfsOwns_ExVcb},
    
    {NtfsOwns_ExVcb_Root_ObjectId_Secure, NtfsResourceRootDir, NtfsOwns_ExVcb_ObjectId_Secure},
    {NtfsOwns_ExVcb_ObjectId_Secure, NtfsResourceSecure, NtfsOwns_ExVcb_ObjectId},
    {NtfsOwns_ExVcb_Root_File_ObjectId_Secure, NtfsResourceRootDir, NtfsOwns_ExVcb_File_ObjectId_Secure},
    {NtfsOwns_ExVcb_File_ObjectId_Secure, NtfsResourceFile, NtfsOwns_ExVcb_ObjectId_Secure},
    {NtfsOwns_ExVcb_Root_File_Volume_ObjectId, NtfsResourceRootDir, NtfsOwns_ExVcb_File_Volume_ObjectId},
    {NtfsOwns_ExVcb_File_Volume_ObjectId, NtfsResourceFile, NtfsOwns_ExVcb_Volume_ObjectId},

    //
    //  Shared out of order release
    // 

    {NtfsOwns_Root_Quota, NtfsResourceRootDir, NtfsOwns_Quota},
    {NtfsOwns_Vcb_Mft_Root_File_ObjectId, NtfsResourceRootDir, NtfsOwns_Vcb_Mft_File_ObjectId},
    {NtfsOwns_Vcb_Root_File_ObjectId, NtfsResourceRootDir, NtfsOwns_Vcb_File_ObjectId}, // cleanup
    {NtfsOwns_Root_File_Quota, NtfsResourceRootDir, NtfsOwns_File_Quota},
    {NtfsOwns_Vcb_Mft_Root_File_Quota, NtfsResourceRootDir, NtfsOwns_Vcb_Mft_File_Quota}, // cleanup
    {NtfsOwns_Vcb_Mft_Root_File_Quota, NtfsResourceRootDir, NtfsOwns_Vcb_Mft_File_Quota}, // cleanup
    
    //
    //  SetObjectIdInternal Paths - out of order file release
    // 

    {NtfsOwns_Mft_File_ObjectId_Journal, NtfsResourceFile, NtfsOwns_Mft_ObjectId_Journal},
    {NtfsOwns_Mft_ObjectId_Journal, NtfsResourceUsnJournal, NtfsOwns_Mft_ObjectId},
    {NtfsOwns_Mft_ObjectId, NtfsResourceMft, NtfsOwns_ObjectId},
    {NtfsOwns_Mft_File_Journal, NtfsResourceFile, NtfsOwns_Mft_Journal},

    //
    //  Misc.
    //  

    {NtfsOwns_Mft_Volume, NtfsResourceVolume, NtfsOwns_Mft},  //  GetMftRecord
    {NtfsOwns_ExVcb_Mft_Journal, NtfsResourceMft, NtfsOwns_ExVcb_Journal}, // initjrnl
    {NtfsOwns_ExVcb_Mft_Extend, NtfsResourceMft, NtfsOwns_ExVcb_Extend}, // deletejrnl

    //
    //  NtfsResourceAny def. backpaths
    //  

    {NtfsOwns_ExVcb, NtfsResourceAny, NtfsOwns_ExVcb},
    {NtfsOwns_ExVcb_File, NtfsResourceAny, NtfsOwns_ExVcb_File},
    {NtfsOwns_ExVcb_ObjectId_Secure, NtfsResourceAny, NtfsOwns_ExVcb_ObjectId_Secure},
    {NtfsOwns_ExVcb_Quota_Reparse_ObjectId, NtfsResourceAny, NtfsOwns_ExVcb_Quota_Reparse_ObjectId},
    {NtfsOwns_ExVcb_Quota, NtfsResourceAny, NtfsOwns_ExVcb_Quota},
    {NtfsOwns_ExVcb_Root, NtfsResourceAny, NtfsOwns_ExVcb_Root},
    {NtfsOwns_ExVcb_Root_File_ObjectId, NtfsResourceAny, NtfsOwns_ExVcb_Root_File_ObjectId},
    {NtfsOwns_ExVcb_Root_File_ObjectId_Secure, NtfsResourceAny, NtfsOwns_ExVcb_Root_File_ObjectId_Secure},
    {NtfsOwns_ExVcb_Root_Volume_ObjectId, NtfsResourceAny, NtfsOwns_ExVcb_Root_Volume_ObjectId},
    {NtfsOwns_ExVcb_Volume, NtfsResourceAny, NtfsOwns_ExVcb_Volume},  
    {NtfsOwns_ExVcb_Volume_ObjectId, NtfsResourceAny, NtfsOwns_ExVcb_Volume_ObjectId},  

    {NtfsOwns_Root_File_ObjectId_Extend, NtfsResourceAny, NtfsOwns_Root_File_ObjectId_Extend} // acquire all files + exception and transaction

};

//
//  Acquire Only transtions
//  
                            
NTFS_OWNERSHIP_TRANSITION OwnershipTransitionTableAcquire[] = 
{
    //
    //  Any relations
    //  

    {NtfsOwns_ExVcb, NtfsResourceAny, NtfsOwns_ExVcb},
    {NtfsOwns_ExVcb_Volume, NtfsResourceAny, NtfsOwns_ExVcb_Volume},  
    {NtfsOwns_ExVcb_File, NtfsResourceAny, NtfsOwns_ExVcb_File},
    {NtfsOwns_ExVcb_File_Secure, NtfsResourceAny, NtfsOwns_ExVcb_File_Secure},
    {NtfsOwns_ExVcb_ObjectId_Extend, NtfsResourceAny, NtfsOwns_ExVcb_ObjectId_Extend},
    {NtfsOwns_ExVcb_Root_File_ObjectId, NtfsResourceAny, NtfsOwns_ExVcb_Root_File_ObjectId},
    {NtfsOwns_ExVcb_Root_File_ObjectId_Extend, NtfsResourceAny, NtfsOwns_ExVcb_Root_File_ObjectId_Extend},
    {NtfsOwns_ExVcb_Root_Volume_ObjectId, NtfsResourceAny, NtfsOwns_ExVcb_Root_Volume_ObjectId},

    //
    //  Acquire all files 
    // 

    {NtfsOwns_ExVcb_Root_ObjectId_Secure, NtfsResourceAny, NtfsOwns_ExVcb_Root_ObjectId_Secure},  // no userfiles
    {NtfsOwns_ExVcb_Root_File_ObjectId_Secure, NtfsResourceAny, NtfsOwns_ExVcb_Root_File_ObjectId_Secure},  // userfile
    {NtfsOwns_ExVcb_Root_File_Volume_ObjectId, NtfsResourceAny, NtfsOwns_ExVcb_Root_File_Volume_ObjectId},  // from volopen

    {NtfsOwns_ExVcb_Quota, NtfsResourceAny, NtfsOwns_ExVcb_Quota},
    {NtfsOwns_ExVcb_Quota_Extend, NtfsResourceAny, NtfsOwns_ExVcb_Quota_Extend},
    {NtfsOwns_ExVcb_Quota_ObjectId, NtfsResourceAny, NtfsOwns_ExVcb_Quota_ObjectId},
    {NtfsOwns_ExVcb_Quota_Reparse_Extend, NtfsResourceAny, NtfsOwns_ExVcb_Quota_Reparse_Extend},
    {NtfsOwns_ExVcb_Quota_Reparse_ObjectId, NtfsResourceAny, NtfsOwns_ExVcb_Quota_Reparse_ObjectId}
    
};

//
//  Unsafe Transitions
//  

NTFS_OWNERSHIP_TRANSITION OwnershipTransitionTableUnsafe[] = 
{
    //
    //  unsafe create path
    //

    {NtfsOwns_Vcb_Extend, NtfsResourceReparseTable, NtfsOwns_Vcb_Extend_Reparse},
    {NtfsOwns_Vcb_Extend, NtfsResourceObjectIdTable, NtfsOwns_Vcb_Extend_ObjectId},  
    {NtfsOwns_Vcb_Extend, NtfsResourceQuotaTable, NtfsOwns_Vcb_Extend_Quota},  
    {NtfsOwns_Vcb_Extend, NtfsResourceUsnJournal, NtfsOwns_Vcb_Extend_Journal},  
    {NtfsOwns_Vcb_Root, NtfsResourceExtendDir, NtfsOwns_Vcb_Root_Extend}, 
    {NtfsOwns_Vcb_Root, NtfsResourceFile, NtfsOwns_Vcb_Root_File}, 
    {NtfsOwns_Vcb_Root, NtfsResourceUpCase, NtfsOwns_Vcb_Root_Upcase},
    {NtfsOwns_Vcb_Root, NtfsResourceBoot, NtfsOwns_Vcb_Root_Boot},
    {NtfsOwns_Vcb_Root, NtfsResourceBadClust, NtfsOwns_Vcb_Root_BadClust},
    {NtfsOwns_Vcb_Root, NtfsResourceLogFile, NtfsOwns_Vcb_Root_LogFile},
    
    //
    //  NewFile - byid
    //  

    {NtfsOwns_Vcb_Mft_Root, NtfsResourceFile, NtfsOwns_Vcb_Mft_Root_File},
    {NtfsOwns_ExVcb_Mft_Root, NtfsResourceFile, NtfsOwns_ExVcb_Mft_Root_File}, // create pagingfile
    {NtfsOwns_Vcb_Mft_Root_Quota, NtfsResourceFile, NtfsOwns_Vcb_Mft_Root_File_Quota},

    {NtfsOwns_Vcb_Mft, NtfsResourceBadClust, NtfsOwns_Vcb_Mft_BadClust},
    {NtfsOwns_Vcb_Mft, NtfsResourceBoot, NtfsOwns_Vcb_Mft_Boot},
    {NtfsOwns_Vcb_Mft, NtfsResourceBitmap, NtfsOwns_Vcb_Mft_Bitmap},
    {NtfsOwns_Vcb_Mft, NtfsResourceRootDir, NtfsOwns_Vcb_Mft_Root},
    {NtfsOwns_Vcb_Mft, NtfsResourceFile, NtfsOwns_Vcb_Mft_File},
    {NtfsOwns_Vcb_Mft, NtfsResourceMft2, NtfsOwns_Vcb_Mft_Mft2},
    {NtfsOwns_Vcb_Mft, NtfsResourceUpCase, NtfsOwns_Vcb_Mft_Upcase},
    {NtfsOwns_Vcb_Mft, NtfsResourceExtendDir, NtfsOwns_Vcb_Mft_Extend},
    {NtfsOwns_Vcb_Mft, NtfsResourceLogFile, NtfsOwns_Vcb_Mft_LogFile},
    {NtfsOwns_Vcb_Mft, NtfsResourceSecure, NtfsOwns_Vcb_Mft_Secure},
    {NtfsOwns_Vcb_Mft, NtfsResourceObjectIdTable, NtfsOwns_Vcb_Mft_ObjectId},
    {NtfsOwns_Vcb_Mft, NtfsResourceQuotaTable, NtfsOwns_Vcb_Mft_Quota},
    {NtfsOwns_Vcb_Mft, NtfsResourceReparseTable, NtfsOwns_Vcb_Mft_Reparse},

    {NtfsOwns_Vcb_Mft_Root_ObjectId, NtfsResourceFile, NtfsOwns_Vcb_Mft_Root_File_ObjectId},

    //
    //  DeleteUnsJrnl
    //
    
    {NtfsOwns_ExVcb_Extend, NtfsResourceUsnJournal, NtfsOwns_ExVcb_Extend_Journal},

    //
    //  CreateUsnJrnl
    //  

    {NtfsOwns_ExVcb_Mft_Extend, NtfsResourceFile, NtfsOwns_ExVcb_Mft_Extend_File},

    //
    //  Close path
    //  

    {NtfsOwns_File, NtfsResourceSharedVcb, NtfsOwns_Vcb_File},
    {NtfsOwns_File_Reparse, NtfsResourceSharedVcb, NtfsOwns_Vcb_File_Reparse},
    {NtfsOwns_Mft_File_Reparse_Journal, NtfsResourceSharedVcb, NtfsOwns_Vcb_Mft_File_Reparse_Journal},

    //
    //  dirctrl
    //  

    {NtfsOwns_Root, NtfsResourceFile, NtfsOwns_Root_File},

    //
    //  Teardown in create
    //  

    {NtfsOwns_Vcb_Mft_File, NtfsResourceRootDir, NtfsOwns_Vcb_Mft_Root_File}
};



#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\lockctrl.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    LockCtrl.c

Abstract:

    This module implements the File Lock Control routine for Ntfs called by the
    dispatch driver.

Author:

    Gary Kimura     [GaryKi]        28-May-1991

Revision History:

--*/

#include "NtfsProc.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_LOCKCTRL)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCommonLockControl)
#pragma alloc_text(PAGE, NtfsFastLock)
#pragma alloc_text(PAGE, NtfsFastUnlockAll)
#pragma alloc_text(PAGE, NtfsFastUnlockAllByKey)
#pragma alloc_text(PAGE, NtfsFastUnlockSingle)
#pragma alloc_text(PAGE, NtfsFsdLockControl)
#endif


NTSTATUS
NtfsFsdLockControl (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of Lock Control.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    NTSTATUS Status = STATUS_SUCCESS;
    PIRP_CONTEXT IrpContext = NULL;

    ASSERT_IRP( Irp );

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFsdLockControl\n") );

    //
    //  Call the common Lock Control routine
    //

    FsRtlEnterFileSystem();

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, FALSE, FALSE );

    do {

        try {

            //
            //  We are either initiating this request or retrying it.
            //

            if (IrpContext == NULL) {

                //
                //  Allocate and initialize the Irp.
                //

                NtfsInitializeIrpContext( Irp, CanFsdWait( Irp ), &IrpContext );

                //
                //  Initialize the thread top level structure, if needed.
                //
    
                NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

            } else if (Status == STATUS_LOG_FILE_FULL) {

                NtfsCheckpointForLogFileFull( IrpContext );
            }

            Status = NtfsCommonLockControl( IrpContext, Irp );
            break;

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error status that we get back from the
            //  execption code
            //

            Status = NtfsProcessException( IrpContext, Irp, GetExceptionCode() );
        }

    } while (Status == STATUS_CANT_WAIT ||
             Status == STATUS_LOG_FILE_FULL);

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsFsdLockControl -> %08lx\n", Status) );

    return Status;
}


BOOLEAN
NtfsFastLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast lock call.

Arguments:

    FileObject - Supplies the file object used in this operation

    FileOffset - Supplies the file offset used in this operation

    Length - Supplies the length used in this operation

    ProcessId - Supplies the process ID used in this operation

    Key - Supplies the key used in this operation

    FailImmediately - Indicates if the request should fail immediately
        if the lock cannot be granted.

    ExclusiveLock - Indicates if this is a request for an exclusive or
        shared lock

    IoStatus - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results;
    PSCB Scb;
    PFCB Fcb;
    BOOLEAN ResourceAcquired = FALSE;

    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFastLock\n") );

    //
    //  Decode the type of file object we're being asked to process and
    //  make sure that is is only a user file open.
    //

    if ((Scb = NtfsFastDecodeUserFileOpen( FileObject )) == NULL) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;
        IoStatus->Information = 0;

        DebugTrace( -1, Dbg, ("NtfsFastLock -> TRUE (STATUS_INVALID_PARAMETER)\n") );
        return TRUE;
    }

    Fcb = Scb->Fcb;

    //
    //  Acquire shared access to the Fcb this operation can always wait
    //

    FsRtlEnterFileSystem();

    if (Scb->ScbType.Data.FileLock == NULL) {

        (VOID) ExAcquireResourceExclusiveLite( Fcb->Resource, TRUE );
        ResourceAcquired = TRUE;

    } else {

        //(VOID) ExAcquireResourceSharedLite( Fcb->Resource, TRUE );
    }

    try {

        //
        //  We check whether we can proceed
        //  based on the state of the file oplocks.
        //

        if ((Scb->ScbType.Data.Oplock != NULL) &&
            !FsRtlOplockIsFastIoPossible( &Scb->ScbType.Data.Oplock )) {

            try_return( Results = FALSE );
        }

        //
        //  If we don't have a file lock, then get one now.
        //

        if (Scb->ScbType.Data.FileLock == NULL
            && !NtfsCreateFileLock( Scb, FALSE )) {

            try_return( Results = FALSE );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request
        //

        if (Results = FsRtlFastLock( Scb->ScbType.Data.FileLock,
                                     FileObject,
                                     FileOffset,
                                     Length,
                                     ProcessId,
                                     Key,
                                     FailImmediately,
                                     ExclusiveLock,
                                     IoStatus,
                                     NULL,
                                     FALSE )) {

            //
            //  Set the flag indicating if Fast I/O is questionable.  We
            //  only change this flag is the current state is possible.
            //  Retest again after synchronizing on the header.
            //

            if (Scb->Header.IsFastIoPossible == FastIoIsPossible) {

                NtfsAcquireFsrtlHeader( Scb );
                Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );
                NtfsReleaseFsrtlHeader( Scb );
            }
        }

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( NtfsFastLock );

        //
        //  Release the Fcb, and return to our caller
        //

        if (ResourceAcquired) {
            ExReleaseResourceLite( Fcb->Resource );
        }

        FsRtlExitFileSystem();

        DebugTrace( -1, Dbg, ("NtfsFastLock -> %08lx\n", Results) );
    }

    return Results;
}


BOOLEAN
NtfsFastUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast unlock single call.

Arguments:

    FileObject - Supplies the file object used in this operation

    FileOffset - Supplies the file offset used in this operation

    Length - Supplies the length used in this operation

    ProcessId - Supplies the process ID used in this operation

    Key - Supplies the key used in this operation

    Status - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results;
    PFCB Fcb;
    PSCB Scb;
    BOOLEAN ResourceAcquired = FALSE;

    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFastUnlockSingle\n") );

    IoStatus->Information = 0;

    //
    //  Decode the type of file object we're being asked to process and
    //  make sure that is is only a user file open.
    //

    if ((Scb = NtfsFastDecodeUserFileOpen( FileObject )) == NULL) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;

        DebugTrace( -1, Dbg, ("NtfsFastUnlockSingle -> TRUE (STATUS_INVALID_PARAMETER)\n") );
        return TRUE;
    }

    Fcb = Scb->Fcb;

    //
    //  Acquire exclusive access to the Fcb this operation can always wait
    //

    FsRtlEnterFileSystem();

    if (Scb->ScbType.Data.FileLock == NULL) {

        (VOID) ExAcquireResourceExclusiveLite( Fcb->Resource, TRUE );
        ResourceAcquired = TRUE;

    } else {

        //(VOID) ExAcquireResourceSharedLite( Fcb->Resource, TRUE );
    }

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if ((Scb->ScbType.Data.Oplock != NULL) &&
            !FsRtlOplockIsFastIoPossible( &Scb->ScbType.Data.Oplock )) {

            try_return( Results = FALSE );
        }

        //
        //  If we don't have a file lock, then get one now.
        //

        if (Scb->ScbType.Data.FileLock == NULL
            && !NtfsCreateFileLock( Scb, FALSE )) {

            try_return( Results = FALSE );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request.  The call will always succeed.
        //

        Results = TRUE;
        IoStatus->Status = FsRtlFastUnlockSingle( Scb->ScbType.Data.FileLock,
                                                  FileObject,
                                                  FileOffset,
                                                  Length,
                                                  ProcessId,
                                                  Key,
                                                  NULL,
                                                  FALSE );

        //
        //  Set the flag indicating if Fast I/O is possible.  We are
        //  only concerned if there are no longer any filelocks on this
        //  file.
        //

        if (!FsRtlAreThereCurrentFileLocks( Scb->ScbType.Data.FileLock ) &&
            (Scb->Header.IsFastIoPossible != FastIoIsPossible)) {

            NtfsAcquireFsrtlHeader( Scb );
            Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );
            NtfsReleaseFsrtlHeader( Scb );
        }

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( NtfsFastUnlockSingle );

        //
        //  Release the Fcb, and return to our caller
        //

        if (ResourceAcquired) {
            ExReleaseResourceLite( Fcb->Resource );
        }

        FsRtlExitFileSystem();

        DebugTrace( -1, Dbg, ("NtfsFastUnlockSingle -> %08lx\n", Results) );
    }

    return Results;
}


BOOLEAN
NtfsFastUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast unlock all call.

Arguments:

    FileObject - Supplies the file object used in this operation

    ProcessId - Supplies the process ID used in this operation

    Status - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results;
    IRP_CONTEXT IrpContext;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFastUnlockAll\n") );

    IoStatus->Information = 0;

    //
    //  Decode the type of file object we're being asked to process and
    //  make sure that is is only a user file open.
    //

    TypeOfOpen = NtfsDecodeFileObject( &IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );

    if (TypeOfOpen != UserFileOpen) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;
        IoStatus->Information = 0;

        DebugTrace( -1, Dbg, ("NtfsFastUnlockAll -> TRUE (STATUS_INVALID_PARAMETER)\n") );
        return TRUE;
    }

    //
    //  Acquire exclusive access to the Fcb this operation can always wait
    //

    FsRtlEnterFileSystem();

    if (Scb->ScbType.Data.FileLock == NULL) {

        (VOID) ExAcquireResourceExclusiveLite( Fcb->Resource, TRUE );

    } else {

        (VOID) ExAcquireResourceSharedLite( Fcb->Resource, TRUE );
    }

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if (!FsRtlOplockIsFastIoPossible( &Scb->ScbType.Data.Oplock )) {

            try_return( Results = FALSE );
        }

        //
        //  If we don't have a file lock, then get one now.
        //

        if (Scb->ScbType.Data.FileLock == NULL
            && !NtfsCreateFileLock( Scb, FALSE )) {

            try_return( Results = FALSE );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request.  The call will always succeed.
        //

        Results = TRUE;
        IoStatus->Status = FsRtlFastUnlockAll( Scb->ScbType.Data.FileLock,
                                               FileObject,
                                               ProcessId,
                                               NULL );

        //
        //  Set the flag indicating if Fast I/O is possible
        //

        NtfsAcquireFsrtlHeader( Scb );
        Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );
        NtfsReleaseFsrtlHeader( Scb );

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( NtfsFastUnlockAll );

        //
        //  Release the Fcb, and return to our caller
        //

        ExReleaseResourceLite( Fcb->Resource );

        FsRtlExitFileSystem();

        DebugTrace( -1, Dbg, ("NtfsFastUnlockAll -> %08lx\n", Results) );
    }

    return Results;
}


BOOLEAN
NtfsFastUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast unlock all by key call.

Arguments:

    FileObject - Supplies the file object used in this operation

    ProcessId - Supplies the process ID used in this operation

    Key - Supplies the key used in this operation

    Status - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results;
    IRP_CONTEXT IrpContext;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFastUnlockAllByKey\n") );

    IoStatus->Information = 0;

    //
    //  Decode the type of file object we're being asked to process and
    //  make sure that is is only a user file open.
    //

    TypeOfOpen = NtfsDecodeFileObject( &IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );

    if (TypeOfOpen != UserFileOpen) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;
        IoStatus->Information = 0;

        DebugTrace( -1, Dbg, ("NtfsFastUnlockAllByKey -> TRUE (STATUS_INVALID_PARAMETER)\n") );
        return TRUE;
    }

    //
    //  Acquire exclusive access to the Fcb this operation can always wait
    //

    FsRtlEnterFileSystem();

    if (Scb->ScbType.Data.FileLock == NULL) {

        (VOID) ExAcquireResourceExclusiveLite( Fcb->Resource, TRUE );

    } else {

        (VOID) ExAcquireResourceSharedLite( Fcb->Resource, TRUE );
    }

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if (!FsRtlOplockIsFastIoPossible( &Scb->ScbType.Data.Oplock )) {

            try_return( Results = FALSE );
        }

        //
        //  If we don't have a file lock, then get one now.
        //

        if (Scb->ScbType.Data.FileLock == NULL
            && !NtfsCreateFileLock( Scb, FALSE )) {

            try_return( Results = FALSE );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request.  The call will always succeed.
        //

        Results = TRUE;
        IoStatus->Status = FsRtlFastUnlockAllByKey( Scb->ScbType.Data.FileLock,
                                                    FileObject,
                                                    ProcessId,
                                                    Key,
                                                    NULL );

        //
        //  Set the flag indicating if Fast I/O is possible
        //

        NtfsAcquireFsrtlHeader( Scb );
        Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );
        NtfsReleaseFsrtlHeader( Scb );

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( NtfsFastUnlockAllByKey );

        //
        //  Release the Fcb, and return to our caller
        //

        ExReleaseResourceLite( Fcb->Resource );

        FsRtlExitFileSystem();

        DebugTrace( -1, Dbg, ("NtfsFastUnlockAllByKey -> %08lx\n", Results) );
    }

    return Results;
}


NTSTATUS
NtfsCommonLockControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for Lock Control called by both the fsd and fsp
    threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    BOOLEAN FcbAcquired = FALSE;

    BOOLEAN OplockPostIrp;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    //
    //  Get a pointer to the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonLockControl\n") );
    DebugTrace( 0, Dbg, ("IrpContext    = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp           = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, ("MinorFunction = %08lx\n", IrpSp->MinorFunction) );

    //
    //  Extract and decode the type of file object we're being asked to process
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  If the file is not a user file open then we reject the request
    //  as an invalid parameter
    //

    if (TypeOfOpen != UserFileOpen) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace( -1, Dbg, ("NtfsCommonLockControl -> STATUS_INVALID_PARAMETER\n") );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Acquire exclusive access to the Fcb
    //

    if (Scb->ScbType.Data.FileLock == NULL) {

        NtfsAcquireExclusiveFcb( IrpContext, Fcb, Scb, 0 );
        FcbAcquired = TRUE;

    } else {

        //NtfsAcquireSharedFcb( IrpContext, Fcb, Scb );
    }

    OplockPostIrp = FALSE;

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //  This call might post the irp for us.
        //

        Status = FsRtlCheckOplock( &Scb->ScbType.Data.Oplock,
                                   Irp,
                                   IrpContext,
                                   NtfsOplockComplete,
                                   NtfsPrePostIrp );

        if (Status != STATUS_SUCCESS) {

            OplockPostIrp = TRUE;
            try_return( NOTHING );
        }

        //
        //  If we don't have a file lock, then get one now.
        //

        if (Scb->ScbType.Data.FileLock == NULL) {

            NtfsCreateFileLock( Scb, TRUE );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request
        //

        Status = FsRtlProcessFileLock( Scb->ScbType.Data.FileLock, Irp, NULL );

        //
        //  Set the flag indicating if Fast I/O is possible
        //

        NtfsAcquireFsrtlHeader( Scb );
        Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );
        NtfsReleaseFsrtlHeader( Scb );

    try_exit: NOTHING;
    } finally {

        DebugUnwind( NtfsCommonLockControl );

        //
        //  Only if this is not an abnormal termination and we did not post the irp
        //  do we delete the irp context
        //

        if (!OplockPostIrp) {

            //
            //  Release the Fcb.
            //
    
            if (FcbAcquired) { NtfsReleaseFcb( IrpContext, Fcb ); }

            if (!AbnormalTermination()) {

                NtfsCompleteRequest( IrpContext, NULL, 0 );
            }
        }

        DebugTrace( -1, Dbg, ("NtfsCommonLockControl -> %08lx\n", Status) );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\logsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    LogSup.c

Abstract:

    This module implements the Ntfs interfaces to the Log File Service (LFS).

Author:

    Tom Miller      [TomM]          24-Jul-1991

Revision History:

--*/

#include "NtfsProc.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_LOGSUP)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('LFtN')

#ifdef NTFSDBG

#define ASSERT_RESTART_TABLE(T) {                                           \
    PULONG _p = (PULONG)(((PCHAR)(T)) + sizeof(RESTART_TABLE));             \
    ULONG _Count = ((T)->EntrySize/4) * (T)->NumberEntries;                 \
    ULONG _i;                                                               \
    for (_i = 0; _i < _Count; _i += 1) {                                    \
        if (_p[_i] == 0xDAADF00D) {                                         \
            DbgPrint("DaadFood for table %08lx, At %08lx\n", (T), &_p[_i]); \
            ASSERTMSG("ASSERT_RESTART_TABLE ", FALSE);                      \
        }                                                                   \
    }                                                                       \
}

#else

#define ASSERT_RESTART_TABLE(T) {NOTHING;}

#endif

//
//  Local procedure prototypes
//

typedef LCN UNALIGNED *PLCN_UNALIGNED;

VOID
DirtyPageRoutine (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN PLSN OldestLsn,
    IN PLSN NewestLsn,
    IN PVOID Context1,
    IN PVOID Context2
    );

BOOLEAN
LookupLcns (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN VCN Vcn,
    IN ULONG ClusterCount,
    IN BOOLEAN MustBeAllocated,
    OUT PLCN_UNALIGNED FirstLcn
    );

LONG
NtfsCatchOutOfMemoryExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    );

LONG
NtfsCheckpointExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer,
    IN NTSTATUS ExceptionCode
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LookupLcns)
#pragma alloc_text(PAGE, NtfsCheckpointCurrentTransaction)
#pragma alloc_text(PAGE, NtfsCheckpointForLogFileFull)
#pragma alloc_text(PAGE, NtfsCheckpointVolume)
#pragma alloc_text(PAGE, NtfsCleanCheckpoint)
#pragma alloc_text(PAGE, NtfsCleanupFailedTransaction)
#pragma alloc_text(PAGE, NtfsCommitCurrentTransaction)
#pragma alloc_text(PAGE, NtfsFreeRecentlyDeallocated)
#pragma alloc_text(PAGE, NtfsFreeRestartTable)
#pragma alloc_text(PAGE, NtfsGetFirstRestartTable)
#pragma alloc_text(PAGE, NtfsGetNextRestartTable)
#pragma alloc_text(PAGE, NtfsInitializeLogging)
#pragma alloc_text(PAGE, NtfsInitializeRestartTable)
#pragma alloc_text(PAGE, NtfsStartLogFile)
#pragma alloc_text(PAGE, NtfsStopLogFile)
#pragma alloc_text(PAGE, NtfsUpdateOatVersion)
#pragma alloc_text(PAGE, NtfsWriteLog)
#endif


LSN
NtfsWriteLog (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PBCB Bcb OPTIONAL,
    IN NTFS_LOG_OPERATION RedoOperation,
    IN PVOID RedoBuffer OPTIONAL,
    IN ULONG RedoLength,
    IN NTFS_LOG_OPERATION UndoOperation,
    IN PVOID UndoBuffer OPTIONAL,
    IN ULONG UndoLength,
    IN LONGLONG StreamOffset,
    IN ULONG RecordOffset,
    IN ULONG AttributeOffset,
    IN ULONG StructureSize
    )

/*++

Routine Description:

    This routine implements an Ntfs-specific interface to LFS for the
    purpose of logging updates to file record segments and resident
    attributes.

    The caller creates one of the predefined log record formats as
    determined by the given LogOperation, and calls this routine with
    this log record and pointers to the respective file and attribute
    records.  The list of log operations along with the respective structure
    expected for the Log Buffer is present in ntfslog.h.

Arguments:

    Scb - Pointer to the Scb for the respective file or Mft.  The caller must
          have at least shared access to this Scb.

    Bcb - If specified, this Bcb will be set dirty specifying the Lsn of
          the log record written.

    RedoOperation - One of the log operation codes defined in ntfslog.h.

    RedoBuffer - A pointer to the structure expected for the given Redo operation,
                 as summarized in ntfslog.h.  This pointer should only be
                 omitted if and only if the table in ntfslog.h does not show
                 a log record for this log operation.

    RedoLength - Length of the Redo buffer in bytes.

    UndoOperation - One of the log operation codes defined in ntfslog.h.

                    Must be CompensationLogRecord if logging the Undo of
                    a previous operation, such as during transaction abort.
                    In this case, of course, the Redo information is from
                    the Undo information of the record being undone.  See
                    next parameter.

    UndoBuffer - A pointer to the structure expected for the given Undo operation,
                 as summarized in ntfslog.h.  This pointer should only be
                 omitted if and only if the table in ntfslog.h does not show
                 a log record for this log operation.  If this pointer is
                 identical to RedoBuffer, then UndoLength is ignored and
                 only a single copy of the RedoBuffer is made, but described
                 by both the Redo and Undo portions of the log record.

                 For a compensation log record (UndoOperation ==
                 CompensationLogRecord), this argument must point to the
                 UndoNextLsn of the log record being compensated.

    UndoLength - Length of the Undo buffer in bytes.  Ignored if RedoBuffer ==
                 UndoBuffer.

                 For a compensation log record, this argument must be the length
                 of the original redo record.  (Used during restart).

    StreamOffset - Offset within the stream for the start of the structure being
                   modified (Mft or Index), or simply the stream offset for the start
                   of the update.

    RecordOffset - Byte offset from StreamOffset above to update reference

    AttributeOffset - Offset within a value to which an update applies, if relevant.

    StructureSize - Size of the entire structure being logged.

Return Value:

    The Lsn of the log record written.  For most callers, this status may be ignored,
    because the Lsn is also correctly recorded in the transaction context.

    If an error occurs this procedure will raise.

--*/

{
    LFS_WRITE_ENTRY WriteEntries[3];

    struct {

        NTFS_LOG_RECORD_HEADER LogRecordHeader;
        LCN Runs[PAGE_SIZE/512 - 1];

    } LocalHeader;

    PNTFS_LOG_RECORD_HEADER MyHeader;
    PVCB Vcb;

    LSN UndoNextLsn;
    LSN ReturnLsn;
    PLSN DirtyLsn = NULL;

    ULONG WriteIndex = 0;
    ULONG UndoIndex = 0;
    ULONG RedoIndex = 0;
    LONG UndoBytes = 0;
    LONG UndoAdjustmentForLfs = 0;
    LONG UndoRecords = 0;

    PTRANSACTION_ENTRY TransactionEntry;
    ULONG OpenAttributeIndex = 0;
    ULONG OnDiskAttributeIndex = 0;
    POPEN_ATTRIBUTE_DATA AttributeData = NULL;
    BOOLEAN AttributeTableAcquired = FALSE;
    BOOLEAN TransactionTableAcquired = FALSE;

    ULONG LogClusterCount = ClustersFromBytes( Scb->Vcb, StructureSize );
    VCN LogVcn = LlClustersFromBytesTruncate( Scb->Vcb, StreamOffset );

    PAGED_CODE();

    Vcb = Scb->Vcb;

    //
    //  If the log handle is gone, then we noop this call.
    //

    if (!FlagOn( Vcb->VcbState, VCB_STATE_VALID_LOG_HANDLE )) {

        return Li0; //**** LfsZeroLsn;
    }

    if (FlagOn( Vcb->VcbState, VCB_STATE_MOUNT_READ_ONLY )) {

        //
        //  We'd like to have a chat with whoever sent the log write.
        //

        ASSERT(!FlagOn( Vcb->VcbState, VCB_STATE_MOUNT_READ_ONLY ));
        return Li0;
    }

    DebugTrace( +1, Dbg, ("NtfsWriteLog:\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("Bcb = %08lx\n", Bcb) );
    DebugTrace( 0, Dbg, ("RedoOperation = %08lx\n", RedoOperation) );
    DebugTrace( 0, Dbg, ("RedoBuffer = %08lx\n", RedoBuffer) );
    DebugTrace( 0, Dbg, ("RedoLength = %08lx\n", RedoLength) );
    DebugTrace( 0, Dbg, ("UndoOperation = %08lx\n", UndoOperation) );
    DebugTrace( 0, Dbg, ("UndoBuffer = %08lx\n", UndoBuffer) );
    DebugTrace( 0, Dbg, ("UndoLength = %08lx\n", UndoLength) );
    DebugTrace( 0, Dbg, ("StreamOffset = %016I64x\n", StreamOffset) );
    DebugTrace( 0, Dbg, ("RecordOffset = %08lx\n", RecordOffset) );
    DebugTrace( 0, Dbg, ("AttributeOffset = %08lx\n", AttributeOffset) );
    DebugTrace( 0, Dbg, ("StructureSize = %08lx\n", StructureSize) );

    //
    //  Check Redo and Undo lengths
    //

    ASSERT(((RedoOperation == UpdateNonresidentValue) && (RedoLength <= PAGE_SIZE))

            ||

           !ARGUMENT_PRESENT(Scb)

            ||

           !ARGUMENT_PRESENT(Bcb)

            ||

           ((Scb->AttributeTypeCode == $INDEX_ALLOCATION) &&
            (RedoLength <= Scb->ScbType.Index.BytesPerIndexBuffer))

            ||

           (RedoLength <= Scb->Vcb->BytesPerFileRecordSegment));

    ASSERT(((UndoOperation == UpdateNonresidentValue) && (UndoLength <= PAGE_SIZE))

            ||

           !ARGUMENT_PRESENT(Scb)

            ||

           !ARGUMENT_PRESENT(Bcb)

            ||

           ((Scb->AttributeTypeCode == $INDEX_ALLOCATION) &&
            (UndoLength <= Scb->ScbType.Index.BytesPerIndexBuffer))

            ||

           (UndoLength <= Scb->Vcb->BytesPerFileRecordSegment)

            ||

           (UndoOperation == CompensationLogRecord));

    //
    //  Initialize local pointers.
    //

    MyHeader = (PNTFS_LOG_RECORD_HEADER)&LocalHeader;

    try {

        //
        //  If the structure size is nonzero, then create an open attribute table
        //  entry.
        //

        if (StructureSize != 0) {

            //
            //  Allocate an entry in the open attribute table and initialize it,
            //  if it does not already exist.  If we subsequently fail, we do
            //  not have to clean this up.  It will go away on the next checkpoint.
            //

            if (Scb->NonpagedScb->OpenAttributeTableIndex == 0) {

                OPEN_ATTRIBUTE_ENTRY_V0 LocalOpenEntry;
                POPEN_ATTRIBUTE_ENTRY OpenAttributeEntry;
                POPEN_ATTRIBUTE_ENTRY_V0 OnDiskAttributeEntry;
                ULONG EntrySize;

                ASSERT( sizeof( OPEN_ATTRIBUTE_ENTRY_V0 ) >= sizeof( OPEN_ATTRIBUTE_ENTRY ));

                NtfsAcquireExclusiveRestartTable( &Vcb->OpenAttributeTable, TRUE );
                AttributeTableAcquired = TRUE;

                //
                //  Only proceed if the OpenAttributeTableIndex is still 0.
                //  We may reach this point for the MftScb.  It may not be
                //  acquired when logging changes to file records.  We will
                //  use the OpenAttributeTable for final synchronization
                //  for the Mft open attribute table entry.
                //

                if (Scb->NonpagedScb->OpenAttributeTableIndex == 0) {

                    //
                    //  Our structures require tables to stay within 64KB, since
                    //  we use USHORT offsets.  Things are getting out of hand
                    //  at this point anyway.  Raise log file full to reset the
                    //  table sizes if we get to this point.
                    //

                    if (SizeOfRestartTable( Vcb->OnDiskOat ) > 0xF000) {
                        NtfsRaiseStatus( IrpContext, STATUS_LOG_FILE_FULL, NULL, NULL );
                    }

                    //
                    //  Allocate the indexes and then the Attribute data structure.  The
                    //  try-finally will handle any failures.
                    //

                    OpenAttributeIndex = NtfsAllocateRestartTableIndex( &Vcb->OpenAttributeTable, TRUE );
                    AttributeData = NtfsAllocatePool( PagedPool, sizeof( OPEN_ATTRIBUTE_DATA ) );
                    OpenAttributeEntry = GetRestartEntryFromIndex( &Vcb->OpenAttributeTable,
                                                                   OpenAttributeIndex );

                    //
                    //  Initialize the entry and auxiliary data.
                    //

                    if (Scb->AttributeTypeCode == $INDEX_ALLOCATION) {

                        OpenAttributeEntry->BytesPerIndexBuffer = Scb->ScbType.Index.BytesPerIndexBuffer;

                    } else {

                        OpenAttributeEntry->BytesPerIndexBuffer = 0;
                    }

                    //
                    //  Its good enough to use the last lsn for the lsnofopenrecord
                    //  since we're serialized on create attributes within a file
                    //

                    OpenAttributeEntry->AttributeTypeCode = Scb->AttributeTypeCode;
                    OpenAttributeEntry->FileReference = Scb->Fcb->FileReference;
                    OpenAttributeEntry->LsnOfOpenRecord = LfsQueryLastLsn( Vcb->LogHandle );

                    AttributeData->Overlay.Scb = Scb;
                    AttributeData->AttributeName = Scb->AttributeName;
                    AttributeData->AttributeNamePresent = FALSE;

                    //
                    //  Use the open attribute entry as the default table entry.
                    //

                    Scb->NonpagedScb->OnDiskOatIndex = OpenAttributeIndex;

                    //
                    //  If the on-disk structure is needed then get it now.
                    //

                    if (Vcb->RestartVersion == 0) {

                        OnDiskAttributeIndex = NtfsAllocateRestartTableIndex( Vcb->OnDiskOat, TRUE );
                        OnDiskAttributeEntry = GetRestartEntryFromIndex( Vcb->OnDiskOat,
                                                                         OnDiskAttributeIndex );

                        OnDiskAttributeEntry->OatIndex = OpenAttributeIndex;
                        OnDiskAttributeEntry->FileReference = Scb->Fcb->FileReference;
                        OnDiskAttributeEntry->LsnOfOpenRecord.QuadPart = 0;
                        OnDiskAttributeEntry->AttributeTypeCode = Scb->AttributeTypeCode;
                        OnDiskAttributeEntry->BytesPerIndexBuffer = OpenAttributeEntry->BytesPerIndexBuffer;
                        OnDiskAttributeEntry->LsnOfOpenRecord.QuadPart = OpenAttributeEntry->LsnOfOpenRecord.QuadPart;

                        //
                        //  Use this new index.
                        //

                        Scb->NonpagedScb->OnDiskOatIndex = OnDiskAttributeIndex;

                    //
                    //  We need to log this so store a copy in our local.
                    //

                    } else {

                        OnDiskAttributeIndex = OpenAttributeIndex;
                    }

                    //
                    //  Now store the table indexes.
                    //

                    AttributeData->OnDiskAttributeIndex = OnDiskAttributeIndex;
                    Scb->NonpagedScb->OpenAttributeTableIndex = OpenAttributeIndex;

                    //
                    //  Now connect the attribute data to the table entry and the Vcb.
                    //

                    OpenAttributeEntry->OatData = AttributeData;
                    InsertTailList( &Vcb->OpenAttributeData, &AttributeData->Links );

                    RtlCopyMemory( &LocalOpenEntry,
                                   GetRestartEntryFromIndex( Vcb->OnDiskOat, OnDiskAttributeIndex ),
                                   EntrySize = Vcb->OnDiskOat->Table->EntrySize );

                    NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );
                    AttributeTableAcquired = FALSE;
                    OpenAttributeIndex = 0;

                    //
                    //  Now log the new open attribute table entry before goin on,
                    //  to insure that the application of the caller's log record
                    //  will have the information he needs on the attribute.  We will
                    //  use the Undo buffer to convey the attribute name.  We will
                    //  not infinitely recurse, because now this Scb already has an
                    //  open attribute table index.
                    //

                    NtfsWriteLog( IrpContext,
                                  Scb,
                                  NULL,
                                  OpenNonresidentAttribute,
                                  &LocalOpenEntry,
                                  EntrySize,
                                  Noop,
                                  Scb->AttributeName.Length != 0 ?
                                    Scb->AttributeName.Buffer : NULL,
                                  Scb->AttributeName.Length,
                                  (LONGLONG)0,
                                  0,
                                  0,
                                  0 );

                } else {

                    NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );
                    AttributeTableAcquired = FALSE;
                }
            }
        }

        //
        //  Allocate a transaction ID and initialize it, if it does not already exist.
        //  If we subsequently fail, we clean it up when the current request is
        //  completed.
        //

        if (IrpContext->TransactionId == 0) {

            NtfsAcquireExclusiveRestartTable( &Vcb->TransactionTable, TRUE );
            TransactionTableAcquired = TRUE;

            //
            //  Our structures require tables to stay within 64KB, since
            //  we use USHORT offsets.  Things are getting out of hand
            //  at this point anyway.  Raise log file full to reset the
            //  table sizes if we get to this point.
            //

            if (SizeOfRestartTable(&Vcb->TransactionTable) > 0xF000) {
                NtfsRaiseStatus( IrpContext, STATUS_LOG_FILE_FULL, NULL, NULL );
            }

            IrpContext->TransactionId =
              NtfsAllocateRestartTableIndex( &Vcb->TransactionTable, TRUE );

            ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WROTE_LOG );

            TransactionEntry = (PTRANSACTION_ENTRY)GetRestartEntryFromIndex(
                                &Vcb->TransactionTable,
                                IrpContext->TransactionId );
            TransactionEntry->TransactionState = TransactionActive;
            TransactionEntry->FirstLsn =
            TransactionEntry->PreviousLsn =
            TransactionEntry->UndoNextLsn = Li0; //**** LfsZeroLsn;

            //
            //  Remember that we will need a commit record even if we abort
            //  the transaction.
            //

            TransactionEntry->UndoBytes = QuadAlign( sizeof( NTFS_LOG_RECORD_HEADER ));
            TransactionEntry->UndoRecords = 1;

            NtfsReleaseRestartTable( &Vcb->TransactionTable );
            TransactionTableAcquired = FALSE;

            //
            //  Remember the space for the commit record in our Lfs adjustment.
            //

            UndoAdjustmentForLfs += QuadAlign( sizeof( NTFS_LOG_RECORD_HEADER ));

            //
            //  If there is an undo operation for this log record, we reserve
            //  the space for another Lfs log record.
            //

            if (UndoOperation != Noop) {
                UndoAdjustmentForLfs += Vcb->LogHeaderReservation;
            }
        }

        //
        //  At least for now, assume update is contained in one physical page.
        //

        //ASSERT( (StructureSize == 0) || (StructureSize <= PAGE_SIZE) );

        //
        //  If there isn't enough room for this structure on the stack, we
        //  need to allocate an auxilary buffer.
        //

        if (LogClusterCount > (PAGE_SIZE / 512)) {

            MyHeader = (PNTFS_LOG_RECORD_HEADER)
                       NtfsAllocatePool(PagedPool, sizeof( NTFS_LOG_RECORD_HEADER )
                                              + (LogClusterCount - 1) * sizeof( LCN ));

        }

        //
        //  Now fill in the WriteEntries array and the log record header.
        //

        WriteEntries[0].Buffer = (PVOID)MyHeader;
        WriteEntries[0].ByteLength = sizeof(NTFS_LOG_RECORD_HEADER);
        WriteIndex += 1;

        //
        //  Lookup the Runs for this log record
        //

        MyHeader->LcnsToFollow = (USHORT)LogClusterCount;

        if (LogClusterCount != 0) {

            if (!LookupLcns( IrpContext,
                             Scb,
                             LogVcn,
                             LogClusterCount,
                             TRUE,
                             &MyHeader->LcnsForPage[0] )) {

                //
                //  It is possible that the allocation for this range is not allocated.
                //  This may happen in cases where a stream which descibes itself is
                //  being hotfixed (perhaps MoveFile in a later release).  In the
                //  hotfix case we will not write this log record.  Hotfix will mark
                //  the volume dirty so we know that the system will verify the volume
                //  at some point.
                //

                ASSERT( NtfsGetTopLevelHotFixScb() != NULL );

                //
                //  Cleanup the transaction entry if allocated here.
                //

                if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WROTE_LOG ) &&
                    (IrpContext->TransactionId != 0)) {

                    NtfsCleanupFailedTransaction( IrpContext );
                }

                ReturnLsn = LfsQueryLastLsn( Vcb->LogHandle );
                DirtyLsn = &ReturnLsn;
                leave;
            }

            WriteEntries[0].ByteLength += (LogClusterCount - 1) * sizeof(LCN);
        }

        //
        //  If there is a Redo buffer, fill in its write entry.
        //

        if (RedoLength != 0) {

            WriteEntries[1].Buffer = RedoBuffer;
            WriteEntries[1].ByteLength = RedoLength;
            UndoIndex = RedoIndex = WriteIndex;
            WriteIndex += 1;
        }

        //
        //  If there is an undo buffer, and it is at a different address than
        //  the redo buffer, then fill in its write entry.
        //

        if ((RedoBuffer != UndoBuffer) && (UndoLength != 0) &&
            (UndoOperation != CompensationLogRecord)) {

            WriteEntries[WriteIndex].Buffer = UndoBuffer;
            WriteEntries[WriteIndex].ByteLength = UndoLength;
            UndoIndex = WriteIndex;
            WriteIndex += 1;
        }

        //
        //  Now fill in the rest of the header.  Assume Redo and Undo buffer is
        //  the same, then fix them up if they are not.
        //

        MyHeader->RedoOperation = (USHORT)RedoOperation;
        MyHeader->UndoOperation = (USHORT)UndoOperation;
        MyHeader->RedoOffset = (USHORT)WriteEntries[0].ByteLength;
        MyHeader->RedoLength = (USHORT)RedoLength;
        MyHeader->UndoOffset = MyHeader->RedoOffset;
        if (RedoBuffer != UndoBuffer) {
            MyHeader->UndoOffset += (USHORT)QuadAlign(MyHeader->RedoLength);
        }
        MyHeader->UndoLength = (USHORT)UndoLength;

        MyHeader->TargetAttribute = (USHORT)Scb->NonpagedScb->OnDiskOatIndex;
        MyHeader->RecordOffset = (USHORT)RecordOffset;
        MyHeader->AttributeOffset = (USHORT)AttributeOffset;
        MyHeader->Reserved = 0;

        MyHeader->TargetVcn = LogVcn;
        MyHeader->ClusterBlockOffset = (USHORT) LogBlocksFromBytesTruncate( ClusterOffset( Vcb, StreamOffset ));

        //
        //  Finally, get our current transaction entry and call Lfs.  We acquire
        //  the transaction table exclusive both to synchronize the Lsn updates
        //  on return from Lfs, and also to mark the Bcb dirty before any more
        //  log records are written.
        //
        //  If we do not do serialize the LfsWrite and CcSetDirtyPinnedData, here is
        //  what can happen:
        //
        //      We log an update for a page and get an Lsn back
        //
        //          Another thread writes a start of checkpoint record
        //          This thread then collects all of the dirty pages at that time
        //          Sometime it writes the dirty page table
        //
        //      The former thread which had been preempted, now sets the Bcb dirty
        //
        //  If we crash at this time, the page we updated is not in the dirty page
        //  table of the checkpoint, and it its update record is also not seen since
        //  it was written before the start of the checkpoint!
        //
        //  Note however, since the page being updated is pinned and cannot be written,
        //  updating the Lsn in the page may simply be considered part of the update.
        //  Whoever is doing this update (to the Mft or an Index buffer), must have the
        //  Mft or Index acquired exclusive anyway.
        //

        NtfsAcquireSharedStartExRestartTable( &Vcb->TransactionTable, TRUE );
        TransactionTableAcquired = TRUE;

        TransactionEntry = (PTRANSACTION_ENTRY)GetRestartEntryFromIndex(
                            &Vcb->TransactionTable,
                            IrpContext->TransactionId );

        //
        //  Set up the UndoNextLsn.  If this is a normal log record, then use
        //  the UndoNextLsn stored in the transaction entry; otherwise, use
        //  the one passed in as the Undo buffer.
        //

        if (UndoOperation != CompensationLogRecord) {

            UndoNextLsn = TransactionEntry->UndoNextLsn;

            //
            //  If there is undo information, calculate the number to pass to Lfs
            //  for undo bytes to reserve.
            //

            if (UndoOperation != Noop) {

                UndoBytes += QuadAlign(WriteEntries[0].ByteLength);

                if (UndoIndex != 0) {

                    UndoBytes += QuadAlign(WriteEntries[UndoIndex].ByteLength);
                }

                UndoRecords += 1;
            }

        } else {

            UndoNextLsn = *(PLSN)UndoBuffer;

            //
            //  We can reduce our Undo requirements, by the Redo data being
            //  logged.  This is either an abort record for a previous action
            //  or a commit record.  If it is a commit record we accounted
            //  for it above on the first NtfsWriteLog, and NtfsCommitTransaction
            //  will adjust for the rest.
            //

            if (!FlagOn( Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS )) {

                UndoBytes -= QuadAlign(WriteEntries[0].ByteLength);

                if (RedoIndex != 0) {

                    UndoBytes -= QuadAlign(WriteEntries[RedoIndex].ByteLength);
                }

                UndoRecords -= 1;
            }
        }

#ifdef NTFS_LOG_FULL_TEST
        //
        //  Perform log-file-full fail checking.  We do not perform this check if
        //  we are writing an undo record (since we are guaranteed space to undo
        //  things).
        //

        if (UndoOperation != CompensationLogRecord &&
            (IrpContext->MajorFunction != IRP_MJ_FILE_SYSTEM_CONTROL ||
             IrpContext->MinorFunction != IRP_MN_MOUNT_VOLUME)) {

            LogFileFullFailCheck( IrpContext );

            if (NtfsFailFrequency != 0 &&
                (++NtfsPeriodicFail % NtfsFailFrequency) == 0) {

                ExRaiseStatus( STATUS_LOG_FILE_FULL );
            }
        }
#endif

        //
        //  Call Lfs to write the record.
        //

        LfsWrite( Vcb->LogHandle,
                  WriteIndex,
                  &WriteEntries[0],
                  LfsClientRecord,
                  &IrpContext->TransactionId,
                  UndoNextLsn,
                  TransactionEntry->PreviousLsn,
                  UndoBytes + UndoAdjustmentForLfs,
                  0,
                  &ReturnLsn );

        //
        //  Now that we are successful, update the transaction entry appropriately.
        //

        TransactionEntry->UndoBytes += UndoBytes;
        TransactionEntry->UndoRecords += UndoRecords;
        TransactionEntry->PreviousLsn = ReturnLsn;

        //
        //  The UndoNextLsn for the transaction depends on whether we are
        //  doing a compensation log record or not.
        //

        if (UndoOperation != CompensationLogRecord) {
            TransactionEntry->UndoNextLsn = ReturnLsn;
        } else {
            TransactionEntry->UndoNextLsn = UndoNextLsn;
        }

        //
        //  If this is the first Lsn, then we have to update that as
        //  well.
        //

        if (TransactionEntry->FirstLsn.QuadPart == 0) {

            TransactionEntry->FirstLsn = ReturnLsn;
        }

        //
        //  Set to use this Lsn when marking dirty below
        //

        DirtyLsn = &ReturnLsn;

        //
        //  Set the flag in the Irp Context which indicates we wrote
        //  a log record to disk.
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WROTE_LOG );

    } finally {

        DebugUnwind( NtfsWriteLog );

        //
        //  Now set the Bcb dirty if specified.  We want to set it no matter
        //  what happens, because our caller has modified the buffer and is
        //  counting on us to call the Cache Manager.
        //

        if (ARGUMENT_PRESENT( Bcb )) {

            TIMER_STATUS TimerStatus;

            CcSetDirtyPinnedData( Bcb, DirtyLsn );

            //
            //  Synchronize with the checkpoint timer and other instances of this routine.
            //
            //  Perform an interlocked exchange to indicate that a timer is being set.
            //
            //  If the previous value indicates that no timer was set, then we
            //  enable the volume checkpoint timer.  This will guarantee that a checkpoint
            //  will occur to flush out the dirty Bcb data.
            //
            //  If the timer was set previously, then it is guaranteed that a checkpoint
            //  will occur without this routine having to reenable the timer.
            //
            //  If the timer and checkpoint occurred between the dirtying of the Bcb and
            //  the setting of the timer status, then we will be queueing a single extra
            //  checkpoint on a clean volume.  This is not considered harmful.
            //

            //
            //  Atomically set the timer status to indicate a timer is being set and
            //  retrieve the previous value.
            //

            TimerStatus = InterlockedExchange( (PLONG)&NtfsData.TimerStatus, TIMER_SET );

            //
            //  If the timer is not currently set then we must start the checkpoint timer
            //  to make sure the above dirtying is flushed out.
            //

            if (TimerStatus == TIMER_NOT_SET) {

                LONGLONG FiveSecondsFromNow = -5*1000*1000*10;

                KeSetTimer( &NtfsData.VolumeCheckpointTimer,
                            *(PLARGE_INTEGER)&FiveSecondsFromNow,
                            &NtfsData.VolumeCheckpointDpc );
            }
        }

        if (TransactionTableAcquired) {
            NtfsReleaseRestartTable( &Vcb->TransactionTable );
        }

        //
        //  Lets cleanup any failed attempt to allocate an attribute entry.
        //  We only need to check the OpenAttributeIndex if the operation
        //  was successful.
        //

        if (OpenAttributeIndex != 0) {

            NtfsFreeRestartTableIndex( &Vcb->OpenAttributeTable, OpenAttributeIndex );

            if (AttributeData != NULL) {

                NtfsFreePool( AttributeData );
            }

            if (OnDiskAttributeIndex != 0) {

                NtfsFreeRestartTableIndex( Vcb->OnDiskOat, OnDiskAttributeIndex );
            }
        }

        if (AttributeTableAcquired) {
            NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );
        }

        if (MyHeader != (PNTFS_LOG_RECORD_HEADER)&LocalHeader) {

            NtfsFreePool( MyHeader );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsWriteLog -> %016I64x\n", ReturnLsn ) );

    return ReturnLsn;
}


VOID
NtfsCheckpointVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN OwnsCheckpoint,
    IN BOOLEAN CleanVolume,
    IN BOOLEAN FlushVolume,
    IN ULONG LfsFlags,
    IN LSN LastKnownLsn
    )

/*++

Routine Description:

    This routine is called periodically to perform a checkpoint on the volume
    with respect to the log file.  The checkpoint dumps a bunch of log file
    state information to the log file, and finally writes a summary of the
    dumped information in its Restart Area.

    This checkpoint dumps the following:

        Open Attribute Table
        (all of the attribute names for the Attribute Table)
        Dirty Pages Table
        Transaction Table

Arguments:

    Vcb - Pointer to the Vcb on which the checkpoint is to occur.

    OwnsCheckpoint - TRUE if the caller has already taken steps to insure
        that he may proceed with the checkpointing.  In this case we
        don't do any checks for other checkpoints and don't clear the
        checkpoint flag or notify any waiting checkpoint threads.

    CleanVolume - TRUE if the caller wishes to clean the volume before doing
        the checkpoint, or FALSE for a normal periodic checkpoint.

    FlushVolume - Applies only if CleanVolume is TRUE.  This indicates if we should
        should flush the volume or only Lsn streams. Only the shutdown thread
        can do a clean and flush checkpoint and avoid deadlocks between
        pagingio and main resources.

    LfsFlags - flags to pass to lfs when writing the restart areas

    LastKnownLsn - Applies only if CleanVolume is TRUE.  Only perform the
        clean checkpoint if this value is the same as the last restart area
        in the Vcb.  This will prevent us from doing unecesary clean
        checkpoints.

Return Value:

    None

--*/

{
    RESTART_AREA RestartArea;
    RESTART_POINTERS DirtyPages;
    RESTART_POINTERS Pointers;
    PRESTART_POINTERS NewTable = NULL;
    LSN BaseLsn;
    PATTRIBUTE_NAME_ENTRY NamesBuffer = NULL;
    PTRANSACTION_ENTRY TransactionEntry;
    BOOLEAN DirtyPageTableInitialized = FALSE;
    BOOLEAN OpenAttributeTableAcquired = FALSE;
    BOOLEAN TransactionTableAcquired = FALSE;
    LSN OldestDirtyPageLsn = Li0;
    BOOLEAN AcquireFiles = FALSE;
    BOOLEAN PostDefrag = FALSE;
    KPRIORITY PreviousPriority;
    BOOLEAN RestorePreviousPriority = FALSE;
    PSCB UsnJournal = NULL;
    LOGICAL LfsCleanShutdown = 0;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCheckpointVolume:\n") );
    DebugTrace( 0, Dbg, ("Vcb = %08lx\n", Vcb) );

    //
    //  No checkpointing on readonly volumes.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        return;
    }

    if (!OwnsCheckpoint) {

        //
        //  Acquire the checkpoint event.
        //

        NtfsAcquireCheckpoint( IrpContext, Vcb );

        //
        //  We will want to post a defrag if defragging is permitted and enabled
        //  and we have begun the defrag operation or have excess mapping.
        //  If the defrag hasn't been triggered then check the Mft free
        //  space.  We can skip defragging if a defrag operation is
        //  currently active.
        //

        if (!CleanVolume &&
            (FlagOn( Vcb->MftDefragState,
                     VCB_MFT_DEFRAG_PERMITTED | VCB_MFT_DEFRAG_ENABLED | VCB_MFT_DEFRAG_ACTIVE ) ==
                (VCB_MFT_DEFRAG_PERMITTED | VCB_MFT_DEFRAG_ENABLED))) {

            if (FlagOn( Vcb->MftDefragState,
                        VCB_MFT_DEFRAG_TRIGGERED | VCB_MFT_DEFRAG_EXCESS_MAP )) {

                PostDefrag = TRUE;

            } else {

                NtfsCheckForDefrag( Vcb );

                if (FlagOn( Vcb->MftDefragState, VCB_MFT_DEFRAG_TRIGGERED )) {

                    PostDefrag = TRUE;

                } else {

                    ClearFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_ENABLED );
                }
            }
        }

        //
        //  If a checkpoint is already active, we either have to get out,
        //  or wait for it.
        //

        while (FlagOn( Vcb->CheckpointFlags, VCB_CHECKPOINT_SYNC_FLAGS )) {

            //
            //  Release the checkpoint event because we cannot checkpoint now.
            //

            NtfsReleaseCheckpoint( IrpContext, Vcb );

            if (CleanVolume) {

                NtfsWaitOnCheckpointNotify( IrpContext, Vcb );

                NtfsAcquireCheckpoint( IrpContext, Vcb );

            } else {

                return;
            }
        }

        //
        //  If the log file is gone then simply exit.
        //

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VALID_LOG_HANDLE )) {

            NtfsReleaseCheckpoint( IrpContext, Vcb );
            return;
        }

        //
        //  We now have the checkpoint event.  Check if there is still
        //  a need to perform the checkpoint.
        //

        if (CleanVolume &&
            (LastKnownLsn.QuadPart != Vcb->LastRestartArea.QuadPart)) {

            NtfsReleaseCheckpoint( IrpContext, Vcb );
            return;
        }

        SetFlag( Vcb->CheckpointFlags, VCB_CHECKPOINT_SYNC_FLAGS );
        NtfsResetCheckpointNotify( IrpContext, Vcb );
        NtfsReleaseCheckpoint( IrpContext, Vcb );

        //
        //  If this is a clean volume checkpoint then boost the priority of
        //  this thread.
        //

        if (CleanVolume) {

            PreviousPriority = KeSetPriorityThread( (PKTHREAD)PsGetCurrentThread(),
                                                    LOW_REALTIME_PRIORITY );

            if (PreviousPriority != LOW_REALTIME_PRIORITY) {

                RestorePreviousPriority = TRUE;
            }
        }
    }

    RtlZeroMemory( &RestartArea, sizeof(RESTART_AREA) );
    RtlZeroMemory( &DirtyPages, sizeof(RESTART_POINTERS) );

    //
    //  Remember if our caller wants to tell Lfs that this is a
    //  clean shutdown.  We will use the combination of the OwnsCheckpoint and
    //  CleanCheckpoint flags.  This will cover system shutdown and volume
    //  snapshot cases.  Both of these want the volume not to need any restart.
    //

    if (OwnsCheckpoint && CleanVolume) {

        LfsCleanShutdown = TRUE;
    }

    //
    //  Insure cleanup on the way out
    //

    try {

        POPEN_ATTRIBUTE_ENTRY AttributeEntry;
        ULONG NameBytes = 0;

        //
        //  Now remember the current "last Lsn" value as the start of
        //  our checkpoint.  We acquire the transaction table to capture
        //  this value to synchronize with threads who are writing log
        //  records and setting pages dirty as atomic actions.
        //

        ASSERT( IrpContext->TransactionId == 0 );

        NtfsAcquireExclusiveRestartTable( &Vcb->TransactionTable, TRUE );

        //
        //  If LfsFlags == LFS_WRITE_FLAG_WRITE_AT_FRONT then produce
        //  the dummy log record that resets the log. This allows us to
        //  keep the log in use only at the front so chkdsk can shrink it
        //

        if (FlagOn( LfsFlags, LFS_WRITE_FLAG_WRITE_AT_FRONT )) {
            LSN Lsn;
            LFS_WRITE_ENTRY WriteEntry;
            UCHAR Buffer[ sizeof( NTFS_LOG_RECORD_HEADER ) + 2 * sizeof( LSN )];
            TRANSACTION_ID TransactionId;

            RtlZeroMemory( &Buffer, sizeof( Buffer ) );

            WriteEntry.Buffer = Buffer;
            WriteEntry.ByteLength = sizeof( Buffer );

            TransactionId = NtfsAllocateRestartTableIndex( &Vcb->TransactionTable, TRUE );
            Lsn.QuadPart = 0;

            LfsGetActiveLsnRange( Vcb->LogHandle,
                                  Add2Ptr( Buffer, sizeof( NTFS_LOG_RECORD_HEADER )),
                                  Add2Ptr( Buffer, sizeof( NTFS_LOG_RECORD_HEADER ) + sizeof( LSN )) );

            LfsWrite( Vcb->LogHandle,
                      1,
                      &WriteEntry,
                      LfsClientRecord,
                      &TransactionId,
                      Lsn,
                      Lsn,
                      0,
                      LfsFlags,
                      &Lsn );

            NtfsFreeRestartTableIndex( &Vcb->TransactionTable, TransactionId );
        }

        BaseLsn =
        RestartArea.StartOfCheckpoint = LfsQueryLastLsn( Vcb->LogHandle );
        NtfsReleaseRestartTable( &Vcb->TransactionTable );

        //  ASSERT( (RestartArea.StartOfCheckpoint.QuadPart != 0) ||
        //          FlagOn(Vcb->CheckpointFlags, VCB_LAST_CHECKPOINT_CLEAN) );

        //
        //  If the last checkpoint was completely clean, and no one has
        //  written to the log since then, we can just return.
        //

        if (FlagOn( Vcb->CheckpointFlags, VCB_LAST_CHECKPOINT_CLEAN )

                &&

            (RestartArea.StartOfCheckpoint.QuadPart == Vcb->EndOfLastCheckpoint.QuadPart)

                &&

            !CleanVolume) {

            //
            //  Let's take this opportunity to shrink the Open Attribute and Transaction
            //  table back if they have gotten large.
            //

            //
            //  First the Open Attribute Table
            //

            NtfsAcquireExclusiveRestartTable( &Vcb->OpenAttributeTable, TRUE );
            OpenAttributeTableAcquired = TRUE;

            if (IsRestartTableEmpty(&Vcb->OpenAttributeTable)

                    &&

                (Vcb->OpenAttributeTable.Table->NumberEntries >
                 HIGHWATER_ATTRIBUTE_COUNT)) {

                //
                //  Initialize first in case we get an allocation failure.
                //

                InitializeNewTable( sizeof( OPEN_ATTRIBUTE_ENTRY ),
                                    INITIAL_NUMBER_ATTRIBUTES,
                                    &Pointers );

                NtfsFreePool( Vcb->OpenAttributeTable.Table );
                Vcb->OpenAttributeTable.Table = Pointers.Table;

                //
                //  Also reinitialize the OnDisk table if different.
                //

                if (Vcb->OnDiskOat != &Vcb->OpenAttributeTable) {

                    //
                    //  Initialize first in case we get an allocation failure.
                    //

                    InitializeNewTable( sizeof( OPEN_ATTRIBUTE_ENTRY_V0 ),
                                        INITIAL_NUMBER_ATTRIBUTES,
                                        &Pointers );

                    NtfsFreePool( Vcb->OnDiskOat->Table );
                    Vcb->OnDiskOat->Table = Pointers.Table;
                }
            }

            NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );
            OpenAttributeTableAcquired = FALSE;

            //
            //  Now check the transaction table (freeing in the finally clause).
            //

            NtfsAcquireExclusiveRestartTable( &Vcb->TransactionTable, TRUE );
            TransactionTableAcquired = TRUE;

            if (IsRestartTableEmpty(&Vcb->TransactionTable)

                    &&

                (Vcb->TransactionTable.Table->NumberEntries >
                 HIGHWATER_TRANSACTION_COUNT)) {

                //
                //  Initialize first in case we get an allocation failure.
                //

                InitializeNewTable( sizeof(TRANSACTION_ENTRY),
                                    INITIAL_NUMBER_TRANSACTIONS,
                                    &Pointers );

                NtfsFreePool( Vcb->TransactionTable.Table );
                Vcb->TransactionTable.Table = Pointers.Table;
            }

            try_return( NOTHING );
        }

        //
        //  Flush any dangling dirty pages from before the last restart.
        //  Note that it is arbitrary what Lsn we flush to here, and, in fact,
        //  it is not absolutely required that we flush anywhere at all - we
        //  could actually rely on the Lazy Writer.  All we are trying to do
        //  is reduce the amount of work that we will have to do at Restart,
        //  by not forcing ourselves to have to go too far back in the log.
        //  Presumably this can only happen for some reason the system is
        //  starting to produce dirty pages faster than the lazy writer is
        //  writing them.
        //
        //  (We may wish to play with taking this call out...)
        //
        //  This may be an appropriate place to worry about this, but, then
        //  again, the Lazy Writer is using (currently) five threads.  It may
        //  not be appropriate to hold up this one thread doing the checkpoint
        //  if the Lazy Writer is getting behind.  How many dirty pages we
        //  can even have is limited by the size of memory, so if the log file
        //  is large enough, this may not be an issue.  It seems kind of nice
        //  to just let the Lazy Writer keep writing dirty pages as he does
        //  now.
        //
        //  if (!FlagOn(Vcb->VcbState, VCB_STATE_LAST_CHECKPOINT_CLEAN)) {
        //      CcFlushPagesToLsn( Vcb->LogHandle, &Vcb->LastRestartArea );
        //  }
        //

        //
        //  Now we must clean the volume here if that is what the caller wants.
        //

        if (CleanVolume) {

            NtfsCleanCheckpoints += 1;

            //
            //  Lock down the volume if this is a clean checkpoint.
            //

            NtfsAcquireAllFiles( IrpContext, Vcb, FlushVolume, FALSE, FALSE );

#ifdef NTFSDBG
            ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_CHECKPOINT_ACTIVE ));
            DebugDoit( SetFlag( IrpContext->State, IRP_CONTEXT_STATE_CHECKPOINT_ACTIVE ));
#endif  //  NTFSDBG


            AcquireFiles = TRUE;

            //
            //  Mark the fact that we are doing a clean checkpoint at this time.
            //

            Vcb->CleanCheckpointMark = Vcb->LogFileFullCount;

            //
            //  It isn't safe to checkpoint a dismounted volume, and
            //  it doesn't make much sense, either.
            //

            if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

                try_return( NOTHING );
            }

            //
            //  Now we will acquire the Open Attribute Table exclusive to delete
            //  all of the entries, since we want to write a clean checkpoint.
            //  This is OK, since we have the global resource and nothing else
            //  can be going on.  (Similarly we are writing an empty transaction
            //  table, while in fact we will be the only transaction, but there
            //  is no need to capture our guy, nor explicitly empty this table.)
            //

            NtfsAcquireExclusiveRestartTable( &Vcb->OpenAttributeTable, TRUE );
            OpenAttributeTableAcquired = TRUE;

            //
            //  First reclaim the page we have reserved in the undo total, to
            //  guarantee that we can flush the log file.
            //

            LfsResetUndoTotal( Vcb->LogHandle, 1, -(LONG)(2 * PAGE_SIZE) );

            if (FlushVolume) {

                (VOID)NtfsFlushVolume( IrpContext, Vcb, TRUE, FALSE, FALSE, FALSE );

            } else {

                NtfsFlushLsnStreams( Vcb );
            }

            SetFlag( Vcb->CheckpointFlags, VCB_LAST_CHECKPOINT_CLEAN );

            //
            //  Loop through to deallocate all of the open attribute entries.  Any
            //  that point to an Scb need to get the index in the Scb zeroed.  If
            //  they do not point to an Scb, we have to see if there is a name to
            //  free.
            //

            AttributeEntry = NtfsGetFirstRestartTable( &Vcb->OpenAttributeTable );

            while (AttributeEntry != NULL) {

                ULONG Index;

                if (AttributeEntry->OatData->Overlay.Scb != NULL) {

                    AttributeEntry->OatData->Overlay.Scb->NonpagedScb->OpenAttributeTableIndex =
                    AttributeEntry->OatData->Overlay.Scb->NonpagedScb->OnDiskOatIndex = 0;

                 } else {

                    //
                    //  Delete its name, if it has one.  Check that we aren't
                    //  using the hardcode $I30 name.
                    //

                    NtfsFreeScbAttributeName( AttributeEntry->OatData->AttributeName.Buffer );
                }

                //
                //  Get the index for the entry.
                //

                Index = GetIndexFromRestartEntry( &Vcb->OpenAttributeTable,
                                                  AttributeEntry );

                if (Vcb->RestartVersion == 0) {

                    NtfsFreeRestartTableIndex( Vcb->OnDiskOat, AttributeEntry->OatData->OnDiskAttributeIndex );
                }

                NtfsFreeOpenAttributeData( AttributeEntry->OatData );
                NtfsFreeRestartTableIndex( &Vcb->OpenAttributeTable, Index );

                AttributeEntry = NtfsGetNextRestartTable( &Vcb->OpenAttributeTable,
                                                          AttributeEntry );
            }

            //
            //  In a rare reuse path there may still be entries in the open attribute data
            //  list.  This can happen when we reuse a slot in the open attribute table
            //  during restart.
            //

            NtfsFreeAllOpenAttributeData( Vcb );

            //
            //  Initialize first in case we get an allocation failure.
            //

            ASSERT( IsRestartTableEmpty( &Vcb->OpenAttributeTable ));
            ASSERT( IsListEmpty( &Vcb->OpenAttributeData ));

            InitializeNewTable( sizeof( OPEN_ATTRIBUTE_ENTRY ),
                                INITIAL_NUMBER_ATTRIBUTES,
                                &Pointers );

            NtfsFreePool( Vcb->OpenAttributeTable.Table );
            Vcb->OpenAttributeTable.Table = Pointers.Table;

            //
            //  Since we are doing a clean checkpoint we may be able to discard the
            //  second open attribute table.  We have three cases to consider.
            //
            //      1 - We want to use Version 0 on-disk but currently aren't.
            //      2 - We are currently using Version 0 but can free some space.
            //      3 - We are currently using Version 0 but don't want to.
            //

            if (NtfsDefaultRestartVersion != Vcb->RestartVersion) {

                NtfsUpdateOatVersion( Vcb, NtfsDefaultRestartVersion );

            } else if (NtfsDefaultRestartVersion == 0) {

                InitializeNewTable( sizeof( OPEN_ATTRIBUTE_ENTRY_V0 ),
                                    INITIAL_NUMBER_ATTRIBUTES,
                                    &Pointers );

                NtfsFreePool( Vcb->OnDiskOat->Table );
                Vcb->OnDiskOat->Table = Pointers.Table;
            }

            //
            //  Initialize first in case we get an allocation failure.
            //  Make sure we commit the current transaction.
            //

            NtfsCommitCurrentTransaction( IrpContext );

            ASSERT(IsRestartTableEmpty(&Vcb->TransactionTable));

            InitializeNewTable( sizeof(TRANSACTION_ENTRY),
                                INITIAL_NUMBER_TRANSACTIONS,
                                &Pointers );

            NtfsFreePool( Vcb->TransactionTable.Table );
            Vcb->TransactionTable.Table = Pointers.Table;

            //
            //  Make sure we do not process any log file before the restart
            //  area, because we did not dump the open attribute table.
            //

            RestartArea.StartOfCheckpoint = LfsQueryLastLsn( Vcb->LogHandle );

        //
        //  More work to do if this is not a clean checkpoint.
        //

        } else {

            PDIRTY_PAGE_ENTRY DirtyPage;
            POPEN_ATTRIBUTE_ENTRY OpenEntry;
            ULONG JustMe = 0;
            ULONG TempCount;

            //
            //  Now we construct the dirty page table by calling the Cache Manager.
            //  For each dirty page on files tagged with our log handle, he will
            //  call us back at our DirtyPageRoutine.  We will allocate the initial
            //  Dirty Page Table, but we will let the call back routine grow it as
            //  necessary.
            //

            NtfsInitializeRestartTable( (((Vcb->RestartVersion == 0) ?
                                          sizeof( DIRTY_PAGE_ENTRY_V0 ) :
                                          sizeof( DIRTY_PAGE_ENTRY )) +
                                         ((Vcb->ClustersPerPage - 1) * sizeof(LCN))),
                                        Vcb->DirtyPageTableSizeHint,
                                        &DirtyPages );

            NtfsAcquireExclusiveRestartTable( &DirtyPages, TRUE );

            DirtyPageTableInitialized = TRUE;

            //
            //  Now we will acquire the Open Attribute Table shared to freeze changes.
            //

            NtfsAcquireExclusiveRestartTable( &Vcb->OpenAttributeTable, TRUE );
            OpenAttributeTableAcquired = TRUE;

            //
            //  Loop to see how much we will have to allocate for attribute names.
            //

            AttributeEntry = NtfsGetFirstRestartTable( &Vcb->OpenAttributeTable );

            while (AttributeEntry != NULL) {

                //
                //  This checks for one type of aliasing.
                //

                //  ASSERT( (AttributeEntry->Overlay.Scb == NULL) ||
                //          (AttributeEntry->Overlay.Scb->OpenAttributeTableIndex ==
                //           GetIndexFromRestartEntry( &Vcb->OpenAttributeTable,
                //                                    AttributeEntry )));

                //
                //  Clear the DirtyPageSeen flag prior to collecting the dirty pages,
                //  to help us figure out which Open Attribute Entries we still need.
                //

                AttributeEntry->DirtyPagesSeen = FALSE;

                if (AttributeEntry->OatData->AttributeName.Length != 0) {

                    //
                    //  Add to our name total, the size of an Attribute Entry,
                    //  which includes the size of the terminating UNICODE_NULL.
                    //

                    NameBytes += AttributeEntry->OatData->AttributeName.Length +
                                 sizeof(ATTRIBUTE_NAME_ENTRY);
                }

                AttributeEntry = NtfsGetNextRestartTable( &Vcb->OpenAttributeTable,
                                                          AttributeEntry );
            }

            //
            //  Now call the Cache Manager to give us all of our dirty pages
            //  via the DirtyPageRoutine callback, and remember what the oldest
            //  Lsn is for a dirty page.
            //

            OldestDirtyPageLsn = CcGetDirtyPages( Vcb->LogHandle,
                                                  &DirtyPageRoutine,
                                                  (PVOID)IrpContext,
                                                  (PVOID)&DirtyPages );

            TempCount = DirtyPages.Table->NumberAllocated;

            Vcb->DirtyPageTableSizeHint = (TempCount & ~(INITIAL_DIRTY_TABLE_HINT - 1)) + INITIAL_DIRTY_TABLE_HINT;

            if (OldestDirtyPageLsn.QuadPart != 0 &&
                OldestDirtyPageLsn.QuadPart < Vcb->LastBaseLsn.QuadPart) {

                OldestDirtyPageLsn = Vcb->LastBaseLsn;
            }

            //
            //  Now loop through the dirty page table to extract all of the Vcn/Lcn
            //  Mapping that we have, and insert it into the appropriate Scb.
            //

            DirtyPage = NtfsGetFirstRestartTable( &DirtyPages );

            //
            //  The dirty page routine is called while holding spin locks,
            //  so it cannot take page faults.  Thus we must scan the dirty
            //  page table we just built and fill in the Lcns here.
            //

            while (DirtyPage != NULL) {

                PSCB Scb;

                //
                //  If we have Lcn's then look them up.
                //

                if (DirtyPage->LengthOfTransfer != 0) {

                    VCN Vcn;
                    PLCN LcnArray;

                    //
                    //  Get the in-memory AttributeEntry from the dirty page entry.
                    //  Then update the dirty page entry with the on-disk TargetAttribute.
                    //  Also mark the pages dirty now.
                    //

                    OpenEntry = GetRestartEntryFromIndex( &Vcb->OpenAttributeTable,
                                                          DirtyPage->TargetAttribute );

                    OpenEntry->DirtyPagesSeen = TRUE;
                    DirtyPage->TargetAttribute = OpenEntry->OatData->OnDiskAttributeIndex;

                    ASSERT( IsRestartTableEntryAllocated( OpenEntry ));

                    Scb = OpenEntry->OatData->Overlay.Scb;

                    //
                    //  Account for  UsnJournal biasing if necc.
                    //  note at this point the vcn is actually still a byte offset
                    //

                    if (Scb == Vcb->UsnJournal) {
                        if (Vcb->RestartVersion == 0 ) {
                            ((PDIRTY_PAGE_ENTRY_V0) DirtyPage)->Vcn = ((PDIRTY_PAGE_ENTRY_V0) DirtyPage)->Vcn + Vcb->UsnCacheBias;
                        } else {
                            DirtyPage->Vcn = DirtyPage->Vcn + Vcb->UsnCacheBias;
                        }
                    }

                    //
                    //  Fix up the count of Lcns.
                    //

                    DirtyPage->LcnsToFollow = ClustersFromBytes( Vcb, DirtyPage->LengthOfTransfer );

                    //
                    //  Now fix up the page entry to account for the differences in the
                    //  restart version structures and also make sure we don't have
                    //  an Lsn which precedes our current base Lsn.
                    //

                    if (Vcb->RestartVersion == 0) {

                        ((PDIRTY_PAGE_ENTRY_V0) DirtyPage)->Reserved = 0;

                        if (((PDIRTY_PAGE_ENTRY_V0) DirtyPage)->OldestLsn.QuadPart < Vcb->LastBaseLsn.QuadPart) {

                            ((PDIRTY_PAGE_ENTRY_V0) DirtyPage)->OldestLsn.QuadPart = Vcb->LastBaseLsn.QuadPart;
                        }

                        Vcn = ((PDIRTY_PAGE_ENTRY_V0) DirtyPage)->Vcn;
                        Vcn = Int64ShraMod32( Vcn, Vcb->ClusterShift );
                        ((PDIRTY_PAGE_ENTRY_V0) DirtyPage)->Vcn = Vcn;

                        LcnArray = &((PDIRTY_PAGE_ENTRY_V0) DirtyPage)->LcnsForPage[0];

                    } else {

                        if (DirtyPage->OldestLsn.QuadPart < Vcb->LastBaseLsn.QuadPart) {

                            DirtyPage->OldestLsn.QuadPart = Vcb->LastBaseLsn.QuadPart;
                        }

                        DirtyPage->Vcn = Vcn = Int64ShraMod32( DirtyPage->Vcn, Vcb->ClusterShift );

                        LcnArray = &DirtyPage->LcnsForPage[0];
                    }

                    LookupLcns( IrpContext,
                                Scb,
                                Vcn,
                                DirtyPage->LcnsToFollow,
                                FALSE,
                                LcnArray );

                //
                //  Otherwise free this dirty page entry.
                //

                } else {

                    NtfsFreeRestartTableIndex( &DirtyPages,
                                               GetIndexFromRestartEntry( &DirtyPages,
                                                                         DirtyPage ));
                }

                //
                //  Point to next entry in table, or NULL.
                //

                DirtyPage = NtfsGetNextRestartTable( &DirtyPages, DirtyPage );
            }

            //
            //  If there were any names, then allocate space for them and copy
            //  them out.
            //

            if (NameBytes != 0) {

                PATTRIBUTE_NAME_ENTRY Name;

                //
                //  Allocate the buffer, with space for two terminating 0's on
                //  the end.
                //

                NameBytes += 4;
                Name =
                NamesBuffer = NtfsAllocatePool( NonPagedPool, NameBytes );

                //
                //  Now loop to copy the names.
                //

                AttributeEntry = NtfsGetFirstRestartTable( &Vcb->OpenAttributeTable );

                while (AttributeEntry != NULL) {

                    //
                    //  Free the Open Attribute Entry if there were no
                    //  dirty pages and the Scb is gone.  This is the only
                    //  place they are deleted.  (Yes, I know we allocated
                    //  space for its name, but I didn't want to make three
                    //  passes through the open attribute table.  Permeter
                    //  is running as we speak, and showing 407 open files
                    //  on NT/IDW5.)
                    //

                    if (!AttributeEntry->DirtyPagesSeen

                            &&

                        (AttributeEntry->OatData->Overlay.Scb == NULL)) {

                        ULONG Index;

                        //
                        //  Get the index for the entry.
                        //

                        Index = GetIndexFromRestartEntry( &Vcb->OpenAttributeTable,
                                                          AttributeEntry );

                        //
                        //  Delete its name and free it up.
                        //

                        NtfsFreeScbAttributeName( AttributeEntry->OatData->AttributeName.Buffer );

                        if (Vcb->RestartVersion == 0) {

                            NtfsFreeRestartTableIndex( Vcb->OnDiskOat,
                                                       AttributeEntry->OatData->OnDiskAttributeIndex );
                        }

                        NtfsFreeOpenAttributeData( AttributeEntry->OatData );
                        NtfsFreeRestartTableIndex( &Vcb->OpenAttributeTable,
                                                   Index );

                    //
                    //  Otherwise, if we are not deleting it, we have to
                    //  copy its name into the buffer we allocated.
                    //

                    } else if (AttributeEntry->OatData->AttributeName.Length != 0) {

                        //
                        //  Prefix each name in the buffer with the attribute index
                        //  and name length.  Be sure to use the index that will
                        //  be on-disk.
                        //

                        Name->Index = (USHORT) AttributeEntry->OatData->OnDiskAttributeIndex;

                        Name->NameLength = AttributeEntry->OatData->AttributeName.Length;
                        RtlCopyMemory( &Name->Name[0],
                                       AttributeEntry->OatData->AttributeName.Buffer,
                                       AttributeEntry->OatData->AttributeName.Length );

                        Name->Name[Name->NameLength / sizeof( WCHAR )] = 0;

                        Name = (PATTRIBUTE_NAME_ENTRY)((PCHAR)Name +
                                                       sizeof(ATTRIBUTE_NAME_ENTRY) +
                                                       Name->NameLength);

                        ASSERT( (PCHAR)Name <= ((PCHAR)NamesBuffer + NameBytes - 4) );
                    }

                    AttributeEntry = NtfsGetNextRestartTable( &Vcb->OpenAttributeTable,
                                                              AttributeEntry );
                }

                //
                //  Terminate the Names Buffer.
                //

                Name->Index = 0;
                Name->NameLength = 0;
            }

            //
            //  Now write all of the non-empty tables to the log.
            //

            //
            //  Write the Open Attribute Table
            //
            //  Make sure the tables are in sync.
            //

            ASSERT( (IsRestartTableEmpty( Vcb->OnDiskOat ) && IsRestartTableEmpty( &Vcb->OpenAttributeTable )) ||
                    (!IsRestartTableEmpty( Vcb->OnDiskOat ) && !IsRestartTableEmpty( &Vcb->OpenAttributeTable )));

            if (!IsRestartTableEmpty( Vcb->OnDiskOat )) {
                RestartArea.OpenAttributeTableLsn =
                NtfsWriteLog( IrpContext,
                              Vcb->MftScb,
                              NULL,
                              OpenAttributeTableDump,
                              Vcb->OnDiskOat->Table,
                              SizeOfRestartTable( Vcb->OnDiskOat ),
                              Noop,
                              NULL,
                              0,
                              (LONGLONG)0,
                              0,
                              0,
                              0 );

                RestartArea.OpenAttributeTableLength =
                  SizeOfRestartTable( Vcb->OnDiskOat );
                JustMe = 1;
            }

            NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );
            OpenAttributeTableAcquired = FALSE;

            //
            //  Write the Open Attribute Names
            //

            if (NameBytes != 0) {
                RestartArea.AttributeNamesLsn =
                NtfsWriteLog( IrpContext,
                              Vcb->MftScb,
                              NULL,
                              AttributeNamesDump,
                              NamesBuffer,
                              NameBytes,
                              Noop,
                              NULL,
                              0,
                              (LONGLONG)0,
                              0,
                              0,
                              0 );

                RestartArea.AttributeNamesLength = NameBytes;
                JustMe = 1;
            }

            //
            //  Write the Dirty Page Table
            //

            if (!IsRestartTableEmpty(&DirtyPages)) {
                RestartArea.DirtyPageTableLsn =
                NtfsWriteLog( IrpContext,
                              Vcb->MftScb,
                              NULL,
                              DirtyPageTableDump,
                              DirtyPages.Table,
                              SizeOfRestartTable(&DirtyPages),
                              Noop,
                              NULL,
                              0,
                              (LONGLONG)0,
                              0,
                              0,
                              0 );

                RestartArea.DirtyPageTableLength = SizeOfRestartTable(&DirtyPages);
                JustMe = 1;
            }

            //
            //  Write the Transaction Table if there is more than just us.  We
            //  are a transaction if we wrote any log records above.
            //

            NtfsAcquireExclusiveRestartTable( &Vcb->TransactionTable, TRUE );
            TransactionTableAcquired = TRUE;

            //
            //  Assumee will want to do at least one more checkpoint.
            //

            ClearFlag( Vcb->CheckpointFlags, VCB_LAST_CHECKPOINT_CLEAN );

            if ((ULONG)Vcb->TransactionTable.Table->NumberAllocated > JustMe) {
                RestartArea.TransactionTableLsn =
                NtfsWriteLog( IrpContext,
                              Vcb->MftScb,
                              NULL,
                              TransactionTableDump,
                              Vcb->TransactionTable.Table,
                              SizeOfRestartTable(&Vcb->TransactionTable),
                              Noop,
                              NULL,
                              0,
                              (LONGLONG)0,
                              0,
                              0,
                              0 );

                RestartArea.TransactionTableLength =
                  SizeOfRestartTable(&Vcb->TransactionTable);

                //
                //  Loop to see if the oldest Lsn comes from the transaction table.
                //

                TransactionEntry = NtfsGetFirstRestartTable( &Vcb->TransactionTable );

                while (TransactionEntry != NULL) {
                    if ((TransactionEntry->FirstLsn.QuadPart != 0)

                            &&

                        (TransactionEntry->FirstLsn.QuadPart < BaseLsn.QuadPart)) {

                        BaseLsn = TransactionEntry->FirstLsn;
                    }

                    TransactionEntry = NtfsGetNextRestartTable( &Vcb->TransactionTable,
                                                                TransactionEntry );
                }

            //
            //  If the transaction table is otherwise empty, then this is a good
            //  time to reset our totals with Lfs, in case our counts get off a bit.
            //

            } else {

                //
                //  If we are a transaction, then we have to add in our counts.
                //

                if (IrpContext->TransactionId != 0) {

                    TransactionEntry = (PTRANSACTION_ENTRY)GetRestartEntryFromIndex(
                                        &Vcb->TransactionTable, IrpContext->TransactionId );

                    LfsResetUndoTotal( Vcb->LogHandle,
                                       TransactionEntry->UndoRecords + 2,
                                       TransactionEntry->UndoBytes +
                                         QuadAlign(sizeof(RESTART_AREA)) + (2 * PAGE_SIZE) );

                //
                //  Otherwise, we reset to our "idle" requirements.
                //

                } else {
                    LfsResetUndoTotal( Vcb->LogHandle,
                                       2,
                                       QuadAlign(sizeof(RESTART_AREA)) + (2 * PAGE_SIZE) );
                }

                //
                //  If the DirtyPage table is empty then mark this as a clean checkpoint.
                //

                if (IsRestartTableEmpty( &DirtyPages )) {

                    SetFlag( Vcb->CheckpointFlags, VCB_LAST_CHECKPOINT_CLEAN );
                    CleanVolume = TRUE;
                }
            }

            NtfsReleaseRestartTable( &Vcb->TransactionTable );
            TransactionTableAcquired = FALSE;
        }

        //
        //  So far BaseLsn holds the minimum of the start Lsn for the checkpoint,
        //  or any of the FirstLsn fields for active transactions.  Now we see
        //  if the oldest Lsn we need in the log should actually come from the
        //  oldest page in the dirty page table.
        //

        if ((OldestDirtyPageLsn.QuadPart != 0)

                &&

            (OldestDirtyPageLsn.QuadPart < BaseLsn.QuadPart)) {

            BaseLsn = OldestDirtyPageLsn;
        }

        //
        //  Now fill in the LowestOpenUsn in the RestartArea.  This is an unsafe
        //  test, but if we think we see an empty list, that is ok.  In case no
        //  files are open yet, make sure we do not backtrack from the number we got
        //  at restart.
        //

        RestartArea.MajorVersion = Vcb->RestartVersion;
        RestartArea.CurrentLsnAtMount = Vcb->CurrentLsnAtMount;
        RestartArea.BytesPerCluster = Vcb->BytesPerCluster;

        RestartArea.Reserved = 0;
        RestartArea.UsnJournalReference = Vcb->UsnJournalReference;
        RestartArea.UsnCacheBias = Vcb->UsnCacheBias;

        UsnJournal = Vcb->UsnJournal;
        if (UsnJournal != NULL) {

            NtfsAcquireResourceShared( IrpContext, UsnJournal, TRUE );
            NtfsLockFcb( IrpContext, UsnJournal->Fcb );
            RestartArea.LowestOpenUsn = Vcb->LowestOpenUsn;

            //
            //  Now we will correctly synchronize, test the list again and capture
            //  the LowestUsn.
            //

            if (!IsListEmpty(&Vcb->ModifiedOpenFiles)) {
                RestartArea.LowestOpenUsn =
                  ((PFCB_USN_RECORD)CONTAINING_RECORD( Vcb->ModifiedOpenFiles.Flink,
                                                       FCB_USN_RECORD,
                                                       ModifiedOpenFilesLinks ))->Fcb->Usn;

            //
            //  If the list is empty, then use FileSize
            //

            } else {
                RestartArea.LowestOpenUsn = UsnJournal->Header.FileSize.QuadPart;
            }

            //
            //  Continue to advance the Usn in the Vcb on checkpoints, so that
            //  if the list goes empty we do not get a restart that has to go
            //  back to where we were at boot time.
            //

#ifdef TOMM
            ASSERT(RestartArea.LowestOpenUsn >= Vcb->LowestOpenUsn);
#endif
            Vcb->LowestOpenUsn = RestartArea.LowestOpenUsn;
            NtfsUnlockFcb( IrpContext, UsnJournal->Fcb );
            NtfsReleaseResource( IrpContext, UsnJournal );

            //
            //  Finally, write our Restart Area to describe all of the above, and
            //  give Lfs our new BaseLsn.
            //

            Vcb->LastBaseLsn = Vcb->LastRestartArea = BaseLsn;
            LfsWriteRestartArea( Vcb->LogHandle,
                                 sizeof( RESTART_AREA ),
                                 &RestartArea,
                                 LfsCleanShutdown,
                                 &Vcb->LastRestartArea );

        } else {

            //
            //  Finally, write our Restart Area to describe all of the above, and
            //  give Lfs our new BaseLsn.
            //

            Vcb->LastBaseLsn = Vcb->LastRestartArea = BaseLsn;
            LfsWriteRestartArea( Vcb->LogHandle,
                                 sizeof( RESTART_AREA ),
                                 &RestartArea,
                                 LfsCleanShutdown,
                                 &Vcb->LastRestartArea );
        }

        //
        //  If this is a clean checkpoint then initialize our reserved area.
        //  Also set the LastBaseLsn to the restart area itself.  This will
        //  prevent us from generating future dirty page table entries
        //  which go back prior to the restart area.
        //

        if (CleanVolume) {

            Vcb->LastBaseLsn = Vcb->LastRestartArea;
            LfsResetUndoTotal( Vcb->LogHandle, 2, QuadAlign(sizeof(RESTART_AREA)) + (2 * PAGE_SIZE) );
            Vcb->DirtyPageTableSizeHint = INITIAL_DIRTY_TABLE_HINT;
        }

        //
        //  Now remember where the log file is at now, so we know when to
        //  go idle above.
        //

        Vcb->EndOfLastCheckpoint = LfsQueryLastLsn( Vcb->LogHandle );

    try_exit: NOTHING;
    } finally {

        DebugUnwind( NtfsCheckpointVolume );

        //
        //  If the Dirty Page Table got initialized, free it up.
        //

        if (DirtyPageTableInitialized) {
            NtfsFreeRestartTable( &DirtyPages );
        }

        //
        //  Release any resources
        //

        if (OpenAttributeTableAcquired) {
            NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );
        }

        if (TransactionTableAcquired) {
            NtfsReleaseRestartTable( &Vcb->TransactionTable );
        }

        //
        //  Release any names buffer.
        //

        if (NamesBuffer != NULL) {
            NtfsFreePool( NamesBuffer );
        }

        //
        //  Free any partial table we allocated.
        //

        if (NewTable != NULL) {

            NtfsFreePool( NewTable );
        }

        //
        //  If this checkpoint created a transaction, free the index now.
        //

        if (IrpContext->TransactionId != 0) {

            NtfsAcquireExclusiveRestartTable( &Vcb->TransactionTable,
                                              TRUE );

            NtfsFreeRestartTableIndex( &Vcb->TransactionTable,
                                       IrpContext->TransactionId );

            NtfsReleaseRestartTable( &Vcb->TransactionTable );

            IrpContext->TransactionId = 0;
        }

        if (AcquireFiles) {

#ifdef NTFSDBG
            ASSERT( FlagOn( IrpContext->State, IRP_CONTEXT_STATE_CHECKPOINT_ACTIVE ));
            DebugDoit( ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_CHECKPOINT_ACTIVE ));
#endif  //  NTFSDBG

            NtfsReleaseAllFiles( IrpContext, Vcb, FALSE );
        }

        //
        //  If we didn't own the checkpoint operation then indicate
        //  that someone else is free to checkpoint.  Hold the checkpoint
        //  flags if we plan to trim the usn journal.  The checkpoint
        //  flags serialize the journal with the delete journal operation.
        //

        ASSERT( !OwnsCheckpoint || CleanVolume );

        if (!OwnsCheckpoint) {

            if ((UsnJournal == NULL) || CleanVolume || AbnormalTermination()) {

                NtfsAcquireCheckpoint( IrpContext, Vcb );
                ClearFlag( Vcb->CheckpointFlags,
                           VCB_CHECKPOINT_SYNC_FLAGS | VCB_DUMMY_CHECKPOINT_POSTED);

                NtfsSetCheckpointNotify( IrpContext, Vcb );
                NtfsReleaseCheckpoint( IrpContext, Vcb );
            }
        }

        if (RestorePreviousPriority) {

            KeSetPriorityThread( (PKTHREAD)PsGetCurrentThread(),
                                 PreviousPriority );
        }
    }

    NtfsFreeRecentlyDeallocated( IrpContext, Vcb, &BaseLsn, CleanVolume );

    //
    //  If there is a Usn Journal, call to perform possible trimming on a periodic checkpoint.
    //

    if (!CleanVolume && (UsnJournal != NULL)) {
        NtfsTrimUsnJournal( IrpContext, Vcb );
    }

    //
    //  If we need to post a defrag request then do so now.
    //

    if (PostDefrag) {

        PDEFRAG_MFT DefragMft;

        //
        //  Use a try-except to ignore allocation errors.
        //

        try {

            NtfsAcquireCheckpoint( IrpContext, Vcb );

            if (!FlagOn( Vcb->MftDefragState, VCB_MFT_DEFRAG_ACTIVE )) {

                SetFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_ACTIVE );
                NtfsReleaseCheckpoint( IrpContext, Vcb );

                DefragMft = NtfsAllocatePool( NonPagedPool, sizeof( DEFRAG_MFT ));

                DefragMft->Vcb = Vcb;
                DefragMft->DeallocateWorkItem = TRUE;

                //
                //  Send it off.....
                //

                ExInitializeWorkItem( &DefragMft->WorkQueueItem,
                                      (PWORKER_THREAD_ROUTINE)NtfsDefragMft,
                                      (PVOID)DefragMft );

                ExQueueWorkItem( &DefragMft->WorkQueueItem, CriticalWorkQueue );

            } else {

                NtfsReleaseCheckpoint( IrpContext, Vcb );
            }

        } except( FsRtlIsNtstatusExpected( GetExceptionCode() )
                  ? EXCEPTION_EXECUTE_HANDLER
                  : EXCEPTION_CONTINUE_SEARCH ) {

            NtfsAcquireCheckpoint( IrpContext, Vcb );
            ClearFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_ACTIVE );
            NtfsReleaseCheckpoint( IrpContext, Vcb );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsCheckpointVolume -> VOID\n") );
}



VOID
NtfsCheckpointForLogFileFull (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine is called to perform the clean checkpoint generated after
    a log file full.  This routine will call the clean checkpoint routine
    and then release all of the resources acquired.


Arguments:

Return Value:

    None.

--*/

{
    PAGED_CODE();
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    IrpContext->ExceptionStatus = 0;

    //
    //  Call the checkpoint routine to do the actual work.  Skip this in the case where there is no
    //  longer a Vcb in the IrpContext.  This can happen if doing some long running operation at
    //  mount time (i.e. Usn scan).  In that case the long running operation should periodically
    //  checkpoint.  Then Ntfs will do a clean checkpoint after restart and the remaining work
    //  to do in the long-running operation will decrease.  At some point it will decrease enough
    //  to finish the mount.
    //
    //  All of the other work is required since this IrpContext will be used to retry the mount.
    //

    if (IrpContext->Vcb != NULL) {

        //
        //  This can raise. However, in the case of dismounts, we do want this to
        //  plough on and succeed the dismount. For example, cluster service marks
        //  the volume offline first and sends the dismount afterward, but still expects it to succeed.
        //

        try {

            NtfsCheckpointVolume( IrpContext,
                                  IrpContext->Vcb,
                                  FALSE,
                                  TRUE,
                                  FALSE,
                                  0,
                                  IrpContext->LastRestartArea );

        } except (NtfsCheckpointExceptionFilter( IrpContext,
                                                 GetExceptionInformation(),
                                                 GetExceptionCode() )) {

            //
            //  This is a LOG_FILE_FULL raise coming via dismount. Ignore errors
            //  because we want the dismount to succeed.
            //

            NtfsMinimumExceptionProcessing( IrpContext );
            if (IrpContext->TransactionId != 0) {

                NtfsCleanupFailedTransaction( IrpContext );
            }
        }
    }

    ASSERT( IrpContext->TransactionId == 0 );

    //
    //  Cleanup the IrpContext but don't delete it.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE );
    NtfsCleanupIrpContext( IrpContext, TRUE );

    //
    //  Make sure we restore the RestartArea.
    //

    IrpContext->LastRestartArea = Li0;
    return;
}


NTSTATUS
NtfsCheckpointForVolumeSnapshot (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine is called to perform a volume flush and a
    clean checkpoint before a snapshot of the volume is taken.
    Since we need to keep the volume quiescent, we make it a
    point to leave the file resources acquired on exit.

Arguments:
    IrpContext.

Return Value:

    Status.

--*/

{
    LOGICAL AcquiredCheckpoint;
    LOGICAL AcquiredFiles = FALSE;
    LOGICAL AcquiredVcb = FALSE;
    PVCB Vcb;
    NTSTATUS Status = STATUS_SUCCESS;
    LOGICAL DefragPermitted;
    KPRIORITY PreviousPriority;
    BOOLEAN RestorePreviousPriority = FALSE;

    PAGED_CODE();

    //
    //  Clear the Mft defrag flag to stop any actions behind our backs.
    //

    Vcb = IrpContext->Vcb;

    //
    //  If this is a readonly volume, then there's nothing we need to do.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        ASSERT( Status == STATUS_SUCCESS );
        DebugTrace( -1, Dbg, ("NtfsCheckpointForVolumeSnapshot -> %08lx\n", Status) );

        return Status;
    }

    NtfsAcquireCheckpoint( IrpContext, Vcb );
    DefragPermitted = FlagOn( Vcb->MftDefragState, VCB_MFT_DEFRAG_PERMITTED );
    ClearFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_PERMITTED );
    NtfsReleaseCheckpoint( IrpContext, Vcb );
    AcquiredCheckpoint = FALSE;

    try {

        //
        //  Then lock out all other checkpoint operations.
        //

        NtfsAcquireCheckpoint( IrpContext, Vcb );

        while (FlagOn( Vcb->CheckpointFlags, VCB_CHECKPOINT_SYNC_FLAGS )) {

            //
            //  Release the checkpoint event because we cannot checkpoint now.
            //

            NtfsReleaseCheckpoint( IrpContext, Vcb );
            NtfsWaitOnCheckpointNotify( IrpContext, Vcb );
            NtfsAcquireCheckpoint( IrpContext, Vcb );
        }

        SetFlag( Vcb->CheckpointFlags, VCB_CHECKPOINT_SYNC_FLAGS );
        NtfsResetCheckpointNotify( IrpContext, Vcb );
        NtfsReleaseCheckpoint( IrpContext, Vcb );
        AcquiredCheckpoint = TRUE;

        NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
        AcquiredVcb = TRUE;

        //
        //  Check that the volume is still mounted.
        //

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  Start by flushing the volume, because we can't call FlushVolume later
        //  while holding only the Main resources without their corresponding
        //  pagingio resources. Flushing the userdata doesn't really need to be
        //  atomic with the rest of the operation; we just have to make sure that
        //  the volume is consistent and restartable without log recovery.
        //

        NtfsFlushVolume( IrpContext,
                         Vcb,
                         TRUE,
                         FALSE,
                         TRUE,
                         FALSE );

        //
        //  Give ourselves some juice. We'll need it.
        //

        PreviousPriority = KeSetPriorityThread( (PKTHREAD)PsGetCurrentThread(),
                                                LOW_REALTIME_PRIORITY );

        if (PreviousPriority != LOW_REALTIME_PRIORITY) {

            RestorePreviousPriority = TRUE;
        }

        //
        //  Lock, stock, clean checkpoint, volume flush and
        //  two smoking barrels. No chance of acquiring PagingIo
        //  here; pretty much only shutdown has that luxury.
        //

        NtfsAcquireAllFiles( IrpContext, Vcb, TRUE, FALSE, FALSE );
        AcquiredFiles = TRUE;

        //
        //  Generate usn CLOSE records. We don't bother to get the FcbMutex because
        //  we already have the Fcb main resource exclusively.
        //

        if (Vcb->UsnJournal != NULL) {

            PLIST_ENTRY Links;
            PFCB_USN_RECORD UsnRecord;

            while (TRUE) {

                NtfsLockFcb( IrpContext, Vcb->UsnJournal->Fcb );

                Links = Vcb->ModifiedOpenFiles.Flink;
                if (Links == &Vcb->ModifiedOpenFiles) {

                    NtfsUnlockFcb( IrpContext, Vcb->UsnJournal->Fcb );
                    break;
                }

                UsnRecord = (PFCB_USN_RECORD)CONTAINING_RECORD( Links,
                                                                FCB_USN_RECORD,
                                                                ModifiedOpenFilesLinks );

                NtfsUnlockFcb( IrpContext, Vcb->UsnJournal->Fcb );

                //
                //  Post the CLOSE record. Checkpointing takes this UsnRecord
                //  off the ModifiedOpenFiles list.
                //

                NtfsPostUsnChange( IrpContext, UsnRecord->Fcb, USN_REASON_CLOSE );
                NtfsWriteUsnJournalChanges( IrpContext );
                NtfsCheckpointCurrentTransaction( IrpContext );

            }
        }

        SetFlag( Vcb->VcbState, VCB_STATE_VOL_PURGE_IN_PROGRESS );

        NtfsCheckpointVolume( IrpContext, Vcb, TRUE, TRUE, FALSE, 0, Vcb->LastRestartArea );
        NtfsCommitCurrentTransaction( IrpContext );

        ClearFlag( Vcb->VcbState, VCB_STATE_VOL_PURGE_IN_PROGRESS );

    } finally {

        //
        //  Restore DEFRAG_PERMITTED flag if we need to.
        //

        if (DefragPermitted) {

            NtfsAcquireCheckpoint( IrpContext, Vcb );
            SetFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_PERMITTED );
            NtfsReleaseCheckpoint( IrpContext, Vcb );
        }

        //
        //  Release the checkpoint, if we got it, but we aren't releasing
        //  all the files unless there was an error.
        //

        if (AcquiredCheckpoint) {

            NtfsAcquireCheckpoint( IrpContext, Vcb );
            ClearFlag( Vcb->CheckpointFlags,
                       VCB_CHECKPOINT_SYNC_FLAGS | VCB_DUMMY_CHECKPOINT_POSTED);
            NtfsSetCheckpointNotify( IrpContext, Vcb );
            NtfsReleaseCheckpoint( IrpContext, Vcb );
        }

        //
        //  Release the file resources only if we hit an error.
        //  We normally do this in the completion routine for the IOCTL.
        //

        if (!NT_SUCCESS( Status ) || AbnormalTermination()) {

            if (AcquiredFiles) {

                NtfsReleaseAllFiles( IrpContext, Vcb, FALSE );
            }

            if (AcquiredVcb) {

                NtfsReleaseVcb( IrpContext, Vcb );
            }
        }

        if (RestorePreviousPriority) {

            KeSetPriorityThread( (PKTHREAD)PsGetCurrentThread(),
                                 PreviousPriority );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsCheckpointForVolsnap -exit\n") );

    return Status;
}


VOID
NtfsCleanCheckpoint (
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine is called to perform a single clean checkpoint at the top level
    and return.  It is used when the lazy writer gets a log file full in order
    to perform the clean checkpoint within the thread doing the lazy write.

Arguments:

Return Value:

    None.

--*/
{
    IRP_CONTEXT LocalIrpContext;
    PIRP_CONTEXT IrpContext = &LocalIrpContext;
    PAGED_CODE();

    try {

        //
        //  Allocate an Irp Context for the request.
        //

        NtfsInitializeIrpContext( NULL, TRUE, &IrpContext );
        IrpContext->Vcb = Vcb;
        IrpContext->LastRestartArea = Vcb->LastRestartArea;

        //
        //  There is no point in posting any dummy requests.
        //

        NtfsAcquireCheckpoint( IrpContext, IrpContext->Vcb );
        SetFlag( IrpContext->Vcb->CheckpointFlags, VCB_DUMMY_CHECKPOINT_POSTED );
        NtfsReleaseCheckpoint( IrpContext, IrpContext->Vcb );

        //
        //  Send this off to the FspDispatch routine.  It will handle all of the
        //  top level logic as well as deleting the IrpContext.
        //

        NtfsFspDispatch( IrpContext );

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        NOTHING;
    }

    return;
}


VOID
NtfsCommitCurrentTransaction (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine commits the current transaction by writing a final record
    to the log and deallocating the transaction Id.

Arguments:

Return Value:

    None.

--*/

{
    PTRANSACTION_ENTRY TransactionEntry;
    PVCB Vcb = IrpContext->Vcb;
    PFCB UsnFcb;
    PUSN_FCB ThisUsn, LastUsn;

    PAGED_CODE();

#if (DBG || defined( NTFS_FREE_ASSERTS ))
    try {
#endif

    //
    //  Walk through the queue of usn records.  We want to remove any effect of this operation.
    //

    ThisUsn = &IrpContext->Usn;

    do {

        //
        //  If we log the close for a file, then it is time to reset the
        //  Usn reasons for the file.  Nothing to do here unless we
        //  wrote new reasons.
        //

        if (ThisUsn->CurrentUsnFcb != NULL ) {

            PSCB UsnJournal = Vcb->UsnJournal;
            PFCB_USN_RECORD FcbUsnRecord;


            UsnFcb = ThisUsn->CurrentUsnFcb;

            NtfsLockFcb( IrpContext, UsnFcb );

            if (UsnJournal != NULL) {
                NtfsLockFcb( IrpContext, UsnJournal->Fcb );
            }

            FcbUsnRecord = UsnFcb->FcbUsnRecord;

            //
            //  After locking the fcb test for the presence of the fcb record again
            //  DeleteUsnJournal may have already removed it
            //

            if (FcbUsnRecord) {

                UsnFcb->Usn = FcbUsnRecord->UsnRecord.Usn;

                //
                //  Now add or move the Fcb in the ModifiedOpenFiles list.
                //

                if (FlagOn( FcbUsnRecord->UsnRecord.Reason, USN_REASON_CLOSE )) {

                    //
                    //  Clean up the UsnRecord in the Fcb.
                    //

                    FcbUsnRecord->UsnRecord.Reason = 0;
                    FcbUsnRecord->UsnRecord.SourceInfo = 0;

                    if (UsnJournal != NULL) {

                        if( FcbUsnRecord->ModifiedOpenFilesLinks.Flink != NULL ) {

                            RemoveEntryList( &FcbUsnRecord->ModifiedOpenFilesLinks );
                            FcbUsnRecord->ModifiedOpenFilesLinks.Flink = NULL;

                            if (FcbUsnRecord->TimeOutLinks.Flink != NULL) {

                                RemoveEntryList( &FcbUsnRecord->TimeOutLinks );
                                FcbUsnRecord->TimeOutLinks.Flink = NULL;
                            }
                        }
                    }

                } else {

                    if (UsnJournal != NULL) {

                        if (FcbUsnRecord->ModifiedOpenFilesLinks.Flink != NULL) {

                            RemoveEntryList( &FcbUsnRecord->ModifiedOpenFilesLinks );
                            if (FcbUsnRecord->TimeOutLinks.Flink != NULL) {

                                RemoveEntryList( &FcbUsnRecord->TimeOutLinks );
                                FcbUsnRecord->TimeOutLinks.Flink = NULL;
                            }
                        }

                        InsertTailList( &Vcb->ModifiedOpenFiles, &FcbUsnRecord->ModifiedOpenFilesLinks );

                        if (UsnFcb->CleanupCount == 0) {

                            InsertTailList( Vcb->CurrentTimeOutFiles, &FcbUsnRecord->TimeOutLinks );
                        }
                    }
                }
            }

            //
            //  Cleanup the UsnFcb in the IrpContext.  It's possible that
            //  we might want to reuse the UsnFcb later in this request.
            //


            if (ThisUsn != &IrpContext->Usn) {

                LastUsn->NextUsnFcb = ThisUsn->NextUsnFcb;
                NtfsFreePool( ThisUsn );
                ThisUsn = LastUsn;

            } else {

                RtlZeroMemory( &ThisUsn->CurrentUsnFcb,
                               sizeof( USN_FCB ) - FIELD_OFFSET( USN_FCB, CurrentUsnFcb ));
            }

            if (UsnJournal != NULL) {
                NtfsUnlockFcb( IrpContext, UsnJournal->Fcb );
            }
            NtfsUnlockFcb( IrpContext, UsnFcb );
        }

        if (ThisUsn->NextUsnFcb == NULL) { break; }

        //
        //  Move to the next entry.
        //

        LastUsn = ThisUsn;
        ThisUsn = ThisUsn->NextUsnFcb;
    } while (TRUE);

    //
    //  If this request created a transaction, complete it now.
    //

    if (IrpContext->TransactionId != 0) {

        LSN CommitLsn;

        //
        //  It is possible to get a LOG_FILE_FULL before writing
        //  out the first log record of a transaction.  In that
        //  case there is a transaction Id but we haven't reserved
        //  space in the log file.  It is wrong to write the
        //  commit record in this case because we can get an
        //  unexpected LOG_FILE_FULL.  We can also test the UndoRecords
        //  count in the transaction entry but don't want to acquire
        //  the restart table to make this check.
        //

        if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WROTE_LOG )) {

            //
            //  Write the log record to "forget" this transaction,
            //  because it should not be aborted.  Until if/when we
            //  do real TP, commit and forget are atomic.
            //

            CommitLsn =
            NtfsWriteLog( IrpContext,
                          Vcb->MftScb,
                          NULL,
                          ForgetTransaction,
                          NULL,
                          0,
                          CompensationLogRecord,
                          (PVOID)&Li0,
                          sizeof(LSN),
                          (LONGLONG)0,
                          0,
                          0,
                          0 );
        }

        //
        //  We can now free the transaction table index, because we are
        //  done with it now.
        //

        NtfsAcquireExclusiveRestartTable( &Vcb->TransactionTable,
                                          TRUE );

        TransactionEntry = (PTRANSACTION_ENTRY)GetRestartEntryFromIndex(
                            &Vcb->TransactionTable,
                            IrpContext->TransactionId );

        //
        //  Call Lfs to free our undo space.
        //

        if ((TransactionEntry->UndoRecords != 0) &&
            (!FlagOn( Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ))) {

            LfsResetUndoTotal( Vcb->LogHandle,
                               TransactionEntry->UndoRecords,
                               -TransactionEntry->UndoBytes );
        }

        NtfsFreeRestartTableIndex( &Vcb->TransactionTable,
                                   IrpContext->TransactionId );

        IrpContext->TransactionId = 0;

        NtfsReleaseRestartTable( &Vcb->TransactionTable );

        //
        //  One way we win by being recoverable, is that we do not really
        //  have to do write-through - flushing the updates to the log
        //  is enough.  We don't make this call if we are in the abort
        //  transaction path.  Otherwise we could get a log file full
        //  while aborting.
        //

        if (FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_WRITE_THROUGH ) &&
            (IrpContext == IrpContext->TopLevelIrpContext) &&
            (IrpContext->TopLevelIrpContext->ExceptionStatus == STATUS_SUCCESS)) {

            NtfsUpdateScbSnapshots( IrpContext );
            LfsFlushToLsn( Vcb->LogHandle, CommitLsn );
        }
    }

    //
    //  Signal any waiters for the new length.
    //

    if (IrpContext->CheckNewLength != NULL) {

        NtfsProcessNewLengthQueue( IrpContext, FALSE );
    }

#if (DBG || defined( NTFS_FREE_ASSERTS ))
    } except( ASSERT( GetExceptionCode() != STATUS_LOG_FILE_FULL ), EXCEPTION_CONTINUE_SEARCH ) {
    }
#endif

}


VOID
NtfsCheckpointCurrentTransaction (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine checkpoints the current transaction by commiting it
    to the log and deallocating the transaction Id.  The current request
    cann keep running, but changes to date are committed and will not be
    backed out.

Arguments:

Return Value:

    None.

--*/

{
    PVCB Vcb = IrpContext->Vcb;
    PAGED_CODE();

    //
    //  If there are new UsnReasons in the IrpContext, then we shoudld write the journal
    //  now.  Note that it is ok for a checkpoint to get logfile full, but in general commit
    //  should not.
    //

    if ((IrpContext->Usn.NewReasons | IrpContext->Usn.RemovedSourceInfo) != 0) {
        NtfsWriteUsnJournalChanges( IrpContext );
    }

    NtfsCommitCurrentTransaction( IrpContext );

    //
    //  Cleanup any recently deallocated record information for this transaction.
    //

    NtfsDeallocateRecordsComplete( IrpContext );
    IrpContext->DeallocatedClusters = 0;
    IrpContext->FreeClusterChange = 0;

    //
    //  The following resources may have been flagged for immediate release on commit.
    //

    if (Vcb->AcquireFilesCount == 0) {

        if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_USN_JRNL )) {
            NtfsReleaseScb( IrpContext, Vcb->UsnJournal );
        }

        if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_MFT )) {
            NtfsReleaseScb( IrpContext, Vcb->MftScb );
        }
    }

    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_USN_JRNL |
                                  IRP_CONTEXT_FLAG_RELEASE_MFT );

    NtfsUpdateScbSnapshots( IrpContext );
}


VOID
NtfsInitializeLogging (
    )

/*

Routine Description:

    This routine is to be called once during startup of Ntfs (not once
    per volume), to initialize the logging support.

Parameters:

    None

Return Value:

    None

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsInitializeLogging:\n") );
    LfsInitializeLogFileService();
    DebugTrace( -1, Dbg, ("NtfsInitializeLogging -> VOID\n") );
}


VOID
NtfsStartLogFile (
    IN PSCB LogFileScb,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine opens the log file for a volume by calling Lfs.  The returned
    LogHandle is stored in the Vcb.  If the log file has not been initialized,
    Lfs detects this and initializes it automatically.

Arguments:

    LogFileScb - The Scb for the log file

    Vcb - Pointer to the Vcb for this volume

Return Value:

    None.

--*/

{
    UNICODE_STRING UnicodeName;
    LFS_INFO LfsInfo;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsStartLogFile:\n") );

    RtlInitUnicodeString( &UnicodeName, L"NTFS" );

    //
    //  LfsInfo structure acts as a information conduit between
    //  LFS and the NTFS client.
    //

    if (Vcb->MajorVersion >= 3) {

        LfsInfo.LfsClientInfo = LfsFixedPageSize;

    } else {

        LfsInfo.LfsClientInfo = LfsPackLog;
    }

    LfsInfo.ReadOnly = (LOGICAL)NtfsIsVolumeReadOnly( Vcb );
    LfsInfo.InRestart = (LOGICAL)FlagOn( Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS );
    LfsInfo.BadRestart = (LOGICAL)FlagOn( Vcb->VcbState, VCB_STATE_BAD_RESTART );

    //
    //  Slam the allocation size into file size and valid data in case there
    //  is some error.
    //

    LogFileScb->Header.FileSize = LogFileScb->Header.AllocationSize;
    LogFileScb->Header.ValidDataLength = LogFileScb->Header.AllocationSize;

    //
    //  Now call into LFS and Open/Restart the log file. This could raise
    //  for various reasons, one of which is an attempt to do restart
    //  on a write protected volume. Vcb wont have the VALID_LOG_HANDLE flag then.
    //

    Vcb->LogHeaderReservation = LfsOpenLogFile( LogFileScb->FileObject,
                                                UnicodeName,
                                                1,
                                                0,
                                                LogFileScb->Header.AllocationSize.QuadPart,
                                                &LfsInfo,
                                                &Vcb->LogHandle,
                                                &Vcb->LfsWriteData );

    SetFlag( Vcb->VcbState, VCB_STATE_VALID_LOG_HANDLE );

    DebugTrace( -1, Dbg, ("NtfsStartLogFile -> VOID\n") );
}


VOID
NtfsStopLogFile (
    IN PVCB Vcb
    )

/*

Routine Description:

    This routine should be called during volume dismount to close the volume's
    log file with the log file service.

Arguments:

    Vcb - Pointer to the Vcb for the volume

Return Value:

    None

--*/

{
    LFS_LOG_HANDLE LogHandle = Vcb->LogHandle;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsStopLogFile:\n") );

    if (FlagOn( Vcb->VcbState, VCB_STATE_VALID_LOG_HANDLE )) {

        ASSERT( LogHandle != NULL );

        //
        //  We don't do any logfile flushing if the volume
        //  is mounted read only or if the device is already gone.
        //

        if (!NtfsIsVolumeReadOnly( Vcb )) {

            //
            //  Proceed even if this call fails.  There is nothing
            //  more we can do at this point.
            //

            try {

                LfsFlushToLsn( LogHandle, LiMax );

            } except( (FsRtlIsNtstatusExpected( GetExceptionCode() )) ?
                      EXCEPTION_EXECUTE_HANDLER :
                      EXCEPTION_CONTINUE_SEARCH ) {

                NOTHING;
            }
        }

        ClearFlag( Vcb->VcbState, VCB_STATE_VALID_LOG_HANDLE );

        //
        //  Allow LFS to close its books. We do this even for readonly
        //  mounts, although we filter writes at the LFS level for those.
        //

        LfsCloseLogFile( LogHandle );
    }

    DebugTrace( -1, Dbg, ("NtfsStopLogFile -> VOID\n") );
}


VOID
NtfsInitializeRestartTable (
    IN ULONG EntrySize,
    IN ULONG NumberEntries,
    OUT PRESTART_POINTERS TablePointer
    )

/*++

Routine Description:

    This routine is called to allocate and initialize a new Restart Table,
    and return a pointer to it.

Arguments:

    EntrySize - Size of the table entries, in bytes.

    NumberEntries - Number of entries to allocate for the table.

    TablePointer - Returns a pointer to the table.

Return Value:

    None

--*/

{
    PAGED_CODE();

    try {

        NtfsInitializeRestartPointers( TablePointer );

        //
        //  Call common routine to allocate the actual table.
        //

        InitializeNewTable( EntrySize, NumberEntries, TablePointer );

    } finally {

        DebugUnwind( NtfsInitializeRestartTable );

        //
        //  On error, clean up any partial work that was done.
        //

        if (AbnormalTermination()) {

            NtfsFreeRestartTable( TablePointer );
        }
    }
}


VOID
NtfsFreeRestartTable (
    IN PRESTART_POINTERS TablePointer
    )

/*++

Routine Description:

    This routine frees a previously allocated Restart Table.

Arguments:

    TablePointer - Pointer to the Restart Table to delete.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    if (TablePointer->Table != NULL) {
        NtfsFreePool( TablePointer->Table );
        TablePointer->Table = NULL;
    }

    if (TablePointer->ResourceInitialized) {
        ExDeleteResourceLite( &TablePointer->Resource );
        TablePointer->ResourceInitialized = FALSE;
    }
}


VOID
NtfsExtendRestartTable (
    IN PRESTART_POINTERS TablePointer,
    IN ULONG NumberNewEntries,
    IN ULONG FreeGoal
    )

/*++

Routine Description:

    This routine extends a previously allocated Restart Table, by
    creating and initializing a new one, and copying over the the
    table entries from the old one.  The old table is then deallocated.
    On return, the table pointer points to the new Restart Table.

Arguments:

    TablePointer - Address of the pointer to the previously created table.

    NumberNewEntries - The number of addtional entries to be allocated
                       in the new table.

    FreeGoal - A hint as to what point the caller would like to truncate
               the table back to, when sufficient entries are deleted.
               If truncation is not desired, then MAXULONG may be specified.

Return Value:

    None.

--*/

{
    PRESTART_TABLE NewTable, OldTable;
    ULONG OldSize;

    OldSize = SizeOfRestartTable(TablePointer);

    //
    //  Get pointer to old table.
    //

    OldTable = TablePointer->Table;
    ASSERT_RESTART_TABLE(OldTable);

    //
    //  Start by initializing a table for the new size.
    //

    InitializeNewTable( OldTable->EntrySize,
                        OldTable->NumberEntries + NumberNewEntries,
                        TablePointer );

    //
    //  Copy body of old table in place to new table.
    //

    NewTable = TablePointer->Table;
    RtlMoveMemory( (NewTable + 1),
                   (OldTable + 1),
                   OldTable->EntrySize * OldTable->NumberEntries );

    //
    //  Fix up new table's header, and fix up free list.
    //

    NewTable->FreeGoal = MAXULONG;
    if (FreeGoal != MAXULONG) {
        NewTable->FreeGoal = sizeof(RESTART_TABLE) + FreeGoal * NewTable->EntrySize;
    }

    if (OldTable->FirstFree != 0) {

        NewTable->FirstFree = OldTable->FirstFree;
        *(PULONG)GetRestartEntryFromIndex( TablePointer, OldTable->LastFree ) =
            OldSize;;
    } else {

        NewTable->FirstFree = OldSize;
    }

    //
    //  Copy number allocated
    //

    NewTable->NumberAllocated = OldTable->NumberAllocated;

    //
    //  Free the old table and return the new one.
    //

    NtfsFreePool( OldTable );

    ASSERT_RESTART_TABLE(NewTable);
}


ULONG
NtfsAllocateRestartTableIndex (
    IN PRESTART_POINTERS TablePointer,
    IN ULONG Exclusive
    )

/*++

Routine Description:

    This routine allocates an index from within a previously initialized
    Restart Table.  If the table is empty, it is extended.

    Note that the table must already be acquired either shared or exclusive,
    and if it must be extended, then the table is released and will be
    acquired exclusive on return.

Arguments:

    TablePointer - Pointer to the Restart Table in which an index is to
                   be allocated.

    Exclusive - Indicates if we have the table exclusive (or if we know that
        synchronization is not a problem).

Return Value:

    The allocated index.

--*/

{
    PRESTART_TABLE Table;
    ULONG EntryIndex;
    KLOCK_QUEUE_HANDLE LockHandle;
    PULONG Entry;

    DebugTrace( +1, Dbg, ("NtfsAllocateRestartTableIndex:\n") );
    DebugTrace( 0, Dbg, ("TablePointer = %08lx\n", TablePointer) );

    Table = TablePointer->Table;
    ASSERT_RESTART_TABLE(Table);

    //
    //  Acquire the spin lock to synchronize the allocation.
    //

    KeAcquireInStackQueuedSpinLock( &TablePointer->SpinLock, &LockHandle );

    //
    //  If the table is empty, then we have to extend it.
    //

    if (Table->FirstFree == 0) {

        //
        //  First release the spin lock and the table resource, and get
        //  the resource exclusive.
        //

        KeReleaseInStackQueuedSpinLock( &LockHandle );

        if (!Exclusive) {

            NtfsReleaseRestartTable( TablePointer );
            NtfsAcquireExclusiveRestartTable( TablePointer, TRUE );
        }

        //
        //  Now extend the table.  Note that if this routine raises, we have
        //  nothing to release.
        //

        NtfsExtendRestartTable( TablePointer, 16, MAXULONG );

        //
        //  And re-get our pointer to the restart table
        //

        Table = TablePointer->Table;

        //
        //  Now get the spin lock again and proceed.
        //

        KeAcquireInStackQueuedSpinLock( &TablePointer->SpinLock, &LockHandle );
    }

    //
    //  Get First Free to return it.
    //

    EntryIndex = Table->FirstFree;

    ASSERT( EntryIndex != 0 );

    //
    //  Dequeue this entry and zero it.
    //

    Entry = (PULONG)GetRestartEntryFromIndex( TablePointer, EntryIndex );

    Table->FirstFree = *Entry;
    ASSERT( Table->FirstFree != RESTART_ENTRY_ALLOCATED );

    RtlZeroMemory( Entry, Table->EntrySize );

    //
    //  Show that it's allocated.
    //

    *Entry = RESTART_ENTRY_ALLOCATED;

    //
    //  If list is going empty, then we fix the LastFree as well.
    //

    if (Table->FirstFree == 0) {

        Table->LastFree = 0;
    }

    Table->NumberAllocated += 1;

    //
    //  Now just release the spin lock before returning.
    //

    KeReleaseInStackQueuedSpinLock( &LockHandle );

    DebugTrace( -1, Dbg, ("NtfsAllocateRestartTableIndex -> %08lx\n", EntryIndex) );

    return EntryIndex;
}


PVOID
NtfsAllocateRestartTableFromIndex (
    IN PRESTART_POINTERS TablePointer,
    IN ULONG Index
    )

/*++

Routine Description:

    This routine allocates a specific index from within a previously
    initialized Restart Table.  If the index does not exist within the
    existing table, the table is extended.

    Note that the table must already be acquired either shared or exclusive,
    and if it must be extended, then the table is released and will be
    acquired exclusive on return.

Arguments:

    TablePointer - Pointer to the Restart Table in which an index is to
                   be allocated.

    Index - The index to be allocated.

Return Value:

    The table entry allocated.

--*/

{
    PULONG Entry;
    PULONG LastEntry;

    PRESTART_TABLE Table;
    KLOCK_QUEUE_HANDLE LockHandle;

    ULONG ThisIndex;
    ULONG LastIndex;

    DebugTrace( +1, Dbg, ("NtfsAllocateRestartTableFromIndex\n") );
    DebugTrace( 0, Dbg, ("TablePointer  = %08lx\n", TablePointer) );
    DebugTrace( 0, Dbg, ("Index         = %08lx\n", Index) );

    Table = TablePointer->Table;
    ASSERT_RESTART_TABLE(Table);

    //
    //  Acquire the spin lock to synchronize the allocation.
    //

    KeAcquireInStackQueuedSpinLock( &TablePointer->SpinLock, &LockHandle );

    //
    //  If the entry is not in the table, we will have to extend the table.
    //

    if (!IsRestartIndexWithinTable( TablePointer, Index )) {

        ULONG TableSize;
        ULONG BytesToIndex;
        ULONG AddEntries;

        //
        //  We extend the size by computing the number of entries
        //  between the existing size and the desired index and
        //  adding 1 to that.
        //

        TableSize = SizeOfRestartTable( TablePointer );;
        BytesToIndex = Index - TableSize;

        AddEntries = BytesToIndex / Table->EntrySize + 1;

        //
        //  There should always be an integral number of entries being added.
        //

        ASSERT( BytesToIndex % Table->EntrySize == 0 );

        //
        //  First release the spin lock and the table resource, and get
        //  the resource exclusive.
        //

        KeReleaseInStackQueuedSpinLock( &LockHandle );
        NtfsReleaseRestartTable( TablePointer );
        NtfsAcquireExclusiveRestartTable( TablePointer, TRUE );

        //
        //  Now extend the table.  Note that if this routine raises, we have
        //  nothing to release.
        //

        NtfsExtendRestartTable( TablePointer,
                                AddEntries,
                                TableSize );

        Table = TablePointer->Table;
        ASSERT_RESTART_TABLE(Table);

        //
        //  Now get the spin lock again and proceed.
        //

        KeAcquireInStackQueuedSpinLock( &TablePointer->SpinLock, &LockHandle );
    }

    //
    //  Now see if the entry is already allocated, and just return if it is.
    //

    Entry = (PULONG)GetRestartEntryFromIndex( TablePointer, Index );

    if (!IsRestartTableEntryAllocated(Entry)) {

        //
        //  We now have to walk through the table, looking for the entry
        //  we're interested in and the previous entry.  Start by looking at the
        //  first entry.
        //

        ThisIndex = Table->FirstFree;

        //
        //  Get the Entry from the list.
        //

        Entry = (PULONG) GetRestartEntryFromIndex( TablePointer, ThisIndex );

        //
        //  If this is a match, then we pull it out of the list and are done.
        //

        if (ThisIndex == Index) {

            //
            //  Dequeue this entry.
            //

            Table->FirstFree = *Entry;
            ASSERT( Table->FirstFree != RESTART_ENTRY_ALLOCATED );

        //
        //  Otherwise we need to walk through the list looking for the
        //  predecessor of our entry.
        //

        } else {

            while (TRUE) {

                //
                //  Remember the entry just found.
                //

                LastIndex = ThisIndex;
                LastEntry = Entry;

                //
                //  We should never run out of entries.
                //

                ASSERT( *LastEntry != 0 );

                //
                //  Lookup up the next entry in the list.
                //

                ThisIndex = *LastEntry;
                Entry = (PULONG) GetRestartEntryFromIndex( TablePointer, ThisIndex );

                //
                //  If this is our match we are done.
                //

                if (ThisIndex == Index) {

                    //
                    //  Dequeue this entry.
                    //

                    *LastEntry = *Entry;

                    //
                    //  If this was the last entry, we update that in the
                    //  table as well.
                    //

                    if (Table->LastFree == ThisIndex) {

                        Table->LastFree = LastIndex;
                    }

                    break;
                }
            }
        }

        //
        //  If the list is now empty, we fix the LastFree as well.
        //

        if (Table->FirstFree == 0) {

            Table->LastFree = 0;
        }

        //
        //  Zero this entry.  Then show that this is allocated and increment the
        //  allocated count.
        //

        RtlZeroMemory( Entry, Table->EntrySize );
        *Entry = RESTART_ENTRY_ALLOCATED;

        Table->NumberAllocated += 1;
    }


    //
    //  Now just release the spin lock before returning.
    //

    KeReleaseInStackQueuedSpinLock( &LockHandle );

    DebugTrace( -1, Dbg, ("NtfsAllocateRestartTableFromIndex -> %08lx\n", Entry) );

    return (PVOID)Entry;
}


VOID
NtfsFreeRestartTableIndex (
    IN PRESTART_POINTERS TablePointer,
    IN ULONG Index
    )

/*++

Routine Description:

    This routine frees a previously allocated index in a Restart Table.
    If the index is before FreeGoal for the table, it is simply deallocated to
    the front of the list for immediate reuse.  If the index is beyond
    FreeGoal, then it is deallocated to the end of the list, to facilitate
    truncation of the list in the event that all of the entries beyond
    FreeGoal are freed.  However, this routine does not automatically
    truncate the list, as this would cause too much overhead.  The list
    is checked during periodic checkpoint processing.

Arguments:

    TablePointer - Pointer to the Restart Table to which the index is to be
                   deallocated.

    Index - The index being deallocated.

Return Value:

    None.

--*/

{
    PRESTART_TABLE Table;
    PULONG Entry, OldLastEntry;
    KLOCK_QUEUE_HANDLE LockHandle;

    DebugTrace( +1, Dbg, ("NtfsFreeRestartTableIndex:\n") );
    DebugTrace( 0, Dbg, ("TablePointer = %08lx\n", TablePointer) );
    DebugTrace( 0, Dbg, ("Index = %08lx\n", Index) );

    //
    //  Get pointers to table and the entry we are freeing.
    //

    Table = TablePointer->Table;
    ASSERT_RESTART_TABLE(Table);

    ASSERT( Table->FirstFree == 0
            || (Table->FirstFree >= 0x18)
                && ((Table->FirstFree - 0x18) % Table->EntrySize) == 0 );

    ASSERT( (Index >= 0x18)
             && ((Index - 0x18) % Table->EntrySize) == 0 );

    Entry = GetRestartEntryFromIndex( TablePointer, Index );

    //
    //  Acquire the spin lock to synchronize the allocation.
    //

    KeAcquireInStackQueuedSpinLock( &TablePointer->SpinLock, &LockHandle );

    //
    //  If the index is before FreeGoal, then do a normal deallocation at
    //  the front of the list.
    //

    if (Index < Table->FreeGoal) {

        *Entry = Table->FirstFree;
        Table->FirstFree = Index;
        if (Table->LastFree == 0) {
            Table->LastFree = Index;
        }

    //
    //  Otherwise we will deallocate this guy to the end of the list.
    //

    } else {

        if (Table->LastFree != 0) {
            OldLastEntry = GetRestartEntryFromIndex( TablePointer,
                                                     Table->LastFree );
            *OldLastEntry = Index;
        } else {
            Table->FirstFree = Index;
        }
        Table->LastFree = Index;
        *Entry = 0;
    }

    Table->NumberAllocated -= 1;

    //
    //  Now just release the spin lock before returning.
    //

    KeReleaseInStackQueuedSpinLock( &LockHandle );

    DebugTrace( -1, Dbg, ("NtfsFreeRestartTableIndex -> VOID\n") );
}


PVOID
NtfsGetFirstRestartTable (
    IN PRESTART_POINTERS TablePointer
    )

/*++

Routine Description:

    This routine returns the first allocated entry from a Restart Table.

Arguments:

    TablePointer - Pointer to the respective Restart Table Pointers structure.

Return Value:

    Pointer to the first entry, or NULL if none are allocated.

--*/

{
    PCHAR Entry;

    PAGED_CODE();

    //
    //  If we know the table is empty, we can return immediately.
    //

    if (IsRestartTableEmpty( TablePointer )) {

        return NULL;
    }

    //
    //  Otherwise point to the first table entry.
    //

    Entry = (PCHAR)(TablePointer->Table + 1);

    //
    //  Loop until we hit the first one allocated, or the end of the list.
    //

    while ((ULONG)(Entry - (PCHAR)TablePointer->Table) <
           SizeOfRestartTable(TablePointer)) {

        if (IsRestartTableEntryAllocated(Entry)) {
            return (PVOID)Entry;
        }

        Entry += TablePointer->Table->EntrySize;
    }

    return NULL;
}


PVOID
NtfsGetNextRestartTable (
    IN PRESTART_POINTERS TablePointer,
    IN PVOID Current
    )

/*++

Routine Description:

    This routine returns the next allocated entry from a Restart Table.

Arguments:

    TablePointer - Pointer to the respective Restart Table Pointers structure.

    Current - Current entry pointer.

Return Value:

    Pointer to the next entry, or NULL if none are allocated.

--*/


{
    PCHAR Entry = (PCHAR)Current;

    PAGED_CODE();

    //
    //  Point to the next entry.
    //

    Entry += TablePointer->Table->EntrySize;

    //
    //  Loop until we hit the first one allocated, or the end of the list.
    //

    while ((ULONG)(Entry - (PCHAR)TablePointer->Table) <
           SizeOfRestartTable(TablePointer)) {

        if (IsRestartTableEntryAllocated(Entry)) {
            return (PVOID)Entry;
        }

        Entry += TablePointer->Table->EntrySize;
    }

    return NULL;
}


VOID
NtfsUpdateOatVersion (
    IN PVCB Vcb,
    IN ULONG NewRestartVersion
    )

/*++

Routine Description:

    This routine is called when we are switching the restart version for a volume.  This can happen
    either after a clean checkpoint or at mount when we encounter a restart area with a non-default
    version number.

Arguments:

    Vcb - Pointer to the Vcb for the volume.

    NewRestartVersion - Restart version to start using for this volume.

Return Value:

    None

--*/

{
    PRESTART_POINTERS NewTable = NULL;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsUpdateOatVersion\n") );

    ASSERT( (Vcb->RestartVersion != NewRestartVersion) || (Vcb->OnDiskOat == NULL) );

    //
    //  Use a try finally to facilitate cleanup.
    //

    try {

        if (NewRestartVersion == 0) {

            //
            //  If we are moving to version 0 then allocate a new table and
            //  initialize it with the initial number of entries.
            //

            NewTable = NtfsAllocatePool( NonPagedPool, sizeof( RESTART_POINTERS ));
            NtfsInitializeRestartTable( sizeof( OPEN_ATTRIBUTE_ENTRY_V0 ),
                                        INITIAL_NUMBER_ATTRIBUTES,
                                        NewTable );

            Vcb->RestartVersion = 0;
            Vcb->OatEntrySize = SIZEOF_OPEN_ATTRIBUTE_ENTRY_V0;
            Vcb->OnDiskOat = NewTable;
            NewTable = NULL;

        } else {

            if (Vcb->OnDiskOat != NULL) {

                NtfsFreeRestartTable( Vcb->OnDiskOat );
                NtfsFreePool( Vcb->OnDiskOat );
            }

            Vcb->OnDiskOat = &Vcb->OpenAttributeTable;
            Vcb->RestartVersion = 1;
            Vcb->OatEntrySize = sizeof( OPEN_ATTRIBUTE_ENTRY );
        }

    } finally {

        DebugUnwind( NtfsUpdateOatVersion );

        if (NewTable != NULL) {

            NtfsFreePool( NewTable );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsUpdateOatVersion -> VOID\n") );

    return;
}


//
//  Internal support routine
//

VOID
DirtyPageRoutine (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN PLSN OldestLsn,
    IN PLSN NewestLsn,
    IN PVOID Context1,
    IN PVOID Context2
    )

/*++

Routine Description:

    This routine is used as the call back routine for retrieving dirty pages
    from the Cache Manager.  It adds them to the Dirty Table list whose
    pointer is pointed to by the Context parameter.

Arguments:

    FileObject - Pointer to the file object which has the dirty page

    FileOffset - File offset for start of dirty page

    Length - Length recorded for the dirty page

    OldestLsn - Oldest Lsn of an update not written through stored for that page

    Context1 - IrpContext

    Context2 - Pointer to the pointer to the Restart Table

Return Value:

    None

--*/

{
    PDIRTY_PAGE_ENTRY PageEntry;
    PRESTART_POINTERS DirtyPageTable = (PRESTART_POINTERS)Context2;
    PSCB_NONPAGED NonpagedScb;
    ULONG PageIndex;

    DebugTrace( +1, Dbg, ("DirtyPageRoutine:\n") );
    DebugTrace( 0, Dbg, ("FileObject = %08lx\n", FileObject) );
    DebugTrace( 0, Dbg, ("FileOffset = %016I64x\n", *FileOffset) );
    DebugTrace( 0, Dbg, ("Length = %08lx\n", Length) );
    DebugTrace( 0, Dbg, ("OldestLsn = %016I64x\n", *OldestLsn) );
    DebugTrace( 0, Dbg, ("Context2 = %08lx\n", Context2) );

    //
    //  Get the Vcb out of the file object.
    //

    NonpagedScb = CONTAINING_RECORD( FileObject->SectionObjectPointer,
                                     SCB_NONPAGED,
                                     SegmentObject );

    //
    //  We noop this call if the open attribute entry for this Scb is 0.  We assume
    //  there was a clean volume checkpoint which cleared this field.
    //

    if (NonpagedScb->OpenAttributeTableIndex == 0 ) {

        DebugTrace( -1, Dbg, ("DirtyPageRoutine -> VOID\n") );
        return;
    }

    //
    //  Get a pointer to the entry we just allocated.
    //

    PageIndex = NtfsAllocateRestartTableIndex( DirtyPageTable, TRUE );
    PageEntry = GetRestartEntryFromIndex( DirtyPageTable, PageIndex );

    //
    //  Now fill in the Dirty Page Entry, except for the Lcns, because
    //  we are not allowed to take page faults now.
    //  Use the index for the in-memory table now.  We will update
    //  this to the on-disk index back in CheckpointVolume.
    //

    PageEntry->TargetAttribute = NonpagedScb->OpenAttributeTableIndex;
    ASSERT( NonpagedScb->OnDiskOatIndex != 0 );

    PageEntry->LengthOfTransfer = Length;

    //
    //  Put the Vcn (FileOffset) and OldestLsn into the page at this point.  Note
    //  we don't want to put an Lsn into the table which is older than the current
    //  BaseLsn.  Store it here for now and we will fix it up when we process the
    //  DiryPage table back in the checkpoint code.
    //

    if (NonpagedScb->Vcb->RestartVersion == 0) {

        ((PDIRTY_PAGE_ENTRY_V0) PageEntry)->Vcn = FileOffset->QuadPart;
        ((PDIRTY_PAGE_ENTRY_V0) PageEntry)->OldestLsn = *OldestLsn;

    } else {

        PageEntry->Vcn = FileOffset->QuadPart;
        PageEntry->OldestLsn = *OldestLsn;
    }

    DebugTrace( -1, Dbg, ("DirtyPageRoutine -> VOID\n") );
    return;

    UNREFERENCED_PARAMETER( Context1 );
    UNREFERENCED_PARAMETER( NewestLsn );
}


//
//  Internal support routine
//

BOOLEAN
LookupLcns (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN VCN Vcn,
    IN ULONG ClusterCount,
    IN BOOLEAN MustBeAllocated,
    OUT PLCN_UNALIGNED FirstLcn
    )

/*++

Routine Description:

    This routine looks up the Lcns for a range of Vcns, and stores them in
    an output array.  One Lcn is stored for each Vcn in the range, even
    if the Lcns are contiguous.

Arguments:

    Scb - Scb for stream on which lookup should occur.

    Vcn - Start of range of Vcns to look up.

    ClusterCount - Number of Vcns to look up.

    MustBeAllocated - FALSE - if need not be allocated, and should check Mcb only
                      TRUE - if it must be allocated as far as caller knows (i.e.,
                             NtfsLookupAllocation also has checks)

    FirstLcn - Pointer to storage for first Lcn.  The caller must guarantee
               that there is enough space to store ClusterCount Lcns.

Return Value:

    BOOLEAN - TRUE if we found the clusters, FALSE otherwise.

--*/

{
    BOOLEAN Allocated;
    LONGLONG Clusters;
    LCN Lcn;
    ULONG i;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("LookupLcns:\n") );
    DebugTrace( 0, Dbg, ("Scb = %08l\n", Scb) );
    DebugTrace( 0, Dbg, ("Vcn = %016I64x\n", Vcn) );
    DebugTrace( 0, Dbg, ("ClusterCount = %08l\n", ClusterCount) );
    DebugTrace( 0, Dbg, ("FirstLcn = %08lx\n", FirstLcn) );

    //
    //  Loop until we have looked up all of the clusters
    //

    while (ClusterCount != 0) {

        if (MustBeAllocated) {

            //
            //  Lookup the next run.
            //

            Allocated = NtfsLookupAllocation( IrpContext,
                                              Scb,
                                              Vcn,
                                              &Lcn,
                                              &Clusters,
                                              NULL,
                                              NULL );

            ASSERT( Lcn != 0 );

            //
            //  Raise if this case not met.  Otherwise we could walk off the end
            //  of the LCN array.
            //

            if (!Allocated) {

                return FALSE;

            } else if (Lcn == 0) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
            }

        } else {

           Allocated = NtfsLookupNtfsMcbEntry( &Scb->Mcb, Vcn, &Lcn, &Clusters, NULL, NULL, NULL, NULL );

           //
           //   If we are off the end of the Mcb, then set up to just return
           //   Li0 for as many Lcns as are being looked up.
           //

           if (!Allocated ||
               (Lcn == UNUSED_LCN)) {
               Lcn = 0;
               Clusters = ClusterCount;
               Allocated = FALSE;
           }
        }

        //
        //  If we got as many clusters as we were looking for, then just
        //  take the number we were looking for.
        //

        if (Clusters > ClusterCount) {

            Clusters = ClusterCount;
        }

        //
        //  Fill in the Lcns in the header.
        //

        for (i = 0; i < (ULONG)Clusters; i++) {

            *(FirstLcn++) = Lcn;

            if (Allocated) {
                Lcn = Lcn + 1;
            }
        }

        //
        //  Adjust loop variables for the number Lcns we just received.
        //

        Vcn = Vcn + Clusters;
        ClusterCount -= (ULONG)Clusters;
    }

    DebugTrace( -1, Dbg, ("LookupLcns -> VOID\n") );

    return TRUE;
}


VOID
InitializeNewTable (
    IN ULONG EntrySize,
    IN ULONG NumberEntries,
    OUT PRESTART_POINTERS TablePointer
    )

/*++

Routine Description:

    This routine is called to allocate and initialize a new table when the
    associated Restart Table is being allocated or extended.

Arguments:

    EntrySize - Size of the table entries, in bytes.

    NumberEntries - Number of entries to allocate for the table.

    TablePointer - Returns a pointer to the table.

Return Value:

    None

--*/

{
    PRESTART_TABLE Table;
    PULONG Entry;
    ULONG Size;
    ULONG Offset;

    ASSERT( EntrySize != 0 );

    //
    //  Calculate size of table to allocate.
    //

    Size = EntrySize * NumberEntries + sizeof(RESTART_TABLE);

    //
    //  Allocate and zero out the table.
    //

    Table =
    TablePointer->Table = NtfsAllocatePool( NonPagedPool, Size );

    RtlZeroMemory( Table, Size );

    //
    //  Initialize the table header.
    //

    Table->EntrySize = (USHORT)EntrySize;
    Table->NumberEntries = (USHORT)NumberEntries;
    Table->FreeGoal = MAXULONG;
    Table->FirstFree = sizeof(RESTART_TABLE);
    Table->LastFree = Table->FirstFree + (NumberEntries - 1) * EntrySize;

    //
    //  Initialize the free list.
    //

    for (Entry = (PULONG)(Table + 1), Offset = sizeof(RESTART_TABLE) + EntrySize;
         Entry < (PULONG)((PCHAR)Table + Table->LastFree);
         Entry = (PULONG)((PCHAR)Entry + EntrySize), Offset += EntrySize) {

        *Entry = Offset;
    }

    ASSERT_RESTART_TABLE(Table);
}



VOID
NtfsFreeRecentlyDeallocated (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PLSN BaseLsn,
    IN ULONG CleanVolume
    )
/*++

Routine Description:

    Free up recently deallocated clusters for reuse

Arguments:

    IrpContext -

    Vcb -  volume to clean up

    BaseLsn - the lsn we're up to now in the logfile, used to determine what can be freed
              and the new threshold for future frees

    CleanVolume - if true the volume is being clean checkpointed and all the clusters can be freed

Return Value:

    None

--*/
{
    PDEALLOCATED_CLUSTERS Clusters;
    BOOLEAN RemovedClusters = FALSE;

    PAGED_CODE();

    //
    //  Quick exit if the list is empty
    //

    if (IsListEmpty( &Vcb->DeallocatedClusterListHead ) || (Vcb->BitmapScb == NULL)) {
        return;
    }

    NtfsAcquireExclusiveScb( IrpContext, Vcb->BitmapScb );

    Clusters = (PDEALLOCATED_CLUSTERS)Vcb->DeallocatedClusterListHead.Blink;

    //
    //  Now we want to check if we can release any of the clusters in the
    //  deallocated cluster arrays.  We know we can look at the
    //  fields in the PriorDeallocatedClusters structure because they
    //  are never modified in the running system.
    //
    //  We will continue from the oldest in the list list until
    //
    //   1) there are no more dealloc lists
    //   2) there are no clusters in the dealloc list (it must be the only one at this point)
    //   3) the lsn == 0 and we're dirty which means we're at the front
    //   4) the lsn is newer in deallocated cluster list
    //

    try {

        while ((!IsListEmpty( &Vcb->DeallocatedClusterListHead )) &&
               (Clusters->ClusterCount > 0) &&
               (((Clusters->Lsn.QuadPart != 0) && (BaseLsn->QuadPart > Clusters->Lsn.QuadPart)) ||
                CleanVolume)) {

            RemovedClusters = TRUE;

            //
            //  For all deallocated during clean checkpoints and non-most recent
            //  ones during fuzzt ones:
            //  Remove all of the mappings in the Mcb.  Protect this with
            //  a try-except.
            //

            try {

                try {
                    ULONG i;
                    ULONGLONG StartingVcn;
                    ULONGLONG StartingLcn;
                    ULONGLONG ClusterCount;

                    for (i = 0; FsRtlGetNextLargeMcbEntry( &Clusters->Mcb, i, &StartingVcn, &StartingLcn, &ClusterCount ); i += 1) {

                        if (StartingVcn == StartingLcn) {

                            if (NtfsAddCachedRun( IrpContext,
                                                  Vcb,
                                                  StartingLcn,
                                                  ClusterCount,
                                                  RunStateFree ) <= 0) break;
                        }
                    }

                } finally {

                    PDEALLOCATED_CLUSTERS NextClusters = (PDEALLOCATED_CLUSTERS)Clusters->Link.Blink;

                    //
                    //  We are committed to freeing the clusters out of the PriorDeallocatedClusters
                    //  in any case.
                    //

                    Vcb->DeallocatedClusters -= Clusters->ClusterCount;

                    //
                    //  Move this cluster list out of the vcb
                    //

                    RemoveEntryList( &Clusters->Link );

#ifdef BENL_DBG
//                    KdPrint(( "NTFS: freeing dealloc clusters: 0x%x LSN: 0x%x\n", Clusters, Clusters->Lsn ));
#endif

                    //
                    //  delete dynamic clusters lists / reset static ones
                    //

                    if ((Clusters != &Vcb->DeallocatedClusters1) && (Clusters != &Vcb->DeallocatedClusters2 )) {

                        FsRtlUninitializeLargeMcb( &Clusters->Mcb );
                        NtfsFreePool( Clusters );
                    } else {
                        Clusters->Link.Flink = NULL;
                        Clusters->ClusterCount = 0;
                        FsRtlResetLargeMcb( &Clusters->Mcb, TRUE );
                    }
                    ASSERT( Vcb->DeallocatedClusters >= 0 );

                    Clusters = NextClusters;
                }

            } except( NtfsCatchOutOfMemoryExceptionFilter( IrpContext, GetExceptionInformation() )) {

                //
                //  Keep going even if out of memory
                //

                NtfsMinimumExceptionProcessing( IrpContext );
                NOTHING;
            }
        }

        //
        //  If we removed any clusters on a fuzzy checkpoint lets make a new active one so
        //  the current active one can be cleaned up eventually
        //  On a clean checkpoint if we removed all the nodes add a blank one back
        //

        if (!CleanVolume) {

            ASSERT( !IsListEmpty( &Vcb->DeallocatedClusterListHead ) );

            if (RemovedClusters && (Clusters->ClusterCount > 0)) {
                Clusters = NtfsGetDeallocatedClusters( IrpContext, Vcb );
            }

        } else if (IsListEmpty( &Vcb->DeallocatedClusterListHead)) {

#ifdef BENL_DBG
//            KdPrint(( "NTFS: adding extra dealloc clusters after clean chkpt: 0x%x\n", &Vcb->DeallocatedClusters1 ));
#endif

            ASSERT( Vcb->DeallocatedClusters1.Link.Flink == NULL );

            Vcb->DeallocatedClusters1.Lsn.QuadPart = 0;
            InsertHeadList( &Vcb->DeallocatedClusterListHead, &Vcb->DeallocatedClusters1.Link );
        }

    } finally {

        NtfsReleaseScb( IrpContext, Vcb->BitmapScb );

    }
}



VOID
NtfsCleanupFailedTransaction (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine is called to cleanup the IrpContext and free structures
    in the event a transaction fails to commit or abort.

Arguments:

Return Value:

    None

--*/

{
    PUSN_FCB ThisUsn;
    PUSN_FCB LastUsn;

    PAGED_CODE();

    //
    //  Clear the flags indicating a transaction is underway.
    //

    ClearFlag( IrpContext->Flags,
               IRP_CONTEXT_FLAG_WROTE_LOG | IRP_CONTEXT_FLAG_RAISED_STATUS | IRP_CONTEXT_FLAG_MODIFIED_BITMAP );

    //
    //  Make sure the recently deallocated queue is empty.
    //

    try {

        if (!IsListEmpty( &IrpContext->RecentlyDeallocatedQueue )) {

            NtfsDeallocateRecordsComplete( IrpContext );
        }

    } except (FsRtlIsNtstatusExpected( GetExceptionCode() ) ?
              EXCEPTION_EXECUTE_HANDLER :
              EXCEPTION_CONTINUE_SEARCH) {

        NOTHING;
    }

    //
    //  Show that we haven't deallocated any clusters.
    //

    IrpContext->DeallocatedClusters = 0;
    IrpContext->FreeClusterChange = 0;

    //
    //  Don't rollback any size changes.
    //

    try {

        NtfsUpdateScbSnapshots( IrpContext );

    } except (FsRtlIsNtstatusExpected( GetExceptionCode() ) ?
              EXCEPTION_EXECUTE_HANDLER :
              EXCEPTION_CONTINUE_SEARCH) {

        NOTHING;
    }

    //
    //  Make sure the last restart area is zeroed.
    //

    IrpContext->LastRestartArea.QuadPart = 0;

    //
    //  Pull the Usn Fcb fields.
    //

    ThisUsn = &IrpContext->Usn;

    try {

        do {

            if (ThisUsn->CurrentUsnFcb != NULL) {

                PFCB UsnFcb = ThisUsn->CurrentUsnFcb;

                NtfsLockFcb( IrpContext, UsnFcb );

                //
                //  If any rename flags are part of the new reasons then
                //  make sure to look the name up again.
                //

                if (FlagOn( ThisUsn->NewReasons,
                            USN_REASON_RENAME_NEW_NAME | USN_REASON_RENAME_OLD_NAME )) {

                    ClearFlag( UsnFcb->FcbState, FCB_STATE_VALID_USN_NAME );
                }

                //
                //  Now restore the reason and source info fields.
                //

                ClearFlag( UsnFcb->FcbUsnRecord->UsnRecord.Reason,
                           ThisUsn->NewReasons );
                if (UsnFcb->FcbUsnRecord->UsnRecord.Reason == 0) {

                    UsnFcb->FcbUsnRecord->UsnRecord.SourceInfo = 0;

                } else {

                    SetFlag( UsnFcb->FcbUsnRecord->UsnRecord.SourceInfo,
                             ThisUsn->RemovedSourceInfo );
                }

                NtfsUnlockFcb( IrpContext, UsnFcb );

                //
                //  Zero out the structure.
                //

                ThisUsn->CurrentUsnFcb = NULL;
                ThisUsn->NewReasons = 0;
                ThisUsn->RemovedSourceInfo = 0;
                ThisUsn->UsnFcbFlags = 0;

                if (ThisUsn != &IrpContext->Usn) {

                    LastUsn->NextUsnFcb = ThisUsn->NextUsnFcb;
                    NtfsFreePool( ThisUsn );
                    ThisUsn = LastUsn;
                }
            }

            if (ThisUsn->NextUsnFcb == NULL) { break; }

            LastUsn = ThisUsn;
            ThisUsn = ThisUsn->NextUsnFcb;

        } while (TRUE);

    } except (FsRtlIsNtstatusExpected( GetExceptionCode() ) ?
              EXCEPTION_EXECUTE_HANDLER :
              EXCEPTION_CONTINUE_SEARCH) {

        NOTHING;
    }

    //
    //  Don't wake any waiters for this failed operation.
    //

    try {

        if (IrpContext->CheckNewLength != NULL) {

            NtfsProcessNewLengthQueue( IrpContext, TRUE );
        }

    } except (FsRtlIsNtstatusExpected( GetExceptionCode() ) ?
              EXCEPTION_EXECUTE_HANDLER :
              EXCEPTION_CONTINUE_SEARCH) {

        NOTHING;
    }

    //
    //  Remove this from the transaction table if present.
    //

    if (IrpContext->TransactionId != 0) {

        NtfsAcquireExclusiveRestartTable( &IrpContext->Vcb->TransactionTable,
                                          TRUE );

        NtfsFreeRestartTableIndex( &IrpContext->Vcb->TransactionTable,
                                   IrpContext->TransactionId );

        NtfsReleaseRestartTable( &IrpContext->Vcb->TransactionTable );

        IrpContext->TransactionId = 0;
    }

    IrpContext->ExceptionStatus = STATUS_SUCCESS;
    return;
}


//
//  Local support routine
//

LONG
NtfsCatchOutOfMemoryExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    )

/*++

Routine Description:

    Exception filter for out of memory errors. This will swallow 0xC0000009A's and let
    all other exceptions filter on

Arguments:

    IrpContext  - IrpContext

    ExceptionPointer - Pointer to the exception context.


Return Value:

    Exception status - EXCEPTION_CONTINUE_SEARCH if we want to raise to another handler,
        EXCEPTION_EXECUTE_HANDLER if we plan to proceed on.

--*/

{
    UNREFERENCED_PARAMETER( IrpContext );

    if (ExceptionPointer->ExceptionRecord->ExceptionCode != STATUS_INSUFFICIENT_RESOURCES) {
        return EXCEPTION_CONTINUE_SEARCH;
    }

    return EXCEPTION_EXECUTE_HANDLER;
}


//
//  Local support routine
//

LONG
NtfsCheckpointExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer,
    IN NTSTATUS ExceptionCode
    )

{
    //
    //  Swallow all expected errors if this is a dismount doing a log file full.
    //

    if ((FlagOn( IrpContext->State, IRP_CONTEXT_STATE_DISMOUNT_LOG_FLUSH )) &&
        (FsRtlIsNtstatusExpected( ExceptionCode ))) {

        return EXCEPTION_EXECUTE_HANDLER;

    } else {

        return EXCEPTION_CONTINUE_SEARCH;
    }

    UNREFERENCED_PARAMETER( ExceptionPointer );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\namesup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    NameSup.c

Abstract:

    This module implements the Ntfs Name support routines

Author:

    Gary Kimura [GaryKi] & Tom Miller [TomM]    20-Feb-1990

Revision History:

--*/

#include "NtfsProc.h"

#define Dbg                              (DEBUG_TRACE_NAMESUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCollateNames)
#pragma alloc_text(PAGE, NtfsIsFatNameValid)
#pragma alloc_text(PAGE, NtfsIsFileNameValid)
#pragma alloc_text(PAGE, NtfsParseName)
#pragma alloc_text(PAGE, NtfsParsePath)
#pragma alloc_text(PAGE, NtfsUpcaseName)
#endif

#define MAX_CHARS_IN_8_DOT_3    (12)


PARSE_TERMINATION_REASON
NtfsParsePath (
    IN UNICODE_STRING Path,
    IN BOOLEAN WildCardsPermissible,
    OUT PUNICODE_STRING FirstPart,
    OUT PNTFS_NAME_DESCRIPTOR Name,
    OUT PUNICODE_STRING RemainingPart
    )

/*++

Routine Description:

    This routine takes as input a path.  Each component of the path is
    checked until either:

        - The end of the path has been reached, or

        - A well formed complex name is excountered, or

        - An illegal character is encountered, or

        - A complex name component is malformed

    At this point the return value is set to one of the three reasons
    above, and the arguments are set as follows:

        FirstPart:     All the components up to one containing an illegal
                       character or colon character.  May be the whole path.

        Name:          The "pieces" of a component containing an illegal
                       character or colon character.  This name is actually
                       a struncture containing the four pieces of a name,
                       "file name, attribute type, attribute name, version
                       number."  In the example below, they are shown
                       separated by plus signs.

        RemainingPart: All the remaining components.

    A preceding or trailing backslash is ignored during processing and
    stripped in either FirstPart or RemainingPart.  Following are some
    examples of this routine's actions.

    Path                         FirstPart Name                   Remaining
    ================             ========= ============           =========

    \nt\pri\os                   \nt\pri\os                        <empty>

    \nt\pri\os\                  \nt\pri\os                        <empty>

    nt\pri\os                    \nt\pri\os                        <empty>

    \nt\pr"\os                   \nt        pr"                    os

    \nt\pri\os:contr::3\ntfs     \nt\pri    os + contr + + 3       ntfs

    \nt\pri\os\circle:pict:circ  \nt\pri\os circle + pict + circ   <empty>

Arguments:

    Path - This unicode string descibes the path to parse.  Note that path
        here may only describe a single component.

    WildCardsPermissible - This parameter tells us if wild card characters
        should be considered legal.

    FirstPart - This unicode string will receive portion of the path, up to
        a component boundry,  successfully parsed before the parse terminated.
        Note that store for this string comes from the Path parameter.

    Name - This is the name we were parsing when we reached our termination
        condition.  It is a srtucture of strings that receive the file name,
        attribute type, attribute name, and version number respectively.
        It wil be filled in only to the extent that the parse succeeded.  For
        example, in the case we encounter an illegal character in the
        attribute type field, only the file name field will be filled in.
        This may signal a special control file, and this possibility must be
        investigated by the file system.

    RemainingPart - This string will receive any portion of the path, starting
        at the first component boundry after the termination name, not parsed.
        It will often be an empty string.

ReturnValue:

    An enumerated type with one of the following values:

        EndOfPathReached       - The path was fully parsed.  Only first part
                                 is filled in.
        NonSimpleName          - A component of the path containing a legal,
                                 well formed non-simple name was encountered.
        IllegalCharacterInName - An illegal character was encountered.  Parsing
                                 stops immediately.
        MalFormedName          - A non-simple name did not conform to the
                                 correct format.  This may be a result of too
                                 many fields, or a malformed version number.
        AttributeOnly          - A component of the path containing a legal
                                 well formed non-simple name was encountered
                                 which does not have a file name.
        VersionNumberPresent   - A component of the path containing a legal
                                 well formed non-simple name was encountered
                                 which contains a version number.

--*/

{
    UNICODE_STRING FirstName;

    BOOLEAN WellFormed;
    BOOLEAN MoreNamesInPath;
    BOOLEAN FirstIteration;
    BOOLEAN FoundIllegalCharacter;

    PARSE_TERMINATION_REASON TerminationReason;

    PAGED_CODE();

    //
    //  Initialize some loacal variables and OUT parameters.
    //

    FirstIteration = TRUE;
    MoreNamesInPath = TRUE;

    //
    //  Clear the fieldspresent flag in the name descriptor.
    //

    Name->FieldsPresent = 0;

    //
    //  By default, set the returned first part to start at the beginning of
    //  the input buffer and include a leading backslash.
    //

    FirstPart->Buffer = Path.Buffer;

    if (Path.Buffer[0] == L'\\') {

        FirstPart->Length = 2;
        FirstPart->MaximumLength = 2;

    } else {

        FirstPart->Length = 0;
        FirstPart->MaximumLength = 0;
    }

    //
    //  Do the first check outside the loop in case we are given a backslash
    //  by itself.
    //

    if (FirstPart->Length == Path.Length) {

        RemainingPart->Length = 0;
        RemainingPart->Buffer = &Path.Buffer[Path.Length >> 1];

        return EndOfPathReached;
    }

    //
    //  Crack the path, checking each componant
    //

    while (MoreNamesInPath) {

        FsRtlDissectName( Path, &FirstName, RemainingPart );

        MoreNamesInPath = (BOOLEAN)(RemainingPart->Length != 0);

        //
        //  If this is not the last name in the path, then attributes
        //  and version numbers are not allowed.  If this is the last
        //  name then propagate the callers arguments.
        //

        WellFormed = NtfsParseName( FirstName,
                                    WildCardsPermissible,
                                    &FoundIllegalCharacter,
                                    Name );

        //
        //  Check the cases when we will break out of this loop, ie. if the
        //  the name was not well formed or it was non-simple.
        //

        if ( !WellFormed ||
             (Name->FieldsPresent != FILE_NAME_PRESENT_FLAG)

             //
             // TEMPCODE    TRAILING_DOT
             //

             || (Name->FileName.Length != Name->FileName.MaximumLength)

             ) {

            break;
        }

        //
        //  We will continue parsing this string, so consider the current
        //  FirstName to be parsed and add it to FirstPart.  Also reset
        //  the Name->FieldsPresent variable.
        //

        if ( FirstIteration ) {

            FirstPart->Length += FirstName.Length;
            FirstIteration = FALSE;

        } else {

            FirstPart->Length += (sizeof(WCHAR) + FirstName.Length);
        }

        FirstPart->MaximumLength = FirstPart->Length;

        Path = *RemainingPart;
    }

    //
    //  At this point FirstPart, Name, and RemainingPart should all be set
    //  correctly.  It remains, only to generate the correct return value.
    //

    if ( !WellFormed ) {

        if ( FoundIllegalCharacter ) {

            TerminationReason = IllegalCharacterInName;

        } else {

            TerminationReason = MalFormedName;
        }

    } else {

        if ( Name->FieldsPresent == FILE_NAME_PRESENT_FLAG ) {

            //
            //  TEMPCODE    TRAILING_DOT
            //

            if (Name->FileName.Length != Name->FileName.MaximumLength) {

                TerminationReason = NonSimpleName;

            } else {

                TerminationReason = EndOfPathReached;
            }

        } else if (FlagOn( Name->FieldsPresent, VERSION_NUMBER_PRESENT_FLAG )) {

            TerminationReason = VersionNumberPresent;

        } else if (!FlagOn( Name->FieldsPresent, FILE_NAME_PRESENT_FLAG )) {

            TerminationReason = AttributeOnly;

        } else {

            TerminationReason = NonSimpleName;
        }

    }

    return TerminationReason;
}


BOOLEAN
NtfsParseName (
    IN const UNICODE_STRING Name,
    IN BOOLEAN WildCardsPermissible,
    OUT PBOOLEAN FoundIllegalCharacter,
    OUT PNTFS_NAME_DESCRIPTOR ParsedName
    )

/*++

Routine Description:

    This routine takes as input a single name component.  It is processed into
    file name, attribute type, attribute name, and version number fields.

    If the name is well formed according to the following rules:

        A. An NTFS name may not contain any of the following characters:

           0x0000-0x001F " / < > ? | *

        B. An Ntfs name can take any of the following forms:

            ::T
            :A
            :A:T
            N
            N:::V
            N::T
            N::T:V
            N:A
            N:A::V
            N:A:T
            N:A:T:V

           If a version number is present, there must be a file name.
           We specifically note the legal names without a filename
           component (AttributeOnly) and any name with a version number
           (VersionNumberPresent).

           Incidently, N corresponds to file name, T to attribute type, A to
           attribute name, and V to version number.

    TRUE is returned.  If FALSE is returned, then the OUT parameter
    FoundIllegalCharacter will be set appropriatly.  Note that the buffer
    space for ParsedName comes from Name.

Arguments:

    Name - This is the single path element input name.

    WildCardsPermissible - This determines if wild cards characters should be
        considered legal

    FoundIllegalCharacter - This parameter will receive a TRUE if the the
        function returns FALSE because of encountering an illegal character.

    ParsedName - Recieves the pieces of the processed name.  Note that the
        storage for all the string from the input Name.

ReturnValue:

    TRUE if the Name is well formed, and FALSE otherwise.


--*/

{
    ULONG Index;
    ULONG NameLength;
    ULONG FieldCount;
    ULONG FieldIndexes[5];
    UCHAR ValidCharFlags = FSRTL_NTFS_LEGAL;

    PULONG Fields;

    BOOLEAN IsNameValid = TRUE;

    PAGED_CODE();

    //
    // Initialize some OUT parameters and local variables.
    //

    *FoundIllegalCharacter = FALSE;

    Fields = &ParsedName->FieldsPresent;

    *Fields = 0;

    FieldCount = 1;

    FieldIndexes[0] = 0xFFFFFFFF;   //  We add on to this later...

    //
    //  For starters, zero length names are invalid.
    //

    NameLength = Name.Length / sizeof(WCHAR);

    if ( NameLength == 0 ) {

        return FALSE;
    }

    //
    //  Now name must correspond to a legal single Ntfs Name.
    //

    for (Index = 0; Index < NameLength; Index += 1) {

        WCHAR Char;

        Char = Name.Buffer[Index];

        //
        //  First check that file names are well formed in terms of colons.
        //

        if ( Char == L':' ) {

            //
            //  A colon can't be the last character, and we can't have
            //  more than three colons.
            //

            if ( (Index == NameLength - 1) ||
                 (FieldCount >= 4) ) {

                IsNameValid = FALSE;
                break;
            }

            FieldIndexes[FieldCount] = Index;

            FieldCount += 1;
            ValidCharFlags = FSRTL_NTFS_STREAM_LEGAL;

            continue;
        }

        //
        //  Now check for wild card characters if they weren't allowed,
        //  and other illegal characters.
        //

        if ((Char <= 0xff) &&
            !FsRtlTestAnsiCharacter( Char, TRUE, WildCardsPermissible, ValidCharFlags )) {

            IsNameValid = FALSE;
            *FoundIllegalCharacter = TRUE;
            break;
        }
    }

    //
    //  If we ran into a problem with one of the fields, don't try to load
    //  up that field into the out parameter.
    //

    if ( !IsNameValid ) {

        FieldCount -= 1;

    //
    //  Set the end of the last field to the current Index.
    //

    } else {

        FieldIndexes[FieldCount] = Index;
    }

    //
    //  Now we load up the OUT parmeters
    //

    while ( FieldCount != 0 ) {

        ULONG StartIndex;
        ULONG EndIndex;
        USHORT Length;

        //
        //  Add one here since this is actually the position of the colon.
        //

        StartIndex = FieldIndexes[FieldCount - 1] + 1;

        EndIndex = FieldIndexes[FieldCount];

        Length = (USHORT)((EndIndex - StartIndex) * sizeof(WCHAR));

        //
        //  If this field is empty, skip it
        //

        if ( Length == 0 ) {

            FieldCount -= 1;
            continue;
        }

        //
        //  Now depending of the field, extract the appropriate information.
        //

        if ( FieldCount == 1 ) {

            UNICODE_STRING TempName;

            TempName.Buffer = &Name.Buffer[StartIndex];
            TempName.Length = Length;
            TempName.MaximumLength = Length;

            //
            //  If the resulting length is 0, forget this entry.
            //

            if (TempName.Length == 0) {

                FieldCount -= 1;
                continue;
            }

            SetFlag(*Fields, FILE_NAME_PRESENT_FLAG);

            ParsedName->FileName = TempName;

        } else if ( FieldCount == 2) {

            SetFlag(*Fields, ATTRIBUTE_NAME_PRESENT_FLAG);

            ParsedName->AttributeName.Buffer = &Name.Buffer[StartIndex];
            ParsedName->AttributeName.Length = Length;
            ParsedName->AttributeName.MaximumLength = Length;

        } else if ( FieldCount == 3) {

            SetFlag(*Fields, ATTRIBUTE_TYPE_PRESENT_FLAG);

            ParsedName->AttributeType.Buffer = &Name.Buffer[StartIndex];
            ParsedName->AttributeType.Length = Length;
            ParsedName->AttributeType.MaximumLength = Length;

        } else if ( FieldCount == 4) {

            ULONG VersionNumber;
            STRING VersionNumberA;
            UNICODE_STRING VersionNumberU;

            NTSTATUS Status;
            UCHAR *endp = NULL;

            VersionNumberU.Buffer = &Name.Buffer[StartIndex];
            VersionNumberU.Length = Length;
            VersionNumberU.MaximumLength = Length;

            //
            //  Note that the resulting Ansi string is null terminated.
            //

            Status = RtlUnicodeStringToCountedOemString( &VersionNumberA,
                                                  &VersionNumberU,
                                                  TRUE );

            //
            //  If something went wrong (most likely ran out of pool), raise.
            //

            if ( !NT_SUCCESS(Status) ) {

                ExRaiseStatus( Status );
            }

            VersionNumber = 0; //**** strtoul( VersionNumberA.Buffer, &endp, 0 );

            RtlFreeOemString( &VersionNumberA );

            if ( (VersionNumber == MAXULONG) || (endp != NULL) ) {

                IsNameValid = FALSE;

            } else {

                SetFlag( *Fields, VERSION_NUMBER_PRESENT_FLAG );
                ParsedName->VersionNumber = VersionNumber;
            }
        }

        FieldCount -= 1;
    }

    //
    //  Check for special malformed cases.
    //

    if (FlagOn( *Fields, VERSION_NUMBER_PRESENT_FLAG )
        && !FlagOn( *Fields, FILE_NAME_PRESENT_FLAG )) {

        IsNameValid = FALSE;
    }

    return IsNameValid;
}


VOID
NtfsUpcaseName (
    IN PWCH UpcaseTable,
    IN ULONG UpcaseTableSize,
    IN OUT PUNICODE_STRING Name
    )

/*++

Routine Description:

    This routine upcases a string.

Arguments:

    UpcaseTable - Pointer to an array of Unicode upcased characters indexed by
                  the Unicode character to be upcased.

    UpcaseTableSize - Size of the Upcase table in unicode characters

    Name - Supplies the string to upcase

Return Value:

    None.

--*/

{
    ULONG i;
    ULONG Length;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsUpcaseName\n") );
    DebugTrace( 0, Dbg, ("Name = %Z\n", Name) );

    Length = Name->Length / sizeof(WCHAR);

    for (i=0; i < Length; i += 1) {

        if ((ULONG)Name->Buffer[i] < UpcaseTableSize) {
            Name->Buffer[i] = UpcaseTable[ (ULONG)Name->Buffer[i] ];
        }
    }

    DebugTrace( 0, Dbg, ("Upcased Name = %Z\n", Name) );
    DebugTrace( -1, Dbg, ("NtfsUpcaseName -> VOID\n") );

    return;
}


FSRTL_COMPARISON_RESULT
NtfsCollateNames (
    IN PCWCH UpcaseTable,
    IN ULONG UpcaseTableSize,
    IN PCUNICODE_STRING Expression,
    IN PCUNICODE_STRING Name,
    IN FSRTL_COMPARISON_RESULT WildIs,
    IN BOOLEAN IgnoreCase
    )

/*++

Routine Description:

    This routine compares an expression with a name lexigraphically for
    LessThan, EqualTo, or GreaterThan.  If the expression does not contain
    any wildcards, this procedure does a complete comparison.  If the
    expression does contain wild cards, then the comparison is only done up
    to the first wildcard character.  Name may not contain wild cards.
    The wildcard character compares as less then all other characters.  So
    the wildcard name "*.*" will always compare less than all all strings.

Arguments:

    UpcaseTable - Pointer to an array of Unicode upcased characters indexed by
                  the Unicode character to be upcased.

    UpcaseTableSize - Size of the Upcase table in unicode characters

    Expression - Supplies the first name expression to compare, optionally with
                 wild cards.  Note that caller must have already upcased
                 the name (this will make lookup faster).

    Name - Supplies the second name to compare - no wild cards allowed.
           The caller must have already upcased the name.

    WildIs - Determines what Result is returned if a wild card is encountered
             in the Expression String.  For example, to find the start of
             an expression in the Btree, LessThan should be supplied; then
             GreaterThan should be supplied to find the end of the expression
             in the tree.

    IgnoreCase - TRUE if case should be ignored for the comparison

Return Value:

    FSRTL_COMPARISON_RESULT - LessThan    if Expression <  Name
                              EqualTo     if Expression == Name
                              GreaterThan if Expression >  Name

--*/

{
    WCHAR ConstantChar;
    WCHAR ExpressionChar;

    ULONG i;
    ULONG Length;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCollateNames\n") );
    DebugTrace( 0, Dbg, ("Expression = %Z\n", Expression) );
    DebugTrace( 0, Dbg, ("Name       = %Z\n", Name) );
    DebugTrace( 0, Dbg, ("WildIs     = %08lx\n", WildIs) );
    DebugTrace( 0, Dbg, ("IgnoreCase = %02lx\n", IgnoreCase) );

    //
    //  Calculate the length in wchars that we need to compare.  This will
    //  be the smallest length of the two strings.
    //

    if (Expression->Length < Name->Length) {

        Length = Expression->Length / sizeof(WCHAR);

    } else {

        Length = Name->Length / sizeof(WCHAR);
    }

    //
    //  Now we'll just compare the elements in the names until we can decide
    //  their lexicagrahical ordering, checking for wild cards in
    //  LocalExpression (from Expression).
    //
    //  If an upcase table was specified, the compare is done case insensitive.
    //

    for (i = 0; i < Length; i += 1) {

        ConstantChar = Name->Buffer[i];
        ExpressionChar = Expression->Buffer[i];

        if ( IgnoreCase ) {

            if (ConstantChar < UpcaseTableSize) {
                ConstantChar = UpcaseTable[(ULONG)ConstantChar];
            }
            if (ExpressionChar < UpcaseTableSize) {
                ExpressionChar = UpcaseTable[(ULONG)ExpressionChar];
            }
        }

        if ( FsRtlIsUnicodeCharacterWild(ExpressionChar) ) {

            DebugTrace( -1, Dbg, ("NtfsCollateNames -> %08lx (Wild)\n", WildIs) );
            return WildIs;
        }

        if ( ExpressionChar < ConstantChar ) {

            DebugTrace( -1, Dbg, ("NtfsCollateNames -> LessThan\n") );
            return LessThan;
        }

        if ( ExpressionChar > ConstantChar ) {

            DebugTrace( -1, Dbg, ("NtfsCollateNames -> GreaterThan\n") );
            return GreaterThan;
        }
    }

    //
    //  We've gone through the entire short match and they're equal
    //  so we need to now check which one is shorter, or, if
    //  LocalExpression is longer, we need to see if the next character is
    //  wild!  (For example, an enumeration of "ABC*", must return
    //  "ABC".
    //

    if (Expression->Length < Name->Length) {

        DebugTrace( -1, Dbg, ("NtfsCollateNames -> LessThan (length)\n") );
        return LessThan;
    }

    if (Expression->Length > Name->Length) {

        if (FsRtlIsUnicodeCharacterWild(Expression->Buffer[i])) {

            DebugTrace( -1, Dbg, ("NtfsCollateNames -> %08lx (trailing wild)\n", WildIs) );
            return WildIs;
        }

        DebugTrace( -1, Dbg, ("NtfsCollateNames -> GreaterThan (length)\n") );
        return GreaterThan;
    }

    DebugTrace( -1, Dbg, ("NtfsCollateNames -> EqualTo\n") );
    return EqualTo;
}

BOOLEAN
NtfsIsFileNameValid (
    IN PUNICODE_STRING FileName,
    IN BOOLEAN WildCardsPermissible
    )

/*++

Routine Description:

    This routine checks if the specified file name is valid.  Note that
    only the file name part of the name is allowed, ie. no colons are
    permitted.

Arguments:

    FileName - Supplies the name to check.

    WildCardsPermissible - Tells us if wild card characters are ok.

Return Value:

    BOOLEAN - TRUE if the name is valid, FALSE otherwise.

--*/

{
    ULONG Index;
    ULONG NameLength;
    BOOLEAN AllDots = TRUE;
    BOOLEAN IsNameValid = TRUE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsIsFileNameValid\n") );
    DebugTrace( 0, Dbg, ("FileName             = %Z\n", FileName) );
    DebugTrace( 0, Dbg, ("WildCardsPermissible = %s\n",
                         WildCardsPermissible ? "TRUE" : "FALSE") );

    //
    //  It better be a valid unicode string.
    //

    if ((FileName->Length == 0) || FlagOn( FileName->Length, 1 )) {

        IsNameValid = FALSE;

    } else {

        //
        //  Check if corresponds to a legal single Ntfs Name.
        //

        NameLength = FileName->Length / sizeof(WCHAR);

        for (Index = 0; Index < NameLength; Index += 1) {

            WCHAR Char;

            Char = FileName->Buffer[Index];

            //
            //  Check for wild card characters if they weren't allowed, and
            //  check for the other illegal characters including the colon and
            //  backslash characters since this can only be a single component.
            //

            if ( ((Char <= 0xff) &&
                  !FsRtlIsAnsiCharacterLegalNtfs(Char, WildCardsPermissible)) ||
                 (Char == L':') ||
                 (Char == L'\\') ) {

                IsNameValid = FALSE;
                break;
            }

            //
            //  Remember if this is not a '.' character.
            //

            if (Char != L'.') {

                AllDots = FALSE;
            }
        }

        //
        //  The names '.' and '..' are also invalid.
        //

        if (AllDots
            && (NameLength == 1
                || NameLength == 2)) {

            IsNameValid = FALSE;
        }
    }

    DebugTrace( -1, Dbg, ("NtfsIsFileNameValid -> %s\n", IsNameValid ? "TRUE" : "FALSE") );

    return IsNameValid;
}


BOOLEAN
NtfsIsFatNameValid (
    IN PUNICODE_STRING FileName,
    IN BOOLEAN WildCardsPermissible
    )

/*++

Routine Description:

    This routine checks if the specified file name is conformant to the
    Fat 8.3 file naming rules.

Arguments:

    FileName - Supplies the name to check.

    WildCardsPermissible - Tells us if wild card characters are ok.

Return Value:

    BOOLEAN - TRUE if the name is valid, FALSE otherwise.

--*/

{
    BOOLEAN Results;
    STRING DbcsName;
    USHORT i;
    CHAR Buffer[24];
    WCHAR wc;

    PAGED_CODE();

    //
    //  If the name is more than 24 bytes then it can't be a valid Fat name.
    //

    if (FileName->Length > 24) {

        return FALSE;
    }

    //
    //  We will do some extra checking ourselves because we really want to be
    //  fairly restrictive of what an 8.3 name contains.  That way
    //  we will then generate an 8.3 name for some nomially valid 8.3
    //  names (e.g., names that contain DBCS characters).  The extra characters
    //  we'll filter off are those characters less than and equal to the space
    //  character and those beyond lowercase z.
    //

    if (FlagOn( NtfsData.Flags,NTFS_FLAGS_ALLOW_EXTENDED_CHAR )) {

        for (i = 0; i < FileName->Length / sizeof( WCHAR ); i += 1) {

            wc = FileName->Buffer[i];

            if ((wc <= 0x0020) || (wc == 0x007c)) { return FALSE; }
        }

    } else {

        for (i = 0; i < FileName->Length / sizeof( WCHAR ); i += 1) {

            wc = FileName->Buffer[i];

            if ((wc <= 0x0020) || (wc >= 0x007f) || (wc == 0x007c)) { return FALSE; }
        }
    }

    //
    //  The characters match up okay so now build up the dbcs string to call
    //  the fsrtl routine to check for legal 8.3 formation
    //

    Results = FALSE;

    DbcsName.MaximumLength = 24;
    DbcsName.Buffer = Buffer;

    if (NT_SUCCESS(RtlUnicodeStringToCountedOemString( &DbcsName, FileName, FALSE))) {

        if (FsRtlIsFatDbcsLegal( DbcsName, WildCardsPermissible, FALSE, FALSE )) {

            Results = TRUE;
        }
    }

    //
    //  And return to our caller
    //

    return Results;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\mftsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    MftSup.c

Abstract:

    This module implements the master file table management routines for Ntfs

Author:

    Your Name       [Email]         dd-Mon-Year

Revision History:

--*/

#include "NtfsProc.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NTFS_BUG_CHECK_STRUCSUP)

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_MFTSUP)

//
//  Boolean controlling whether to allow holes in the Mft.
//

BOOLEAN NtfsPerforateMft = FALSE;

//
//  Local support routines
//

BOOLEAN
NtfsTruncateMft (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

BOOLEAN
NtfsDefragMftPriv (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

LONG
NtfsReadMftExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer,
    IN PBCB Bcb,
    IN LONGLONG FileOffset
    );

#if  (DBG || defined( NTFS_FREE_ASSERTS ))
VOID
NtfsVerifyFileReference (
    IN PIRP_CONTEXT IrpContext,
    IN PMFT_SEGMENT_REFERENCE MftSegment
    );
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsAllocateMftRecord)
#pragma alloc_text(PAGE, NtfsCheckForDefrag)
#pragma alloc_text(PAGE, NtfsDeallocateMftRecord)
#pragma alloc_text(PAGE, NtfsDefragMftPriv)
#pragma alloc_text(PAGE, NtfsFillMftHole)
#pragma alloc_text(PAGE, NtfsInitializeMftHoleRecords)
#pragma alloc_text(PAGE, NtfsInitializeMftRecord)
#pragma alloc_text(PAGE, NtfsIsMftIndexInHole)
#pragma alloc_text(PAGE, NtfsLogMftFileRecord)
#pragma alloc_text(PAGE, NtfsPinMftRecord)
#pragma alloc_text(PAGE, NtfsReadFileRecord)
#pragma alloc_text(PAGE, NtfsReadMftRecord)
#pragma alloc_text(PAGE, NtfsTruncateMft)
#pragma alloc_text(PAGE, NtfsIterateMft)

#if  (DBG || defined( NTFS_FREE_ASSERTS ))
#pragma alloc_text(PAGE, NtfsVerifyFileReference)
#endif

#endif


#if NTFSDBG
ULONG FileRecordCacheHit = 0;
ULONG FileRecordCacheMiss = 0;
#endif  //  DBG

VOID
NtfsReadFileRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_REFERENCE FileReference,
    OUT PBCB *Bcb,
    OUT PFILE_RECORD_SEGMENT_HEADER *BaseFileRecord,
    OUT PATTRIBUTE_RECORD_HEADER *FirstAttribute,
    OUT PLONGLONG MftFileOffset OPTIONAL
    )

/*++

Routine Description:

    This routine reads the specified file record from the Mft or cache if its present
    If it comes from disk it is always verified.

Arguments:

    Vcb - Vcb for volume on which Mft is to be read

    Fcb - If specified allows us to identify the file which owns the
        invalid file record.

    FileReference - File reference, including sequence number, of the file record
        to be read.

    Bcb - Returns the Bcb for the file record.  This Bcb is mapped, not pinned.

    BaseFileRecord - Returns a pointer to the requested file record.

    FirstAttribute - Returns a pointer to the first attribute in the file record.

    MftFileOffset - If specified, returns the file offset of the file record.

Return Value:

    None

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsReadFileRecord\n") );

    //
    //  Perform a quick look-aside to see if the file record being requested
    //  is one that we have cached in the IrpContext.  If so, we reuse that Bcb
    //

    if (NtfsFindCachedFileRecord( IrpContext,
                                  NtfsSegmentNumber( FileReference ),
                                  Bcb,
                                  BaseFileRecord )) {

        //
        //  We found the Bcb and File record in the cache.  Figure out the remainder
        //  of the data
        //

        if (ARGUMENT_PRESENT( MftFileOffset )) {
            *MftFileOffset =
                LlBytesFromFileRecords( Vcb, NtfsSegmentNumber( FileReference ));

        DebugDoit( FileRecordCacheHit++ );

        }
    } else {

        USHORT SequenceNumber = FileReference->SequenceNumber;

        DebugDoit( FileRecordCacheMiss++ );

        NtfsReadMftRecord( IrpContext,
                           Vcb,
                           FileReference,
                           TRUE,
                           Bcb,
                           BaseFileRecord,
                           MftFileOffset );

        //
        //  Make sure the file is in use - we validated everything else in NtfsReadMftRecord
        //

        if (!FlagOn( (*BaseFileRecord)->Flags, FILE_RECORD_SEGMENT_IN_USE )) {

            NtfsUnpinBcb( IrpContext, Bcb );
            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, FileReference, NULL );
        }
    }

    *FirstAttribute = (PATTRIBUTE_RECORD_HEADER)((PCHAR)*BaseFileRecord +
                      (*BaseFileRecord)->FirstAttributeOffset);

    DebugTrace( -1, Dbg, ("NtfsReadFileRecord -> VOID\n") );

    return;
}


VOID
NtfsReadMftRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PMFT_SEGMENT_REFERENCE SegmentReference,
    IN BOOLEAN CheckRecord,
    OUT PBCB *Bcb,
    OUT PFILE_RECORD_SEGMENT_HEADER *FileRecord,
    OUT PLONGLONG MftFileOffset OPTIONAL
    )

/*++

Routine Description:

    This routine reads the specified Mft record from the Mft, without checking
    sequence numbers.  This routine may be used to read records in the Mft for
    a file other than its base file record, or it could conceivably be used for
    extraordinary maintenance functions.

Arguments:

    Vcb - Vcb for volume on which Mft is to be read

    SegmentReference - File reference, including sequence number, of the file
                       record to be read.

    Bcb - Returns the Bcb for the file record.  This Bcb is mapped, not pinned.

    FileRecord - Returns a pointer to the requested file record.

    MftFileOffset - If specified, returns the file offset of the file record.

    CheckRecord - Do a check of records consistency -  always set TRUE unless the
                  record is unowned and could change beneath us

Return Value:

    None

--*/

{
    PFILE_RECORD_SEGMENT_HEADER FileRecord2;
    LONGLONG FileOffset;
    PBCB Bcb2 = NULL;
    BOOLEAN ErrorPath = FALSE;

    LONGLONG LlTemp1;
    ULONG CorruptHint;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsReadMftRecord\n") );
    DebugTrace( 0, Dbg, ("Vcb = %08lx\n", Vcb) );
    DebugTrace( 0, Dbg, ("SegmentReference = %08lx\n", NtfsSegmentNumber( SegmentReference )) );
    *Bcb = NULL;

    try {

        //
        //  Capture the Segment Reference and make sure the Sequence Number is 0.
        //

        FileOffset = NtfsFullSegmentNumber( SegmentReference );

        //
        //  Calculate the file offset in the Mft to the file record segment.
        //

        FileOffset = LlBytesFromFileRecords( Vcb, FileOffset );

        //
        //  Pass back the file offset within the Mft.
        //

        if (ARGUMENT_PRESENT( MftFileOffset )) {

            *MftFileOffset = FileOffset;
        }

        //
        //  Try to read it from the normal Mft.
        //

        try {

            NtfsMapStream( IrpContext,
                           Vcb->MftScb,
                           FileOffset,
                           Vcb->BytesPerFileRecordSegment,
                           Bcb,
                           (PVOID *)FileRecord );

            //
            //  Raise here if we have a file record covered by the mirror,
            //  and we do not see the file signature.
            //

            if ((FileOffset < Vcb->Mft2Scb->Header.FileSize.QuadPart) &&
                (*(PULONG)(*FileRecord)->MultiSectorHeader.Signature != *(PULONG)FileSignature)) {

                NtfsRaiseStatus( IrpContext, STATUS_DATA_ERROR, NULL, NULL );
            }


        //
        //  If we get an exception that is not expected, then we will allow
        //  the search to continue and let the crash occur in the "normal" place.
        //  Otherwise, if the read is within the part of the Mft mirrored in Mft2,
        //  then we will simply try to read the data from Mft2.  If the expected
        //  status came from a read not within Mft2, then we will also continue,
        //  which cause one of our caller's try-except's to initiate an unwind.
        //

        } except (NtfsReadMftExceptionFilter( IrpContext, GetExceptionInformation(), *Bcb, FileOffset )) {

            NtfsMinimumExceptionProcessing( IrpContext );
            ErrorPath = TRUE;
        }

        if (ErrorPath) {

            //
            //  Try to read from Mft2.  If this fails with an expected status,
            //  then we are just going to have to give up and let the unwind
            //  occur from one of our caller's try-except.
            //

            NtfsMapStream( IrpContext,
                           Vcb->Mft2Scb,
                           FileOffset,
                           Vcb->BytesPerFileRecordSegment,
                           &Bcb2,
                           (PVOID *)&FileRecord2 );

            //
            //  Pin the original page because we are going to update it.
            //

            NtfsPinMappedData( IrpContext,
                               Vcb->MftScb,
                               FileOffset,
                               Vcb->BytesPerFileRecordSegment,
                               Bcb );

            //
            //  Now copy the entire page.
            //

            RtlCopyMemory( *FileRecord,
                           FileRecord2,
                           Vcb->BytesPerFileRecordSegment );

            //
            //  Set it dirty with the largest Lsn, so that whoever is doing Restart
            //  will successfully establish the "oldest unapplied Lsn".
            //

            LlTemp1 = MAXLONGLONG;

            CcSetDirtyPinnedData( *Bcb,
                                  (PLARGE_INTEGER)&LlTemp1 );


            NtfsUnpinBcb( IrpContext, &Bcb2 );
        }

        //
        //  Do a consistency check
        //

        if ( CheckRecord && FlagOn((*FileRecord)->Flags, FILE_RECORD_SEGMENT_IN_USE ) ) {
            if (!NtfsCheckFileRecord( Vcb, *FileRecord, SegmentReference, &CorruptHint )) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, SegmentReference, NULL );
            }
        }

    } finally {

        if (AbnormalTermination()) {

            NtfsUnpinBcb( IrpContext, Bcb );
            NtfsUnpinBcb( IrpContext, &Bcb2 );
        }
    }

    //
    //  Now that we've pinned a file record, cache it in the IrpContext so that
    //  it can be safely retrieved later without the expense of mapping again.
    //  Don't do any caching if there are no handles, we don't want to do this for
    //  mount.
    //

    if (Vcb->CleanupCount != 0) {

        NtfsAddToFileRecordCache( IrpContext,
                                  NtfsSegmentNumber( SegmentReference ),
                                  *Bcb,
                                  *FileRecord );
    }

    DebugTrace( 0, Dbg, ("Bcb > %08lx\n", Bcb) );
    DebugTrace( 0, Dbg, ("FileRecord > %08lx\n", *FileRecord) );
    DebugTrace( -1, Dbg, ("NtfsReadMftRecord -> VOID\n") );

    return;
}


VOID
NtfsPinMftRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PMFT_SEGMENT_REFERENCE SegmentReference,
    IN BOOLEAN PreparingToWrite,
    OUT PBCB *Bcb,
    OUT PFILE_RECORD_SEGMENT_HEADER *FileRecord,
    OUT PLONGLONG MftFileOffset OPTIONAL
    )

/*++

Routine Description:

    This routine pins the specified Mft record from the Mft, without checking
    sequence numbers.  This routine may be used to pin records in the Mft for
    a file other than its base file record, or it could conceivably be used for
    extraordinary maintenance functions, such as during restart.

Arguments:

    Vcb - Vcb for volume on which Mft is to be read

    SegmentReference - File reference, including sequence number, of the file
                       record to be read.

    PreparingToWrite - TRUE if caller is preparing to write, and does not care
                       about whether the record read correctly

    Bcb - Returns the Bcb for the file record.  This Bcb is mapped, not pinned.

    FileRecord - Returns a pointer to the requested file record.

    MftFileOffset - If specified, returns the file offset of the file record.

Return Value:

    None

--*/

{
    LONGLONG FileOffset;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsPinMftRecord\n") );
    DebugTrace( 0, Dbg, ("Vcb = %08lx\n", Vcb) );
    DebugTrace( 0, Dbg, ("SegmentReference = %08lx\n", NtfsSegmentNumber( SegmentReference )) );

    //
    //  Capture the Segment Reference and make sure the Sequence Number is 0.
    //

    FileOffset = NtfsFullSegmentNumber( SegmentReference );

    //
    //  Calculate the file offset in the Mft to the file record segment.
    //

    FileOffset = LlBytesFromFileRecords( Vcb, FileOffset );

    //
    //  Pass back the file offset within the Mft.
    //

    if (ARGUMENT_PRESENT( MftFileOffset )) {

        *MftFileOffset = FileOffset;
    }

    //
    //  Try to read it from the normal Mft.
    //

    try {

        NtfsPinStream( IrpContext,
                       Vcb->MftScb,
                       FileOffset,
                       Vcb->BytesPerFileRecordSegment,
                       Bcb,
                       (PVOID *)FileRecord );

    //
    //  If we get an exception that is not expected, then we will allow
    //  the search to continue and let the crash occur in the "normal" place.
    //  Otherwise, if the read is within the part of the Mft mirrored in Mft2,
    //  then we will simply try to read the data from Mft2.  If the expected
    //  status came from a read not within Mft2, then we will also continue,
    //  which cause one of our caller's try-except's to initiate an unwind.
    //

    } except(!FsRtlIsNtstatusExpected(GetExceptionCode()) ?
                        EXCEPTION_CONTINUE_SEARCH :
                        ( FileOffset < Vcb->Mft2Scb->Header.FileSize.QuadPart ) ?
                            EXCEPTION_EXECUTE_HANDLER :
                            EXCEPTION_CONTINUE_SEARCH ) {

        //
        //  Try to read from Mft2.  If this fails with an expected status,
        //  then we are just going to have to give up and let the unwind
        //  occur from one of our caller's try-except.
        //

        NtfsMinimumExceptionProcessing( IrpContext );
        NtfsPinStream( IrpContext,
                       Vcb->Mft2Scb,
                       FileOffset,
                       Vcb->BytesPerFileRecordSegment,
                       Bcb,
                       (PVOID *)FileRecord );

    }

    if (!PreparingToWrite &&
        (*(PULONG)(*FileRecord)->MultiSectorHeader.Signature != *(PULONG)FileSignature)) {

        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, SegmentReference, NULL );
    }

    //
    //  Now that we've pinned a file record, cache it in the IrpContext so that
    //  it can be safely retrieved later without the expense of mapping again.
    //  Don't do any caching if there are no handles, we don't want to do this for
    //  mount.
    //

    if (Vcb->CleanupCount != 0) {

        NtfsAddToFileRecordCache( IrpContext,
                                  NtfsSegmentNumber( SegmentReference ),
                                  *Bcb,
                                  *FileRecord );
    }

    DebugTrace( 0, Dbg, ("Bcb > %08lx\n", Bcb) );
    DebugTrace( 0, Dbg, ("FileRecord > %08lx\n", *FileRecord) );
    DebugTrace( -1, Dbg, ("NtfsPinMftRecord -> VOID\n") );

    return;
}


MFT_SEGMENT_REFERENCE
NtfsAllocateMftRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN MftData
    )

/*++

Routine Description:

    This routine is called to allocate a record in the Mft file.  We need
    to find the bitmap attribute for the Mft file and call into the bitmap
    package to allocate us a record.

Arguments:

    Vcb - Vcb for volume on which Mft is to be read

    MftData - TRUE if the file record is being allocated to describe the
              $DATA attribute for the Mft.

Return Value:

    MFT_SEGMENT_REFERENCE - The is the segment reference for the allocated
        record.  It contains the file reference number but without
        the previous sequence number.

--*/

{
    MFT_SEGMENT_REFERENCE NewMftRecord;

    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    BOOLEAN FoundAttribute;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAllocateMftRecord:  Entered\n") );

    //
    //  Synchronize the lookup by acquiring the Mft.
    //

    NtfsAcquireExclusiveScb( IrpContext, Vcb->MftScb );

    //
    //  Lookup the bitmap allocation for the Mft file.  This is the
    //  bitmap attribute for the Mft file.
    //

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Use a try finally to cleanup the attribute context.
    //

    try {

        //
        //  Lookup the bitmap attribute for the Mft.
        //

        FoundAttribute = NtfsLookupAttributeByCode( IrpContext,
                                                    Vcb->MftScb->Fcb,
                                                    &Vcb->MftScb->Fcb->FileReference,
                                                    $BITMAP,
                                                    &AttrContext );
        //
        //  Error if we don't find the bitmap
        //

        if (!FoundAttribute) {

            DebugTrace( 0, Dbg, ("Should find bitmap attribute\n") );

            NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
        }

        //
        //  Reserve a new mft record if necc.
        //

        if (!FlagOn(Vcb->MftReserveFlags, VCB_MFT_RECORD_RESERVED)) {

            (VOID)NtfsReserveMftRecord( IrpContext,
                                        Vcb,
                                        &AttrContext );
        }

        //
        //  If we need this record for the Mft Data attribute, then we need to
        //  use the one we have already reserved, and then remember there is'nt
        //  one reserved anymore.
        //

        if (MftData) {

            ASSERT( FlagOn(Vcb->MftReserveFlags, VCB_MFT_RECORD_RESERVED) );

            NtfsSetSegmentNumber( &NewMftRecord,
                                  0,
                                  NtfsAllocateMftReservedRecord( IrpContext,
                                                                 Vcb,
                                                                 &AttrContext ) );

            //
            //  Never let use get file record zero for this or we could lose a
            //  disk.
            //

            ASSERT( NtfsUnsafeSegmentNumber( &NewMftRecord ) != 0 );

            if (NtfsUnsafeSegmentNumber( &NewMftRecord ) == 0) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

        //
        //  Allocate the record.
        //

        } else {

            NtfsSetSegmentNumber( &NewMftRecord,
                                  0,
                                  NtfsAllocateRecord( IrpContext,
                                                      &Vcb->MftScb->ScbType.Index.RecordAllocationContext,
                                                      &AttrContext ) );
        }


    } finally {

        DebugUnwind( NtfsAllocateMftRecord );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        NtfsReleaseScb( IrpContext, Vcb->MftScb );

        DebugTrace( -1, Dbg, ("NtfsAllocateMftRecord:  Exit\n") );
    }

    return NewMftRecord;
}


VOID
NtfsInitializeMftRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PMFT_SEGMENT_REFERENCE MftSegment,
    IN OUT PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PBCB Bcb,
    IN BOOLEAN Directory
    )

/*++

Routine Description:

    This routine initializes a Mft record for use.  We need to initialize the
    sequence number for this usage of the the record.  We also initialize the
    update sequence array and the field which indicates the first usable
    attribute offset in the record.

Arguments:

    Vcb - Vcb for volume for the Mft.

    MftSegment - This is a pointer to the file reference for this
        segment.  We store the sequence number in it to make this
        a fully valid file reference.

    FileRecord - Pointer to the file record to initialize.

    Bcb - Bcb to use to set this page dirty via NtfsWriteLog.

    Directory - Boolean indicating if this file is a directory containing
        an index over the filename attribute.

Return Value:

    None.

--*/

{
    LONGLONG FileRecordOffset;

    PUSHORT UsaSequenceNumber;

    PATTRIBUTE_RECORD_HEADER AttributeHeader;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsInitializeMftRecord:  Entered\n") );

    //
    //  Write a log record to uninitialize the structure in case we abort.
    //  We need to do this prior to setting the IN_USE bit.
    //  We don't store the Lsn for this operation in the page because there
    //  is no redo operation.
    //

    //
    //  Capture the Segment Reference and make sure the Sequence Number is 0.
    //

    FileRecordOffset = NtfsFullSegmentNumber(MftSegment);

    FileRecordOffset = LlBytesFromFileRecords( Vcb, FileRecordOffset );

    //
    //  We now log the new Mft record.
    //

    FileRecord->Lsn = NtfsWriteLog( IrpContext,
                                    Vcb->MftScb,
                                    Bcb,
                                    Noop,
                                    NULL,
                                    0,
                                    DeallocateFileRecordSegment,
                                    NULL,
                                    0,
                                    FileRecordOffset,
                                    0,
                                    0,
                                    Vcb->BytesPerFileRecordSegment );

    RtlZeroMemory( &FileRecord->ReferenceCount,
                   Vcb->BytesPerFileRecordSegment - FIELD_OFFSET( FILE_RECORD_SEGMENT_HEADER, ReferenceCount ));

    //
    //  First we update the sequence count in the file record and our
    //  Mft segment.  We avoid using 0 as a sequence number.
    //

    if (FileRecord->SequenceNumber == 0) {

        FileRecord->SequenceNumber = 1;
    }

    //
    //  Store the new sequence number in the Mft segment given us by the
    //  caller.
    //

    MftSegment->SequenceNumber = FileRecord->SequenceNumber;

#if (DBG || defined( NTFS_FREE_ASSERTS ))

    //
    //  Do a DBG-only sanity check to see if we're errorneously reusing this file reference.
    //

    NtfsVerifyFileReference( IrpContext, MftSegment );

#endif

    //
    //  Fill in the header for the Update sequence array.
    //

    *(PULONG)FileRecord->MultiSectorHeader.Signature = *(PULONG)FileSignature;

    FileRecord->MultiSectorHeader.UpdateSequenceArrayOffset = FIELD_OFFSET( FILE_RECORD_SEGMENT_HEADER, UpdateArrayForCreateOnly );
    FileRecord->MultiSectorHeader.UpdateSequenceArraySize = (USHORT)UpdateSequenceArraySize( Vcb->BytesPerFileRecordSegment );

    //
    //  We initialize the update sequence array sequence number to one.
    //

    UsaSequenceNumber = Add2Ptr( FileRecord, FileRecord->MultiSectorHeader.UpdateSequenceArrayOffset );
    *UsaSequenceNumber = 1;

    //
    //  The first attribute offset begins on a quad-align boundary
    //  after the update sequence array.
    //

    FileRecord->FirstAttributeOffset = (USHORT)(FileRecord->MultiSectorHeader.UpdateSequenceArrayOffset
                                                + (FileRecord->MultiSectorHeader.UpdateSequenceArraySize
                                                * sizeof( UPDATE_SEQUENCE_NUMBER )));

    FileRecord->FirstAttributeOffset = (USHORT)QuadAlign( FileRecord->FirstAttributeOffset );

    //
    //  This is also the first free byte in this file record.
    //

    FileRecord->FirstFreeByte = FileRecord->FirstAttributeOffset;

    //
    //  We set the flags to show the segment is in use and look at
    //  the directory parameter to indicate whether to show
    //  the name index present.
    //

    FileRecord->Flags = (USHORT)(FILE_RECORD_SEGMENT_IN_USE |
                                 (Directory ? FILE_FILE_NAME_INDEX_PRESENT : 0));

    //
    //  The size is given in the Vcb.
    //

    FileRecord->BytesAvailable = Vcb->BytesPerFileRecordSegment;

    //
    //  The current FRS number.
    //

    FileRecord->SegmentNumberHighPart = MftSegment->SegmentNumberHighPart;
    FileRecord->SegmentNumberLowPart = MftSegment->SegmentNumberLowPart;

    //
    //  Now we put an $END attribute in the File record.
    //

    AttributeHeader = (PATTRIBUTE_RECORD_HEADER) Add2Ptr( FileRecord,
                                                          FileRecord->FirstFreeByte );

    FileRecord->FirstFreeByte += QuadAlign( sizeof(ATTRIBUTE_TYPE_CODE) );

    //
    //  Fill in the fields in the attribute.
    //

    AttributeHeader->TypeCode = $END;

    //
    //  Remember if this is the first time used.
    //

    AttributeHeader->RecordLength = 0x11477982;

    DebugTrace( -1, Dbg, ("NtfsInitializeMftRecord:  Exit\n") );

    return;
}


VOID
NtfsDeallocateMftRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG FileNumber
    )

/*++

Routine Description:

    This routine will cause an Mft record to go into the NOT_USED state.
    We pin the record and modify the sequence count and IN USE bit.

Arguments:

    Vcb - Vcb for volume.

    FileNumber - This is the low 32 bits for the file number.

Return Value:

    None.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    LONGLONG FileOffset;
    MFT_SEGMENT_REFERENCE Reference;
    PBCB MftBcb = NULL;

    BOOLEAN FoundAttribute;
    BOOLEAN AcquiredMft = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsDeallocateMftRecord:  Entered\n") );

    NtfsSetSegmentNumber( &Reference, 0, FileNumber );
    Reference.SequenceNumber = 0;

    //
    //  Lookup the bitmap allocation for the Mft file.
    //

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Use a try finally to cleanup the attribute context.
    //

    try {

        NtfsPinMftRecord( IrpContext,
                          Vcb,
                          &Reference,
                          TRUE,
                          &MftBcb,
                          &FileRecord,
                          &FileOffset );

        //
        //  Log changes if the file is currently in use
        //

        if (FlagOn(FileRecord->Flags, FILE_RECORD_SEGMENT_IN_USE)) {

            FileRecord->Lsn = NtfsWriteLog( IrpContext,
                                            Vcb->MftScb,
                                            MftBcb,
                                            DeallocateFileRecordSegment,
                                            NULL,
                                            0,
                                            InitializeFileRecordSegment,
                                            FileRecord,
                                            PtrOffset(FileRecord, &FileRecord->Flags) + 4,
                                            FileOffset,
                                            0,
                                            0,
                                            Vcb->BytesPerFileRecordSegment );

            //
            //  We increment the sequence count in the file record and clear
            //  the In-Use flag.
            //

            ClearFlag( FileRecord->Flags, FILE_RECORD_SEGMENT_IN_USE );

            FileRecord->SequenceNumber += 1;

            NtfsUnpinBcb( IrpContext, &MftBcb );
        }

        //
        //  Synchronize the lookup by acquiring the Mft.
        //

        NtfsAcquireExclusiveScb( IrpContext, Vcb->MftScb );
        AcquiredMft = TRUE;

        //
        //  Lookup the bitmap attribute for the Mft.
        //

        FoundAttribute = NtfsLookupAttributeByCode( IrpContext,
                                                    Vcb->MftScb->Fcb,
                                                    &Vcb->MftScb->Fcb->FileReference,
                                                    $BITMAP,
                                                    &AttrContext );
        //
        //  Error if we don't find the bitmap
        //

        if (!FoundAttribute) {

            DebugTrace( 0, Dbg, ("Should find bitmap attribute\n") );

            NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
        }

        NtfsDeallocateRecord( IrpContext,
                              &Vcb->MftScb->ScbType.Index.RecordAllocationContext,
                              FileNumber,
                              &AttrContext );

        //
        //  If this file number is less than our reserved index then clear
        //  the reserved index.
        //

        if (FlagOn( Vcb->MftReserveFlags, VCB_MFT_RECORD_RESERVED )
            && FileNumber < Vcb->MftScb->ScbType.Mft.ReservedIndex) {

            ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MFT_REC_RESERVED );
            ClearFlag( Vcb->MftReserveFlags, VCB_MFT_RECORD_RESERVED );

            Vcb->MftScb->ScbType.Mft.ReservedIndex = 0;
        }

        NtfsAcquireCheckpoint( IrpContext, Vcb );
        SetFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_ENABLED );
        NtfsReleaseCheckpoint( IrpContext, Vcb );

        Vcb->MftFreeRecords += 1;
        Vcb->MftScb->ScbType.Mft.FreeRecordChange += 1;

    } finally {

        DebugUnwind( NtfsDeallocateMftRecord );

        NtfsUnpinBcb( IrpContext, &MftBcb );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        if (AcquiredMft) {

            NtfsReleaseScb( IrpContext, Vcb->MftScb );
        }

        DebugTrace( -1, Dbg, ("NtfsDeallocateMftRecord:  Exit\n") );
    }
}


BOOLEAN
NtfsIsMftIndexInHole (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG Index,
    OUT PULONG HoleLength OPTIONAL
    )

/*++

Routine Description:

    This routine is called to check if an Mft index lies within a hole in
    the Mft.

Arguments:

    Vcb - Vcb for volume.

    Index - This is the index to test.  It is the lower 32 bits of an
        Mft segment.

    HoleLength - This is the length of the hole starting at this index.

Return Value:

    BOOLEAN - TRUE if the index is within the Mft and there is no allocation
        for it.

--*/

{
    BOOLEAN InHole = FALSE;
    VCN Vcn;
    LCN Lcn;
    LONGLONG Clusters;

    PAGED_CODE();

    //
    //  If the index is past the last file record then it is not considered
    //  to be in a hole.
    //

    if (Index < (ULONG) LlFileRecordsFromBytes( Vcb, Vcb->MftScb->Header.FileSize.QuadPart )) {

        if (Vcb->FileRecordsPerCluster == 0) {

            Vcn = Index << Vcb->MftToClusterShift;

        } else {

            Vcn = Index >> Vcb->MftToClusterShift;
        }

        //
        //  Now look this up the Mcb for the Mft.  This Vcn had better be
        //  in the Mcb or there is some problem.
        //

        if (!NtfsLookupNtfsMcbEntry( &Vcb->MftScb->Mcb,
                                     Vcn,
                                     &Lcn,
                                     &Clusters,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL )) {

            ASSERT( FALSE );
            NtfsRaiseStatus( IrpContext,
                             STATUS_FILE_CORRUPT_ERROR,
                             NULL,
                             Vcb->MftScb->Fcb );
        }

        if (Lcn == UNUSED_LCN) {

            InHole = TRUE;

            //
            //  We know the number of clusters beginning from
            //  this point in the Mcb.  Convert to file records
            //  and return to the user.
            //

            if (ARGUMENT_PRESENT( HoleLength )) {

                if (Vcb->FileRecordsPerCluster == 0) {

                    *HoleLength = ((ULONG)Clusters) >> Vcb->MftToClusterShift;

                } else {

                    *HoleLength = ((ULONG)Clusters) << Vcb->MftToClusterShift;
                }
            }
        }
    }

    return InHole;
}


VOID
NtfsFillMftHole (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG Index
    )

/*++

Routine Description:

    This routine is called to fill in a hole within the Mft.  We will find
    the beginning of the hole and then allocate the clusters to fill the
    hole.  We will try to fill a hole with the HoleGranularity in the Vcb.
    If the hole containing this index is not that large we will truncate
    the size being added.  We always guarantee to allocate the clusters on
    file record boundaries.

Arguments:

    Vcb - Vcb for volume.

    Index - This is the index to test.  It is the lower 32 bits of an
        Mft segment.

Return Value:

    None.

--*/

{
    ULONG FileRecords;
    ULONG BaseIndex;

    VCN IndexVcn;
    VCN HoleStartVcn;
    VCN StartingVcn;

    LCN Lcn = UNUSED_LCN;
    LONGLONG ClusterCount;
    LONGLONG RunClusterCount;

    PAGED_CODE();

    //
    //  Convert the Index to a Vcn in the file.  Find the cluster that would
    //  be the start of this hole if the hole is fully deallocated.
    //

    if (Vcb->FileRecordsPerCluster == 0) {

        IndexVcn = Index << Vcb->MftToClusterShift;
        HoleStartVcn = (Index & Vcb->MftHoleInverseMask) << Vcb->MftToClusterShift;

    } else {

        IndexVcn = Index >> Vcb->MftToClusterShift;
        HoleStartVcn = (Index & Vcb->MftHoleInverseMask) >> Vcb->MftToClusterShift;
    }

    //
    //  Lookup the run containing this index.
    //

    NtfsLookupNtfsMcbEntry( &Vcb->MftScb->Mcb,
                            IndexVcn,
                            &Lcn,
                            &ClusterCount,
                            NULL,
                            &RunClusterCount,
                            NULL,
                            NULL );

    //
    //  This had better be a hole.
    //

    if (Lcn != UNUSED_LCN) {

        NtfsAcquireCheckpoint( IrpContext, Vcb );
        ClearFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_PERMITTED );
        NtfsReleaseCheckpoint( IrpContext, Vcb );
        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Vcb->MftScb->Fcb );
    }

    //
    //  Take the start of the deallocated space and round up to a hole boundary.
    //

    StartingVcn = IndexVcn - (RunClusterCount - ClusterCount);

    if (StartingVcn <= HoleStartVcn) {

        StartingVcn = HoleStartVcn;
        RunClusterCount -= (HoleStartVcn - StartingVcn);
        StartingVcn = HoleStartVcn;

    //
    //  We can go to the beginning of a hole.  Just use the Vcn for the file
    //  record we want to reallocate.
    //

    } else {

        RunClusterCount = ClusterCount;
        StartingVcn = IndexVcn;
    }

    //
    //  Trim the cluster count back to a hole if necessary.
    //

    if ((ULONG) RunClusterCount >= Vcb->MftClustersPerHole) {

        RunClusterCount = Vcb->MftClustersPerHole;

    //
    //  We don't have enough clusters for a full hole.  Make sure
    //  we end on a file record boundary however.  We must end up
    //  with enough clusters for the file record we are reallocating.
    //

    } else if (Vcb->FileRecordsPerCluster == 0) {

        ((PLARGE_INTEGER) &ClusterCount)->LowPart &= (Vcb->ClustersPerFileRecordSegment - 1);

        if (StartingVcn + ClusterCount < IndexVcn + Vcb->ClustersPerFileRecordSegment) {

            NtfsAcquireCheckpoint( IrpContext, Vcb );
            ClearFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_PERMITTED );
            NtfsReleaseCheckpoint( IrpContext, Vcb );
            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Vcb->MftScb->Fcb );
        }
    }

    //
    //  Now attempt to allocate the space.
    //

    NtfsAddAllocation( IrpContext,
                       Vcb->MftScb->FileObject,
                       Vcb->MftScb,
                       StartingVcn,
                       ClusterCount,
                       FALSE,
                       NULL );

    //
    //  Compute the number of file records reallocated and then
    //  initialize and deallocate each file record.
    //

    if (Vcb->FileRecordsPerCluster == 0) {

        FileRecords = (ULONG) ClusterCount >> Vcb->MftToClusterShift;
        BaseIndex = (ULONG) StartingVcn >> Vcb->MftToClusterShift;

    } else {

        FileRecords = (ULONG) ClusterCount << Vcb->MftToClusterShift;
        BaseIndex = (ULONG) StartingVcn << Vcb->MftToClusterShift;
    }

    NtfsInitializeMftHoleRecords( IrpContext,
                                  Vcb,
                                  BaseIndex,
                                  FileRecords );

    Vcb->MftHoleRecords -= FileRecords;
    Vcb->MftScb->ScbType.Mft.HoleRecordChange -= FileRecords;

    return;
}


VOID
NtfsLogMftFileRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN LONGLONG MftOffset,
    IN PBCB Bcb,
    IN BOOLEAN Redo
    )

/*++

Routine Description:

    This routine is called to log changes to the file record for the Mft
    file.  We log the entire record instead of individual changes so
    that we can recover the data even if there is a USA error.  The entire
    data will be sitting in the Log file.

Arguments:

    Vcb - This is the Vcb for the volume being logged.

    FileRecord - This is the file record being logged.

    MftOffset - This is the offset of this file record in the Mft stream.

    Bcb - This is the Bcb for the pinned file record.

    RedoOperation - Boolean indicating if we are logging
        a redo or undo operation.

Return Value:

    None.

--*/

{
    PVOID RedoBuffer;
    NTFS_LOG_OPERATION RedoOperation;
    ULONG RedoLength;

    PVOID UndoBuffer;
    NTFS_LOG_OPERATION UndoOperation;
    ULONG UndoLength;

    PAGED_CODE();

    //
    //  Find the logging values based on whether this is an
    //  undo or redo.
    //

    if (Redo) {

        RedoBuffer = FileRecord;
        RedoOperation = InitializeFileRecordSegment;
        RedoLength = FileRecord->FirstFreeByte;

        UndoBuffer = NULL;
        UndoOperation = Noop;
        UndoLength = 0;

    } else {

        UndoBuffer = FileRecord;
        UndoOperation = InitializeFileRecordSegment;
        UndoLength = FileRecord->FirstFreeByte;

        RedoBuffer = NULL;
        RedoOperation = Noop;
        RedoLength = 0;
    }

    //
    //  Now that we have calculated all the values, call the logging
    //  routine.
    //

    NtfsWriteLog( IrpContext,
                  Vcb->MftScb,
                  Bcb,
                  RedoOperation,
                  RedoBuffer,
                  RedoLength,
                  UndoOperation,
                  UndoBuffer,
                  UndoLength,
                  MftOffset,
                  0,
                  0,
                  Vcb->BytesPerFileRecordSegment );

    return;
}


BOOLEAN
NtfsDefragMft (
    IN PDEFRAG_MFT DefragMft
    )

/*++

Routine Description:

    This routine is called whenever we have detected that the Mft is in a state
    where defragging is desired.

Arguments:

    DefragMft - This is the defrag structure.

Return Value:

    BOOLEAN - TRUE if we took some defrag step, FALSE otherwise.

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    PVCB Vcb;
    PIRP_CONTEXT IrpContext = NULL;

    BOOLEAN DefragStepTaken = FALSE;

    DebugTrace( +1, Dbg, ("NtfsDefragMft:  Entered\n") );

    FsRtlEnterFileSystem();

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, TRUE, FALSE );
    ASSERT( ThreadTopLevelContext == &TopLevelContext );

    Vcb = DefragMft->Vcb;

    //
    //  Use a try-except to catch errors here.
    //

    try {

        //
        //  Deallocate the defrag structure we were called with.
        //

        if (DefragMft->DeallocateWorkItem) {

            NtfsFreePool( DefragMft );
        }

        //
        //  Create the Irp context.  We will use all of the transaction support
        //  contained in a normal IrpContext.
        //

        NtfsInitializeIrpContext( NULL, TRUE, &IrpContext );
        IrpContext->Vcb = Vcb;

        NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

        NtfsAcquireCheckpoint( IrpContext, Vcb );

        if (FlagOn( Vcb->MftDefragState, VCB_MFT_DEFRAG_PERMITTED )
            && FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            NtfsReleaseCheckpoint( IrpContext, Vcb );
            DefragStepTaken = NtfsDefragMftPriv( IrpContext,
                                                 Vcb );
        } else {

            NtfsReleaseCheckpoint( IrpContext, Vcb );
        }

        NtfsCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

    } except( NtfsExceptionFilter( IrpContext, GetExceptionInformation())) {

        NtfsProcessException( IrpContext, NULL, GetExceptionCode() );

        //
        //  If the exception code was not LOG_FILE_FULL then
        //  disable defragging.
        //

        if (GetExceptionCode() != STATUS_LOG_FILE_FULL) {

            NtfsAcquireCheckpoint( IrpContext, Vcb );
            ClearFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_ENABLED );
            NtfsReleaseCheckpoint( IrpContext, Vcb );
        }

        DefragStepTaken = FALSE;
    }

    NtfsAcquireCheckpoint( IrpContext, Vcb );
    ClearFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_ACTIVE );
    NtfsReleaseCheckpoint( IrpContext, Vcb );

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
    FsRtlExitFileSystem();

    DebugTrace( -1, Dbg, ("NtfsDefragMft:  Exit\n") );

    return DefragStepTaken;
}


VOID
NtfsCheckForDefrag (
    IN OUT PVCB Vcb
    )

/*++

Routine Description:

    This routine is called to check whether there is any defrag work to do
    involving freeing file records and creating holes in the Mft.  It
    will modify the TRIGGERED flag in the Vcb if there is still work to
    do.

Arguments:

    Vcb - This is the Vcb for the volume to defrag.

Return Value:

    None.

--*/

{
    LONGLONG RecordsToClusters;
    LONGLONG AdjClusters;

    PAGED_CODE();

    //
    //  Convert the available Mft records to clusters.
    //

    if (Vcb->FileRecordsPerCluster) {

        RecordsToClusters = Int64ShllMod32(((LONGLONG)(Vcb->MftFreeRecords - Vcb->MftHoleRecords)),
                                           Vcb->MftToClusterShift);

    } else {

        RecordsToClusters = Int64ShraMod32(((LONGLONG)(Vcb->MftFreeRecords - Vcb->MftHoleRecords)),
                                           Vcb->MftToClusterShift);
    }

    //
    //  If we have already triggered the defrag then check if we are below
    //  the lower threshold.
    //

    if (FlagOn( Vcb->MftDefragState, VCB_MFT_DEFRAG_TRIGGERED )) {

        AdjClusters = Vcb->FreeClusters >> MFT_DEFRAG_LOWER_THRESHOLD;

        if (AdjClusters >= RecordsToClusters) {

            ClearFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_TRIGGERED );
        }

    //
    //  Otherwise check if we have exceeded the upper threshold.
    //

    } else {

        AdjClusters = Vcb->FreeClusters >> MFT_DEFRAG_UPPER_THRESHOLD;

        if (AdjClusters < RecordsToClusters) {

            SetFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_TRIGGERED );
        }
    }

    return;
}


VOID
NtfsInitializeMftHoleRecords (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG FirstIndex,
    IN ULONG RecordCount
    )

/*++

Routine Description:

    This routine is called to initialize the file records created when filling
    a hole in the Mft.

Arguments:

    Vcb - Vcb for volume.

    FirstIndex - Index for the start of the hole to fill.

    RecordCount - Count of file records in the hole.

Return Value:

    None.

--*/

{
    PBCB Bcb = NULL;

    PAGED_CODE();

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Loop to initialize each file record.
        //

        while (RecordCount--) {

            PUSHORT UsaSequenceNumber;
            PMULTI_SECTOR_HEADER UsaHeader;

            MFT_SEGMENT_REFERENCE ThisMftSegment;
            PFILE_RECORD_SEGMENT_HEADER FileRecord;

            PATTRIBUTE_RECORD_HEADER AttributeHeader;

            //
            //  Convert the index to a segment reference.
            //

            *((PLONGLONG)&ThisMftSegment) = FirstIndex;

            //
            //  Pin the file record to initialize.
            //

            NtfsPinMftRecord( IrpContext,
                              Vcb,
                              &ThisMftSegment,
                              TRUE,
                              &Bcb,
                              &FileRecord,
                              NULL );

            //
            //  Initialize the file record including clearing the in-use
            //  bit.
            //

            RtlZeroMemory( FileRecord, Vcb->BytesPerFileRecordSegment );

            //
            //  Fill in the header for the Update sequence array.
            //

            UsaHeader = (PMULTI_SECTOR_HEADER) FileRecord;

            *(PULONG)UsaHeader->Signature = *(PULONG)FileSignature;

            UsaHeader->UpdateSequenceArrayOffset = FIELD_OFFSET( FILE_RECORD_SEGMENT_HEADER,
                                                                 UpdateArrayForCreateOnly );
            UsaHeader->UpdateSequenceArraySize = (USHORT)UpdateSequenceArraySize( Vcb->BytesPerFileRecordSegment );

            //
            //  We initialize the update sequence array sequence number to one.
            //

            UsaSequenceNumber = Add2Ptr( FileRecord, UsaHeader->UpdateSequenceArrayOffset );
            *UsaSequenceNumber = 1;

            //
            //  The first attribute offset begins on a quad-align boundary
            //  after the update sequence array.
            //

            FileRecord->FirstAttributeOffset = (USHORT)(UsaHeader->UpdateSequenceArrayOffset
                                                        + (UsaHeader->UpdateSequenceArraySize
                                                           * sizeof( UPDATE_SEQUENCE_NUMBER )));

            FileRecord->FirstAttributeOffset = (USHORT)QuadAlign( FileRecord->FirstAttributeOffset );

            //
            //  The size is given in the Vcb.
            //

            FileRecord->BytesAvailable = Vcb->BytesPerFileRecordSegment;

            //
            //  Now we put an $END attribute in the File record.
            //

            AttributeHeader = (PATTRIBUTE_RECORD_HEADER) Add2Ptr( FileRecord,
                                                                  FileRecord->FirstAttributeOffset );

            //
            //  The first free byte is after this location.
            //

            FileRecord->FirstFreeByte = QuadAlign( FileRecord->FirstAttributeOffset
                                                   + sizeof( ATTRIBUTE_TYPE_CODE ));

            //
            //  Fill in the fields in the attribute.
            //

            AttributeHeader->TypeCode = $END;

            //
            //  The current FRS number.
            //

            FileRecord->SegmentNumberHighPart = ThisMftSegment.SegmentNumberHighPart;
            FileRecord->SegmentNumberLowPart = ThisMftSegment.SegmentNumberLowPart;

            //
            //  Log the entire file record.
            //

            NtfsLogMftFileRecord( IrpContext,
                                  Vcb,
                                  FileRecord,
                                  LlBytesFromFileRecords( Vcb, FirstIndex ),
                                  Bcb,
                                  TRUE );

            NtfsUnpinBcb( IrpContext, &Bcb );

            //
            //  Move to the next record.
            //

            FirstIndex += 1;
        }

    } finally {

        DebugUnwind( NtfsInitializeMftHoleRecords );

        NtfsUnpinBcb( IrpContext, &Bcb );
    }

    return;
}


//
//  Local support routine
//

BOOLEAN
NtfsTruncateMft (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine is called to perform the work of truncating the Mft.  If will
    truncate the Mft and adjust the sizes of the Mft and Mft bitmap.

Arguments:

    Vcb - This is the Vcb for the volume to defrag.

Return Value:

    BOOLEAN - TRUE if we could deallocate any disk space, FALSE otherwise.

--*/

{
    PVOID RangePtr;
    ULONG Index;
    VCN StartingVcn;
    VCN NextVcn;
    LCN NextLcn;
    LONGLONG ClusterCount;
    LONGLONG FileOffset;

    ULONG FreeRecordChange;
    IO_STATUS_BLOCK IoStatus;

    PAGED_CODE();

    //
    //  Try to find a range of file records at the end of the file which can
    //  be deallocated.
    //

    if (!NtfsFindMftFreeTail( IrpContext, Vcb, &FileOffset )) {

        return FALSE;
    }

    FreeRecordChange = (ULONG) LlFileRecordsFromBytes( Vcb, Vcb->MftScb->Header.FileSize.QuadPart - FileOffset );

    Vcb->MftFreeRecords -= FreeRecordChange;
    Vcb->MftScb->ScbType.Mft.FreeRecordChange -= FreeRecordChange;

    //
    //  Now we want to figure out how many holes we may be removing from the Mft.
    //  Walk through the Mcb and count the holes.
    //

    StartingVcn = LlClustersFromBytes( Vcb, FileOffset );

    NtfsLookupNtfsMcbEntry( &Vcb->MftScb->Mcb,
                            StartingVcn,
                            &NextLcn,
                            &ClusterCount,
                            NULL,
                            NULL,
                            &RangePtr,
                            &Index );

    do {

        //
        //  If this is a hole then update the hole count in the Vcb and
        //  hole change count in the MftScb.
        //

        if (NextLcn == UNUSED_LCN) {

            ULONG HoleChange;

            if (Vcb->FileRecordsPerCluster == 0) {

                HoleChange = ((ULONG)ClusterCount) >> Vcb->MftToClusterShift;

            } else {

                HoleChange = ((ULONG)ClusterCount) << Vcb->MftToClusterShift;
            }

            Vcb->MftHoleRecords -= HoleChange;
            Vcb->MftScb->ScbType.Mft.HoleRecordChange -= HoleChange;
        }

        Index += 1;

    } while (NtfsGetSequentialMcbEntry( &Vcb->MftScb->Mcb,
                                        &RangePtr,
                                        Index,
                                        &NextVcn,
                                        &NextLcn,
                                        &ClusterCount ));

    //
    //  We want to flush the data in the Mft out to disk in
    //  case a lazywrite comes in during a window where we have
    //  removed the allocation but before a possible abort.
    //

    CcFlushCache( &Vcb->MftScb->NonpagedScb->SegmentObject,
                  (PLARGE_INTEGER)&FileOffset,
                  BytesFromFileRecords( Vcb, FreeRecordChange ),
                  &IoStatus );

    ASSERT( IoStatus.Status == STATUS_SUCCESS );

    //
    //  Now do the truncation.
    //

    NtfsDeleteAllocation( IrpContext,
                          Vcb->MftScb->FileObject,
                          Vcb->MftScb,
                          StartingVcn,
                          MAXLONGLONG,
                          TRUE,
                          FALSE );

    return TRUE;
}

NTSTATUS
NtfsIterateMft (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PFILE_REFERENCE FileReference,
    IN FILE_RECORD_WALK FileRecordFunction,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine interates over the MFT.  It calls the FileRecordFunction
    with an Fcb for each existing file on the volume.  The Fcb is owned
    exclusive and Vcb is owned shared.  The starting FileReference number
    is passed in so that iterate can be restarted where is left off.

Arguments:

    Vcb - Pointer to the volume to control for the MFT

    FileReference - Suplies a pointer to the starting file reference number
                    This value is updated as the interator progresses.

    FileRecordFunction - Suplies a pointer to function to be called with
                          each file found in the MFT.

    Context - Passed along to the FileRecordFunction.

Return Value:

    Returns back status of the entire operation.

--*/

{

    ULONG LogFileFullCount = 0;
    NTSTATUS Status = STATUS_SUCCESS;
    PFCB CurrentFcb = NULL;
    BOOLEAN DecrementReferenceCount = FALSE;
    KEVENT Event;
    LARGE_INTEGER Timeout;

    PAGED_CODE();

    KeInitializeEvent( &Event, SynchronizationEvent, FALSE );
    Timeout.QuadPart = 0;

    while (TRUE) {

        FsRtlExitFileSystem();

        //
        //  Check for APC delivery indicating thread death or cancel
        //

        Status = KeWaitForSingleObject( &Event,
                                        Executive,
                                        UserMode,
                                        FALSE,
                                        &Timeout );
        FsRtlEnterFileSystem();

        if (STATUS_TIMEOUT == Status) {
            Status = STATUS_SUCCESS;
        } else {
            break;
        }

        //
        //  If irp has been cancelled break out
        //

        if (IrpContext->OriginatingIrp && IrpContext->OriginatingIrp->Cancel) {

#ifdef BENL_DBG
            KdPrint(( "Ntfs: cancelled mft iteration irp: 0x%x\n", IrpContext->OriginatingIrp ));
#endif
            Status = STATUS_CANCELLED;
            break;
        }


        NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

        try {

            //
            //  Acquire the VCB shared and check whether we should
            //  continue.
            //

            if (!NtfsIsVcbAvailable( Vcb )) {

                //
                //  The volume is going away, bail out.
                //

                Status = STATUS_VOLUME_DISMOUNTED;
                leave;
            }

            //
            //  Set the irp context flags to indicate that we are in the
            //  fsp and that the irp context should not be deleted when
            //  complete request or process exception are called. The in
            //  fsp flag keeps us from raising in a few places.  These
            //  flags must be set inside the loop since they are cleared
            //  under certain conditions.
            //

            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP);

            DecrementReferenceCount = TRUE;

            Status = NtfsTryOpenFcb( IrpContext,
                                     Vcb,
                                     &CurrentFcb,
                                     *FileReference );

            if (!NT_SUCCESS( Status )) {
                leave;
            }

            //
            //  Call the worker function.
            //

            Status = FileRecordFunction( IrpContext, CurrentFcb, Context );

            if (!NT_SUCCESS( Status )) {
                leave;
            }

            //
            //  Complete the request which commits the pending
            //  transaction if there is one and releases of the
            //  acquired resources.  The IrpContext will not
            //  be deleted because the no delete flag is set.
            //

            NtfsCheckpointCurrentTransaction( IrpContext );

            NtfsAcquireFcbTable( IrpContext, Vcb );
            ASSERT(CurrentFcb->ReferenceCount > 0);
            CurrentFcb->ReferenceCount--;
            NtfsReleaseFcbTable( IrpContext, Vcb );
            DecrementReferenceCount = FALSE;
            NtfsTeardownStructures( IrpContext,
                                    CurrentFcb,
                                    NULL,
                                    FALSE,
                                    0,
                                    NULL );

        } finally {

            if (CurrentFcb != NULL) {

                if (DecrementReferenceCount) {


                    NtfsAcquireFcbTable( IrpContext, Vcb );
                    ASSERT(CurrentFcb->ReferenceCount > 0);
                    CurrentFcb->ReferenceCount--;
                    NtfsReleaseFcbTable( IrpContext, Vcb );
                    DecrementReferenceCount = FALSE;
                }

                CurrentFcb = NULL;
            }

            //
            //  Make sure to release any maps in the cached file records in
            //  the Irp Context.
            //

            NtfsPurgeFileRecordCache( IrpContext );
            NtfsReleaseVcb( IrpContext, Vcb );
        }

        //
        //  If a status of not found was return then just continue to
        //  the next file record.
        //

        if (Status == STATUS_NOT_FOUND) {
            Status = STATUS_SUCCESS;
        }

        if (!NT_SUCCESS( Status )) {
            break;
        }

        //
        //  Release resources
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE | IRP_CONTEXT_FLAG_RETAIN_FLAGS );
        NtfsCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

        //
        //  Advance to the next file record.
        //

        (*((LONGLONG UNALIGNED *) FileReference))++;
    }

    return Status;
}


//
//  Local support routine.
//

BOOLEAN
NtfsDefragMftPriv (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This is the main worker routine which performs the Mft defragging.  This routine
    will defrag according to the following priorities.  First try to deallocate the
    tail of the file.  Second rewrite the mapping for the file if necessary.  Finally
    try to find a range of the Mft that we can turn into a hole.  We will only do
    the first and third if we are trying to reclaim disk space.  The second we will
    do to try and keep us from getting into trouble while modify Mft records which
    describe the Mft itself.

Arguments:

    Vcb - This is the Vcb for the volume being defragged.

Return Value:

    BOOLEAN - TRUE if a defrag operation was successfully done, FALSE otherwise.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    BOOLEAN CleanupAttributeContext = FALSE;
    BOOLEAN DefragStepTaken = FALSE;

    PAGED_CODE();

    //
    //  We will acquire the Scb for the Mft for this operation.
    //

    NtfsAcquireExclusiveScb( IrpContext, Vcb->MftScb );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If we don't have a reserved record then reserve one now.
        //

        if (!FlagOn( Vcb->MftReserveFlags, VCB_MFT_RECORD_RESERVED )) {

            NtfsInitializeAttributeContext( &AttrContext );
            CleanupAttributeContext = TRUE;

            //
            //  Lookup the bitmap.  There is an error if we can't find
            //  it.
            //

            if (!NtfsLookupAttributeByCode( IrpContext,
                                            Vcb->MftScb->Fcb,
                                            &Vcb->MftScb->Fcb->FileReference,
                                            $BITMAP,
                                            &AttrContext )) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            (VOID)NtfsReserveMftRecord( IrpContext,
                                        Vcb,
                                        &AttrContext );

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
            CleanupAttributeContext = FALSE;
        }

        //
        //  We now want to test for the three defrag operation we
        //  do.  Start by checking if we are still trying to
        //  recover Mft space for the disk.  This is true if
        //  have begun defragging and are above the lower threshold
        //  or have not begun defragging and are above the upper
        //  threshold.
        //

        NtfsAcquireCheckpoint( IrpContext, Vcb );
        NtfsCheckForDefrag( Vcb );
        NtfsReleaseCheckpoint( IrpContext, Vcb );

        //
        //  If we are actively defragging and can deallocate space
        //  from the tail of the file then do that.  We won't synchronize
        //  testing the flag for the defrag state below since making
        //  the calls is benign in any case.
        //

        if (FlagOn( Vcb->MftDefragState, VCB_MFT_DEFRAG_TRIGGERED )) {

            if (NtfsTruncateMft( IrpContext, Vcb )) {

                try_return( DefragStepTaken = TRUE );
            }
        }

        //
        //  Else if we need to rewrite the mapping for the file do
        //  so now.
        //

        if (FlagOn( Vcb->MftDefragState, VCB_MFT_DEFRAG_EXCESS_MAP )) {

            if (NtfsRewriteMftMapping( IrpContext,
                                       Vcb )) {

                try_return( DefragStepTaken = TRUE );
            }
        }

        //
        //  The last choice is to try to find a candidate for a hole in
        //  the file.  We will walk backwards from the end of the file.
        //

        if (NtfsPerforateMft &&
            FlagOn( Vcb->MftDefragState, VCB_MFT_DEFRAG_TRIGGERED )) {

            if (NtfsCreateMftHole( IrpContext, Vcb )) {

                try_return( DefragStepTaken = TRUE );
            }
        }

        //
        //  We couldn't do any work to defrag.  This means that we can't
        //  even try to defrag unless a file record is freed at some
        //  point.
        //

        NtfsAcquireCheckpoint( IrpContext, Vcb );
        ClearFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_ENABLED );
        NtfsReleaseCheckpoint( IrpContext, Vcb );

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( NtfsDefragMftPriv );

        if (CleanupAttributeContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }

        NtfsReleaseScb( IrpContext, Vcb->MftScb );
    }

    return DefragStepTaken;
}


//
//  Local support routine
//

LONG
NtfsReadMftExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer,
    IN PBCB Bcb,
    IN LONGLONG FileOffset
    )
{
    //
    //  Check if we support this error,
    //  if we didn't fail to  totally page in the first time since we need the original
    //  to copy the mirror one into, or if the offset isn't within the mirror range
    //

    if (!FsRtlIsNtstatusExpected( ExceptionPointer->ExceptionRecord->ExceptionCode ) ||
        (Bcb == NULL) ||
        (FileOffset >= IrpContext->Vcb->Mft2Scb->Header.FileSize.QuadPart)) {

        return EXCEPTION_CONTINUE_SEARCH;
    }

    //
    //  Clear the status field in the IrpContext. We're going to retry in the mirror
    //

    IrpContext->ExceptionStatus = STATUS_SUCCESS;

    return EXCEPTION_EXECUTE_HANDLER;
}


#if  (DBG || defined( NTFS_FREE_ASSERTS ))

//
//  Look for a prior entry in the Fcb table for the same value.
//

VOID
NtfsVerifyFileReference (
    IN PIRP_CONTEXT IrpContext,
    IN PMFT_SEGMENT_REFERENCE MftSegment
    )

{
    MFT_SEGMENT_REFERENCE TestReference;
    ULONG Index = 5;
    FCB_TABLE_ELEMENT Key;
    PFCB_TABLE_ELEMENT Entry;

    TestReference = *MftSegment;
    TestReference.SequenceNumber -= 1;

    NtfsAcquireFcbTable( NULL, IrpContext->Vcb );

    while((TestReference.SequenceNumber != 0) && (Index != 0)) {

        Key.FileReference = TestReference;

        if ((Entry = RtlLookupElementGenericTable( &IrpContext->Vcb->FcbTable, &Key )) != NULL) {

            //
            //  Let's be optimistic and do an unsafe check. If we can't get the resource,
            //  we'll just assume that it's in the process of getting deleted.
            //

            if (!FlagOn( Entry->Fcb->FcbState, FCB_STATE_FILE_DELETED )) {

                if (NtfsAcquireResourceExclusive( IrpContext, Entry->Fcb, FALSE )) {

                    //
                    //  Either the Fcb should be marked as deleted or there should be no
                    //  Scbs lying around to flush.
                    //

                    if (!FlagOn( Entry->Fcb->FcbState, FCB_STATE_FILE_DELETED )) {

                        PLIST_ENTRY Links;
                        PSCB NextScb;

                        Links = Entry->Fcb->ScbQueue.Flink;

                        //
                        //  We don't care if there are Scb's as long as none of them
                        //  represent real data.
                        //

                        while (Links != &Entry->Fcb->ScbQueue) {

                            NextScb = CONTAINING_RECORD( Links, SCB, FcbLinks );
                            if (NextScb->AttributeTypeCode != $UNUSED) {

                                break;
                            }

                            Links = Links->Flink;
                        }

                        //
                        //  Leave the test for deleted in the assert message so the debugger output
                        //  is more descriptive.
                        //

                        ASSERT( FlagOn( Entry->Fcb->FcbState, FCB_STATE_FILE_DELETED ) ||
                                (Links == &Entry->Fcb->ScbQueue) );
                    }
                    NtfsReleaseResource( IrpContext, Entry->Fcb );
                }
            }
        }

        Index -= 1;
        TestReference.SequenceNumber -= 1;
    }

    NtfsReleaseFcbTable( IrpContext, IrpContext->Vcb );
    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\mcbsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    McbSup.c

Abstract:

    This module implements the Ntfs Mcb package.

Author:

    Gary Kimura     [GaryKi]        10-Sep-1994
    Tom Miller      [TomM]

Revision History:

--*/

#include "NtfsProc.h"

#define FIRST_RANGE ((PVOID)1)

#ifndef NTFS_VERIFY_MCB
#define NtfsVerifyNtfsMcb(M)                    NOTHING;
#define NtfsVerifyUncompressedNtfsMcb(M,S,E)    NOTHING;
#endif

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('MFtN')

//
//  Local procedure prototypes
//

ULONG
NtfsMcbLookupArrayIndex (
    IN PNTFS_MCB Mcb,
    IN VCN Vcn
    );

VOID
NtfsInsertNewRange (
    IN PNTFS_MCB Mcb,
    IN LONGLONG StartingVcn,
    IN ULONG ArrayIndex,
    IN BOOLEAN MakeNewRangeEmpty
    );

VOID
NtfsCollapseRanges (
    IN PNTFS_MCB Mcb,
    IN ULONG StartingArrayIndex,
    IN ULONG EndingArrayIndex
    );

VOID
NtfsMcbCleanupLruQueue (
    IN PVOID Parameter
    );

#ifdef NTFS_VERIFY_MCB
VOID
NtfsVerifyNtfsMcb (
    IN PNTFS_MCB Mcb
    );

VOID
NtfsVerifyUncompressedNtfsMcb (
    IN PNTFS_MCB Mcb,
    IN LONGLONG StartingVcn,
    IN LONGLONG EndingVcn
    );
#endif

BOOLEAN
NtfsLockNtfsMcb (
    IN PNTFS_MCB Mcb
    );

VOID
NtfsUnlockNtfsMcb (
    IN PNTFS_MCB Mcb
    );

NtfsGrowMcbArray(
    IN PNTFS_MCB Mcb
    );

//
//  Local macros to ASSERT that caller's resource is exclusive or restart is
//  underway.
//

#define ASSERT_STREAM_EXCLUSIVE(M) {                                    \
    ASSERT( FlagOn( ((PSCB) (M)->FcbHeader)->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ) ||  \
            ExIsResourceAcquiredExclusiveLite((M)->FcbHeader->Resource ));  \
}

//
//  Local macros to enqueue and dequeue elements from the lru queue
//

#define NtfsMcbEnqueueLruEntry(M,E) {                       \
    InsertTailList( &NtfsMcbLruQueue, &(E)->LruLinks );     \
    NtfsMcbCurrentLevel += 1;                               \
}

#define NtfsMcbDequeueLruEntry(M,E) {      \
    if ((E)->LruLinks.Flink != NULL) {     \
        RemoveEntryList( &(E)->LruLinks ); \
        NtfsMcbCurrentLevel -= 1;          \
    }                                      \
}

//
//  Local macro to unload a single array entry
//

#define UnloadEntry(M,I) {                              \
    PNTFS_MCB_ENTRY _Entry;                             \
    _Entry = (M)->NtfsMcbArray[(I)].NtfsMcbEntry;       \
    (M)->NtfsMcbArray[(I)].NtfsMcbEntry = NULL;         \
    if (_Entry != NULL) {                               \
        ExAcquireFastMutex( &NtfsMcbFastMutex );        \
        NtfsMcbDequeueLruEntry( Mcb, _Entry );          \
        ExReleaseFastMutex( &NtfsMcbFastMutex );        \
        FsRtlUninitializeLargeMcb( &_Entry->LargeMcb ); \
        if ((M)->NtfsMcbArraySize != MCB_ARRAY_PHASE1_SIZE) {               \
            NtfsFreePool( _Entry );                       \
        }                                               \
    }                                                   \
}


VOID
NtfsInitializeNtfsMcb (
    IN PNTFS_MCB Mcb,
    IN PNTFS_ADVANCED_FCB_HEADER FcbHeader,
    IN PNTFS_MCB_INITIAL_STRUCTS McbStructs,
    IN POOL_TYPE PoolType
    )

/*++

Routine Description:

    This routine initializes a new Ntfs Mcb structure.

Arguments:

    Mcb - Supplies the Mcb being initialized

    FcbHeader - Supplies a pointer to the Fcb header containing
        the resource to grab when accessing the Mcb

    McbStructs - Initial allocation typically coresident in another
                 structure to handle initial structures for small and
                 medium files.  This structure should be initially zeroed.

    PoolType - Supplies the type of pool to use when
        allocating mapping information storage

Return Value:

    None.

--*/

{
    PNTFS_MCB_ARRAY Array;

    RtlZeroMemory( McbStructs, sizeof(NTFS_MCB_INITIAL_STRUCTS) );

    //
    //  Initialize the fcb header field of the mcb
    //

    Mcb->FcbHeader = FcbHeader;

    //
    //  Initialize the pool type
    //

    Mcb->PoolType = PoolType;

    //
    //  Now initialize the initial array element
    //

    Mcb->NtfsMcbArray = Array = &McbStructs->Phase1.SingleMcbArrayEntry;
    Mcb->NtfsMcbArraySize = MCB_ARRAY_PHASE1_SIZE;
    Mcb->NtfsMcbArraySizeInUse = 1;
    Mcb->FastMutex = FcbHeader->FastMutex;

    //
    //  Initialize the first array entry.
    //

    Array[0].StartingVcn = 0;
    Array[0].EndingVcn = -1;

    //
    //  And return to our caller
    //

    NtfsVerifyNtfsMcb(Mcb);

    return;
}


VOID
NtfsUninitializeNtfsMcb (
    IN PNTFS_MCB Mcb
    )

/*++

Routine Description:

    This routine uninitializes an Ntfs Mcb structure.

Arguments:

    Mcb - Supplies the Mcb being decommissioned

Return Value:

    None.

--*/

{
    ULONG i;
    PNTFS_MCB_ENTRY Entry;

    NtfsVerifyNtfsMcb(Mcb);

    //
    //  Take out the global mutex
    //

    ExAcquireFastMutex( &NtfsMcbFastMutex );

    //
    //  Deallocate the mcb array if it exists.  For every entry in the array
    //  if the mcb entry is not null then remove the entry from the lru
    //  queue, uninitialize the large mcb, and free the pool.
    //

    if (Mcb->NtfsMcbArray != NULL) {

        for (i = 0; i < Mcb->NtfsMcbArraySizeInUse; i += 1) {

            if ((Entry = Mcb->NtfsMcbArray[i].NtfsMcbEntry) != NULL) {

                //
                //  Remove the entry from the lru queue
                //

                NtfsMcbDequeueLruEntry( Mcb, Entry );

                //
                //  Now release the entry
                //

                FsRtlUninitializeLargeMcb( &Entry->LargeMcb );

                //
                //  We can tell from the array count whether this is
                //  the initial entry and does not need to be deallocated.
                //

                if (Mcb->NtfsMcbArraySize > MCB_ARRAY_PHASE1_SIZE) {
                    NtfsFreePool( Entry );
                }
            }
        }

        //
        //  We can tell from the array count whether this is
        //  the initial array entry(s) and do not need to be deallocated.
        //


        if (Mcb->NtfsMcbArraySize > MCB_ARRAY_PHASE2_SIZE) {
            NtfsFreePool( Mcb->NtfsMcbArray );
        }

        Mcb->NtfsMcbArray = NULL;

        //
        //  Clear the fast mutex field.
        //

        Mcb->FastMutex = NULL;
    }

    ExReleaseFastMutex( &NtfsMcbFastMutex );

    //
    //  And return to our caller
    //

    return;
}


ULONG
NtfsNumberOfRangesInNtfsMcb (
    IN PNTFS_MCB Mcb
    )

/*++

Routine Description:

    This routine returns the total number of ranges stored in
    the mcb

Arguments:

    Mcb - Supplies the Mcb being queried

Return Value:

    ULONG - The number of ranges mapped by the input mcb

--*/

{
    ASSERT_STREAM_EXCLUSIVE(Mcb);

    //
    //  Our answer is the number of ranges in use in the mcb
    //

    NtfsVerifyNtfsMcb(Mcb);

    return Mcb->NtfsMcbArraySizeInUse;
}


BOOLEAN
NtfsNumberOfRunsInRange (
    IN PNTFS_MCB Mcb,
    IN PVOID RangePtr,
    OUT PULONG NumberOfRuns
    )

/*++

Routine Description:

    This routine returns the total number of runs stored withing a range

Arguments:

    Mcb - Supplies the Mcb being queried

    RangePtr - Supplies the range to being queried

    NumberOrRuns - Returns the number of run in the specified range
        but only if the range is loaded

Return Value:

    BOOLEAN - TRUE if the range is loaded and then output variable
        is valid and FALSE if the range is not loaded.

--*/

{
    VCN TempVcn;
    LCN TempLcn;
    PNTFS_MCB_ENTRY Entry = (PNTFS_MCB_ENTRY)RangePtr;

    //
    //  Null RangePtr means first range
    //

    if (Entry == FIRST_RANGE) {
        Entry = Mcb->NtfsMcbArray[0].NtfsMcbEntry;

        //
        //  If not loaded, return FALSE
        //

        if (Entry == NULL) {
            return FALSE;
        }
    }

    ASSERT_STREAM_EXCLUSIVE(Mcb);

    NtfsVerifyNtfsMcb(Mcb);

    ASSERT( Mcb == Entry->NtfsMcb );

    *NumberOfRuns = FsRtlNumberOfRunsInLargeMcb( &Entry->LargeMcb );

    //
    //  Check if the current entry ends with a hole and increment the run count
    //  to reflect this.  Detect the case where the range has length 0 for a
    //  file with no allocation.  EndingVcn will be less than the starting Vcn
    //  in this case.
    //

    if (!FsRtlLookupLastLargeMcbEntry( &Entry->LargeMcb, &TempVcn, &TempLcn )) {

        //
        //  If this is a non-zero length range then add one for the implied hole.
        //

        if (Entry->NtfsMcbArray->EndingVcn >= Entry->NtfsMcbArray->StartingVcn) {

            *NumberOfRuns += 1;
        }

    //
    //  There is an entry then check if it reaches the end boundary of the range.
    //

    } else if (TempVcn != (Entry->NtfsMcbArray->EndingVcn - Entry->NtfsMcbArray->StartingVcn)) {

        *NumberOfRuns += 1;
    }

    return TRUE;
}


BOOLEAN
NtfsLookupLastNtfsMcbEntry (
    IN PNTFS_MCB Mcb,
    OUT PLONGLONG Vcn,
    OUT PLONGLONG Lcn
    )

/*++

Routine Description:

    This routine returns the last mapping stored in the mcb

Arguments:

    Mcb - Supplies the Mcb being queried

    Vcn - Receives the Vcn of the last mapping

    Lcn - Receives the Lcn corresponding to the Vcn

Return Value:

    BOOLEAN - TRUE if the mapping exist and FALSE if no mapping has been
        defined or it is unloaded

--*/

{
    PNTFS_MCB_ENTRY Entry;
    LONGLONG StartingVcn;

    ASSERT_STREAM_EXCLUSIVE(Mcb);

    NtfsVerifyNtfsMcb(Mcb);

    //
    //  Get the last entry and compute its starting vcn, and make sure
    //  the entry is valid
    //

    if ((Entry = Mcb->NtfsMcbArray[Mcb->NtfsMcbArraySizeInUse - 1].NtfsMcbEntry) == NULL) {

        return FALSE;
    }

    StartingVcn = Mcb->NtfsMcbArray[Mcb->NtfsMcbArraySizeInUse - 1].StartingVcn;

    //
    //  Otherwise lookup the last entry and compute the real vcn
    //

    if (FsRtlLookupLastLargeMcbEntry( &Entry->LargeMcb, Vcn, Lcn )) {

        *Vcn += StartingVcn;

    } else {

        *Vcn = Mcb->NtfsMcbArray[Mcb->NtfsMcbArraySizeInUse - 1].EndingVcn;
        *Lcn = UNUSED_LCN;
    }

    return TRUE;
}


BOOLEAN
NtfsLookupNtfsMcbEntry (
    IN PNTFS_MCB Mcb,
    IN LONGLONG Vcn,
    OUT PLONGLONG Lcn OPTIONAL,
    OUT PLONGLONG CountFromLcn OPTIONAL,
    OUT PLONGLONG StartingLcn OPTIONAL,
    OUT PLONGLONG CountFromStartingLcn OPTIONAL,
    OUT PVOID *RangePtr OPTIONAL,
    OUT PULONG RunIndex OPTIONAL
    )

/*++

Routine Description:

    This routine is used to query mapping information

Arguments:

    Mcb - Supplies the Mcb being queried

    Vcn - Supplies the Vcn being queried

    Lcn - Optionally receives the lcn corresponding to the input vcn

    CountFromLcn - Optionally receives the number of clusters following
        the lcn in the run

    StartingLcn - Optionally receives the start of the run containing the
        input vcn

    CountFromStartingLcn - Optionally receives the number of clusters in
        the entire run

    RangePtr - Optionally receives the index for the range that we're returning

    RunIndex - Optionally receives the index for the run within the range that
        we're returning

Return Value:

    BOOLEAN - TRUE if the mapping exists and FALSE if it doesn't exist
        or if it is unloaded.

--*/

{
    ULONG LocalRangeIndex;

    PNTFS_MCB_ENTRY Entry;

    NtfsAcquireNtfsMcbMutex( Mcb );

    NtfsVerifyNtfsMcb(Mcb);

    //
    //  Do a basic bounds check
    //

    ASSERT( Mcb->NtfsMcbArraySizeInUse > 0 );

    //
    //  Locate the array entry that has the hit for the input vcn, and
    //  make sure it is valid.  Also set the output range index if present
    //

    LocalRangeIndex = NtfsMcbLookupArrayIndex(Mcb, Vcn);

    //
    //  Now lookup the large mcb entry.  The Vcn we pass in is
    //  biased by the starting vcn.  If we miss then we'll just return false
    //

    if (((Entry = Mcb->NtfsMcbArray[LocalRangeIndex].NtfsMcbEntry) == NULL) ||
        (Vcn > Entry->NtfsMcbArray->EndingVcn) ||
        (Vcn < Entry->NtfsMcbArray->StartingVcn)) {

        ASSERT( (Entry == NULL) || (Vcn > Entry->NtfsMcbArray->EndingVcn) || (Vcn < 0) );

        if (ARGUMENT_PRESENT(RangePtr)) {

            *RangePtr = (PVOID)Entry;

            //
            //  If this is the first range, always normalize back to the reserved pointer,
            //  since this is the only range which can move if we split out of our
            //  initial static allocation!
            //

            if (LocalRangeIndex == 0) {
                *RangePtr = FIRST_RANGE;
            }
        }

        NtfsReleaseNtfsMcbMutex( Mcb );
        return FALSE;
    }

    if (!FsRtlLookupLargeMcbEntry( &Entry->LargeMcb,
                                   Vcn - Mcb->NtfsMcbArray[LocalRangeIndex].StartingVcn,
                                   Lcn,
                                   CountFromLcn,
                                   StartingLcn,
                                   CountFromStartingLcn,
                                   RunIndex )) {

        //
        //  If we go off the end of the Mcb, but are in the range, then we
        //  return a hole to the end of the range.
        //

        if (ARGUMENT_PRESENT(Lcn)) {
            *Lcn = UNUSED_LCN;
        }

        if (ARGUMENT_PRESENT(CountFromLcn)) {
            *CountFromLcn = Mcb->NtfsMcbArray[LocalRangeIndex].EndingVcn - Vcn + 1;
        }

        if (ARGUMENT_PRESENT(StartingLcn)) {
            *StartingLcn = UNUSED_LCN;
        }

        if (ARGUMENT_PRESENT(RunIndex)) {
            *RunIndex = FsRtlNumberOfRunsInLargeMcb( &Entry->LargeMcb );
        }

        if (ARGUMENT_PRESENT( CountFromStartingLcn )) {

            //
            //  If there are no runs in the Mcb then specify
            //  a hole for the full range.
            //

            *CountFromStartingLcn = Mcb->NtfsMcbArray[LocalRangeIndex].EndingVcn -
                                    Mcb->NtfsMcbArray[LocalRangeIndex].StartingVcn + 1;

            if (*RunIndex != 0) {

                VCN LastVcn;
                LCN LastLcn;

                FsRtlLookupLastLargeMcbEntry( &Entry->LargeMcb,
                                              &LastVcn,
                                              &LastLcn );

                ASSERT( LastVcn <= *CountFromStartingLcn );
                *CountFromStartingLcn -= (LastVcn + 1);
            }
        }
    }

    if (ARGUMENT_PRESENT(RangePtr)) {

        *RangePtr = (PVOID)Entry;

        //
        //  If this is the first range, always normalize back to the reserved pointer,
        //  since this is the only range which can move if we split out of our
        //  initial static allocation!
        //

        if (LocalRangeIndex == 0) {
            *RangePtr = FIRST_RANGE;
        }
    }

    //
    //  Now move this entry to the tail of the lru queue.
    //  We need to take out the global mutex to do this.
    //  Only do this if he is already in the queue - we can
    //  deadlock if we take a fault in the paging file path.
    //

    if (Entry->LruLinks.Flink != NULL) {

        if (ExTryToAcquireFastMutex( &NtfsMcbFastMutex )) {

            NtfsMcbDequeueLruEntry( Mcb, Entry );
            NtfsMcbEnqueueLruEntry( Mcb, Entry );

            ExReleaseFastMutex( &NtfsMcbFastMutex );
        }
    }

    NtfsReleaseNtfsMcbMutex( Mcb );

    return TRUE;
}


BOOLEAN
NtfsGetNextNtfsMcbEntry (
    IN PNTFS_MCB Mcb,
    IN PVOID *RangePtr,
    IN ULONG RunIndex,
    OUT PLONGLONG Vcn,
    OUT PLONGLONG Lcn,
    OUT PLONGLONG Count
    )

/*++

Routine Description:

    This routine returns the range denoted by the type index values

Arguments:

    Mcb - Supplies the Mcb being queried

    RangePtr - Supplies the pointer to the range being queried, or NULL for the first one,
               returns next range

    RunIndex - Supplies the index within then being queried, or MAXULONG for first in next

    Vcn - Receives the starting Vcn of the run being returned

    Lcn - Receives the starting Lcn of the run being returned or unused
        lbn value of -1

    Count - Receives the number of clusters within this run

Return Value:

    BOOLEAN - TRUE if the two input indices are valid and FALSE if the
        the index are not valid or if the range is not loaded

--*/

{
    PNTFS_MCB_ENTRY Entry = (PNTFS_MCB_ENTRY)*RangePtr;
    BOOLEAN Result = FALSE;

    NtfsAcquireNtfsMcbMutex( Mcb );

    NtfsVerifyNtfsMcb(Mcb);

    try {

        //
        //  Null RangePtr means first range
        //

        if (Entry == FIRST_RANGE) {
            Entry = Mcb->NtfsMcbArray[0].NtfsMcbEntry;
        }

        //
        //  If there is no entry 0, get out.
        //

        if (Entry == NULL) {

            try_return(Result = FALSE);
        }

        //
        //  RunIndex of MAXULONG means first of next
        //

        if (RunIndex == MAXULONG) {

            //
            //  If we are already in the last range, get out.
            //

            if (Entry->NtfsMcbArray == (Mcb->NtfsMcbArray + Mcb->NtfsMcbArraySizeInUse - 1)) {

                try_return(Result = FALSE);
            }

            *RangePtr = Entry = (Entry->NtfsMcbArray + 1)->NtfsMcbEntry;
            RunIndex = 0;
        }

        //
        //  If there is no next entry, get out.
        //

        if (Entry == NULL) {

            try_return(Result = FALSE);
        }

        ASSERT( Mcb == Entry->NtfsMcb );

        //
        //  Lookup the large mcb entry.  If we get a miss then the we're
        //  beyond the end of the ntfs mcb and should return false
        //

        if (!FsRtlGetNextLargeMcbEntry( &Entry->LargeMcb, RunIndex, Vcn, Lcn, Count )) {

            //
            //  Our caller should only be off by one or two (if there is
            //  a hole) runs.
            //

            ASSERT(RunIndex <= (FsRtlNumberOfRunsInLargeMcb(&Entry->LargeMcb) + 1));

            //
            //  Get the first Vcn past the last Vcn in a run.  It is -1 if there
            //  are no runs.
            //

            if (!FsRtlLookupLastLargeMcbEntry( &Entry->LargeMcb, Vcn, Lcn )) {

                *Vcn = -1;
            }

            *Vcn += Entry->NtfsMcbArray->StartingVcn + 1;

            //
            //  If that one is beyond the ending Vcn, then get out.
            //  Otherwise there is a hole at the end of the range, and we
            //  must return that when he is reading one index beyond the
            //  last run.  If we have a run index beyond that, then it is
            //  time to return FALSE as well.
            //

            if ((*Vcn  > Entry->NtfsMcbArray->EndingVcn) ||
                (RunIndex > FsRtlNumberOfRunsInLargeMcb(&Entry->LargeMcb))) {

                try_return(Result = FALSE);
            }

            //
            //  If we go off the end of the Mcb, but are in the range, then we
            //  return a hole to the end of the range.
            //

            *Lcn = UNUSED_LCN;
            *Count = Entry->NtfsMcbArray->EndingVcn - *Vcn + 1;

        } else {

            //
            //  Otherwise we have a hit on the large mcb and need to bias the returned
            //  vcn by the starting vcn value for this range.
            //

            *Vcn = *Vcn + Entry->NtfsMcbArray->StartingVcn;
        }

        //
        //  Make certain we aren't returning a VCN that maps over to
        //  the next range.
        //

        ASSERT(*Vcn - 1 != Entry->NtfsMcbArray->EndingVcn);

        Result = TRUE;

    try_exit: NOTHING;

    } finally {

        NtfsReleaseNtfsMcbMutex( Mcb );
    }

    return Result;
}


BOOLEAN
NtfsSplitNtfsMcb (
    IN PNTFS_MCB Mcb,
    IN LONGLONG Vcn,
    IN LONGLONG Amount
    )

/*++

Routine Description:

    This routine splits an mcb

Arguments:

    Mcb - Supplies the Mcb being maniuplated

    Vcn - Supplies the Vcn to be shifted

    Amount - Supplies the amount to shift by

Return Value:

    BOOLEAN - TRUE if worked okay and FALSE otherwise

--*/

{
    ULONG RangeIndex;
    PNTFS_MCB_ENTRY Entry;
    ULONG i;

    ASSERT_STREAM_EXCLUSIVE(Mcb);

    NtfsVerifyNtfsMcb(Mcb);

    //
    //  Locate the array entry that has the hit for the input vcn
    //

    RangeIndex = NtfsMcbLookupArrayIndex(Mcb, Vcn);

    Entry = Mcb->NtfsMcbArray[RangeIndex].NtfsMcbEntry;

    //
    //  Now if the entry is not null then we have to call the large
    //  mcb package to split the mcb.  Bias the vcn by the starting vcn
    //

    if (Entry != NULL) {

        if (!FsRtlSplitLargeMcb( &Entry->LargeMcb,
                                 Vcn - Mcb->NtfsMcbArray[RangeIndex].StartingVcn,
                                 Amount )) {

            NtfsVerifyNtfsMcb(Mcb);

            return FALSE;
        }
    }

    //
    //  Even if the entry is null we will march through the rest of our ranges
    //  updating the ending vcn and starting vcn as we go.  We will update the
    //  ending vcn for the range we split and only update the starting vcn
    //  for the last entry, because its ending vcn is already max long long
    //

    for (i = RangeIndex + 1; i < Mcb->NtfsMcbArraySizeInUse; i += 1) {

        Mcb->NtfsMcbArray[i - 1].EndingVcn += Amount;
        Mcb->NtfsMcbArray[i].StartingVcn += Amount;
    }

    //
    //  And grow the last range unless it would wrap.
    //

    if ((Mcb->NtfsMcbArray[i - 1].EndingVcn + Amount) > Mcb->NtfsMcbArray[i - 1].EndingVcn) {
        Mcb->NtfsMcbArray[i - 1].EndingVcn += Amount;
    }

    //
    //  Then return to our caller
    //

    NtfsVerifyNtfsMcb(Mcb);

    return TRUE;
}


VOID
NtfsRemoveNtfsMcbEntry (
    IN PNTFS_MCB Mcb,
    IN LONGLONG StartingVcn,
    IN LONGLONG Count
    )

/*++

Routine Description:

    This routine removes an range of mappings from the Mcb.  After
    the call the mapping for the range will be a hole.  It is an
    error to call this routine with the mapping range being removed
    also being unloaded.

Arguments:

    Mcb - Supplies the Mcb being maniuplated

    StartingVcn - Supplies the starting Vcn to remove

    Count - Supplies the number of mappings to remove

Return Value:

    None.

--*/

{
    LONGLONG Vcn;
    LONGLONG RunLength;
    LONGLONG RemainingCount;

    ULONG RangeIndex;
    PNTFS_MCB_ENTRY Entry;
    VCN EntryStartingVcn;
    VCN EntryEndingVcn;

    ASSERT_STREAM_EXCLUSIVE(Mcb);

    NtfsVerifyNtfsMcb(Mcb);

    //
    //  Loop through the range of vcn's that we need to remove
    //

    for (Vcn = StartingVcn, RemainingCount = Count;
         Vcn < StartingVcn + Count;
         Vcn += RunLength, RemainingCount -= RunLength) {

        //
        //  Locate the array entry that has the hit for the vcn
        //

        RangeIndex = NtfsMcbLookupArrayIndex(Mcb, Vcn);

        Entry = Mcb->NtfsMcbArray[RangeIndex].NtfsMcbEntry;
        EntryStartingVcn = Mcb->NtfsMcbArray[RangeIndex].StartingVcn;
        EntryEndingVcn = Mcb->NtfsMcbArray[RangeIndex].EndingVcn;

        //
        //  Compute how much to delete from the entry.  We will delete to
        //  to end of the entry or as much as count is remaining
        //

        RunLength = EntryEndingVcn - Vcn + 1;

        //
        //  If the Mcb is set up correctly, the only way we can get
        //  RunLength == 0 is if the Mcb is completely empty.  Assume
        //  that this is error recovery, and that it is ok.
        //

        if ((Entry == NULL) || (RunLength == 0)) {
            break;
        }

        //
        //  If that is too much, then just delete what we need.
        //

        if ((ULONGLONG)RunLength > (ULONGLONG)RemainingCount) { RunLength = RemainingCount; }

        //
        //  Now remove the mapping from the large mcb, bias the vcn
        //  by the start of the range
        //

        FsRtlRemoveLargeMcbEntry( &Entry->LargeMcb, Vcn - EntryStartingVcn,  RunLength );
    }

    NtfsVerifyNtfsMcb(Mcb);

    return;
}


BOOLEAN
NtfsAddNtfsMcbEntry (
    IN PNTFS_MCB Mcb,
    IN LONGLONG Vcn,
    IN LONGLONG Lcn,
    IN LONGLONG RunCount,
    IN BOOLEAN AlreadySynchronized
    )

/*++

Routine Description:

    This routine add a new entry to a Mcb

Arguments:

    Mcb - Supplies the Mcb being modified

    Vcn - Supplies the Vcn that we are providing a mapping for

    Lcn - Supplies the Lcn corresponding to the input Vcn if run count is non zero

    RunCount - Supplies the size of the run following the hole

    AlreadySynchronized - Indicates if the caller has already acquired the mcb mutex

Return Value:

    BOOLEAN - TRUE if the mapping was added successfully and FALSE otherwise

--*/

{
    LONGLONG LocalVcn;
    LONGLONG LocalLcn;
    LONGLONG RunLength;
    LONGLONG RemainingCount;

    ULONG RangeIndex;
    PNTFS_MCB_ENTRY Entry;
    PNTFS_MCB_ENTRY NewEntry = NULL;
    LONGLONG EntryStartingVcn;
    LONGLONG EntryEndingVcn;
    LONGLONG PrevEndingVcn;

    BOOLEAN Result = FALSE;

    if (!AlreadySynchronized) { NtfsAcquireNtfsMcbMutex( Mcb ); }

    NtfsVerifyNtfsMcb(Mcb);

    try {

        //
        //  Loop through the range of vcn's that we need to add
        //

        for (LocalVcn = Vcn, LocalLcn = Lcn, RemainingCount = RunCount;
             LocalVcn < Vcn + RunCount;
             LocalVcn += RunLength, LocalLcn += RunLength, RemainingCount -= RunLength) {

            //
            //  Locate the array entry that has the hit for the vcn
            //

            RangeIndex = NtfsMcbLookupArrayIndex(Mcb, LocalVcn);

            Entry = Mcb->NtfsMcbArray[RangeIndex].NtfsMcbEntry;
            EntryStartingVcn = Mcb->NtfsMcbArray[RangeIndex].StartingVcn;

            //
            //  Now if the entry doesn't exist then we'll need to create one
            //

            if (Entry == NULL) {

                //
                //  See if we need to get the first entry in the initial structs.
                //

                if (Mcb->NtfsMcbArraySize == MCB_ARRAY_PHASE1_SIZE) {
                    Entry = &CONTAINING_RECORD(&Mcb->NtfsMcbArray[0],
                                               NTFS_MCB_INITIAL_STRUCTS,
                                               Phase1.SingleMcbArrayEntry)->Phase1.McbEntry;

                //
                //  Allocate pool and initialize the fields in of the entry
                //

                } else {
                    NewEntry =
                    Entry = NtfsAllocatePoolWithTag( Mcb->PoolType, sizeof(NTFS_MCB_ENTRY), 'MftN' );
                }

                //
                //  Initialize the entry but don't put into the Mcb array until
                //  initialization is complete.
                //

                Entry->NtfsMcb = Mcb;
                Entry->NtfsMcbArray = &Mcb->NtfsMcbArray[RangeIndex];
                FsRtlInitializeLargeMcb( &Entry->LargeMcb, Mcb->PoolType );

                //
                //  Now put the entry into the lru queue under the protection of
                //  the global mutex
                //

                ExAcquireFastMutex( &NtfsMcbFastMutex );

                //
                //  Only put paged Mcb entries in the queue.
                //

                if (Mcb->PoolType == PagedPool) {
                    NtfsMcbEnqueueLruEntry( Mcb, Entry );
                }

                //
                //  Now that the initialization is complete we can store
                //  this entry in the Mcb array.  This will now be cleaned
                //  up with the Scb if there is a future error.
                //

                Mcb->NtfsMcbArray[RangeIndex].NtfsMcbEntry = Entry;
                NewEntry = NULL;

                //
                //  Check if we should fire off the cleanup lru queue work item
                //

                if ((NtfsMcbCurrentLevel > NtfsMcbHighWaterMark) && !NtfsMcbCleanupInProgress) {

                    NtfsMcbCleanupInProgress = TRUE;

                    ExInitializeWorkItem( &NtfsMcbWorkItem, NtfsMcbCleanupLruQueue, NULL );

                    ExQueueWorkItem( &NtfsMcbWorkItem, CriticalWorkQueue );
                }

                ExReleaseFastMutex( &NtfsMcbFastMutex );
            }

            //
            //  Get out if he is trying to add a hole.  At least we created the LargeMcb
            //

            if (Lcn == UNUSED_LCN) {
                try_return( Result = TRUE );
            }

            //
            //  If this request goes beyond the end of the range,
            //  and it is the last range, and we will simply
            //  grow it.
            //

            EntryEndingVcn = LocalVcn + RemainingCount - 1;

            if ((EntryEndingVcn > Mcb->NtfsMcbArray[RangeIndex].EndingVcn) &&
                ((RangeIndex + 1) == Mcb->NtfsMcbArraySizeInUse)) {

                PrevEndingVcn = Mcb->NtfsMcbArray[RangeIndex].EndingVcn;
                Mcb->NtfsMcbArray[RangeIndex].EndingVcn = EntryEndingVcn;

            //
            //  Otherwise, just insert enough of this run to go to the end
            //  of the range.
            //

            } else {
                EntryEndingVcn = Mcb->NtfsMcbArray[RangeIndex].EndingVcn;
            }

            //
            //  At this point the entry exists so now compute how much to add
            //  We will add to end of the entry or as much as count allows us
            //

            RunLength = EntryEndingVcn - LocalVcn + 1;

            if (((ULONGLONG)RunLength) > ((ULONGLONG)RemainingCount)) { RunLength = RemainingCount; }

            //
            //  We need to deal with the case where a range is larger than (2^32 - 1) clusters.
            //  If there are no runs in this range then the state is legal.  Otherwise we
            //  need to split up the entry.
            //

            if (EntryEndingVcn - EntryStartingVcn >= MAX_CLUSTERS_PER_RANGE) {

                //
                //  We should only be adding this entry as part of a transaction and the
                //  snapshot limits should force this range to be unloaded on error.
                //

                ASSERT( ExIsResourceAcquiredExclusiveLite( ((PSCB) (Mcb->FcbHeader))->Header.Resource ));
                ASSERT( ((PSCB) (Mcb->FcbHeader))->ScbSnapshot != NULL);

                if (Mcb->NtfsMcbArray[RangeIndex].StartingVcn < ((PSCB) (Mcb->FcbHeader))->ScbSnapshot->LowestModifiedVcn) {

                    ((PSCB) (Mcb->FcbHeader))->ScbSnapshot->LowestModifiedVcn = Mcb->NtfsMcbArray[RangeIndex].StartingVcn;
                }

                if (Mcb->NtfsMcbArray[RangeIndex].EndingVcn > ((PSCB) (Mcb->FcbHeader))->ScbSnapshot->HighestModifiedVcn) {

                    ((PSCB) (Mcb->FcbHeader))->ScbSnapshot->HighestModifiedVcn = Mcb->NtfsMcbArray[RangeIndex].EndingVcn;
                }

                //
                //  If the count in the this Mcb is non-zero then we must be growing the
                //  range.  We can simply split at the previoius end of the Mcb.  It must
                //  be legal.
                //

                if (FsRtlNumberOfRunsInLargeMcb( &Entry->LargeMcb ) != 0) {

                    ASSERT( PrevEndingVcn < EntryEndingVcn );

                    NtfsInsertNewRange( Mcb, PrevEndingVcn + 1, RangeIndex, FALSE );

                //
                //  There are no runs currently in this range.  If we are at the
                //  start of the range then split at our maximum range value.
                //  Otherwise split at the Vcn being inserted.  We don't need
                //  to be too smart here.  The mapping pair package will decide where
                //  the final range values are.
                //

                } else if (LocalVcn == EntryStartingVcn) {

                    NtfsInsertNewRange( Mcb,
                                        EntryStartingVcn + MAX_CLUSTERS_PER_RANGE,
                                        RangeIndex,
                                        FALSE );

                //
                //  Go ahead and split at the CurrentVcn.  On our next pass we will
                //  trim the length of this new range if necessary.
                //

                } else {

                    NtfsInsertNewRange( Mcb,
                                        LocalVcn,
                                        RangeIndex,
                                        FALSE );
                }

                //
                //  Set the run length to 0 and go back to the start of the loop.
                //  We will encounter the inserted range on the next pass.
                //

                RunLength = 0;
                continue;
            }

            //
            //  Now add the mapping from the large mcb, bias the vcn
            //  by the start of the range
            //

            ASSERT( (LocalVcn - EntryStartingVcn) >= 0 );

            if (!FsRtlAddLargeMcbEntry( &Entry->LargeMcb,
                                        LocalVcn - EntryStartingVcn,
                                        LocalLcn,
                                        RunLength )) {

                try_return( Result = FALSE );
            }
        }

        Result = TRUE;

    try_exit: NOTHING;

    } finally {

        NtfsVerifyNtfsMcb(Mcb);

        if (!AlreadySynchronized) { NtfsReleaseNtfsMcbMutex( Mcb ); }

        if (NewEntry != NULL) { NtfsFreePool( NewEntry ); }
    }

    return Result;
}


VOID
NtfsUnloadNtfsMcbRange (
    IN PNTFS_MCB Mcb,
    IN LONGLONG StartingVcn,
    IN LONGLONG EndingVcn,
    IN BOOLEAN TruncateOnly,
    IN BOOLEAN AlreadySynchronized
    )

/*++

Routine Description:

    This routine unloads the mapping stored in the Mcb.  After
    the call everything from startingVcn and endingvcn is now unmapped and unknown.

Arguments:

    Mcb - Supplies the Mcb being manipulated

    StartingVcn - Supplies the first Vcn which is no longer being mapped

    EndingVcn - Supplies the last vcn to be unloaded

    TruncateOnly - Supplies TRUE if last affected range should only be
                   truncated, or FALSE if it should be unloaded (as during
                   error recovery)

    AlreadySynchronized - Supplies TRUE if our caller already owns the Mcb mutex.

Return Value:

    None.

--*/

{
    ULONG StartingRangeIndex;
    ULONG EndingRangeIndex;

    ULONG i;

    if (!AlreadySynchronized) { NtfsAcquireNtfsMcbMutex( Mcb ); }

    //
    //  Verify that we've been called to unload a valid range.  If we haven't,
    //  then there's nothing we can unload, so we just return here.  Still,
    //  we'll assert so we can see why we were called with an invalid range.
    //

    if ((StartingVcn < 0) || (EndingVcn < StartingVcn)) {

        //
        //  The only legal case is if the range is empty.
        //

        ASSERT( StartingVcn == EndingVcn + 1 );
        if (!AlreadySynchronized) { NtfsReleaseNtfsMcbMutex( Mcb ); }
        return;
    }

    NtfsVerifyNtfsMcb(Mcb);
    NtfsVerifyUncompressedNtfsMcb(Mcb,StartingVcn,EndingVcn);

    //
    //  Get the starting and ending range indices for this call
    //

    StartingRangeIndex = NtfsMcbLookupArrayIndex( Mcb, StartingVcn );
    EndingRangeIndex = NtfsMcbLookupArrayIndex( Mcb, EndingVcn );

    //
    //  Use try finally to enforce common termination processing.
    //

    try {

        //
        //  For all paged Mcbs, just unload all ranges touched by the
        //  unload range, and collapse with any unloaded neighbors.
        //

        if (Mcb->PoolType == PagedPool) {

            //
            //  Handle truncate case.  The first test insures that we only truncate
            //  the Mcb were were initialized with (we cannot deallocate it).
            //
            //  Also only truncate if ending is MAXLONGLONG and we are not eliminating
            //  the entire range, because that is the common truncate case, and we
            //  do not want to unload the last range every time we truncate on close.
            //

            if (((StartingRangeIndex == 0) && (Mcb->NtfsMcbArraySizeInUse == 1))

                ||

                (TruncateOnly && (StartingVcn != Mcb->NtfsMcbArray[StartingRangeIndex].StartingVcn))) {

                //
                //  If this is not a truncate call, make sure to eliminate the
                //  entire range.
                //

                if (!TruncateOnly) {
                    StartingVcn = 0;
                }

                if (Mcb->NtfsMcbArray[StartingRangeIndex].NtfsMcbEntry != NULL) {

                    FsRtlTruncateLargeMcb( &Mcb->NtfsMcbArray[StartingRangeIndex].NtfsMcbEntry->LargeMcb,
                                           StartingVcn - Mcb->NtfsMcbArray[StartingRangeIndex].StartingVcn );
                }

                Mcb->NtfsMcbArray[StartingRangeIndex].EndingVcn = StartingVcn - 1;

                StartingRangeIndex += 1;
            }

            //
            //  Unload entries that are beyond the starting range index
            //

            for (i = StartingRangeIndex; i <= EndingRangeIndex; i += 1) {

                UnloadEntry( Mcb, i );
            }

            //
            //  If there is a preceding unloaded range, we must collapse him too.
            //

            if ((StartingRangeIndex != 0) &&
                (Mcb->NtfsMcbArray[StartingRangeIndex - 1].NtfsMcbEntry == NULL)) {

                StartingRangeIndex -= 1;
            }

            //
            //  If there is a subsequent unloaded range, we must collapse him too.
            //

            if ((EndingRangeIndex != (Mcb->NtfsMcbArraySizeInUse - 1)) &&
                (Mcb->NtfsMcbArray[EndingRangeIndex + 1].NtfsMcbEntry == NULL)) {

                EndingRangeIndex += 1;
            }

            //
            //  Now collapse empty ranges.
            //

            if (StartingRangeIndex < EndingRangeIndex) {
                NtfsCollapseRanges( Mcb, StartingRangeIndex, EndingRangeIndex );
            }

            try_return(NOTHING);
        }

        //
        //  For nonpaged Mcbs, there is only one range and we truncate it.
        //

        ASSERT((StartingRangeIndex | EndingRangeIndex) == 0);

        if (Mcb->NtfsMcbArray[0].NtfsMcbEntry != NULL) {

            FsRtlTruncateLargeMcb( &Mcb->NtfsMcbArray[0].NtfsMcbEntry->LargeMcb, StartingVcn );
        }

        Mcb->NtfsMcbArray[0].EndingVcn = StartingVcn - 1;

    try_exit: NOTHING;

    } finally {

        //
        //  Truncate all unused entries from the end by dropping ArraySizeInUse
        //  to be the index of the last loaded entry + 1.
        //

        for (i = Mcb->NtfsMcbArraySizeInUse - 1;
             (Mcb->NtfsMcbArray[i].NtfsMcbEntry == NULL);
             i--) {

            //
            //  If the first range is unloaded, set it to its initial state
            //  (empty) and break out.
            //

            if (i==0) {
                Mcb->NtfsMcbArray[0].EndingVcn = -1;
                break;
            }
        }
        Mcb->NtfsMcbArraySizeInUse = i + 1;

        //
        //  See if we broke anything.
        //

        NtfsVerifyNtfsMcb(Mcb);
        NtfsVerifyUncompressedNtfsMcb(Mcb,StartingVcn,EndingVcn);

        if (!AlreadySynchronized) { NtfsReleaseNtfsMcbMutex( Mcb ); }
    }

    return;
}


VOID
NtfsDefineNtfsMcbRange (
    IN PNTFS_MCB Mcb,
    IN LONGLONG StartingVcn,
    IN LONGLONG EndingVcn,
    IN BOOLEAN AlreadySynchronized
    )

/*++

Routine Description:

    This routine splits an existing range within the Mcb into two ranges

Arguments:

    Mcb - Supplies the Mcb being modified

    StartingVcn - Supplies the beginning of the new range being split

    EndingVcn - Supplies the ending vcn to include in this new range

    AlreadySynchronized - Indicates if the caller has already acquired the mcb mutex

Return Value:

    None.

--*/

{
    ULONG StartingRangeIndex, EndingRangeIndex;

    if (!AlreadySynchronized) { NtfsAcquireNtfsMcbMutex( Mcb ); }

    NtfsVerifyNtfsMcb(Mcb);

    //
    //  Make sure we're of the right pool type
    //
    //  If the ending vcn is less than or equal to the starting vcn then we will no op
    //  this call
    //

    if ((Mcb->PoolType != PagedPool) || (EndingVcn < StartingVcn)) {

        if (!AlreadySynchronized) { NtfsReleaseNtfsMcbMutex( Mcb ); }

        return;
    }

    try {

        PNTFS_MCB_ARRAY StartingArray;
        PNTFS_MCB_ARRAY EndingArray;
        PNTFS_MCB_ENTRY StartingEntry;
        PNTFS_MCB_ENTRY EndingEntry;
        ULONG i;

        //
        //  Locate the Starting Mcb
        //

        StartingRangeIndex = NtfsMcbLookupArrayIndex( Mcb, StartingVcn );

        //
        //  Locate the ending Mcb
        //

        EndingRangeIndex = NtfsMcbLookupArrayIndex( Mcb, EndingVcn );
        EndingArray = &Mcb->NtfsMcbArray[EndingRangeIndex];
        EndingEntry = EndingArray->NtfsMcbEntry;

        //
        //  Special case:  extending last range where StartingVcn matches
        //

        if (((EndingRangeIndex + 1) == Mcb->NtfsMcbArraySizeInUse) &&
            (StartingVcn == EndingArray->StartingVcn) &&
            (EndingArray->EndingVcn <= EndingVcn)) {

            //
            //  Since this range already starts with the desired Vcn
            //  we adjust the end to match the caller's request
            //

            EndingArray->EndingVcn = EndingVcn;

            ASSERT( ((EndingVcn - StartingVcn) < MAX_CLUSTERS_PER_RANGE) ||
                    (EndingEntry == NULL) ||
                    (FsRtlNumberOfRunsInLargeMcb( &EndingEntry->LargeMcb ) == 0) );

            leave;
        }

        //
        //  Special case:  handling defining a range after the end of the file
        //

        if (StartingVcn > EndingArray->EndingVcn) {

            LONGLONG OldEndingVcn = EndingArray->EndingVcn;

            //
            //  Has to be the last range.
            //

            ASSERT( StartingRangeIndex == EndingRangeIndex );
            ASSERT( (EndingRangeIndex + 1) == Mcb->NtfsMcbArraySizeInUse );

            //
            //  First extend the last range to include our new range.
            //

            EndingArray->EndingVcn = EndingVcn;

            //
            //  We will be adding a new range and inserting or growing the
            //  previous range up to the new range.  If the previous range is
            //  *empty* but has an NtfsMcbEntry then we want to unload the entry.
            //  Otherwise we will grow that range to the correct value but
            //  the Mcb won't contain the clusters for the range.  We want
            //  to unload that range and update the OldEndingVcn value so
            //  as not to create two empty ranges prior to this.
            //

            if ((OldEndingVcn == -1) &&
                (EndingArray->NtfsMcbEntry != NULL)) {

                ASSERT( EndingRangeIndex == 0 );

                UnloadEntry( Mcb, EndingRangeIndex );
            }

            //
            //  Create the range the caller specified.
            //

            NtfsInsertNewRange( Mcb, StartingVcn, EndingRangeIndex, TRUE );
            DebugDoit( StartingArray = EndingArray = NULL );
            DebugDoit( StartingEntry = EndingEntry = NULL );

            //
            //  If this range does not abut the previous last range, *and*
            //  the previous range was not *empty*, then we have to define a
            //  range to contain the unloaded space in the middle.
            //

            if (((OldEndingVcn + 1) < StartingVcn) &&
                ((OldEndingVcn + 1) != 0)) {

                NtfsInsertNewRange( Mcb, OldEndingVcn + 1, StartingRangeIndex, TRUE );
                DebugDoit( StartingArray = EndingArray = NULL );
                DebugDoit( StartingEntry = EndingEntry = NULL );
            }

            ASSERT( ((EndingVcn - StartingVcn) < MAX_CLUSTERS_PER_RANGE) ||
                    (Mcb->NtfsMcbArray[NtfsMcbLookupArrayIndex( Mcb, EndingVcn )].NtfsMcbEntry == NULL) ||
                    (FsRtlNumberOfRunsInLargeMcb( &Mcb->NtfsMcbArray[NtfsMcbLookupArrayIndex( Mcb, EndingVcn )].NtfsMcbEntry->LargeMcb ) == 0) );

            leave;
        }

        //
        //  Check if we really need to insert a new range at the ending vcn
        //  we only need to do the work if there is not already one at that vcn
        //  and this is not the last range
        //

        if (EndingVcn < EndingArray->EndingVcn) {

            NtfsInsertNewRange( Mcb, EndingVcn + 1, EndingRangeIndex, FALSE );
            DebugDoit( StartingArray = EndingArray = NULL );
            DebugDoit( StartingEntry = EndingEntry = NULL );

            //
            //  Recache pointers since NtfsMcbArray may have moved
            //

            EndingArray = &Mcb->NtfsMcbArray[EndingRangeIndex];
            EndingEntry = EndingArray->NtfsMcbEntry;

            ASSERT( EndingArray->EndingVcn == EndingVcn );
        }

        //
        //  Determine location for insertion
        //

        StartingArray = &Mcb->NtfsMcbArray[StartingRangeIndex];
        StartingEntry = StartingArray->NtfsMcbEntry;

        //
        //  Check if we really need to insert a new range at the starting vcn
        //  we only need to do the work if this Mcb doesn't start at the
        //  requested Vcn
        //

        if (StartingArray->StartingVcn < StartingVcn) {

            NtfsInsertNewRange( Mcb, StartingVcn, StartingRangeIndex, FALSE );
            DebugDoit( StartingArray = EndingArray = NULL );
            DebugDoit( StartingEntry = EndingEntry = NULL );

            StartingRangeIndex++;
            StartingArray = &Mcb->NtfsMcbArray[StartingRangeIndex];
            StartingEntry = StartingArray->NtfsMcbEntry;
            ASSERT( StartingArray->StartingVcn == StartingVcn );

            EndingRangeIndex++;
            // EndingArray = &Mcb->NtfsMcbArray[EndingRangeIndex];
            // EndingEntry = EndingArray->NtfsMcbEntry;
            // ASSERT( EndingArray->EndingVcn == EndingVcn );
        }

        ASSERT( StartingArray->StartingVcn == StartingVcn );
        // ASSERT( EndingArray->EndingVcn == EndingVcn );

        //
        //  At this point, we have a Vcn range beginning at StartingVcn stored in
        //  NtfsMcbArray[StartingRangeIndex] AND ending at EndingVcb which is the
        //  end of NtfsMcbArray[StartingRangeIndex]. This is a collection (>= 1)
        //  of NtfsMcbEntry's.  Our caller expects to have these reduced to
        //  a single run.  Note that our caller should never break the restriction
        //  on maximum number clusters per range.
        //

        while (StartingRangeIndex != EndingRangeIndex) {

            VCN Vcn;
            BOOLEAN MoreEntries;
            LCN Lcn;
            LONGLONG Count;
            ULONG Index;

            PNTFS_MCB_ARRAY NextArray;
            PNTFS_MCB_ENTRY NextEntry;

            //
            //  We merge the contents of NtfsMcbArray[StartingRangeIndex + 1] into
            //  NtfsMcbArray[StartingRangeIndex]
            //

            //
            //  Look up the first Vcn to move in the second Mcb.  If this
            //  Mcb consists of one large hole then there is nothing to
            //  move.
            //

            NextArray = &Mcb->NtfsMcbArray[StartingRangeIndex + 1];
            NextEntry = NextArray->NtfsMcbEntry;

            //
            //  We should never exceed our limit on the maximum number of clusters.
            //

            ASSERT( ((NextArray->EndingVcn - StartingArray->StartingVcn + 1) <= MAX_CLUSTERS_PER_RANGE) ||
                    ((FsRtlNumberOfRunsInLargeMcb( &StartingEntry->LargeMcb ) == 0) &&
                     (FsRtlNumberOfRunsInLargeMcb( &NextEntry->LargeMcb ) == 0)) );

            Vcn = 0;
            MoreEntries = FsRtlLookupLargeMcbEntry( &NextEntry->LargeMcb,
                                                    Vcn,
                                                    &Lcn,
                                                    &Count,
                                                    NULL,
                                                    NULL,
                                                    &Index );

            //
            //  Loop to move entries over.
            //

            //
            // this is the case described by bug #9054.
            // the mcb has somehow? been incorrectly split
            // so this will force everything to be unloaded
            // instead of half loaded and half unloaded
            //
            // the assert is here simply for debug purposes.
            // if this assert fires then we simply want to step
            // thru the code and examine the mcb state to
            // be certain that our assumtions about this bug
            // are correct.  the actual bug scenario could not
            // be reproed so this code path is un-tested.
            //

            ASSERT( StartingEntry != NULL );

            if (StartingEntry != NULL) {

                while (MoreEntries) {

                    //
                    //  If this entry is not a hole, move it.
                    //

                    if (Lcn != UNUSED_LCN) {

                        FsRtlAddLargeMcbEntry( &StartingEntry->LargeMcb,
                                               (Vcn + NextArray->StartingVcn) - StartingArray->StartingVcn,
                                               Lcn,
                                               Count );
                    }

                    Index += 1;

                    MoreEntries = FsRtlGetNextLargeMcbEntry( &NextEntry->LargeMcb,
                                                             Index,
                                                             &Vcn,
                                                             &Lcn,
                                                             &Count );
                }

                ASSERT( StartingArray->EndingVcn < NextArray->EndingVcn );
                StartingArray->EndingVcn = NextArray->EndingVcn;
            }

            //
            //  We've completely emptied the next Mcb.  Unload it.
            //

            UnloadEntry( Mcb, StartingRangeIndex + 1 );

            Mcb->NtfsMcbArraySizeInUse -= 1;

            //
            //  Compact the array
            //

            RtlMoveMemory( StartingArray + 1,
                           StartingArray + 2,
                           sizeof( NTFS_MCB_ARRAY ) * (Mcb->NtfsMcbArraySizeInUse - (StartingRangeIndex + 1))
                           );

            //
            //  Adjust the backpointers
            //

            for (i = StartingRangeIndex + 1;
                 i < Mcb->NtfsMcbArraySizeInUse;
                 i += 1) {

                if (Mcb->NtfsMcbArray[i].NtfsMcbEntry != NULL) {
                    Mcb->NtfsMcbArray[i].NtfsMcbEntry->NtfsMcbArray = &Mcb->NtfsMcbArray[i];
                }
            }

            EndingRangeIndex--;
        }

    } finally {

        NtfsVerifyNtfsMcb(Mcb);

        if (!AlreadySynchronized) { NtfsReleaseNtfsMcbMutex( Mcb ); }
    }

    return;
}


//
//  Local support routines
//

ULONG
NtfsMcbLookupArrayIndex (
    IN PNTFS_MCB Mcb,
    IN VCN Vcn
    )

/*++

Routine Description:

    This routines searches the mcb array for an entry that contains
    the input vcn value

Arguments:

    Mcb - Supplies the Mcb being queried

    Vcn - Supplies the Vcn to lookup

Return Value:

    ULONG - The index of the entry containing the input Vcn value

--*/

{
    ULONG Index;
    ULONG MinIndex;
    ULONG MaxIndex;

    NtfsVerifyNtfsMcb(Mcb);

    //
    //  Do a quick binary search for the entry containing the vcn
    //

    MinIndex = 0;
    MaxIndex = Mcb->NtfsMcbArraySizeInUse - 1;

    while (TRUE) {

        Index = (MaxIndex + MinIndex) / 2;

        if ((Mcb->NtfsMcbArray[Index].StartingVcn > Vcn) &&
            (Index != 0)) {

            MaxIndex = Index - 1;

        } else if ((Mcb->NtfsMcbArray[Index].EndingVcn < Vcn) &&
                   (Index != Mcb->NtfsMcbArraySizeInUse - 1)) {

            MinIndex = Index + 1;

        } else {

            return Index;
        }
    }
}


//
//  Local support routines
//

VOID
NtfsInsertNewRange (
    IN PNTFS_MCB Mcb,
    IN LONGLONG StartingVcn,
    IN ULONG ArrayIndex,
    IN BOOLEAN MakeNewRangeEmpty
    )

/*++

    This routine is used to add a new range at the specified vcn and index location.
    Since this routine will resize the NtfsMcbArray, the caller must be sure to
    invalidate all cached pointers to NtfsMcbArray entries.

Arguments:

    Mcb - Supplies the Mcb being modified

    StartingVcn - Supplies the vcn for the new range

    ArrayIndex - Supplies the index currently containing the starting vcn

    MakeNewRangeEmpty - TRUE if the caller wants the new range unloaded regardless
                        of the state of the current range

Return Value:

    None.

--*/

{
    ULONG i;
    PNTFS_MCB_ENTRY Entry;
    PNTFS_MCB_ENTRY NewEntry;

    NtfsVerifyNtfsMcb(Mcb);

    //
    //  Check if we need to grow the array
    //

    if (Mcb->NtfsMcbArraySizeInUse >= Mcb->NtfsMcbArraySize) {
        NtfsGrowMcbArray( Mcb );
    }

    //
    //  Now move entries that are beyond the array index over by one to make
    //  room for the new entry
    //

    if (ArrayIndex + 2 <= Mcb->NtfsMcbArraySizeInUse) {

        RtlMoveMemory( &Mcb->NtfsMcbArray[ArrayIndex + 2],
                       &Mcb->NtfsMcbArray[ArrayIndex + 1],
                       sizeof(NTFS_MCB_ARRAY) * (Mcb->NtfsMcbArraySizeInUse - ArrayIndex - 1));

        for (i = ArrayIndex + 2; i < Mcb->NtfsMcbArraySizeInUse + 1; i += 1) {

            if (Mcb->NtfsMcbArray[i].NtfsMcbEntry != NULL) {

                Mcb->NtfsMcbArray[i].NtfsMcbEntry->NtfsMcbArray = &Mcb->NtfsMcbArray[i];
            }
        }
    }

    //
    //  Increment our in use count by one
    //

    Mcb->NtfsMcbArraySizeInUse += 1;

    //
    //  Now fix the starting and ending Vcn values for the old entry and the
    //  new entry
    //

    Mcb->NtfsMcbArray[ArrayIndex + 1].StartingVcn = StartingVcn;
    Mcb->NtfsMcbArray[ArrayIndex + 1].EndingVcn = Mcb->NtfsMcbArray[ArrayIndex].EndingVcn;
    Mcb->NtfsMcbArray[ArrayIndex + 1].NtfsMcbEntry = NULL;

    Mcb->NtfsMcbArray[ArrayIndex].EndingVcn = StartingVcn - 1;

    //
    //  Now if the entry is old entry is not null then we have a bunch of work to do
    //

    if (!MakeNewRangeEmpty && (Entry = Mcb->NtfsMcbArray[ArrayIndex].NtfsMcbEntry) != NULL) {

        LONGLONG Vcn;
        LONGLONG Lcn;
        LONGLONG RunLength;
        ULONG Index;
        BOOLEAN FreeNewEntry = FALSE;

        //
        //  Use a try-finally in case the Mcb initialization fails.
        //

        try {

            //
            //  Allocate the new entry slot
            //

            NewEntry = NtfsAllocatePoolWithTag( Mcb->PoolType, sizeof(NTFS_MCB_ENTRY), 'MftN' );

            FreeNewEntry = TRUE;
            NewEntry->NtfsMcb = Mcb;
            NewEntry->NtfsMcbArray = &Mcb->NtfsMcbArray[ArrayIndex + 1];
            FsRtlInitializeLargeMcb( &NewEntry->LargeMcb, Mcb->PoolType );

            ExAcquireFastMutex( &NtfsMcbFastMutex );
            NtfsMcbEnqueueLruEntry( Mcb, NewEntry );
            ExReleaseFastMutex( &NtfsMcbFastMutex );

            //
            //  Now that the initialization is complete we can store
            //  this entry in the Mcb array.  This will now be cleaned
            //  up with the Scb if there is a future error.
            //

            Mcb->NtfsMcbArray[ArrayIndex + 1].NtfsMcbEntry = NewEntry;
            FreeNewEntry = FALSE;

            //
            //  Lookup the entry containing the starting vcn in the old entry and put it
            //  in the new entry.  But only if the entry exists otherwise we know that
            //  the large mcb doesn't extend into the new range
            //

            if (FsRtlLookupLargeMcbEntry( &Entry->LargeMcb,
                                          StartingVcn - Mcb->NtfsMcbArray[ArrayIndex].StartingVcn,
                                          &Lcn,
                                          &RunLength,
                                          NULL,
                                          NULL,
                                          &Index )) {

                if (Lcn != UNUSED_LCN) {

                    FsRtlAddLargeMcbEntry( &NewEntry->LargeMcb,
                                           0,
                                           Lcn,
                                           RunLength );
                }

                //
                //  Now for every run in the old entry that is beyond the starting vcn we will
                //  copy it into the new entry. This will also copy over the dummy run at the end
                //  of the mcb if it exists
                //

                for (i = Index + 1; FsRtlGetNextLargeMcbEntry( &Entry->LargeMcb, i, &Vcn, &Lcn, &RunLength ); i += 1) {

                    if (Lcn != UNUSED_LCN) {
                        ASSERT( (Vcn - (StartingVcn - Mcb->NtfsMcbArray[ArrayIndex].StartingVcn)) >= 0 );
                        FsRtlAddLargeMcbEntry( &NewEntry->LargeMcb,
                                               Vcn - (StartingVcn - Mcb->NtfsMcbArray[ArrayIndex].StartingVcn),
                                               Lcn,
                                               RunLength );
                    }
                }

                //
                //  Now modify the old mcb to be smaller and put in the dummy run
                //

                FsRtlTruncateLargeMcb( &Entry->LargeMcb,
                                       StartingVcn - Mcb->NtfsMcbArray[ArrayIndex].StartingVcn );
            }

        } finally {

            if (FreeNewEntry) { NtfsFreePool( NewEntry ); }
        }
    }

    NtfsVerifyNtfsMcb(Mcb);

    return;
}


//
//  Local support routines
//

VOID
NtfsCollapseRanges (
    IN PNTFS_MCB Mcb,
    IN ULONG StartingArrayIndex,
    IN ULONG EndingArrayIndex
    )

/*++

Routine Description:

    This routine will remove the indicated array entries

Arguments:

    Mcb - Supplies the Mcb being modified

    StartingArrayIndex - Supplies the first index to remove

    EndingArrayIndex - Supplies the last index to remove

Return Value:

    None.

--*/

{
    ULONG i;

    NtfsVerifyNtfsMcb(Mcb);

    //
    //  Make sure all the ranges are unloaded.
    //

    DebugDoit(

        for (i = StartingArrayIndex; i <= EndingArrayIndex; i++) {
            ASSERT(Mcb->NtfsMcbArray[i].NtfsMcbEntry == NULL);
        }
    );

    //
    //  We keep the first entry by we need to copy over
    //  the ending vcn of the last entry
    //

    Mcb->NtfsMcbArray[StartingArrayIndex].EndingVcn = Mcb->NtfsMcbArray[EndingArrayIndex].EndingVcn;

    //
    //  Check if we need to move the ending entries up the array
    //  if so then move them forward, and adjust the back pointers.
    //

    if (EndingArrayIndex < Mcb->NtfsMcbArraySizeInUse - 1) {

        RtlMoveMemory( &Mcb->NtfsMcbArray[StartingArrayIndex + 1],
                       &Mcb->NtfsMcbArray[EndingArrayIndex + 1],
                       sizeof(NTFS_MCB_ARRAY) * (Mcb->NtfsMcbArraySizeInUse - EndingArrayIndex - 1));

        for (i = StartingArrayIndex + 1;
             i <= (StartingArrayIndex + Mcb->NtfsMcbArraySizeInUse - EndingArrayIndex - 1);
             i += 1) {

            if (Mcb->NtfsMcbArray[i].NtfsMcbEntry != NULL) {

                Mcb->NtfsMcbArray[i].NtfsMcbEntry->NtfsMcbArray = &Mcb->NtfsMcbArray[i];
            }
        }
    }

    //
    //  Decrement the in use count and return to our caller
    //

    Mcb->NtfsMcbArraySizeInUse -= (EndingArrayIndex - StartingArrayIndex);

    NtfsVerifyNtfsMcb(Mcb);

    return;
}


//
//  Local support routine
//

VOID
NtfsMcbCleanupLruQueue (
    IN PVOID Parameter
    )

/*++

Routine Description:

    This routine is called as an ex work queue item and its job is
    to free up the lru queue until we reach the low water mark


Arguments:

    Parameter - ignored

Return Value:

    None.

--*/

{
    PLIST_ENTRY Links;

    PNTFS_MCB Mcb;
    PNTFS_MCB_ARRAY Array;
    PNTFS_MCB_ENTRY Entry;

    UNREFERENCED_PARAMETER( Parameter );

    //
    //  Grab the global lock
    //

    ExAcquireFastMutex( &NtfsMcbFastMutex );

    try {

        //
        //  Scan through the lru queue until we either exhaust the queue
        //  or we've trimmed enough
        //

        for (Links = NtfsMcbLruQueue.Flink;
             (Links != &NtfsMcbLruQueue) && (NtfsMcbCurrentLevel > NtfsMcbLowWaterMark);
             Links = Links->Flink ) {

            //
            //  Get the entry and the mcb it points to
            //

            Entry = CONTAINING_RECORD( Links, NTFS_MCB_ENTRY, LruLinks );

            Mcb = Entry->NtfsMcb;

            //
            //  Skip this entry if it is in the open attribute table.
            //

            if (((PSCB)(Mcb->FcbHeader))->NonpagedScb->OpenAttributeTableIndex != 0) {

                continue;
            }

            //
            //  Try and lock the mcb
            //

            if (NtfsLockNtfsMcb( Mcb )) {

                NtfsVerifyNtfsMcb(Mcb);

                //
                //  The previous test was an unsafe test.  Check again in case
                //  this entry has been added.
                //

                if (((PSCB)(Mcb->FcbHeader))->NonpagedScb->OpenAttributeTableIndex == 0) {

                    //
                    //  We locked the mcb so we can remove this entry, but
                    //  first backup our links pointer so we can continue with the loop
                    //

                    Links = Links->Blink;

                    //
                    //  Get a point to the array entry and then remove this entry and return
                    //  it to pool
                    //

                    Array = Entry->NtfsMcbArray;

                    Array->NtfsMcbEntry = NULL;
                    NtfsMcbDequeueLruEntry( Mcb, Entry );
                    FsRtlUninitializeLargeMcb( &Entry->LargeMcb );
                    if (Mcb->NtfsMcbArraySize != 1) {
                        NtfsFreePool( Entry );
                    }
                }

                NtfsUnlockNtfsMcb( Mcb );
            }
        }

    } finally {

        //
        //  Say we're done with the cleanup so that another one can be fired off when
        //  necessary
        //

        NtfsMcbCleanupInProgress = FALSE;

        ExReleaseFastMutex( &NtfsMcbFastMutex );
    }

    //
    //  Return to our caller
    //

    return;
}


VOID 
NtfsSwapMcbs (
    IN PNTFS_MCB McbTarget,
    IN PNTFS_MCB McbSource
    ) 
/*++

Routine Description:

    This routine swaps the mapping pairs between two mcbs atomically

Arguments:

    McbTarget -
    
    McbSource - 

Return Value:

    None.

--*/
{
    ULONG TempNtfsMcbArraySizeInUse;
    ULONG TempNtfsMcbArraySize;
    PNTFS_MCB_ARRAY TempNtfsMcbArray;
    ULONG Index;

    ASSERT( McbTarget->PoolType == McbSource->PoolType );

    //
    //  Grab the mutex in the original and new  mcb to block everyone out
    //  

    NtfsAcquireNtfsMcbMutex( McbTarget );
    NtfsAcquireNtfsMcbMutex( McbSource );

    try {
        
        //
        //  Check if we need to grow either array so they are in the general form
        //  In the general form we can swap the two by switching the array of mcb entries
        //

        if (McbSource->NtfsMcbArraySize == MCB_ARRAY_PHASE1_SIZE) {
            NtfsGrowMcbArray( McbSource );
        }
        if (McbSource->NtfsMcbArraySize == MCB_ARRAY_PHASE2_SIZE) {
            NtfsGrowMcbArray( McbSource );
        }

        if (McbTarget->NtfsMcbArraySize == MCB_ARRAY_PHASE1_SIZE) {
            NtfsGrowMcbArray( McbTarget);
        }
        if (McbTarget->NtfsMcbArraySize == MCB_ARRAY_PHASE2_SIZE) {
            NtfsGrowMcbArray( McbTarget );
        }

        //
        //  Swap the arrays in the two mcb's
        // 

        TempNtfsMcbArraySizeInUse = McbTarget->NtfsMcbArraySizeInUse;                
        TempNtfsMcbArraySize = McbTarget->NtfsMcbArraySize;
        TempNtfsMcbArray = McbTarget->NtfsMcbArray;

        McbTarget->NtfsMcbArray = McbSource->NtfsMcbArray;
        McbTarget->NtfsMcbArraySize = McbSource->NtfsMcbArraySize;
        McbTarget->NtfsMcbArraySizeInUse = McbSource->NtfsMcbArraySizeInUse;

        McbSource->NtfsMcbArray = TempNtfsMcbArray;
        McbSource->NtfsMcbArraySize = TempNtfsMcbArraySize;
        McbSource->NtfsMcbArraySizeInUse = TempNtfsMcbArraySizeInUse;

        //  
        //  Fixup the backptr in the array entries to point the the correct mcb
        //

        for (Index=0; Index < McbSource->NtfsMcbArraySize; Index++) {
            if (McbSource->NtfsMcbArray[Index].NtfsMcbEntry != NULL) {
                McbSource->NtfsMcbArray[Index].NtfsMcbEntry->NtfsMcb = McbSource;
            }
        }

        for (Index=0; Index < McbTarget->NtfsMcbArraySize; Index++) {
            if (McbTarget->NtfsMcbArray[Index].NtfsMcbEntry != NULL) {
                McbTarget->NtfsMcbArray[Index].NtfsMcbEntry->NtfsMcb = McbTarget;
            }
        }
    
    } finally {
        NtfsReleaseNtfsMcbMutex( McbSource );
        NtfsReleaseNtfsMcbMutex( McbTarget );
    }
}


//
//  Local support routine
//

BOOLEAN
NtfsLockNtfsMcb (
    IN PNTFS_MCB Mcb
    )

/*++

Routine Description:

    This routine attempts to get the Fcb resource(s) exclusive so that
    ranges may be unloaded.

Arguments:

    Mcb - Supplies the mcb being queried

Return Value:

--*/

{
    //
    //  Try to acquire paging resource exclusive.
    //

    if ((Mcb->FcbHeader->PagingIoResource == NULL) ||
        ExAcquireResourceExclusiveLite(Mcb->FcbHeader->PagingIoResource, FALSE)) {

        //
        //  Now we can try to acquire the main resource exclusively as well.
        //

        if (ExAcquireResourceExclusiveLite(Mcb->FcbHeader->Resource, FALSE)) {
            return TRUE;
        }

        //
        //  We failed to acquire the paging I/O resource, so free the main one
        //  on the way out.
        //

        if (Mcb->FcbHeader->PagingIoResource != NULL) {
            ExReleaseResourceLite( Mcb->FcbHeader->PagingIoResource );
        }
    }

    //
    //  Could not get this file exclusive.
    //

    return FALSE;
}


//
//  Local support routine
//

VOID
NtfsUnlockNtfsMcb (
    IN PNTFS_MCB Mcb
    )

/*++

Routine Description:

    This routine verifies that an mcb is properly formed

Arguments:

    Mcb - Supplies the mcb being queried

Return Value:

    None.

--*/

{
    //
    //  If there is a paging I/O resource, release it first.
    //

    if (Mcb->FcbHeader->PagingIoResource != NULL) {
        ExReleaseResourceLite(Mcb->FcbHeader->PagingIoResource);
    }

    //
    //  Now release the main resource.
    //

    ExReleaseResourceLite(Mcb->FcbHeader->Resource);
}

//
//  Local support routine
//  


NtfsGrowMcbArray(
    IN PNTFS_MCB Mcb
    )
/*++

Routine Description:

    This routine grows the mcb array. If its phase1 - then it will be promoted to phase2
    If its phase2 it will become the general form. If its the general form 8 new entries will be added.

Arguments:

    Mcb - Supplies the mcb being grown

Return Value:

    None.

--*/
{
    PNTFS_MCB_ARRAY NewArray;
    ULONG OldArraySize = Mcb->NtfsMcbArraySize;
    PNTFS_MCB_ENTRY Entry;

    //
    //  Test for initial case where we only have one array entry.
    //

    if (Mcb->NtfsMcbArraySize == MCB_ARRAY_PHASE1_SIZE) {

        //
        //  Convince ourselves that we do not have to move the array entry.
        //

        ASSERT(FIELD_OFFSET(NTFS_MCB_INITIAL_STRUCTS, Phase1.SingleMcbArrayEntry) ==
               FIELD_OFFSET(NTFS_MCB_INITIAL_STRUCTS, Phase2.ThreeMcbArrayEntries));

        if (Mcb->NtfsMcbArray[0].NtfsMcbEntry != NULL) {

            //
            //  Allocate a new Mcb Entry, copy the current one over and change the pointer.
            //

            Entry = NtfsAllocatePoolWithTag( Mcb->PoolType, sizeof(NTFS_MCB_ENTRY), 'MftN' );

            //
            //  Once space is allocated, dequeue the old entry.
            //

            ExAcquireFastMutex( &NtfsMcbFastMutex );
            NtfsMcbDequeueLruEntry( Mcb, Mcb->NtfsMcbArray[0].NtfsMcbEntry );

            RtlCopyMemory( Entry, Mcb->NtfsMcbArray[0].NtfsMcbEntry, sizeof(NTFS_MCB_ENTRY) );

            Mcb->NtfsMcbArray[0].NtfsMcbEntry = Entry;

            NtfsMcbEnqueueLruEntry( Mcb, Entry );
            ExReleaseFastMutex( &NtfsMcbFastMutex );
        }

        //
        //  Now change to using the three array elements
        //

        Mcb->NtfsMcbArraySize = MCB_ARRAY_PHASE2_SIZE;

    } else {

        ULONG i;

        //
        //  If we do then allocate an array that can contain 8 more entires
        //

        NewArray = NtfsAllocatePoolWithTag( Mcb->PoolType, sizeof(NTFS_MCB_ARRAY) * (Mcb->NtfsMcbArraySize + 8), 'mftN' );
        Mcb->NtfsMcbArraySize += 8;

        //
        //  Copy over the memory from the old array to the new array and then
        //  for every loaded entry we need to adjust its back pointer to the
        //  array
        //

        RtlCopyMemory( NewArray, Mcb->NtfsMcbArray, sizeof(NTFS_MCB_ARRAY) * OldArraySize );

        for (i = 0; i < Mcb->NtfsMcbArraySizeInUse; i += 1) {

            if (NewArray[i].NtfsMcbEntry != NULL) {

                NewArray[i].NtfsMcbEntry->NtfsMcbArray = &NewArray[i];
            }
        }

        //
        //  Free the old array if it was not the original array.
        //

        if (OldArraySize > MCB_ARRAY_PHASE2_SIZE) {
           NtfsFreePool( Mcb->NtfsMcbArray );
        }

        Mcb->NtfsMcbArray = NewArray;
    }

    //
    //  Zero the new part of the array.
    //

    ASSERT(sizeof(NTFS_MCB_ARRAY) == ((PCHAR)&NewArray[1] - (PCHAR)&NewArray[0]));

    RtlZeroMemory( &Mcb->NtfsMcbArray[OldArraySize],
                   (Mcb->NtfsMcbArraySize - OldArraySize) * sizeof(NTFS_MCB_ARRAY) );
}

#ifdef NTFS_VERIFY_MCB

//
//  Local support routine
//

VOID
NtfsVerifyNtfsMcb (
    IN PNTFS_MCB Mcb
    )

/*++

Routine Description:

    This routine verifies that an mcb is properly formed

Arguments:

    Mcb - Supplies the mcb being queried

Return Value:

--*/

{
    ULONG i;
    PNTFS_MCB_ARRAY Array;
    PNTFS_MCB_ENTRY Entry;

    LONGLONG Vbn;
    LONGLONG Lbn;

    ASSERT(Mcb->FcbHeader != NULL);
    ASSERT(Mcb->FcbHeader->NodeTypeCode != 0);

    ASSERT((Mcb->PoolType == PagedPool) || (Mcb->PoolType == NonPagedPool));

    ASSERT(Mcb->NtfsMcbArraySizeInUse <= Mcb->NtfsMcbArraySize);

    for (i = 0; i < Mcb->NtfsMcbArraySizeInUse; i += 1) {

        Array = &Mcb->NtfsMcbArray[i];

        ASSERT(((i == 0) && (Array->StartingVcn == 0)) ||
               ((i != 0) && (Array->StartingVcn != 0)));

        ASSERT(Array->StartingVcn <= (Array->EndingVcn + 1));

        if ((Entry = Array->NtfsMcbEntry) != NULL) {

            ASSERT(Entry->NtfsMcb == Mcb);
            ASSERT(Entry->NtfsMcbArray == Array);

            if (FsRtlLookupLastLargeMcbEntry( &Entry->LargeMcb, &Vbn, &Lbn )) {
                ASSERT( Vbn <= (Array->EndingVcn - Array->StartingVcn) );
            }
        }
    }
}


//
//  Local support routine
//

VOID
NtfsVerifyUncompressedNtfsMcb (
    IN PNTFS_MCB Mcb,
    IN LONGLONG StartingVcn,
    IN LONGLONG EndingVcn
    )

/*++

Routine Description:

    This routines checks if an mcb is for an uncompressed scb and then
    checks that there are no holes in the mcb.  Holes within the range being
    removed are legal provided EndingVcn is max long long.

Arguments:

    Mcb - Supplies the Mcb being examined

    StartingVcn - The starting Vcn being unloaded

    EndingVcn - The ending Vcn being unloaded

Return Value:

    None

--*/

{
    ULONG i;
    ULONG j;
    PNTFS_MCB_ARRAY Array;
    PNTFS_MCB_ENTRY Entry;

    LONGLONG Vbn;
    LONGLONG Lbn;
    LONGLONG Count;

    //
    //  Check if the scb is compressed
    //

    if (((PSCB)Mcb->FcbHeader)->CompressionUnit != 0) { return; }

    //
    //  For each large mcb in the ntfs mcb we will make sure it doesn't
    //  have any holes.
    //

    for (i = 0; i < Mcb->NtfsMcbArraySizeInUse; i += 1) {

        Array = &Mcb->NtfsMcbArray[i];

        if ((Entry = Array->NtfsMcbEntry) != NULL) {

            for (j = 0; FsRtlGetNextLargeMcbEntry(&Entry->LargeMcb,j,&Vbn,&Lbn,&Count); j += 1) {

                ASSERT((Lbn != -1) ||
                       ((Vbn + Array->StartingVcn >= StartingVcn) && (EndingVcn == MAXLONGLONG)) ||
                       FlagOn(((PSCB)Mcb->FcbHeader)->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS));
            }            
        }
    }

    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\nodetype.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    NodeType.h

Abstract:

    This module defines all of the node type codes used in this development
    shell.  Every major data structure in the file system is assigned a node
    type code that is.  This code is the first CSHORT in the structure and is
    followed by a CSHORT containing the size, in bytes, of the structure.

Author:

    Gary Kimura     [GaryKi]        21-May-1991

Revision History:

--*/

#ifndef _NODETYPE_
#define _NODETYPE_

typedef CSHORT NODE_TYPE_CODE;
typedef NODE_TYPE_CODE *PNODE_TYPE_CODE;

#define NTC_UNDEFINED                    ((NODE_TYPE_CODE)0x0000)

#define NTFS_NTC_DATA_HEADER             ((NODE_TYPE_CODE)0x0700)
#define NTFS_NTC_VCB                     ((NODE_TYPE_CODE)0x0701)
#define NTFS_NTC_FCB                     ((NODE_TYPE_CODE)0x0702)
#define NTFS_NTC_SCB_INDEX               ((NODE_TYPE_CODE)0x0703)
#define NTFS_NTC_SCB_ROOT_INDEX          ((NODE_TYPE_CODE)0x0704)
#define NTFS_NTC_SCB_DATA                ((NODE_TYPE_CODE)0x0705)
#define NTFS_NTC_SCB_MFT                 ((NODE_TYPE_CODE)0x0706)
#define NTFS_NTC_SCB_NONPAGED            ((NODE_TYPE_CODE)0x0707)
#define NTFS_NTC_CCB_INDEX               ((NODE_TYPE_CODE)0x0708)
#define NTFS_NTC_CCB_DATA                ((NODE_TYPE_CODE)0x0709)
#define NTFS_NTC_IRP_CONTEXT             ((NODE_TYPE_CODE)0x070A)
#define NTFS_NTC_LCB                     ((NODE_TYPE_CODE)0x070B)
#define NTFS_NTC_PREFIX_ENTRY            ((NODE_TYPE_CODE)0x070C)
#define NTFS_NTC_QUOTA_CONTROL           ((NODE_TYPE_CODE)0x070D)
#define NTFS_NTC_USN_RECORD              ((NODE_TYPE_CODE)0x070E)



typedef CSHORT NODE_BYTE_SIZE;

//
//  So all records start with
//
//  typedef struct _RECORD_NAME {
//      NODE_TYPE_CODE NodeTypeCode;
//      NODE_BYTE_SIZE NodeByteSize;
//          :
//  } RECORD_NAME;
//  typedef RECORD_NAME *PRECORD_NAME;
//

#define NodeType(P) ((P) != NULL ? (*((PNODE_TYPE_CODE)(P))) : NTC_UNDEFINED)
#define SafeNodeType(P) (*((PNODE_TYPE_CODE)(P)))


//
//  The following definitions are used to generate meaningful blue bugcheck
//  screens.  On a bugcheck the file system can output 4 ulongs of useful
//  information.  The first ulong will have encoded in it a source file id
//  (in the high word) and the line number of the bugcheck (in the low word).
//  The other values can be whatever the caller of the bugcheck routine deems
//  necessary.
//
//  Each individual file that calls bugcheck needs to have defined at the
//  start of the file a constant called BugCheckFileId with one of the
//  NTFS_BUG_CHECK_ values defined below and then use NtfsBugCheck to bugcheck
//  the system.
//

#define NTFS_BUG_CHECK_ALLOCSUP          (0x00010000)
#define NTFS_BUG_CHECK_ATTRDATA          (0x00020000)
#define NTFS_BUG_CHECK_ATTRSUP           (0x00030000)
#define NTFS_BUG_CHECK_BITMPSUP          (0x00040000)
#define NTFS_BUG_CHECK_CACHESUP          (0x00050000)
#define NTFS_BUG_CHECK_CHECKSUP          (0x00060000)
#define NTFS_BUG_CHECK_CLEANUP           (0x00070000)
#define NTFS_BUG_CHECK_CLOST             (0x00080000)
#define NTFS_BUG_CHECK_COLATSUP          (0x00090000)
#define NTFS_BUG_CHECK_CREATE            (0x000a0000)
#define NTFS_BUG_CHECK_DEVCTRL           (0x000b0000)
#define NTFS_BUG_CHECK_DEVIOSUP          (0x000c0000)
#define NTFS_BUG_CHECK_DIRCTRL           (0x000d0000)
#define NTFS_BUG_CHECK_EA                (0x000e0000)
#define NTFS_BUG_CHECK_FILEINFO          (0x000f0000)
#define NTFS_BUG_CHECK_FILOBSUP          (0x00100000)
#define NTFS_BUG_CHECK_FLUSH             (0x00110000)
#define NTFS_BUG_CHECK_FSCTRL            (0x00120000)
#define NTFS_BUG_CHECK_FSPDISP           (0x00130000)
#define NTFS_BUG_CHECK_HASHSUP           (0x00280000)
#define NTFS_BUG_CHECK_INDEXSUP          (0x00140000)
#define NTFS_BUG_CHECK_LOCKCTRL          (0x00150000)
#define NTFS_BUG_CHECK_LOGSUP            (0x00160000)
#define NTFS_BUG_CHECK_MFTSUP            (0x00170000)
#define NTFS_BUG_CHECK_NAMESUP           (0x00180000)
#define NTFS_BUG_CHECK_NTFSDATA          (0x00190000)
#define NTFS_BUG_CHECK_NTFSINIT          (0x001a0000)
#define NTFS_BUG_CHECK_PNP               (0x00270000)
#define NTFS_BUG_CHECK_PREFXSUP          (0x001b0000)
#define NTFS_BUG_CHECK_READ              (0x001c0000)
#define NTFS_BUG_CHECK_RESRCSUP          (0x001d0000)
#define NTFS_BUG_CHECK_RESTRSUP          (0x001e0000)
#define NTFS_BUG_CHECK_SECURSUP          (0x001f0000)
#define NTFS_BUG_CHECK_SEINFO            (0x00200000)
#define NTFS_BUG_CHECK_SHUTDOWN          (0x00210000)
#define NTFS_BUG_CHECK_STRUCSUP          (0x00220000)
#define NTFS_BUG_CHECK_VERFYSUP          (0x00230000)
#define NTFS_BUG_CHECK_VOLINFO           (0x00240000)
#define NTFS_BUG_CHECK_WORKQUE           (0x00250000)
#define NTFS_BUG_CHECK_WRITE             (0x00260000)

#define NTFS_LAST_BUG_CHECK              NTFS_BUG_CHECK_HASHSUP

#define NtfsBugCheck(A,B,C) { KeBugCheckEx(NTFS_FILE_SYSTEM, BugCheckFileId | __LINE__, A, B, C ); }

#endif // _NODETYPE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\ntfs.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Ntfs.h

Current Version Numbers:

    Major.Minor Version:  3.1

Abstract:

    This module defines the on-disk structure of the Ntfs file system.

    An Ntfs volume consists of sectors of data allocated on a granularity
    called a cluster.  The cluster factor is the number of sectors per
    cluster.  Valid cluster factors are 1, 2, 4, 8, etc.

    The Ntfs volume starts with a boot sector at LBN=0, and a duplicate
    boot sector at LBN=(number of sectors on the partition div 2).  So
    a disk with N sectors start with two boot sectors as illustrated.

         0             ...   N/2            ...   N
        +-----------+-------+------------+-------+------------+
        |BootSector |  ...  | BootSector |  ...  |            |
        +-----------+-------+------------+-------+------------+

    The boot sector gives you the standard Bios Parameter Block, and
    tells you how many sectors are in the volume, and gives you the starting
    LCNs of the master file table (mft) and the duplicate master file table
    (mft2).

    The master file table contains the file record segments for all of
    the volume.  The first 16 or so file record segments are reserved for
    special files.  Mft2 only mirrors the first three record segments.

          0   1   2   3   4   5   6   7   8   9   ...
        +---+---+---+---+---+---+---+---+---+---+-----+
        | M | M | L | V | A | R | B | B | B | Q |     |
        | f | f | o | o | t | o | i | o | a | u |     |
        | t | t | g | l | t | o | t | o | d | o |     |
        |   | 2 | F | D | r | t | M | t | C | t | ... |
        |   |   | i | a | D | D | a |   | l | a |     |
        |   |   | l | s | e | i | p |   | u |   |     |
        |   |   | e | d | f | r |   |   | s |   |     |
        +---+---+---+---+---+---+---+---+---+---+-----+


    Each file record segment starts with a file record segment header, and
    is followed by one or more attributes.  Each attribute starts with an
    attribute record header.  The attribute record denotes the attribute type,
    optional name, and value for the attribute.  If the attribute is resident
    the value is contained in the file record and immediately follows the
    attribute record header.  If the attribute is non-resident the value
    value is off in some other sectors on the disk.

        +---------+-----------------+-------+
        | File    | Attrib : Name   |       |
        | Record  | Record : and/or |  ...  |
        | Segment | Header : Attrib |       |
        | Header  |        : Data   |       |
        +---------+-----------------+-------+

    Now if we run out of space for storing attributes in the file record
    segment we allocate additional file record segments and insert in the
    first (or base) file record segment an attribute called the Attribute
    List.  The attribute list indicates for every attribute associated
    with the file where the attribute can be found.  This includes
    those in the base file record.

    The value part of the attribute we're calling the attribute list is
    a list of sorted attribute list entries.  Though illustrated
    here as resident the attribute list can be nonresident.

        +---------+---------------------------+-----------------+-------+
        | File    | Attrib : Attrib   :       | Attrib : Name   |       |
        | Record  | Record : List     :  ...  | Record : and/or |  ...  |
        | Segment | Header : Entry    :       | Header : Attrib |       |
        | Header  |        :          :       |        : Data   |       |
        +---------+---------------------------+-----------------+-------+

                               |
                               V

                           +---------+-----------------+-------+
                           | File    | Attrib : Name   |       |
                           | Record  | Record : and/or |  ...  |
                           | Segment | Header : Attrib |       |
                           | Header  |        : Data   |       |
                           +---------+-----------------+-------+

    This file defines all of the above structures and also lays out the
    structures for some predefined attributes values (e.g., standard
    information, etc).

    Attributes are stored in ascending order in the file record and
    attribute list.  The sorting is done by first sorting according to
    attribute type code, then attribute name, and lastly attribute value.
    NTFS guarantees that if two attributes of the same type code and
    name exist on a file then they must have different values, and the
    values must be resident.

    The indexing attributes are the last interesting attribute.  The data
    component of an index root attribute must always be resident and contains
    an index header followed by a list of index list entries.

        +--------+------------------------+
        | Attrib |        : Index :       |
        | Record | Index  : List  :  ...  |
        | Header | Header : Entry :       |
        |        |        :       :       |
        +--------+------------------------+

    Each index list entry contains the key for the index and a reference
    to the file record segment for the index.  If ever we need to spill
    out of the file record segment we allocate an additional cluster from
    the disk (not file record segments).  The storage for the additional
    clusters is the data part of an index allocation attribute.  So what
    we wind up with is an index allocation attribute (non-resident) consisting
    of Index Allocation Buffers which are referenced by the b-tree used in in
    the index.

        +--------+------------------------+-----+---------------------+
        | Attrib | Index  : Index :       |     | Attrib : Index      |
        | Record | List   : List  :  ...  | ... | Record : Allocation |
        | Header | Header : Entry :       |     | Header :            |
        |        |        :       :       |     |        :            |
        +--------+------------------------+-----+---------------------+

                              |
                              | (VCN within index allocation)
                              V

                          +------------+------------------------------+
                          | Index      |       : Index : Index :      |
                          | Allocation | Index : List  : List  : ...  |
                          | Buffer     | Header: Entry : Entry :      |
                          |            |       :       :       :      |
                          +------------+------------------------------+

    Resident attributes are straight forward.  Non-resident attributes require
    a little more work.  If the attribute is non-resident then following
    the attribute record header is a list of retrieval information giving a
    VCN to LCN mapping for the attribute.  In the figure above the
    Index allocation attribute is a a non-resident attribute

        +---------+----------------------+-------+
        | File    | Attrib : Retrieval   |       |
        | Record  | Record : Information |  ...  |
        | Segment | Header :             |       |
        | Header  |        :             |       |
        +---------+----------------------+-------+

    If the retrieval information does not fit in the base file segment then
    it can be stored in an external file record segment all by itself, and
    if in the still doesn't fit in one external file record segment then
    there is a provision in the attribute list to contain multiple
    entries for an attribute that needs additional retrieval information.

Author:

    Brian Andrew    [BrianAn]       21-May-1991
    David Goebel    [DavidGoe]
    Gary Kimura     [GaryKi]
    Tom Miller      [TomM]

Revision History:


IMPORTANT NOTE:

    The NTFS on-disk structure must guarantee natural alignment of all
    arithmetic quantities on disk up to and including quad-word (64-bit)
    numbers.  Therefore, all attribute records are quad-word aligned, etc.

--*/

#ifndef _NTFS_
#define _NTFS_

#pragma pack(4)


//
//  The fundamental unit of allocation on an Ntfs volume is the
//  cluster.  Format guarantees that the cluster size is an integral
//  power of two times the physical sector size of the device.  Ntfs
//  reserves 64-bits to describe a cluster, in order to support
//  large disks.  The LCN represents a physical cluster number on
//  the disk, and the VCN represents a virtual cluster number within
//  an attribute.
//

typedef LONGLONG LCN;
typedef LCN *PLCN;

typedef LONGLONG VCN;
typedef VCN *PVCN;

typedef LONGLONG LBO;
typedef LBO *PLBO;

typedef LONGLONG VBO;
typedef VBO *PVBO;

//
//  Current Versions
//  

#define NTFS_MAJOR_VERSION 3
#define NTFS_MINOR_VERSION 1


//
//  Temporary definitions ****
//

typedef ULONG COLLATION_RULE;
typedef ULONG DISPLAY_RULE;

//
//  The compression chunk size is constant for now, at 4KB.
//

#define NTFS_CHUNK_SIZE                  (0x1000)
#define NTFS_CHUNK_SHIFT                 (12)

//
//  This number is actually the log of the number of clusters per compression
//  unit to be stored in a nonresident attribute record header.
//

#define NTFS_CLUSTERS_PER_COMPRESSION    (4)

//
//  This is the sparse file unit. This is the unit we use for generating holes
//  in sparse files.
//

#define NTFS_SPARSE_FILE_UNIT            (0x10000)

//
//  Collation Rules
//

//
//  For binary collation, values are collated by a binary compare of
//  their bytes, with the first byte being most significant.
//

#define COLLATION_BINARY                 (0)

//
//  For collation of Ntfs file names, file names are collated as
//  Unicode strings.  See below.
//

#define COLLATION_FILE_NAME              (1)

//
//  For collation of Unicode strings, the strings are collated by
//  their binary Unicode value, with the exception that for
//  characters which may be upcased, the lower case value for that
//  character collates immediately after the upcased value.
//

#define COLLATION_UNICODE_STRING         (2)

//
//  Total number of collation rules
//

#define COLLATION_NUMBER_RULES           (3)

//
//  Define the NtOfs Collation Rules
//

#define COLLATION_NTOFS_FIRST            (16)
#define COLLATION_NTOFS_ULONG            (16)
#define COLLATION_NTOFS_SID              (17)
#define COLLATION_NTOFS_SECURITY_HASH    (18)
#define COLLATION_NTOFS_ULONGS           (19)
#define COLLATION_NTOFS_LAST             (19)

//
//  The following macros are used to set and query with respect to
//  the update sequence arrays.
//

#define UpdateSequenceStructureSize(MSH) (                         \
    ((((PMULTI_SECTOR_HEADER)(MSH))->UpdateSequenceArraySize-1) *  \
                                           SEQUENCE_NUMBER_STRIDE) \
)

#define UpdateSequenceArraySize(STRUCT_SIZE) (   \
    ((STRUCT_SIZE) / SEQUENCE_NUMBER_STRIDE + 1) \
)


//
//  The MFT Segment Reference is an address in the MFT tagged with
//  a circularly reused sequence number set at the time that the MFT
//  Segment Reference was valid.  Note that this format limits the
//  size of the Master File Table to 2**48 segments.  So, for
//  example, with a 1KB segment size the maximum size of the master
//  file would be 2**58 bytes, or 2**28 gigabytes.
//

typedef struct _MFT_SEGMENT_REFERENCE {

    //
    //  First a 48 bit segment number.
    //

    ULONG SegmentNumberLowPart;                                    //  offset = 0x000
    USHORT SegmentNumberHighPart;                                  //  offset = 0x004

    //
    //  Now a 16 bit nonzero sequence number.  A value of 0 is
    //  reserved to allow the possibility of a routine accepting
    //  0 as a sign that the sequence number check should be
    //  repressed.
    //

    USHORT SequenceNumber;                                          //  offset = 0x006

} MFT_SEGMENT_REFERENCE, *PMFT_SEGMENT_REFERENCE;                   //  sizeof = 0x008

//
//  A file reference in NTFS is simply the MFT Segment Reference of
//  the Base file record.
//

typedef MFT_SEGMENT_REFERENCE FILE_REFERENCE, *PFILE_REFERENCE;

//
//  While the format allows 48 bits worth of segment number, the current
//  implementation restricts this to 32 bits.  Using NtfsUnsafeSegmentNumber
//  results in a performance win.  When the implementation changes, the
//  unsafe segment numbers must be cleaned up.  NtfsFullSegmentNumber is
//  used in a few spots to guarantee integrity of the disk.
//

#define NtfsSegmentNumber(fr)       NtfsUnsafeSegmentNumber( fr )
#define NtfsFullSegmentNumber(fr)   ( (*(ULONGLONG UNALIGNED *)(fr)) & 0xFFFFFFFFFFFF )
#define NtfsUnsafeSegmentNumber(fr) ((fr)->SegmentNumberLowPart)

#define NtfsSetSegmentNumber(fr,high,low)   \
    ((fr)->SegmentNumberHighPart = (high), (fr)->SegmentNumberLowPart = (low))

#define NtfsEqualMftRef(X,Y)    ( NtfsSegmentNumber( X ) == NtfsSegmentNumber( Y ) )

#define NtfsLtrMftRef(X,Y)      ( NtfsSegmentNumber( X ) <  NtfsSegmentNumber( Y ) )

#define NtfsGtrMftRef(X,Y)      ( NtfsSegmentNumber( X ) >  NtfsSegmentNumber( Y ) )                                               \

#define NtfsLeqMftRef(X,Y)      ( NtfsSegmentNumber( X ) <= NtfsSegmentNumber( Y ) )

#define NtfsGeqMftRef(X,Y)      ( NtfsSegmentNumber( X ) >= NtfsSegmentNumber( Y ) )

//
//  System File Numbers.  The following file numbers are a fixed
//  part of the volume number.  For the system files, the
//  SequenceNumber is always equal to the File Number.  So to form a
//  File Reference for a given System File, set LowPart and
//  SequenceNumber to the File Number, and set HighPart to 0.  Any
//  unused file numbers prior to FIRST_USER_FILE_NUMBER should not
//  be used.  They are reserved to allow the potential for easy
//  upgrade of existing volumes from future versions of the file
//  system.
//
//  Each definition below is followed by a comment containing
//  the file name for the file:
//
//                                      Number     Name
//                                      ------     ----

#define MASTER_FILE_TABLE_NUMBER         (0)   //  $Mft

#define MASTER_FILE_TABLE2_NUMBER        (1)   //  $MftMirr

#define LOG_FILE_NUMBER                  (2)   //  $LogFile

#define VOLUME_DASD_NUMBER               (3)   //  $Volume

#define ATTRIBUTE_DEF_TABLE_NUMBER       (4)   //  $AttrDef

#define ROOT_FILE_NAME_INDEX_NUMBER      (5)   //  .

#define BIT_MAP_FILE_NUMBER              (6)   //  $BitMap

#define BOOT_FILE_NUMBER                 (7)   //  $Boot

#define BAD_CLUSTER_FILE_NUMBER          (8)   //  $BadClus

#define SECURITY_FILE_NUMBER             (9)   //  $Secure

#define UPCASE_TABLE_NUMBER              (10)  //  $UpCase

#define EXTEND_NUMBER                    (11)  //  $Extend

#define LAST_SYSTEM_FILE_NUMBER          (11)
#define FIRST_USER_FILE_NUMBER           (16)

//
//  The number of bits to extend the Mft and bitmap.  We round these up to a
//  cluster boundary for a large cluster volume
//

#define BITMAP_EXTEND_GRANULARITY               (64)
#define MFT_HOLE_GRANULARITY                    (32)
#define MFT_EXTEND_GRANULARITY                  (16)

//
//  The shift values for determining the threshold for the Mft defragging.
//

#define MFT_DEFRAG_UPPER_THRESHOLD      (3)     //  Defrag if 1/8 of free space
#define MFT_DEFRAG_LOWER_THRESHOLD      (4)     //  Stop at 1/16 of free space


//
//  Attribute Type Code.  Attribute Types also have a Unicode Name,
//  and the correspondence between the Unicode Name and the
//  Attribute Type Code is stored in the Attribute Definition File.
//

typedef ULONG ATTRIBUTE_TYPE_CODE;
typedef ATTRIBUTE_TYPE_CODE *PATTRIBUTE_TYPE_CODE;

//
//  System-defined Attribute Type Codes.  For the System-defined
//  attributes, the Unicode Name is exactly equal to the name of the
//  following symbols.  For this reason, all of the system-defined
//  attribute names start with "$", to always distinguish them when
//  attribute names are listed, and to reserve a namespace for
//  attributes defined in the future.  I.e., a User-Defined
//  attribute name will never collide with a current or future
//  system-defined attribute name if it does not start with "$".
//  User attribute numbers should not start until
//  $FIRST_USER_DEFINED_ATTRIBUTE, to allow the potential for
//  upgrading existing volumes with new user-defined attributes in
//  future versions of NTFS.  The tagged attribute list is
//  terminated with a lone-standing 0 ($END) - the rest of the
//  attribute record does not exist.
//
//  The type code value of 0 is reserved for convenience of the
//  implementation.
//

#define $UNUSED                          (0X0)

#define $STANDARD_INFORMATION            (0x10)
#define $ATTRIBUTE_LIST                  (0x20)
#define $FILE_NAME                       (0x30)
#define $OBJECT_ID                       (0x40)
#define $SECURITY_DESCRIPTOR             (0x50)
#define $VOLUME_NAME                     (0x60)
#define $VOLUME_INFORMATION              (0x70)
#define $DATA                            (0x80)
#define $INDEX_ROOT                      (0x90)
#define $INDEX_ALLOCATION                (0xA0)
#define $BITMAP                          (0xB0)
#define $REPARSE_POINT                   (0xC0)
#define $EA_INFORMATION                  (0xD0)
#define $EA                              (0xE0)
// #define $LOGGED_UTILITY_STREAM           (0x100) // defined in ntfsexp.h
#define $FIRST_USER_DEFINED_ATTRIBUTE    (0x1000)
#define $END                             (0xFFFFFFFF)


//
//  The boot sector is duplicated on the partition.  The first copy
//  is on the first physical sector (LBN == 0) of the partition, and
//  the second copy is at <number sectors on partition> / 2.  If the
//  first copy can not be read when trying to mount the disk, the
//  second copy may be read and has the identical contents.  Format
//  must figure out which cluster the second boot record belongs in,
//  and it must zero all of the other sectors that happen to be in
//  the same cluster.  The boot file minimally contains with two
//  clusters, which are the two clusters which contain the copies of
//  the boot record.  If format knows that some system likes to put
//  code somewhere, then it should also align this requirement to
//  even clusters, and add that to the boot file as well.
//
//  Part of the sector contains a BIOS Parameter Block.  The BIOS in
//  the sector is packed (i.e., unaligned) so we'll supply an
//  unpacking macro to translate a packed BIOS into its unpacked
//  equivalent.  The unpacked BIOS structure is already defined in
//  ntioapi.h so we only need to define the packed BIOS.
//

//
//  Define the Packed and Unpacked BIOS Parameter Block
//

typedef struct _PACKED_BIOS_PARAMETER_BLOCK {

    UCHAR  BytesPerSector[2];                               //  offset = 0x000
    UCHAR  SectorsPerCluster[1];                            //  offset = 0x002
    UCHAR  ReservedSectors[2];                              //  offset = 0x003 (zero)
    UCHAR  Fats[1];                                         //  offset = 0x005 (zero)
    UCHAR  RootEntries[2];                                  //  offset = 0x006 (zero)
    UCHAR  Sectors[2];                                      //  offset = 0x008 (zero)
    UCHAR  Media[1];                                        //  offset = 0x00A
    UCHAR  SectorsPerFat[2];                                //  offset = 0x00B (zero)
    UCHAR  SectorsPerTrack[2];                              //  offset = 0x00D
    UCHAR  Heads[2];                                        //  offset = 0x00F
    UCHAR  HiddenSectors[4];                                //  offset = 0x011 (zero)
    UCHAR  LargeSectors[4];                                 //  offset = 0x015 (zero)

} PACKED_BIOS_PARAMETER_BLOCK;                              //  sizeof = 0x019

typedef PACKED_BIOS_PARAMETER_BLOCK *PPACKED_BIOS_PARAMETER_BLOCK;

typedef struct BIOS_PARAMETER_BLOCK {

    USHORT BytesPerSector;
    UCHAR  SectorsPerCluster;
    USHORT ReservedSectors;
    UCHAR  Fats;
    USHORT RootEntries;
    USHORT Sectors;
    UCHAR  Media;
    USHORT SectorsPerFat;
    USHORT SectorsPerTrack;
    USHORT Heads;
    ULONG  HiddenSectors;
    ULONG  LargeSectors;

} BIOS_PARAMETER_BLOCK;

typedef BIOS_PARAMETER_BLOCK *PBIOS_PARAMETER_BLOCK;

//
//  This macro takes a Packed BIOS and fills in its Unpacked
//  equivalent
//

#define NtfsUnpackBios(Bios,Pbios) {                                       \
    CopyUchar2(&((Bios)->BytesPerSector),    &(Pbios)->BytesPerSector   ); \
    CopyUchar1(&((Bios)->SectorsPerCluster), &(Pbios)->SectorsPerCluster); \
    CopyUchar2(&((Bios)->ReservedSectors),   &(Pbios)->ReservedSectors  ); \
    CopyUchar1(&((Bios)->Fats),              &(Pbios)->Fats             ); \
    CopyUchar2(&((Bios)->RootEntries),       &(Pbios)->RootEntries      ); \
    CopyUchar2(&((Bios)->Sectors),           &(Pbios)->Sectors          ); \
    CopyUchar1(&((Bios)->Media),             &(Pbios)->Media            ); \
    CopyUchar2(&((Bios)->SectorsPerFat),     &(Pbios)->SectorsPerFat    ); \
    CopyUchar2(&((Bios)->SectorsPerTrack),   &(Pbios)->SectorsPerTrack  ); \
    CopyUchar2(&((Bios)->Heads),             &(Pbios)->Heads            ); \
    CopyUchar4(&((Bios)->HiddenSectors),     &(Pbios)->HiddenSectors    ); \
    CopyUchar4(&((Bios)->LargeSectors),      &(Pbios)->LargeSectors     ); \
}

//
//  Define the boot sector.  Note that MFT2 is exactly three file
//  record segments long, and it mirrors the first three file record
//  segments from the MFT, which are MFT, MFT2 and the Log File.
//
//  The Oem field contains the ASCII characters "NTFS    ".
//
//  The Checksum field is a simple additive checksum of all of the
//  ULONGs which precede the Checksum ULONG.  The rest of the sector
//  is not included in this Checksum.
//

typedef struct _PACKED_BOOT_SECTOR {

    UCHAR Jump[3];                                                              //  offset = 0x000
    UCHAR Oem[8];                                                               //  offset = 0x003
    PACKED_BIOS_PARAMETER_BLOCK PackedBpb;                                      //  offset = 0x00B
    UCHAR Unused[4];                                                            //  offset = 0x024
    LONGLONG NumberSectors;                                                     //  offset = 0x028
    LCN MftStartLcn;                                                            //  offset = 0x030
    LCN Mft2StartLcn;                                                           //  offset = 0x038
    CHAR ClustersPerFileRecordSegment;                                          //  offset = 0x040
    UCHAR Reserved0[3];
    CHAR DefaultClustersPerIndexAllocationBuffer;                               //  offset = 0x044
    UCHAR Reserved1[3];
    LONGLONG SerialNumber;                                                      //  offset = 0x048
    ULONG Checksum;                                                             //  offset = 0x050
    UCHAR BootStrap[0x200-0x054];                                               //  offset = 0x054

} PACKED_BOOT_SECTOR;                                                           //  sizeof = 0x200

typedef PACKED_BOOT_SECTOR *PPACKED_BOOT_SECTOR;


//
//  File Record Segment.  This is the header that begins every File
//  Record Segment in the Master File Table.
//

typedef struct _FILE_RECORD_SEGMENT_HEADER {

    //
    //  Multi-Sector Header as defined by the Cache Manager.  This
    //  structure will always contain the signature "FILE" and a
    //  description of the location and size of the Update Sequence
    //  Array.
    //

    MULTI_SECTOR_HEADER MultiSectorHeader;                          //  offset = 0x000

    //
    //  Log File Sequence Number of last logged update to this File
    //  Record Segment.
    //

    LSN Lsn;                                                        //  offset = 0x008

    //
    //  Sequence Number.  This is incremented each time that a File
    //  Record segment is freed, and 0 is not used.  The
    //  SequenceNumber field of a File Reference must match the
    //  contents of this field, or else the File Reference is
    //  incorrect (presumably stale).
    //

    USHORT SequenceNumber;                                          //  offset = 0x010

    //
    //  This is the count of the number of references which exist
    //  for this segment, from an INDEX_xxx attribute.  In File
    //  Records Segments other than the Base File Record Segment,
    //  this field is 0.
    //

    USHORT ReferenceCount;                                          //  offset = 0x012

    //
    //  Offset to the first Attribute record in bytes.
    //

    USHORT FirstAttributeOffset;                                    //  offset = 0x014

    //
    //  FILE_xxx flags.
    //

    USHORT Flags;                                                   //  offset = 0x016

    //
    //  First free byte available for attribute storage, from start
    //  of this header.  This value should always be aligned to a
    //  quad-word boundary, since attributes are quad-word aligned.
    //

    ULONG FirstFreeByte;                                            //  offset = x0018

    //
    //  Total bytes available in this file record segment, from the
    //  start of this header.  This is essentially the file record
    //  segment size.
    //

    ULONG BytesAvailable;                                           //  offset = 0x01C

    //
    //  This is a File Reference to the Base file record segment for
    //  this file.  If this is the Base, then the value of this
    //  field is all 0's.
    //

    FILE_REFERENCE BaseFileRecordSegment;                           //  offset = 0x020

    //
    //  This is the attribute instance number to be used when
    //  creating an attribute.  It is zeroed when the base file
    //  record is created, and captured for each new attribute as it
    //  is created and incremented afterwards for the next
    //  attribute.  Instance numbering must also occur for the
    //  initial attributes.  Zero is a valid attribute instance
    //  number, and typically used for standard information.
    //

    USHORT NextAttributeInstance;                                   //  offset = 0x028

    //
    //  Current FRS record - this is here for recovery alone and added in 5.1
    //  Note: this is not aligned
    // 

    USHORT SegmentNumberHighPart;                                  //  offset = 0x02A
    ULONG SegmentNumberLowPart;                                    //  offset = 0x02C

    //
    //  Update Sequence Array to protect multi-sector transfers of
    //  the File Record Segment.  Accesses to already initialized
    //  File Record Segments should go through the offset above, for
    //  upwards compatibility.
    //

    UPDATE_SEQUENCE_ARRAY UpdateArrayForCreateOnly;                 //  offset = 0x030

} FILE_RECORD_SEGMENT_HEADER;
typedef FILE_RECORD_SEGMENT_HEADER *PFILE_RECORD_SEGMENT_HEADER;


//
//  earlier version of FRS from 5.0
//  

typedef struct _FILE_RECORD_SEGMENT_HEADER_V0 {

    //
    //  Multi-Sector Header as defined by the Cache Manager.  This
    //  structure will always contain the signature "FILE" and a
    //  description of the location and size of the Update Sequence
    //  Array.
    //

    MULTI_SECTOR_HEADER MultiSectorHeader;                          //  offset = 0x000

    //
    //  Log File Sequence Number of last logged update to this File
    //  Record Segment.
    //

    LSN Lsn;                                                        //  offset = 0x008

    //
    //  Sequence Number.  This is incremented each time that a File
    //  Record segment is freed, and 0 is not used.  The
    //  SequenceNumber field of a File Reference must match the
    //  contents of this field, or else the File Reference is
    //  incorrect (presumably stale).
    //

    USHORT SequenceNumber;                                          //  offset = 0x010

    //
    //  This is the count of the number of references which exist
    //  for this segment, from an INDEX_xxx attribute.  In File
    //  Records Segments other than the Base File Record Segment,
    //  this field is 0.
    //

    USHORT ReferenceCount;                                          //  offset = 0x012

    //
    //  Offset to the first Attribute record in bytes.
    //

    USHORT FirstAttributeOffset;                                    //  offset = 0x014

    //
    //  FILE_xxx flags.
    //

    USHORT Flags;                                                   //  offset = 0x016

    //
    //  First free byte available for attribute storage, from start
    //  of this header.  This value should always be aligned to a
    //  quad-word boundary, since attributes are quad-word aligned.
    //

    ULONG FirstFreeByte;                                            //  offset = x0018

    //
    //  Total bytes available in this file record segment, from the
    //  start of this header.  This is essentially the file record
    //  segment size.
    //

    ULONG BytesAvailable;                                           //  offset = 0x01C

    //
    //  This is a File Reference to the Base file record segment for
    //  this file.  If this is the Base, then the value of this
    //  field is all 0's.
    //

    FILE_REFERENCE BaseFileRecordSegment;                           //  offset = 0x020

    //
    //  This is the attribute instance number to be used when
    //  creating an attribute.  It is zeroed when the base file
    //  record is created, and captured for each new attribute as it
    //  is created and incremented afterwards for the next
    //  attribute.  Instance numbering must also occur for the
    //  initial attributes.  Zero is a valid attribute instance
    //  number, and typically used for standard information.
    //

    USHORT NextAttributeInstance;                                   //  offset = 0x028

    //
    //  Update Sequence Array to protect multi-sector transfers of
    //  the File Record Segment.  Accesses to already initialized
    //  File Record Segments should go through the offset above, for
    //  upwards compatibility.
    //

    UPDATE_SEQUENCE_ARRAY UpdateArrayForCreateOnly;                 //  offset = 0x02A

} FILE_RECORD_SEGMENT_HEADER_V0;

//
//  FILE_xxx flags.
//

#define FILE_RECORD_SEGMENT_IN_USE       (0x0001)
#define FILE_FILE_NAME_INDEX_PRESENT     (0x0002)
#define FILE_SYSTEM_FILE                 (0x0004)
#define FILE_VIEW_INDEX_PRESENT          (0x0008)

//
//  Define a macro to determine the maximum space available for a
//  single attribute.  For example, this is required when a
//  nonresident attribute has to split into multiple file records -
//  we need to know how much we can squeeze into a single file
//  record.  If this macro has any inaccurracy, it must be in the
//  direction of returning a slightly smaller number than actually
//  required.
//
//      ULONG
//      NtfsMaximumAttributeSize (
//          IN ULONG FileRecordSegmentSize
//          );
//

#define NtfsMaximumAttributeSize(FRSS) (                                               \
    (FRSS) - QuadAlign(sizeof(FILE_RECORD_SEGMENT_HEADER)) -                           \
    QuadAlign((((FRSS) / SEQUENCE_NUMBER_STRIDE) * sizeof(UPDATE_SEQUENCE_NUMBER))) -  \
    QuadAlign(sizeof(ATTRIBUTE_TYPE_CODE))                                             \
)


//
//  Attribute Record.  Logically an attribute has a type, an
//  optional name, and a value, however the storage details make it
//  a little more complicated.  For starters, an attribute's value
//  may either be resident in the file record segment itself, on
//  nonresident in a separate data stream.  If it is nonresident, it
//  may actually exist multiple times in multiple file record
//  segments to describe different ranges of VCNs.
//
//  Attribute Records are always aligned on a quad word (64-bit)
//  boundary.
//

typedef struct _ATTRIBUTE_RECORD_HEADER {

    //
    //  Attribute Type Code.
    //

    ATTRIBUTE_TYPE_CODE TypeCode;                                   //  offset = 0x000

    //
    //  Length of this Attribute Record in bytes.  The length is
    //  always rounded to a quad word boundary, if necessary.  Also
    //  the length only reflects the size necessary to store the
    //  given record variant.
    //

    ULONG RecordLength;                                             //  offset = 0x004

    //
    //  Attribute Form Code (see below)
    //

    UCHAR FormCode;                                                 //  offset = 0x008

    //
    //  Length of the optional attribute name in characters, or 0 if
    //  there is none.
    //

    UCHAR NameLength;                                               //  offset = 0x009

    //
    //  Offset to the attribute name from start of attribute record,
    //  in bytes, if it exists.  This field is undefined if
    //  NameLength is 0.
    //

    USHORT NameOffset;                                              //  offset = 0x00A

    //
    //  ATTRIBUTE_xxx flags.
    //

    USHORT Flags;                                                   //  offset = 0x00C

    //
    //  The file-record-unique attribute instance number for this
    //  attribute.
    //

    USHORT Instance;                                                //  offset = 0x00E

    //
    //  The following union handles the cases distinguished by the
    //  Form Code.
    //

    union {

        //
        //  Resident Form.  Attribute resides in file record segment.
        //

        struct {

            //
            //  Length of attribute value in bytes.
            //

            ULONG ValueLength;                                      //  offset = 0x010

            //
            //  Offset to value from start of attribute record, in
            //  bytes.
            //

            USHORT ValueOffset;                                     //  offset = 0x014

            //
            //  RESIDENT_FORM_xxx Flags.
            //

            UCHAR ResidentFlags;                                    //  offset = 0x016

            //
            //  Reserved.
            //

            UCHAR Reserved;                                         //  offset = 0x017

        } Resident;

        //
        //  Nonresident Form.  Attribute resides in separate stream.
        //

        struct {

            //
            //  Lowest VCN covered by this attribute record.
            //

            VCN LowestVcn;                                          //  offset = 0x010

            //
            //  Highest VCN covered by this attribute record.
            //

            VCN HighestVcn;                                         //  offset = 0x018

            //
            //  Offset to the Mapping Pairs Array  (defined below),
            //  in bytes, from the start of the attribute record.
            //

            USHORT MappingPairsOffset;                              //  offset = 0x020

            //
            //  Unit of Compression size for this stream, expressed
            //  as a log of the cluster size.
            //
            //      0 means file is not compressed
            //      1, 2, 3, and 4 are potentially legal values if the
            //          stream is compressed, however the implementation
            //          may only choose to use 4, or possibly 3.  Note
            //          that 4 means cluster size time 16.  If convenient
            //          the implementation may wish to accept a
            //          reasonable range of legal values here (1-5?),
            //          even if the implementation only generates
            //          a smaller set of values itself.
            //

            UCHAR CompressionUnit;                                  //  offset = 0x022

            //
            //  Reserved to get to quad word boundary.
            //

            UCHAR Reserved[5];                                      //  offset = 0x023

            //
            //  Allocated Length of the file in bytes.  This is
            //  obviously an even multiple of the cluster size.
            //  (Not present if LowestVcn != 0.)
            //

            LONGLONG AllocatedLength;                               //  offset = 0x028

            //
            //  File Size in bytes (highest byte which may be read +
            //  1).  (Not present if LowestVcn != 0.)
            //

            LONGLONG FileSize;                                      //  offset = 0x030

            //
            //  Valid Data Length (highest initialized byte + 1).
            //  This field must also be rounded to a cluster
            //  boundary, and the data must always be initialized to
            //  a cluster boundary. (Not present if LowestVcn != 0.)
            //

            LONGLONG ValidDataLength;                               //  offset = 0x038

            //
            //  Totally allocated.  This field is only present for the first
            //  file record of a compressed stream.  It represents the sum of
            //  the allocated clusters for a file.
            //

            LONGLONG TotalAllocated;                                //  offset = 0x040

            //
            //
            //  Mapping Pairs Array, starting at the offset stored
            //  above.
            //
            //  The Mapping Pairs Array is stored in a compressed
            //  form, and assumes that this information is
            //  decompressed and cached by the system.  The reason
            //  for compressing this information is clear, it is
            //  done in the hopes that all of the retrieval
            //  information always fits in a single file record
            //  segment.
            //
            //  Logically, the MappingPairs Array stores a series of
            //  NextVcn/CurrentLcn pairs.  So, for example, given
            //  that we know the first Vcn (from LowestVcn above),
            //  the first Mapping Pair tells us what the next Vcn is
            //  (for the next Mapping Pair), and what Lcn the
            //  current Vcn is mapped to, or 0 if the Current Vcn is
            //  not allocated.  (This is exactly the FsRtl MCB
            //  structure).
            //
            //  For example, if a file has a single run of 8
            //  clusters, starting at Lcn 128, and the file starts
            //  at LowestVcn=0, then the Mapping Pairs array has
            //  just one entry, which is:
            //
            //    NextVcn = 8
            //    CurrentLcn = 128
            //
            //  The compression is implemented with the following
            //  algorithm.  Assume that you initialize two "working"
            //  variables as follows:
            //
            //    NextVcn = LowestVcn (from above)
            //    CurrentLcn = 0
            //
            //  The MappingPairs array is byte stream, which simply
            //  store the changes to the working variables above,
            //  when processed sequentially.  The byte stream is to
            //  be interpreted as a zero-terminated stream of
            //  triples, as follows:
            //
            //    count byte = v + (l * 16)
            //
            //      where v = number of changed low-order Vcn bytes
            //            l = number of changed low-order Lcn bytes
            //
            //    v Vcn change bytes
            //    l Lcn change bytes
            //
            //  The byte stream terminates when a count byte of 0 is
            //  encountered.
            //
            //  The decompression algorithm goes as follows,
            //  assuming that Attribute is a pointer to the
            //  attribute record.
            //
            //  1.  Initialize:
            //          NextVcn = Attribute->LowestVcn;
            //          CurrentLcn = 0;
            //
            //  2.  Initialize byte stream pointer to: (PCHAR)Attribute +
            //      Attribute->AttributeForm->Nonresident->MappingPairsOffset
            //
            //  3.  CurrentVcn = NextVcn;
            //
            //  4.  Read next byte from stream.  If it is 0, then
            //      break, else extract v and l (see above).
            //
            //  5.  Interpret the next v bytes as a signed quantity,
            //      with the low-order byte coming first.  Unpack it
            //      sign-extended into 64 bits and add it to NextVcn.
            //      (It can really only be positive, but the Lcn
            //      change can be positive or negative.)
            //
            //  6.  Interpret the next l bytes as a signed quantity,
            //      with the low-order byte coming first.  Unpack it
            //      sign-extended into 64 bits and add it to
            //      CurrentLcn.  Remember, if this produces a
            //      CurrentLcn of 0, then the Vcns from the
            //      CurrentVcn to NextVcn-1 are unallocated.
            //
            //  7.  Update cached mapping information from
            //      CurrentVcn, NextVcn and CurrentLcn.
            //
            //  8.  Loop back to 3.
            //
            //  The compression algorithm should now be obvious, as
            //  it is the reverse of the above.  The compression and
            //  decompression algorithms will be available as common
            //  RTL routines, available to NTFS and file utilities.
            //
            //  In defense of this algorithm, not only does it
            //  provide compression of the on-disk storage
            //  requirements, but it results in a single
            //  representation, independent of disk size and file
            //  size.  Contrast this with solutions which are in use
            //  which define multiple sizes for virtual and logical
            //  cluster sizes, depending on the size of the disk,
            //  etc.  For example, two byte cluster numbers might
            //  suffice for a floppy, while four bytes would be
            //  required for most hard disks today, and five or six
            //  bytes are required after a certain number of
            //  gigabytes, etc.  This eventually results in more
            //  complex code than above (because of the cases) and
            //  worse yet - untested cases.  So, more important than
            //  the compression, the above algorithm provides one
            //  case which efficiently handles any size disk.
            //

        } Nonresident;

    } Form;

} ATTRIBUTE_RECORD_HEADER;
typedef ATTRIBUTE_RECORD_HEADER *PATTRIBUTE_RECORD_HEADER;

//
//  Attribute Form Codes
//

#define RESIDENT_FORM                    (0x00)
#define NONRESIDENT_FORM                 (0x01)

//
//  Define Attribute Flags
//

//
//  The first range of flag bits is reserved for
//  storing the compression method.  This constant
//  defines the mask of the bits reserved for
//  compression method.  It is also the first
//  illegal value, since we increment it to calculate
//  the code to pass to the Rtl routines.  Thus it is
//  impossible for us to store COMPRESSION_FORMAT_DEFAULT.
//

#define ATTRIBUTE_FLAG_COMPRESSION_MASK  (0x00FF)
#define ATTRIBUTE_FLAG_SPARSE            (0x8000)
#define ATTRIBUTE_FLAG_ENCRYPTED         (0x4000)

//
//  RESIDENT_FORM_xxx flags
//

//
//  This attribute is indexed.
//

#define RESIDENT_FORM_INDEXED            (0x01)

//
//  The maximum attribute name length is 255 (in chars)
//

#define NTFS_MAX_ATTR_NAME_LEN           (255)

//
//  Define macros for the size of resident and nonresident headers.
//

#define SIZEOF_RESIDENT_ATTRIBUTE_HEADER (                         \
    FIELD_OFFSET(ATTRIBUTE_RECORD_HEADER,Form.Resident.Reserved)+1 \
)

#define SIZEOF_FULL_NONRES_ATTR_HEADER (    \
    sizeof(ATTRIBUTE_RECORD_HEADER)         \
)

#define SIZEOF_PARTIAL_NONRES_ATTR_HEADER (                                 \
    FIELD_OFFSET(ATTRIBUTE_RECORD_HEADER,Form.Nonresident.TotalAllocated)   \
)


//
//  Standard Information Attribute.  This attribute is present in
//  every base file record, and must be resident.
//

typedef struct _STANDARD_INFORMATION {

    //
    //  File creation time.
    //

    LONGLONG CreationTime;                                          //  offset = 0x000

    //
    //  Last time the DATA attribute was modified.
    //

    LONGLONG LastModificationTime;                                  //  offset = 0x008

    //
    //  Last time any attribute was modified.
    //

    LONGLONG LastChangeTime;                                        //  offset = 0x010

    //
    //  Last time the file was accessed.  This field may not always
    //  be updated (write-protected media), and even when it is
    //  updated, it may only be updated if the time would change by
    //  a certain delta.  It is meant to tell someone approximately
    //  when the file was last accessed, for purposes of possible
    //  file migration.
    //

    LONGLONG LastAccessTime;                                        //  offset = 0x018

    //
    //  File attributes.  The first byte is the standard "Fat"
    //  flags for this file.
    //

    ULONG FileAttributes;                                           //  offset = 0x020

    //
    //  Maximum file versions allowed for this file.  If this field
    //  is 0, then versioning is not enabled for this file.  If
    //  there are multiple files with the same version, then the
    //  value of Maximum file versions in the file with the highest
    //  version is the correct one.
    //

    ULONG MaximumVersions;                                          //  offset = 0x024

    //
    //  Version number for this file.
    //

    ULONG VersionNumber;                                            //  offset = 0x028

    //
    //  Class Id from the bidirectional Class Id index
    //

    ULONG ClassId;                                                  //  offset = 0x02c

    //
    //  Id for file owner, from bidir security index
    //

    ULONG OwnerId;                                                  //  offset = 0x030

    //
    //  SecurityId for the file - translates via bidir index to
    //  granted access Acl.
    //

    ULONG SecurityId;                                               //  offset = 0x034

    //
    //  Current amount of quota that has been charged for all the
    //  streams of this file.  Changed in same transaction with the
    //  quota file itself.
    //

    ULONGLONG QuotaCharged;                                         //  offset = 0x038

    //
    //  Update sequence number for this file.
    //

    ULONGLONG Usn;                                                  //  offset = 0x040

} STANDARD_INFORMATION;                                             //  sizeof = 0x048
typedef STANDARD_INFORMATION *PSTANDARD_INFORMATION;

//
//  Large Standard Information Attribute.  We use this to find the
//  security ID field.
//

typedef struct LARGE_STANDARD_INFORMATION {

    //
    //  File creation time.
    //

    LONGLONG CreationTime;                                          //  offset = 0x000

    //
    //  Last time the DATA attribute was modified.
    //

    LONGLONG LastModificationTime;                                  //  offset = 0x008

    //
    //  Last time any attribute was modified.
    //

    LONGLONG LastChangeTime;                                        //  offset = 0x010

    //
    //  Last time the file was accessed.  This field may not always
    //  be updated (write-protected media), and even when it is
    //  updated, it may only be updated if the time would change by
    //  a certain delta.  It is meant to tell someone approximately
    //  when the file was last accessed, for purposes of possible
    //  file migration.
    //

    LONGLONG LastAccessTime;                                        //  offset = 0x018

    //
    //  File attributes.  The first byte is the standard "Fat"
    //  flags for this file.
    //

    ULONG FileAttributes;                                           //  offset = 0x020

    //
    //  Maximum file versions allowed for this file.  If this field
    //  is 0, then versioning is not enabled for this file.  If
    //  there are multiple files with the same version, then the
    //  value of Maximum file versions in the file with the highest
    //  version is the correct one.
    //

    ULONG MaximumVersions;                                          //  offset = 0x024

    //
    //  Version number for this file.
    //

    ULONG VersionNumber;                                            //  offset = 0x028

    ULONG UnusedUlong;

    //
    //  Id for file owner, from bidir security index
    //

    ULONG OwnerId;                                                  //  offset = 0x030

    //
    //  SecurityId for the file - translates via bidir index to
    //  granted access Acl.
    //

    ULONG SecurityId;                                               //  offset = 0x034

} LARGE_STANDARD_INFORMATION;
typedef LARGE_STANDARD_INFORMATION *PLARGE_STANDARD_INFORMATION;

//
//  This was the size of standard information prior to NT4.0
//

#define SIZEOF_OLD_STANDARD_INFORMATION  (0x30)

//
//  Define the file attributes, starting with the Fat attributes.
//

#define FAT_DIRENT_ATTR_READ_ONLY        (0x01)
#define FAT_DIRENT_ATTR_HIDDEN           (0x02)
#define FAT_DIRENT_ATTR_SYSTEM           (0x04)
#define FAT_DIRENT_ATTR_VOLUME_ID        (0x08)
#define FAT_DIRENT_ATTR_ARCHIVE          (0x20)
#define FAT_DIRENT_ATTR_DEVICE           (0x40)


//
//  Attribute List.  Because there is not a special header that goes
//  before the list of attribute list entries we do not need to
//  declare an attribute list header
//

//
//  The Attributes List attribute is an ordered-list of quad-word
//  aligned ATTRIBUTE_LIST_ENTRY records.  It is ordered first by
//  Attribute Type Code, and then by Attribute Name (if present).
//  No two attributes may exist with the same type code, name and
//  LowestVcn.  This also means that at most one occurrence of a
//  given Attribute Type Code without a name may exist.
//
//  To binary search this attribute, it is first necessary to make a
//  quick pass through it and form a list of pointers, since the
//  optional name makes it variable-length.
//

typedef struct _ATTRIBUTE_LIST_ENTRY {

    //
    //  Attribute Type Code, the first key on which this list is
    //  ordered.
    //

    ATTRIBUTE_TYPE_CODE AttributeTypeCode;                          //  offset = 0x000

    //
    //  Size of this record in bytes, including the optional name
    //  appended to this structure.
    //

    USHORT RecordLength;                                            //  offset = 0x004

    //
    //  Length of attribute name, if there is one.  If a name exists
    //  (AttributeNameLength != 0), then it is a Unicode string of
    //  the specified number of characters immediately following
    //  this record.  This is the second key on which this list is
    //  ordered.
    //

    UCHAR AttributeNameLength;                                      //  offset = 0x006

    //
    //  Reserved to get to quad-word boundary
    //

    UCHAR AttributeNameOffset;                                      //  offset = 0x007

    //
    //  Lowest Vcn for this attribute.  This field is always zero
    //  unless the attribute requires multiple file record segments
    //  to describe all of its runs, and this is a reference to a
    //  segment other than the first one.  The field says what the
    //  lowest Vcn is that is described by the referenced segment.
    //

    VCN LowestVcn;                                                  //  offset = 0x008

    //
    //  Reference to the MFT segment in which the attribute resides.
    //

    MFT_SEGMENT_REFERENCE SegmentReference;                         //  offset = 0x010

    //
    //  The file-record-unique attribute instance number for this
    //  attribute.
    //

    USHORT Instance;                                                //  offset = 0x018

    //
    //  When creating an attribute list entry, start the name here.
    //  (When reading one, use the AttributeNameOffset field.)
    //

    WCHAR AttributeName[1];                                         //  offset = 0x01A

} ATTRIBUTE_LIST_ENTRY;
typedef ATTRIBUTE_LIST_ENTRY *PATTRIBUTE_LIST_ENTRY;


typedef struct _DUPLICATED_INFORMATION {

    //
    //  File creation time.
    //

    LONGLONG CreationTime;                                          //  offset = 0x000

    //
    //  Last time the DATA attribute was modified.
    //

    LONGLONG LastModificationTime;                                  //  offset = 0x008

    //
    //  Last time any attribute was modified.
    //

    LONGLONG LastChangeTime;                                        //  offset = 0x010

    //
    //  Last time the file was accessed.  This field may not always
    //  be updated (write-protected media), and even when it is
    //  updated, it may only be updated if the time would change by
    //  a certain delta.  It is meant to tell someone approximately
    //  when the file was last accessed, for purposes of possible
    //  file migration.
    //

    LONGLONG LastAccessTime;                                        //  offset = 0x018

    //
    //  Allocated Length of the file in bytes.  This is obviously
    //  an even multiple of the cluster size.  (Not present if
    //  LowestVcn != 0.)
    //

    LONGLONG AllocatedLength;                                       //  offset = 0x020

    //
    //  File Size in bytes (highest byte which may be read + 1).
    //  (Not present if LowestVcn != 0.)
    //

    LONGLONG FileSize;                                              //  offset = 0x028

    //
    //  File attributes.  The first byte is the standard "Fat"
    //  flags for this file.
    //

    ULONG FileAttributes;                                           //  offset = 0x030

    //
    //  This union enables the retrieval of the tag in reparse
    //  points when there are no Ea's.
    //

    union {

        struct {

            //
            //  The size of buffer needed to pack these Ea's
            //

            USHORT  PackedEaSize;                                   //  offset = 0x034

            //
            //  Reserved for quad word alignment
            //

            USHORT  Reserved;                                       //  offset = 0x036
        };

        //
        //  The tag of the data in a reparse point. It represents
        //  the type of a reparse point. It enables different layered
        //  filters to operate on their own reparse points.
        //

        ULONG  ReparsePointTag;                                     //  offset = 0x034
    };

} DUPLICATED_INFORMATION;                                           //  sizeof = 0x038
typedef DUPLICATED_INFORMATION *PDUPLICATED_INFORMATION;

//
//  This bit is duplicated from the file record, to indicate that
//  this file has a file name index present (is a "directory").
//

#define DUP_FILE_NAME_INDEX_PRESENT      (0x10000000)

//
//  This bit is duplicated from the file record, to indicate that
//  this file has a view index present, such as the quota or
//  object id index.
//

#define DUP_VIEW_INDEX_PRESENT        (0x20000000)

//
//  The following macros examine fields of the duplicated structure.
//

#define IsDirectory( DUPLICATE )                                        \
    (FlagOn( ((PDUPLICATED_INFORMATION) (DUPLICATE))->FileAttributes,   \
             DUP_FILE_NAME_INDEX_PRESENT ))

#define IsViewIndex( DUPLICATE )                                        \
    (FlagOn( ((PDUPLICATED_INFORMATION) (DUPLICATE))->FileAttributes,   \
             DUP_VIEW_INDEX_PRESENT ))

#define IsReadOnly( DUPLICATE )                                         \
    (FlagOn( ((PDUPLICATED_INFORMATION) (DUPLICATE))->FileAttributes,   \
             FILE_ATTRIBUTE_READONLY ))

#define IsHidden( DUPLICATE )                                           \
    (FlagOn( ((PDUPLICATED_INFORMATION) (DUPLICATE))->FileAttributes,   \
             FILE_ATTRIBUTE_HIDDEN ))

#define IsSystem( DUPLICATE )                                           \
    (FlagOn( ((PDUPLICATED_INFORMATION) (DUPLICATE))->FileAttributes,   \
             FILE_ATTRIBUTE_SYSTEM ))

#define IsEncrypted( DUPLICATE )                                        \
    (FlagOn( ((PDUPLICATED_INFORMATION) (DUPLICATE))->FileAttributes,   \
             FILE_ATTRIBUTE_ENCRYPTED ))

#define IsCompressed( DUPLICATE )                                       \
    (FlagOn( ((PDUPLICATED_INFORMATION) (DUPLICATE))->FileAttributes,   \
             FILE_ATTRIBUTE_COMPRESSED ))

#define BooleanIsDirectory( DUPLICATE )                                        \
    (BooleanFlagOn( ((PDUPLICATED_INFORMATION) (DUPLICATE))->FileAttributes,   \
                    DUP_FILE_NAME_INDEX_PRESENT ))

#define BooleanIsReadOnly( DUPLICATE )                                         \
    (BooleanFlagOn( ((PDUPLICATED_INFORMATION) (DUPLICATE))->FileAttributes,   \
                    FILE_ATTRIBUTE_READONLY ))

#define BooleanIsHidden( DUPLICATE )                                           \
    (BooleanFlagOn( ((PDUPLICATED_INFORMATION) (DUPLICATE))->FileAttributes,   \
                    FILE_ATTRIBUTE_HIDDEN ))

#define BooleanIsSystem( DUPLICATE )                                           \
    (BooleanFlagOn( ((PDUPLICATED_INFORMATION) (DUPLICATE))->FileAttributes,   \
                    FILE_ATTRIBUTE_SYSTEM ))

#define HasReparsePoint( DUPLICATE )                                        \
    (FlagOn( ((PDUPLICATED_INFORMATION) (DUPLICATE))->FileAttributes,   \
             FILE_ATTRIBUTE_REPARSE_POINT ))


//
//  File Name attribute.  A file has one File Name attribute for
//  every directory it is entered into (hard links).
//

typedef struct _FILE_NAME {

    //
    //  This is a File Reference to the directory file which indexes
    //  to this name.
    //

    FILE_REFERENCE ParentDirectory;                                 //  offset = 0x000

    //
    //  Information for faster directory operations.
    //

    DUPLICATED_INFORMATION Info;                                    //  offset = 0x008

    //
    //  Length of the name to follow, in (Unicode) characters.
    //

    UCHAR FileNameLength;                                           //  offset = 0x040

    //
    //  FILE_NAME_xxx flags
    //

    UCHAR Flags;                                                    //  offset = 0x041

    //
    //  First character of Unicode File Name
    //

    WCHAR FileName[1];                                              //  offset = 0x042

} FILE_NAME;
typedef FILE_NAME *PFILE_NAME;

//
//  File Name flags
//

#define FILE_NAME_NTFS                   (0x01)
#define FILE_NAME_DOS                    (0x02)

//
//  The maximum file name length is 255 (in chars)
//

#define NTFS_MAX_FILE_NAME_LENGTH       (255)

//
//  The maximum number of links on a file is 1024
//

#define NTFS_MAX_LINK_COUNT             (1024)

//
//  This flag is not part of the disk structure, but is defined here
//  to explain its use and avoid possible future collisions.  For
//  enumerations of "directories" this bit may be set to convey to
//  the collating routine that it should not match file names that
//  only have the FILE_NAME_DOS bit set.
//

#define FILE_NAME_IGNORE_DOS_ONLY        (0x80)

#define NtfsFileNameSizeFromLength(LEN) (                   \
    (sizeof( FILE_NAME ) + LEN - sizeof( WCHAR ))           \
)

#define NtfsFileNameSize(PFN) (                                             \
    (sizeof( FILE_NAME ) + ((PFN)->FileNameLength - 1) * sizeof( WCHAR ))   \
)


//
//  Object id attribute.
//

//
//  On disk representation of an object id.
//

#define OBJECT_ID_KEY_LENGTH      16
#define OBJECT_ID_EXT_INFO_LENGTH 48

typedef struct _NTFS_OBJECTID_INFORMATION {

    //
    //  Data the filesystem needs to identify the file with this object id.
    //

    FILE_REFERENCE FileSystemReference;

    //
    //  This portion of the object