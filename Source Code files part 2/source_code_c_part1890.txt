Kcb - Supplies the key control block

    UserEvent - the event to be signaled after the hive was unloaded
                (only if late - unload is needed)

Return Value:

    STATUS_PENDING - the hive was frozen and it'll be unloaded later

    STATUS_SUCCESS - the hive was successfully sync-unloaded (no need 
                to signal for UserEvent)

    <other> - an error occured, operation failed

--*/
{
    PCMHIVE         CmHive;
    HCELL_INDEX     Cell;    
    NTSTATUS        Status;

    CM_PAGED_CODE();

    Cell = kcb->KeyCell;
    CmHive = (PCMHIVE)CONTAINING_RECORD(kcb->KeyHive, CMHIVE, Hive);

    if( IsHiveFrozen(CmHive) ) {
        //
        // don't let them hurt themselves by calling it twice
        //
        return STATUS_TOO_LATE;
    }
    //
    // first, try out he sync routine; this may or may not unload the hive,
    // but at least will kick kcbs with refcount = 0 out of cache
    //
    Status = CmUnloadKey(kcb,0,CM_UNLOAD_REG_LOCKED_EX);
    if( Status != STATUS_CANNOT_DELETE ) {
        //
        // the hive was either unloaded, or some bad thing happened
        //
        return Status;
    }

    ASSERT( kcb->RefCount > 1 );
    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

    //
    // Prepare for late-unloading:
    // 1. reference the kcb, to make sure it won't go away without us noticing
    //  (we have the registry locked in exclusive mode, so we don't need to lock the kcbtree
    //
    if (!CmpReferenceKeyControlBlock(kcb)) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

	//
	// parse the kcb tree and mark all open kcbs inside this hive and "no delay close"
	//
    CmpSearchForOpenSubKeys(kcb,SearchAndTagNoDelayClose,TRUE,NULL);
	kcb->ExtFlags |= CM_KCB_NO_DELAY_CLOSE;

    //
    // 2. Freeze the hive
    //
    CmHive->RootKcb = kcb;
    CmHive->Frozen = TRUE;
    CmHive->UnloadEvent = UserEvent;

    return STATUS_PENDING;
}

// define in cmworker.c
extern BOOLEAN CmpForceForceFlush;

BOOLEAN
CmpDoFlushAll(
    BOOLEAN ForceFlush
    )
/*++

Routine Description:

    Flush all hives.

    Runs down list of Hives and applies HvSyncHive to them.

    NOTE: Hives which are marked as HV_NOLAZYFLUSH are *NOT* flushed
          by this call.  You must call HvSyncHive explicitly to flush
          a hive marked as HV_NOLAZYFLUSH.

Arguments:

    ForceFlush - used as a contingency plan when a prior exception left 
                some hive in a used state. When set to TRUE, assumes the 
                registry is locked exclusive. It also repairs the broken 
                hives.

               - When FALSE saves only the hives with UseCount == 0.

Return Value:

    NONE

Notes:

    If any of the hives is about to shrink CmpForceForceFlush is set to TRUE, 
    otherwise, it is set to FALSE

--*/
{
    NTSTATUS    Status;
    PLIST_ENTRY p;
    PCMHIVE     h;
    BOOLEAN     Result = TRUE;    
    //
    // If writes are not working, lie and say we succeeded, will
    // clean up in a short time.  Only early system init code
    // will ever know the difference.
    //
    if (CmpNoWrite) {
        return TRUE;
    }
    
    CmpForceForceFlush = FALSE;

    //
    // traverse list of hives, sync each one
    //
    CmpLockHiveListShared();
    p = CmpHiveListHead.Flink;
    while (p != &CmpHiveListHead) {

        h = CONTAINING_RECORD(p, CMHIVE, HiveList);

        if (!(h->Hive.HiveFlags & HIVE_NOLAZYFLUSH)) {

            //
            // Lock the hive before we flush it.
            // -- since we now allow multiple readers
            // during a flush (a flush is considered a read)
            // we have to force a serialization on the vector table
            //
            CmpLockHiveFlusherExclusive(h);
            
            if( (ForceFlush == TRUE) &&  (h->UseCount != 0) ) {
                //
                // hive was left in an unstable state by a prior exception raised 
                // somewhere inside a CM function.
                //
                ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
                CmpFixHiveUsageCount(h);
                ASSERT( h->UseCount == 0 );
            }

            
            if( (ForceFlush == TRUE) || (!HvHiveWillShrink((PHHIVE)h)) ) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"CmpDoFlushAll hive = %p ForceFlush = %lu IsHiveShrinking = %lu BaseLength = %lx StableLength = %lx\n",
                    h,(ULONG)ForceFlush,(ULONG)HvHiveWillShrink((PHHIVE)h),((PHHIVE)h)->BaseBlock->Length,((PHHIVE)h)->Storage[Stable].Length));
                // 
                // no writes while we are flushing the hive
                //
                Status = HvSyncHive((PHHIVE)h);

                if( !NT_SUCCESS( Status ) ) {
                    Result = FALSE;
                }
            } else {
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"CmpDoFlushAll: Fail to flush hive %p because is shrinking\n",h));
                Result = FALSE;
                //
                // another unsuccessful attempt to save this hive, because we needed the reglock exclusive
                //
                CmpForceForceFlush = TRUE;
            }

            CmpUnlockHiveFlusher(h);
            //
            // WARNNOTE - the above means that a lazy flush or
            //            or shutdown flush did not work.  we don't
            //            know why.  there is no one to report an error
            //            to, so continue on and hope for the best.
            //            (in theory, worst that can happen is user changes
            //             are lost.)
            //
        }

        p = p->Flink;
    }
    CmpUnlockHiveList();
    
    return Result;
}

extern ULONG    CmpLazyFlushCount;
extern ULONG    CmpLazyFlushHiveCount;

BOOLEAN
CmpDoFlushNextHive(
    BOOLEAN     ForceFlush,
    PBOOLEAN    PostWarning,
    PULONG      DirtyCount
    )
/*++

Routine Description:

    Flush next hive in list with FlushCount != CmpLazyFlushCount

    Runs in the context of the CmpWorkerThread.

    Runs down list of Hives until it finds the first one with that was not yet flushed
    by the lazy flusher (ie. has its flush count different than the lazy flusher count)

    NOTE: Hives which are marked as HV_NOLAZYFLUSH are *NOT* flushed
          by this call.  You must call HvSyncHive explicitly to flush
          a hive marked as HV_NOLAZYFLUSH.

Arguments:

    ForceFlush - used as a contingency plan when a prior exception left 
                some hive in a used state. When set to TRUE, assumes the 
                registry is locked exclusive. It also repairs the broken 
                hives.

               - When FALSE saves only the hives with UseCount == 0.

Return Value:

    TRUE - if there are more hives to flush
    FALSE - otherwise

Notes:

    If any of the hives is about to shrink CmpForceForceFlush is set to TRUE, 
    otherwise, it is set to FALSE

--*/
{
    NTSTATUS    Status;
    PLIST_ENTRY p;
    PCMHIVE     h;
    BOOLEAN     Result;    
    ULONG       HiveCount = CmpLazyFlushHiveCount;

    *PostWarning = FALSE;
    *DirtyCount = 0;

    //
    // If writes are not working, lie and say we succeeded, will
    // clean up in a short time.  Only early system init code
    // will ever know the difference.
    //
    if (CmpNoWrite) {
        return TRUE;
    }

    //
    // flush at least one hive
    //
    if( !HiveCount ) {
        HiveCount = 1;
    }

    CmpForceForceFlush = FALSE;

    //
    // traverse list of hives, sync each one
    //
    CmpLockHiveListShared();
    p = CmpHiveListHead.Flink;
    while (p != &CmpHiveListHead) {

        h = CONTAINING_RECORD(p, CMHIVE, HiveList);

        if (!(h->Hive.HiveFlags & HIVE_NOLAZYFLUSH) &&  // lazy flush is notspecifically disabled on this hive
            (h->FlushCount != CmpLazyFlushCount)        // and it was not already flushed during this iteration
            ) {

            Result = TRUE;    
            //
            // Lock the hive before we flush it.
            // -- since we now allow multiple readers
            // during a flush (a flush is considered a read)
            // we have to force a serialization on the vector table
            //
            CmpLockHiveFlusherExclusive(h);
            if( (h->Hive.DirtyCount == 0) || (h->Hive.HiveFlags & HIVE_VOLATILE) ) {
                //
                // if the hive is volatile or has no dirty data, just skip it.
                // silently update the flush count
                //
                h->FlushCount = CmpLazyFlushCount;
            } else {
                if( (ForceFlush == TRUE) &&  (h->UseCount != 0) ) {
                    //
                    // hive was left in an unstable state by a prior exception raised 
                    // somewhere inside a CM function.
                    //
                    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
                    CmpFixHiveUsageCount(h);
                    ASSERT( h->UseCount == 0 );
                }

            
                if( (ForceFlush == TRUE) || (!HvHiveWillShrink((PHHIVE)h)) ) {
                    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"CmpDoFlushAll hive = %p ForceFlush = %lu IsHiveShrinking = %lu BaseLength = %lx StableLength = %lx\n",
                        h,(ULONG)ForceFlush,(ULONG)HvHiveWillShrink((PHHIVE)h),((PHHIVE)h)->BaseBlock->Length,((PHHIVE)h)->Storage[Stable].Length));
                    // 
                    // no writes while we are flushing the hive
                    //
                    Status = HvSyncHive((PHHIVE)h);

                    if( !NT_SUCCESS( Status ) ) {
                        *PostWarning = TRUE;
                        Result = FALSE;
                    }
                } else {
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"CmpDoFlushAll: Fail to flush hive %p because is shrinking\n",h));
                    Result = FALSE;
                    //
                    // another unsuccessful attempt to save this hive, because we needed the reglock exclusive
                    //
                    CmpForceForceFlush = TRUE;
                }
                if( Result == TRUE ) {
                    //
                    // we have successfully flushed current hive hive
                    //
                    h->FlushCount = CmpLazyFlushCount;
                    HiveCount--;
                    if( (!HiveCount) && (!ForceFlush)) { // since we have it all locked exclusive; flush the remainder of the list
                        //
                        // skip to the next one and break out of the loop, so we can detect whether the last one was flushed out
                        //
                        CmpUnlockHiveFlusher(h);
                        p = p->Flink;
                        break;
                    }
                } else {
                    //
                    // do not update flush count for this one as we want to attempt to flush it at next iteration
                    //
                }
            }
            CmpUnlockHiveFlusher(h);

        } else if(  (h->Hive.DirtyCount != 0) &&                // hive has dirty data
                    (!(h->Hive.HiveFlags & HIVE_VOLATILE)) &&   // is not volatile
                    (!(h->Hive.HiveFlags & HIVE_NOLAZYFLUSH))){  // and lazy flush is enabled
            //
            // count dirty count for this hive; we'll need to fire another lazy flusher
            // to take this into account, even if we made it to the end of the list
            //
            // sanity; this has already been flushed
            ASSERT( h->FlushCount == CmpLazyFlushCount );
            *DirtyCount += h->Hive.DirtyCount;
        }
        //
        // for the ones that we cannot do the unload check at last deref
        //
        if( IsHiveFrozen(h) ) {
            CmpDoQueueLateUnloadWorker(h);
        }
        p = p->Flink;
    }
    if( p == &CmpHiveListHead ) {
        //
        // we have flushed out everything; caller must update globalflush count
        //
        Result = FALSE;
    } else {
        Result = TRUE;
    }
    CmpUnlockHiveList();

    return Result;
}


NTSTATUS
CmRenameKey(
    IN PCM_KEY_CONTROL_BLOCK    KeyControlBlock,
    IN UNICODE_STRING           NewKeyName,         // RAW
    IN KPROCESSOR_MODE          PreviousMode
    )
/*++

Routine Description:

    Changes the name of the key to the given one.

    What needs to be done:
    
    1. Allocate a cell big enough to accommodate new knode 
    2. make a duplicate of the index in subkeylist of kcb's parent
    3. replace parent's subkeylist with the duplicate
    4. add new subkey to parent
    5. remove old subkey
    6. free storage.

Arguments:

    KeyControlBlock - pointer to kcb for key to operate on

    NewKeyName - The new name to be given to this key

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                Status;
    PHHIVE                  Hive;
    HCELL_INDEX             Cell;
    PCM_KEY_NODE            Node;
    PCM_KEY_NODE            ParentNode;
    ULONG                   NodeSize;
    HCELL_INDEX             NewKeyCell = HCELL_NIL;
    HSTORAGE_TYPE           StorageType;
    HCELL_INDEX             OldSubKeyList = HCELL_NIL;
    PCM_KEY_NODE            NewKeyNode;
    PCM_KEY_INDEX           Index;
    ULONG                   i;
    LARGE_INTEGER           TimeStamp;
    ULONG                   NameLength;
    PCM_NAME_CONTROL_BLOCK  OldNcb = NULL;
    ULONG                   ConvKey;
    BOOLEAN                 NameUpCase;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_CM,"CmRenameKey\n"));

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
    //
    // no edits, on keys marked for deletion
    //
    if (KeyControlBlock->Delete) {
        return STATUS_KEY_DELETED;
    }

    //
    // see if the newName is not already a subkey of parentKcb
    //
    Hive = KeyControlBlock->KeyHive;
    Cell = KeyControlBlock->KeyCell;
    StorageType = HvGetCellType(Cell);

    //
    // OBS. we could have worked with the kcb tree instead, but if this is not 
    // going to work, we are in trouble anyway, so it's better to find out soon
    //
    Node = (PCM_KEY_NODE)HvGetCell(Hive,Cell);
    if( Node == NULL ) {
        //
        // cannot map view
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // release the cell right here, as the registry is locked exclusively, so we don't care
    HvReleaseCell(Hive, Cell);

    //
    // cannot rename the root of a hive; or anything in the master hive !!!
    //
    if((Hive == &CmpMasterHive->Hive) || (KeyControlBlock->ParentKcb == NULL) || (KeyControlBlock->ParentKcb->KeyHive == &CmpMasterHive->Hive) ) {
        return STATUS_ACCESS_DENIED;
    }

    //
    // Exhaustive access check is done here. We already checked we have DELETE on this KCB
    // We need to check we have KEY_CREATE_SUB_KEY on the parent
    // and DELETE on the entire subtree underneath us.
    //
    Status = CmpCheckKeyAccess( KeyControlBlock->ParentKcb->KeyHive,
                                KeyControlBlock->ParentKcb->KeyCell,
                                PreviousMode,
                                KEY_CREATE_SUB_KEY);
    if( NT_SUCCESS(Status) ) {
        Status = CmpDoAccessCheckOnSubtree( Hive,
                                            Cell,
                                            PreviousMode,
                                            DELETE,
                                            TRUE);
    }

    if( !NT_SUCCESS(Status) ) {
        return Status;
    }

    ParentNode = (PCM_KEY_NODE)HvGetCell(Hive,Node->Parent);
    if( ParentNode == NULL ) {
        //
        // cannot map view
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    // release the cell right here, as the registry is locked exclusively, so we don't care
    HvReleaseCell(Hive, Node->Parent);

    try {
        if( CmpFindSubKeyByName(Hive,ParentNode,&NewKeyName) != HCELL_NIL ) {
            //
            // a subkey with this name already exists
            //
            return STATUS_CANNOT_DELETE;
        }

        //
        // since we are in try-except, compute the new node size
        //
        NodeSize = CmpHKeyNodeSize(Hive, &NewKeyName);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!CmRenameKey: code:%08lx\n", GetExceptionCode()));
        return GetExceptionCode();
    }    
    
    //
    // 1. Allocate the new knode cell and copy the data from the old one, updating 
    // the name. 
    
    //
    // mark the parent dirty, as we will modify its SubkeyLists
    //
    if(!HvMarkCellDirty(Hive, Node->Parent,FALSE)) {
        return STATUS_NO_LOG_SPACE;
    }

    //
    // mark the index dirty as we are going to free it on success
    //
    if ( !CmpMarkIndexDirty(Hive, Node->Parent, Cell) ) {
        return STATUS_NO_LOG_SPACE;
    }
    //
    // mark key_node as dirty as we are going to free it if we succeed
    //
    if(!HvMarkCellDirty(Hive, Cell,FALSE)) {
        return STATUS_NO_LOG_SPACE;
    }
   
    OldSubKeyList = ParentNode->SubKeyLists[StorageType];       
    if( (OldSubKeyList == HCELL_NIL) || (!HvMarkCellDirty(Hive, OldSubKeyList,FALSE)) ) {
        return STATUS_NO_LOG_SPACE;
    }
    Index = (PCM_KEY_INDEX)HvGetCell(Hive,OldSubKeyList);
    if( Index == NULL ) {
        //
        // we just marked this dirty
        //
        ASSERT( FALSE );
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    // release the cell right here, as the registry is locked exclusively, so we don't care
    HvReleaseCell(Hive, OldSubKeyList);

    //
    // mark all the index cells dirty
    //
    if( Index->Signature == CM_KEY_INDEX_ROOT ) {
        //
        // it's a root
        //
        for(i=0;i<Index->Count;i++) {
            // common sense
            ASSERT( (Index->List[i] != 0) && (Index->List[i] != HCELL_NIL) );
            if(!HvMarkCellDirty(Hive, Index->List[i],FALSE)) {
                return STATUS_NO_LOG_SPACE;
            }
        }

    } 


    NewKeyCell = HvAllocateCell(
                    Hive,
                    NodeSize,
                    StorageType,
                    Cell // in the same vicinity
                    );
    if( NewKeyCell == HCELL_NIL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    NewKeyNode = (PCM_KEY_NODE)HvGetCell(Hive,NewKeyCell);
    if( NewKeyNode == NULL ) {
        //
        // cannot map view; this shouldn't happen as we just allocated 
        // this cell (i.e. it should be dirty/pinned into memory)
        //
        ASSERT( FALSE );
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }
    // release the cell right here, as the registry is locked exclusively, so we don't care
    HvReleaseCell(Hive, NewKeyCell);

    //
    // copy old keynode info onto the new cell and update the name
    //
    // first everything BUT the name
    RtlCopyMemory(NewKeyNode,Node,FIELD_OFFSET(CM_KEY_NODE, Name));
    // second, the new name
    try {
        NewKeyNode->NameLength = CmpCopyName(   Hive,
                                                NewKeyNode->Name,
                                                &NewKeyName);
        NameLength = NewKeyName.Length;

        if (NewKeyNode->NameLength < NameLength ) {
            NewKeyNode->Flags |= KEY_COMP_NAME;
        } else {
            NewKeyNode->Flags &= ~KEY_COMP_NAME;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!CmRenameKey: code:%08lx\n", GetExceptionCode()));
        Status = GetExceptionCode();
        goto ErrorExit;
    }    
    // third, the timestamp
    KeQuerySystemTime(&TimeStamp);
    NewKeyNode->LastWriteTime = TimeStamp;
    
    //
    // at this point we have the new key_node all built up.
    //

    //
    // 2.3. Make a duplicate of the parent's subkeylist and replace the original
    //
    ParentNode->SubKeyLists[StorageType] = CmpDuplicateIndex(Hive,OldSubKeyList,StorageType);
    if( ParentNode->SubKeyLists[StorageType] == HCELL_NIL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    //
    // 4. Add new subkey to the parent. This will take care of index 
    // grow and rebalance problems. 
    // Note: the index is at this point a duplicate, so if we fail, we still have the 
    // original one handy to recover
    //
    if( !CmpAddSubKey(Hive,Node->Parent,NewKeyCell) ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    //
    // 5. remove old subkey;
    //
    if( !CmpRemoveSubKey(Hive,Node->Parent,Cell) ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    //
    // update the NCB in the kcb; at the end of this function, the kcbs underneath this 
    // will eventually get rehashed
    //
    OldNcb = KeyControlBlock->NameBlock;
    try {
        KeyControlBlock->NameBlock = CmpGetNameControlBlock (&NewKeyName,&NameUpCase);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!CmRenameKey: code:%08lx\n", GetExceptionCode()));
        Status = GetExceptionCode();
        goto ErrorExit;
    }    

    if( KeyControlBlock->NameBlock == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    //
    // 5'. update the parent on each and every son.
    //
    if( !CmpUpdateParentForEachSon(Hive,NewKeyCell) ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    //
    // 6. At this point we have it all done. We just need to free the old index and key_cell
    //
    
    //
    // free old index
    //
    Index = (PCM_KEY_INDEX)HvGetCell(Hive,OldSubKeyList);
    if( Index == NULL ) {
        //
        // we just marked this dirty
        //
        ASSERT( FALSE );
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }
    // release the cell right here, as the registry is locked exclusively, so we don't care
    HvReleaseCell(Hive, OldSubKeyList);

    if( Index->Signature == CM_KEY_INDEX_ROOT ) {
        //
        // it's a root
        //
        for(i=0;i<Index->Count;i++) {
            // common sense
            ASSERT( (Index->List[i] != 0) && (Index->List[i] != HCELL_NIL) );
            HvFreeCell(Hive, Index->List[i]);
        }

    } else {
        //
        // should be a leaf 
        //
        ASSERT((Index->Signature == CM_KEY_INDEX_LEAF)  ||
               (Index->Signature == CM_KEY_FAST_LEAF)   ||
               (Index->Signature == CM_KEY_HASH_LEAF)
               );
        ASSERT(Index->Count != 0);
    }
    HvFreeCell(Hive, OldSubKeyList);
    
    //
    // free old cell
    //
    HvFreeCell(Hive,Cell);

    //
    // update the node KeyCell for this kcb and the timestamp on the kcb;
    //
    KeyControlBlock->KeyCell = NewKeyCell;
    KeyControlBlock->KcbLastWriteTime = TimeStamp;

    //
    // and one last "little" thing: update parent's maxnamelen and reset parents cache
    //
    CmpCleanUpSubKeyInfo (KeyControlBlock->ParentKcb);

    if (ParentNode->MaxNameLen < NameLength) {
        ParentNode->MaxNameLen = NameLength;
        KeyControlBlock->ParentKcb->KcbMaxNameLen = (USHORT)NameLength;
    }
    
    //
    // rehash this kcb
    //
    ConvKey = CmpComputeKcbConvKey(KeyControlBlock);
    if( ConvKey != KeyControlBlock->ConvKey ) {
        //
        // rehash the kcb by removing it from hash, and then inserting it
        // again with th new ConvKey
        //
        CmpRemoveKeyHash(&(KeyControlBlock->KeyHash));
        KeyControlBlock->ConvKey = ConvKey;
        CmpInsertKeyHash(&(KeyControlBlock->KeyHash),FALSE);
    }

    //
    // Additional work: take care of the kcb subtree; this cannot fail, punt
    //
    CmpSearchForOpenSubKeys(KeyControlBlock,SearchAndRehash,TRUE,NULL);

    //
    // last, dereference the OldNcb for this kcb
    //
    ASSERT( OldNcb != NULL );
    CmpDereferenceNameControlBlockWithLock(OldNcb);
#if defined(_WIN64)
    //
    // set up the UpCase name flag in the kcb; free old name if present
    //
    if( (KeyControlBlock->RealKeyName != NULL) && (KeyControlBlock->RealKeyName != CMP_KCB_REAL_NAME_UPCASE) ) {
        ExFreePoolWithTag(KeyControlBlock->RealKeyName, CM_NAME_TAG);
    }
    if( NameUpCase == TRUE ) {
        KeyControlBlock->RealKeyName = CMP_KCB_REAL_NAME_UPCASE;
    } else {
        KeyControlBlock->RealKeyName = NULL;
    }
#endif

    return STATUS_SUCCESS;

ErrorExit:
    if( OldSubKeyList != HCELL_NIL ) {
        //
        // we have attempted (maybe even succeeded) to duplicate parent's index)
        //
        if( ParentNode->SubKeyLists[StorageType] != HCELL_NIL ) {
            //
            // we need to free this as it is a duplicate
            //
            Index = (PCM_KEY_INDEX)HvGetCell(Hive,ParentNode->SubKeyLists[StorageType]);
            if( Index == NULL ) {
                //
                // could not map view;this shouldn't happen as we just allocated this cell
                //
                ASSERT( FALSE );
            } else {
                // release the cell right here, as the registry is locked exclusively, so we don't care
                HvReleaseCell(Hive, ParentNode->SubKeyLists[StorageType]);

                if( Index->Signature == CM_KEY_INDEX_ROOT ) {
                    //
                    // it's a root
                    //
                    for(i=0;i<Index->Count;i++) {
                        // common sense
                        ASSERT( (Index->List[i] != 0) && (Index->List[i] != HCELL_NIL) );
                        HvFreeCell(Hive, Index->List[i]);
                    }

                } else {
                    //
                    // should be a leaf 
                    //
                    ASSERT((Index->Signature == CM_KEY_INDEX_LEAF)  ||
                           (Index->Signature == CM_KEY_FAST_LEAF)   ||
                           (Index->Signature == CM_KEY_HASH_LEAF)
                           );
                    ASSERT(Index->Count != 0);
                }
                HvFreeCell(Hive, ParentNode->SubKeyLists[StorageType]);
            }

        }
        //
        // restore the parent's index
        //
        ParentNode->SubKeyLists[StorageType] = OldSubKeyList;
    }
    ASSERT( NewKeyCell != HCELL_NIL );
    HvFreeCell(Hive,NewKeyCell);
    
    if( OldNcb != NULL ) {
        KeyControlBlock->NameBlock = OldNcb;
    }
    
    return Status;
}

NTSTATUS
CmMoveKey(
    IN PCM_KEY_CONTROL_BLOCK    KeyControlBlock
    )
/*++

Routine Description:

    Moves all the cells related to this kcb above the specified fileoffset.

    What needs to be done:
    
    1. mark all data that we are going to touch dirty
    2. Duplicate the key_node (and values and all cells involved)
    3. Update the parent for all children
    4. replace the new Key_cell in the parent's subkeylist
    5. Update the kcb and the kcb cache
    6. remove old subkey

WARNING:
    after 3 we cannot fail anymore. if we do, we'll leak cells.

Arguments:

    KeyControlBlock - pointer to kcb for key to operate on

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                Status;
    PHHIVE                  Hive;
    HCELL_INDEX             OldKeyCell;
    HCELL_INDEX             NewKeyCell = HCELL_NIL;
    HCELL_INDEX             ParentKeyCell;
    HSTORAGE_TYPE           StorageType;
    PCM_KEY_NODE            OldKeyNode;
    PCM_KEY_NODE            ParentKeyNode;
    PCM_KEY_NODE            NewKeyNode;
    PCM_KEY_INDEX           ParentIndex;
    PCM_KEY_INDEX           OldIndex;
    ULONG                   i,j;
    HCELL_INDEX             LeafCell;
    PCM_KEY_INDEX           Leaf;
    PCM_KEY_FAST_INDEX      FastIndex;
    PHCELL_INDEX            ParentIndexLocation = NULL;

    PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_CM,"CmMoveKey\n"));

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

    //
    // no edits, on keys marked for deletion
    //
    if (KeyControlBlock->Delete) {
        return STATUS_KEY_DELETED;
    }

    //
    // see if the newName is not already a subkey of parentKcb
    //
    Hive = KeyControlBlock->KeyHive;
    OldKeyCell = KeyControlBlock->KeyCell;
    StorageType = HvGetCellType(OldKeyCell);

    if( StorageType != Stable ) {
        //
        // nop the volatiles
        //
        return STATUS_SUCCESS;
    }

    if( OldKeyCell ==  Hive->BaseBlock->RootCell ) {
        //
        // this works only for stable keys.
        //
        return STATUS_INVALID_PARAMETER;
    }

    //
    // 1. mark all data that we are going to touch dirty
    //
    // parent's index, as we will replace the key node cell in it
    // we only search in the Stable storage. It is supposed to be there
    //
    OldKeyNode = (PCM_KEY_NODE)HvGetCell(Hive,OldKeyCell);
    if( OldKeyNode == NULL ) {
        //
        // cannot map view
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (! CmpMarkKeyDirty(Hive, OldKeyCell
#if DBG
		,FALSE
#endif //DBG
		)) {
        HvReleaseCell(Hive, OldKeyCell);
        return STATUS_NO_LOG_SPACE;
    }
    // release the cell right here, as the registry is locked exclusively, and the key_cell is marked as dirty
    HvReleaseCell(Hive, OldKeyCell);

	if( OldKeyNode->Flags & KEY_SYM_LINK ) {
		//
		// we do not compact links
		//
		return STATUS_INVALID_PARAMETER;
	}
	if( OldKeyNode->SubKeyLists[Stable] != HCELL_NIL ) {
		//
		// mark the index dirty
		//
		OldIndex = (PCM_KEY_INDEX)HvGetCell(Hive, OldKeyNode->SubKeyLists[Stable]);
		if( OldIndex == NULL ) {
			//
			// we couldn't map the bin containing this cell
			//
			return STATUS_INSUFFICIENT_RESOURCES;
		}
		HvReleaseCell(Hive, OldKeyNode->SubKeyLists[Stable]);
		if( !HvMarkCellDirty(Hive, OldKeyNode->SubKeyLists[Stable],FALSE) ) {
			return STATUS_NO_LOG_SPACE;
		}

		if(OldIndex->Signature == CM_KEY_INDEX_ROOT) {
			for (i = 0; i < OldIndex->Count; i++) {
				if( !HvMarkCellDirty(Hive, OldIndex->List[i],FALSE) ) {
					return STATUS_NO_LOG_SPACE;
				}
			}
		} 
	}

    ParentKeyCell = OldKeyNode->Parent;
    //
    // now in the parent's spot
    //
    ParentKeyNode = (PCM_KEY_NODE)HvGetCell(Hive,ParentKeyCell);
    if( ParentKeyNode == NULL ) {
        //
        // cannot map view
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    if( !HvMarkCellDirty(Hive, ParentKeyCell,FALSE) ) {
        HvReleaseCell(Hive, ParentKeyCell);
        return STATUS_NO_LOG_SPACE;
    }
    // release the cell right here, as the registry is locked exclusively, so we don't care
    // Key_cell is marked dirty to keep the parent knode mapped
    HvReleaseCell(Hive, ParentKeyCell);

    ParentIndex = (PCM_KEY_INDEX)HvGetCell(Hive, ParentKeyNode->SubKeyLists[Stable]);
    if( ParentIndex == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    HvReleaseCell(Hive, ParentKeyNode->SubKeyLists[Stable]);

    if(ParentIndex->Signature == CM_KEY_INDEX_ROOT) {

        //
        // step through root, till we find the right leaf
        //
        for (i = 0; i < ParentIndex->Count; i++) {
            LeafCell = ParentIndex->List[i];
            Leaf = (PCM_KEY_INDEX)HvGetCell(Hive, LeafCell);
            if( Leaf == NULL ) {
                //
                // we couldn't map the bin containing this cell
                //
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            HvReleaseCell(Hive, LeafCell);

            if ( (Leaf->Signature == CM_KEY_FAST_LEAF) ||
                 (Leaf->Signature == CM_KEY_HASH_LEAF)
                ) {
                FastIndex = (PCM_KEY_FAST_INDEX)Leaf;
                for(j=0;j<FastIndex->Count;j++) {
                    if( FastIndex->List[j].Cell == OldKeyCell ) {
                        //
                        // found it! remember the locations we want to update later and break the loop
                        //
                        if( !HvMarkCellDirty(Hive, LeafCell,FALSE) ) {
					        return STATUS_NO_LOG_SPACE;
                        }
                        ParentIndexLocation = &(FastIndex->List[j].Cell);
                        break;
                    }
                }
                if( ParentIndexLocation != NULL ) {
                    break;
                }
            } else {
                for(j=0;j<Leaf->Count;j++) {
                    if( Leaf->List[j] == OldKeyCell ) {
                        //
                        // found it! remember the locations we want to update later and break the loop
                        //
                        if( !HvMarkCellDirty(Hive, LeafCell,FALSE) ) {
					        return STATUS_NO_LOG_SPACE;
                        }
                        ParentIndexLocation = &(Leaf->List[j]);
                        break;
                    }
                }
                if( ParentIndexLocation != NULL ) {
                    break;
                }
            }
        }
    } else if ( (ParentIndex->Signature == CM_KEY_FAST_LEAF) ||
                (ParentIndex->Signature == CM_KEY_HASH_LEAF)
        ) {
        FastIndex = (PCM_KEY_FAST_INDEX)ParentIndex;
        for(j=0;j<FastIndex->Count;j++) {
            if( FastIndex->List[j].Cell == OldKeyCell ) {
                //
                // found it! remember the locations we want to update later and break the loop
                //
                if( !HvMarkCellDirty(Hive, ParentKeyNode->SubKeyLists[Stable],FALSE) ) {
			        return STATUS_NO_LOG_SPACE;
                }
                ParentIndexLocation = &(FastIndex->List[j].Cell);
                break;
            }
        }
    } else {
        for(j=0;j<ParentIndex->Count;j++) {
            if( ParentIndex->List[j] == OldKeyCell ) {
                //
                // found it! remember the locations we want to update later and break the loop
                //
                if( !HvMarkCellDirty(Hive, ParentKeyNode->SubKeyLists[Stable],FALSE) ) {
			        return STATUS_NO_LOG_SPACE;
                }
                ParentIndexLocation = &(ParentIndex->List[j]);
                break;
            }
        }
    }

    // we should've find it !!!
    ASSERT( ParentIndexLocation != NULL );

    // 
    // 2. Duplicate the key_node (and values and all cells involved)
    //
    Status = CmpDuplicateKey(Hive,OldKeyCell,&NewKeyCell);
    if( !NT_SUCCESS(Status) ) {
        return Status;
    }

    // sanity
    ASSERT( (NewKeyCell != HCELL_NIL) && (StorageType == (HSTORAGE_TYPE)HvGetCellType(NewKeyCell)));

    //
    // 3. update the parent on each and every son.
    //
    if( !CmpUpdateParentForEachSon(Hive,NewKeyCell) ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    //
    // 4. replace the new Key_cell in the parent's subkeylist
    // From now on, WE CANNOT fails. we have everything marked dirty
    // we just update some fields. no resources required !
    // If we fail to free some cells, too bad, we'll leak some cells.
    //
    *ParentIndexLocation = NewKeyCell;

    //
    // 5. Update the kcb and the kcb cache
    //
    CmpCleanUpSubKeyInfo(KeyControlBlock->ParentKcb);
    KeyControlBlock->KeyCell = NewKeyCell;
    CmpRebuildKcbCache(KeyControlBlock);

    //
    // 6. remove old subkey
    //
    // First the Index; it's already marked dirty (i.e. PINNED)
    //
	if( OldKeyNode->SubKeyLists[Stable] != HCELL_NIL ) {
		OldIndex = (PCM_KEY_INDEX)HvGetCell(Hive, OldKeyNode->SubKeyLists[Stable]);
		ASSERT( OldIndex != NULL );
		HvReleaseCell(Hive, OldKeyNode->SubKeyLists[Stable]);
		if(OldIndex->Signature == CM_KEY_INDEX_ROOT) {
			for (i = 0; i < OldIndex->Count; i++) {
				HvFreeCell(Hive, OldIndex->List[i]);
			}
		} 
		HvFreeCell(Hive,OldKeyNode->SubKeyLists[Stable]);
	}

	OldKeyNode->SubKeyCounts[Stable] = 0;
    OldKeyNode->SubKeyCounts[Volatile] = 0;

    CmpFreeKeyByCell(Hive,OldKeyCell,FALSE);

    return STATUS_SUCCESS;

ErrorExit:
    //
    // we need to free the new knode allocated
    //
    NewKeyNode = (PCM_KEY_NODE)HvGetCell(Hive,NewKeyCell);
    // must be dirty
    ASSERT( NewKeyNode != NULL );
	HvReleaseCell(Hive, NewKeyCell);
	if( NewKeyNode->SubKeyLists[Stable] != HCELL_NIL ) {
		OldIndex = (PCM_KEY_INDEX)HvGetCell(Hive, NewKeyNode->SubKeyLists[Stable]);
		ASSERT( OldIndex != NULL );
		HvReleaseCell(Hive, NewKeyNode->SubKeyLists[Stable]);
		if(OldIndex->Signature == CM_KEY_INDEX_ROOT) {
			for (i = 0; i < OldIndex->Count; i++) {
				HvFreeCell(Hive, OldIndex->List[i]);
			}
		} 
		HvFreeCell(Hive,NewKeyNode->SubKeyLists[Stable]);
	}
    NewKeyNode->SubKeyCounts[Stable] = 0;
    NewKeyNode->SubKeyCounts[Volatile] = 0;

    CmpFreeKeyByCell(Hive,NewKeyCell,FALSE);
    return Status;

}

NTSTATUS
CmpDuplicateKey(
    PHHIVE          Hive,
    HCELL_INDEX     OldKeyCell,
    PHCELL_INDEX    NewKeyCell
    )
/*++

Routine Description:

    Makes an exact clone of OldKeyCell key_node in the 
    space above AboveFileOffset.
    Operates on Stable storage ONLY!!!

Arguments:


Return Value:

    NTSTATUS

--*/
{
    PCM_KEY_NODE			OldKeyNode;
    PCM_KEY_NODE			NewKeyNode;
    PRELEASE_CELL_ROUTINE   TargetReleaseCellRoutine;

    PAGED_CODE();

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
    ASSERT( HvGetCellType(OldKeyCell) == Stable );
    
    OldKeyNode = (PCM_KEY_NODE)HvGetCell(Hive,OldKeyCell);
    if( OldKeyNode == NULL ) {
        //
        // cannot map view
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // since the registry is locked exclusively here, we don't need to lock/release cells 
    // while copying the trees; So, we just set the release routines to NULL and restore after
    // the copy is complete; this saves some pain
    //
    TargetReleaseCellRoutine = Hive->ReleaseCellRoutine;
    Hive->ReleaseCellRoutine = NULL;

    *NewKeyCell = CmpCopyKeyPartial(Hive,OldKeyCell,Hive,OldKeyNode->Parent,TRUE);
    Hive->ReleaseCellRoutine  = TargetReleaseCellRoutine;

    if( *NewKeyCell == HCELL_NIL ) {
	    HvReleaseCell(Hive, OldKeyCell);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    NewKeyNode = (PCM_KEY_NODE)HvGetCell(Hive,*NewKeyCell);
    if( NewKeyNode == NULL ) {
        //
        // cannot map view
        //
	    HvReleaseCell(Hive, OldKeyCell);
        CmpFreeKeyByCell(Hive,*NewKeyCell,FALSE);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // now we have the key_cell duplicated. Values and security has also been taken care of
    // Go ahead and duplicate the Index.
    //
    if( OldKeyNode->SubKeyLists[Stable] != HCELL_NIL ) {
		NewKeyNode->SubKeyLists[Stable] = CmpDuplicateIndex(Hive,OldKeyNode->SubKeyLists[Stable],Stable);
		if( NewKeyNode->SubKeyLists[Stable] == HCELL_NIL ) {
			HvReleaseCell(Hive, OldKeyCell);
			CmpFreeKeyByCell(Hive,*NewKeyCell,FALSE);
			HvReleaseCell(Hive, *NewKeyCell);
			return STATUS_INSUFFICIENT_RESOURCES;
		}
	} else {
		ASSERT( OldKeyNode->SubKeyCounts[Stable] == 0 );
		NewKeyNode->SubKeyLists[Stable] = HCELL_NIL;
	}
    NewKeyNode->SubKeyCounts[Stable] = OldKeyNode->SubKeyCounts[Stable];
    NewKeyNode->SubKeyLists[Volatile] = OldKeyNode->SubKeyLists[Volatile];
    NewKeyNode->SubKeyCounts[Volatile] = OldKeyNode->SubKeyCounts[Volatile];

	HvReleaseCell(Hive, *NewKeyCell);
    HvReleaseCell(Hive, OldKeyCell);
    return STATUS_SUCCESS;

}

ULONG
CmpCompressKeyWorker(
    PCM_KEY_CONTROL_BLOCK Current,
    PVOID                 Context1,
    PVOID                 Context2
    )
{
	PLIST_ENTRY				pListHead;
	PCM_KCB_REMAP_BLOCK		kcbRemapBlock;
	//PLIST_ENTRY             AnchorAddr;

    if (Current->KeyHive == Context1) {
		
		pListHead = (PLIST_ENTRY)Context2;
		ASSERT( pListHead );

		kcbRemapBlock = (PCM_KCB_REMAP_BLOCK)ExAllocatePool(PagedPool, sizeof(CM_KCB_REMAP_BLOCK));
		if( kcbRemapBlock == NULL ) {
			return KCB_WORKER_ERROR;
		}
		kcbRemapBlock->KeyControlBlock = Current;
		kcbRemapBlock->NewCellIndex = HCELL_NIL;
		kcbRemapBlock->OldCellIndex = Current->KeyCell;
		kcbRemapBlock->ValueCount = 0;
		kcbRemapBlock->ValueList = HCELL_NIL;
        InsertTailList(pListHead,&(kcbRemapBlock->RemapList));

    }
    return KCB_WORKER_CONTINUE;   // always keep searching
}

NTSTATUS
CmCompressKey(
    IN PHHIVE Hive
    )
/*++

Routine Description:

	Compresses the kcb, by means of simulating an "in-place" SaveKey

    What needs to be done:

	1. iterate through the kcb tree and make a list of all the kcbs 
	that need to be changed (their keycell will change during the process)
	2. iterate through the cache and compute an array of security cells.
	We'll need it to map security cells into the new hive.
	3. Save the hive into a temporary hive, preserving
	the volatile info in keynodes and updating the cell mappings.
	4. Update the cache by adding volatile security cells from the old hive.
	5. Dump temporary (compressed) hive over to the old file.
	6. Switch hive data from the compressed one to the existing one and update
	the kcb KeyCell and security mapping
	7. Invalidate the map and drop paged bins.
	8. Free storage for the new hive (OK if we fail)

Arguments:

    Hive - Hive to operate on

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                Status = STATUS_SUCCESS;
    HCELL_INDEX             KeyCell;
    PCMHIVE                 CmHive;
    PCM_KCB_REMAP_BLOCK     RemapBlock;
    PCMHIVE                 NewHive = NULL;
    HCELL_INDEX             LinkCell;
    PCM_KEY_NODE            LinkNode;
    PCM_KNODE_REMAP_BLOCK   KnodeRemapBlock;
    ULONG                   OldLength;

    
	PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_CM,"CmCompressKey\n"));

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

    if( HvAutoCompressCheck(Hive) == FALSE ) {
        return STATUS_SUCCESS;
    }

    KeyCell = Hive->BaseBlock->RootCell;
    CmHive = CONTAINING_RECORD(Hive, CMHIVE, Hive);
    //
    // Make sure the cell passed in is the root cell of the hive.
    //
    if ( CmHive == CmpMasterHive ) {
        return STATUS_INVALID_PARAMETER;
    }

	//
	// 0. Get the cells we need to relink the compressed hive
	//
	LinkNode = (PCM_KEY_NODE)HvGetCell(Hive,KeyCell);
	if( LinkNode == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
	}
	LinkCell = LinkNode->Parent;
	HvReleaseCell(Hive,KeyCell);
	LinkNode = (PCM_KEY_NODE)HvGetCell((PHHIVE)CmpMasterHive,LinkCell);

	// master storage is paged pool
	ASSERT(LinkNode != NULL);
	HvReleaseCell((PHHIVE)CmpMasterHive,LinkCell);

    OldLength = Hive->BaseBlock->Length;

	//
	//	1. iterate through the kcb tree and make a list of all the kcbs 
	//	that need to be changed (their keycell will change during the process)
	//
	ASSERT( IsListEmpty(&(CmHive->KcbConvertListHead)) );

	//
	// this will kick all kcb with refcount == 0 out of cache, so we can use 
	// CmpSearchKeyControlBlockTree for recording referenced kcbs
	//
	CmpCleanUpKCBCacheTable(NULL,TRUE);
    if( !CmpSearchKeyControlBlockTree(CmpCompressKeyWorker,(PVOID)Hive,(PVOID)(&(CmHive->KcbConvertListHead))) ) {
		Status = STATUS_INSUFFICIENT_RESOURCES;
		goto Exit;
	}

	//
	// 2. iterate through the cache and compute an array of security cells.
	// We'll need it to map security cells into the new hive.
	//
	if( !CmpBuildSecurityCellMappingArray(CmHive) ) {
		Status = STATUS_INSUFFICIENT_RESOURCES;
		goto Exit;
	}

	//
	// 3. Save the hive into a temporary hive , preserving
	// the volatile info in keynodes and updating the cell mappings.
	//
	Status = CmpShiftHiveFreeBins(CmHive,&NewHive);
	if( !NT_SUCCESS(Status) ) {
		goto Exit;
	}

	//
	// 5. Dump temporary (compressed) hive over to the old file.
	//
	Status = CmpOverwriteHive(CmHive,NewHive,LinkCell);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }


	//
	// From this point on, we WILL NOT FAIL!
	//

	//
	// get the root node and link it into the master storage
	//
	LinkNode->ChildHiveReference.KeyCell = NewHive->Hive.BaseBlock->RootCell;

	//
	// 6. Switch hive data from the compressed one to the existing one and update
	// the kcb KeyCell and security mapping
	// This should better NOT fail!!! If it does, we are doomed, as we have partial
	// data => bugcheck
	//
	CmpSwitchStorageAndRebuildMappings(CmHive,NewHive);

	
	//
	// 7. Invalidate the map and drop paged bins. If system hive, check for the hysteresis callback.
	//
    HvpDropAllPagedBins(&(CmHive->Hive));
    if( OldLength < CmHive->Hive.BaseBlock->Length ) {
        CmpUpdateSystemHiveHysteresis(&(CmHive->Hive),CmHive->Hive.BaseBlock->Length,OldLength);
    }


Exit:

	//
	// 8. Free storage for the new hive (OK if we fail)
	//
	if( NewHive != NULL ) { 
		CmpDestroyTemporaryHive(NewHive);	
	}

	if( CmHive->CellRemapArray != NULL ) {
		ExFreePool(CmHive->CellRemapArray);
		CmHive->CellRemapArray = NULL;
	}
	//
	// remove all remap blocks and free them
	//
	while (IsListEmpty(&(CmHive->KcbConvertListHead)) == FALSE) {
        RemapBlock = (PCM_KCB_REMAP_BLOCK)RemoveHeadList(&(CmHive->KcbConvertListHead));
        RemapBlock = CONTAINING_RECORD(
                        RemapBlock,
                        CM_KCB_REMAP_BLOCK,
                        RemapList
                        );
		ExFreePool(RemapBlock);
	}
	while (IsListEmpty(&(CmHive->KnodeConvertListHead)) == FALSE) {
        KnodeRemapBlock = (PCM_KNODE_REMAP_BLOCK)RemoveHeadList(&(CmHive->KnodeConvertListHead));
        KnodeRemapBlock = CONTAINING_RECORD(
                            KnodeRemapBlock,
                            CM_KNODE_REMAP_BLOCK,
                            RemapList
                        );
		ExFreePool(KnodeRemapBlock);
	}

	return Status;
}

NTSTATUS
CmLockKcbForWrite(PCM_KEY_CONTROL_BLOCK KeyControlBlock)
/*++

Routine Description:

    Tags the kcb as being read-only and no-delay-close

Arguments:

    KeyControlBlock

--*/
{
    CM_PAGED_CODE();

    CmpLockKCBExclusive(KeyControlBlock);

    ASSERT_KCB(KeyControlBlock);
    if( KeyControlBlock->Delete ) {
        CmpUnlockKCB(KeyControlBlock);
        return STATUS_KEY_DELETED;
    }
    //
    // sanity check in case we are called twice
    //
    ASSERT( ((KeyControlBlock->ExtFlags&CM_KCB_READ_ONLY_KEY) && (KeyControlBlock->ExtFlags&CM_KCB_NO_DELAY_CLOSE)) ||
            (!(KeyControlBlock->ExtFlags&CM_KCB_READ_ONLY_KEY))
        );

    //
    // tag the kcb as read-only; also make it no-delay close so it can revert to the normal state after all handles are closed.
    //
    KeyControlBlock->ExtFlags |= (CM_KCB_READ_ONLY_KEY|CM_KCB_NO_DELAY_CLOSE);

    //
    // add an artificial refcount on this kcb. This will keep the kcb (and the read only flag set in memory for as long as the system is up)
    //
    InterlockedIncrement( (PLONG)&KeyControlBlock->RefCount );

    CmpUnlockKCB(KeyControlBlock);

    return STATUS_SUCCESS;
}

VALUE_SEARCH_RETURN_TYPE
CmpCompareNewValueDataAgainstKCBCache(  PCM_KEY_CONTROL_BLOCK KeyControlBlock,
                                        PUNICODE_STRING ValueName,
                                        ULONG Type,
                                        PVOID Data,
                                        ULONG DataSize
                                        )

/*++

Routine Description:

    Most of the SetValue calls are noops (i.e. they are setting the same 
    value name to the same value data). By comparing against the data already 
    in the kcb cache (i.e. faulted in) we can save page faults.


Arguments:

    KeyControlBlock - pointer to kcb for the key to operate on

    ValueName - The unique (relative to the containing key) name
        of the value entry.  May be NULL.

    Type - The integer type number of the value entry.

    Data - Pointer to buffer with actual data for the value entry.

    DataSize - Size of Data buffer.


Return Value:

    TRUE - same value with the same data exist in the cache.

--*/
{
    PCM_KEY_VALUE       Value;
    ULONG               Index;
    BOOLEAN             ValueCached;
    PPCM_CACHED_VALUE   ContainingList;
    HCELL_INDEX         ValueDataCellToRelease = HCELL_NIL;
    PUCHAR              datapointer = NULL;
    BOOLEAN             BufferAllocated = FALSE;
    HCELL_INDEX         CellToRelease = HCELL_NIL;
    ULONG               compareSize;
    ULONG               realsize;
    BOOLEAN             small;
    VALUE_SEARCH_RETURN_TYPE SearchValue = SearchFail;

    CM_PAGED_CODE();

    ASSERT_KCB_LOCKED(KeyControlBlock);

    if( KeyControlBlock->Flags & KEY_SYM_LINK ) {
        //
        // need to rebuild the value cache, so we could runt the same code
        //
        PCM_KEY_NODE    Node;
        if( (CmpIsKCBLockedExclusive(KeyControlBlock) == FALSE) &&
            (CmpTryConvertKCBLockSharedToExclusive(KeyControlBlock) == FALSE) ) {
            //
            // need to upgrade lock to exclusive
            //
            return SearchNeedExclusiveLock;
        }

        Node = (PCM_KEY_NODE)HvGetCell(KeyControlBlock->KeyHive,KeyControlBlock->KeyCell);

        if( Node == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            return SearchFail;
        }

        CmpCleanUpKcbValueCache(KeyControlBlock);
        CmpSetUpKcbValueCache(KeyControlBlock,Node->ValueList.Count,Node->ValueList.List);

        HvReleaseCell(KeyControlBlock->KeyHive,KeyControlBlock->KeyCell);
    }

    SearchValue = CmpFindValueByNameFromCache(  KeyControlBlock,
                                                ValueName,
                                                &ContainingList,
                                                &Index,
                                                &Value,
                                                &ValueCached,
                                                &ValueDataCellToRelease
                                                );

    if( SearchValue == SearchNeedExclusiveLock ) {
        //
        // retry with exclusive lock, since we need to update the cache
        //
        ASSERT( CmpIsKCBLockedExclusive(KeyControlBlock) == FALSE );    
        ASSERT( ValueDataCellToRelease == HCELL_NIL );    
        ASSERT( Value == NULL );
        goto Exit;
    }

    if (SearchValue == SearchSuccess) {
        ASSERT( Value != NULL );
        if( (Type == Value->Type) && (DataSize == (Value->DataLength & ~CM_KEY_VALUE_SPECIAL_SIZE)) ) {
        
            small = CmpIsHKeyValueSmall(realsize, Value->DataLength);
            if (small == TRUE) {
                datapointer = (PUCHAR)(&(Value->Data));
            } else {
                SearchValue = CmpGetValueDataFromCache(KeyControlBlock, ContainingList,(PCELL_DATA)Value, 
                                                ValueCached,&datapointer,&BufferAllocated,&CellToRelease);
                if(SearchValue != SearchSuccess  ) {
                    ASSERT( datapointer == NULL );
                    ASSERT( BufferAllocated == FALSE );
                    goto Exit;
                }
            }
            //
            // compare data
            //
            if (DataSize > 0) {

                try {
                    compareSize = (ULONG)RtlCompareMemory ((PVOID)datapointer,Data,(DataSize & ~CM_KEY_VALUE_SPECIAL_SIZE));
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    SearchValue = SearchFail;
                    goto Exit;
                }

            } else {
                compareSize = 0;
            }

            if (compareSize != DataSize) {
                SearchValue = SearchFail;
            }

        } else {
            SearchValue = SearchFail;
        }
    }

Exit:

    if(ValueDataCellToRelease != HCELL_NIL) {
        HvReleaseCell(KeyControlBlock->KeyHive,ValueDataCellToRelease);
    }
    if( BufferAllocated == TRUE ) {
        ExFreePool(datapointer);
    }
    if(CellToRelease != HCELL_NIL) {
        HvReleaseCell(KeyControlBlock->KeyHive,CellToRelease);
    }
    
    return SearchValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmchek.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmchek.c

Abstract:

    This module implements consistency checking for the registry.
    This module can be linked standalone, cmchek2.c cannot.

--*/

#include    "cmp.h"

#define     REG_MAX_PLAUSIBLE_KEY_SIZE \
                ((FIELD_OFFSET(CM_KEY_NODE, Name)) + \
                 (sizeof(WCHAR) * REG_MAX_KEY_NAME_LENGTH) + 16)

extern PCMHIVE CmpMasterHive;

//
// Private prototypes
//

ULONG
CmpCheckRegistry2(
    PHHIVE      HiveToCheck,
    ULONG       CheckFlags,
    HCELL_INDEX Cell,
    HCELL_INDEX ParentCell,
    BOOLEAN     ResetSD
    );

ULONG
CmpCheckKey(
    PHHIVE      HiveToCheck,
    ULONG       CheckFlags,
    HCELL_INDEX Cell,
    HCELL_INDEX ParentCell,
    BOOLEAN     ResetSD
    );

ULONG
CmpCheckValueList(
    PHHIVE      Hive,
    PCELL_DATA  List,
    ULONG       Count,
    HCELL_INDEX KeyCell
    );

BOOLEAN
CmpCheckLexicographicalOrder (  IN PHHIVE       HiveToCheck,
                                IN HCELL_INDEX  PriorSibling,
                                IN HCELL_INDEX  Current 
                                );

VOID
CmpLogError(IN NTSTATUS         NtStatusCode);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmCheckRegistry)
#pragma alloc_text(PAGE,CmpCheckRegistry2)
#pragma alloc_text(PAGE,CmpCheckKey)
#pragma alloc_text(PAGE,CmpCheckValueList)
#pragma alloc_text(PAGE,CmpCheckLexicographicalOrder)
#pragma alloc_text(PAGE,CmpLogError)

#endif

//
// debug structures
//

extern struct {
    PHHIVE      Hive;
    ULONG       Status;
} CmCheckRegistryDebug;

extern struct {
    PHHIVE      Hive;
    ULONG       Status;
} CmpCheckRegistry2Debug;

extern struct {
    PHHIVE      Hive;
    ULONG       Status;
    HCELL_INDEX Cell;
    PCELL_DATA  CellPoint;
    PVOID       RootPoint;
    ULONG       Index;
} CmpCheckKeyDebug;

extern struct {
    PHHIVE      Hive;
    ULONG       Status;
    PCELL_DATA  List;
    ULONG       Index;
    HCELL_INDEX Cell;
    PCELL_DATA  CellPoint;
} CmpCheckValueListDebug;


ULONG
CmCheckRegistry(
    PCMHIVE CmHive,
    ULONG   Flags
    )
/*++

Routine Description:

    Check consistency of the registry within a given hive.  Start from
    root, and check that:
        .   Each child key points back to its parent.
        .   All allocated cells are referred to exactly once
            (requires looking inside the hive structure...)
            [This also detects space leaks.]
        .   All allocated cells are reachable from the root.

    NOTE:   Exactly 1 ref rule may change with security.

Arguments:

    CmHive - supplies a pointer to the CM hive control structure for the
            hive of interest.

    Clean   - if TRUE, references to volatile cells will be zapped
              (done at startup only to avoid groveling hives twice.)
              if FALSE, nothing will be changed.
    
    HiveCheck - If TRUE, performs hive consistency check too (i.e. checks
                the bins)

Return Value:

    0 if Hive is OK.  Error return indicator if not.

    RANGE:  3000 - 3999

--*/
{
    PHHIVE                  Hive;
    ULONG                   rc = 0;
    ULONG                   Storage;
    PRELEASE_CELL_ROUTINE   ReleaseCellRoutine;
    BOOLEAN                 ResetSD = FALSE;

    if (CmHive == CmpMasterHive) {
        return(0);
    }

    CmCheckRegistryDebug.Hive = (PHHIVE)CmHive;
    CmCheckRegistryDebug.Status = 0;


    //
    // check the underlying hive and get storage use
    //
    Hive = &CmHive->Hive;

    if( Flags & CM_CHECK_REGISTRY_HIVE_CHECK ) {
        rc = HvCheckHive(Hive, &Storage);
        if (rc != 0) {
            CmCheckRegistryDebug.Status = rc;
            return rc;
        }
    }

    //
    // Store the release cell procedure so we can restore at the end;
    // Set it to NULL so we don't count : this saves us some pain during the check
    //
    ReleaseCellRoutine = Hive->ReleaseCellRoutine;
    Hive->ReleaseCellRoutine = NULL;

    //
    // Validate all the security descriptors in the hive
    //
    if (!CmpValidateHiveSecurityDescriptors(Hive,&ResetSD)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmCheckRegistry:"));
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL," CmpValidateHiveSecurityDescriptors failed\n"));
        rc = 3040;
        CmCheckRegistryDebug.Status = rc;
        Hive->ReleaseCellRoutine = ReleaseCellRoutine;
        return rc;
    }

    rc = CmpCheckRegistry2((PHHIVE)CmHive,Flags,Hive->BaseBlock->RootCell, HCELL_NIL,ResetSD);

    //
    // Print a bit of a summary (make sure this data avail in all error cases)
    //
    if (rc > 0) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmCheckRegistry Failed (%d): CmHive:%p\n", rc, CmHive));
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL," Hive:%p Root:%08lx\n", Hive, Hive->BaseBlock->RootCell));
    }

    //
    // restore the release cell routine
    // this saves us some pain during the check
    //
    Hive->ReleaseCellRoutine = ReleaseCellRoutine;

    return rc;
}

ULONG
CmpCheckRegistry2(
    PHHIVE      HiveToCheck,
    ULONG       CheckFlags,
    HCELL_INDEX Cell,
    HCELL_INDEX ParentCell,
    BOOLEAN     ResetSD
    )
/*++

Routine Description:

    Check consistency of the registry, from a particular cell on down.

        .   Check that the cell's value list, child key list, class,
            security are OK.
        .   Check that each value entry IN the list is OK.
        .   Apply self to each child key list.

    
    This version uses a stack in order to parse the tree "in-depth", 
    but not to touch any key_node.

Arguments:

    Cell - HCELL_INDEX of subkey to work on.

    ParentCell - expected value of parent cell for Cell, unless
                 HCELL_NIL, in which case ignore.

Return Value:

    0 if Hive is OK.  Error return indicator if not.

    RANGE:  4000 - 4999

--*/
{
    PCMP_CHECK_REGISTRY_STACK_ENTRY     CheckStack;
    LONG                                StackIndex;
    PCM_KEY_NODE                        Node;
    ULONG                               rc = 0;
    HCELL_INDEX                         SubKey;


    CmpCheckRegistry2Debug.Hive = HiveToCheck;
    CmpCheckRegistry2Debug.Status = 0;
    
    ASSERT( HiveToCheck->ReleaseCellRoutine == NULL );

    //
    // Initialize the stack to simulate recursion here
    //

    CmRetryExAllocatePoolWithTag(PagedPool,sizeof(CMP_CHECK_REGISTRY_STACK_ENTRY)*CMP_MAX_REGISTRY_DEPTH,CM_POOL_TAG|PROTECTED_POOL,CheckStack);
    if (CheckStack == NULL) {
        CmpCheckRegistry2Debug.Status = 4099;
        return 4099;
    }

Restart:

    CheckStack[0].Cell = Cell;
    CheckStack[0].ParentCell = ParentCell;
    CheckStack[0].PriorSibling = HCELL_NIL;
    CheckStack[0].ChildIndex = 0;
    CheckStack[0].CellChecked = FALSE;
    StackIndex = 0;


    while(StackIndex >=0) {
        //
        // first check the current cell
        //
        if( CheckStack[StackIndex].CellChecked == FALSE ) {
            CheckStack[StackIndex].CellChecked = TRUE;

            rc = CmpCheckKey(HiveToCheck,CheckFlags,CheckStack[StackIndex].Cell, CheckStack[StackIndex].ParentCell,ResetSD);
            if (rc != 0) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tChild is list entry #%08lx\n", CheckStack[StackIndex].ChildIndex));
                CmpCheckRegistry2Debug.Status = rc;
YankKey:
                if( CmDoSelfHeal() && StackIndex ) { // root cell damage is fatal.
                    //
                    // delete this key from the parent's list and restart the whole iteration (not best performance, but safest).
                    //
                    if( !CmpRemoveSubKeyCellNoCellRef(HiveToCheck,CheckStack[StackIndex].ParentCell,CheckStack[StackIndex].Cell) ) {
                        //
                        // unable to delete subkey; punt.
                        //
                        break;
                    }
                    CmMarkSelfHeal(HiveToCheck);
                    rc = 0;
                    goto Restart;
                } else {
                    // bail out
                    break;
                }
            } else if( StackIndex > 0 ) {
                //
                // key is OK, check lexicographical order with PriorSibling
                //
                if( CheckStack[StackIndex-1].PriorSibling != HCELL_NIL ) {
                
                    ASSERT( CheckStack[StackIndex-1].Cell == CheckStack[StackIndex].ParentCell );
                    
                    if( !CmpCheckLexicographicalOrder(HiveToCheck,CheckStack[StackIndex-1].PriorSibling,CheckStack[StackIndex].Cell) ) {
                        //
                        // invalid order
                        //
                        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\t Invalid subkey ordering key #%08lx\n", CheckStack[StackIndex].Cell));
                        CmpCheckRegistry2Debug.Status = 4091;
                        rc = 4091;
                        // attempt to yank the key
                        goto YankKey;
                    }
                }   
                CheckStack[StackIndex-1].PriorSibling = CheckStack[StackIndex].Cell;
            }
        }

        Node = (PCM_KEY_NODE)HvGetCell(HiveToCheck, CheckStack[StackIndex].Cell);
        if( Node == NULL ) {
            //
            // we couldn't map a view for the bin containing this cell
            //
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tCould not map cell #%08lx\n", CheckStack[StackIndex].Cell));
            CmpCheckRegistry2Debug.Status = 4098;
            rc = 4098;
            // bail out
            break;
        }

        if( CheckStack[StackIndex].ChildIndex < Node->SubKeyCounts[Stable] ) {
            //
            // we still have childs to check; add another entry for them and advance the 
            // StackIndex
            //
            SubKey = CmpFindSubKeyByNumber(HiveToCheck,
                                           Node,
                                           CheckStack[StackIndex].ChildIndex);
            if( SubKey == HCELL_NIL ) {
                //
                // we couldn't map cell;bail out
                //
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tCould not map cell #%08lx\n", CheckStack[StackIndex].Cell));
                CmpCheckRegistry2Debug.Status = 4097;
                rc = 4097;
                break;
            }
            //
            // next iteration will check the next child
            //
            CheckStack[StackIndex].ChildIndex++;

            StackIndex++;
            if( StackIndex == CMP_MAX_REGISTRY_DEPTH ) {
                //
                // we've run out of stack; registry tree has too many levels
                //
                CmpCheckRegistry2Debug.Status = 4096;
                rc = 4096;
                // bail out
                break;
            }
            CheckStack[StackIndex].Cell = SubKey;
            CheckStack[StackIndex].ParentCell = CheckStack[StackIndex-1].Cell;
            CheckStack[StackIndex].PriorSibling = HCELL_NIL;
            CheckStack[StackIndex].ChildIndex = 0;
            CheckStack[StackIndex].CellChecked = FALSE;

        } else {
            //
            // we have checked all childs for this node; go back
            //
            StackIndex--;

        }

    }

    ExFreePoolWithTag(CheckStack, CM_POOL_TAG|PROTECTED_POOL);
    return rc;
}


#if DBG

#define VOLATILE_KEY_NAME_LENGTH        PAGE_SIZE

HCELL_INDEX     CmpKeyCellDebug = 0;
WCHAR           CmpVolatileKeyNameBuffer[VOLATILE_KEY_NAME_LENGTH/2];
#endif //DBG

ULONG
CmpCheckKey(
    PHHIVE      HiveToCheck,
    ULONG       CheckFlags,
    HCELL_INDEX Cell,
    HCELL_INDEX ParentCell,
    BOOLEAN     ResetSD
    )
/*++

Routine Description:

    Check consistency of the registry, for a particular cell

        .   Check that the cell's value list, child key list, class,
            security are OK.
        .   Check that each value entry IN the list is OK.

Arguments:

    Cell - HCELL_INDEX of subkey to work on.

    ParentCell - expected value of parent cell for Cell, unless
                 HCELL_NIL, in which case ignore.

Return Value:

    0 if Hive is OK.  Error return indicator if not.

    RANGE:  4000 - 4999

--*/
{
    PCELL_DATA      pcell;
    ULONG           size;
    ULONG           usedlen;
    ULONG           ClassLength;
    HCELL_INDEX     Class;
    ULONG           ValueCount;
    HCELL_INDEX     ValueList;
    HCELL_INDEX     Security;
    ULONG           rc = 0;
    ULONG           nrc = 0;
    ULONG           i;
    PCM_KEY_INDEX   Root;
    PCM_KEY_INDEX   Leaf;
    ULONG           SubCount;

    CmpCheckKeyDebug.Hive = HiveToCheck;
    CmpCheckKeyDebug.Status = 0;
    CmpCheckKeyDebug.Cell = Cell;
    CmpCheckKeyDebug.CellPoint = NULL;
    CmpCheckKeyDebug.RootPoint = NULL;
    CmpCheckKeyDebug.Index = (ULONG)-1;

#if DBG
    if(CmpKeyCellDebug == Cell) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"Hive = %p :: Cell to debug = %lx\n",HiveToCheck,(ULONG)Cell));
        DbgBreakPoint();
    }
#endif //DBG

    //
    // Check key itself
    //
    if (! HvIsCellAllocated(HiveToCheck, Cell)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpCheckKey: HiveToCheck:%p Cell:%08lx\n", HiveToCheck, Cell));
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tNot allocated\n"));
        rc = 4010;
        CmpCheckKeyDebug.Status = rc;
        return rc;
    }
    pcell = HvGetCell(HiveToCheck, Cell);
    if( pcell == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tCould not map cell #%08lx\n", Cell));
        CmpCheckKeyDebug.Status = 4095;
        return 4095;
    }

    CmpCheckKeyDebug.CellPoint = pcell;

    size = HvGetCellSize(HiveToCheck, pcell);
    if (size > REG_MAX_PLAUSIBLE_KEY_SIZE) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpCheckKey: HiveToCheck:%p Cell:%08lx\n", HiveToCheck, Cell));
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tImplausible size %lx\n", size));
        rc = 4020;
        CmpCheckKeyDebug.Status = rc;
        return rc;
    }
    usedlen = FIELD_OFFSET(CM_KEY_NODE, Name) + pcell->u.KeyNode.NameLength;
    if( (!pcell->u.KeyNode.NameLength) || (usedlen > size)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpCheckKey: HiveToCheck:%p Cell:%08lx\n", HiveToCheck, Cell));
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tKey is bigger than containing cell.\n"));
        rc = 4030;
        CmpCheckKeyDebug.Status = rc;
        return rc;
    }
    if (pcell->u.KeyNode.Signature != CM_KEY_NODE_SIGNATURE) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpCheckKey: HiveToCheck:%p Cell:%08lx\n", HiveToCheck, Cell));
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tNo key signature\n"));
        rc = 4040;
        CmpCheckKeyDebug.Status = rc;
        if( CmDoSelfHeal() ) {
            //
            // this could be only signature corruption; fix it;
            //
            if( HvMarkCellDirty(HiveToCheck, Cell,FALSE) ) {
                pcell->u.KeyNode.Signature = CM_KEY_NODE_SIGNATURE;
                rc = 0;
                CmMarkSelfHeal(HiveToCheck);
            } else {
                return rc;
            }
        } else {
            return rc;
        }
    }
    if (ParentCell != HCELL_NIL) {
        if (pcell->u.KeyNode.Parent != ParentCell) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpCheckKey: HiveToCheck:%p Cell:%08lx\n", HiveToCheck, Cell));
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tWrong parent value.\n"));
            rc = 4045;
            CmpCheckKeyDebug.Status = rc;
            if( CmDoSelfHeal() ) {
                //
                // this could isolated corruption; fix it;
                //
                if( HvMarkCellDirty(HiveToCheck, Cell,FALSE) ) {
                    pcell->u.KeyNode.Parent = ParentCell;
                    CmMarkSelfHeal(HiveToCheck);
                    rc = 0;
                } else {
                    return rc;
                }
            } else {
                return rc;
            }
        }
    }
    ClassLength = pcell->u.KeyNode.ClassLength;
    Class = pcell->u.KeyNode.Class;
    ValueCount = pcell->u.KeyNode.ValueList.Count;
    ValueList = pcell->u.KeyNode.ValueList.List;
    Security = pcell->u.KeyNode.Security;

    //
    // Check simple non-empty cases
    //
    if (ClassLength > 0) {
        if( Class == HCELL_NIL ) {
            pcell->u.KeyNode.ClassLength = 0;
            HvMarkCellDirty(HiveToCheck, Cell,FALSE);
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpCheckKey: HiveToCheck:%p Cell:%08lx has ClassLength = %lu and Class == HCELL_NIL\n", HiveToCheck, Cell,ClassLength));
        } else {
            if (HvIsCellAllocated(HiveToCheck, Class) == FALSE) {
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpCheckKey: HiveToCheck:%p Cell:%08lx\n", HiveToCheck, Cell));
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tClass:%08lx - unallocated class\n", Class));
                    rc = 4080;
                    CmpCheckKeyDebug.Status = rc;
                    if( CmDoSelfHeal() ) {
                        //
                        // yank the class
                        //
                        if( HvMarkCellDirty(HiveToCheck, Cell,FALSE) ) {
                            pcell->u.KeyNode.Class = HCELL_NIL;
                            pcell->u.KeyNode.ClassLength = 0;
                            CmMarkSelfHeal(HiveToCheck);
                            rc = 0;
                        } else {
                            return rc;
                        }
                    } else {
                        return rc;
                    }
            } 
        }
    }

    if (Security != HCELL_NIL) {
        if ((HvIsCellAllocated(HiveToCheck, Security) == FALSE) || 
            ((ParentCell != HCELL_NIL) && CmDoSelfHeal() && ResetSD) ) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpCheckKey: HiveToCheck:%p Cell:%08lx\n", HiveToCheck, Cell));
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tSecurity:%08lx - unallocated security\n", Security));
            rc = 4090;
            CmpCheckKeyDebug.Status = rc;
            goto SetParentSecurity;
        } 
        //
        // Else CmpValidateHiveSecurityDescriptors must do computation
        //
    } else {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"SecurityCell is HCELL_NIL for (%p,%08lx) !!!\n", HiveToCheck, Cell));
        rc = 4130;
        CmpCheckKeyDebug.Status = rc;
SetParentSecurity:
        if( CmDoSelfHeal() ) {
            //
            // attempt to set the same security as it's parent
            //
            PCM_KEY_NODE ParentNode = NULL;
            PCM_KEY_SECURITY SecurityNode = NULL;

            if( ParentCell != HCELL_NIL ) {
                ParentNode = (PCM_KEY_NODE )HvGetCell(HiveToCheck, ParentCell);
                SecurityNode = (PCM_KEY_SECURITY)HvGetCell(HiveToCheck, ParentNode->Security);
            }

            if( ParentNode == NULL || SecurityNode == NULL ) {
                //
                // we couldn't map a view for the bin containing this cell
                //
                return rc;
            }

            if( HvMarkCellDirty(HiveToCheck, Cell,FALSE) &&  HvMarkCellDirty(HiveToCheck, ParentNode->Security,FALSE) ) {
                pcell->u.KeyNode.Security = ParentNode->Security;
                SecurityNode->ReferenceCount++;
                rc = 0;
                CmMarkSelfHeal(HiveToCheck);
            } else {
                return rc;
            }
        } else {
            return rc;
        }
        
    }

    //
    // Check value list case
    //
    if (ValueCount > 0) {
        if (HvIsCellAllocated(HiveToCheck, ValueList) == FALSE) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpCheckKey: HiveToCheck:%p Cell:%08lx\n", HiveToCheck, Cell));
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tValueList:%08lx - unallocated valuelist\n", ValueList));
            rc = 4100;
            CmpCheckKeyDebug.Status = rc;
            goto YankValueList;
        } else {
            pcell = HvGetCell(HiveToCheck, ValueList);
            if( pcell == NULL ) {
                //
                // we couldn't map a view for the bin containing this cell
                //
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tCould not map cell #%08lx\n", ValueList));
                CmpCheckKeyDebug.Status = 4094;
                return 4094;
            }
            if( ValueCount * sizeof(HCELL_INDEX) > (ULONG)HvGetCellSize(HiveToCheck,pcell) ) {
                //
                // implausible value count.
                //
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpCheckKey: HiveToCheck:%p Cell:%08lx\n", HiveToCheck, Cell));
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tValueList:%08lx - Implausible ValueCount = %08lx\n", ValueList,ValueCount));
                rc = 4095;
                CmpCheckKeyDebug.Status = rc;
                goto YankValueList;
            }

            nrc = CmpCheckValueList(HiveToCheck, pcell, ValueCount,Cell);
            if (nrc != 0) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"List was for HiveToCheck:%p Cell:%08lx\n", HiveToCheck, Cell));
                rc = nrc;
                CmpCheckKeyDebug.CellPoint = pcell;
                CmpCheckKeyDebug.Status = rc;
YankValueList:
                if( CmDoSelfHeal() ) {
                    PCM_KEY_NODE KeyNode;
                    //
                    // make the key valueless
                    //
                    if( HvMarkCellDirty(HiveToCheck, Cell,FALSE) && (KeyNode = (PCM_KEY_NODE)HvGetCell(HiveToCheck, Cell) ) ) {
                        KeyNode->ValueList.Count = 0;
                        KeyNode->ValueList.List = HCELL_NIL;
                        CmMarkSelfHeal(HiveToCheck);
                        rc = 0;
                    } else {
                        return rc;
                    }
                } else {
                    return rc;
                }
            }
        }
    }


    //
    // Check subkey list case
    //

    pcell = HvGetCell(HiveToCheck, Cell);
    if( pcell == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tCould not map cell #%08lx\n", Cell));
        CmpCheckKeyDebug.Status = 4093;
        return 4093;
    }
    CmpCheckKeyDebug.CellPoint = pcell;
    if ((HvGetCellType(Cell) == Volatile) &&
        (pcell->u.KeyNode.SubKeyCounts[Stable] != 0))
    {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpCheckKey: HiveToCheck:%p Cell:%08lx\n", HiveToCheck, Cell));
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tVolatile Cell has Stable children\n"));
        rc = 4108;
        CmpCheckKeyDebug.Status = rc;
        return rc;
    } else if (pcell->u.KeyNode.SubKeyCounts[Stable] > 0) {
        if (! HvIsCellAllocated(HiveToCheck, pcell->u.KeyNode.SubKeyLists[Stable])) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpCheckKey: HiveToCheck:%p Cell:%08lx\n", HiveToCheck, Cell));
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tStableKeyList:%08lx - unallocated\n", pcell->u.KeyNode.SubKeyLists[Stable]));
            rc = 4110;
            CmpCheckKeyDebug.Status = rc;
            goto YankStableSubkeys;
        } else {
            //
            // Prove that the index is OK
            //
            Root = (PCM_KEY_INDEX)HvGetCell(
                                    HiveToCheck,
                                    pcell->u.KeyNode.SubKeyLists[Stable]
                                    );
            if( Root == NULL ) {
                //
                // we couldn't map a view for the bin containing this cell
                //
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tCould not map cell #%08lx\n", pcell->u.KeyNode.SubKeyLists[Stable]));
                CmpCheckKeyDebug.Status = 4093;
                return 4093;
            }
            CmpCheckKeyDebug.RootPoint = Root;
            if ((Root->Signature == CM_KEY_INDEX_LEAF) ||
                (Root->Signature == CM_KEY_FAST_LEAF)  ||
                (Root->Signature == CM_KEY_HASH_LEAF) ) {
                if ((ULONG)Root->Count != pcell->u.KeyNode.SubKeyCounts[Stable]) {
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpCheckKey: HiveToCheck:%p Cell:%08lx\n", HiveToCheck, Cell));
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tBad Index count @%08lx\n", Root));
                    rc = 4120;
                    CmpCheckKeyDebug.Status = rc;
                    if( CmDoSelfHeal() ) {
                        //
                        // fix the subkeycount
                        //
                        if( HvMarkCellDirty(HiveToCheck, Cell,FALSE) ) {
                            pcell->u.KeyNode.SubKeyCounts[Stable] = (ULONG)Root->Count;
                            CmMarkSelfHeal(HiveToCheck);
                            rc = 0;
                        } else {
                            return rc;
                        }
                    } else {
                        return rc;
                    } 
                }
            } else if (Root->Signature == CM_KEY_INDEX_ROOT) {
                SubCount = 0;
                for (i = 0; i < Root->Count; i++) {
                    CmpCheckKeyDebug.Index = i;
                    if (! HvIsCellAllocated(HiveToCheck, Root->List[i])) {
                        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpCheckKey: Hive:%p Cell:%08lx\n", HiveToCheck, Cell));
                        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tBad Leaf Cell %08lx Root@%08lx\n", Root->List[i], Root));
                        rc = 4130;
                        CmpCheckKeyDebug.Status = rc;
                        goto YankStableSubkeys;
                    }
                    Leaf = (PCM_KEY_INDEX)HvGetCell(HiveToCheck,
                                                    Root->List[i]);
                    if( Leaf == NULL ) {
                        //
                        // we couldn't map a view for the bin containing this cell
                        //
                        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tCould not map cell #%08lx\n", Root->List[i]));
                        CmpCheckKeyDebug.Status = 4092;
                        return 4092;
                    }

                    if ((Leaf->Signature != CM_KEY_INDEX_LEAF) &&
                        (Leaf->Signature != CM_KEY_FAST_LEAF)  &&
                        (Leaf->Signature != CM_KEY_HASH_LEAF) ) {
                        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpCheckKey: HiveToCheck:%p Cell:%08lx\n", HiveToCheck, Cell));
                        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tBad Leaf Index @%08lx Root@%08lx\n", Leaf, Root));
                        rc = 4140;
                        CmpCheckKeyDebug.Status = rc;
                        goto YankStableSubkeys;
                    }
                    SubCount += Leaf->Count;
                }
                if (pcell->u.KeyNode.SubKeyCounts[Stable] != SubCount) {
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpCheckKey: HiveToCheck:%p Cell:%08lx\n", HiveToCheck, Cell));
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tBad count in index, SubCount=%08lx\n", SubCount));
                    rc = 4150;
                    CmpCheckKeyDebug.Status = rc;
                    if( CmDoSelfHeal() ) {
                        //
                        // fix the subkeycount
                        //
                        if( HvMarkCellDirty(HiveToCheck, Cell,FALSE) ) {
                            pcell->u.KeyNode.SubKeyCounts[Stable] = SubCount;
                            CmMarkSelfHeal(HiveToCheck);
                            rc = 0;
                        } else {
                            return rc;
                        }
                    } else {
                        return rc;
                    } 
                }
            } else {
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpCheckKey: HiveToCheck:%p Cell:%08lx\n", HiveToCheck, Cell));
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tBad Root index signature @%08lx\n", Root));
                rc = 4120;
                CmpCheckKeyDebug.Status = rc;
                goto YankStableSubkeys;
            }
        }
    }
    if( FALSE ) {
YankStableSubkeys:
        if( CmDoSelfHeal() ) {
            //
            // mark the key as no subkeys
            //
            if( HvMarkCellDirty(HiveToCheck, Cell,FALSE) ) {
                pcell->u.KeyNode.SubKeyCounts[Stable] = 0;
                pcell->u.KeyNode.SubKeyLists[Stable] = HCELL_NIL;
                CmMarkSelfHeal(HiveToCheck);
                rc = 0;
            } else {
                return rc;
            }
        } else {
            return rc;
        } 
    }
    //
    // force volatiles to be empty, if this is a load operation
    //
    if ( (CheckFlags & CM_CHECK_REGISTRY_FORCE_CLEAN) || // force clear out volatile info 
         ( 
             ( CheckFlags & (CM_CHECK_REGISTRY_CHECK_CLEAN | CM_CHECK_REGISTRY_LOADER_CLEAN) ) &&  // if asked to clear volatile info
             ( pcell->u.KeyNode.SubKeyCounts[Volatile] != 0 )                               // there is some volatile info saved from a previous version
         )                                             ||
         (
             ( CheckFlags & CM_CHECK_REGISTRY_SYSTEM_CLEAN ) &&         // system hive special case; the loader has cleaned only subkeycount
             (( pcell->u.KeyNode.SubKeyLists[Volatile] != HCELL_NIL ) ||    // now it is our job to clear Subkeylist, too
             (HiveToCheck->Version < HSYS_WHISTLER_BETA1) )
         ) 
        
        ) {
        //
        // go ahead and clear the volatile info for this key
        //
        if( CheckFlags & CM_CHECK_REGISTRY_SYSTEM_CLEAN ) {
            //
            // the loader must've left this on the previous value and cleared only the count
            //
            ASSERT( pcell->u.KeyNode.SubKeyLists[Volatile] == 0xBAADF00D || HiveToCheck->Version < HSYS_WHISTLER_BETA1 );
            ASSERT( pcell->u.KeyNode.SubKeyCounts[Volatile] == 0 );
#if DBG
            //
            // see who those volatile keys are
            //
            {
                ULONG           TotalLength = 0;
                HCELL_INDEX     CurrCell = Cell;
                PCM_KEY_NODE    CurrNode;
                PUCHAR          Dest;
                ULONG           k;

                Dest = ((PUCHAR)CmpVolatileKeyNameBuffer) + VOLATILE_KEY_NAME_LENGTH - 2;
                while(TRUE) {
                    CurrNode = (PCM_KEY_NODE)HvGetCell(HiveToCheck,CurrCell);
                    Dest -= CurrNode->NameLength;
                    TotalLength += CurrNode->NameLength;
                    if (CurrNode->Flags & KEY_COMP_NAME) {
                        Dest -= CurrNode->NameLength;
                        for (k=0;k<CurrNode->NameLength;k++) {
                            ((PWCHAR)Dest)[k] = (WCHAR)(((PUCHAR)CurrNode->Name)[k]);
                        }
                    } else {
                        RtlCopyMemory(
                            Dest,
                            CurrNode->Name,
                            CurrNode->NameLength
                            );
                    }
                    Dest -= 2;
                    TotalLength += (CurrNode->NameLength +2);
                    ((PWCHAR)Dest)[0] = (WCHAR)'\\';
                    if( CurrCell == HiveToCheck->BaseBlock->RootCell ) {
                        break;
                    }
                    CurrCell = CurrNode->Parent;
                }  
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"%.*S\n",TotalLength/2,Dest));
                
            }
#endif

        }

        HvMarkCellDirty(HiveToCheck, Cell,FALSE);
        pcell->u.KeyNode.SubKeyCounts[Volatile] = 0;
        if( (CheckFlags & CM_CHECK_REGISTRY_LOADER_CLEAN) &&
            (HiveToCheck->Version >= HSYS_WHISTLER_BETA1)
            ) {
            //
            // mark this as bad food
            //
            pcell->u.KeyNode.SubKeyLists[Volatile] = 0xBAADF00D;
        } else {
            //
            // clean it up 
            //
            pcell->u.KeyNode.SubKeyLists[Volatile] = HCELL_NIL;
        }
    }

    return rc;
}

ULONG
CmpCheckValueList(
    PHHIVE      Hive,
    PCELL_DATA  List,
    ULONG       Count,
    HCELL_INDEX KeyCell
    )
/*++

Routine Description:

    Check consistency of a value list.
        .   Each element allocated?
        .   Each element have valid signature?
        .   Data properly allocated?

Arguments:

    Hive - containing Hive.

    List - pointer to an array of HCELL_INDEX entries.

    Count - number of entries in list.

Return Value:

    0 if Hive is OK.  Error return indicator if not.

    RANGE:  5000 - 5999

--*/
{
    ULONG           i = 0,j;
    HCELL_INDEX     Cell;
    PCELL_DATA      pcell;
    ULONG           size;
    ULONG           usedlen;
    ULONG           DataLength;
    HCELL_INDEX     Data;
    ULONG           rc = 0;

    CmpCheckValueListDebug.Hive = Hive;
    CmpCheckValueListDebug.Status = 0;
    CmpCheckValueListDebug.List = List;
    CmpCheckValueListDebug.Index = (ULONG)-1;
    CmpCheckValueListDebug.Cell = 0;   // NOT HCELL_NIL
    CmpCheckValueListDebug.CellPoint = NULL;

    if( FALSE ) {
RemoveThisValue:
        if( CmDoSelfHeal() ) {
            //
            // remove value at index i
            //
            PCM_KEY_NODE    Node;
            Node = (PCM_KEY_NODE)HvGetCell(Hive,KeyCell);
            if( Node == NULL ) {
                return rc;
            }
            HvReleaseCell(Hive,KeyCell);

            if( HvMarkCellDirty(Hive, KeyCell,FALSE) &&
                HvMarkCellDirty(Hive, Node->ValueList.List,FALSE)) {
                Node->ValueList.Count--;
                Count--;
                RtlMoveMemory(&(List->u.KeyList[i]),&(List->u.KeyList[i+1]),(Count - i)*sizeof(HCELL_INDEX));
                rc = 0;
                CmMarkSelfHeal(Hive);
            } else {
                return rc;
            }
        } else {
            return rc;
        } 
    }

    for (; i < Count; i++) {

        //
        // Check out value entry's refs.
        //
        Cell = List->u.KeyList[i];
        if (Cell == HCELL_NIL) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpCheckValueList: List:%p i:%08lx\n", List, i));
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tEntry is null\n"));
            rc = 5010;
            CmpCheckValueListDebug.Status = rc;
            CmpCheckValueListDebug.Index = i;
            CmpCheckValueListDebug.Cell = Cell;
            goto RemoveThisValue;
        }
        if (HvIsCellAllocated(Hive, Cell) == FALSE) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpCheckValueList: List:%p i:%08lx\n", List, i));
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tEntry is not allocated\n"));
            rc = 5020;
            CmpCheckValueListDebug.Status = rc;
            CmpCheckValueListDebug.Index = i;
            CmpCheckValueListDebug.Cell = Cell;
            goto RemoveThisValue;
        } 

        //
        // Check out the value entry itself
        //
        pcell = HvGetCell(Hive, Cell);
        if( pcell == NULL ) {
            //
            // we couldn't map a view for the bin containing this cell
            //
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tCould not map cell #%08lx\n", Cell));
            CmpCheckValueListDebug.Status = 5099;
            CmpCheckValueListDebug.Index = i;
            CmpCheckValueListDebug.Cell = Cell;
            rc = 5099;
            goto Exit;
        }
        size = HvGetCellSize(Hive, pcell);
        if (pcell->u.KeyValue.Signature != CM_KEY_VALUE_SIGNATURE) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpCheckValueList: List:%p i:%08lx\n", List, i));
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tCell:%08lx - invalid value signature\n", Cell));
            rc = 5030;
            CmpCheckValueListDebug.Status = rc;
            CmpCheckValueListDebug.Index = i;
            CmpCheckValueListDebug.Cell = Cell;
            CmpCheckValueListDebug.CellPoint = pcell;
            goto RemoveThisValue;
        }
        usedlen = FIELD_OFFSET(CM_KEY_VALUE, Name) + pcell->u.KeyValue.NameLength;
        if (usedlen > size) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpCheckValueList: List:%p i:%08lx\n", List, i));
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tCell:%08lx - value bigger than containing cell\n", Cell));
            rc = 5040;
            CmpCheckValueListDebug.Status = rc;
            CmpCheckValueListDebug.Index = i;
            CmpCheckValueListDebug.Cell = Cell;
            CmpCheckValueListDebug.CellPoint = pcell;
            goto RemoveThisValue;
        }

        //
        // Check out value entry's data
        //
        DataLength = pcell->u.KeyValue.DataLength;
        if (DataLength < CM_KEY_VALUE_SPECIAL_SIZE) {
            Data = pcell->u.KeyValue.Data;
            if ((DataLength == 0) && (Data != HCELL_NIL)) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpCheckValueList: List:%p i:%08lx\n", List, i));
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tCell:%08lx Data:%08lx - data not null\n", Cell, Data));
                rc = 5050;
                CmpCheckValueListDebug.Status = rc;
                CmpCheckValueListDebug.Index = i;
                CmpCheckValueListDebug.Cell = Cell;
                CmpCheckValueListDebug.CellPoint = pcell;
                goto RemoveThisValue;
            }
            if (DataLength > 0) {
                if (HvIsCellAllocated(Hive, Data) == FALSE) {
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpCheckValueList: List:%p i:%08lx\n", List, i));
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tCell:%08lx Data:%08lx - unallocated\n", Cell, Data));
                    rc = 5060;
                    CmpCheckValueListDebug.Status = rc;
                    CmpCheckValueListDebug.Index = i;
                    CmpCheckValueListDebug.Cell = Cell;
                    CmpCheckValueListDebug.CellPoint = pcell;
                    goto RemoveThisValue;
                }
            }
            if( CmpIsHKeyValueBig(Hive,DataLength) == TRUE ) {
                PCM_BIG_DATA    BigData;
                PHCELL_INDEX    Plist;

                BigData = (PCM_BIG_DATA)HvGetCell(Hive, Data);
                if( BigData == NULL ) {
                    //
                    // we couldn't map a view for the bin containing this cell
                    //
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tCould not map cell #%08lx\n", Data));
                    CmpCheckValueListDebug.Status = 5098;
                    CmpCheckValueListDebug.Index = i;
                    CmpCheckValueListDebug.Cell = Data;
                    rc = 5098;
                    goto Exit;
                }
                
                if( (BigData->Signature != CM_BIG_DATA_SIGNATURE) ||
                    (BigData->Count == 0 ) ||
                    (BigData->List == HCELL_NIL) 
                    ) {
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tinvalid big data cell #%08lx\n", Data));
                    CmpCheckValueListDebug.Status = 5097;
                    CmpCheckValueListDebug.Index = i;
                    CmpCheckValueListDebug.Cell = Data;
                    rc = 5097;
                    goto RemoveThisValue;
                }
                
                if (HvIsCellAllocated(Hive, BigData->List) == FALSE) {
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpCheckValueList: List:%p i:%08lx\n", List, i));
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tCell:%08lx DataList:%08lx - unallocated\n", Cell, BigData->List));
                    rc = 5096;
                    CmpCheckValueListDebug.Status = rc;
                    CmpCheckValueListDebug.Index = i;
                    CmpCheckValueListDebug.Cell = BigData->List;
                    CmpCheckValueListDebug.CellPoint = (PCELL_DATA)BigData;
                    goto RemoveThisValue;
                }

                Plist = (PHCELL_INDEX)HvGetCell(Hive,BigData->List);
                if( Plist == NULL ) {
                    //
                    // we couldn't map a view for the bin containing this cell
                    //
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tCould not map cell #%08lx\n", BigData->List));
                    CmpCheckValueListDebug.Status = 5098;
                    CmpCheckValueListDebug.Index = i;
                    CmpCheckValueListDebug.Cell = BigData->List;
                    rc = 5095;
                    goto Exit;
                }

                //
                // check each and every big data cell to see if it is allocated.
                // 
                for(j=0;j<BigData->Count;j++) {
                    if (HvIsCellAllocated(Hive, Plist[j]) == FALSE) {
                        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpCheckValueList: List:%p j:%08lx\n", BigData->List, j));
                        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tCell:%08lx BigData:%08lx - unallocated\n", Plist[j], BigData->List));
                        rc = 5094;
                        CmpCheckValueListDebug.Status = rc;
                        CmpCheckValueListDebug.Index = j;
                        CmpCheckValueListDebug.Cell = Plist[j];
                        CmpCheckValueListDebug.CellPoint = (PCELL_DATA)BigData;
                        goto RemoveThisValue;
                    }
                }
            }

        }
    }

Exit:
    // cleanup
        
    return rc;
}

BOOLEAN
CmpCheckLexicographicalOrder (  IN PHHIVE       HiveToCheck,
                                IN HCELL_INDEX  PriorSibling,
                                IN HCELL_INDEX  Current 
                                )
{
    PCM_KEY_NODE    CurrentNode;
    PCM_KEY_NODE    PriorNode;
    UNICODE_STRING  PriorKeyName;
    UNICODE_STRING  CurrentKeyName;

    PAGED_CODE();


    CurrentNode = (PCM_KEY_NODE)HvGetCell(HiveToCheck, Current);
    PriorNode = (PCM_KEY_NODE)HvGetCell(HiveToCheck, PriorSibling);
    if( (CurrentNode == NULL) || (PriorNode == NULL ) ) {
        return FALSE;
    }
    if(CurrentNode->Flags & KEY_COMP_NAME) { 
        if(PriorNode->Flags & KEY_COMP_NAME) {
            //
            // most usual case
            //
            if( CmpCompareTwoCompressedNames(   PriorNode->Name,
                                                PriorNode->NameLength,
                                                CurrentNode->Name,
                                                CurrentNode->NameLength ) >=0 ) {
                return FALSE;
            }
        } else {
            PriorKeyName.Buffer = &(PriorNode->Name[0]);
            PriorKeyName.Length = PriorNode->NameLength;
            PriorKeyName.MaximumLength = PriorKeyName.Length;
            if( CmpCompareCompressedName(&PriorKeyName,
                                        CurrentNode->Name,
                                        CurrentNode->NameLength,
                                        0) >= 0 ) {
                return FALSE;            
            }

        }
    } else {
        if(PriorNode->Flags & KEY_COMP_NAME) {
            CurrentKeyName.Buffer = &(CurrentNode->Name[0]);
            CurrentKeyName.Length = CurrentNode->NameLength;
            CurrentKeyName.MaximumLength = CurrentKeyName.Length;
            if( CmpCompareCompressedName(&CurrentKeyName,
                                        PriorNode->Name,
                                        PriorNode->NameLength,
                                        0) <= 0 ) {
                return FALSE;            
            }
        } else {
            //
            // worst case: two unicode strings
            //
            PriorKeyName.Buffer = &(PriorNode->Name[0]);
            PriorKeyName.Length = PriorNode->NameLength;
            PriorKeyName.MaximumLength = PriorKeyName.Length;
            CurrentKeyName.Buffer = &(CurrentNode->Name[0]);
            CurrentKeyName.Length = CurrentNode->NameLength;
            CurrentKeyName.MaximumLength = CurrentKeyName.Length;
            if( RtlCompareUnicodeString(&PriorKeyName,
                                        &CurrentKeyName,
                                        TRUE) >= 0 ) {
                return FALSE;
            }

        }
    }
    
    return TRUE;
}

//
// EventLog helpers
//
VOID
CmpLogError(IN NTSTATUS         NtStatusCode)
/*++

Routine Description:

    This routine writes an eventlog entry to the eventlog.

Arguments:

Return Value:


--*/
{
    PIO_ERROR_LOG_PACKET pErrorLog;
    
    CM_PAGED_CODE();

    pErrorLog = (PIO_ERROR_LOG_PACKET) IoAllocateGenericErrorLogEntry(sizeof(IO_ERROR_LOG_PACKET));
    if (pErrorLog) {
        pErrorLog->FinalStatus = NtStatusCode;
        pErrorLog->ErrorCode = NtStatusCode;
        IoWriteErrorLogEntry(pErrorLog);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmclose.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmclose.c

Abstract:

    This module contains the close object method.

--*/

#include    "cmp.h"

VOID
CmpDelayedDerefKeys(
                    PLIST_ENTRY DelayedDeref
                    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpCloseKeyObject)
#endif

VOID
CmpCloseKeyObject(
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG_PTR ProcessHandleCount,
    IN ULONG_PTR SystemHandleCount
    )
/*++

Routine Description:

    This routine interfaces to the NT Object Manager.  It is invoked when
    a Key object (or Key Root object) is closed.

    It's function is to do cleanup processing by waking up any notifies
    pending on the handle.  This keeps the key object from hanging around
    forever because a synchronous notify is stuck on it somewhere.

    All other cleanup, in particular, the freeing of storage, will be
    done in CmpDeleteKeyObject.

Arguments:

    Process - ignored

    Object - supplies a pointer to a KeyRoot or Key, thus -> KEY_BODY.

    GrantedAccess, ProcessHandleCount, SystemHandleCount - ignored

Return Value:

    NONE.

--*/
{
    PCM_KEY_BODY        KeyBody;
    PCM_NOTIFY_BLOCK    NotifyBlock;

    CM_PAGED_CODE();

    UNREFERENCED_PARAMETER (Process);
    UNREFERENCED_PARAMETER (GrantedAccess);
    UNREFERENCED_PARAMETER (ProcessHandleCount);

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_POOL,"CmpCloseKeyObject: Object = %p\n", Object));

    if( SystemHandleCount > 1 ) {
        //
        // There are still has open handles on this key. Do nothing
        //
        return;
    }

    KeyBody = (PCM_KEY_BODY)Object;

    //
    // Check the type, it will be something else if we are closing a predefined
    // handle key
    //
    if (KeyBody->Type == KEY_BODY_TYPE) {

        if (KeyBody->NotifyBlock == NULL) {
            return;
        }

        CmpLockRegistry();

        //
        // Clean up any outstanding notifies attached to the KeyBody
        //
        CmLockHive((PCMHIVE)(KeyBody->KeyControlBlock->KeyHive));
        if (KeyBody->NotifyBlock != NULL) {
            //
            // Post all PostBlocks waiting on the NotifyBlock
            //
            NotifyBlock = KeyBody->NotifyBlock;
            if (IsListEmpty(&(NotifyBlock->PostList)) == FALSE) {
                LIST_ENTRY          DelayedDeref;
                //
                // we need to follow the rule here the hive lock
                // otherwise we could deadlock down in CmDeleteKeyObject. We don't acquire the kcb lock, 
                // but we make sure that in subsequent places where we get the hive lock we get it before 
                // the kcb lock, ie. we follow the precedence rule below. 
                //
                // NB: the order of these locks is First the hive lock, then the kcb lock
                //
                InitializeListHead(&DelayedDeref);
                CmpPostNotify(NotifyBlock,
                              NULL,
                              0,
                              STATUS_NOTIFY_CLEANUP,
                              FALSE,
                              &DelayedDeref
#if DBG
                              ,(PCMHIVE)(KeyBody->KeyControlBlock->KeyHive)
#endif
                              );
                //
                // finish the job started in CmpPostNotify (i.e. dereference the keybodies
                // we prevented. this may cause some notifyblocks to be freed
                //
                CmpDelayedDerefKeys(&DelayedDeref);
            }
        }
        CmUnlockHive((PCMHIVE)(KeyBody->KeyControlBlock->KeyHive));

        CmpUnlockRegistry();
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmconfig.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmconfig.c

Abstract:

    This module is responsible to build the hardware tree of the
    registry data base.

--*/

#include "cmp.h"

//
// Title Index - Never used for Product 1, set to 0 for now.
//

#define TITLE_INDEX_VALUE 0


extern ULONG CmpTypeCount[];


#define EISA_ADAPTER_INDEX EisaAdapter
#define TURBOCHANNEL_ADAPTER_INDEX TcAdapter

//
// The following variables are used to cross-reference multifunction
// adapters to their corresponding NT interface type.
//

extern struct {
    PUCHAR  AscString;
    USHORT  InterfaceType;
    USHORT  Count;
} CmpMultifunctionTypes[];

extern USHORT CmpUnknownBusCount;


//
// CmpConfigurationData - A pointer to the area reserved for the purpose
//     of reconstructing Configuration Data.
//
// CmpConfigurationAreaSize - Record the size of the Configuration Data
//     area.

extern ULONG CmpConfigurationAreaSize;
extern PCM_FULL_RESOURCE_DESCRIPTOR CmpConfigurationData;

//
// Function prototypes for internal references
//

NTSTATUS
CmpSetupConfigurationTree(
     IN PCONFIGURATION_COMPONENT_DATA CurrentEntry,
     IN HANDLE ParentHandle,
     IN INTERFACE_TYPE InterfaceType,
     IN ULONG BusNumber
     );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,CmpInitializeHardwareConfiguration)
#pragma alloc_text(INIT,CmpSetupConfigurationTree)
#pragma alloc_text(INIT,CmpInitializeRegistryNode)
#endif


NTSTATUS
CmpInitializeHardwareConfiguration(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This routine creates \\Registry\Machine\Hardware node in
    the registry and calls SetupTree routine to put the hardware
    information to the registry.

Arguments:

    LoaderBlock - supplies a pointer to the LoaderBlock passed in from the
                  OS Loader.

Returns:

    NTSTATUS code for success or reason of failure.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE BaseHandle;
    PCONFIGURATION_COMPONENT_DATA ConfigurationRoot;
    ULONG Disposition;

    ConfigurationRoot = (PCONFIGURATION_COMPONENT_DATA)LoaderBlock->ConfigurationRoot;

    //
    // Create \\Registry\Machine\Hardware\DeviceMap
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &CmRegistryMachineHardwareDeviceMapName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    Status = NtCreateKey(                   // Paht may already exist
                &BaseHandle,
                KEY_READ | KEY_WRITE,
                &ObjectAttributes,
                TITLE_INDEX_VALUE,
                NULL,
                0,
                &Disposition
                );

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    NtClose(BaseHandle);

    ASSERT(Disposition == REG_CREATED_NEW_KEY);

    //
    // Create \\Registry\Machine\Hardware\Description and use the
    // returned handle as the BaseHandle to build the hardware tree.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &CmRegistryMachineHardwareDescriptionName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    Status = NtCreateKey(                   // Path may already exist
                &BaseHandle,
                KEY_READ | KEY_WRITE,
                &ObjectAttributes,
                TITLE_INDEX_VALUE,
                NULL,
                0,
                &Disposition
                );

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    ASSERT(Disposition == REG_CREATED_NEW_KEY);

    //
    // Allocate 16K bytes memory from paged pool for constructing
    // configuration data for controller component.
    // NOTE:  The configuration Data for controller component
    //    usually takes less than 100 bytes.  But on EISA machine, the
    //    EISA configuration information takes more than 10K and up to
    //    64K.  I believe 16K is the reasonable number to handler 99.9%
    //    of the machines.  Therefore, 16K is the initial value.
    //

    CmpConfigurationData = (PCM_FULL_RESOURCE_DESCRIPTOR)ExAllocatePool(
                                        PagedPool,
                                        CmpConfigurationAreaSize
                                        );

    if (CmpConfigurationData == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Call SetupConfigurationTree routine to go over each component
    // of the tree and add component information to registry database.
    //

    if (ConfigurationRoot) {
        Status = CmpSetupConfigurationTree(ConfigurationRoot,
                                           BaseHandle,
                                           -1,
                                           (ULONG)-1);
    } else {
        Status = STATUS_SUCCESS;
    }

    ExFreePool((PVOID)CmpConfigurationData);
    NtClose(BaseHandle);
    return(Status);
}

NTSTATUS
CmpSetupConfigurationTree(
     IN PCONFIGURATION_COMPONENT_DATA CurrentEntry,
     IN HANDLE ParentHandle,
     IN INTERFACE_TYPE InterfaceType,
     IN ULONG BusNumber
     )
/*++

Routine Description:

    This routine traverses loader configuration tree and register
    the hardware information to the registry data base.

    Note to reduce the stack usage on machines with large number of PCI buses,
    we do not recursively process the sibling nodes.  We only recursively
    process the child trees.

Arguments:

    CurrentEntry - Supplies a pointer to a loader configuration
        tree or subtree.

    ParentHandle - Supplies the parent handle of CurrentEntry node.

    InterfaceType - Specify the Interface type of the bus that the
        CurrentEntry component resides.

    BusNumber - Specify the Bus Number of the bus that the CurrentEntry
        component resides.  If Bus number is -1, it means InterfaceType
        and BusNumber are meaningless for this component.

Returns:

    None.

--*/
{
    NTSTATUS Status;
    HANDLE NewHandle;
    USHORT i;
    CONFIGURATION_COMPONENT *Component;
    INTERFACE_TYPE LocalInterfaceType = InterfaceType;
    ULONG LocalBusNumber = BusNumber;
    USHORT DeviceIndexTable[NUMBER_TYPES];

    for (i = 0; i < NUMBER_TYPES; i++) {
        DeviceIndexTable[i] = 0;
    }

    //
    // Process current entry and its siblings
    //

    while (CurrentEntry) {

        //
        // Register current entry first before going down to its children
        //

        Component = &CurrentEntry->ComponentEntry;

        //
        // If the current component is a bus component, we will set up
        // its bus number and Interface type and use them to initialize
        // its subtree.
        //

        if (Component->Class == AdapterClass &&
            CurrentEntry->Parent->ComponentEntry.Class == SystemClass) {

            switch (Component->Type) {

            case EisaAdapter:
                LocalInterfaceType = Eisa;
                LocalBusNumber = CmpTypeCount[EISA_ADAPTER_INDEX]++;
                break;
            case TcAdapter:
                LocalInterfaceType = TurboChannel;
                LocalBusNumber = CmpTypeCount[TURBOCHANNEL_ADAPTER_INDEX]++;
                break;
            case MultiFunctionAdapter:

                //
                // Here we try to distinguish if the Multifunction adapter is
                // Isa, Mca, Internal bus and assign BusNumber based on
                // its interface type (bus type.)
                //

                if (Component->Identifier) {
                    for (i=0; CmpMultifunctionTypes[i].AscString; i++) {
                        if (_stricmp((PCHAR)CmpMultifunctionTypes[i].AscString,
                                    Component->Identifier) == 0) {
                                        break;
                        }
                    }

                    LocalInterfaceType = CmpMultifunctionTypes[i].InterfaceType;
                    LocalBusNumber = CmpMultifunctionTypes[i].Count++;
                }
                break;

            case ScsiAdapter:

                //
                // Set the bus type to internal.
                //

                LocalInterfaceType = Internal;
                LocalBusNumber = CmpTypeCount[ScsiAdapter]++;
                break;

            default:
                LocalInterfaceType = -1;
                LocalBusNumber = CmpUnknownBusCount++;
                break;
            }
        }

        //
        // Initialize and copy current component to hardware registry
        //

        Status = CmpInitializeRegistryNode(
                     CurrentEntry,
                     ParentHandle,
                     &NewHandle,
                     LocalInterfaceType,
                     LocalBusNumber,
                     DeviceIndexTable
                     );

        if (!NT_SUCCESS(Status)) {
            return(Status);
        }

        //
        // Once we are going one level down, we need to clear the TypeCount
        // table for everything under the current component class ...
        //

        if (CurrentEntry->Child) {

            //
            // Process the child entry of current entry
            //

            Status = CmpSetupConfigurationTree(CurrentEntry->Child,
                                               NewHandle,
                                               LocalInterfaceType,
                                               LocalBusNumber
                                               );
            if (!NT_SUCCESS(Status)) {
                NtClose(NewHandle);
                return(Status);
            }
        }
        NtClose(NewHandle);
        CurrentEntry = CurrentEntry->Sibling;
    }
    return(STATUS_SUCCESS);
}


NTSTATUS
CmpInitializeRegistryNode(
    IN PCONFIGURATION_COMPONENT_DATA CurrentEntry,
    IN HANDLE ParentHandle,
    OUT PHANDLE NewHandle,
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber,
    IN PUSHORT DeviceIndexTable
    )

/*++

Routine Description:

    This routine creates a node for the current firmware component
    and puts component data to the data part of the node.

Arguments:

    CurrentEntry - Supplies a pointer to a configuration component.

    Handle - Supplies the parent handle of CurrentEntry node.

    NewHandle - Supplies a pointer to a HANDLE to receive the handle of
        the newly created node.

    InterfaceType - Specify the Interface type of the bus that the
        CurrentEntry component resides. (See BusNumber also)

    BusNumber - Specify the Bus Number of the bus that the CurrentEntry
        component resides on.  If Bus number is -1, it means InterfaceType
        and BusNumber are meaningless for this component.

Returns:

    None.

--*/
{

    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    UNICODE_STRING ValueData;
    HANDLE Handle;
    HANDLE OldHandle;
    ANSI_STRING AnsiString;
    CHAR Buffer[12];
    WCHAR UnicodeBuffer[12];
    CONFIGURATION_COMPONENT *Component;
    ULONG Disposition;
    ULONG ConfigurationDataLength = 0;
    PCM_FULL_RESOURCE_DESCRIPTOR NewArea;

    Component = &CurrentEntry->ComponentEntry;

    //
    // If the component class is SystemClass, we set its Type to be
    // ArcSystem.  The reason is because the detection code sets
    // its type to MaximumType to indicate it is NOT ARC compatible.
    // Here, we are only interested in building a System Node.  So we
    // change its Type to ArcSystem to ease the setup.
    //

    if (Component->Class == SystemClass) {
        Component->Type = ArcSystem;
    }

    //
    // Create a new key to describe the Component.
    //
    // The type of the component will be used as the keyname of the
    // registry node.  The class is the class of the component.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &(CmTypeName[Component->Type]),
        0,
        ParentHandle,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    Status = NtCreateKey(                   // Paht may already exist
                &Handle,
                KEY_READ | KEY_WRITE,
                &ObjectAttributes,
                0,
                NULL,
                0,
                &Disposition
                );

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // If this component is NOT a SystemClass component, we will
    // create a subkey to identify the component's ordering.
    //

    if (Component->Class != SystemClass) {

        RtlIntegerToChar(
            DeviceIndexTable[Component->Type]++,
            10,
            12,
            Buffer
            );

        RtlInitAnsiString(
            &AnsiString,
            Buffer
            );

        KeyName.Buffer = (PWSTR)UnicodeBuffer;
        KeyName.Length = 0;
        KeyName.MaximumLength = sizeof(UnicodeBuffer);

        RtlAnsiStringToUnicodeString(
            &KeyName,
            &AnsiString,
            FALSE
            );

        OldHandle = Handle;

        InitializeObjectAttributes(
            &ObjectAttributes,
            &KeyName,
            0,
            OldHandle,
            NULL
            );
        ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

        Status = NtCreateKey(
                    &Handle,
                    KEY_READ | KEY_WRITE,
                    &ObjectAttributes,
                    0,
                    NULL,
                    0,
                    &Disposition
                    );

        NtClose(OldHandle);

        if (!NT_SUCCESS(Status)) {
            return(Status);
        }

        ASSERT(Disposition == REG_CREATED_NEW_KEY);
    }

    //
    // Create a value which describes the following component information:
    //     Flags, Cersion, Key, AffinityMask.
    //

    RtlInitUnicodeString(
        &ValueName,
        L"Component Information"
        );

    Status = NtSetValueKey(
                Handle,
                &ValueName,
                TITLE_INDEX_VALUE,
                REG_BINARY,
                &Component->Flags,
                FIELD_OFFSET(CONFIGURATION_COMPONENT, ConfigurationDataLength) -
                    FIELD_OFFSET(CONFIGURATION_COMPONENT, Flags)
                );

    if (!NT_SUCCESS(Status)) {
        NtClose(Handle);
        return(Status);
    }

    //
    // Create a value which describes the component identifier, if any.
    //

    if (Component->IdentifierLength) {

        RtlInitUnicodeString(
            &ValueName,
            L"Identifier"
            );

        RtlInitAnsiString(
            &AnsiString,
            Component->Identifier
            );

        Status = RtlAnsiStringToUnicodeString(
                    &ValueData,
                    &AnsiString,
                    TRUE
                    );

        if( NT_SUCCESS(Status) ) {
            Status = NtSetValueKey(
                        Handle,
                        &ValueName,
                        TITLE_INDEX_VALUE,
                        REG_SZ,
                        ValueData.Buffer,
                        ValueData.Length + sizeof( UNICODE_NULL )
                        );

            RtlFreeUnicodeString(&ValueData);
        }

        if (!NT_SUCCESS(Status)) {
            NtClose(Handle);
            return(Status);
        }
    }

    //
    // Create a value entry for component configuration data.
    //

    RtlInitUnicodeString(
        &ValueName,
        L"Configuration Data"
        );

    //
    // Create the configuration data based on CM_FULL_RESOURCE_DESCRIPTOR.
    //
    // Note the configuration data in firmware tree may be in the form of
    // CM_PARTIAL_RESOURCE_LIST or nothing.  In both cases, we need to
    // set up the registry configuration data to be in the form of
    // CM_FULL_RESOURCE_DESCRIPTOR.
    //

    if (CurrentEntry->ConfigurationData) {

        //
        // This component has configuration data, we copy the data
        // to our work area, add some more data items and copy the new
        // configuration data to the registry.
        //

        ConfigurationDataLength = Component->ConfigurationDataLength +
                      FIELD_OFFSET(CM_FULL_RESOURCE_DESCRIPTOR,
                      PartialResourceList);

        //
        // Make sure our reserved area is big enough to hold the data.
        //

        if (ConfigurationDataLength > CmpConfigurationAreaSize) {

            //
            // If reserved area is not big enough, we resize our reserved
            // area.  If, unfortunately, the reallocation fails, we simply
            // loss the configuration data of this particular component.
            //

            NewArea = (PCM_FULL_RESOURCE_DESCRIPTOR)ExAllocatePool(
                                            PagedPool,
                                            ConfigurationDataLength
                                            );

            if (NewArea) {
                CmpConfigurationAreaSize = ConfigurationDataLength;
                ExFreePool(CmpConfigurationData);
                CmpConfigurationData = NewArea;
                RtlCopyMemory(
                    (PUCHAR)&CmpConfigurationData->PartialResourceList.Version,
                    CurrentEntry->ConfigurationData,
                    Component->ConfigurationDataLength
                    );
            } else {
                Component->ConfigurationDataLength = 0;
                CurrentEntry->ConfigurationData = NULL;
            }
        } else {
            RtlCopyMemory(
                (PUCHAR)&CmpConfigurationData->PartialResourceList.Version,
                CurrentEntry->ConfigurationData,
                Component->ConfigurationDataLength
                );
        }

    }

    if (CurrentEntry->ConfigurationData == NULL) {

        //
        // This component has NO configuration data (or we can't resize
        // our reserved area to hold the data), we simple add whatever
        // is required to set up a CM_FULL_RESOURCE_LIST.
        //

        CmpConfigurationData->PartialResourceList.Version = 0;
        CmpConfigurationData->PartialResourceList.Revision = 0;
        CmpConfigurationData->PartialResourceList.Count = 0;
        ConfigurationDataLength = FIELD_OFFSET(CM_FULL_RESOURCE_DESCRIPTOR,
                                               PartialResourceList) +
                                  FIELD_OFFSET(CM_PARTIAL_RESOURCE_LIST,
                                               PartialDescriptors);
    }

    //
    // Set up InterfaceType and BusNumber for the component.
    //

    CmpConfigurationData->InterfaceType = InterfaceType;
    CmpConfigurationData->BusNumber = BusNumber;

    //
    // Write the newly constructed configuration data to the hardware registry
    //

    Status = NtSetValueKey(
                Handle,
                &ValueName,
                TITLE_INDEX_VALUE,
                REG_FULL_RESOURCE_DESCRIPTOR,
                CmpConfigurationData,
                ConfigurationDataLength
                );

    if (!NT_SUCCESS(Status)) {
        NtClose(Handle);
        return(Status);
    }

    *NewHandle = Handle;
    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmapi2.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmapi2.c

Abstract:

    This module contains CM level entry points for the registry,
    particularly those which we don't want to link into tools,
    setup, the boot loader, etc.

--*/

#include "cmp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmDeleteKey)
#endif


NTSTATUS
CmDeleteKey(
    IN PCM_KEY_BODY KeyBody
    )
/*++

Routine Description:

    Delete a registry key, clean up Notify block.

Arguments:

    KeyBody - pointer to key handle object

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status;
    PCM_KEY_NODE            ptarget;
    PHHIVE                  Hive;
    HCELL_INDEX             Cell;
    HCELL_INDEX             Parent;
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock;
    LARGE_INTEGER           TimeStamp;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_CM,"CmDeleteKey\n"));

    CmpLockRegistry();

    //
    // If already marked for deletion, storage is gone, so
    // do nothing and return success.
    //
    KeyControlBlock = KeyBody->KeyControlBlock;

    if( KeyControlBlock->ParentKcb == NULL ) {
        //
        // cannot delete \Registry
        //
        CmpUnlockRegistry();
        return STATUS_CANNOT_DELETE;
    }

    PERFINFO_REG_DELETE_KEY(KeyControlBlock);
    //
    // serialize access to this key. and its parent
    // need to lock them both atomically
    // 
    CmpLockTwoHashEntriesExclusive(KeyControlBlock->ConvKey,KeyControlBlock->ParentKcb->ConvKey);

    if (KeyControlBlock->Delete == TRUE) {
        status = STATUS_SUCCESS;
        goto Exit;
    }
    Hive = KeyControlBlock->KeyHive;
    Cell = KeyControlBlock->KeyCell;
    // 
    // no flush from this point on
    //
    CmpLockHiveFlusherShared((PCMHIVE)KeyControlBlock->KeyHive);

    // Mark the hive as read only
    CmpMarkAllBinsReadOnly(KeyControlBlock->KeyHive);

    ptarget = (PCM_KEY_NODE)HvGetCell(KeyControlBlock->KeyHive, KeyControlBlock->KeyCell);
    if( ptarget == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit2;
    }

    ASSERT( ptarget->Flags == KeyControlBlock->Flags );

    if ( ((ptarget->SubKeyCounts[Stable] + ptarget->SubKeyCounts[Volatile]) == 0) &&
         ((ptarget->Flags & KEY_NO_DELETE) == 0))
    {
        //
        // Cell is NOT marked NO_DELETE and does NOT have children
        // Send Notification while key still present, if delete fails,
        //   we'll have sent a spurious notify, that doesn't matter
        // Delete the actual storage
        //
        Parent = ptarget->Parent;

        CmpReportNotify(
            KeyControlBlock,
            Hive,
            Cell,
            REG_NOTIFY_CHANGE_NAME
            );

        status = CmpFreeKeyByCell(Hive, Cell, TRUE);

        if (NT_SUCCESS(status)) {
            //
            // post any waiting notifies
            //
            CmpFlushNotifiesOnKeyBodyList(KeyControlBlock,FALSE);

            //
            // Remove kcb out of cache, but do NOT
            // free its storage, CmDelete will do that when
            // the RefCount becomes zero.
            //
            // There are two things that can hold the RefCount non-zero.
            //
            // 1. open handles for this key
            // 2. Fake subKeys that are still in DelayClose.
            //
            // At this point, we have no way of deleting the fake subkeys from cache
            // unless we do a search for the whole cache, which is too expensive.
            // Thus, we decide to either let the fake keys age out of cache or when 
            // someone is doing the lookup for the fake key, then we delete it at that point.
            // See routine CmpCacheLookup in cmparse.c for more details.
            //
            // If the parent has the subkey info or hint cached, free it.
            // Again, registry is locked exclusively, no need to lock KCB.
            //
            CmpCleanUpSubKeyInfo(KeyControlBlock->ParentKcb);
            ptarget = (PCM_KEY_NODE)HvGetCell(Hive, Parent);
            if( ptarget != NULL ) {

                //
                // this should always be true as CmpFreeKeyByCell always marks the parent dirty on success
                //
                KeyControlBlock->ParentKcb->KcbMaxNameLen = (USHORT)ptarget->MaxNameLen;
                // sanity
                ASSERT_CELL_DIRTY(Hive,Parent);
                //
                // update the LastWriteTime on parent and kcb too
                //
                KeQuerySystemTime(&TimeStamp);
                ptarget->LastWriteTime = TimeStamp;
                KeyBody->KeyControlBlock->ParentKcb->KcbLastWriteTime = TimeStamp;
                HvReleaseCell(Hive, Parent);
            }

            KeyControlBlock->Delete = TRUE;
            CmpRemoveKeyControlBlock(KeyControlBlock);
            KeyControlBlock->KeyCell = HCELL_NIL;
        }

    } else {

        status = STATUS_CANNOT_DELETE;

    }

Exit2:
    HvReleaseCell(Hive, Cell);
    CmpUnlockHiveFlusher((PCMHIVE)KeyControlBlock->KeyHive);

Exit:
    CmpUnlockTwoHashEntries(KeyControlBlock->ConvKey,KeyControlBlock->ParentKcb->ConvKey);

    CmpUnlockRegistry();

    // Mark the hive as read only
    CmpMarkAllBinsReadOnly(KeyControlBlock->KeyHive);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmcontrl.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmcontrl.c

Abstract:

    The module contains CmGetSystemControlValues, see cmdat.c for data.

--*/

#include    "cmp.h"

extern WCHAR   CmDefaultLanguageId[];
extern ULONG   CmDefaultLanguageIdLength;
extern ULONG   CmDefaultLanguageIdType;

extern WCHAR   CmInstallUILanguageId[];
extern ULONG   CmInstallUILanguageIdLength;
extern ULONG   CmInstallUILanguageIdType;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INITDATA")
#endif
CMHIVE CmControlHive;
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

HCELL_INDEX
CmpWalkPath(
    PHHIVE      SystemHive,
    HCELL_INDEX ParentCell,
    PWSTR       Path
    );

LANGID
CmpConvertLangId(
    PWSTR LangIdString,
    ULONG LangIdStringLength
);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,CmGetSystemControlValues)
#pragma alloc_text(INIT,CmpWalkPath)
#pragma alloc_text(INIT,CmpConvertLangId)
#endif

VOID
CmGetSystemControlValues(
    __in PVOID                   SystemHiveBuffer,
    __inout PCM_SYSTEM_CONTROL_VECTOR  ControlVector
    )
/*++

Routine Description:

    Look for registry values in current control set, as specified
    by entries in ControlVector.  Report data for value entries
    (if any) to variables ControlVector points to.

Arguments:

    SystemHiveBuffer - pointer to flat image of the system hive

    ControlVector - pointer to structure that describes what values
                    to pull out and store

Return Value:

    NONE.

--*/
{
    NTSTATUS        status;
    PHHIVE          SystemHive;
    HCELL_INDEX     RootCell;
    HCELL_INDEX     BaseCell;
    UNICODE_STRING  Name;
    HCELL_INDEX     KeyCell;
    HCELL_INDEX     ValueCell;
    PCM_KEY_VALUE   ValueBody;
    ULONG           Length;
    BOOLEAN         AutoSelect;
    BOOLEAN         small;
    ULONG           tmplength;
    PCM_KEY_NODE    Node;

    //
    // set up to read flat system hive image loader passes us
    //
    RtlZeroMemory((PVOID)&CmControlHive, sizeof(CmControlHive));
    SystemHive = &(CmControlHive.Hive);
    CmpInitHiveViewList((PCMHIVE)SystemHive);
    CmpInitSecurityCache((PCMHIVE)SystemHive);
    status = HvInitializeHive(
                SystemHive,
                HINIT_FLAT,
                HIVE_VOLATILE,
                HFILE_TYPE_PRIMARY,
                SystemHiveBuffer,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                1,
                NULL
                );
    if (!NT_SUCCESS(status)) {
         CM_BUGCHECK(BAD_SYSTEM_CONFIG_INFO,BAD_SYSTEM_CONTROL_VALUES,1,SystemHive,status);
    }

    //
    // don't bother locking/releasing cells
    //
    ASSERT( SystemHive->ReleaseCellRoutine == NULL );
    //
    // get hive.cell of root of current control set
    //
    RootCell = ((PHBASE_BLOCK)SystemHiveBuffer)->RootCell;
    RtlInitUnicodeString(&Name, L"current");
    BaseCell = CmpFindControlSet(
                    SystemHive,
                    RootCell,
                    &Name,
                    &AutoSelect
                    );
    if (BaseCell == HCELL_NIL) {
        CM_BUGCHECK(BAD_SYSTEM_CONFIG_INFO,BAD_SYSTEM_CONTROL_VALUES,2,SystemHive,&Name);
    }

    Node = (PCM_KEY_NODE)HvGetCell(SystemHive,BaseCell);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //
        return;
    }
    RtlInitUnicodeString(&Name, L"control");
    BaseCell = CmpFindSubKeyByName(SystemHive,
                                   Node,
                                   &Name);
    if (BaseCell == HCELL_NIL) {
        CM_BUGCHECK(BAD_SYSTEM_CONFIG_INFO,BAD_SYSTEM_CONTROL_VALUES,3,Node,&Name);
    }

    //
    // SystemHive.BaseCell = \registry\machine\system\currentcontrolset\control
    //

    //
    // step through vector, trying to fetch each value
    //
    while (ControlVector->KeyPath != NULL) {

        //
        //  Assume we will fail to find the key or value.
        //
        
        Length = (ULONG)-1;

        KeyCell = CmpWalkPath(SystemHive, BaseCell, ControlVector->KeyPath);

        if (KeyCell != HCELL_NIL) {

            //
            // found the key, look for the value entry
            //
            Node = (PCM_KEY_NODE)HvGetCell(SystemHive,KeyCell);
            if( Node == NULL ) {
                //
                // we couldn't map a view for the bin containing this cell
                //
                return;
            }
            RtlInitUnicodeString(&Name, ControlVector->ValueName);
            ValueCell = CmpFindValueByName(SystemHive,
                                           Node,
                                           &Name);
            if (ValueCell != HCELL_NIL) {

                //
                // SystemHive.ValueCell is value entry body
                //

                if (ControlVector->BufferLength == NULL) {
                    tmplength = sizeof(ULONG);
                } else {
                    tmplength = *(ControlVector->BufferLength);
                }

                ValueBody = (PCM_KEY_VALUE)HvGetCell(SystemHive, ValueCell);
                if( ValueBody == NULL ) {
                    //
                    // we couldn't map a view for the bin containing this cell
                    //
                    return;
                }

                small = CmpIsHKeyValueSmall(Length, ValueBody->DataLength);

                if (tmplength < Length) {
                    Length = tmplength;
                }

                if (Length > 0) {

                    PCELL_DATA  Buffer;
                    BOOLEAN     BufferAllocated;
                    ULONG       realsize;
                    HCELL_INDEX CellToRelease;

                    ASSERT((small ? (Length <= CM_KEY_VALUE_SMALL) : TRUE));
                    //
                    // get the data from source, regardless of the size
                    //
                    if( CmpGetValueData(SystemHive,ValueBody,&realsize,&Buffer,&BufferAllocated,&CellToRelease) == FALSE ) {
                        //
                        // insufficient resources; return NULL
                        //
                        ASSERT( BufferAllocated == FALSE );
                        ASSERT( Buffer == NULL );
                        return;
                    }

                    RtlCopyMemory(
                        ControlVector->Buffer,
                        Buffer,
                        Length
                        );

                    //
                    // cleanup the temporary buffer
                    //
                    if( BufferAllocated == TRUE ) {
                        ExFreePool( Buffer );
                    }
                    if( CellToRelease != HCELL_NIL ) {
                        HvReleaseCell(SystemHive,CellToRelease);
                    }
                }

                if (ControlVector->Type != NULL) {
                    *(ControlVector->Type) = ValueBody->Type;
                }
            }
        }

        //
        // Stash the length of result (-1 if nothing was found)
        //
        
        if (ControlVector->BufferLength != NULL) {
            *(ControlVector->BufferLength) = Length;
        }

        ControlVector++;
    }

    //
    // Get the default locale ID for the system from the registry.
    //

    if (CmDefaultLanguageIdType == REG_SZ) {
        PsDefaultSystemLocaleId = (LCID) CmpConvertLangId( 
                                                CmDefaultLanguageId,
                                                CmDefaultLanguageIdLength);
    } else {
        PsDefaultSystemLocaleId = 0x00000409;
    }

    //
    // Get the install (native UI) language ID for the system from the registry.
    //

    if (CmInstallUILanguageIdType == REG_SZ) {
        PsInstallUILanguageId =  CmpConvertLangId( 
                                                CmInstallUILanguageId,
                                                CmInstallUILanguageIdLength);
    } else {
        PsInstallUILanguageId = LANGIDFROMLCID(PsDefaultSystemLocaleId);
    }

    //
    // Set the default thread locale to the default system locale
    // for now.  This will get changed as soon as somebody logs in.
    // Use the install (native) language id as our default UI language id. 
    // This also will get changed as soon as somebody logs in.
    //

    PsDefaultThreadLocaleId = PsDefaultSystemLocaleId;
    PsDefaultUILanguageId = PsInstallUILanguageId;
}


HCELL_INDEX
CmpWalkPath(
    PHHIVE      SystemHive,
    HCELL_INDEX ParentCell,
    PWSTR       Path
    )
/*++

Routine Description:

    Walk the path.

Arguments:

    SystemHive - hive

    ParentCell - where to start

    Path - string to walk

Return Value:

    HCELL_INDEX of found key cell, or HCELL_NIL for error

--*/
{
    UNICODE_STRING  PathString;
    UNICODE_STRING  NextName;
    BOOLEAN         Last;
    HCELL_INDEX     KeyCell;
    PCM_KEY_NODE    Node;

    //
    // don't bother counting/releasing used cells
    //
    ASSERT( SystemHive->ReleaseCellRoutine == NULL );

    KeyCell = ParentCell;
    RtlInitUnicodeString(&PathString, Path);

    while (TRUE) {

        CmpGetNextName(&PathString, &NextName, &Last);

        if (NextName.Length == 0) {
            return KeyCell;
        }

        Node = (PCM_KEY_NODE)HvGetCell(SystemHive,KeyCell);
        if( Node == NULL ) {
            //
            // we couldn't map a view for the bin containing this cell
            //
            return HCELL_NIL;
        }
        KeyCell = CmpFindSubKeyByName(SystemHive,
                                      Node,
                                      &NextName);

        if (KeyCell == HCELL_NIL) {
            return HCELL_NIL;
        }
    }
}

LANGID
CmpConvertLangId(
    PWSTR LangIdString,
    ULONG LangIdStringLength
)
{


    USHORT i, Digit;
    WCHAR c;
    LANGID LangId;

    LangId = 0;
    LangIdStringLength = LangIdStringLength / sizeof( WCHAR );
    for (i=0; i < LangIdStringLength; i++) {
        c = LangIdString[ i ];

        if (c >= L'0' && c <= L'9') {
            Digit = c - L'0';

        } else if (c >= L'A' && c <= L'F') {
            Digit = c - L'A' + 10;

        } else if (c >= L'a' && c <= L'f') {
            Digit = c - L'a' + 10;

        } else {
            break;
        }

        if (Digit >= 16) {
            break;
        }

        LangId = (LangId << 4) | Digit;
    }

    return LangId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmchek2.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmchek2.c

Abstract:

    This module implements consistency checking for the registry.

--*/

#include    "cmp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpValidateHiveSecurityDescriptors)
#endif

extern ULONG   CmpUsedStorage;

BOOLEAN
CmpValidateHiveSecurityDescriptors(
    IN PHHIVE       Hive,
    OUT PBOOLEAN    ResetSD
    )
/*++

Routine Description:

    Walks the list of security descriptors present in the hive and passes
    each security descriptor to RtlValidSecurityDescriptor.

    Only applies to descriptors in Stable store.  Those in Volatile store
    cannot have come from disk and therefore do not need this treatment
    anyway.

Arguments:

    Hive - Supplies pointer to the hive control structure

Return Value:

    TRUE  - All security descriptors are valid
    FALSE - At least one security descriptor is invalid

--*/

{
    PCM_KEY_NODE        RootNode;
    PCM_KEY_SECURITY    SecurityCell;
    HCELL_INDEX         ListAnchor;
    HCELL_INDEX         NextCell;
    HCELL_INDEX         LastCell;
    BOOLEAN             BuildSecurityCache;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpValidateHiveSecurityDescriptor: Hive = %p\n",(ULONG_PTR)Hive));

    ASSERT( Hive->ReleaseCellRoutine == NULL );

    *ResetSD = FALSE;

    if( ((PCMHIVE)Hive)->SecurityCount == 0 ) {
        BuildSecurityCache = TRUE;
    } else {
        BuildSecurityCache = FALSE;
    }
    if (!HvIsCellAllocated(Hive,Hive->BaseBlock->RootCell)) {
        //
        // root cell HCELL_INDEX is bogus
        //
        return(FALSE);
    }
    RootNode = (PCM_KEY_NODE) HvGetCell(Hive, Hive->BaseBlock->RootCell);
    if( RootNode == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //
        return FALSE;
    }
    
    if( FALSE ) {
YankSD:
        if( CmDoSelfHeal() ) {
            //
            // reset all security for the entire hive to the root security. There is no reliable way to 
            // patch the security list
            //
            if(!HvIsCellAllocated(Hive, RootNode->Security)) {
                return FALSE;
            }
            SecurityCell = (PCM_KEY_SECURITY) HvGetCell(Hive, RootNode->Security);
            if( SecurityCell == NULL ) {
                return FALSE;
            }

            if( HvMarkCellDirty(Hive, RootNode->Security,FALSE) ) {
                SecurityCell->Flink = SecurityCell->Blink = RootNode->Security;
            } else {
                return FALSE;
            }
            //
            // destroy existing cache and set up an empty one
            //
            CmpDestroySecurityCache((PCMHIVE)Hive);
            CmpInitSecurityCache((PCMHIVE)Hive);
            CmMarkSelfHeal(Hive);
            *ResetSD = TRUE;
        } else {
            return FALSE;
        }

    }

    LastCell = 0;
    ListAnchor = NextCell = RootNode->Security;

    do {
        if (!HvIsCellAllocated(Hive, NextCell)) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CM: CmpValidateHiveSecurityDescriptors\n"));
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"    NextCell: %08lx is invalid HCELL_INDEX\n",NextCell));
            goto YankSD;
        }
        SecurityCell = (PCM_KEY_SECURITY) HvGetCell(Hive, NextCell);
        if( SecurityCell == NULL ) {
            //
            // we couldn't map a view for the bin containing this cell
            //
            return FALSE;
        }

        if (NextCell != ListAnchor) {
            //
            // Check to make sure that our Blink points to where we just
            // came from.
            //
            if (SecurityCell->Blink != LastCell) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"  Invalid Blink (%08lx) on security cell %08lx\n",SecurityCell->Blink, NextCell));
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"  should point to %08lx\n", LastCell));
                return(FALSE);
            }
        }

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpValidSD:  SD shared by %d nodes\n",SecurityCell->ReferenceCount));
        if (!SeValidSecurityDescriptor(SecurityCell->DescriptorLength, &SecurityCell->Descriptor)) {
#if DBG
            CmpDumpSecurityDescriptor(&SecurityCell->Descriptor,"INVALID DESCRIPTOR");
#endif
            goto YankSD;
        }
        //
        // cache this security cell; now that we know it is valid
        //
        if( BuildSecurityCache == TRUE ) {
            if( !NT_SUCCESS(CmpAddSecurityCellToCache ( (PCMHIVE)Hive,NextCell,TRUE,NULL) ) ) {
                return FALSE;
            }
        } else {
            //
            // just check this cell is there
            //
            ULONG Index;
            if( CmpFindSecurityCellCacheIndex ((PCMHIVE)Hive,NextCell,&Index) == FALSE ) {
                //
                // bad things happened; maybe an error in our caching code?
                //
                return FALSE;
            }

        }

        LastCell = NextCell;
        NextCell = SecurityCell->Flink;
    } while ( NextCell != ListAnchor );

    if( BuildSecurityCache == TRUE ) {
        //
        // adjust the size of the cache in case we allocated too much
        //
        CmpAdjustSecurityCacheSize ( (PCMHIVE)Hive );
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmdat2.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmdat2.c

Abstract:

    This module contains data strings that describes the registry space
    and that are exported to the rest of the system.

--*/

#include "cmp.h"

//
// ***** PAGE *****
//

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif

//
// control values/overrides read from registry
//
ULONG CmRegistrySizeLimit = { 0 };
ULONG CmRegistrySizeLimitLength = 4;
ULONG CmRegistrySizeLimitType = { 0 };

//
// Maximum number of bytes of Global Quota the registry may use.
// Set to largest positive number for use in boot.  Will be set down
// based on pool and explicit registry values.
//
SIZE_T  CmpGlobalQuotaAllowed = CM_WRAP_LIMIT;
SIZE_T  CmpGlobalQuota = CM_WRAP_LIMIT;
SIZE_T  CmpGlobalQuotaWarning = CM_WRAP_LIMIT;
BOOLEAN CmpQuotaWarningPopupDisplayed = FALSE;
BOOLEAN CmpSystemQuotaWarningPopupDisplayed = FALSE;

//
// the "disk full" popup has already been displayed
//
BOOLEAN CmpDiskFullWorkerPopupDisplayed = FALSE;
BOOLEAN CmpCannotWriteConfiguration = FALSE;

//
// GQ actually in use
//
SIZE_T  CmpGlobalQuotaUsed = 0;

//
// State flag to remember when to turn it on
//
BOOLEAN CmpProfileLoaded = FALSE;

PUCHAR CmpStashBuffer = NULL;
ULONG  CmpStashBufferSize = 0;
EX_PUSH_LOCK CmpStashBufferLock;

//
// Shutdown control
//
BOOLEAN HvShutdownComplete = FALSE;     // Set to true after shutdown
                                        // to disable any further I/O

PCM_KEY_CONTROL_BLOCK CmpKeyControlBlockRoot = NULL;

HANDLE CmpRegistryRootHandle = NULL;

struct {
    PHHIVE      Hive;
    ULONG       Status;
} CmCheckRegistryDebug = { 0 };

//
// The last I/O error status code
//
struct {
    ULONG       Action;
    HANDLE      Handle;
    NTSTATUS    Status;
} CmRegistryIODebug = { 0 };

//
// globals private to check code
//

struct {
    PHHIVE      Hive;
    ULONG       Status;
} CmpCheckRegistry2Debug = { 0 };

struct {
    PHHIVE      Hive;
    ULONG       Status;
    HCELL_INDEX Cell;
    PCELL_DATA  CellPoint;
    PVOID       RootPoint;
    ULONG       Index;
} CmpCheckKeyDebug = { 0 };

struct {
    PHHIVE      Hive;
    ULONG       Status;
    PCELL_DATA  List;
    ULONG       Index;
    HCELL_INDEX Cell;
    PCELL_DATA  CellPoint;
} CmpCheckValueListDebug = { 0 };

ULONG CmpUsedStorage = { 0 };

// hivechek.c
struct {
    PHHIVE      Hive;
    ULONG       Status;
    ULONG       Space;
    HCELL_INDEX MapPoint;
    PHBIN       BinPoint;
} HvCheckHiveDebug = { 0 };

struct {
    PHBIN       Bin;
    ULONG       Status;
    PHCELL      CellPoint;
} HvCheckBinDebug = { 0 };

struct {
    PHHIVE      Hive;
    ULONG       FileOffset;
    ULONG       FailPoint; // look in HvpRecoverData for exact point of failure
} HvRecoverDataDebug = { 0 };

//
// when a local hive cannot be loaded, set this to it's index
// and the load hive worker thread responsible for it will be held of 
// until all the others finish; We can then debug the offending hive
//
ULONG   CmpCheckHiveIndex = CM_NUMBER_OF_MACHINE_HIVES;

#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmdatini.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

   cmdatini.c

Abstract:

   contains code to init static STRING structures for registry name space.

--*/

#include "cmp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,CmpInitializeRegistryNames)
#endif

extern UNICODE_STRING CmRegistryRootName;
extern UNICODE_STRING CmRegistryMachineName;
extern UNICODE_STRING CmRegistryMachineHardwareName;
extern UNICODE_STRING CmRegistryMachineHardwareDescriptionName;
extern UNICODE_STRING CmRegistryMachineHardwareDescriptionSystemName;
extern UNICODE_STRING CmRegistryMachineHardwareDeviceMapName;
extern UNICODE_STRING CmRegistryMachineHardwareResourceMapName;
extern UNICODE_STRING CmRegistryMachineHardwareOwnerMapName;
extern UNICODE_STRING CmRegistryMachineSystemName;
extern UNICODE_STRING CmRegistryMachineSystemCurrentControlSet;
extern UNICODE_STRING CmRegistryUserName;
extern UNICODE_STRING CmRegistrySystemCloneName;
extern UNICODE_STRING CmpSystemFileName;
extern UNICODE_STRING CmRegistryMachineSystemCurrentControlSetEnumName;
extern UNICODE_STRING CmRegistryMachineSystemCurrentControlSetEnumRootName;
extern UNICODE_STRING CmRegistryMachineSystemCurrentControlSetServices;
extern UNICODE_STRING CmRegistryMachineSystemCurrentControlSetHardwareProfilesCurrent;
extern UNICODE_STRING CmRegistryMachineSystemCurrentControlSetControlClass;
extern UNICODE_STRING CmSymbolicLinkValueName;

#ifdef _WANT_MACHINE_IDENTIFICATION
extern UNICODE_STRING CmRegistryMachineSystemCurrentControlSetControlBiosInfo;
#endif

extern const PWCHAR CmpRegistryRootString;
extern const PWCHAR CmpRegistryMachineString;
extern const PWCHAR CmpRegistryMachineHardwareString;
extern const PWCHAR CmpRegistryMachineHardwareDescriptionString;
extern const PWCHAR CmpRegistryMachineHardwareDescriptionSystemString;
extern const PWCHAR CmpRegistryMachineHardwareDeviceMapString;
extern const PWCHAR CmpRegistryMachineHardwareResourceMapString;
extern const PWCHAR CmpRegistryMachineHardwareOwnerMapString;
extern const PWCHAR CmpRegistryMachineSystemString;
extern const PWCHAR CmpRegistryMachineSystemCurrentControlSetString;
extern const PWCHAR CmpRegistryUserString;
extern const PWCHAR CmpRegistrySystemCloneString;
extern const PWCHAR CmpRegistrySystemFileNameString;
extern const PWCHAR CmpRegistryMachineSystemCurrentControlSetEnumString;
extern const PWCHAR CmpRegistryMachineSystemCurrentControlSetEnumRootString;
extern const PWCHAR CmpRegistryMachineSystemCurrentControlSetServicesString;
extern const PWCHAR CmpRegistryMachineSystemCurrentControlSetHardwareProfilesCurrentString;
extern const PWCHAR CmpRegistryMachineSystemCurrentControlSetControlClassString;
extern const PWCHAR CmpRegistryMachineSystemCurrentControlSetControlSafeBootString;
extern const PWCHAR CmpRegistryMachineSystemCurrentControlSetControlSessionManagerMemoryManagementString;

extern const PWCHAR CmpRegistryMachineSystemCurrentControlSetControlBootLogString;
extern const PWCHAR CmpRegistryMachineSystemCurrentControlSetServicesEventLogString;
extern const PWCHAR CmpSymbolicLinkValueName;

#ifdef _WANT_MACHINE_IDENTIFICATION
extern const PWCHAR CmpRegistryMachineSystemCurrentControlSetControlBiosInfoString;
#endif


VOID
CmpInitializeRegistryNames(
VOID
)

/*++

Routine Description:

    This routine creates all the Unicode strings for the various names used
    in and by the registry

Arguments:

    None.

Returns:

    None.

--*/
{
    ULONG i;

    RtlInitUnicodeString( &CmRegistryRootName,
                          CmpRegistryRootString );

    RtlInitUnicodeString( &CmRegistryMachineName,
                          CmpRegistryMachineString );

    RtlInitUnicodeString( &CmRegistryMachineHardwareName,
                          CmpRegistryMachineHardwareString );

    RtlInitUnicodeString( &CmRegistryMachineHardwareDescriptionName,
                          CmpRegistryMachineHardwareDescriptionString );

    RtlInitUnicodeString( &CmRegistryMachineHardwareDescriptionSystemName,
                          CmpRegistryMachineHardwareDescriptionSystemString );

    RtlInitUnicodeString( &CmRegistryMachineHardwareDeviceMapName,
                          CmpRegistryMachineHardwareDeviceMapString );

    RtlInitUnicodeString( &CmRegistryMachineHardwareResourceMapName,
                          CmpRegistryMachineHardwareResourceMapString );

    RtlInitUnicodeString( &CmRegistryMachineHardwareOwnerMapName,
                          CmpRegistryMachineHardwareOwnerMapString );

    RtlInitUnicodeString( &CmRegistryMachineSystemName,
                          CmpRegistryMachineSystemString );

    RtlInitUnicodeString( &CmRegistryMachineSystemCurrentControlSet,
                          CmpRegistryMachineSystemCurrentControlSetString);

    RtlInitUnicodeString( &CmRegistryUserName,
                          CmpRegistryUserString );

    RtlInitUnicodeString( &CmRegistrySystemCloneName,
                          CmpRegistrySystemCloneString );

    RtlInitUnicodeString( &CmpSystemFileName,
                          CmpRegistrySystemFileNameString );

    RtlInitUnicodeString( &CmRegistryMachineSystemCurrentControlSetEnumName,
                          CmpRegistryMachineSystemCurrentControlSetEnumString);

    RtlInitUnicodeString( &CmRegistryMachineSystemCurrentControlSetEnumRootName,
                          CmpRegistryMachineSystemCurrentControlSetEnumRootString);

    RtlInitUnicodeString( &CmRegistryMachineSystemCurrentControlSetServices,
                          CmpRegistryMachineSystemCurrentControlSetServicesString);

    RtlInitUnicodeString( &CmRegistryMachineSystemCurrentControlSetHardwareProfilesCurrent,
                          CmpRegistryMachineSystemCurrentControlSetHardwareProfilesCurrentString);

    RtlInitUnicodeString( &CmRegistryMachineSystemCurrentControlSetControlClass,
                          CmpRegistryMachineSystemCurrentControlSetControlClassString);

    RtlInitUnicodeString( &CmRegistryMachineSystemCurrentControlSetControlSafeBoot,
                          CmpRegistryMachineSystemCurrentControlSetControlSafeBootString);

    RtlInitUnicodeString( &CmRegistryMachineSystemCurrentControlSetControlSessionManagerMemoryManagement,
                          CmpRegistryMachineSystemCurrentControlSetControlSessionManagerMemoryManagementString);

    RtlInitUnicodeString( &CmRegistryMachineSystemCurrentControlSetControlBootLog,
                          CmpRegistryMachineSystemCurrentControlSetControlBootLogString);

    RtlInitUnicodeString( &CmRegistryMachineSystemCurrentControlSetServicesEventLog,
                          CmpRegistryMachineSystemCurrentControlSetServicesEventLogString);

    RtlInitUnicodeString( &CmSymbolicLinkValueName,
                          CmpSymbolicLinkValueName);

#ifdef _WANT_MACHINE_IDENTIFICATION
    RtlInitUnicodeString( &CmRegistryMachineSystemCurrentControlSetControlBiosInfo,
                          CmpRegistryMachineSystemCurrentControlSetControlBiosInfoString);
#endif

    //
    // Initialize the type names for the hardware tree.
    //

    for (i = 0; i <= MaximumType; i++) {

        RtlInitUnicodeString( &(CmTypeName[i]),
                              CmTypeString[i] );

    }

    //
    // Initialize the class names for the hardware tree.
    //

    for (i = 0; i <= MaximumClass; i++) {

        RtlInitUnicodeString( &(CmClassName[i]),
                              CmClassString[i] );

    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmdelete.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmdelete.c

Abstract:

    This module contains the delete object method (used to delete key
    control blocks  when last handle to a key is closed, and to delete
    keys marked for deletetion when last reference to them goes away.)

--*/

#include    "cmp.h"

extern  BOOLEAN HvShutdownComplete;

VOID
CmpLateUnloadHiveWorker(
    IN PVOID Hive
    );
VOID
CmpDoQueueLateUnloadWorker(IN PCMHIVE CmHive);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpDeleteKeyObject)
#pragma alloc_text(PAGE,CmpLateUnloadHiveWorker)
#pragma alloc_text(PAGE,CmpDoQueueLateUnloadWorker)
#endif


VOID
CmpDeleteKeyObject(
    IN  PVOID   Object
    )
/*++

Routine Description:

    This routine interfaces to the NT Object Manager.  It is invoked when
    the last reference to a particular Key object (or Key Root object)
    is destroyed.

    If the Key object going away holds the last reference to
    the extension it is associated with, that extension is destroyed.

Arguments:

    Object - supplies a pointer to a KeyRoot or Key, thus -> KEY_BODY.

Return Value:

    NONE.

--*/
{
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock;
    PCM_KEY_BODY            KeyBody;
    PCMHIVE                 CmHive = NULL;
    BOOLEAN                 DoUnloadCheck = FALSE;

    CM_PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"CmpDeleteKeyObject: Object = %p\n", Object));

    //
    // HandleClose callback
    //
    if ( CmAreCallbacksRegistered() ) {
        REG_KEY_HANDLE_CLOSE_INFORMATION  KeyHandleCloseInfo;
       
        KeyHandleCloseInfo.Object = Object;

        CmpCallCallBacks(RegNtPreKeyHandleClose,&KeyHandleCloseInfo,TRUE,RegNtPostKeyHandleClose,Object);
    }

    KeyBody = (PCM_KEY_BODY)Object;

    BEGIN_LOCK_CHECKPOINT;

    CmpLockRegistry();

    if (KeyBody->Type==KEY_BODY_TYPE) {
        KeyControlBlock = KeyBody->KeyControlBlock;

        //
        // the keybody should be initialized; when kcb is null, something went wrong
        // between the creation and the dereferenciation of the object
        //
        if( KeyControlBlock != NULL ) {
            //
            // Clean up any outstanding notifies attached to the KeyBody
            //
            CmpFlushNotify(KeyBody,FALSE);

            //
            // Remove our reference to the KeyControlBlock, clean it up, perform any
            // pend-till-final-close operations.
            //
            // NOTE: Delete notification is seen at the parent of the deleted key,
            //       not the deleted key itself.  If any notify was outstanding on
            //       this key, it was cleared away above us.  Only parent/ancestor
            //       keys will see the report.
            //
            //
            // The dereference will free the KeyControlBlock.  If the key was deleted, it
            // has already been removed from the hash table, and relevant notifications
            // posted then as well.  All we are doing is freeing the tombstone.
            //
            // If it was not deleted, we're both cutting the kcb out of
            // the kcb list/tree, AND freeing its storage.
            //

           
            //
            // Replace this with the definition so we avoid dropping and reacquiring the lock
            DelistKeyBodyFromKCB(KeyBody,FALSE);

            //
            // take additional precaution in the case the hive has been unloaded and this is the root
            //
            if( !KeyControlBlock->Delete ) {
                CmHive = (PCMHIVE)CONTAINING_RECORD(KeyControlBlock->KeyHive, CMHIVE, Hive);
                if( IsHiveFrozen(CmHive) ) {
                    //
                    // unload is pending for this hive;
                    //
                    DoUnloadCheck = TRUE;

                }
            }

            CmpDelayDerefKeyControlBlock(KeyControlBlock);

        }
    } else {
        //
        // This must be a predefined handle
        //  some sanity asserts
        //
        KeyControlBlock = KeyBody->KeyControlBlock;

        ASSERT( KeyBody->Type&REG_PREDEF_HANDLE_MASK);
        ASSERT( KeyControlBlock->Flags&KEY_PREDEF_HANDLE );

        if( KeyControlBlock != NULL ) {
            CmHive = (PCMHIVE)CONTAINING_RECORD(KeyControlBlock->KeyHive, CMHIVE, Hive);
            if( IsHiveFrozen(CmHive) ) {
                //
                // unload is pending for this hive; we shouldn't put the kcb in the delay
                // close table
                //
                DoUnloadCheck = TRUE;

            }
            CmpDereferenceKeyControlBlock(KeyControlBlock);
        }

    }

    //
    // if a handle inside a frozen hive has been closed, we may need to unload the hive
    //
    if( DoUnloadCheck == TRUE ) {
        CmpDoQueueLateUnloadWorker(CmHive);
    }

    CmpUnlockRegistry();
    END_LOCK_CHECKPOINT;

    // 
    // just a notification; disregard the return status
    //
    CmPostCallbackNotification(RegNtPostKeyHandleClose,NULL,STATUS_SUCCESS);
    return;
}

VOID
CmpDoQueueLateUnloadWorker(IN PCMHIVE CmHive)
{
    PWORK_QUEUE_ITEM    WorkItem;

    CM_PAGED_CODE();

    ASSERT( CmHive->RootKcb != NULL );

    //
    // NB: Hive lock has higher precedence; We don't need the kcb lock as we are only checking the refcount
    //
    CmLockHive(CmHive);

    if( (CmHive->RootKcb->RefCount == 1) && (CmHive->UnloadWorkItem == NULL) ) {
        //
        // the only reference on the rookcb is the one that we artificially created
        // queue a work item to late unload the hive
        //
        WorkItem = ExAllocatePool(NonPagedPool, sizeof(WORK_QUEUE_ITEM));
        if( InterlockedCompareExchangePointer(&(CmHive->UnloadWorkItem),WorkItem,NULL) == NULL ) {
            ExInitializeWorkItem(CmHive->UnloadWorkItem,
                                 CmpLateUnloadHiveWorker,
                                 CmHive);
            ExQueueWorkItem(CmHive->UnloadWorkItem, DelayedWorkQueue);
        } else {
            ExFreePool(WorkItem);
        }

    }

    CmUnlockHive(CmHive);
}

VOID
CmpLateUnloadHiveWorker(
    IN PVOID Hive
    )
/*++

Routine Description:

    "Late" unloads the hive; If nothing goes badly wrong (i.e. insufficient resources),
    this function should succeed

Arguments:

    CmHive - the frozen hive to be unloaded

Return Value:

    NONE.

--*/
{
    NTSTATUS                Status;
    HCELL_INDEX             Cell;
    PCM_KEY_CONTROL_BLOCK   RootKcb;
    PCMHIVE                 CmHive;

    CM_PAGED_CODE();

    //
    // first, load the registry exclusive
    //
    CmpLockRegistryExclusive();

    //
    // hive is the parameter to this worker; make sure we free the work item
    // allocated by CmpDeleteKeyObject
    //
    CmHive = (PCMHIVE)Hive;

    ASSERT( CmHive->UnloadWorkItem != NULL );
    ExFreePool( CmHive->UnloadWorkItem );

    //
    // if this attempt doesn't succeed, mark that we can try another
    //
    CmHive->UnloadWorkItem = NULL;

    ASSERT( !(CmHive->Hive.HiveFlags & HIVE_IS_UNLOADING) );
    if( CmHive->Frozen == FALSE )  {
        //
        // another thread mounted the exact same hive in the exact same place, hence unfreezing the hive
        // we've done the cleanup part (free the workitem) nothing more to do.
        // or hive is already in process of being unloaded
        //
        ASSERT( CmHive->RootKcb == NULL );
        CmpUnlockRegistry();
        return;
    }
    //
    // this is just about the only possible way the hive can get corrupted in between
    //
    if( HvShutdownComplete == TRUE ) {
        // too late to do anything
        CmpUnlockRegistry();
        return;
    }

    //
    // hive should be frozen, otherwise we wouldn't get here
    //
    ASSERT( CmHive->Frozen == TRUE );

    RootKcb = CmHive->RootKcb;
    //
    // root kcb must be valid and has only our "artificial" refcount on it
    //
    ASSERT( RootKcb != NULL );

    if( RootKcb->RefCount > 1 ) {
        //
        // somebody else must've gotten in between dropping/reacquiring the reglock
        // and opened a handle inside this hive; bad luck, we can't unload
        //
        CmpUnlockRegistry();
        return;
    }

    ASSERT_KCB(RootKcb);

    Cell = RootKcb->KeyCell;
    Status = CmUnloadKey(RootKcb,0,CM_UNLOAD_REG_LOCKED_EX);
    ASSERT( (Status != STATUS_CANNOT_DELETE) && (Status != STATUS_INVALID_PARAMETER) );

    if(NT_SUCCESS(Status)) {
        // CmUnloadKey already released the lock
        CmpLockRegistry();
        CmpDereferenceKeyControlBlock(RootKcb);
    } 
    CmpUnlockRegistry();
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmdown.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmdown.c

Abstract:

    This module cleans up all the memory used by CM.

    This routine is intended to be called at system shutdown
    in order to detect memory leaks. It is supposed to free 
    all registry data that is not freed by CmShutdownSystem.

--*/

#include    "cmp.h"

//
// externals
//
extern  PUCHAR                      CmpStashBuffer;
extern  ULONG                       CmpDelayedCloseSize;

extern  BOOLEAN                     HvShutdownComplete;

extern  BOOLEAN                     CmFirstTime;

extern HIVE_LIST_ENTRY CmpMachineHiveList[];

VOID
CmpFreeAllMemory(
    VOID
    );

VOID
CmpDereferenceNameControlBlockWithLock(
    PCM_NAME_CONTROL_BLOCK   Ncb
    );

VOID
CmpDumpKeyBodyList(
    IN PCM_KEY_CONTROL_BLOCK   kcb,
    IN PULONG                  Count,
    IN PVOID                   Context 
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpFreeAllMemory)
#pragma alloc_text(PAGE,CmShutdownSystem)
#endif


VOID
CmpFreeAllMemory(
    VOID
    )
/*++

Routine Description:

    - All hives are freed
    - KCB table is freed 
    - Name hash table is freed
    - delay close table is freed - question: We need to clean/free all delayed close KCBs
    - all notifications/postblocks-aso.

    * equivalent with MmReleaseAllMemory

Arguments:


Return Value:


--*/

{

    PCMHIVE                 CmHive;
    LONG                    i;
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock;
    PLIST_ENTRY             NotifyPtr;
    PCM_NOTIFY_BLOCK        NotifyBlock;
    PCM_POST_BLOCK          PostBlock;
    PCM_KEY_HASH            Current;
    PLIST_ENTRY             AnchorAddr;
    ULONG                   Count;
    BOOLEAN                 MessageDisplayed;

    CmpRunDownDelayDerefKCBEngine(NULL,TRUE);
    //
    // Iterate through the list of the hives in the system
    //
    while (IsListEmpty(&CmpHiveListHead) == FALSE) {
        //
        // Remove the hive from the list
        //
        CmHive = (PCMHIVE)RemoveHeadList(&CmpHiveListHead);
        CmHive = (PCMHIVE)CONTAINING_RECORD(CmHive,
                                            CMHIVE,
                                            HiveList);

        //
        // close hive handles (the ones that are open)
        //
        for (i=0; i<HFILE_TYPE_MAX; i++) {
            // these should be closed by CmShutdownSystem
            ASSERT( CmHive->FileHandles[i] == NULL );
        }
        
        //
        // free the hive lock  and view lock
        //
        CmpFreeMutex(CmHive->ViewLock);
#if DBG
        CmpFreeResource(CmHive->FlusherLock);
#endif

        //
        // Spew in the debugger the names of the keynodes having notifies still set
        //
        NotifyPtr = &(CmHive->NotifyList);
        NotifyPtr = NotifyPtr->Flink;
        MessageDisplayed = FALSE;
        while( NotifyPtr != NULL ) {
            NotifyBlock = CONTAINING_RECORD(NotifyPtr, CM_NOTIFY_BLOCK, HiveList);
            
            AnchorAddr = &(NotifyBlock->PostList);
            PostBlock = (PCM_POST_BLOCK)(NotifyBlock->PostList.Flink);
            // 
            // walk through the list and spew the keynames and postblock types.
            //
            while ( PostBlock != (PCM_POST_BLOCK)AnchorAddr ) {
                PostBlock = CONTAINING_RECORD(PostBlock,
                                              CM_POST_BLOCK,
                                              NotifyList);

                if( PostBlock->PostKeyBody ) {
                    if( MessageDisplayed == FALSE ){
                        MessageDisplayed = TRUE;
                        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Dumping untriggered notifications for hive (%lx) (%.*S) \n\n",CmHive,
                            HBASE_NAME_ALLOC / sizeof(WCHAR),CmHive->Hive.BaseBlock->FileName);
                    }
                    switch (PostBlockType(PostBlock)) {
                        case PostSynchronous:
                            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Synchronous ");
                            break;
                        case PostAsyncUser:
                            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"AsyncUser   ");
                            break;
                        case PostAsyncKernel:
                            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"AsyncKernel ");
                            break;
                    }
                    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Notification, PostBlock %p not triggered on KCB %p\n",PostBlock,
                        PostBlock->PostKeyBody->KeyBody->KeyControlBlock);
                }


                //
                // skip to the next element
                //
                PostBlock = (PCM_POST_BLOCK)(PostBlock->NotifyList.Flink);

            }
            NotifyPtr = NotifyPtr->Flink;
        }

        //
        // free security cache
        //
        CmpDestroySecurityCache (CmHive);
        
        //
        // free the hv level structure
        //
        HvFreeHive(&(CmHive->Hive));

        //
        // free the cm level structure
        //
        CmpFree(CmHive, sizeof(CMHIVE));
        
    }

    //
    // Now free the CM globals
    //
    
    // the stash buffer
    if( CmpStashBuffer != NULL ) {
        ExFreePool( CmpStashBuffer );
    }

    //
    // Spew open handles and associated processes
    //
    Count = 0;
    MessageDisplayed = FALSE;
    for (i=0; i<(LONG)CmpHashTableSize; i++) {
        Current = CmpCacheTable[i].Entry;
        while (Current) {
            KeyControlBlock = CONTAINING_RECORD(Current, CM_KEY_CONTROL_BLOCK, KeyHash);
            if( MessageDisplayed == FALSE ){
                MessageDisplayed = TRUE;
                DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\nDumping open handles : \n\n");
            }
            CmpDumpKeyBodyList(KeyControlBlock,&Count,NULL);
            Current = Current->NextHash;
        }
    }
    
    if( Count != 0 ) {
        //
        // there some open handles; bugcheck 
        //
        CM_BUGCHECK( REGISTRY_ERROR,HANDLES_STILL_OPEN_AT_SHUTDOWN,1,Count,0);
    }

    //
    // in case of private alloc, free pages 
    //
    CmpDestroyCmPrivateAlloc();
    CmpDestroyCmPrivateDelayAlloc();
    //
    // For the 3 tables below, the objects actually pointed from inside 
    // should be cleaned up (freed) at the last handle closure time
    // the related handles are closed
    //
    // KCB cache table
    ASSERT( CmpCacheTable != NULL );
    ExFreePool(CmpCacheTable);

    // NameCacheTable
    ASSERT( CmpNameCacheTable != NULL );
    ExFreePool( CmpNameCacheTable );


}

VOID
CmShutdownSystem(
    VOID
    )
/*++

Routine Description:

    Shuts down the registry.

Arguments:

    NONE

Return Value:

    NONE

--*/
{

    PLIST_ENTRY p;
    PCMHIVE     CmHive;
    NTSTATUS    Status;
    PVOID       RegistryRoot;

    CM_PAGED_CODE();

    if (CmpRegistryRootHandle) {
        Status = ObReferenceObjectByHandle(CmpRegistryRootHandle,
                                           KEY_READ,
                                           NULL,
                                           KernelMode,
                                           &RegistryRoot,
                                           NULL);

        if (NT_SUCCESS(Status)) {
            // We want to dereference the object twice -- once for the
            // reference we just made, and once for the reference
            // fromCmpCreateRegistryRoot.
            ObDereferenceObject(RegistryRoot);
            ObDereferenceObject(RegistryRoot);
        }

        ObCloseHandle(CmpRegistryRootHandle, KernelMode);
    }
    
    CmpLockRegistryExclusive();

    //
    // Stop the workers; only if registry has been initializeed
    //
    if( CmFirstTime == FALSE ) {
        CmpShutdownWorkers();
    }
    
    //
    // shut down the registry
    //
    CmpDoFlushAll(TRUE);

    //
    // try to compress the system hive
    //
    CmCompressKey( &(CmpMachineHiveList[SYSTEM_HIVE_INDEX].CmHive->Hive) );

    //
    // close all the hive files
    //
    p = CmpHiveListHead.Flink;
    while(p != &CmpHiveListHead) {
        CmHive = CONTAINING_RECORD(p, CMHIVE, HiveList);
        //
        // we need to unmap all views mapped for this hive first
        //
        CmpDestroyHiveViewList(CmHive);
        CmpUnJoinClassOfTrust(CmHive);
        //
        // dereference the fileobject (if any).
        //
        CmpDropFileObjectForHive(CmHive);

        //
        // now we can safely close all the handles
        //
        CmpCmdHiveClose(CmHive);

        p=p->Flink;
    }

    HvShutdownComplete = TRUE;      // Tell HvSyncHive to ignore all further requests

    if((PoCleanShutdownEnabled() & PO_CLEAN_SHUTDOWN_REGISTRY) && (CmFirstTime == FALSE)){
        //
        // Free aux memory used internally by CM
        //
        CmpFreeAllMemory();
    }

    CmpUnlockRegistry();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmdat.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmdat.c

Abstract:

    This module contains registry "static" data, except for data
    also used by setup, which is in cmdat2.c.

--*/

#include "cmp.h"

//
// ***** INIT *****
//

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INITDATA")
#pragma const_seg("INITCONST")
#endif

//
// ---------------------------
//


UNICODE_STRING  CmpLoadOptions = { 0 };        // sys options from FW or boot.ini


//
// CmpClassString - contains strings which are used as the class
//     strings in the keynode.
// The associated enumerated type is CONFIGURATION_CLASS in arc.h
//

UNICODE_STRING CmClassName[MaximumClass + 1] = { 0 };

const PWCHAR CmClassString[MaximumClass + 1] = {
    L"System",
    L"Processor",
    L"Cache",
    L"Adapter",
    L"Controller",
    L"Peripheral",
    L"MemoryClass",
    L"Undefined"
    };


struct {
    PCHAR  AscString;
    USHORT  InterfaceType;
    USHORT  Count;
} CmpMultifunctionTypes[] = {
    "ISA",      Isa,            0,
    "MCA",      MicroChannel,   0,
    "PCI",      PCIBus,         0,
    "VME",      VMEBus,         0,
    "PCMCIA",   PCMCIABus,      0,
    "CBUS",     CBus,           0,
    "MPIPI",    MPIBus,         0,
    "MPSA",     MPSABus,        0,
    NULL,       Internal,       0
};


USHORT CmpUnknownBusCount = 0;

ULONG CmpConfigurationAreaSize = 0x4000;        // Initialize size = 16K
PCM_FULL_RESOURCE_DESCRIPTOR CmpConfigurationData = { 0 };

//
// The following strings will be used as the keynames for registry
// nodes.
// The associated enumerated type is CONFIGURATION_TYPE in arc.h
//

UNICODE_STRING CmTypeName[MaximumType + 1] = { 0 };


//
// ***** PAGE *****
//

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#pragma const_seg("PAGECONST")
#endif

const PWCHAR CmTypeString[MaximumType + 1] = {
    L"System",
    L"CentralProcessor",
    L"FloatingPointProcessor",
    L"PrimaryICache",
    L"PrimaryDCache",
    L"SecondaryICache",
    L"SecondaryDCache",
    L"SecondaryCache",
    L"EisaAdapter",
    L"TcAdapter",
    L"ScsiAdapter",
    L"DtiAdapter",
    L"MultifunctionAdapter",
    L"DiskController",
    L"TapeController",
    L"CdRomController",
    L"WormController",
    L"SerialController",
    L"NetworkController",
    L"DisplayController",
    L"ParallelController",
    L"PointerController",
    L"KeyboardController",
    L"AudioController",
    L"OtherController",
    L"DiskPeripheral",
    L"FloppyDiskPeripheral",
    L"TapePeripheral",
    L"ModemPeripheral",
    L"MonitorPeripheral",
    L"PrinterPeripheral",
    L"PointerPeripheral",
    L"KeyboardPeripheral",
    L"TerminalPeripheral",
    L"OtherPeripheral",
    L"LinePeripheral",
    L"NetworkPeripheral",
    L"SystemMemory",
    L"DockingInformation",
    L"RealModeIrqRoutingTable",    
    L"RealModePCIEnumeration",    
    L"Undefined"
    };

//
// CmpTypeCount[] - For each 'type', a count is used to keep track how many
//     keys have been created.
//

ULONG CmpTypeCount[NUMBER_TYPES] = {
            0,                  // ArcSystem
            0,                  // CentralProcessor",
            0,                  // FloatingPointProcessor",
            0,                  // PrimaryICache",
            0,                  // PrimaryDCache",
            0,                  // SecondaryICache",
            0,                  // SecondaryDCache",
            0,                  // SecondaryCache",
            0,                  // EisaAdapter", (8)
            0,                  // TcAdapter",   (9)
            0,                  // ScsiAdapter",
            0,                  // DtiAdapter",
            0,                  // MultifunctionAdapter", (12)
            0,                  // DiskController", (13)
            0,                  // TapeController",
            0,                  // CdRomController",
            0,                  // WormController",
            0,                  // SerialController",
            0,                  // NetworkController",
            0,                  // DisplayController",
            0,                  // ParallelController",
            0,                  // PointerController",
            0,                  // KeyboardController",
            0,                  // AudioController",
            0,                  // OtherController",
            0,                  // DiskPeripheral",
            0,                  // FloppyDiskPeripheral",
            0,                  // TapePeripheral",
            0,                  // ModemPeripheral",
            0,                  // MonitorPeripheral",
            0,                  // PrinterPeripheral",
            0,                  // PointerPeripheral",
            0,                  // KeyboardPeripheral",
            0,                  // TerminalPeripheral",
            0,                  // OtherPeripheral",
            0,                  // LinePeripheral",
            0,                  // NetworkPeripheral",
            0,                  // SystemMemory",
            0,                  // DockingInformation,
            0,					// RealModeIrqRoutingTable
            0                   // Undefined"
            };

const UNICODE_STRING nullclass = { 0, 0, NULL };

//
// All names used by the registry
//


UNICODE_STRING CmRegistryRootName = { 0 };
UNICODE_STRING CmRegistryMachineName = { 0 };
UNICODE_STRING CmRegistryMachineHardwareName = { 0 };
UNICODE_STRING CmRegistryMachineHardwareDescriptionName = { 0 };
UNICODE_STRING CmRegistryMachineHardwareDescriptionSystemName = { 0 };
UNICODE_STRING CmRegistryMachineHardwareDeviceMapName = { 0 };
UNICODE_STRING CmRegistryMachineHardwareResourceMapName = { 0 };
UNICODE_STRING CmRegistryMachineHardwareOwnerMapName = { 0 };
UNICODE_STRING CmRegistryMachineSystemName = { 0 };
UNICODE_STRING CmRegistryMachineSystemCurrentControlSet = { 0 };
UNICODE_STRING CmRegistryMachineSystemCurrentControlSetEnumName = { 0 };
UNICODE_STRING CmRegistryMachineSystemCurrentControlSetEnumRootName = { 0 };
UNICODE_STRING CmRegistryMachineSystemCurrentControlSetServices = { 0 };
UNICODE_STRING CmRegistryMachineSystemCurrentControlSetHardwareProfilesCurrent = { 0 };
UNICODE_STRING CmRegistryMachineSystemCurrentControlSetControlClass = { 0 };
UNICODE_STRING CmRegistryMachineSystemCurrentControlSetControlSafeBoot = { 0 };
UNICODE_STRING CmRegistryMachineSystemCurrentControlSetControlSessionManagerMemoryManagement = { 0 };
UNICODE_STRING CmRegistryMachineSystemCurrentControlSetControlBootLog = { 0 };
UNICODE_STRING CmRegistryMachineSystemCurrentControlSetServicesEventLog = { 0 };
UNICODE_STRING CmRegistryUserName = { 0 };
UNICODE_STRING CmRegistrySystemCloneName = { 0 };
UNICODE_STRING CmpSystemFileName = { 0 };
UNICODE_STRING CmSymbolicLinkValueName = { 0 };

#ifdef _WANT_MACHINE_IDENTIFICATION
UNICODE_STRING CmRegistryMachineSystemCurrentControlSetControlBiosInfo = { 0 };
#endif

const PWCHAR CmpRegistryRootString = L"\\REGISTRY";
const PWCHAR CmpRegistryMachineString = L"\\REGISTRY\\MACHINE";
const PWCHAR CmpRegistryMachineHardwareString =
                    L"\\REGISTRY\\MACHINE\\HARDWARE";
const PWCHAR CmpRegistryMachineHardwareDescriptionString =
                    L"\\REGISTRY\\MACHINE\\HARDWARE\\DESCRIPTION";
const PWCHAR CmpRegistryMachineHardwareDescriptionSystemString =
                    L"\\REGISTRY\\MACHINE\\HARDWARE\\DESCRIPTION\\SYSTEM";
const PWCHAR CmpRegistryMachineHardwareDeviceMapString =
                    L"\\REGISTRY\\MACHINE\\HARDWARE\\DEVICEMAP";
const PWCHAR CmpRegistryMachineHardwareResourceMapString =
                    L"\\REGISTRY\\MACHINE\\HARDWARE\\RESOURCEMAP";
const PWCHAR CmpRegistryMachineHardwareOwnerMapString =
                    L"\\REGISTRY\\MACHINE\\HARDWARE\\OWNERMAP";
const PWCHAR CmpRegistryMachineSystemString =
                    L"\\REGISTRY\\MACHINE\\SYSTEM";
const PWCHAR CmpRegistryMachineSystemCurrentControlSetString =
                    L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET";
const PWCHAR CmpRegistryMachineSystemCurrentControlSetEnumString =
                    L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\ENUM";
const PWCHAR CmpRegistryMachineSystemCurrentControlSetEnumRootString =
                    L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\ENUM\\ROOT";
const PWCHAR CmpRegistryMachineSystemCurrentControlSetServicesString =
                    L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\SERVICES";
const PWCHAR CmpRegistryMachineSystemCurrentControlSetHardwareProfilesCurrentString =
                    L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\HARDWARE PROFILES\\CURRENT";
const PWCHAR CmpRegistryMachineSystemCurrentControlSetControlClassString =
                    L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\CONTROL\\CLASS";
const PWCHAR CmpRegistryMachineSystemCurrentControlSetControlSafeBootString =
                    L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\CONTROL\\SAFEBOOT";
const PWCHAR CmpRegistryMachineSystemCurrentControlSetControlSessionManagerMemoryManagementString =
                    L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\CONTROL\\SESSION MANAGER\\MEMORY MANAGEMENT";
const PWCHAR CmpRegistryMachineSystemCurrentControlSetControlBootLogString =
                    L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\CONTROL\\BOOTLOG";
const PWCHAR CmpRegistryMachineSystemCurrentControlSetServicesEventLogString =
                    L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\SERVICES\\EVENTLOG";
const PWCHAR CmpRegistryUserString = L"\\REGISTRY\\USER";
const PWCHAR CmpRegistrySystemCloneString = L"\\REGISTRY\\MACHINE\\CLONE";
const PWCHAR CmpRegistrySystemFileNameString = L"SYSTEM";
const PWCHAR CmpRegistryPerflibString = L"\\REGISTRY\\MACHINE\\SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\PERFLIB";

const PWCHAR CmpProcessorControl = L"ProcessorControl";
const PWCHAR CmpControlSessionManager = L"Control\\Session Manager";
const PWCHAR CmpSymbolicLinkValueName = L"SymbolicLinkValue";

#ifdef _WANT_MACHINE_IDENTIFICATION
const PWCHAR CmpRegistryMachineSystemCurrentControlSetControlBiosInfoString =
                    L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\CONTROL\\BIOSINFO";
#endif

//
// N.B. The CLONE hive is left out of the machine Hive list if 
//      we will not be using it to clone the current control set, 
//      since that is that Hive's only purpose.
//

HIVE_LIST_ENTRY CmpMachineHiveList[] = {
    { L"HARDWARE", L"MACHINE\\", NULL, HIVE_VOLATILE    , 0                         ,   NULL,   FALSE,  FALSE,  FALSE},
    { L"SECURITY", L"MACHINE\\", NULL, 0                , 0                         ,   NULL,   FALSE,  FALSE,  FALSE},
    { L"SOFTWARE", L"MACHINE\\", NULL, 0                , 0                         ,   NULL,   FALSE,  FALSE,  FALSE},
    { L"SYSTEM",   L"MACHINE\\", NULL, 0                , 0                         ,   NULL,   FALSE,  FALSE,  FALSE},
    { L"DEFAULT",  L"USER\\.DEFAULT", NULL, 0           , CM_CMHIVE_FLAG_UNTRUSTED  ,   NULL,   FALSE,  FALSE,  FALSE},
    { L"SAM",      L"MACHINE\\", NULL, HIVE_NOLAZYFLUSH , 0                         ,   NULL,   FALSE,  FALSE,  FALSE},
    { NULL,        NULL,         0, 0                   , 0                         ,   NULL,   FALSE,  FALSE,  FALSE}
    };


UCHAR           SystemHiveFullPathBuffer[MAX_NAME];
UNICODE_STRING  SystemHiveFullPathName;

//
// Master Hive
//
//  The KEY_NODEs for \REGISTRY, \REGISTRY\MACHINE, and \REGISTRY\USER
//  are stored in a small memory only hive called the Master Hive.
//  All other hives have link nodes in this hive which point to them.
//
PCMHIVE CmpMasterHive = { 0 };
BOOLEAN CmpNoMasterCreates = FALSE;     // Set TRUE after we're done to
                                        // prevent random creates in the
                                        // master hive, which is not backed
                                        // by a file.


LIST_ENTRY      CmpHiveListHead = { 0 };            // List of CMHIVEs
EX_PUSH_LOCK    CmpHiveListHeadLock;                // used to protect the list above
EX_PUSH_LOCK    CmpLoadHiveLock;

//
// Addresses of object type descriptors:
//

POBJECT_TYPE CmpKeyObjectType = { 0 };

//
// Write-Control:
//  CmpNoWrite is initially true.  When set this way write and flush
//  do nothing, simply returning success.  When cleared to FALSE, I/O
//  is enabled.  This change is made after the I/O system is started
//  AND autocheck (chkdsk) has done its thing.
//

BOOLEAN CmpNoWrite = TRUE;


//
// NtInitializeRegistry global status flags
//

// 
// If CmFirstTime is TRUE, then NtInitializeRegistry has not yet been
// called to perform basic registry initialization
//

BOOLEAN CmFirstTime = TRUE;       

//
// trick to allow parallel threads to access the registry
//
BOOLEAN CmpSpecialBootCondition = FALSE;


//
// If CmBootAcceptFirstTime is TRUE, then NtInitializeRegistry has not 
// yet been called to accept the current Boot and save the boot
// control set as the LKG control set.
//

BOOLEAN CmBootAcceptFirstTime = TRUE;   

//
// CmpWasSetupBoot indicates whether or not the boot
// is into text mode setup.  If so, we do not turn
// on global quotas.
//
BOOLEAN CmpWasSetupBoot;

//
// Indicates whether the hives need to be loaded in memory
// and in scratch mode
//
BOOLEAN CmpMiniNTBoot = FALSE;

//
// Indicates whether the system hives need to be opened in a
// shared mode. Generally needed if we are booting WinPE (MiniNT)
// on network
//
BOOLEAN CmpShareSystemHives = FALSE;

//
// Where are we booting from
//
ULONG	CmpBootType;

//
// Self healing hives control switch
//
BOOLEAN CmpSelfHeal = TRUE;


#ifdef ALLOC_DATA_PRAGMA
#pragma  const_seg()
#pragma  data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmdelay.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmdelay.c

Abstract:

    This module implements the new algorithm (LRU style) for the 
    Delayed Close KCB table.

    Functions in this module are thread safe protected by the kcb lock.
    When kcb lock is converted to a resource, we should assert (enforce)
    exclusivity of that resource here !!!

Note:
    
    We might want to convert these functions to macros after enough testing
    provides that they work well

--*/

#include    "cmp.h"

ULONG                   CmpDelayedCloseSize = 2048; // !!!! Cannot be bigger that 4094 !!!!!
ULONG                   CmpDelayedCloseElements = 0; 

#define MAX_DELAY_WORKER_ITERATIONS     ( CmpDelayedCloseSize / 4 )

VOID
CmpDelayDerefKCBWorker(
    IN PVOID Parameter
    );

VOID
CmpDelayCloseWorker(
    IN PVOID Parameter
    );

typedef struct _CM_DELAY_DEREF_KCB_ITEM {
    LIST_ENTRY              ListEntry;
    PCM_KEY_CONTROL_BLOCK   Kcb;
} CM_DELAY_DEREF_KCB_ITEM, *PCM_DELAY_DEREF_KCB_ITEM;

VOID
CmpDelayCloseDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
CmpDelayDerefKCBDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
CmpDoQueueLateUnloadWorker(IN PCMHIVE CmHive);

VOID
CmpArmDelayedCloseTimer(VOID);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpInitializeDelayedCloseTable)
#pragma alloc_text(PAGE,CmpRemoveFromDelayedClose)
#pragma alloc_text(PAGE,CmpAddToDelayedClose)

#pragma alloc_text(PAGE,CmpInitDelayDerefKCBEngine)
#pragma alloc_text(PAGE,CmpRunDownDelayDerefKCBEngine)
#pragma alloc_text(PAGE,CmpDelayDerefKeyControlBlock)
#pragma alloc_text(PAGE,CmpDelayDerefKCBWorker)
#pragma alloc_text(PAGE,CmpArmDelayedCloseTimer)
#endif

WORK_QUEUE_ITEM CmpDelayCloseWorkItem;
BOOLEAN         CmpDelayCloseWorkItemActive = FALSE;

KGUARDED_MUTEX  CmpDelayedCloseTableLock;                
LIST_ENTRY      CmpDelayedLRUListHead;          // head of the LRU list of Delayed Close Table entries

KTIMER          CmpDelayCloseTimer;
KDPC            CmpDelayCloseDpc;

ULONG           CmpDelayCloseIntervalInSeconds = 5;


#define LOCK_DELAY_CLOSE() KeAcquireGuardedMutex(&CmpDelayedCloseTableLock)
#define UNLOCK_DELAY_CLOSE() KeReleaseGuardedMutex(&CmpDelayedCloseTableLock)

VOID
CmpDelayCloseDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This is the DPC routine triggered by the delayclose timer.  
    is queue a work item to an executive worker thread.  

Arguments:

    Dpc - Supplies a pointer to the DPC object.

    DeferredContext - not used

    SystemArgument1 - not used

    SystemArgument2 - not used

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (DeferredContext);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);

    ASSERT(CmpDelayCloseWorkItemActive);
    ExQueueWorkItem(&CmpDelayCloseWorkItem, DelayedWorkQueue);
}


#define CmpDelayCloseAllocNewEntry() (PCM_DELAYED_CLOSE_ENTRY)CmpAllocateDelayItem()
#define CmpDelayCloseFreeEntry(Item) CmpFreeDelayItem((PVOID)(Item))

VOID
CmpInitializeDelayedCloseTable()
/*++

Routine Description:

    Initialize delayed close table; allocation + LRU list initialization.

Arguments:


Return Value:

    NONE.

--*/
{
    ExInitializeWorkItem(&CmpDelayCloseWorkItem, CmpDelayCloseWorker, NULL);
    KeInitializeGuardedMutex(&CmpDelayedCloseTableLock);
    InitializeListHead(&(CmpDelayedLRUListHead));
    KeInitializeDpc(&CmpDelayCloseDpc,
                    CmpDelayCloseDpcRoutine,
                    NULL);

    KeInitializeTimer(&CmpDelayCloseTimer);

}

VOID
CmpDelayCloseWorker(
    IN PVOID Parameter
    )

/*++

Routine Description:
    
      The fun part. We need to walk the cache and look for kcbs with refcount == 0
      Get the oldest one and kick it out of cache.

Arguments:

    Parameter - not used.

Return Value:

    None.

--*/

{
    PCM_DELAYED_CLOSE_ENTRY     DelayedEntry;
    ULONG                       ConvKey;
    ULONG                       MaxIterations = MAX_DELAY_WORKER_ITERATIONS;

    CM_PAGED_CODE();

    UNREFERENCED_PARAMETER (Parameter);

    ASSERT(CmpDelayCloseWorkItemActive);

    BEGIN_LOCK_CHECKPOINT;
    CmpLockRegistry();
    
    //
    // process kick out every entry with RefCount == 0 && DelayCloseIndex == 0
    // ignore the others; we only do this while there is excess of delay - close kcbs
    //
    LOCK_DELAY_CLOSE();
    while( (CmpDelayedCloseElements > CmpDelayedCloseSize) && (MaxIterations--) ) {
        ASSERT( !CmpIsListEmpty(&CmpDelayedLRUListHead) );
        //
        // We first need to get the hash entry and attempt to lock it.
        //
        DelayedEntry = (PCM_DELAYED_CLOSE_ENTRY)(CmpDelayedLRUListHead.Blink);
        DelayedEntry = CONTAINING_RECORD(   DelayedEntry,
                                            CM_DELAYED_CLOSE_ENTRY,
                                            DelayedLRUList);
        ConvKey = DelayedEntry->KeyControlBlock->ConvKey;
        UNLOCK_DELAY_CLOSE();
        //
        // now lock the hash then recheck if the entry is still first on the list
        //
        CmpLockHashEntryExclusive(ConvKey);
        LOCK_DELAY_CLOSE();
        if( CmpDelayedCloseElements <= CmpDelayedCloseSize ) {
            //
            // just bail out; no need to kick them out
            //
            CmpUnlockHashEntry(ConvKey);
            break;
        }
        DelayedEntry = (PCM_DELAYED_CLOSE_ENTRY)(CmpDelayedLRUListHead.Blink);
        DelayedEntry = CONTAINING_RECORD(   DelayedEntry,
                                            CM_DELAYED_CLOSE_ENTRY,
                                            DelayedLRUList);
        if( ConvKey == DelayedEntry->KeyControlBlock->ConvKey ) {
            //
            // same hash entry; proceed
            // pull it out of the list
            //
            DelayedEntry = (PCM_DELAYED_CLOSE_ENTRY)RemoveTailList(&CmpDelayedLRUListHead);
    
            DelayedEntry = CONTAINING_RECORD(   DelayedEntry,
                                                CM_DELAYED_CLOSE_ENTRY,
                                                DelayedLRUList);
            CmpClearListEntry(&(DelayedEntry->DelayedLRUList));

            if( (DelayedEntry->KeyControlBlock->RefCount == 0) && (DelayedEntry->KeyControlBlock->DelayedCloseIndex == 0) ){
                //
                // free this kcb and the entry
                //
                UNLOCK_DELAY_CLOSE();
                DelayedEntry->KeyControlBlock->DelayCloseEntry = NULL;
                CmpCleanUpKcbCacheWithLock(DelayedEntry->KeyControlBlock,FALSE);
                CmpDelayCloseFreeEntry(DelayedEntry);
                InterlockedDecrement((PLONG)&CmpDelayedCloseElements);
            } else {
                //
                // put it back at the top
                //
                InsertHeadList( &CmpDelayedLRUListHead,
                                &(DelayedEntry->DelayedLRUList)
                            );
                UNLOCK_DELAY_CLOSE();
            }
        } else {
            UNLOCK_DELAY_CLOSE();
        }
        CmpUnlockHashEntry(ConvKey);

        LOCK_DELAY_CLOSE();
    }
    if( CmpDelayedCloseElements > CmpDelayedCloseSize ) {
        //
        // iteration run was too short, there are more elements to process, queue ourselves for later
        //
        CmpArmDelayedCloseTimer();
    } else {
        //
        // signal that we have finished our work.
        //
        CmpDelayCloseWorkItemActive = FALSE;
    }
    UNLOCK_DELAY_CLOSE();


    CmpUnlockRegistry();
    END_LOCK_CHECKPOINT;
}

VOID
CmpArmDelayedCloseTimer( )

/*++

Routine Description:

    Arms timer for DelayClose worker procession

    NB: this routine should be called with CmpDelayedCloseTableLock held. 
        If not --> change CmpDelayCloseWorkItemActive to a ULONG and do an InterlockedCompareExchange on it 
        before setting the timer

Arguments:


Note: 
    

Return Value:

    NONE.

--*/
{
    LARGE_INTEGER DueTime;

    CM_PAGED_CODE();
    
    CmpDelayCloseWorkItemActive = TRUE;

    //
    // queue a timer for 5 secs later to do the actual delay close
    //

    DueTime.QuadPart = Int32x32To64(CmpDelayCloseIntervalInSeconds,
                                    - SECOND_MULT);
    //
    // Indicate relative time
    //

    KeSetTimer(&CmpDelayCloseTimer,
               DueTime,
               &CmpDelayCloseDpc);

}

VOID
CmpRemoveFromDelayedClose(
    IN PCM_KEY_CONTROL_BLOCK kcb
    )
/*++

Routine Description:

    Removes a KCB from the delayed close table;

Arguments:

    kcb - the kcb in question

Note: 
    
    kcb lock/resource should be acquired exclusively when this function is called

Return Value:

    NONE.

--*/
{
    PCM_DELAYED_CLOSE_ENTRY     DelayedEntry;

    CM_PAGED_CODE();


    ASSERT( (CmpIsKCBLockedExclusive(kcb) == TRUE) || // this kcb is owned exclusive
            (CmpTestRegistryLockExclusive() == TRUE) ); // or the entire registry is locked exclusive

    // not on delay close; don't try to remove it.
    if (kcb->DelayedCloseIndex == CmpDelayedCloseSize) { // see if we really need this
        ASSERT( FALSE );
        return;
    }

    DelayedEntry = (PCM_DELAYED_CLOSE_ENTRY)kcb->DelayCloseEntry;
    if( DelayedEntry != NULL ) {
        LOCK_DELAY_CLOSE();
        CmpRemoveEntryList(&(DelayedEntry->DelayedLRUList));
        UNLOCK_DELAY_CLOSE();

        //
        // give back the entry
        //
        CmpDelayCloseFreeEntry(DelayedEntry);
        InterlockedDecrement((PLONG)&CmpDelayedCloseElements);
#if DBG
        if( kcb->InDelayClose == 0 ) {
            ASSERT( FALSE );
        }
        {
            LONG                        OldRefCount;
            LONG                        NewRefCount;

            OldRefCount = *(PLONG)&kcb->InDelayClose; //get entire dword
            ASSERT( OldRefCount == 1 );
            NewRefCount = 0;
            if( InterlockedCompareExchange((PLONG)&kcb->InDelayClose,NewRefCount,OldRefCount)
                    != OldRefCount ) {
    
                ASSERT( FALSE );
            }
        }
#endif //DBG
    }

    //
    // easy enough huh ?
    //
    kcb->DelayedCloseIndex = CmpDelayedCloseSize; // see if we really need this
    kcb->DelayCloseEntry = NULL;
}


VOID
CmpAddToDelayedClose(
    IN PCM_KEY_CONTROL_BLOCK    kcb,
    IN BOOLEAN                  RegLockHeldEx
    )
/*++

Routine Description:

    Adds a kcb to the delayed close table

Arguments:

    kcb - the kcb in question

Note: 
    
    kcb lock/resource should be acquired exclusively when this function is called

Return Value:

    NONE.

--*/
{
    PCM_DELAYED_CLOSE_ENTRY     DelayedEntry = NULL;

    CM_PAGED_CODE();

    ASSERT( (CmpIsKCBLockedExclusive(kcb) == TRUE) || // this kcb is owned exclusive
            (CmpTestRegistryLockExclusive() == TRUE) ); // or the entire registry is locked exclusive


    // Already on delayed close, don't try to put on again
    if (kcb->DelayedCloseIndex != CmpDelayedCloseSize) { // see if we really need this
        ASSERT( FALSE );
        return;
    }

    ASSERT(kcb->RefCount == 0);

    //
    // now materialize a new entry for this kcb
    //
    ASSERT_KEYBODY_LIST_EMPTY(kcb);
    DelayedEntry = CmpDelayCloseAllocNewEntry();
    if( !DelayedEntry ) {
        //
        // this is bad luck; we need to free the kcb in place
        //
        CmpCleanUpKcbCacheWithLock(kcb,RegLockHeldEx);
        return;
    }
#if DBG
    if( kcb->InDelayClose != 0 ) {
        ASSERT( FALSE );
    }
    {
        LONG                        OldRefCount;
        LONG                        NewRefCount;

        OldRefCount = *(PLONG)&kcb->InDelayClose; //get entire dword
        ASSERT( OldRefCount == 0 );
        NewRefCount = 1;
        if( InterlockedCompareExchange((PLONG)&kcb->InDelayClose,NewRefCount,OldRefCount)
                != OldRefCount ) {
    
            ASSERT( FALSE );
        }
    }
#endif //DBG
    //
    // populate the entry and insert it into the LRU list (at the top).
    //
    kcb->DelayedCloseIndex = 0; // see if we really need this
    kcb->DelayCloseEntry = (PVOID)DelayedEntry;    // need this for removing it back from here
    DelayedEntry->KeyControlBlock = kcb;
    InterlockedIncrement((PLONG)&CmpDelayedCloseElements);

    LOCK_DELAY_CLOSE();
    InsertHeadList(
        &CmpDelayedLRUListHead,
        &(DelayedEntry->DelayedLRUList)
        );
    //
    // check if limit hit and arm timer if not already armed
    //
    if( (CmpDelayedCloseElements > CmpDelayedCloseSize) && (!CmpDelayCloseWorkItemActive) ) {
        CmpArmDelayedCloseTimer();
    } 
    UNLOCK_DELAY_CLOSE();
    //
    // we're done here
    //

}

//-----------------------------------------------------------------------------------------------------------//
//                                                                                                           //
// Delayed KCB deref. Used when we hit a symlink or when we simply cannot safely acquire the kcb lock        //
//                                                                                                           //
//-----------------------------------------------------------------------------------------------------------//
LIST_ENTRY      CmpDelayDerefKCBListHead;
KGUARDED_MUTEX  CmpDelayDerefKCBLock;                
WORK_QUEUE_ITEM CmpDelayDerefKCBWorkItem;
BOOLEAN         CmpDelayDerefKCBWorkItemActive = FALSE;

KTIMER          CmpDelayDerefKCBTimer;
KDPC            CmpDelayDerefKCBDpc;

ULONG           CmpDelayDerefKCBIntervalInSeconds = 5;


#define LOCK_KCB_DELAY_DEREF_LIST() KeAcquireGuardedMutex(&CmpDelayDerefKCBLock)
#define UNLOCK_KCB_DELAY_DEREF_LIST() KeReleaseGuardedMutex(&CmpDelayDerefKCBLock)

VOID
CmpDelayDerefKCBDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This is the DPC routine triggered by the delayclose timer.  
    is queue a work item to an executive worker thread.  

Arguments:

    Dpc - Supplies a pointer to the DPC object.

    DeferredContext - not used

    SystemArgument1 - not used

    SystemArgument2 - not used

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (DeferredContext);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);

    ASSERT(CmpDelayDerefKCBWorkItemActive);
    ExQueueWorkItem(&CmpDelayDerefKCBWorkItem, DelayedWorkQueue);
}

#define CmpDelayDerefKCBAllocNewEntry() (PCM_DELAY_DEREF_KCB_ITEM)CmpAllocateDelayItem()
#define CmpDelayDerefKCBFreeEntry(Item) CmpFreeDelayItem((PVOID)(Item))

//#define CmpDelayDerefKCBAllocNewEntry() (PCM_DELAY_DEREF_KCB_ITEM)ExAllocatePool(PagedPool,sizeof(CM_DELAY_DEREF_KCB_ITEM))
//#define CmpDelayDerefKCBFreeEntry(Item) ExFreePool(Item)


VOID
CmpInitDelayDerefKCBEngine()
{
    InitializeListHead(&CmpDelayDerefKCBListHead);
    KeInitializeGuardedMutex(&CmpDelayDerefKCBLock);
    ExInitializeWorkItem(&CmpDelayDerefKCBWorkItem, CmpDelayDerefKCBWorker, NULL);

    KeInitializeDpc(&CmpDelayDerefKCBDpc,
                    CmpDelayDerefKCBDpcRoutine,
                    NULL);

    KeInitializeTimer(&CmpDelayDerefKCBTimer);
}

VOID    
CmpRunDownDelayDerefKCBEngine(  PCM_KEY_CONTROL_BLOCK KeyControlBlock,
                                BOOLEAN               RegLockHeldEx)
{
    PCM_DELAY_DEREF_KCB_ITEM    DelayItem;
    ULONG                       NewIndex;
    ULONG                       Index1 = CmpHashTableSize;
    ULONG                       Index2 = CmpHashTableSize;
    PCMHIVE                     CmHive = NULL;
    BOOLEAN                     DoUnloadCheck = FALSE;

    CM_PAGED_CODE();

    ASSERT_CM_LOCK_OWNED();

    ASSERT( (KeyControlBlock && CmpIsKCBLockedExclusive(KeyControlBlock)) || (CmpTestRegistryLockExclusive() == TRUE) );

    if( KeyControlBlock ) {
        Index1 = GET_HASH_INDEX(KeyControlBlock->ConvKey);
        if( KeyControlBlock->ParentKcb ) {
            Index2 = GET_HASH_INDEX(KeyControlBlock->ParentKcb->ConvKey);
        }
    }
    LOCK_KCB_DELAY_DEREF_LIST();
    while( !CmpIsListEmpty(&CmpDelayDerefKCBListHead) ) {
        //
        // pull it out of the list
        //
        DelayItem = (PCM_DELAY_DEREF_KCB_ITEM)RemoveHeadList(&CmpDelayDerefKCBListHead);
        UNLOCK_KCB_DELAY_DEREF_LIST();

        DelayItem = CONTAINING_RECORD(  DelayItem,
                                        CM_DELAY_DEREF_KCB_ITEM,
                                        ListEntry);
        CmpClearListEntry(&(DelayItem->ListEntry));

        //
        // take additional precaution in the case the hive has been unloaded and this is the root
        //
        DoUnloadCheck = FALSE;
        if( !DelayItem->Kcb->Delete ) {
            CmHive = (PCMHIVE)CONTAINING_RECORD(DelayItem->Kcb->KeyHive, CMHIVE, Hive);
            if( IsHiveFrozen(CmHive) ) {
                //
                // unload is pending for this hive;
                //
                DoUnloadCheck = TRUE;

            }
        }

        NewIndex = GET_HASH_INDEX(DelayItem->Kcb->ConvKey);
        //
        // now deref and free 
        //
        if( (NewIndex == Index1) || (NewIndex == Index2) ) {
            //
            // we already hold the lock
            //
            ASSERT_KCB_LOCKED_EXCLUSIVE(DelayItem->Kcb);
            CmpDereferenceKeyControlBlockWithLock(DelayItem->Kcb,RegLockHeldEx);
        } else {
            //
            // we can't afford to force acquire; try to acquire and if it fails bail out
            //
            if( CmpKCBLockForceAcquireAllowed(Index1,Index2,NewIndex) ) {
                CmpLockHashEntryByIndexExclusive(NewIndex);
            } else if( CmpTryToLockHashEntryByIndexExclusive(NewIndex) == FALSE ) {
                //
                // add the item back to the list and bail out
                //
                ASSERT( CmpTestRegistryLockExclusive() == FALSE );
                LOCK_KCB_DELAY_DEREF_LIST();
                InsertHeadList(&CmpDelayDerefKCBListHead,&(DelayItem->ListEntry));
                UNLOCK_KCB_DELAY_DEREF_LIST();
                return;
            }
            ASSERT_KCB_LOCKED_EXCLUSIVE(DelayItem->Kcb);
            CmpDereferenceKeyControlBlockWithLock(DelayItem->Kcb,RegLockHeldEx);
            CmpUnlockHashEntryByIndex(NewIndex);
        }
        CmpDelayDerefKCBFreeEntry(DelayItem);

        //
        // if we dropped a reference inside a frozen hive, we may need to unload the hive
        //
        if( DoUnloadCheck == TRUE ) {
            CmpDoQueueLateUnloadWorker(CmHive);
        }

        LOCK_KCB_DELAY_DEREF_LIST();
    }
    UNLOCK_KCB_DELAY_DEREF_LIST();
}

VOID
CmpDelayDerefKCBWorker(
    IN PVOID Parameter
    )

/*++

Routine Description:


Arguments:

    Parameter - not used.

Return Value:

    None.

--*/

{
    PCM_DELAY_DEREF_KCB_ITEM DelayItem;
    PCMHIVE                 CmHive = NULL;
    BOOLEAN                 DoUnloadCheck = FALSE;

    CM_PAGED_CODE();

    UNREFERENCED_PARAMETER (Parameter);

    ASSERT(CmpDelayDerefKCBWorkItemActive);

    BEGIN_LOCK_CHECKPOINT;
    CmpLockRegistry();

    LOCK_KCB_DELAY_DEREF_LIST();
    while( !CmpIsListEmpty(&CmpDelayDerefKCBListHead) ) {
        //
        // pull it out of the list
        //
        DelayItem = (PCM_DELAY_DEREF_KCB_ITEM)RemoveHeadList(&CmpDelayDerefKCBListHead);
        UNLOCK_KCB_DELAY_DEREF_LIST();

        DelayItem = CONTAINING_RECORD(  DelayItem,
                                        CM_DELAY_DEREF_KCB_ITEM,
                                        ListEntry);
        CmpClearListEntry(&(DelayItem->ListEntry));
        //
        // take additional precaution in the case the hive has been unloaded and this is the root
        //
        DoUnloadCheck = FALSE;
        if( !DelayItem->Kcb->Delete ) {
            CmHive = (PCMHIVE)CONTAINING_RECORD(DelayItem->Kcb->KeyHive, CMHIVE, Hive);
            if( IsHiveFrozen(CmHive) ) {
                //
                // unload is pending for this hive;
                //
                DoUnloadCheck = TRUE;

            }
        }

        //
        // now deref and free 
        //
        CmpDereferenceKeyControlBlock(DelayItem->Kcb);
        CmpDelayDerefKCBFreeEntry(DelayItem);

        //
        // if we dropped a reference inside a frozen hive, we may need to unload the hive
        //
        if( DoUnloadCheck == TRUE ) {
            CmpDoQueueLateUnloadWorker(CmHive);
        }

        LOCK_KCB_DELAY_DEREF_LIST();
    }
    //
    // signal that we have finished our work.
    //
    CmpDelayDerefKCBWorkItemActive = FALSE;
    UNLOCK_KCB_DELAY_DEREF_LIST();

    CmpUnlockRegistry();
    END_LOCK_CHECKPOINT;
}

VOID
CmpDelayDerefKeyControlBlock( PCM_KEY_CONTROL_BLOCK   KeyControlBlock )
/*++

Routine Description:

    Adds kcb to a list to be deref in a workitem

Arguments:

    kcb - the kcb in question

Note: 
    
    kcb lock/resource should be acquired exclusively when this function is called

Return Value:

    NONE.

--*/
{
    PCM_DELAY_DEREF_KCB_ITEM    DelayItem;
    LONG                        OldRefCount;
    LONG                        NewRefCount;

    CM_PAGED_CODE();

    //
    // try the fast path first; we only need to take the work item approach when we drop to 0
    //
    OldRefCount = *(PLONG)&KeyControlBlock->RefCount; //get entire dword
    NewRefCount = OldRefCount - 1;
    if( (NewRefCount & 0xffff) > 0  &&
        InterlockedCompareExchange((PLONG)&KeyControlBlock->RefCount,NewRefCount,OldRefCount)
            == OldRefCount ) {
    
        LogKCBReference(KeyControlBlock,2);
        return;
    }

    DelayItem = CmpDelayDerefKCBAllocNewEntry();
    if( DelayItem == NULL ) {
        //
        // nothing to do here ; we'll leak a reference on this kcb
        //
        return;
    }

    DelayItem->Kcb = KeyControlBlock;
    LOCK_KCB_DELAY_DEREF_LIST();
    InsertTailList( &CmpDelayDerefKCBListHead,&(DelayItem->ListEntry));
    //
    // if worker is not already up; queue it
    //
    if( !CmpDelayDerefKCBWorkItemActive ) {
        LARGE_INTEGER DueTime;

        CmpDelayDerefKCBWorkItemActive = TRUE;
            
        //
        // queue a timer for 5 secs later to do the actual delay close
        //

        DueTime.QuadPart = Int32x32To64(CmpDelayDerefKCBIntervalInSeconds,
                                        - SECOND_MULT);
        //
        // Indicate relative time
        //

        KeSetTimer(&CmpDelayDerefKCBTimer,
                   DueTime,
                   &CmpDelayDerefKCBDpc);
    } 
    UNLOCK_KCB_DELAY_DEREF_LIST();
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmgquota.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmgquota.c

Abstract:

    The module contains CM routines to support Global Quota

    Global Quota has little to do with NT's standard per-process/user
    quota system.  Global Quota is waying of controlling the aggregate
    resource usage of the entire registry.  It is used to manage space
    consumption by objects which user apps create, but which are persistent
    and therefore cannot be assigned to the quota of a user app.

    Global Quota prevents the registry from consuming all of paged
    pool, and indirectly controls how much disk it can consume.
    Like the release 1 file systems, a single app can fill all the
    space in the registry, but at least it cannot kill the system.

    Memory objects used for known short times and protected by
    serialization, or billable as quota objects, are not counted
    in the global quota.

--*/

#include "cmp.h"

VOID
CmpSystemHiveHysteresisWorker(
    IN PVOID WorkItem
    );

VOID
CmpRaiseSelfHealWarningWorker(
    IN PVOID Arg
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpClaimGlobalQuota)
#pragma alloc_text(PAGE,CmpReleaseGlobalQuota)
#pragma alloc_text(PAGE,CmpSetGlobalQuotaAllowed)
#pragma alloc_text(PAGE,CmpQuotaWarningWorker)
#pragma alloc_text(PAGE,CmQueryRegistryQuotaInformation)
#pragma alloc_text(PAGE,CmSetRegistryQuotaInformation)
#pragma alloc_text(PAGE,CmpCanGrowSystemHive)
#pragma alloc_text(PAGE,CmpSystemQuotaWarningWorker)
#pragma alloc_text(INIT,CmpComputeGlobalQuotaAllowed)
#pragma alloc_text(PAGE,CmpSystemHiveHysteresisWorker)
#pragma alloc_text(PAGE,CmpUpdateSystemHiveHysteresis)
#pragma alloc_text(PAGE,CmRegisterSystemHiveLimitCallback)
#pragma alloc_text(PAGE,CmpRaiseSelfHealWarning)
#pragma alloc_text(PAGE,CmpRaiseSelfHealWarningForSystemHives)
#pragma alloc_text(PAGE,CmpRaiseSelfHealWarningWorker)
#endif

//
// Registry control values
//
#define CM_DEFAULT_RATIO            (3)
#define CM_LIMIT_RATIO(x)           ((x / 10) * 8)
#define CM_MINIMUM_GLOBAL_QUOTA     (16 *1024 * 1024)

//
// Percent of used registry quota that triggers a hard error
// warning popup.
//
#define CM_REGISTRY_WARNING_LEVEL   (95)

//
// System hive hard quota limit
//
// For an x86 3GB system we set the limit at 12MB for now. Needs some MM changes before we 
// bump this up.
// For an x86 non-3GB system, we set the limit at 1/4 of physical memory
// For IA-64 we set the limit at 32MB
//

#define _200MB (200 *1024 * 1024) 

#if defined(_X86_)
#define CM_SYSTEM_HIVE_LIMIT_SIZE       (min(MmNumberOfPhysicalPages / 4, _200MB >> PAGE_SHIFT) * PAGE_SIZE)
#else
#define CM_SYSTEM_HIVE_LIMIT_SIZE       (32 * 1024 * 1024)
#endif

#define CM_SYSTEM_HIVE_WARNING_SIZE     ((CM_SYSTEM_HIVE_LIMIT_SIZE*9)/10)


extern ULONG CmRegistrySizeLimit;
extern ULONG CmRegistrySizeLimitLength;
extern ULONG CmRegistrySizeLimitType;

//
// Maximum number of bytes of Global Quota the registry may use.
// Set to largest positive number for use in boot.  Will be set down
// based on pool and explicit registry values.
//
extern SIZE_T  CmpGlobalQuota;
extern SIZE_T  CmpGlobalQuotaAllowed;

//
// Mark that will trigger the low-on-quota popup
//
extern SIZE_T  CmpGlobalQuotaWarning;
extern SIZE_T MmSizeOfPagedPoolInBytes;

//
// Indicate whether the popup has been triggered yet or not.
//
extern BOOLEAN CmpQuotaWarningPopupDisplayed;
extern BOOLEAN CmpSystemQuotaWarningPopupDisplayed;

//
// GQ actually in use
//
extern SIZE_T  CmpGlobalQuotaUsed;

extern  HIVE_LIST_ENTRY CmpMachineHiveList[];

VOID
CmQueryRegistryQuotaInformation(
    __inout PSYSTEM_REGISTRY_QUOTA_INFORMATION RegistryQuotaInformation
    )

/*++

Routine Description:

    Returns the registry quota information

Arguments:

    RegistryQuotaInformation - Supplies pointer to buffer that will return
        the registry quota information.

Return Value:

    None.

--*/

{
    RegistryQuotaInformation->RegistryQuotaAllowed  = (ULONG) CmpGlobalQuota;
    RegistryQuotaInformation->RegistryQuotaUsed     = (ULONG) CmpGlobalQuotaUsed;
    RegistryQuotaInformation->PagedPoolSize         = MmSizeOfPagedPoolInBytes;
}


VOID
CmSetRegistryQuotaInformation(
    __in PSYSTEM_REGISTRY_QUOTA_INFORMATION RegistryQuotaInformation
    )

/*++

Routine Description:

    Sets the registry quota information.  The caller is assumed to have
    completed the necessary security checks already.

Arguments:

    RegistryQuotaInformation - Supplies pointer to buffer that provides
        the new registry quota information.

Return Value:

    None.

--*/

{
    CmpGlobalQuota = RegistryQuotaInformation->RegistryQuotaAllowed;

    //
    // Sanity checks against insane values
    //
    if (CmpGlobalQuota > CM_WRAP_LIMIT) {
        CmpGlobalQuota = CM_WRAP_LIMIT;
    }
    if (CmpGlobalQuota < CM_MINIMUM_GLOBAL_QUOTA) {
        CmpGlobalQuota = CM_MINIMUM_GLOBAL_QUOTA;
    }

    //
    // Recompute the warning level
    //
    CmpGlobalQuotaWarning = CM_REGISTRY_WARNING_LEVEL * (CmpGlobalQuota / 100);

    CmpGlobalQuotaAllowed = CmpGlobalQuota;
}

VOID
CmpQuotaWarningWorker(
    IN PVOID WorkItem
    )

/*++

Routine Description:

    Displays hard error popup that indicates the registry quota is
    running out.

Arguments:

    WorkItem - Supplies pointer to the work item. This routine will
               free the work item.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    ULONG Response;

    ExFreePool(WorkItem);

    Status = ExRaiseHardError(STATUS_REGISTRY_QUOTA_LIMIT,
                              0,
                              0,
                              NULL,
                              OptionOk,
                              &Response);
}


BOOLEAN
CmpClaimGlobalQuota(
    IN ULONG    Size
    )
/*++

Routine Description:

    If CmpGlobalQuotaUsed + Size >= CmpGlobalQuotaAllowed, return
    false.  Otherwise, increment CmpGlobalQuotaUsed, in effect claiming
    the requested GlobalQuota.

Arguments:

    Size - number of bytes of GlobalQuota caller wants to claim

Return Value:

    TRUE - Claim succeeded, and has been counted in Used GQ

    FALSE - Claim failed, nothing counted in GQ.

--*/
{
    InterlockedExchangeAdd((PLONG)&CmpGlobalQuotaUsed, Size);

    return TRUE;
}


VOID
CmpReleaseGlobalQuota(
    IN ULONG    Size
    )
/*++

Routine Description:

    If Size <= CmpGlobalQuotaUsed, then decrement it.  Else BugCheck.

Arguments:

    Size - number of bytes of GlobalQuota caller wants to release

Return Value:

    NONE.

--*/
{
    if (Size > CmpGlobalQuotaUsed) {
        CM_BUGCHECK(REGISTRY_ERROR,QUOTA_ERROR,1,0,0);
    }

    InterlockedExchangeAdd((PLONG)&CmpGlobalQuotaUsed, -(LONG)Size);
}


VOID
CmpComputeGlobalQuotaAllowed(
    VOID
    )

/*++

Routine Description:

    Compute CmpGlobalQuota based on:
        (a) Size of paged pool
        (b) Explicit user registry commands to set registry GQ

Return Value:

    NONE.

--*/

{
    SIZE_T   PagedLimit;

    PagedLimit = (ULONG)(CM_LIMIT_RATIO(MmSizeOfPagedPoolInBytes));

    if ((CmRegistrySizeLimitLength != 4) ||
        (CmRegistrySizeLimitType != REG_DWORD) ||
        (CmRegistrySizeLimit == 0))
    {
        //
        // If no value at all, or value of wrong type, or set to
        // zero, use internally computed default
        //
        CmpGlobalQuota = (ULONG)(MmSizeOfPagedPoolInBytes / CM_DEFAULT_RATIO);

    } else if (CmRegistrySizeLimit >= PagedLimit) {
        //
        // If more than computed upper bound, use computed upper bound
        //
        CmpGlobalQuota = PagedLimit;

    } else {
        //
        // Use the set size
        //
        CmpGlobalQuota = CmRegistrySizeLimit;

    }

    if (CmpGlobalQuota > CM_WRAP_LIMIT) {
        CmpGlobalQuota = CM_WRAP_LIMIT;
    }
    if (CmpGlobalQuota < CM_MINIMUM_GLOBAL_QUOTA) {
        CmpGlobalQuota = CM_MINIMUM_GLOBAL_QUOTA;
    }

    CmpGlobalQuotaWarning = CM_REGISTRY_WARNING_LEVEL * (CmpGlobalQuota / 100);

    return;
}


VOID
CmpSetGlobalQuotaAllowed(
    VOID
    )
/*++

Routine Description:

    Enables registry quota

    NOTE:   Do NOT put this in init segment, we call it after
            that code has been freed!

Return Value:

    NONE.

--*/
{
     CmpGlobalQuotaAllowed = CmpGlobalQuota;
}


BOOLEAN
CmpCanGrowSystemHive(
                     IN PHHIVE  Hive,
                     IN ULONG   NewLength
                     )

/*++

Routine Description:

    Checks if the system hive is allowed to grow with the specified amount
    of data (using the hard quota limit on the system hive)

Return Value:

    NONE.

--*/
{
    PCMHIVE             CmHive;
    PWORK_QUEUE_ITEM    WorkItem;

    PAGED_CODE();

    CmHive = (PCMHIVE)CONTAINING_RECORD(Hive,CMHIVE,Hive);
    
    if( CmHive != CmpMachineHiveList[SYSTEM_HIVE_INDEX].CmHive ) {
        //
        // not the system hive, bail out
        //
        return TRUE;
    }

    // account for the header.
    NewLength += HBLOCK_SIZE;
    if( NewLength > CM_SYSTEM_HIVE_LIMIT_SIZE ) {
        //
        // this is bad; we may not be able to boot next time !!!
        //
        return FALSE;
    }

    if( (NewLength > CM_SYSTEM_HIVE_WARNING_SIZE) && 
        (!CmpSystemQuotaWarningPopupDisplayed) &&
        (ExReadyForErrors)
      ) {
        //
        // we're above the warning level, queue work item to display popup
        //
        WorkItem = ExAllocatePool(NonPagedPool, sizeof(WORK_QUEUE_ITEM));
        if (WorkItem != NULL) {

            CmpSystemQuotaWarningPopupDisplayed = TRUE;
            ExInitializeWorkItem(WorkItem,
                                 CmpSystemQuotaWarningWorker,
                                 WorkItem);
            ExQueueWorkItem(WorkItem, DelayedWorkQueue);
        }

    }

    return TRUE;
}


VOID
CmpSystemQuotaWarningWorker(
    IN PVOID WorkItem
    )

/*++

Routine Description:

    Displays hard error popup that indicates the hard quota limit
    on the system hive is running out.

Arguments:

    WorkItem - Supplies pointer to the work item. This routine will
               free the work item.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    ULONG Response;

    ExFreePool(WorkItem);

    Status = ExRaiseHardError(STATUS_REGISTRY_QUOTA_LIMIT,
                              0,
                              0,
                              NULL,
                              OptionOk,
                              &Response);
}

//
// Pnp API 
//
ULONG                       CmpSystemHiveHysteresisLow = 0;
ULONG                       CmpSystemHiveHysteresisHigh = 0;
PVOID                       CmpSystemHiveHysteresisContext = NULL;
PCM_HYSTERESIS_CALLBACK     CmpSystemHiveHysteresisCallback = NULL;
ULONG                       CmpSystemHiveHysteresisHitRatio = 0;
BOOLEAN                     CmpSystemHiveHysteresisLowSeen = FALSE;
BOOLEAN                     CmpSystemHiveHysteresisHighSeen = FALSE;

VOID
CmpSystemHiveHysteresisWorker(
    IN PVOID WorkItem
    )

/*++

Routine Description:

    Calls the hysteresis callback

Arguments:

    WorkItem - Supplies pointer to the work item. This routine will
               free the work item.

Return Value:

    None.

--*/

{
    PCM_HYSTERESIS_CALLBACK   Callback;

    ExFreePool(WorkItem);

    Callback = CmpSystemHiveHysteresisCallback;

    if( Callback ) {
        (*Callback)(CmpSystemHiveHysteresisContext,CmpSystemHiveHysteresisHitRatio);
    }
}


VOID
CmpUpdateSystemHiveHysteresis(  PHHIVE  Hive,
                                ULONG   NewLength,
                                ULONG   OldLength
                                )
{
    PCMHIVE             CmHive;
    PWORK_QUEUE_ITEM    WorkItem;
    ULONG               CurrentRatio;
    BOOLEAN             DoWorkItem = FALSE;

    PAGED_CODE();

    CmHive = (PCMHIVE)CONTAINING_RECORD(Hive,CMHIVE,Hive);
    
    if( (!CmpSystemHiveHysteresisCallback) || (CmHive != CmpMachineHiveList[SYSTEM_HIVE_INDEX].CmHive) ) {
        //
        // not the system hive, bail out
        //
        return;
    }

    ASSERT( NewLength != OldLength );

    //
    // compute current ratio; account for the header first
    //
    CurrentRatio = NewLength + HBLOCK_SIZE;
    CurrentRatio *= 100;
    CurrentRatio /= CM_SYSTEM_HIVE_LIMIT_SIZE;

    if( NewLength > OldLength ) {
        //
        // hive is growing
        //
        if( (CmpSystemHiveHysteresisHighSeen == FALSE) && (CurrentRatio > CmpSystemHiveHysteresisHigh) ) {
            //
            // we reached high; see if low has already been hit and queue work item
            //
            CmpSystemHiveHysteresisHighSeen = TRUE;
            if( TRUE == CmpSystemHiveHysteresisLowSeen ) {
                //
                // low to high; queue workitem
                //
                CmpSystemHiveHysteresisHitRatio = CurrentRatio;
                DoWorkItem = TRUE;
            }
        }
    } else {
        //
        // hive is shrinking
        //
        if( (FALSE == CmpSystemHiveHysteresisLowSeen) && (CurrentRatio < CmpSystemHiveHysteresisLow ) ) {
            //
            // we reached low; see if low has been hit and queue work item
            //
            CmpSystemHiveHysteresisLowSeen = TRUE;
            if( TRUE == CmpSystemHiveHysteresisHighSeen ) {
                //
                // high to low; queue workitem
                //
                CmpSystemHiveHysteresisHitRatio = CurrentRatio;
                DoWorkItem = TRUE;
            }
        }
    }

    if( DoWorkItem ) {
        ASSERT( CmpSystemHiveHysteresisLowSeen && CmpSystemHiveHysteresisHighSeen );

        WorkItem = ExAllocatePool(NonPagedPool, sizeof(WORK_QUEUE_ITEM));
        if (WorkItem != NULL) {

            ExInitializeWorkItem(WorkItem,
                                 CmpSystemHiveHysteresisWorker,
                                 WorkItem);
            ExQueueWorkItem(WorkItem, DelayedWorkQueue);
        }
        //
        // reset state so we can fire again later
        //
        CmpSystemHiveHysteresisLowSeen = FALSE;
        CmpSystemHiveHysteresisHighSeen = FALSE;
    }
}

ULONG
CmRegisterSystemHiveLimitCallback(
                                __in ULONG Low,
                                __in ULONG High,
                                __in PVOID Ref,
                                __in PCM_HYSTERESIS_CALLBACK Callback
                                )
/*++

Routine Description:

    This routine registers a hysteresis for the system hive limit ratio.
    We will call the callback :

    a. the system hive goes above High from below Low
    b. the system hive goes below Low from above High

Arguments:

    Low, High - specifies the hysteresis

    Ref - Context to give back to the callback

    Callback - callback routine.

Return Value:

    current ratio 0 - 100

--*/
{
    ULONG               Length;

    PAGED_CODE();

    if( CmpMachineHiveList[SYSTEM_HIVE_INDEX].CmHive ) {
        Length = CmpMachineHiveList[SYSTEM_HIVE_INDEX].CmHive->Hive.BaseBlock->Length + HBLOCK_SIZE;

        Length *= 100;
        Length /= CM_SYSTEM_HIVE_LIMIT_SIZE;
    } else {
        Length = 0;
    }

    //
    // allow only one call per system uptime.
    //
    if( CmpSystemHiveHysteresisCallback == NULL ) {
        CmpSystemHiveHysteresisLow = Low;
        CmpSystemHiveHysteresisHigh = High;
        CmpSystemHiveHysteresisContext = Ref;
        CmpSystemHiveHysteresisCallback = Callback;
        //
        // set state vars
        //
        if( Length <= Low ) {
            CmpSystemHiveHysteresisLowSeen = TRUE;
        } else {
            CmpSystemHiveHysteresisLowSeen = FALSE;
        }
        if( Length >= High) {
            CmpSystemHiveHysteresisHighSeen = TRUE;
        } else {
            CmpSystemHiveHysteresisHighSeen = FALSE;
        }
    }
    return Length;
}


VOID 
CmpHysteresisTest(PVOID Ref, ULONG Level)
{
    UNREFERENCED_PARAMETER (Ref);

    DbgPrint("CmpHysteresisTest called with level = %lu \n",Level);
}

LIST_ENTRY	    CmpSelfHealQueueListHead;
KGUARDED_MUTEX	CmpSelfHealQueueLock;
BOOLEAN		    CmpSelfHealWorkerActive = FALSE;

#define LOCK_SELF_HEAL_QUEUE() KeAcquireGuardedMutex(&CmpSelfHealQueueLock)
#define UNLOCK_SELF_HEAL_QUEUE() KeReleaseGuardedMutex(&CmpSelfHealQueueLock)

typedef struct {
    PWORK_QUEUE_ITEM    WorkItem;
	LIST_ENTRY			SelfHealQueueListEntry;
    UNICODE_STRING      HiveName;
    //
    // variable length; name goes here
    //
} CM_SELF_HEAL_WORK_ITEM_PARAMETER, *PCM_SELF_HEAL_WORK_ITEM_PARAMETER;

VOID
CmpRaiseSelfHealWarningWorker(
    IN PVOID Arg
    )
{
    PVOID                               ErrorParameters;
    ULONG                               ErrorResponse;
    PCM_SELF_HEAL_WORK_ITEM_PARAMETER   Param;

    Param = (PCM_SELF_HEAL_WORK_ITEM_PARAMETER)Arg;
    ErrorParameters = &(Param->HiveName);
    ExRaiseHardError(
        STATUS_REGISTRY_HIVE_RECOVERED,
        1,
        1,
        (PULONG_PTR)&ErrorParameters,
        OptionOk,
        &ErrorResponse
        );

    //
    // free what we have allocated
    //
    ExFreePool(Param->WorkItem);
    ExFreePool(Param);
	
	//
	// see if there are other self heal warnings to be posted.
	//
	LOCK_SELF_HEAL_QUEUE();
	CmpSelfHealWorkerActive = FALSE;
	if( IsListEmpty(&CmpSelfHealQueueListHead) == FALSE ) {
		//
		// remove head and queue it.
		//
        Param = (PCM_SELF_HEAL_WORK_ITEM_PARAMETER)RemoveHeadList(&CmpSelfHealQueueListHead);
        Param = CONTAINING_RECORD(
                        Param,
                        CM_SELF_HEAL_WORK_ITEM_PARAMETER,
                        SelfHealQueueListEntry
                        );
		ExQueueWorkItem(Param->WorkItem, DelayedWorkQueue);
		CmpSelfHealWorkerActive = TRUE;
	} 
	UNLOCK_SELF_HEAL_QUEUE();
}

VOID 
CmpRaiseSelfHealWarning( 
                        IN PUNICODE_STRING  HiveName
                        )
/*++

Routine Description:

    Raise a hard error informing the use the specified hive has been self healed and
    it might not be entirely consitent

Arguments:

    Parameter - the hive name.

Return Value:

    None.

--*/
{
    PCM_SELF_HEAL_WORK_ITEM_PARAMETER   Param;

    PAGED_CODE();

    //
    // we're above the warning level, queue work item to display popup
    //
    Param = ExAllocatePool(NonPagedPool, sizeof(CM_SELF_HEAL_WORK_ITEM_PARAMETER) + HiveName->Length);
    if( Param ) {
        Param->WorkItem = ExAllocatePool(NonPagedPool, sizeof(WORK_QUEUE_ITEM));
        if(Param->WorkItem != NULL) {
            Param->HiveName.Length = Param->HiveName.MaximumLength = HiveName->Length;
            Param->HiveName.Buffer = (PWSTR)(((PUCHAR)Param) + sizeof(CM_SELF_HEAL_WORK_ITEM_PARAMETER));
            RtlCopyMemory(Param->HiveName.Buffer,HiveName->Buffer,HiveName->Length);
            ExInitializeWorkItem(Param->WorkItem,
                                 CmpRaiseSelfHealWarningWorker,
                                 Param);
			LOCK_SELF_HEAL_QUEUE();
			if( !CmpSelfHealWorkerActive ) {
				//
				// no work item currently; ok to queue one.
				//
				ExQueueWorkItem(Param->WorkItem, DelayedWorkQueue);
				CmpSelfHealWorkerActive = TRUE;
			} else {
				//
				// add it to the end of the list. It'll be picked up when the current work item 
				// completes
				//
				InsertTailList(
					&CmpSelfHealQueueListHead,
					&(Param->SelfHealQueueListEntry)
					);
			}
			UNLOCK_SELF_HEAL_QUEUE();
        } else {
            ExFreePool(Param);
        }
    }
}

VOID 
CmpRaiseSelfHealWarningForSystemHives( )
/*++

Routine Description:

    Walks the system hivelist and raises a hard error in the event one of the hives has been self healed.

    Intended to be called after controlset has been saved, from inside NtInitializeRegistry
    (i.e. we have an UI available so it will not stop the machine).

Arguments:

Return Value:

    None.

--*/
{
    ULONG           i;
    UNICODE_STRING  Name;

    PAGED_CODE();

	for (i = 0; i < CM_NUMBER_OF_MACHINE_HIVES; i++) {
        if( !(CmpMachineHiveList[i].HHiveFlags & HIVE_VOLATILE) && (((PHHIVE)(CmpMachineHiveList[i].CmHive2))->BaseBlock->BootType & HBOOT_SELFHEAL) ) {
            RtlInitUnicodeString(
                &Name,
                CmpMachineHiveList[i].Name
                );
            CmpRaiseSelfHealWarning( &Name );
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmhvlist.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmhvlist.c

Abstract:

    Code to maintain registry node that lists where the roots of
    hives are and what files they map to.

--*/

#include "cmp.h"

#define HIVE_LIST L"\\registry\\machine\\system\\currentcontrolset\\control\\hivelist"

BOOLEAN
CmpGetHiveName(
    PCMHIVE         CmHive,
    PUNICODE_STRING HiveName
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpAddToHiveFileList)
#pragma alloc_text(PAGE,CmpRemoveFromHiveFileList)
#pragma alloc_text(PAGE,CmpGetHiveName)
#endif


NTSTATUS
CmpAddToHiveFileList(
    PCMHIVE CmHive
    )
/*++

Routine Description:

    Add Hive to list of hives and their files in
    \registry\machine\system\currentcontrolset\control\hivelist

Arguments:

    HivePath - path to root of hive (e.g. \registry\machine\system)

    CmHive - pointer to CM_HIVE structure for hive.

Return Value:

    ntstatus

--*/
{
#define NAME_BUFFER_SIZE    512
    OBJECT_ATTRIBUTES   ObjectAttributes;
    HANDLE              KeyHandle;
    NTSTATUS            Status;
    PUCHAR              Buffer;
    ULONG               Length;
    PWSTR               FilePath;
    WCHAR               UnicodeNull=UNICODE_NULL;
    UNICODE_STRING      TempName;
    UNICODE_STRING      HivePath;

    //
    // create/open the hive list key
    //
    RtlInitUnicodeString(
        &TempName,
        HIVE_LIST
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &TempName,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        NULL
        );

    Status = ZwCreateKey(
                &KeyHandle,
                KEY_READ | KEY_WRITE,
                &ObjectAttributes,
                0,
                NULL,
                REG_OPTION_VOLATILE,
                NULL
                );

    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpAddToHiveFileList: "));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"Create/Open of Hive list failed status = %08lx\n", Status));
        return Status;
    }

    //
    // allocate work buffers
    //
    Buffer = ExAllocatePool(PagedPool, NAME_BUFFER_SIZE + sizeof(WCHAR));
    if (Buffer == NULL) {
        NtClose(KeyHandle);
        return STATUS_NO_MEMORY;
    }

    //
    // compute name of hive
    //
    if (! CmpGetHiveName(CmHive, &HivePath)) {
        NtClose(KeyHandle);
        ExFreePool(Buffer);
        return STATUS_NO_MEMORY;
    }


    //
    // get name of file
    //
    if (!(CmHive->Hive.HiveFlags & HIVE_VOLATILE)) {
        Status = ZwQueryObject(
                    CmHive->FileHandles[HFILE_TYPE_PRIMARY],
                    ObjectNameInformation,
                    (PVOID)Buffer,
                    NAME_BUFFER_SIZE,
                    &Length
                    );
        Length -= sizeof(UNICODE_STRING);
        if (!NT_SUCCESS(Status)) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpAddToHiveFileList: "));
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"Query of name2 failed status = %08lx\n", Status));
            NtClose(KeyHandle);
            ExFreePool(HivePath.Buffer);
            ExFreePool(Buffer);
            return  Status;
        }
        FilePath = ((POBJECT_NAME_INFORMATION)Buffer)->Name.Buffer;
        FilePath[Length/sizeof(WCHAR)] = UNICODE_NULL;
        Length+=sizeof(WCHAR);
    } else {
        FilePath = &UnicodeNull;
        Length = sizeof(UnicodeNull);
    }

    //
    // set entry in list
    //
    Status = ZwSetValueKey(
                KeyHandle,
                &HivePath,
                0,
                REG_SZ,
                FilePath,
                Length
                );
    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpAddToHiveFileList: "));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"Set of entry in Hive list failed status = %08lx\n", Status));
    }

    NtClose(KeyHandle);
    ExFreePool(HivePath.Buffer);
    ExFreePool(Buffer);
    return  Status;
}


VOID
CmpRemoveFromHiveFileList(
    PUNICODE_STRING  EntryName
    )
/*++

Routine Description:

    Remove hive name from hive file list key

Arguments:

    CmHive - pointer to CM_HIVE structure for hive.

Return Value:

    ntstatus

--*/
{
    NTSTATUS        Status;
    UNICODE_STRING  TempName;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    HANDLE          KeyHandle;

    //
    // open the hive list key
    //
    RtlInitUnicodeString(
        &TempName,
        HIVE_LIST
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &TempName,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        NULL
        );

    Status = ZwOpenKey(
                &KeyHandle,
                KEY_READ | KEY_WRITE,
                &ObjectAttributes
                );

    if (!NT_SUCCESS(Status)) {
        return;
    }

    ZwDeleteValueKey(KeyHandle, EntryName);

    NtClose(KeyHandle);

    return;
}


BOOLEAN
CmpGetHiveName(
    PCMHIVE         CmHive,
    PUNICODE_STRING HiveName
    )
/*++

Routine Description:

    Compute full path to a hive.

Arguments:

    CmHive - pointer to CmHive structure

    HiveName - supplies pointer to unicode string structure that
                 will be filled in with pointer to name.

                CALL IS EXPECTED TO FREE BUFFER

Return Value:

    TRUE = it worked, FALSE = it failed (memory)

--*/
{
    HCELL_INDEX     RootCell;
    HCELL_INDEX     LinkCell;
    PCM_KEY_NODE    LinkKey;
    PCM_KEY_NODE    LinkParent;
    SIZE_T          size;
    SIZE_T          rsize;
    ULONG           KeySize;
    ULONG           ParentSize;
    PWCHAR          p;
    PCM_KEY_NODE    EntryKey;

    //
    // First find the link cell.
    //
    RootCell = CmHive->Hive.BaseBlock->RootCell;
    EntryKey = (PCM_KEY_NODE)HvGetCell((PHHIVE)CmHive, RootCell);
    if( EntryKey == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //
        return FALSE;
    }
    LinkCell = EntryKey->Parent;
    HvReleaseCell((PHHIVE)CmHive, RootCell);

    // for master we don't need to count cell usage
    ASSERT( ((PHHIVE)CmpMasterHive)->ReleaseCellRoutine == NULL );
    //
    // Compute the value entry name, which is of the form:
    //      \registry\<parent of link node name>\<link node name>
    //
    LinkKey = (PCM_KEY_NODE)HvGetCell((PHHIVE)CmpMasterHive, LinkCell);
    if( LinkKey == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //
        return FALSE;
    }
    LinkParent = (PCM_KEY_NODE)HvGetCell(
                                (PHHIVE)CmpMasterHive,
                                LinkKey->Parent
                                );
    if( LinkParent == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //
        return FALSE;
    }
    rsize = wcslen(L"\\REGISTRY\\");

    KeySize = CmpHKeyNameLen(LinkKey);
    ParentSize = CmpHKeyNameLen(LinkParent);
    size = KeySize + ParentSize +
           (rsize * sizeof(WCHAR)) + sizeof(WCHAR);

    HiveName->Buffer = ExAllocatePool(PagedPool, size);
    if (HiveName->Buffer == NULL) {
        return FALSE;
    }

#pragma prefast(suppress:12005, "no overflow. size is bounded by max key length (512)")
    HiveName->Length = (USHORT)size;
    HiveName->MaximumLength = (USHORT)size;
    p = HiveName->Buffer;

    RtlCopyMemory(
        (PVOID)p,
        (PVOID)L"\\REGISTRY\\",
        rsize * sizeof(WCHAR)
        );
    p += rsize;

    if (LinkParent->Flags & KEY_COMP_NAME) {
        CmpCopyCompressedName(p,
                              ParentSize,
                              LinkParent->Name,
                              LinkParent->NameLength);
    } else {
        RtlCopyMemory(
            (PVOID)p,
            (PVOID)&(LinkParent->Name[0]),
            ParentSize
            );
    }

    p += ParentSize / sizeof(WCHAR);

    *p = OBJ_NAME_PATH_SEPARATOR;
    p++;

    if (LinkKey->Flags & KEY_COMP_NAME) {
        CmpCopyCompressedName(p,
                              KeySize,
                              LinkKey->Name,
                              LinkKey->NameLength);

    } else {
        RtlCopyMemory(
            (PVOID)p,
            (PVOID)&(LinkKey->Name[0]),
            KeySize
            );
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmhook.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmhook.c

Abstract:

    Provides routines for implementing callbacks into the registry code.
    Callbacks are to be used by the virus filter drivers and cluster 
    replication engine.

--*/
#include "cmp.h"

#define CM_MAX_CALLBACKS    100

typedef struct _CM_CALLBACK_CONTEXT_BLOCK {
    LARGE_INTEGER               Cookie;             // to identify a specific callback for deregistration purposes
    LIST_ENTRY                  ThreadListHead;     // Active threads inside this callback
    EX_PUSH_LOCK                ThreadListLock;     // synchronize access to the above
    PVOID                       CallerContext;
} CM_CALLBACK_CONTEXT_BLOCK, *PCM_CALLBACK_CONTEXT_BLOCK;

typedef struct _CM_ACTIVE_NOTIFY_THREAD {
    LIST_ENTRY  ThreadList;
    PETHREAD    Thread;
} CM_ACTIVE_NOTIFY_THREAD, *PCM_ACTIVE_NOTIFY_THREAD;

#define CmpLockContext(Context)    ExAcquirePushLockExclusive(&((Context)->ThreadListLock))
#define CmpUnlockContext(Context)  ExReleasePushLock(&((Context)->ThreadListLock))


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif

ULONG       CmpCallBackCount = 0;
EX_CALLBACK CmpCallBackVector[CM_MAX_CALLBACKS] = {0};

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

VOID
CmpInitCallback(VOID);

BOOLEAN
CmpCheckRecursionAndRecordThreadInfo(
                                     PCM_CALLBACK_CONTEXT_BLOCK         CallbackBlock,
                                     PCM_ACTIVE_NOTIFY_THREAD   ActiveThreadInfo
                                     );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmRegisterCallback)
#pragma alloc_text(PAGE,CmUnRegisterCallback)
#pragma alloc_text(PAGE,CmpInitCallback)
#pragma alloc_text(PAGE,CmpCallCallBacks)
#pragma alloc_text(PAGE,CmpCheckRecursionAndRecordThreadInfo)
#endif


NTSTATUS
CmRegisterCallback(__in     PEX_CALLBACK_FUNCTION Function,
                   __in_opt PVOID                 Context,
                   __out    PLARGE_INTEGER    Cookie
                    )
/*++

Routine Description:

    Registers a new callback.

Arguments:



Return Value:


--*/
{
    PEX_CALLBACK_ROUTINE_BLOCK  RoutineBlock;
    ULONG                       i;
    PCM_CALLBACK_CONTEXT_BLOCK  CmCallbackContext;

    PAGED_CODE();
    
    CmCallbackContext = (PCM_CALLBACK_CONTEXT_BLOCK)ExAllocatePoolWithTag (PagedPool,
                                                                    sizeof (CM_CALLBACK_CONTEXT_BLOCK),
                                                                    'bcMC');
    if( CmCallbackContext == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RoutineBlock = ExAllocateCallBack (Function,CmCallbackContext);
    if( RoutineBlock == NULL ) {
        ExFreePool(CmCallbackContext);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // init the context
    //
    KeQuerySystemTime(&(CmCallbackContext->Cookie));
    *Cookie = CmCallbackContext->Cookie;
    InitializeListHead(&(CmCallbackContext->ThreadListHead));   
	ExInitializePushLock(&(CmCallbackContext->ThreadListLock));
    CmCallbackContext->CallerContext = Context;

    //
    // find a spot where we could add this callback
    //
    for( i=0;i<CM_MAX_CALLBACKS;i++) {
        if( ExCompareExchangeCallBack (&CmpCallBackVector[i],RoutineBlock,NULL) ) {
            InterlockedExchangeAdd ((PLONG) &CmpCallBackCount, 1);
            return STATUS_SUCCESS;
        }
    }
    
    //
    // no more callbacks
    //
    ExFreePool(CmCallbackContext);
    ExFreeCallBack(RoutineBlock);
    return STATUS_INSUFFICIENT_RESOURCES;
}


NTSTATUS
CmUnRegisterCallback(__in LARGE_INTEGER  Cookie)
/*++

Routine Description:

    Unregisters a callback.

Arguments:

Return Value:


--*/
{
    ULONG                       i;
    PCM_CALLBACK_CONTEXT_BLOCK  CmCallbackContext;
    PEX_CALLBACK_ROUTINE_BLOCK  RoutineBlock;

    PAGED_CODE();
    
    //
    // Search for this cookie
    //
    for( i=0;i<CM_MAX_CALLBACKS;i++) {
        RoutineBlock = ExReferenceCallBackBlock(&(CmpCallBackVector[i]) );
        if( RoutineBlock  ) {
            CmCallbackContext = (PCM_CALLBACK_CONTEXT_BLOCK)ExGetCallBackBlockContext(RoutineBlock);
            if( CmCallbackContext && (CmCallbackContext->Cookie.QuadPart  == Cookie.QuadPart) ) {
                //
                // found it
                //
                if( ExCompareExchangeCallBack (&CmpCallBackVector[i],NULL,RoutineBlock) ) {
                    InterlockedExchangeAdd ((PLONG) &CmpCallBackCount, -1);
    
                    ExDereferenceCallBackBlock (&(CmpCallBackVector[i]),RoutineBlock);
                    //
                    // wait for others to release their reference, then tear down the structure
                    //
                    ExWaitForCallBacks (RoutineBlock);

                    ExFreePool(CmCallbackContext);
                    ExFreeCallBack(RoutineBlock);
                    return STATUS_SUCCESS;
                }

            } else {
                ExDereferenceCallBackBlock (&(CmpCallBackVector[i]),RoutineBlock);
            }
        }
            
    }

    return STATUS_INVALID_PARAMETER;
}

//
// Cm internals
//
NTSTATUS
CmpCallCallBacks (
    IN REG_NOTIFY_CLASS Type,
    IN PVOID            Argument,
    IN BOOLEAN          Wind,
    IN REG_NOTIFY_CLASS PostType,
    IN PVOID            Object
    )
/*++

Routine Description:

    This function calls the callback thats inside a callback structure

Arguments:

    Type - Nt call selector

    Argument - Caller provided argument to pass on (one of the REG_*_INFORMATION )

    Wind - tells if this is a pre or a post callback

    PostType - matching post notify class

    Object - to be used in case we fail part through.

Return Value:

    NTSTATUS - STATUS_SUCCESS or error status returned by the first callback

--*/
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    LONG                        i;
    LONG                        Direction;
    PEX_CALLBACK_ROUTINE_BLOCK  RoutineBlock;
    PCM_CALLBACK_CONTEXT_BLOCK  CmCallbackContext;
    BOOLEAN                     InternalUnWind = FALSE;

    PAGED_CODE();

    if( Wind == TRUE ) {
        Direction = 1;
        i = 0;
    } else {
        Direction = -1;
        i = CM_MAX_CALLBACKS - 1;
    }
    for(;(i >= 0) && (i < CM_MAX_CALLBACKS);i += Direction) {
        RoutineBlock = ExReferenceCallBackBlock(&(CmpCallBackVector[i]) );
        if( RoutineBlock != NULL ) {
            //
            // we have a safe reference on this block.
            //
            //
            // record thread on a stack struct, so we don't need to allocate pool for it. We unlink
            // it from our lists prior to this function exit, so we are on the safe side.
            //
            CM_ACTIVE_NOTIFY_THREAD ActiveThreadInfo;
            
            //
            // get context info
            //
            CmCallbackContext = (PCM_CALLBACK_CONTEXT_BLOCK)ExGetCallBackBlockContext(RoutineBlock);
            ASSERT( CmCallbackContext != NULL );

            ActiveThreadInfo.Thread = PsGetCurrentThread();
#if DBG
            InitializeListHead(&(ActiveThreadInfo.ThreadList));   
#endif //DBG

            if( CmpCheckRecursionAndRecordThreadInfo(CmCallbackContext,&ActiveThreadInfo) ) {
                if( InternalUnWind == TRUE ) {
                    //
                    // this is an internal unwind due to fail part through. need to call posts manually
                    //
                    REG_POST_OPERATION_INFORMATION PostInfo;
                    PostInfo.Object = Object;
                    PostInfo.Status = Status;
                    ExGetCallBackBlockRoutine(RoutineBlock)(CmCallbackContext->CallerContext,(PVOID)(ULONG_PTR)PostType,&PostInfo);
                    // ignore return status.
                } else {
                    //
                    // regular callback call
                    //
                    Status = ExGetCallBackBlockRoutine(RoutineBlock)(CmCallbackContext->CallerContext,(PVOID)(ULONG_PTR)Type,Argument);
                    if( Wind == FALSE ) {
                        //
                        // always ignore post return calls so they all get a chance to run
                        //
                        Status = STATUS_SUCCESS;
                    }
                }
                //
                // now that we're down, remove ourselves from the thread list
                //
                CmpLockContext(CmCallbackContext);
                RemoveEntryList(&(ActiveThreadInfo.ThreadList));
                CmpUnlockContext(CmCallbackContext);
            } else {
                ASSERT( IsListEmpty(&(ActiveThreadInfo.ThreadList)) );
            }

            ExDereferenceCallBackBlock (&(CmpCallBackVector[i]),RoutineBlock);

            if( !NT_SUCCESS(Status) ) {
                if( Wind == TRUE ) {
                    //
                    // switch direction and start calling the posts 
                    //
                    Wind = FALSE;
                    Direction *= -1;
                    InternalUnWind = TRUE;
                } else if( InternalUnWind == FALSE ) {
                    return Status;
                }
                //
                // else fall through so the unwind completes
                //
            }
        }
    }
    
    return Status;
}

VOID
CmpInitCallback(VOID)
/*++

Routine Description:

    Init the callback module

Arguments:



Return Value:


--*/
{
    ULONG   i;

    PAGED_CODE();
    
    CmpCallBackCount = 0;
    for( i=0;i<CM_MAX_CALLBACKS;i++) {
        ExInitializeCallBack (&(CmpCallBackVector[i]));
    }
}

BOOLEAN
CmpCheckRecursionAndRecordThreadInfo(
                                     PCM_CALLBACK_CONTEXT_BLOCK CallbackBlock,
                                     PCM_ACTIVE_NOTIFY_THREAD   ActiveThreadInfo
                                     )
/*++

Routine Description:

    Checks if current thread is already inside the callback (recursion avoidance)

Arguments:


Return Value:


--*/
{
    PLIST_ENTRY                 AnchorAddr;
    PCM_ACTIVE_NOTIFY_THREAD    CurrentThreadInfo;

    PAGED_CODE();

    CmpLockContext(CallbackBlock);
    //
	// walk the ActiveThreadList and see if we are already active
	//
	AnchorAddr = &(CallbackBlock->ThreadListHead);
	CurrentThreadInfo = (PCM_ACTIVE_NOTIFY_THREAD)(CallbackBlock->ThreadListHead.Flink);

	while ( CurrentThreadInfo != (PCM_ACTIVE_NOTIFY_THREAD)AnchorAddr ) {
		CurrentThreadInfo = CONTAINING_RECORD(
						                    CurrentThreadInfo,
						                    CM_ACTIVE_NOTIFY_THREAD,
						                    ThreadList
						                    );
		if( CurrentThreadInfo->Thread == ActiveThreadInfo->Thread ) {
			//
			// already there!
			//
            CmpUnlockContext(CallbackBlock);
            return FALSE;
		}
        //
        // skip to the next element
        //
        CurrentThreadInfo = (PCM_ACTIVE_NOTIFY_THREAD)(CurrentThreadInfo->ThreadList.Flink);
	}

    //
    // add this thread
    //
    InsertTailList(&(CallbackBlock->ThreadListHead), &(ActiveThreadInfo->ThreadList));
    CmpUnlockContext(CallbackBlock);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmindex.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmindex.c

Abstract:

    This module contains cm routines that understand the structure
    of child subkey indicies.

--*/

/* -

The Structure:

    Use a 1 or 2 level tree.  Leaf nodes are arrays of pointers to
    cells, sorted.  Binary search to find cell of interest.  Directory
    node (can be only one) is an array of pointers to leaf blocks.
    Do compare on last entry of each leaf block.

    One Level:

        Key--->+----+
               |    |
               |  x----------><key whose name is "apple", string in key>
               |    |
               +----+
               |    |
               |  x----------><as above, but key named "banana">
               |    |
               +----+
               |    |
               |    |
               |    |
               +----+
               |    |
               |    |
               |    |
               +----+
               |    |
               |  x----------><as above, but key named "zumwat">
               |    |
               +----+


    Two Level:

        Key--->+----+
               |    |    +-----+
               |  x----->|     |
               |    |    |  x----------------->"aaa"
               +----+    |     |
               |    |    +-----+
               |    |    |     |
               |    |    |     |
               +----+    |     |
               |    |    +-----+
               |    |    |     |
               |    |    |  x----------------->"abc"
               +----+    |     |
               |    |    +-----+
               |    |
               |    |
               +----+
               |    |    +-----+
               |  x----->|     |
               |    |    |  x----------------->"w"
               +----+    |     |
                         +-----+
                         |     |
                         |     |
                         |     |
                         +-----+
                         |     |
                         |  x----------------->"z"
                         |     |
                         +-----+


    Never more than two levels.

    Each block must fix in on HBLOCK_SIZE Cell.  Allows about 1000
    entries.  Max of 1 million total, best case.  Worst case something
    like 1/4 of that.

*/

#include    "cmp.h"

ULONG
CmpFindSubKeyInRoot(
    PHHIVE          Hive,
    PCM_KEY_INDEX   Index,
    PUNICODE_STRING SearchName,
    PHCELL_INDEX    Child
    );

ULONG
CmpFindSubKeyInLeaf(
    PHHIVE          Hive,
    PCM_KEY_INDEX   Index,
    PUNICODE_STRING SearchName,
    PHCELL_INDEX    Child
    );

LONG
CmpCompareInIndex(
    PHHIVE          Hive,
    PUNICODE_STRING SearchName,
    ULONG           Count,
    PCM_KEY_INDEX   Index,
    PHCELL_INDEX    Child
    );

LONG
CmpDoCompareKeyName(
    PHHIVE          Hive,
    PUNICODE_STRING SearchName,
    HCELL_INDEX     Cell
    );

HCELL_INDEX
CmpDoFindSubKeyByNumber(
    PHHIVE          Hive,
    PCM_KEY_INDEX   Index,
    ULONG           Number
    );

HCELL_INDEX
CmpAddToLeaf(
    PHHIVE          Hive,
    HCELL_INDEX     LeafCell,
    HCELL_INDEX     NewKey,
    PUNICODE_STRING NewName
    );

HCELL_INDEX
CmpSelectLeaf(
    PHHIVE          Hive,
    PCM_KEY_NODE    ParentKey,
    PUNICODE_STRING NewName,
    HSTORAGE_TYPE   Type,
    PHCELL_INDEX    *RootPointer
    );

HCELL_INDEX
CmpSplitLeaf(
    PHHIVE          Hive,
    HCELL_INDEX     RootCell,
    ULONG           RootSelect,
    HSTORAGE_TYPE   Type
    );

HCELL_INDEX
CmpFindSubKeyByHash(
    PHHIVE                  Hive,
    PCM_KEY_FAST_INDEX      FastIndex,
    PUNICODE_STRING         SearchName
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpFindSubKeyByName)
#pragma alloc_text(PAGE,CmpFindSubKeyInRoot)
#pragma alloc_text(PAGE,CmpFindSubKeyInLeaf)
#pragma alloc_text(PAGE,CmpDoCompareKeyName)
#pragma alloc_text(PAGE,CmpCompareInIndex)
#pragma alloc_text(PAGE,CmpFindSubKeyByNumber)
#pragma alloc_text(PAGE,CmpDoFindSubKeyByNumber)
#pragma alloc_text(PAGE,CmpAddSubKey)
#pragma alloc_text(PAGE,CmpAddToLeaf)
#pragma alloc_text(PAGE,CmpSelectLeaf)
#pragma alloc_text(PAGE,CmpSplitLeaf)
#pragma alloc_text(PAGE,CmpMarkIndexDirty)
#pragma alloc_text(PAGE,CmpRemoveSubKey)
#pragma alloc_text(PAGE,CmpComputeHashKey)
#pragma alloc_text(PAGE,CmpComputeHashKeyForCompressedName)
#pragma alloc_text(PAGE,CmpFindSubKeyByHash)
#pragma alloc_text(PAGE,CmpDuplicateIndex)
#pragma alloc_text(PAGE,CmpUpdateParentForEachSon)
#pragma alloc_text(PAGE,CmpRemoveSubKeyCellNoCellRef)
#endif


HCELL_INDEX
CmpFindSubKeyByName(
    PHHIVE          Hive,
    PCM_KEY_NODE    Parent,
    PUNICODE_STRING SearchName
    )
/*++

Routine Description:

    Find the child cell (either subkey or value) specified by name.

Arguments:

    Hive - pointer to hive control structure for hive of interest

    Parent - cell of key body which is parent of child of interest

    SearchName - name of child of interest

Return Value:

    Cell of matching child key, or HCELL_NIL if none.

--*/
{
    PCM_KEY_INDEX   IndexRoot;
    HCELL_INDEX     Child;
    ULONG           i;
    ULONG           FoundIndex;
    HCELL_INDEX     CellToRelease = HCELL_NIL;

    CM_PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INDEX,"CmpFindSubKeyByName:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INDEX,"Hive=%p Parent=%p SearchName=%p\n", Hive, Parent, SearchName));

    //
    // Try first the Stable, then the Volatile store.  Assumes that
    // all Volatile refs in Stable space are zeroed out at boot.
    //
    for (i = 0; i < Hive->StorageTypeCount; i++) {
        if (Parent->SubKeyCounts[i] != 0) {
            IndexRoot = (PCM_KEY_INDEX)HvGetCell(Hive, Parent->SubKeyLists[i]);
            ASSERT( (IndexRoot == NULL) || HvIsCellAllocated(Hive, Parent->SubKeyLists[i]) );
            if( IndexRoot == NULL ) {
                //
                // we couldn't map a view for the bin containing this cell
                //
                return HCELL_NIL;
            }
            CellToRelease = Parent->SubKeyLists[i];

            if (IndexRoot->Signature == CM_KEY_INDEX_ROOT) {
                if( INVALID_INDEX & CmpFindSubKeyInRoot(Hive, IndexRoot, SearchName, &Child) ) {
                    //
                    // couldn't map view inside
                    //
                    ASSERT( CellToRelease != HCELL_NIL );
                    HvReleaseCell(Hive,CellToRelease);
                    return HCELL_NIL;
                }

                ASSERT( CellToRelease != HCELL_NIL );
                HvReleaseCell(Hive,CellToRelease);

                if (Child == HCELL_NIL) {
                    continue;
                }
                IndexRoot = (PCM_KEY_INDEX)HvGetCell(Hive, Child);
                if( IndexRoot == NULL ) {
                    //
                    // we couldn't map a view for the bin containing this cell
                    //
                    return HCELL_NIL;
                }
                CellToRelease = Child;
            }
            ASSERT((IndexRoot->Signature == CM_KEY_INDEX_LEAF)  ||
                   (IndexRoot->Signature == CM_KEY_FAST_LEAF)   ||
                   (IndexRoot->Signature == CM_KEY_HASH_LEAF)
                   );


            if( IndexRoot->Signature == CM_KEY_HASH_LEAF ) {
                Child = CmpFindSubKeyByHash(Hive,(PCM_KEY_FAST_INDEX)IndexRoot,SearchName);
                ASSERT( CellToRelease != HCELL_NIL );
                HvReleaseCell(Hive,CellToRelease);
            } else {
                FoundIndex = CmpFindSubKeyInLeaf(Hive,
                                                 IndexRoot,
                                                 SearchName,
                                                 &Child);

                ASSERT( CellToRelease != HCELL_NIL );
                HvReleaseCell(Hive,CellToRelease);

                if( INVALID_INDEX & FoundIndex ) {
                    //
                    // couldn't map view
                    // 
                    return HCELL_NIL;
                }
            }

            if (Child != HCELL_NIL) {
                //
                // success
                //
                return Child;
            }
        }
    }
    return HCELL_NIL;
}


ULONG
CmpFindSubKeyInRoot(
    PHHIVE          Hive,
    PCM_KEY_INDEX   Index,
    PUNICODE_STRING SearchName,
    PHCELL_INDEX    Child
    )
/*++

Routine Description:

    Find the leaf index that would contain a key, if there is one.

Arguments:

    Hive - pointer to hive control structure for hive of interest

    Index - pointer to root index block

    SearchName - pointer to name of key of interest

    Child - pointer to variable to receive hcell_index of found leaf index
            block, HCELL_NIL if none.  Non nil does not necessarily mean
            the key is present, call FindSubKeyInLeaf to decide that.

Return Value:

    Index in List of last Leaf Cell entry examined.  If Child != HCELL_NIL,
    Index is entry that matched, else, index is for last entry we looked
    at.  (Target Leaf will be this value plus or minus 1)

    If an error appears while searching the subkey (i.e. a cell cannot be 
    mapped into memory) INVALID_INDEX is returned.

--*/
{
    ULONG           High;
    ULONG           Low;
    ULONG           CanCount;
    HCELL_INDEX     LeafCell;
    PCM_KEY_INDEX   Leaf;
    LONG            Result;
    ULONG           ReturnIndex = INVALID_INDEX;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INDEX,"CmpFindSubKeyInRoot:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INDEX,"Hive=%p Index=%p SearchName=%p\n",Hive,Index,SearchName));


    ASSERT(Index->Count != 0);
    ASSERT(Index->Signature == CM_KEY_INDEX_ROOT);

    High = Index->Count - 1;
    Low = 0;

    while (TRUE) {

        //
        // Compute where to look next, get correct pointer, do compare
        //
        CanCount = ((High-Low)/2)+Low;
        LeafCell = Index->List[CanCount];
        Leaf = (PCM_KEY_INDEX)HvGetCell(Hive, LeafCell);
        if( Leaf == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            *Child = HCELL_NIL;
            ReturnIndex = INVALID_INDEX;
            goto JustReturn;
        }

        ASSERT((Leaf->Signature == CM_KEY_INDEX_LEAF) ||
               (Leaf->Signature == CM_KEY_FAST_LEAF)  || 
               (Leaf->Signature == CM_KEY_HASH_LEAF)
               );
        ASSERT(Leaf->Count != 0);

        Result = CmpCompareInIndex(Hive,
                                   SearchName,
                                   Leaf->Count-1,
                                   Leaf,
                                   Child);

        if( Result == 2 ) {
            //
            // couldn't map view inside; bail out
            //
            *Child = HCELL_NIL;
            ReturnIndex = INVALID_INDEX;
            goto JustReturn;
        }
        if (Result == 0) {

            //
            // SearchName == KeyName of last key in leaf, so
            //  this is our leaf
            //
            *Child = LeafCell;
            ReturnIndex = CanCount;
            goto JustReturn;
        }

        if (Result < 0) {

            ASSERT( Result == -1 );
            //
            // SearchName < KeyName, so this may still be our leaf
            //
            Result = CmpCompareInIndex(Hive,
                                       SearchName,
                                       0,
                                       Leaf,
                                       Child);

            if( Result == 2 ) {
                //
                // couldn't map view inside; bail out
                //
                *Child = HCELL_NIL;
                ReturnIndex = INVALID_INDEX;
                goto JustReturn;
            }

            if (Result >= 0) {

                ASSERT( (Result == 1) || (Result == 0) );
                //
                // we know from above that SearchName is less than
                // last key in leaf.
                // since it is also >= first key in leaf, it must
                // reside in leaf somewhere, and we are done
                //
                *Child = LeafCell;
                ReturnIndex = CanCount;
                goto JustReturn;
            }

            High = CanCount;

        } else {

            //
            // SearchName > KeyName
            //
            Low = CanCount;
        }

        if ((High - Low) <= 1) {
            break;
        }
        HvReleaseCell(Hive, LeafCell);
    }

    HvReleaseCell(Hive, LeafCell);
    //
    // If we get here, High - Low = 1 or High == Low
    //
    ASSERT((High - Low == 1) || (High == Low));
    LeafCell = Index->List[Low];
    Leaf = (PCM_KEY_INDEX)HvGetCell(Hive, LeafCell);
    if( Leaf == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        *Child = HCELL_NIL;
        ReturnIndex = INVALID_INDEX;
        goto JustReturn;
    }
    Result = CmpCompareInIndex(Hive,
                               SearchName,
                               Leaf->Count-1,
                               Leaf,
                               Child);

    if( Result == 2 ) {
        //
        // couldn't map view inside; bail out
        //
        *Child = HCELL_NIL;
        ReturnIndex = INVALID_INDEX;
        goto JustReturn;
    }

    if (Result == 0) {

        //
        // found it
        //
        *Child = LeafCell;
        ReturnIndex = Low;
        goto JustReturn;
    }

    if (Result < 0) {

        ASSERT( Result == -1 );
        //
        // SearchName < KeyName, so this may still be our leaf
        //
        Result = CmpCompareInIndex(Hive,
                                   SearchName,
                                   0,
                                   Leaf,
                                   Child);

        if( Result == 2 ) {
            //
            // couldn't map view inside; bail out
            //
            *Child = HCELL_NIL;
            ReturnIndex = INVALID_INDEX;
            goto JustReturn;
        }

        if (Result >= 0) {

            ASSERT( (Result == 1) || (Result == 0) );
            //
            // we know from above that SearchName is less than
            // last key in leaf.
            // since it is also >= first key in leaf, it must
            // reside in leaf somewhere, and we are done
            //
            *Child = LeafCell;
            ReturnIndex = Low;
            goto JustReturn;
        }

        //
        // does not exist, but belongs in Low or Leaf below low
        //
        *Child = HCELL_NIL;
        ReturnIndex = Low;
        goto JustReturn;
    }

    HvReleaseCell(Hive, LeafCell);
    //
    // see if High matches
    //
    LeafCell = Index->List[High];
    Leaf = (PCM_KEY_INDEX)HvGetCell(Hive, LeafCell);
    if( Leaf == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        *Child = HCELL_NIL;
        ReturnIndex = INVALID_INDEX;
        goto JustReturn;
    }
    Result = CmpCompareInIndex(Hive,
                               SearchName,
                               Leaf->Count - 1,
                               Leaf,
                               Child);
    if( Result == 2 ) {
        //
        // couldn't map view inside; bail out
        //
        *Child = HCELL_NIL;
        ReturnIndex = INVALID_INDEX;
        goto JustReturn;
    }
    if (Result == 0) {

        //
        // found it
        //
        *Child = LeafCell;
        ReturnIndex = High;
        goto JustReturn;

    } else if (Result < 0) {

        ASSERT( Result == -1 );
        //
        // Clearly greater than low, or we wouldn't be here.
        // So regardless of whether it's below the start
        // of this leaf, it would be in this leaf if it were
        // where, so report this leaf.
        //
        *Child = LeafCell;
        ReturnIndex = High;
        goto JustReturn;

    }

    //
    // Off the high end
    //
    *Child = HCELL_NIL;
    ReturnIndex = High;

JustReturn:
    if(Leaf != NULL){
        HvReleaseCell(Hive, LeafCell);
    }
    return ReturnIndex;
}


ULONG
CmpFindSubKeyInLeaf(
    PHHIVE          Hive,
    PCM_KEY_INDEX   Index,
    PUNICODE_STRING SearchName,
    PHCELL_INDEX    Child
    )
/*++

Routine Description:

    Find a named key in a leaf index, if it exists. The supplied index
    may be either a fast index or a slow one.

Arguments:

    Hive - pointer to hive control structure for hive of interest

    Index - pointer to leaf block

    SearchName - pointer to name of key of interest

    Child - pointer to variable to receive hcell_index of found key
            HCELL_NIL if none found

Return Value:

    Index in List of last cell.  If Child != HCELL_NIL, is offset in
    list at which Child was found.  Else, is offset of last place
    we looked.

    INVALID_INDEX - resources problem; couldn't map view
--*/
{
    ULONG       High;
    ULONG       Low;
    ULONG       CanCount;
    LONG        Result;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INDEX,"CmpFindSubKeyInLeaf:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INDEX,"Hive=%p Index=%p SearchName=%p\n",Hive,Index,SearchName));

    ASSERT((Index->Signature == CM_KEY_INDEX_LEAF)  ||
           (Index->Signature == CM_KEY_FAST_LEAF)   ||
           (Index->Signature == CM_KEY_HASH_LEAF)
           );

    High = Index->Count - 1;
    Low = 0;
    CanCount = High/2;

    if (Index->Count == 0) {
        *Child = HCELL_NIL;
        return 0;
    }

    while (TRUE) {

        //
        // Compute where to look next, get correct pointer, do compare
        //
        Result = CmpCompareInIndex(Hive,
                                   SearchName,
                                   CanCount,
                                   Index,
                                   Child);

        if( Result == 2 ) {
            //
            // couldn't map view inside; bail out
            //
            *Child = HCELL_NIL;
            return INVALID_INDEX;
        }

        if (Result == 0) {

            //
            // SearchName == KeyName
            //
            return CanCount;
        }

        if (Result < 0) {

            ASSERT( Result == -1 );
            //
            // SearchName < KeyName
            //
            High = CanCount;

        } else {

            ASSERT( Result == 1 );
            //
            // SearchName > KeyName
            //
            Low = CanCount;
        }

        if ((High - Low) <= 1) {
            break;
        }
        CanCount = ((High-Low)/2)+Low;
    }

    //
    // If we get here, High - Low = 1 or High == Low
    // Simply look first at Low, then at High
    //
    Result = CmpCompareInIndex(Hive,
                               SearchName,
                               Low,
                               Index,
                               Child);
    if( Result == 2 ) {
        //
        // couldn't map view inside; bail out
        //
        *Child = HCELL_NIL;
        return INVALID_INDEX;
    }

    if (Result == 0) {

        //
        // found it
        //
        return Low;
    }

    if (Result < 0) {

        ASSERT( Result == -1 );
        //
        // does not exist, under
        //
        return Low;
    }

    //
    // see if High matches, we will return High as the
    // closest key regardless.
    //
    Result = CmpCompareInIndex(Hive,
                               SearchName,
                               High,
                               Index,
                               Child);
    if( Result == 2 ) {
        //
        // couldn't map view inside; bail out
        //
        *Child = HCELL_NIL;
        return INVALID_INDEX;
    }

    return High;
}


LONG
CmpCompareInIndex(
    PHHIVE          Hive,
    PUNICODE_STRING SearchName,
    ULONG           Count,
    PCM_KEY_INDEX   Index,
    PHCELL_INDEX    Child
    )
/*++

Routine Description:

    Do a compare of a name in an index. This routine handles both
    fast leafs and slow ones.

Arguments:

    Hive - pointer to hive control structure for hive of interest

    SearchName - pointer to name of key we are searching for

    Count - supplies index that we are searching at.

    Index - Supplies pointer to either a CM_KEY_INDEX or
            a CM_KEY_FAST_INDEX. This routine will determine which
            type of index it is passed.

    Child - pointer to variable to receive hcell_index of found key
            HCELL_NIL if result != 0

Return Value:

    0 = SearchName == KeyName (of Cell)

    -1 = SearchName < KeyName

    +1 = SearchName > KeyName

    +2 = Error, insufficient resources

--*/
{
    PCM_KEY_FAST_INDEX  FastIndex;
    LONG                Result;
    ULONG               i;
    WCHAR               c1;
    WCHAR               c2;
    ULONG               HintLength;
    ULONG               ValidChars;
    ULONG               NameLength;
    PCM_INDEX           Hint;

    *Child = HCELL_NIL;
    if ( (Index->Signature == CM_KEY_FAST_LEAF) ||
         (Index->Signature == CM_KEY_HASH_LEAF) ) {
        FastIndex = (PCM_KEY_FAST_INDEX)Index;
        Hint = &FastIndex->List[Count];

        if(Index->Signature == CM_KEY_FAST_LEAF) {
            //
            // Compute the number of valid characters in the hint to compare.
            //
            HintLength = 4;
            for (i=0;i<4;i++) {
                if (Hint->NameHint[i] == 0) {
                    HintLength = i;
                    break;
                }
            }
            NameLength = SearchName->Length / sizeof(WCHAR);
            if (NameLength < HintLength) {
                ValidChars = NameLength;
            } else {
                ValidChars = HintLength;
            }
            for (i=0; i<ValidChars; i++) {
                c1 = SearchName->Buffer[i];
                c2 = FastIndex->List[Count].NameHint[i];
                Result = (LONG)CmUpcaseUnicodeChar(c1) -
                         (LONG)CmUpcaseUnicodeChar(c2);
                if (Result != 0) {

                    //
                    // We have found a mismatched character in the hint,
                    // we can now tell which direction to go.
                    //
                    return (Result > 0) ? 1 : -1 ;
                }
            }
        }

        //
        // We have compared all the available characters without a
        // discrepancy. Go ahead and do the actual comparison now.
        //
        Result = CmpDoCompareKeyName(Hive,SearchName,FastIndex->List[Count].Cell);
        if( Result == 2 ) {
            //
            // couldn't map view inside; signal it to the caller
            //
            return 2;
        }
        if (Result == 0) {
            *Child = Hint->Cell;
        }
    } else {
        //
        // This is just a normal old slow index.
        //
        Result = CmpDoCompareKeyName(Hive,SearchName,Index->List[Count]);
        if( Result == 2 ) {
            //
            // couldn't map view inside; signal it to the caller
            //
            return 2;
        }
        if (Result == 0) {
            *Child = Index->List[Count];
        }
    }
    return(Result);
}


LONG
CmpDoCompareKeyName(
    PHHIVE          Hive,
    PUNICODE_STRING SearchName,
    HCELL_INDEX     Cell
    )
/*++

Routine Description:

    Do a compare of a name with a key.

Arguments:

    Hive - pointer to hive control structure for hive of interest

    SearchName - pointer to name of key we are searching for

    Cell - cell of key we are to compare with

Return Value:

    0   = SearchName == KeyName (of Cell)

    -1  = SearchName < KeyName

    +1  = SearchName > KeyName

    +2  = Error (couldn't map bin)

--*/
{
    PCM_KEY_NODE    Pcan;
    UNICODE_STRING  KeyName;
    LONG            Result;

    Pcan = (PCM_KEY_NODE)HvGetCell(Hive, Cell);
    if( Pcan == NULL ) {
        //
        // we couldn't map the bin containing this cell
        // return error, so the caller could safely bail out
        //
        return 2;
    }
    if (Pcan->Flags & KEY_COMP_NAME) {
        
        Result = CmpCompareCompressedName(SearchName,
                                        Pcan->Name,
                                        Pcan->NameLength,
                                        0);
    } else {
        KeyName.Buffer = &(Pcan->Name[0]);
        KeyName.Length = Pcan->NameLength;
        KeyName.MaximumLength = KeyName.Length;
        Result = RtlCompareUnicodeString(SearchName,
                                        &KeyName,
                                        TRUE);
    }
    
    HvReleaseCell(Hive, Cell);

    if( Result == 0 ) {
        //
        // match
        //
        return 0;
    }
    
    return (Result < 0) ? -1 : 1;
}


HCELL_INDEX
CmpFindSubKeyByNumber(
    PHHIVE          Hive,
    PCM_KEY_NODE    Node,
    ULONG           Number
    )
/*++

Routine Description:

    Find the Number'th entry in the index, starting from 0.

Arguments:

    Hive - pointer to hive control structure for hive of interest

    Node - pointer to key body which is parent of child of interest

    Number - ordinal of child key to return

Return Value:

    Cell of matching child key, or HCELL_NIL if none or error.

--*/
{
    PCM_KEY_INDEX   Index;
    HCELL_INDEX     Result = HCELL_NIL;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INDEX,"CmpFindSubKeyByNumber:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INDEX,"Hive=%p Node=%p Number=%08lx\n",Hive,Node,Number));

    if (Number < Node->SubKeyCounts[Stable]) {

        //
        // It's in the stable set
        //
        Index = (PCM_KEY_INDEX)HvGetCell(Hive, Node->SubKeyLists[Stable]);
        if( Index == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            return HCELL_NIL;
        }
        Result = CmpDoFindSubKeyByNumber(Hive, Index, Number);
        HvReleaseCell(Hive, Node->SubKeyLists[Stable]);
        return Result;

    } else if (Hive->StorageTypeCount > Volatile) {

        //
        // It's in the volatile set
        //
        Number = Number - Node->SubKeyCounts[Stable];
        if (Number < Node->SubKeyCounts[Volatile]) {

            Index = (PCM_KEY_INDEX)HvGetCell(Hive, Node->SubKeyLists[Volatile]);
            if( Index == NULL ) {
                //
                // we couldn't map the bin containing this cell
                //
                return HCELL_NIL;
            }
            Result = CmpDoFindSubKeyByNumber(Hive, Index, Number);
            HvReleaseCell(Hive, Node->SubKeyLists[Volatile]);
            return Result;
        }
    }
    //
    // It's nowhere
    //
    return HCELL_NIL;
}


HCELL_INDEX
CmpDoFindSubKeyByNumber(
    PHHIVE          Hive,
    PCM_KEY_INDEX   Index,
    ULONG           Number
    )
/*++

Routine Description:

    Helper for CmpFindSubKeyByNumber,
    Find the Number'th entry in the index, starting from 0.

Arguments:

    Hive - pointer to hive control structure for hive of interest

    Index - root or leaf of the index

    Number - ordinal of child key to return

Return Value:

    Cell of requested entry. HCELL_NIL on resources problem

--*/
{
    ULONG           i;
    HCELL_INDEX     LeafCell = 0;
    PCM_KEY_INDEX   Leaf = NULL;
    PCM_KEY_FAST_INDEX FastIndex;
    HCELL_INDEX     Result;

    if (Index->Signature == CM_KEY_INDEX_ROOT) {

        //
        // step through root, till we find the right leaf
        //
        for (i = 0; i < Index->Count; i++) {
            if( i ) {
                ASSERT( Leaf!= NULL );
                ASSERT( LeafCell == Index->List[i-1] );
                HvReleaseCell(Hive,LeafCell);
            }
            LeafCell = Index->List[i];
            Leaf = (PCM_KEY_INDEX)HvGetCell(Hive, LeafCell);
            if( Leaf == NULL ) {
                //
                // we couldn't map the bin containing this cell
                //
                return HCELL_NIL;
            }
            if (Number < Leaf->Count) {
                if ( (Leaf->Signature == CM_KEY_FAST_LEAF) ||
                     (Leaf->Signature == CM_KEY_HASH_LEAF) ) {
                    FastIndex = (PCM_KEY_FAST_INDEX)Leaf;
                    Result = FastIndex->List[Number].Cell;
                    HvReleaseCell(Hive,LeafCell);
                    return Result;
                } else {
                    Result = Leaf->List[Number];
                    HvReleaseCell(Hive,LeafCell);
                    return Result;
                }
            } else {
                Number = Number - Leaf->Count;
            }
        }
        ASSERT(FALSE);
    }
    ASSERT(Number < Index->Count);
    if ( (Index->Signature == CM_KEY_FAST_LEAF) ||
         (Index->Signature == CM_KEY_HASH_LEAF) ) {
        FastIndex = (PCM_KEY_FAST_INDEX)Index;
        return(FastIndex->List[Number].Cell);
    } else {
        return (Index->List[Number]);
    }
}

BOOLEAN
CmpRemoveSubKeyCellNoCellRef(
    PHHIVE          Hive,
    HCELL_INDEX     Parent,
    HCELL_INDEX     Child
    )
/*++

Routine Description:

    Removes a subkey by cell index; Also marks relevant data dirty.
    Intended for self healing process.

Arguments:

    Hive - pointer to hive control structure for hive of interest

    Parent - cell of key that will be parent of new key

    Child - key to delete from Paren't sub key list

Return Value:

    TRUE - it worked

    FALSE - resource problem

--*/
{
    PCM_KEY_NODE        Node = NULL;
    PCM_KEY_INDEX       Index = NULL;
    BOOLEAN             Result = TRUE;
    ULONG               i,j;
    HCELL_INDEX         LeafCell = 0;
    PCM_KEY_INDEX       Leaf = NULL;
    PCM_KEY_FAST_INDEX  FastIndex;

    CM_PAGED_CODE();

    Node = (PCM_KEY_NODE)HvGetCell(Hive,Parent);
    if( Node == NULL ) {
        Result = FALSE;
        goto Exit;
    }
    Index = (PCM_KEY_INDEX)HvGetCell(Hive, Node->SubKeyLists[Stable]);
    if( Index == NULL ) {
        Result = FALSE;
        goto Exit;
    }
    if (Index->Signature == CM_KEY_INDEX_ROOT) {
        //
        // step through root, till we find the right leaf
        //
        for (i = 0; i < Index->Count; i++) {
            if( i ) {
                ASSERT( Leaf!= NULL );
                ASSERT( LeafCell == Index->List[i-1] );
                HvReleaseCell(Hive,LeafCell);
            }
            LeafCell = Index->List[i];
            Leaf = (PCM_KEY_INDEX)HvGetCell(Hive, LeafCell);
            if( Leaf == NULL ) {
                Result = FALSE;
                goto Exit;
            }
            for(j=0;j<Leaf->Count;j++) {
                if ( (Leaf->Signature == CM_KEY_FAST_LEAF) ||
                     (Leaf->Signature == CM_KEY_HASH_LEAF) ) {
                    FastIndex = (PCM_KEY_FAST_INDEX)Leaf;
                    if( FastIndex->List[j].Cell == Child ) {
                        //
                        // found it!
                        //
                        HvReleaseCell(Hive,LeafCell);
                        HvMarkCellDirty(Hive,LeafCell,FALSE);
                        FastIndex->Count--;
                        RtlMoveMemory((PVOID)&(FastIndex->List[j]),
                                      (PVOID)&(FastIndex->List[j+1]),
                                      (FastIndex->Count - j) * sizeof(CM_INDEX));
                        goto DirtyParent;
                    }
                } else {
                    if( Leaf->List[j] == Child ) {
                        //
                        // found it!
                        //
                        HvReleaseCell(Hive,LeafCell);
                        HvMarkCellDirty(Hive,LeafCell,FALSE);
                        Leaf->Count--;
                        RtlMoveMemory((PVOID)&(Leaf->List[j]),
                                      (PVOID)&(Leaf->List[j+1]),
                                      (Leaf->Count - j) * sizeof(HCELL_INDEX));
                        goto DirtyParent;
                    }
                }
            }
        }
    } else {
        for(j=0;j<Index->Count;j++) {
            if ( (Index->Signature == CM_KEY_FAST_LEAF) ||
                 (Index->Signature == CM_KEY_HASH_LEAF) ) {
                FastIndex = (PCM_KEY_FAST_INDEX)Index;
                if( FastIndex->List[j].Cell == Child ) {
                    //
                    // found it!
                    //
                    RtlMoveMemory((PVOID)&(FastIndex->List[j]),
                                  (PVOID)&(FastIndex->List[j+1]),
                                  (FastIndex->Count - j) * sizeof(CM_INDEX));
				    HvMarkCellDirty(Hive,Node->SubKeyLists[Stable],FALSE);
				    Index->Count--;
                    goto DirtyParent;
                }
            } else {
                if( Index->List[j] == Child ) {
                    //
                    // found it!
                    //
                    RtlMoveMemory((PVOID)&(Index->List[j]),
                                  (PVOID)&(Index->List[j+1]),
                                  (Index->Count - j) * sizeof(HCELL_INDEX));
				    HvMarkCellDirty(Hive,Node->SubKeyLists[Stable],FALSE);
				    Index->Count--;
                    goto DirtyParent;
                }
            }
        }
    }
    ASSERT( FALSE );

DirtyParent:
    //
    // mark parent and index dirty and decrement index count.
    //
    HvMarkCellDirty(Hive,Parent,FALSE);
    Node->SubKeyCounts[Stable]--;
Exit:
    if( Index ) {
        ASSERT( Node );
        HvReleaseCell(Hive,Node->SubKeyLists[Stable]);
    }
    if( Node ) {
        HvReleaseCell(Hive,Parent);
    }
    return Result;
}

BOOLEAN
CmpAddSubKey(
    PHHIVE          Hive,
    HCELL_INDEX     Parent,
    HCELL_INDEX     Child
    )
/*++

Routine Description:

    Add a new child subkey to the subkey index for a cell.  The
    child MUST NOT already be present (bugcheck if so.)

    NOTE:   We expect Parent to already be marked dirty.
            We will mark stuff in Index dirty

Arguments:

    Hive - pointer to hive control structure for hive of interest

    Parent - cell of key that will be parent of new key

    Child - new key to put in Paren't sub key list

Return Value:

    TRUE - it worked

    FALSE - resource problem

--*/
{
    PCM_KEY_NODE    pcell;
    HCELL_INDEX     WorkCell = HCELL_NIL;
    PCM_KEY_INDEX   Index;
    PCM_KEY_FAST_INDEX FastIndex;
    UNICODE_STRING  NewName;
    HCELL_INDEX     LeafCell;
    PHCELL_INDEX    RootPointer = NULL;
    ULONG           cleanup = 0;
    ULONG           Type = 0;
    BOOLEAN         IsCompressed;
    ULONG           i;
    HCELL_INDEX     CellToRelease = HCELL_NIL;

    CM_PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INDEX,"CmpAddSubKey:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INDEX,"Hive=%p Parent=%08lx Child=%08lx\n",Hive,Parent,Child));

    //
    // we have the lock exclusive or nobody is operating inside this hive
    //

    //
    // build a name string
    //
    pcell = (PCM_KEY_NODE)HvGetCell(Hive, Child);
    if( pcell == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        return FALSE;
    }

    if (pcell->Flags & KEY_COMP_NAME) {
        IsCompressed = TRUE;
        NewName.Length = CmpCompressedNameSize(pcell->Name, pcell->NameLength);
        NewName.MaximumLength = NewName.Length;
        NewName.Buffer = (Hive->Allocate)(NewName.Length, FALSE,CM_FIND_LEAK_TAG8);
        if (NewName.Buffer==NULL) {
            HvReleaseCell(Hive, Child);
            return(FALSE);
        }
        CmpCopyCompressedName(NewName.Buffer,
                              NewName.MaximumLength,
                              pcell->Name,
                              pcell->NameLength);
    } else {
        IsCompressed = FALSE;
        NewName.Length = pcell->NameLength;
        NewName.MaximumLength = pcell->NameLength;
        NewName.Buffer = &(pcell->Name[0]);
    }
    HvReleaseCell(Hive, Child);

    pcell = (PCM_KEY_NODE)HvGetCell(Hive, Parent);
    if( pcell == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        goto ErrorExit;
    }

    Type = HvGetCellType(Child);

    if (pcell->SubKeyCounts[Type] == 0) {

        //
        // we must allocate a leaf
        //
        WorkCell = HvAllocateCell(Hive, sizeof(CM_KEY_FAST_INDEX), Type,(HvGetCellType(Parent)==Type)?Parent:HCELL_NIL);
        if (WorkCell == HCELL_NIL) {
            goto ErrorExit;
        }
        Index = (PCM_KEY_INDEX)HvGetCell(Hive, WorkCell);
        if( Index == NULL ) {
            //
            // we couldn't map the bin containing this cell
            // this shouldn't happen 'cause we just allocated this
            // cell (i.e. bin is PINNED in memory ! )
            //
            ASSERT( FALSE );
            goto ErrorExit;
        }
        if( UseHashIndex(Hive) ) {
            Index->Signature = CM_KEY_HASH_LEAF;
        } else if( UseFastIndex(Hive) ) {
            Index->Signature = CM_KEY_FAST_LEAF;
        } else {
            Index->Signature = CM_KEY_INDEX_LEAF;
        }
        Index->Count = 0;
        pcell->SubKeyLists[Type] = WorkCell;
        cleanup = 1;
    } else {

        Index = (PCM_KEY_INDEX)HvGetCell(Hive, pcell->SubKeyLists[Type]);
        if( Index == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            goto ErrorExit;
        }
        CellToRelease = pcell->SubKeyLists[Type];

        if ( (Index->Signature == CM_KEY_FAST_LEAF) &&
             (Index->Count >= (CM_MAX_FAST_INDEX)) ) {
            //
            // We must change fast index to a slow index to accommodate
            // growth.
            //
            if( !HvMarkCellDirty(Hive, pcell->SubKeyLists[Type],FALSE) ) {
                goto ErrorExit;
            }

            FastIndex = (PCM_KEY_FAST_INDEX)Index;
            for (i=0; i<Index->Count; i++) {
                Index->List[i] = FastIndex->List[i].Cell;
            }
            Index->Signature = CM_KEY_INDEX_LEAF;

        } else if (((Index->Signature == CM_KEY_INDEX_LEAF) ||
                    (Index->Signature == CM_KEY_HASH_LEAF)) &&
                   (Index->Count >= (CM_MAX_INDEX - 1) )) {
            //
            // We must change flat entry to a root/leaf tree
            //
            WorkCell = HvAllocateCell(
                         Hive,
                         sizeof(CM_KEY_INDEX) + sizeof(HCELL_INDEX), // allow for 2
                         Type,
                         (HvGetCellType(Parent)==Type)?Parent:HCELL_NIL
                         );
            if (WorkCell == HCELL_NIL) {
                goto ErrorExit;
            }

            Index = (PCM_KEY_INDEX)HvGetCell(Hive, WorkCell);
            if( Index == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // this shouldn't happen 'cause we just allocated this
                // cell (i.e. bin is PINNED in memory
                ASSERT( FALSE );
                goto ErrorExit;
            }

            Index->Signature = CM_KEY_INDEX_ROOT;
            Index->Count = 1;
            Index->List[0] = pcell->SubKeyLists[Type];
            pcell->SubKeyLists[Type] = WorkCell;
            cleanup = 2;
        }
    }
    LeafCell = pcell->SubKeyLists[Type];

    //
    // LeafCell is target for add, or perhaps root
    // Index is pointer to fast leaf, slow Leaf or Root, whichever applies
    //
    if (Index->Signature == CM_KEY_INDEX_ROOT) {
        LeafCell = CmpSelectLeaf(Hive, pcell, &NewName, Type, &RootPointer);
        if (LeafCell == HCELL_NIL) {
            goto ErrorExit;
        }
    }

    //
    // Add new cell to Leaf, update pointers
    //
    LeafCell = CmpAddToLeaf(Hive, LeafCell, Child, &NewName);

    if (LeafCell == HCELL_NIL) {
        goto ErrorExit;
    }

    pcell->SubKeyCounts[Type] += 1;

    if (RootPointer != NULL) {
        *RootPointer = LeafCell;
    } else {
        pcell->SubKeyLists[Type] = LeafCell;
    }

    if (IsCompressed) {
        (Hive->Free)(NewName.Buffer, NewName.Length);
    }

    if( WorkCell != HCELL_NIL ) {
        HvReleaseCell(Hive, WorkCell);
    }
    if( CellToRelease != HCELL_NIL ) {
        HvReleaseCell(Hive, CellToRelease);
    }
    HvReleaseCell(Hive, Parent);
    return TRUE;
ErrorExit:
    if( WorkCell != HCELL_NIL ) {
        HvReleaseCell(Hive, WorkCell);
    }
    if( CellToRelease != HCELL_NIL ) {
        HvReleaseCell(Hive, CellToRelease);
    }
    if (IsCompressed) {
        (Hive->Free)(NewName.Buffer, NewName.Length);
    }

    switch (cleanup) {
    case 1:
        HvFreeCell(Hive, pcell->SubKeyLists[Type]);
        pcell->SubKeyLists[Type] = HCELL_NIL;
        break;

    case 2:
        Index = (PCM_KEY_INDEX)HvGetCell(Hive, pcell->SubKeyLists[Type]);
        if( Index == NULL ) {
            //
            // we couldn't map the bin containing this cell
            // this shouldn't happen 'cause we just allocated this
            // cell (i.e. bin is PINNED in memory). 
            // But ... better safe than sorry
            //
            ASSERT( FALSE );
            HvReleaseCell(Hive, Parent);
            return FALSE;
        }
        WorkCell = Index->List[0];
        {
            HCELL_INDEX CellTemp = pcell->SubKeyLists[Type];
            HvFreeCell(Hive, pcell->SubKeyLists[Type]);
            pcell->SubKeyLists[Type] = WorkCell;
            HvReleaseCell(Hive, CellTemp);
        }
        break;
    }

    HvReleaseCell(Hive, Parent);
    return  FALSE;
}


HCELL_INDEX
CmpAddToLeaf(
    PHHIVE          Hive,
    HCELL_INDEX     LeafCell,
    HCELL_INDEX     NewKey,
    PUNICODE_STRING NewName
    )
/*++

Routine Description:

    Insert a new subkey into a Leaf index. Supports both fast and slow
    leaf indexes and will determine which sort of index the given leaf is.

    NOTE:   We expect Root to already be marked dirty by caller if non NULL.
            We expect Leaf to always be marked dirty by caller.

Arguments:

    Hive - pointer to hive control structure for hive of interest

    LeafCell - cell of index leaf node we are to add entry too

    NewKey - cell of KEY_NODE we are to add

    NewName - pointer to unicode string with name to we are to add

Return Value:

    HCELL_NIL - some resource problem

    Else - cell of Leaf index when are done, caller is expected to
            set this into Root index or Key body.

--*/
{
    PCM_KEY_INDEX   Leaf;
    PCM_KEY_FAST_INDEX FastLeaf;
    ULONG           Size;
    ULONG           OldSize;
    ULONG           freecount;
    HCELL_INDEX     NewCell;
    HCELL_INDEX     Child;
    ULONG           Select;
    LONG            Result;
    ULONG           EntrySize;
    ULONG           i;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INDEX,"CmpAddToLeaf:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INDEX,"Hive=%p LeafCell=%08lx NewKey=%08lx\n",Hive,LeafCell,NewKey));

    //
    // we have the lock exclusive or nobody is operating inside this hive
    //

    if (!HvMarkCellDirty(Hive, LeafCell, FALSE)) {
        return HCELL_NIL;
    }

    //
    // compute number free slots left in the leaf
    //
    Leaf = (PCM_KEY_INDEX)HvGetCell(Hive, LeafCell);
    if( Leaf == NULL ) {
        //
        // we couldn't map the bin containing this cell
        // this shouldn't happen as marking dirty means 
        // PINNING the view into memory
        //
        ASSERT( FALSE );
        return HCELL_NIL;
    }

    // release the cell here; as the view is pinned
    HvReleaseCell(Hive, LeafCell);

    if (Leaf->Signature == CM_KEY_INDEX_LEAF) {
        FastLeaf = NULL;
        EntrySize = sizeof(HCELL_INDEX);
    } else {
        ASSERT( (Leaf->Signature == CM_KEY_FAST_LEAF) ||
                (Leaf->Signature == CM_KEY_HASH_LEAF)
            );
        FastLeaf = (PCM_KEY_FAST_INDEX)Leaf;
        EntrySize = sizeof(CM_INDEX);
    }
    OldSize = HvGetCellSize(Hive, Leaf);
    Size = OldSize - ((EntrySize * Leaf->Count) +
              FIELD_OFFSET(CM_KEY_INDEX, List));
    freecount = Size / EntrySize;

    //
    // grow the leaf if it isn't big enough
    //
    NewCell = LeafCell;
    if (freecount < 1) {
        Size = OldSize + OldSize / 2;
        if (Size < (OldSize + EntrySize)) {
            Size = OldSize + EntrySize;
        }
        NewCell = HvReallocateCell(Hive, LeafCell, Size);
        if (NewCell == HCELL_NIL) {
            return HCELL_NIL;
        }
        Leaf = (PCM_KEY_INDEX)HvGetCell(Hive, NewCell);
        if( Leaf == NULL ) {
            //
            // we couldn't map the bin containing this cell
            // this shouldn't happen 'cause we just allocated this
            // cell (i.e. bin is PINNED in memory)
            //
            ASSERT( FALSE );
            return HCELL_NIL;
        }
        // release the cell here; as the view is pinned
        HvReleaseCell(Hive, NewCell);
        if (FastLeaf != NULL) {
            FastLeaf = (PCM_KEY_FAST_INDEX)Leaf;
        }
    }

    //
    // Find where to put the new entry
    //
    Select = CmpFindSubKeyInLeaf(Hive, Leaf, NewName, &Child);
    if( INVALID_INDEX & Select ) {
        //
        // couldn't map view
        // 
        return HCELL_NIL;
    }

    ASSERT(Child == HCELL_NIL);

    //
    // Select is the index in List of the entry nearest where the
    // new entry should go.
    // Decide whether the new entry goes before or after Offset entry,
    // and then ripple copy and set.
    // If Select == Count, then the leaf is empty, so simply set our entry
    //
    if (Select != Leaf->Count) {

        Result = CmpCompareInIndex(Hive,
                                   NewName,
                                   Select,
                                   Leaf,
                                   &Child);
        if( Result == 2 ) {
            //
            // couldn't map view inside; bail out
            //
            return HCELL_NIL;
        }

        ASSERT(Result != 0);

        //
        // Result -1 - NewName/NewKey less than selected key, insert before
        //        +1 - NewName/NewKey greater than selected key, insert after
        //
        if (Result > 0) {
            ASSERT( Result == 1 );
            Select++;
        }

        if (Select != Leaf->Count) {

            //
            // ripple copy to make space and insert
            //

            if (FastLeaf != NULL) {
                RtlMoveMemory((PVOID)&(FastLeaf->List[Select+1]),
                              (PVOID)&(FastLeaf->List[Select]),
                              sizeof(CM_INDEX)*(FastLeaf->Count - Select));
            } else {
                RtlMoveMemory((PVOID)&(Leaf->List[Select+1]),
                              (PVOID)&(Leaf->List[Select]),
                              sizeof(HCELL_INDEX)*(Leaf->Count - Select));
            }
        }
    }
    if (FastLeaf != NULL) {
        FastLeaf->List[Select].Cell = NewKey;
        if( FastLeaf->Signature == CM_KEY_HASH_LEAF ) {
            //
            // Hash leaf; store the HashKey
            //
            FastLeaf->List[Select].HashKey = CmpComputeHashKey(0,NewName
#if DBG
                                                                , FALSE
#endif
                );
        } else {
            FastLeaf->List[Select].NameHint[0] = 0;
            FastLeaf->List[Select].NameHint[1] = 0;
            FastLeaf->List[Select].NameHint[2] = 0;
            FastLeaf->List[Select].NameHint[3] = 0;
            if (NewName->Length/sizeof(WCHAR) < 4) {
                i = NewName->Length/sizeof(WCHAR);
            } else {
                i = 4;
            }
            do {
                if ((USHORT)NewName->Buffer[i-1] > (UCHAR)-1) {
                    //
                    // Can't compress this name. Leave NameHint[0]==0
                    // to force the name to be looked up in the key.
                    //
                    break;
                }
                FastLeaf->List[Select].NameHint[i-1] = (UCHAR)NewName->Buffer[i-1];
                i--;
            } while ( i>0 );
        }
    } else {
        Leaf->List[Select] = NewKey;
    }
    Leaf->Count += 1;
    
	return NewCell;
}


HCELL_INDEX
CmpSelectLeaf(
    PHHIVE          Hive,
    PCM_KEY_NODE    ParentKey,
    PUNICODE_STRING NewName,
    HSTORAGE_TYPE   Type,
    PHCELL_INDEX    *RootPointer
    )
/*++

Routine Description:

    This routine is only called if the subkey index for a cell is NOT
    simply a single Leaf index block.

    It selects the Leaf index block to which a new entry is to be
    added.  It may create this block by splitting an existing Leaf
    block.

Arguments:

    Hive - pointer to hive control structure for hive of interest

    ParentKey - mapped pointer to parent key

    NewName - pointer to unicode string naming entry to add

    Type - Stable or Volatile, describes Child's storage

    RootPointer - pointer to variable to receive address of HCELL_INDEX
                that points to Leaf block returned as function argument.
                Used for updates.

Return Value:

    HCELL_NIL - resource problem

    Else, cell index of Leaf index block to add entry to

--*/
{
    HCELL_INDEX         LeafCell;
    HCELL_INDEX         WorkCell;
    PCM_KEY_INDEX       Index;
    PCM_KEY_INDEX       Leaf;
    PCM_KEY_FAST_INDEX  FastLeaf;
    ULONG               RootSelect;
    LONG                Result;
    HV_TRACK_CELL_REF   CellRef = {0};

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INDEX,"CmpSelectLeaf:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INDEX,"Hive=%p ParentKey=%p\n", Hive, ParentKey));

    //
    // we have the lock exclusive or nobody is operating inside this hive
    //

    //
    // Force root to always be dirty, since we'll either grow it or edit it,
    // and it needs to be marked dirty for BOTH cases.  (Edit may not
    // occur until after we leave
    //
    if (! HvMarkCellDirty(Hive, ParentKey->SubKeyLists[Type], FALSE)) {
        return HCELL_NIL;
    }

    //
    // must find the proper leaf
    //
    Index = (PCM_KEY_INDEX)HvGetCell(Hive, ParentKey->SubKeyLists[Type]);
    if( Index == NULL ) {
        //
        // we couldn't map the bin containing this cell
        // this shouldn't happen as marking dirty means 
        // PINNING the view into memory
        //
        ASSERT( FALSE );
        return HCELL_NIL;
    }
    ASSERT(Index->Signature == CM_KEY_INDEX_ROOT);

    if( !HvTrackCellRef(&CellRef,Hive,ParentKey->SubKeyLists[Type]) ) {
        goto ErrorExit;
    }

    while (TRUE) {

        RootSelect = CmpFindSubKeyInRoot(Hive, Index, NewName, &LeafCell);
        if( INVALID_INDEX & RootSelect ) {
            //
            // couldn't map view inside; bail out
            //
            goto ErrorExit;
        }

        if (LeafCell == HCELL_NIL) {

            //
            // Leaf of interest is somewhere near RootSelect
            //
            // . Always use lowest order leaf we can get away with
            // . Never split a leaf if there's one with space we can use
            // . When we split a leaf, we have to repeat search
            //
            // If (NewKey is below lowest key in selected)
            //    If there's a Leaf below selected with space
            //       use the leaf below
            //    else
            //       use the leaf (split it if not enough space)
            // Else
            //    must be above highest key in selected, less than
            //      lowest key in Leaf to right of selected
            //       if space in selected
            //          use selected
            //       else if space in leaf above selected
            //          use leaf above
            //       else
            //          split selected
            //
            LeafCell = Index->List[RootSelect];
            Leaf = (PCM_KEY_INDEX)HvGetCell(Hive, LeafCell);
            if( Leaf == NULL ) {
                //
                // we couldn't map the bin containing this cell
                //
                goto ErrorExit;
            }
            if( !HvTrackCellRef(&CellRef,Hive,LeafCell) ) {
                goto ErrorExit;
            }

            if( (Leaf->Signature == CM_KEY_FAST_LEAF)   ||
                (Leaf->Signature == CM_KEY_HASH_LEAF) ) {
                FastLeaf = (PCM_KEY_FAST_INDEX)Leaf;
                WorkCell = FastLeaf->List[0].Cell;
            } else {
                ASSERT( Leaf->Signature == CM_KEY_INDEX_LEAF );
                WorkCell = Leaf->List[0];
            }

            Result = CmpDoCompareKeyName(Hive, NewName, WorkCell);
            if( Result == 2 ) {
                //
                // couldn't map view inside; bail out
                // 
                goto ErrorExit;
            }
            ASSERT(Result != 0);

            if (Result < 0) {

                //
                // new is off the left end of Selected
                //
                if (RootSelect > 0) {

                    //
                    // there's a Leaf to the left, try to use it
                    //
                    LeafCell = Index->List[RootSelect-1];
                    Leaf = (PCM_KEY_INDEX)HvGetCell(Hive, LeafCell);
                    if( Leaf == NULL ) {
                        //
                        // we couldn't map the bin containing this cell
                        //
                        goto ErrorExit;
                    }
                    if( !HvTrackCellRef(&CellRef,Hive,LeafCell) ) {
                        goto ErrorExit;
                    }

                    if (Leaf->Count < (CM_MAX_INDEX - 1)) {
                        RootSelect--;
                        *RootPointer = &(Index->List[RootSelect]);
                        break;
                    }

                } else {
                    //
                    // new key is off the left end of the leftmost leaf.
                    // Use the leftmost leaf, if there's enough room
                    //
                    LeafCell = Index->List[0];
                    Leaf = (PCM_KEY_INDEX)HvGetCell(Hive, LeafCell);
                    if( Leaf == NULL ) {
                        //
                        // we couldn't map the bin containing this cell
                        //
                        goto ErrorExit;
                    }
                    if( !HvTrackCellRef(&CellRef,Hive,LeafCell) ) {
                        goto ErrorExit;
                    }
                    if (Leaf->Count < (CM_MAX_INDEX - 1)) {
                        *RootPointer = &(Index->List[0]);
                        break;
                    }
                }

                //
                // else fall to split case
                //

            } else {

                //
                // since new key is not in a Leaf, and is not off
                // the left end of the ResultSelect Leaf, it must
                // be off the right end.
                //
                LeafCell = Index->List[RootSelect];
                Leaf = (PCM_KEY_INDEX)HvGetCell(Hive, LeafCell);
                if( Leaf == NULL ) {
                    //
                    // we couldn't map the bin containing this cell
                    //
                    goto ErrorExit;
                }
                if( !HvTrackCellRef(&CellRef,Hive,LeafCell) ) {
                    goto ErrorExit;
                }

                if (Leaf->Count < (CM_MAX_INDEX - 1)) {
                    *RootPointer = &(Index->List[RootSelect]);
                    break;
                }

                //
                // No space, see if there's a leaf to the rigth
                // and if it has space
                //
                if (RootSelect < (ULONG)(Index->Count - 1)) {

                    LeafCell = Index->List[RootSelect+1];
                    Leaf = (PCM_KEY_INDEX)HvGetCell(Hive, LeafCell);
                    if( Leaf == NULL ) {
                        //
                        // we couldn't map the bin containing this cell
                        //
                        goto ErrorExit;
                    }
                    if( !HvTrackCellRef(&CellRef,Hive,LeafCell) ) {
                        goto ErrorExit;
                    }

                    if (Leaf->Count < (CM_MAX_INDEX - 1)) {
                        *RootPointer = &(Index->List[RootSelect+1]);
                        break;
                    }
                }

                //
                // fall to split case
                //
            }

        } else {   // LeafCell != HCELL_NIL

            //
            // Since newkey cannot already be in tree, it must be
            // greater than the bottom of Leaf and less than the top,
            // therefore it must go in Leaf.  If no space, split it.
            //
            Leaf = (PCM_KEY_INDEX)HvGetCell(Hive, LeafCell);
            if( Leaf == NULL ) {
                //
                // we couldn't map the bin containing this cell
                //
                goto ErrorExit;
            }

            if( !HvTrackCellRef(&CellRef,Hive,LeafCell) ) {
                goto ErrorExit;
            }

            if (Leaf->Count < (CM_MAX_INDEX - 1)) {

                *RootPointer = &(Index->List[RootSelect]);
                break;
            }

            //
            // fall to split case
            //
        }

        //
        // either no neigbor, or no space in neighbor, so split
        //
        WorkCell = CmpSplitLeaf(
                        Hive,
                        ParentKey->SubKeyLists[Type],       // root cell
                        RootSelect,
                        Type
                        );
        if (WorkCell == HCELL_NIL) {
            goto ErrorExit;
        }

        ParentKey->SubKeyLists[Type] = WorkCell;
        Index = (PCM_KEY_INDEX)HvGetCell(Hive, WorkCell);
        if( Index == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            goto ErrorExit;
        }

        if( !HvTrackCellRef(&CellRef,Hive,WorkCell) ) {
            goto ErrorExit;
        }

        ASSERT(Index->Signature == CM_KEY_INDEX_ROOT);

    } // while(true)
    HvReleaseFreeCellRefArray(&CellRef);
    return LeafCell;

ErrorExit:
    HvReleaseFreeCellRefArray(&CellRef);
    return HCELL_NIL;
}


HCELL_INDEX
CmpSplitLeaf(
    PHHIVE          Hive,
    HCELL_INDEX     RootCell,
    ULONG           RootSelect,
    HSTORAGE_TYPE   Type
    )
/*++

Routine Description:

    Split the Leaf index block specified by RootSelect, causing both
    of the split out Leaf blocks to appear in the Root index block
    specified by RootCell.

    Caller is expected to have marked old root cell dirty.

Arguments:

    Hive - pointer to hive control structure for hive of interest

    RootCell - cell of the Root index block of index being grown

    RootSelect - indicates which child of Root to split

    Type - Stable or Volatile

Return Value:

    HCELL_NIL - some resource problem

    Else - cell of new (e.g. reallocated) Root index block

--*/
{
    PCM_KEY_INDEX   Root;
    HCELL_INDEX     LeafCell;
    PCM_KEY_INDEX   Leaf;
    HCELL_INDEX     NewLeafCell;
    PCM_KEY_INDEX   NewLeaf;
	PCM_KEY_FAST_INDEX	FastLeaf;
    ULONG           Size;
    ULONG           freecount;
    USHORT          OldCount;
    USHORT          KeepCount;
    USHORT          NewCount;
    USHORT          ElemSize;
    HV_TRACK_CELL_REF   CellRef = {0};

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INDEX,"CmpSplitLeaf:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INDEX,"Hive=%p RootCell=%08lx RootSelect\n", Hive, RootCell, RootSelect));

    //
    // we have the lock exclusive or nobody is operating inside this hive
    //

    //
    // allocate new Leaf index block
    //
    Root = (PCM_KEY_INDEX)HvGetCell(Hive, RootCell);
    if( Root == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        return HCELL_NIL;
    }

    if( !HvTrackCellRef(&CellRef,Hive,RootCell) ) {
        goto ErrorExit;
    }

    LeafCell = Root->List[RootSelect];
    Leaf = (PCM_KEY_INDEX)HvGetCell(Hive, LeafCell);
    if( Leaf == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        goto ErrorExit;
    }
    OldCount = Leaf->Count;

    if( !HvTrackCellRef(&CellRef,Hive,LeafCell) ) {
        goto ErrorExit;
    }

    KeepCount = (USHORT)(OldCount / 2);     // # of entries to keep in org. Leaf
    NewCount = (OldCount - KeepCount);      // # of entries to move

    if( UseHashIndex(Hive) ) {
        ASSERT( Leaf->Signature == CM_KEY_HASH_LEAF );
        ElemSize = sizeof(CM_INDEX);
    } else {
        ElemSize = sizeof(HCELL_INDEX);
        ASSERT( Leaf->Signature == CM_KEY_INDEX_LEAF );
    }

    ASSERT( FIELD_OFFSET(CM_KEY_INDEX, List) == FIELD_OFFSET(CM_KEY_FAST_INDEX, List) );
    Size = (ElemSize * NewCount) +
            FIELD_OFFSET(CM_KEY_INDEX, List) + 1;   // +1 to assure room for add

    if (!HvMarkCellDirty(Hive, LeafCell,FALSE)) {
        goto ErrorExit;
    }
    //
    //
    //
    ASSERT( (HvGetCellType(LeafCell) == (ULONG)Type) );

    NewLeafCell = HvAllocateCell(Hive, Size, Type,LeafCell);
    if (NewLeafCell == HCELL_NIL) {
        goto ErrorExit;
    }
    NewLeaf = (PCM_KEY_INDEX)HvGetCell(Hive, NewLeafCell);
    if( NewLeaf == NULL ) {
        //
        // we couldn't map the bin containing this cell
        // this shouldn't happen as we just allocated this cell
        // so it's bin should be PINNED into memory
        //
        ASSERT( FALSE );
        HvFreeCell(Hive, NewLeafCell);
        goto ErrorExit;
    }
    // release it right here as is dirty (view is pinned)
    HvReleaseCell(Hive,NewLeafCell);

    if( UseHashIndex(Hive) ) {
        NewLeaf->Signature = CM_KEY_HASH_LEAF;
    } else {
        NewLeaf->Signature = CM_KEY_INDEX_LEAF;
    }

    //
    // compute number of free slots left in the root
    //
    Size = HvGetCellSize(Hive, Root);
    Size = Size - ((sizeof(HCELL_INDEX) * Root->Count) +
              FIELD_OFFSET(CM_KEY_INDEX, List));
    freecount = Size / sizeof(HCELL_INDEX);


    //
    // grow the root if it isn't big enough
    //
    if (freecount < 1) {
        Size = HvGetCellSize(Hive, Root) + sizeof(HCELL_INDEX);
        RootCell = HvReallocateCell(Hive, RootCell, Size);
        if (RootCell == HCELL_NIL) {
            HvFreeCell(Hive, NewLeafCell);
            goto ErrorExit;
        }
        Root = (PCM_KEY_INDEX)HvGetCell(Hive, RootCell);
        if( Root == NULL ) {
            //
            // we couldn't map the bin containing this cell
            // this shouldn't happen as we just allocated this cell
            // so it's bin should be PINNED into memory
            //
            ASSERT( FALSE );
            HvFreeCell(Hive, NewLeafCell);
            goto ErrorExit;
        }
        if( !HvTrackCellRef(&CellRef,Hive,RootCell) ) {
            goto ErrorExit;
        }
    }


    //
    // copy data from one Leaf to the other
    //
    //
    if( UseHashIndex(Hive) ) {
		FastLeaf = (PCM_KEY_FAST_INDEX)Leaf;
		RtlMoveMemory(
			(PVOID)&(NewLeaf->List[0]),
			(PVOID)&(FastLeaf->List[KeepCount]),
			ElemSize * NewCount
			);
	} else {
		RtlMoveMemory(
			(PVOID)&(NewLeaf->List[0]),
			(PVOID)&(Leaf->List[KeepCount]),
			ElemSize * NewCount
			);
	}

    ASSERT(KeepCount != 0);
    ASSERT(NewCount  != 0);

    Leaf->Count = KeepCount;
    NewLeaf->Count = NewCount;


    //
    // make an open slot in the root
    //
    if (RootSelect < (ULONG)(Root->Count-1)) {
        RtlMoveMemory(
            (PVOID)&(Root->List[RootSelect+2]),
            (PVOID)&(Root->List[RootSelect+1]),
            (Root->Count - (RootSelect + 1)) * sizeof(HCELL_INDEX)
            );
    }

    //
    // update the root
    //
    Root->Count += 1;
    Root->List[RootSelect+1] = NewLeafCell;

    HvReleaseFreeCellRefArray(&CellRef);
    return RootCell;

ErrorExit:
    HvReleaseFreeCellRefArray(&CellRef);
    return HCELL_NIL;
}


BOOLEAN
CmpMarkIndexDirty(
    PHHIVE          Hive,
    HCELL_INDEX     ParentKey,
    HCELL_INDEX     TargetKey
    )
/*++

Routine Description:

    Mark as dirty relevant cells of a subkey index.  The Leaf that
    points to TargetKey, and the Root index block, if applicable,
    will be marked dirty.  This call assumes we are setting up
    for a subkey delete.

Arguments:

    Hive - pointer to hive control structure for hive of interest

    ParentKey - key from whose subkey list delete is to be performed

    TargetKey - key being deleted

Return Value:

    TRUE - it worked, FALSE - it didn't, some resource problem

--*/
{
    PCM_KEY_NODE    pcell;
    ULONG           i;
    HCELL_INDEX     IndexCell;
    PCM_KEY_INDEX   Index;
    HCELL_INDEX     Child = HCELL_NIL;
    UNICODE_STRING  SearchName;
    BOOLEAN         IsCompressed;
    HCELL_INDEX     CellToRelease = HCELL_NIL;


    pcell = (PCM_KEY_NODE)HvGetCell(Hive, TargetKey);
    if( pcell == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        return FALSE;
    }

    if (pcell->Flags & KEY_COMP_NAME) {
        IsCompressed = TRUE;
        SearchName.Length = CmpCompressedNameSize(pcell->Name, pcell->NameLength);
        SearchName.MaximumLength = SearchName.Length;
        SearchName.Buffer = ExAllocatePool(PagedPool, SearchName.Length);
        if (SearchName.Buffer==NULL) {
            HvReleaseCell(Hive, TargetKey);
            return(FALSE);
        }
        CmpCopyCompressedName(SearchName.Buffer,
                              SearchName.MaximumLength,
                              pcell->Name,
                              pcell->NameLength);
    } else {
        IsCompressed = FALSE;
        SearchName.Length = pcell->NameLength;
        SearchName.MaximumLength = pcell->NameLength;
        SearchName.Buffer = &(pcell->Name[0]);
    }

    HvReleaseCell(Hive, TargetKey);

    pcell = (PCM_KEY_NODE)HvGetCell(Hive, ParentKey);
    if( pcell == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        goto ErrorExit;
    }

    for (i = 0; i < Hive->StorageTypeCount; i++) {
        if (pcell->SubKeyCounts[i] != 0) {
            ASSERT(HvIsCellAllocated(Hive, pcell->SubKeyLists[i]));
            IndexCell = pcell->SubKeyLists[i];
            if( CellToRelease != HCELL_NIL ) {
                HvReleaseCell(Hive, CellToRelease);
                CellToRelease = HCELL_NIL;
            }
            Index = (PCM_KEY_INDEX)HvGetCell(Hive, IndexCell);
            if( Index == NULL ) {
                //
                // we couldn't map the bin containing this cell
                //
                goto ErrorExit;
            }
            CellToRelease = IndexCell;

            if (Index->Signature == CM_KEY_INDEX_ROOT) {

                //
                // target even in index?
                //
                if( INVALID_INDEX & CmpFindSubKeyInRoot(Hive, Index, &SearchName, &Child) ) {
                    //
                    // couldn't map view inside; bail out
                    //
                    goto ErrorExit;
                }

                if (Child == HCELL_NIL) {
                    continue;
                }

                //
                // mark root dirty
                //
                if (! HvMarkCellDirty(Hive, IndexCell, FALSE)) {
                    goto ErrorExit;
                }

                if( CellToRelease != HCELL_NIL ) {
                    HvReleaseCell(Hive, CellToRelease);
                    CellToRelease = HCELL_NIL;
                }
                IndexCell = Child;
                Index = (PCM_KEY_INDEX)HvGetCell(Hive, Child);
                if( Index == NULL ) {
                    //
                    // we couldn't map the bin containing this cell
                    //
                    goto ErrorExit;
                }

                CellToRelease = Child;

            }
            ASSERT((Index->Signature == CM_KEY_INDEX_LEAF)  ||
                   (Index->Signature == CM_KEY_FAST_LEAF)   ||
                   (Index->Signature == CM_KEY_HASH_LEAF)
                   );

            if( INVALID_INDEX & CmpFindSubKeyInLeaf(Hive, Index, &SearchName, &Child) ) {
                //
                // couldn't map view
                // 
                goto ErrorExit;
            }

            if (Child != HCELL_NIL) {
                if (IsCompressed) {
                    ExFreePool(SearchName.Buffer);
                }
                // cleanup
                HvReleaseCell(Hive, ParentKey);
                if( CellToRelease != HCELL_NIL ) {
                    HvReleaseCell(Hive, CellToRelease);
                }
                return(HvMarkCellDirty(Hive, IndexCell, FALSE));
            }
        }
    }

ErrorExit:
    if( pcell!= NULL ) {
        HvReleaseCell(Hive, ParentKey);
    }
    if( CellToRelease != HCELL_NIL ) {
        HvReleaseCell(Hive, CellToRelease);
    }

    if (IsCompressed) {
        ExFreePool(SearchName.Buffer);
    }
    return FALSE;
}


BOOLEAN
CmpRemoveSubKey(
    PHHIVE          Hive,
    HCELL_INDEX     ParentKey,
    HCELL_INDEX     TargetKey
    )
/*++

Routine Description:

    Remove the subkey TargetKey refers to from ParentKey's list.

    NOTE:   Assumes that caller has marked relevant cells dirty,
            see CmpMarkIndexDirty.

Arguments:

    Hive - pointer to hive control structure for hive of interest

    ParentKey - key from whose subkey list delete is to be performed

    TargetKey - key being deleted

Return Value:

    TRUE - it worked, FALSE - it didn't, some resource problem

--*/
{
    PCM_KEY_NODE    pcell;
    HCELL_INDEX     LeafCell;
    PCM_KEY_INDEX   Leaf;
    PCM_KEY_FAST_INDEX FastIndex;
    HCELL_INDEX     RootCell = HCELL_NIL;
    PCM_KEY_INDEX   Root = NULL;
    HCELL_INDEX     Child;
    ULONG           Type;
    ULONG           RootSelect;
    ULONG           LeafSelect;
    UNICODE_STRING  SearchName;
    BOOLEAN         IsCompressed;
    WCHAR           CompressedBuffer[50];
    BOOLEAN         Result;
    HCELL_INDEX     CellToRelease1 = HCELL_NIL,CellToRelease2  = HCELL_NIL;

    pcell = (PCM_KEY_NODE)HvGetCell(Hive, TargetKey);
    if( pcell == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        return FALSE;
    }

    ASSERT_CELL_DIRTY(Hive,TargetKey);

    //
    // release the cell here; as key is dirty/pinned
    //
    HvReleaseCell(Hive, TargetKey);

    if (pcell->Flags & KEY_COMP_NAME) {
        IsCompressed = TRUE;
        SearchName.Length = CmpCompressedNameSize(pcell->Name, pcell->NameLength);
        SearchName.MaximumLength = SearchName.Length;
        if (SearchName.MaximumLength > sizeof(CompressedBuffer)) {
            SearchName.Buffer = ExAllocatePool(PagedPool, SearchName.Length);
            if (SearchName.Buffer==NULL) {
                return(FALSE);
            }
        } else {
            SearchName.Buffer = CompressedBuffer;
        }
        CmpCopyCompressedName(SearchName.Buffer,
                              SearchName.MaximumLength,
                              pcell->Name,
                              pcell->NameLength);
    } else {
        IsCompressed = FALSE;
        SearchName.Length = pcell->NameLength;
        SearchName.MaximumLength = pcell->NameLength;
        SearchName.Buffer = &(pcell->Name[0]);
    }

    pcell = (PCM_KEY_NODE)HvGetCell(Hive, ParentKey);
    if( pcell == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        Result = FALSE;
        goto Exit;
    }

    ASSERT_CELL_DIRTY(Hive,ParentKey);

    //
    // release the cell here; as key is dirty/pinned
    //
    HvReleaseCell(Hive, ParentKey);

    Type = HvGetCellType(TargetKey);

    ASSERT(pcell->SubKeyCounts[Type] != 0);
    ASSERT(HvIsCellAllocated(Hive, pcell->SubKeyLists[Type]));

    LeafCell = pcell->SubKeyLists[Type];
    Leaf = (PCM_KEY_INDEX)HvGetCell(Hive, LeafCell);
    if( Leaf == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        Result = FALSE;
        goto Exit;
    }

    CellToRelease1 = LeafCell;

    RootSelect = INVALID_INDEX; // only needed for the compiler W4 option

    if (Leaf->Signature == CM_KEY_INDEX_ROOT) {
        RootSelect = CmpFindSubKeyInRoot(Hive, Leaf, &SearchName, &Child);

        if( INVALID_INDEX & RootSelect ) {
            //
            // couldn't map view inside; bail out
            //
            Result = FALSE;
            goto Exit;
        }
        ASSERT(Child != FALSE);

        Root = Leaf;
        RootCell = LeafCell;
        LeafCell = Child;
        Leaf = (PCM_KEY_INDEX)HvGetCell(Hive, LeafCell);
        if( Leaf == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            Result = FALSE;
            goto Exit;
        }
        CellToRelease2  = LeafCell;

    }

    ASSERT((Leaf->Signature == CM_KEY_INDEX_LEAF)   ||
           (Leaf->Signature == CM_KEY_FAST_LEAF)    ||
           (Leaf->Signature == CM_KEY_HASH_LEAF)
           );

    LeafSelect = CmpFindSubKeyInLeaf(Hive, Leaf, &SearchName, &Child);
    if( INVALID_INDEX & LeafSelect ) {
        //
        // couldn't map view
        // 
        Result = FALSE;
        goto Exit;
    }

    ASSERT(Child != HCELL_NIL);


    //
    // Leaf points to Index Leaf block
    // Child is Index Leaf block cell
    // LeafSelect is Index for List[]
    //
    pcell->SubKeyCounts[Type] -= 1;

    Leaf->Count -= 1;
    if (Leaf->Count == 0) {

        //
        // Empty Leaf, drop it.
        //
        HvFreeCell(Hive, LeafCell);

        if (Root != NULL) {

            Root->Count -= 1;
            if (Root->Count == 0) {

                //
                // Root is empty, free it too.
                //
                HvFreeCell(Hive, RootCell);
                pcell->SubKeyLists[Type] = HCELL_NIL;

            } else if (RootSelect < (ULONG)(Root->Count)) {

                //
                // Middle entry, squeeze root
                //
                RtlMoveMemory(
                    (PVOID)&(Root->List[RootSelect]),
                    (PVOID)&(Root->List[RootSelect+1]),
                    (Root->Count - RootSelect) * sizeof(HCELL_INDEX)
                    );
            }
            //
            // Else RootSelect == last entry, so decrementing count
            // was all we needed to do
            //

        } else {

            pcell->SubKeyLists[Type] = HCELL_NIL;

        }

    } else if (LeafSelect < (ULONG)(Leaf->Count)) {

        if (Leaf->Signature == CM_KEY_INDEX_LEAF) {
            RtlMoveMemory((PVOID)&(Leaf->List[LeafSelect]),
                          (PVOID)&(Leaf->List[LeafSelect+1]),
                          (Leaf->Count - LeafSelect) * sizeof(HCELL_INDEX));
        } else {
            FastIndex = (PCM_KEY_FAST_INDEX)Leaf;
            RtlMoveMemory((PVOID)&(FastIndex->List[LeafSelect]),
                          (PVOID)&(FastIndex->List[LeafSelect+1]),
                          (FastIndex->Count - LeafSelect) * sizeof(CM_INDEX));
        }
    }
    //
    // Else LeafSelect == last entry, so decrementing count was enough
    //

    // things went OK
    Result = TRUE;

Exit:
    if( CellToRelease1 != HCELL_NIL ) {
        HvReleaseCell(Hive,CellToRelease1);
    }
    if( CellToRelease2 != HCELL_NIL ) {
        HvReleaseCell(Hive,CellToRelease2);
    }

    if ((IsCompressed) &&
        (SearchName.MaximumLength > sizeof(CompressedBuffer))) {
        ExFreePool(SearchName.Buffer);
    }
    return Result;
}

HCELL_INDEX
CmpDuplicateIndex(
    PHHIVE          Hive,
    HCELL_INDEX     IndexCell,
    ULONG           StorageType
    )
/*++

Routine Description:

    Duplicate an index, regardless of its type; Needed for NtRenameKey

Arguments:

    Hive - pointer to hive control structure for hive of interest

    IndexCell - the index to be duplicated

    StorageType - storagetype (Stable or Volatile)

Return Value:

    cellindex of a duplicate or HCELL_NIL

--*/
{

    PCM_KEY_INDEX   Index;
#if DBG
    PCM_KEY_INDEX   Leaf;
#endif
    ULONG           i;
    PCM_KEY_INDEX   NewIndex = NULL;
    HCELL_INDEX     NewIndexCell;
    HCELL_INDEX     LeafCell;
    HV_TRACK_CELL_REF   CellRef = {0};

    CM_PAGED_CODE();

    //
    // we have the lock exclusive or nobody is operating inside this hive
    //
    ASSERT_CM_EXCLUSIVE_HIVE_ACCESS(Hive);

    ASSERT( HvGetCellType(IndexCell) == StorageType );

    Index = (PCM_KEY_INDEX)HvGetCell(Hive, IndexCell);
    if( Index == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //
        return HCELL_NIL;
    }

    if( !HvTrackCellRef(&CellRef,Hive,IndexCell) ) {
        return HCELL_NIL;
    }

    if (Index->Signature == CM_KEY_INDEX_ROOT) {
        //
        // first duplicate IndexCell, zeroing out the new content
        //
        NewIndexCell = HvDuplicateCell(Hive,IndexCell,StorageType,FALSE);
        if( NewIndexCell == HCELL_NIL ) {
            HvReleaseFreeCellRefArray(&CellRef);
            return HCELL_NIL;
        }

        NewIndex = (PCM_KEY_INDEX)HvGetCell(Hive, NewIndexCell);
        if( NewIndex == NULL ) {
            //
            // we couldn't map a view for the bin containing this cell
            // this shouldn't happen as we just allocated this cell (i.e. is dirty/pinned into memory)
            //
            ASSERT( FALSE );
            goto ErrorExit;
        }
        if( !HvTrackCellRef(&CellRef,Hive,NewIndexCell) ) {
            goto ErrorExit;
        }

        //
        // we have a root index;
        //
        NewIndex->Signature = CM_KEY_INDEX_ROOT;
        NewIndex->Count = 0;

        //
        // copy first level.
        //
        for( i=0;i<Index->Count;i++) {
#if DBG
            Leaf = (PCM_KEY_INDEX)HvGetCell(Hive, Index->List[i]);
            if( Leaf == NULL ) {
                //
                // we couldn't map the bin containing this cell
                //
                goto ErrorExit;
            }

            ASSERT((Leaf->Signature == CM_KEY_INDEX_LEAF)   ||
                   (Leaf->Signature == CM_KEY_FAST_LEAF)    ||
                   (Leaf->Signature == CM_KEY_HASH_LEAF)
                   );
            ASSERT(Leaf->Count != 0);
            HvReleaseCell(Hive, Index->List[i]);
#endif
            
            LeafCell = HvDuplicateCell(Hive,Index->List[i],StorageType,TRUE);
            if( LeafCell == HCELL_NIL ) {
                goto ErrorExit;
            }
            
            NewIndex->List[i] = LeafCell;
            NewIndex->Count++;
        }
        
        ASSERT( NewIndex->Count == Index->Count );

    } else {
        //
        // leaf index
        //
        ASSERT((Index->Signature == CM_KEY_INDEX_LEAF)  ||
               (Index->Signature == CM_KEY_FAST_LEAF)   ||
               (Index->Signature == CM_KEY_HASH_LEAF)
               );
        ASSERT(Index->Count != 0);

        //
        // first duplicate IndexCell, copying the old content
        //
        NewIndexCell = HvDuplicateCell(Hive,IndexCell,StorageType,TRUE);
    }

    HvReleaseFreeCellRefArray(&CellRef);
    return NewIndexCell;

ErrorExit:
    HvReleaseFreeCellRefArray(&CellRef);
    if( NewIndex != NULL ){
        // we can get here only if we are trying to duplicate an index_root
        ASSERT( NewIndex->Signature == CM_KEY_INDEX_ROOT );
       
        //
        // free the space we already allocated
        //
        for(i=0;i<NewIndex->Count;i++) {
            ASSERT(NewIndex->List[i] != 0 );
            HvFreeCell(Hive, NewIndex->List[i]);
        }
    }

    HvFreeCell(Hive, NewIndexCell);
    return HCELL_NIL;
}

BOOLEAN
CmpUpdateParentForEachSon(
    PHHIVE          Hive,
    HCELL_INDEX     Parent
    )
/*++

Routine Description:

    Walks the child's list (both stable and volatile and marks updates
    the parent link to Parent.

    First step is to mark all children dirty, and then to update the link.
    This way, if we fail part through, we leave everything in good order

Arguments:

    Hive - pointer to hive control structure for hive of interest

    Parent - cell index of the cell who's son's to be updated.

Return Value:

    TRUE - successfully updated

--*/
{
    PCM_KEY_NODE    ParentNode;
    PCM_KEY_NODE    CurrentSon;
    HCELL_INDEX     Child;
    ULONG           Count;   
    ULONG           i;   

    CM_PAGED_CODE();

    //
    // we have the lock exclusive or nobody is operating inside this hive
    //
    ASSERT_CM_EXCLUSIVE_HIVE_ACCESS(Hive);

    //
    // grab the parent node; this was already marked as dirty, we shouldn't 
    // have any problem here;
    //
    ParentNode = (PCM_KEY_NODE)HvGetCell(Hive,Parent);
    if( ParentNode == NULL ) {
        //
        // cannot map view; this shouldn't happen as we just allocated 
        // this cell (i.e. it should be dirty/pinned into memory)
        //
        ASSERT( FALSE );
        return FALSE;
    }

    //
    // iterate through the child list (both stable and volatile), marking every
    // child dirty; this will pin the cell into memory and we will have no problems 
    // changing the parent later on
    //
    Count = ParentNode->SubKeyCounts[Stable] + ParentNode->SubKeyCounts[Volatile];
    for( i=0;i<Count;i++) {
        Child = CmpFindSubKeyByNumber(Hive,ParentNode,i);
        if( Child == HCELL_NIL ) {
            HvReleaseCell(Hive, Parent);
            return FALSE;
        }
        if(!HvMarkCellDirty(Hive,Child,FALSE)) {
            HvReleaseCell(Hive, Parent);
            return FALSE;
        }
    }

    //
    // second iteration, change the parent for each and every son
    //
    for( i=0;i<Count;i++) {
        Child = CmpFindSubKeyByNumber(Hive,ParentNode,i);

        //
        // sanity test: we marked this dirty few lines above!
        //
        ASSERT( Child != HCELL_NIL );

        CurrentSon = (PCM_KEY_NODE)HvGetCell(Hive,Child);

        //
        // sanity test: this cell should be pinned in memory by now
        //
        ASSERT( CurrentSon != NULL );

        //
        // change the parent
        //
        CurrentSon->Parent = Parent;
        // release the cell here; as the registry is locked exclusive (i.e. we don't care)
        HvReleaseCell(Hive, Child);
    }

    HvReleaseCell(Hive, Parent);
    return TRUE;
}

ULONG
CmpComputeHashKey(
    IN ULONG            HashStart,
    IN PUNICODE_STRING  Name
#if DBG
    ,IN BOOLEAN        AllowSeparators
#endif
    )
{
    ULONG                   Cnt;
    WCHAR                   *Cp;

    ASSERT((Name->Length == 0) || AllowSeparators || (Name->Buffer[0] != OBJ_NAME_PATH_SEPARATOR));
    //
    // Manually compute the hash to use.
    //

    Cp = Name->Buffer;
    for (Cnt=0; Cnt<Name->Length; Cnt += sizeof(WCHAR)) {
        ASSERT( AllowSeparators || (*Cp != OBJ_NAME_PATH_SEPARATOR) );
        HashStart = 37 * HashStart + (ULONG)CmUpcaseUnicodeChar(*Cp);
        ++Cp;
    }

    return HashStart;
}

ULONG
CmpComputeHashKeyForCompressedName(
                                    IN ULONG    HashStart,
                                    IN PWCHAR   Source,
                                    IN ULONG    SourceLength
                                    )
{
    ULONG   i;

    for (i=0;i<SourceLength;i++) {
        HashStart = 37*HashStart + (ULONG)CmUpcaseUnicodeChar((WCHAR)(((PUCHAR)Source)[i]));
    }

    return HashStart;
}

//
// HashIndex routines
//


HCELL_INDEX
CmpFindSubKeyByHash(
    PHHIVE                  Hive,
    PCM_KEY_FAST_INDEX      FastIndex,
    PUNICODE_STRING         SearchName
    )
/*++

Routine Description:

    Find the child cell (either subkey or value) specified by name.
    It searched in the index table ordered by the hash

Arguments:

    Hive - pointer to hive control structure for hive of interest

    Index - 

    SearchName - name of child of interest

Return Value:

    Cell of matching child key, or HCELL_NIL if none.

--*/
{
    USHORT      Current;
    ULONG       HashKey;
    LONG        Result;

    CM_PAGED_CODE();

    ASSERT( FastIndex->Signature == CM_KEY_HASH_LEAF );

    HashKey = CmpComputeHashKey(0,SearchName
#if DBG
                                , FALSE
#endif
    );

    for(Current = 0; Current < FastIndex->Count; Current++ ) {
        if( HashKey == FastIndex->List[Current].HashKey ) {
            //
            // HashKey matches; see if this is a real hit
            //

            Result = CmpDoCompareKeyName(Hive,SearchName,FastIndex->List[Current].Cell);
            if (Result == 0) {
                return FastIndex->List[Current].Cell;
            }

        }
    }

    return HCELL_NIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cminit.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cminit.c

Abstract:

    This module contains init support for the CM level of the
    config manager/hive.

--*/

#include    "cmp.h"

//
// Prototypes local to this module
//
NTSTATUS
CmpOpenFileWithExtremePrejudice(
    OUT PHANDLE Primary,
    IN POBJECT_ATTRIBUTES Obja,
    IN ULONG IoFlags,
    IN ULONG AttributeFlags
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpOpenHiveFiles)
#pragma alloc_text(PAGE,CmpInitializeHive)
#pragma alloc_text(PAGE,CmpDestroyHive)
#pragma alloc_text(PAGE,CmpOpenFileWithExtremePrejudice)
#endif

extern PCMHIVE CmpMasterHive;
extern LIST_ENTRY CmpHiveListHead;

NTSTATUS
CmpOpenHiveFiles(
    PUNICODE_STRING     BaseName,
    PWSTR               Extension OPTIONAL,
    PHANDLE             Primary,
    PHANDLE             Secondary,
    PULONG              PrimaryDisposition,
    PULONG              SecondaryDisposition,
    BOOLEAN             CreateAllowed,
    BOOLEAN             MarkAsSystemHive,
    BOOLEAN             NoBuffering,
    OUT OPTIONAL PULONG ClusterSize
    )
/*++

Routine Description:

    Open/Create Primary, and Log files for Hives.

    BaseName is some name like "\winnt\system32\config\system".
    Extension is ".alt" or ".log" or NULL.

    If extension is NULL skip secondary work.

    If extension is .alt or .log, open/create a secondary file
    (e.g. "\winnt\system32\config\system.alt")

    If extension is .log, open secondary for buffered I/O, else,
    open for non-buffered I/O.  Primary always uses non-buffered I/O.

    If primary is newly created, supersede secondary.  If secondary
    does not exist, simply create (other code will complain if Log
    is needed but does not exist.)

    WARNING:    If Secondary handle is NULL, you have no log
                or alternate!

Arguments:

    BaseName - unicode string of base hive file, must have space for
                extension if that is used.

    Extension - unicode type extension of secondary file, including
                the leading "."

    Primary - will get handle to primary file

    Secondary - will get handle to secondary, or NULL

    PrimaryDisposition - STATUS_SUCCESS or STATUS_CREATED, of primary file.

    SecondaryDisposition - STATUS_SUCCESS or STATUS_CREATED, of secondary file.

    CreateAllowed - if TRUE will create nonexistent primary, if FALSE will
                    fail if primary does not exist.  no effect on log

    MarkAsSystemHive - if TRUE will call into file system to mark this
                       as a critical system hive.

    ClusterSize - if not NULL, will compute and return the appropriate
        cluster size for the primary file.

Return Value:

    status - if status is success, Primary succeeded, check Secondary
             value to see if it succeeded.

--*/
{
    IO_STATUS_BLOCK     IoStatus;
    IO_STATUS_BLOCK     FsctlIoStatus;
    FILE_FS_SIZE_INFORMATION FsSizeInformation;
    ULONG Cluster;
    ULONG               CreateDisposition;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    NTSTATUS            status;
    UNICODE_STRING      ExtName;
    UNICODE_STRING      WorkName;
    PVOID               WorkBuffer;
    USHORT              NameSize;
    ULONG               IoFlags;
    ULONG               AttributeFlags;
    ULONG               ShareMode;
    ULONG               DesiredAccess;
    USHORT              CompressionState;
    HANDLE              hEvent;
    PKEVENT             pEvent;

    //
    // Allocate an event to use for our overlapped I/O
    //
    status = CmpCreateEvent(NotificationEvent, &hEvent, &pEvent);
    if (!NT_SUCCESS(status)) {
        return(status);
    }
    
    //
    // Allocate a buffer big enough to hold the full name
    //
    WorkName.Length = 0;
    WorkName.MaximumLength = 0;
    WorkName.Buffer = NULL;

    NameSize = BaseName->Length;
    if (ARGUMENT_PRESENT(Extension)) {
        NameSize = (USHORT)(NameSize + (wcslen(Extension)+1) * sizeof(WCHAR));
        WorkBuffer = ExAllocatePool(PagedPool, NameSize);
        if (WorkBuffer == NULL) {
            ObDereferenceObject(pEvent);
            ZwClose(hEvent);
            return STATUS_NO_MEMORY;
        }
        WorkName.Buffer = WorkBuffer;
        WorkName.MaximumLength = NameSize;
        RtlAppendStringToString((PSTRING)&WorkName, (PSTRING)BaseName);
    } else {
        WorkName = *BaseName;
        WorkBuffer = NULL;
    }


    //
    // Open/Create the primary
    //
    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL
        );

    if (CreateAllowed && !CmpShareSystemHives) {
        CreateDisposition = FILE_OPEN_IF;
    } else {
        CreateDisposition = FILE_OPEN;
    }

    ASSERT_PASSIVE_LEVEL();

    AttributeFlags = FILE_OPEN_FOR_BACKUP_INTENT | FILE_NO_COMPRESSION | FILE_RANDOM_ACCESS;
    if( NoBuffering == TRUE ) {
        AttributeFlags |= FILE_NO_INTERMEDIATE_BUFFERING;
    }

    //
    // Share the file if needed
    //
    if (CmpMiniNTBoot && CmpShareSystemHives) {
    	DesiredAccess = FILE_READ_DATA;
    	ShareMode = FILE_SHARE_READ;	
    } else {
    	ShareMode = 0;
    	DesiredAccess = FILE_READ_DATA | FILE_WRITE_DATA;
    }				

    status = ZwCreateFile(
                Primary,
                DesiredAccess,
                &ObjectAttributes,
                &IoStatus,
                NULL,                               // alloc size = none
                FILE_ATTRIBUTE_NORMAL,
                ShareMode,                          // share nothing
                CreateDisposition,
                AttributeFlags,
                NULL,                               // eabuffer
                0                                   // ealength
                );

    if (status == STATUS_ACCESS_DENIED) {

        //
        // This means some  person has put a read-only attribute
        // on one of the critical system hive files. Remove it so they
        // don't hurt themselves.
        //

        status = CmpOpenFileWithExtremePrejudice(Primary,
                                                 &ObjectAttributes,
                                                 AttributeFlags,
                                                 FILE_ATTRIBUTE_NORMAL);
    }

    if (!CmpShareSystemHives && (MarkAsSystemHive) &&
        (NT_SUCCESS(status))) {

        ASSERT_PASSIVE_LEVEL();
        status = ZwFsControlFile(*Primary,
                                 hEvent,
                                 NULL,
                                 NULL,
                                 &FsctlIoStatus,
                                 FSCTL_MARK_AS_SYSTEM_HIVE,
                                 NULL,
                                 0,
                                 NULL,
                                 0);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(pEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
            status = FsctlIoStatus.Status;
        }

        //
        //  STATUS_INVALID_DEVICE_REQUEST is OK.
        //

        if (status == STATUS_INVALID_DEVICE_REQUEST) {
            status = STATUS_SUCCESS;

        } else if (!NT_SUCCESS(status)) {
            ZwClose(*Primary);
        }
    }

    if (!NT_SUCCESS(status)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CMINIT: CmpOpenHiveFile: "));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"\tPrimary Open/Create failed for:\n"));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"\t%wZ\n", &WorkName));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"\tstatus = %08lx\n", status));

        if (WorkBuffer != NULL) {
            ExFreePool(WorkBuffer);
        }
        ObDereferenceObject(pEvent);
        ZwClose(hEvent);
        return status;
    }

    //
    // Make sure the file is uncompressed in order to prevent the filesystem
    // from failing our updates due to disk full conditions.
    //
    // Do not fail to open the file if this fails, we don't want to prevent
    // people from booting just because their disk is full. Although they
    // will not be able to update their registry, they will at lease be
    // able to delete some files.
    //
    CompressionState = 0;
    ASSERT_PASSIVE_LEVEL();
    status = ZwFsControlFile(*Primary,
                             hEvent,
                             NULL,
                             NULL,
                             &FsctlIoStatus,
                             FSCTL_SET_COMPRESSION,
                             &CompressionState,
                             sizeof(CompressionState),
                             NULL,
                             0);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(pEvent,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
    }

    *PrimaryDisposition = (ULONG) IoStatus.Information;

    if( *PrimaryDisposition != FILE_CREATED ) {
        //
        // 0-length file case
        //
        FILE_STANDARD_INFORMATION   FileInformation;
        NTSTATUS                    status2;
        
        status2 = ZwQueryInformationFile(*Primary,
                                         &IoStatus,
                                         (PVOID)&FileInformation,
                                         sizeof( FileInformation ),
                                         FileStandardInformation
                                       );
        if (NT_SUCCESS( status2 )) {
            if(FileInformation.EndOfFile.QuadPart == 0) {
                //
                // treat it as a non-existent one.
                //
                *PrimaryDisposition = FILE_CREATED;
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"Primary file is zero-length => treat it as non-existent\n"));
            }
        }
    }

    if (ARGUMENT_PRESENT(ClusterSize)) {

        ASSERT_PASSIVE_LEVEL();
        status = ZwQueryVolumeInformationFile(*Primary,
                                              &IoStatus,
                                              &FsSizeInformation,
                                              sizeof(FILE_FS_SIZE_INFORMATION),
                                              FileFsSizeInformation);
        if (!NT_SUCCESS(status)) {
            ObDereferenceObject(pEvent);
            ZwClose(hEvent);
            return(status);
        }
        if (FsSizeInformation.BytesPerSector > HBLOCK_SIZE) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpOpenHiveFiles: sectorsize %lx > HBLOCK_SIZE\n"));
            ObDereferenceObject(pEvent);
            ZwClose(hEvent);
            return(STATUS_CANNOT_LOAD_REGISTRY_FILE);
        }

        Cluster = FsSizeInformation.BytesPerSector / HSECTOR_SIZE;
        *ClusterSize = (Cluster < 1) ? 1 : Cluster;

    }

    if ( ! ARGUMENT_PRESENT(Extension)) {
        if (WorkBuffer != NULL) {
            ExFreePool(WorkBuffer);
        }
        ObDereferenceObject(pEvent);
        ZwClose(hEvent);
        return STATUS_SUCCESS;
    }

    //
    // Open/Create the secondary
    //
    CreateDisposition = CmpShareSystemHives ? FILE_OPEN : FILE_OPEN_IF;
    
    if (*PrimaryDisposition == FILE_CREATED) {
        CreateDisposition = FILE_SUPERSEDE;
    }

    RtlInitUnicodeString(&ExtName,Extension);
    status = RtlAppendStringToString((PSTRING)&WorkName, (PSTRING)&ExtName);

    InitializeObjectAttributes(&ObjectAttributes,
                               &WorkName,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);

    //
    // non-cached log files (or alternates)
    //
    IoFlags = FILE_NO_COMPRESSION | FILE_NO_INTERMEDIATE_BUFFERING;
    if (_wcsnicmp(Extension, L".log", 4) != 0) {
        AttributeFlags = FILE_ATTRIBUTE_NORMAL;
    } else {
        AttributeFlags = FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_HIDDEN;
    }

    ASSERT_PASSIVE_LEVEL();
    status = ZwCreateFile(
                Secondary,
                DesiredAccess,
                &ObjectAttributes,
                &IoStatus,
                NULL,                               // alloc size = none
                AttributeFlags,
                ShareMode,
                CreateDisposition,
                IoFlags,
                NULL,                               // eabuffer
                0                                   // ealength
                );

    if (status == STATUS_ACCESS_DENIED) {

        //
        // This means some person has put a read-only attribute
        // on one of the critical system hive files. Remove it so they
        // don't hurt themselves.
        //

        status = CmpOpenFileWithExtremePrejudice(Secondary,
                                                 &ObjectAttributes,
                                                 IoFlags,
                                                 AttributeFlags);
    }

    if (!CmpShareSystemHives && (MarkAsSystemHive) &&
        (NT_SUCCESS(status))) {

        ASSERT_PASSIVE_LEVEL();
        status = ZwFsControlFile(*Secondary,
                                 hEvent,
                                 NULL,
                                 NULL,
                                 &FsctlIoStatus,
                                 FSCTL_MARK_AS_SYSTEM_HIVE,
                                 NULL,
                                 0,
                                 NULL,
                                 0);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(pEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
            status = FsctlIoStatus.Status;
        }
        //
        //  STATUS_INVALID_DEVICE_REQUEST is OK.
        //

        if (status == STATUS_INVALID_DEVICE_REQUEST) {
            status = STATUS_SUCCESS;

        } else if (!NT_SUCCESS(status)) {

            ZwClose(*Secondary);
        }
    }

    if (!NT_SUCCESS(status)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CMINIT: CmpOpenHiveFile: "));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"\tSecondary Open/Create failed for:\n"));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"\t%wZ\n", &WorkName));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"\tstatus = %08lx\n", status));

        *Secondary = NULL;
    } else {
        *SecondaryDisposition = (ULONG) IoStatus.Information;

        //
        // Make sure the file is uncompressed in order to prevent the filesystem
        // from failing our updates due to disk full conditions.
        //
        // Do not fail to open the file if this fails, we don't want to prevent
        // people from booting just because their disk is full. Although they
        // will not be able to update their registry, they will at least be
        // able to delete some files.
        //
        CompressionState = 0;

        ASSERT_PASSIVE_LEVEL();
        status = ZwFsControlFile(*Secondary,
                                 hEvent,
                                 NULL,
                                 NULL,
                                 &FsctlIoStatus,
                                 FSCTL_SET_COMPRESSION,
                                 &CompressionState,
                                 sizeof(CompressionState),
                                 NULL,
                                 0);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(pEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }
    }

    if (WorkBuffer != NULL) {
        ExFreePool(WorkBuffer);
    }
    ObDereferenceObject(pEvent);
    ZwClose(hEvent);
    return STATUS_SUCCESS;
}


NTSTATUS
CmpInitializeHive(
    PCMHIVE         *CmHive,
    ULONG           OperationType,
    ULONG           HiveFlags,
    ULONG           FileType,
    PVOID           HiveData OPTIONAL,
    HANDLE          Primary,
    HANDLE          Log,
    HANDLE          External,
    PUNICODE_STRING FileName OPTIONAL,
    ULONG           CheckFlags
    )
/*++

Routine Description:

    Initialize a hive.

Arguments:

    CmHive - pointer to a variable to receive a pointer to the CmHive structure

    OperationType - specifies whether to create a new hive from scratch,
            from a memory image, or by reading a file from disk.
            [HINIT_CREATE | HINIT_MEMORY | HINIT_FILE | HINIT_MAPFILE]

    HiveFlags - HIVE_VOLATILE - Entire hive is to be volatile, regardless
                                   of the types of cells allocated
                HIVE_NO_LAZY_FLUSH - Data in this hive is never written
                                   to disk except by an explicit FlushKey

    FileType - HFILE_TYPE_*, HFILE_TYPE_LOG set up for logging support 

    HiveData - if present, supplies a pointer to an in memory image of
            from which to init the hive.  Only useful when OperationType
            is set to HINIT_MEMORY.

    Primary - File handle for primary hive file (e.g. SYSTEM)

    Log - File handle for log hive file (e.g. SOFTWARE.LOG)

    External - File handle for primary hive file  (e.g.  BACKUP.REG)

    FileName - some path like "...\system32\config\system", which will
                be written into the base block as an aid to debugging.
                may be NULL.

    CheckFlags - Flags to be passed to CmCheckRegistry

        usually this is CM_CHECK_REGISTRY_CHECK_CLEAN, except for the system hive 
        where CM_CHECK_REGISTRY_FORCE_CLEAN is passed

Return Value:

    NTSTATUS

--*/
{
    FILE_FS_SIZE_INFORMATION    FsSizeInformation;
    IO_STATUS_BLOCK             IoStatusBlock;
    ULONG                       Cluster;
    NTSTATUS                    Status;
    PCMHIVE                     cmhive2;
    ULONG                       rc;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INIT,"CmpInitializeHive:\t\n"));

    //
    // Reject illegal parms
    //
    if ( (External && (Primary || Log)) ||
         (Log && !Primary) ||
         (!CmpShareSystemHives && (HiveFlags & HIVE_VOLATILE) && (Primary || External || Log)) ||
         ((OperationType == HINIT_MEMORY) && (!ARGUMENT_PRESENT(HiveData))) ||
         (Log && (FileType != HFILE_TYPE_LOG)) 
       )
    {
        return (STATUS_INVALID_PARAMETER);
    }

    //
    // compute control
    //
    if (Primary) {

        ASSERT_PASSIVE_LEVEL();
        Status = ZwQueryVolumeInformationFile(
                    Primary,
                    &IoStatusBlock,
                    &FsSizeInformation,
                    sizeof(FILE_FS_SIZE_INFORMATION),
                    FileFsSizeInformation
                    );
        if (!NT_SUCCESS(Status)) {
            return (Status);
        }
        if (FsSizeInformation.BytesPerSector > HBLOCK_SIZE) {
            return (STATUS_REGISTRY_IO_FAILED);
        }
        Cluster = FsSizeInformation.BytesPerSector / HSECTOR_SIZE;
        Cluster = (Cluster < 1) ? 1 : Cluster;
    } else {
        Cluster = 1;
    }

    cmhive2 = CmpAllocate(sizeof(CMHIVE), FALSE,CM_FIND_LEAK_TAG10);

    if (cmhive2 == NULL) {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    cmhive2->UnloadEvent = NULL;
    cmhive2->RootKcb = NULL;
    cmhive2->Frozen = FALSE;
    cmhive2->UnloadWorkItem = NULL;

    cmhive2->GrowOnlyMode = FALSE;
    cmhive2->GrowOffset = 0;
#if DBG
    cmhive2->HiveIsLoading = TRUE;
#endif
    cmhive2->CreatorOwner = NULL;

    InitializeListHead(&(cmhive2->KcbConvertListHead));
    InitializeListHead(&(cmhive2->KnodeConvertListHead));
	cmhive2->CellRemapArray	= NULL;

    //
    // Allocate the mutex from NonPagedPool so it will not be swapped to the disk
    //
    cmhive2->ViewLock = (PKGUARDED_MUTEX)ExAllocatePoolWithTag(NonPagedPool, sizeof(KGUARDED_MUTEX), CM_POOL_TAG );
    if( cmhive2->ViewLock == NULL ) {
        CmpFree(cmhive2, sizeof(CMHIVE));
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

#if DBG
    cmhive2->FlusherLock = (PERESOURCE)ExAllocatePoolWithTag(NonPagedPool, sizeof(ERESOURCE), CM_POOL_TAG );
    if( cmhive2->FlusherLock == NULL ) {
        CmpFreeMutex(cmhive2->ViewLock);
        CmpFree(cmhive2, sizeof(CMHIVE));
        return (STATUS_INSUFFICIENT_RESOURCES);
    }
#endif    

    // need to do this consistently!!!
    cmhive2->FileObject = NULL;
    cmhive2->FileFullPath.Buffer = NULL;
    cmhive2->FileFullPath.Length = 0;
    cmhive2->FileFullPath.MaximumLength = 0;

    cmhive2->FileUserName.Buffer = NULL;
    cmhive2->FileUserName.Length = 0;
    cmhive2->FileUserName.MaximumLength = 0;

    //
    // Initialize the Cm hive control block
    //
    //
    ASSERT((HFILE_TYPE_EXTERNAL+1) == HFILE_TYPE_MAX);
    cmhive2->FileHandles[HFILE_TYPE_PRIMARY] = Primary;
    cmhive2->FileHandles[HFILE_TYPE_LOG] = Log;
    cmhive2->FileHandles[HFILE_TYPE_EXTERNAL] = External;

    cmhive2->NotifyList.Flink = NULL;
    cmhive2->NotifyList.Blink = NULL;

    ExInitializePushLock(&(cmhive2->HiveLock));

#if DBG
    cmhive2->HiveLockOwner = NULL;
    KeInitializeGuardedMutex(cmhive2->ViewLock);
    cmhive2->ViewLockOwner = NULL;
    ExInitializePushLock(&(cmhive2->WriterLock));
    cmhive2->WriterLockOwner = NULL;
    ExInitializeResourceLite(cmhive2->FlusherLock);
    ExInitializePushLock(&(cmhive2->SecurityLock));
    cmhive2->HiveSecurityLockOwner = NULL;
#else
    KeInitializeGuardedMutex(cmhive2->ViewLock);
    ExInitializePushLock(&(cmhive2->WriterLock));
    ExInitializePushLock(&(cmhive2->FlusherLock));
    ExInitializePushLock(&(cmhive2->SecurityLock));
#endif

    CmpInitHiveViewList(cmhive2);
    cmhive2->Flags = 0;
    InitializeListHead(&(cmhive2->TrustClassEntry));
    cmhive2->FlushCount = 0;
    //
    // Initialize the view list
    //
#if DBG
    if( FileName ) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"Initializing HiveViewList for hive (%p) (%.*S) \n\n",cmhive2,FileName->Length / sizeof(WCHAR),FileName->Buffer));
    }
#endif

    //
    // Initialize the security cache
    // 
    CmpInitSecurityCache(cmhive2);
    
    //
    // Initialize the Hv hive control block
    //
    Status = HvInitializeHive(
                &(cmhive2->Hive),
                OperationType,
                HiveFlags,
                FileType,
                HiveData,
                CmpAllocate,
                CmpFree,
                CmpFileSetSize,
                CmpFileWrite,
                CmpFileRead,
                CmpFileFlush,
                Cluster,
                FileName
                );
    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpInitializeHive: "));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"HvInitializeHive failed, Status = %08lx\n", Status));
        
        if( !(cmhive2->Hive.HiveFlags & HIVE_HAS_BEEN_FREED) ) {
            HvpFreeHiveFreeDisplay((PHHIVE)cmhive2);
            HvpCleanMap((PHHIVE)cmhive2);
        }

        CmpFreeMutex(cmhive2->ViewLock);
#if DBG
        CmpFreeResource(cmhive2->FlusherLock);
#endif
        CmpDestroyHiveViewList(cmhive2);
        CmpDestroySecurityCache (cmhive2);
        CmpDropFileObjectForHive(cmhive2);
        CmpUnJoinClassOfTrust(cmhive2);

        CmpCheckForOrphanedKcbs((PHHIVE)cmhive2);

        CmpFree(cmhive2, sizeof(CMHIVE));
        return (Status);


    }
    if ( (OperationType == HINIT_FILE) ||
         (OperationType == HINIT_MAPFILE) ||
         (OperationType == HINIT_MEMORY) ||
         (OperationType == HINIT_MEMORY_INPLACE))
    {

        rc = CmCheckRegistry(cmhive2, CheckFlags);
        if (rc != 0) {

            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpInitializeHive: "));
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmCheckRegistry failed, rc = %08lx\n",rc));
            // 
            // we have dirtied some cells (by clearing the volatile information)
            // we need first to unpin all the views

            CmpDestroyHiveViewList(cmhive2);
            CmpDestroySecurityCache(cmhive2);
            CmpDropFileObjectForHive(cmhive2);
            CmpUnJoinClassOfTrust(cmhive2);

            CmpCheckForOrphanedKcbs((PHHIVE)cmhive2);
            HvFreeHive((PHHIVE)cmhive2);

            CmpFreeMutex(cmhive2->ViewLock);
#if DBG
            CmpFreeResource(cmhive2->FlusherLock);
#endif
            CmpFree(cmhive2, sizeof(CMHIVE));
            return(STATUS_REGISTRY_CORRUPT);
        }
    }

#if DBG
    cmhive2->HiveIsLoading = FALSE;
#endif
    if( !(CheckFlags&CM_DONT_ADD_TO_HIVE_LIST) ) {
        CmpLockHiveListExclusive(); // at the end so system hive is first during the lazy flush iteration
        InsertTailList(&CmpHiveListHead, &(cmhive2->HiveList));
        CmpUnlockHiveList();
    }
    *CmHive = cmhive2;
    return (STATUS_SUCCESS);
}


LOGICAL
CmpDestroyHive(
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell
    )

/*++

Routine Description:

    This routine tears down a cmhive.

Arguments:

    Hive - Supplies a pointer to the hive to be freed.

    Cell - Supplies index of the hive's root cell.

Return Value:

    TRUE if successful
    FALSE if some failure occurred

--*/

{
    PCELL_DATA CellData;
    HCELL_INDEX LinkCell;
    NTSTATUS Status;

    //
    // First find the link cell.
    //
    CellData = HvGetCell(Hive, Cell);
    if( CellData == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        return FALSE;
    }
    LinkCell = CellData->u.KeyNode.Parent;
    HvReleaseCell(Hive, Cell);

    //
    // Now delete the link cell.
    //
    ASSERT(FIELD_OFFSET(CMHIVE, Hive) == 0);
    CmpLockHiveFlusherExclusive(CmpMasterHive);
    Status = CmpFreeKeyByCell((PHHIVE)CmpMasterHive, LinkCell, TRUE);
    CmpUnlockHiveFlusher(CmpMasterHive);

    if (NT_SUCCESS(Status)) {
        //
        // Take the hive out of the hive list
        //
        CmpLockHiveListExclusive();
        CmpRemoveEntryList(&( ((PCMHIVE)Hive)->HiveList));
        CmpUnlockHiveList();
        return(TRUE);
    } else {
        return(FALSE);
    }
}


NTSTATUS
CmpOpenFileWithExtremePrejudice(
    OUT PHANDLE Primary,
    IN POBJECT_ATTRIBUTES Obja,
    IN ULONG IoFlags,
    IN ULONG AttributeFlags
    )

/*++

Routine Description:

    This routine opens a hive file that some person has put a
    read-only attribute on. It is used to prevent people from hurting
    themselves by making the critical system hive files read-only.

Arguments:

    Primary - Returns handle to file

    Obja - Supplies Object Attributes of file.

    IoFlags - Supplies flags to pass to ZwCreateFile

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION FileInfo;

    RtlZeroMemory(&FileInfo, sizeof(FileInfo));
    //
    // Get the current file attributes
    //
    ASSERT_PASSIVE_LEVEL();
    Status = ZwQueryAttributesFile(Obja, &FileInfo);
    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"ZwQueryAttributesFile failed with IO status  %lx\n",Status));
        return(Status);
    }

    //
    // Clear the readonly bit.
    //
    FileInfo.FileAttributes &= ~FILE_ATTRIBUTE_READONLY;

    //
    // Open the file
    //
    Status = ZwOpenFile(&Handle,
                        FILE_WRITE_ATTRIBUTES,
                        Obja,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_OPEN_FOR_BACKUP_INTENT);
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Set the new attributes
    //
    Status = ZwSetInformationFile(Handle,
                                  &IoStatusBlock,
                                  &FileInfo,
                                  sizeof(FileInfo),
                                  FileBasicInformation);
    ZwClose(Handle);
    if (NT_SUCCESS(Status)) {
        //
        // Reopen the file with the access that we really need.
        //
        Status = ZwCreateFile(Primary,
                              FILE_READ_DATA | FILE_WRITE_DATA,
                              Obja,
                              &IoStatusBlock,
                              NULL,
                              AttributeFlags,
                              0,
                              FILE_OPEN,
                              IoFlags,
                              NULL,
                              0);
    }
#if DBG
    else {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"ZwSetInformationFile failed with IO status  %lx\n",Status));
    }
    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpOpenFileWithExtremePrejudice returns with IO status  %lx\n",Status));
#endif

    return(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmmapvw.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmmapvw.c

Abstract:

    This module contains mapped view support for hives.

--*/

#include "cmp.h"

VOID
CmpUnmapCmView(
    IN PCMHIVE              CmHive,
    IN PCM_VIEW_OF_FILE     CmView,
    IN BOOLEAN              MapIsValid,
    IN BOOLEAN              MoveToEnd
    );

PCM_VIEW_OF_FILE
CmpAllocateCmView (
        IN  PCMHIVE             CmHive
                             );

VOID
CmpFreeCmView (
        PCM_VIEW_OF_FILE  CmView
                             );

VOID
CmpUnmapCmViewSurroundingOffset(
        IN  PCMHIVE             CmHive,
        IN  ULONG               FileOffset
        );

VOID
CmpUnmapUnusedViews(
            IN  PCMHIVE             CmHive
    );

BOOLEAN
CmIsFileLoadedAsHive(PFILE_OBJECT FileObject);

extern  PUCHAR      CmpStashBuffer;
extern  ULONG       CmpStashBufferSize;

BOOLEAN CmpTrackHiveClose = FALSE;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpUnmapCmView)
#pragma alloc_text(PAGE,CmpTouchView)
#pragma alloc_text(PAGE,CmpMapCmView)
#pragma alloc_text(PAGE,CmpAcquireFileObjectForFile)
#pragma alloc_text(PAGE,CmpDropFileObjectForHive)
#pragma alloc_text(PAGE,CmpInitHiveViewList)
#pragma alloc_text(PAGE,CmpDestroyHiveViewList)
#pragma alloc_text(PAGE,CmpAllocateCmView)
#pragma alloc_text(PAGE,CmpFreeCmView)
#pragma alloc_text(PAGE,CmpPinCmView)
#pragma alloc_text(PAGE,CmpUnPinCmView)
#pragma alloc_text(PAGE,CmpMapThisBin)
#pragma alloc_text(PAGE,CmpFixHiveUsageCount)
#pragma alloc_text(PAGE,CmpUnmapUnusedViews)

#pragma alloc_text(PAGE,CmpUnmapCmViewSurroundingOffset)
#pragma alloc_text(PAGE,CmpPrefetchHiveFile)
#pragma alloc_text(PAGE,CmPrefetchHivePages)
#pragma alloc_text(PAGE,CmIsFileLoadedAsHive)
#pragma alloc_text(PAGE,CmpReferenceHiveView)
#pragma alloc_text(PAGE,CmpDereferenceHiveView)
#pragma alloc_text(PAGE,CmpReferenceHiveViewWithLock)
#pragma alloc_text(PAGE,CmpDereferenceHiveViewWithLock)
#endif

//
// this controls how many views we allow per each hive (basically how many address space we 
// allow per hive). We use this to optimize boot time.
//
ULONG   CmMaxViewsPerHive = MAX_VIEWS_PER_HIVE;

VOID
CmpUnmapCmView(
    IN PCMHIVE              CmHive,
    IN PCM_VIEW_OF_FILE     CmView,
    IN BOOLEAN              MapIsValid,
    IN BOOLEAN              MoveToEnd
    )
/*++

Routine Description:

    Unmaps the view by marking all the bins that maps inside of it as invalid.

Arguments:

    Hive - Hive containing the section

    CmView - pointer to the view to operate on

    MapIsValid - Hive's map has been successfully initialized (and not yet freed)

    MoveToEnd - moves the view to the end of the LRUList after unmapping
                This is normally TRUE, unless we want to be able to iterate through 
                the entire list and unmap views in the same time


Return Value:

    <none>

--*/
{

    ULONG           Offset;
    ULONG_PTR       Address;
    ULONG_PTR       AddressEnd;
    PHMAP_ENTRY     Me;

    CM_PAGED_CODE();

    ASSERT( (CmView->FileOffset + CmView->Size) != 0 && (CmView->ViewAddress != 0));
    //
    // it is forbidden to unmap a view still in use!
    //
    ASSERT( CmView->UseCount == 0 );

    ASSERT_VIEW_LOCK_OWNED(CmHive);
    //
    // only if the map is still valid
    //
    if( MapIsValid == TRUE ) {
        Offset = CmView->FileOffset;

        AddressEnd = Address = (ULONG_PTR)(CmView->ViewAddress);
        AddressEnd += CmView->Size;
    
        if( Offset == 0 ) {
            //
            // we are at the beginning, we have to skip the base block
            //
            Address += HBLOCK_SIZE;
        } else {
            //
            // we are in the middle of the file. just adjust the offset
            //
            Offset -= HBLOCK_SIZE;
        }
   
        while((Address < AddressEnd) && (Offset < CmHive->Hive.Storage[Stable].Length))
        {
            Me = HvpGetCellMap(&(CmHive->Hive), Offset);
            VALIDATE_CELL_MAP(__LINE__,Me,&(CmHive->Hive),Offset);

            if( Me->BinAddress & HMAP_INPAGEDPOOL ) {
                //
                // if bin is mapped in paged pool for some ubiquitous reason,
                // leave it like that (don't alter it's mapping).
                //
            } else {
                //
                // Invalidate the bin
                //
                Me->BinAddress &= (~HMAP_INVIEW);
        
                // we don't need to set it - just for debug purposes
                ASSERT( (Me->CmView = NULL) == NULL );
            }

            Offset += HBLOCK_SIZE;
            Address += HBLOCK_SIZE;
        }
    }

    //
    // Invalidate the view
    //

    CcUnpinData( CmView->Bcb );

    CmView->FileOffset = 0;
    CmView->Size = 0;
    CmView->ViewAddress = 0;
    CmView->Bcb = NULL;
    CmView->UseCount = 0;

    if( MoveToEnd == TRUE ) {
        //
        // remove the view from the LRU list
        //
        RemoveEntryList(&(CmView->LRUViewList));

        //
        // add it to the end of LRU list
        //
        InsertTailList(
            &(CmHive->LRUViewListHead),
            &(CmView->LRUViewList)
            );
    }
}

VOID
CmpTouchView(
    IN PCMHIVE              CmHive,
    IN PCM_VIEW_OF_FILE     CmView,
    IN ULONG                Cell
            )
/*++

Warning:
    
    This function should be called with the viewlock held!!!

Routine Description:

    Touches the view by moving it at the top of the LRU list.
    This function is to be called from HvpGetCellPaged, every 
    time a view is touched.

Arguments:

    Hive - Hive containing the section

    CmView - pointer to the view to operate on

Return Value:

    <none>

--*/
{
    CM_PAGED_CODE();

#if DBG
    {
        UNICODE_STRING  HiveName;
        RtlInitUnicodeString(&HiveName, (PCWSTR)CmHive->Hive.BaseBlock->FileName);
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"CmpTouchView for hive (%p) (%.*S),",CmHive,HiveName.Length / sizeof(WCHAR),HiveName.Buffer));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"Cell = %8lx ViewAddress = %p ViewSize = %lx\n",Cell,CmView->ViewAddress,CmView->Size));
    }
#else
    UNREFERENCED_PARAMETER (Cell);
#endif
    
    ASSERT( (CmView->FileOffset + CmView->Size) != 0 && (CmView->ViewAddress != 0));

    ASSERT_VIEW_LOCK_OWNED(CmHive);

    if( IsListEmpty(&(CmView->PinViewList)) == FALSE ) {
        //
        // the view is pinned; don't mess with it as it is guaranteed
        // that it'll be in memory until the next flush
        //
        return;
    }

    //
    // optimization: if already is first, do nothing
    //

    if( CmHive->LRUViewListHead.Flink == &(CmView->LRUViewList) ) {
        // remove the bp after making sure it's working properly
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"CmView %p already first\n",CmView));

        //it's already first
        return;
    }

    //
    // remove the view from the LRU list
    //
    RemoveEntryList(&(CmView->LRUViewList));

    //
    // add it on top of LRU list
    //
    InsertHeadList(
        &(CmHive->LRUViewListHead),
        &(CmView->LRUViewList)
        );

}

NTSTATUS
CmpMapCmView(
    IN  PCMHIVE             CmHive,
    IN  ULONG               FileOffset,
    OUT PCM_VIEW_OF_FILE    *CmView,
    IN  BOOLEAN             MapInited
    )
/*++

Warning:
    
    This function should be called with the hivelock held!!!

Routine Description:

    Unmaps the view by marking all the bins that maps inside of it as invalid.

Arguments:

    CmHive - Hive containing the section

    FileOffset - Offset where to map the view

    CmView - pointer to the view to operate on

    MapInited - when TRUE, we can rely on the map info.

Return Value:

    status of the operation

--*/
{

    PHMAP_ENTRY     Me;
    NTSTATUS        Status = STATUS_SUCCESS;
    LARGE_INTEGER   SectionOffset;
    ULONG           Offset;
    ULONG_PTR       Address;
    ULONG_PTR       AddressEnd;
    ULONG_PTR       BinAddress;
    PHBIN           Bin;
    LONG            PrevMappedBinSize; 
    BOOLEAN         FirstTry = TRUE;

    CM_PAGED_CODE();
    
    ASSERT_VIEW_LOCK_OWNED(CmHive);

    if( CmHive->MappedViews == 0 ){
        //
        // we've run out of views; all are pinned
        //
        ASSERT( IsListEmpty(&(CmHive->LRUViewListHead)) == TRUE );
        *CmView = CmpAllocateCmView(CmHive);

    } else {
        //
        // Remove the last view from LRU list (i.e. the LEAST recently used)
        //
        *CmView = (PCM_VIEW_OF_FILE)CmHive->LRUViewListHead.Blink;
        *CmView = CONTAINING_RECORD( *CmView,
                                    CM_VIEW_OF_FILE,
                                    LRUViewList);


        if( (*CmView)->ViewAddress != 0 ) {
            PCM_VIEW_OF_FILE    TempCmView = NULL;
            //
            // the last view is mapped
            //
            if( CmHive->MappedViews < CmMaxViewsPerHive ) { 
                //
                // we are still allowed to add views 
                //
                TempCmView = CmpAllocateCmView(CmHive);
            }
            if( TempCmView == NULL ) {                
                //  
                // we couldn't allocate a new view, or we need to use an existent one
                //
                if( (*CmView)->UseCount != 0 ) {
                    BOOLEAN  FoundView = FALSE;
                    //
                    // view is in use; try walking to the top and find an unused view
                    // 
                    while( (*CmView)->LRUViewList.Blink != &CmHive->LRUViewListHead ) {
                        *CmView = CONTAINING_RECORD( (*CmView)->LRUViewList.Blink,
                                                    CM_VIEW_OF_FILE,
                                                    LRUViewList);
                        if( (*CmView)->UseCount == 0 ) {
                            //
                            // this one is free go ahead and use it !
                            // first unmap, then signal that we found it
                            //
                            if( (*CmView)->ViewAddress != 0 ) {
                                //
                                // unnmap only if mapped
                                //
                                CmpUnmapCmView(CmHive,(*CmView),TRUE,TRUE);
                            }
                            FoundView = TRUE;
                            break;

                        }
                    }
                
                    if( FoundView == FALSE ) {
                        //
                        // no luck, all views are in use allocate a new one (we are forced to do so)
                        //
                        *CmView = CmpAllocateCmView(CmHive);
                    }
                } else {
                    //
                    // unmap it!
                    //
                    CmpUnmapCmView(CmHive,(*CmView),TRUE,TRUE);
                }
            } else {
                //
                // we successfully allocated a new view
                //
                (*CmView) = TempCmView;
            }
        }
    }

    if( (*CmView) == NULL ) {
        //
        // we're running low on resources
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }

#if DBG
    {
        UNICODE_STRING  HiveName;
        RtlInitUnicodeString(&HiveName, (PCWSTR)CmHive->Hive.BaseBlock->FileName);
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"CmpMapCmView for hive (%p) (%.*S),",CmHive,HiveName.Length / sizeof(WCHAR),HiveName.Buffer));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP," FileOfset = %lx ... ",FileOffset));
    }
#endif
    //
    // On this call, FileOffset must be a multiple of CM_VIEW_SIZE
    //

    
    //
    // adjust the file offset to respect the CM_VIEW_SIZE alignment
    //
    Offset = ((FileOffset+HBLOCK_SIZE) & ~(CM_VIEW_SIZE - 1) );
    SectionOffset.LowPart = Offset;
    SectionOffset.HighPart = 0;
    
    (*CmView)->Size = CM_VIEW_SIZE;//(FileOffset + Size) - Offset;

    if( (Offset + (*CmView)->Size) > (CmHive->Hive.Storage[Stable].Length + HBLOCK_SIZE ) ){
        (*CmView)->Size = CmHive->Hive.Storage[Stable].Length + HBLOCK_SIZE - Offset;
    }

RetryToMap:

    try {

        ASSERT( (*CmView)->Size != 0 );
        ASSERT( (*CmView)->ViewAddress == NULL );
        ASSERT( (*CmView)->UseCount == 0 );

        if (!CcMapData( CmHive->FileObject,
                        (PLARGE_INTEGER)&SectionOffset,
                        (*CmView)->Size,
                        MAP_WAIT | MAP_NO_READ,
                        (PVOID *)(&((*CmView)->Bcb)),
                        (PVOID *)(&((*CmView)->ViewAddress)) )) {
            Status = STATUS_CANT_WAIT;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // in low-memory scenarios, CcMapData throws a STATUS_IN_PAGE_ERROR
        // this happens when the IO issued to touch the just-mapped data fails (usually with
        // STATUS_INSUFFICIENT_RESOURCES; We want to catch this and treat as a 
        // "not enough resources" problem, rather than letting it to surface the kernel call
        //
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpMapCmView : CcMapData has raised :%08lx\n",GetExceptionCode()));
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if(!NT_SUCCESS(Status) ){
        if( FirstTry == TRUE ) {
            //
            // unmap all unnecessary views and try again
            //
            FirstTry = FALSE;
            CmpUnmapUnusedViews(CmHive);
            Status = STATUS_SUCCESS;
            goto RetryToMap;
        }
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"Fail\n"));
        ASSERT(FALSE);
        return Status;
    }

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"Succedeed Address = %p Size = %lx\n",(*CmView)->ViewAddress,(*CmView)->Size));

    (*CmView)->FileOffset = SectionOffset.LowPart;

    ASSERT( Offset == (*CmView)->FileOffset);

    AddressEnd = Address = (ULONG_PTR)((*CmView)->ViewAddress);
    AddressEnd += (*CmView)->Size;
    
    if( Offset == 0 ) {
        //
        // we are at the beginning, we have to skip the base block
        //
        Address += HBLOCK_SIZE;
    } else {
        //
        // we are in the middle of the file. just adjust the offset
        //
        Offset -= HBLOCK_SIZE;
    }

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"CmpMapCmView :: Address = %p AddressEnd = %p ; Size = %lx\n",Address,AddressEnd,(*CmView)->Size));
   
    //
    // here we can optimize not to touch all the bins!!!
    //
     
    //
    // we don't know yet if the first bin is mapped.
    //
    PrevMappedBinSize = 0;
    BinAddress = Address;
    while(Address < AddressEnd)
    {
        Me = HvpGetCellMap(&(CmHive->Hive), Offset);
        VALIDATE_CELL_MAP(__LINE__,Me,&(CmHive->Hive),Offset);

        if( Me->BinAddress & HMAP_INPAGEDPOOL ) {
            //
            // if bin is mapped in paged pool for some reason,
            // leave it like that (don't alter it's mapping).
            //
            
            //
            // next mapped bin should start updating his bin address
            //
            PrevMappedBinSize = 0;
        } else {
            //
            // at this point the bin should be invalid.
            //
            ASSERT_BIN_INVALID(Me);

            Me->BinAddress |= HMAP_INVIEW;
            Me->CmView = *CmView;

            //
            // set the new BinAddress, but take care to preserve the flags
            //
            ASSERT( HBIN_FLAGS(Address) == 0 );

            

            //
            // new bins are Always tagged with this flag (we can start updating BinAddress) 
            //
            if( MapInited && ( Me->BinAddress & HMAP_NEWALLOC ) ) {

                //
                // we are at the beginning of a new bin
                //
                BinAddress = Address;
            } else if( (!MapInited) &&(PrevMappedBinSize == 0) ) {
                //
                // we cannot rely on the map to carry the bin flags; we have to fault data in
                //
                //
                // Validate the bin
                //
                Bin = (PHBIN)Address;
                PrevMappedBinSize = (LONG)Bin->Size;
                //
                // we are at the beginning of a new bin
                //
                BinAddress = Address;
            }

            //
            // common sense
            //
            ASSERT( (!MapInited) || ((PrevMappedBinSize >=0) && (PrevMappedBinSize%HBLOCK_SIZE == 0)) );

            Me->BinAddress = ( HBIN_BASE(BinAddress) | HBIN_FLAGS(Me->BinAddress) );
            if( (Me->BinAddress & HMAP_DISCARDABLE) == 0 ) {
                //
                // for discardable bins do not alter this member, as it contains
                // the address of the free bin
                //
                Me->BlockAddress = Address;
            }

            if( !MapInited ) {
                //
                // compute the remaining size of this bin; next iteration will update BinAddress only if 
                // this variable reaches 0
                //
                PrevMappedBinSize -= HBLOCK_SIZE;
            }

            ASSERT_BIN_INVIEW(Me);
        }

        Offset += HBLOCK_SIZE;
        Address += HBLOCK_SIZE;
    }
    
    return Status;
}

VOID
CmpUnmapCmViewSurroundingOffset(
        IN  PCMHIVE             CmHive,
        IN  ULONG               FileOffset
        )
/*++

Routine Description:

    Parses the mapped view list and if it finds one surrounding this offset, unmaps it.
      
Arguments:

    CmHive - Hive in question

    FileOffset - the offset in question

Return Value:

    none

Note: 
    
    Offset is an absolute value, 
--*/
{
    PCM_VIEW_OF_FILE    CmView;
    USHORT              NrViews;
    BOOLEAN             UnMap = FALSE;
    
    CM_PAGED_CODE();

    ASSERT_VIEW_LOCK_OWNED(CmHive);
    // 
    // Walk through the LRU list and compare view addresses
    //
    CmView = (PCM_VIEW_OF_FILE)CmHive->LRUViewListHead.Flink;

    for(NrViews = CmHive->MappedViews;NrViews;NrViews--) {
        CmView = CONTAINING_RECORD( CmView,
                                    CM_VIEW_OF_FILE,
                                    LRUViewList);
        
        if( ((CmView->Size + CmView->FileOffset) != 0) && (CmView->ViewAddress != 0) )  {
            //
            // view is valid
            //
            if( (CmView->FileOffset <= FileOffset) && ((CmView->FileOffset + CmView->Size) > FileOffset) ) {
                //
                // the file offset is surrounded by this view
                //
                UnMap = TRUE;
                break;
            }
        }

        CmView = (PCM_VIEW_OF_FILE)CmView->LRUViewList.Flink;
    }

    if( UnMap == TRUE ) {
        // unmap the view anyway (this implies unpinning).
        ASSERT_VIEW_MAPPED( CmView );
        ASSERT( CmView->UseCount == 0 );
        CmpUnmapCmView(CmHive,CmView,TRUE,TRUE);
    }
}

PCM_VIEW_OF_FILE
CmpAllocateCmView (
        IN  PCMHIVE             CmHive
                             )
/*++

Routine Description:

    Allocate a CM-view.
    Insert it in  various list.

Arguments:

    CmHive - Hive in question


Return Value:

    the new view

--*/
{
    PCM_VIEW_OF_FILE  CmView;
    
    CM_PAGED_CODE();

    CmView = ExAllocatePoolWithTag(PagedPool,sizeof(CM_VIEW_OF_FILE),CM_MAPPEDVIEW_TAG | PROTECTED_POOL);
    
    if (CmView == NULL) {
        //
        // we're low on resources; we should handle the error path for this.
        //
        return NULL;
    }
    
    //
    // Init the view
    //
    CmView->FileOffset = 0;
    CmView->Size = 0;
    CmView->ViewAddress = NULL;
    CmView->Bcb = NULL;
    CmView->UseCount =0;
    
    //
    // add it to the list(s)
    //
    InitializeListHead(&(CmView->PinViewList));

    InsertTailList(
        &(CmHive->LRUViewListHead),
        &(CmView->LRUViewList)
        );
    
    CmHive->MappedViews++;
    return CmView;
}

VOID
CmpInitHiveViewList (
        IN  PCMHIVE             CmHive
                             )
/*++

Routine Description:

    adds the first view to the LRU list.
    others are added as needed.!

Arguments:

    CmHive - Hive in question

--*/
{

    CM_PAGED_CODE();

    // 
    // Init the heads.
    //
    InitializeListHead(&(CmHive->PinViewListHead));
    InitializeListHead(&(CmHive->LRUViewListHead));

    CmHive->MappedViews = 0;
    CmHive->PinnedViews = 0;
    CmHive->UseCount = 0;
}

VOID
CmpDestroyHiveViewList (
        IN  PCMHIVE             CmHive
                             )
/*++

Routine Description:

    Frees the storage fo all the views used by this hive

Arguments:

    CmHive - Hive in question

--*/
{
    PCM_VIEW_OF_FILE    CmView;

    CM_PAGED_CODE();

    if( CmHive->FileObject == NULL ) {
        //
        // hive is not mapped.
        //
        return;
    }

    // 
    // Walk through the Pinned View list and free all the views
    //
    while( IsListEmpty( &(CmHive->PinViewListHead) ) == FALSE ) {
        CmView = (PCM_VIEW_OF_FILE)RemoveHeadList(&(CmHive->PinViewListHead));
        CmView = CONTAINING_RECORD( CmView,
                                    CM_VIEW_OF_FILE,
                                    PinViewList);
        
        ASSERT_VIEW_PINNED(CmView);
        //
        // we need to move this view to the mapped view list and remember to purge after all 
        // views have been unmapped. Otherwise we rick deadlock on CcWaitOnActiveCount, when we purge

        //
        //
        // sanity check; we shouldn't get here for a read-only hive
        //
        ASSERT( CmHive->Hive.ReadOnly == FALSE );

        //
        // empty the LRUList for this view
        //
        InitializeListHead(&(CmView->PinViewList));
    
        //
        // update the counters
        //
        CmHive->PinnedViews--;        
        CmHive->MappedViews++;        

        //
        // add it at the tail of LRU list for this hive
        //
        InsertTailList(
            &(CmHive->LRUViewListHead),
            &(CmView->LRUViewList)
            );
        
    }

    //
    // At this point, there should be no pinned view
    //
    ASSERT( IsListEmpty(&(CmHive->PinViewListHead)) == TRUE);
    ASSERT( CmHive->PinnedViews == 0 );

    // 
    // Walk through the LRU list and free all the views
    //
    while( IsListEmpty( &(CmHive->LRUViewListHead) ) == FALSE ) {
        CmView = (PCM_VIEW_OF_FILE)CmHive->LRUViewListHead.Flink;
        CmView = CONTAINING_RECORD( CmView,
                                    CM_VIEW_OF_FILE,
                                    LRUViewList);
        if( CmView->ViewAddress != 0 ) {
            //
            // view is mapped; unmap it
            // we should not encounter that in sane systems
            // this can happen only when a hive-loading fails 
            // in HvpMapFileImageAndBuildMap
            // no need move it as we are going to free it anyway
            //
            CmpUnmapCmView(CmHive,CmView,FALSE,FALSE);
        }

        //
        // update the counter
        //
        CmHive->MappedViews--;

        //
        // remove the view from the LRU list
        //
        RemoveEntryList(&(CmView->LRUViewList));

        ExFreePoolWithTag(CmView, CM_MAPPEDVIEW_TAG | PROTECTED_POOL);
    }

    ASSERT( CmHive->MappedViews == 0 );
    ASSERT( CmHive->UseCount == 0 );

    //
    // we need to purge as the FS cannot do it for us (private writers)
    // valid data is already on the disk by now (it should!)
    // purge and flush everything 
    //
    CcPurgeCacheSection(CmHive->FileObject->SectionObjectPointer,(PLARGE_INTEGER)(((ULONG_PTR)NULL) + 1)/*we are private writers*/,0/*ignored*/,FALSE);
    //
    // This is for the case where the last flush failed (we couldn't write the log file....) 
    // .... then : flush the cache to clear dirty hints added by the purge
    //
    CcFlushCache (CmHive->FileObject->SectionObjectPointer,(PLARGE_INTEGER)(((ULONG_PTR)NULL) + 1)/*we are private writers*/,0/*ignored*/,NULL);

    //
    // Flush again to take care of the dirty pages that may appear due to FS page zeroing
    //
    CcFlushCache (CmHive->FileObject->SectionObjectPointer,(PLARGE_INTEGER)(((ULONG_PTR)NULL) + 1)/*we are private writers*/,0/*ignored*/,NULL);
}

VOID
CmpDropFileObjectForHive(
        IN  PCMHIVE             CmHive
            )
/*++

Routine Description:

    Drops the extra reference kept on the file object (if any)
    and frees the name 

Arguments:

    CmHive

Return Value:

    none

--*/
{
    
    CM_PAGED_CODE();

    if( CmHive->FileUserName.Buffer != NULL ) {
        ExFreePoolWithTag(CmHive->FileUserName.Buffer, CM_NAME_TAG | PROTECTED_POOL);
        CmHive->FileUserName.Buffer = NULL;
        CmHive->FileUserName.Length = 0;
        CmHive->FileUserName.MaximumLength = 0;
    } else {
        ASSERT(CmHive->FileUserName.Length == 0);
        ASSERT(CmHive->FileUserName.MaximumLength == 0);
    }

    if( CmHive->FileObject == NULL ) {
        // debug only code
        ASSERT(CmHive->FileFullPath.Buffer == NULL);
        ASSERT(CmHive->FileFullPath.Length == 0);
        ASSERT(CmHive->FileFullPath.MaximumLength == 0);
        return;
    }
    
    // debug only code
    if( CmHive->FileFullPath.Buffer != NULL ) {
        ExFreePoolWithTag(CmHive->FileFullPath.Buffer, CM_NAME_TAG | PROTECTED_POOL);
        CmHive->FileFullPath.Buffer = NULL;
        CmHive->FileFullPath.Length = 0;
        CmHive->FileFullPath.MaximumLength = 0;
    } else {
        ASSERT(CmHive->FileFullPath.Length == 0);
        ASSERT(CmHive->FileFullPath.MaximumLength == 0);
    }

    ObDereferenceObject((PVOID)(CmHive->FileObject));

    CmHive->FileObject = NULL;
}

NTSTATUS
CmpAcquireFileObjectForFile(
        IN  PCMHIVE         CmHive,
        IN HANDLE           FileHandle,
        OUT PFILE_OBJECT    *FileObject
            )
/*++

Routine Description:

    Creates the section for the given file handle.
    the section is used to map/unmap views of the file

Arguments:

    FileHandle - Handle of the file

    SectionPointer - the section object

Return Value:

    status of the operation

--*/
{
    NTSTATUS                    Status,Status2;
    POBJECT_NAME_INFORMATION    FileNameInfo;
    ULONG                       ReturnedLength;
    ULONG                       FileNameLength;

    CM_PAGED_CODE();

    Status = ObReferenceObjectByHandle ( FileHandle,
                                         FILE_READ_DATA | FILE_WRITE_DATA,
                                         IoFileObjectType,
                                         KernelMode,
                                         (PVOID *)FileObject,
                                         NULL );
    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"[CmpAcquireFileObjectForFile] Could not reference file object status = %x\n",Status));
    } else {
        //
        // call cc private to mark the stream as Modify-No-Write
        //
        if( !CcSetPrivateWriteFile(*FileObject) ) {
            //
            // filter out invalid failures to initialize the cache
            // top-level routine CmpInitHiveFromFile will retry to load the hive in the old fashion way.
            //
            CmpDropFileObjectForHive(CmHive);
            (*FileObject) = NULL;
            return STATUS_RETRY;
        }
        
        LOCK_STASH_BUFFER();
        //
        // capture the full path of the file
        //
        ASSERT( CmpStashBuffer != NULL );
        
        FileNameInfo = (POBJECT_NAME_INFORMATION)CmpStashBuffer;

        //
        // Try to get the name for the file object. 
        //
        Status2 = ObQueryNameString(*FileObject,
                                    FileNameInfo,
                                    CmpStashBufferSize,
                                    &ReturnedLength);
        if (NT_SUCCESS(Status2)) {

            //
            // Allocate a file name buffer and copy into it. 
            // The file names will be NUL terminated. Allocate extra for that.
            //

            FileNameLength = FileNameInfo->Name.Length / sizeof(WCHAR);

            CmHive->FileFullPath.Buffer = ExAllocatePoolWithTag(PagedPool,
                                                                (FileNameLength + 1) * sizeof(WCHAR),
                                                                CM_NAME_TAG | PROTECTED_POOL);

            if (CmHive->FileFullPath.Buffer) {

                RtlCopyMemory(CmHive->FileFullPath.Buffer,
                              FileNameInfo->Name.Buffer,
                              FileNameLength * sizeof(WCHAR));

                //
                // Make sure it is NUL terminated.
                //

                CmHive->FileFullPath.Buffer[FileNameLength] = 0;
                CmHive->FileFullPath.Length = FileNameInfo->Name.Length;
                CmHive->FileFullPath.MaximumLength = FileNameInfo->Name.Length + sizeof(WCHAR);

            } else {
                //
                // not fatal, just that we won't be able to prefetch this hive
                //
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"[CmpAcquireFileObjectForFile] Could not allocate buffer for fullpath for fileobject %p\n",*FileObject));
            }

        } else {
            //
            // not fatal, just that we won't be able to prefetch this hive
            //
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"[CmpAcquireFileObjectForFile] Could not retrieve name for fileobject %p, Status = %lx\n",*FileObject,Status2));
            CmHive->FileFullPath.Buffer = NULL;
        }
        UNLOCK_STASH_BUFFER();
        
    }    

    return Status;
}

NTSTATUS
CmpMapThisBin(
                PCMHIVE         CmHive,
                HCELL_INDEX     Cell,
                BOOLEAN         Touch
              )
/*++

Routine Description:

    Makes sure the bin is mapped in memory. 

Arguments:

Return Value:


--*/
{
    PCM_VIEW_OF_FILE CmView;
    
    CM_PAGED_CODE();

    //
    // ViewLock must be held 
    //
    ASSERT_VIEW_LOCK_OWNED(CmHive);

    //
    // bin is either mapped, or invalid
    //
    ASSERT( HvGetCellType(Cell) == Stable );
    //
    // map the bin
    //
    if( !NT_SUCCESS (CmpMapCmView(CmHive,Cell,&CmView,TRUE) ) ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if( Touch == TRUE ) {
        //
        // touch the view
        //
        CmpTouchView(CmHive,CmView,(ULONG)Cell);
    } else {
        //
        // if we are here; we should have either the reg lock exclusive
        // or the reg lock shared AND the hive lock. 
        // Find a way to assert that!!!
        //
    }
    
    return STATUS_SUCCESS;
}

NTSTATUS
CmpPinCmView (
        IN  PCMHIVE             CmHive,
        PCM_VIEW_OF_FILE        CmView
                             )
/*++

Routine Description:

    Pins the specified view into memory

    The view is removed from the LRU list.
    Then, the view is moved to the PinList

Arguments:

    CmHive - Hive in question
    
    CmView - View in question

Return Value:

    the new view

--*/
{
    LARGE_INTEGER   SectionOffset;
    NTSTATUS        Status = STATUS_SUCCESS;
    PVOID           SaveBcb;                
    
    CM_PAGED_CODE();

#if DBG
    {
        UNICODE_STRING  HiveName;
        RtlInitUnicodeString(&HiveName, (PCWSTR)CmHive->Hive.BaseBlock->FileName);
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"CmpPinCmView %lx for hive (%p) (%.*S), Address = %p Size = %lx\n",CmView,CmHive,HiveName.Length / sizeof(WCHAR),HiveName.Buffer,CmView->ViewAddress,CmView->Size));
    }
#endif

    //
    // We only pin mapped views
    //
    ASSERT_VIEW_MAPPED(CmView);

    ASSERT_VIEW_LOCK_OWNED(CmHive);
    
    //
    // sanity check; we shouldn't get here for a read-only hive
    //
    ASSERT( CmHive->Hive.ReadOnly == FALSE );

    // we may need this later
    SaveBcb = CmView->Bcb;

    SectionOffset.LowPart = CmView->FileOffset;
    SectionOffset.HighPart = 0;
    try {
        //
        // the MOST important: pin the view
        //
        if( !CcPinMappedData(   CmHive->FileObject,
                                &SectionOffset,
                                CmView->Size,
                                TRUE, // wait == synchronous call
                                &(CmView->Bcb) )) {
            //
            // this should never happen; handle it, though
            //
        
            ASSERT( FALSE );
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // in low-memory scenarios, CcPinMappedData throws a STATUS_INSUFFICIENT_RESOURCES
        // We want to catch this and treat as a  "not enough resources" problem, 
        // rather than letting it to surface the kernel call
        //
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpPinCmView : CcPinMappedData has raised :%08lx\n",GetExceptionCode()));
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if( NT_SUCCESS(Status) ) {
        //
        // Pin succeeded, move the view to the pinned list
        // remove the view from the LRU list
        //
        RemoveEntryList(&(CmView->LRUViewList));
        //
        // empty the LRUList for this view
        //
        InitializeListHead(&(CmView->LRUViewList));
    
        //
        // add it at the tail of pinned list for this hive
        //
        InsertTailList(
            &(CmHive->PinViewListHead),
            &(CmView->PinViewList)
            );
    
        //
        // update the counters
        //
        CmHive->MappedViews--;        
        CmHive->PinnedViews++;        
    } else {
        //
        // pin failed; we need to restore view data that may have been altered by the pin call
        // view will remain mapped
        //
        CmView->Bcb = SaveBcb;
    }

    // make sure we didn't unmapped/punned more than we mapped/pinned
    ASSERT( (CmHive->MappedViews >= 0) ); // && (CmHive->MappedViews < CmMaxViewsPerHive) );
    ASSERT( (CmHive->PinnedViews >= 0) );
    
    return Status;
}

VOID
CmpUnPinCmView (
        IN  PCMHIVE             CmHive,
        IN  PCM_VIEW_OF_FILE    CmView,
        IN  BOOLEAN             SetClean,
        IN  BOOLEAN             MapValid
                             )
/*++

Routine Description:

    UnPins the specified view from memory

    The view is NOT in the PinViewList !!! (it has already been removed !!!!!!)
    Then, the view is moved to the LRUList.
    If more than CmMaxViewsPerHive are in LRU list, the view is freed

    This function always grabs the ViewLock for the hive!!!

Arguments:

    CmHive - Hive in question
    
    CmView - View in question

    SetClean - Tells whether the changes made to this view should be discarded

--*/
{
    LIST_ENTRY  *LRUListEntry;
    LARGE_INTEGER   FileOffset;         // where the mapping starts
    ULONG           Size;               // size the view maps

    
    CM_PAGED_CODE();

    //
    // Grab the viewLock, to protect the viewlist
    //
    CmLockHiveViews (CmHive);

    //
    // We only pin mapped views
    //
    ASSERT_VIEW_PINNED(CmView);
    
    //
    // sanity check; we shouldn't get here for a read-only hive
    //
    ASSERT( CmHive->Hive.ReadOnly == FALSE );

    //
    // empty the LRUList for this view
    //
    InitializeListHead(&(CmView->PinViewList));
    
    //
    // update the counters
    //
    CmHive->PinnedViews--;        
    CmHive->MappedViews++;        

    //
    // add it at the tail of LRU list for this hive
    //
    InsertTailList(
        &(CmHive->LRUViewListHead),
        &(CmView->LRUViewList)
        );
    
    //
    // store the FileOffset and size as we will need them for purging
    //
    FileOffset.LowPart = CmView->FileOffset;
    FileOffset.HighPart = 0;
    Size = CmView->Size;

    if( SetClean == TRUE ) {
        ASSERT( CmView->UseCount == 0 );
        //
        // unmap the view (this implies unpinning).
        //
        CmpUnmapCmView(CmHive,CmView,MapValid,TRUE);
        //
        // purge cache data
        //
        CcPurgeCacheSection(CmHive->FileObject->SectionObjectPointer,(PLARGE_INTEGER)(((ULONG_PTR)(&FileOffset)) + 1)/*we are private writers*/,Size,FALSE);
    } else {
        PVOID           NewBcb;
        PULONG_PTR      NewViewAddress;        
        NTSTATUS        Status = STATUS_SUCCESS;

        //
        // the data is to be saved to the file,
        // notify the cache manager that the data is dirty
        //
        CcSetDirtyPinnedData (CmView->Bcb,NULL);

        //
        // remap this view so we don't lose the refcount on this address range
        //
        try {
            if (!CcMapData( CmHive->FileObject,
                            (PLARGE_INTEGER)&FileOffset,
                            CmView->Size,
                            MAP_WAIT | MAP_NO_READ,
                            (PVOID *)(&NewBcb),
                            (PVOID *)(&NewViewAddress) )) {

                Status = STATUS_CANT_WAIT;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // in low-memory scenarios, CcMapData throws a STATUS_IN_PAGE_ERROR
            // this happens when the IO issued to touch the just-mapped data fails (usually with
            // STATUS_INSUFFICIENT_RESOURCES; We want to catch this and treat as a 
            // "not enough resources" problem, rather than letting it to surface the kernel call
            //
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpUnPinCmView : CcMapData has raised :%08lx\n",GetExceptionCode()));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            NewBcb = NULL;
            NewViewAddress = NULL;
        }

        if( !NT_SUCCESS(Status) ) {
            //
            // CcMap didn't succeeded; bad luck, just unmap (implies unpinning).
            //
            CmpUnmapCmView(CmHive,CmView,MapValid,TRUE);
        } else {
            BOOLEAN  FoundView = FALSE;
            //
            // sanity asserts; Cc guarantees the same address is returned.
            //
            ASSERT( FileOffset.LowPart == CmView->FileOffset );
            ASSERT( NewViewAddress == CmView->ViewAddress );
            //
            // unpin old data
            //
            CcUnpinData( CmView->Bcb );
            //
            // replace the bcb for this view; there is no need to modify the map as the 
            // address and the size of the view remains the same; We just need to update the bcb
            //
            CmView->Bcb = NewBcb;
            //
            // move the view on top of the LRU list (consider it as "hot")
            //
            RemoveEntryList(&(CmView->LRUViewList));
            InsertHeadList(
                &(CmHive->LRUViewListHead),
                &(CmView->LRUViewList)
                );
            //
            // walk the LRU list back-wards until we find an unused view
            // 
            for (LRUListEntry = CmHive->LRUViewListHead.Blink;
                    LRUListEntry != &CmHive->LRUViewListHead;
                    LRUListEntry = LRUListEntry->Blink) {
                CmView = CONTAINING_RECORD( LRUListEntry,
                                            CM_VIEW_OF_FILE,
                                            LRUViewList);
                if( CmView->UseCount == 0 ) {
                    //
                    // this one is free go ahead and use it !
                    // first unmap, then signal that we found it
                    //
                    if( (CmHive->MappedViews >= CmMaxViewsPerHive) && (CmView->Bcb != NULL) ) {
                        CmpUnmapCmView(CmHive,CmView,MapValid,TRUE);
                    }
                    FoundView = TRUE;
                    break;

                }
            }
            //
            // all views are in use; bad luck, we just have to live with it (extend past MAX_VIEW_SIZE)
            //
            if( FoundView == FALSE ) {
                CmView = NULL;
            }

        }
    }
    //
    // immediately flush the cache so these dirty pages won't throttle other IOs
    // in case we did a CcPurge, this will clean out the Cc dirty hints. 
	//
    CcFlushCache (CmHive->FileObject->SectionObjectPointer,(PLARGE_INTEGER)(((ULONG_PTR)(&FileOffset)) + 1)/*we are private writers*/,Size,NULL);

    if( (CmHive->MappedViews >= CmMaxViewsPerHive) && (CmView != NULL) ) {
        
        // assert view unmapped
        ASSERT( ((CmView->FileOffset + CmView->Size) == 0) && (CmView->ViewAddress == 0) );
        //
        // no more views are allowed for this hive
        //
        RemoveEntryList(&(CmView->LRUViewList));
#if DBG
        //
        // do this to signal that LRUViewList is empty.
        //
        InitializeListHead(&(CmView->LRUViewList));
#endif
        CmpFreeCmView(CmView);        
        CmHive->MappedViews --;
    } 

    // make sure we didn't unmapped/unpinned more than we mapped/pinned
    ASSERT( (CmHive->MappedViews >= 0) ); // && (CmHive->MappedViews < CmMaxViewsPerHive) );
    ASSERT( (CmHive->PinnedViews >= 0) );
    
    //
    // at last, release the view lock
    //
    CmUnlockHiveViews (CmHive);

    return;
}

VOID
CmpFreeCmView (
        PCM_VIEW_OF_FILE  CmView
                             )
/*++

Routine Description:

    frees a CM View

Arguments:

Return Value:

--*/
{
    
    CM_PAGED_CODE();

    if (CmView == NULL) {
        CM_BUGCHECK(REGISTRY_ERROR,CMVIEW_ERROR,2,0,0);
    }
    
    //
    // Init the view
    //
    ASSERT( CmView->FileOffset == 0 );
    ASSERT( CmView->Size == 0 );
    ASSERT( CmView->ViewAddress == NULL );
    ASSERT( CmView->Bcb == NULL );
    ASSERT( CmView->UseCount == 0 );
    ASSERT( IsListEmpty(&(CmView->PinViewList)) == TRUE );
    ASSERT( IsListEmpty(&(CmView->LRUViewList)) == TRUE );
    
    ExFreePoolWithTag(CmView, CM_MAPPEDVIEW_TAG | PROTECTED_POOL);
    
    return;
}

VOID
CmpFixHiveUsageCount(
                    IN  PCMHIVE             CmHive
                    )

/*++

Routine Description:

    This is registry's contingency plan against bad and misbehaved apps.
    In a perfect world this should never be called; If we get here, somewhere
    inside a cm function we took an exception and never had a chance to 
    release all used cells. We fix that here, and as we hold the reglock exclusive,
    we are safe to do so.

    We have to clear each view UseCount and the hive UseCount.
    Also, unmap all views that are beyond CmMaxViewsPerHive


Arguments:

    Hive to be fixed

Return Value:

    none

--*/
{
    PCM_VIEW_OF_FILE    CmCurrentView;
    USHORT              NrViews;

    CM_PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"CmpFixHiveUsageCount : Contingency plan, fixing hive %p UseCount = %lx \n",CmHive,CmHive->UseCount));

    //
    // lock should be held exclusive and we should have a good reason to come here
    //
    ASSERT( CmHive->UseCount );

    // 
    // Walk through the LRU list and fix each view
    //
    CmCurrentView = (PCM_VIEW_OF_FILE)CmHive->LRUViewListHead.Flink;

    for(NrViews = CmHive->MappedViews;NrViews;NrViews--) {
        CmCurrentView = CONTAINING_RECORD(  CmCurrentView,
                                            CM_VIEW_OF_FILE,
                                            LRUViewList);

        CmCurrentView->UseCount = 0;

        CmCurrentView = (PCM_VIEW_OF_FILE)CmCurrentView->LRUViewList.Flink;
    }

    //
    // unmap views from CmHive->MappedViews to CmMaxViewsPerHive
    //
    while( CmHive->MappedViews >= CmMaxViewsPerHive ) {
        //
        // get the last view from the list
        //
        CmCurrentView = (PCM_VIEW_OF_FILE)CmHive->LRUViewListHead.Blink;
        CmCurrentView = CONTAINING_RECORD(  CmCurrentView,
                                            CM_VIEW_OF_FILE,
                                            LRUViewList);

        //
        // unmap it; no need to move it at the end as we shall free it anyway
        //
        CmpUnmapCmView(CmHive,CmCurrentView,TRUE,FALSE);

        //
        // remove it from LRU list
        //
        RemoveEntryList(&(CmCurrentView->LRUViewList));
#if DBG
        //
        // do this to signal that LRUViewList is empty.
        //
        InitializeListHead(&(CmCurrentView->LRUViewList));
#endif
        CmpFreeCmView(CmCurrentView);        
        CmHive->MappedViews --;

    }

    // 
    // Walk through the pinned list and fix each view 
    //
    CmCurrentView = (PCM_VIEW_OF_FILE)CmHive->PinViewListHead.Flink;

    for(NrViews = CmHive->PinnedViews;NrViews;NrViews--) {
        CmCurrentView = CONTAINING_RECORD(  CmCurrentView,
                                            CM_VIEW_OF_FILE,
                                            PinViewList);
        
        CmCurrentView->UseCount = 0;

        CmCurrentView = (PCM_VIEW_OF_FILE)CmCurrentView->PinViewList.Flink;
    }

    //
    // finally, fix hive use count
    //
    CmHive->UseCount = 0;

}

VOID
CmpPrefetchHiveFile( 
                    IN PFILE_OBJECT FileObject,
                    IN ULONG        Length
                    )
/*++

Routine Description:

    Prefetch all file into memory.
    We're using MmPrefetchPages fast routine; Pages will be put in the transition
    state, and they'll be used by the hive load worker while mapping data
  
Arguments:

    FileObject - file object associated with the file to be prefetched

    Length - length of the file
    
Return Value:

    none

--*/
{
    ULONG       NumberOfPages;
    PREAD_LIST  *ReadLists;
    PREAD_LIST  ReadList;
    ULONG       AllocationSize;
    ULONG       Offset;

    CM_PAGED_CODE();

    NumberOfPages = ROUND_UP(Length,PAGE_SIZE) / PAGE_SIZE ;

    ReadLists = ExAllocatePoolWithTag(NonPagedPool, sizeof(PREAD_LIST), CM_POOL_TAG);
    if (ReadLists == NULL) {
        return;
    }

    AllocationSize = sizeof(READ_LIST) + (NumberOfPages * sizeof(FILE_SEGMENT_ELEMENT));

    ReadList = ExAllocatePoolWithTag(NonPagedPool,AllocationSize,CM_POOL_TAG);

    if (ReadList == NULL) {
        ExFreePool(ReadLists);
        return;
    }

    ReadList->FileObject = FileObject;
    ReadList->IsImage = FALSE;
    ReadList->NumberOfEntries = 0;
    Offset = 0;
    while( Offset < Length ) {
        ReadList->List[ReadList->NumberOfEntries].Alignment = Offset;
        ReadList->NumberOfEntries++;
        Offset += PAGE_SIZE;
    }
    ASSERT( ReadList->NumberOfEntries == NumberOfPages );

    ReadLists[0] = ReadList;

    MmPrefetchPages (1,ReadLists);
    
    ExFreePool(ReadList);
    ExFreePool(ReadLists);
}


VOID
CmpUnmapUnusedViews(
        IN  PCMHIVE             CmHive
    )
/*++

Routine Description:

    Unmaps all mapped views than are not currently in-use.

    The purpose of this is to allow a retry in case CcMapData failed
    because of the system having to many mapped views.

    We should not run into this too often ( - at all ).

Arguments:
    
      CmHive - hive for which we already have the viewlist lock owned
    
Return Value:

    none
--*/
{
    PCM_VIEW_OF_FILE    CmView;
    USHORT              NrViews;
    PCMHIVE             CmCurrentHive;
    PLIST_ENTRY         p;

    CM_PAGED_CODE();

    //
    // iterate through the hive list
    //
    CmpLockHiveListShared();
    p = CmpHiveListHead.Flink;
    while(p != &CmpHiveListHead) {
        CmCurrentHive = (PCMHIVE)CONTAINING_RECORD(p, CMHIVE, HiveList);
        
        if( CmCurrentHive < CmHive ) {
            //
            // we need to be the only ones operating on this list
            //
            CmLockHiveViews (CmCurrentHive);
        } else if( CmCurrentHive == CmHive ) {
            //
            // we already have the mutex owned
            //
            NOTHING;
        } else {
            //
            // can't lock this one as we may deadlock with another thread racing us here
            //
            goto Ignore;
        }
        //
        // try to unmap all mapped views
        //
        CmView = (PCM_VIEW_OF_FILE)CmCurrentHive->LRUViewListHead.Flink;

        for(NrViews = CmCurrentHive->MappedViews;NrViews;NrViews--) {
            CmView = CONTAINING_RECORD( CmView,
                                        CM_VIEW_OF_FILE,
                                        LRUViewList);
        
            if( (CmView->ViewAddress != 0) && ( CmView->UseCount == 0 ) ) {
                //
                // view is mapped and it is not in use 
                //
                ASSERT( (CmView->FileOffset + CmView->Size) != 0 && (CmView->Bcb != 0));

                //
                // unmap it without altering its position in the list
                //
                CmpUnmapCmView(CmCurrentHive,CmView,TRUE,FALSE);
            }
    
            CmView = (PCM_VIEW_OF_FILE)CmView->LRUViewList.Flink;
        }

        if( CmCurrentHive != CmHive ) {
            CmUnlockHiveViews (CmCurrentHive);
        }

Ignore:
        p=p->Flink;
    }
    CmpUnlockHiveList();

}

NTSTATUS
CmPrefetchHivePages(
                    __in PUNICODE_STRING     FullHivePath,
                    __inout PREAD_LIST      ReadList
                           )
/*++

Routine Description:

    Searches through the hive list for a hive with the backing file of name FullHivePath
    Builds a READ_LIST based on the given page offsets array and prefetches the pages 

Arguments:

    FullHivePath - Full Path of the file

    ReadList - read_list of page offsets to be prefetched.

Return Value:

    STATUS_SUCCESS - OK, pages prefetched

    STATUS_INVALID_PARAMETER - file was not found in the machine's hive list

    else, status returned by MmPrefetchPages.

--*/
{
    PCMHIVE             CmHive = NULL;
    PLIST_ENTRY         p;
    NTSTATUS            Status;

    CM_PAGED_CODE();

    if( ReadList == NULL ) {
        return STATUS_INVALID_PARAMETER;
    }

    CmpLockRegistry();

    //
    // iterate through the hive list
    //
    CmpLockHiveListShared();
    p = CmpHiveListHead.Flink;
    while(p != &CmpHiveListHead) {
        CmHive = (PCMHIVE)CONTAINING_RECORD(p, CMHIVE, HiveList);
        
        if( (CmHive->FileObject != NULL) && (CmHive->FileFullPath.Buffer != NULL) ) {
            //
            // there is a chance this might be the one
            //
            if( RtlCompareUnicodeString(FullHivePath,&(CmHive->FileFullPath),TRUE) == 0 ) {
                //
                // we found it !
                //
                break;
            }
            
        }

        p=p->Flink;
    }
    CmpUnlockHiveList();
    
    if( p == &CmpHiveListHead ) {

        //
        // bad luck;
        //
        CmpUnlockRegistry();
        return STATUS_INVALID_PARAMETER;
    }

    ASSERT( CmHive->FileObject != NULL );

    //
    // at this point, we have successfully identified the hive 
    //
    
    //
    // build up the READ_LIST with the requested page offsets
    //
    ReadList->FileObject = CmHive->FileObject;
    ReadList->IsImage = FALSE;
    ASSERT( ReadList->NumberOfEntries != 0 );
    
    Status = MmPrefetchPages (1,&ReadList);
    
    ASSERT( MmDisableModifiedWriteOfSection (CmHive->FileObject->SectionObjectPointer) );

    CmpUnlockRegistry();
    return Status;
}

BOOLEAN
CmIsFileLoadedAsHive(PFILE_OBJECT FileObject)
{
    PCMHIVE             CmHive;
    PLIST_ENTRY         p;
    BOOLEAN             HiveFound = FALSE;

    //
    // iterate through the hive list
    //
    CmpLockHiveListShared();
    p = CmpHiveListHead.Flink;
    while(p != &CmpHiveListHead) {
        CmHive = (PCMHIVE)CONTAINING_RECORD(p, CMHIVE, HiveList);
        
        if( CmHive->FileObject == FileObject ) {
            //
            // we found it !
            //
            HiveFound = TRUE;
            break;
        }

        p=p->Flink;
    }
    CmpUnlockHiveList();

    return HiveFound;
}

VOID
CmpReferenceHiveView(   IN PCMHIVE          CmHive,
                        IN PCM_VIEW_OF_FILE CmView
                     )
/*++

Routine Description:

    Adds a refcount to the hive and view, to prevent it from going away from under us;
    Assumes the viewlock is held by the caller. 
    Can be converted to a macro.

Arguments:


Return Value:


--*/
{
    CM_PAGED_CODE();

    ASSERT_VIEW_LOCK_OWNED(CmHive);

    if(CmView && CmHive->Hive.ReleaseCellRoutine) {
        //
        // up the view use count if any
        //
        CmView->UseCount++;
    }

}

VOID
CmpDereferenceHiveView(   IN PCMHIVE          CmHive,
                          IN PCM_VIEW_OF_FILE CmView
                     )
/*++

Routine Description:

    Pair of CmpReferenceHiveView
    Assumes the viewlock is held by the caller. 
    Can be converted to a macro.

Arguments:


Return Value:


--*/
{
    CM_PAGED_CODE();

    ASSERT_VIEW_LOCK_OWNED(CmHive);

    if(CmView && CmHive->Hive.ReleaseCellRoutine) {
        CmView->UseCount--;
    }
}


VOID
CmpReferenceHiveViewWithLock(   IN PCMHIVE          CmHive,
                                IN PCM_VIEW_OF_FILE CmView
                            )
/*++

Routine Description:

    Adds a refcount to the hive and view, to prevent it from going away from under us;
    Can be converted to a macro.

Arguments:


Return Value:


--*/
{
    CM_PAGED_CODE();

    CmLockHiveViews(CmHive);
    //
    // call the unsafe routine
    //
    CmpReferenceHiveView(CmHive,CmView);

    CmUnlockHiveViews(CmHive);
}

VOID
CmpDereferenceHiveViewWithLock(     IN PCMHIVE          CmHive,
                                    IN PCM_VIEW_OF_FILE CmView
                                )
/*++

Routine Description:

    Pair of CmpDereferenceHiveViewWithLock
    Can be converted to a macro.

Arguments:


Return Value:


--*/
{
    CM_PAGED_CODE();

    CmLockHiveViews(CmHive);
    //
    // call the unsafe routine
    //
    CmpDereferenceHiveView(CmHive,CmView);

    CmUnlockHiveViews(CmHive);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmp.h

Abstract:

    This module contains the private (internal) header file for the
    configuration manager.

--*/

#ifndef _CMP_
#define _CMP_

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4324)   // alignment sensitive to declspec
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4706)   // assignment within conditional expression

#define     _64K    (64L*1024L)   //64K
#define     _256K   (256L*1024L)  //256K
#define		IO_BUFFER_SIZE  _64K  //64K

#include "ntos.h"
#include "hive.h"
#include "wchar.h"
#include "zwapi.h"
#include <stdio.h>
#include <profiles.h>

// bugcheck description and defines
#include "cmpbug.h"

#include "kddll.h"

// CM data structure declarations
// file location: \nt\private\ntos\inc
#include "cmdata.h"


#define CmKdPrintEx(_x_)  KdPrintEx(_x_)

//
// this constant defines the size of a Cc view that is mapped -in every time a cell
// is accessed; It can be any power of 2, no less than 16K and no bigger than 256K
//
#define     CM_VIEW_SIZE            16L*1024L  //16K

//
// control the granularity the primary file grows;
// Warning: this should be multiple of 4K (HBLOCK_SIZE) !!!
//
#define     CM_FILE_GROW_INCREMENT  256L*1024L  //256K

//
// this controls the maximum address space allowed per hive. It should be specified in
// multiples of 256K
//
//  4  means 1   MB
//  6  means 1.5 MB
//  12 means 3   MB
//  .....
//
#define     MAX_MB_PER_HIVE     16          // 4MB


#define MAX_NAME    128

#define CmpRemoveEntryList(a) RemoveEntryList(a)
#define CmpClearListEntry(a) //nothing
#define CmpIsListEmpty(a) IsListEmpty(a)

extern PCM_TRACE_NOTIFY_ROUTINE CmpTraceRoutine;

VOID
CmpWmiDumpKcb(
    PCM_KEY_CONTROL_BLOCK       kcb
);

#define CmpWmiFireEvent(Status,Kcb,ElapsedTime,Index,KeyName,Type)  \
{                                                               \
    PCM_TRACE_NOTIFY_ROUTINE TraceRoutine = CmpTraceRoutine;        \
    if( TraceRoutine != NULL ) {                                    \
        (*TraceRoutine)(Status,Kcb,ElapsedTime,Index,KeyName,Type); \
    }                                                               \
}

#define StartWmiCmTrace()\
    LARGE_INTEGER   StartSystemTime = {0};\
    LARGE_INTEGER   EndSystemTime;\
    PVOID           HookKcb = NULL;\
    if (CmpTraceRoutine) {\
        PerfTimeStamp(StartSystemTime); \
    }


#define EndWmiCmTrace(Status,Index,KeyName,Type)\
    if (CmpTraceRoutine) {\
        PerfTimeStamp(EndSystemTime); \
        CmpWmiFireEvent(Status,HookKcb,EndSystemTime.QuadPart - StartSystemTime.QuadPart,Index,KeyName,Type);\
    }

#define HookKcbForWmiCmTrace(KeyBody) \
    if (CmpTraceRoutine) {\
        if(KeyBody) {\
            HookKcb = KeyBody->KeyControlBlock;\
        }\
    }

#define HookKcbFromHandleForWmiCmTrace(KeyHandle) \
    if (CmpTraceRoutine && (KeyHandle)) {\
        PCM_KEY_BODY KeyBody;\
        NTSTATUS status;\
        status = ObReferenceObjectByHandle(\
                    KeyHandle,\
                    0,\
                    CmpKeyObjectType,\
                    KeGetPreviousMode(),\
                    (PVOID *)(&KeyBody),\
                    NULL\
                    );\
        if (NT_SUCCESS(status)) {\
            HookKcb = KeyBody->KeyControlBlock;\
            ObDereferenceObject((PVOID)KeyBody);\
        }\
    }

#define CmpTraceKcbCreate(kcb) \
    if (CmpTraceRoutine) {\
        CmpWmiDumpKcb(kcb);\
    }

#define CmpMakeSpecialPoolReadOnly(a)  //nothing
#define CmpMakeSpecialPoolReadWrite(a)  //nothing
#define CmpMakeValueCacheReadOnly(a,b) //nothing
#define CmpMakeValueCacheReadWrite(a,b) //nothing

#define HvpChangeBinAllocation(a,b) //nothing
#define HvpMarkBinReadWrite(a,b) //nothing
#define CmpMarkAllBinsReadOnly(a) //nothing

#ifdef POOL_TAGGING
//
// Pool Tag
//
#define  CM_POOL_TAG        '  MC'
#define  CM_KCB_TAG         'bkMC'
#define  CM_POSTBLOCK_TAG   'bpMC'
#define  CM_NOTIFYBLOCK_TAG 'bnMC'
#define  CM_POSTEVENT_TAG   'epMC'
#define  CM_POSTAPC_TAG     'apMC'
#define  CM_MAPPEDVIEW_TAG  'wVMC'
#define  CM_SECCACHE_TAG    'cSMC'
#define  CM_DELAYCLOSE_TAG  'cDMC'
#define  CM_STASHBUFFER_TAG 'bSMC'
#define  CM_HVBIN_TAG       'bHMC'
#define  CM_ALLOCATE_TAG    'lAMC'

//
// Find leaks
//
#define  CM_FIND_LEAK_TAG1    ' 1MC'
#define  CM_FIND_LEAK_TAG2    ' 2MC'
#define  CM_FIND_LEAK_TAG3    ' 3MC'
#define  CM_FIND_LEAK_TAG4    ' 4MC'
#define  CM_FIND_LEAK_TAG5    ' 5MC'
#define  CM_FIND_LEAK_TAG6    ' 6MC'
#define  CM_FIND_LEAK_TAG7    ' 7MC'
#define  CM_FIND_LEAK_TAG8    ' 8MC'
#define  CM_FIND_LEAK_TAG9    ' 9MC'
#define  CM_FIND_LEAK_TAG10    '01MC'
#define  CM_FIND_LEAK_TAG11    '11MC'
#define  CM_FIND_LEAK_TAG12    '21MC'
#define  CM_FIND_LEAK_TAG13    '31MC'
#define  CM_FIND_LEAK_TAG14    '41MC'
#define  CM_FIND_LEAK_TAG15    '51MC'
#define  CM_FIND_LEAK_TAG16    '61MC'
#define  CM_FIND_LEAK_TAG17    '71MC'
#define  CM_FIND_LEAK_TAG18    '81MC'
#define  CM_FIND_LEAK_TAG19    '91MC'
#define  CM_FIND_LEAK_TAG20    '02MC'
#define  CM_FIND_LEAK_TAG21    '12MC'
#define  CM_FIND_LEAK_TAG22    '22MC'
#define  CM_FIND_LEAK_TAG23    '32MC'
#define  CM_FIND_LEAK_TAG24    '42MC'
#define  CM_FIND_LEAK_TAG25    '52MC'
#define  CM_FIND_LEAK_TAG26    '62MC'
#define  CM_FIND_LEAK_TAG27    '72MC'
#define  CM_FIND_LEAK_TAG28    '82MC'
#define  CM_FIND_LEAK_TAG29    '92MC'
#define  CM_FIND_LEAK_TAG30    '03MC'
#define  CM_FIND_LEAK_TAG31    '13MC'
#define  CM_FIND_LEAK_TAG32    '23MC'
#define  CM_FIND_LEAK_TAG33    '33MC'
#define  CM_FIND_LEAK_TAG34    '43MC'
#define  CM_FIND_LEAK_TAG35    '53MC'
#define  CM_FIND_LEAK_TAG36    '63MC'
#define  CM_FIND_LEAK_TAG37    '73MC'
#define  CM_FIND_LEAK_TAG38    '83MC'
#define  CM_FIND_LEAK_TAG39    '93MC'
#define  CM_FIND_LEAK_TAG40    '04MC'
#define  CM_FIND_LEAK_TAG41    '14MC'
#define  CM_FIND_LEAK_TAG42    '24MC'
#define  CM_FIND_LEAK_TAG43    '34MC'
#define  CM_FIND_LEAK_TAG44    '44MC'
#define  CM_FIND_LEAK_TAG45    '54MC'
#define  CM_FIND_LEAK_TAG46    '64MC'

#ifdef _WANT_MACHINE_IDENTIFICATION

#define CM_PARSEINI_TAG 'ipMC'
#define CM_GENINST_TAG  'igMC'

#endif

//
// Extra Tags for cache.
// We may want to merge these tags later.
//
#define  CM_CACHE_VALUE_INDEX_TAG 'IVMC'
#define  CM_CACHE_VALUE_TAG       'aVMC'
#define  CM_CACHE_INDEX_TAG       'nIMC'
#define  CM_CACHE_VALUE_DATA_TAG  'aDMC'
#define  CM_NAME_TAG              'bNMC'


#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,CM_POOL_TAG)
#define ExAllocatePoolWithQuota(a,b) ExAllocatePoolWithQuotaTag(a,b,CM_POOL_TAG)

PVOID
CmpAllocateTag(
    ULONG   Size,
    BOOLEAN UseForIo,
    ULONG   Tag
    );
#else
#define CmpAllocateTag(a,b,c) CmpAllocate(a,b,c)
#endif

#define CmRetryExAllocatePoolWithTag(a,b,c,Result)  \
    {                                               \
        ULONG   RetryCount = 10;                    \
        do {                                        \
            Result = ExAllocatePoolWithTag(a,b,c);  \
        } while ((!Result) && (RetryCount--));      \
    }
    

//
// A variable so can turn on/off certain performance features.
//
extern const ULONG CmpCacheOnFlag;

#define CM_CACHE_FAKE_KEY  0x00000001      // Create Fake key KCB

//
// This is \REGISTRY
//
extern HANDLE CmpRegistryRootHandle;

//
// Logging: remember, first 4 levels (0-3) are reserved system-wide
//
#define CML_BUGCHECK    4   // fatal errors
#define CML_EXCEPTION   5   // all exception's
#define CML_NTAPI       6   // NtApi calls
#define CML_NTAPI_ARGS  7   // NtApi parameters
#define CML_CM          8   // Cm level, general
#define CML_NOTIFY      9   // Notify level, general
#define CML_HIVE        10  // Hv level, general
#define CML_IO          11  // IO level
#define CML_SEC         12  // Security level
#define CML_INIT        13  // Init level, general
#define CML_INDEX       14  // Index level, general
#define CML_BIN_MAP     15  // bin mapping level
#define CML_FREECELL    16  // Free cell hints
#define CML_POOL        17  // Pool
#define CML_LOCKING     18  // Lock/unlock level
#define CML_FLOW        19  // General flow
#define CML_PARSE       20  // Parse algorithm
#define CML_SAVRES      21  // SavRes operations
#define CML_CHECK_HIVE  23  // check hive spew


#define REGCHECKING 1

#if DBG

#if REGCHECKING
#define DCmCheckRegistry(a) if(HvHiveChecking) ASSERT(CmCheckRegistry(a, CM_CHECK_REGISTRY_HIVE_CHECK) == 0)
#else
#define DCmCheckRegistry(a)
#endif

#else
#define DCmCheckRegistry(a)
#endif

#define LogKCBReference(kcb,reason) //nothing
#define CmpCheckIfResourceOwned() //nothing

#define BEGIN_LOCK_CHECKPOINT
#define END_LOCK_CHECKPOINT

extern BOOLEAN CmpSpecialBootCondition;

#if DBG
#define ASSERT_CM_LOCK_OWNED() \
    ASSERT( (CmpSpecialBootCondition == TRUE) || (CmpTestRegistryLock() == TRUE) )
#define ASSERT_CM_LOCK_OWNED_EXCLUSIVE() \
    ASSERT((CmpSpecialBootCondition == TRUE) || (CmpTestRegistryLockExclusive() == TRUE) )
#define ASSERT_CM_EXCLUSIVE_HIVE_ACCESS(Hive) \
    ASSERT((CmpSpecialBootCondition == TRUE) || (CmpTestRegistryLockExclusive() == TRUE) || (Hive->ReleaseCellRoutine == NULL) )
#define ASSERT_CM_LOCK_OWNED_OR_HIVE_LOADING(_CmHive_) \
    ASSERT( (CmpSpecialBootCondition == TRUE) || (((PCMHIVE)(_CmHive_))->HiveIsLoading) || (CmpTestRegistryLock() == TRUE) )
#define ASSERT_CM_LOCK_OWNED_EXCLUSIVE_OR_HIVE_LOADING(_CmHive_) \
    ASSERT( (CmpSpecialBootCondition == TRUE) || (((PCMHIVE)(_CmHive_))->HiveIsLoading) || (CmpTestRegistryLockExclusive() == TRUE) )
#define ASSERT_CM_LOCK_NOT_OWNED() \
    ASSERT( (CmpTestRegistryLock() == FALSE)  && (CmpTestRegistryLockExclusive() == FALSE) )
#else
#define ASSERT_CM_LOCK_OWNED()
#define ASSERT_CM_LOCK_OWNED_EXCLUSIVE()
#define ASSERT_CM_EXCLUSIVE_HIVE_ACCESS(Hive)
#define ASSERT_CM_LOCK_OWNED_OR_HIVE_LOADING(_CmHive_) 
#define ASSERT_CM_LOCK_OWNED_EXCLUSIVE_OR_HIVE_LOADING(_CmHive_) 
#define ASSERT_CM_LOCK_NOT_OWNED() 
#endif

#if DBG
#define ASSERT_PASSIVE_LEVEL()                                              \
    {                                                                       \
        KIRQL   Irql;                                                       \
        Irql = KeGetCurrentIrql();                                          \
        if( KeGetCurrentIrql() != PASSIVE_LEVEL ) {                         \
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"ASSERT_PASSIVE_LEVEL failed ... Irql = %lu\n",Irql);  \
            ASSERT( FALSE );                                                \
        }                                                                   \
    }
#else
#define ASSERT_PASSIVE_LEVEL()
#endif

#define VALIDATE_CELL_MAP(LINE,Map,Hive,Address)                                                    \
    if( Map == NULL ) {                                                                             \
            CM_BUGCHECK (REGISTRY_ERROR,BAD_CELL_MAP,(ULONG_PTR)(Hive),(ULONG)(Address),(ULONG)(LINE)) ;      \
    }

#if DBG
VOID
SepDumpSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSZ TitleString
    );

extern BOOLEAN SepDumpSD;

#define CmpDumpSecurityDescriptor(x,y) \
        { \
            SepDumpSD=TRUE;     \
            SepDumpSecurityDescriptor(x, y);  \
            SepDumpSD=FALSE;    \
        }
#else

#define CmpDumpSecurityDescriptor(x,y)

#endif


//
// misc stuff
//

extern  UNICODE_STRING  CmRegistrySystemCloneName;

//
// Determines whether the Current Control Set used during booting
// is cloned in order to fully preserve it for being saved
// as the LKG Control Set.
//

#define     CM_NUMBER_OF_MACHINE_HIVES  6

#define NUMBER_TYPES (MaximumType + 1)

#define CM_WRAP_LIMIT               0x7fffffff


//
// Tuning and control constants
//
#define CM_MAX_STASH           1024*1024        // If size of data for a set
                                                // is bigger than this,

#define CM_MAX_REASONABLE_VALUES    100         // If number of values for a
                                                // key is greater than this,
                                                // round up value list size


//
// Limit on the number of layers of hive there may be.  We allow only
// the master hive and hives directly linked into it for now, for currently
// value is always 2..
//

#define MAX_HIVE_LAYERS         2


//
// structure used to create and sort ordered list of drivers to be loaded.
// This is also used by the OS Loader when loading the boot drivers.
// (Particularly the ErrorControl field)
//

typedef struct _BOOT_DRIVER_NODE {
    BOOT_DRIVER_LIST_ENTRY ListEntry;
    UNICODE_STRING Group;
    UNICODE_STRING Name;
    ULONG Tag;
    ULONG ErrorControl;
} BOOT_DRIVER_NODE, *PBOOT_DRIVER_NODE;

//
// extern for object type pointer
//

extern  POBJECT_TYPE CmpKeyObjectType;
extern  POBJECT_TYPE IoFileObjectType;

//
// indexes in CmpMachineHiveList
//
#define SYSTEM_HIVE_INDEX 3
#define CLONE_HIVE_INDEX 6

//
// Miscellaneous Hash routines
//
#define RNDM_CONSTANT   314159269    /* default value for "scrambling constant" */
#define RNDM_PRIME     1000000007    /* prime number, also used for scrambling  */

#define HASH_KEY(_convkey_) ((RNDM_CONSTANT * (_convkey_)) % RNDM_PRIME)

#define GET_HASH_INDEX(Key) HASH_KEY(Key) % CmpHashTableSize
#define GET_HASH_ENTRY(Table, Key) Table[GET_HASH_INDEX(Key)]
#define GET_KCB_HASH_ENTRY(Table, Key)  GET_HASH_ENTRY(Table, Key).Entry
#define GET_KCB_HASH_ENTRY_LOCK(kcb)    (GET_HASH_ENTRY(CmpCacheTable,(kcb)->ConvKey).Lock)
#define GET_KCB_HASH_ENTRY_OWNER(kcb)    (GET_HASH_ENTRY(CmpCacheTable,(kcb)->ConvKey).Owner)

//
// CM_KEY_BODY
//
//  Same structure used for KEY_ROOT and KEY objects.  This is the
//  Cm defined part of the object.
//
//  This object represents an open instance, several of them could refer
//  to a single key control block.
//
#define KEY_BODY_TYPE           0x6b793032      // "ky02"

#define KEY_BODY_HIVE_UNLOADED          0x00000001               // hive for this has been force unloaded or replaced

struct _CM_NOTIFY_BLOCK; //forward

typedef struct _CM_KEY_BODY {
    ULONG                   Type;
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock;
    struct _CM_NOTIFY_BLOCK *NotifyBlock;
    HANDLE                  ProcessID;        // the owner process
    LIST_ENTRY              KeyBodyList;    // key_nodes using the same kcb
} CM_KEY_BODY, *PCM_KEY_BODY;

#define CmpSetNoCallers(KeyBody) // nothing
#define CmpAddKeyTracker(KeyHandle,mode) // nothing yet

VOID InitializeKCBKeyBodyList(IN PCM_KEY_CONTROL_BLOCK kcb);

#if DBG
#define ASSERT_KEYBODY_LIST_EMPTY(kcb)                          \
{                                                               \
    ULONG   i;                                                  \
    ASSERT(IsListEmpty(&(kcb->KeyBodyListHead)) == TRUE);       \
    for(i=0;i<CMP_LOCK_FREE_KEY_BODY_ARRAY_SIZE;i++) {          \
        ASSERT( kcb->KeyBodyArray[i] == NULL );                 \
    }                                                           \
}
#else
#define ASSERT_KEYBODY_LIST_EMPTY(kcb) //nothing
#endif

#define CMP_ENLIST_KCB_LOCKED_SHARED        1
#define CMP_ENLIST_KCB_LOCKED_EXCLUSIVE     2

VOID EnlistKeyBodyWithKCB(IN PCM_KEY_BODY   KeyBody,
                          IN ULONG          ControlFlags );

VOID DelistKeyBodyFromKCB(IN PCM_KEY_BODY   KeyBody,
                          IN BOOLEAN        LockHeld );


#define ASSERT_KEY_OBJECT(x) ASSERT(((PCM_KEY_BODY)x)->Type == KEY_BODY_TYPE)
#define ASSERT_NODE(x) ASSERT(((PCM_KEY_NODE)x)->Signature == CM_KEY_NODE_SIGNATURE)
#define ASSERT_SECURITY(x) ASSERT(((PCM_KEY_SECURITY)x)->Signature == CM_KEY_SECURITY_SIGNATURE)

//
// CM_POST_KEY_BODY
//
// A post block can have attached a keybody which has to be dereferenced
// when the post block goes out of scope. This structure allows the
// implementation of keybody "delayed dereferencing". (see CmpPostNotify for comments)
//

typedef struct _CM_POST_KEY_BODY {
    LIST_ENTRY                  KeyBodyList;
    struct _CM_KEY_BODY         *KeyBody;        // this key body object
} CM_POST_KEY_BODY, *PCM_POST_KEY_BODY;


//
// CM_NOTIFY_BLOCK
//
//  A notify block tracks an active notification waiting for notification.
//  Any one open instance (CM_KEY_BODY) will refer to at most one
//  notify block.  A given key control block may have as many notify
//  blocks referring to it as there are CM_KEY_BODYs referring to it.
//  Notify blocks are attached to hives and sorted by length of name.
//

typedef struct _CM_NOTIFY_BLOCK {
    LIST_ENTRY                  HiveList;        // sorted list of notifies
    LIST_ENTRY                  PostList;        // Posts to fill
    PCM_KEY_CONTROL_BLOCK       KeyControlBlock; // Open instance notify is on
    struct _CM_KEY_BODY         *KeyBody;        // our owning key handle object
    struct {
        ULONG                       Filter          : 30;    // Events of interest
        ULONG                       WatchTree       : 1;
        ULONG                       NotifyPending   : 1;
    };
    SECURITY_SUBJECT_CONTEXT    SubjectContext;  // Security stuff
} CM_NOTIFY_BLOCK, *PCM_NOTIFY_BLOCK;

//
// CM_POST_BLOCK
//
//  Whenever a notify call is made, a post block is created and attached
//  to the notify block.  Each time an event is posted against the notify,
//  the waiter described by the post block is signaled.  (i.e. APC enqueued,
//  event signaled, etc.)
//

//
//  The NotifyType ULONG is a combination of POST_BLOCK_TYPE enum and flags
//

typedef enum _POST_BLOCK_TYPE {
    PostSynchronous = 1,
    PostAsyncUser = 2,
    PostAsyncKernel = 3
} POST_BLOCK_TYPE;

typedef struct _CM_SYNC_POST_BLOCK {
    PKEVENT                 SystemEvent;
    NTSTATUS                Status;
} CM_SYNC_POST_BLOCK, *PCM_SYNC_POST_BLOCK;

typedef struct _CM_ASYNC_USER_POST_BLOCK {
    ULONG                   Dummy;
    PKEVENT                 UserEvent;
    PKAPC                   Apc;
    PIO_STATUS_BLOCK        IoStatusBlock;
} CM_ASYNC_USER_POST_BLOCK, *PCM_ASYNC_USER_POST_BLOCK;

typedef struct _CM_ASYNC_KERNEL_POST_BLOCK {
    PKEVENT                 Event;
    PWORK_QUEUE_ITEM        WorkItem;
    WORK_QUEUE_TYPE         QueueType;
} CM_ASYNC_KERNEL_POST_BLOCK, *PCM_ASYNC_KERNEL_POST_BLOCK;

typedef union _CM_POST_BLOCK_UNION {
    CM_SYNC_POST_BLOCK  Sync;
    CM_ASYNC_USER_POST_BLOCK AsyncUser;
    CM_ASYNC_KERNEL_POST_BLOCK AsyncKernel;
} CM_POST_BLOCK_UNION, *PCM_POST_BLOCK_UNION;

typedef struct _CM_POST_BLOCK {
#if DBG
    BOOLEAN                     TraceIntoDebugger;
#endif
    LIST_ENTRY                  NotifyList;
    LIST_ENTRY                  ThreadList;
    LIST_ENTRY                  CancelPostList; // slave notifications that are attached to this notification
    struct _CM_POST_KEY_BODY    *PostKeyBody;
    ULONG                       NotifyType;
    PCM_POST_BLOCK_UNION        u;
} CM_POST_BLOCK, *PCM_POST_BLOCK;

#define REG_NOTIFY_POST_TYPE_MASK (0x0000FFFFL)   // mask for finding out the type of the post block

#define REG_NOTIFY_MASTER_POST    (0x00010000L)   // The current post block is a master one

//
// Useful macros to manipulate the NotifyType field in CM_POST_BLOCK
//
#define PostBlockType(_post_) ((POST_BLOCK_TYPE)( ((_post_)->NotifyType) & REG_NOTIFY_POST_TYPE_MASK ))

#define IsMasterPostBlock(_post_)           ( ((_post_)->NotifyType) &   REG_NOTIFY_MASTER_POST )
#define SetMasterPostBlockFlag(_post_)      ( ((_post_)->NotifyType) |=  REG_NOTIFY_MASTER_POST )
#define ClearMasterPostBlockFlag(_post_)    ( ((_post_)->NotifyType) &= ~REG_NOTIFY_MASTER_POST )

//
// This lock protects the PostList(s) in Notification objects.
// It is used to prevent attempts for simultaneous changes of
// CancelPostList list in PostBlocks
//

extern EX_PUSH_LOCK CmpPostLock;
#define LOCK_POST_LIST() ExAcquirePushLockExclusive(&CmpPostLock)
#define UNLOCK_POST_LIST() ExReleasePushLock(&CmpPostLock)


extern EX_PUSH_LOCK CmpStashBufferLock;
#define LOCK_STASH_BUFFER() ExAcquirePushLockExclusive(&CmpStashBufferLock)
#define UNLOCK_STASH_BUFFER() ExReleasePushLock(&CmpStashBufferLock)


//
// protection for CmpHiveListHead
//
extern EX_PUSH_LOCK CmpHiveListHeadLock;
#define CmpLockHiveListShared()     ExAcquirePushLockShared(&CmpHiveListHeadLock)
#define CmpLockHiveListExclusive()  ExAcquirePushLockExclusive(&CmpHiveListHeadLock)
#define CmpUnlockHiveList()         ExReleasePushLock(&CmpHiveListHeadLock)

//
// protection for CmLoadKey
//
extern EX_PUSH_LOCK    CmpLoadHiveLock;
#define LOCK_HIVE_LOAD() ExAcquirePushLockExclusive(&CmpLoadHiveLock)
#define UNLOCK_HIVE_LOAD() ExReleasePushLock(&CmpLoadHiveLock)

//
// used by CmpFileWrite, so it doesn't take up so much stack.
//
typedef struct _CM_WRITE_BLOCK {
    HANDLE          EventHandles[MAXIMUM_WAIT_OBJECTS];
    PKEVENT         EventObjects[MAXIMUM_WAIT_OBJECTS];
    KWAIT_BLOCK     WaitBlockArray[MAXIMUM_WAIT_OBJECTS];
    IO_STATUS_BLOCK IoStatus[MAXIMUM_WAIT_OBJECTS];
} CM_WRITE_BLOCK, *PCM_WRITE_BLOCK;

//
// CM data to manipulate views inside the primary hive file
//

//#define MAPPED_VIEWS_PER_HIVE   12 * (_256K / CM_VIEW_SIZE ) // max 3 MB per hive ; we don't really need this
#define MAX_VIEWS_PER_HIVE      MAX_MB_PER_HIVE * ( (_256K) / (CM_VIEW_SIZE) )

#define ASSERT_VIEW_MAPPED(a)                           \
    ASSERT((a)->Size != 0);                             \
    ASSERT((a)->ViewAddress != 0);                      \
    ASSERT((a)->Bcb != 0);                              \
    ASSERT( IsListEmpty(&((a)->LRUViewList)) == FALSE); \
    ASSERT( IsListEmpty(&((a)->PinViewList)) == TRUE)

#define ASSERT_VIEW_PINNED(a)                           \
    ASSERT((a)->Size != 0);                             \
    ASSERT((a)->ViewAddress != 0);                      \
    ASSERT((a)->Bcb != 0);                              \
    ASSERT( IsListEmpty(&((a)->LRUViewList)) == TRUE)

typedef struct _CM_VIEW_OF_FILE {
    LIST_ENTRY      LRUViewList;        // LRU connection ==> when this is empty, the view is pinned
    LIST_ENTRY      PinViewList;        // list of views pinned into memory ==> when this is empty, the view is in LRU list
    ULONG           FileOffset;         // file offset at which the mapping starts
    ULONG           Size;               // size the view maps
    PULONG_PTR      ViewAddress;        // memory address containing the mapping
    PVOID           Bcb;                // BCB needed for map/pin/unpin access
    ULONG           UseCount;           // how many cells are currently in use inside this view
} CM_VIEW_OF_FILE, *PCM_VIEW_OF_FILE;


//
// security hash manipulation
//
#define CmpSecHashTableSize             64      // size of the hash table

typedef struct _CM_KCB_REMAP_BLOCK {
    LIST_ENTRY              RemapList;
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock;
    HCELL_INDEX             OldCellIndex;
    HCELL_INDEX             NewCellIndex;
    ULONG                   ValueCount;
    HCELL_INDEX             ValueList;
} CM_KCB_REMAP_BLOCK, *PCM_KCB_REMAP_BLOCK;

typedef struct _CM_CELL_REMAP_BLOCK {
    HCELL_INDEX             OldCell;
    HCELL_INDEX             NewCell;
} CM_CELL_REMAP_BLOCK, *PCM_CELL_REMAP_BLOCK;

typedef struct _CM_KNODE_REMAP_BLOCK {
    LIST_ENTRY              RemapList;
    PCM_KEY_NODE            KeyNode;
    HCELL_INDEX             NewParent;
} CM_KNODE_REMAP_BLOCK, *PCM_KNODE_REMAP_BLOCK;

#define CM_CMHIVE_FLAG_UNTRUSTED    1   // hive is untrusted (but it may be inside of a trusted class).
// ----- Cm version of Hive structure (CMHIVE) -----
//
typedef struct _CMHIVE {
    HHIVE                           Hive;
    HANDLE                          FileHandles[HFILE_TYPE_MAX];
    LIST_ENTRY                      NotifyList;
    LIST_ENTRY                      HiveList;           // Used to find hives at shutdown
    EX_PUSH_LOCK                    HiveLock;           // Used to synchronize operations on the hive (NotifyList and Flush)
#if DBG
    PKTHREAD                        HiveLockOwner;      // debug only
#endif
    PKGUARDED_MUTEX                 ViewLock;           // Used to control access over the view list, UseCount
#if DBG
    PKTHREAD                        ViewLockOwner;      // debug only
#endif
    EX_PUSH_LOCK                    WriterLock;         // Used to synchronize writers (and get rid of global registry lock).
#if DBG
    PKTHREAD                        WriterLockOwner;    // debug only
#endif
#if DBG
    PERESOURCE                      FlusherLock;        // Used to synchronize flushes, read and writes ( make sure the image we flush is atomic).
#else
    EX_PUSH_LOCK                    FlusherLock;        // Used to synchronize flushes, read and writes ( make sure the image we flush is atomic).
#endif
    EX_PUSH_LOCK                    SecurityLock;       // Used to synchronize security on the hive
#if DBG
    PKTHREAD                        HiveSecurityLockOwner;      // debug only
#endif
    LIST_ENTRY                      LRUViewListHead;    // Head of the same list as above but ordered (LRU)
    LIST_ENTRY                      PinViewListHead;    // Head of the List of Views pinned into memory inside the primary hive file
    PFILE_OBJECT                    FileObject;         // FileObject needed for Cc operations on the mapped views
    UNICODE_STRING                  FileFullPath;       // full path of the hive file- needed for CmPrefetchHivePages
    UNICODE_STRING                  FileUserName;       // file name as passed onto NtLoadKey 
    USHORT                          MappedViews;        // number of mapped (but not pinned views) i.e. the number of elements in LRUViewList
    USHORT                          PinnedViews;        // number of pinned views i.e. the number of elements in PinViewList
    ULONG                           UseCount;           // how many cells are currently in use inside this hive
    ULONG                           SecurityCount;      // number of security cells cached
    ULONG                           SecurityCacheSize;  // number of entries in the cache (to avoid memory fragmentation)
    LONG                            SecurityHitHint;    // index of the last cell we've searched on
    PCM_KEY_SECURITY_CACHE_ENTRY    SecurityCache;      // the security cache

                                                        // hash table (to retrieve the security cells by descriptor)
    LIST_ENTRY                      SecurityHash[CmpSecHashTableSize];

    PKEVENT                         UnloadEvent;        // the event to be signaled when the hive unloads
                                                        // this may be valid (not NULL) only in conjunction with
                                                        // a not NULL RootKcb and a TRUE Frozen (below)

    PCM_KEY_CONTROL_BLOCK           RootKcb;            // kcb to the root of the hive. We keep a reference on it, which
                                                        // will be released at the time the hive unloads (i.e. it is the last
                                                        // reference somebody has on this kcb); This is should be valid (not NULL)
                                                        // only when the Frozen flag is set to TRUE

    BOOLEAN                         Frozen;             // set to TRUE when the hive is frozen (no further operations are allowed on
                                                        // this hive

    PWORK_QUEUE_ITEM                UnloadWorkItem;     // Work Item to actually perform the late unload

    BOOLEAN                         GrowOnlyMode;       // the hive is in "grow only" mode; new cells are allocated past GrowOffset
    ULONG                           GrowOffset;

    LIST_ENTRY                      KcbConvertListHead; // list of CM_KCB_REMAP_BLOCK storing the associations to the new hive.
    LIST_ENTRY                      KnodeConvertListHead;
    PCM_CELL_REMAP_BLOCK            CellRemapArray;     // array of mappings used for security cells

    ULONG                           Flags;              // CMHIVE specific flags
    LIST_ENTRY                      TrustClassEntry;    // links together the UNTRUSTED hives in the same 'class of trust'
    ULONG                           FlushCount;
#if DBG
    BOOLEAN                         HiveIsLoading;      // hive is loading; not yet in the hive list; safe to work on it alone
#endif
    PKTHREAD                        CreatorOwner;       // so we can mount the hive safely
} CMHIVE, *PCMHIVE;

#define CmpUnJoinClassOfTrust(CmHive)                       \
if( !IsListEmpty(&(CmHive->TrustClassEntry)) ) {            \
    ASSERT(CmHive->Flags&CM_CMHIVE_FLAG_UNTRUSTED);         \
    CmpLockHiveListExclusive();                             \
    RemoveEntryList(&(CmHive->TrustClassEntry));            \
    CmpUnlockHiveList();                                    \
} 
#define CmpJoinClassOfTrust(_NewHive,_OtherHive)                            \
CmpLockHiveListExclusive();                                                 \
InsertTailList(&(_OtherHive->TrustClassEntry),&(_NewHive->TrustClassEntry));\
CmpUnlockHiveList()


#define CmLogCellRef( HIVE, CELL )   
#define CmLogCellDeRef( HIVE, CELL )

#define CmLogLockHive( HIVE)
#define CmLogUnlockHive( HIVE)

//
// Hive's own writer lock
//
#define CmpLockHiveWriter(_hive_)  ASSERT_CM_LOCK_OWNED_OR_HIVE_LOADING((PCMHIVE)(_hive_));\
                                    ExAcquirePushLockExclusive(&(((PCMHIVE)(_hive_))->WriterLock));\
                                    ASSERT( ((PCMHIVE)(_hive_))->WriterLockOwner = KeGetCurrentThread() )

#define CmpUnlockHiveWriter(_hive_) ASSERT_CM_LOCK_OWNED_OR_HIVE_LOADING((PCMHIVE)(_hive_));\
                             ASSERT_HIVE_WRITER_LOCK_OWNED((PCMHIVE)(_hive_));\
                             ASSERT( (((PCMHIVE)(_hive_))->WriterLockOwner = NULL) == NULL);\
                             ExReleasePushLock(&(((PCMHIVE)(_hive_))->WriterLock))
#if DBG
#define ASSERT_HIVE_WRITER_LOCK_OWNED(_CmHive_) ASSERT( (CmpSpecialBootCondition == TRUE) || (((PCMHIVE)(_CmHive_))->HiveIsLoading) || (((PCMHIVE)(_CmHive_))->WriterLockOwner == KeGetCurrentThread()) || (CmpTestRegistryLockExclusive() == TRUE))
#else
#define ASSERT_HIVE_WRITER_LOCK_OWNED(_CmHive_) //nothing
#endif //DBG

//
// Hive's flusher lock
//
#if DBG
VOID CmpLockHiveFlusherShared(PCMHIVE CmHive);
VOID CmpLockHiveFlusherExclusive(PCMHIVE CmHive);
VOID CmpUnlockHiveFlusher(PCMHIVE CmHive);

BOOLEAN CmpTestHiveFlusherLockShared(PCMHIVE CmHive);
BOOLEAN CmpTestHiveFlusherLockExclusive(PCMHIVE CmHive);

#define ASSERT_HIVE_FLUSHER_LOCKED(_CmHive_) ASSERT( (CmpSpecialBootCondition == TRUE) || (((PCMHIVE)(_CmHive_))->HiveIsLoading) || (CmpTestHiveFlusherLockShared(_CmHive_) == TRUE) || (CmpTestHiveFlusherLockExclusive(_CmHive_) == TRUE) || (CmpTestRegistryLockExclusive() == TRUE))
#define ASSERT_HIVE_FLUSHER_LOCKED_EXCLUSIVE(_CmHive_) ASSERT( (CmpSpecialBootCondition == TRUE) || (((PCMHIVE)(_CmHive_))->HiveIsLoading) || (CmpTestHiveFlusherLockExclusive(_CmHive_) == TRUE) || (CmpTestRegistryLockExclusive() == TRUE))

#else 
#define CmpLockHiveFlusherShared(CmHive)    ExAcquirePushLockShared(&(((PCMHIVE)CmHive)->FlusherLock))
#define CmpLockHiveFlusherExclusive(CmHive) ExAcquirePushLockExclusive(&(((PCMHIVE)CmHive)->FlusherLock))
#define CmpUnlockHiveFlusher(CmHive)        ExReleasePushLock(&(((PCMHIVE)CmHive)->FlusherLock))

#define ASSERT_HIVE_FLUSHER_LOCKED(_CmHive_) //nothing
#define ASSERT_HIVE_FLUSHER_LOCKED_EXCLUSIVE(_CmHive_) //nothing
#endif //DBG

#define IsHiveFrozen(_CmHive_) (((PCMHIVE)(_CmHive_))->Frozen == TRUE)

#define HiveWritesThroughCache(Hive,FileType) ((FileType == HFILE_TYPE_PRIMARY) && (((PCMHIVE)CONTAINING_RECORD(Hive, CMHIVE, Hive))->FileObject != NULL))


//
// Delayed close kcb list
//
typedef struct _CM_DELAYED_CLOSE_ENTRY {
    LIST_ENTRY              DelayedLRUList;     //  LRU list of entries in the Delayed Close Table
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock;    //  KCB in this entry; NULL if the entry is available
} CM_DELAYED_CLOSE_ENTRY, *PCM_DELAYED_CLOSE_ENTRY;


//
// Hive locking support
//
//
#if DBG
#define ASSERT_HIVE_LOCK_OWNED(_hive_)  ASSERT( (CmpSpecialBootCondition == TRUE) || (((PCMHIVE)(_hive_))->HiveIsLoading) || ((_hive_)->HiveLockOwner == KeGetCurrentThread()) || (CmpTestRegistryLockExclusive() == TRUE) )
#else
#define ASSERT_HIVE_LOCK_OWNED(_hive_) //nothing
#endif

#define CmLockHive(_hive_)  ExAcquirePushLockExclusive(&((_hive_)->HiveLock));\
                            CmLogLockHive(_hive_);\
                            ASSERT( (_hive_)->HiveLockOwner = KeGetCurrentThread() )

#define CmUnlockHive(_hive_) ASSERT_HIVE_LOCK_OWNED(_hive_);\
                             ASSERT( ((_hive_)->HiveLockOwner = NULL) == NULL);\
                             CmLogUnlockHive(_hive_);\
                             ExReleasePushLock(&((_hive_)->HiveLock))


#if DBG
#define ASSERT_HIVE_SECURITY_LOCK_OWNED(_hive_)  ASSERT( ((_hive_)->HiveSecurityLockOwner == KeGetCurrentThread()) || (CmpTestRegistryLockExclusive() == TRUE) )
#else
#define ASSERT_HIVE_SECURITY_LOCK_OWNED(_hive_) //nothing
#endif

#define CmLockHiveSecurityShared(_hive_) ExAcquirePushLockShared(&((_hive_)->SecurityLock))

#define CmLockHiveSecurityExclusive(_hive_) ExAcquirePushLockExclusive(&((_hive_)->SecurityLock));\
                                            ASSERT( (_hive_)->HiveSecurityLockOwner = KeGetCurrentThread() )

#define CmUnlockHiveSecurity(_hive_)    ASSERT( ((_hive_)->HiveSecurityLockOwner == NULL) || ((_hive_)->HiveSecurityLockOwner == KeGetCurrentThread()) );\
                                        ASSERT( ((_hive_)->HiveSecurityLockOwner = NULL) == NULL);\
                                        ExReleasePushLock(&((_hive_)->SecurityLock))

//
// View locking support
//
#if DBG
#define ASSERT_VIEW_LOCK_OWNED(_hive_)  ASSERT( (CmpSpecialBootCondition == TRUE) || (((PCMHIVE)(_hive_))->HiveIsLoading) || (((PCMHIVE)(_hive_))->ViewLockOwner == KeGetCurrentThread()) || (CmpTestRegistryLockExclusive() == TRUE))
#else
#define ASSERT_VIEW_LOCK_OWNED(_hive_) //nothing
#endif

#define CmLockHiveViews(_hive_)     ASSERT( ((PCMHIVE)(_hive_))->ViewLock );\
                                    KeAcquireGuardedMutex(((PCMHIVE)(_hive_))->ViewLock);\
                                    ASSERT( ((PCMHIVE)(_hive_))->ViewLockOwner = KeGetCurrentThread() )

#define CmUnlockHiveViews(_hive_)   ASSERT( ((PCMHIVE)(_hive_))->ViewLock );\
                                    ASSERT_VIEW_LOCK_OWNED((PCMHIVE)(_hive_));\
                                    ASSERT( (((PCMHIVE)(_hive_))->ViewLockOwner = NULL) == NULL);\
                                    KeReleaseGuardedMutex(((PCMHIVE)(_hive_))->ViewLock)

//
// Macros
//

//
// ----- CM_KEY_NODE -----
//
#define CmpHKeyNameLen(Key) \
        (((Key)->Flags & KEY_COMP_NAME) ? \
            CmpCompressedNameSize((Key)->Name,(Key)->NameLength) : \
            (Key)->NameLength)

#define CmpNcbNameLen(Ncb) \
        (((Ncb)->Compressed) ? \
            CmpCompressedNameSize((Ncb)->Name,(Ncb)->NameLength) : \
            (Ncb)->NameLength)

#define CmpHKeyNodeSize(Hive, KeyName) \
    (FIELD_OFFSET(CM_KEY_NODE, Name) + CmpNameSize(Hive, KeyName))


//
// ----- CM_KEY_VALUE -----
//


#define CmpValueNameLen(Value)                                       \
        (((Value)->Flags & VALUE_COMP_NAME) ?                           \
            CmpCompressedNameSize((Value)->Name,(Value)->NameLength) :  \
            (Value)->NameLength)

#define CmpHKeyValueSize(Hive, ValueName) \
    (FIELD_OFFSET(CM_KEY_VALUE, Name) + CmpNameSize(Hive, ValueName))


//
// ----- Procedure Prototypes -----
//

//
// Configuration Manager private procedure prototypes
//

#define REG_OPTION_PREDEF_HANDLE (0x01000000L)
#define REG_PREDEF_HANDLE_MASK   (0x80000000L)

typedef struct _CM_PARSE_CONTEXT {
    ULONG                   TitleIndex;
    UNICODE_STRING          Class;
    ULONG                   CreateOptions;
    ULONG                   Disposition;
    CM_KEY_REFERENCE        ChildHive;
    HANDLE                  PredefinedHandle;
    BOOLEAN                 CreateLink;
    BOOLEAN                 CreateOperation;
    PCMHIVE                 OriginatingPoint;
} CM_PARSE_CONTEXT, *PCM_PARSE_CONTEXT;

#define CmpParseRecordOriginatingPoint(_Context,_CmHive)                                            \
if( ARGUMENT_PRESENT(_Context) && (((PCM_PARSE_CONTEXT)(_Context))->OriginatingPoint == NULL) &&    \
    (((PCMHIVE)_CmHive)->Flags&CM_CMHIVE_FLAG_UNTRUSTED) ){                                         \
    ((PCM_PARSE_CONTEXT)(_Context))->OriginatingPoint = (PCMHIVE)_CmHive;                           \
}

#define CmpParseGetOriginatingPoint(_Context) ARGUMENT_PRESENT(_Context)?((PCM_PARSE_CONTEXT)(_Context))->OriginatingPoint:NULL

NTSTATUS
CmpParseKey(
    IN PVOID ParseObject,
    IN PVOID ObjectType,
    IN OUT PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN OUT PUNICODE_STRING CompleteName,
    IN OUT PUNICODE_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
    OUT PVOID *Object
    );

NTSTATUS
CmpDoCreate(
    IN PHHIVE                   Hive,
    IN HCELL_INDEX              Cell,
    IN PACCESS_STATE            AccessState,
    IN PUNICODE_STRING          Name,
    IN KPROCESSOR_MODE          AccessMode,
    IN PCM_PARSE_CONTEXT        Context,
    IN PCM_KEY_CONTROL_BLOCK    ParentKcb,
    IN PCMHIVE                  OriginatingHive OPTIONAL,
    OUT PVOID                   *Object
    );

NTSTATUS
CmpDoCreateChild(
    IN PHHIVE Hive,
    IN HCELL_INDEX ParentCell,
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PACCESS_STATE AccessState,
    IN PUNICODE_STRING Name,
    IN KPROCESSOR_MODE AccessMode,
    IN PCM_PARSE_CONTEXT Context,
    IN PCM_KEY_CONTROL_BLOCK ParentKcb,
    IN USHORT Flags,
    OUT PHCELL_INDEX KeyCell,
    OUT PVOID *Object
    );

NTSTATUS
CmpQueryKeyName(
    IN PVOID Object,
    IN BOOLEAN HasObjectName,
    OUT POBJECT_NAME_INFORMATION ObjectNameInfo,
    IN ULONG Length,
    OUT PULONG ReturnLength,
    IN KPROCESSOR_MODE Mode
    );

VOID
CmpDeleteKeyObject(
    IN  PVOID   Object
    );

VOID
CmpCloseKeyObject(
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG_PTR ProcessHandleCount,
    IN ULONG_PTR SystemHandleCount
    );

NTSTATUS
CmpAssignSecurityDescriptorWrapper(
    IN PVOID                    Object,
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSTATUS
CmpSecurityMethod (
    IN PVOID Object,
    IN SECURITY_OPERATION_CODE OperationCode,
    IN PSECURITY_INFORMATION SecurityInformation,
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG CapturedLength,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN POOL_TYPE PoolType,
    IN PGENERIC_MAPPING GenericMapping
    );

#define KCB_WORKER_CONTINUE     0
#define KCB_WORKER_DONE         1
#define KCB_WORKER_DELETE       2
#define KCB_WORKER_ERROR        3

typedef
ULONG
(*PKCB_WORKER_ROUTINE) (
    PCM_KEY_CONTROL_BLOCK Current,
    PVOID                 Context1,
    PVOID                 Context2
    );


BOOLEAN
CmpSearchKeyControlBlockTree(
    PKCB_WORKER_ROUTINE WorkerRoutine,
    PVOID               Context1,
    PVOID               Context2
    );

//
// Wrappers
//

PVOID
CmpAllocate(
    ULONG   Size,
    BOOLEAN UseForIo,
    ULONG   Tag
    );

VOID
CmpFree(
    PVOID   MemoryBlock,
    ULONG   GlobalQuotaSize
    );

BOOLEAN
CmpFileSetSize(
    PHHIVE      Hive,
    ULONG       FileType,
    ULONG       FileSize,
    ULONG       OldFileSize
    );

NTSTATUS
CmpDoFileSetSize(
    PHHIVE      Hive,
    ULONG       FileType,
    ULONG       FileSize,
    ULONG       OldFileSize
    );

BOOLEAN
CmpFileWrite(
    PHHIVE      Hive,
    ULONG       FileType,
    PCMP_OFFSET_ARRAY offsetArray,
    ULONG offsetArrayCount,
    PULONG      FileOffset
    );

BOOLEAN
CmpFileWriteThroughCache(
    PHHIVE              Hive,
    ULONG               FileType,
    PCMP_OFFSET_ARRAY   offsetArray,
    ULONG               offsetArrayCount
    );

BOOLEAN
CmpFileRead (
    PHHIVE      Hive,
    ULONG       FileType,
    PULONG      FileOffset,
    PVOID       DataBuffer,
    ULONG       DataLength
    );

BOOLEAN
CmpFileFlush (
    PHHIVE          Hive,
    ULONG           FileType,
    PLARGE_INTEGER  FileOffset,
    ULONG           Length
    );

NTSTATUS
CmpCreateEvent(
    IN EVENT_TYPE  eventType,
    OUT PHANDLE eventHandle,
    OUT PKEVENT *event
    );


//
// Configuration Manager CM level registry functions
//

NTSTATUS
CmDeleteKey(
    IN PCM_KEY_BODY KeyBody
    );

NTSTATUS
CmDeleteValueKey(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    IN UNICODE_STRING ValueName
    );

NTSTATUS
CmEnumerateKey(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    IN PVOID KeyInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    );

NTSTATUS
CmEnumerateValueKey(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    IN PVOID KeyValueInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    );

NTSTATUS
CmFlushKey(
    IN PCM_KEY_CONTROL_BLOCK    Kcb,
    IN BOOLEAN                  RegistryLockOwnedExclusive
    );

NTSTATUS
CmQueryKey(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    IN PVOID KeyInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    );

NTSTATUS
CmQueryValueKey(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    IN UNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    IN PVOID KeyValueInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    );

NTSTATUS
CmQueryMultipleValueKey(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    IN PKEY_VALUE_ENTRY ValueEntries,
    IN ULONG EntryCount,
    IN PVOID ValueBuffer,
    IN OUT PULONG BufferLength,
    IN OPTIONAL PULONG ResultLength
    );

NTSTATUS
CmRenameValueKey(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    IN UNICODE_STRING SourceValueName,
    IN UNICODE_STRING TargetValueName,
    IN ULONG TargetIndex
    );

NTSTATUS
CmReplaceKey(
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell,
    IN PUNICODE_STRING NewHiveName,
    IN PUNICODE_STRING OldFileName
    );

NTSTATUS
CmRestoreKey(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    IN HANDLE  FileHandle,
    IN ULONG Flags
    );

NTSTATUS
CmSaveKey(
    IN PCM_KEY_CONTROL_BLOCK    KeyControlBlock,
    IN HANDLE                   FileHandle,
    IN ULONG                    HiveVersion
    );

NTSTATUS
CmDumpKey(
    IN PCM_KEY_CONTROL_BLOCK    KeyControlBlock,
    IN HANDLE                   FileHandle
    );

NTSTATUS
CmSaveMergedKeys(
    IN PCM_KEY_CONTROL_BLOCK    HighPrecedenceKcb,
    IN PCM_KEY_CONTROL_BLOCK    LowPrecedenceKcb,
    IN HANDLE   FileHandle
    );

NTSTATUS
CmpShiftHiveFreeBins(
                      PCMHIVE           CmHive,
                      PCMHIVE           *NewHive
                      );

NTSTATUS
CmpOverwriteHive(
                    PCMHIVE         CmHive,
                    PCMHIVE         NewHive,
                    HCELL_INDEX     LinkCell
                    );

VOID
CmpSwitchStorageAndRebuildMappings(PCMHIVE  OldCmHive,
                                   PCMHIVE  NewHive
                                   );

NTSTATUS
CmSetValueKey(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    IN PUNICODE_STRING ValueName,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    );

NTSTATUS
CmSetLastWriteTimeKey(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    IN PLARGE_INTEGER LastWriteTime
    );

NTSTATUS
CmSetKeyUserFlags(
    IN PCM_KEY_CONTROL_BLOCK    KeyControlBlock,
    IN ULONG                    UserFlags
    );

NTSTATUS
CmpNotifyChangeKey(
    IN PCM_KEY_BODY     KeyBody,
    IN PCM_POST_BLOCK   PostBlock,
    IN ULONG            CompletionFilter,
    IN BOOLEAN          WatchTree,
    IN PVOID            Buffer,
    IN ULONG            BufferSize,
    IN PCM_POST_BLOCK   MasterPostBlock
    );

NTSTATUS
CmLoadKey(
    IN POBJECT_ATTRIBUTES   TargetKey,
    IN POBJECT_ATTRIBUTES   SourceFile,
    IN ULONG                Flags,
    IN PCM_KEY_BODY         KeyBody
    );

#define CM_UNLOAD_KCB_LOCKED    1
#define CM_UNLOAD_REG_LOCKED_EX 2
                  
NTSTATUS
CmUnloadKey(
    IN PCM_KEY_CONTROL_BLOCK    Kcb,
    IN ULONG                    Flags,
    IN ULONG                    ControlFlags
    );

NTSTATUS
CmMoveKey(
    IN PCM_KEY_CONTROL_BLOCK    KeyControlBlock
    );

NTSTATUS
CmCompressKey(
    IN PHHIVE Hive
    );

//
// Procedures private to CM
//

BOOLEAN
CmpMarkKeyDirty(
    PHHIVE Hive,
    HCELL_INDEX Cell
#if DBG
    ,
    BOOLEAN CheckNoSubkeys
#endif
    );

BOOLEAN
CmpDoFlushAll(
    BOOLEAN ForceFlush
    );

VOID
CmpFixHiveUsageCount(
                    IN  PCMHIVE             CmHive
                    );

VOID
CmpLazyFlush(
    VOID
    );

VOID
CmpQuotaWarningWorker(
    IN PVOID WorkItem
    );

VOID
CmpComputeGlobalQuotaAllowed(
    VOID
    );

BOOLEAN
CmpClaimGlobalQuota(
    IN ULONG    Size
    );

VOID
CmpReleaseGlobalQuota(
    IN ULONG    Size
    );

VOID
CmpSetGlobalQuotaAllowed(
    VOID
    );

VOID
CmpSystemQuotaWarningWorker(
    IN PVOID WorkItem
    );

BOOLEAN
CmpCanGrowSystemHive(
                     IN PHHIVE  Hive,
                     IN ULONG   NewLength
                     );

//
// security functions (cmse.c)
//

NTSTATUS
CmpAssignSecurityDescriptor(
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell,
    IN PCM_KEY_NODE Node,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );

BOOLEAN
CmpCheckCreateAccess(
    IN PUNICODE_STRING RelativeName,
    IN PSECURITY_DESCRIPTOR Descriptor,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE PreviousMode,
    IN ACCESS_MASK AdditionalAccess,
    OUT PNTSTATUS AccessStatus
    );

BOOLEAN
CmpCheckNotifyAccess(
    IN PCM_NOTIFY_BLOCK NotifyBlock,
    IN PHHIVE Hive,
    IN PCM_KEY_NODE Node
    );

PSECURITY_DESCRIPTOR
CmpHiveRootSecurityDescriptor(
    VOID
    );

VOID
CmpFreeSecurityDescriptor(
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell
    );

NTSTATUS
CmpCheckKeyAccess(
    IN PHHIVE           Hive,
    IN HCELL_INDEX      NodeCell,
    IN KPROCESSOR_MODE  PreviousMode,
    IN ACCESS_MASK      DesiredAccess
    );

NTSTATUS
CmpDoAccessCheckOnSubtree(
    PHHIVE          HiveToCheck,
    HCELL_INDEX     Cell,
    KPROCESSOR_MODE PreviousMode,
    ACCESS_MASK     DesiredAccess,
    BOOLEAN         CheckRoot
    );

//
// Access to the registry is serialized by a shared resource, CmpRegistryLock.
//
extern ERESOURCE    CmpRegistryLock;

//
// Support for "StarveExclusive" mode ensuring a flush
//
extern LONG        CmpFlushStarveWriters;

#define ENTER_FLUSH_MODE()  InterlockedIncrement (&CmpFlushStarveWriters);

#if DBG
#define EXIT_FLUSH_MODE()                                                       \
{                                                                               \
    LONG LocalIncrement = (LONG)InterlockedDecrement (&CmpFlushStarveWriters);  \
    ASSERT( LocalIncrement >= 0 );                                              \
}
#else
#define EXIT_FLUSH_MODE() InterlockedDecrement (&CmpFlushStarveWriters)
#endif


VOID
CmpLockRegistryExclusive(
    VOID
    );
VOID
CmpLockRegistry(
    VOID
    );

VOID
CmpUnlockRegistry(
    );

#if DBG
BOOLEAN
CmpTestRegistryLock(
    VOID
    );
BOOLEAN
CmpTestRegistryLockExclusive(
    VOID
    );

#endif

NTSTATUS
CmpQueryKeyData(
    PHHIVE Hive,
    PCM_KEY_NODE Node,
    KEY_INFORMATION_CLASS KeyInformationClass,
    PVOID KeyInformation,
    ULONG Length,
    PULONG ResultLength
    );

NTSTATUS
CmpQueryKeyDataFromCache(
    PCM_KEY_CONTROL_BLOCK   Kcb,
    KEY_INFORMATION_CLASS   KeyInformationClass,
    PVOID                   KeyInformation,
    ULONG                   Length,
    PULONG                  ResultLength
    );


BOOLEAN
CmpFreeKeyBody(
    PHHIVE Hive,
    HCELL_INDEX Cell
    );

BOOLEAN
CmpFreeValue(
    PHHIVE Hive,
    HCELL_INDEX Cell
    );

HCELL_INDEX
CmpFindValueByName(
    PHHIVE Hive,
    PCM_KEY_NODE KeyNode,
    PUNICODE_STRING Name
    );

NTSTATUS
CmpDeleteChildByName(
    PHHIVE  Hive,
    HCELL_INDEX Cell,
    UNICODE_STRING  Name,
    PHCELL_INDEX    ChildCell
    );

NTSTATUS
CmpFreeKeyByCell(
    PHHIVE Hive,
    HCELL_INDEX Cell,
    BOOLEAN Unlink
    );

BOOLEAN
CmpFindNameInList(
    IN PHHIVE  Hive,
    IN PCHILD_LIST ChildList,
    IN PUNICODE_STRING Name,
    IN OPTIONAL PULONG ChildIndex,
    OUT PHCELL_INDEX    CellIndex
    );

HCELL_INDEX
CmpCopyCell(
    PHHIVE  SourceHive,
    HCELL_INDEX SourceCell,
    PHHIVE  TargetHive,
    HSTORAGE_TYPE   Type
    );

HCELL_INDEX
CmpCopyValue(
    PHHIVE  SourceHive,
    HCELL_INDEX SourceValueCell,
    PHHIVE  TargetHive,
    HSTORAGE_TYPE Type
    );

HCELL_INDEX
CmpCopyKeyPartial(
    PHHIVE  SourceHive,
    HCELL_INDEX SourceKeyCell,
    PHHIVE  TargetHive,
    HCELL_INDEX Parent,
    BOOLEAN CopyValues
    );

BOOLEAN
CmpCopySyncTree(
    PHHIVE                  SourceHive,
    HCELL_INDEX             SourceCell,
    PHHIVE                  TargetHive,
    HCELL_INDEX             TargetCell,
    BOOLEAN                 CopyVolatile,
    CMP_COPY_TYPE           CopyType
    );

//
// BOOLEAN
// CmpCopyTree(
//    PHHIVE      SourceHive,
//    HCELL_INDEX SourceCell,
//    PHHIVE      TargetHive,
//    HCELL_INDEX TargetCell
//    );
//

#define CmpCopyTree(s,c,t,l) CmpCopySyncTree(s,c,t,l,FALSE,Copy)

//
// BOOLEAN
// CmpCopyTreeEx(
//    PHHIVE      SourceHive,
//    HCELL_INDEX SourceCell,
//    PHHIVE      TargetHive,
//    HCELL_INDEX TargetCell,
//    BOOLEAN     CopyVolatile
//    );
//

#define CmpCopyTreeEx(s,c,t,l,f) CmpCopySyncTree(s,c,t,l,f,Copy)

//
// BOOLEAN
// CmpSyncTrees(
//   PHHIVE      SourceHive,
//   HCELL_INDEX SourceCell,
//   PHHIVE      TargetHive,
//   HCELL_INDEX TargetCell,
//   BOOLEAN     CopyVolatile);
//

#define CmpSyncTrees(s,c,t,l,f) CmpCopySyncTree(s,c,t,l,f,Sync)


//
// BOOLEAN
// CmpMergeTrees(
//   PHHIVE      SourceHive,
//   HCELL_INDEX SourceCell,
//   PHHIVE      TargetHive,
//   HCELL_INDEX TargetCell);
//

#define CmpMergeTrees(s,c,t,l) CmpCopySyncTree(s,c,t,l,FALSE,Merge)

VOID
CmpDeleteTree(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    );

VOID
CmpSetVersionData(
    VOID
    );

NTSTATUS
CmpInitializeHardwareConfiguration(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

NTSTATUS
CmpInitializeMachineDependentConfiguration(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

NTSTATUS
CmpInitializeRegistryNode(
    IN PCONFIGURATION_COMPONENT_DATA CurrentEntry,
    IN HANDLE ParentHandle,
    OUT PHANDLE NewHandle,
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber,
    IN PUSHORT DeviceIndexTable
    );

NTSTATUS
CmpInitializeHive(
    PCMHIVE         *CmHive,
    ULONG           OperationType,
    ULONG           HiveFlags,
    ULONG           FileType,
    PVOID           HiveData OPTIONAL,
    HANDLE          Primary,
    HANDLE          Log,
    HANDLE          External,
    PUNICODE_STRING FileName OPTIONAL,
    ULONG           CheckFlags
    );

LOGICAL
CmpDestroyHive(
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell
    );

VOID
CmpInitializeRegistryNames(
    VOID
    );

VOID
CmpInitializeCache(
    VOID
    );

#define CMP_CREATE_KCB_FAKE                     1
#define CMP_CREATE_KCB_KCB_LOCKED               2
#define CMP_DO_OPEN_COMPLETE_KEY_CACHED         4

PCM_KEY_CONTROL_BLOCK
CmpCreateKeyControlBlock(
    PHHIVE                  Hive,
    HCELL_INDEX             Cell,
    PCM_KEY_NODE            Node,
    PCM_KEY_CONTROL_BLOCK   ParentKcb,
    ULONG                   ControlFlags,
    PUNICODE_STRING         KeyName
    );

VOID CmpCleanUpKCBCacheTable(PCM_KEY_CONTROL_BLOCK    KeyControlBlock,
                             BOOLEAN                    RegLockHeldEx);

typedef struct _QUERY_OPEN_SUBKEYS_CONTEXT {
    ULONG       BufferLength;
    PVOID       Buffer;
    ULONG       RequiredSize;
    NTSTATUS    StatusCode;
    ULONG       UsedLength;
	PVOID		KeyBodyToIgnore;
    PVOID       CurrentNameBuffer;
} QUERY_OPEN_SUBKEYS_CONTEXT, *PQUERY_OPEN_SUBKEYS_CONTEXT;

ULONG
CmpSearchForOpenSubKeys(
    IN PCM_KEY_CONTROL_BLOCK    SearchKey,
    IN SUBKEY_SEARCH_TYPE       SearchType,
    IN BOOLEAN                  RegLockHeldEx,
    IN OUT PVOID                SearchContext OPTIONAL
    );

VOID
CmpDereferenceKeyControlBlock(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock
    );

VOID
CmpRemoveKeyControlBlock(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock
    );

VOID
CmpReportNotify(
    PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    PHHIVE          Hive,
    HCELL_INDEX     Cell,
    ULONG           NotifyMask
    );

VOID
CmpPostNotify(
    PCM_NOTIFY_BLOCK    NotifyBlock,
    PUNICODE_STRING     Name OPTIONAL,
    ULONG               Filter,
    NTSTATUS            Status,
    BOOLEAN             PostListLockHeld,
    PLIST_ENTRY         ExternalKeyDeref OPTIONAL
#if DBG
    ,
    PCMHIVE             CmHive
#endif 
    );

PCM_POST_BLOCK
CmpAllocatePostBlock(
    IN POST_BLOCK_TYPE BlockType,
    IN ULONG           PostFlags,
    IN PCM_KEY_BODY    KeyBody,
    IN PCM_POST_BLOCK  MasterBlock
    );

//
// PCM_POST_BLOCK
// CmpAllocateMasterPostBlock(
//    IN POST_BLOCK_TYPE BlockType
//     );
//
#define CmpAllocateMasterPostBlock(b) CmpAllocatePostBlock(b,REG_NOTIFY_MASTER_POST,NULL,NULL)

//
// PCM_POST_BLOCK
// CmpAllocateSlavePostBlock(
//    IN POST_BLOCK_TYPE BlockType,
//    IN PCM_KEY_BODY     KeyBody,
//    IN PCM_POST_BLOCK  MasterBlock
//     );
//
#define CmpAllocateSlavePostBlock(b,k,m) CmpAllocatePostBlock(b,0,k,m)

VOID
CmpFreePostBlock(
    IN PCM_POST_BLOCK PostBlock
    );

VOID
CmpPostApc(
    struct _KAPC *Apc,
    PKNORMAL_ROUTINE *NormalRoutine,
    PVOID *NormalContext,
    PVOID *SystemArgument1,
    PVOID *SystemArgument2
    );

VOID
CmpFlushNotify(
    PCM_KEY_BODY    KeyBody,
    BOOLEAN         LockHeld
    );

VOID
CmpPostApcRunDown(
    struct _KAPC *Apc
    );

NTSTATUS
CmpOpenHiveFiles(
    PUNICODE_STRING     BaseName,
    PWSTR               Extension OPTIONAL,
    PHANDLE             Primary,
    PHANDLE             Secondary,
    PULONG              PrimaryDisposition,
    PULONG              SecondaryDispoition,
    BOOLEAN             CreateAllowed,
    BOOLEAN             MarkAsSystemHive,
    BOOLEAN             NoBuffering,
    PULONG              ClusterSize
    );

NTSTATUS
CmpLinkHiveToMaster(
    PUNICODE_STRING LinkName,
    HANDLE RootDirectory,
    PCMHIVE CmHive,
    BOOLEAN Allocate,
    PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSTATUS
CmpSaveBootControlSet(
     IN USHORT ControlSetNum
     );

//
// checkout procedure
//

//
// Flags to be passed to CmCheckRegistry
//
#define     CM_CHECK_REGISTRY_CHECK_CLEAN       0x00000001
#define     CM_CHECK_REGISTRY_FORCE_CLEAN       0x00000002
#define     CM_CHECK_REGISTRY_LOADER_CLEAN      0x00000004
#define     CM_CHECK_REGISTRY_SYSTEM_CLEAN      0x00000008
#define     CM_CHECK_REGISTRY_HIVE_CHECK        0x00010000
#define     CM_DONT_ADD_TO_HIVE_LIST            0x01000000

ULONG
CmCheckRegistry(
    PCMHIVE CmHive,
    ULONG   Flags
    );

BOOLEAN
CmpValidateHiveSecurityDescriptors(
    IN PHHIVE       Hive,
    OUT PBOOLEAN    ResetSD
    );

//
// cmboot - functions for determining driver load lists
//

#define CM_HARDWARE_PROFILE_STR_DATABASE L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\IDConfigDB"
#define CM_HARDWARE_PROFILE_STR_CCS_HWPROFILE L"\\Registry\\Machine\\System\\CurrentControlSet\\Hardware Profiles"
#define CM_HARDWARE_PROFILE_STR_CCS_CURRENT L"\\Registry\\Machine\\System\\CurrentControlSet\\Hardware Profiles\\Current"
//
// Alias table key names in IDConfigDB
//
#define CM_HARDWARE_PROFILE_STR_ALIAS L"Alias"
#define CM_HARDWARE_PROFILE_STR_ACPI_ALIAS L"AcpiAlias"
#define CM_HARDWARE_PROFILE_STR_HARDWARE_PROFILES L"Hardware Profiles"

//
// Entries in the alias tables (value names)
//
#define CM_HARDWARE_PROFILE_STR_DOCKING_STATE L"DockingState"
#define CM_HARDWARE_PROFILE_STR_CAPABILITIES L"Capabilities"
#define CM_HARDWARE_PROFILE_STR_DOCKID L"DockID"
#define CM_HARDWARE_PROFILE_STR_SERIAL_NUMBER L"SerialNumber"
#define CM_HARDWARE_PROFILE_STR_ACPI_SERIAL_NUMBER L"AcpiSerialNumber"
#define CM_HARDWARE_PROFILE_STR_PROFILE_NUMBER L"ProfileNumber"
#define CM_HARDWARE_PROFILE_STR_ALIASABLE L"Aliasable"
#define CM_HARDWARE_PROFILE_STR_CLONED L"Cloned"
//
// Entries in the profile tables.
//
#define CM_HARDWARE_PROFILE_STR_PRISTINE L"Pristine"
#define CM_HARDWARE_PROFILE_STR_PREFERENCE_ORDER L"PreferenceOrder"
#define CM_HARDWARE_PROFILE_STR_FRIENDLY_NAME L"FriendlyName"
#define CM_HARDWARE_PROFILE_STR_CURRENT_DOCK_INFO L"CurrentDockInfo"
#define CM_HARDWARE_PROFILE_STR_HW_PROFILE_GUID L"HwProfileGuid"
//
// Entries for the root Hardware Profiles key.
//
#define CM_HARDWARE_PROFILE_STR_DOCKED L"Docked"
#define CM_HARDWARE_PROFILE_STR_UNDOCKED L"Undocked"
#define CM_HARDWARE_PROFILE_STR_UNKNOWN L"Unknown"

//
// List structure used in config manager init
//

typedef struct _HIVE_LIST_ENTRY {
    PWSTR       Name;
    PWSTR       BaseName;                       // MACHINE or USER
    PCMHIVE     CmHive;
    ULONG       HHiveFlags;
    ULONG       CmHiveFlags;
    PCMHIVE     CmHive2;
    BOOLEAN     ThreadFinished;
    BOOLEAN     ThreadStarted;
    BOOLEAN     Allocate;
} HIVE_LIST_ENTRY, *PHIVE_LIST_ENTRY;

//
// structure definitions shared with the boot loader
// to select the hardware profile.
//
typedef struct _CM_HARDWARE_PROFILE {
    ULONG   NameLength;
    PWSTR   FriendlyName;
    ULONG   PreferenceOrder;
    ULONG   Id;
    ULONG   Flags;
} CM_HARDWARE_PROFILE, *PCM_HARDWARE_PROFILE;

#define CM_HP_FLAGS_ALIASABLE  1
#define CM_HP_FLAGS_TRUE_MATCH 2
#define CM_HP_FLAGS_PRISTINE   4
#define CM_HP_FLAGS_DUPLICATE  8

typedef struct _CM_HARDWARE_PROFILE_LIST {
    ULONG MaxProfileCount;
    ULONG CurrentProfileCount;
    CM_HARDWARE_PROFILE Profile[1];
} CM_HARDWARE_PROFILE_LIST, *PCM_HARDWARE_PROFILE_LIST;

typedef struct _CM_HARDWARE_PROFILE_ALIAS {
    ULONG   ProfileNumber;
    ULONG   DockState;
    ULONG   DockID;
    ULONG   SerialNumber;
} CM_HARDWARE_PROFILE_ALIAS, *PCM_HARDWARE_PROFILE_ALIAS;

typedef struct _CM_HARDWARE_PROFILE_ALIAS_LIST {
    ULONG MaxAliasCount;
    ULONG CurrentAliasCount;
    CM_HARDWARE_PROFILE_ALIAS Alias[1];
} CM_HARDWARE_PROFILE_ALIAS_LIST, *PCM_HARDWARE_PROFILE_ALIAS_LIST;

typedef struct _CM_HARDWARE_PROFILE_ACPI_ALIAS {
    ULONG   ProfileNumber;
    ULONG   DockState;
    ULONG   SerialLength;
    PCHAR   SerialNumber;
} CM_HARDWARE_PROFILE_ACPI_ALIAS, *PCM_HARDWARE_PROFILE_ACPI_ALIAS;

typedef struct _CM_HARDWARE_PROFILE_ACPI_ALIAS_LIST {
    ULONG   MaxAliasCount;
    ULONG   CurrentAliasCount;
    CM_HARDWARE_PROFILE_ACPI_ALIAS Alias[1];
} CM_HARDWARE_PROFILE_ACPI_ALIAS_LIST, *PCM_HARDWARE_PROFILE_ACPI_ALIAS_LIST;

HCELL_INDEX
CmpFindControlSet(
     IN PHHIVE SystemHive,
     IN HCELL_INDEX RootCell,
     IN PUNICODE_STRING SelectName,
     OUT PBOOLEAN AutoSelect
     );

BOOLEAN
CmpValidateSelect(
     IN PHHIVE SystemHive,
     IN HCELL_INDEX RootCell
     );

BOOLEAN
CmpFindDrivers(
    IN PHHIVE Hive,
    IN HCELL_INDEX ControlSet,
    IN SERVICE_LOAD_TYPE LoadType,
    IN PWSTR BootFileSystem OPTIONAL,
    IN PLIST_ENTRY DriverListHead
    );

BOOLEAN
CmpFindNLSData(
    IN PHHIVE Hive,
    IN HCELL_INDEX ControlSet,
    OUT PUNICODE_STRING AnsiFilename,
    OUT PUNICODE_STRING OemFilename,
    OUT PUNICODE_STRING CaseTableFilename,
    OUT PUNICODE_STRING OemHalFilename
    );

HCELL_INDEX
CmpFindProfileOption(
    IN PHHIVE Hive,
    IN HCELL_INDEX ControlSet,
    OUT PCM_HARDWARE_PROFILE_LIST *ProfileList,
    OUT PCM_HARDWARE_PROFILE_ALIAS_LIST *AliasList,
    OUT PULONG Timeout
    );

VOID
CmpSetCurrentProfile(
    IN PHHIVE Hive,
    IN HCELL_INDEX ControlSet,
    IN PCM_HARDWARE_PROFILE Profile
    );

BOOLEAN
CmpResolveDriverDependencies(
    IN PLIST_ENTRY DriverListHead
    );

BOOLEAN
CmpSortDriverList(
    IN PHHIVE Hive,
    IN HCELL_INDEX ControlSet,
    IN PLIST_ENTRY DriverListHead
    );

HCELL_INDEX
CmpFindSubKeyByName(
    PHHIVE          Hive,
    PCM_KEY_NODE    Parent,
    PUNICODE_STRING SearchName
    );

HCELL_INDEX
CmpFindSubKeyByNumber(
    PHHIVE          Hive,
    PCM_KEY_NODE    Parent,
    ULONG           Number
    );

BOOLEAN
CmpAddSubKey(
    PHHIVE          Hive,
    HCELL_INDEX     Parent,
    HCELL_INDEX     Child
    );

BOOLEAN
CmpMarkIndexDirty(
    PHHIVE          Hive,
    HCELL_INDEX     ParentKey,
    HCELL_INDEX     TargetKey
    );

BOOLEAN
CmpRemoveSubKey(
    PHHIVE          Hive,
    HCELL_INDEX     ParentKey,
    HCELL_INDEX     TargetKey
    );

BOOLEAN
CmpGetNextName(
    IN OUT PUNICODE_STRING  RemainingName,
    OUT    PUNICODE_STRING  NextName,
    OUT    PBOOLEAN  Last
    );

NTSTATUS
CmpAddToHiveFileList(
    PCMHIVE CmHive
    );

VOID
CmpRemoveFromHiveFileList(
                          PUNICODE_STRING HiveName
    );

NTSTATUS
CmpInitHiveFromFile(
    IN PUNICODE_STRING FileName,
    IN ULONG HiveFlags,
    OUT PCMHIVE *CmHive,
    IN OUT PBOOLEAN Allocate,
    IN  ULONG       CheckFlags
    );

NTSTATUS
CmpCloneHwProfile (
    IN HANDLE IDConfigDB,
    IN HANDLE Parent,
    IN HANDLE OldProfile,
    IN ULONG  OldProfileNumber,
    IN USHORT DockingState,
    OUT PHANDLE NewProfile,
    OUT PULONG  NewProfileNumber
    );

NTSTATUS
CmpCreateHwProfileFriendlyName (
    IN HANDLE IDConfigDB,
    IN ULONG  DockingState,
    IN ULONG  NewProfileNumber,
    OUT PUNICODE_STRING FriendlyName
    );

typedef
NTSTATUS
(*PCM_ACPI_SELECTION_ROUTINE) (
    IN  PCM_HARDWARE_PROFILE_LIST ProfileList,
    OUT PULONG ProfileIndexToUse, // Set to -1 for none.
    IN  PVOID Context
    );

NTSTATUS
CmSetAcpiHwProfile (
    IN  PPROFILE_ACPI_DOCKING_STATE DockState,
    IN  PCM_ACPI_SELECTION_ROUTINE,
    IN  PVOID Context,
    OUT PHANDLE NewProfile,
    OUT PBOOLEAN ProfileChanged
    );

NTSTATUS
CmpAddAcpiAliasEntry (
    IN HANDLE                       IDConfigDB,
    IN PPROFILE_ACPI_DOCKING_STATE  NewDockState,
    IN ULONG                        ProfileNumber,
    IN PWCHAR                       nameBuffer,
    IN PVOID                        valueBuffer,
    IN ULONG                        valueBufferLength,
    IN BOOLEAN                      PreventDuplication
    );

//
// Routines for handling registry compressed names
//
USHORT
CmpNameSize(
    IN PHHIVE Hive,
    IN PUNICODE_STRING Name
    );

USHORT
CmpCopyName(
    IN PHHIVE Hive,
    IN PWCHAR Destination,
    IN PUNICODE_STRING Source
    );

VOID
CmpCopyCompressedName(
    IN PWCHAR Destination,
    IN ULONG DestinationLength,
    IN PWCHAR Source,
    IN ULONG SourceLength
    );

USHORT
CmpCompressedNameSize(
    IN PWCHAR Name,
    IN ULONG Length
    );


//
// ----- CACHED_DATA -----
//
// When values are not cached, List in ValueCache is the Hive cell index to the value list.
// When they are cached, List will be pointer to the allocation.  We distinguish them by
// marking the lowest bit in the variable to indicate it is a cached allocation.
//
// Note that the cell index for value list
// is stored in the cached allocation.  It is not used now but may be in further performance
// optimization.
//
// When value key and vaule data are cached, there is only one allocation for both.
// Value data is appended that the end of value key.  DataCacheType indicates
// whether data is cached and ValueKeySize tells how big is the value key (so
// we can calculate the address of cached value data)
//
//

PCM_NAME_CONTROL_BLOCK
CmpGetNameControlBlock(
    PUNICODE_STRING NodeName,
    PBOOLEAN        NameUpCase
    );

VOID
CmpDereferenceKeyControlBlockWithLock(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock,
    BOOLEAN                 RegLockHeldEx
    );

VOID
CmpCleanUpSubKeyInfo(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock
    );

VOID
CmpCleanUpKcbValueCache(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock
    );


VOID
CmpRebuildKcbCache(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock
    );



/* - macro
VOID
CmpSetUpKcbValueCache(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock,
    ULONG                   Count,
    ULONG_PTR               ValueList
    )
*/
#define CmpSetUpKcbValueCache(KeyControlBlock,_Count,_List)                 \
    ASSERT( !(CMP_IS_CELL_CACHED(KeyControlBlock->ValueCache.ValueList)) ); \
    ASSERT( !(KeyControlBlock->ExtFlags & CM_KCB_SYM_LINK_FOUND) );         \
    KeyControlBlock->ValueCache.Count = (ULONG)(_Count);                    \
    KeyControlBlock->ValueCache.ValueList = (ULONG_PTR)(_List)

VOID
CmpCleanUpKcbCacheWithLock(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock,
    BOOLEAN                 RegLockHeldEx
    );

VOID
CmpRemoveFromDelayedClose(
    IN PCM_KEY_CONTROL_BLOCK kcb
    );

PUNICODE_STRING
CmpConstructName(
    PCM_KEY_CONTROL_BLOCK kcb
);

typedef enum _VALUE_SEARCH_RETURN_TYPE {
    SearchSuccess = 0,
    SearchNeedExclusiveLock = 1,
    SearchFail = 2
} VALUE_SEARCH_RETURN_TYPE;

VALUE_SEARCH_RETURN_TYPE
CmpGetValueListFromCache(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    OUT PCELL_DATA          *List,
    OUT BOOLEAN             *IndexCached,
    OUT PHCELL_INDEX        ValueListToRelease
);

VALUE_SEARCH_RETURN_TYPE
CmpGetValueKeyFromCache(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    IN PCELL_DATA           List,
    IN ULONG                Index,
    OUT PPCM_CACHED_VALUE   *ContainingList,
    OUT PCM_KEY_VALUE       *Value,
    IN BOOLEAN              IndexCached,
    OUT BOOLEAN             *ValueCached,
    OUT PHCELL_INDEX        CellToRelease
);

VALUE_SEARCH_RETURN_TYPE
CmpFindValueByNameFromCache(
    IN PCM_KEY_CONTROL_BLOCK    KeyControlBlock,
    IN PUNICODE_STRING          Name,
    OUT PPCM_CACHED_VALUE       *ContainingList,
    OUT ULONG                   *Index,
    OUT PCM_KEY_VALUE           *Value,
    OUT BOOLEAN                 *ValueCached,
    OUT PHCELL_INDEX            CellToRelease
    );

VALUE_SEARCH_RETURN_TYPE
CmpGetValueDataFromCache(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    IN PPCM_CACHED_VALUE    ContainingList,
    IN PCELL_DATA           ValueKey,
    IN BOOLEAN              ValueCached,
    OUT PUCHAR              *DataPointer,
    OUT PBOOLEAN            Allocated,
    OUT PHCELL_INDEX        CellToRelease
);

VALUE_SEARCH_RETURN_TYPE
CmpQueryKeyValueData(
    PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    PPCM_CACHED_VALUE   ContainingList,
    PCM_KEY_VALUE       ValueKey,
    BOOLEAN             ValueCached,
    KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    PVOID               KeyValueInformation,
    ULONG               Length,
    PULONG              ResultLength,
    NTSTATUS            *status
    );

BOOLEAN
CmpReferenceKeyControlBlock(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock
    );

VOID
CmpInitializeKeyNameString(PCM_KEY_NODE Cell,
                           PUNICODE_STRING KeyName,
                           WCHAR *NameBuffer
                           );

VOID
CmpInitializeValueNameString(PCM_KEY_VALUE Cell,
                             PUNICODE_STRING ValueName,
                             WCHAR *NameBuffer
                             );

VOID
CmpFlushNotifiesOnKeyBodyList(
    IN PCM_KEY_CONTROL_BLOCK    kcb,
    IN BOOLEAN                  LockHeld
    );

extern ULONG CmpHashTableSize;
extern  PCM_KEY_HASH_TABLE_ENTRY    CmpCacheTable;
extern  PCM_NAME_HASH_TABLE_ENTRY   CmpNameCacheTable;

#ifdef _WANT_MACHINE_IDENTIFICATION

BOOLEAN
CmpGetBiosDateFromRegistry(
    IN PHHIVE Hive,
    IN HCELL_INDEX ControlSet,
    OUT PUNICODE_STRING Date
    );

BOOLEAN
CmpGetBiosinfoFileNameFromRegistry(
    IN PHHIVE Hive,
    IN HCELL_INDEX ControlSet,
    OUT PUNICODE_STRING InfName
    );


#endif


// Utility macro to set the fields of an IO_STATUS_BLOCK.  On Win64, 32bit processes
// will pass in a 32bit Iosb, and 64bit processes will pass in a 64bit Iosb.
#if defined(_WIN64)

#define CmpSetIoStatus(Iosb, s, i, UseIosb32)                              \
if ((UseIosb32)) {                                                         \
    ((PIO_STATUS_BLOCK32)(Iosb))->Status = (NTSTATUS)(s);                  \
    ((PIO_STATUS_BLOCK32)(Iosb))->Information = (ULONG)(i);                \
}                                                                          \
else {                                                                     \
    (Iosb)->Status = (s);                                                  \
    (Iosb)->Information = (i);                                             \
}                                                                          \

#else

#define CmpSetIoStatus(Iosb, s, i, UseIosb32)                              \
(Iosb)->Status = (s);                                                      \
(Iosb)->Information = (i);                                                 \

#endif

#define CmpCheckIoStatusPointer(AsyncUser)                                              \
    if( (PVOID)((AsyncUser).IoStatusBlock) == (PVOID)(&((AsyncUser).IoStatusBlock)) ) { \
        DbgPrint("IoStatusBlock pointing onto itself AsyncUser = %p\n",&(AsyncUser));   \
        DbgBreakPoint();                                                                \
    }


// new function prototypes

NTSTATUS
CmpAcquireFileObjectForFile(
        IN  PCMHIVE         CmHive,
        IN HANDLE           FileHandle,
        OUT PFILE_OBJECT    *FileObject
            );

VOID
CmpDropFileObjectForHive(
        IN  PCMHIVE             CmHive
            );

VOID
CmpTouchView(
    IN PCMHIVE              CmHive,
    IN PCM_VIEW_OF_FILE     CmView,
    IN ULONG                Cell
            );

NTSTATUS
CmpMapCmView(
    IN  PCMHIVE             CmHive,
    IN  ULONG               FileOffset,
    OUT PCM_VIEW_OF_FILE    *CmView,
    IN  BOOLEAN             MapInited
    );

VOID
CmpInitHiveViewList (
        IN  PCMHIVE             CmHive
                             );

VOID
CmpDestroyHiveViewList (
        IN  PCMHIVE             CmHive
                             );

NTSTATUS
CmpPinCmView (
        IN  PCMHIVE             CmHive,
        PCM_VIEW_OF_FILE        CmView
                             );
VOID
CmpUnPinCmView (
        IN  PCMHIVE             CmHive,
        IN  PCM_VIEW_OF_FILE    CmView,
        IN  BOOLEAN             SetClean,
        IN  BOOLEAN             MapIsValid
                             );

NTSTATUS
CmpMapThisBin(
                PCMHIVE         CmHive,
                HCELL_INDEX     Cell,
                BOOLEAN         Touch
              );
VOID
CmpReferenceHiveView(   IN PCMHIVE          CmHive,
                        IN PCM_VIEW_OF_FILE CmView
                     );
VOID
CmpDereferenceHiveView(   IN PCMHIVE          CmHive,
                        IN PCM_VIEW_OF_FILE CmView
                     );

VOID
CmpReferenceHiveViewWithLock(   IN PCMHIVE          CmHive,
                                IN PCM_VIEW_OF_FILE CmView
                            );

VOID
CmpDereferenceHiveViewWithLock(     IN PCMHIVE          CmHive,
                                    IN PCM_VIEW_OF_FILE CmView
                                );

VOID
CmpInitializeDelayedCloseTable();

VOID
CmpAddToDelayedClose(
    IN PCM_KEY_CONTROL_BLOCK    kcb,
    IN BOOLEAN                  RegLockHeldEx
    );

NTSTATUS
CmpAddValueToList(
    IN PHHIVE  Hive,
    IN HCELL_INDEX ValueCell,
    IN ULONG Index,
    IN ULONG Type,
    IN OUT PCHILD_LIST ChildList
    );

NTSTATUS
CmpRemoveValueFromList(
    IN PHHIVE  Hive,
    IN ULONG Index,
    IN OUT PCHILD_LIST ChildList
    );

BOOLEAN
CmpGetValueData(IN PHHIVE Hive,
                IN PCM_KEY_VALUE Value,
                OUT PULONG realsize,
                IN OUT PVOID *Buffer,
                OUT PBOOLEAN Allocated,
                OUT PHCELL_INDEX CellToRelease
               );

PCELL_DATA
CmpValueToData(IN PHHIVE Hive,
               IN PCM_KEY_VALUE Value,
               OUT PULONG realsize
               );

BOOLEAN
CmpMarkValueDataDirty(  IN PHHIVE Hive,
                        IN PCM_KEY_VALUE Value
                      );

NTSTATUS
CmpSetValueDataNew(
    IN PHHIVE           Hive,
    IN PVOID            Data,
    IN ULONG            DataSize,
    IN ULONG            StorageType,
    IN HCELL_INDEX      ValueCell,
    OUT PHCELL_INDEX    DataCell
    );

NTSTATUS
CmpSetValueDataExisting(
    IN PHHIVE           Hive,
    IN PVOID            Data,
    IN ULONG            DataSize,
    IN ULONG            StorageType,
    IN HCELL_INDEX      OldDataCell
    );

BOOLEAN
CmpFreeValueData(
    PHHIVE      Hive,
    HCELL_INDEX DataCell,
    ULONG       DataLength
    );


NTSTATUS
CmpAddSecurityCellToCache (
    IN OUT PCMHIVE              CmHive,
    IN HCELL_INDEX              SecurityCell,
    IN BOOLEAN                  BuildUp,
    IN PCM_KEY_SECURITY_CACHE   SecurityCached
    );

BOOLEAN
CmpFindSecurityCellCacheIndex (
    IN PCMHIVE      CmHive,
    IN HCELL_INDEX  SecurityCell,
    OUT PULONG      Index
    );

BOOLEAN
CmpAdjustSecurityCacheSize (
    IN PCMHIVE      CmHive
    );

VOID
CmpRemoveFromSecurityCache (
    IN OUT PCMHIVE      CmHive,
    IN HCELL_INDEX      SecurityCell
    );

VOID
CmpDestroySecurityCache (
    IN OUT PCMHIVE      CmHive
    );


VOID
CmpInitSecurityCache(
    IN OUT PCMHIVE      CmHive
    );

BOOLEAN
CmpRebuildSecurityCache(
                        IN OUT PCMHIVE      CmHive
                        );

ULONG
CmpSecConvKey(
              IN ULONG  DescriptorLength,
              IN PULONG Descriptor
              );

VOID
CmpAssignSecurityToKcb(
    IN PCM_KEY_CONTROL_BLOCK    Kcb,
    IN HCELL_INDEX              SecurityCell,
    IN BOOLEAN                  SecurityLocked
    );

BOOLEAN
CmpBuildSecurityCellMappingArray(
    IN PCMHIVE CmHive
    );


//
// new function replacing CmpWorker
//
VOID
CmpCmdHiveClose(
                     PCMHIVE    CmHive
                     );

VOID
CmpCmdInit(
           BOOLEAN SetupBoot
            );

NTSTATUS
CmpCmdRenameHive(
            PCMHIVE                     CmHive,
            POBJECT_NAME_INFORMATION    OldName,
            PUNICODE_STRING             NewName,
            ULONG                       NameInfoLength
            );

NTSTATUS
CmpCmdHiveOpen(
            POBJECT_ATTRIBUTES          FileAttributes,
            PSECURITY_CLIENT_CONTEXT    ImpersonationContext,
            PBOOLEAN                    Allocate,
            PCMHIVE                     *NewHive,
            ULONG                       CheckFlags
            );

ULONG
CmpComputeKcbConvKey(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock
    );

HCELL_INDEX
CmpDuplicateIndex(
    PHHIVE          Hive,
    HCELL_INDEX     IndexCell,
    ULONG           StorageType
    );

NTSTATUS
CmRenameKey(
    IN PCM_KEY_CONTROL_BLOCK    KeyControlBlock,
    IN UNICODE_STRING           NewKeyName,         
    IN KPROCESSOR_MODE          PreviousMode
    );

BOOLEAN
CmpUpdateParentForEachSon(
    PHHIVE          Hive,
    HCELL_INDEX     Parent
    );

NTSTATUS
CmUnloadKeyEx(
    IN PCM_KEY_CONTROL_BLOCK Kcb,
    IN PKEVENT UserEvent
    );

VOID
CmpShutdownWorkers(
    VOID
    );

VOID
CmpPrefetchHiveFile(
                    IN PFILE_OBJECT FileObject,
                    IN ULONG        Length
                    );

#define CmpCheckForOrphanedKcbs(Hive) //nothing

#define CM_HIVE_COMPRESS_LEVEL   (25)


#define CMP_MAX_REGISTRY_DEPTH      512        // levels

typedef struct {
    HCELL_INDEX Cell;
    HCELL_INDEX ParentCell;
    HCELL_INDEX PriorSibling;
    ULONG       ChildIndex;
    BOOLEAN     CellChecked;
} CMP_CHECK_REGISTRY_STACK_ENTRY, *PCMP_CHECK_REGISTRY_STACK_ENTRY;


#define CmIsKcbReadOnly(kcb)        ((kcb)->ExtFlags & CM_KCB_READ_ONLY_KEY)

NTSTATUS
CmLockKcbForWrite(PCM_KEY_CONTROL_BLOCK KeyControlBlock);

//
// Wrapper to RtlCompareUnicodeString; uses CompareFlags to avoid upcasing names
//

#define CMP_SOURCE_UP       0x00000001
#define CMP_DEST_UP         0x00000002

LONG
CmpCompareUnicodeString(
    IN PUNICODE_STRING  SourceName,
    IN PUNICODE_STRING  DestName,
    IN ULONG            CompareFlags
    );

LONG
CmpCompareCompressedName(
    IN PUNICODE_STRING  SearchName,
    IN PWCHAR           CompressedName,
    IN ULONG            NameLength,
    IN ULONG            CompareFlags
    );

LONG
CmpCompareTwoCompressedNames(
    IN PWCHAR           CompressedName1,
    IN ULONG            NameLength1,
    IN PWCHAR           CompressedName2,
    IN ULONG            NameLength2
    );

#define INIT_SYSTEMROOT_HIVEPATH L"\\SystemRoot\\System32\\Config\\"


ULONG
CmpComputeHashKey(
    IN ULONG            HashStart,
    IN PUNICODE_STRING  Name
#if DBG
    ,IN BOOLEAN        AllowSeparators
#endif
    );


ULONG
CmpComputeHashKeyForCompressedName(
                                    IN ULONG    HashStart,
                                    IN PWCHAR   Source,
                                    IN ULONG SourceLength
                                    );
//
// KCB allocator routines
//
VOID CmpInitCmPrivateAlloc();
VOID CmpDestroyCmPrivateAlloc();
PCM_KEY_CONTROL_BLOCK CmpAllocateKeyControlBlock( );
VOID CmpFreeKeyControlBlock( PCM_KEY_CONTROL_BLOCK kcb );

//
// delay related allocator routines
//
VOID CmpInitCmPrivateDelayAlloc();
VOID CmpDestroyCmPrivateDelayAlloc();
PVOID CmpAllocateDelayItem( );
VOID CmpFreeDelayItem( PVOID Item );

//
// make handles protected, so we control handle closure
//

#define CmpSetHandleProtection(Handle,Protection)                       \
{                                                                       \
    OBJECT_HANDLE_FLAG_INFORMATION  Ohfi = {    FALSE,                  \
                                                FALSE                   \
                                            };                          \
    Ohfi.ProtectFromClose = Protection;                                 \
    ZwSetInformationObject( Handle,                                     \
                            ObjectHandleFlagInformation,                \
                            &Ohfi,                                      \
                            sizeof (OBJECT_HANDLE_FLAG_INFORMATION));   \
}

#define CmCloseHandle(Handle)               \
    CmpSetHandleProtection(Handle,FALSE);   \
    ZwClose(Handle)


VOID
CmpUpdateSystemHiveHysteresis(  PHHIVE  Hive,
                                ULONG   NewLength,
                                ULONG   OldLength
                                );

NTSTATUS
CmpCallCallBacks (
    IN REG_NOTIFY_CLASS Type,
    IN PVOID            Argument,
    IN BOOLEAN          Wind,
    IN REG_NOTIFY_CLASS PostType,
    IN PVOID            Object
    );

extern ULONG CmpCallBackCount;

#define CmAreCallbacksRegistered() ((CmpCallBackCount != 0) && (0 == ExIsResourceAcquiredShared(&CmpRegistryLock)))

#define CmPostCallbackNotification(Type,_Object_,_Status_)      \
    if( CmAreCallbacksRegistered() ) {                          \
        REG_POST_OPERATION_INFORMATION PostInfo;                \
        PostInfo.Object = _Object_;                             \
        PostInfo.Status = _Status_;                             \
        CmpCallCallBacks(Type,&PostInfo,FALSE,Type,_Object_);   \
    }

//
// Self healing hives control switch
//
extern BOOLEAN  CmpSelfHeal;
extern ULONG    CmpBootType;

#define CmDoSelfHeal() (CmpSelfHeal || (CmpBootType & (HBOOT_BACKUP|HBOOT_SELFHEAL)))

#define CmMarkSelfHeal(Hive) ( (Hive)->BaseBlock->BootType |= HBOOT_SELFHEAL )

BOOLEAN
CmpRemoveSubKeyCellNoCellRef(
    PHHIVE          Hive,
    HCELL_INDEX     Parent,
    HCELL_INDEX     Child
    );

VOID 
CmpRaiseSelfHealWarning( 
                        IN PUNICODE_STRING  HiveName
                        );

VOID 
CmpRaiseSelfHealWarningForSystemHives();


//
// Tracking quota leaks helpers
//
#define CM_TRACK_QUOTA_START() //nothing
#define CM_TRACK_QUOTA_STOP()  //nothing

//
// PERF: try inline ascii upcase
//
#define CmUpcaseUnicodeChar(c)          \
( ((c) < 'a') ? (c) : ( ((c) > 'z') ? RtlUpcaseUnicodeChar(c) : ((c) - ('a'-'A')) ) )


//
// Mini NT boot indicator
//
extern BOOLEAN CmpMiniNTBoot;
extern BOOLEAN CmpShareSystemHives;


//
// new per- KCB lock
//
#define CmpLockKCBShared(Kcb)               ExAcquirePushLockShared(&(GET_KCB_HASH_ENTRY_LOCK((Kcb))))  

#define CmpLockKCBExclusive(Kcb)            ExAcquirePushLockExclusive(&(GET_KCB_HASH_ENTRY_LOCK((Kcb))));\
                                            GET_KCB_HASH_ENTRY_OWNER(Kcb) = KeGetCurrentThread()

#define CmpUnlockKCB(Kcb)                   GET_KCB_HASH_ENTRY_OWNER(Kcb) = NULL;\
                                            ExReleasePushLock(&(GET_KCB_HASH_ENTRY_LOCK((Kcb))))

#define CmpIsKCBLockedExclusive(Kcb)        (GET_KCB_HASH_ENTRY_OWNER(Kcb) == KeGetCurrentThread())

#define CmpLockHashEntryShared(ConvKey)     ExAcquirePushLockShared(&(GET_HASH_ENTRY(CmpCacheTable,(ConvKey)).Lock))

#define CmpLockHashEntryExclusive(ConvKey)  ExAcquirePushLockExclusive(&(GET_HASH_ENTRY(CmpCacheTable,(ConvKey)).Lock));\
                                            GET_HASH_ENTRY(CmpCacheTable,(ConvKey)).Owner = KeGetCurrentThread()

#define CmpUnlockHashEntry(ConvKey)         GET_HASH_ENTRY(CmpCacheTable,(ConvKey)).Owner = NULL;\
                                            ExReleasePushLock(&(GET_HASH_ENTRY(CmpCacheTable,(ConvKey)).Lock))

#define CmpLockHashEntryByIndexShared(Index)    ExAcquirePushLockShared(&(CmpCacheTable[(Index)].Lock))

#define CmpLockHashEntryByIndexExclusive(Index) ExAcquirePushLockExclusive(&(CmpCacheTable[(Index)].Lock)); \
                                                CmpCacheTable[(Index)].Owner = KeGetCurrentThread()

BOOLEAN CmpTryToLockHashEntryByIndexExclusive(ULONG   Index);

#define CmpUnlockHashEntryByIndex(Index)        CmpCacheTable[(Index)].Owner = NULL; \
                                                ExReleasePushLock(&(CmpCacheTable[(Index)].Lock))

#define CmpLockNameHashEntryExclusive(ConvKey)  ExAcquirePushLockExclusive(&(GET_HASH_ENTRY(CmpNameCacheTable,(ConvKey)).Lock))
#define CmpUnlockNameHashEntry(ConvKey)         ExReleasePushLock(&(GET_HASH_ENTRY(CmpNameCacheTable,(ConvKey)).Lock))

BOOLEAN CmpTryConvertKCBLockSharedToExclusive(PCM_KEY_CONTROL_BLOCK    KeyControlBlock);

#define ASSERT_KCB_LOCKED(kcb) //nothing
#define ASSERT_HASH_ENTRY_LOCKED(ConvKey) //nothing

#define ASSERT_KCB_LOCKED_EXCLUSIVE(kcb) ASSERT( (CmpIsKCBLockedExclusive(kcb) == TRUE) || (CmpTestRegistryLockExclusive() == TRUE) )
#define ASSERT_HASH_ENTRY_LOCKED_EXCLUSIVE(ConvKey) ASSERT( (GET_HASH_ENTRY(CmpCacheTable,(ConvKey)).Owner == KeGetCurrentThread()) || (CmpTestRegistryLockExclusive() == TRUE) )


#define CmpUpgradeKCBLockToExclusive(kcb)   ASSERT( CmpIsKCBLockedExclusive(kcb) == FALSE ); \
                                            CmpUnlockKCB(kcb);                               \
                                            CmpLockKCBExclusive(kcb)

BOOLEAN
CmpKCBLockForceAcquireAllowed(ULONG Index1,
                              ULONG Index2,
                              ULONG NewIndex);

VOID
CmpLockTwoHashEntriesExclusive(
    ULONG   ConvKey1,
    ULONG   ConvKey2
    );

VOID
CmpLockTwoHashEntriesShared(
    ULONG   ConvKey1,
    ULONG   ConvKey2
    );

VOID
CmpUnlockTwoHashEntries(
    ULONG   ConvKey1,
    ULONG   ConvKey2
    );
//
// DelayDerefKCB engine
//
VOID CmpInitDelayDerefKCBEngine();
VOID CmpRunDownDelayDerefKCBEngine(PCM_KEY_CONTROL_BLOCK    KeyControlBlock,
                                   BOOLEAN                  RegLockHeldEx);
VOID CmpDelayDerefKeyControlBlock( PCM_KEY_CONTROL_BLOCK KeyControlBlock);

#define SECOND_MULT 10*1000*1000        // 10->mic, 1000->mil, 1000->second

#define ASSERT_RESOURCE_NOT_OWNED(Res) ASSERT( (ExIsResourceAcquiredShared(Res) == 0) && (ExIsResourceAcquiredExclusiveLite(Res) == 0) )
#define ASSERT_RESOURCE_OWNED(Res) ASSERT( (ExIsResourceAcquiredShared(Res) != 0) || (ExIsResourceAcquiredExclusiveLite(Res) != 0) )

#define CmpFreeResource(Resource)   ASSERT( Resource );                     \
                                    ASSERT_RESOURCE_NOT_OWNED( Resource );  \
                                    ExDeleteResourceLite( Resource );       \
                                    ExFreePool(Resource)

#define CmpFreeMutex( _mutex_ )     ASSERT( _mutex_ );                      \
                                    ExFreePool(_mutex_)


typedef struct _CM_DELAY_ALLOC {
    LIST_ENTRY              ListEntry;
    PCM_KEY_CONTROL_BLOCK   Kcb;
} CM_DELAY_ALLOC, *PCM_DELAY_ALLOC;

#define CM_PAGED_CODE() PAGED_CODE()

extern  PCMHIVE     CmpMasterHive;
extern  LIST_ENTRY  CmpHiveListHead;   // List of CMHIVEs

#endif //_CMP_
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmname.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmname.c

Abstract:

    Provides routines for handling name comparisons and converting to/from the registry
    compressed name format.

--*/

#include "cmp.h"
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpNameSize)
#pragma alloc_text(PAGE,CmpCopyName)
#pragma alloc_text(PAGE,CmpCompressedNameSize)
#pragma alloc_text(PAGE,CmpCopyCompressedName)
#pragma alloc_text(PAGE,CmpCompareCompressedName)
#pragma alloc_text(PAGE,CmpCompareUnicodeString)
#pragma alloc_text(PAGE,CmpCompareTwoCompressedNames)
#endif


USHORT
CmpNameSize(
    IN PHHIVE Hive,
    IN PUNICODE_STRING Name
    )

/*++

Routine Description:

    Determines the space needed to store a given string in the registry.  May apply
    any relevant compression to compute the length, but the compression used is
    guaranteed to be the same as CmpCopyName.

Arguments:

    Hive - supplies the hive control structure (for version checking)

    Name - Supplies the unicode string to be copied into the registry.

Return Value:

    The number of bytes of storage required to store this name.

--*/

{
    ULONG i;

    if (Hive->Version == 1) {
        return(Name->Length);
    }
    for (i=0;i<Name->Length/sizeof(WCHAR);i++) {
        if ((USHORT)Name->Buffer[i] > (UCHAR)-1) {
            return(Name->Length);
        }
    }
    return(Name->Length / sizeof(WCHAR));

}

USHORT
CmpCopyName(
    IN PHHIVE Hive,
    IN PWCHAR Destination,
    IN PUNICODE_STRING Source
    )

/*++

Routine Description:

    Copies the given unicode name into the registry, applying any relevant compression
    at the same time.

Arguments:

    Hive - supplies the hive control structure (For version checking)

    Destination - Supplies the destination of the given string.

    Source - Supplies the unicode string to copy into the registry.

Return Value:

    Number of bytes of storage copied

--*/

{
    ULONG i;

    if (Hive->Version==1) {
        RtlCopyMemory(Destination,Source->Buffer, Source->Length);
        return(Source->Length);
    }

    for (i=0;i<Source->Length/sizeof(WCHAR);i++) {
        if ((USHORT)Source->Buffer[i] > (UCHAR)-1) {
            RtlCopyMemory(Destination,Source->Buffer, Source->Length);
            return(Source->Length);
        }
        ((PUCHAR)Destination)[i] = (UCHAR)(Source->Buffer[i]);
    }
    return(Source->Length / sizeof(WCHAR));
}


USHORT
CmpCompressedNameSize(
    IN PWCHAR Name,
    IN ULONG Length
    )

/*++

Routine Description:

    Computes the length of the unicode string that the given compressed name
    expands into.

Arguments:

    Name - Supplies the compressed name.

    Length - Supplies the length in bytes of the compressed name

Return Value:

    The number of bytes of storage required to hold the Unicode expanded name.

--*/

{
    UNREFERENCED_PARAMETER (Name);

    return((USHORT)Length*sizeof(WCHAR));
}


VOID
CmpCopyCompressedName(
    IN PWCHAR Destination,
    IN ULONG DestinationLength,
    IN PWCHAR Source,
    IN ULONG SourceLength
    )

/*++

Routine Description:

    Copies a compressed name from the registry and expands it to Unicode.

Arguments:

    Destination - Supplies the destination Unicode buffer

    DestinationLength - Supplies the max length of the destination buffer in bytes

    Source - Supplies the compressed string.

    SourceLength - Supplies the length of the compressed string in bytes

Return Value:

    None.

--*/

{
    ULONG i;
    ULONG Chars;

    Chars = (DestinationLength/sizeof(WCHAR) < SourceLength)
             ? DestinationLength/sizeof(WCHAR)
             : SourceLength;

    for (i=0;i<Chars;i++) {
        Destination[i] = (WCHAR)(((PUCHAR)Source)[i]);
    }
}

LONG
CmpCompareCompressedName(
    IN PUNICODE_STRING  SearchName,
    IN PWCHAR           CompressedName,
    IN ULONG            NameLength,
    IN ULONG            CompareFlags
    )

/*++

Routine Description:

    Compares a compressed registry string to a Unicode string.  Does a case-insensitive
    comparison.

Arguments:

    SearchName - Supplies the Unicode string to be compared

    CompressedName - Supplies the compressed string to be compared

    NameLength - Supplies the length of the compressed string

Return Value:

    0 = SearchName == CompressedName (of Cell)

    < 0 = SearchName < CompressedName

    > 0 = SearchName > CompressedName

--*/

{
    WCHAR *s1;
    UCHAR *s2;
    USHORT n1, n2;
    WCHAR c1;
    WCHAR c2;
    LONG cDiff;

    s1 = SearchName->Buffer;
    s2 = (UCHAR *)CompressedName;
    n1 = (USHORT )(SearchName->Length / sizeof(WCHAR));
    n2 = (USHORT )(NameLength);
    while (n1 && n2) {
        c1 = *s1++;
        c2 = (WCHAR)(*s2++);

        //
        // there is a 2/3 chance they match without doing the uppercase comparison.
        //
        if( c1 != c2 ) {
            c1 = (CompareFlags&CMP_SOURCE_UP)?c1:CmUpcaseUnicodeChar(c1);
            c2 = (CompareFlags&CMP_DEST_UP)?c2:CmUpcaseUnicodeChar(c2);

            if ((cDiff = ((LONG)c1 - (LONG)c2)) != 0) {
                return( cDiff );
            }
        }

        n1--;
        n2--;
    }

    return( n1 - n2 );
}


LONG
CmpCompareUnicodeString(
    IN PUNICODE_STRING  SourceName,
    IN PUNICODE_STRING  DestName,
    IN ULONG            CompareFlags
    )

/*++

Routine Description:

    Compares 2 unicode strings; Case insensitive comparison.
    Uses flags to avoid UpCasing strings again.
    

Arguments:

    SourceName - Supplies the Unicode string to be compared

    DestName - Supplies the compressed string to be compared

    CompareFlags - Supplies the flags to control comparison (see cmp.h)

Return Value:

    0 = SearchName == CompressedName (of Cell)

    < 0 = SearchName < CompressedName

    > 0 = SearchName > CompressedName

--*/

{
    WCHAR *s1, *s2;
    USHORT n1, n2;
    WCHAR c1, c2;
    LONG cDiff;

    s1 = SourceName->Buffer;
    s2 = DestName->Buffer;
    n1 = (USHORT )(SourceName->Length / sizeof(WCHAR));
    n2 = (USHORT )(DestName->Length / sizeof(WCHAR));
    while (n1 && n2) {
        c1 = *s1++;
        c2 = *s2++;

        //
        // there is a 2/3 chance of being the same case
        //
        if( c1 != c2 ){
            c1 = (CompareFlags&CMP_SOURCE_UP)?c1:CmUpcaseUnicodeChar(c1);
            c2 = (CompareFlags&CMP_DEST_UP)?c2:CmUpcaseUnicodeChar(c2);

            if ((cDiff = ((LONG)c1 - (LONG)c2)) != 0) {
                return( cDiff );
            }
        }
        n1--;
        n2--;
    }

    return( n1 - n2 );
}

LONG
CmpCompareTwoCompressedNames(
    IN PWCHAR           CompressedName1,
    IN ULONG            NameLength1,
    IN PWCHAR           CompressedName2,
    IN ULONG            NameLength2
    )

/*++

Routine Description:

    Compares 2 compressed registry strings.  Does a case-insensitive
    comparison.

Arguments:

    CompressedName1 - Supplies the compressed string to be compared

    NameLength2 - Supplies the length of the compressed string

    CompressedName1 - Supplies the compressed string to be compared

    NameLength2 - Supplies the length of the compressed string

Return Value:

    0 = CompressedName1 == CompressedName2 (of Cell)

    < 0 = CompressedName1 < CompressedName2

    > 0 = CompressedName1 > CompressedName2

--*/

{
    UCHAR *s1;
    UCHAR *s2;
    USHORT n1, n2;
    WCHAR c1;
    WCHAR c2;
    LONG cDiff;

    s1 = (UCHAR *)CompressedName1;
    s2 = (UCHAR *)CompressedName2;
    n1 = (USHORT )(NameLength1);
    n2 = (USHORT )(NameLength2);
    while (n1 && n2) {
        c1 = (WCHAR)(*s1++);
        c2 = (WCHAR)(*s2++);

        //
        // there is a 2/3 chance they match without doing the upercpase comparison.
        //
        if( c1 != c2 ) {
            c1 = CmUpcaseUnicodeChar(c1);
            c2 = CmUpcaseUnicodeChar(c2);

            if ((cDiff = ((LONG)c1 - (LONG)c2)) != 0) {
                return( cDiff );
            }
        }

        n1--;
        n2--;
    }

    return( n1 - n2 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmparse2.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmparse2.c

Abstract:

    This module contains parse routines for the configuration manager, particularly
    the registry.

--*/

#include    "cmp.h"

BOOLEAN
CmpOKToFollowLink(  IN PCMHIVE  OrigHive,
                    IN PCMHIVE  DestHive
                    );

ULONG
CmpUnLockKcbArray(IN PULONG LockedKcbs,
                  IN ULONG  Exempt);

VOID
CmpReLockKcbArray(IN PULONG LockedKcbs,
                  IN BOOLEAN LockExclusive);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpDoCreate)
#pragma alloc_text(PAGE,CmpDoCreateChild)
#endif

extern  PCM_KEY_CONTROL_BLOCK CmpKeyControlBlockRoot;


NTSTATUS
CmpDoCreate(
    IN PHHIVE                   Hive,
    IN HCELL_INDEX              Cell,
    IN PACCESS_STATE            AccessState,
    IN PUNICODE_STRING          Name,
    IN KPROCESSOR_MODE          AccessMode,
    IN PCM_PARSE_CONTEXT        Context,
    IN PCM_KEY_CONTROL_BLOCK    ParentKcb,
    IN PCMHIVE                  OriginatingHive OPTIONAL,
    OUT PVOID                   *Object
    )
/*++

Routine Description:

    Performs the first step in the creation of a registry key.  This
    routine checks to make sure the caller has the proper access to
    create a key here, and allocates space for the child in the parent
    cell.  It then calls CmpDoCreateChild to initialize the key and
    create the key object.

    This two phase creation allows us to share the child creation code
    with the creation of link nodes.

Arguments:

    Hive - supplies a pointer to the hive control structure for the hive

    Cell - supplies index of node to create child under.

    AccessState - Running security access state information for operation.

    Name - supplies pointer to a UNICODE string which is the name of
            the child to be created.

    AccessMode - Access mode of the original caller.

    Context - pointer to CM_PARSE_CONTEXT structure passed through
                the object manager

    BaseName - Name of object create is relative to

    KeyName - Relative name (to BaseName)

    Object - The address of a variable to receive the created key object, if
             any.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status;
    PCELL_DATA              pdata;
    HCELL_INDEX             KeyCell;
    ULONG                   ParentType;
    ACCESS_MASK             AdditionalAccess;
    BOOLEAN                 CreateAccess;
    PCM_KEY_BODY            KeyBody;
    PSECURITY_DESCRIPTOR    SecurityDescriptor;
    LARGE_INTEGER           TimeStamp;
    BOOLEAN                 BackupRestore;
    KPROCESSOR_MODE         mode;
    PCM_KEY_NODE            ParentNode;
#if DBG
    ULONG                   ChildConvKey;
#endif
    HV_TRACK_CELL_REF       CellRef = {0};

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpDoCreate:\n"));

    BackupRestore = FALSE;
    if (ARGUMENT_PRESENT(Context)) {

        if (Context->CreateOptions & REG_OPTION_BACKUP_RESTORE) {

            //
            // allow backup operators to create new keys
            //
            BackupRestore = TRUE;
        }

        //
        // Operation is a create, so set Disposition
        //
        Context->Disposition = REG_CREATED_NEW_KEY;
    }

#if DBG
    ChildConvKey = ParentKcb->ConvKey;

    if (Name->Length) {
        ULONG                   Cnt;
        WCHAR                   *Cp;
        Cp = Name->Buffer;
        for (Cnt=0; Cnt<Name->Length; Cnt += sizeof(WCHAR)) {
            //
            // UNICODE_NULL is a valid char !!!
            //
            if (*Cp != OBJ_NAME_PATH_SEPARATOR) {
                //(*Cp != UNICODE_NULL)) {
                ChildConvKey = 37 * ChildConvKey + (ULONG)CmUpcaseUnicodeChar(*Cp);
            }
            ++Cp;
        }
    }
    
    ASSERT_HASH_ENTRY_LOCKED_EXCLUSIVE(ChildConvKey);
    ASSERT_KCB_LOCKED_EXCLUSIVE(ParentKcb);
#endif
    CmpLockHiveFlusherShared((PCMHIVE)Hive);

    if( CmIsKcbReadOnly(ParentKcb) ) {
        //
        // key is protected
        //
        status = STATUS_ACCESS_DENIED;
        goto Exit;
    } 

    //
    // make sure nothing changed in between:
    //  1. ParentKcb is still valid
    //  2. Child was not already added by somebody else
    //
    if( ParentKcb->Delete ) {
        //
        // key was deleted in between
        //
        status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto Exit;
    }

    //
    // KeQuerySystemTime doesn't give us a fine resolution
    // so we have to search if the child has not been created already
    //
    ParentNode = (PCM_KEY_NODE)HvGetCell(Hive, Cell);
    if( ParentNode == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    if( !HvTrackCellRef(&CellRef,Hive,Cell) ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    if( CmpFindSubKeyByName(Hive,ParentNode,Name) != HCELL_NIL ) {
        //
        // key was changed in between; possibly this key was already created ==> reparse
        //
        status = STATUS_REPARSE;
        goto Exit;
    }
    
    if(!CmpOKToFollowLink(OriginatingHive,(PCMHIVE)Hive) ) {
        //
        // about to cross class of trust boundary
        //
        status = STATUS_ACCESS_DENIED;
        goto Exit;
    }

    ASSERT( Cell == ParentKcb->KeyCell );

    ASSERT( ParentKcb->CachedSecurity != NULL );
    SecurityDescriptor = &(ParentKcb->CachedSecurity->Descriptor);

    ParentType = HvGetCellType(Cell);

    if ( (ParentType == Volatile) &&
         ((Context->CreateOptions & REG_OPTION_VOLATILE) == 0) )
    {
        //
        // Trying to create stable child under volatile parent, report error
        //
        status = STATUS_CHILD_MUST_BE_VOLATILE;
        goto Exit;
    }

    if (ParentKcb->Flags &   KEY_SYM_LINK) {
        //
        // Disallow attempts to create anything under a symbolic link
        //
        status = STATUS_ACCESS_DENIED;
        goto Exit;
    }

    AdditionalAccess = (Context->CreateOptions & REG_OPTION_CREATE_LINK) ? KEY_CREATE_LINK : 0;

    if( BackupRestore == TRUE ) {
        //
        // this is a create to support a backup or restore
        // operation, do the special case work
        //
        AccessState->RemainingDesiredAccess = 0;
        AccessState->PreviouslyGrantedAccess = 0;

        mode = KeGetPreviousMode();

        if (SeSinglePrivilegeCheck(SeBackupPrivilege, mode)) {
            AccessState->PreviouslyGrantedAccess |=
                KEY_READ | ACCESS_SYSTEM_SECURITY;
        }

        if (SeSinglePrivilegeCheck(SeRestorePrivilege, mode)) {
            AccessState->PreviouslyGrantedAccess |=
                KEY_WRITE | ACCESS_SYSTEM_SECURITY | WRITE_DAC | WRITE_OWNER;
        }

        if (AccessState->PreviouslyGrantedAccess == 0) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpDoCreate for backup restore: access denied\n"));
            status = STATUS_ACCESS_DENIED;
            //
            // this is not a backup-restore operator; deny the create
            //
            CreateAccess = FALSE;
        } else {
            //
            // allow backup operators to create new keys
            //
            status = STATUS_SUCCESS;
            CreateAccess = TRUE;
        }

    } else {
        //
        // The FullName is not used in the routine CmpCheckCreateAccess,
        //
        CreateAccess = CmpCheckCreateAccess(NULL,
                                            SecurityDescriptor,
                                            AccessState,
                                            AccessMode,
                                            AdditionalAccess,
                                            &status);
    }

    if (CreateAccess) {

        //
        // Security check passed, so we can go ahead and create
        // the sub-key.
        //
        if ( !HvMarkCellDirty(Hive, Cell,FALSE) ) {
            status = STATUS_NO_LOG_SPACE;
            goto Exit;
        }
        //
        // Create and initialize the new sub-key
        //
        status = CmpDoCreateChild( Hive,
                                   Cell,
                                   SecurityDescriptor,
                                   AccessState,
                                   Name,
                                   AccessMode,
                                   Context,
                                   ParentKcb,
                                   0,
                                   &KeyCell,
                                   Object );

        if (NT_SUCCESS(status)) {
            PCM_KEY_NODE KeyNode;

            KeyBody = (PCM_KEY_BODY)(*Object);

            //
            // Child successfully created, add to parent's list.
            //
            if (! CmpAddSubKey(Hive, Cell, KeyCell)) {
                //
                // Unable to add child, so free it
                //
                CmpFreeKeyByCell(Hive, KeyCell, FALSE);
                //
                // release the object created inside CmpDoCreateChild make sure kcb gets kicked out of cache
                //
                KeyBody->KeyControlBlock->Delete = TRUE;
                CmpRemoveKeyControlBlock(KeyBody->KeyControlBlock);
                ObDereferenceObjectDeferDelete(*Object);
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto Exit;
            }

            KeyNode =  (PCM_KEY_NODE)HvGetCell(Hive, Cell);
            if( KeyNode == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // this shouldn't happen as we successfully marked the cell as dirty
                //
                ASSERT( FALSE );
                CmpFreeKeyByCell(Hive, KeyCell, TRUE);
                KeyBody->KeyControlBlock->Delete = TRUE;
                CmpRemoveKeyControlBlock(KeyBody->KeyControlBlock);
                ObDereferenceObjectDeferDelete(*Object);
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto Exit;
            }

            if( !HvTrackCellRef(&CellRef,Hive,Cell) ) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto Exit;
            }

            CmpCleanUpSubKeyInfo (KeyBody->KeyControlBlock->ParentKcb);

            //
            // Update max keyname and class name length fields
            //

            //some sanity asserts first
            ASSERT( KeyBody->KeyControlBlock->ParentKcb->KeyCell == Cell );
            ASSERT( KeyBody->KeyControlBlock->ParentKcb->KeyHive == Hive );
            ASSERT( KeyBody->KeyControlBlock->ParentKcb == ParentKcb );
            ASSERT( KeyBody->KeyControlBlock->ParentKcb->KcbMaxNameLen == KeyNode->MaxNameLen );

            //
            // update the LastWriteTime on both keynode and kcb;
            //
            KeQuerySystemTime(&TimeStamp);
            KeyNode->LastWriteTime = TimeStamp;
            KeyBody->KeyControlBlock->ParentKcb->KcbLastWriteTime = TimeStamp;

            if (KeyNode->MaxNameLen < Name->Length) {
                KeyNode->MaxNameLen = Name->Length;
                // update the kcb cache too
                KeyBody->KeyControlBlock->ParentKcb->KcbMaxNameLen = Name->Length;
            }

            if (KeyNode->MaxClassLen < Context->Class.Length) {
                KeyNode->MaxClassLen = Context->Class.Length;
            }


            if (Context->CreateOptions & REG_OPTION_CREATE_LINK) {
                pdata = HvGetCell(Hive, KeyCell);
                if( pdata == NULL ) {
                    //
                    // we couldn't map the bin containing this cell
                    // this shouldn't happen as we just allocated the cell
                    // (i.e. it must be PINNED into memory at this point)
                    //
                    ASSERT( FALSE );
                    CmpFreeKeyByCell(Hive, KeyCell, TRUE);
                    KeyBody->KeyControlBlock->Delete = TRUE;
                    CmpRemoveKeyControlBlock(KeyBody->KeyControlBlock);
                    ObDereferenceObjectDeferDelete(*Object);
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Exit;
                }

                pdata->u.KeyNode.Flags |= KEY_SYM_LINK;
                KeyBody->KeyControlBlock->Flags = pdata->u.KeyNode.Flags;
                HvReleaseCell(Hive,KeyCell);

            }
		}
    }
Exit:
    HvReleaseFreeCellRefArray(&CellRef);
    CmpUnlockHiveFlusher((PCMHIVE)Hive);
    return status;
}


NTSTATUS
CmpDoCreateChild(
    IN PHHIVE Hive,
    IN HCELL_INDEX ParentCell,
    IN PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    IN PACCESS_STATE AccessState,
    IN PUNICODE_STRING Name,
    IN KPROCESSOR_MODE AccessMode,
    IN PCM_PARSE_CONTEXT Context,
    IN PCM_KEY_CONTROL_BLOCK ParentKcb,
    IN USHORT Flags,
    OUT PHCELL_INDEX KeyCell,
    OUT PVOID *Object
    )

/*++

Routine Description:

    Creates a new sub-key.  This is called by CmpDoCreate to create child
    sub-keys and CmpCreateLinkNode to create root sub-keys.

Arguments:

    Hive - supplies a pointer to the hive control structure for the hive

    ParentCell - supplies cell index of parent cell

    ParentDescriptor - Supplies security descriptor of parent key, for use
           in inheriting ACLs.

    AccessState - Running security access state information for operation.

    Name - Supplies pointer to a UNICODE string which is the name of the
           child to be created.

    AccessMode - Access mode of the original caller.

    Context - Supplies pointer to CM_PARSE_CONTEXT structure passed through
           the object manager.

    BaseName - Name of object create is relative to

    KeyName - Relative name (to BaseName)

    Flags - Supplies any flags to be set in the newly created node

    KeyCell - Receives the cell index of the newly created sub-key, if any.

    Object - Receives a pointer to the created key object, if any.

Return Value:

    STATUS_SUCCESS - sub-key successfully created.  New object is returned in
            Object, and the new cell's cell index is returned in KeyCell.

    !STATUS_SUCCESS - appropriate error message.

--*/

{
    ULONG alloc=0;
    NTSTATUS Status = STATUS_SUCCESS;
    PCM_KEY_BODY KeyBody;
    HCELL_INDEX ClassCell=HCELL_NIL;
    PCM_KEY_NODE KeyNode;
    PCELL_DATA CellData;
    PCM_KEY_CONTROL_BLOCK kcb = NULL;
    ULONG StorageType;
    PSECURITY_DESCRIPTOR NewDescriptor = NULL;
    LARGE_INTEGER systemtime;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpDoCreateChild:\n"));

    //
    // Get allocation type
    //
    StorageType = Stable;

    try {

        if (Context->CreateOptions & REG_OPTION_VOLATILE) {
            StorageType = Volatile;
        }

        //
        // Allocate child cell
        //
        *KeyCell = HvAllocateCell(
                        Hive,
                        CmpHKeyNodeSize(Hive, Name),
                        StorageType,
                        HCELL_NIL
                        );
        if (*KeyCell == HCELL_NIL) {
			Status = STATUS_INSUFFICIENT_RESOURCES;
			leave;
        }
        alloc = 1;
        KeyNode = (PCM_KEY_NODE)HvGetCell(Hive, *KeyCell);
        if( KeyNode == NULL ) {
            //
            // we couldn't map the bin containing this cell
            // this shouldn't happen as we just allocated the cell
            // (i.e. it must be PINNED into memory at this point)
            //
            ASSERT( FALSE );
			Status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }
        // release the cell right here as the view is pinned
        HvReleaseCell(Hive,*KeyCell);

        //
        // Allocate cell for class name
        //
        if (Context->Class.Length > 0) {
            ClassCell = HvAllocateCell(Hive, Context->Class.Length, StorageType,*KeyCell);
            if (ClassCell == HCELL_NIL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
				leave;
            }
        }
        alloc = 2;
        //
        // Allocate the object manager object
        //
        Status = ObCreateObject(AccessMode,
                                CmpKeyObjectType,
                                NULL,
                                AccessMode,
                                NULL,
                                sizeof(CM_KEY_BODY),
                                0,
                                0,
                                Object);

        if (NT_SUCCESS(Status)) {

            KeyBody = (PCM_KEY_BODY)(*Object);

            //
            // We have managed to allocate all of the objects we need to,
            // so initialize them
            //

            //
            // Mark the object as uninitialized (in case we get an error too soon)
            //
            KeyBody->Type = KEY_BODY_TYPE;
            KeyBody->KeyControlBlock = NULL;

            //
            // Fill in the class name
            //
            if (Context->Class.Length > 0) {

                CellData = HvGetCell(Hive, ClassCell);
                if( CellData == NULL ) {
                    //
                    // we couldn't map the bin containing this cell
                    // this shouldn't happen as we just allocated the cell
                    // (i.e. it must be PINNED into memory at this point)
                    //
                    ASSERT( FALSE );
			        Status = STATUS_INSUFFICIENT_RESOURCES;
                    ObDereferenceObject(*Object);
                    leave;
                }

                // release the cell right here as the view is pinned (cell is dirty).
                HvReleaseCell(Hive,ClassCell);

                try {

                    RtlCopyMemory(
                        &(CellData->u.KeyString[0]),
                        Context->Class.Buffer,
                        Context->Class.Length
                        );

                } except(EXCEPTION_EXECUTE_HANDLER) {
                    ObDereferenceObjectDeferDelete(*Object);
                    Status = GetExceptionCode();
                    leave;
                }
            }

            //
            // Fill in the new key itself
            //
            KeyNode->Signature = CM_KEY_NODE_SIGNATURE;
            KeyNode->Flags = Flags;

            KeQuerySystemTime(&systemtime);
            KeyNode->LastWriteTime = systemtime;

            KeyNode->Spare = 0;
            KeyNode->Parent = ParentCell;
            KeyNode->SubKeyCounts[Stable] = 0;
            KeyNode->SubKeyCounts[Volatile] = 0;
            KeyNode->SubKeyLists[Stable] = HCELL_NIL;
            KeyNode->SubKeyLists[Volatile] = HCELL_NIL;
            KeyNode->ValueList.Count = 0;
            KeyNode->ValueList.List = HCELL_NIL;
            KeyNode->Security = HCELL_NIL;
            KeyNode->Class = ClassCell;
            KeyNode->ClassLength = Context->Class.Length;

            KeyNode->MaxValueDataLen = 0;
            KeyNode->MaxNameLen = 0;
            KeyNode->MaxValueNameLen = 0;
            KeyNode->MaxClassLen = 0;

            KeyNode->NameLength = CmpCopyName(Hive,
                                              KeyNode->Name,
                                              Name);
            if (KeyNode->NameLength < Name->Length) {
                KeyNode->Flags |= KEY_COMP_NAME;
            }

            if (Context->CreateOptions & REG_OPTION_PREDEF_HANDLE) {
                KeyNode->ValueList.Count = (ULONG)((ULONG_PTR)Context->PredefinedHandle);
                KeyNode->Flags |= KEY_PREDEF_HANDLE;
            }

            //
            // Create kcb here so all data are filled in.
            //
            // Allocate a key control block
            //
            kcb = CmpCreateKeyControlBlock(Hive, *KeyCell, KeyNode, ParentKcb, CMP_CREATE_KCB_KCB_LOCKED, Name);
            if (kcb == NULL) {
                ObDereferenceObjectDeferDelete(*Object);
                Status = STATUS_INSUFFICIENT_RESOURCES;
                leave;
            }
            ASSERT(kcb->RefCount == 1);
            alloc = 3;

#if DBG
            if( kcb->ExtFlags & CM_KCB_KEY_NON_EXIST ) {
                //
                // we shouldn't fall into this
                //
                ObDereferenceObjectDeferDelete(*Object);
                DbgBreakPoint();
                Status = STATUS_OBJECT_NAME_NOT_FOUND;
                leave;
            }
#endif //DBG
            //
            // Fill in CM specific fields in the object
            //
            KeyBody->Type = KEY_BODY_TYPE;
            KeyBody->KeyControlBlock = kcb;
            KeyBody->NotifyBlock = NULL;
            KeyBody->ProcessID = PsGetCurrentProcessId();
            EnlistKeyBodyWithKCB(KeyBody,CMP_ENLIST_KCB_LOCKED_EXCLUSIVE);
            //
            // Assign a security descriptor to the object.  Note that since
            // registry keys are container objects, and ObAssignSecurity
            // assumes that the only container object in the world is
            // the ObpDirectoryObjectType, we have to call SeAssignSecurity
            // directly in order to get the right inheritance.
            //

            Status = SeAssignSecurity(ParentDescriptor,
                                      AccessState->SecurityDescriptor,
                                      &NewDescriptor,
                                      TRUE,             // container object
                                      &AccessState->SubjectSecurityContext,
                                      &CmpKeyObjectType->TypeInfo.GenericMapping,
                                      CmpKeyObjectType->TypeInfo.PoolType);
            if (NT_SUCCESS(Status)) {
                CmLockHiveSecurityExclusive((PCMHIVE)kcb->KeyHive);
                //
                // force assign to the new kcb, by passing NULL as the trans
                //
                Status = CmpAssignSecurityDescriptorWrapper(*Object,NewDescriptor); 
                CmUnlockHiveSecurity((PCMHIVE)kcb->KeyHive);
            }

            //
            // Since the security descriptor now lives in the hive,
            // free the in-memory copy
            //
            SeDeassignSecurity( &NewDescriptor );

            if (!NT_SUCCESS(Status)) {

                //
                // Note that the dereference will clean up the kcb, so
                // make sure and decrement the allocation count here.
                //
                // Also mark the kcb as deleted so it does not get
                // inappropriately cached.
                //
                kcb->Delete = TRUE;
                CmpRemoveKeyControlBlock(kcb);
                ObDereferenceObjectDeferDelete(*Object);
                alloc = 2;

            } else {
                CmpReportNotify(
                        kcb,
                        kcb->KeyHive,
                        kcb->KeyCell,
                        REG_NOTIFY_CHANGE_NAME
                        );
            }
        }

    } finally {

        if (!NT_SUCCESS(Status)) {

            //
            // Clean up allocations
            //
            switch (alloc) {
            case 3:
                //
                // Mark KCB as deleted so it does not get inadvertently added to
                // the delayed close list. That would have fairly disastrous effects
                // as the KCB points to storage we are about to free.
                //
                kcb->Delete = TRUE;
                CmpRemoveKeyControlBlock(kcb);
                CmpDereferenceKeyControlBlockWithLock(kcb,FALSE);
                // DELIBERATE FALL

            case 2:
                if (Context->Class.Length > 0) {
                    HvFreeCell(Hive, ClassCell);
                }
                // DELIBERATE FALL

            case 1:
                HvFreeCell(Hive, *KeyCell);
                // DELIBERATE FALL
            }
        }
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmnotify.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmnotify.c

Abstract:

    This module contains support for NtNotifyChangeKey.

--*/


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                      //
//   "The" POST BLOCK RULE :                                                                                            //
//                                                                                                                      //
//      To operate on a post block (i.e. add or remove it from a list - notify,thread,slave),                           //
//      you should at least:                                                                                            //
//          1. Hold the registry lock exclusively                                                                       //
//                     OR                                                                                               //
//          2. Hold the registry lock shared and acquire the postblock mutex.                                            //
//                                                                                                                      //
//                                                                                                                      //
//      WARNING!!!                                                                                                      //
//          Failing to do that could arise in obscure registry deadlocks or usage of already freed memory (bugcheck)    //
//                                                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                      //
//  Other important rules to follow:                                                                                    //
//                                                                                                                      //
//      1. We DO NOT dereference objects in CmpPostApc !                                                                //
//      2. We DO NOT dereference objects while walking the notify list!                                                 //
//      3. All operations with Thread PostList are done in CmpPostApc or at APC level. This should avoid two threads    //
//          operating on the same list at the same time                                                                 //
//                                                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include    "cmp.h"

#define CmpCheckPostBlock(a) //nothing

//
// "Back Side" of notify
//

extern  PCMHIVE  CmpMasterHive;

VOID
CmpReportNotifyHelper(
    PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    IN PHHIVE SearchHive,
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell,
    IN ULONG Filter
    );

VOID
CmpCancelSlavePost(
    PCM_POST_BLOCK  PostBlock,
    PLIST_ENTRY     DelayedDeref
    );

VOID
CmpFreeSlavePost(
    PCM_POST_BLOCK  MasterPostBlock
    );

VOID
CmpAddToDelayedDeref(
    PCM_POST_BLOCK  PostBlock,
    PLIST_ENTRY     DelayedDeref
    );

VOID
CmpDelayedDerefKeys(
                    PLIST_ENTRY DelayedDeref
                    );

BOOLEAN
CmpNotifyTriggerCheck(
    IN PCM_NOTIFY_BLOCK NotifyBlock,
    IN PHHIVE Hive,
    IN PCM_KEY_NODE Node
    );

VOID
CmpDummyApc(
    struct _KAPC *Apc,
    PVOID *SystemArgument1,
    PVOID *SystemArgument2
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpReportNotify)
#pragma alloc_text(PAGE,CmpReportNotifyHelper)
#pragma alloc_text(PAGE,CmpPostNotify)
#pragma alloc_text(PAGE,CmpPostApc)
#pragma alloc_text(PAGE,CmpPostApcRunDown)
#pragma alloc_text(PAGE,CmNotifyRunDown)
#pragma alloc_text(PAGE,CmpFlushNotify)
#pragma alloc_text(PAGE,CmpNotifyChangeKey)
#pragma alloc_text(PAGE,CmpCancelSlavePost)
#pragma alloc_text(PAGE,CmpFreeSlavePost)
#pragma alloc_text(PAGE,CmpAddToDelayedDeref)
#pragma alloc_text(PAGE,CmpDelayedDerefKeys)
#pragma alloc_text(PAGE,CmpNotifyTriggerCheck)
#pragma alloc_text(PAGE,CmpDummyApc)
#endif

VOID
CmpDummyApc(
    struct _KAPC *Apc,
    PVOID *SystemArgument1,
    PVOID *SystemArgument2
    )
/*++

Routine Description:

    Dummy routine to prevent user-mode callers to set special kernel apcs

Arguments:

    Apc - pointer to apc object

    SystemArgument1 -  IN: Status value for IoStatusBlock
                      OUT: Ptr to IoStatusBlock (2nd arg to user apc routine)

    SystemArgument2 - Pointer to the PostBlock

Return Value:

    NONE.

--*/
{
    UNREFERENCED_PARAMETER(Apc);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);
}

VOID
CmpReportNotify(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock,
    PHHIVE                  Hive,
    HCELL_INDEX             Cell,
    ULONG                   Filter
    )
/*++

Routine Description:

    This routine is called when a notifiable event occurs. It will
    apply CmpReportNotifyHelper to the hive the event occured in,
    and the master hive if different.

Arguments:

    KeyControlBlock - KCB of the key at which the event occured.
            For create or delete this is the created or deleted key.

    Hive - pointer to hive containing cell of Key at which event occured.

    Cell - cell of Key at which event occured

            (hive and cell correspond with name.)

    Filter - event to be reported

Return Value:

    NONE.

--*/
{
    HCELL_INDEX     CellToRelease = HCELL_NIL;

    CM_PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"CmpReportNotify:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"\tHive:%p Cell:%08lx Filter:%08lx\n", Hive, Cell, Filter));

    //
    // If the operation was create or delete, treat it as a change
    // to the parent.
    //
    if (Filter == REG_NOTIFY_CHANGE_NAME) {
        PCM_KEY_NODE pcell;
        ULONG       flags;

        pcell = (PCM_KEY_NODE)HvGetCell(Hive, Cell);
        if( pcell == NULL ) {
            //
            // we couldn't map the bin containing this cell
            // Bad luck! notifications will be broken.
            //
            return;
        }
        
        CellToRelease = Cell;

        flags = pcell->Flags;
        Cell = pcell->Parent;
        if (flags & KEY_HIVE_ENTRY) {
            ASSERT( CellToRelease != HCELL_NIL );
            HvReleaseCell(Hive,CellToRelease);

            Hive = &(CmpMasterHive->Hive);
            pcell = (PCM_KEY_NODE)HvGetCell(Hive, Cell);
            if( pcell == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // Bad luck! notifications will be broken.
                //
                return;
            }
            CellToRelease = Cell;
        }


        KeyControlBlock = KeyControlBlock->ParentKcb;

        //
        // if we're at an exit/link node, back up the real node
        // that MUST be it's parent.
        //
        if (pcell->Flags & KEY_HIVE_EXIT) {
            Cell = pcell->Parent;
        }

        ASSERT( CellToRelease != HCELL_NIL );
        HvReleaseCell(Hive,CellToRelease);

    }

    //
    // Report to notifies waiting on the event's hive
    //
    CmpReportNotifyHelper(KeyControlBlock, Hive, Hive, Cell, Filter);


    //
    // If containing hive is not the master hive, apply to master hive
    //
    if (Hive != &(CmpMasterHive->Hive)) {
        CmpReportNotifyHelper(KeyControlBlock,
                              &(CmpMasterHive->Hive),
                              Hive,
                              Cell,
                              Filter);
    }

    return;
}

BOOLEAN
CmpNotifyTriggerCheck(
    IN PCM_NOTIFY_BLOCK NotifyBlock,
    IN PHHIVE Hive,
    IN PCM_KEY_NODE Node
    )
/*++

Routine Description:

    Checks if a notify can be triggered

Arguments:

    NotifyBlock - the notify block

    Hive - Supplies hive containing node to match with.

    Node - pointer to key to match with (and check access to)


Return Value:

    TRUE - yes.
    FALSE - no

--*/
{
    PCM_POST_BLOCK PostBlock;
    POST_BLOCK_TYPE NotifyType;

    CM_PAGED_CODE();

    if(IsListEmpty(&(NotifyBlock->PostList)) == FALSE) {

        //
        // check if it is a kernel notify. Look at the first post block
        // to see that. If is a kernel post-block, then all posts in 
        // the list should be kernel notifies
        //
        PostBlock = (PCM_POST_BLOCK)NotifyBlock->PostList.Flink;
        PostBlock = CONTAINING_RECORD(PostBlock,
                                      CM_POST_BLOCK,
                                      NotifyList);

        NotifyType = PostBlockType(PostBlock);

        if( NotifyType == PostAsyncKernel ) {
            // this is a kernel notify; always trigger it
#if DBG
            //
            // DEBUG only code: All post blocks should be of the same type
            // (kernel/user)
            //
            while( PostBlock->NotifyList.Flink != &(NotifyBlock->PostList) ) {
                PostBlock = (PCM_POST_BLOCK)PostBlock->NotifyList.Flink;
                PostBlock = CONTAINING_RECORD(PostBlock,
                                            CM_POST_BLOCK,
                                            NotifyList);
                
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"CmpNotifyTriggerCheck : NotifyBlock = %p\n",NotifyBlock));
                
                ASSERT( PostBlockType(PostBlock) == NotifyType );
            }
#endif
        
            return TRUE;
        }
    }

    //
    // else, check if the caller has the right access
    //
    return CmpCheckNotifyAccess(NotifyBlock,Hive,Node);
}

VOID
CmpReportNotifyHelper(
    PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    IN PHHIVE SearchHive,
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell,
    IN ULONG Filter
    )
/*++

Routine Description:

    Scan the list of active notifies for the specified hive.  For
    any with scope including KeyControlBlock and filter matching
    Filter, and with proper security access, post the notify.

Arguments:

    Name - canonical path name (as in a key control block) of the key
            at which the event occured.  (This is the name for
            reporting purposes.)

    SearchHive - hive to search for matches (which notify list to check)

    Hive - Supplies hive containing node to match with.

    Cell - cell identifying the node in Hive

    Filter - type of event

Return Value:

    NONE.

--*/
{
    PLIST_ENTRY         NotifyPtr;
    PCM_NOTIFY_BLOCK    NotifyBlock;
    PCMHIVE             CmSearchHive;
    KIRQL               OldIrql;
    LIST_ENTRY          DelayedDeref;
    PCM_KEY_NODE        Node;

    CM_PAGED_CODE();

    Node = (PCM_KEY_NODE)HvGetCell(Hive,Cell);
    if( Node == NULL ) {
        //
        // bad luck, we cannot map the view containing this cell
        //
        return;
    }

    CmSearchHive = CONTAINING_RECORD(SearchHive, CMHIVE, Hive);
    CmLockHive(CmSearchHive);

    KeRaiseIrql(APC_LEVEL, &OldIrql);

    NotifyPtr = &(CmSearchHive->NotifyList);

    InitializeListHead(&(DelayedDeref));

    while (NotifyPtr->Flink != NULL) {

        NotifyPtr = NotifyPtr->Flink;

        NotifyBlock = CONTAINING_RECORD(NotifyPtr, CM_NOTIFY_BLOCK, HiveList);
        if (NotifyBlock->KeyControlBlock->TotalLevels > KeyControlBlock->TotalLevels) {
            //
            // list is level sorted, we're past all shorter entries
            //
            break;
        } else {
            PCM_KEY_CONTROL_BLOCK kcb;
            ULONG LevelDiff, l;

            LevelDiff = KeyControlBlock->TotalLevels - NotifyBlock->KeyControlBlock->TotalLevels;

            kcb = KeyControlBlock;
            for (l=0; l<LevelDiff; l++) {
                kcb = kcb->ParentKcb;
            }

            if (kcb == NotifyBlock->KeyControlBlock) {
                //
                // This Notify path is the prefix of this kcb.
                //
                if ((NotifyBlock->Filter & Filter)
                            &&
                    ((NotifyBlock->WatchTree == TRUE) ||
                     (Cell == kcb->KeyCell))
                   )
                {
                    // Filter matches, this event is relevant to this notify
                    //                  AND
                    // Either the notify spans the whole subtree, or the cell
                    // (key) of interest is the one it applies to
                    //
                    // THEREFORE:   The notify is relevant.
                    //

                    //
                    // Correct scope, does caller have access?
                    //
                    if (CmpNotifyTriggerCheck(NotifyBlock,Hive,Node)) {
                        //
                        // Notify block has KEY_NOTIFY access to the node
                        // the event occured at.  It is relevant.  Therefore,
                        // it gets to see this event.  Post and be done.
                        //
                        // we specify that we want no key body dereferenciation 
                        // during the CmpPostNotify call. This is to prevent the 
                        // deletion of the current notify block
                        //
                        CmpPostNotify(
                            NotifyBlock,
                            NULL,
                            Filter,
                            STATUS_NOTIFY_ENUM_DIR,
                            FALSE,
                            &DelayedDeref
#if DBG
                            ,(PCMHIVE)CmSearchHive
#endif 
                            );

                    }  // else no KEY_NOTIFY access to node event occured at
                } // else not relevant (wrong scope, filter, etc)
            }
        }
    }
    
    KeLowerIrql(OldIrql);
    CmUnlockHive(CmSearchHive);

    HvReleaseCell(Hive,Cell);

    //
    // finish the job started in CmpPostNotify (i.e. dereference the keybodies
    // we prevented. this may cause some notifyblocks to be freed
    //
    CmpDelayedDerefKeys(&DelayedDeref);

    return;
}

VOID
CmpPostNotify(
    PCM_NOTIFY_BLOCK    NotifyBlock,
    PUNICODE_STRING     Name OPTIONAL,
    ULONG               Filter,
    NTSTATUS            Status,
    BOOLEAN             PostListLockHeld,
    PLIST_ENTRY         ExternalKeyDeref OPTIONAL
#if DBG
    ,
    PCMHIVE             CmHive
#endif 
    )
/*++

Routine Description:

    Actually report the notify event by signaling events, enqueing
    APCs, and so forth.

    When Status is STATUS_NOTIFY_CLEANUP:

      - if the post block is a slave one, just cancel it.
      - if the post block is a master one, cancel all slave post blocks
        and trigger event on the master block.

Comments:
    
    This routine is using a "delayed dereferencing" technique to prevent
    deadlocks that may appear when a keybody is dereferenced while holding
    the post block lock. As for this, a list with keybodies that have to be 
    dereferenced is constructed while walking the list of postblocks attached
    to the current notify block and the related (slave or master) post blocks.
    The list is built by tricking postblocks. For all postblock about to be 
    freed the PostKeyBody member is added to the local list and then set to NULL
    on the postblock. This will avoid the key body dereferencing in CmpFreePostBlock.
    Instead, after the postblock lock is released, the local list is iterated and 
    the keybodies are dereferenced and the storage for associated CM_POST_KEY_BODY 
    objects is freed.

  
Arguments:

    NotifyBlock - pointer to structure that describes the notify
                  operation.  (Where to post to)

    Name - name of key at which event occurred.

    Filter - nature of event

    Status - completion status to report

    ExternalKeyDeref - this parameter (when not NULL) specifies that the caller doesn't 
                    want any keybody to be dereferenced while in this routine

Return Value:

    NONE.

--*/
{
    PCM_POST_BLOCK      PostBlock;
    PCM_POST_BLOCK      SlavePostBlock;
    LIST_ENTRY          LocalDelayedDeref;
    KIRQL               OldIrql;
    PLIST_ENTRY         DelayedDeref;

    Filter;
    Name;

    CM_PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"CmpPostNotify:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"\tNotifyBlock:%p  ", NotifyBlock));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"\tName = %wZ\n", Name));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"\tFilter:%08lx  Status=%08lx\n", Filter, Status));
    ASSERT_CM_LOCK_OWNED();

    if( ARGUMENT_PRESENT(ExternalKeyDeref) ) {
        //
        // The caller want to do all keybody dereferencing by himself
        //
        DelayedDeref = ExternalKeyDeref;
    } else {
        // local delayed dereferencing (the caller doesn't care!)
        DelayedDeref = &LocalDelayedDeref;
        InitializeListHead(DelayedDeref);
    }

    ASSERT_HIVE_LOCK_OWNED(CmHive);
    //
    // Acquire exclusive access over the postlist(s)
    //
    if( !PostListLockHeld ) {
        LOCK_POST_LIST();
    }

    if (IsListEmpty(&(NotifyBlock->PostList)) == TRUE) {
        //
        // Nothing to post, set a mark and return
        //
        NotifyBlock->NotifyPending = TRUE;
        if( !PostListLockHeld ) {
            UNLOCK_POST_LIST();
        }
        return;
    }
    NotifyBlock->NotifyPending = FALSE;

    //
    // IMPLEMENTATION NOTE:
    //      If we ever want to actually implement the code that returns
    //      names of things that changed, this is the place to add the
    //      name and operation type to the buffer.
    //

    //
    // Pull and post all the entries in the post list
    //
    while (IsListEmpty(&(NotifyBlock->PostList)) == FALSE) {

        //
        // Remove from the notify block list, and enqueue the apc.
        // The apc will remove itself from the thread list
        //
        PostBlock = (PCM_POST_BLOCK)RemoveHeadList(&(NotifyBlock->PostList));
        PostBlock = CONTAINING_RECORD(PostBlock,
                                      CM_POST_BLOCK,
                                      NotifyList);

        // Protect for multiple deletion of the same object
        CmpClearListEntry(&(PostBlock->NotifyList));
        
        if( (Status == STATUS_NOTIFY_CLEANUP) && !IsMasterPostBlock(PostBlock) ) {
            //
            // Cleanup notification (i.e. the key handle was closed or the key was deleted)
            // When the post is a slave one, just cancel it. Canceling means:
            //      1. Removing from the notify PostList (already done at this point - see above)
            //      2. Unchaining from the Master Block CancelPostList
            //      3. Delisting from the thread PostBlockList
            //      4. Actually freeing the memory
            //

            // Use Cmp variant to protect for multiple deletion of the same object
            CmpRemoveEntryList(&(PostBlock->CancelPostList));
            //
            // FIX 289351
            //
            // Use Cmp variant to protect for multiple deletion of the same object
            KeRaiseIrql(APC_LEVEL, &OldIrql);
            CmpRemoveEntryList(&(PostBlock->ThreadList));
            KeLowerIrql(OldIrql);

#if DBG
            if(PostBlock->TraceIntoDebugger) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"[CM]\tCmpPostNotify: PostBlock:%p is a slave block,and notify is CLEANUP==> just cleanning\n", PostBlock));
            }
#endif
            if( PostBlock->NotifyType != PostSynchronous ) {

                // add to the deref list and clean the post block
                CmpAddToDelayedDeref(PostBlock,DelayedDeref);

                //
                // Front-end routine will do self cleanup for synchronous notifications
                CmpFreePostBlock(PostBlock);
            }

            continue; //try the next one
        }

        //
        // Simulate that this block is the master one, so we can free the others
        // Doing that will ensure the right memory deallocation when the master
        // (from now on this block) will be freed.
        //
        if(!IsMasterPostBlock(PostBlock)) {
            //
            // this is not the master block, we have some more work to do
            //
            SlavePostBlock = PostBlock;
            do {
                SlavePostBlock = (PCM_POST_BLOCK)SlavePostBlock->CancelPostList.Flink;
                SlavePostBlock = CONTAINING_RECORD(SlavePostBlock,
                                                   CM_POST_BLOCK,
                                                   CancelPostList);
                //
                // reset the "master flag" if set
                //
                ClearMasterPostBlockFlag(SlavePostBlock);
            } while (SlavePostBlock != PostBlock);

            //
            // Make this post block the master one
            //
            SetMasterPostBlockFlag(PostBlock);
        }

#if DBG
        if(PostBlock->TraceIntoDebugger) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"[CM]\tCmpPostNotify: Master block switched to :%p\n", PostBlock));
        }
#endif

        //
        // Cancel all slave Post requests that may be linked to self
        //

        if( PostBlockType(PostBlock) != PostSynchronous ) {
            //
            // Front-end routine will do self cleanup for synchronous notifications
            CmpCancelSlavePost(PostBlock,DelayedDeref);
            //
            // Do the same for the master (in case master and slave got switched)
            // This will avoid dereferencing the keybody from CmpPostApc
            CmpAddToDelayedDeref(PostBlock,DelayedDeref);
        }

        switch (PostBlockType(PostBlock)) {
            case PostSynchronous:
                //
                // This is a SYNC notify call.  There will be no user event,
                // and no user apc routine.  Quick exit here, just fill in
                // the Status and poke the event.
                //
                // Holder of the systemevent will wake up and free the
                // postblock.  If we free it here, we get a race & bugcheck.
                //
                // Set the flink to NULL so that the front side can tell this
                // has been removed if its wait aborts.
                //
                PostBlock->NotifyList.Flink = NULL;
                PostBlock->u->Sync.Status = Status;
                KeSetEvent(PostBlock->u->Sync.SystemEvent,
                           0,
                           FALSE);
                break;

            case PostAsyncUser:
                //
                // Insert the APC into the queue
                //
                KeInsertQueueApc(PostBlock->u->AsyncUser.Apc,
                                 (PVOID)ULongToPtr(Status),
                                 (PVOID)PostBlock,
                                 0);
                break;

            case PostAsyncKernel:
                //
                // Queue the work item, then free the post block.
                //
                if (PostBlock->u->AsyncKernel.WorkItem != NULL) {
                    ExQueueWorkItem(PostBlock->u->AsyncKernel.WorkItem,
                                    PostBlock->u->AsyncKernel.QueueType);
                }

                //
                // Signal Event if present, and deref it.
                //
                if (PostBlock->u->AsyncKernel.Event != NULL) {
                    KeSetEvent(PostBlock->u->AsyncKernel.Event,
                               0,
                               FALSE);
                    ObDereferenceObject(PostBlock->u->AsyncKernel.Event);
                }

				//
				// Multiple async kernel notification are not allowed
				//
				ASSERT(IsListEmpty(&(PostBlock->CancelPostList)) == TRUE);
				//
                // remove the post block from the thread list, and free it
                //
                // Use Cmp variant to protect for multiple deletion of the same object
                KeRaiseIrql(APC_LEVEL, &OldIrql);
                CmpRemoveEntryList(&(PostBlock->ThreadList));
                KeLowerIrql(OldIrql);
                
                // it was already added to delayed deref.
                CmpFreePostBlock(PostBlock);
                break;
        }
    }

    if( !PostListLockHeld ) {
        UNLOCK_POST_LIST();
    }

    //
    // At this point we have a list of keybody elements that have to be dereferenciated
    // and the associated storage for the covering objects freed. The keybodies in this 
    // list have only one reference count on them (they were referenced only in 
    // NtNotifyChangeMultipleKeys), dereferencing them here should free the object
    //

    if( ARGUMENT_PRESENT(ExternalKeyDeref) ) {
        // do nothing; the caller wants to handle the dereferenciation by himself!
    } else {
        // dereferenciate all keybodies in the delayed list
        CmpDelayedDerefKeys(DelayedDeref);
    }
   
    return;
}


VOID
CmpPostApc(
    struct _KAPC *Apc,
    PKNORMAL_ROUTINE *NormalRoutine,
    PVOID *NormalContext,
    PVOID *SystemArgument1,
    PVOID *SystemArgument2
    )
/*++

Routine Description:

    This is the kernel apc routine.  It is called for all notifies,
    regardless of what form of notification the caller requested.

    We compute the postblock address from the apc object address.
    IoStatus is set.  SystemEvent and UserEvent will be signaled
    as appropriate.  If the user requested an APC, then NormalRoutine
    will be set at entry and executed when we exit.  The PostBlock
    is freed here.

Arguments:

    Apc - pointer to apc object

    NormalRoutine - Will be called when we return

    NormalContext - will be 1st argument to normal routine, ApcContext
                    passed in when NtNotifyChangeKey was called

    SystemArgument1 -  IN: Status value for IoStatusBlock
                      OUT: Ptr to IoStatusBlock (2nd arg to user apc routine)

    SystemArgument2 - Pointer to the PostBlock

Return Value:

    NONE.

--*/
{
    PCM_POST_BLOCK  PostBlock;

    CM_PAGED_CODE();

#if !DBG
    UNREFERENCED_PARAMETER (Apc);
    UNREFERENCED_PARAMETER (NormalRoutine);
    UNREFERENCED_PARAMETER (NormalContext);
#endif

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"CmpPostApc:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"\tApc:%p ", Apc));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"NormalRoutine:%p\n", NormalRoutine));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"\tNormalContext:%08lx", NormalContext));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"\tSystemArgument1=IoStatusBlock:%p\n", SystemArgument1));


    PostBlock = *(PCM_POST_BLOCK *)SystemArgument2;

#if DBG
    if(PostBlock->TraceIntoDebugger) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"[CM]CmpPostApc: PostBlock:%p\n", PostBlock));
    }
#endif

    
    //
    // Fill in IO Status Block
    //
    // IMPLEMENTATION NOTE:
    //      If we ever want to actually implement the code that returns
    //      names of things that changed, this is the place to copy the
    //      buffer into the caller's buffer.
    //
    //  Win64 only: Use a 32bit IO_STATUS_BLOCK if the caller is 32bit.

    try {
        CmpCheckIoStatusPointer(PostBlock->u->AsyncUser);
        CmpSetIoStatus(PostBlock->u->AsyncUser.IoStatusBlock, 
                       *((ULONG *)SystemArgument1), 
                       0L,
                       PsGetCurrentProcess()->Wow64Process != NULL);
        CmpCheckIoStatusPointer(PostBlock->u->AsyncUser);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        NOTHING;
    }
    *SystemArgument1 = PostBlock->u->AsyncUser.IoStatusBlock;
    CmpCheckIoStatusPointer(PostBlock->u->AsyncUser);

    //
    // This is an Async notify, do all work here, including
    // cleaning up the post block
    //

    //
    // Signal UserEvent if present, and deref it.
    //
    if (PostBlock->u->AsyncUser.UserEvent != NULL) {
        KeSetEvent(PostBlock->u->AsyncUser.UserEvent,
                   0,
                   FALSE);
        ObDereferenceObject(PostBlock->u->AsyncUser.UserEvent);
    }

    //
    // remove the post block from the thread list, and free it
    //
    // Use Cmp variant to protect for multiple deletion of the same object
    CmpRemoveEntryList(&(PostBlock->ThreadList));

    // debug only checks
    CmpCheckPostBlock(PostBlock);
    //
	// Free the slave post block to avoid "dangling" postblocks
	//
	CmpFreeSlavePost(PostBlock);
    //
	// free this post block
	// 
	CmpFreePostBlock(PostBlock);

    return;
}


VOID
CmpPostApcRunDown(
    struct _KAPC *Apc
    )
/*++

Routine Description:

    This routine is called to clear away apcs in the apc queue
    of a thread that has been terminated.

    Since the apc is in the apc queue, we know that it is NOT in
    any NotifyBlock's post list.  It is, however, in the threads's
    PostBlockList.

    Therefore, poke any user events so that waiters are not stuck,
    drop the references so the event can be cleaned up, delist the
    PostBlock and free it.

    Since we are cleaning up the thread, SystemEvents are not interesting.

    Since the apc is in the apc queue, we know that if there were any other
    notifications related to this one, they are cleaned up by the
    CmPostNotify routine

Arguments:

    Apc - pointer to apc object

Return Value:

    NONE.

--*/
{
    PCM_POST_BLOCK  PostBlock;
    KIRQL           OldIrql;

    CM_PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"CmpApcRunDown:"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"\tApc:%p \n", Apc));

    KeRaiseIrql(APC_LEVEL, &OldIrql);

    PostBlock = (PCM_POST_BLOCK)Apc->SystemArgument2;

#if DBG
    if(PostBlock->TraceIntoDebugger) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"[CM]CmpPostApcRunDown: PostBlock:%p\n", PostBlock));
    }
#endif

    //
    // report status and wake up any threads that might otherwise
    // be stuck.  also drop any event references we hold
    //
    //  Win64 only: Use a 32bit IO_STATUS_BLOCK if the caller is 32bit. 

    try {
        CmpCheckIoStatusPointer(PostBlock->u->AsyncUser);
        CmpSetIoStatus(PostBlock->u->AsyncUser.IoStatusBlock, 
                       STATUS_NOTIFY_CLEANUP, 
                       0L, 
                       PsGetCurrentProcess()->Wow64Process != NULL);
        CmpCheckIoStatusPointer(PostBlock->u->AsyncUser);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        NOTHING;
    }

    if (PostBlock->u->AsyncUser.UserEvent != NULL) {
        KeSetEvent(
            PostBlock->u->AsyncUser.UserEvent,
            0,
            FALSE
            );
        ObDereferenceObject(PostBlock->u->AsyncUser.UserEvent);
    }

    //
    // delist the post block
    //
    // Use Cmp variant to protect for multiple deletion of the same object
    CmpRemoveEntryList(&(PostBlock->ThreadList));

	//
	// Free the slave post block to avoid "dangling" postblocks
	//
	CmpFreeSlavePost(PostBlock);
    //
    // Free the post block.  Use Ex call because PostBlocks are NOT
    // part of the global registry pool computation, but are instead
    // part of NonPagedPool with Quota.
    //
    CmpFreePostBlock(PostBlock);

    KeLowerIrql(OldIrql);

    return;
}


//
// Cleanup procedure
//
VOID
CmNotifyRunDown(
    __in PETHREAD    Thread
    )
/*++

Routine Description:

    This routine is called from PspExitThread to clean up any pending
    notify requests.

    It will traverse the thread's PostBlockList, for each PostBlock it
    finds, it will:

        1.  Remove it from the relevant NotifyBlock.  This requires
            that we hold the Registry mutex.

        2.  Remove it from the thread's PostBlockList.  This requires
            that we run at APC level.

        3.  By the time this procedure runs, user apcs are not interesting
            and neither are SystemEvents, so do not bother processing
            them.

            UserEvents and IoStatusBlocks could be referred to by other
            threads in the same process, or even a different process,
            so process them so those threads know what happened, use
            status code of STATUS_NOTIFY_CLEANUP.

            If the notify is a master one, cancel all slave notifications.
            Else only remove this notification from the master CancelPortList

        4.  Free the post block.

Arguments:

    Thread - pointer to the executive thread object for the thread
             we wish to do rundown on.

Return Value:

    NONE.

--*/
{
    PCM_POST_BLOCK      PostBlock;
    KIRQL               OldIrql;

    CM_PAGED_CODE();

    if ( IsListEmpty(&(Thread->PostBlockList)) == TRUE ) {
        return;
    }

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"CmNotifyRunDown: ethread:%p\n", Thread));

    CmpLockRegistry();
	//
    // Acquire exclusive access over the postlist(s)
    //
    LOCK_POST_LIST(); 

    KeRaiseIrql(APC_LEVEL, &OldIrql);
    while (IsListEmpty(&(Thread->PostBlockList)) == FALSE) {

        //
        // remove from thread list
        //
        PostBlock = (PCM_POST_BLOCK)RemoveHeadList(&(Thread->PostBlockList));
        PostBlock = CONTAINING_RECORD(
                        PostBlock,
                        CM_POST_BLOCK,
                        ThreadList
                        );

        // Protect for multiple deletion of the same object
        CmpClearListEntry(&(PostBlock->ThreadList));

#if DBG
        if(PostBlock->TraceIntoDebugger) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"[CM]CmpNotifyRunDown: ethread:%p, PostBlock:%p\n", Thread,PostBlock));
        }
#endif

        //
        // Canceling a master notification implies canceling all the slave notifications
        // from the CancelPostList
        //
        if(IsMasterPostBlock(PostBlock)) {

#if DBG
            if(PostBlock->TraceIntoDebugger) {
                    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"[CM]\tCmpNotifyRunDown: PostBlock:%p is a master block\n", PostBlock));
            }
#endif
            //
            // at this point, CmpReportNotify and friends will no longer
            // attempt to post this post block.
            //
            if (PostBlockType(PostBlock) == PostAsyncUser) {
                //
                // report status and wake up any threads that might otherwise
                // be stuck.  also drop any event references we hold
                //
                //  Win64 only: Use a 32bit IO_STATUS_BLOCK if the caller is 32bit. 

                try {
                    CmpCheckIoStatusPointer(PostBlock->u->AsyncUser);
                    CmpSetIoStatus(PostBlock->u->AsyncUser.IoStatusBlock, 
                                   STATUS_NOTIFY_CLEANUP, 
                                   0L, 
                                   PsGetCurrentProcess()->Wow64Process != NULL);
                    CmpCheckIoStatusPointer(PostBlock->u->AsyncUser);
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!CmNotifyRundown: code:%08lx\n", GetExceptionCode()));
                    NOTHING;
                }

                if (PostBlock->u->AsyncUser.UserEvent != NULL) {
                    KeSetEvent(
                        PostBlock->u->AsyncUser.UserEvent,
                        0,
                        FALSE
                        );
                    ObDereferenceObject(PostBlock->u->AsyncUser.UserEvent);
                }

                //
                // Cancel the APC. Otherwise the rundown routine will also
                // free the post block if the APC happens to be queued at
                // this point. If the APC is queued, then the post block has
                // already been removed from the notify list, so don't remove
                // it again.
                //
                if (!KeRemoveQueueApc(PostBlock->u->AsyncUser.Apc)) {

                    //
                    // remove from notify block's list
                    //
                    // Use Cmp variant to protect for multiple deletion of the same object
                    CmpRemoveEntryList(&(PostBlock->NotifyList));
                    //
                    // Cancel all slave Post requests that may be linked to self
                    //
                    CmpCancelSlavePost(PostBlock,NULL); // we do not want delayed deref
                } else {
                    //
                    // if we are here, the apc was in the apc queue, i.e. both master and slave 
                    // post blocks were removed from the notify list. nothing more to do.
                    //
                    ASSERT( CmpIsListEmpty(&(PostBlock->NotifyList)) );
                    NOTHING;
                }
            } else {
                //
                // remove from notify block's list
                //
                // Use Cmp variant to protect for multiple deletion of the same object
                CmpRemoveEntryList(&(PostBlock->NotifyList));
                //
                // Cancel all slave Post requests that may be linked to self
                //
                CmpCancelSlavePost(PostBlock,NULL); // we do not want delayed deref
            }

			//
			// Free the slave Post blocks too
			//
			CmpFreeSlavePost(PostBlock);
            //
            // Free the post block.  Use Ex call because PostBlocks are NOT
            // part of the global registry pool computation, but are instead
            // part of NonPagedPool with Quota.
            //
            CmpFreePostBlock(PostBlock);
        } else {

#if DBG
            if(PostBlock->TraceIntoDebugger) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"[CM]\tCmpNotifyRunDown: PostBlock:%p is a slave block\n", PostBlock));
            }
#endif
            //
            // master should always be ahead of slaves; if we got here, we switched master
            // and slaves back in CmpPostNotify; Show some respect and add slave at the end;
            // master will control the cleanup
            //
            ASSERT( CmpIsListEmpty(&(PostBlock->CancelPostList)) == FALSE );
            ASSERT( IsListEmpty(&(Thread->PostBlockList)) == FALSE );
                       
            InsertTailList(
                &(Thread->PostBlockList),
                &(PostBlock->ThreadList)
                );
        }
    }

    KeLowerIrql(OldIrql);

    UNLOCK_POST_LIST();

    CmpUnlockRegistry();
    return;
}


VOID
CmpFlushNotify(
    PCM_KEY_BODY        KeyBody,
    BOOLEAN             LockHeld
    )
/*++

Routine Description:

    Clean up notifyblock when a handle is closed or the key it refers
    to is deleted.

Arguments:

    KeyBody - supplies pointer to key object body for handle we
                are cleaning up.

Return Value:

    NONE

--*/
{
    PCM_NOTIFY_BLOCK    NotifyBlock;
    PCMHIVE             Hive;

    CM_PAGED_CODE();
    ASSERT_CM_LOCK_OWNED();

    if (KeyBody->NotifyBlock == NULL) {
        return;
    }

    //
    // Lock the hive exclusively to prevent multiple threads from whacking
    // on the list.
    //
    Hive = CONTAINING_RECORD(KeyBody->KeyControlBlock->KeyHive,
                             CMHIVE,
                             Hive);
    if( !LockHeld ) {
        CmLockHive(Hive);
    } else {
        //
        // we should be holding the reglock exclusive
        //
        ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
    }
    //
    // Reread the notify block in case it has already been freed.
    //
    NotifyBlock = KeyBody->NotifyBlock;
    if (NotifyBlock == NULL) {
        if( !LockHeld ) {
            CmUnlockHive(Hive); 
        }
        return;
    }

    //
    // Clean up all PostBlocks waiting on the NotifyBlock
    //
    if (IsListEmpty(&(NotifyBlock->PostList)) == FALSE) {
        CmpPostNotify(
            NotifyBlock,
            NULL,
            0,
            STATUS_NOTIFY_CLEANUP,
            FALSE,
            NULL
#if DBG
            ,Hive
#endif
            );
    }

    //
    // Reread the notify block in case it has already been freed.
    //
    NotifyBlock = KeyBody->NotifyBlock;
    if (NotifyBlock == NULL) {
        if( !LockHeld ) {
            CmUnlockHive(Hive); 
        }
        return;
    }

    //
    // Release the subject context
    //
    SeReleaseSubjectContext(&NotifyBlock->SubjectContext);

    //
    // IMPLEMENTATION NOTE:
    //      If we ever do code to report names and types of events,
    //      this is the place to free the buffer.
    //

    //
    // Remove the NotifyBlock from the hive chain
    //
    NotifyBlock->HiveList.Blink->Flink = NotifyBlock->HiveList.Flink;
    if (NotifyBlock->HiveList.Flink != NULL) {
        NotifyBlock->HiveList.Flink->Blink = NotifyBlock->HiveList.Blink;
    }

    // Protect for multiple deletion of the same object
    CmpClearListEntry(&(NotifyBlock->HiveList));

    KeyBody->NotifyBlock = NULL;

    if( !LockHeld ) {
        CmUnlockHive(Hive); 
    }

    //
    // Free the block, clean up the KeyBody
    //
    ExFreePool(NotifyBlock);
    return;
}


//
// "Front Side" of notify.  See also Ntapi.c: ntnotifychangekey
//
NTSTATUS
CmpNotifyChangeKey(
    IN PCM_KEY_BODY     KeyBody,
    IN PCM_POST_BLOCK   PostBlock,
    IN ULONG            CompletionFilter,
    IN BOOLEAN          WatchTree,
    IN PVOID            Buffer,
    IN ULONG            BufferSize,
    IN PCM_POST_BLOCK   MasterPostBlock
    )
/*++

Routine Description:

    This routine sets up the NotifyBlock, and attaches the PostBlock
    to it.  When it returns, the Notify is visible to the system,
    and will receive event reports.

    If there is already an event report pending, then the notify
    call will be satisfied at once.

Arguments:

    KeyBody - pointer to key object that handle refers to, allows access
              to key control block, notify block, etc.

    PostBlock - pointer to structure that describes how/where the caller
                is to be notified.

                WARNING:    PostBlock must come from Pool, THIS routine
                            will keep it, back side will free it.  This
                            routine WILL free it in case of error.

    CompletionFilter - what types of events the caller wants to see

    WatchTree - TRUE to watch whole subtree, FALSE to watch only immediate
                key the notify is applied to

    Buffer - pointer to area to receive notify data

    BufferSize - size of buffer, also size user would like to allocate
                 for internal buffer

    MasterPostBlock - the post block of the master notification. Used to
                      insert the PostBlock into the CancelPostList list.

OBS:
    POST_BLOCK_LIST is assumed hold on call.

Return Value:

    Status.

--*/
{
    PCM_NOTIFY_BLOCK    NotifyBlock;
    PCM_NOTIFY_BLOCK    node;
    PLIST_ENTRY         ptr;
    PCMHIVE             Hive;
    KIRQL               OldIrql;

    CM_PAGED_CODE();

    UNREFERENCED_PARAMETER (Buffer);
    UNREFERENCED_PARAMETER (BufferSize);

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"CmpNotifyChangeKey:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"\tKeyBody:%p PostBlock:%p ", KeyBody, PostBlock));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"Filter:%08lx WatchTree:%08lx\n", CompletionFilter, WatchTree));

    //
    // The registry lock should be acquired exclusively by the caller !!!
    //
    ASSERT_CM_LOCK_OWNED();

    if (KeyBody->KeyControlBlock->Delete) {
        ASSERT( KeyBody->NotifyBlock == NULL );
        CmpFreePostBlock(PostBlock);
        return STATUS_KEY_DELETED;
    }

#if DBG
    if(PostBlock->TraceIntoDebugger) {
        WCHAR                   *NameBuffer = NULL;
        UNICODE_STRING          KeyName;
        PCM_KEY_NODE            TempNode;

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"[CM]CmpNotifyChangeKey: PostBlock:%p\tMasterBlock: %p\n", PostBlock,MasterPostBlock));
        
        TempNode = (PCM_KEY_NODE)HvGetCell(KeyBody->KeyControlBlock->KeyHive, KeyBody->KeyControlBlock->KeyCell);
        if( TempNode != NULL ) {
            NameBuffer = ExAllocatePool(PagedPool, REG_MAX_KEY_NAME_LENGTH);
            if(NameBuffer&& (KeyBody->KeyControlBlock->KeyCell != HCELL_NIL)) {
               CmpInitializeKeyNameString(TempNode,&KeyName,NameBuffer);
               CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"\t[CM]CmpNotifyChangeKey: Key = %.*S\n",KeyName.Length / sizeof(WCHAR),KeyName.Buffer));
               ExFreePool(NameBuffer);
            }
            HvReleaseCell(KeyBody->KeyControlBlock->KeyHive, KeyBody->KeyControlBlock->KeyCell);
        }
    }
#endif

    Hive = (PCMHIVE)KeyBody->KeyControlBlock->KeyHive;
    Hive = CONTAINING_RECORD(Hive, CMHIVE, Hive);
    NotifyBlock = KeyBody->NotifyBlock;

    if (NotifyBlock == NULL) {
        //
        // Set up new notify session
        //
        NotifyBlock = ExAllocatePoolWithQuotaTag(PagedPool|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,sizeof(CM_NOTIFY_BLOCK),CM_NOTIFYBLOCK_TAG);
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_POOL,"**CmpNotifyChangeKey: allocate:%08lx, ", sizeof(CM_NOTIFY_BLOCK)));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_POOL,"type:%d, at:%p\n", PagedPool, NotifyBlock));

        if (NotifyBlock == NULL) {
            CmpFreePostBlock(PostBlock);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        NotifyBlock->KeyControlBlock = KeyBody->KeyControlBlock;
        NotifyBlock->Filter = CompletionFilter;
        NotifyBlock->WatchTree = WatchTree;
        NotifyBlock->NotifyPending = FALSE;
        InitializeListHead(&(NotifyBlock->PostList));
        KeyBody->NotifyBlock = NotifyBlock;
        NotifyBlock->KeyBody = KeyBody;
        ASSERT( KeyBody->KeyControlBlock->Delete == FALSE );

#if DBG
        if(PostBlock->TraceIntoDebugger) {
            WCHAR                   *NameBuffer = NULL;
            UNICODE_STRING          KeyName;
            PCM_KEY_NODE            TempNode;

            TempNode = (PCM_KEY_NODE)HvGetCell(KeyBody->KeyControlBlock->KeyHive, KeyBody->KeyControlBlock->KeyCell);
            if( TempNode != NULL ) {
                NameBuffer = ExAllocatePool(PagedPool, REG_MAX_KEY_NAME_LENGTH);
                if(NameBuffer) {
                   CmpInitializeKeyNameString(TempNode,&KeyName,NameBuffer);
                   CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"[CM]\tCmpNotifyChangeKey: New NotifyBlock at:%p was allocated for Key = %.*S\n",NotifyBlock,KeyName.Length / sizeof(WCHAR),KeyName.Buffer));
                   ExFreePool(NameBuffer);
                }
                HvReleaseCell(KeyBody->KeyControlBlock->KeyHive, KeyBody->KeyControlBlock->KeyCell);
            }
        }
#endif

        //
        // IMPLEMENTATION NOTE:
        //      If we ever want to actually return the buffers full of
        //      data, the buffer should be allocated and its address
        //      stored in the notify block here.
        //

        //
        // Capture the subject context so we can do checking once the
        // notify goes off.
        //
        SeCaptureSubjectContext(&NotifyBlock->SubjectContext);

        //
        // Attach notify block to hive in properly sorted order
        //
        ptr = &(Hive->NotifyList);
        while (TRUE) {
            if (ptr->Flink == NULL) {
                //
                // End of list, add self after ptr.
                //
                ptr->Flink = &(NotifyBlock->HiveList);
                NotifyBlock->HiveList.Flink = NULL;
                NotifyBlock->HiveList.Blink = ptr;
                break;
            }

            ptr = ptr->Flink;

            node = CONTAINING_RECORD(ptr, CM_NOTIFY_BLOCK, HiveList);

            if (node->KeyControlBlock->TotalLevels >
                KeyBody->KeyControlBlock->TotalLevels)
            {
                //
                // ptr -> notify with longer name than us, insert in FRONT
                //
                NotifyBlock->HiveList.Flink = ptr;
                ptr->Blink->Flink = &(NotifyBlock->HiveList);
                NotifyBlock->HiveList.Blink = ptr->Blink;
                ptr->Blink = &(NotifyBlock->HiveList);
                break;
            }
        }
    }


    //
    // Add post block to front of notify block's list, and add it to thread list.
    //
    InsertHeadList(
        &(NotifyBlock->PostList),
        &(PostBlock->NotifyList)
        );



    if( IsMasterPostBlock(PostBlock) ) {
        //
        // Protect against outrageous calls
        //
        ASSERT(PostBlock == MasterPostBlock);

        //
        // When the notification is a master one, initialize the CancelPostList list
        //
        InitializeListHead(&(PostBlock->CancelPostList));
    } else {
        //
        // Add PostBlock at the end of the CancelPostList list from the master post
        //
        InsertTailList(
            &(MasterPostBlock->CancelPostList),
            &(PostBlock->CancelPostList)
            );
    }


    KeRaiseIrql(APC_LEVEL, &OldIrql);
    //
    // show some respect and add masters to the front and slaves to the tail
    //
    if( IsMasterPostBlock(PostBlock) ) {
        InsertHeadList(
            &(PsGetCurrentThread()->PostBlockList),
            &(PostBlock->ThreadList)
            );
    } else {
        InsertTailList(
            &(PsGetCurrentThread()->PostBlockList),
            &(PostBlock->ThreadList)
            );
    }

#if DBG
    if(PostBlock->TraceIntoDebugger) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"[CM]\tCmpNotifyChangeKey: Attaching the post:%p\t to thread:%p\n",PostBlock,PsGetCurrentThread()));
    }
#endif

    KeLowerIrql(OldIrql);

    //
    // If there is a notify pending (will not be if we just created
    // the notify block) then post it at once.  Note that this call
    // ALWAYS returns STATUS_PENDING unless it fails.  Caller must
    // ALWAYS look in IoStatusBlock to see what happened.
    //
    if (NotifyBlock->NotifyPending == TRUE) {
        CmpPostNotify(
            NotifyBlock,
            NULL,
            0,
            STATUS_NOTIFY_ENUM_DIR,
            TRUE,
            NULL
#if DBG
            ,Hive
#endif
            );

        //
        // return STATUS_SUCCESS to signal to the caller the the notify already been triggered
        //
        return STATUS_SUCCESS;
    }

    //
    // return STATUS_PENDING to signal to the caller the the notify has not been triggered yet
    //
    return STATUS_PENDING;
}

VOID
CmpFreeSlavePost(
    PCM_POST_BLOCK  MasterPostBlock
    )
/*++

Routine Description:

	Free the slave post block related to this master post block

Arguments:

    MasterPostBlock - pointer to structure that describes the post requests.
                It should be a master post!!
Return Value:

    NONE.

--*/
{
    PCM_POST_BLOCK  SlavePostBlock;

    CM_PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"CmpCancelSlavePost:\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"MasterPostBlock:%p\n", MasterPostBlock));

    ASSERT(IsMasterPostBlock(MasterPostBlock));

#if DBG
    if(MasterPostBlock->TraceIntoDebugger) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"[CM]CmCancelSlavePost: MasterPostBlock:%p\n", MasterPostBlock));
    }
#endif

    if (IsListEmpty(&(MasterPostBlock->CancelPostList)) == TRUE) {
        //
        // Nothing to cancel, just return
        //
#if DBG
        if(MasterPostBlock->TraceIntoDebugger) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"[CM]CmCancelSlavePost: MasterPostBlock:%p has no slaves\n", MasterPostBlock));
        }
#endif

        return;
    }


    //
    // Pull all the entries in the cancel post list and unlink them (when they are slave requests)
    // We base here on the assumption that there is only one slave.
    //
    //     NOTE!!!
    //       When more than slave allowed, here to modify
    //


    SlavePostBlock = (PCM_POST_BLOCK)MasterPostBlock->CancelPostList.Flink;
    SlavePostBlock = CONTAINING_RECORD(SlavePostBlock,
                                       CM_POST_BLOCK,
                                       CancelPostList);

#if DBG
    if(MasterPostBlock->TraceIntoDebugger) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"[CM]CmCancelSlavePost: Cleaning SlavePostBlock:%p\n", SlavePostBlock));
    }
#endif

    //
    // This should be true !
    //
    ASSERT( !IsMasterPostBlock(SlavePostBlock) );

    //
    // Unchain from the Master CancelPostList
    //
    // Use Cmp variant to protect for multiple deletion of the same object
    CmpRemoveEntryList(&(SlavePostBlock->CancelPostList));

    //
    // delist the post block from the thread postblocklist
    //
    // Use Cmp variant to protect for multiple deletion of the same object
    CmpRemoveEntryList(&(SlavePostBlock->ThreadList));

    //
    // Free the post block.
    //
    CmpFreePostBlock(SlavePostBlock);

    //
    // Result validation. was it the only slave?
    //
    ASSERT(IsListEmpty(&(MasterPostBlock->CancelPostList)));
}

VOID
CmpCancelSlavePost(
    PCM_POST_BLOCK  MasterPostBlock,
    PLIST_ENTRY     DelayedDeref
    )
/*++

Routine Description:

	Unlink the slave postblock from its notify list and dereferences (or adds to the delayed deref list)
	the keybody related to this thread. This should disable the slave post block. 
	It will be cleared later in CmpPostApc.

Arguments:

    MasterPostBlock - pointer to structure that describes the post requests.
                It should be a master post!!
    DelayedDeref - pointer to list of delayed deref keybodies. If this parameter is not NULL,
                the keybody for the slave is not cleared before calling CmpFreePostBlock, 
                and instead is added to the list


Return Value:

    NONE.

--*/
{
    PCM_POST_BLOCK  SlavePostBlock;

    CM_PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"CmpCancelSlavePost:\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"MasterPostBlock:%p\n", MasterPostBlock));

    ASSERT_CM_LOCK_OWNED();

    ASSERT(IsMasterPostBlock(MasterPostBlock));

#if DBG
    if(MasterPostBlock->TraceIntoDebugger) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"[CM]CmCancelSlavePost: MasterPostBlock:%p\n", MasterPostBlock));
    }
#endif

    if (IsListEmpty(&(MasterPostBlock->CancelPostList)) == TRUE) {
        //
        // Nothing to cancel, just return
        //
#if DBG
        if(MasterPostBlock->TraceIntoDebugger) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"[CM]CmCancelSlavePost: MasterPostBlock:%p has no slaves\n", MasterPostBlock));
        }
#endif

        return;
    }


    //
    // Pull all the entries in the cancel post list and unlink them (when they are slave requests)
    // We base here on the assumption that there is only one slave.
    //
    //     NOTE!!!
    //       When more than slave allowed, here to modify
    //


    SlavePostBlock = (PCM_POST_BLOCK)MasterPostBlock->CancelPostList.Flink;
    SlavePostBlock = CONTAINING_RECORD(SlavePostBlock,
                                       CM_POST_BLOCK,
                                       CancelPostList);

#if DBG
    if(MasterPostBlock->TraceIntoDebugger) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NOTIFY,"[CM]CmCancelSlavePost: Cleaning SlavePostBlock:%p\n", SlavePostBlock));
    }
#endif

    //
    // This should be true !
    //
    ASSERT( !IsMasterPostBlock(SlavePostBlock) );

    //
    // Remove it from notify block's list
    //
    // Use Cmp variant to protect for multiple deletion of the same object
	// This will disable the notifications that might come on the slave key
	//
    CmpRemoveEntryList(&(SlavePostBlock->NotifyList));

    if( DelayedDeref ) {
        // 
        // the caller wants to handle key body dereferenciation by himself
        //
        CmpAddToDelayedDeref(SlavePostBlock,DelayedDeref);
    }
}

VOID
CmpAddToDelayedDeref(
    PCM_POST_BLOCK  PostBlock,
    PLIST_ENTRY     DelayedDeref
    )
/*++

Routine Description:

    Add the key body attached to the post block to the delayed deref list.
    Cleans the post block KeyBody member, so it will not be dereferenced 
    when the post block is freed.

Arguments:

    PostBlock - pointer to structure that describes the post requests.

    DelayedDeref - the delayed deref list

Return Value:

    NONE.

--*/

{
    CM_PAGED_CODE();

    // common sense
    ASSERT( PostBlock != NULL );

    if( PostBlock->PostKeyBody ) {
        //
        // If the post block has a keybody attached, add it to delayed deref list and 
        // clear the post block member. The key body will be deref'd prior after 
        // postblock lock is released.
        //
    
        // extra validation
        ASSERT(PostBlock->PostKeyBody->KeyBody != NULL);
        ASSERT(DelayedDeref);

        // add it to the end of the list
        InsertTailList(
            DelayedDeref,
            &(PostBlock->PostKeyBody->KeyBodyList)
            );
    
        // make sure we don't deref it in CmpFreePostBlock
        PostBlock->PostKeyBody = NULL;
    }

    return;
}

VOID
CmpDelayedDerefKeys(
                    PLIST_ENTRY DelayedDeref
                    )
/*++

Routine Description:

    Walk through the entire list, dereference each keybody and free storage for the 
    CM_POST_KEY_BODY allocated for this purpose.

Arguments:

    DelayedDeref - the delayed deref list

Return Value:

    NONE.

--*/
{
    PCM_POST_KEY_BODY   PostKeyBody;

    CM_PAGED_CODE();

    // common sense
    ASSERT( DelayedDeref != NULL );

    while(IsListEmpty(DelayedDeref) == FALSE) {
        //
        // Remove from the delayed deref list and deref the coresponding keybody
        // free the storage associated with CM_POST_KEY_BODY
        //
        PostKeyBody = (PCM_POST_KEY_BODY)RemoveHeadList(DelayedDeref);
        PostKeyBody = CONTAINING_RECORD(PostKeyBody,
                                      CM_POST_KEY_BODY,
                                      KeyBodyList);

        // extra validation
        ASSERT(PostKeyBody->KeyBody != NULL);
        // this should be a valid key body
        ASSERT(PostKeyBody->KeyBody->Type == KEY_BODY_TYPE);
        
        // at last ..... dereference the key object
        ObDereferenceObjectDeferDelete(PostKeyBody->KeyBody);

        // Free the storage for the CM_POST_KEY_BODY object (allocated by CmpAllocatePostBlock)
        ExFreePool(PostKeyBody);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmpbug.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmpbug.h

Abstract:

    Description of the registry bugchecks; only defines and comments.

--*/

#ifndef __CMPBUG_H__
#define __CMPBUG_H__

#define CM_BUGCHECK( Code, Parm1, Parm2, Parm3, Parm4 ) \
    KeBugCheckEx( (ULONG)Code, (ULONG_PTR)Parm1, (ULONG_PTR)Parm2, (ULONG_PTR)Parm3, (ULONG_PTR)Parm4 )


/* -
CRITICAL_SERVICE_FAILED          (0x5A)
*/
/* -
SET_ENV_VAR_FAILED               (0x5B)
*/

#define BAD_LAST_KNOWN_GOOD             1       //CmBootLastKnownGood


/* -
CONFIG_LIST_FAILED               (0x73)
Indicates that one of the core system hives cannot be linked in the
registry tree. The hive is valid, it was loaded OK. Examine the 2nd 
bugcheck argument to see why the hive could not be linked in the 
registry tree.

PARAMETERS
        1 - 1
        2 - Indicates the NT status code that tripped us into thinking
			that we failed to load the hive.
        3 - Index of hive in hivelist 
        4 - Pointer to UNICODE_STRING containing filename of hive

DESCRIPTION
This can be either SAM, SECURITY, SOFTWARE or DEFAULT. One common reason 
for this to happen is if you are out of disk space on the system drive 
(in which case param 4 is 0xC000017D - STATUS_NO_LOG_SPACE) or an attempt 
to allocate pool has failed (in which case param 4 is 0xC000009A -
STATUS_INSUFFICIENT_RESOURCES). Other status codes must be individually
investigated. 
*/

#define BAD_CORE_HIVE                   1       // CmpInitializeHiveList

/* -
BAD_SYSTEM_CONFIG_INFO           (0x74)
Can indicate that the SYSTEM hive loaded by the osloader/NTLDR
was corrupt.  This is unlikely, since the osloader will check
a hive to make sure it isn't corrupt after loading it.

It can also indicate that some critical registry keys and values
are not present.  (i.e. somebody used regedt32 to delete something
that they shouldn't have)  Booting from LastKnownGood may fix
the problem, but if someone is persistent enough in mucking with
the registry they will need to reinstall or use the Emergency
Repair Disk.

PARAMETERS
		1 - identifies the function
		2 - identifies the line inside the function
		3 - other info
		4 - usually the NT status code.
*/

#define BAD_SYSTEM_CONTROL_VALUES       1       // CmGetSystemControlValues

#define BAD_HIVE_LIST                   2       // CmpInitializeHiveList

#define BAD_SYSTEM_HIVE                 3       // CmpInitializeSystemHive



/* -
CONFIG_INITIALIZATION_FAILED     (0x67)

PARAMETERS
    1 - indicates location in ntos\config\cmsysini that failed
    2 - location selector
	3 - NT status code 

DESCRIPTION
This means the registry couldn't allocate the pool needed to contain the
registry files.  This should never happen, since it is early enough in
system initialization that there is always plenty of paged pool available.
*/

#define INIT_SYSTEM1                    1       // CmInitSystem1

#define INIT_SYSTEM_DRIVER_LIST         2       // CmGetSystemDriverList

#define INIT_CACHE_TABLE                3       // CmpInitializeCache

#define INIT_DELAYED_CLOSE_TABLE        4       // CmpInitializeDelayedCloseTable


/* -
CANNOT_WRITE_CONFIGURATION       (0x75)

This will result if the SYSTEM hive file cannot be converted to a 
mapped file. This usually happens if the system is out of pool and
we cannot reopen the hive. 

PARAMETERS
		1 - 1
		2 - Indicates the NT status code that tripped us into thinking
			that we failed to convert the hive.

DESCRIPTION
Normally you shouldn't see this as the conversion happens at early 
during system initialization, so enough pool should be available.
*/

#define CANNOT_CONVERT_SYSTEM_HIVE      1


/* -
REGISTRY_ERROR                   (0x51)
PARAMETERS
        1 - value 1 (indicates where we bugchecked)
        2 - value 2 (indicates where we bugchecked)
        3 - depends on where it bugchecked, may be pointer to hive
        4 - depends on where it bugchecked, may be return code of
            HvCheckHive if the hive is corrupt.

DESCRIPTION
Something has gone horribly wrong with the registry.  If a kernel debugger
is available, get a stack trace.It can also indicate that the registry got 
an I/O error while trying to read one of its files, so it can be caused by 
hardware problems or filesystem corruption.

It may occur due to a failure in a refresh operation, which is used only
in by the security system, and then only when resource limits are encountered.
*/

#define BAD_CELL_MAP                    1           // VALIDATE_CELL_MAP

#define BAD_FREE_BINS_LIST              2           // HvpDelistBinFreeCells

#define FATAL_MAPPING_ERROR             3           // HvpFindNextDirtyBlock
                                                    // HvpDoWriteHive

#define BAD_SECURITY_CACHE              4           // CmpAssignSecurityToKcb
                                                    // CmpSetSecurityDescriptorInfo

#define BAD_SECURITY_METHOD             5           // CmpSecurityMethod

#define CHECK_LOCK_EXCEPTION            6           // CmpCheckLockExceptionFilter

#define REGISTRY_LOCK_CHECKPOINT        7           // END_LOCK_CHECKPOINT

#define BIG_CELL_ERROR                  8           // CmpValueToData

#define CMVIEW_ERROR                    9           // CmpAllocateCmView
                                                    // CmpFreeCmView
                                                    // CmpPinCmView

#define REFRESH_HIVE                    0xA         // HvRefreshHive


#define ALLOCATE_SECURITY_DESCRIPTOR    0xB         // CmpHiveRootSecurityDescriptor

#define BAD_NOTIFY_CONTEXT              0xC         // NtNotifyChangeMultipleKeys


#define QUOTA_ERROR                     0xD         // CmpReleaseGlobalQuota

#define INVALID_WRITE_OPERATION         0xE         // NtCreateKey

#define HANDLES_STILL_OPEN_AT_SHUTDOWN  0xF         // CmFreeAllMemory

#define COMPRESS_HIVE					0x10        // CmCompressKey

#define ALLOC_ERROR						0x11        // CmpFreeKeyControlBlock

#endif  // _CMPBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmparse.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmparse.c

Abstract:

    This module contains parse routines for the configuration manager, particularly
    the registry.

--*/

#include    "cmp.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif
const ULONG CmpCacheOnFlag = CM_CACHE_FAKE_KEY;

extern  BOOLEAN CmpNoMasterCreates;
extern  PCM_KEY_CONTROL_BLOCK CmpKeyControlBlockRoot;
extern  UNICODE_STRING CmSymbolicLinkValueName;

#define CM_HASH_STACK_SIZE  32
#define MAX_LOCAL_KCB_ARRAY (CM_HASH_STACK_SIZE + 1) // need to account for RootObject as well

typedef struct _CM_HASH_ENTRY {
    ULONG ConvKey;
    UNICODE_STRING KeyName;
} CM_HASH_ENTRY, *PCM_HASH_ENTRY;

BOOLEAN
CmpGetHiveName(
    PCMHIVE         CmHive,
    PUNICODE_STRING HiveName
    );

ULONG
CmpComputeHashValue(
    IN PCM_HASH_ENTRY  HashStack,
    IN OUT ULONG  *TotalSubkeys,
    IN ULONG BaseConvKey,
    IN PUNICODE_STRING RemainingName
    );

NTSTATUS
CmpCacheLookup(
    IN PCM_HASH_ENTRY HashStack,
    IN ULONG TotalRemainingSubkeys,
    OUT ULONG *MatchRemainSubkeyLevel,
    IN OUT PCM_KEY_CONTROL_BLOCK *Kcb,
    OUT PUNICODE_STRING RemainingName,
    OUT PHHIVE *Hive,
    OUT HCELL_INDEX *Cell,
    IN PULONG   OuterStackArray
    );

VOID
CmpCacheAdd(
    IN PCM_HASH_ENTRY LastHashEntry,
    IN ULONG Count
    );

PCM_KEY_CONTROL_BLOCK
CmpAddInfoAfterParseFailure(
    PHHIVE          Hive,
    HCELL_INDEX     Cell,
    PCM_KEY_NODE    Node,
    PCM_KEY_CONTROL_BLOCK kcb,
    PUNICODE_STRING NodeName
    );

//
// Prototypes for procedures private to this file
//

BOOLEAN
CmpGetSymbolicLink(
    IN PHHIVE Hive,
    IN OUT PUNICODE_STRING ObjectName,
    IN OUT PCM_KEY_CONTROL_BLOCK SymbolicKcb,
    IN PUNICODE_STRING RemainingName
    );

NTSTATUS
CmpDoOpen(
    IN PHHIVE                       Hive,
    IN HCELL_INDEX                  Cell,
    IN PCM_KEY_NODE                 Node,
    IN PACCESS_STATE                AccessState,
    IN KPROCESSOR_MODE              AccessMode,
    IN ULONG                        Attributes,
    IN PCM_PARSE_CONTEXT            Context,
    IN ULONG                        ControlFlags,
    IN OUT PCM_KEY_CONTROL_BLOCK    *CachedKcb,
    IN PUNICODE_STRING              KeyName,
    IN PCMHIVE                      OriginatingHive OPTIONAL,
    IN PULONG                       KcbsLocked,
    OUT PVOID                       *Object,
    OUT PBOOLEAN                    NeedDeref OPTIONAL
    );


NTSTATUS
CmpCreateLinkNode(
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell,
    IN PACCESS_STATE AccessState,
    IN UNICODE_STRING Name,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN PCM_PARSE_CONTEXT Context,
    IN PCM_KEY_CONTROL_BLOCK ParentKcb,
    IN PULONG LockedKcbs,
    OUT PVOID *Object
    );

BOOLEAN
CmpOKToFollowLink(  IN PCMHIVE  OrigHive,
                    IN PCMHIVE  DestHive
                    );


NTSTATUS
CmpBuildHashStackAndLookupCache( PCM_KEY_BODY           ParseObject,
                                 PCM_KEY_CONTROL_BLOCK  *kcb,
                                 PUNICODE_STRING        Current,
                                 PHHIVE                 *Hive,
                                 HCELL_INDEX            *Cell,
                                 PULONG                 TotalRemainingSubkeys,
                                 PULONG                 MatchRemainSubkeyLevel,
                                 PULONG                 TotalSubkeys,
                                 PULONG                 OuterStackArray,
                                 PULONG                 *LockedKcbs
                                );

PULONG 
CmpBuildAndLockKcbArray(   
    IN PCM_HASH_ENTRY HashStack,
    IN ULONG TotalLevels,
    IN ULONG RemainingLevel,
    IN PCM_KEY_CONTROL_BLOCK    kcb,
    IN PULONG                   OuterStackArray,
    IN BOOLEAN LockExclusive);

ULONG
CmpUnLockKcbArray(IN PULONG LockedKcbs,
                  IN ULONG  Exempt);

VOID
CmpReLockKcbArray(IN PULONG LockedKcbs,
                  IN BOOLEAN LockExclusive);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpBuildHashStackAndLookupCache)
#pragma alloc_text(PAGE,CmpParseKey)
#pragma alloc_text(PAGE,CmpGetNextName)
#pragma alloc_text(PAGE,CmpDoOpen)
#pragma alloc_text(PAGE,CmpCreateLinkNode)
#pragma alloc_text(PAGE,CmpGetSymbolicLink)
#pragma alloc_text(PAGE,CmpComputeHashValue)
#pragma alloc_text(PAGE,CmpCacheLookup)
#pragma alloc_text(PAGE,CmpAddInfoAfterParseFailure)
#pragma alloc_text(PAGE,CmpOKToFollowLink)
#pragma alloc_text(PAGE,CmpBuildAndLockKcbArray)
#pragma alloc_text(PAGE,CmpUnLockKcbArray)
#pragma alloc_text(PAGE,CmpReLockKcbArray)
#endif
    
/* macro
VOID
CmpStepThroughExit(
    IN OUT PHHIVE       *Hive,
    IN OUT HCELL_INDEX  *Cell,
    IN OUT PCM_KEY_NODE *pNode
    )
*/
#define CmpStepThroughExit(h,c,n,ReleaseHive,ReleaseCell)           \
if ((n)->Flags & KEY_HIVE_EXIT) {                                   \
    if( ReleaseCell != HCELL_NIL ) {                                \
        ASSERT( ReleaseHive != NULL );                              \
        HvReleaseCell( ReleaseHive,ReleaseCell);                    \
    }                                                               \
    (h)=(n)->ChildHiveReference.KeyHive;                            \
    (c)=(n)->ChildHiveReference.KeyCell;                            \
    (n)=(PCM_KEY_NODE)HvGetCell((h),(c));                           \
    if( (n) == NULL ) {                                             \
        ReleaseHive = NULL;                                         \
        ReleaseCell = HCELL_NIL;                                    \
    } else {                                                        \
        ReleaseHive = (h);                                          \
        ReleaseCell = (c);                                          \
    }                                                               \
}

#define CmpReleasePreviousAndHookNew(NewHive,NewCell,ReleaseHive,ReleaseCell)   \
    if( ReleaseCell != HCELL_NIL ) {                                            \
        ASSERT( ReleaseHive != NULL );                                          \
        HvReleaseCell( ReleaseHive,ReleaseCell);                                \
    }                                                                           \
    ReleaseHive = (NewHive);                                                    \
    ReleaseCell = (NewCell)                                                    

#define CMP_PARSE_GOTO_NONE     0
#define CMP_PARSE_GOTO_CREATE   1
#define CMP_PARSE_GOTO_RETURN   2
#define CMP_PARSE_GOTO_RETURN2  3

NTSTATUS
CmpBuildHashStackAndLookupCache( PCM_KEY_BODY           ParseObject,
                                 PCM_KEY_CONTROL_BLOCK  *kcb,
                                 PUNICODE_STRING        Current,
                                 PHHIVE                 *Hive,
                                 HCELL_INDEX            *Cell,
                                 PULONG                 TotalRemainingSubkeys,
                                 PULONG                 MatchRemainSubkeyLevel,
                                 PULONG                 TotalSubkeys,
                                 PULONG                 OuterStackArray,
                                 PULONG                 *LockedKcbs
                                )
{
    CM_HASH_ENTRY   HashStack[CM_HASH_STACK_SIZE];
    ULONG           HashKeyCopy;
    BOOLEAN         RegLocked = FALSE;
    NTSTATUS        status;

    *LockedKcbs = NULL;
RetryHash:
    HashKeyCopy = (*kcb)->ConvKey;
    //
    // Compute the hash values of each subkeys
    //
    *TotalRemainingSubkeys = CmpComputeHashValue(HashStack,
                                                TotalSubkeys,
                                                HashKeyCopy,
                                                Current);
    //
    // we now lock it shared as 85% of the create calls are in fact opens
    // the lock will be acquired exclusively in CmpDoCreate/CmpCreateLinkNode
    //
    // We only lock the registry here, in the parse routine to reduce contention 
    // on the registry lock (NO reason to wait on OB)
    //

    if( !RegLocked ) {
        CmpLockRegistry();
        RegLocked = TRUE;
    }

    //
    // we can't go deeper than what our stack buffer allows us to at one iteration.
    //
    if( *TotalSubkeys > CM_HASH_STACK_SIZE ) {
        return STATUS_NAME_TOO_LONG;
    }

    if( (*kcb)->ConvKey != HashKeyCopy ) {
        goto RetryHash;
    }
    //
    // Check to make sure the passed in root key is not marked for deletion.
    //
    if (((PCM_KEY_BODY)ParseObject)->KeyControlBlock->Delete == TRUE) {
        ASSERT( RegLocked );
        return STATUS_KEY_DELETED;
    }

    //
    // Fetch the starting Hive.Cell.  Because of the way the parse
    // paths work, this will always be defined.  (ObOpenObjectByName
    // had to bounce off of a KeyObject or KeyRootObject to get here)
    //
    *Hive = (*kcb)->KeyHive;
    *Cell = (*kcb)->KeyCell;

    // Look up from the cache.  kcb will be changed if we find a partial or exact match
    // PCmpCacheEntry, the entry found, will be moved to the front of
    // the Cache.
    status = CmpCacheLookup(HashStack,
                          *TotalRemainingSubkeys,
                          MatchRemainSubkeyLevel,
                          kcb,
                          Current,
                          Hive,
                          Cell,
                          OuterStackArray);
    //
    // The RefCount of kcb was increased in the CmpCacheLookup process,
    // It is to protect it from being kicked out of cache.
    // Make sure we dereference it after we are done.
    //
    //
    // lock in advance all kcbs we might be touching so key_nodes don't get away from under us.
    //
    if (NT_SUCCESS (status)) {
        if( ((*TotalRemainingSubkeys) == (*MatchRemainSubkeyLevel)) && (OuterStackArray[0] == 1) ) {
            //
            // fast path; we're lucky and have a hit to an already opened kcb
            // we can (try) to do a lock free open.
            //
            ASSERT( OuterStackArray );
            ASSERT( OuterStackArray[1] == GET_HASH_INDEX((*kcb)->ConvKey) );
            ASSERT_KCB_LOCKED(*kcb);
            *LockedKcbs = OuterStackArray;
        } else {
            *LockedKcbs = CmpBuildAndLockKcbArray(   HashStack,
                                                    *TotalRemainingSubkeys,
                                                    *MatchRemainSubkeyLevel,
                                                    *kcb,
                                                    OuterStackArray,
                                                    TRUE
                                                );
            if( *LockedKcbs == NULL ) {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }
    
    return status;
}

C_ASSERT( sizeof(REG_CREATE_KEY_INFORMATION) >= sizeof(REG_OPEN_KEY_INFORMATION) );
C_ASSERT( FIELD_OFFSET(REG_CREATE_KEY_INFORMATION, CompleteName) == FIELD_OFFSET(REG_OPEN_KEY_INFORMATION, CompleteName) );
C_ASSERT( FIELD_OFFSET(REG_CREATE_KEY_INFORMATION, RootObject) == FIELD_OFFSET(REG_OPEN_KEY_INFORMATION, RootObject) );

NTSTATUS
CmpParseKey(
    IN PVOID ParseObject,
    IN PVOID ObjectType,
    IN OUT PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN OUT PUNICODE_STRING CompleteName,
    IN OUT PUNICODE_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
    OUT PVOID *Object
    )
/*++

Routine Description:

    This routine interfaces to the NT Object Manager.  It is invoked when
    the object system is given the name of an entity to create or open and
    a Key or KeyRoot is encountered in the path.  In practice this means
    that this routine is called for all objects whose names are of the
    form \REGISTRY\...

    This routine will create a Key object, which is effectively an open
    instance to a registry key node, and return its address
    (for the success case.)

Arguments:

    ParseObject - Pointer to a KeyRoot or Key, thus -> KEY_BODY.

    ObjectType - Type of the object being opened.

    AccessState - Running security access state information for operation.

    AccessMode - Access mode of the original caller.

    Attributes - Attributes to be applied to the object.

    CompleteName - Supplies complete name of the object.

    RemainingName - Remaining name of the object.

    Context - if create or hive root open, points to a CM_PARSE_CONTEXT
              structure,
              if open, is NULL.

    SecurityQos - Optional security quality of service indicator.

    Object - The address of a variable to receive the created key object, if
        any.

Return Value:

    The function return value is one of the following:

        a)  Success - This indicates that the function succeeded and the object
            parameter contains the address of the created key object.

        b)  STATUS_REPARSE - This indicates that a symbolic link key was
            found, and the path should be reparsed.

        c)  Error - This indicates that the file was not found or created and
            no file object was created.

--*/
{
    NTSTATUS                status = STATUS_UNSUCCESSFUL;
    BOOLEAN                 rc;
    PHHIVE                  Hive = NULL;
    PCM_KEY_NODE            Node = NULL;
    HCELL_INDEX             Cell = HCELL_NIL;
    HCELL_INDEX             NextCell;
    PCM_PARSE_CONTEXT       lcontext;
    UNICODE_STRING          Current;
    UNICODE_STRING          NextName = {0}; // Component last returned by CmpGetNextName,
                                        // will always be behind Current.
    
    BOOLEAN                 Last;       // TRUE if component NextName points to
                                        // is the last one in the path.

    ULONG           TotalRemainingSubkeys;
    ULONG           MatchRemainSubkeyLevel = 0;
    ULONG           TotalSubkeys=0;
    PCM_KEY_CONTROL_BLOCK   kcb;
    PCM_KEY_CONTROL_BLOCK   ParentKcb = NULL;
    UNICODE_STRING          TmpNodeName;
    ULONG                   GoToValue = CMP_PARSE_GOTO_NONE;
    BOOLEAN                 CompleteKeyCached = FALSE;

    PHHIVE                  HiveToRelease = NULL;
    HCELL_INDEX             CellToRelease = HCELL_NIL;
    PULONG                  LockedKcbs = NULL;
    ULONG                   LocalFastKcbArray[MAX_LOCAL_KCB_ARRAY + 1]; // perf, avoid ExAllocatePool

    CM_PAGED_CODE();

    UNREFERENCED_PARAMETER (SecurityQos);

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpParseKey:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CompleteName = '%wZ'\n\t", CompleteName));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"RemainingName = '%wZ'\n", RemainingName));

    //
    // Strip off any trailing path separators
    //
    while ((RemainingName->Length > 0) &&
           (RemainingName->Buffer[(RemainingName->Length/sizeof(WCHAR)) - 1] == OBJ_NAME_PATH_SEPARATOR)) {
        RemainingName->Length -= sizeof(WCHAR);
    }

    Current = *RemainingName;
    if (ObjectType != CmpKeyObjectType) {
        return STATUS_OBJECT_TYPE_MISMATCH;
    }

    if( ARGUMENT_PRESENT(Context) && (((PCM_PARSE_CONTEXT)Context)->CreateOperation == TRUE) ) {
        lcontext = (PCM_PARSE_CONTEXT)Context;
    } else {
        //
        // keep the old behavior (open == parse without context)
        //
        lcontext = NULL;
    }

    //
    // PreCreate callback
    //
    if ( CmAreCallbacksRegistered() ) {
        REG_CREATE_KEY_INFORMATION  PreCreateInfo;
        PreCreateInfo.CompleteName = CompleteName;
        PreCreateInfo.RootObject = ParseObject;
        if( ARGUMENT_PRESENT(lcontext) ) {
            //
            // NtCreateKey
            //
            status = CmpCallCallBacks(RegNtPreCreateKeyEx,&PreCreateInfo,TRUE,RegNtPostCreateKeyEx,ParseObject);
        } else {
            //
            // NtOpenKey
            //
            status = CmpCallCallBacks(RegNtPreOpenKeyEx,(PREG_OPEN_KEY_INFORMATION)(&PreCreateInfo),TRUE,RegNtPostOpenKeyEx,ParseObject);
        }

        if( !NT_SUCCESS(status) ) {
            return status;
        }
    }
    
    BEGIN_LOCK_CHECKPOINT;

    kcb = ((PCM_KEY_BODY)ParseObject)->KeyControlBlock;

    status = CmpBuildHashStackAndLookupCache(ParseObject,
                                             &kcb,
                                             &Current,
                                             &Hive,
                                             &Cell,
                                             &TotalRemainingSubkeys,
                                             &MatchRemainSubkeyLevel,
                                             &TotalSubkeys,
                                             LocalFastKcbArray,
                                             &LockedKcbs);
    ASSERT_CM_LOCK_OWNED();
    //
    // First make sure it is OK to proceed.
    //
    if (!NT_SUCCESS (status)) {
        goto JustReturn;
    } 

    ParentKcb = kcb;

    if(TotalRemainingSubkeys == 0) {
        //
        // We REALLY don't want to mess with the cache code below
        // in this case (this could only happen if we called with 
        // the lpSubkey = NULL )
        //
        CompleteKeyCached = TRUE;
        goto Found;
    }


    //
    // First check if there are further information in the cached kcb.
    // 
    // The additional information can be
    // 1. This cached key is a fake key (CM_KCB_KEY_NON_EXIST), then either let it be created
    //    or return STATUS_OBJECT_NAME_NOT_FOUND.
    // 2. The cached key is not the destination and it has no subkey (CM_KCB_NO_SUBKEY).
    // 3. The cached key is not the destination and it has 
    //    the first four characters of its subkeys.  If the flag is CM_KCB_SUBKEY_ONE, there is only one subkey
    //    and the four char is embedded in the KCB.  If the flag is CM_KCB_SUBKEY_INFO, then there is
    //    an allocation for these info. 
    //
    // We do need to lock KCB tree to protect the KCB being modified.  Currently there is not lock contention problem
    // on KCBs, We can change KCB lock to a read-write lock if this becomes a problem.
    // We already have the lock on the kcb tree and we need it until we finish work on the cache table.  
    //
    if( kcb->Delete ) {
        //
        // kcb has been deleted while playing with the lock
        //
        status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto JustReturn;

    }

    if (kcb->ExtFlags & CM_KCB_CACHE_MASK) {
        if (MatchRemainSubkeyLevel == TotalRemainingSubkeys) {
            //
            // We have found a cache for the complete path,
            //
            if (kcb->ExtFlags & CM_KCB_KEY_NON_EXIST) {
                //
                // This key does not exist.
                //
                if (ARGUMENT_PRESENT(lcontext)) {
                    ULONG LevelToSkip = TotalRemainingSubkeys-1;
                    ULONG i=0;
                    
                    ParentKcb = kcb->ParentKcb;

                    ASSERT_KCB_LOCKED_EXCLUSIVE(kcb);
                    ASSERT_KCB_LOCKED_EXCLUSIVE(ParentKcb);
                    //
                    // The non-existing key is the destination key and lcontext is present.
                    // delete this fake kcb and let the real one be created.
                    //
                    // Temporarily increase the RefCount of the ParentKcb so it's 
                    // not removed while removing the fake and creating the real KCB.
                    //
                    
                    if (CmpReferenceKeyControlBlock(ParentKcb)) {
                    
                        kcb->Delete = TRUE;
                        CmpRemoveKeyControlBlock(kcb);
                        CmpDereferenceKeyControlBlockWithLock(kcb,FALSE);

                        //
                        // Update Hive, Cell and Node
                        //
                        Hive = ParentKcb->KeyHive;
                        Cell = ParentKcb->KeyCell;
                        Node = (PCM_KEY_NODE)HvGetCell(Hive,Cell);
                        if( Node == NULL ) {
                            //
                            // we couldn't map the bin containing this cell
                            //
                            status = STATUS_INSUFFICIENT_RESOURCES;
                            goto FreeAndReturn;
                        }
                    
                        CmpReleasePreviousAndHookNew(Hive,Cell,HiveToRelease,CellToRelease);

                        //
                        // Now get the child name to be created.
                        //
   
                        NextName = *RemainingName;
                        if ((NextName.Buffer == NULL) || (NextName.Length == 0)) {
                            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Something wrong in finding the child name\n"));
                            DbgBreakPoint();
                        }
                        //
                        // Skip over leading path separators
                        //
                        while (*(NextName.Buffer) == OBJ_NAME_PATH_SEPARATOR) {
                            NextName.Buffer++;
                            NextName.Length -= sizeof(WCHAR);
                            NextName.MaximumLength -= sizeof(WCHAR);
                        }
   
                        while (i < LevelToSkip) {
                            if (*(NextName.Buffer) == OBJ_NAME_PATH_SEPARATOR) {
                                i++;
                                while (*(NextName.Buffer) == OBJ_NAME_PATH_SEPARATOR) {
                                    NextName.Buffer++;
                                    NextName.Length -= sizeof(WCHAR);
                                    NextName.MaximumLength -= sizeof(WCHAR);
                                }
                            } else {
                                NextName.Buffer++;
                                NextName.Length -= sizeof(WCHAR);
                                NextName.MaximumLength -= sizeof(WCHAR);
                            }
                        } 
                        GoToValue = CMP_PARSE_GOTO_CREATE;
                    } else {
                        //
                        // We have maxed the RefCount of ParentKcb; treate it as key cannot be created.
                        // The ParentKcb will not be dereferenced at the end.
                        //
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        GoToValue = CMP_PARSE_GOTO_RETURN2;
                    }
                } else {
                    status = STATUS_OBJECT_NAME_NOT_FOUND;
                    GoToValue = CMP_PARSE_GOTO_RETURN;
                }
            }
        } else if (kcb->ExtFlags & CM_KCB_KEY_NON_EXIST) {
            //
            // one subkey (not destination) in the path does not exist. no point to continue.
            //
            status = STATUS_OBJECT_NAME_NOT_FOUND;
            GoToValue = CMP_PARSE_GOTO_RETURN;
        } else if (kcb->ExtFlags & CM_KCB_NO_SUBKEY) {
            //
            // one parent in the path has no subkey. see if it is a create.
            //
            if (((TotalRemainingSubkeys - MatchRemainSubkeyLevel) == 1) && (ARGUMENT_PRESENT(lcontext))) {
                //
                // Now we are going to create this subkey. 
                // The kcb cache will be updated in CmpDoCreate routine.
                //
            } else {
                status = STATUS_OBJECT_NAME_NOT_FOUND;
                GoToValue = CMP_PARSE_GOTO_RETURN;
            }
        } else {
            //
            // We have a partial match.  Current is the remaining name to be parsed.
            // The Key has either one or a few subkeys and has index hint. check if it is the candidate.
            //
           
            BOOLEAN NoMatch = TRUE;
            ULONG   NextHashKey;
            PULONG  TempHashKey;
            ULONG   HintCounts;
            ULONG   CmpCount;
            //
            // When NoMatch is TRUE, we know for sure there is no subkey that can match.
            // When NoMatch is FALSE, it can we either we found a match or
            // there is not enough information.  Either case, we need to continue
            // the parse.
            //

            TmpNodeName = Current;

            rc = CmpGetNextName(&TmpNodeName, &NextName, &Last);
        
            NextHashKey = CmpComputeHashKey(0,&NextName
#if DBG
                                            , FALSE
#endif
                );

            if (kcb->ExtFlags & CM_KCB_SUBKEY_ONE) {
                HintCounts = 1;
                TempHashKey = &(kcb->HashKey);
            } else {
                //
                // More than one child, the hint info in not inside the kcb but pointed by kcb.
                //
                HintCounts = kcb->IndexHint->Count;
                TempHashKey = &(kcb->IndexHint->HashKey[0]);
            }

            for (CmpCount=0; CmpCount<HintCounts; CmpCount++) {
                if( TempHashKey[CmpCount] == 0) {
                    //
                    // No hint available; assume the subkey exist and go on with the parse
                    //
                    NoMatch = FALSE;
                    break;
                } 
                
                if( NextHashKey == TempHashKey[CmpCount] ) {
                    //
                    // There is a match.
                    //
                    NoMatch = FALSE;
                    break;
                }
            }

            if (NoMatch) {
                if (((TotalRemainingSubkeys - MatchRemainSubkeyLevel) == 1) && (ARGUMENT_PRESENT(lcontext))) {
                    //
                    // No we are going to create this subkey. 
                    // The kcb cache will be updated in CmpDoCreate.
                    //
                } else {
                    status = STATUS_OBJECT_NAME_NOT_FOUND;
                    GoToValue = CMP_PARSE_GOTO_RETURN;
                }
            }
        }
    }

    if (GoToValue == CMP_PARSE_GOTO_CREATE) {
        goto CreateChild;
    } else if (GoToValue == CMP_PARSE_GOTO_RETURN) {
        goto FreeAndReturn;
    } else if (GoToValue == CMP_PARSE_GOTO_RETURN2) {
        goto JustReturn;
    }

    if (MatchRemainSubkeyLevel) {
        // Found something, update the information to start the search
        // from the new BaseName

        if (MatchRemainSubkeyLevel == TotalSubkeys) {
            // The complete key has been found in the cache,
            // go directly to the CmpDoOpen.
            
            //
            // Found the whole thing cached.
            // 
            //
            CompleteKeyCached = TRUE;
            goto Found;
        }
        ASSERT( (Cell == kcb->KeyCell) && (Hive == kcb->KeyHive) );
    }  

    //
    //  Check if we hit a symbolic link case
    //
    if (kcb->Flags & KEY_SYM_LINK) {
        //
        // The given key was a symbolic link.  Find the name of
        // its link, and return STATUS_REPARSE to the Object Manager.
        //
        rc = CmpGetNextName(&Current, &NextName, &Last);
        Current.Buffer = NextName.Buffer;
        if (Current.Length + NextName.Length > MAXUSHORT) {
            status = STATUS_NAME_TOO_LONG;
            goto FreeAndReturn;
        }
        Current.Length = (USHORT)(Current.Length + NextName.Length);

        if (Current.MaximumLength + NextName.MaximumLength > MAXUSHORT) {
            status = STATUS_NAME_TOO_LONG;
            goto FreeAndReturn;
        }
        Current.MaximumLength = (USHORT)(Current.MaximumLength + NextName.MaximumLength);
        //
        // need not to interfere with CmpGetSymbolicLink
        //
        CmpUnLockKcbArray(LockedKcbs,CmpHashTableSize);
        if( LockedKcbs != LocalFastKcbArray ) {
            ExFreePool(LockedKcbs);
        }
        LockedKcbs = NULL;
        if (CmpGetSymbolicLink(Hive,
                               CompleteName,
                               kcb,
                               &Current)) {

            status = STATUS_REPARSE;
            CmpParseRecordOriginatingPoint(Context,(PCMHIVE)kcb->KeyHive);
        } else {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpParseKey: couldn't find symbolic link name\n"));
            status = STATUS_OBJECT_NAME_NOT_FOUND;
        }
        goto FreeAndReturn;
    }

    Node = (PCM_KEY_NODE)HvGetCell(Hive,Cell);
    if( Node == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto FreeAndReturn;
    }
    CmpReleasePreviousAndHookNew(Hive,Cell,HiveToRelease,CellToRelease);

    //
    // Parse the path.
    //

    status = STATUS_SUCCESS;
    while (TRUE) {

        //
        // Parse out next component of name
        //
        rc = CmpGetNextName(&Current, &NextName, &Last);
        if ((NextName.Length > 0) && (rc == TRUE)) {

            //
            // As we iterate through, we will create a kcb for each subkey parsed.
            // 
            // Always use the information in kcb to avoid
            // touching registry data.
            //
            if (!(kcb->Flags & KEY_SYM_LINK)) {
                //
                // Got a legal name component, see if we can find a sub key
                // that actually has such a name.
                //
                NextCell = CmpFindSubKeyByName(Hive,
                                               Node,
                                               &NextName);

                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpParseKey:\n\t"));
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"NextName = '%wZ'\n\t", &NextName));
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"NextCell = %08lx  Last = %01lx\n", NextCell, Last));

                if (NextCell != HCELL_NIL) {
                    Cell = NextCell;
                    Node = (PCM_KEY_NODE)HvGetCell(Hive,Cell);
                    if( Node == NULL ) {
                        //
                        // we couldn't map the bin containing this cell
                        //
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }
                    
                    CmpReleasePreviousAndHookNew(Hive,Cell,HiveToRelease,CellToRelease);

                    if (Last == TRUE) {
                        BOOLEAN     NeedDeref;

Found:
                        //
                        // We will open the key regardless of whether the
                        // call was open or create, so step through exit
                        // portholes here.
                        //

                        if (CompleteKeyCached == TRUE) {
                            //
                            // If the key found is already cached, 
                            // do not need to StepThroughExit
                            // (no kcb is created using exit node).
                            // This prevents us from touching the key node just for the Flags.
                            //
                        } else {
                            CmpStepThroughExit(Hive, Cell, Node,HiveToRelease,CellToRelease);
                            if( Node == NULL ) {
                                //
                                // we couldn't map view for this cell
                                //
                                status = STATUS_INSUFFICIENT_RESOURCES;
                                break;
                            }
                        }
                        //
                        // We have found the entire path, so we want to open
                        // it (for both Open and Create calls).
                        // Hive,Cell -> the key we are supposed to open.
                        //

                        status = CmpDoOpen(Hive,
                                           Cell,
                                           Node,
                                           AccessState,
                                           AccessMode,
                                           Attributes,
                                           lcontext,
                                           CMP_CREATE_KCB_KCB_LOCKED| (CompleteKeyCached?CMP_DO_OPEN_COMPLETE_KEY_CACHED:0),
                                           &kcb,
                                           &NextName,
                                           CmpParseGetOriginatingPoint(Context),
                                           LockedKcbs,
                                           Object,
                                           &NeedDeref);

                        if (status == STATUS_REPARSE) {
                            //
                            // The given key was a symbolic link.  Find the name of
                            // its link, and return STATUS_REPARSE to the Object Manager.
                            //

                            //
                            // need not to interfere with CmpGetSymbolicLink
                            //
                            CmpUnLockKcbArray(LockedKcbs,CmpHashTableSize);
                            if( LockedKcbs != LocalFastKcbArray ) {
                                ExFreePool(LockedKcbs);
                            }
                            LockedKcbs = NULL;

                            if (!CmpGetSymbolicLink(Hive,
                                                    CompleteName,
                                                    kcb,
                                                    NULL)) {
                                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpParseKey: couldn't find symbolic link name\n"));
                                status = STATUS_OBJECT_NAME_NOT_FOUND;
                            }
                            CmpParseRecordOriginatingPoint(Context,(PCMHIVE)kcb->KeyHive);
                            if( TRUE == NeedDeref  ) {
                                CmpDereferenceKeyControlBlock(kcb);
                            }
                        } else {
                            ASSERT( !NeedDeref );
                        }

                        break;
                    }
                    // else
                    //   Not at end, so we'll simply iterate and consume
                    //   the next component.
                    //
                    //
                    // Step through exit portholes here.
                    // This ensures that no KCB is created using
                    // the Exit node.
                    //

                    CmpStepThroughExit(Hive, Cell, Node,HiveToRelease,CellToRelease);
                    if( Node == NULL ) {
                        //
                        // we couldn't map view for this cell
                        //
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }

                    //
                    // Create a kcb for each subkey parsed.
                    //

                    kcb = CmpCreateKeyControlBlock(Hive,
                                                   Cell,
                                                   Node,
                                                   ParentKcb,
                                                   CMP_CREATE_KCB_KCB_LOCKED,
                                                   &NextName);
            
                    if (kcb  == NULL) {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        goto FreeAndReturn;
                        //
                        // Currently, the kcb has one extra reference count to be decremented.
                        // Remember it so we can dereference it properly.
                        //
                    }
                    //
                    // Now we have created a kcb for the next level,
                    // the kcb in the previous level is no longer needed.
                    // Dereference the parent kcb.
                    //
                    CmpDereferenceKeyControlBlockWithLock(ParentKcb,FALSE);

                    ParentKcb = kcb;


                } else {
                    //
                    // We did not find a key matching the name, but no
                    // unexpected error occured
                    //

                    if ((Last == TRUE) && (ARGUMENT_PRESENT(lcontext))) {

CreateChild:
                        //
                        // Only unfound component is last one, and operation
                        // is a create, so perform the create.
                        //

                        //
                        // There are two possibilities here.  The normal one
                        // is that we are simply creating a new node.
                        //
                        // The abnormal one is that we are creating a root
                        // node that is linked to the main hive.  In this
                        // case, we must create the link.  Once the link is
                        // created, we can check to see if the root node
                        // exists, then either create it or open it as
                        // necessary.
                        //
                        // CmpCreateLinkNode creates the link, and calls
                        // back to CmpDoCreate or CmpDoOpen to create or open
                        // the root node as appropriate.
                        //

                        //
                        // either one of this will drop the reglock and reaquire it 
                        // exclusive; we need not to hurt ourselves, so release
                        // all cells here
                        //
                        CmpReleasePreviousAndHookNew(NULL,HCELL_NIL,HiveToRelease,CellToRelease);

                        if (lcontext->CreateLink) {
                            status = CmpCreateLinkNode(Hive,
                                                       Cell,
                                                       AccessState,
                                                       NextName,
                                                       AccessMode,
                                                       Attributes,
                                                       lcontext,
                                                       ParentKcb,
                                                       LockedKcbs,
                                                       Object);

                        } else {

                            if ( (Hive == &(CmpMasterHive->Hive)) &&
                                 (CmpNoMasterCreates == TRUE) ) {
                                //
                                // attempting to create a cell in the master
                                // hive, and not a link, so blow out of here,
                                // since it wouldn't work anyway.
                                //
                                status = STATUS_INVALID_PARAMETER;
                                break;
                            }

                            status = CmpDoCreate(Hive,
                                                 Cell,
                                                 AccessState,
                                                 &NextName,
                                                 AccessMode,
                                                 lcontext,
                                                 ParentKcb,
                                                 CmpParseGetOriginatingPoint(Context),
                                                 Object);
                        }

                        if( status == STATUS_REPARSE ) {
                            //
                            // somebody else created the key in between; 
                            // let the Object Manager work for us !!!
                            // now we have the lock exclusive, so nothing can happen in between 
                            // next iteration will find the key very quick
                            //
                            break;
                        }
                        lcontext->Disposition = REG_CREATED_NEW_KEY;
                        break;

                    } else {

                        //
                        // Did not find a key to match the component, and
                        // are not at the end of the path.  Thus, open must
                        // fail because the whole path dosn't exist, create must
                        // fail because more than 1 component doesn't exist.
                        //
                        //
                        // We have a lookup failure here, so having additional information
                        // about this kcb may help us not to go through all the code just to fail again.
                        // 
                        ParentKcb = CmpAddInfoAfterParseFailure(Hive,
                                                                Cell,
                                                                Node,
                                                                kcb,
                                                                &NextName
                                                                );
                        
                        status = STATUS_OBJECT_NAME_NOT_FOUND;
                        break;
                    }

                }

            } else {
                //
                // The given key was a symbolic link.  Find the name of
                // its link, and return STATUS_REPARSE to the Object Manager.
                //
                Current.Buffer = NextName.Buffer;
                if (Current.Length + NextName.Length > MAXUSHORT) {
                    status = STATUS_NAME_TOO_LONG;
                    break;
                }
                Current.Length = (USHORT)(Current.Length + NextName.Length);

                if (Current.MaximumLength + NextName.MaximumLength > MAXUSHORT) {
                    status = STATUS_NAME_TOO_LONG;
                    break;
                }
                Current.MaximumLength = (USHORT)(Current.MaximumLength + NextName.MaximumLength);
                //
                // need not to interfere with CmpGetSymbolicLink
                //
                CmpUnLockKcbArray(LockedKcbs,CmpHashTableSize);
                if( LockedKcbs != LocalFastKcbArray ) {
                    ExFreePool(LockedKcbs);
                }
                LockedKcbs = NULL;
                if (CmpGetSymbolicLink(Hive,
                                       CompleteName,
                                       kcb,
                                       &Current)) {

                    status = STATUS_REPARSE;
                    CmpParseRecordOriginatingPoint(Context,(PCMHIVE)kcb->KeyHive);
                    break;

                } else {
                    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpParseKey: couldn't find symbolic link name\n"));
                    status = STATUS_OBJECT_NAME_NOT_FOUND;
                    break;
                }
            }

        } else if (rc == TRUE && Last == TRUE) {
            //
            // We will open the \Registry root.
            // Or some strange remaining name that
            // messes up the lookup.
            //
            CmpStepThroughExit(Hive, Cell, Node,HiveToRelease,CellToRelease);
            if( Node == NULL ) {
                //
                // we couldn't map view for this cell
                //
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            //
            // We have found the entire path, so we want to open
            // it (for both Open and Create calls).
            // Hive,Cell -> the key we are supposed to open.
            //
            status = CmpDoOpen(Hive,
                               Cell,
                               Node,
                               AccessState,
                               AccessMode,
                               Attributes,
                               lcontext,
                               CMP_CREATE_KCB_KCB_LOCKED|CMP_DO_OPEN_COMPLETE_KEY_CACHED,
                               &kcb,
                               &NextName,
                               CmpParseGetOriginatingPoint(Context),
                               LockedKcbs,
                               Object,
                               NULL);
            if(status == STATUS_REPARSE ) {
                CmpParseRecordOriginatingPoint(Context,(PCMHIVE)kcb->KeyHive);
            }
            break;

        } else {

            //
            // bogus path -> fail
            //
            status = STATUS_INVALID_PARAMETER;
            break;
        }

    } // while

FreeAndReturn:
    //
    // Now we have to free the last kcb that still has one extra reference count to
    // protect it from being freed.
    //
    if( LockedKcbs != NULL ) {
        CmpUnLockKcbArray(LockedKcbs,CmpHashTableSize);
        if( LockedKcbs != LocalFastKcbArray ) {
            ExFreePool(LockedKcbs);
        }
        LockedKcbs = NULL;
    }

    if( ParentKcb != NULL ) {
        CmpDereferenceKeyControlBlock(ParentKcb);
    }
JustReturn:
    CmpReleasePreviousAndHookNew(NULL,HCELL_NIL,HiveToRelease,CellToRelease);
    if( LockedKcbs != NULL ) {
        CmpUnLockKcbArray(LockedKcbs,CmpHashTableSize);
        if( LockedKcbs != LocalFastKcbArray ) {
            ExFreePool(LockedKcbs);
        }
    }

    CmpUnlockRegistry();
    END_LOCK_CHECKPOINT;

    //
    // PostCreate callback. just a notification; disregard the return status
    //
    CmPostCallbackNotification((ARGUMENT_PRESENT(lcontext)?RegNtPostCreateKeyEx:RegNtPostOpenKeyEx),(*Object),status);

    return status;
}


BOOLEAN
CmpGetNextName(
    IN OUT PUNICODE_STRING  RemainingName,
    OUT    PUNICODE_STRING  NextName,
    OUT    PBOOLEAN  Last
    )
/*++

Routine Description:

    This routine parses off the next component of a registry path, returning
    all of the interesting state about it, including whether it's legal.

Arguments:

    Current - supplies pointer to variable which points to path to parse.
              on input - parsing starts from here
              on output - updated to reflect starting position for next call.

    NextName - supplies pointer to a unicode_string, which will be set up
               to point into the parse string.

    Last - supplies a pointer to a boolean - set to TRUE if this is the
           last component of the name being parse, FALSE otherwise.

Return Value:

    TRUE if all is well.

    FALSE if illegal name (too long component, bad character, etc.)
        (if false, all out parameter values are bogus.)

--*/
{
    BOOLEAN rc = TRUE;

    //
    // Deal with NULL paths, and pointers to NULL paths
    //
    if ((RemainingName->Buffer == NULL) || (RemainingName->Length == 0)) {
        *Last = TRUE;
        NextName->Buffer = NULL;
        NextName->Length = 0;
        return TRUE;
    }

    if (*(RemainingName->Buffer) == UNICODE_NULL) {
        *Last = TRUE;
        NextName->Buffer = NULL;
        NextName->Length = 0;
        return TRUE;
    }

    //
    // Skip over leading path separators
    //
    while (*(RemainingName->Buffer) == OBJ_NAME_PATH_SEPARATOR) {
        RemainingName->Buffer++;
        RemainingName->Length -= sizeof(WCHAR);
        RemainingName->MaximumLength -= sizeof(WCHAR);
    }

    //
    // Remember where the component starts, and scan to the end
    //
    NextName->Buffer = RemainingName->Buffer;
    while (TRUE) {
        if (RemainingName->Length == 0) {
            break;
        }
        if (*RemainingName->Buffer == OBJ_NAME_PATH_SEPARATOR) {
            break;
        }

        //
        // NOT at end
        // NOT another path sep
        //

        RemainingName->Buffer++;
        RemainingName->Length -= sizeof(WCHAR);
        RemainingName->MaximumLength -= sizeof(WCHAR);
    }

    //
    // Compute component length, return error if it's illegal
    //
    NextName->Length = (USHORT)
        ((PUCHAR)RemainingName->Buffer - (PUCHAR)(NextName->Buffer));
    if (NextName->Length > REG_MAX_KEY_NAME_LENGTH)
    {
        rc = FALSE;
    }
    NextName->MaximumLength = NextName->Length;

	//
    // Set last, return success
    //
    *Last = (RemainingName->Length == 0) ? TRUE : FALSE;
    return rc;
}

NTSTATUS
CmpDoOpen(
    IN PHHIVE                       Hive,
    IN HCELL_INDEX                  Cell,
    IN PCM_KEY_NODE                 Node,
    IN PACCESS_STATE                AccessState,
    IN KPROCESSOR_MODE              AccessMode,
    IN ULONG                        Attributes,
    IN PCM_PARSE_CONTEXT            Context OPTIONAL,
    IN ULONG                        ControlFlags,
    IN OUT PCM_KEY_CONTROL_BLOCK    *CachedKcb,
    IN PUNICODE_STRING              KeyName,
    IN PCMHIVE                      OriginatingHive OPTIONAL,
    IN PULONG                       KcbsLocked,
    OUT PVOID                       *Object,
    OUT PBOOLEAN                    NeedDeref OPTIONAL
    )
/*++

Routine Description:

    Open a registry key, create a keycontrol block.

Arguments:

    Hive - supplies a pointer to the hive control structure for the hive

    Cell - supplies index of node to delete

    AccessState - Running security access state information for operation.

    AccessMode - Access mode of the original caller.

    Attributes - Attributes to be applied to the object.

    Context - if create or hive root open, points to a CM_PARSE_CONTEXT
              structure,
              if open, is NULL.

    CompleteKeyCached - BOOLEAN to indicate it the completekey is cached.

    CachedKcb - If the completekey is cached, this is the kcb for the destination.
                If not, this is the parent kcb.

    KeyName - Relative name (to BaseName)

    Object - The address of a variable to receive the created key object, if
             any.

    NeedDeref - if specified, keep reference in the fake create kcb (link case). Caller
                is responsible to release the fake kcb after it finishes with it.

Return Value:

    NTSTATUS


--*/
{
    NTSTATUS status;
    PCM_KEY_BODY            pbody = NULL;
    PCM_KEY_CONTROL_BLOCK kcb = NULL;
    KPROCESSOR_MODE   mode;
    BOOLEAN BackupRestore;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpDoOpen:\n"));
    
    if( ARGUMENT_PRESENT(NeedDeref) ) {
        *NeedDeref = FALSE;
    }

    //
    // don't allow others to use this until it is up and running
    //
    if( (Hive->HiveFlags & HIVE_IS_UNLOADING) && (((PCMHIVE)Hive)->CreatorOwner != KeGetCurrentThread()) ) {
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    if (ARGUMENT_PRESENT(Context)) {

        //
        // It's a create of some sort
        //
        if (Context->CreateLink) {
            //
            // The node already exists as a regular key, so it cannot be
            // turned into a link node.
            //
            return STATUS_ACCESS_DENIED;

        } else if (Context->CreateOptions & REG_OPTION_CREATE_LINK) {
            //
            // Attempt to create a symbolic link has hit an existing key
            // so return an error
            //
            return STATUS_OBJECT_NAME_COLLISION;

        } else {
            //
            // Operation is an open, so set Disposition
            //
            Context->Disposition = REG_OPENED_EXISTING_KEY;
        }
    }

    ASSERT( ControlFlags&CMP_CREATE_KCB_KCB_LOCKED );
    //
    // Check for symbolic link and caller does not want to open a link
    //
    if(ControlFlags&CMP_DO_OPEN_COMPLETE_KEY_CACHED) {
        ASSERT_KCB_LOCKED(*CachedKcb);
    
        //
        // The complete key is cached.
        //
        if ((*CachedKcb)->Flags & KEY_SYM_LINK && !(Attributes & OBJ_OPENLINK)) {
            //
            // If the key is a symbolic link, check if the link has been resolved.
            // If the link is resolved, change the kcb to the real KCB.
            // Otherwise, return for reparse.
            //
            if ((*CachedKcb)->ExtFlags & CM_KCB_SYM_LINK_FOUND) {
                kcb = (*CachedKcb)->ValueCache.RealKcb;
                
                ASSERT( KcbsLocked );
                //
                // deadlock avoidance; unlock all locked kcbs and lock the symbolic one
                // store the index in the array; caller will take care of unlock
                //
                CmpUnLockKcbArray(KcbsLocked,CmpHashTableSize);
                KcbsLocked[0] = 1; //just this
                KcbsLocked[1] = GET_HASH_INDEX(kcb->ConvKey);
                CmpLockHashEntryByIndexExclusive(KcbsLocked[1]);

                if (kcb->Delete == TRUE) {
                    //
                    // The real key it points to had been deleted.
                    // We have no way of knowing if the key has been recreated.
                    // Just clean up the cache and do a reparse.
                    //
                    CmpUnlockHashEntryByIndex(KcbsLocked[1]);
                    KcbsLocked[1] = GET_HASH_INDEX((*CachedKcb)->ConvKey);
                    CmpLockHashEntryByIndexExclusive(KcbsLocked[1]);
                    CmpCleanUpKcbValueCache(*CachedKcb);
                    return(STATUS_REPARSE);
                }
            } else {
                return(STATUS_REPARSE);
            }
        } else {
            //
            // Not a symbolic link, increase the reference Count of Kcb.
            //
            kcb = *CachedKcb;
        }
        // common path instead of repeating code
        if (!CmpReferenceKeyControlBlock(kcb)) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
   } else {
            //
            // The key is not in cache, the CachedKcb is the parentkcb of this
            // key to be opened.
            //
        ASSERT_KCB_LOCKED_EXCLUSIVE(*CachedKcb);

        if (Node->Flags & KEY_SYM_LINK && !(Attributes & OBJ_OPENLINK)) {
            //
            // Create a KCB for this symbolic key and put it in delay close.
            //
            kcb = CmpCreateKeyControlBlock(Hive, Cell, Node, *CachedKcb,CMP_CREATE_KCB_KCB_LOCKED, KeyName);
            if (kcb  == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            ASSERT_KCB_LOCKED_EXCLUSIVE(kcb);
            if( ARGUMENT_PRESENT(NeedDeref) ) {
                //
                // caller will perform deref.
                //
                *NeedDeref = TRUE;
            } else {
                CmpDereferenceKeyControlBlockWithLock(kcb,FALSE);
            }
            *CachedKcb = kcb;
            return(STATUS_REPARSE);
        }
    
        //
        // If key control block does not exist, and cannot be created, fail,
        // else just increment the ref count (done for us by CreateKeyControlBlock)
        //
        kcb = CmpCreateKeyControlBlock(Hive, Cell, Node, *CachedKcb,CMP_CREATE_KCB_KCB_LOCKED, KeyName);
        if (kcb  == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
   
        ASSERT_KCB_LOCKED_EXCLUSIVE(kcb);
        *CachedKcb = kcb;
    }

#if DBG
   if( kcb->ExtFlags & CM_KCB_KEY_NON_EXIST ) {
        //
        // we shouldn't fall into this
        //
        DbgBreakPoint();
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }
#endif // DBG
   
   if(!CmpOKToFollowLink(OriginatingHive,(PCMHIVE)Hive) ) {
       //
       // about to cross class of trust boundary
       //
       status = STATUS_ACCESS_DENIED;
   } else {
        //
        // Allocate the object.
        //
        status = ObCreateObject(AccessMode,
                                CmpKeyObjectType,
                                NULL,
                                AccessMode,
                                NULL,
                                sizeof(CM_KEY_BODY),
                                0,
                                0,
                                Object);
   }
    if (NT_SUCCESS(status)) {

        pbody = (PCM_KEY_BODY)(*Object);

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_POOL,"CmpDoOpen: object allocated at:%p\n", pbody));

        //
        // Check for predefined handle
        //

        pbody = (PCM_KEY_BODY)(*Object);

        if (kcb->Flags & KEY_PREDEF_HANDLE) {
            pbody->Type = kcb->ValueCache.Count;
            pbody->KeyControlBlock = kcb;
            return(STATUS_PREDEFINED_HANDLE);
        } else {
            //
            // Fill in CM specific fields in the object
            //
            pbody->Type = KEY_BODY_TYPE;
            pbody->KeyControlBlock = kcb;
            pbody->NotifyBlock = NULL;
            pbody->ProcessID = PsGetCurrentProcessId();
            EnlistKeyBodyWithKCB(pbody,(ControlFlags&CMP_DO_OPEN_COMPLETE_KEY_CACHED)? CMP_ENLIST_KCB_LOCKED_SHARED : CMP_ENLIST_KCB_LOCKED_EXCLUSIVE);
        }

    } else {

        //
        // Failed to create object, so undo key control block work
        //
#if DBG
        if(ControlFlags&CMP_DO_OPEN_COMPLETE_KEY_CACHED) {
            ASSERT_KCB_LOCKED(kcb);
        } else {
            ASSERT_KCB_LOCKED_EXCLUSIVE(kcb);
        }
#endif
        CmpDereferenceKeyControlBlockWithLock(kcb,FALSE);
        return status;
    }

    //
    // Check to make sure the caller can access the key.
    //
    BackupRestore = FALSE;
    if (ARGUMENT_PRESENT(Context)) {
        if (Context->CreateOptions & REG_OPTION_BACKUP_RESTORE) {
            BackupRestore = TRUE;
        }
    }

    status = STATUS_SUCCESS;

    if (BackupRestore == TRUE) {

        //
        // this is an open to support a backup or restore
        // operation, do the special case work
        //
        AccessState->RemainingDesiredAccess = 0;
        AccessState->PreviouslyGrantedAccess = 0;

        mode = KeGetPreviousMode();

        if (SeSinglePrivilegeCheck(SeBackupPrivilege, mode)) {
            AccessState->PreviouslyGrantedAccess |=
                KEY_READ | ACCESS_SYSTEM_SECURITY;
        }

        if (SeSinglePrivilegeCheck(SeRestorePrivilege, mode)) {
            AccessState->PreviouslyGrantedAccess |=
                KEY_WRITE | ACCESS_SYSTEM_SECURITY | WRITE_DAC | WRITE_OWNER;
        }

        if (AccessState->PreviouslyGrantedAccess == 0) {
            //
            // relevant privileges not asserted/possessed, so
            // deref (which will cause CmpDeleteKeyObject to clean up)
            // and return an error.
            //
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpDoOpen for backup restore: access denied\n"));
            ObDereferenceObjectDeferDelete(*Object);
            return STATUS_ACCESS_DENIED;
        }

    } else {
        BOOLEAN AllowAccess;
        //
        // trick; last bit set means kcb locked exclusive
        //
        ASSERT( pbody );
        pbody->KeyControlBlock = (PCM_KEY_CONTROL_BLOCK)((ULONG_PTR)pbody->KeyControlBlock + 1);

        AllowAccess = ObCheckObjectAccess(*Object,
                                  AccessState,
                                  TRUE,         // Type mutex already locked
                                  AccessMode,
                                  &status);
        pbody->KeyControlBlock = (PCM_KEY_CONTROL_BLOCK)((ULONG_PTR)pbody->KeyControlBlock ^ 1);
        if (!AllowAccess) {
            //
            // Access denied, so deref object, will cause CmpDeleteKeyObject
            // to be called, it will clean up.
            //
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpDoOpen: access denied\n"));
            ObDereferenceObjectDeferDelete(*Object);
        }
    }

    return status;
}

NTSTATUS
CmpCreateLinkNode(
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell,
    IN PACCESS_STATE AccessState,
    IN UNICODE_STRING Name,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN PCM_PARSE_CONTEXT Context,
    IN PCM_KEY_CONTROL_BLOCK ParentKcb,
    IN PULONG                   LockedKcbs,
    OUT PVOID *Object
    )
/*++

Routine Description:

    Perform the creation of a link node.  Allocate all components,
    and attach to parent key.  Calls CmpDoCreate or CmpDoOpen to
    create or open the root node of the hive as appropriate.

    Note that you can only create link nodes in the master hive.

Arguments:

    Hive - supplies a pointer to the hive control structure for the hive

    Cell - supplies index of node to create child under

    Name - supplies pointer to a UNICODE string which is the name of
            the child to be created.

    AccessMode - Access mode of the original caller.

    Attributes - Attributes to be applied to the object.

    Context - pointer to CM_PARSE_CONTEXT structure passed through
                the object manager

    BaseName - Name of object create is relative to

    KeyName - Relative name (to BaseName)

    Object - The address of a variable to receive the created key object, if
             any.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                Status;
    PCELL_DATA              Parent;
    PCELL_DATA              Link;
    PCELL_DATA              CellData;
    HCELL_INDEX             LinkCell;
    HCELL_INDEX             KeyCell;
    HCELL_INDEX             ChildCell;
    PCM_KEY_CONTROL_BLOCK   kcb = ParentKcb;  
    PCM_KEY_BODY            KeyBody;
    LARGE_INTEGER           systemtime;
    PCM_KEY_NODE            TempNode;
#if DBG
    ULONG                   ChildConvKey;
#endif

    ASSERT_CM_LOCK_OWNED();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpCreateLinkNode:\n"));

    if (Hive != &CmpMasterHive->Hive) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpCreateLinkNode: attempt to create link node in\n"));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"    non-master hive %p\n", Hive));
        return(STATUS_ACCESS_DENIED);
    }

#if DBG
    //
    // debug only code
    //
    *Object = NULL;
#endif
#if DBG
    ChildConvKey = ParentKcb->ConvKey;

    if (Name.Length) {
        ULONG                   Cnt;
        WCHAR                   *Cp;
        Cp = Name.Buffer;
        for (Cnt=0; Cnt<Name.Length; Cnt += sizeof(WCHAR)) {
            //
            // UNICODE_NULL is a valid char !!!
            //
            if (*Cp != OBJ_NAME_PATH_SEPARATOR) {
                //(*Cp != UNICODE_NULL)) {
                ChildConvKey = 37 * ChildConvKey + (ULONG)CmUpcaseUnicodeChar(*Cp);
            }
            ++Cp;
        }
    }
    
    ASSERT_HASH_ENTRY_LOCKED_EXCLUSIVE(ChildConvKey);
    ASSERT_KCB_LOCKED_EXCLUSIVE(ParentKcb);
#endif
    // no flush while we are doing this
    CmpLockHiveFlusherShared((PCMHIVE)Hive);
    CmpLockHiveFlusherShared((PCMHIVE)Context->ChildHive.KeyHive);
    //
    // this is a create, so we need exclusive access on the registry
    // first get the time stamp to see if somebody messed with this key
    // this might be more easier if we decide to cache the LastWriteTime
    // in the KCB ; now it IS !!!
    //
    if( CmIsKcbReadOnly(ParentKcb) ) {
        //
        // key is protected
        //
        Status = STATUS_ACCESS_DENIED;
        goto Exit;
    } 

    //
    // make sure nothing changed in between:
    //  1. ParentKcb is still valid
    //  2. Child was not already added by somebody else 
    //
    if( ParentKcb->Delete ) {
        //
        // key was deleted in between
        //
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto Exit;
    }

    //
    // Allocate link node
    //
    // Link nodes are always in the master hive, so their storage type is
    // mostly irrelevant.
    //
    LinkCell = HvAllocateCell(Hive,  CmpHKeyNodeSize(Hive, &Name), Stable,HCELL_NIL);
    if (LinkCell == HCELL_NIL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    KeyCell = Context->ChildHive.KeyCell;

    if (KeyCell != HCELL_NIL) {

        //
        // This hive already exists, so we just need to open the root node.
        //
        ChildCell=KeyCell;

        //
        // The root cell in the hive does not has the Name buffer 
        // space reserved.  This is why we need to pass in the Name for creating KCB
        // instead of using the name in the keynode.
        //
        CellData = HvGetCell(Context->ChildHive.KeyHive, ChildCell);
        if( CellData == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            HvFreeCell(Hive, LinkCell);
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }
        
        CellData->u.KeyNode.Parent = LinkCell;
        CellData->u.KeyNode.Flags |= KEY_HIVE_ENTRY | KEY_NO_DELETE;
        HvReleaseCell(Context->ChildHive.KeyHive, ChildCell);
        
        TempNode = (PCM_KEY_NODE)HvGetCell(Context->ChildHive.KeyHive,KeyCell);
        if( TempNode == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            HvFreeCell(Hive, LinkCell);
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }

        Status = CmpDoOpen( Context->ChildHive.KeyHive,
                            KeyCell,
                            TempNode,
                            AccessState,
                            AccessMode,
                            Attributes,
                            NULL,
                            CMP_CREATE_KCB_KCB_LOCKED,
                            &kcb,
                            &Name,
                            CmpParseGetOriginatingPoint(Context),
                            LockedKcbs,
                            Object,
                            NULL);
        HvReleaseCell(Context->ChildHive.KeyHive,KeyCell);
    } else {

        //
        // This is a newly created hive, so we must allocate and initialize
        // the root node.
        //

        Status = CmpDoCreateChild( Context->ChildHive.KeyHive,
                                   Cell,
                                   NULL,
                                   AccessState,
                                   &Name,
                                   AccessMode,
                                   Context,
                                   ParentKcb,
                                   KEY_HIVE_ENTRY | KEY_NO_DELETE,
                                   &ChildCell,
                                   Object );

        if (NT_SUCCESS(Status)) {

            //
            // Initialize hive root cell pointer.
            //

            Context->ChildHive.KeyHive->BaseBlock->RootCell = ChildCell;
        }

    }
    if (NT_SUCCESS(Status)) {

        //
        // Initialize parent and flags.  Note that we do this whether the
        // root has been created or opened, because we are not guaranteed
        // that the link node is always the same cell in the master hive.
        //
        if (!HvMarkCellDirty(Context->ChildHive.KeyHive, ChildCell, FALSE)) {
            Status = STATUS_NO_LOG_SPACE;
            goto Cleanup;
        }
        CellData = HvGetCell(Context->ChildHive.KeyHive, ChildCell);
        if( CellData == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            HvFreeCell(Hive, LinkCell);
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        
        // release the cell right here as the view is already pinned
        HvReleaseCell(Context->ChildHive.KeyHive, ChildCell);

        CellData->u.KeyNode.Parent = LinkCell;
        CellData->u.KeyNode.Flags |= KEY_HIVE_ENTRY | KEY_NO_DELETE;

        //
        // Initialize special link node flags and data
        //
        Link = HvGetCell(Hive, LinkCell);
        if( Link == NULL ) {
            //
            // we couldn't map the bin containing this cell
            // this shouldn't happen as we just allocated this cell
            // (i.e. it should be PINNED in memory at this point)
            //
            ASSERT( FALSE );
            HvFreeCell(Hive, LinkCell);
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        Link->u.KeyNode.Signature = CM_LINK_NODE_SIGNATURE;
        Link->u.KeyNode.Flags = KEY_HIVE_EXIT | KEY_NO_DELETE;
        Link->u.KeyNode.Parent = Cell;
        Link->u.KeyNode.NameLength = CmpCopyName(Hive, Link->u.KeyNode.Name, &Name);
        if (Link->u.KeyNode.NameLength < Name.Length) {
            Link->u.KeyNode.Flags |= KEY_COMP_NAME;
        }

        KeQuerySystemTime(&systemtime);
        Link->u.KeyNode.LastWriteTime = systemtime;

        //
        // Zero out unused fields.
        //
        Link->u.KeyNode.SubKeyCounts[Stable] = 0;
        Link->u.KeyNode.SubKeyCounts[Volatile] = 0;
        Link->u.KeyNode.SubKeyLists[Stable] = HCELL_NIL;
        Link->u.KeyNode.SubKeyLists[Volatile] = HCELL_NIL;
        Link->u.KeyNode.ValueList.Count = 0;
        Link->u.KeyNode.ValueList.List = HCELL_NIL;
        Link->u.KeyNode.ClassLength = 0;


        //
        // Fill in the link node's pointer to the root node
        //
        Link->u.KeyNode.ChildHiveReference.KeyHive = Context->ChildHive.KeyHive;
        Link->u.KeyNode.ChildHiveReference.KeyCell = ChildCell;

        HvReleaseCell(Hive,LinkCell);
        //
        // get the parent first, we don't need to do unnecessary cleanup
        //
        Parent = HvGetCell(Hive, Cell);
        if( Parent == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            HvFreeCell(Hive, LinkCell);
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Fill in the parent cell's child list
        //
        if (! CmpAddSubKey(Hive, Cell, LinkCell)) {
            HvReleaseCell(Hive,Cell);
            HvFreeCell(Hive, LinkCell);
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // If the parent has the subkey info or hint cached, free it.
        //
        KeyBody = (PCM_KEY_BODY)(*Object);
        CmpCleanUpSubKeyInfo (KeyBody->KeyControlBlock->ParentKcb);

        //
        // Update max keyname and class name length fields
        //

        //
        // It seems to me that the original code is wrong.
        // Isn't the definition of MaxNameLen just the length of the subkey?
        //
        
        // some sanity asserts
        ASSERT( KeyBody->KeyControlBlock->ParentKcb->KeyCell == Cell );
        ASSERT( KeyBody->KeyControlBlock->ParentKcb->KeyHive == Hive );
        ASSERT( KeyBody->KeyControlBlock->ParentKcb->KcbMaxNameLen == Parent->u.KeyNode.MaxNameLen );
        
        //
        // update the LastWriteTime on both keynode and kcb;
        //
        KeQuerySystemTime(&systemtime);
        Parent->u.KeyNode.LastWriteTime = systemtime;
        KeyBody->KeyControlBlock->ParentKcb->KcbLastWriteTime = systemtime;

        if (Parent->u.KeyNode.MaxNameLen < Name.Length) {
            Parent->u.KeyNode.MaxNameLen = Name.Length;
            KeyBody->KeyControlBlock->ParentKcb->KcbMaxNameLen = Name.Length;
        }

        if (Parent->u.KeyNode.MaxClassLen < Context->Class.Length) {
            Parent->u.KeyNode.MaxClassLen = Context->Class.Length;
        }
        HvReleaseCell(Hive,Cell);
Cleanup:
        if( !NT_SUCCESS(Status) ) {
            ASSERT( (*Object) != NULL );
            //
            // mark the kcb as "no-delay-close" so it gets kicked out of cache when 
            // refcount goes down to 0
            //
            KeyBody = (PCM_KEY_BODY)(*Object);

            ASSERT_KCB_LOCKED_EXCLUSIVE(KeyBody->KeyControlBlock);
            ASSERT( KeyBody->KeyControlBlock );
            ASSERT_KCB( KeyBody->KeyControlBlock );
            KeyBody->KeyControlBlock->ExtFlags |= CM_KCB_NO_DELAY_CLOSE;
            KeyBody->KeyControlBlock->Delete = TRUE;
            CmpRemoveKeyControlBlock(KeyBody->KeyControlBlock);
            KeyBody->KeyControlBlock->KeyCell = HCELL_NIL;
            ObDereferenceObjectDeferDelete(*Object);
        }

    } else {
        HvFreeCell(Hive, LinkCell);
    }

Exit:
    CmpUnlockHiveFlusher((PCMHIVE)Context->ChildHive.KeyHive);
    CmpUnlockHiveFlusher((PCMHIVE)Hive);
    return Status;
}

BOOLEAN
CmpGetSymbolicLink(
    IN PHHIVE Hive,
    IN OUT PUNICODE_STRING ObjectName,
    IN OUT PCM_KEY_CONTROL_BLOCK SymbolicKcb,
    IN PUNICODE_STRING RemainingName OPTIONAL
    )

/*++

Routine Description:

    This routine extracts the symbolic link name from a key, if it is
    marked as a symbolic link.

Arguments:

    Hive - Supplies the hive of the key.

    ObjectName - Supplies the current ObjectName.
                 Returns the new ObjectName.  If the new name is longer
                 than the maximum length of the current ObjectName, the
                 old buffer will be freed and a new buffer allocated.

    RemainingName - Supplies the remaining path.  If present, this will be
                concatenated with the symbolic link to form the new objectname.

Return Value:

    TRUE - symbolic link succesfully found

    FALSE - Key is not a symbolic link, or an error occurred

--*/

{
    NTSTATUS                Status;
    HCELL_INDEX             LinkCell = HCELL_NIL;
    PCM_KEY_VALUE           LinkValue = NULL;
    PWSTR                   LinkName = NULL;
    BOOLEAN                 LinkNameAllocated = FALSE;
    PWSTR                   NewBuffer;
    ULONG                   Length = 0;
    ULONG                   ValueLength = 0;
    PUNICODE_STRING         ConstructedName = NULL;
    ULONG                   ConvKey=0;
    PCM_KEY_HASH            KeyHash;
    PCM_KEY_CONTROL_BLOCK   RealKcb;
    BOOLEAN                 KcbFound = FALSE;
    ULONG                   Cnt;
    WCHAR                   *Cp;
    WCHAR                   *Cp2;
    ULONG                   TotalLevels;
    BOOLEAN                 FreeConstructedName = FALSE;
    BOOLEAN                 Result = TRUE;
    HCELL_INDEX             CellToRelease = HCELL_NIL;
    ULONG                   ConvKey1 = 0;
    ULONG                   ConvKey2 = 0;
    BOOLEAN                 BothHashesLocked = FALSE;
    BOOLEAN                 UnlockConvKey1 = FALSE;

    
    //
    ConvKey1 = SymbolicKcb->ConvKey;
    CmpLockKCBExclusive(SymbolicKcb);
Again:
    if( SymbolicKcb->Delete ) {
        if( !BothHashesLocked ) {
            CmpUnlockKCB(SymbolicKcb);
        } else {
            CmpUnlockTwoHashEntries(ConvKey1,ConvKey2);
        }
        return FALSE;
    }
    if (SymbolicKcb->ExtFlags & CM_KCB_SYM_LINK_FOUND) {
        if( !BothHashesLocked ) {
            ConvKey2 = SymbolicKcb->ValueCache.RealKcb->ConvKey;
            CmpUnlockKCB(SymbolicKcb);
            CmpLockTwoHashEntriesExclusive(ConvKey1,ConvKey2);
            BothHashesLocked = TRUE;
            goto Again;
        }
        //
        // First see of the real kcb for this symbolic name has been found
        // 
        ConstructedName = CmpConstructName(SymbolicKcb->ValueCache.RealKcb);
        if (ConstructedName) {
            FreeConstructedName = TRUE;
            LinkName = ConstructedName->Buffer;
            ValueLength = ConstructedName->Length;
            Length = (USHORT)ValueLength + sizeof(WCHAR);
        }
    } 
    // we still need symbolicLink to reach to the name
    if( BothHashesLocked && (GET_HASH_INDEX(ConvKey1) != GET_HASH_INDEX(ConvKey2)) ) {
        CmpUnlockHashEntry(ConvKey2);
    }
    UnlockConvKey1 = TRUE;

    if (FreeConstructedName == FALSE) {
        PCM_KEY_NODE Node;
        ASSERT_KCB_LOCKED(SymbolicKcb);
        //
        // Find the SymbolicLinkValue value.  This is the name of the symbolic link.
        //
        Node = (PCM_KEY_NODE)HvGetCell(SymbolicKcb->KeyHive,SymbolicKcb->KeyCell);
        if( Node == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            Result = FALSE;
            goto Exit;
        }

        LinkCell = CmpFindValueByName(Hive,
                                      Node,
                                      &CmSymbolicLinkValueName);
        // release the node here as we don't need it anymore
        HvReleaseCell(SymbolicKcb->KeyHive,SymbolicKcb->KeyCell);
        if (LinkCell == HCELL_NIL) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpGetSymbolicLink: couldn't open symbolic link\n"));
            Result = FALSE;
            goto Exit;
        }
    
        LinkValue = (PCM_KEY_VALUE)HvGetCell(Hive, LinkCell);
        if( LinkValue == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            Result = FALSE;
            goto Exit;
        }
    
            if (LinkValue->Type != REG_LINK) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpGetSymbolicLink: link value is wrong type: %08lx", LinkValue->Type));
            Result = FALSE;
            goto Exit;
        }
    

        if( CmpGetValueData(Hive,LinkValue,&ValueLength,&LinkName,&LinkNameAllocated,&CellToRelease) == FALSE ) {
            //
            // insufficient resources; return NULL
            //
            ASSERT( LinkNameAllocated == FALSE );
            ASSERT( LinkName == NULL );
            Result = FALSE;
            goto Exit;
        }
    
        Length = (USHORT)ValueLength + sizeof(WCHAR);

        //
        // Now see if we have this kcb cached.
        //
        Cp = LinkName;
        //
        // first char SHOULD be OBJ_NAME_PATH_SEPARATOR, otherwise we could get into real trouble!!!
        //
        if( *Cp != OBJ_NAME_PATH_SEPARATOR ) {
            Result = FALSE;
            goto Exit;
        }

        TotalLevels = 0;
        for (Cnt=0; Cnt<ValueLength; Cnt += sizeof(WCHAR)) {
            if (*Cp != OBJ_NAME_PATH_SEPARATOR) {
                ConvKey = 37 * ConvKey + (ULONG) CmUpcaseUnicodeChar(*Cp);
            } else {
                TotalLevels++;
            }
            ++Cp;
        }

        CmpUnlockHashEntry(ConvKey1);
        UnlockConvKey1 = FALSE;
        //
        // lock symbolickcb in advance
        //
        CmpLockTwoHashEntriesExclusive(ConvKey,SymbolicKcb->ConvKey);
        if( SymbolicKcb->Delete ) {
            CmpUnlockTwoHashEntries(ConvKey,SymbolicKcb->ConvKey);
            Result = FALSE;
            goto Exit;
        }
        KeyHash = GET_KCB_HASH_ENTRY(CmpCacheTable, ConvKey); 

        while (KeyHash) {
            RealKcb =  CONTAINING_RECORD(KeyHash, CM_KEY_CONTROL_BLOCK, KeyHash);
            if ((ConvKey == KeyHash->ConvKey) && (TotalLevels == RealKcb->TotalLevels) && (!(RealKcb->ExtFlags & CM_KCB_KEY_NON_EXIST)) ) {
                ConstructedName = CmpConstructName(RealKcb);
                if (ConstructedName) {
                    FreeConstructedName = TRUE;
                    if (ConstructedName->Length == ValueLength) {
                        KcbFound = TRUE;
                        Cp = LinkName;
                        Cp2 = ConstructedName->Buffer;
                        for (Cnt=0; Cnt<ConstructedName->Length; Cnt += sizeof(WCHAR)) {
                            if (CmUpcaseUnicodeChar(*Cp) != CmUpcaseUnicodeChar(*Cp2)) {
                                KcbFound = FALSE;
                                break;
                            }
                            ++Cp;
                            ++Cp2;
                        }
                        if (KcbFound) {
                            //
                            // Now the RealKcb is also pointed to by its symbolic link Kcb,
                            // Increase the reference count.
                            // Need to dereference the realkcb when the symbolic kcb is removed.
                            // Do this in CmpCleanUpKcbCacheWithLock();
                            //
                            if (CmpReferenceKeyControlBlock(RealKcb)) {
                                if( CmpOKToFollowLink( (((PCMHIVE)(SymbolicKcb->KeyHive))->Flags&CM_CMHIVE_FLAG_UNTRUSTED)?(PCMHIVE)(SymbolicKcb->KeyHive):NULL,
                                                    (PCMHIVE)(RealKcb->KeyHive))) {
                                    //
                                    // This symbolic kcb may have value lookup for the path
                                    // Cleanup the value cache.
                                    //
                                    CmpCleanUpKcbValueCache(SymbolicKcb);

                                    SymbolicKcb->ExtFlags |= CM_KCB_SYM_LINK_FOUND;
                                    SymbolicKcb->ValueCache.RealKcb = RealKcb;
                                } else {
                                    //
                                    // let go of the extra ref and break
                                    //
                                    CmpDereferenceKeyControlBlockWithLock(RealKcb,FALSE);
                                    break;
                                }
                            } else {
                                //
                                // We have maxed out the ref count on the real kcb.
                                // do not cache the symbolic link.
                                //
                            }
                            break;
                        }
                    }
                } else {
                    break;
                }
            }
            if (FreeConstructedName) {
                ExFreePoolWithTag(ConstructedName, CM_NAME_TAG | PROTECTED_POOL);
                FreeConstructedName = FALSE;
            }
            KeyHash = KeyHash->NextHash;
        }
        CmpUnlockTwoHashEntries(ConvKey,SymbolicKcb->ConvKey);
    }
    
    if (ARGUMENT_PRESENT(RemainingName)) {
        Length += RemainingName->Length + sizeof(WCHAR);
    }

    //
    // Overflow test: If Length overflows the USHRT_MAX value
    //                cleanup and return FALSE  
    //
    if( Length>0xFFFF ) {
        Result = FALSE;
        goto Exit;
    }

	if (Length > ObjectName->MaximumLength) {
        UNICODE_STRING NewObjectName;

        //
        // The new name is too long to fit in the existing ObjectName buffer,
        // so allocate a new buffer.
        //
        NewBuffer = ExAllocatePool(PagedPool, Length);
        if (NewBuffer == NULL) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpGetSymbolicLink: couldn't allocate new name buffer\n"));
            Result = FALSE;
            goto Exit;
        }

        NewObjectName.Buffer = NewBuffer;
#pragma prefast(suppress:12005, "overflow test already done above")
        NewObjectName.MaximumLength = (USHORT)Length;
        NewObjectName.Length = (USHORT)ValueLength;
        RtlCopyMemory(NewBuffer, LinkName, ValueLength);
#if DBG
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpGetSymbolicLink: LinkName is %wZ\n", ObjectName));
        if (ARGUMENT_PRESENT(RemainingName)) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"               RemainingName is %wZ\n", RemainingName));
        } else {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"               RemainingName is NULL\n"));
        }
#endif
        if (ARGUMENT_PRESENT(RemainingName)) {
            NewBuffer[ ValueLength / sizeof(WCHAR) ] = OBJ_NAME_PATH_SEPARATOR;
            NewObjectName.Length += sizeof(WCHAR);
            Status = RtlAppendUnicodeStringToString(&NewObjectName, RemainingName);
            ASSERT(NT_SUCCESS(Status));
        }

        ExFreePool(ObjectName->Buffer);
        *ObjectName = NewObjectName;
    } else {
        //
        // The new name will fit within the maximum length of the existing
        // ObjectName, so do the expansion in-place. Note that the remaining
        // name must be moved into its new position first since the symbolic
        // link may or may not overlap it.
        //
        ObjectName->Length = (USHORT)ValueLength;
        if (ARGUMENT_PRESENT(RemainingName)) {
            RtlMoveMemory(&ObjectName->Buffer[(ValueLength / sizeof(WCHAR)) + 1],
                          RemainingName->Buffer,
                          RemainingName->Length);
            ObjectName->Buffer[ValueLength / sizeof(WCHAR)] = OBJ_NAME_PATH_SEPARATOR;
            ObjectName->Length += RemainingName->Length + sizeof(WCHAR);
        }
        RtlCopyMemory(ObjectName->Buffer, LinkName, ValueLength);
    }
    ObjectName->Buffer[ObjectName->Length / sizeof(WCHAR)] = UNICODE_NULL;

Exit:
    if( UnlockConvKey1 ) {
        CmpUnlockHashEntry(ConvKey1);
    }
    if( LinkNameAllocated ) {
        ExFreePool(LinkName);
    }
    if (FreeConstructedName) {
        ExFreePoolWithTag(ConstructedName, CM_NAME_TAG | PROTECTED_POOL);
    }

    if( LinkValue != NULL ) {
        ASSERT( LinkCell != HCELL_NIL );
        HvReleaseCell(Hive,LinkCell);
    }
    if( CellToRelease != HCELL_NIL ) {
        HvReleaseCell(Hive,CellToRelease);
    }
    return Result;
}


ULONG
CmpComputeHashValue(
    IN PCM_HASH_ENTRY HashStack,
    IN OUT ULONG  *TotalSubkeys,
    IN ULONG BaseConvKey,
    IN PUNICODE_STRING RemainingName
    )

/*++

Routine Description:

    This routine parses the complete path of a request registry key and calculate
    the hash value at each level.

Arguments:

    HashStack - Array for filling the hash value of each level.

    TotalSubkeys - a pointer to fill the total number of subkeys

    BaseConvKey - Supplies the convkey for the base key.

    RemainingName - supplies pointer to a unicode_string for RemainingName.

Return Value:

    Number of Levels in RemainingName

--*/

{
    ULONG  TotalRemainingSubkeys=0;
    ULONG  TotalKeys=0;
    ULONG  ConvKey=BaseConvKey;
    USHORT  Cnt;
    WCHAR *Cp;
    WCHAR *Begin;
    USHORT Length;

    if (RemainingName->Length) {
        Cp = RemainingName->Buffer;
        Cnt = RemainingName->Length;

        // Skip the leading OBJ_NAME_PATH_SEPARATOR

        while (*Cp == OBJ_NAME_PATH_SEPARATOR) {
            Cp++;
            Cnt -= sizeof(WCHAR);
        }
        Begin = Cp;
        Length = 0;

        HashStack[TotalRemainingSubkeys].KeyName.Buffer = Cp;

        while (Cnt) {
            if (*Cp == OBJ_NAME_PATH_SEPARATOR) {
                if (TotalRemainingSubkeys < CM_HASH_STACK_SIZE) {
                    HashStack[TotalRemainingSubkeys].ConvKey = ConvKey;
                    //
                    // Due to the changes in KCB structure, we now only have the subkey name
                    // in the kcb (not the full path).  Change the name in the stack to store
                    // the parse element (each subkey) only.
                    //
                    HashStack[TotalRemainingSubkeys].KeyName.Length = Length;
                    Length = 0;
                    TotalRemainingSubkeys++;
                }

                TotalKeys++;

                //
                // Now skip over leading path separators
                // Just in case someone has a RemainingName '..A\\\\B..'
                //
                //
                // We are stripping all OBJ_NAME_PATH_SEPARATOR (The original code keep the first one).
                // so the KeyName.Buffer is set properly.
                //
                while(*Cp == OBJ_NAME_PATH_SEPARATOR) {
                    Cp++;
                    Cnt -= sizeof(WCHAR);
                }
                if (TotalRemainingSubkeys < CM_HASH_STACK_SIZE) {
                    HashStack[TotalRemainingSubkeys].KeyName.Buffer = Cp;
                }

            } else {
                ConvKey = 37 * ConvKey + (ULONG) CmUpcaseUnicodeChar(*Cp);
                //
                // We are stripping all OBJ_NAME_PATH_SEPARATOR in the above code,
                // we should only move to the next char in the else case.
                //
                Cp++;
                Cnt -= sizeof(WCHAR);
                Length += sizeof(WCHAR);
            
            }


        }

        //
        // Since we have stripped off all trailing path separators in CmpParseKey routine,
        // the last char will not be OBJ_NAME_PATH_SEPARATOR.
        //
        if (TotalRemainingSubkeys < CM_HASH_STACK_SIZE) {
            HashStack[TotalRemainingSubkeys].ConvKey = ConvKey;
            HashStack[TotalRemainingSubkeys].KeyName.Length = Length;
            TotalRemainingSubkeys++;
        }
        TotalKeys++;

        (*TotalSubkeys) = TotalKeys;
    }

    return(TotalRemainingSubkeys);
}
NTSTATUS
CmpCacheLookup(
    IN PCM_HASH_ENTRY HashStack,
    IN ULONG TotalRemainingSubkeys,
    OUT ULONG *MatchRemainSubkeyLevel,
    IN OUT PCM_KEY_CONTROL_BLOCK *Kcb,
    OUT PUNICODE_STRING RemainingName,
    OUT PHHIVE *Hive,
    OUT HCELL_INDEX *Cell,
    IN PULONG   OuterStackArray
    )
/*++

Routine Description:

    This routine Search the cache to find the matching path in the Cache.

Arguments:

    HashStack - Array that has the hash value of each level.

    TotalRemainingSubkeys - Total Subkey counts from base.

    MatchRemainSubkeyLevel - Number of Levels in RemaingName 
                             that matches. (0 if not found)

    kcb - Pointer to the kcb of the basename.
          Will be changed to the kcb for the new basename.

    RemainingName - Returns remaining name

    Hive - Returns the hive of the cache entry found (if any)

    Cell - Returns the cell of the cache entry found (if any)

Return Value:

    Status

--*/

{
    LONG i;
    LONG j;
    NTSTATUS status = STATUS_SUCCESS;
    ULONG CurrentLevel;
    PCM_KEY_HASH Current;
    PCM_KEY_CONTROL_BLOCK BaseKcb;
    PCM_KEY_CONTROL_BLOCK CurrentKcb;
    PCM_KEY_CONTROL_BLOCK ParentKcb;
    BOOLEAN Found;
    BOOLEAN LockedExclusive = FALSE;
    PULONG LockedKcbs = NULL;

    BaseKcb = *Kcb;
    //
    // try shared first
    //
    LockedKcbs = CmpBuildAndLockKcbArray(   HashStack,
                                            TotalRemainingSubkeys,
                                            0,
                                            BaseKcb,
                                            OuterStackArray,
                                            FALSE);
    if( LockedKcbs == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT(BaseKcb->RefCount != 0);
    CmpReferenceKeyControlBlock(BaseKcb);

RetryExclusive:
    Found = FALSE;

    CurrentLevel = TotalRemainingSubkeys + BaseKcb->TotalLevels + 1;

    for(i = TotalRemainingSubkeys-1; i>=0; i--) {
        //
        // Try to find the longest path in the cache.
        //
        // First, find the kcb that match the hash value.
        //

        CurrentLevel--; 

        Current = GET_KCB_HASH_ENTRY(CmpCacheTable, HashStack[i].ConvKey);
        Found = FALSE;

        while (Current) {
            ASSERT_KEY_HASH(Current);

            //
            // Check against both the ConvKey and total levels;
            //
            CurrentKcb = (CONTAINING_RECORD(Current, CM_KEY_CONTROL_BLOCK, KeyHash));

            if (CurrentKcb->TotalLevels == CurrentLevel) {
                //
                // The total subkey levels match.
                // Iterate through the kcb path and compare each subkey.
                //
                Found = TRUE;
                ParentKcb = CurrentKcb;
                for (j=i; j>=0; j--) {
                    if (HashStack[j].ConvKey == ParentKcb->ConvKey) {
                        //
                        // Convkey matches, compare the string
                        //
                        LONG Result;
                        UNICODE_STRING  TmpNodeName;

                        if (ParentKcb->NameBlock->Compressed) {
                               Result = CmpCompareCompressedName(&(HashStack[j].KeyName),
                                                                 ParentKcb->NameBlock->Name, 
                                                                 ParentKcb->NameBlock->NameLength,
                                                                 CMP_DEST_UP // name block is always UPPERCASE!!!
                                                                 ); 
                        } else {
                               TmpNodeName.Buffer = ParentKcb->NameBlock->Name;
                               TmpNodeName.Length = ParentKcb->NameBlock->NameLength;
                               TmpNodeName.MaximumLength = ParentKcb->NameBlock->NameLength;

                               //
                               // use the cmp compare variant as we know the destination is already uppercased.
                               //
                               Result = CmpCompareUnicodeString(&(HashStack[j].KeyName),
                                                                &TmpNodeName, 
                                                                CMP_DEST_UP);
                        }

                        if (Result) {
                            Found = FALSE;
                            break;
                        } 
                        ParentKcb = ParentKcb->ParentKcb;
                    } else {
                        Found = FALSE;
                        break;
                    }
                }
                if (Found) {
                    //
                    // All remaining key matches.  Now compare the BaseKcb.
                    //
                    if (BaseKcb == ParentKcb) {
                        
                        // if neither of these, don't need to ugrade KCB lock
                        if (CurrentKcb->ParentKcb->Delete || CurrentKcb->Delete) {
                            if( !LockedExclusive ) {
                                CmpUnLockKcbArray(LockedKcbs,CmpHashTableSize);
                                if( LockedKcbs != OuterStackArray ) {
                                    ExFreePool(LockedKcbs);
                                }
                                //
                                // try again, this time with EX lock
                                //
                                LockedKcbs = CmpBuildAndLockKcbArray(   HashStack,
                                                                        TotalRemainingSubkeys,
                                                                        0,
                                                                        BaseKcb,
                                                                        OuterStackArray,
                                                                        TRUE);
                                if( LockedKcbs == NULL ) {
                                    CmpDereferenceKeyControlBlock(BaseKcb);
                                    return STATUS_INSUFFICIENT_RESOURCES;
                                }
                                LockedExclusive = TRUE;
                                goto RetryExclusive;
                            }

                            if (CurrentKcb->ParentKcb->Delete) {
                                //
                                // The parentkcb is marked deleted.  
                                // So this must be a fake key created when the parent still existed.
                                // Otherwise it cannot be in the cache
                                //
                                ASSERT (CurrentKcb->ExtFlags & CM_KCB_KEY_NON_EXIST);

                                //
                                // It is possible that the parent key was deleted but now recreated.
                                // In that case this fake key is not longer valid for the ParentKcb is bad.
                                // We must now remove this fake key out of cache so, if this is a
                                // create operation, we do get hit this kcb in CmpCreateKeyControlBlock. 
                                //
                                ASSERT_KCB_LOCKED_EXCLUSIVE(CurrentKcb);
                                if (CurrentKcb->RefCount == 0) {
                                    //
                                    // No one is holding this fake kcb, just delete it.
                                    //
                                    CmpRemoveFromDelayedClose(CurrentKcb);
                                    CmpCleanUpKcbCacheWithLock(CurrentKcb,FALSE);
                                } else {
                                    //
                                    // Someone is still holding this fake kcb, 
                                    // Mark it as delete and remove it out of cache.
                                    //
                                    CurrentKcb->Delete = TRUE;
                                    CmpRemoveKeyControlBlock(CurrentKcb);
                                }
                                Found = FALSE;
                                break;
                            } else if(CurrentKcb->Delete) {
                                //
                                // the key has been deleted, but still kept in the cache for 
                                // this kcb does not belong here
                                //
                                CmpRemoveKeyControlBlock(CurrentKcb);
                                CmpUnLockKcbArray(LockedKcbs,CmpHashTableSize);
                                if( LockedKcbs != OuterStackArray ) {
                                    ExFreePool(LockedKcbs);
                                }
                                CmpDereferenceKeyControlBlock(BaseKcb);
                                return STATUS_OBJECT_NAME_NOT_FOUND;
                            }
                        }
                        
                        //
                        // We have a match, update the RemainingName.
                        //

                        //
                        // Skip the leading OBJ_NAME_PATH_SEPARATOR
                        //
                        while ((RemainingName->Length > 0) &&
                               (RemainingName->Buffer[0] == OBJ_NAME_PATH_SEPARATOR)) {
                            RemainingName->Buffer++;
                            RemainingName->Length -= sizeof(WCHAR);
                        }

                        //
                        // Skip all subkeys plus OBJ_NAME_PATH_SEPARATOR
                        //
                        for(j=0; j<=i; j++) {
                            RemainingName->Buffer += HashStack[j].KeyName.Length/sizeof(WCHAR);
                            RemainingName->Length = RemainingName->Length - (USHORT)(HashStack[j].KeyName.Length);
                            //
                            // Skip the leading OBJ_NAME_PATH_SEPARATOR 
                            // loop if some dumb caller decided to double quote
                            //
                            while ((RemainingName->Length > 0) &&
                                   (RemainingName->Buffer[0] == OBJ_NAME_PATH_SEPARATOR)) {
                                RemainingName->Buffer++;
                                RemainingName->Length -= sizeof(WCHAR);
                            }
                        }
                        //
                        // unlock all BUT this kcb; then reference it with the lock shared (safe even if it's in the delay close)
                        //
                        CmpUnLockKcbArray(LockedKcbs,GET_HASH_INDEX(CurrentKcb->ConvKey));
                        if( LockedKcbs != OuterStackArray ) {
                            ExFreePool(LockedKcbs);
                        }
                        LockedKcbs = NULL;
                        CmpReferenceKeyControlBlock(CurrentKcb);
                        ASSERT_KCB_LOCKED(CurrentKcb);
                        CmpUnlockKCB(CurrentKcb);
                        CmpDereferenceKeyControlBlock(BaseKcb);
                        //
                        // Update the KCB, Hive and Cell.
                        //
                        *Kcb = CurrentKcb;
                        *Hive = CurrentKcb->KeyHive;
                        *Cell = CurrentKcb->KeyCell;
                        break;
                    } else {
                        Found = FALSE;
                    }
                }
            }
            Current = Current->NextHash;
        }

        if (Found) {
            break;
        }
    }
    if( LockedKcbs != NULL ) {
        CmpUnLockKcbArray(LockedKcbs,CmpHashTableSize);
        if( LockedKcbs != OuterStackArray ) {
            ExFreePool(LockedKcbs);
        }
    }
    CmpLockKCBShared(*Kcb);

    if((*Kcb)->Delete) {
        //
        // the key has been deleted, but still kept in the cache for 
        // this kcb does not belong here
        //
        CmpUnlockKCB(*Kcb);
        CmpDereferenceKeyControlBlock( *Kcb );
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    if( (LONG)TotalRemainingSubkeys != (i+1) ) {
        CmpUnlockKCB(*Kcb);
    } else {
        ASSERT_KCB_LOCKED(*Kcb);
        //
        // check if not a false hit (non-existent key).
        //
        if( (*Kcb)->ExtFlags & CM_KCB_KEY_NON_EXIST ) {
            CmpUnlockKCB(*Kcb);
            OuterStackArray[0] = 0;
        } else {
            //
            // this is the fast path. the caller will know we have already locked the kcb by looking in the 
            // OuterKcbArray and determining Count == 1
            //
            ASSERT( NT_SUCCESS(status) );
            ASSERT( OuterStackArray );
            OuterStackArray[0] = 1;
            OuterStackArray[1] = GET_HASH_INDEX((*Kcb)->ConvKey);
        }
    }

    //
    // Now the kcb will be used in the parse routine.
    // Increase its reference count.
    // Make sure we remember to dereference it at the parse routine.
    //
    //
    // Don't need to do that since we already have a refcount added on this puppy 
    //
    //if (!CmpReferenceKeyControlBlock(*Kcb)) {
    //    status = STATUS_INSUFFICIENT_RESOURCES;
    //}
    *MatchRemainSubkeyLevel = i+1;
    return status;
}


PCM_KEY_CONTROL_BLOCK
CmpAddInfoAfterParseFailure(
    PHHIVE          Hive,
    HCELL_INDEX     Cell,
    PCM_KEY_NODE    Node,
    PCM_KEY_CONTROL_BLOCK kcb,
    PUNICODE_STRING NodeName
    )
/*++

Routine Description:

    This routine builds up further information in the cache when parse
    fails.  The additional information can be
    1. The key is has no subkey (CM_KCB_NO_SUBKEY).
    2. The key has a few subkeys, then build the index hint in the cache.
    3. If lookup failed even we have index hint cached, then create a fake key so
       we do not fail again.   This is very useful for lookup failure under keys like
       \registry\machine\software\classes\clsid, which have 1500+ subkeys and lots of
       them have the smae first four chars.
       
       NOTE. Currently we are not seeing too many fake keys being created.
       We need to monitor this periodly and work out a way to work around if
       we do create too many fake keys. 
       One solution is to use hash value for index hint (We can do it in the cache only
       if we need to be backward comparable).
    
Arguments:

    Hive - Supplies Hive that holds the key we are creating a KCB for.

    Cell - Supplies Cell that contains the key we are creating a KCB for.

    Node - Supplies pointer to key node.

    KeyName - The KeyName.

Return Value:

    The KCB that CmpParse need to dereference at the end.

    If resources problem, it returns NULL, and the caller is responsible for cleanup
--*/
{

    ULONG                   TotalSubKeyCounts;
    BOOLEAN                 CreateFakeKcb = FALSE;
    BOOLEAN                 HintCached;
    PCM_KEY_CONTROL_BLOCK   ParentKcb;
    USHORT                  i,j;
    HCELL_INDEX             CellToRelease;
    ULONG                   HashKey;

    if (!UseFastIndex(Hive)) {
        //
        // Older version of hive, do not bother to cache hint.
        //
        return (kcb);
    }

    ASSERT_KCB_LOCKED_EXCLUSIVE(kcb);
    TotalSubKeyCounts = Node->SubKeyCounts[Stable] + Node->SubKeyCounts[Volatile];

    if (TotalSubKeyCounts == 0) {
        kcb->ExtFlags |= CM_KCB_NO_SUBKEY;
        // clean up the invalid flag (if any)
        kcb->ExtFlags &= ~CM_KCB_INVALID_CACHED_INFO;
    } else if (TotalSubKeyCounts == 1) {
        if (!(kcb->ExtFlags & CM_KCB_SUBKEY_ONE)) {
            //
            // Build the subkey hint to avoid unnecessary lookups in the index leaf
            //
            PCM_KEY_INDEX   Index;
            HCELL_INDEX     SubKeyCell = 0;
            PCM_KEY_NODE    SubKeyNode;
            UNICODE_STRING  TmpStr;

            if (Node->SubKeyCounts[Stable] == 1) {
                CellToRelease = Node->SubKeyLists[Stable];
                Index = (PCM_KEY_INDEX)HvGetCell(Hive, CellToRelease);
            } else {
                CellToRelease = Node->SubKeyLists[Volatile];
                Index = (PCM_KEY_INDEX)HvGetCell(Hive, CellToRelease);
            } 
            
            if( Index == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // return NULL; The caller must handle this gracefully!
                //
                return NULL;
            }

            if( Index->Signature == CM_KEY_INDEX_ROOT ) {
                //
                // don't cache root indexes; they are too big
                //
                HvReleaseCell(Hive,CellToRelease);
                return NULL;
            }

            HashKey = 0;
            if ( Index->Signature == CM_KEY_HASH_LEAF ) {
                PCM_KEY_FAST_INDEX FastIndex;
                FastIndex = (PCM_KEY_FAST_INDEX)Index;
                //
                // we already have the hash key handy; preserve it for the kcb hint
                //
                HashKey = FastIndex->List[0].HashKey;
                SubKeyCell = FastIndex->List[0].Cell;
            } else if(Index->Signature == CM_KEY_FAST_LEAF) {
                PCM_KEY_FAST_INDEX FastIndex;
                FastIndex = (PCM_KEY_FAST_INDEX)Index;
                SubKeyCell = FastIndex->List[0].Cell;

            } else {
                SubKeyCell = Index->List[0];
            }
            
            if( HashKey != 0 ) {
                kcb->HashKey = HashKey;
                kcb->ExtFlags |= CM_KCB_SUBKEY_ONE;
                // clean up the invalid flag (if any)
                kcb->ExtFlags &= ~CM_KCB_INVALID_CACHED_INFO;
            } else {
                SubKeyNode = (PCM_KEY_NODE)HvGetCell(Hive,SubKeyCell);
                if( SubKeyNode != NULL ) {
                    if (SubKeyNode->Flags & KEY_COMP_NAME) {
                        kcb->HashKey = CmpComputeHashKeyForCompressedName(0,SubKeyNode->Name,SubKeyNode->NameLength);
                    } else {
                        TmpStr.Buffer = SubKeyNode->Name;
                        TmpStr.Length = SubKeyNode->NameLength;
                        kcb->HashKey = CmpComputeHashKey(0,&TmpStr
#if DBG
                                                        , FALSE
#endif
                            );
                    }
                
                    
                    HvReleaseCell(Hive,SubKeyCell);
                    kcb->ExtFlags |= CM_KCB_SUBKEY_ONE;
                    // clean up the invalid flag (if any)
                    kcb->ExtFlags &= ~CM_KCB_INVALID_CACHED_INFO;
                } else {
                    //
                    // we couldn't map the bin containing this cell
                    // return NULL; The caller must handle this gracefully!
                    //
                    HvReleaseCell(Hive,CellToRelease);
                    return NULL;
                }
            }
            HvReleaseCell(Hive,CellToRelease);
        } else {
            //
            // The name hint does not prevent from this look up
            // Create the fake Kcb.
            //
            CreateFakeKcb = TRUE;
        }
    } else if (TotalSubKeyCounts < CM_MAX_CACHE_HINT_SIZE) {
        if (!(kcb->ExtFlags & CM_KCB_SUBKEY_HINT)) {
            //
            // Build the index leaf info in the parent KCB
            // How to sync the cache with the registry data is a problem to be resolved.
            //
            ULONG               Size;
            PCM_KEY_INDEX       Index;
            PCM_KEY_FAST_INDEX  FastIndex;
            HCELL_INDEX         SubKeyCell = 0;
            PCM_KEY_NODE        SubKeyNode;
            ULONG               HintCrt;
            UNICODE_STRING      TmpStr;

            Size = sizeof(ULONG) * (Node->SubKeyCounts[Stable] + Node->SubKeyCounts[Volatile] + 1);

            kcb->IndexHint = ExAllocatePoolWithTag(PagedPool,
                                                   Size,
                                                   CM_CACHE_INDEX_TAG | PROTECTED_POOL);

            HintCached = TRUE;
            if (kcb->IndexHint) {
                kcb->IndexHint->Count = Node->SubKeyCounts[Stable] + Node->SubKeyCounts[Volatile]; 

                HintCrt = 0;

                for (i = 0; i < Hive->StorageTypeCount; i++) {
                    if(Node->SubKeyCounts[i]) {
                        CellToRelease = Node->SubKeyLists[i];
                        Index = (PCM_KEY_INDEX)HvGetCell(Hive, CellToRelease);
                        if( Index == NULL ) {
                            //
                            // we couldn't map the bin containing this cell
                            // return NULL; The caller must handle this gracefully!
                            //
                            return NULL;
                        }
                        if( Index->Signature == CM_KEY_INDEX_ROOT ) {
                            HvReleaseCell(Hive,CellToRelease);
                            HintCached = FALSE;
                            break;
                        } else {
                          
                            for (j=0; j<Node->SubKeyCounts[i]; j++) {
                                HashKey = 0;

                                if ( Index->Signature == CM_KEY_HASH_LEAF ) {
                                    FastIndex = (PCM_KEY_FAST_INDEX)Index;
                                    //
                                    // preserve the hash key for the kcb hint
                                    //
                                    HashKey = FastIndex->List[j].HashKey;
                                    SubKeyCell = FastIndex->List[j].Cell;
                                } else if( Index->Signature == CM_KEY_FAST_LEAF ) {
                                    FastIndex = (PCM_KEY_FAST_INDEX)Index;
                                    SubKeyCell = FastIndex->List[j].Cell;
                                } else {
                                    SubKeyCell = Index->List[j];
                                }
                            
                                if( HashKey != 0 ) {
                                    kcb->IndexHint->HashKey[HintCrt] = HashKey;
                                } else {
                                    SubKeyNode = (PCM_KEY_NODE)HvGetCell(Hive,SubKeyCell);
                                    if( SubKeyNode == NULL ) {
                                        //
                                        // couldn't map view; bad luck; don't cache hint for this kcb
                                        //
                                        HintCached = FALSE;
                                        break;
                                    }

                                    if (SubKeyNode->Flags & KEY_COMP_NAME) {
                                        kcb->IndexHint->HashKey[HintCrt] = CmpComputeHashKeyForCompressedName(0,SubKeyNode->Name,SubKeyNode->NameLength);
                                    } else {
                                        TmpStr.Buffer = SubKeyNode->Name;
                                        TmpStr.Length = SubKeyNode->NameLength;
                                        kcb->IndexHint->HashKey[HintCrt] = CmpComputeHashKey(0,&TmpStr
#if DBG
                                                                                            , FALSE
#endif
                                            );
                                    }

                                    HvReleaseCell(Hive,SubKeyCell);
                                }
                                //
                                // advance to the new hint
                                //
                                HintCrt++;
                            
                            }
                        }

                        HvReleaseCell(Hive,CellToRelease);
                    }
                }

                if (HintCached) {
                    kcb->ExtFlags |= CM_KCB_SUBKEY_HINT;
                    // clean up the invalid flag (if any)
                    kcb->ExtFlags &= ~CM_KCB_INVALID_CACHED_INFO;
                } else {
                    //
                    // Do not have a FAST_LEAF, free the allocation.
                    //
                    ExFreePoolWithTag(kcb->IndexHint, CM_CACHE_INDEX_TAG | PROTECTED_POOL);
                }
            }
        } else {
            //
            // The name hint does not prevent from this look up
            // Create the fake Kcb.
            //
            CreateFakeKcb = TRUE;
        }
    } else {
        CreateFakeKcb = TRUE;
    }

    ParentKcb = kcb;

    if (CreateFakeKcb && (CmpCacheOnFlag & CM_CACHE_FAKE_KEY)) {
        //
        // It has more than a few children but not the one we are interested.
        // Create a kcb for this non-existing key so we do not try to find it
        // again. Use the cell and node from the parent.
        //
        // Before we create a new one. Dereference the current kcb.
        //
        // CmpCacheOnFlag is for us to turn it on/off easily.
        //

        kcb = CmpCreateKeyControlBlock(Hive,
                                       Cell,
                                       Node,
                                       ParentKcb,
                                       CMP_CREATE_KCB_FAKE|CMP_CREATE_KCB_KCB_LOCKED,
                                       NodeName);

        if (kcb) {
            ASSERT_KCB_LOCKED_EXCLUSIVE(ParentKcb);
            CmpDereferenceKeyControlBlockWithLock(ParentKcb,FALSE);
            ParentKcb = kcb;
        }
    }

    return (ParentKcb);
}

BOOLEAN
CmpOKToFollowLink(  IN PCMHIVE  OrigHive,
                    IN PCMHIVE  DestHive
                    )
/*++

Routine Description:

    1.      You can follow links from TRUSTED to anywhere. 
    2.      You cannot follow links from UNTRUSTED to TRUSTED. 
    3.      Inside the UNTRUSTED name space, you can only follow links inside the same class of trust. 

    OBS: OrigHive is just an address. It should not be dereferenced, as it may not be valid anymore (ie.
            hive could have been unloaded in between). We don't really care as if it was, it will not be 
            in the trust list for the SourceKcb's hive
         If OrigHive == NULL it means we have originated in a trusted hive.
  
Arguments:


Return Value:

    TRUE or FALSE
--*/
{
    PCMHIVE     TmpHive;
    PLIST_ENTRY AnchorAddr;
    
    PAGED_CODE();

    if( OrigHive == NULL ) {
        //
        // OK to follow links from trusted to anywhere
        //
        return TRUE;
    }
    if( OrigHive == DestHive ) {
        //
        // OK to follow links inside the same hive 
        //
        return TRUE;
    }
    
    if( !(DestHive->Flags & CM_CMHIVE_FLAG_UNTRUSTED) ) {
        //
        // fail to follow from untrusted to trusted
        //
        //return FALSE;
        goto Fail;
    }
    //
    // both untrusted; see if they are in the same class of trust
    //
    ASSERT( DestHive->Flags & CM_CMHIVE_FLAG_UNTRUSTED );

    CmpLockHiveListShared();
    //
	// walk the TrustClassEntry list of SrcHive, to see if we can find DstSrc
	//
	AnchorAddr = &(DestHive->TrustClassEntry);
	TmpHive = (PCMHIVE)(DestHive->TrustClassEntry.Flink);

	while ( TmpHive != (PCMHIVE)AnchorAddr ) {
		TmpHive = CONTAINING_RECORD(
						TmpHive,
						CMHIVE,
						TrustClassEntry
						);
		if( TmpHive == OrigHive ) {
			//
			// found it ==> same class of trust
			//
            CmpUnlockHiveList();
            return TRUE;
		}
        //
        // skip to the next element
        //
        TmpHive = (PCMHIVE)(TmpHive->TrustClassEntry.Flink);
	}

    CmpUnlockHiveList();

Fail:
    //
    // returning TRUE here will disable the 'don't follow links outside class of trust' behavior
    //
    return FALSE;
}

PULONG 
CmpBuildAndLockKcbArray(   
    IN PCM_HASH_ENTRY           HashStack,
    IN ULONG                    TotalLevels,
    IN ULONG                    RemainingLevel,
    IN PCM_KEY_CONTROL_BLOCK    kcb,
    IN PULONG                   OuterStackArray,
    IN BOOLEAN                  LockExclusive)
/*++

Routine Description:

    Builds up an array with indexes associated to the hash keys in hash stack starting at RemainingLevel
    then locks all hash entries exclusive
    The array is sorted.
    If RemainingLevel == TotalLevels, kcb->Parent is also locked
    kcb is always locked
  
Arguments:

    HashStack - 
    TotalLevels -
    RemainingLevel -
    Kcb -


Return Value:

    The array, first ULONG is the number of valid elements  in the success case

  - NULL on failure.
--*/
{
    PULONG  IndexArray;
    ULONG   Count;
    ULONG   Current;
    ULONG   HashIndex;
    ULONG   i,k;
    ULONG   InputArray[MAX_LOCAL_KCB_ARRAY];
    PULONG  OutputArray;
    char    OrderArray[MAX_LOCAL_KCB_ARRAY] = {0};

    CM_PAGED_CODE();

    Count = 1; // this kcb
    if( (TotalLevels == RemainingLevel) && (kcb->ParentKcb != NULL) ) {
        //
        // need to lock the parent also
        //
        Count++;
    }
    //
    // now add up the remaining levels.
    //
    Current = 0;
    Count += (TotalLevels - RemainingLevel);
    
    ASSERT( Count <= MAX_LOCAL_KCB_ARRAY);

    //
    // take the fast path and use the array we have handy on the stack.
    //
    ASSERT( OuterStackArray != NULL );
    IndexArray = OuterStackArray;
    OutputArray = &(IndexArray[1]);
    //
    // quick sort them on the fly with an auxiliary array.
    //

    //
    // add parent if needed
    //
    if( (TotalLevels == RemainingLevel) && (kcb->ParentKcb != NULL) ) {
        InputArray[Current++] = GET_HASH_INDEX(kcb->ParentKcb->ConvKey);
    }
    //
    // add this kcb
    //
    HashIndex = GET_HASH_INDEX(kcb->ConvKey);
    if( Current == 1) {
        if( HashIndex != InputArray[0] ) {
            //
            // not same
            //
            InputArray[Current++] = HashIndex;
            if( HashIndex < InputArray[0] ) {
                OrderArray[0]++;
            } else {
                ASSERT( HashIndex > InputArray[0] );
                OrderArray[1]++;
            }
        }
    } else {
        ASSERT( Current == 0 );
        //
        // simply store it
        //
        InputArray[Current++] = HashIndex;
    }

    //
    // now the fun part; parse the input array and sort the output as we go
    //
    for(;RemainingLevel<TotalLevels;RemainingLevel++) {
        InputArray[Current] = GET_HASH_INDEX(HashStack[RemainingLevel].ConvKey);
        for(i=0;i<Current;i++) {
            if(InputArray[Current] == InputArray[i]) {
                //
                // need to go undo what we have touched already
                //
                for( k=0;k<i;k++) {
                    if( InputArray[Current] < InputArray[k] ) {
                        OrderArray[k]--;
                    }
                }
                OrderArray[Current] = 0;
                break;
            }

            if( InputArray[Current] < InputArray[i] ) {
                OrderArray[i]++;
            } else {
                OrderArray[Current]++;
            }
        }

        if( i == Current ) {
            Current++;
        }
    }
    //
    // now sort it up nicely
    //
    for(i=0;i<Current;i++) {
        OutputArray[OrderArray[i]] = InputArray[i];
    }

    //
    // remember how many they are;
    //
    IndexArray[0] = Current;
#if DBG
    //
    // did we sort them right ?
    //
    for( i=0;i<(Current-1);i++) {
        ASSERT( IndexArray[i+1] < IndexArray[i+2] );
    }
#endif
    //
    // now lock'em up;
    //
    for(i=0;i<Current;i++) {
        if( LockExclusive ) {
            CmpLockHashEntryByIndexExclusive(IndexArray[i+1]);
        } else {
            CmpLockHashEntryByIndexShared(IndexArray[i+1]);
        }
    }
    
    return IndexArray;
}

ULONG
CmpUnLockKcbArray(IN PULONG LockedKcbs,
                  IN ULONG  Exempt)
{
    ULONG   i;
    ULONG   Count;

    CM_PAGED_CODE();

    Count = LockedKcbs[0];
    for( i=Count;i>0;i--) {
        if(LockedKcbs[i] != Exempt) {
            CmpUnlockHashEntryByIndex(LockedKcbs[i]);
        }
    }
    LockedKcbs[0] = 0;
    return Count;
}

VOID
CmpReLockKcbArray(IN PULONG LockedKcbs,
                  IN BOOLEAN LockExclusive)
{
    ULONG   i;
    ULONG   Count;

    CM_PAGED_CODE();

    Count = LockedKcbs[0];

    for(i=0;i<Count;i++) {
        if( LockExclusive ) {
            CmpLockHashEntryByIndexExclusive(LockedKcbs[i+1]);
        } else {
            CmpLockHashEntryByIndexShared(LockedKcbs[i+1]);
        }
    }
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmquery.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmquery.c

Abstract:

    This module contains the object name query method for the registry.

--*/

#include    "cmp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpQueryKeyName)
#endif

NTSTATUS
CmpQueryKeyName(
    IN PVOID Object,
    IN BOOLEAN HasObjectName,
    OUT POBJECT_NAME_INFORMATION ObjectNameInfo,
    IN ULONG Length,
    OUT PULONG ReturnLength,
    IN KPROCESSOR_MODE Mode
    )
/*++

Routine Description:

    This routine interfaces to the NT Object Manager.  It is invoked when
    the object system wishes to discover the name of an object that
    belongs to the registry.

Arguments:

    Object - pointer to a Key, thus -> KEY_BODY.

    HasObjectName - indicates whether the object manager knows about a name
        for this object

    ObjectNameInfo - place where we report the name

    Length - maximum length they can deal with

    ReturnLength - supplies variable to receive actual length

    Mode - Processor mode of the caller

Return Value:

    STATUS_SUCCESS

    STATUS_INFO_LENGTH_MISMATCH

--*/

{
    PUNICODE_STRING         Name = NULL;
    PWCHAR                  t;
    PWCHAR                  s;
    ULONG                   l;
    NTSTATUS                status;
    PCM_KEY_CONTROL_BLOCK   kcb;
    BOOLEAN                 UnlockKcb = TRUE;

    UNREFERENCED_PARAMETER(HasObjectName);
    UNREFERENCED_PARAMETER(Mode);

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_PARSE,"CmpQueryKeyName:\n"));

    BEGIN_LOCK_CHECKPOINT;
    CmpLockRegistry();
    //
    // sanitize the kcb, for cases where we get a callback for se audit
    //
    kcb = (PCM_KEY_CONTROL_BLOCK)(((PCM_KEY_BODY)Object)->KeyControlBlock);
    if( (ULONG_PTR)kcb & 1 ) {
        kcb = (PCM_KEY_CONTROL_BLOCK)((ULONG_PTR)kcb ^ 1);
        ASSERT_KCB_LOCKED(kcb);
        UnlockKcb = FALSE;
    } else {
        CmpLockKCBShared(kcb);
    }

    if ( kcb->Delete) {
        if( UnlockKcb ) {
            CmpUnlockKCB(kcb);
        }
        CmpUnlockRegistry();
        return STATUS_KEY_DELETED;
    }
    Name = CmpConstructName(kcb);

    if( UnlockKcb ) {
        CmpUnlockKCB(kcb);
    }

    //
    // don't need the lock anymore
    //
    CmpUnlockRegistry();
    END_LOCK_CHECKPOINT;

    if (Name == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        return status;
    }

    if (Length <= sizeof(OBJECT_NAME_INFORMATION)) {
        *ReturnLength = Name->Length + sizeof(WCHAR) + sizeof(OBJECT_NAME_INFORMATION);
        ExFreePoolWithTag(Name, CM_NAME_TAG | PROTECTED_POOL);
        return STATUS_INFO_LENGTH_MISMATCH;  // they can't even handle null
    }

    t = (PWCHAR)(ObjectNameInfo + 1);
    s = Name->Buffer;
    l = Name->Length;
    l += sizeof(WCHAR);     // account for null

    *ReturnLength = l + sizeof(OBJECT_NAME_INFORMATION);
    if (l > Length - sizeof(OBJECT_NAME_INFORMATION)) {
        l = Length - sizeof(OBJECT_NAME_INFORMATION);
        status = STATUS_INFO_LENGTH_MISMATCH;
        if( l < sizeof(WCHAR) ) {
            ExFreePoolWithTag(Name, CM_NAME_TAG | PROTECTED_POOL);
            return status;  // they can't even handle null
        } 
    } else {
        status = STATUS_SUCCESS;
    }

    l -= sizeof(WCHAR);

    //
    // The ObjectNameInfo buffer is a usermode buffer, so make sure we have an
    // exception handler in case a malicious app changes the protection out from
    // under us.
    //
    // Note the object manager is responsible for probing the buffer and ensuring
    // that a top-level exception handler returns the correct error code. We just
    // need to make sure we drop our lock.
    //
    try {
        RtlCopyMemory(t, s, l);
        t[l/sizeof(WCHAR)] = UNICODE_NULL;
        ObjectNameInfo->Name.Length = (USHORT)l;
        ObjectNameInfo->Name.MaximumLength = ObjectNameInfo->Name.Length;
        ObjectNameInfo->Name.Buffer = t;
    } finally {
        ExFreePoolWithTag(Name, CM_NAME_TAG | PROTECTED_POOL);
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmsavres.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmsavres.c

Abstract:

    This file contains code for SaveKey and RestoreKey.

--*/

#include    "cmp.h"

//
// defines how big the buffer we use for doing a savekey by copying the
// hive file should be.
//
#define CM_SAVEKEYBUFSIZE 0x10000

extern PCMHIVE CmpMasterHive;

extern  BOOLEAN CmpProfileLoaded;

extern PUCHAR  CmpStashBuffer;
extern SIZE_T  CmpGlobalQuotaUsed;
extern BOOLEAN HvShutdownComplete;     // Set to true after shutdown
                                        // to disable any further I/O

PCMHIVE
CmpCreateTemporaryHive(
    IN HANDLE FileHandle
    );

VOID
CmpDestroyTemporaryHive(
    PCMHIVE CmHive
    );

NTSTATUS
CmpLoadHiveVolatile(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    IN HANDLE FileHandle
    );

NTSTATUS
CmpRefreshHive(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock
    );

NTSTATUS
CmpSaveKeyByFileCopy(
    PCMHIVE Hive,
    HANDLE  FileHandle
    );

ULONG
CmpRefreshWorkerRoutine(
    PCM_KEY_CONTROL_BLOCK Current,
    PVOID                 Context1,
    PVOID                 Context2
    );

BOOLEAN
CmpMergeKeyValues(
    PHHIVE  SourceHive,
    HCELL_INDEX SourceKeyCell,
    PCM_KEY_NODE SourceKeyNode,
    PHHIVE  TargetHive,
    HCELL_INDEX TargetKeyCell,
    PCM_KEY_NODE TargetKeyNode
    );

VOID 
CmpShiftSecurityCells(PHHIVE        Hive);

VOID
CmpShiftValueList(PHHIVE      Hive,
            HCELL_INDEX ValueList,
            ULONG       Count
            );

VOID
CmpShiftKey(PHHIVE      Hive,
            PCMHIVE     OldHive,
            HCELL_INDEX Cell,
            HCELL_INDEX ParentCell
            );

VOID 
CmpShiftIndex(PHHIVE        Hive,
              PCM_KEY_INDEX Index
              );

BOOLEAN
CmpShiftAllCells2(  PHHIVE      Hive,
                    PCMHIVE     OldHive,
                    HCELL_INDEX Cell,
                    HCELL_INDEX ParentCell
                    );

BOOLEAN
CmpShiftAllCells(PHHIVE     NewHive,
                 PCMHIVE    OldHive
                 );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmRestoreKey)
#pragma alloc_text(PAGE,CmpLoadHiveVolatile)
#pragma alloc_text(PAGE,CmpRefreshHive)
#pragma alloc_text(PAGE,CmSaveKey)
#pragma alloc_text(PAGE,CmDumpKey)
#pragma alloc_text(PAGE,CmSaveMergedKeys)
#pragma alloc_text(PAGE,CmpCreateTemporaryHive)
#pragma alloc_text(PAGE,CmpDestroyTemporaryHive)
#pragma alloc_text(PAGE,CmpRefreshWorkerRoutine)
#pragma alloc_text(PAGE,CmpSaveKeyByFileCopy)
#pragma alloc_text(PAGE,CmpOverwriteHive)
#pragma alloc_text(PAGE,CmpShiftHiveFreeBins)
#pragma alloc_text(PAGE,CmpSwitchStorageAndRebuildMappings)
#pragma alloc_text(PAGE,CmpShiftSecurityCells)
#pragma alloc_text(PAGE,CmpShiftValueList)
#pragma alloc_text(PAGE,CmpShiftKey)
#pragma alloc_text(PAGE,CmpShiftIndex)
#pragma alloc_text(PAGE,CmpShiftAllCells2)
#pragma alloc_text(PAGE,CmpShiftAllCells)
#endif



NTSTATUS
CmRestoreKey(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    IN HANDLE  FileHandle,
    IN ULONG Flags
    )
/*++

Routine Description:

    This copies the data from an on-disk hive into the registry.  The file
    is not loaded into the registry, and the system will NOT be using
    the source file after the call returns.

    If the flag REG_WHOLE_HIVE_VOLATILE is not set, the given key is replaced
    by the root of the hive file.  The root's name is changed to the name
    of the given key.

    If the flag REG_WHOLE_HIVE_VOLATILE is set, a volatile hive is created,
    the hive file is copied into it, and the resulting hive is linked to
    the master hive.  The given key must be in the master hive.  (Usually
    will be \Registry\User)

    If the flag REG_REFRESH_HIVE is set (must be only flag) then the
    the Hive will be restored to its state as of the last flush.
    (The hive must be marked NOLAZY_FLUSH, and the caller must have
     TCB privilege, and the handle must point to the root of the hive.
     If the refresh fails, the hive will be corrupt, and the system
     will bugcheck.)

    If the flag REG_FORCE_RESTORE is set, the restore operation is done even
    if there areopen handles underneath the key we are restoring to.

Arguments:

    Hive - supplies a pointer to the hive control structure for the hive

    Cell - supplies index of node at root of tree to restore into

    FileHandle - handle of the file to read from.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PCELL_DATA  ptar;
    PCELL_DATA  psrc;
    PCMHIVE     TmpCmHive;
    HCELL_INDEX newroot;
    HCELL_INDEX newcell;
    HCELL_INDEX parent;
    HCELL_INDEX list;
    ULONG       count;
    ULONG       i;
    ULONG       j;
    LONG        size;
    PHHIVE      Hive;
    HCELL_INDEX Cell;
    HSTORAGE_TYPE Type;
    ULONG       NumberLeaves;
    PHCELL_INDEX LeafArray;
    PCM_KEY_INDEX Leaf;
    PCM_KEY_FAST_INDEX FastLeaf;
    PRELEASE_CELL_ROUTINE   SourceReleaseCellRoutine;
    PRELEASE_CELL_ROUTINE   TargetReleaseCellRoutine;

    CM_PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"CmRestoreKey:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tKCB=%p\n",KeyControlBlock));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tFileHandle=%08lx\n",FileHandle));

    if (Flags & REG_REFRESH_HIVE) {
        if ((Flags & ~REG_REFRESH_HIVE) != 0) {
            //
            // Refresh must be alone
            //
            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // If they want to do WHOLE_HIVE_VOLATILE, it's a completely different API.
    //
    if (Flags & REG_WHOLE_HIVE_VOLATILE) {
        return(CmpLoadHiveVolatile(KeyControlBlock, FileHandle));
    }

    //
    // If they want to do REFRESH_HIVE, that's a completely different api too.
    //
    if (Flags & REG_REFRESH_HIVE) {
        CmpLockRegistryExclusive();
        status = CmpRefreshHive(KeyControlBlock);
        CmpUnlockRegistry();
        return status;
    }

    Hive = KeyControlBlock->KeyHive;

    //
    // Disallow attempts to "restore" the master hive
    //
    if (Hive == &CmpMasterHive->Hive) {
        return STATUS_ACCESS_DENIED;
    }

    CmpLockRegistryExclusive();

    //
    // Make sure this key has not been deleted
    //
    if (KeyControlBlock->Delete) {
        CmpUnlockRegistry();
        return(STATUS_CANNOT_DELETE);
    }

    Cell = KeyControlBlock->KeyCell;

    if( IsHiveFrozen(((PCMHIVE)Hive)) ) {
        //
        // deny attempts to clobber with a frozen hive
        //
        CmpUnlockRegistry();
        return STATUS_TOO_LATE;
    }

    DCmCheckRegistry(CONTAINING_RECORD(Hive, CMHIVE, Hive));

    //
    // Check for any open handles underneath the key we are restoring to.
    //
    if (CmpSearchForOpenSubKeys(KeyControlBlock, ((Flags & REG_FORCE_RESTORE) ? 
        SearchAndDeref : SearchIfExist),TRUE, NULL) != 0) {
        //
        // Cannot restore over a subtree with open handles in it, or the open handles to subkeys 
        // successfully marked as closed.
        //

        CmpUnlockRegistry();
        return(STATUS_CANNOT_DELETE);
    }

     //
    // Make sure this is the only handle open for this key
    //
    if (KeyControlBlock->RefCount != 1 && !(Flags&REG_FORCE_RESTORE)) {
        CmpUnlockRegistry();
        return(STATUS_CANNOT_DELETE);
    }

    ptar = HvGetCell(Hive, Cell);
    if( ptar == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        CmpUnlockRegistry();
		return STATUS_INSUFFICIENT_RESOURCES;
    }
    // release the cell right here as we are holding the reglock exclusive
    HvReleaseCell(Hive,Cell);

    //
    // The subtree the caller wants does not exactly match a
    // subtree.  Make a temporary hive, load the file into it,
    // tree copy the temporary to the active, and free the temporary.
    //

    //
    // Create the temporary hive
    //
    status = CmpInitializeHive(&TmpCmHive,
                           HINIT_FILE,
                           0,
                           HFILE_TYPE_PRIMARY,
                           NULL,
                           FileHandle,
                           NULL,
                           NULL,
                           NULL,
                           CM_CHECK_REGISTRY_CHECK_CLEAN
                           );

    if (!NT_SUCCESS(status)) {
        goto ErrorExit1;
    }                         

    //
    // Create a new target root, under which we will copy the new tree
    //
    if (ptar->u.KeyNode.Flags & KEY_HIVE_ENTRY) {
        parent = HCELL_NIL;                         // root of hive, so parent is NIL
    } else {
        parent = ptar->u.KeyNode.Parent;
    }

    SourceReleaseCellRoutine = TmpCmHive->Hive.ReleaseCellRoutine;
    TargetReleaseCellRoutine = Hive->ReleaseCellRoutine;
    TmpCmHive->Hive.ReleaseCellRoutine = NULL;
    Hive->ReleaseCellRoutine = NULL;

    newroot = CmpCopyKeyPartial(&(TmpCmHive->Hive),
                                TmpCmHive->Hive.BaseBlock->RootCell,
                                Hive,
                                parent,
                                TRUE);
    TmpCmHive->Hive.ReleaseCellRoutine = SourceReleaseCellRoutine;
    Hive->ReleaseCellRoutine = TargetReleaseCellRoutine;

    if (newroot == HCELL_NIL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit2;
    }

    //
    // newroot has all the correct stuff, except that it has the
    // source root's name, when it needs to have the target root's.
    // So edit its name.
    //
    psrc = HvGetCell(Hive, Cell);
    if( psrc == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit2;
    }

    // release the cell right here as we are holding the reglock exclusive
    HvReleaseCell(Hive,Cell);

    ptar = HvGetCell(Hive, newroot);
    if( ptar == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit2;
    }
    size = FIELD_OFFSET(CM_KEY_NODE, Name) + psrc->u.KeyNode.NameLength;

    // release the cell right here as we are holding the reglock exclusive
    HvReleaseCell(Hive,newroot);

    //
    // make sure that new root has correct amount of space
    // to hold name from old root
    //
    newcell = HvReallocateCell(Hive, newroot, size);
    if (newcell == HCELL_NIL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit2;
    }
    newroot = newcell;
    ptar = HvGetCell(Hive, newroot);
    if( ptar == NULL ) {
        //
        // we couldn't map the bin containing this cell
        // this shouldn't happen, as we just allocated this cell
        // (i.e. it should be PINNED in memory at this point)
        //
        ASSERT( FALSE );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit2;
    }
    // release the cell right here as we are holding the reglock exclusive
    HvReleaseCell(Hive,newroot);

    status = STATUS_SUCCESS;

    RtlCopyMemory((PVOID)&(ptar->u.KeyNode.Name[0]),
                  (PVOID)&(psrc->u.KeyNode.Name[0]),
                  psrc->u.KeyNode.NameLength);

    ptar->u.KeyNode.NameLength = psrc->u.KeyNode.NameLength;
    if (psrc->u.KeyNode.Flags & KEY_COMP_NAME) {
        ptar->u.KeyNode.Flags |= KEY_COMP_NAME;
    } else {
        ptar->u.KeyNode.Flags &= ~KEY_COMP_NAME;
    }

    //
    // newroot is now ready to have subtree copied under it, do tree copy
    //
    if (CmpCopyTree(&(TmpCmHive->Hive),
                    TmpCmHive->Hive.BaseBlock->RootCell,
                    Hive,
                    newroot) == FALSE)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit2;
    }

    //
    // The new root and the tree under it now look the way we want.
    //

    //
    // Swap the new tree in for the old one.
    //
    ptar = HvGetCell(Hive, Cell);
    if( ptar == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit2;
    }

    parent = ptar->u.KeyNode.Parent;

    // release the cell right here as we are holding the reglock exclusive
    HvReleaseCell(Hive,Cell);

    if (ptar->u.KeyNode.Flags & KEY_HIVE_ENTRY) {

        //
        // root is actually the root of the hive.  parent doesn't
        // refer to it via a child list, but rather with an inter hive
        // pointer.  also, must update base block
        //
        ptar = HvGetCell( (&(CmpMasterHive->Hive)), parent);
        if( ptar == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit2;
        }
        // release the cell right here as we are holding the reglock exclusive
        HvReleaseCell((&(CmpMasterHive->Hive)), parent);

        ptar->u.KeyNode.ChildHiveReference.KeyCell = newroot;
        ptar = HvGetCell(Hive, newroot);
        if( ptar == NULL ) {
            //
            // we couldn't map the bin containing this cell
            // this shouldn't happen, as we just allocated this cell
            // (i.e. it should be PINNED in memory at this point)
            //
            ASSERT( FALSE );
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit2;
        }
        // release the cell right here as we are holding the reglock exclusive
        HvReleaseCell(Hive, newroot);

        ptar->u.KeyNode.Parent = parent;
        Hive->BaseBlock->RootCell = newroot;


    } else {

        //
        //  Notice that new root is *always* name of existing target,
        //      therefore, even in b-tree, old and new cell can share
        //      the same reference slot in the parent.  So simply edit
        //      the new cell_index on the top of the old.
        //
        ptar = HvGetCell(Hive, parent);
        if( ptar == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit2;
        }
        // release the cell right here as we are holding the reglock exclusive
        HvReleaseCell(Hive, parent);

        Type = HvGetCellType(Cell);
        list = ptar->u.KeyNode.SubKeyLists[Type];
        count = ptar->u.KeyNode.SubKeyCounts[Type];

        ptar = HvGetCell(Hive, list);
        if( ptar == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit2;
        }
        // release the cell right here as we are holding the reglock exclusive
        HvReleaseCell(Hive, list);
        if (ptar->u.KeyIndex.Signature == CM_KEY_INDEX_ROOT) {
            NumberLeaves = ptar->u.KeyIndex.Count;
            LeafArray = &ptar->u.KeyIndex.List[0];
        } else {
            NumberLeaves = 1;
            LeafArray = &list;
        }

        //
        // Look in each leaf for the HCELL_INDEX we need to replace
        //
        for (i = 0; i < NumberLeaves; i++) {
            Leaf = (PCM_KEY_INDEX)HvGetCell(Hive, LeafArray[i]);
            if( Leaf == NULL ) {
                //
                // we couldn't map the bin containing this cell
                //
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto ErrorExit2;
            }
            // release the cell right here as we are holding the reglock exclusive
            HvReleaseCell(Hive, LeafArray[i]);
            if( !HvMarkCellDirty(Hive, LeafArray[i], FALSE) ) {
                status = STATUS_NO_LOG_SPACE;
                goto ErrorExit2;
            }
            if ( (Leaf->Signature == CM_KEY_FAST_LEAF) ||
                 (Leaf->Signature == CM_KEY_HASH_LEAF) ) {
                FastLeaf = (PCM_KEY_FAST_INDEX)Leaf;
                for (j=0; j < FastLeaf->Count; j++) {
                    if (FastLeaf->List[j].Cell == Cell) {
                        FastLeaf->List[j].Cell = newroot;
                        goto FoundCell;
                    }
                }
            } else {
                for (j=0; j < Leaf->Count; j++) {
                    if (Leaf->List[j] == Cell) {

                        Leaf->List[j] = newroot;
                        goto FoundCell;
                    }
                }
            }
        }
        ASSERT(FALSE);      //  implies we didn't find it
                        //  we should never get here
    }

FoundCell:


    //
    // Fix up the key control block to point to the new root
    //
    KeyControlBlock->KeyCell = newroot;

    //
    // Kcb has changed, update the cache information.
    // Registry locked exclusively, no need for KCB lock.
    //
    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

    CmpCleanUpKcbValueCache(KeyControlBlock);

    {
        PCM_KEY_NODE    Node = (PCM_KEY_NODE)HvGetCell(KeyControlBlock->KeyHive,KeyControlBlock->KeyCell);

        if( Node == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit2;
        }

        // release the cell right here as we are holding the reglock exclusive
        HvReleaseCell(KeyControlBlock->KeyHive,KeyControlBlock->KeyCell);

        CmpSetUpKcbValueCache(KeyControlBlock,Node->ValueList.Count,Node->ValueList.List);
        KeyControlBlock->Flags = Node->Flags;

        CmpAssignSecurityToKcb(KeyControlBlock,Node->Security,FALSE);
        
        //
        // we need to update the other kcb cache members too!!!
        //
        CmpCleanUpSubKeyInfo (KeyControlBlock);
        KeyControlBlock->KcbLastWriteTime = Node->LastWriteTime;  
        KeyControlBlock->KcbMaxNameLen = (USHORT)Node->MaxNameLen;
        KeyControlBlock->KcbMaxValueNameLen = (USHORT)Node->MaxValueNameLen;
        KeyControlBlock->KcbMaxValueDataLen = Node->MaxValueDataLen;
    
    }

    KeyControlBlock->ExtFlags = 0;

    // mark the cached info as not valid
    KeyControlBlock->ExtFlags |= CM_KCB_INVALID_CACHED_INFO;

    //
    // Delete the old subtree and it's root cell
    //
    CmpDeleteTree(Hive, Cell);
    CmpFreeKeyByCell(Hive, Cell, FALSE);

    //
    // Report the notify event
    //
    CmpReportNotify(KeyControlBlock,
                    KeyControlBlock->KeyHive,
                    KeyControlBlock->KeyCell,
                    REG_NOTIFY_CHANGE_NAME);
    

    //
    // Free the temporary hive
    //
    CmpDestroyTemporaryHive(TmpCmHive);

    //
    // We've given user chance to log on, so turn on quota
    //
    if (CmpProfileLoaded == FALSE) {
        CmpProfileLoaded = TRUE;
        CmpSetGlobalQuotaAllowed();
    }

    DCmCheckRegistry(CONTAINING_RECORD(Hive, CMHIVE, Hive));
    CmpUnlockRegistry();
    return status;


    //
    // Error exits
    //
ErrorExit2:
    CmpDestroyTemporaryHive(TmpCmHive);
ErrorExit1:
    DCmCheckRegistry(CONTAINING_RECORD(Hive, CMHIVE, Hive));
    CmpUnlockRegistry();

    return status;
}


NTSTATUS
CmpLoadHiveVolatile(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    IN HANDLE FileHandle
    )

/*++

Routine Description:

    Creates a VOLATILE hive and loads it underneath the given Hive and Cell.
    The data for the volatile hive is copied out of the given file.  The
    file is *NOT* in use by the registry when this returns.

Arguments:

    Hive - Supplies the hive that the new hive is to be created under.
           Currently this must be the Master Hive.

    Cell - Supplies the HCELL_INDEX of the new hive's parent.  (Usually
           will by \Registry\User)

    FileHandle - Supplies a handle to the hive file that will be copied
           into the volatile hive.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS status;
    PHHIVE Hive;
    PCELL_DATA RootData;
    PCMHIVE NewHive;
    PCMHIVE TempHive;
    HCELL_INDEX Cell;
    HCELL_INDEX Root;
    NTSTATUS Status;
    UNICODE_STRING RootName;
    UNICODE_STRING NewName;
    USHORT NewNameLength;
    PUNICODE_STRING ConstructedName;
    PRELEASE_CELL_ROUTINE   SourceReleaseCellRoutine;
    PRELEASE_CELL_ROUTINE   TargetReleaseCellRoutine;

    CM_PAGED_CODE();
    CmpLockRegistryExclusive();

    if (KeyControlBlock->Delete) {
        CmpUnlockRegistry();
        return(STATUS_KEY_DELETED);
    }
    Hive = KeyControlBlock->KeyHive;
    Cell = KeyControlBlock->KeyCell;

    if( IsHiveFrozen(((PCMHIVE)Hive)) ) {
        //
        // deny attempts to clobber with a frozen hive
        //
        CmpUnlockRegistry();
        return STATUS_TOO_LATE;
    }
    //
    // New hives can be created only under the master hive.
    //

    if (Hive != &CmpMasterHive->Hive) {
        CmpUnlockRegistry();
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Create a temporary hive and load the file into it
    //
    status = CmpInitializeHive(&TempHive,
                           HINIT_FILE,
                           0,
                           HFILE_TYPE_PRIMARY,
                           NULL,
                           FileHandle,
                           NULL,
                           NULL,
                           NULL,
                           CM_CHECK_REGISTRY_CHECK_CLEAN); 
    if (!NT_SUCCESS(status)) {
        CmpUnlockRegistry();
        return(status);
    }                           

    //
    // Create the volatile hive.
    //
    status = CmpInitializeHive(&NewHive,
                           HINIT_CREATE,
                           HIVE_VOLATILE,
                           0,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           0);
    if (!NT_SUCCESS(status)) {
        CmpDestroyTemporaryHive(TempHive);
        CmpUnlockRegistry();
        return(status);
    }                           

    //
    // Create the target root
    //
    SourceReleaseCellRoutine = TempHive->Hive.ReleaseCellRoutine;
    TargetReleaseCellRoutine = NewHive->Hive.ReleaseCellRoutine;
    TempHive->Hive.ReleaseCellRoutine = NULL;
    NewHive->Hive.ReleaseCellRoutine = NULL;

    Root = CmpCopyKeyPartial(&TempHive->Hive,
                             TempHive->Hive.BaseBlock->RootCell,
                             &NewHive->Hive,
                             HCELL_NIL,
                             FALSE);

    TempHive->Hive.ReleaseCellRoutine = SourceReleaseCellRoutine;
    NewHive->Hive.ReleaseCellRoutine = TargetReleaseCellRoutine;

    if (Root == HCELL_NIL) {
        CmpDestroyTemporaryHive(TempHive);
        CmpDestroyTemporaryHive(NewHive);
        CmpUnlockRegistry();
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    NewHive->Hive.BaseBlock->RootCell = Root;

    //
    // Copy the temporary hive into the volatile hive
    //
    if (!CmpCopyTree(&TempHive->Hive,
                    TempHive->Hive.BaseBlock->RootCell,
                    &NewHive->Hive,
                    Root))
    {
        CmpDestroyTemporaryHive(TempHive);
        CmpDestroyTemporaryHive(NewHive);
        CmpUnlockRegistry();
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // The volatile hive now has all the right stuff in all the right places,
    // we just need to link it into the master hive.
    //
    RootData = HvGetCell(&NewHive->Hive,Root);
    if( RootData == NULL ) {
        //
        // we couldn't map the bin containing this cell
        // this shouldn't happen, as we just allocated this cell
        // (i.e. it should be PINNED in memory at this point)
        //
        ASSERT( FALSE );
        CmpDestroyTemporaryHive(TempHive);
        CmpDestroyTemporaryHive(NewHive);
        CmpUnlockRegistry();
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    // release the cell right here as we are holding the reglock exclusive
    HvReleaseCell(&NewHive->Hive,Root);

    ConstructedName = CmpConstructName(KeyControlBlock);
    
    NewNameLength = ConstructedName->Length +
                CmpHKeyNameLen(&RootData->u.KeyNode) +
                sizeof(WCHAR);
    NewName.Buffer = ExAllocatePool(PagedPool, NewNameLength);
    if (NewName.Buffer == NULL) {
        CmpDestroyTemporaryHive(TempHive);
        CmpDestroyTemporaryHive(NewHive);
        CmpUnlockRegistry();
        ExFreePoolWithTag(ConstructedName, CM_NAME_TAG | PROTECTED_POOL);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    NewName.Length = NewName.MaximumLength = NewNameLength;
    RtlCopyUnicodeString(&NewName, ConstructedName);
    ExFreePoolWithTag(ConstructedName, CM_NAME_TAG | PROTECTED_POOL);
    RtlAppendUnicodeToString(&NewName, L"\\");

    if (RootData->u.KeyNode.Flags & KEY_COMP_NAME) {
        CmpCopyCompressedName(NewName.Buffer + (NewName.Length / sizeof(WCHAR)),
                              NewName.MaximumLength - NewName.Length,
                              RootData->u.KeyNode.Name,
                              CmpHKeyNameLen(&RootData->u.KeyNode));
        NewName.Length += CmpHKeyNameLen(&RootData->u.KeyNode);
    } else {
        RootName.Buffer = RootData->u.KeyNode.Name;
        RootName.Length = RootName.MaximumLength = RootData->u.KeyNode.NameLength;

        RtlAppendUnicodeStringToString(&NewName,&RootName);
    }

    Status = CmpLinkHiveToMaster(&NewName,
                                 NULL,
                                 NewHive,
                                 FALSE,
                                 NULL);
    if (NT_SUCCESS(Status)) {
        // call the worker to add the hive to the list
        CmpAddToHiveFileList(NewHive);
    } else {
        CmpDestroyTemporaryHive(NewHive);
    }
    CmpDestroyTemporaryHive(TempHive);

    ExFreePool(NewName.Buffer);

    if (NT_SUCCESS(Status)) {
        //
        // We've given user chance to log on, so turn on quota
        //
        if (CmpProfileLoaded == FALSE) {
            CmpProfileLoaded = TRUE;
            CmpSetGlobalQuotaAllowed();
        }
    }

    CmpUnlockRegistry();
    return(Status);
}



ULONG
CmpRefreshWorkerRoutine(
    PCM_KEY_CONTROL_BLOCK Current,
    PVOID                 Context1,
    PVOID                 Context2
    )
/*++

Routine Description:

    Helper used by CmpRefreshHive when calling
    CmpSearchKeyControlBlockTree.

    If a match is found, the KCB is deleted and restart is returned.
    Else, continue is returned.

Arguments:

    Current - the kcb to examine

    Context1 - the hive to match against

    Context2 - nothing

Return Value:

    if no match, return continue.

    if match, return restart.

--*/
{
    CM_PAGED_CODE();

    UNREFERENCED_PARAMETER (Context2);

    if (Current->KeyHive == (PHHIVE)Context1) {

        //
        // match.  set deleted flag.  continue search.
        //
        Current->Delete = TRUE;
        Current->KeyHive = NULL;
        Current->KeyCell = 0;
        return(KCB_WORKER_DELETE);
    }
    return KCB_WORKER_CONTINUE;
}


NTSTATUS
CmpRefreshHive(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock
    )
/*++

Routine Description:

    Backs out all changes to a hives since it was last flushed.
    Used as a transaction abort by the security system.

    Caller must have SeTcbPrivilege.

    The target hive must have HIVE_NOLAZYFLUSH set.

    KeyControlBlock must refer to the root of the hive (HIVE_ENTRY must
    be set in the key.)

    Any kcbs that point into this hive (and thus any handles open
    against it) will be force to DELETED state.  (If we do any work.)

    All notifies pending against the hive will be flushed.

    When we're done, only the tombstone kcbs, handles, and attached
    notify blocks will be left.

    WARNNOTE:   Once reads have begun, if the operation fails, the hive
                will be corrupt, so we will bugcheck.

Arguments:

    KeyControlBlock - provides a reference to the root of the hive
                      we wish to refresh.

Return Value:

    NTSTATUS

--*/
{
    PHHIVE              Hive;
    PLIST_ENTRY         ptr;
    PCM_NOTIFY_BLOCK    node;

    CM_PAGED_CODE();
    //
    // Check to see if the caller has the privilege to make this call.
    //
    if (!SeSinglePrivilegeCheck(SeTcbPrivilege, KeGetPreviousMode())) {
        return STATUS_PRIVILEGE_NOT_HELD;
    }

    if (KeyControlBlock->Delete) {
        return(STATUS_KEY_DELETED);
    }
    CmpLockRegistryExclusive();
    Hive = KeyControlBlock->KeyHive;

    if( IsHiveFrozen(((PCMHIVE)Hive)) ) {
        //
        // deny attempts to clobber with a frozen hive
        //
        CmpUnlockRegistry();
        return STATUS_TOO_LATE;
    }

    //
    // check to see if hive is of proper type
    //
    if ( ! (Hive->HiveFlags & HIVE_NOLAZYFLUSH)) {
        CmpUnlockRegistry();
        return STATUS_INVALID_PARAMETER;
    }

    //
    // punt if any volatile storage has been allocated
    //
    if (Hive->Storage[Volatile].Length != 0) {
        CmpUnlockRegistry();
        return STATUS_UNSUCCESSFUL;
    }

    if ( ! (KeyControlBlock->Flags & KEY_HIVE_ENTRY)) {
        CmpUnlockRegistry();
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Flush all NotifyBlocks attached to this hive
    //
    while (TRUE) {

        //
        // flush below will edit list, so restart at beginning each time
        //
        ptr = &(((PCMHIVE)Hive)->NotifyList);
        if (ptr->Flink == NULL) {
            break;
        }

        ptr = ptr->Flink;
        node = CONTAINING_RECORD(ptr, CM_NOTIFY_BLOCK, HiveList);
        ASSERT((node->KeyBody)->NotifyBlock == node);
        CmpFlushNotify(node->KeyBody,TRUE);
    }

    //
    // Force all kcbs that refer to this hive to the deleted state.
    //
    CmpSearchKeyControlBlockTree(
        CmpRefreshWorkerRoutine,
        (PVOID)Hive,
        NULL
        );

    //
    // Call the worker to do the refresh
    //
    HvRefreshHive(Hive);

    CmpUnlockRegistry();
    //
    // we're back (rather than bugchecked) so it worked
    //
    return STATUS_SUCCESS;
}

NTSTATUS
CmDumpKey(
    IN PCM_KEY_CONTROL_BLOCK    KeyControlBlock,
    IN HANDLE                   FileHandle
    )
/*++

Routine Description:
    
    Dumps the key into the specified File - no tree copy.
    It is supposed to work fast, Works only when KeyControlBlock is 
    the root of the hive

Arguments:

    KeyControlBlock - pointer to the KCB that describes the key

    FileHandle - handle of the file to dump to.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status;
    PHHIVE                  Hive;
    HCELL_INDEX             Cell;
    PCMHIVE                 CmHive;

    CM_PAGED_CODE();

    //
    // Disallow attempts to "save" the master hive
    //
    Hive = KeyControlBlock->KeyHive;
    if (Hive == &CmpMasterHive->Hive) {
        return STATUS_ACCESS_DENIED;
    }

    CmpLockRegistry();

    //
    // Punt if post shutdown
    //
    if (HvShutdownComplete) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmDumpKey: Attempt to write hive AFTER SHUTDOWN\n"));
        CmpUnlockRegistry();
        return STATUS_REGISTRY_IO_FAILED;
    }

    CmpLockKCBShared(KeyControlBlock);
    if (KeyControlBlock->Delete) {
        CmpUnlockKCB(KeyControlBlock);
        CmpUnlockRegistry();
        return STATUS_KEY_DELETED;
    }
    //
    // Make sure the cell passed in is the root cell of the hive.
    //
    Cell = KeyControlBlock->KeyCell;
    if (Cell != Hive->BaseBlock->RootCell) {
        CmpUnlockKCB(KeyControlBlock);
        CmpUnlockRegistry();
        return STATUS_INVALID_PARAMETER;
    }

    CmHive = (PCMHIVE)CONTAINING_RECORD(Hive, CMHIVE, Hive);

    // 
    // no writes while we are dumping the hive
    // also protects against lazy flusher
    //
    CmpLockHiveFlusherExclusive(CmHive);
    // sanity
    ASSERT( CmHive->FileHandles[HFILE_TYPE_EXTERNAL] == NULL );
    CmHive->FileHandles[HFILE_TYPE_EXTERNAL] = FileHandle;
    status = HvWriteHive(Hive,FALSE,FALSE,FALSE);
    CmHive->FileHandles[HFILE_TYPE_EXTERNAL] = NULL;

    CmpUnlockHiveFlusher(CmHive);
    CmpUnlockKCB(KeyControlBlock);
    CmpUnlockRegistry();
    return status;
}

NTSTATUS
CmSaveKey(
    IN PCM_KEY_CONTROL_BLOCK    KeyControlBlock,
    IN HANDLE                   FileHandle,
    IN ULONG                    HiveVersion
    )
/*++

Routine Description:

Arguments:

    KeyControlBlock - pointer to the KCB that describes the key

    FileHandle - handle of the file to dump to.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status;
    PCMHIVE                 TmpCmHive;
    PCMHIVE                 CmHive;
    HCELL_INDEX             newroot;
    PHHIVE                  Hive;
    HCELL_INDEX             Cell;

    CM_PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"CmSaveKey:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tKCB=%p",KeyControlBlock));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tFileHandle=%08lx\n",FileHandle));

    //
    // Disallow attempts to "save" the master hive
    //
    Hive = KeyControlBlock->KeyHive;

    if (Hive == &CmpMasterHive->Hive) {
        return STATUS_ACCESS_DENIED;
    }

    CmpLockRegistry();

    CmpLockKCBShared(KeyControlBlock);
    if (KeyControlBlock->Delete) {
        CmpUnlockKCB(KeyControlBlock);
        CmpUnlockRegistry();
        return STATUS_KEY_DELETED;
    }

    Cell = KeyControlBlock->KeyCell;

    CmHive = (PCMHIVE)CONTAINING_RECORD(Hive, CMHIVE, Hive);

    DCmCheckRegistry(CmHive);
    if ( (Hive->HiveFlags & HIVE_NOLAZYFLUSH) &&
         (Hive->DirtyCount != 0) &&
         (CmHive->FileHandles[HFILE_TYPE_PRIMARY] != NULL)
         )
    {
        //
        // we really need the lock exclusive in this case as we can't afford somebody else 
        // to alter the file
        //
        CmpUnlockKCB(KeyControlBlock);
        CmpUnlockRegistry();
        CmpLockRegistryExclusive();
        if (KeyControlBlock->Delete) {
            CmpUnlockRegistry();
            return STATUS_KEY_DELETED;
        }

        //
        // It's a NOLAZY hive, and there's some dirty data, so writing
        // out a snapshot of what's in memory will not give the caller
        // consistent user data.  Therefore, copy the on disk image
        // instead of the memory image
        //

        //
        // Note that this will generate weird results if the key
        // being saved is not the root of the hive, since the
        // resulting file will always be a copy of the entire hive, not
        // just the subtree they asked for.
        //
        status = CmpSaveKeyByFileCopy((PCMHIVE)Hive, FileHandle);

        CmpUnlockRegistry();
        return status;
    }

    ENTER_FLUSH_MODE();
    //
    // Always try to copy the hive and write it out.  This has the
    // effect of compressing out unused free storage.
    // If there isn't space, and the savekey is of the root of the
    // hive, then just write it out directly.  (i.e. don't fail on
    // a whole hive restore just because we're out of memory.)
    //
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tSave of partial hive\n"));

    //
    // The subtree the caller wants does not exactly match a
    // subtree.  Make a temporary hive, tree copy the source
    // to temp, write out the temporary, free the temporary.
    //

    //
    // Create the temporary hive
    //

    TmpCmHive = CmpCreateTemporaryHive(FileHandle);
    if (TmpCmHive == NULL) {
        status =  STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorInsufficientResources;
    }

    //
    // Create a root cell, mark it as such
    //

    //
    // overwrite the hive's minor version in order to implement NtSaveKeyEx
    //
    TmpCmHive->Hive.BaseBlock->Minor = HiveVersion;
    TmpCmHive->Hive.Version = HiveVersion;
    
    // 
    // no writes while we are copying the hive
    //
    CmpLockHiveFlusherExclusive(TmpCmHive);
    CmpLockHiveFlusherExclusive(CmHive);
    newroot = CmpCopyKeyPartial(
                Hive,
                Cell,
                &(TmpCmHive->Hive),
                HCELL_NIL,          // will force KEY_HIVE_ENTRY set
                TRUE);

    if (newroot == HCELL_NIL) {
        CmpUnlockHiveFlusher(TmpCmHive);
        CmpUnlockHiveFlusher(CmHive);
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorInsufficientResources;
    }
    TmpCmHive->Hive.BaseBlock->RootCell = newroot;

    //
    // Do a tree copy
    //
    if (CmpCopyTree(Hive, Cell, &(TmpCmHive->Hive), newroot) == FALSE) {
        CmpUnlockHiveFlusher(TmpCmHive);
        CmpUnlockHiveFlusher(CmHive);
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorInsufficientResources;
    }
    CmpUnlockHiveFlusher(CmHive);
    //
    // Write the file
    //
    ASSERT( TmpCmHive->FileHandles[HFILE_TYPE_EXTERNAL] == NULL );
    TmpCmHive->FileHandles[HFILE_TYPE_EXTERNAL] = FileHandle;
    status = HvWriteHive(&(TmpCmHive->Hive),FALSE,FALSE,FALSE);
    TmpCmHive->FileHandles[HFILE_TYPE_EXTERNAL] = NULL;
    CmpUnlockHiveFlusher(TmpCmHive);

    //
    // Error exits
    //
ErrorInsufficientResources:

    //
    // Free the temporary hive
    //
    if (TmpCmHive != NULL) {
        CmpDestroyTemporaryHive(TmpCmHive);
    }

    DCmCheckRegistry(CONTAINING_RECORD(Hive, CMHIVE, Hive));

    CmpUnlockKCB(KeyControlBlock);
    EXIT_FLUSH_MODE();
    CmpUnlockRegistry();
    return status;
}

#define CM_SAVE_MERGED_TMP_HIVE     1
#define CM_SAVE_MERGED_HIGH_HIVE    2
#define CM_SAVE_MERGED_LOW_HIVE     4

NTSTATUS
CmSaveMergedKeys(
    IN PCM_KEY_CONTROL_BLOCK    HighPrecedenceKcb,
    IN PCM_KEY_CONTROL_BLOCK    LowPrecedenceKcb,
    IN HANDLE   FileHandle
    )
/*++

Routine Description:

Arguments:

    HighPrecedenceKcb - pointer to the KCB that describes the High precedence key 
                        (the one that wins in a duplicate key case)

    LowPrecedenceKcb - pointer to the KCB that describes the Low precedence key 
                        (the one that gets overwritten in a duplicate key case)

    FileHandle - handle of the file to dump to.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PCMHIVE     TmpCmHive;
    HCELL_INDEX newroot;
    PHHIVE HighHive;
    PHHIVE LowHive;
    HCELL_INDEX HighCell;
    HCELL_INDEX LowCell;
    PCM_KEY_NODE HighNode,LowNode;
    ULONG                   FlusherLocks = 0; //none
    HV_TRACK_CELL_REF       CellRef = {0};
    PRELEASE_CELL_ROUTINE   TmpReleaseCellRoutine;

    CM_PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"CmSaveMergedKeys:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tHighKCB=%p",HighPrecedenceKcb));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tLowKCB=%p",LowPrecedenceKcb));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tFileHandle=%08lx\n",FileHandle));

    //
    // Disallow attempts to "merge" keys located in the same hive
    // A brutal way to avoid recursivity
    //
    HighHive = HighPrecedenceKcb->KeyHive;
    LowHive = LowPrecedenceKcb->KeyHive;

    if (LowHive  == HighHive ) {
        return STATUS_INVALID_PARAMETER;
    }

    CmpLockRegistry();
    CmpLockTwoHashEntriesShared(HighPrecedenceKcb->ConvKey,LowPrecedenceKcb->ConvKey);

    if (HighPrecedenceKcb->Delete || LowPrecedenceKcb->Delete) {
        //
        // Unlock the registry and fail if one of the keys are marked as deleted
        //
        CmpUnlockTwoHashEntries(HighPrecedenceKcb->ConvKey,LowPrecedenceKcb->ConvKey);
        CmpUnlockRegistry();
        return STATUS_KEY_DELETED;
    }

    DCmCheckRegistry(CONTAINING_RECORD(HighHive, CMHIVE, Hive));
    DCmCheckRegistry(CONTAINING_RECORD(LowHive, CMHIVE, Hive));

    HighCell = HighPrecedenceKcb->KeyCell;
    LowCell = LowPrecedenceKcb->KeyCell;

    if( ((HighHive->HiveFlags & HIVE_NOLAZYFLUSH) && (HighHive->DirtyCount != 0)) ||
        ((LowHive->HiveFlags & HIVE_NOLAZYFLUSH) && (LowHive->DirtyCount != 0)) ) {
        //
        // Reject the call when one of the hives is a NOLAZY hive and there's
        // some dirty data. Another alternative will be to save only one of the 
        // trees (if a valid one exists) or an entire hive (see CmSaveKey)
        //
        status =  STATUS_INVALID_PARAMETER;

        CmpUnlockTwoHashEntries(HighPrecedenceKcb->ConvKey,LowPrecedenceKcb->ConvKey);
        CmpUnlockRegistry();
        return status;
    }

    ENTER_FLUSH_MODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tCopy of partial HighHive\n"));

    //
    // Make a temporary hive, tree copy the key subtree from
    // HighHive hive to temp, tree-merge with the key subtree from
    // LowHive hive, write out the temporary, free the temporary.
    // Always write the HighHive subtree first, so its afterwise
    // only add new keys/values
    // 

    //
    // Create the temporary hive
    //

    TmpCmHive = CmpCreateTemporaryHive(FileHandle);
    if (TmpCmHive == NULL) {
        status =  STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorInsufficientResources;
    }

    //
    // Create a root cell, mark it as such
    //

    // 
    // no writes while we are copying the hive
    //
    CmpLockHiveFlusherExclusive(TmpCmHive);
    CmpLockHiveFlusherExclusive((PCMHIVE)HighHive);
    FlusherLocks |= (CM_SAVE_MERGED_TMP_HIVE|CM_SAVE_MERGED_HIGH_HIVE);

    newroot = CmpCopyKeyPartial(
                HighHive,
                HighCell,
                &(TmpCmHive->Hive),
                HCELL_NIL,          // will force KEY_HIVE_ENTRY set
                TRUE);

    if (newroot == HCELL_NIL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorInsufficientResources;
    }
    TmpCmHive->Hive.BaseBlock->RootCell = newroot;

    //
    // Do a tree copy. Copy the HighCell tree from HighHive first.
    //
    if (CmpCopyTree(HighHive, HighCell, &(TmpCmHive->Hive), newroot) == FALSE) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorInsufficientResources;
    }

    //
    // don't need this guys anymore
    //
    CmpUnlockHiveFlusher((PCMHIVE)HighHive);
    FlusherLocks &= (~CM_SAVE_MERGED_HIGH_HIVE);
    
    CmpLockHiveFlusherExclusive((PCMHIVE)LowHive);
    FlusherLocks |= (CM_SAVE_MERGED_LOW_HIVE);
    //
    // Merge the values in the root node of the merged subtrees
    //
    LowNode = (PCM_KEY_NODE)HvGetCell(LowHive, LowCell);                                         
    if( LowNode == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorInsufficientResources;
    }

    if( !HvTrackCellRef(&CellRef,LowHive, LowCell) ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorInsufficientResources;
    }

    HighNode = (PCM_KEY_NODE)HvGetCell(&(TmpCmHive->Hive),newroot);
    if( HighNode == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorInsufficientResources;
    }

    if( !HvTrackCellRef(&CellRef,&(TmpCmHive->Hive),newroot) ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorInsufficientResources;
    }

    //
    // safe to do this since it's an in memory hive
    //
    TmpReleaseCellRoutine = TmpCmHive->Hive.ReleaseCellRoutine;
    TmpCmHive->Hive.ReleaseCellRoutine = NULL;
    if (CmpMergeKeyValues(LowHive, LowCell, LowNode, &(TmpCmHive->Hive), newroot, HighNode) == FALSE ){
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorInsufficientResources;
    }
    TmpCmHive->Hive.ReleaseCellRoutine = TmpReleaseCellRoutine;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tMerge partial LowHive over the HighHive\n"));

    //
    // Merge the two trees. A Merge operation is a sync that obeys
    // the following additional rules:
    //      1. keys the exist in the target tree and does not exist
    //      in the source tree remain as they are (don't get deleted)
    //      2. keys the doesn't exist both in the target tree are added
    //      "as they are" from the source tree (always the target tree
    //      has a higher precedence)
    // 
    if (CmpMergeTrees(LowHive, LowCell, &(TmpCmHive->Hive), newroot) == FALSE) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorInsufficientResources;
    }

    CmpUnlockHiveFlusher((PCMHIVE)LowHive);
    FlusherLocks &= (~CM_SAVE_MERGED_LOW_HIVE);
    
    //
    // Write the file
    //
    ASSERT( TmpCmHive->FileHandles[HFILE_TYPE_EXTERNAL] == NULL );
    TmpCmHive->FileHandles[HFILE_TYPE_EXTERNAL] = FileHandle;
    status = HvWriteHive(&(TmpCmHive->Hive),FALSE,FALSE,FALSE);
    TmpCmHive->FileHandles[HFILE_TYPE_EXTERNAL] = NULL;

    //
    // Error exits
    //
ErrorInsufficientResources:
    //
    // let go of those refcounts
    //
    HvReleaseFreeCellRefArray(&CellRef);
    //
    // unlock whatever happens to have been locked
    //
    if( FlusherLocks & CM_SAVE_MERGED_LOW_HIVE ) {
        // sanity
        ASSERT( !(FlusherLocks & CM_SAVE_MERGED_HIGH_HIVE) );
        CmpUnlockHiveFlusher((PCMHIVE)LowHive);
    }
    if( FlusherLocks & CM_SAVE_MERGED_HIGH_HIVE ) {
        // sanity
        ASSERT( !(FlusherLocks & CM_SAVE_MERGED_LOW_HIVE) );
        CmpUnlockHiveFlusher((PCMHIVE)HighHive);
    }
    if( FlusherLocks & CM_SAVE_MERGED_TMP_HIVE ) {
        CmpUnlockHiveFlusher(TmpCmHive);
    }
    //
    // Free the temporary hive
    //
    if (TmpCmHive != NULL) {
        CmpDestroyTemporaryHive(TmpCmHive);
    }

    //
    // Set global quota back to what it was.
    //
    DCmCheckRegistry(CONTAINING_RECORD(HighHive, CMHIVE, Hive));
    DCmCheckRegistry(CONTAINING_RECORD(LowHive, CMHIVE, Hive));

    CmpUnlockTwoHashEntries(HighPrecedenceKcb->ConvKey,LowPrecedenceKcb->ConvKey);
    EXIT_FLUSH_MODE();
    CmpUnlockRegistry();
    return status;
}


NTSTATUS
CmpSaveKeyByFileCopy(
    PCMHIVE  CmHive,
    HANDLE  FileHandle
    )
/*++

Routine Description:

    Do special case of SaveKey by copying the hive file

Arguments:

    CmHive - supplies a pointer to an HHive

    FileHandle - open handle to target file

Return Value:

    NTSTATUS - Result code from call, among the following:

--*/
{
    PHBASE_BLOCK    BaseBlock;
    NTSTATUS        status;
    ULONG           Offset;
    ULONG           Length;
    ULONG           Position;
    PUCHAR          CopyBuffer;
    ULONG           BufferLength;
    ULONG           BytesToCopy;
    CMP_OFFSET_ARRAY offsetElement;

    CM_PAGED_CODE();

    //
    // Attempt to allocate large buffer for copying stuff around.  If
    // we can't get one, just use the stash buffer.
    //
    BufferLength = CM_SAVEKEYBUFSIZE;
    try {
        CopyBuffer = ExAllocatePoolWithQuota(PagedPoolCacheAligned,
                                             BufferLength);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        CopyBuffer = NULL;
    }
    CmpLockRegistryExclusive();
    if (CopyBuffer == NULL) {
        LOCK_STASH_BUFFER();
        CopyBuffer = CmpStashBuffer;
        BufferLength = HBLOCK_SIZE;
    }
    //
    // Read the base block, step the sequence number, and write it out
    //
    status = STATUS_REGISTRY_IO_FAILED;

    CmHive->FileHandles[HFILE_TYPE_EXTERNAL] = FileHandle;

    Offset = 0;

    if( !CmpFileRead((PHHIVE)CmHive,HFILE_TYPE_PRIMARY,&Offset,CopyBuffer,HBLOCK_SIZE) ) {
        goto ErrorExit;
    }

    BaseBlock = (PHBASE_BLOCK)CopyBuffer;
    Length = BaseBlock->Length;

    BaseBlock->Sequence1++;

    Offset = 0;
    offsetElement.FileOffset = Offset;
    offsetElement.DataBuffer = CopyBuffer;
    offsetElement.DataLength = HBLOCK_SIZE;
    if ( ! CmpFileWrite((PHHIVE)CmHive, HFILE_TYPE_EXTERNAL, &offsetElement,
                        1, &Offset))
    {
        goto ErrorExit;
    }

    //
    // Flush the external, so header will show corrupt until we're done
    //
    if (CmpFileFlush((PHHIVE)CmHive, HFILE_TYPE_EXTERNAL,NULL,0)) {
        status = STATUS_SUCCESS;
    }

    //
    // For span of data, read from master and write to external
    //
    for (Position = 0; Position < Length; Position += BytesToCopy) {

        Offset = Position + HBLOCK_SIZE;
        BytesToCopy = Length-Position;
        if (BytesToCopy > BufferLength) {
            BytesToCopy = BufferLength;
        }

        if( !CmpFileRead((PHHIVE)CmHive,HFILE_TYPE_PRIMARY,&Offset,CopyBuffer,BytesToCopy) ) {
            goto ErrorExit;
        }

        Offset = Position + HBLOCK_SIZE;
        offsetElement.FileOffset = Offset;
        offsetElement.DataBuffer = CopyBuffer;
        offsetElement.DataLength = BytesToCopy;
        if ( ! CmpFileWrite((PHHIVE)CmHive, HFILE_TYPE_EXTERNAL, &offsetElement,
                            1, &Offset))
        {
            goto ErrorExit;
        }
    }

    //
    // Flush the external, so data is there before we update the header
    //
    if (CmpFileFlush((PHHIVE)CmHive, HFILE_TYPE_EXTERNAL,NULL,0)) {
        status = STATUS_SUCCESS;
    }

    //
    // Reread the base block, sync the seq #, rewrite it.
    // (Brute force, but means no memory alloc - always works)
    //
    Offset = 0;
    if( !CmpFileRead((PHHIVE)CmHive,HFILE_TYPE_PRIMARY,&Offset,CopyBuffer,HBLOCK_SIZE) ) {
        goto ErrorExit;
    }
    BaseBlock->Sequence1++;     // it got trampled when we reread it
    BaseBlock->Sequence2++;

    Offset = 0;
    offsetElement.FileOffset = Offset;
    offsetElement.DataBuffer = CopyBuffer;
    offsetElement.DataLength = HBLOCK_SIZE;
    if ( ! CmpFileWrite((PHHIVE)CmHive, HFILE_TYPE_EXTERNAL, &offsetElement,
                        1, &Offset))
    {
        goto ErrorExit;
    }

    //
    // Flush the external, and we are done
    //
    if (CmpFileFlush((PHHIVE)CmHive, HFILE_TYPE_EXTERNAL,NULL,0)) {
        status = STATUS_SUCCESS;
    }

ErrorExit:
    if (CopyBuffer != CmpStashBuffer) {
        ExFreePool(CopyBuffer);
    } else {
        UNLOCK_STASH_BUFFER();
    }
    CmHive->FileHandles[HFILE_TYPE_EXTERNAL] = NULL;
    CmpUnlockRegistry();
    return status;
}


PCMHIVE
CmpCreateTemporaryHive(
    IN HANDLE FileHandle
    )
/*++

Routine Description:

    Allocates and inits a temporary hive.

Arguments:

    FileHandle - Supplies the handle of the file to back the hive.

Return Value:

    Pointer to CmHive.

    If NULL the operation failed.

--*/
{
    PCMHIVE TempHive;
    NTSTATUS Status;

    CM_PAGED_CODE();

    UNREFERENCED_PARAMETER (FileHandle);

    //
    // NOTE: Hive will get put on CmpHiveListHead list.
    //       Make sure CmpDestroyTemporaryHive gets called to remove it.
    //

    Status = CmpInitializeHive(&TempHive,
                          HINIT_CREATE,
                          HIVE_VOLATILE,
                          0,
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          0);
    if (NT_SUCCESS(Status)) {
        return(TempHive);
    } else {
        return(NULL);
    }

}


VOID
CmpDestroyTemporaryHive(
    PCMHIVE CmHive
    )
/*++

Routine Description:

    Frees all the pieces of a hive.

Arguments:

    CmHive - CM level hive structure to free

Return Value:

    None.

--*/
{
    CM_PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"CmpDestroyTemporaryHive:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tCmHive=%p\n", CmHive));

    if (CmHive == NULL) {
        return;
    }

    //
    // NOTE: Hive is on CmpHiveListHead list.
    //       Remove it.
    //
    CmpDestroyHiveViewList(CmHive);
    CmpDestroySecurityCache(CmHive);
    CmpDropFileObjectForHive(CmHive);
    CmpUnJoinClassOfTrust(CmHive);

    CmpLockHiveListExclusive();
    CmpRemoveEntryList(&CmHive->HiveList);
    CmpUnlockHiveList();

    HvFreeHive(&(CmHive->Hive));
    CmpFreeMutex(CmHive->ViewLock);
#if DBG
    CmpFreeResource(CmHive->FlusherLock);
#endif
    CmpFree(CmHive, sizeof(CMHIVE));
    return;
}

NTSTATUS
CmpOverwriteHive(
					PCMHIVE			CmHive,
					PCMHIVE			NewHive,
					HCELL_INDEX		LinkCell
					)
{
	HCELL_INDEX             RootCell;
	BOOLEAN					Result;
	PCM_KEY_NODE			RootNode;
    PULONG					Vector;
	ULONG					Length;

    CM_PAGED_CODE();

	// get rid of the views.
	CmpDestroyHiveViewList (CmHive);

    RootCell = NewHive->Hive.BaseBlock->RootCell;

	RootNode = (PCM_KEY_NODE)HvGetCell(&(NewHive->Hive),RootCell);
	if( RootNode == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
	}
	if( !HvMarkCellDirty(&(NewHive->Hive),RootCell, FALSE) ) {
		HvReleaseCell(&(NewHive->Hive),RootCell);
        return STATUS_NO_LOG_SPACE;
	}
	RootNode->Parent = LinkCell;
	RootNode->Flags |= KEY_HIVE_ENTRY | KEY_NO_DELETE;
	HvReleaseCell(&(NewHive->Hive),RootCell);
	//
	// dump data over to the log and primary
	//
	ASSERT( NewHive->Hive.DirtyVector.Buffer == NULL );
	ASSERT( NewHive->Hive.DirtyAlloc == 0 );
	Length = NewHive->Hive.Storage[Stable].Length;
	Vector = (PULONG)((NewHive->Hive.Allocate)(ROUND_UP(Length /HSECTOR_SIZE/8,sizeof(ULONG)),TRUE,CM_FIND_LEAK_TAG22));
	if (Vector == NULL) {
		return STATUS_NO_MEMORY;
	}
	RtlZeroMemory(Vector, Length / HSECTOR_SIZE / 8);
    RtlInitializeBitMap(&(NewHive->Hive.DirtyVector), Vector, Length / HSECTOR_SIZE);
	NewHive->Hive.DirtyAlloc = ROUND_UP(Length /HSECTOR_SIZE/8,sizeof(ULONG));
    RtlSetAllBits(&(NewHive->Hive.DirtyVector));
    NewHive->Hive.DirtyCount = NewHive->Hive.DirtyVector.SizeOfBitMap;
    NewHive->Hive.Log = TRUE;

	NewHive->FileHandles[HFILE_TYPE_LOG] = CmHive->FileHandles[HFILE_TYPE_LOG];
	
	Result = HvpGrowLog2(&(NewHive->Hive), Length);
	if( Result) {
		Result = HvpWriteLog(&(NewHive->Hive));
	}

	NewHive->FileHandles[HFILE_TYPE_LOG] = NULL;
	
	NewHive->Hive.Free(Vector,NewHive->Hive.DirtyAlloc);
	NewHive->Hive.DirtyAlloc = 0;
	NewHive->Hive.DirtyCount = 0;
	RtlZeroMemory(&(NewHive->Hive.DirtyVector),sizeof(RTL_BITMAP));
    NewHive->Hive.Log = FALSE;

	if( !Result ) {
        return STATUS_REGISTRY_IO_FAILED;
	}
	NewHive->FileHandles[HFILE_TYPE_EXTERNAL] = CmHive->FileHandles[HFILE_TYPE_PRIMARY];
	//
	// all data in the new hive is marked as dirty !!!
	// even if this fails; we are going to keep the hive in memory, so no problem, we have the log !
	//
	NewHive->FileObject = CmHive->FileObject;
    NewHive->Hive.BaseBlock->Type = HFILE_TYPE_PRIMARY;
	HvWriteHive(&(NewHive->Hive),Length <= CmHive->Hive.Storage[Stable].Length ? TRUE : FALSE,CmHive->FileObject != NULL ? TRUE : FALSE,TRUE);
	NewHive->FileHandles[HFILE_TYPE_EXTERNAL] = NULL;
	NewHive->FileObject = NULL;

    RtlClearAllBits(&(NewHive->Hive.DirtyVector));
    NewHive->Hive.DirtyCount = 0;
	return STATUS_SUCCESS;
}


VOID
CmpSwitchStorageAndRebuildMappings(PCMHIVE	OldCmHive,
								   PCMHIVE	NewCmHive
								   ) 
/*++

Routine Description:

    Switches relevant storage between the hives. Then, rebuilds 
	the kcb mapping according with the mapping stored inside OldHive

Arguments:

    OldHive - Hive to be updated; the one that is currently linked in 
	the registry tree

	NewHive - the compressed hive; it'll be freed after this operation.

Return Value:

    None.

--*/
{

	HHIVE							TmpHive;
    ULONG							i;
    PCM_KCB_REMAP_BLOCK				RemapBlock;
	PLIST_ENTRY						AnchorAddr;
	LOGICAL							OldSmallDir;
	LOGICAL							NewSmallDir;
    PFREE_HBIN                      FreeBin;
    PCM_KNODE_REMAP_BLOCK           KnodeRemapBlock;

	CM_PAGED_CODE();

	//
	// The baseblock
	//
    OldCmHive->Hive.BaseBlock->Sequence1 = NewCmHive->Hive.BaseBlock->Sequence1;
    OldCmHive->Hive.BaseBlock->Sequence2 = NewCmHive->Hive.BaseBlock->Sequence2;
    OldCmHive->Hive.BaseBlock->RootCell = NewCmHive->Hive.BaseBlock->RootCell;
    
	//
	// rest of the hive 
	//
	ASSERT( (NewCmHive->Hive.DirtyVector.Buffer == NULL) && 
			(NewCmHive->Hive.DirtyCount == 0) &&
			(NewCmHive->Hive.DirtyAlloc == 0) &&
			(OldCmHive->Hive.Storage[Stable].Length >= NewCmHive->Hive.Storage[Stable].Length) );

	OldCmHive->Hive.LogSize = NewCmHive->Hive.LogSize;
	NewCmHive->Hive.LogSize = 0;


	//
	// switch hive stable storage; preserving the volatile info
	//
	OldSmallDir = (OldCmHive->Hive.Storage[Stable].Map == (PHMAP_DIRECTORY)&(OldCmHive->Hive.Storage[Stable].SmallDir));
	NewSmallDir = (NewCmHive->Hive.Storage[Stable].Map == (PHMAP_DIRECTORY)&(NewCmHive->Hive.Storage[Stable].SmallDir));
	RtlCopyMemory(&(TmpHive.Storage[Stable]),&(OldCmHive->Hive.Storage[Stable]),sizeof(TmpHive.Storage[Stable]) - sizeof(LIST_ENTRY) );
	RtlCopyMemory(&(OldCmHive->Hive.Storage[Stable]),&(NewCmHive->Hive.Storage[Stable]),sizeof(TmpHive.Storage[Stable]) - sizeof(LIST_ENTRY) );
	RtlCopyMemory(&(NewCmHive->Hive.Storage[Stable]),&(TmpHive.Storage[Stable]),sizeof(TmpHive.Storage[Stable])  - sizeof(LIST_ENTRY) );
	if( OldSmallDir ) {
        NewCmHive->Hive.Storage[Stable].Map = (PHMAP_DIRECTORY)&(NewCmHive->Hive.Storage[Stable].SmallDir);
	}
	if( NewSmallDir ) {
        OldCmHive->Hive.Storage[Stable].Map = (PHMAP_DIRECTORY)&(OldCmHive->Hive.Storage[Stable].SmallDir);
	}
    //
    // For FreeBins we have to take special precaution and move them manually from one list to another
    //
    // new hive should not have free bins. (except 64 bits where we deliberately create them to avoid fragmentation)
#if !defined(_WIN64)
    ASSERT( IsListEmpty(&(NewCmHive->Hive.Storage[Stable].FreeBins)) );
#endif
    while( !IsListEmpty(&(OldCmHive->Hive.Storage[Stable].FreeBins)) ) {
        FreeBin = (PFREE_HBIN)RemoveHeadList(&(OldCmHive->Hive.Storage[Stable].FreeBins));
        FreeBin = CONTAINING_RECORD(FreeBin,
                                    FREE_HBIN,
                                    ListEntry);

        InsertTailList(
            &(NewCmHive->Hive.Storage[Stable].FreeBins),
            &(FreeBin->ListEntry)
            );
    }
    ASSERT( IsListEmpty(&(OldCmHive->Hive.Storage[Stable].FreeBins)) );

	ASSERT( IsListEmpty(&(OldCmHive->LRUViewListHead)) && (OldCmHive->MappedViews == 0) && (OldCmHive->UseCount == 0) );
	ASSERT( IsListEmpty(&(NewCmHive->LRUViewListHead)) && (NewCmHive->MappedViews == 0) && (OldCmHive->UseCount == 0) );

	ASSERT( IsListEmpty(&(OldCmHive->PinViewListHead)) && (OldCmHive->PinnedViews == 0) );
	ASSERT( IsListEmpty(&(NewCmHive->PinViewListHead)) && (NewCmHive->PinnedViews == 0) );
	
	//
	// now the security cache; we preserve the security cache; only that we go through it and 
    // shift cells accordingly
	//
    for( i=0;i<OldCmHive->SecurityCount;i++) {
		if( HvGetCellType(OldCmHive->SecurityCache[i].Cell) == (ULONG)Stable ) {
            ASSERT( OldCmHive->SecurityCache[i].Cell == OldCmHive->CellRemapArray[i].OldCell );
            ASSERT( OldCmHive->SecurityCache[i].Cell ==  OldCmHive->SecurityCache[i].CachedSecurity->Cell);
            OldCmHive->SecurityCache[i].Cell = OldCmHive->CellRemapArray[i].NewCell;
            OldCmHive->SecurityCache[i].CachedSecurity->Cell = OldCmHive->CellRemapArray[i].NewCell;
		} 
    }

	//
	// now restore mappings for kcbs KeyCells 
	//
	AnchorAddr = &(OldCmHive->KcbConvertListHead);
	RemapBlock = (PCM_KCB_REMAP_BLOCK)(OldCmHive->KcbConvertListHead.Flink);

	while ( RemapBlock != (PCM_KCB_REMAP_BLOCK)AnchorAddr ) {
		RemapBlock = CONTAINING_RECORD(
						RemapBlock,
						CM_KCB_REMAP_BLOCK,
						RemapList
						);
		ASSERT( RemapBlock->OldCellIndex != HCELL_NIL );

		if( (HvGetCellType(RemapBlock->KeyControlBlock->KeyCell) == (ULONG)Stable) &&  // we are preserving volatile storage
			(!(RemapBlock->KeyControlBlock->ExtFlags & CM_KCB_KEY_NON_EXIST)) // don't mess with fake kcbs
			) {
			ASSERT( RemapBlock->NewCellIndex != HCELL_NIL );
			RemapBlock->KeyControlBlock->KeyCell = RemapBlock->NewCellIndex;
		}
		//
		// invalidate the cache
		//
        if( (!(RemapBlock->KeyControlBlock->Flags & KEY_PREDEF_HANDLE) ) && // don't mess with predefined handles
			(!(RemapBlock->KeyControlBlock->ExtFlags & (CM_KCB_KEY_NON_EXIST|CM_KCB_SYM_LINK_FOUND))) && // don't mess with fake kcbs or symlinks
			(HvGetCellType(RemapBlock->KeyControlBlock->KeyCell) == (ULONG)Stable) // we are preserving volatile storage
			) {
			CmpCleanUpKcbValueCache(RemapBlock->KeyControlBlock);
			CmpSetUpKcbValueCache(RemapBlock->KeyControlBlock,RemapBlock->ValueCount,RemapBlock->ValueList);
		}
        //
        // skip to the next element
        //
        RemapBlock = (PCM_KCB_REMAP_BLOCK)(RemapBlock->RemapList.Flink);
	}

	//
	// now restore mappings for volatile Knodes
	//
	AnchorAddr = &(OldCmHive->KnodeConvertListHead);
	KnodeRemapBlock = (PCM_KNODE_REMAP_BLOCK)(OldCmHive->KnodeConvertListHead.Flink);

	while ( KnodeRemapBlock != (PCM_KNODE_REMAP_BLOCK)AnchorAddr ) {
		KnodeRemapBlock = CONTAINING_RECORD(
						KnodeRemapBlock,
						CM_KNODE_REMAP_BLOCK,
						RemapList
						);
	    KnodeRemapBlock->KeyNode->Parent = KnodeRemapBlock->NewParent;
       
        //
        // skip to the next element
        //
        KnodeRemapBlock = (PCM_KNODE_REMAP_BLOCK)(KnodeRemapBlock->RemapList.Flink);
	}


}

NTSTATUS
CmpShiftHiveFreeBins(
					  PCMHIVE			CmHive,
					  PCMHIVE			*NewHive
					  )
/*++

Routine Description:

Arguments:

	CmHive - the hive to compress

    NewHive - hive with the free bins shifted to the end.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status;
    PHHIVE                  Hive;
	HCELL_INDEX             RootCell;
    ULONG                   NewLength;

    CM_PAGED_CODE();

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
	ASSERT( !IsListEmpty(&(CmHive->Hive.Storage[Stable].FreeBins)) );

	*NewHive = NULL;
    //
    // Disallow attempts to "save" a hive which cannot be saved.
    //
    Hive = &(CmHive->Hive);
    RootCell = Hive->BaseBlock->RootCell;


    if ( (Hive == &CmpMasterHive->Hive) ||
		 ( (Hive->HiveFlags & HIVE_NOLAZYFLUSH) && (Hive->DirtyCount != 0) ) ||
         (CmHive->FileHandles[HFILE_TYPE_PRIMARY] == NULL) 
       ) {
        return STATUS_ACCESS_DENIED;
    }


	if(Hive->DirtyCount != 0) {
		//
		// need to flush the hive as we will replace it with the compressed one.
		//
		if( !HvSyncHive(Hive) ) {
	        return STATUS_ACCESS_DENIED;
		}
	}

    //
    // The subtree the caller wants does not exactly match a
    // subtree.  Make a temporary hive, tree copy the source
    // to temp, write out the temporary, free the temporary.
    //

    //
    // Create the temporary hive
    //

    (*NewHive) = CmpCreateTemporaryHive(NULL);
    if (*NewHive == NULL) {
        status =  STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorInsufficientResources;
    }

    //
    // Create a root cell, mark it as such
    //

    //
    // preserve the hive version and signal to copy tree to build mappings and preserve volatile.
    //
    (*NewHive)->Hive.BaseBlock->Minor = Hive->BaseBlock->Minor;
    (*NewHive)->Hive.Version = Hive->Version;
    (*NewHive)->Hive.BaseBlock->RootCell = CmHive->Hive.BaseBlock->RootCell;
    

    //
    // this will create a clone hive (in paged pool) and will compute the shift index for each bin
    //
    status = HvCloneHive(&(CmHive->Hive),&((*NewHive)->Hive),&NewLength);
    if( !NT_SUCCESS(status) ) {
        goto ErrorInsufficientResources;
    }

    //
    // iterate through the hive and shift each cell; this will take care of the mappings too.
    //
    if( !CmpShiftAllCells(&((*NewHive)->Hive),CmHive) ) {
        status =  STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorInsufficientResources;
    }
    (*NewHive)->Hive.BaseBlock->RootCell = HvShiftCell(&((*NewHive)->Hive),(*NewHive)->Hive.BaseBlock->RootCell);

    //
    // moves free bins at the end and updates the maps.
    //
    status = HvShrinkHive(&((*NewHive)->Hive),NewLength);
    if( !NT_SUCCESS(status) ) {
        goto ErrorInsufficientResources;
    }
    
    return STATUS_SUCCESS;
    //
    // Error exits
    //
ErrorInsufficientResources:

    //
    // Free the temporary hive
    //
    if ((*NewHive) != NULL) {
        CmpDestroyTemporaryHive((*NewHive));
        (*NewHive) = NULL;
    }

    return status;
}

BOOLEAN
CmpShiftAllCells(PHHIVE     NewHive,
                 PCMHIVE    OldHive
                 )
/*++

Routine Description:

    Parses the logical structure of the registry tree and remaps all
    cells inside, according to the Spare filed in each bin. Updates 
    kcb and security mapping also.

Arguments:

	NewHive - hive to remap
    
    OldHive - the old hive - will use volatile from it (temporary)

Return Value:

    NTSTATUS

--*/
{
    
    PRELEASE_CELL_ROUTINE   ReleaseCellRoutine;
    BOOLEAN                 Result = TRUE;
    ULONG                   i;

    CM_PAGED_CODE();

    ReleaseCellRoutine = NewHive->ReleaseCellRoutine;
    NewHive->ReleaseCellRoutine = NULL;

    //
    // setup volatile to the newhive; just temporary, so we can access it
    //
    ASSERT( NewHive->Storage[Volatile].Length == 0 );
    ASSERT( NewHive->Storage[Volatile].Map == NULL );
    ASSERT( NewHive->Storage[Volatile].SmallDir == NULL );
    NewHive->Storage[Volatile].Length = OldHive->Hive.Storage[Volatile].Length;
    NewHive->Storage[Volatile].Map = OldHive->Hive.Storage[Volatile].Map;
    NewHive->Storage[Volatile].SmallDir = OldHive->Hive.Storage[Volatile].SmallDir;

    CmpShiftSecurityCells(NewHive);
    //
    // update the security mapping array
    //
    for( i=0;i<OldHive->SecurityCount;i++) {
		if( HvGetCellType(OldHive->SecurityCache[i].Cell) == (ULONG)Stable ) {
			OldHive->CellRemapArray[i].NewCell = HvShiftCell(NewHive,OldHive->CellRemapArray[i].OldCell);
		} 
    }
    
    Result =  CmpShiftAllCells2(NewHive,OldHive,NewHive->BaseBlock->RootCell, HCELL_NIL);
    
    NewHive->Storage[Volatile].Length = 0;
    NewHive->Storage[Volatile].Map = NULL;
    NewHive->Storage[Volatile].SmallDir = NULL;

    NewHive->ReleaseCellRoutine = ReleaseCellRoutine;
    return Result;
}

BOOLEAN
CmpShiftAllCells2(  PHHIVE      Hive,
                    PCMHIVE     OldHive,
                    HCELL_INDEX Cell,
                    HCELL_INDEX ParentCell
                    )
/*++

Routine Description:

    In this routine, HvGetCell cannot fail because the hive is in paged pool!

Arguments:

	CmHive - hive to remap

Return Value:

        TRUE/FALSE
--*/
{   
    PCMP_CHECK_REGISTRY_STACK_ENTRY     CheckStack;
    LONG                                StackIndex;
    PCM_KEY_NODE                        Node;
    HCELL_INDEX                         SubKey;
    BOOLEAN                             Result = TRUE;
    PCM_KEY_INDEX                       Index;
    ULONG                               i;


    ASSERT( Hive->ReleaseCellRoutine == NULL );

    //
    // Initialize the stack to simulate recursion here
    //

    CheckStack = ExAllocatePool(PagedPool,sizeof(CMP_CHECK_REGISTRY_STACK_ENTRY)*CMP_MAX_REGISTRY_DEPTH);
    if (CheckStack == NULL) {
        return FALSE;
    }
    CheckStack[0].Cell = Cell;
    CheckStack[0].ParentCell = ParentCell;
    CheckStack[0].ChildIndex = 0;
    CheckStack[0].CellChecked = FALSE;
    StackIndex = 0;


    while(StackIndex >=0) {
        //
        // first check the current cell
        //
        if( CheckStack[StackIndex].CellChecked == FALSE ) {
            CheckStack[StackIndex].CellChecked = TRUE;

            CmpShiftKey(Hive,OldHive,CheckStack[StackIndex].Cell,CheckStack[StackIndex].ParentCell);
        }

        Node = (PCM_KEY_NODE)HvGetCell(Hive, CheckStack[StackIndex].Cell);
        ASSERT( Node != NULL );

        if( CheckStack[StackIndex].ChildIndex < Node->SubKeyCounts[Stable] ) {
            //
            // we still have childs to check; add another entry for them and advance the 
            // StackIndex
            //
            SubKey = CmpFindSubKeyByNumber(Hive,
                                           Node,
                                           CheckStack[StackIndex].ChildIndex);
            ASSERT( SubKey != HCELL_NIL ); 
            //
            // next iteration will check the next child
            //
            CheckStack[StackIndex].ChildIndex++;

            StackIndex++;
            if( StackIndex == CMP_MAX_REGISTRY_DEPTH ) {
                //
                // we've run out of stack; registry tree has too many levels
                //
                Result = FALSE;
                // bail out
                break;
            }
            CheckStack[StackIndex].Cell = SubKey;
            CheckStack[StackIndex].ParentCell = CheckStack[StackIndex-1].Cell;
            CheckStack[StackIndex].ChildIndex = 0;
            CheckStack[StackIndex].CellChecked = FALSE;

        } else {
            //
            // add all volatile nodes to the volatile list
            //
	        PCM_KNODE_REMAP_BLOCK		knodeRemapBlock;

            for(i = 0; i<Node->SubKeyCounts[Volatile];i++) {
                SubKey = CmpFindSubKeyByNumber(Hive,
                                               Node,
                                               Node->SubKeyCounts[Stable] + i);
                ASSERT( SubKey != HCELL_NIL ); 

                knodeRemapBlock = (PCM_KNODE_REMAP_BLOCK)ExAllocatePool(PagedPool, sizeof(CM_KNODE_REMAP_BLOCK));
		        if( knodeRemapBlock == NULL ) {
			        Result = FALSE;
                    break;
		        }
                ASSERT( HvGetCellType(SubKey) == (ULONG)Volatile );
                knodeRemapBlock->KeyNode = (PCM_KEY_NODE)HvGetCell(Hive,SubKey);;
	            knodeRemapBlock->NewParent = HvShiftCell(Hive,CheckStack[StackIndex].Cell);

                InsertTailList(&(OldHive->KnodeConvertListHead),&(knodeRemapBlock->RemapList));
            }

            //
            // we have checked all childs for this node; time to take care of the index.
            // 
            if( Node->SubKeyLists[Stable] != HCELL_NIL ) {
                Index = (PCM_KEY_INDEX)HvGetCell(Hive, Node->SubKeyLists[Stable]);
                CmpShiftIndex(Hive,Index);
                Node->SubKeyLists[Stable] = HvShiftCell(Hive,Node->SubKeyLists[Stable]);
            }
            //
            // ; go back
            //
            StackIndex--;

        }

    }

    ExFreePool(CheckStack);
    return Result;

}

VOID 
CmpShiftIndex(PHHIVE        Hive,
              PCM_KEY_INDEX Index
              )
{
    ULONG               i,j;
    HCELL_INDEX         LeafCell;
    PCM_KEY_INDEX       Leaf;
    PCM_KEY_FAST_INDEX  FastIndex;

    if (Index->Signature == CM_KEY_INDEX_ROOT) {

        //
        // step through root, update the leafs
        //
        for (i = 0; i < Index->Count; i++) {
            LeafCell = Index->List[i];
            Leaf = (PCM_KEY_INDEX)HvGetCell(Hive, LeafCell);
            ASSERT( Leaf != NULL ); 

            for(j=0;j<Leaf->Count;j++) {
                if( (Leaf->Signature == CM_KEY_FAST_LEAF) ||
                    (Leaf->Signature == CM_KEY_HASH_LEAF) ) {
                    FastIndex = (PCM_KEY_FAST_INDEX)Leaf;
                    FastIndex->List[j].Cell = HvShiftCell(Hive,FastIndex->List[j].Cell);
                } else {
                    Leaf->List[j] = HvShiftCell(Hive,Leaf->List[j]);
                }
            }
        }
    }

    //
    // now update the root
    //
    for (i = 0; i < Index->Count; i++) {
        if( (Index->Signature == CM_KEY_FAST_LEAF) ||
            (Index->Signature == CM_KEY_HASH_LEAF) ) {
            FastIndex = (PCM_KEY_FAST_INDEX)Index;
            FastIndex->List[i].Cell = HvShiftCell(Hive,FastIndex->List[i].Cell);
        } else {
            Index->List[i] = HvShiftCell(Hive,Index->List[i]);
        }
    }
}

VOID
CmpShiftKey(PHHIVE      Hive,
            PCMHIVE     OldHive,
            HCELL_INDEX Cell,
            HCELL_INDEX ParentCell
            )
{
    PCM_KEY_NODE            Node;
	PCM_KCB_REMAP_BLOCK		RemapBlock;
    PLIST_ENTRY             AnchorAddr;

    Node = (PCM_KEY_NODE)HvGetCell(Hive,Cell);
    ASSERT( Node != NULL );
    
    //
    // key node related cells
    //
    if( ParentCell != HCELL_NIL ) {
        ASSERT( ParentCell == Node->Parent );
        Node->Parent = HvShiftCell(Hive,Node->Parent);
    }
    ASSERT( Node->Security != HCELL_NIL );
    Node->Security = HvShiftCell(Hive,Node->Security);
    if( Node->Class != HCELL_NIL ) {
        Node->Class = HvShiftCell(Hive,Node->Class);
    }
    
    //
    // now the valuelist
    //
    if( Node->ValueList.Count > 0 ) {
        CmpShiftValueList(Hive,Node->ValueList.List,Node->ValueList.Count);
        Node->ValueList.List = HvShiftCell(Hive,Node->ValueList.List);
    }

    //
	// walk the KcbConvertListHead and store the mappings
	//
	AnchorAddr = &(OldHive->KcbConvertListHead);
	RemapBlock = (PCM_KCB_REMAP_BLOCK)(OldHive->KcbConvertListHead.Flink);

	while ( RemapBlock != (PCM_KCB_REMAP_BLOCK)AnchorAddr ) {
		RemapBlock = CONTAINING_RECORD(
						RemapBlock,
						CM_KCB_REMAP_BLOCK,
						RemapList
						);
		ASSERT( RemapBlock->OldCellIndex != HCELL_NIL );
		if( RemapBlock->OldCellIndex == Cell ) {
			//
			// found it !
			//
			// can only be set once 
			ASSERT( RemapBlock->NewCellIndex == HCELL_NIL );
			RemapBlock->NewCellIndex = HvShiftCell(Hive,Cell);;
		    RemapBlock->ValueCount = Node->ValueList.Count;
		    RemapBlock->ValueList = Node->ValueList.List;
			break;
		}
        //
        // skip to the next element
        //
        RemapBlock = (PCM_KCB_REMAP_BLOCK)(RemapBlock->RemapList.Flink);
	}

}

VOID
CmpShiftValueList(PHHIVE      Hive,
            HCELL_INDEX ValueList,
            ULONG       Count
            )
{
    PCELL_DATA      List,pcell;
    ULONG           i,j;
    HCELL_INDEX     Cell;
    ULONG           DataLength;
    PCM_BIG_DATA    BigData;
    PHCELL_INDEX    Plist;

    List = HvGetCell(Hive,ValueList);
    ASSERT( List != NULL );

    for (i = 0; i < Count; i++) {
        Cell = List->u.KeyList[i];
        pcell = HvGetCell(Hive, Cell);
        ASSERT( pcell != NULL );
        DataLength = pcell->u.KeyValue.DataLength;
        if (DataLength < CM_KEY_VALUE_SPECIAL_SIZE) {
            //
            // regular value.
            //
            if( CmpIsHKeyValueBig(Hive,DataLength) == TRUE ) {
                BigData = (PCM_BIG_DATA)HvGetCell(Hive, pcell->u.KeyValue.Data);
                ASSERT( BigData != NULL );
                
                if( BigData->Count ) {
                    Plist = (PHCELL_INDEX)HvGetCell(Hive,BigData->List);
                    ASSERT( Plist != NULL );
                    for(j=0;j<BigData->Count;j++) {
                        Plist[j] = HvShiftCell(Hive,Plist[j]);
                    }
                    BigData->List = HvShiftCell(Hive,BigData->List);
                }
            }
            
            if( pcell->u.KeyValue.Data != HCELL_NIL ) {
                pcell->u.KeyValue.Data = HvShiftCell(Hive,pcell->u.KeyValue.Data);
            }
        }
        List->u.KeyList[i] = HvShiftCell(Hive,List->u.KeyList[i]);

    }

}

VOID 
CmpShiftSecurityCells(PHHIVE        Hive)
{

    PCM_KEY_NODE        RootNode;
    PCM_KEY_SECURITY    SecurityCell;
    HCELL_INDEX         ListAnchor;
    HCELL_INDEX         NextCell;
    
    ASSERT( Hive->ReleaseCellRoutine == NULL );
    RootNode = (PCM_KEY_NODE) HvGetCell(Hive, Hive->BaseBlock->RootCell);
    ASSERT( RootNode != NULL );

    ListAnchor = NextCell = RootNode->Security;
    
    do {
        SecurityCell = (PCM_KEY_SECURITY) HvGetCell(Hive, NextCell);
        ASSERT( SecurityCell != NULL );

        NextCell = SecurityCell->Flink;
        SecurityCell->Flink = HvShiftCell(Hive,SecurityCell->Flink);
        SecurityCell->Blink = HvShiftCell(Hive,SecurityCell->Blink);
    } while ( NextCell != ListAnchor );
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmse.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmse.c

Abstract:

    This module implements security routines for the configuration manager.

--*/

#include "cmp.h"


//
// Function prototypes private to this module
//

BOOLEAN
CmpFindMatchingDescriptorCell(
    IN PCMHIVE CmHive,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG Type,
    OUT PHCELL_INDEX MatchingCell,
    OUT OPTIONAL PCM_KEY_SECURITY_CACHE *CachedSecurityPointer
    );

NTSTATUS
CmpSetSecurityDescriptorInfo(
    IN PCM_KEY_CONTROL_BLOCK kcb,
    IN PSECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR ModificationDescriptor,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN POOL_TYPE PoolType,
    IN PGENERIC_MAPPING GenericMapping
    );

NTSTATUS
CmpQuerySecurityDescriptorInfo(
    IN PCM_KEY_CONTROL_BLOCK kcb,
    IN PSECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG Length,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor
    );

PCM_KEY_SECURITY
CmpGetKeySecurity(
    IN PHHIVE Hive,
    IN PCM_KEY_NODE Key,
    OUT PHCELL_INDEX SecurityCell
    );

BOOLEAN
CmpInsertSecurityCellList(
    IN PHHIVE Hive,
    IN HCELL_INDEX NodeCell,
    IN HCELL_INDEX SecurityCell
    );

VOID
CmpRemoveSecurityCellList(
    IN PHHIVE Hive,
    IN HCELL_INDEX SecurityCell
    );

ULONG
CmpSecurityExceptionFilter(
    IN PEXCEPTION_POINTERS ExceptionPointers
    );

//
// This macro takes a PSECURITY_DESCRIPTOR and returns the size of the
// hive cell required to contain the entire security descriptor.
//

#define SECURITY_CELL_LENGTH(pDescriptor) \
    FIELD_OFFSET(CM_KEY_SECURITY,Descriptor) + \
    RtlLengthSecurityDescriptor(pDescriptor)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpSecurityMethod )
#pragma alloc_text(PAGE,CmpSetSecurityDescriptorInfo)
#pragma alloc_text(PAGE,CmpAssignSecurityDescriptor)
#pragma alloc_text(PAGE,CmpQuerySecurityDescriptorInfo)
#pragma alloc_text(PAGE,CmpCheckCreateAccess)
#pragma alloc_text(PAGE,CmpCheckNotifyAccess)
#pragma alloc_text(PAGE,CmpGetKeySecurity)
#pragma alloc_text(PAGE,CmpHiveRootSecurityDescriptor)
#pragma alloc_text(PAGE,CmpFreeSecurityDescriptor)
#pragma alloc_text(PAGE,CmpInsertSecurityCellList)
#pragma alloc_text(PAGE,CmpRemoveSecurityCellList)
#pragma alloc_text(PAGE,CmpSecurityExceptionFilter)
#pragma alloc_text(PAGE,CmpAssignSecurityDescriptorWrapper)
#pragma alloc_text(PAGE,CmpCheckKeyAccess)
#pragma alloc_text(PAGE,CmpDoAccessCheckOnSubtree)
#endif

ULONG
CmpSecurityExceptionFilter(
    IN PEXCEPTION_POINTERS ExceptionPointers
    )

/*++

Routine Description:

    Debug code to find registry security exceptions that are being swallowed

Return Value:

    EXCEPTION_EXECUTE_HANDLER

--*/

{
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CM: Registry security exception %lx, ExceptionPointers = %p\n",
            ExceptionPointers->ExceptionRecord->ExceptionCode,
            ExceptionPointers);
    
    //
    // This is a request from the base test team; no dbg should be hit on the free builds 
    // at the client; after RC2 is shipped we should enable this on free builds too.
    //
#if DBG
    try {
        DbgBreakPoint();
    } except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // no debugger enabled, just keep going
        //

    }
#endif

    return(EXCEPTION_EXECUTE_HANDLER);
}

NTSTATUS
CmpAssignSecurityDescriptorWrapper(
    IN PVOID                    Object,
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor
    )
{
    PCM_KEY_CONTROL_BLOCK   kcb;
    PCM_KEY_NODE            TempNode;
    NTSTATUS                Status = STATUS_UNSUCCESSFUL;

    CM_PAGED_CODE();

    kcb = ((PCM_KEY_BODY)Object)->KeyControlBlock;

    TempNode = (PCM_KEY_NODE)HvGetCell(kcb->KeyHive, kcb->KeyCell);
    if( TempNode == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    try {
        //
        // Set the SecurityDescriptor field in the object's header to
        // NULL.  This indicates that our security method needs to be
        // called for any security descriptor operations.
        //

        Status = ObAssignObjectSecurityDescriptor(Object, NULL, PagedPool);

        ASSERT( NT_SUCCESS( Status ));
       
        ASSERT_KCB_LOCKED_EXCLUSIVE(kcb);
        ASSERT_HIVE_SECURITY_LOCK_OWNED((PCMHIVE)kcb->KeyHive);

        //
        // Assign the actual descriptor.
        //
        Status = CmpAssignSecurityDescriptor( kcb->KeyHive,
                                              kcb->KeyCell,
                                              TempNode,
                                              SecurityDescriptor );
        if( NT_SUCCESS(Status) ) {
            //
            // Security has been changed, update the cache.
            //
            CmpAssignSecurityToKcb(kcb,TempNode->Security,TRUE);
        }

    } except (CmpSecurityExceptionFilter(GetExceptionInformation())) {
        Status = GetExceptionCode();
    }
    
    HvReleaseCell(kcb->KeyHive, kcb->KeyCell);
    return Status;
}

NTSTATUS
CmpSecurityMethod (
    IN PVOID Object,
    IN SECURITY_OPERATION_CODE OperationCode,
    IN PSECURITY_INFORMATION SecurityInformation,
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG CapturedLength,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN POOL_TYPE PoolType,
    IN PGENERIC_MAPPING GenericMapping
    )

/*++

Routine Description:

    This is the security method for registry objects.  It is responsible for
    retrieving, setting, and deleting the security descriptor of a registry
    object.  It is not used to assign the original security descriptor to an
    object (use SeAssignSecurity for that purpose).


    IT IS ASSUMED THAT THE OBJECT MANAGER HAS ALREADY DONE THE ACCESS
    VALIDATIONS NECESSARY TO ALLOW THE REQUESTED OPERATIONS TO BE PERFORMED.

Arguments:

    Object - Supplies a pointer to the object being used.

    OperationCode - Indicates if the operation is for setting, querying, or
        deleting the object's security descriptor.

    SecurityInformation - Indicates which security information is being
        queried or set.  This argument is ignored for the delete operation.

    SecurityDescriptor - The meaning of this parameter depends on the
        OperationCode:

        QuerySecurityDescriptor - For the query operation this supplies the
            buffer to copy the descriptor into.  The security descriptor is
            assumed to have been probed up to the size passed in in Length.
            Since it still points into user space, it must always be
            accessed in a try clause in case it should suddenly disappear.

        SetSecurityDescriptor - For a set operation this supplies the
            security descriptor to copy into the object.  The security
            descriptor must be captured before this routine is called.

        DeleteSecurityDescriptor - It is ignored when deleting a security
            descriptor.

        AssignSecurityDescriptor - For assign operations this is the
            security descriptor that will be assigned to the object.
            It is assumed to be in kernel space, and is therefore not
            probed or captured.

    CapturedLength - For the query operation this specifies the length, in
        bytes, of the security descriptor buffer, and upon return contains
        the number of bytes needed to store the descriptor.  If the length
        needed is greater than the length supplied the operation will fail.
        It is ignored in the set and delete operation.

        This parameter is assumed to be captured and probed as appropriate.

    ObjectsSecurityDescriptor - For the Set operation this supplies the address
        of a pointer to the object's current security descriptor.  This routine
        will either modify the security descriptor in place or deallocate/
        allocate a new security descriptor and use this variable to indicate
        its new location.  For the query operation it simply supplies
        the security descriptor being queried.

    PoolType - For the set operation this specifies the pool type to use if
        a new security descriptor needs to be allocated.  It is ignored
        in the query and delete operation.

    GenericMapping - Passed only for the set operation, this argument provides
        the mapping of generic to specific/standard access types for the object
        being accessed.  This mapping structure is expected to be safe to
        access (i.e., captured if necessary) prior to be passed to this routine.

Return Value:

    NTSTATUS - STATUS_SUCCESS if the operation is successful and an
        appropriate error status otherwise.

--*/

{
    PCM_KEY_CONTROL_BLOCK   kcb;
    NTSTATUS                Status = STATUS_UNSUCCESSFUL;
    BOOLEAN                 UnlockKcb = TRUE;
    BOOLEAN                 UnlockSecurity = FALSE;

    //
    //  Make sure the common parts of our input are proper
    //

    CM_PAGED_CODE();
    ASSERT_KEY_OBJECT(Object);

    ASSERT( (OperationCode == SetSecurityDescriptor) ||
            (OperationCode == QuerySecurityDescriptor) ||
            (OperationCode == AssignSecurityDescriptor) ||
            (OperationCode == DeleteSecurityDescriptor) );

    kcb = ((PCM_KEY_BODY)Object)->KeyControlBlock;
    //
    // Lock hive for shared or exclusive, depending on what we need
    // to do.
    //
    CmpLockRegistry(); 
    if (OperationCode == QuerySecurityDescriptor) {
        //
        // trick to avoid recursive acquires
        //
        if( (ULONG_PTR)kcb & 1 ) {
            kcb = (PCM_KEY_CONTROL_BLOCK)((ULONG_PTR)kcb ^ 1);
            ASSERT_KCB_LOCKED(kcb);
            UnlockKcb = FALSE;
        } else {
            //
            // serialize access to this key.
            //
            CmpLockKCBShared(kcb);
        }
    } else {
        //
        // serialize access to this key.
        //
        ASSERT( ((ULONG_PTR)kcb & 1) == 0 );
        CmpLockKCBExclusive(kcb);
    }

    if(kcb->Delete) {
        //
        // Key has been deleted, performing security operations on
        // it is Not Allowed.
        //
        if( UnlockKcb ) {
            CmpUnlockKCB(kcb);
        }
        CmpUnlockRegistry();
        return(STATUS_KEY_DELETED);
    }

    if (OperationCode != QuerySecurityDescriptor) {
        // 
        // no flush from this point on
        //
        CmpLockHiveFlusherShared((PCMHIVE)kcb->KeyHive);
        //
        // we will be changing the security for this hive.
        //
        CmLockHiveSecurityExclusive((PCMHIVE)kcb->KeyHive);
        UnlockSecurity = TRUE;
    } 

    try {

        //
        //  This routine simply cases off of the operation code to decide
        //  which support routine to call
        //

        switch (OperationCode) {

        case SetSecurityDescriptor:

            //
            //  check the rest of our input and call the set security
            //  method
            //
            ASSERT( (PoolType == PagedPool) || (PoolType == NonPagedPool) );

            ASSERT_KCB_LOCKED(kcb);
            Status = CmpSetSecurityDescriptorInfo( kcb,
                                                   SecurityInformation,
                                                   SecurityDescriptor,
                                                   ObjectsSecurityDescriptor,
                                                   PoolType,
                                                   GenericMapping );

            //
            // this is the one and only path on which a user could change
            // a security descriptor, therefore, report such changes for
            // notification here.
            //
            if (NT_SUCCESS(Status)) {
                ASSERT( UnlockSecurity );
                CmUnlockHiveSecurity((PCMHIVE)kcb->KeyHive);
                UnlockSecurity = FALSE;

                CmpReportNotify(kcb,
                                kcb->KeyHive,
                                kcb->KeyCell,
                                REG_NOTIFY_CHANGE_ATTRIBUTES | REG_NOTIFY_CHANGE_SECURITY);
    
            }

            break;

        case QuerySecurityDescriptor:

            //
            //  check the rest of our input and call the default query security
            //  method
            //
            ASSERT( CapturedLength != NULL );
            Status = CmpQuerySecurityDescriptorInfo( kcb,
                                                     SecurityInformation,
                                                     SecurityDescriptor,
                                                     CapturedLength,
                                                     ObjectsSecurityDescriptor );
            break;

        case DeleteSecurityDescriptor:

            //
            // Nobody should ever call the delete method.  When the key is
            // freed, the security descriptor associated with it is
            // explicitly freed (CmpFreeSecurityDescriptor)
            //
            ASSERT(FALSE);

            break;

        case AssignSecurityDescriptor:

            //
            // Set the SecurityDescriptor field in the object's header to
            // NULL.  This indicates that our security method needs to be
            // called for any security descriptor operations.
            //
            Status = CmpAssignSecurityDescriptorWrapper(Object,SecurityDescriptor);
            break;

        default:

            //
            //  Bugcheck on any other operation code,  We won't get here if
            //  the earlier asserts are still checked.
            //
            CM_BUGCHECK( REGISTRY_ERROR,BAD_SECURITY_METHOD,1,kcb,OperationCode);

        }

    } except (CmpSecurityExceptionFilter(GetExceptionInformation())) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!CmpSecurityMethod: code:%08lx\n", GetExceptionCode()));
        Status = GetExceptionCode();
    }

    if (OperationCode != QuerySecurityDescriptor) {
        CmpUnlockHiveFlusher((PCMHIVE)kcb->KeyHive);
        if( UnlockSecurity ) {
            CmUnlockHiveSecurity((PCMHIVE)kcb->KeyHive);
        }
    }
    if( UnlockKcb ) {
        CmpUnlockKCB(kcb);
    }
    CmpUnlockRegistry();
    return(Status);

}

NTSTATUS
CmpSetSecurityDescriptorInfo(
    IN PCM_KEY_CONTROL_BLOCK Key,
    IN PSECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR ModificationDescriptor,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN POOL_TYPE PoolType,
    IN PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    This routine will set a node's security descriptor.  The input
    security descriptor must be previously captured.

Arguments:

    Key - Supplies a pointer to the KEY_CONTROL_BLOCK for the node whose
        security descriptor will be set.

    SecurityInformation - Indicates which security information is
        to be applied to the object.  The value(s) to be assigned are
        passed in the SecurityDescriptor parameter.

    ModificationDescriptor - Supplies the input security descriptor to be
        applied to the object.  The caller of this routine is expected
        to probe and capture the passed security descriptor before calling
        and release it after calling.

    ObjectsSecurityDescriptor - Supplies the address of a pointer to
        the objects security descriptor that is going to be altered by
        this procedure

    PoolType - Specifies the type of pool to allocate for the objects
        security descriptor.

    GenericMapping - This argument provides the mapping of generic to
        specific/standard access types for the object being accessed.
        This mapping structure is expected to be safe to access
        (i.e., captured if necessary) prior to be passed to this routine.

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful and an appropriate error
        value otherwise

--*/

{
    NTSTATUS                Status;
    HCELL_INDEX             SecurityCell;
    HCELL_INDEX             MatchSecurityCell;
    HCELL_INDEX             NewCell;
    HCELL_INDEX             OldCell;
    PCM_KEY_SECURITY        Security;
    PCM_KEY_SECURITY        NewSecurity;
    PCM_KEY_SECURITY        FlinkSecurity;
    PCM_KEY_SECURITY        BlinkSecurity;
    PCM_KEY_NODE            Node;
    ULONG                   DescriptorLength;
    PSECURITY_DESCRIPTOR    DescriptorCopy;
    ULONG                   Type;
    LARGE_INTEGER           SystemTime;
    PHHIVE                  Hive;
    PCM_KEY_SECURITY_CACHE  CachedSecurity;
    HV_TRACK_CELL_REF       CellRef = {0};

    CM_PAGED_CODE();

    UNREFERENCED_PARAMETER (ObjectsSecurityDescriptor);

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpSetSecurityDescriptorInfo:\n"));

    ASSERT_KCB_LOCKED_EXCLUSIVE(Key);
    ASSERT_HIVE_SECURITY_LOCK_OWNED((PCMHIVE)Key->KeyHive);

    Node = (PCM_KEY_NODE)HvGetCell(Key->KeyHive, Key->KeyCell);
    if( Node == NULL ) {
        //
        // we couldn't map the bin containing this cell;
        // this shouldn't happen as we are about to modify the cell
        // (i.e. it should be dirty/pinned by this time)
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if( !HvTrackCellRef(&CellRef,Key->KeyHive, Key->KeyCell) ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Map in the hive cell for the security descriptor before we make
    // the call to SeSetSecurityDescriptorInfo.  This prevents us from
    // changing its security descriptor and then being unable to bring
    // the hive cell into memory for updating.
    //
    Security = CmpGetKeySecurity(Key->KeyHive,
                                 Node,
                                 &SecurityCell);
    if( Security == NULL ) {
        //
        // couldn't map view inside
        //
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    if( !HvTrackCellRef(&CellRef,Key->KeyHive, SecurityCell) ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    //
    // SeSetSecurityDescriptorInfo takes a pointer to the original
    // descriptor. This pointer is not freed, but a new pointer will
    // be returned.
    //
    DescriptorCopy = &Security->Descriptor;
    Status = SeSetSecurityDescriptorInfo( NULL,
                                          SecurityInformation,
                                          ModificationDescriptor,
                                          &DescriptorCopy,
                                          PoolType,
                                          GenericMapping );

    if (!NT_SUCCESS(Status)) {
        goto ErrorExit;
    }

    //
    // Set Security operation succeeded, so we update the security
    // descriptor in the hive.
    //
    DescriptorLength = RtlLengthSecurityDescriptor(DescriptorCopy);
    Type = HvGetCellType(Key->KeyCell);
    Hive = Key->KeyHive;

    if (! (HvMarkCellDirty(Hive, Key->KeyCell,FALSE) && HvMarkCellDirty(Hive, SecurityCell,FALSE)) ) {
        ExFreePool(DescriptorCopy);
        Status = STATUS_NO_LOG_SPACE;
        goto ErrorExit;
    }

    //
    // Try to find an existing security descriptor that we can share.
    //
    if (CmpFindMatchingDescriptorCell((PCMHIVE)Hive, DescriptorCopy, Type, &MatchSecurityCell,&CachedSecurity)) {
        //
        // A match was found.
        //
        if( MatchSecurityCell == SecurityCell ) {
            //
            // what we want to set is already here, so bail out
            //
            ExFreePool(DescriptorCopy);

            //
            // Update the LastWriteTime of the key.
            //
            KeQuerySystemTime(&SystemTime);
            Node->LastWriteTime = SystemTime;
            // update the time in kcb too, to keep the cache in sync
            Key->KcbLastWriteTime = SystemTime;

            HvReleaseFreeCellRefArray(&CellRef);
            return STATUS_SUCCESS;
        } else {
            if (!HvMarkCellDirty(Hive, MatchSecurityCell,FALSE)) {
                ExFreePool(DescriptorCopy);
                Status = STATUS_NO_LOG_SPACE;
                goto ErrorExit;
            }
            if (Security->ReferenceCount == 1) {
                //
                // No more references to the old security cell, so we can free it now.
                //
                if (! (HvMarkCellDirty(Hive, Security->Flink,FALSE) &&
                       HvMarkCellDirty(Hive, Security->Blink,FALSE))) {
                    ExFreePool(DescriptorCopy);
                    Status = STATUS_NO_LOG_SPACE;
                    goto ErrorExit;
                }
                CmpRemoveSecurityCellList(Hive, SecurityCell);
                HvFreeCell(Hive, SecurityCell);
            } else {

                //
                // Just decrement the count on the old security cell
                //
                Security->ReferenceCount -= 1;
            }

            //
            // Set the node to point at the matching security cell.
            //
            Security = (PCM_KEY_SECURITY)HvGetCell(Hive, MatchSecurityCell);
            if( Security == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // this should not happen as we just marked the cell dirty
                //
                ASSERT( FALSE );
                ExFreePool(DescriptorCopy);
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto ErrorExit;
            }

            if( !HvTrackCellRef(&CellRef,Hive, MatchSecurityCell) ) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto ErrorExit;
            }

            Security->ReferenceCount += 1;
            Node->Security = MatchSecurityCell;
        }
    } else {

        //
        // No match was found, we need to create a new cell.
        //
        if (Security->ReferenceCount > 1) {

            //
            // We can't change the existing security cell, since it is shared
            // by multiple keys.  Allocate a new cell and decrement the existing
            // one's reference count.
            //
            NewCell = HvAllocateCell(Key->KeyHive,
                                     SECURITY_CELL_LENGTH(DescriptorCopy),
                                     Type,
                                     HCELL_NIL);
            if (NewCell == HCELL_NIL) {
                ExFreePool(DescriptorCopy);
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto ErrorExit;
            }

            if (! HvMarkCellDirty(Key->KeyHive, Security->Flink,FALSE)) {
                ExFreePool(DescriptorCopy);
                Status = STATUS_NO_LOG_SPACE;
                goto ErrorExit;
            }

            Security->ReferenceCount -= 1;

            //
            // Map in the new cell and insert it into the linked list.
            //
            NewSecurity = (PCM_KEY_SECURITY) HvGetCell(Key->KeyHive, NewCell);
            if( NewSecurity == NULL ) {
                //
                // we couldn't map the bin containing this cell
                //
                ExFreePool(DescriptorCopy);
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto ErrorExit;
            }

            if( !HvTrackCellRef(&CellRef,Key->KeyHive, NewCell) ) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto ErrorExit;
            }

            NewSecurity->Blink = SecurityCell;
            NewSecurity->Flink = Security->Flink;
            FlinkSecurity = (PCM_KEY_SECURITY) HvGetCell(Key->KeyHive, Security->Flink);
            if( FlinkSecurity == NULL ) {
                //
                // we couldn't map the bin containing this cell
                //
                ExFreePool(DescriptorCopy);
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto ErrorExit;
            }

            if( !HvTrackCellRef(&CellRef,Key->KeyHive, Security->Flink) ) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto ErrorExit;
            }

            Security->Flink = FlinkSecurity->Blink = NewCell;

            //
            // initialize new cell
            //
            NewSecurity->Signature = CM_KEY_SECURITY_SIGNATURE;
            NewSecurity->ReferenceCount = 1;
            NewSecurity->DescriptorLength = DescriptorLength;
            Security=NewSecurity;

            //
            // copy the descriptor
            //
            RtlCopyMemory( &(Security->Descriptor),
                           DescriptorCopy,
                           DescriptorLength );

            //
            // Add the new created security cell to the cache
            //
            if( !NT_SUCCESS(CmpAddSecurityCellToCache( (PCMHIVE)Key->KeyHive,NewCell,FALSE,NULL)) ) {
                //
                // we couldn't map the bin containing this cell
                // this shouldn't happen as we just allocated (marked dirty) the cell
                //
                ASSERT( FALSE );
                ExFreePool(DescriptorCopy);
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto ErrorExit;
            }

            //
            // Update the pointer in the node cell.
            //
            Node->Security = NewCell;

        } else {
            //
            // when this is FALSE, the new cell is ADDED to cache;
            // Otherwise (the cell index and size did not change), 
            // the new sd is copied over the one in cache
            //
            BOOLEAN UpdateCache;

            if (DescriptorLength != Security->DescriptorLength) {

                //
                // The security descriptor's size has changed, and it is not shared
                // by any other cells, so reallocate the cell.
                //
                if (! (HvMarkCellDirty(Key->KeyHive, Security->Flink,FALSE) &&
                       HvMarkCellDirty(Key->KeyHive, Security->Blink,FALSE))) {
                    ExFreePool(DescriptorCopy);
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto ErrorExit;
                }

                DCmCheckRegistry((PCMHIVE)(Key->KeyHive));
                OldCell = SecurityCell;
                SecurityCell = HvReallocateCell( Key->KeyHive,
                                                 SecurityCell,
                                                 SECURITY_CELL_LENGTH(DescriptorCopy) );
                if (SecurityCell == HCELL_NIL) {
                    ExFreePool(DescriptorCopy);
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto ErrorExit;
                }

                //
                // remove the old cell from security cache and signal that the new one should be added
                //
                CmpRemoveFromSecurityCache ((PCMHIVE)Key->KeyHive,OldCell);
                UpdateCache = FALSE;

                //
                // Update the Node's security data.
                //
                Node->Security = SecurityCell;

                //
                // Update Security to point to where the new security object is
                //
                Security = (PCM_KEY_SECURITY) HvGetCell(Key->KeyHive, SecurityCell);
                if( Security == NULL ) {
                    //
                    // we couldn't map the bin containing this cell
                    // this shouldn't happen as we just allocated this cell
                    // (i.e. it should be pinned into memory at this point)
                    //
                    ASSERT( FALSE );
                    ExFreePool(DescriptorCopy);
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto ErrorExit;
                }

                if( !HvTrackCellRef(&CellRef,Key->KeyHive, SecurityCell) ) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto ErrorExit;
                }

                ASSERT_SECURITY(Security);

                //
                // Update other list references to the node
                //
                if (Security->Flink == OldCell) {
                    Security->Flink = SecurityCell; // point to new self
                } else {
                    FlinkSecurity = (PCM_KEY_SECURITY) HvGetCell(
                                                            Key->KeyHive,
                                                            Security->Flink
                                                            );
                    if( FlinkSecurity == NULL ) {
                        //
                        // we couldn't map the bin containing this cell
                        //
                        ExFreePool(DescriptorCopy);
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto ErrorExit;
                    }

                    if( !HvTrackCellRef(&CellRef,Key->KeyHive, Security->Flink) ) {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto ErrorExit;
                    }

                    FlinkSecurity->Blink = SecurityCell;
                }

                if (Security->Blink == OldCell) {
                    Security->Blink = SecurityCell; // point to new self
                } else {
                    BlinkSecurity = (PCM_KEY_SECURITY) HvGetCell(
                                                            Key->KeyHive,
                                                            Security->Blink
                                                            );
                    if( BlinkSecurity == NULL ) {
                        //
                        // we couldn't map the bin containing this cell
                        //
                        ExFreePool(DescriptorCopy);
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto ErrorExit;
                    }

                    if( !HvTrackCellRef(&CellRef,Key->KeyHive,Security->Blink) ) {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto ErrorExit;
                    }

                    BlinkSecurity->Flink = SecurityCell;
                }

                //
                // Finally, update the length field in the cell
                //
                Security->DescriptorLength = DescriptorLength;
                DCmCheckRegistry((PCMHIVE)(Key->KeyHive));

            } else {

                //
                // Size hasn't changed, and it's not shared by any other cells, so
                // we can just write the new bits over the old bits.
                //

                //
                // new bits should be copied over the cached security 
                // descriptor too, to keep cache consistency
                //
                //
                // get the cached security structure for this security cell
                //
                ULONG Index;

                if( CmpFindSecurityCellCacheIndex ((PCMHIVE)Hive,SecurityCell,&Index) == FALSE ) {
                    //
                    // this cannot happen !!!
                    //
                    CM_BUGCHECK( REGISTRY_ERROR,BAD_SECURITY_CACHE,2,Key,SecurityCell);
                } 
                CachedSecurity = ((PCMHIVE)Hive)->SecurityCache[Index].CachedSecurity;

                UpdateCache = TRUE;
            }

            RtlCopyMemory( &(Security->Descriptor),
                           DescriptorCopy,
                           DescriptorLength );

            if( UpdateCache == TRUE ) {
                //
                // we just need to copy the descriptor over the existing one
                // (keep the security cache in sync !!!)
                //
                RtlCopyMemory( &(CachedSecurity->Descriptor),
                                DescriptorCopy,
                                DescriptorLength );
                //
                // recalculate the conv key and insert the sd in the proper place in the hash
                //
                CmpRemoveEntryList(&(CachedSecurity->List));
                CachedSecurity->ConvKey = CmpSecConvKey(DescriptorLength,(PULONG)(DescriptorCopy));
                InsertTailList( &(((PCMHIVE)Hive)->SecurityHash[CachedSecurity->ConvKey % CmpSecHashTableSize]),
                                &(CachedSecurity->List)
                              );

            
            } else {
                //
                // add new cell to the security cache
                //
                if( !NT_SUCCESS(CmpAddSecurityCellToCache( (PCMHIVE)Hive,SecurityCell,FALSE,NULL)) ) {
                    //
                    // we couldn't map the bin containing this cell
                    // this shouldn't happen as we just allocated (marked dirty) the cell
                    //
                    ASSERT( FALSE );
                    ExFreePool(DescriptorCopy);
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto ErrorExit;
                }
            }
        }    
    }


    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"\tObject's SD has been changed\n"));

    ExFreePool(DescriptorCopy);

    //
    // Update the LastWriteTime of the key.
    //
    KeQuerySystemTime(&SystemTime);
    Node->LastWriteTime = SystemTime;

    // update the time in kcb too, to keep the cache in sync
    Key->KcbLastWriteTime = SystemTime;

    //
    // Security has changed, update the cache.
    //
    ASSERT_KCB_LOCKED_EXCLUSIVE(Key);
    ASSERT_HIVE_SECURITY_LOCK_OWNED((PCMHIVE)Key->KeyHive);
    CmpAssignSecurityToKcb(Key,Node->Security,TRUE);

    HvReleaseFreeCellRefArray(&CellRef);
    return(STATUS_SUCCESS);

ErrorExit:
    HvReleaseFreeCellRefArray(&CellRef);
    return Status;
}

NTSTATUS
CmpAssignSecurityDescriptor(
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell,
    IN PCM_KEY_NODE Node,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    This routine assigns the given security descriptor to the specified
    node in the configuration tree.

Arguments:

    Hive - Supplies a pointer to the Hive for the node whose security
           descriptor will be assigned.

    Cell - Supplies the HCELL_INDEX of the node whose security descriptor
           will be assigned.

    Node - Supplies a pointer to the node whose security descriptor will
           be assigned.

    SecurityDescriptor - Supplies a pointer to the security descriptor to
           be assigned to the node.

    PoolType - Supplies the type of pool the SecurityDescriptor was a
           allocated from.

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful and an appropriate error value
        otherwise

--*/

{
    HCELL_INDEX SecurityCell;
    PCM_KEY_SECURITY Security;
    ULONG DescriptorLength;
    ULONG Type;

    CM_PAGED_CODE();
    //
    // Map the node that we need to assign the security descriptor to.
    //
    if (! HvMarkCellDirty(Hive, Cell,FALSE)) {
        return STATUS_NO_LOG_SPACE;
    }
    ASSERT_NODE(Node);

    ASSERT_HIVE_SECURITY_LOCK_OWNED((PCMHIVE)Hive);

#if DBG
    {
        UNICODE_STRING Name;

        Name.MaximumLength = Name.Length = Node->NameLength;
        Name.Buffer = Node->Name;
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpAssignSecurityDescriptor: '%wZ' (H %p C %lx)\n",&Name,Hive,Cell ));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"\tSecurityCell = %lx\n",Node->Security));
    }
#endif

    ASSERT(Node->Security==HCELL_NIL);

    //
    // This is a CreateKey, so the registry node has just been created and
    // the security descriptor we have been passed needs to be associated
    // with the new registry node and inserted into the hive.
    //

    //
    // Try to find an existing security descriptor that matches this one.
    // If successful, then we don't need to allocate a new cell, we can
    // just point to the existing one and increment its reference count.
    //
    Type = HvGetCellType(Cell);
    if (!CmpFindMatchingDescriptorCell( (PCMHIVE)Hive,
                                        SecurityDescriptor,
                                        Type,
                                        &SecurityCell,
                                        NULL)) {
        //
        // No matching descriptor found, allocate and initialize a new one.
        //
        SecurityCell = HvAllocateCell(Hive,
                                      SECURITY_CELL_LENGTH(SecurityDescriptor),
                                      Type,
                                      HCELL_NIL);
        if (SecurityCell == HCELL_NIL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Map the security cell
        //
        Security = (PCM_KEY_SECURITY) HvGetCell(Hive, SecurityCell);
        if( Security == NULL ) {
            //
            // we couldn't map the bin containing this cell
            // this shouldn't happen as we just allocated this cell
            // (i.e. it should be PINNED into memory at this point)
            //
            ASSERT( FALSE );
            HvFreeCell(Hive, SecurityCell);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        // release the cell right here as the view is pinned
        HvReleaseCell(Hive, SecurityCell);

        //
        // Initialize the security cell
        //
        DescriptorLength = RtlLengthSecurityDescriptor(SecurityDescriptor);

        Security->Signature = CM_KEY_SECURITY_SIGNATURE;
        Security->ReferenceCount = 1;
        Security->DescriptorLength = DescriptorLength;
        RtlCopyMemory( &(Security->Descriptor),
                       SecurityDescriptor,
                       DescriptorLength );

        //
        // Insert the new security descriptor into the list of security
        // cells; takes care of cache too
        //
        if (!CmpInsertSecurityCellList(Hive,Cell,SecurityCell))
        {
            HvFreeCell(Hive, SecurityCell);
            return STATUS_NO_LOG_SPACE;
        }

    } else {

        //
        // Found identical descriptor already existing.  Map it in and
        // increment its reference count.
        //
        if (! HvMarkCellDirty(Hive, SecurityCell,FALSE)) {
            return STATUS_NO_LOG_SPACE;
        }
        Security = (PCM_KEY_SECURITY) HvGetCell(Hive, SecurityCell);
        if( Security == NULL ) {
            //
            // we couldn't map the bin containing this cell
            // this shouldn't happen as we just marked the cell dirty
            // (dirty means PIN !)
            //
            ASSERT( FALSE );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        // release the cell right here as the cell is dirty
        HvReleaseCell(Hive, SecurityCell);

        Security->ReferenceCount += 1;
    }

    //
    // Initialize the reference in the node cell
    //
    Node->Security = SecurityCell;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"\tSecurityCell = %lx\n",Node->Security));

    return(STATUS_SUCCESS);
}


NTSTATUS
CmpQuerySecurityDescriptorInfo(
    IN PCM_KEY_CONTROL_BLOCK kcb,
    IN PSECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG Length,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor
    )

/*++

Routine Description:

    This routine will extract the desired information from the
    passed security descriptor and return the information in
    the passed buffer as a security descriptor in absolute format.

Arguments:

    Key - Supplies a pointer to the CM_KEY_REFERENCE for the node whose
        security descriptor will be deleted.

    SecurityInformation - Specifies what information is being queried.

    SecurityDescriptor - Supplies the buffer to output the requested
        information into.

        This buffer has been probed only to the size indicated by
        the Length parameter.  Since it still points into user space,
        it must always be accessed in a try clause.

    Length - Supplies the address of a variable containing the length of
        the security descriptor buffer.  Upon return this variable will
        contain the length needed to store the requested information.

    ObjectsSecurityDescriptor - Supplies the address of a pointer to
        the objects security descriptor.  The passed security descriptor
        must be in self-relative format.


Return Value:

    NTSTATUS - STATUS_SUCCESS if successful and an appropriate error value
        otherwise

Note:
    
      In the new implementation this function looks just in the security cache

--*/

{
    NTSTATUS                Status;
    PSECURITY_DESCRIPTOR    CellSecurityDescriptor;

    CM_PAGED_CODE();

    UNREFERENCED_PARAMETER (ObjectsSecurityDescriptor);

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpQuerySecurityDescriptorInfo:\n"));



    CellSecurityDescriptor = &(kcb->CachedSecurity->Descriptor);

    Status = SeQuerySecurityDescriptorInfo( SecurityInformation,
                                            SecurityDescriptor,
                                            Length,
                                            &CellSecurityDescriptor );

    return Status;
}


BOOLEAN
CmpCheckCreateAccess(
    IN PUNICODE_STRING RelativeName,
    IN PSECURITY_DESCRIPTOR Descriptor,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE PreviousMode,
    IN ACCESS_MASK AdditionalAccess,
    OUT PNTSTATUS AccessStatus
    )

/*++

Routine Description:

    This routine checks to see if we are allowed to create a sub-key in the
    given key, and performs auditing as appropriate.

Arguments:

    RelativeName - Supplies the relative name of the key being created.

    Descriptor - Supplies the security descriptor of the key in which
        the sub-key is to be created.

    CreateAccess - The access mask corresponding to create access for
        this directory type.

    AccessState - Checks for traverse access will typically be incidental
        to some other access attempt.  Information on the current state of
        that access attempt is required so that the constituent access
        attempts may be associated with each other in the audit log.

    PreviousMode - The previous processor mode.

    AdditionalAccess - access rights in addition to KEY_CREATE_SUB_KEY
            that are required.  (e.g. KEY_CREATE_LINK)

    AccessStatus - Pointer to a variable to return the status code of the
        access attempt.  In the case of failure this status code must be
        propagated back to the user.

Return Value:

    BOOLEAN - TRUE if access is allowed and FALSE otherwise.  AccessStatus
    contains the status code to be passed back to the caller.  It is not
    correct to simply pass back STATUS_ACCESS_DENIED, since this will have
    to change with the advent of mandatory access control.

--*/

{
    BOOLEAN AccessAllowed;
    ACCESS_MASK GrantedAccess = 0;

    CM_PAGED_CODE();

    UNREFERENCED_PARAMETER (RelativeName);

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpCheckCreateAccess:\n"));

    SeLockSubjectContext( &AccessState->SubjectSecurityContext );

    AccessAllowed = SeAccessCheck(
                        Descriptor,
                        &AccessState->SubjectSecurityContext,
                        TRUE,                              // Token is read locked
                        (KEY_CREATE_SUB_KEY | AdditionalAccess),
                        0,
                        NULL,
                        &CmpKeyObjectType->TypeInfo.GenericMapping,
                        PreviousMode,
                        &GrantedAccess,
                        AccessStatus
                        );

    SeUnlockSubjectContext( &AccessState->SubjectSecurityContext );

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"Create access %s\n",AccessAllowed ? "granted" : "denied"));

    return(AccessAllowed);
}


BOOLEAN
CmpCheckNotifyAccess(
    IN PCM_NOTIFY_BLOCK NotifyBlock,
    IN PHHIVE Hive,
    IN PCM_KEY_NODE Node
    )
/*++

Routine Description:

    Check whether the subject process/thread/user specified by the
    security data in the NotifyBlock has required access to the
    key specified by Hive.Cell.

Arguments:

    NotifyBlock - pointer to structure that describes the notify
                  operation, including the identity of the subject
                  that opened the notify.

    Hive - Supplies pointer to hive containing Node.

    Node - Supplies pointer to key of interest.

Return Value:

    TRUE if RequiredAccess is in fact possessed by the subject,
    else FALSE.

Note:

    In the new implementation get the sd from the security cache.

--*/
{
    PSECURITY_DESCRIPTOR    SecurityDescriptor;
    BOOLEAN                 AccessAllowed;
    NTSTATUS                Status;
    ACCESS_MASK             GrantedAccess = 0;
    ULONG                   Index;

    CM_PAGED_CODE();

    ASSERT_CM_LOCK_OWNED();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpCheckAccessForNotify:\n"));

    CmLockHiveSecurityShared((PCMHIVE)Hive);
    if( CmpFindSecurityCellCacheIndex ((PCMHIVE)Hive,Node->Security,&Index) == FALSE ) {
        CmUnlockHiveSecurity((PCMHIVE)Hive);
        return FALSE;
    }


    SecurityDescriptor = &(((PCMHIVE)Hive)->SecurityCache[Index].CachedSecurity->Descriptor);
    CmUnlockHiveSecurity((PCMHIVE)Hive);

    SeLockSubjectContext( &NotifyBlock->SubjectContext );

    AccessAllowed = SeAccessCheck( SecurityDescriptor,
                                   &NotifyBlock->SubjectContext,
                                   TRUE,
                                   KEY_NOTIFY,
                                   0,
                                   NULL,
                                   &CmpKeyObjectType->TypeInfo.GenericMapping,
                                   UserMode,
                                   &GrantedAccess,
                                   &Status );

    SeUnlockSubjectContext( &NotifyBlock->SubjectContext );

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"Notify access %s\n",AccessAllowed ? "granted" : "denied"));

    return AccessAllowed;
}

PCM_KEY_SECURITY
CmpGetKeySecurity(
    IN PHHIVE Hive,
    IN PCM_KEY_NODE Key,
    OUT PHCELL_INDEX SecurityCell
    )

/*++

Routine Description:

    This routine returns the security of a registry key.

    NB: Caller to do a release on SecurityCell

Arguments:

    Hive - Supplies the hive the object's cell is in.

    Key - Supplies a pointer to the key node.

    SecurityCell - Returns the index of the security cell

Return Value:

    Returns a pointer to the security cell of the object
    
    NULL, if resources problem
--*/

{
    HCELL_INDEX CellIndex;
    PCM_KEY_SECURITY Security;

    CM_PAGED_CODE();

    ASSERT(Key->Signature == CM_KEY_NODE_SIGNATURE);
    ASSERT_NODE(Key);

#if DBG
    {
        UNICODE_STRING Name;

        Name.MaximumLength = Name.Length = Key->NameLength;
        Name.Buffer = Key->Name;
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpGetObjectSecurity for: "));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"%wZ\n", &Name));
    }
#endif

    CellIndex = Key->Security;

    //
    // Map in the security descriptor cell
    //
    Security = (PCM_KEY_SECURITY) HvGetCell(Hive, CellIndex);
    if( Security == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        return NULL;
    }
    ASSERT_SECURITY(Security);

    *SecurityCell = CellIndex;

    return(Security);
}

PSECURITY_DESCRIPTOR
CmpHiveRootSecurityDescriptor(
    VOID
    )
/*++

Routine Description:

    This routine allocates and initializes the default security descriptor
    for a system-created registry key.

    The caller is responsible for freeing the allocated security descriptor
    when he is done with it.

Arguments:

    None

Return Value:

    Pointer to an initialized security descriptor if successful.

    Bugcheck otherwise.

--*/

{
    NTSTATUS Status;
    PSECURITY_DESCRIPTOR SecurityDescriptor=NULL;
    PACL Acl=NULL;
    PACL AclCopy;
    PSID WorldSid=NULL;
    PSID RestrictedSid=NULL;
    PSID SystemSid=NULL;
    PSID AdminSid=NULL;
    SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    ULONG AceLength;
    ULONG AclLength;
    PACE_HEADER AceHeader;

    CM_PAGED_CODE();

    //
    // Allocate and initialize the SIDs we will need.
    //
    WorldSid  = ExAllocatePool(PagedPool, RtlLengthRequiredSid(1));
    RestrictedSid  = ExAllocatePool(PagedPool, RtlLengthRequiredSid(1));
    SystemSid = ExAllocatePool(PagedPool, RtlLengthRequiredSid(1));
    AdminSid  = ExAllocatePool(PagedPool, RtlLengthRequiredSid(2));
    if ((WorldSid  == NULL) ||
        (RestrictedSid == NULL) ||
        (SystemSid == NULL) ||
        (AdminSid  == NULL)) {

        CM_BUGCHECK(REGISTRY_ERROR, ALLOCATE_SECURITY_DESCRIPTOR, 1, 0, 0);
    }

    if ((!NT_SUCCESS(RtlInitializeSid(WorldSid, &WorldAuthority, 1))) ||
        (!NT_SUCCESS(RtlInitializeSid(RestrictedSid, &NtAuthority, 1))) ||
        (!NT_SUCCESS(RtlInitializeSid(SystemSid, &NtAuthority, 1))) ||
        (!NT_SUCCESS(RtlInitializeSid(AdminSid, &NtAuthority, 2)))) {
        CM_BUGCHECK(REGISTRY_ERROR, ALLOCATE_SECURITY_DESCRIPTOR, 2, 0, 0);
    }

    *(RtlSubAuthoritySid(WorldSid, 0)) = SECURITY_WORLD_RID;

    *(RtlSubAuthoritySid(RestrictedSid, 0)) = SECURITY_RESTRICTED_CODE_RID;

    *(RtlSubAuthoritySid(SystemSid, 0)) = SECURITY_LOCAL_SYSTEM_RID;

    *(RtlSubAuthoritySid(AdminSid, 0)) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid(AdminSid, 1)) = DOMAIN_ALIAS_RID_ADMINS;

    ASSERT(RtlValidSid(WorldSid));
    ASSERT(RtlValidSid(RestrictedSid));
    ASSERT(RtlValidSid(SystemSid));
    ASSERT(RtlValidSid(AdminSid));

    //
    // Compute the size of the ACE list
    //

    AceLength = (SeLengthSid(WorldSid)  -
                 sizeof(ULONG)          +
                 sizeof(ACCESS_ALLOWED_ACE))
              + (SeLengthSid(RestrictedSid)  -
                 sizeof(ULONG)          +
                 sizeof(ACCESS_ALLOWED_ACE))
              + (SeLengthSid(SystemSid) -
                 sizeof(ULONG)          +
                 sizeof(ACCESS_ALLOWED_ACE))
              + (SeLengthSid(AdminSid)  -
                 sizeof(ULONG)          +
                 sizeof(ACCESS_ALLOWED_ACE));

    //
    // Allocate and initialize the ACL
    //

    AclLength = AceLength + sizeof(ACL);
    Acl = ExAllocatePool(PagedPool, AclLength);
    if (Acl == NULL) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpHiveRootSecurityDescriptor: couldn't allocate ACL\n"));

        CM_BUGCHECK(REGISTRY_ERROR, ALLOCATE_SECURITY_DESCRIPTOR, 3, 0, 0);
    }

    Status = RtlCreateAcl(Acl, AclLength, ACL_REVISION);
    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpHiveRootSecurityDescriptor: couldn't initialize ACL\n"));
        CM_BUGCHECK(REGISTRY_ERROR, ALLOCATE_SECURITY_DESCRIPTOR, 4, Status, 0);
    }

    //
    // Now add the ACEs to the ACL
    //
    Status = RtlAddAccessAllowedAce(Acl,
                                    ACL_REVISION,
                                    KEY_ALL_ACCESS,
                                    SystemSid);
    if (NT_SUCCESS(Status)) {
        Status = RtlAddAccessAllowedAce(Acl,
                                        ACL_REVISION,
                                        KEY_ALL_ACCESS,
                                        AdminSid);
    }
    if (NT_SUCCESS(Status)) {
        Status = RtlAddAccessAllowedAce(Acl,
                                        ACL_REVISION,
                                        KEY_READ,
                                        WorldSid);
    }
    if (NT_SUCCESS(Status)) {
        Status = RtlAddAccessAllowedAce(Acl,
                                        ACL_REVISION,
                                        KEY_READ,
                                        RestrictedSid);
    }
    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpHiveRootSecurityDescriptor: RtlAddAce failed status %08lx\n", Status));

        CM_BUGCHECK(REGISTRY_ERROR, ALLOCATE_SECURITY_DESCRIPTOR, 5, Status, 0);
    }

    //
    // Make the ACEs inheritable
    //
    Status = RtlGetAce(Acl,0,&AceHeader);
    ASSERT(NT_SUCCESS(Status));
    AceHeader->AceFlags |= CONTAINER_INHERIT_ACE;

    Status = RtlGetAce(Acl,1,&AceHeader);
    ASSERT(NT_SUCCESS(Status));
    AceHeader->AceFlags |= CONTAINER_INHERIT_ACE;

    Status = RtlGetAce(Acl,2,&AceHeader);
    ASSERT(NT_SUCCESS(Status));
    AceHeader->AceFlags |= CONTAINER_INHERIT_ACE;

    Status = RtlGetAce(Acl,3,&AceHeader);
    ASSERT(NT_SUCCESS(Status));
    AceHeader->AceFlags |= CONTAINER_INHERIT_ACE;
    //
    // We are finally ready to allocate and initialize the security descriptor
    // Allocate enough space to hold both the security descriptor and the
    // ACL.  This allows us to free the whole thing at once when we are
    // done with it.
    //

    SecurityDescriptor = ExAllocatePool(
                            PagedPool,
                            sizeof(SECURITY_DESCRIPTOR) + AclLength
                            );

    if (SecurityDescriptor == NULL) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpHiveRootSecurityDescriptor: Couldn't allocate Sec. Desc.\n"));
        CM_BUGCHECK(REGISTRY_ERROR, ALLOCATE_SECURITY_DESCRIPTOR, 6, 0, 0);
    }

    AclCopy = (PACL)((PISECURITY_DESCRIPTOR)SecurityDescriptor+1);
    RtlCopyMemory(AclCopy, Acl, AclLength);

    Status = RtlCreateSecurityDescriptor( SecurityDescriptor,
                                          SECURITY_DESCRIPTOR_REVISION );
    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpHiveRootSecurityDescriptor: CreateSecDesc failed %08lx\n",Status));
        ExFreePool(SecurityDescriptor);
        SecurityDescriptor=NULL;
        CM_BUGCHECK(REGISTRY_ERROR, ALLOCATE_SECURITY_DESCRIPTOR, 7, Status, 0);
    }

    Status = RtlSetDaclSecurityDescriptor( SecurityDescriptor,
                                           TRUE,
                                           AclCopy,
                                           FALSE );
    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpHiveRootSecurityDescriptor: SetDacl failed %08lx\n",Status));
        ExFreePool(SecurityDescriptor);
        SecurityDescriptor=NULL;
        CM_BUGCHECK(REGISTRY_ERROR, ALLOCATE_SECURITY_DESCRIPTOR, 8, Status, 0);
    }

    //
    // free any allocations we made
    //
    if (WorldSid!=NULL) {
        ExFreePool(WorldSid);
    }
    if (RestrictedSid!=NULL) {
        ExFreePool(RestrictedSid);
    }
    if (SystemSid!=NULL) {
        ExFreePool(SystemSid);
    }
    if (AdminSid!=NULL) {
        ExFreePool(AdminSid);
    }
    if (Acl!=NULL) {
        ExFreePool(Acl);
    }

    return(SecurityDescriptor);
}

VOID
CmpFreeSecurityDescriptor(
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell
    )

/*++

Routine Description:

    Frees the security descriptor associated with a particular node.  This
    can only happen when the node is actually being deleted from the
    registry.

    NOTE:   Caller is expected to have already marked relevant cells dirty.

Arguments:

    Hive - Supplies thepointer to hive control structure for hive of interest

    Cell - Supplies index for cell to free storage for (the target)

Return Value:

    None.

--*/

{
    PCELL_DATA Node;
    PCELL_DATA Security;
    HCELL_INDEX SecurityCell;

    CM_PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpFreeSecurityDescriptor for cell %ld\n",Cell));

    ASSERT_HIVE_SECURITY_LOCK_OWNED((PCMHIVE)Hive);
    //
    // Map in the cell whose security descriptor is being freed
    //
    Node = HvGetCell(Hive, Cell);
    if( Node == NULL ) {
        //
        // we couldn't map the bin containing this cell
        // Sorry, we cannot free the descriptor
        return;
    }

    ASSERT_NODE(&(Node->u.KeyNode));

    //
    // Map in the cell containing the security descriptor.
    //
    SecurityCell = Node->u.KeyNode.Security;
    Security = HvGetCell(Hive, SecurityCell);
    if( Security == NULL ) {
        //
        // we couldn't map the bin containing this cell
        // Sorry, we cannot free the descriptor
        HvReleaseCell(Hive, Cell);
        return;
    }

    ASSERT_SECURITY(&(Security->u.KeySecurity));


    if (Security->u.KeySecurity.ReferenceCount == 1) {

        //
        // This is the only cell that references this security descriptor,
        // so it is ok to free it now.
        //
        CmpRemoveSecurityCellList(Hive, SecurityCell);
        HvFreeCell(Hive, SecurityCell);
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpFreeSecurityDescriptor: freeing security cell\n"));
    } else {

        //
        // More than one node references this security descriptor, so
        // just decrement the reference count.
        //
        Security->u.KeySecurity.ReferenceCount -= 1;
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpFreeSecurityDescriptor: decrementing reference count\n"));
    }

    //
    // Zero out the pointer to the security descriptdr in the main cell
    //
    Node->u.KeyNode.Security = HCELL_NIL;
    // release the cells
    HvReleaseCell(Hive, Cell);
    HvReleaseCell(Hive, SecurityCell);
}

BOOLEAN
CmpInsertSecurityCellList(
    IN PHHIVE Hive,
    IN HCELL_INDEX NodeCell,
    IN HCELL_INDEX SecurityCell
    )
/*++

Routine Description:

    Inserts a newly-created security cell into the per-hive linked list of
    security cells.

    NOTE:   Assumes that NodeCell and SecurityCell have already been
            marked dirty.

Arguments:

    Hive - Supplies a pointer to the hive control structure.

    NodeCell - Supplies the cell index of the node that owns the security cell

    SecurityCell - Supplies the cell index of the security cell.

Return Value:

    TRUE - it worked

    FALSE - some failure - generally STATUS_NO_LOG_SPACE

--*/

{
    PCM_KEY_SECURITY    FlinkCell;
    PCM_KEY_SECURITY    BlinkCell;
    PCM_KEY_SECURITY    Cell;
    PCM_KEY_NODE        Node;
    PCM_KEY_NODE        ParentNode;
    HV_TRACK_CELL_REF   CellRef = {0};

    CM_PAGED_CODE();
    //
    // If the new cell's storage type is Volatile, simply make it the
    //  anchor of it's own list.  (Volatile security entries will disappear
    //  at reboot, restore, etc, so we don't need the list to hunt them
    //  down at those times.)
    //
    // Else, the storage type is Stable.
    //   Map in the node that owns the new security cell.  If it is a root
    //   cell, then we are creating the hive for the first time, so this is
    //   the only security cell in the list.  If it is not a root cell, then
    //   we simply find its parent's security cell and stick the new security
    //   cell into the list immediately after it.
    //
    //
    // we have the lock exclusive or nobody is operating inside this hive
    //
    ASSERT_HIVE_SECURITY_LOCK_OWNED((PCMHIVE)Hive);

    Cell = (PCM_KEY_SECURITY) HvGetCell(Hive, SecurityCell);
    if( Cell == NULL ) {
        //
        // we couldn't map the bin containing this cell
        // 
        return FALSE;
    }

    if( !HvTrackCellRef(&CellRef,Hive,SecurityCell) ) {
        return FALSE;
    }

    ASSERT_SECURITY(Cell);

    if (HvGetCellType(SecurityCell) == Volatile) {

        Cell->Flink = Cell->Blink = SecurityCell;

    } else {

        Node = (PCM_KEY_NODE) HvGetCell(Hive, NodeCell);
        if( Node == NULL ) {
            //
            // we couldn't map the bin containing this cell
            // 
            goto ErrorExit;
        }

        if( !HvTrackCellRef(&CellRef,Hive,NodeCell) ) {
            goto ErrorExit;
        }

        ASSERT_NODE(Node);

        if (Node->Flags & KEY_HIVE_ENTRY) {
            //
            // This must be the hive creation, so this cell becomes the anchor
            // for the list.
            //
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpInsertSecurityCellList: hive creation\n"));
            Cell->Flink = Cell->Blink = SecurityCell;

        } else {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpInsertSecurityCellList: insert at parent\n"));
            //
            // Map in the node's parent's security cell, so we can hook into
            // the list there.
            //
            ParentNode = (PCM_KEY_NODE) HvGetCell(Hive, Node->Parent);
            if( ParentNode == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // 
                goto ErrorExit;
            }
            if( !HvTrackCellRef(&CellRef,Hive,Node->Parent) ) {
                goto ErrorExit;
            }

            ASSERT_NODE(ParentNode);
            BlinkCell = (PCM_KEY_SECURITY) HvGetCell(
                                            Hive,
                                            ParentNode->Security
                                            );
            if( BlinkCell == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // 
                goto ErrorExit;
            }
            if( !HvTrackCellRef(&CellRef,Hive,ParentNode->Security) ) {
                goto ErrorExit;
            }

            ASSERT_SECURITY(BlinkCell);

            //
            // Map in the Flink of the parent's security cell.
            //
            FlinkCell = (PCM_KEY_SECURITY) HvGetCell(
                                            Hive,
                                            BlinkCell->Flink
                                            );
            if( FlinkCell == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // 
                goto ErrorExit;
            }
            if( !HvTrackCellRef(&CellRef,Hive,BlinkCell->Flink) ) {
                goto ErrorExit;
            }

            ASSERT_SECURITY(FlinkCell);

            if (! (HvMarkCellDirty(Hive, ParentNode->Security,FALSE) &&
                   HvMarkCellDirty(Hive, BlinkCell->Flink,FALSE)))
            {
                goto ErrorExit;
            }

            //
            // Insert the new security cell in between the Flink and Blink cells
            //
            Cell->Flink = BlinkCell->Flink;
            Cell->Blink = FlinkCell->Blink;
            BlinkCell->Flink = SecurityCell;
            FlinkCell->Blink = SecurityCell;
        }
    }

    //
    // add the new security cell to the hive's security cache
    //
    if( !NT_SUCCESS( CmpAddSecurityCellToCache ( (PCMHIVE)Hive,SecurityCell,FALSE,NULL) ) ) {
        goto ErrorExit;
    }

    HvReleaseFreeCellRefArray(&CellRef);
    return TRUE;
ErrorExit:
    HvReleaseFreeCellRefArray(&CellRef);
    return FALSE;
}

VOID
CmpRemoveSecurityCellList(
    IN PHHIVE Hive,
    IN HCELL_INDEX SecurityCell
    )
/*++

Routine Description:

    Removes a security cell from the per-hive linked list of security cells.
    (This means the cell is going to be deleted!)

    NOTE:   Caller is expected to have already marked relevant cells dirty

Arguments:

    Hive - Supplies a pointer to the hive control structure

    SecurityCell - Supplies the cell index of the security cell to be
           removed

Return Value:

    None.

--*/

{
    PCM_KEY_SECURITY FlinkCell;
    PCM_KEY_SECURITY BlinkCell;
    PCM_KEY_SECURITY Cell;

    CM_PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpRemoveSecurityCellList: index %ld\n",SecurityCell));

    ASSERT_HIVE_SECURITY_LOCK_OWNED((PCMHIVE)Hive);

    Cell = (PCM_KEY_SECURITY) HvGetCell(Hive, SecurityCell);
    if( Cell == NULL ) {
        //
        // we couldn't map the bin containing one of these cells
        // 
        return;
    }

    FlinkCell = (PCM_KEY_SECURITY) HvGetCell(Hive, Cell->Flink);
    if( FlinkCell == NULL ) {
        //
        // we couldn't map the bin containing one of these cells
        // 
        HvReleaseCell(Hive, SecurityCell);
        return;
    }

    BlinkCell = (PCM_KEY_SECURITY) HvGetCell(Hive, Cell->Blink);
    if( BlinkCell == NULL ) {
        //
        // we couldn't map the bin containing one of these cells
        // 
        HvReleaseCell(Hive, SecurityCell);
        HvReleaseCell(Hive, Cell->Flink);
        return;
    }

    ASSERT(FlinkCell->Blink == SecurityCell);
    ASSERT(BlinkCell->Flink == SecurityCell);

    FlinkCell->Blink = Cell->Blink;
    BlinkCell->Flink = Cell->Flink;

    //
    // finally, remove the security cell from cache, as it'll be freed
    //
    CmpRemoveFromSecurityCache ( (PCMHIVE)Hive,SecurityCell);

    //
    // release used cells
    //
    HvReleaseCell(Hive, Cell->Blink);
    HvReleaseCell(Hive, Cell->Flink);
    HvReleaseCell(Hive, SecurityCell);
}

NTSTATUS
CmpCheckKeyAccess(
    IN PHHIVE           Hive,
    IN HCELL_INDEX      NodeCell,
    IN KPROCESSOR_MODE  PreviousMode,
    IN ACCESS_MASK      DesiredAccess
    )
/*++

Routine Description:

    Checks if the specified access is granted on this key by looking at the hive
    storage. SD as stored in the key needs to be converted to relative first.

    Assumes reglock held EX

Arguments:

    Hive - Supplies a pointer to the hive control structure.

    NodeCell - Supplies the cell index of the node that owns the security cell
    
    PreviousMode - caller's previous mode

    DesiredAccess - the access we want to check against

Return Value:

    STATUS_SUCCESS - access granted

    else - not granted or other error

--*/

{
    PCM_KEY_SECURITY    Security = NULL;
    HCELL_INDEX         SecurityCell;
    PCM_KEY_NODE        Node;
    PSECURITY_DESCRIPTOR    SecurityDescriptor = NULL;
    NTSTATUS            Status = STATUS_SUCCESS;
    SECURITY_INFORMATION SecurityInformation;
    ULONG               Length;
    SECURITY_SUBJECT_CONTEXT SubjectContext;
    ACCESS_MASK         GrantedAccess;
    NTSTATUS            AccessStatus;
    PSECURITY_DESCRIPTOR    CellSecurityDescriptor;
    CM_PAGED_CODE();

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

    //
    // fetch the SD through the key node
    //
    Node = (PCM_KEY_NODE)HvGetCell(Hive,NodeCell);
    if( Node == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    SecurityCell = Node->Security;
    HvReleaseCell(Hive,NodeCell);

    Security = (PCM_KEY_SECURITY)HvGetCell(Hive,SecurityCell);
    if( Security == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    SecurityDescriptor = ExAllocatePool(PagedPool, Security->DescriptorLength);
    if( SecurityDescriptor == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }
    Length = Security->DescriptorLength;
    //
    //  Request a complete security descriptor
    //
    SecurityInformation = OWNER_SECURITY_INFORMATION |
                          GROUP_SECURITY_INFORMATION |
                          DACL_SECURITY_INFORMATION  |
                          SACL_SECURITY_INFORMATION;


    CellSecurityDescriptor = &(Security->Descriptor);
    Status = SeQuerySecurityDescriptorInfo( &SecurityInformation,
                                            SecurityDescriptor,
                                            &Length,
                                            &CellSecurityDescriptor );
    if (Status == STATUS_BUFFER_TOO_SMALL) {
        //
        //  The SD is larger than we tried first time. We need to allocate an other
        //  buffer and try again with this size
        //
        ExFreePool(SecurityDescriptor);
        SecurityDescriptor = ExAllocatePool(PagedPool, Length);
        if( SecurityDescriptor == NULL ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }
        Status = SeQuerySecurityDescriptorInfo( &SecurityInformation,
                                                SecurityDescriptor,
                                                &Length,
                                                &CellSecurityDescriptor );
    }
    if( !NT_SUCCESS(Status) ) {
        goto Exit;
    }
    //
    // now that we have the SD handy and prepared, do the access check.
    //
    SeCaptureSubjectContext( &SubjectContext );

    if( SeAccessCheck(   SecurityDescriptor,
                            &SubjectContext,
                            FALSE,
                            DesiredAccess,
                            0,
                            NULL,
                            &CmpKeyObjectType->TypeInfo.GenericMapping,
                            PreviousMode,
                            &GrantedAccess,
                            &AccessStatus ) != TRUE ) {
        Status = STATUS_ACCESS_DENIED;
    }
    
    SeReleaseSubjectContext(&SubjectContext);

Exit:
    HvReleaseCell(Hive,SecurityCell);
    if( SecurityDescriptor != NULL ) {
        ExFreePool(SecurityDescriptor);
    }
    return Status;
}

NTSTATUS
CmpDoAccessCheckOnSubtree(
    PHHIVE          HiveToCheck,
    HCELL_INDEX     Cell,
    KPROCESSOR_MODE PreviousMode,
    ACCESS_MASK     DesiredAccess,
    BOOLEAN         CheckRoot
    )
/*++

Routine Description:

    Recursively does the access check for the DesiredAccess on the whole subtree.

Arguments:


Return Value:


--*/
{
    PCMP_CHECK_REGISTRY_STACK_ENTRY     CheckStack;
    LONG                                StackIndex;
    PCM_KEY_NODE                        Node;
    HCELL_INDEX                         SubKey;
    NTSTATUS                            Status = STATUS_INSUFFICIENT_RESOURCES;
    PRELEASE_CELL_ROUTINE               SavedReleaseCellRoutine;

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

    //
    // Initialize the stack to simulate recursion here
    //
    CheckStack = ExAllocatePoolWithTag(PagedPool,sizeof(CMP_CHECK_REGISTRY_STACK_ENTRY)*CMP_MAX_REGISTRY_DEPTH,CM_POOL_TAG|PROTECTED_POOL);
    if (CheckStack == NULL) {
        return Status;
    }

    SavedReleaseCellRoutine = HiveToCheck->ReleaseCellRoutine;
    HiveToCheck->ReleaseCellRoutine = NULL;

    CheckStack[0].Cell = Cell;
    CheckStack[0].ChildIndex = 0;
    CheckStack[0].CellChecked = !CheckRoot;
    StackIndex = 0;

    while(StackIndex >=0) {
        //
        // first check the current cell
        //
        if( CheckStack[StackIndex].CellChecked == FALSE ) {
            CheckStack[StackIndex].CellChecked = TRUE;

            Status = CmpCheckKeyAccess(HiveToCheck,CheckStack[StackIndex].Cell,PreviousMode,DesiredAccess);
            if(!NT_SUCCESS(Status) ) {
                //
                // bail out
                //
                break;
            }             
        }

        Node = (PCM_KEY_NODE)HvGetCell(HiveToCheck, CheckStack[StackIndex].Cell);
        if( Node == NULL ) {
            //
            // we couldn't map a view for the bin containing this cell
            // bail out
            //
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        if( CheckStack[StackIndex].ChildIndex < (Node->SubKeyCounts[Stable] + Node->SubKeyCounts[Volatile]) ) {
            //
            // we still have childs to check; add another entry for them and advance the 
            // StackIndex
            //
            SubKey = CmpFindSubKeyByNumber(HiveToCheck,
                                           Node,
                                           CheckStack[StackIndex].ChildIndex);
            if( SubKey == HCELL_NIL ) {
                //
                // we couldn't map cell;bail out
                //
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            //
            // next iteration will check the next child
            //
            CheckStack[StackIndex].ChildIndex++;

            StackIndex++;
            if( StackIndex == CMP_MAX_REGISTRY_DEPTH ) {
                //
                // we've run out of stack; registry tree has too many levels
                // bail out
                //
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            CheckStack[StackIndex].Cell = SubKey;
            CheckStack[StackIndex].ChildIndex = 0;
            CheckStack[StackIndex].CellChecked = FALSE;

        } else {
            //
            // we have checked all childs for this node; go back
            //
            StackIndex--;

        }

    }

    HiveToCheck->ReleaseCellRoutine = SavedReleaseCellRoutine;

    ExFreePoolWithTag(CheckStack, CM_POOL_TAG|PROTECTED_POOL);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmsecache.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmsecache.c

Abstract:

    This module implements the security cache.

--*/

#include "cmp.h"

#define SECURITY_CACHE_GROW_INCREMENTS  0x10

BOOLEAN
CmpFindMatchingDescriptorCell(
    IN PCMHIVE CmHive,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG Type,
    OUT PHCELL_INDEX MatchingCell,
    OUT OPTIONAL PCM_KEY_SECURITY_CACHE *CachedSecurityPointer
    );

PCM_KEY_SECURITY_CACHE
CmpFindReusableCellFromCache(IN PCMHIVE     CmHive,
                             IN HCELL_INDEX SecurityCell,
                             IN ULONG       PreviousCount
                             );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpSecConvKey)
#pragma alloc_text(PAGE,CmpInitSecurityCache)
#pragma alloc_text(PAGE,CmpDestroySecurityCache)
#pragma alloc_text(PAGE,CmpRebuildSecurityCache)
#pragma alloc_text(PAGE,CmpAddSecurityCellToCache)
#pragma alloc_text(PAGE,CmpFindSecurityCellCacheIndex)
#pragma alloc_text(PAGE,CmpAdjustSecurityCacheSize)
#pragma alloc_text(PAGE,CmpRemoveFromSecurityCache)
#pragma alloc_text(PAGE,CmpFindMatchingDescriptorCell)
#pragma alloc_text(PAGE,CmpAssignSecurityToKcb)
#pragma alloc_text(PAGE,CmpFindReusableCellFromCache)
#pragma alloc_text(PAGE,CmpBuildSecurityCellMappingArray)
#endif

ULONG
CmpSecConvKey(
              IN ULONG  DescriptorLength,
              IN PULONG Descriptor
              )
/*++

Routine Description:

    Computes the ConvKey for the given security descriptor.
    The algorithm is taken from the NTFS security hash. 
    (it was proven to be efficient there; why shouldn't do the same ?)


    For speed in the hash, we consider the security descriptor as an array
    of ULONGs.  The fragment at the end that is ignored should not affect
    the collision nature of this hash.

Arguments:

    DescriptorLength - length (in bytes) of the sd

    Descriptor - actual sd to cache

Return Value:

    ConvKey

Note:
    
      We may want to convert this to a macro
--*/

{
    ULONG   Count;     
    ULONG   Hash = 0;

    PAGED_CODE();

    Count = DescriptorLength / 4;

    while (Count--) {
        Hash = ((Hash << 3) | (Hash >> (32-3))) + *Descriptor++;
    }

    return Hash;
}

VOID
CmpInitSecurityCache(
    IN OUT PCMHIVE      CmHive
    )
{
    ULONG i;

    PAGED_CODE();

    CmHive->SecurityCache = NULL;        
    CmHive->SecurityCacheSize = 0;       
    CmHive->SecurityCount = 0;
    CmHive->SecurityHitHint = -1; // no hint

    for( i=0;i<CmpSecHashTableSize;i++) {
        InitializeListHead(&(CmHive->SecurityHash[i]));
    }
}

NTSTATUS
CmpAddSecurityCellToCache (
    IN OUT PCMHIVE              CmHive,
    IN HCELL_INDEX              SecurityCell,
    IN BOOLEAN                  BuildUp,
    IN PCM_KEY_SECURITY_CACHE   SecurityCached
    )

/*++

Routine Description:

    This routine adds the specified security cell to the cache of the
    specified hive. It takes care of cache allocation (grow) as well.
    At build up time, cache size grows with a PAGE_SIZE, to avoid memory 
    fragmentation. After the table is built, it's size is adjusted (most 
    of the hives never add new security cells). Then, at run-time, the size 
    grows with 16 entries at a time (same reason)
    The cache is ordered by the cell's index, so we can do a binary search on 
    cells retrieval.

Arguments:

    CmHive - the hive to which the security cell belongs

    SecurityCell - the security cell to be added to the cache

    BuildUp - specifies that this is build up time 

    SecurityCached - if not NULL it means we have it already allocated (this happens when rebuilding the cache).

Return Value:

    NTSTATUS - STATUS_SUCCESS if the operation is successful and an
        appropriate error status otherwise (i.e STATUS_INSUFFICIENT_RESOURCES).

Note: 

    If the security cell is already IN the cache; this function will return TRUE.
--*/
{
    ULONG                   Index;
    PCM_KEY_SECURITY        Security;

    PAGED_CODE();

    if( CmpFindSecurityCellCacheIndex (CmHive,SecurityCell,&Index) == TRUE ) {
        // 
        // cell already exist in the cache; return;
        //
        return STATUS_SUCCESS;
    }

    //
    // if this fails, we're doomed !
    //
    ASSERT( (PAGE_SIZE % sizeof(CM_KEY_SECURITY_CACHE_ENTRY)) == 0 );

    //
    // check if the cache can accommodate a new cell
    //
    if( CmHive->SecurityCount == CmHive->SecurityCacheSize ) {
        //
        // We're at the limit with the cache; we need to extend it by a page
        //
        // OBS: this takes care of the first allocation too, as SecurityCount 
        // and SecurityCacheSize are both initialized with 0
        //
        PCM_KEY_SECURITY_CACHE_ENTRY  Temp;

        // store the actual buffer
        Temp = CmHive->SecurityCache;
        
        //
        // compute the new size and allocate a new buffer 
        //
        if( BuildUp == TRUE ) {
            //
            // We are building up the cache; grow the table in page increments
            //
            ASSERT( ((CmHive->SecurityCacheSize * sizeof(CM_KEY_SECURITY_CACHE_ENTRY)) % PAGE_SIZE) == 0 );
            CmHive->SecurityCacheSize += (PAGE_SIZE / sizeof(CM_KEY_SECURITY_CACHE_ENTRY));
        } else {
            //
            // normal case (running time); a new security cell is added; grow the
            // table with a fixed number of increments (to avoid fragmentation, in
            // case of an Office install :-) )
            //
            CmHive->SecurityCacheSize += SECURITY_CACHE_GROW_INCREMENTS;

        }
        CmRetryExAllocatePoolWithTag(PagedPool, CmHive->SecurityCacheSize * sizeof(CM_KEY_SECURITY_CACHE_ENTRY),
                                    CM_SECCACHE_TAG|PROTECTED_POOL,CmHive->SecurityCache);
        if( CmHive->SecurityCache == NULL ) {
            //
            // bad luck; bail out
            //
            CmHive->SecurityCache = Temp;
            CmHive->SecurityCacheSize = CmHive->SecurityCount;
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        //
        // copy existing data in the new location and free the old buffer
        //
        RtlCopyMemory(CmHive->SecurityCache,Temp,CmHive->SecurityCount*sizeof(CM_KEY_SECURITY_CACHE_ENTRY));
        if( Temp != NULL ) {
            ExFreePoolWithTag(Temp, CM_SECCACHE_TAG|PROTECTED_POOL );
        } else {
            ASSERT( CmHive->SecurityCount == 0 );
        }
    }

    //
    // try first to get the security cell from the hive; if this fails, there is no point to go on 
    //
    Security = (PCM_KEY_SECURITY)HvGetCell(&(CmHive->Hive),SecurityCell);
    if( Security == NULL ){
        //
        // we failed to map the view containing this cell; bail out
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if( !SecurityCached ) {
        ULONG                   Size;
        //
        // compute the size for the cached security structure
        //
        Size = FIELD_OFFSET(CM_KEY_SECURITY_CACHE,Descriptor) + Security->DescriptorLength;

        //
        // think forward: allocate and initialize a copy for the security cell, in order to store it in the cache
        //
        CmRetryExAllocatePoolWithTag(PagedPool,Size,CM_SECCACHE_TAG|PROTECTED_POOL,SecurityCached);
        if(SecurityCached == NULL) {
            //
            // bad luck; bail out
            //
            HvReleaseCell(&(CmHive->Hive),SecurityCell);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    //
    // from now on, nothing can go wrong !
    //
    RtlCopyMemory(&(SecurityCached->Descriptor),&(Security->Descriptor),Security->DescriptorLength);
    SecurityCached->Cell = SecurityCell;
    SecurityCached->DescriptorLength = Security->DescriptorLength;

    //
    // now add this to the hash table
    //
    SecurityCached->ConvKey = CmpSecConvKey(Security->DescriptorLength,(PULONG)(&(Security->Descriptor)));
    // add it to the end of the list with this conv key
    InsertTailList( &(CmHive->SecurityHash[SecurityCached->ConvKey % CmpSecHashTableSize]),
                    &(SecurityCached->List)
                   );
    
    HvReleaseCell(&(CmHive->Hive),SecurityCell);

    //
    // At this point we are sure we have space for at least one more entry
    // Move data to make room for the new entry
    //
    if( Index < CmHive->SecurityCount ) {
        //
        // RtlMoveMemory will take care of the overlapping problem
        //
        RtlMoveMemory( ((PUCHAR)CmHive->SecurityCache) + (Index+1)*sizeof(CM_KEY_SECURITY_CACHE_ENTRY),     // destination
                       ((PUCHAR)CmHive->SecurityCache) + Index*sizeof(CM_KEY_SECURITY_CACHE_ENTRY),         // source
                       (CmHive->SecurityCount - Index)*sizeof(CM_KEY_SECURITY_CACHE_ENTRY)                  // size
                        );
    }

    //
    // setup the new entry
    //
    CmHive->SecurityCache[Index].Cell = SecurityCell;
    CmHive->SecurityCache[Index].CachedSecurity = SecurityCached;

    // update the count
    CmHive->SecurityCount++;

    return STATUS_SUCCESS;
}

BOOLEAN
CmpFindSecurityCellCacheIndex (
    IN PCMHIVE      CmHive,
    IN HCELL_INDEX  SecurityCell,
    OUT PULONG      Index
    )

/*++

Routine Description:

    Search (binary) for the specified cellindex in the security cache.
    Returns the index of the cache entry where the cell is cached or 
    it should be added

Arguments:

    CmHive - the hive to which the security cell belongs

    SecurityCell - the security cell to search for

    Index - out param to pass the index at which the cell is (or it should be)

Return Value:

    TRUE - the cell was found (at *Index)
    FALSE - the cell is not in the cache (it should be added at *Index)

--*/
{
    ULONG           High;
    ULONG           Low;
    ULONG           Current;
    USHORT          State = 0;  // state of the operation:  0 - normal binary search
                                //                          1 - last low
                                //                          2 - last high
    LONG            Result;
    LONG            Tmp1,Tmp2;
    
    PAGED_CODE();

    if( CmHive->SecurityCount == 0 ) {
        //
        // there is no cell in the security cache
        //
        *Index = 0;
        return FALSE;
    }

    // sanity asserts
    ASSERT( CmHive->SecurityCount <= CmHive->SecurityCacheSize );
    ASSERT( CmHive->SecurityCache != NULL );


    High = CmHive->SecurityCount - 1;
    Low = 0;
    if( (CmHive->SecurityHitHint >= 0) && ( (ULONG)CmHive->SecurityHitHint <= High) ) {
        //
        // try the last search
        //
        Current = CmHive->SecurityHitHint;
    } else {
        Current = High/2;
    }

    // sign adjustment
    Tmp1 = SecurityCell & ~HCELL_TYPE_MASK;
    if( SecurityCell & HCELL_TYPE_MASK ) {
        Tmp1 = -Tmp1;
    }

    while( TRUE ) {

        Tmp2 = CmHive->SecurityCache[Current].Cell & ~HCELL_TYPE_MASK;
        // sign adjustment
        if( CmHive->SecurityCache[Current].Cell & HCELL_TYPE_MASK ) {
            Tmp2 = -Tmp2;
        }

        Result = Tmp1 -  Tmp2;    
        
        if (Result == 0) {
            //
            // Success, return data to caller and exit
            //

            *Index = Current;
            //
            // we have a hit! update the count and exit
            //
            CmHive->SecurityHitHint = Current;
            return TRUE;
        }
        //
        // compute the next index to try
        //
        switch(State) {
        case 0:
            //
            // normal binary search state
            //
            if( Result < 0 ) {
                High = Current;
            } else {
                Low = Current;
            }
            if ((High - Low) <= 1) {
                //
                // advance to the new state
                //
                Current = Low;
                State = 1;
            } else {
                Current = Low + ( (High-Low) / 2 );
            }
            break;
        case 1:
            //
            // last low state
            //

            // this should be true
            ASSERT( Current == Low );
            if (Result < 0) {
                //
                // does not exist, under
                //
            
                *Index = Current;
                return FALSE;
            } else if( Low == High ) {
                        //
                        // low and high are identical; but current is bigger than them; insert after
                        //

                        *Index = Current + 1;
                        return FALSE;
                    } else {
                        //
                        // advance to the new state; i.e. look at high
                        //
                        State = 2;
                        Current = High;
                    }

            break;
        case 2:
            //
            // last high state; if we got here, High = Low +1 and Current == High
            //
            ASSERT( Current == High);
            ASSERT( High == (Low + 1) );
            if( Result < 0 ) {
                //
                // under High, but above Low; we should insert it here
                //

                *Index = Current;
                return FALSE;
            } else {
                //
                // above High; 
                //

                *Index = Current + 1;
                return FALSE;
            }
            break;
        default:
            ASSERT( FALSE );
            break;
        }
    }

    //
    // we shouldn't get here !!!
    //
    ASSERT( FALSE );
    return FALSE;
}

BOOLEAN
CmpAdjustSecurityCacheSize (
    IN PCMHIVE      CmHive
    )

/*++

Routine Description:

    Adjust the scusrity cache size for the specified hive. This function
    should be called after all the security cells for the hive were cached, 
    in order to give back extra memory used in the process.


Arguments:

    CmHive - the hive to which the security cell belongs

Return Value:

    TRUE - success
    FALSE - failure - the size remains the same

--*/
{
    PCM_KEY_SECURITY_CACHE_ENTRY  Buffer;
    
    PAGED_CODE();

    if( CmHive->SecurityCount < CmHive->SecurityCacheSize ) {
        //
        // cache size is bigger than what we need; there is a good chance 
        // nobody will ever add new security cells to this hive, so go on
        // and free the extra space
        //

        //
        // allocate a new buffer with the exact size we need
        //
        CmRetryExAllocatePoolWithTag(PagedPool, CmHive->SecurityCount * sizeof(CM_KEY_SECURITY_CACHE_ENTRY),
                                        CM_SECCACHE_TAG|PROTECTED_POOL,Buffer);
        
        if( Buffer == NULL ) {
            //
            // the system is low on resources; leave the cache as it is
            //
            return FALSE;
        }

        //
        // copy significant data inot the new buffer
        //
        RtlCopyMemory(Buffer,CmHive->SecurityCache,CmHive->SecurityCount*sizeof(CM_KEY_SECURITY_CACHE_ENTRY));

        //
        // free the old buffer and update cache members
        //
        ExFreePoolWithTag(CmHive->SecurityCache, CM_SECCACHE_TAG|PROTECTED_POOL );
        
        CmHive->SecurityCache = Buffer;
        CmHive->SecurityCacheSize = CmHive->SecurityCount;
    }

    return TRUE;
}

VOID
CmpRemoveFromSecurityCache (
    IN OUT PCMHIVE      CmHive,
    IN HCELL_INDEX      SecurityCell
    )

/*++

Routine Description:

    Removes the specified security cell from the security cache.
    (only if present !)
    For performance (and memory fragmentation) reasons, it does not 
    change (shrink) the cache size.

Arguments:

    CmHive - the hive to which the security cell belongs

    SecurityCell - the security cell to be removed from the cache

Return Value:

    <none>
--*/
{
    ULONG               Index;

    PAGED_CODE();

    if( CmpFindSecurityCellCacheIndex (CmHive,SecurityCell,&Index) == FALSE ) {
        // 
        // cell is not in the cache
        //
        return;
    }

    ASSERT( CmHive->SecurityCache[Index].Cell == SecurityCell );
    ASSERT( CmHive->SecurityCache[Index].CachedSecurity->Cell == SecurityCell );
    
    //
    // remove the cached structure from the hash
    //
    CmpRemoveEntryList(&(CmHive->SecurityCache[Index].CachedSecurity->List));
    
    //
    // free up the cached security cell;
    //
    ExFreePoolWithTag(CmHive->SecurityCache[Index].CachedSecurity, CM_SECCACHE_TAG|PROTECTED_POOL );

    //
    // move memory to reflect the new size, and update the cache count
    //
    RtlMoveMemory( ((PUCHAR)CmHive->SecurityCache) + Index*sizeof(CM_KEY_SECURITY_CACHE_ENTRY),         // destination
                   ((PUCHAR)CmHive->SecurityCache) + (Index+1)*sizeof(CM_KEY_SECURITY_CACHE_ENTRY),     // source
                   (CmHive->SecurityCount - Index - 1)*sizeof(CM_KEY_SECURITY_CACHE_ENTRY)              // size   
                 );
    
    CmHive->SecurityCount--;
}

VOID
CmpDestroySecurityCache (
    IN OUT PCMHIVE      CmHive
    )
/*++

Routine Description:

    Frees up all the cached security cells and the cache itself

Arguments:

    CmHive - the hive to which the security cell belongs

Return Value:

    <none>
--*/
{
    ULONG   i;

    PAGED_CODE();

    for( i=0;i<CmHive->SecurityCount;i++) {
        CmpRemoveEntryList(&(CmHive->SecurityCache[i].CachedSecurity->List));
        ExFreePoolWithTag(CmHive->SecurityCache[i].CachedSecurity, CM_SECCACHE_TAG|PROTECTED_POOL );
    }

    if( CmHive->SecurityCount != 0 ) {
        ASSERT( CmHive->SecurityCache != NULL );
        ExFreePoolWithTag(CmHive->SecurityCache, CM_SECCACHE_TAG|PROTECTED_POOL );
    }

    CmHive->SecurityCache = NULL;
    CmHive->SecurityCacheSize = CmHive->SecurityCount = 0;
}

PCM_KEY_SECURITY_CACHE
CmpFindReusableCellFromCache(IN PCMHIVE     CmHive,
                             IN HCELL_INDEX SecurityCell,
                             IN ULONG       PreviousCount)
/*++

Routine Description:

    Attempts to find the smallest cell which can accommodate the current security cell.
    Then moves it at the end and return a pointer to it. Shifts the array towards the end 
	as we are going to extend the cache

    Security doesn't change too often, so chances are that we will be able to reuse the cells 90% 
    of the time.

    If one cannot be found, the last cell in the array is freed. A new one will be allocated inside
    CmpAddSecurityCellToCache

Arguments:

    CmHive - the hive to which the security cell belongs

    SecurityCell - the security cell 

    PreviousCount - the end of the array

Return Value:

    the cached cell or NULL
--*/
{
    ULONG                   Size;
    PCM_KEY_SECURITY        Security;
    PCM_KEY_SECURITY_CACHE  SecurityCached;
    ULONG                   i;
    ULONG                   SmallestSize = 0;
    ULONG                   SmallestIndex = 0;

    PAGED_CODE();

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

    //
    // try first to get the security cell from the hive; if this fails, there is no point to go on 
    //
    Security = (PCM_KEY_SECURITY)HvGetCell(&(CmHive->Hive),SecurityCell);
    if( Security == NULL ){
        //
        // we failed to map the view containing this cell; bail out
        //
        goto ErrorExit;
    }

    //
    // compute the size for the cached security structure
    //
    Size = Security->DescriptorLength;
    HvReleaseCell(&(CmHive->Hive),SecurityCell);

    //
    // Now that we know the desired size, start iterating the array to find a suitable entry.
    //
    for(i = CmHive->SecurityCount; i < PreviousCount; i++) {
       SecurityCached =  CmHive->SecurityCache[i].CachedSecurity;
       if( SecurityCached->DescriptorLength == Size ) {
Found:
            //
            // we have found one matching the exact size; move it at the end 
			// shift to the end one entry as we are going to extend the cache
			//
			// this factored down translates to:
            //
			RtlMoveMemory( ((PUCHAR)CmHive->SecurityCache) + (CmHive->SecurityCount+1)*sizeof(CM_KEY_SECURITY_CACHE_ENTRY),     // destination
						   ((PUCHAR)CmHive->SecurityCache) + CmHive->SecurityCount*sizeof(CM_KEY_SECURITY_CACHE_ENTRY),         // source
						   (i - CmHive->SecurityCount)*sizeof(CM_KEY_SECURITY_CACHE_ENTRY)							// size
							);

            return SecurityCached;
       }

       //
       // if not; record the smallest suitable entry
       //
       if( SecurityCached->DescriptorLength > Size ) {
           if( (SmallestSize == 0) ||
               (SmallestSize > SecurityCached->DescriptorLength)
               ) {
               //
               // first one or this one is smaller
               //
               SmallestSize = SecurityCached->DescriptorLength;
               SmallestIndex = i;
           } 
       }
    }

    if( SmallestSize != 0 ) {
        SecurityCached = CmHive->SecurityCache[SmallestIndex].CachedSecurity;
        ASSERT( SecurityCached->DescriptorLength == SmallestSize );
        ASSERT( Size < SmallestSize );
        i = SmallestIndex;
        goto Found;
    }

ErrorExit:
    ExFreePoolWithTag(CmHive->SecurityCache[PreviousCount - 1].CachedSecurity, CM_SECCACHE_TAG|PROTECTED_POOL );
	//
	// shift to the end one entry as we are going to extend the cache
	//
	RtlMoveMemory( ((PUCHAR)CmHive->SecurityCache) + (CmHive->SecurityCount+1)*sizeof(CM_KEY_SECURITY_CACHE_ENTRY),     // destination
				   ((PUCHAR)CmHive->SecurityCache) + CmHive->SecurityCount*sizeof(CM_KEY_SECURITY_CACHE_ENTRY),         // source
				   (PreviousCount - CmHive->SecurityCount - 1)*sizeof(CM_KEY_SECURITY_CACHE_ENTRY)							// size
					);
    return NULL;
}

BOOLEAN
CmpRebuildSecurityCache(
                        IN OUT PCMHIVE      CmHive
                        )
/*++

Routine Description:

    Rebuilds the security cache by reiterating all security cells
    and adding them to the cache; this routine is intended for hive
    refresh operations

Arguments:

    CmHive - the hive to which the security cell belongs

Return Value:

    TRUE or FALSE
--*/
{
    PCM_KEY_NODE            RootNode;
    PCM_KEY_SECURITY        SecurityCell;
    HCELL_INDEX             ListAnchor;
    HCELL_INDEX             NextCell;
    HCELL_INDEX             LastCell = 0;
    PHHIVE                  Hive;
    PRELEASE_CELL_ROUTINE   ReleaseCellRoutine;
    BOOLEAN                 Result = TRUE;
    ULONG                   PreviousCount;
    PCM_KEY_SECURITY_CACHE  SecCache;

    PAGED_CODE();

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
    //
    // avoid extra work
    //
    Hive = &(CmHive->Hive);
    ReleaseCellRoutine = Hive->ReleaseCellRoutine;
    Hive->ReleaseCellRoutine = NULL;

    //
    // be smart and reuse the cache; For each cell, we'll iterate through the cache
    // find an entry big enough to accommodate the current cell, move it at the end 
    // and then reuse it. 
    //
    // first, reinitialize the hash table.
    //
    for( PreviousCount=0;PreviousCount<CmpSecHashTableSize;PreviousCount++) {
        InitializeListHead(&(CmHive->SecurityHash[PreviousCount]));
    }

    //
    // this we use to keep track of how many valid cells were in the cache previously
    //
    PreviousCount = CmHive->SecurityCount;
    //
    // start building an pseudo-empty one.
    //
    CmHive->SecurityCount = 0;

    if (!HvIsCellAllocated(Hive,Hive->BaseBlock->RootCell)) {
        //
        // root cell HCELL_INDEX is bogus
        //
        Result = FALSE;
        goto JustReturn;
    }
    RootNode = (PCM_KEY_NODE) HvGetCell(Hive, Hive->BaseBlock->RootCell);
    if( RootNode == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //
        Result = FALSE;
        goto JustReturn;
    }
    ListAnchor = NextCell = RootNode->Security;

    do {
        if (!HvIsCellAllocated(Hive, NextCell)) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CM: CmpRebuildSecurityCache\n"));
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"    NextCell: %08lx is invalid HCELL_INDEX\n",NextCell));
            Result = FALSE;
            goto JustReturn;
        }
        SecurityCell = (PCM_KEY_SECURITY) HvGetCell(Hive, NextCell);
        if( SecurityCell == NULL ) {
            //
            // we couldn't map a view for the bin containing this cell
            //
            Result = FALSE;
            goto JustReturn;
        }
        if (NextCell != ListAnchor) {
            //
            // Check to make sure that our Blink points to where we just
            // came from.
            //
            if (SecurityCell->Blink != LastCell) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"  Invalid Blink (%ld) on security cell %ld\n",SecurityCell->Blink, NextCell));
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"  should point to %ld\n", LastCell));
                Result = FALSE;
                goto JustReturn;
            }
        }
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SEC,"CmpValidSD:  SD shared by %d nodes\n",SecurityCell->ReferenceCount));
        if (!SeValidSecurityDescriptor(SecurityCell->DescriptorLength, &SecurityCell->Descriptor)) {
#if DBG
            CmpDumpSecurityDescriptor(&SecurityCell->Descriptor,"INVALID DESCRIPTOR");
#endif
            Result = FALSE;
            goto JustReturn;
        }

        SecCache = CmpFindReusableCellFromCache(CmHive,NextCell,PreviousCount);

        if( !NT_SUCCESS(CmpAddSecurityCellToCache ( CmHive,NextCell,TRUE,SecCache) ) ) {
            Result = FALSE;
            goto JustReturn;
        }

        LastCell = NextCell;
        NextCell = SecurityCell->Flink;
    } while ( NextCell != ListAnchor );


JustReturn:
    Hive->ReleaseCellRoutine = ReleaseCellRoutine;
    return Result;
}

BOOLEAN
CmpFindMatchingDescriptorCell(
    IN PCMHIVE CmHive,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG Type,
    OUT PHCELL_INDEX MatchingCell,
    OUT OPTIONAL PCM_KEY_SECURITY_CACHE *CachedSecurityPointer
    )

/*++

Routine Description:

    This routine attempts to find a security descriptor in the hive that
    is identical to the one passed in.  If it finds one, it returns its
    cell index.

    Obsolete:
    Currently, this routine checks the security descriptors of the parent
    and siblings of the node to find a match.

    New:
    It looks for the sd in the security cache for this hive. This will 
    eliminate duplicates and make the search process faster.

Arguments:

    CmHive - Supplies a pointer to the hive control structure for the node.
            Needed to get access to the cache

    SecurityDescriptor - Supplies the cooked security descriptor which
           should be searched for.

    Type - Indicates whether the Security Descriptor that matches must
            be in Stable or Volatile store

    MatchingCell - Returns the cell index of a security cell whose
           security descriptor is identical to SecurityDescriptor.
           Valid only if TRUE is returned.

    CachedSecurityPointer - pointer to the cached security (for update reasons)

Return Value:

    TRUE - Matching security descriptor found.  MatchingCell returns the
           cell index of the matching security descriptor.

    FALSE - No matching security descriptor found.  MatchingCell is invalid.

--*/

{
    ULONG                   DescriptorLength;
    ULONG                   ConvKey;
    PLIST_ENTRY             ListAnchor;
    PLIST_ENTRY             Current;
    PCM_KEY_SECURITY_CACHE  CachedSecurity;

    PAGED_CODE();
	
    DescriptorLength = RtlLengthSecurityDescriptor(SecurityDescriptor);

    //
    // calculate the conv key
    //
    ConvKey = CmpSecConvKey(DescriptorLength,(PULONG)SecurityDescriptor);

    ListAnchor = &(CmHive->SecurityHash[ConvKey % CmpSecHashTableSize]);
    if( IsListEmpty(ListAnchor) == TRUE ) {
        return FALSE;
    }

    //
    // iterate through the list of colisions for this convkey
    // start with teh first element in list
    //
    Current = (PLIST_ENTRY)(ListAnchor->Flink);
    while( Current != ListAnchor ){
        //
        // get the current cached security 
        //
        CachedSecurity = CONTAINING_RECORD(Current,
                                           CM_KEY_SECURITY_CACHE,
                                           List);

        //
        // see if it matches with the given descriptor; 
        //
        if( (CachedSecurity->ConvKey == ConvKey) &&                             // same convkey
            (Type == HvGetCellType(CachedSecurity->Cell)) &&                    // same cell type
            (DescriptorLength == CachedSecurity->DescriptorLength) &&  // same length
            (RtlEqualMemory(SecurityDescriptor,                                 // and, finally, bit-wise identical
                            &(CachedSecurity->Descriptor),
                            DescriptorLength))
            ) {
            //
            // we have found a match
            //
            *MatchingCell = CachedSecurity->Cell;
            if (ARGUMENT_PRESENT(CachedSecurityPointer)) {
                *CachedSecurityPointer = CachedSecurity;
            }
            return TRUE;
        }

        //
        // advance to the next element
        //
        Current = (PLIST_ENTRY)(Current->Flink);
    } 

    // sorry, no match
    return FALSE;
}

VOID
CmpAssignSecurityToKcb(
    IN PCM_KEY_CONTROL_BLOCK    Kcb,
    IN HCELL_INDEX              SecurityCell,
    IN BOOLEAN                  SecurityLocked
    )
/*++

Routine Description:

    Establishes the connection between the KCB and the cached security
    descriptor.

    As most of the time this is called after the security cell has been 
    linked to the Key Node, and because the binary search starts with 
    the last cell looked up, we will not hit a performance impact here.

Arguments:

    Kcb - the KCb to which this security cell needs to be attached

    SecurityCell - Security cell for the kcb


Return Value:

    NONE; bugchecks on error

--*/
{
    ULONG   Index;
    PCMHIVE CmHive;

    PAGED_CODE();

    if( SecurityCell == HCELL_NIL ) {
        Kcb->CachedSecurity = NULL;
        return;
    }

    CmHive = (PCMHIVE)(Kcb->KeyHive);

    if( !SecurityLocked ) {
        CmLockHiveSecurityShared(CmHive);
    }
    //
    // get the security descriptor from cache
    //
    if( CmpFindSecurityCellCacheIndex (CmHive,SecurityCell,&Index) == FALSE ) {
        Kcb->CachedSecurity = NULL;
        //
        //  we are doomed !!!
        //
        CM_BUGCHECK( REGISTRY_ERROR,BAD_SECURITY_CACHE,1,Kcb,SecurityCell);

    } 

    //
    // success; link the cached security to this KCB
    //
    Kcb->CachedSecurity = CmHive->SecurityCache[Index].CachedSecurity;
    if( !SecurityLocked ) {
        CmUnlockHiveSecurity(CmHive);
    }
}

BOOLEAN
CmpBuildSecurityCellMappingArray(
    IN PCMHIVE CmHive
    )
/*++

Routine Description:

    Iterates through the security cache for the specified hive and 
	build the array of mappings.

Arguments:

    CmHive - the hive in question

Return Value:

    TRUE/FALSE
--*/
{
    ULONG                   i;
    PAGED_CODE();

	ASSERT( CmHive->CellRemapArray == NULL );
	CmHive->CellRemapArray = ExAllocatePool(PagedPool,sizeof(CM_CELL_REMAP_BLOCK)*CmHive->SecurityCount);

	if( CmHive->CellRemapArray == NULL ) {
		return FALSE;
	}

#pragma prefast(suppress:12009, "silence prefast")
    for( i=0;i<CmHive->SecurityCount;i++) {
		CmHive->CellRemapArray[i].OldCell = CmHive->SecurityCache[i].Cell;
		if( HvGetCellType(CmHive->SecurityCache[i].Cell) == (ULONG)Volatile ) {
			//
			// we preserve volatile cells
			//
			CmHive->CellRemapArray[i].NewCell = CmHive->SecurityCache[i].Cell;
		} else {
			CmHive->CellRemapArray[i].NewCell = HCELL_NIL;
		}
    }

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmsubs.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmsubs.c

Abstract:

    This module various support routines for the configuration manager.

    The routines in this module are not independent enough to be linked
    into any other program.  The routines in cmsubs2.c are.

--*/

#include    "cmp.h"

EX_PUSH_LOCK CmpPostLock;

PCM_KEY_HASH_TABLE_ENTRY CmpCacheTable;
PCM_NAME_HASH_TABLE_ENTRY CmpNameCacheTable;
ULONG CmpHashTableSize = 2048;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif

extern ULONG CmpDelayedCloseSize; 
extern BOOLEAN CmpHoldLazyFlush;

VOID
CmpRemoveKeyHash(
    IN PCM_KEY_HASH KeyHash
    );

PCM_KEY_CONTROL_BLOCK
CmpInsertKeyHash(
    IN PCM_KEY_HASH KeyHash,
    IN BOOLEAN      FakeKey
    );

//
// private prototype for recursive worker
//


VOID
CmpDereferenceNameControlBlockWithLock(
    PCM_NAME_CONTROL_BLOCK   Ncb
    );

VOID
CmpDumpOneKeyBody(
    IN PCM_KEY_CONTROL_BLOCK    kcb,
    IN PCM_KEY_BODY             KeyBody,
    IN PUNICODE_STRING          Name,
    IN PVOID                    Context
    );

VOID
CmpDumpKeyBodyList(
    IN PCM_KEY_CONTROL_BLOCK   kcb,
    IN PULONG                  Count,
    IN PVOID                   Context 
    );

BOOLEAN
CmpRehashKcbSubtree(
                    PCM_KEY_CONTROL_BLOCK   Start,
                    PCM_KEY_CONTROL_BLOCK   End
                    );

VOID
CmpRebuildKcbCache(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpCleanUpKCBCacheTable)
#pragma alloc_text(PAGE,CmpSearchForOpenSubKeys)
#pragma alloc_text(PAGE,CmpReferenceKeyControlBlock)
#pragma alloc_text(PAGE,CmpGetNameControlBlock)
#pragma alloc_text(PAGE,CmpDereferenceNameControlBlockWithLock)
#pragma alloc_text(PAGE,CmpCleanUpSubKeyInfo)
#pragma alloc_text(PAGE,CmpCleanUpKcbValueCache)
#pragma alloc_text(PAGE,CmpCleanUpKcbCacheWithLock)
#pragma alloc_text(PAGE,CmpConstructName)
#pragma alloc_text(PAGE,CmpCreateKeyControlBlock)
#pragma alloc_text(PAGE,CmpSearchKeyControlBlockTree)
#pragma alloc_text(PAGE,CmpDereferenceKeyControlBlock)
#pragma alloc_text(PAGE,CmpDereferenceKeyControlBlockWithLock)
#pragma alloc_text(PAGE,CmpRemoveKeyControlBlock)
#pragma alloc_text(PAGE,CmpFreeKeyBody)
#pragma alloc_text(PAGE,CmpInsertKeyHash)
#pragma alloc_text(PAGE,CmpRemoveKeyHash)
#pragma alloc_text(PAGE,CmpInitializeCache)
#pragma alloc_text(PAGE,CmpDumpKeyBodyList)
#pragma alloc_text(PAGE,CmpFlushNotifiesOnKeyBodyList)
#pragma alloc_text(PAGE,CmpRebuildKcbCache)
#pragma alloc_text(PAGE,CmpComputeKcbConvKey)
#pragma alloc_text(PAGE,CmpRehashKcbSubtree)
#pragma alloc_text(PAGE,InitializeKCBKeyBodyList)
#pragma alloc_text(PAGE,EnlistKeyBodyWithKCB)
#pragma alloc_text(PAGE,DelistKeyBodyFromKCB)

#pragma alloc_text(PAGE,CmpDumpOneKeyBody)
#endif

#define CMP_FAST_KEY_BODY_ARRAY_DUMP    1
#define CMP_FAST_KEY_BODY_ARRAY_FLUSH   2

VOID
CmpDumpOneKeyBody(
    IN PCM_KEY_CONTROL_BLOCK    kcb,
    IN PCM_KEY_BODY             KeyBody,
    IN PUNICODE_STRING          Name,
    IN PVOID                    Context
    )
{
    //
    // sanity check: this should be a KEY_BODY
    //
    ASSERT_KEY_OBJECT(KeyBody);
    
    if( !Context ) {
        //
        // NtQueryOpenSubKeys : dump it's name and owning process
        //
        {
            PEPROCESS   Process;
            PUCHAR      ImageName = NULL;


            if( NT_SUCCESS(PsLookupProcessByProcessId(KeyBody->ProcessID,&Process))) {
                ImageName = PsGetProcessImageFileName(Process);
            } else {
                Process = NULL;
            }

            if( !ImageName ) {
                ImageName = (PUCHAR)"Unknown";
            }
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Process %p (PID = %lx ImageFileName = %s) (KCB = %p) :: Key %wZ \n",
                                    Process,KeyBody->ProcessID,ImageName,kcb,Name);
            if( Process ) {
                ObDereferenceObject (Process);
            }
        }
    } else {
        //
        // NtQueryOpenSubKeysEx: build up the return buffer; make sure we only touch it
        // inside a try except as it's user-mode buffer
        //
        PQUERY_OPEN_SUBKEYS_CONTEXT     QueryContext = (PQUERY_OPEN_SUBKEYS_CONTEXT)Context;
        PKEY_OPEN_SUBKEYS_INFORMATION   SubkeysInfo = (PKEY_OPEN_SUBKEYS_INFORMATION)(QueryContext->Buffer);
        ULONG                           SizeNeeded;
        
		//
		// we need to ignore the one created by us inside NtQueryOpenSubKeysEx
		//
		if( QueryContext->KeyBodyToIgnore != KeyBody ) {
			//
			// update RequiredSize; we do this regardless if we have room or not in the buffer
			// reserve for one entry in the array and the unicode name buffer
			//
			SizeNeeded = (sizeof(KEY_PID_ARRAY) + (ULONG)(Name->Length));
			QueryContext->RequiredSize += SizeNeeded;
        
			//
			// if we have encountered an error (overflow, or else) at some previous iteration, no point going on
			//
			if( NT_SUCCESS(QueryContext->StatusCode) ) {
				//
				// see if we have enough room for current entry.
				//
				if( (QueryContext->UsedLength + SizeNeeded) > QueryContext->BufferLength ) {
					//
					// buffer not big enough; 
					//
					QueryContext->StatusCode = STATUS_BUFFER_OVERFLOW;
				} else {
					//
					// we have established we have enough room; create/add a new entry to the key array
					// and build up unicode name buffer. copy key name to it.
					// array elements are at the beginning of the user buffer, while name buffers start at 
					// the end and continue backwards, as long as there is enough room.
					//
					try {
						//
						// protect user mode memory
						//
						SubkeysInfo->KeyArray[SubkeysInfo->Count].PID = KeyBody->ProcessID;
						SubkeysInfo->KeyArray[SubkeysInfo->Count].KeyName.Length = Name->Length;
						SubkeysInfo->KeyArray[SubkeysInfo->Count].KeyName.MaximumLength = Name->Length; 
						SubkeysInfo->KeyArray[SubkeysInfo->Count].KeyName.Buffer = (PWSTR)((PUCHAR)QueryContext->CurrentNameBuffer - Name->Length);
						RtlCopyMemory(  SubkeysInfo->KeyArray[SubkeysInfo->Count].KeyName.Buffer,
										Name->Buffer,
										Name->Length);
						//
						// update array count and work vars inside the querycontext
						//
						SubkeysInfo->Count++;
						QueryContext->CurrentNameBuffer = (PUCHAR)QueryContext->CurrentNameBuffer - Name->Length;
						QueryContext->UsedLength += SizeNeeded;
					} except (EXCEPTION_EXECUTE_HANDLER) {
						QueryContext->StatusCode = GetExceptionCode();
					}
				}
			}
		}

    }
}


VOID
CmpDumpKeyBodyList(
    IN PCM_KEY_CONTROL_BLOCK    kcb,
    IN PULONG                   Count,
    IN PVOID                    Context
    )
{
        
    PCM_KEY_BODY    KeyBody;
    PUNICODE_STRING Name;
    ULONG           i;
    BOOLEAN         KeyBodyArrayEmpty = TRUE;

    ASSERT_KCB_LOCKED_EXCLUSIVE(kcb);

    if( kcb->RefCount == 0 ) {
        //
        // this kcb is in the delay close, ignore it.
        //
        ASSERT( kcb->DelayedCloseIndex != CmpDelayedCloseSize );
        return;
    }

    for(i=0;i<CMP_LOCK_FREE_KEY_BODY_ARRAY_SIZE;i++) {
        if( kcb->KeyBodyArray[i] != NULL ) {
            KeyBodyArrayEmpty = FALSE;
            break;
        }
    }

    if( (IsListEmpty(&(kcb->KeyBodyListHead)) == TRUE) && (KeyBodyArrayEmpty == TRUE) ) {
        //
        // Nobody has this subkey open, but for sure some subkey must be 
        // open. nicely return.
        //
        return;
    }


    Name = CmpConstructName(kcb);
    if( !Name ){
        // we're low on resources
        if( Context != NULL ) {
            ((PQUERY_OPEN_SUBKEYS_CONTEXT)Context)->StatusCode = STATUS_INSUFFICIENT_RESOURCES;
        }
        return;
    }
    
    //
    // now iterate through the list of KEY_BODYs referencing this kcb
    //
    KeyBody = (PCM_KEY_BODY)kcb->KeyBodyListHead.Flink;
    while( KeyBody != (PCM_KEY_BODY)(&(kcb->KeyBodyListHead)) ) {
        KeyBody = CONTAINING_RECORD(KeyBody,
                                    CM_KEY_BODY,
                                    KeyBodyList);
        // dump it.
        CmpDumpOneKeyBody(kcb,KeyBody,Name,Context);

        // count it
        (*Count)++;
        
        KeyBody = (PCM_KEY_BODY)KeyBody->KeyBodyList.Flink;
    }

    //
    // now dump the ones that are on the fast array
    //
    for(i=0;i<CMP_LOCK_FREE_KEY_BODY_ARRAY_SIZE;i++) {
        KeyBody = kcb->KeyBodyArray[i];
        if( (KeyBody != NULL) && 
            ((ULONG_PTR)KeyBody != CMP_FAST_KEY_BODY_ARRAY_DUMP)  &&
            ((ULONG_PTR)KeyBody != CMP_FAST_KEY_BODY_ARRAY_FLUSH) ) {
            //
            // avoid races
            //
            if( InterlockedCompareExchangePointer(&(kcb->KeyBodyArray[i]),
                                                (PVOID)CMP_FAST_KEY_BODY_ARRAY_DUMP,
                                                KeyBody) == KeyBody ) {
                // dump it.
                CmpDumpOneKeyBody(kcb,KeyBody,Name,Context);

                // count it
                (*Count)++;
                //
                // set it back
                //
                InterlockedCompareExchangePointer(&(kcb->KeyBodyArray[i]),
                                                KeyBody,
                                                (PVOID)CMP_FAST_KEY_BODY_ARRAY_DUMP);
            }
        }
    }

    ExFreePoolWithTag(Name, CM_NAME_TAG | PROTECTED_POOL);

}

VOID
CmpFlushNotifiesOnKeyBodyList(
    IN PCM_KEY_CONTROL_BLOCK    kcb,
    IN BOOLEAN                  LockHeld
    )
/*++
Routine Description:
    
      Flushes notifications on all key_bodies linked to this kcb
      and sets the key object flag.

Arguments:


Return Value:

--*/
{
    PCM_KEY_BODY    KeyBody;
    ULONG           i;
    
#if DBG
    if( LockHeld ) {
        ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
    } else {
        ASSERT_KCB_LOCKED_EXCLUSIVE(kcb);
    }
#endif

Again:
    if( IsListEmpty(&(kcb->KeyBodyListHead)) == FALSE ) {
        //
        // now iterate through the list of KEY_BODYs referencing this kcb
        //
        KeyBody = (PCM_KEY_BODY)kcb->KeyBodyListHead.Flink;
        while( KeyBody != (PCM_KEY_BODY)(&(kcb->KeyBodyListHead)) ) {
            KeyBody = CONTAINING_RECORD(KeyBody,
                                        CM_KEY_BODY,
                                        KeyBodyList);
            //
            // sanity check: this should be a KEY_BODY
            //
            ASSERT_KEY_OBJECT(KeyBody);

            //
            // flush any notifies that might be set on it
            //
            if( KeyBody->NotifyBlock ) {
                //
                // if we hold exclusive registry lock, we are safe; defer delete can't race with us
                // otherwise add an extra reference on the key body so it won't go away.
                //
                if( LockHeld ) {
                    CmpFlushNotify(KeyBody,LockHeld);
                    ASSERT( KeyBody->NotifyBlock == NULL );
                    goto Again;
                } else if(ObReferenceObjectSafe(KeyBody)) {
                    CmpFlushNotify(KeyBody,LockHeld);
                    ASSERT( KeyBody->NotifyBlock == NULL );
				    ObDereferenceObjectDeferDelete(KeyBody);
                    goto Again;
                }
            }
            KeyBody = (PCM_KEY_BODY)KeyBody->KeyBodyList.Flink;
        }
    }
    //
    // same thing for fast array
    //
    for(i=0;i<CMP_LOCK_FREE_KEY_BODY_ARRAY_SIZE;i++) {
        KeyBody = kcb->KeyBodyArray[i];
        if( (KeyBody != NULL) && 
            ((ULONG_PTR)KeyBody != CMP_FAST_KEY_BODY_ARRAY_DUMP)  &&
            ((ULONG_PTR)KeyBody != CMP_FAST_KEY_BODY_ARRAY_FLUSH) ) {
            //
            // avoid races
            //
            if( InterlockedCompareExchangePointer(&(kcb->KeyBodyArray[i]),
                                                (PVOID)CMP_FAST_KEY_BODY_ARRAY_FLUSH,
                                                KeyBody) == KeyBody ) {
                //
                // sanity check: this should be a KEY_BODY
                //
                ASSERT_KEY_OBJECT(KeyBody);

                //
                // flush any notifies that might be set on it
                //
                if( KeyBody->NotifyBlock ) {
                    //
                    // if we hold exclusive registry lock, we are safe; defer delete can't race with us
                    // otherwise add an extra reference on the key body so it won't go away.
                    //
                    if( LockHeld ) {
                        CmpFlushNotify(KeyBody,LockHeld);
                        ASSERT( KeyBody->NotifyBlock == NULL );
                    } else if(ObReferenceObjectSafe(KeyBody)) {
                        CmpFlushNotify(KeyBody,LockHeld);
                        ASSERT( KeyBody->NotifyBlock == NULL );
				        ObDereferenceObjectDeferDelete(KeyBody);
                    }
                }
                //
                // now set it back only if nobody else messed with it in between
                //
                InterlockedCompareExchangePointer(&(kcb->KeyBodyArray[i]),
                                                    KeyBody,
                                                    (PVOID)CMP_FAST_KEY_BODY_ARRAY_FLUSH);    
            }
        }
    }

}

VOID CmpCleanUpKCBCacheTable(PCM_KEY_CONTROL_BLOCK      KeyControlBlock,
                             BOOLEAN                    RegLockHeldEx)
/*++
Routine Description:

	Kicks out of cache all kcbs with RefCount == 0

Arguments:
    
    KeyControlBlock - when present, it's already locked EX.

Return Value:

--*/
{
    ULONG					i;
    PCM_KEY_HASH			*Current;
    PCM_KEY_CONTROL_BLOCK	kcb;
    ULONG                   ThisKcbHashIndex = CmpHashTableSize;
    ULONG                   ParentKcbHashIndex = CmpHashTableSize;
    BOOLEAN                 CacheChanged;

	CM_PAGED_CODE();

    ASSERT( (KeyControlBlock && CmpIsKCBLockedExclusive(KeyControlBlock) &&
            ((KeyControlBlock->ParentKcb == NULL) || (CmpIsKCBLockedExclusive(KeyControlBlock->ParentKcb))) 
            )
            || (CmpTestRegistryLockExclusive() == TRUE) );

    //
    // make sure all delayed dereferences are serviced first
    //
    CmpRunDownDelayDerefKCBEngine(KeyControlBlock,RegLockHeldEx);

    if(KeyControlBlock!= NULL) {
        ThisKcbHashIndex = GET_HASH_INDEX(KeyControlBlock->ConvKey);
        if( KeyControlBlock->ParentKcb != NULL ) {
            ParentKcbHashIndex = GET_HASH_INDEX(KeyControlBlock->ParentKcb->ConvKey);
        }
    }
TryAgain:
    CacheChanged = FALSE;
    for (i=0; i<CmpHashTableSize; i++) {
        if( (KeyControlBlock == NULL) || ((ThisKcbHashIndex != i) && (ParentKcbHashIndex != i)) ) {
            //
            // deadlock avoidance
            //
            if( CmpKCBLockForceAcquireAllowed(ParentKcbHashIndex,ThisKcbHashIndex,i) ) {
                CmpLockHashEntryByIndexExclusive(i);
            } else if( CmpTryToLockHashEntryByIndexExclusive(i) == FALSE ) {
                //
                // couldn't get EX access to this entry; we need to skip it
                //
                continue;
            }
        }
        Current = &(CmpCacheTable[i].Entry);
        while (*Current) {
            kcb = CONTAINING_RECORD(*Current, CM_KEY_CONTROL_BLOCK, KeyHash);
            if( (kcb->RefCount == 0) &&
                ((KeyControlBlock == NULL) || (KeyControlBlock->KeyHive == kcb->KeyHive)) ) { // only interested in kcbs below this hive's root

                //
                // This kcb is in DelayClose case, remove it.
                //
                CmpRemoveFromDelayedClose(kcb);
                CmpCleanUpKcbCacheWithLock(kcb,RegLockHeldEx);
                CacheChanged = TRUE;
                //
                // The HashTable is changed, start over in this index again.
                //
                Current = &(CmpCacheTable[i].Entry);
                continue;
            }
            Current = &(kcb->NextHash);
        }
        if( (KeyControlBlock == NULL) || ((ThisKcbHashIndex != i) && (ParentKcbHashIndex != i)) ) {
            CmpUnlockHashEntryByIndex(i);
        }
        if( CacheChanged ) {
            goto TryAgain;
        }
    }

}

PERFINFO_REG_DUMP_CACHE()

ULONG
CmpSearchForOpenSubKeys(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock,
    SUBKEY_SEARCH_TYPE      SearchType,
    BOOLEAN                 RegLockHeldEx,
    PVOID                   SearchContext
    )
/*++
Routine Description:

    This routine searches the KCB tree for any open handles to keys that
    are subkeys of the given key.

    It is used by CmRestoreKey to verify that the tree being restored to
    has no open handles.

Arguments:

    KeyControlBlock - Supplies the key control block for the key for which
        open subkeys are to be found.

    SearchType - the type of the search
        SearchIfExist - exits at the first open subkey found ==> returns 1 if any subkey is open
        
        SearchAndDeref - Forces the keys underneath the Key referenced KeyControlBlock to 
                be marked as not referenced (see the REG_FORCE_RESTORE flag in CmRestoreKey);
                return value indicates number of keys that could NOT be dereferenced, and thus are
                still open.
        
        SearchAndCount - Counts all open subkeys - returns the number of them

        SearchAndTagNoDelayClose - Flag the subkey so as not to place it in the delayed closed
                table.

        SearchAndRehash (NT_RENAME_KEY) - Rehash subkeys in KCB hash table, if needed.

Return Value:

    Returns the number of open sub keys.
    
--*/
{
    ULONG                   i;
    PCM_KEY_HASH            Current;
    PCM_KEY_CONTROL_BLOCK   kcb;
    PCM_KEY_CONTROL_BLOCK   Parent;
    ULONG                   LevelDiff, l;
    ULONG                   Count = 0;
    ULONG                   ThisKcbHashIndex = CmpHashTableSize;
    ULONG                   ParentKcbHashIndex = CmpHashTableSize;
    
    //
    // Registry lock should be held exclusively, so no need to KCB lock
    //
    ASSERT( ( CmpIsKCBLockedExclusive(KeyControlBlock) && 
             ((KeyControlBlock->ParentKcb == NULL) || CmpIsKCBLockedExclusive(KeyControlBlock->ParentKcb))
             ) ||
             (CmpTestRegistryLockExclusive() == TRUE) );

    //
    // First, clean up all subkeys in the cache
    //
    CmpCleanUpKCBCacheTable(((SearchType == SearchIfExist) || (SearchType == SearchAndCount))?KeyControlBlock:NULL,RegLockHeldEx);

    if( (KeyControlBlock->RefCount == 1) && (SearchType != SearchAndRehash) ) {
        //
        // There is only one open handle, so there must be no open subkeys.
        //
        Count = 0;
    } else {
        //
        // Now search for an open subkey handle.
        //
        Count = 0;

        //
        // dump the root first if we were asked to do so.
        //
        if(SearchType == SearchAndCount) {
            CmpDumpKeyBodyList(KeyControlBlock,&Count,SearchContext);
        }
        ThisKcbHashIndex = GET_HASH_INDEX(KeyControlBlock->ConvKey);
        if( KeyControlBlock->ParentKcb != NULL ) {
            ParentKcbHashIndex = GET_HASH_INDEX(KeyControlBlock->ParentKcb->ConvKey);
        }

        for (i=0; i<CmpHashTableSize; i++) {

            if( (ThisKcbHashIndex != i) && (ParentKcbHashIndex != i) ) {
                //
                // we can wait for the bucket lock in case we are going upwards of what we already own
                //
                if( CmpKCBLockForceAcquireAllowed(ParentKcbHashIndex,ThisKcbHashIndex,i) ) {
                    CmpLockHashEntryByIndexExclusive(i);
                } else {
                    //
                    // deadlock avoidance; bail out with error if we can't get EX access here
                    //
                    if( CmpTryToLockHashEntryByIndexExclusive(i) == FALSE ) {
                        ASSERT(CmpTestRegistryLockExclusive() == FALSE);
                        ASSERT( (SearchType == SearchIfExist) || (SearchType == SearchAndCount) );
                        if( SearchType == SearchIfExist ) {
                            //
                            // assume one already exist
                            //
                            return 1;
                        } 
                        //
                        // else skip this entry;
                        //
                        continue;
                    }
                }
            }

StartDeref:

            Current = CmpCacheTable[i].Entry;
            while (Current) {
                kcb = CONTAINING_RECORD(Current, CM_KEY_CONTROL_BLOCK, KeyHash);
                if (kcb->TotalLevels > KeyControlBlock->TotalLevels) {
                    LevelDiff = kcb->TotalLevels - KeyControlBlock->TotalLevels;
                
                    Parent = kcb;
                    for (l=0; l<LevelDiff; l++) {
                        Parent = Parent->ParentKcb;
                    }
    
                    if (Parent == KeyControlBlock) {
                        //
                        // Found a match;
                        //
                        if( SearchType == SearchIfExist ) {
                            Count = 1;
                            if( (ThisKcbHashIndex != i) && (ParentKcbHashIndex != i) ) {
                                CmpUnlockHashEntryByIndex(i);
                            }
                            return Count;
                        } else if(SearchType == SearchAndTagNoDelayClose) {
				            kcb->ExtFlags |= CM_KCB_NO_DELAY_CLOSE;
                        } else if(SearchType == SearchAndDeref) {
                            //
                            // Mark the key as deleted, remove it from cache, but don't add it
                            // to the Delay Close table (we want the key to be visible only to
                            // the one(s) that have open handles on it.
                            //

                            ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

                            //
                            // don't mess with read only kcbs; this prevents a potential hack when 
                            // trying to FORCE_RESTORE over WPA keys.
                            //
                            if( !CmIsKcbReadOnly(kcb) ) {
                                //
                                // flush any pending notifies as the kcb won't be around any longer
                                //
                                CmpFlushNotifiesOnKeyBodyList(kcb,TRUE);
                            
                                CmpCleanUpSubKeyInfo(kcb->ParentKcb);
                                kcb->Delete = TRUE;
                                // Cache the pointer to the next hash block before unlinking the
                                // current one.
                                Current = kcb->NextHash;
                                CmpRemoveKeyControlBlock(kcb);
                                kcb->KeyCell = HCELL_NIL;
                                //
                                // Continue the search.
                                // 
                                continue;
                            } else {
                                // We cannot close the key. Record it as still open.
                                ++Count;
                            }
                        } else if(SearchType == SearchAndCount) {
                            //
                            // here do the dumping and count incrementing stuff
                            //
                            CmpDumpKeyBodyList(kcb,&Count,SearchContext);

                        } else if( SearchType == SearchAndRehash ) {
                            //
                            // every kcb which has the one passed as a parameter
                            // as an ancestor needs to be moved to the right location 
                            // in the kcb hash table.
                            //
                            ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

                            if( CmpRehashKcbSubtree(KeyControlBlock,kcb) == TRUE ) {
                                //
                                // at least one kcb has been moved, we need to reiterate this bucket
                                //
                                Count++;
                                goto StartDeref;
                            }
                        }
                    }   

                }
                Current = kcb->NextHash;
            }
            if( (ThisKcbHashIndex != i) && (ParentKcbHashIndex != i) ) {
                CmpUnlockHashEntryByIndex(i);
            }
        }
    }
    
                           
    return Count;
}

ULONG
CmpComputeKcbConvKey(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock
    )
/*++
Routine Description:

    Computes the convkey for this kcb based on the NCB and its parent ConvKey

Arguments:

    KeyControlBlock - Supplies the key control block for the key for which
        the ConvKey is to be calculated

Return Value:

    The new ConvKey

Notes:

    This is to be used by the rename key api, which needs to rehash kcbs

--*/
{
    ULONG   ConvKey = 0;
    ULONG   Cnt;
    WCHAR   Cp;
    PUCHAR  u;
    PWCHAR  w;

    CM_PAGED_CODE();

    if( KeyControlBlock->ParentKcb != NULL ) {
        ConvKey = KeyControlBlock->ParentKcb->ConvKey;
    }

    //
    // Manually compute the hash to use.
    //
    ASSERT(KeyControlBlock->NameBlock->NameLength > 0);

    u = (PUCHAR)(&(KeyControlBlock->NameBlock->Name[0]));
    w = (PWCHAR)u;
    for( Cnt = 0; Cnt < KeyControlBlock->NameBlock->NameLength;) {
        if( KeyControlBlock->NameBlock->Compressed ) {
            Cp = (WCHAR)(*u);
            u++;
            Cnt += sizeof(UCHAR);
        } else {
            Cp = *w;
            w++;
            Cnt += sizeof(WCHAR);
        }
        ASSERT( Cp != OBJ_NAME_PATH_SEPARATOR );
        
        ConvKey = 37 * ConvKey + (ULONG)CmUpcaseUnicodeChar(Cp);
    }

    return ConvKey;
}

BOOLEAN
CmpRehashKcbSubtree(
                    PCM_KEY_CONTROL_BLOCK   Start,
                    PCM_KEY_CONTROL_BLOCK   End
                    )
/*++
Routine Description:

    Walks the path between End and Start and rehashed all kcbs that need
    rehashing;

    Assumptions: It is a priori taken that Start is an ancestor of End;

    Works in two steps:
    1. walks the path backwards from End to Start, reverting the back-link
    (we use the ParentKcb member in the kcb structure for that). I.e. we build a 
    forward path from Start to End
    2.Walks the forward path built at 1, rehashes kcbs whos need rehashing and restores
    the parent relationship.
    
Arguments:

    KeyControlBlock - where we start

    kcb - where we stop

Return Value:

    TRUE if at least one kcb has been rehashed

--*/
{
    PCM_KEY_CONTROL_BLOCK   Parent;
    PCM_KEY_CONTROL_BLOCK   Current;
    PCM_KEY_CONTROL_BLOCK   TmpKcb;
    ULONG                   ConvKey;
    BOOLEAN                 Result;

    CM_PAGED_CODE();

#if DBG
    //
    // make sure Start is an ancestor of End;
    //
    {
        ULONG LevelDiff = End->TotalLevels - Start->TotalLevels;

        ASSERT( (LONG)LevelDiff >= 0 );

        TmpKcb = End;
        for(;LevelDiff; LevelDiff--) {
            TmpKcb = TmpKcb->ParentKcb;
        }

        ASSERT( TmpKcb == Start );
    }
    
#endif
    //
    // Step 1: walk the path backwards (using the parentkcb link) and
    // revert it, until we reach Start. It is assumed that Start is an 
    // ancestor of End (the caller must not call this function otherwise !!!)
    //
    Current = NULL;
    Parent = End;
    while( Current != Start ) {
        //
        // revert the link
        //
        TmpKcb = Parent->ParentKcb;
        Parent->ParentKcb = Current;
        Current = Parent;
        Parent = TmpKcb;
        
        ASSERT( Current->TotalLevels >= Start->TotalLevels );
    }

    ASSERT( Current == Start );

    //
    // Step 2: Walk the forward path built at 1 and rehash the kcbs that need 
    // caching; At the same time, restore the links (parent relationships)
    //
    Result = FALSE;
    while( Current != NULL ) {
        //
        // see if we need to rehash this kcb;
        //
        //
        // restore the parent relationship; need to do this first so
        // CmpComputeKcbConvKey works OK
        //
        TmpKcb = Current->ParentKcb;
        Current->ParentKcb = Parent;

        ConvKey = CmpComputeKcbConvKey(Current);
        if( ConvKey != Current->ConvKey ) {
            //
            // rehash the kcb by removing it from hash, and then inserting it
            // again with th new ConvKey
            //
            CmpRemoveKeyHash(&(Current->KeyHash));
            Current->ConvKey = ConvKey;
            CmpInsertKeyHash(&(Current->KeyHash),FALSE);
            Result = TRUE;
        }

        //
        // advance forward
        //
        Parent = Current;
        Current = TmpKcb;
    }

    ASSERT( Parent == End );

    return Result;
}

BOOLEAN
CmpReferenceKeyControlBlock(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock
    )
{
    // Note: this is called only under KCB lock
    LONG RefCount;
    
    ASSERT_KCB_LOCKED( KeyControlBlock ); 

    if( (KeyControlBlock->RefCount == 0) && 
        (CmpIsKCBLockedExclusive(KeyControlBlock) == FALSE) &&
        (CmpTryConvertKCBLockSharedToExclusive(KeyControlBlock) == FALSE) ) {
        //
        // need to get the lock exclusive as we are changing the cache table
        // if we're here, the only way this kcb can go away from under us is if the delay close worker fires 
        // while we are dropping the lock; we set DelayCloseIndex to 1 (different than 0 that the worker uses)
        // to signal the worker to ignore this kcb; then after we get the lock exclusive, we put it back to 0 
        // (if it's still 1); We're the only ones playing with that value.
        //

        KeyControlBlock->DelayedCloseIndex = 1;

        // add an artificial refcount so it doesn't go away from under us while we drop the lock
        InterlockedIncrement( (PLONG)&KeyControlBlock->RefCount );
        CmpUpgradeKCBLockToExclusive(KeyControlBlock);

        // remove the artificial refcount we added above
        InterlockedDecrement( (PLONG)&KeyControlBlock->RefCount);
        if( KeyControlBlock->DelayedCloseIndex == 1 ) {
            KeyControlBlock->DelayedCloseIndex = 0;
        } else {
            // else someone beat us here
            ASSERT( (KeyControlBlock->DelayedCloseIndex == CmpDelayedCloseSize) ||
                    (KeyControlBlock->DelayedCloseIndex == 0)  );
        }
    }
    RefCount = (InterlockedIncrement( (PLONG)&KeyControlBlock->RefCount )) & 0xffff;
    if (RefCount == 0) {
        //
        // We have maxed out the ref count on this key. Probably
        // some bogus app has opened the same key 64K times without
        // ever closing it. Just fail the call
        //
        InterlockedDecrement( (PLONG)&KeyControlBlock->RefCount);
        return FALSE;
    } else if( KeyControlBlock->DelayedCloseIndex == 0 ) {
        if( (CmpIsKCBLockedExclusive(KeyControlBlock) == FALSE) &&
            (CmpTryConvertKCBLockSharedToExclusive(KeyControlBlock) == FALSE) ) {
            //
            // we need to promote this kcb to EX; safe since we're already added a reference on it.
            //
            CmpUpgradeKCBLockToExclusive(KeyControlBlock);
        }
        if( KeyControlBlock->DelayedCloseIndex == 0 ) {
            CmpRemoveFromDelayedClose(KeyControlBlock);
        }
    }

    LogKCBReference(KeyControlBlock,1);
    return TRUE;
}

PCM_NAME_CONTROL_BLOCK
CmpGetNameControlBlock(
    PUNICODE_STRING NodeName,
    PBOOLEAN        NameUpCase
    )
{
    PCM_NAME_CONTROL_BLOCK   Ncb = NULL;
    ULONG  Cnt;
    WCHAR *Cp;
    WCHAR *Cp2;
    ULONG Index;
    ULONG i;
    ULONG   Size;
    PCM_NAME_HASH CurrentName;
    BOOLEAN NameFound = FALSE;
    USHORT NameSize;
    BOOLEAN NameCompressed;
    ULONG NameConvKey=0;

    //
    // Calculate the ConvKey for this NodeName;
    //
    *NameUpCase = TRUE;
    Cp = NodeName->Buffer;
    for (Cnt=0; Cnt<NodeName->Length; Cnt += sizeof(WCHAR)) {
        if (*Cp != OBJ_NAME_PATH_SEPARATOR) {
            i = (ULONG)CmUpcaseUnicodeChar(*Cp);
            if( i != (*Cp) ) {
                *NameUpCase = FALSE;
            }
            NameConvKey = 37 * NameConvKey + i;
        }
        ++Cp;
    }

    //
    // Find the Name Size;
    // 
    NameCompressed = TRUE;
    NameSize = NodeName->Length / sizeof(WCHAR);
    for (i=0;i<NodeName->Length/sizeof(WCHAR);i++) {
        if ((USHORT)NodeName->Buffer[i] > (UCHAR)-1) {
            NameSize = NodeName->Length;
            NameCompressed = FALSE;
        }
    }

    CmpLockNameHashEntryExclusive(NameConvKey);
    Index = GET_HASH_INDEX(NameConvKey);
    CurrentName = CmpNameCacheTable[Index].Entry;

    while (CurrentName) {
        Ncb =  CONTAINING_RECORD(CurrentName, CM_NAME_CONTROL_BLOCK, NameHash);

        if ((NameConvKey == CurrentName->ConvKey) &&
            (NameSize == Ncb->NameLength)) {
            //
            // Hash value matches, compare the names.
            //
            NameFound = TRUE;
            if (Ncb->Compressed) {
                // we already know the name is uppercase
                if (CmpCompareCompressedName(NodeName, Ncb->Name, NameSize, CMP_DEST_UP)) {
                    NameFound = FALSE;
                }
            } else {
                Cp = (WCHAR *) NodeName->Buffer;
                Cp2 = (WCHAR *) Ncb->Name;
                for (i=0 ;i<Ncb->NameLength; i+= sizeof(WCHAR)) {
                    //
                    // Cp2 is always uppercase; see below
                    //
                    if (CmUpcaseUnicodeChar(*Cp) != (*Cp2) ) {
                        NameFound = FALSE;
                        break;
                    }
                    ++Cp;
                    ++Cp2;
                }
            }
            if (NameFound) {
                //
                // Found it, increase the refcount.
                //
                if ((USHORT) (Ncb->RefCount + 1) == 0) {
                    //
                    // We have maxed out the ref count.
                    // fail the call.
                    //
                    Ncb = NULL;
                } else {
                    ++Ncb->RefCount;
                }
                break;
            }
        }
        CurrentName = CurrentName->NextHash;
    }
    
    if (NameFound == FALSE) {
        //
        // Now need to create one Name block for this string.
        //
        Size = FIELD_OFFSET(CM_NAME_CONTROL_BLOCK, Name) + NameSize;
 
        Ncb = ExAllocatePoolWithTag(PagedPool,
                                    Size,
                                    CM_NAME_TAG | PROTECTED_POOL);
 
        if (Ncb == NULL) {
            CmpUnlockNameHashEntry(NameConvKey);
            return(NULL);
        }
        RtlZeroMemory(Ncb, Size);
 
        //
        // Update all the info for this newly created Name block.
        // Starting with Windows XP, the name is always uppercase in kcb name block
        //
        if (NameCompressed) {
            Ncb->Compressed = TRUE;
            for (i=0;i<NameSize;i++) {
                ((PUCHAR)Ncb->Name)[i] = (UCHAR)CmUpcaseUnicodeChar(NodeName->Buffer[i]);
            }
        } else {
            Ncb->Compressed = FALSE;
            for (i=0;i<NameSize/sizeof(WCHAR);i++) {
                Ncb->Name[i] = CmUpcaseUnicodeChar(NodeName->Buffer[i]);
            }
        }

        Ncb->ConvKey = NameConvKey;
        Ncb->RefCount = 1;
        Ncb->NameLength = NameSize;
        
        CurrentName = &(Ncb->NameHash);
        //
        // Insert into Name Hash table.
        //
        CurrentName->NextHash = CmpNameCacheTable[Index].Entry;
        CmpNameCacheTable[Index].Entry = CurrentName;
    }
    CmpUnlockNameHashEntry(NameConvKey);

    return(Ncb);
}


VOID
CmpDereferenceNameControlBlockWithLock(
    PCM_NAME_CONTROL_BLOCK   Ncb
    )
{
    PCM_NAME_HASH *Prev;
    PCM_NAME_HASH Current;
    ULONG         ConvKey = Ncb->ConvKey;

    CmpLockNameHashEntryExclusive(ConvKey);
    if (--Ncb->RefCount == 0) {

        //
        // Remove it from the the Hash Table
        //
        Prev = &((GET_HASH_ENTRY(CmpNameCacheTable, Ncb->ConvKey)).Entry);
        
        while (TRUE) {
            Current = *Prev;
            ASSERT(Current != NULL);
            if (Current == &(Ncb->NameHash)) {
                *Prev = Current->NextHash;
                break;
            }
            Prev = &Current->NextHash;
        }

        //
        // Free storage
        //
        ExFreePoolWithTag(Ncb, CM_NAME_TAG | PROTECTED_POOL);
    }
    CmpUnlockNameHashEntry(ConvKey);
    return;
}

VOID
CmpRebuildKcbCache(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock
    )
/*++
Routine Description:

    rebuilds all the kcb cache values from knode; this routine is intended to be called
    after a tree sync/copy

Arguments:

    KeyControlBlock - pointer to a key control block.

Return Value:

    NONE.

--*/
{
    PCM_KEY_NODE    Node;

    ASSERT_KCB_LOCKED_EXCLUSIVE(KeyControlBlock);

    ASSERT( !(KeyControlBlock->ExtFlags & CM_KCB_SYM_LINK_FOUND) ); 

    Node = (PCM_KEY_NODE)HvGetCell(KeyControlBlock->KeyHive,KeyControlBlock->KeyCell);
    if( Node == NULL ) {
        // no can do
        return;
    }

    // subkey info;
    CmpCleanUpSubKeyInfo(KeyControlBlock);

    // value cache
    CmpCleanUpKcbValueCache(KeyControlBlock);
    CmpSetUpKcbValueCache(KeyControlBlock,Node->ValueList.Count,Node->ValueList.List);

    // the rest of the cache
    KeyControlBlock->KcbLastWriteTime = Node->LastWriteTime;
    KeyControlBlock->KcbMaxNameLen = (USHORT)Node->MaxNameLen;
    KeyControlBlock->KcbMaxValueNameLen = (USHORT)Node->MaxValueNameLen;
    KeyControlBlock->KcbMaxValueDataLen = Node->MaxValueDataLen;
    HvReleaseCell(KeyControlBlock->KeyHive,KeyControlBlock->KeyCell);
}

VOID
CmpCleanUpSubKeyInfo(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock
    )
/*++
Routine Description:

    Clean up the subkey information cache due to create or delete keys.
    Registry is locked exclusively and no need to lock the KCB.

Arguments:

    KeyControlBlock - pointer to a key control block.

Return Value:

    NONE.

--*/
{
    PCM_KEY_NODE    Node;

    ASSERT_KCB_LOCKED_EXCLUSIVE(KeyControlBlock);

    if (KeyControlBlock->ExtFlags & (CM_KCB_NO_SUBKEY | CM_KCB_SUBKEY_ONE | CM_KCB_SUBKEY_HINT)) {
        if (KeyControlBlock->ExtFlags & (CM_KCB_SUBKEY_HINT)) {
            ExFreePoolWithTag(KeyControlBlock->IndexHint, CM_CACHE_INDEX_TAG | PROTECTED_POOL);
        }
        KeyControlBlock->ExtFlags &= ~((CM_KCB_NO_SUBKEY | CM_KCB_SUBKEY_ONE | CM_KCB_SUBKEY_HINT));
    }
   
    //
    // Update the cached SubKeyCount in stored the kcb
    //
	if( KeyControlBlock->KeyCell == HCELL_NIL ) {
		//
		// prior call of ZwRestoreKey(REG_FORCE_RESTORE) invalidated this kcb
		//
		ASSERT( KeyControlBlock->Delete );
		Node = NULL;
	} else {
	    Node = (PCM_KEY_NODE)HvGetCell(KeyControlBlock->KeyHive,KeyControlBlock->KeyCell);
	}
    if( Node == NULL ) {
        //
        // insufficient resources; mark subkeycount as invalid
        //
        KeyControlBlock->ExtFlags |= CM_KCB_INVALID_CACHED_INFO;
    } else {
        KeyControlBlock->ExtFlags &= ~CM_KCB_INVALID_CACHED_INFO;
        KeyControlBlock->SubKeyCount = Node->SubKeyCounts[Stable] + Node->SubKeyCounts[Volatile];
        HvReleaseCell(KeyControlBlock->KeyHive,KeyControlBlock->KeyCell);
    }
    
}


VOID
CmpCleanUpKcbValueCache(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock
    )
/*++

Routine Description:

    Clean up cached value/data that are associated to this key.

Arguments:

    KeyControlBlock - pointer to a key control block.

Return Value:

    NONE.

--*/
{
    ULONG i;
    PULONG_PTR CachedList;

    ASSERT_KCB_LOCKED_EXCLUSIVE(KeyControlBlock);

    if (CMP_IS_CELL_CACHED(KeyControlBlock->ValueCache.ValueList)) {
        CachedList = (PULONG_PTR) CMP_GET_CACHED_CELLDATA(KeyControlBlock->ValueCache.ValueList);
        for (i = 0; i < KeyControlBlock->ValueCache.Count; i++) {
            if (CMP_IS_CELL_CACHED(CachedList[i])) {

                // Trying to catch the BAD guy who writes over our pool.
                CmpMakeSpecialPoolReadWrite( CMP_GET_CACHED_ADDRESS(CachedList[i]) );

                ExFreePool((PVOID) CMP_GET_CACHED_ADDRESS(CachedList[i]));
               
            }
        }

        // Trying to catch the BAD guy who writes over our pool.
        CmpMakeSpecialPoolReadWrite( CMP_GET_CACHED_ADDRESS(KeyControlBlock->ValueCache.ValueList) );

        ExFreePool((PVOID) CMP_GET_CACHED_ADDRESS(KeyControlBlock->ValueCache.ValueList));

        // Mark the ValueList as NULL 
        KeyControlBlock->ValueCache.ValueList = HCELL_NIL;

    } else if (KeyControlBlock->ExtFlags & CM_KCB_SYM_LINK_FOUND) {
        //
        // This is a symbolic link key with symbolic name resolved.
        // Dereference to its real kcb and clear the bit.
        //
        if ((KeyControlBlock->ValueCache.RealKcb->RefCount == 1) && !(KeyControlBlock->ValueCache.RealKcb->Delete)) {
            KeyControlBlock->ValueCache.RealKcb->ExtFlags |= CM_KCB_NO_DELAY_CLOSE;
        }
        CmpDelayDerefKeyControlBlock(KeyControlBlock->ValueCache.RealKcb);
        KeyControlBlock->ExtFlags &= ~CM_KCB_SYM_LINK_FOUND;
    }
}


VOID
CmpCleanUpKcbCacheWithLock(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock,
    BOOLEAN                 RegLockHeldEx
    )
/*++

Routine Description:

    Clean up all cached allocations that are associated to this key.
    If the parent is still open just because of this one, Remove the parent as well.

Arguments:

    KeyControlBlock - pointer to a key control block.

Return Value:

    NONE.

--*/
{
    PCM_KEY_CONTROL_BLOCK   Kcb;
    PCM_KEY_CONTROL_BLOCK   ParentKcb;

    ASSERT_KCB_LOCKED_EXCLUSIVE(KeyControlBlock);

    Kcb = KeyControlBlock;

    ASSERT(KeyControlBlock->RefCount == 0);

    //
    // change in design: We are only freeing the current kcb and delay deref the parent
    //
    
    if(Kcb->RefCount == 0) {
        //
        // First, free allocations for Value/data.
        //
    
        CmpCleanUpKcbValueCache(Kcb);
    
        //
        // Free the kcb and dereference parentkcb and nameblock.
        //
    
        CmpDereferenceNameControlBlockWithLock(Kcb->NameBlock);
    
        if (Kcb->ExtFlags & CM_KCB_SUBKEY_HINT) {
            //
            // Now free the HintIndex allocation
            //
            ExFreePoolWithTag(Kcb->IndexHint, CM_CACHE_INDEX_TAG | PROTECTED_POOL);
        }

        //
        // Save the ParentKcb before we free the Kcb
        //
        ParentKcb = Kcb->ParentKcb;
        
        //
        // We cannot call CmpDereferenceKeyControlBlockWithLock so we can avoid recursion.
        //
        
        if (!Kcb->Delete) {
            CmpRemoveKeyControlBlock(Kcb);
        }
        SET_KCB_SIGNATURE(Kcb, '4FmC');

        CmpFreeKeyControlBlock( Kcb );
        
        if (ParentKcb) {
            if( RegLockHeldEx ) {
                CmpDereferenceKeyControlBlockWithLock(ParentKcb,RegLockHeldEx);
            } else {
                CmpDelayDerefKeyControlBlock(ParentKcb);
            }
        }
    }
}


PUNICODE_STRING
CmpConstructName(
    PCM_KEY_CONTROL_BLOCK kcb
)
/*++

Routine Description:

    Construct the name given a kcb.

Arguments:

    kcb - Kcb for the key

Return Value:

    Pointer to the unicode string constructed.  
    Caller is responsible to free this storage space.

--*/
{
    PUNICODE_STRING         FullName;
    PCM_KEY_CONTROL_BLOCK   TmpKcb;
    PCM_KEY_NODE            KeyNode;
    SIZE_T                  Length;
    SIZE_T                  size;
    USHORT                  i;
    SIZE_T                  BeginPosition;
    WCHAR                   *w1, *w2;
    UCHAR                   *u2;
    BOOLEAN                 DeletedPath = FALSE;

    //
    // Calculate the total string length.
    //
    Length = 0;
    TmpKcb = kcb;
    while (TmpKcb) {
        if (TmpKcb->NameBlock->Compressed) {
            Length += TmpKcb->NameBlock->NameLength * sizeof(WCHAR);
        } else {
            Length += TmpKcb->NameBlock->NameLength; 
        }
        //
        // Add the space for OBJ_NAME_PATH_SEPARATOR;
        //
        Length += sizeof(WCHAR);

        TmpKcb = TmpKcb->ParentKcb;
    }

    if (Length > MAXUSHORT) {
        return NULL;
    }

    //
    // Allocate the pool for the unicode string
    //
    size = sizeof(UNICODE_STRING) + Length;

    FullName = (PUNICODE_STRING) ExAllocatePoolWithTag(PagedPool,
                                                       size,
                                                       CM_NAME_TAG | PROTECTED_POOL);

    if (FullName) {
        FullName->Buffer = (USHORT *) ((ULONG_PTR) FullName + sizeof(UNICODE_STRING));
        FullName->Length = (USHORT) Length;
        FullName->MaximumLength = (USHORT) Length;

        //
        // Now fill the name into the buffer.
        //
        TmpKcb = kcb;
        BeginPosition = Length;

        while (TmpKcb) {
            if( (TmpKcb->KeyHive == NULL) || 
                (TmpKcb->ExtFlags & CM_KCB_KEY_NON_EXIST) ||
                ((!TmpKcb->Delete) && (TmpKcb->KeyCell == HCELL_NIL))  ) {
                ExFreePoolWithTag(FullName, CM_NAME_TAG | PROTECTED_POOL);
                FullName = NULL;
                break;
            }
            
#if defined(_WIN64)
            //
            // only go to the hive in case name hasn't been cached yet
            //
            if( TmpKcb->RealKeyName == NULL ) {
#endif
                if( !(TmpKcb->Delete || DeletedPath ) ) {
                    KeyNode = (PCM_KEY_NODE)HvGetCell(TmpKcb->KeyHive,TmpKcb->KeyCell);
                    if( KeyNode == NULL ) {
                        //
                        // could not allocate view
                        //
                        ExFreePoolWithTag(FullName, CM_NAME_TAG | PROTECTED_POOL);
                        FullName = NULL;
                        break;
                    }
                } else {
                    DeletedPath = TRUE;
                    KeyNode = NULL;
                }
#if defined(_WIN64)
            } else {
                KeyNode = NULL;
            }
#endif

            //
            // sanity
            //
#if DBG
            if( KeyNode && (!(TmpKcb->Flags & (KEY_HIVE_ENTRY | KEY_HIVE_EXIT))) ) {
                ASSERT( KeyNode->NameLength == TmpKcb->NameBlock->NameLength );
                ASSERT( ((KeyNode->Flags&KEY_COMP_NAME) && (TmpKcb->NameBlock->Compressed)) ||
                        ((!(KeyNode->Flags&KEY_COMP_NAME)) && (!(TmpKcb->NameBlock->Compressed))) );
            }
#endif //DBG
            //
            // Calculate the begin position of each subkey. Then fill in the char.
            //
            //
            if (TmpKcb->NameBlock->Compressed) {
                BeginPosition -= (TmpKcb->NameBlock->NameLength + 1) * sizeof(WCHAR);
                w1 = &(FullName->Buffer[BeginPosition/sizeof(WCHAR)]);
                *w1 = OBJ_NAME_PATH_SEPARATOR;
                w1++;

                if( ! (TmpKcb->Flags & (KEY_HIVE_ENTRY | KEY_HIVE_EXIT)) ) {
                    //
                    // Get the name from the knode; to preserve case
                    //
#if defined(_WIN64)
                    if( TmpKcb->RealKeyName == NULL ) {
                        //
                        // name not cached yet; we'll do it before we let go of KeyNode
                        //
                        if( KeyNode ) {
                            u2 = (UCHAR *) &(KeyNode->Name[0]);
                        } else {
                            //
                            // deleted key; need to get the name from the kcb
                            //
                            ASSERT( TmpKcb->Delete || DeletedPath );
                            u2 = (UCHAR *) &(TmpKcb->NameBlock->Name[0]);
                        }
                    } else if(TmpKcb->RealKeyName == CMP_KCB_REAL_NAME_UPCASE) {
                        //
                        // name is uppercase, use the one in the kcb name block
                        //
                        u2 = (UCHAR *) &(TmpKcb->NameBlock->Name[0]);
                    } else {
                        //
                        // we have previously cached this name; use that; it is guaranteed it doesn't go away from under us
                        // since the only 2 places where that can happen are:
                        //  1. NtRenameKey --> reglock held EX there
                        //  2. CmpFreeKeyControlBlock --> can't happen since we have a reference to this kcb
                        //
                        u2 = (UCHAR *) (TmpKcb->RealKeyName);
                    }
#else
                    if( KeyNode ) {
                        u2 = (UCHAR *) &(KeyNode->Name[0]);
                    } else {
                        //
                        // deleted key; need to get the name from the kcb
                        //
                        ASSERT( TmpKcb->Delete || DeletedPath );
                        u2 = (UCHAR *) &(TmpKcb->NameBlock->Name[0]);
                    }
#endif
                } else { 
                    //
                    // get it from the kcb, as in the keynode we don't hold the right name (see PROTO.HIV nodes)
                    //
                    u2 = (UCHAR *) &(TmpKcb->NameBlock->Name[0]);
                }

                for (i=0; i<TmpKcb->NameBlock->NameLength; i++) {
                    *w1 = (WCHAR)(*u2);
                    w1++;
                    u2++;
                }
            } else {
                BeginPosition -= (TmpKcb->NameBlock->NameLength + sizeof(WCHAR));
                w1 = &(FullName->Buffer[BeginPosition/sizeof(WCHAR)]);
                *w1 = OBJ_NAME_PATH_SEPARATOR;
                w1++;

                if( ! (TmpKcb->Flags & (KEY_HIVE_ENTRY | KEY_HIVE_EXIT)) ) {
                    //
                    // Get the name from the knode; to preserve case
                    //
#if defined(_WIN64)
                    if( TmpKcb->RealKeyName == NULL ) {
                        //
                        // name not cached yet; we'll do it before we let go of KeyNode
                        //
                        if( KeyNode ) {
                            w2 = KeyNode->Name;
                        } else {
                            //
                            // deleted key; need to get the name from the kcb
                            //
                            ASSERT( TmpKcb->Delete || DeletedPath );
                            w2 = TmpKcb->NameBlock->Name;
                        }
                    } else if(TmpKcb->RealKeyName == CMP_KCB_REAL_NAME_UPCASE) {
                        //
                        // name is uppercase, use the one in the kcb name block
                        //
                        w2 = TmpKcb->NameBlock->Name;
                    } else {
                        //
                        // we have previously cached this name; use that; it is guaranteed it doesn't go away from under us
                        // since the only 2 places where that can happen are:
                        //  1. NtRenameKey --> reglock held EX there
                        //  2. CmpFreeKeyControlBlock --> can't happen since we have a reference to this kcb
                        //
                        w2 = (WCHAR *) (TmpKcb->RealKeyName);
                    }
#else
                    if( KeyNode ) {
                        w2 = KeyNode->Name;
                    } else {
                        //
                        // deleted key; need to get the name from the kcb
                        //
                        ASSERT( TmpKcb->Delete || DeletedPath );
                        w2 = TmpKcb->NameBlock->Name;
                    }
#endif
                } else {
                    //
                    // get it from the kcb, as in the keynode we don't hold the right name (see PROTO.HIV nodes)
                    //
                    w2 = TmpKcb->NameBlock->Name;
                }
                for (i=0; i<TmpKcb->NameBlock->NameLength; i=i+sizeof(WCHAR)) {
                    *w1 = *w2;
                    w1++;
                    w2++;
                }
            }

#if defined(_WIN64)
            //
            // here's the challenging part; if the name is not yet cached; do it here; 
            // allocate pool for cached name; populate it from the KeyNode, then InterlockExchange it to the RealKeyName
            //
            if( (TmpKcb->RealKeyName == NULL) && (KeyNode != NULL) ) {
                PCHAR   CachedName = ExAllocatePoolWithTag(PagedPool,TmpKcb->NameBlock->NameLength,CM_NAME_TAG);
                
                if( CachedName != NULL ) {
                    
                    RtlCopyMemory(CachedName,KeyNode->Name,TmpKcb->NameBlock->NameLength);
                    if( InterlockedCompareExchangePointer(&(TmpKcb->RealKeyName),CachedName,NULL) != NULL ) {
                        //
                        // somebody else beat us here
                        //
                        ExFreePoolWithTag(CachedName, CM_NAME_TAG);
                    }
                }

            }
            //
            // we might end up with 2 threads racing in this routine, we can't rely on RealKeyName being NULL only
            //
#endif
            if( KeyNode != NULL ) {
                HvReleaseCell(TmpKcb->KeyHive,TmpKcb->KeyCell);
            }

            TmpKcb = TmpKcb->ParentKcb;
        }
    }
    return (FullName);
}

PCM_KEY_CONTROL_BLOCK
CmpCreateKeyControlBlock(
    PHHIVE          Hive,
    HCELL_INDEX     Cell,
    PCM_KEY_NODE    Node,
    PCM_KEY_CONTROL_BLOCK ParentKcb,
    ULONG                   ControlFlags,
    PUNICODE_STRING KeyName
    )
/*++

Routine Description:

    Allocate and initialize a key control block, insert it into
    the kcb tree.

    Full path will be BaseName + '\' + KeyName, unless BaseName
    NULL, in which case the full path is simply KeyName.

    RefCount of returned KCB WILL have been incremented to reflect
    callers ref.

Arguments:

    Hive - Supplies Hive that holds the key we are creating a KCB for.

    Cell - Supplies Cell that contains the key we are creating a KCB for.

    Node - Supplies pointer to key node.

    ParentKcb - Parent kcb of the kcb to be created

    FakeKey - Whether the kcb to be create is a fake one or not

    KeyName - the subkey name to of the KCB to be created.
 
    NOTE:  We need the parameter instead of just using the name in the KEY_NODE 
           because there is no name in the root cell of a hive.

Return Value:

    NULL - failure (insufficient memory)
    else a pointer to the new kcb.

--*/
{
    PCM_KEY_CONTROL_BLOCK   kcb;
    PCM_KEY_CONTROL_BLOCK   kcbmatch=NULL;
    UNICODE_STRING          NodeName;
    ULONG                   ConvKey = 0;
    ULONG                   Cnt;
    WCHAR                   *Cp;
    BOOLEAN                 FakeKey;
    BOOLEAN                 NameUpCase;

    //
    // support for hive unloading in shared mode; do not allow other keys to be opened while unloading
    //
    if( Hive->HiveFlags & HIVE_IS_UNLOADING && (((PCMHIVE)Hive)->CreatorOwner != KeGetCurrentThread()) ) {
        return NULL;
    }

    FakeKey = (ControlFlags&CMP_CREATE_KCB_FAKE)?TRUE:FALSE;
    //
    // ParentKCb has the base hash value.
    //
    if (ParentKcb) {
        ConvKey = ParentKcb->ConvKey;
    }

    NodeName = *KeyName;

    while ((NodeName.Length > 0) && (NodeName.Buffer[0] == OBJ_NAME_PATH_SEPARATOR)) {
        //
        // This must be the \REGISTRY.
        // Strip off the leading OBJ_NAME_PATH_SEPARATOR
        //
        NodeName.Buffer++;
        NodeName.Length -= sizeof(WCHAR);
    }

    //
    // Manually compute the hash to use.
    //
    ASSERT(NodeName.Length > 0);

    if (NodeName.Length) {
        Cp = NodeName.Buffer;
        for (Cnt=0; Cnt<NodeName.Length; Cnt += sizeof(WCHAR)) {
            //
            // UNICODE_NULL is a valid char !!!
            //
            if (*Cp != OBJ_NAME_PATH_SEPARATOR) {
                //(*Cp != UNICODE_NULL)) {
                ConvKey = 37 * ConvKey + (ULONG)CmUpcaseUnicodeChar(*Cp);
            }
            ++Cp;
        }
    }

    //
    // Create a new kcb, which we will free if one already exists
    // for this key.
    // Now it is a fixed size structure.
    //
    kcb = CmpAllocateKeyControlBlock( );

    if (kcb == NULL) {
        return(NULL);
    } else {
        SET_KCB_SIGNATURE(kcb, KCB_SIGNATURE);
        InitializeKCBKeyBodyList(kcb);
        kcb->Delete = FALSE;
        kcb->RefCount = 1;
        kcb->KeyHive = Hive;
        kcb->KeyCell = Cell;
        kcb->ConvKey = ConvKey;

        // Initialize as not on delayed close (0=1st delayed close slot)
        kcb->DelayedCloseIndex = CmpDelayedCloseSize;
#if defined(_WIN64)
        kcb->RealKeyName = NULL;
#endif

#if DBG
        kcb->InDelayClose = 0;
#endif //DBG
    }

    ASSERT_KCB(kcb);
    //
    // Find location to insert kcb in kcb tree.
    //
    if( !(ControlFlags & CMP_CREATE_KCB_KCB_LOCKED) ) {
        if( ParentKcb ) {
            //
            // need to lock them both atomically
            // 
            CmpLockTwoHashEntriesExclusive(ConvKey,ParentKcb->ConvKey);
        } else {
            CmpLockKCBExclusive(kcb);
        }
    }
    //
    // Add the KCB to the hash table
    //
    kcbmatch = CmpInsertKeyHash(&kcb->KeyHash, FakeKey);
    if (kcbmatch != NULL) {
        //
        // A match was found.
        //
        ASSERT(!kcbmatch->Delete);
        SET_KCB_SIGNATURE(kcb, '1FmC');

        CmpFreeKeyControlBlock(kcb);
        ASSERT_KCB(kcbmatch);
        kcb = kcbmatch;
        if( !CmpReferenceKeyControlBlock(kcb) ) {
            //
            // We have maxed out the ref count on this key. Probably
            // some bogus app has opened the same key 64K times without
            // ever closing it. Just fail the open, they've got enough
            // handles already.
            //
            ASSERT(kcb->RefCount + 1 != 0);
            kcb = NULL;
        } else {
            //
            // update the keycell and hive, in case this is a fake kcb
            //
            if( (kcb->ExtFlags & CM_KCB_KEY_NON_EXIST) && (!FakeKey) ) {
                kcb->ExtFlags = CM_KCB_INVALID_CACHED_INFO;
                kcb->KeyHive = Hive;
                kcb->KeyCell = Cell;
            }

            //
            // Update the cached information stored in the kcb, since we have the key_node handy
            //
            if (!(kcb->ExtFlags & (CM_KCB_NO_SUBKEY | CM_KCB_SUBKEY_ONE | CM_KCB_SUBKEY_HINT)) ) {
                // SubKeyCount
                kcb->SubKeyCount = Node->SubKeyCounts[Stable] + Node->SubKeyCounts[Volatile];
                // clean up the invalid flag (if any)
                kcb->ExtFlags &= ~CM_KCB_INVALID_CACHED_INFO;

            }

            kcb->KcbLastWriteTime = Node->LastWriteTime;
            kcb->KcbMaxNameLen = (USHORT)Node->MaxNameLen;
            kcb->KcbMaxValueNameLen = (USHORT)Node->MaxValueNameLen;
            kcb->KcbMaxValueDataLen = Node->MaxValueDataLen;
        }

    } else {
        //
        // No kcb created previously, fill in all the data.
        //

        //
        // Now try to reference the parentkcb
        //
        
        if (ParentKcb) {
            if ( ((ParentKcb->TotalLevels + 1) < CMP_MAX_REGISTRY_DEPTH) && (CmpReferenceKeyControlBlock(ParentKcb)) ) {
                kcb->ParentKcb = ParentKcb;
                kcb->TotalLevels = ParentKcb->TotalLevels + 1;
            } else {
                //
                // We have maxed out the ref count on the parent.
                // Since it has been cached in the cachetable,
                // remove it first before we free the allocation.
                //
                CmpRemoveKeyControlBlock(kcb);
                SET_KCB_SIGNATURE(kcb, '2FmC');

                CmpFreeKeyControlBlock(kcb);
                kcb = NULL;
            }
        } else {
            //
            // It is the \REGISTRY node.
            //
            kcb->ParentKcb = NULL;
            kcb->TotalLevels = 1;
        }

        if (kcb) {
            //
            // Cache the security cells in the kcb
            //
            CmpAssignSecurityToKcb(kcb,Node->Security,FALSE);

            //
            // Now try to find the Name Control block that has the name for this node.
            //
            kcb->NameBlock = CmpGetNameControlBlock (&NodeName,&NameUpCase);

            if (kcb->NameBlock) {
                //
                // Now fill in all the data needed for the cache.
                //
                kcb->ValueCache.Count = Node->ValueList.Count;                    
                kcb->ValueCache.ValueList = (ULONG_PTR)(Node->ValueList.List);
        
                kcb->Flags = Node->Flags;
                kcb->ExtFlags = 0;
                kcb->DelayedCloseIndex = CmpDelayedCloseSize;
        
                if (FakeKey) {
                    //
                    // The KCb to be created is a fake one; 
                    //
                    kcb->ExtFlags |= CM_KCB_KEY_NON_EXIST;
                }

                CmpTraceKcbCreate(kcb);
                PERFINFO_REG_KCB_CREATE(kcb);

                //
                // Update the cached information stored in the kcb, since we have the key_node handy
                //
                
                // SubKeyCount
                kcb->SubKeyCount = Node->SubKeyCounts[Stable] + Node->SubKeyCounts[Volatile];
                
                kcb->KcbLastWriteTime = Node->LastWriteTime;
                kcb->KcbMaxNameLen = (USHORT)Node->MaxNameLen;
                kcb->KcbMaxValueNameLen = (USHORT)Node->MaxValueNameLen;
                kcb->KcbMaxValueDataLen = Node->MaxValueDataLen;

#if defined(_WIN64)
                if(NameUpCase == TRUE) {
                    kcb->RealKeyName = CMP_KCB_REAL_NAME_UPCASE;
                }
#endif
            } else {
                //
                // We have maxed out the ref count on the Name.
                //
                
                //
                // First dereference the parent KCB.
                //
                CmpDereferenceKeyControlBlockWithLock(ParentKcb,FALSE);

                CmpRemoveKeyControlBlock(kcb);
                SET_KCB_SIGNATURE(kcb, '3FmC');

                CmpFreeKeyControlBlock(kcb);
                kcb = NULL;
            }
        }
    }
	if( kcb && IsHiveFrozen(Hive) && (!(kcb->Flags & KEY_SYM_LINK)) ) {
		//
		// kcbs created inside a frozen hive should not be added to delayclose table.
		//
		kcb->ExtFlags |= CM_KCB_NO_DELAY_CLOSE;

	}

    ASSERT( (!kcb) || (kcb->Delete == FALSE) );
    if( !(ControlFlags & CMP_CREATE_KCB_KCB_LOCKED) ) {
        if( ParentKcb ) {
            //
            // need to lock them both atomically
            // 
            CmpUnlockTwoHashEntries(ConvKey,ParentKcb->ConvKey);
        } else {
            // need to use ConvKey here since the kcb might not always be available
            CmpUnlockHashEntry(ConvKey);
        }
    }
    return kcb;
}

BOOLEAN
CmpSearchKeyControlBlockTree(
    PKCB_WORKER_ROUTINE WorkerRoutine,
    PVOID               Context1,
    PVOID               Context2
    )
/*++

Routine Description:

    Traverse the kcb tree.  We will visit all nodes unless WorkerRoutine
    tells us to stop part way through.

    For each node, call WorkerRoutine(..., Context1, Contex2).  If it returns
    KCB_WORKER_DONE, we are done, simply return.  If it returns
    KCB_WORKER_CONTINUE, just continue the search. If it returns KCB_WORKER_DELETE,
    the specified KCB is marked as deleted.
	If it returns KCB_WORKER_ERROR we bail out and signal the error to the caller.

    This routine has the side-effect of removing all delayed-close KCBs.

Arguments:

    WorkerRoutine - applied to nodes witch Match.

    Context1 - data we pass through

    Context2 - data we pass through


Return Value:

    NONE.

--*/
{
    PCM_KEY_CONTROL_BLOCK   Current;
    PCM_KEY_HASH *Prev;
    ULONG                   WorkerResult;
    ULONG                   i;

    //
    // Walk the hash table
    //
    for (i=0; i<CmpHashTableSize; i++) {
        CmpLockHashEntryByIndexExclusive(i);
        Prev = &(CmpCacheTable[i].Entry);
        while (*Prev) {
            Current = CONTAINING_RECORD(*Prev,
                                        CM_KEY_CONTROL_BLOCK,
                                        KeyHash);
            ASSERT_KCB(Current);
            ASSERT(!Current->Delete);
            if (Current->RefCount == 0) {
                //
                // This kcb is in DelayClose case, remove it.
                //
                CmpRemoveFromDelayedClose(Current);
                CmpCleanUpKcbCacheWithLock(Current,FALSE);

                //
                // The HashTable is changed, start over in this index again.
                //
                Prev = &(CmpCacheTable[i].Entry);
                continue;
            }

            WorkerResult = (WorkerRoutine)(Current, Context1, Context2);
            if (WorkerResult == KCB_WORKER_DONE) {
                CmpUnlockHashEntryByIndex(i);
                return TRUE;
            } else if (WorkerResult == KCB_WORKER_ERROR) {
                CmpUnlockHashEntryByIndex(i);
				return FALSE;
            } else if (WorkerResult == KCB_WORKER_DELETE) {
                ASSERT(Current->Delete);
                *Prev = Current->NextHash;
                continue;
            } else {
                ASSERT(WorkerResult == KCB_WORKER_CONTINUE);
                Prev = &Current->NextHash;
            }
        }
        CmpUnlockHashEntryByIndex(i);
    }

	return TRUE;
}

VOID
CmpDereferenceKeyControlBlock(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock
    )
/*++

Routine Description:

    Decrements the reference count on a key control block, and frees it if it
    becomes zero.

    It is expected that no notify control blocks remain if the reference count
    becomes zero.

Arguments:

    KeyControlBlock - pointer to a key control block.

Return Value:

    NONE.

--*/
{
    LONG OldRefCount;
    LONG NewRefCount;
    ULONG   ConvKey;

    OldRefCount = *(PLONG)&KeyControlBlock->RefCount; //get entire dword
    NewRefCount = OldRefCount - 1;
    if( (NewRefCount & 0xffff) > 0  &&
        InterlockedCompareExchange((PLONG)&KeyControlBlock->RefCount,NewRefCount,OldRefCount)
            == OldRefCount ) {
        LogKCBReference(KeyControlBlock,2);
        return;
    }

    // kcb may be freed from under us !
    ConvKey = KeyControlBlock->ConvKey;
    
    CmpLockKCBExclusive(KeyControlBlock);
    CmpDereferenceKeyControlBlockWithLock(KeyControlBlock,FALSE);
    CmpUnlockHashEntry(ConvKey);
    return;
}


VOID
CmpDereferenceKeyControlBlockWithLock(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock,
    BOOLEAN                 RegLockHeldEx
    )
{
    ASSERT_KCB(KeyControlBlock);
    ASSERT_KCB_LOCKED(KeyControlBlock);

    if( (InterlockedDecrement( (PLONG)&KeyControlBlock->RefCount ) & 0xffff) == 0) {
        LogKCBReference(KeyControlBlock,2);
        ASSERT_KCB_LOCKED_EXCLUSIVE(KeyControlBlock);
        //
        // Remove kcb from the tree
        //
        // delay close disabled during boot; up to the point CCS is saved.
        // for symbolic links, we still need to keep the symbolic link kcb around.
        //
        if((CmpHoldLazyFlush && (!(KeyControlBlock->ExtFlags & CM_KCB_SYM_LINK_FOUND)) && (!(KeyControlBlock->Flags & KEY_SYM_LINK))) || 
            (KeyControlBlock->ExtFlags & CM_KCB_NO_DELAY_CLOSE) ) {
            //
            // Free storage directly so we can clean up junk quickly.
            //
            //
            // Need to free all cached Index List, Index Leaf, Value, etc.
            //
            CmpCleanUpKcbCacheWithLock(KeyControlBlock,RegLockHeldEx);
        } else if (!KeyControlBlock->Delete) {

            //
            // Put this kcb on our delayed close list.
            //
            CmpAddToDelayedClose(KeyControlBlock,RegLockHeldEx);

        } else {
            //
            // Free storage directly as there is no point in putting this on
            // our delayed close list.
            //
            //
            // Need to free all cached Index List, Index Leaf, Value, etc.
            //
            CmpCleanUpKcbCacheWithLock(KeyControlBlock,RegLockHeldEx);
        }
    }
    return;
}

VOID
CmpRemoveKeyControlBlock(
    PCM_KEY_CONTROL_BLOCK   KeyControlBlock
    )
/*++

Routine Description:

    Remove a key control block from the KCB tree.

    It is expected that no notify control blocks remain.

    The kcb will NOT be freed, call DereferenceKeyControlBlock for that.

    This call assumes the KCB tree is already locked or registry is locked exclusively.

Arguments:

    KeyControlBlock - pointer to a key control block.

Return Value:

    NONE.

--*/
{
    ASSERT_KCB(KeyControlBlock);
    ASSERT_KCB_LOCKED_EXCLUSIVE(KeyControlBlock);

    //
    // Remove the KCB from the hash table
    //
    CmpRemoveKeyHash(&KeyControlBlock->KeyHash);

    return;
}


BOOLEAN
CmpFreeKeyBody(
    PHHIVE Hive,
    HCELL_INDEX Cell
    )
/*++

Routine Description:

    Free storage for the key entry Hive.Cell refers to, including
    its class and security data.  Will NOT free child list or value list.

Arguments:

    Hive - supplies a pointer to the hive control structure for the hive

    Cell - supplies index of key to free

Return Value:

    TRUE - success

    FALSE - error; couldn't map cell
--*/
{
    PCELL_DATA key;

    //
    // map in the cell
    //
    key = HvGetCell(Hive, Cell);
    if( key == NULL ) {
        //
        // we couldn't map the bin containing this cell
        // Sorry, we cannot free the keybody
        // this shouldn't happen as the cell must've been
        // marked dirty (i.e. pinned in memory) by now
        //
        ASSERT( FALSE );
        return FALSE;
    }

    if (!(key->u.KeyNode.Flags & KEY_HIVE_EXIT)) {
        if (key->u.KeyNode.Security != HCELL_NIL) {
            HvFreeCell(Hive, key->u.KeyNode.Security);
        }

        if (key->u.KeyNode.ClassLength > 0) {
            HvFreeCell(Hive, key->u.KeyNode.Class);
        }
    }

    HvReleaseCell(Hive,Cell);

    //
    // unmap the cell itself and free it
    //
    HvFreeCell(Hive, Cell);

    return TRUE;
}

PCM_KEY_CONTROL_BLOCK
CmpInsertKeyHash(
    IN PCM_KEY_HASH KeyHash,
    IN BOOLEAN      FakeKey
    )
/*++

Routine Description:

    Adds a key hash structure to the hash table. The hash table
    will be checked to see if a duplicate entry already exists. If
    a duplicate is found, its kcb will be returned. If a duplicate is not
    found, NULL will be returned.

Arguments:

    KeyHash - Supplies the key hash structure to be added.

Return Value:

    NULL - if the supplied key has was added
    PCM_KEY_HASH - The duplicate hash entry, if one was found

--*/

{
    ULONG Index;
    PCM_KEY_HASH Current;

    ASSERT_KEY_HASH(KeyHash);
    Index = GET_HASH_INDEX(KeyHash->ConvKey);

    //
    // If this is a fake key, we will use the cell and hive from its 
    // parent for uniqeness.  To deal with the case when the fake
    // has the same ConvKey as its parent (in which case we cannot distingish 
    // between the two), we set the lowest bit of the fake key's cell.
    //
    // It's possible (unlikely) that we cannot distingish two fake keys 
    // (when their Convkey's are the same) under the same key.  It is not breaking
    // anything, we just cannot find the other one in cache lookup.
    //
    //
    if (FakeKey) {
        KeyHash->KeyCell++;
    }

    //
    // First look for duplicates.
    //
    Current = CmpCacheTable[Index].Entry;
    while (Current) {
        ASSERT_KEY_HASH(Current);
        //
        // We must check ConvKey since we can create a fake kcb
        // for keys that does not exist.
        // We will use the Hive and Cell from the parent.
        //

        if ((KeyHash->ConvKey == Current->ConvKey) &&
            (KeyHash->KeyCell == Current->KeyCell) &&
            (KeyHash->KeyHive == Current->KeyHive)) {
            //
            // Found a match
            //
            return(CONTAINING_RECORD(Current,
                                     CM_KEY_CONTROL_BLOCK,
                                     KeyHash));
        }
        Current = Current->NextHash;
    }

    //
    // No duplicate was found, add this entry at the head of the list
    //
    KeyHash->NextHash = CmpCacheTable[Index].Entry;
    CmpCacheTable[Index].Entry = KeyHash;
    return(NULL);
}

VOID
CmpRemoveKeyHash(
    IN PCM_KEY_HASH KeyHash
    )
/*++

Routine Description:

    Removes a key hash structure from the hash table.

Arguments:

    KeyHash - Supplies the key hash structure to be deleted.

Return Value:

    None

--*/

{
    ULONG Index;
    PCM_KEY_HASH *Prev;
    PCM_KEY_HASH Current;

    ASSERT_KEY_HASH(KeyHash);

    Index = GET_HASH_INDEX(KeyHash->ConvKey);

    //
    // Find this entry.
    //
    Prev = &(CmpCacheTable[Index].Entry);
    while (TRUE) {
        Current = *Prev;
        ASSERT(Current != NULL);
        ASSERT_KEY_HASH(Current);
        if (Current == KeyHash) {
            *Prev = Current->NextHash;
#if DBG
            if (*Prev) {
                ASSERT_KEY_HASH(*Prev);
            }
#endif
            break;
        }
        Prev = &Current->NextHash;
    }
}


VOID
CmpInitializeCache()
{
    ULONG   i;
    ULONG   TotalCmCacheSize;
    TotalCmCacheSize = CmpHashTableSize * sizeof(CM_KEY_HASH_TABLE_ENTRY);

    CmpCacheTable = ExAllocatePoolWithTag(PagedPool,
                                          TotalCmCacheSize,
                                          'aCMC');
    if (CmpCacheTable == NULL) {
        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_CACHE_TABLE,1,0,0);
        return;
    }
    RtlZeroMemory(CmpCacheTable, TotalCmCacheSize);
    
    //
    // initialize each entry lock
    //
#pragma prefast(suppress:12009, "silence prefast")
    for(i=0;i<CmpHashTableSize;i++) {
        ExInitializePushLock(&(CmpCacheTable[i].Lock));
    }

    TotalCmCacheSize = CmpHashTableSize * sizeof(CM_NAME_HASH_TABLE_ENTRY);
    CmpNameCacheTable = ExAllocatePoolWithTag(PagedPool,
                                              TotalCmCacheSize,
                                              'aCMC');
    if (CmpNameCacheTable == NULL) {
        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_CACHE_TABLE,3,0,0);
        return;
    }
    RtlZeroMemory(CmpNameCacheTable, TotalCmCacheSize);

    for(i=0;i<CmpHashTableSize;i++) {
        ExInitializePushLock(&(CmpNameCacheTable[i].Lock));
    }

    CmpInitializeDelayedCloseTable();
}

//
// lock free keybody array ==> convert these to macros
//
VOID InitializeKCBKeyBodyList(IN PCM_KEY_CONTROL_BLOCK kcb)
{
    ULONG   i;

    InitializeListHead(&(kcb->KeyBodyListHead));
    for(i=0;i<CMP_LOCK_FREE_KEY_BODY_ARRAY_SIZE;i++) {
        kcb->KeyBodyArray[i] = NULL;
    }
}

VOID EnlistKeyBodyWithKCB(IN PCM_KEY_BODY   KeyBody,
                          IN ULONG          ControlFlags )
{
    ULONG   i;
    
    ASSERT( KeyBody->KeyControlBlock != NULL );
    ASSERT_KCB_LOCKED(KeyBody->KeyControlBlock);

    CmpSetNoCallers(KeyBody);
    InitializeListHead(&(KeyBody->KeyBodyList));   

    // 
    // try the fast path first; no locks required here.
    //
    for(i=0;i<CMP_LOCK_FREE_KEY_BODY_ARRAY_SIZE;i++) {
        if(InterlockedCompareExchangePointer(&(KeyBody->KeyControlBlock->KeyBodyArray[i]),
                                               KeyBody,
                                               NULL) == NULL) {
            //
            // we're lucky, it worked.
            //
            return;
        }
    }
    
    //
    // slow path
    //
    if( ControlFlags & CMP_ENLIST_KCB_LOCKED_SHARED ) {
        CmpUnlockKCB(KeyBody->KeyControlBlock);     
        ASSERT( !(ControlFlags & CMP_ENLIST_KCB_LOCKED_EXCLUSIVE) );
    } 
    if( !(ControlFlags & CMP_ENLIST_KCB_LOCKED_EXCLUSIVE) ) {
        CmpLockKCBExclusive(KeyBody->KeyControlBlock);                                      
    }                                                                                       
    ASSERT_KCB_LOCKED_EXCLUSIVE(KeyBody->KeyControlBlock);
    InsertTailList(&(KeyBody->KeyControlBlock->KeyBodyListHead),&(KeyBody->KeyBodyList));   
    if( !(ControlFlags & (CMP_ENLIST_KCB_LOCKED_SHARED|CMP_ENLIST_KCB_LOCKED_EXCLUSIVE)) ) {  
        CmpUnlockKCB(KeyBody->KeyControlBlock);                                             
    }                                                                                       
}

VOID DelistKeyBodyFromKCB(IN PCM_KEY_BODY   KeyBody,
                          IN BOOLEAN        LockHeld )
{
    ULONG       i;
    ULONG_PTR   Value;

    ASSERT( KeyBody->KeyControlBlock != NULL );
Retry:
    // 
    // try the fast path first; no locks required here.
    //
    for(i=0;i<CMP_LOCK_FREE_KEY_BODY_ARRAY_SIZE;i++) {
        Value = (ULONG_PTR)InterlockedCompareExchangePointer(&(KeyBody->KeyControlBlock->KeyBodyArray[i]),
                                               NULL,
                                               KeyBody);
        if( Value == (ULONG_PTR)KeyBody) {
            //
            // we're lucky, it worked.
            //
            return;
        }
        if( (Value == CMP_FAST_KEY_BODY_ARRAY_DUMP) ||
            (Value == CMP_FAST_KEY_BODY_ARRAY_FLUSH) ) {
            //
            // other routine is performing work on this array; retry until they are done
            //
            goto Retry;
        }
    }

    //
    // slow path
    //
    ASSERT(IsListEmpty(&(KeyBody->KeyControlBlock->KeyBodyListHead)) == FALSE);
    ASSERT(IsListEmpty(&(KeyBody->KeyBodyList)) == FALSE);
    if( !(LockHeld) ) {                                                                     
        CmpLockKCBExclusive(KeyBody->KeyControlBlock);                                      
    }                                                                                       
    ASSERT_KCB_LOCKED_EXCLUSIVE(KeyBody->KeyControlBlock);
    RemoveEntryList(&(KeyBody->KeyBodyList));                                               
    if( !(LockHeld) ) {                                                                     
        CmpUnlockKCB(KeyBody->KeyControlBlock);                                             
    }                                                                                       
}

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmsubs3.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmsubs3.c

Abstract:

    This module contains locking support routines for the configuration manager.

--*/

#include    "cmp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpLockRegistry)
#pragma alloc_text(PAGE,CmpLockRegistryExclusive)
#pragma alloc_text(PAGE,CmpUnlockRegistry)

#if DBG
#pragma alloc_text(PAGE,CmpTestRegistryLock)
#pragma alloc_text(PAGE,CmpTestRegistryLockExclusive)
#endif

#pragma alloc_text(PAGE,CmpTryToLockHashEntryByIndexExclusive)
#pragma alloc_text(PAGE,CmpLockTwoHashEntriesExclusive)
#pragma alloc_text(PAGE,CmpLockTwoHashEntriesShared)
#pragma alloc_text(PAGE,CmpUnlockTwoHashEntries)

#if DBG
#pragma alloc_text(PAGE,CmpLockHiveFlusherShared)
#pragma alloc_text(PAGE,CmpLockHiveFlusherExclusive)
#pragma alloc_text(PAGE,CmpUnlockHiveFlusher)
#pragma alloc_text(PAGE,CmpTestHiveFlusherLockShared)
#pragma alloc_text(PAGE,CmpTestHiveFlusherLockExclusive)
#endif

#pragma alloc_text(PAGE,CmpKCBLockForceAcquireAllowed)
#endif


//
// Global registry lock
//

ERESOURCE   CmpRegistryLock;


LONG        CmpFlushStarveWriters = 0;
BOOLEAN     CmpFlushOnLockRelease = FALSE;
LONG        CmRegistryLogSizeLimit = -1;


#if DBG
PVOID       CmpRegistryLockCaller;
PVOID       CmpRegistryLockCallerCaller;
PVOID       CmpKCBLockCaller;
PVOID       CmpKCBLockCallerCaller;
#endif //DBG

extern BOOLEAN CmpSpecialBootCondition;

VOID
CmpLockRegistry(
    VOID
    )
/*++

Routine Description:

    Lock the registry for shared (read-only) access

Arguments:

    None.

Return Value:

    None, the registry lock will be held for shared access upon return.

--*/
{
#if DBG
    PVOID       Caller;
    PVOID       CallerCaller;
#endif

    KeEnterCriticalRegion();

    if( CmpFlushStarveWriters ) {
        //
        // a flush is in progress; starve potential writers
        //
        ExAcquireSharedStarveExclusive(&CmpRegistryLock, TRUE);
    } else {
        //
        // regular shared mode
        //
        ExAcquireResourceSharedLite(&CmpRegistryLock, TRUE);
    }

#if DBG
    RtlGetCallersAddress(&Caller, &CallerCaller);
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_LOCKING,"CmpLockRegistry: c, cc: %p  %p\n", Caller, CallerCaller));
#endif

}

VOID
CmpLockRegistryExclusive(
    VOID
    )
/*++

Routine Description:

    Lock the registry for exclusive (write) access.

Arguments:

    None.

Return Value:

    TRUE - Lock was acquired exclusively

    FALSE - Lock is owned by another thread.

--*/
{
    KeEnterCriticalRegion();
    
    ExAcquireResourceExclusiveLite(&CmpRegistryLock,TRUE);

    ASSERT( CmpFlushStarveWriters == 0 );

#if DBG
    RtlGetCallersAddress(&CmpRegistryLockCaller, &CmpRegistryLockCallerCaller);
#endif //DBG
}

VOID
CmpUnlockRegistry(
    )
/*++

Routine Description:

    Unlock the registry.

--*/
{
    ASSERT_CM_LOCK_OWNED();

    //
    // test if bit set to force flush; and we own the reglock exclusive and ownercount is 1
    //
    if( CmpFlushOnLockRelease && ExIsResourceAcquiredExclusiveLite(&CmpRegistryLock) && (CmpRegistryLock.OwnerThreads[0].OwnerCount == 1) ) {
        //
        // we need to flush now
        //
        ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
        CmpDoFlushAll(TRUE);
        CmpFlushOnLockRelease = FALSE;
    }
    
    ExReleaseResourceLite(&CmpRegistryLock);
    KeLeaveCriticalRegion();
}


#if DBG

BOOLEAN
CmpTestRegistryLock(VOID)
{
    BOOLEAN rc;

    rc = TRUE;
    if (ExIsResourceAcquiredShared(&CmpRegistryLock) == 0) {
        rc = FALSE;
    }
    return rc;
}

BOOLEAN
CmpTestRegistryLockExclusive(VOID)
{
    if (ExIsResourceAcquiredExclusiveLite(&CmpRegistryLock) == 0) {
        return(FALSE);
    }
    return(TRUE);
}

#endif

BOOLEAN CmpTryConvertKCBLockSharedToExclusive(PCM_KEY_CONTROL_BLOCK Kcb) 
/*++

Routine Description:

    Attempts to convert a shared acquire to exclusive. 

Arguments:

    Kcb - Kcb to be converted

Return Value:

    BOOLEAN - TRUE: Conversion worked ok, FALSE: The conversion could not be achieved

--*/
{
    BOOLEAN Result;

    ASSERT_KCB_LOCKED(Kcb);
    ASSERT( CmpIsKCBLockedExclusive(Kcb) == FALSE );
    Result = ExTryConvertPushLockSharedToExclusive(&(GET_KCB_HASH_ENTRY_LOCK((Kcb))));
    if( Result ) {
        GET_KCB_HASH_ENTRY_OWNER(Kcb) = KeGetCurrentThread();
    }
    return Result;
}

BOOLEAN
CmpTryToLockHashEntryByIndexExclusive(
    ULONG   Index
    )
/*++

Routine Description:

    Try to acquire the entry exclusive 

Arguments:

    None.

Return Value:

    TRUE if acquire was successfull; FALSE otherwise

--*/
{
    BOOLEAN Result;

    ASSERT_CM_LOCK_OWNED();

    Result = ExTryAcquirePushLockExclusive(&(CmpCacheTable[Index].Lock));

    if( Result ) {
        ASSERT( CmpCacheTable[Index].Owner == NULL );
    
        CmpCacheTable[Index].Owner = KeGetCurrentThread();
    }
    return Result;
}


VOID
CmpLockTwoHashEntriesExclusive(
    ULONG   ConvKey1,
    ULONG   ConvKey2
    )
/*++

Routine Description:

    Lock two entries ordered by the index. deadlock avoidance.
    Takes care of not locking the same entry twice.

  NOTE: should be used in pair with UnlockTwoHashEntries

Arguments:

    None.

Return Value:

    None

--*/
{
    ULONG   Index1;
    ULONG   Index2;

    ASSERT_CM_LOCK_OWNED();

    Index1 = GET_HASH_INDEX(ConvKey1);
    Index2 = GET_HASH_INDEX(ConvKey2);

    if( Index1 < Index2 ) {
        CmpLockHashEntryExclusive(ConvKey1);
        CmpLockHashEntryExclusive(ConvKey2);
    } else {
        CmpLockHashEntryExclusive(ConvKey2);
        if( Index1 != Index2 ) {
            CmpLockHashEntryExclusive(ConvKey1);
        }
        
    }
}

VOID
CmpLockTwoHashEntriesShared(
    ULONG   ConvKey1,
    ULONG   ConvKey2
    )
/*++

Routine Description:

    Lock two entries ordered by the index. deadlock avoidance.
    Takes care of not locking the same entry twice.

  NOTE: should be used in pair with UnlockTwoHashEntries

Arguments:

    None.

Return Value:

    None

--*/
{
    ULONG   Index1;
    ULONG   Index2;

    ASSERT_CM_LOCK_OWNED();

    Index1 = GET_HASH_INDEX(ConvKey1);
    Index2 = GET_HASH_INDEX(ConvKey2);

    if( Index1 < Index2 ) {
        CmpLockHashEntryShared(ConvKey1);
        CmpLockHashEntryShared(ConvKey2);
    } else {
        CmpLockHashEntryShared(ConvKey2);
        if( Index1 != Index2 ) {
            CmpLockHashEntryShared(ConvKey1);
        }
        
    }
}

VOID
CmpUnlockTwoHashEntries(
    ULONG   ConvKey1,
    ULONG   ConvKey2
    )
{
    ULONG   Index1;
    ULONG   Index2;

    ASSERT_CM_LOCK_OWNED();

    Index1 = GET_HASH_INDEX(ConvKey1);
    Index2 = GET_HASH_INDEX(ConvKey2);

    ASSERT_HASH_ENTRY_LOCKED(ConvKey2);
    if( Index1 < Index2 ) {
        ASSERT_HASH_ENTRY_LOCKED(ConvKey1);
        CmpUnlockHashEntry(ConvKey2);
        CmpUnlockHashEntry(ConvKey1);
    } else {
        if( Index1 != Index2 ) {
            ASSERT_HASH_ENTRY_LOCKED(ConvKey1);
            CmpUnlockHashEntry(ConvKey1);
        }
        CmpUnlockHashEntry(ConvKey2);
    }
}

//
// GOAL: get rid of the global registry lock.
//

//
// flusher lock: atomic flushes
//
#if DBG
VOID
CmpLockHiveFlusherShared(
    PCMHIVE CmHive
    )
/*++

Routine Description:

    Locks the writer lock for this hive; no cell allocs/free/markdirty are allowed unless this lock is held exclusive

Arguments:

    None.

Return Value:

    None

--*/
{
    ASSERT_CM_LOCK_OWNED_OR_HIVE_LOADING(CmHive);

    ASSERT_RESOURCE_NOT_OWNED(CmHive->FlusherLock);

    ExAcquireResourceSharedLite(CmHive->FlusherLock, TRUE);
}

VOID
CmpLockHiveFlusherExclusive(
    PCMHIVE CmHive
    )
/*++

Routine Description:

    Locks the Flusher lock for this hive; 
    
    do that in order to: cell allocs/free/markdirty 

Arguments:

    None.

Return Value:

    None

--*/
{
    ASSERT_CM_LOCK_OWNED_OR_HIVE_LOADING(CmHive);

    ASSERT_RESOURCE_NOT_OWNED(CmHive->FlusherLock);

    ExAcquireResourceExclusiveLite(CmHive->FlusherLock,TRUE);
}

VOID
CmpUnlockHiveFlusher(
    PCMHIVE CmHive
    )
/*++

Routine Description:

Arguments:

    None.

Return Value:

    None

--*/
{
    ASSERT_CM_LOCK_OWNED_OR_HIVE_LOADING(CmHive);

    ASSERT_HIVE_FLUSHER_LOCKED(CmHive);

    ExReleaseResourceLite(CmHive->FlusherLock);
}

BOOLEAN
CmpTestHiveFlusherLockShared(
    PCMHIVE CmHive
    )
{
    BOOLEAN rc;

    rc = TRUE;
    if (ExIsResourceAcquiredShared(CmHive->FlusherLock) == 0) {
        rc = FALSE;
    }
    return rc;
}

BOOLEAN
CmpTestHiveFlusherLockExclusive(
    PCMHIVE CmHive
    )
{
    if (ExIsResourceAcquiredExclusiveLite(CmHive->FlusherLock) == 0) {
        return(FALSE);
    }
    return(TRUE);
}
#endif // DBG

BOOLEAN
CmpKCBLockForceAcquireAllowed(ULONG Index1,
                              ULONG Index2,
                              ULONG NewIndex) 
/*++

Routine Description:

    Decides whether we are allowed to force acquire a hash entry bucket; Used for deadlock avoidance

Arguments:

Return Value:

--*/
{
    ASSERT( Index1 != NewIndex );
    ASSERT( Index2 != NewIndex );

    if( Index1 == CmpHashTableSize ) {
        if( Index2 == CmpHashTableSize ) {
            // none locked
            return TRUE;
        } else {
            return ((NewIndex > Index2)?TRUE:FALSE);
        }
    } else {
        if( Index2 == CmpHashTableSize ) {
            return ((NewIndex > Index1)?TRUE:FALSE);
        } else {
            //
            // both indexes valid
            //
            return (((NewIndex > Index1) && (NewIndex > Index2))?TRUE:FALSE);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmsysini.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmsysini.c

Abstract:

    This module contains init support for the configuration manager,
    particularly the registry.

Revision History:

     Added CmpSaveBootControlSet & CmpDeleteCloneTree in order to
     perform some of the LKG work that has been moved into the kernel.
     Modified system initialization to permit operation and LKG control
     set saves without a CurrentControlSet clone.

--*/

#include    "cmp.h"
#include    "arc.h"
#pragma hdrstop
#include    "arccodes.h"

#pragma warning(disable:4204)   // non constant aggregate initializer
#pragma warning(disable:4221)   // initialization using address of automatic

//
// paths
//

#define INIT_REGISTRY_MASTERPATH   L"\\REGISTRY\\"

extern  PKPROCESS   CmpSystemProcess;
extern  ERESOURCE   CmpRegistryLock;

extern  EX_PUSH_LOCK  CmpPostLock;

extern  BOOLEAN     CmFirstTime;
extern  BOOLEAN HvShutdownComplete;

//
// List of MACHINE hives to load.
//
extern  HIVE_LIST_ENTRY CmpMachineHiveList[];
extern  UCHAR           SystemHiveFullPathBuffer[];
extern  UNICODE_STRING  SystemHiveFullPathName;

#define SYSTEM_PATH L"\\registry\\machine\\system"

//
// special keys for backwards compatibility with 1.0
//
#define HKEY_PERFORMANCE_TEXT       (( HANDLE ) (ULONG_PTR)((LONG)0x80000050) )
#define HKEY_PERFORMANCE_NLSTEXT    (( HANDLE ) (ULONG_PTR)((LONG)0x80000060) )

extern UNICODE_STRING  CmpSystemFileName;
extern UNICODE_STRING  CmSymbolicLinkValueName;
extern UNICODE_STRING  CmpLoadOptions;         // sys options from FW or boot.ini
extern PWCHAR CmpProcessorControl;
extern PWCHAR CmpControlSessionManager;

//
//
// Object type definition support.
//
// Key objects (CmpKeyObjectType) represent open instances of keys in the
// registry.  They do not have object names, rather, their names are
// defined by the registry backing store.
//

//
// Master Hive
//
//  The KEY_NODEs for \REGISTRY, \REGISTRY\MACHINE, and \REGISTRY\USER
//  are stored in a small memory only hive called the Master Hive.
//  All other hives have link nodes in this hive which point to them.
//
extern   PCMHIVE CmpMasterHive;
extern   BOOLEAN CmpNoMasterCreates;    // Init False, Set TRUE after we're done to
                                        // prevent random creates in the
                                        // master hive, which is not backed
                                        // by a file.

extern   LIST_ENTRY  CmpHiveListHead;   // List of CMHIVEs


//
// Addresses of object type descriptors:
//

extern   POBJECT_TYPE CmpKeyObjectType;

//
// Define attributes that Key objects are not allowed to have.
//

#define CMP_KEY_INVALID_ATTRIBUTES  (OBJ_EXCLUSIVE  |\
                                     OBJ_PERMANENT)


//
// Global control values
//

//
// Write-Control:
//  CmpNoWrite is initially true.  When set this way write and flush
//  do nothing, simply returning success.  When cleared to FALSE, I/O
//  is enabled.  This change is made after the I/O system is started
//  AND autocheck (chkdsk) has done its thing.
//

extern BOOLEAN CmpNoWrite;

//
// Buffer used for quick-stash transfers in CmSetValueKey
//
extern PUCHAR  CmpStashBuffer;
extern ULONG   CmpStashBufferSize;


//
// set to true if disk full when trying to save the changes made between system hive loading and registry initialization
//
extern BOOLEAN CmpCannotWriteConfiguration;
//
// Global "constants"
//

extern   const UNICODE_STRING nullclass;
extern BOOLEAN CmpTrackHiveClose;

ULONG   CmSelfHeal = 1; // enabled by default

extern LIST_ENTRY	    CmpSelfHealQueueListHead;
extern KGUARDED_MUTEX	CmpSelfHealQueueLock;

//
// Private prototypes
//
VOID
CmpCreatePredefined(
    IN HANDLE Root,
    IN PWSTR KeyName,
    IN HANDLE PredefinedHandle
    );

VOID
CmpCreatePerfKeys(
    VOID
    );

BOOLEAN
CmpLinkKeyToHive(
    PWSTR   KeyPath,
    PWSTR   HivePath
    );

NTSTATUS
CmpCreateControlSet(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

NTSTATUS
CmpCloneControlSet(
    VOID
    );

NTSTATUS
CmpCreateObjectTypes(
    VOID
    );

BOOLEAN
CmpCreateRegistryRoot(
    VOID
    );

BOOLEAN
CmpCreateRootNode(
    IN PHHIVE   Hive,
    IN PWSTR    Name,
    OUT PHCELL_INDEX RootCellIndex
    );

VOID
CmpFreeDriverList(
    IN PHHIVE Hive,
    IN PLIST_ENTRY DriverList
    );

VOID
CmpInitializeHiveList(
    VOID
    );

BOOLEAN
CmpInitializeSystemHive(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

NTSTATUS
CmpInterlockedFunction (
    PWCHAR RegistryValueKey,
    VOID (*InterlockedFunction)(VOID)
    );

VOID
CmpConfigureProcessors (
    VOID
    );

NTSTATUS
CmpAddDockingInfo (
    IN HANDLE Key,
    IN PROFILE_PARAMETER_BLOCK * ProfileBlock
    );

NTSTATUS
CmpAddAliasEntry (
    IN HANDLE IDConfigDB,
    IN PROFILE_PARAMETER_BLOCK * ProfileBlock,
    IN ULONG  ProfileNumber
    );

NTSTATUS CmpDeleteCloneTree(VOID);

VOID
CmpDiskFullWarning(
    VOID
    );

VOID
CmpLoadHiveThread(
    IN PVOID StartContext
    );

NTSTATUS
CmpSetupPrivateWrite(
    PCMHIVE             CmHive
    );

NTSTATUS
CmpSetSystemValues(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

NTSTATUS
CmpSetNetworkValue(
    IN PNETWORK_LOADER_BLOCK NetworkLoaderBlock
    );

VOID
CmpInitCallback(VOID);

VOID
CmpMarkCurrentValueDirty(
                         IN PHHIVE SystemHive,
                         IN HCELL_INDEX RootCell
                         );

#ifdef ALLOC_PRAGMA
NTSTATUS
CmpHwprofileDefaultSelect (
    IN  PCM_HARDWARE_PROFILE_LIST ProfileList,
    OUT PULONG ProfileIndexToUse,
    IN  PVOID Context
    );
#pragma alloc_text(INIT,CmInitSystem1)
#pragma alloc_text(INIT,CmIsLastKnownGoodBoot)
#pragma alloc_text(INIT,CmpHwprofileDefaultSelect)
#pragma alloc_text(INIT,CmpCreateControlSet)
#pragma alloc_text(INIT,CmpCloneControlSet)
#pragma alloc_text(INIT,CmpCreateObjectTypes)
#pragma alloc_text(INIT,CmpCreateRegistryRoot)
#pragma alloc_text(INIT,CmpCreateRootNode)
#pragma alloc_text(INIT,CmpInitializeSystemHive)
#pragma alloc_text(INIT,CmGetSystemDriverList)
#pragma alloc_text(INIT,CmpFreeDriverList)
#pragma alloc_text(INIT,CmpSetSystemValues)
#pragma alloc_text(INIT,CmpSetNetworkValue)
#pragma alloc_text(PAGE,CmpInitializeHiveList)
#pragma alloc_text(PAGE,CmpLinkHiveToMaster)
#pragma alloc_text(PAGE,CmBootLastKnownGood)
#pragma alloc_text(PAGE,CmpSaveBootControlSet)
#pragma alloc_text(PAGE,CmpInitHiveFromFile)
#pragma alloc_text(PAGE,CmpLinkKeyToHive)
#pragma alloc_text(PAGE,CmpCreatePredefined)
#pragma alloc_text(PAGE,CmpCreatePerfKeys)
#pragma alloc_text(PAGE,CmpInterlockedFunction)
#pragma alloc_text(PAGE,CmpConfigureProcessors)
#pragma alloc_text(INIT,CmpAddDockingInfo)
#pragma alloc_text(INIT,CmpAddAliasEntry)
#pragma alloc_text(PAGE,CmpDeleteCloneTree)
#pragma alloc_text(PAGE,CmpSetupPrivateWrite)
#pragma alloc_text(PAGE,CmpLoadHiveThread)
#pragma alloc_text(PAGE,CmpMarkCurrentValueDirty)
#endif



BOOLEAN
CmInitSystem1(
    __in PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This function is called as part of phase1 init, after the object
    manager has been initialized, but before IoInit.  It's purpose is to
    set up basic registry object operations, and transform data
    captured during boot into registry format (whether it was read
    from the SYSTEM hive file by the osloader or computed by recognizers.)
    After this call, Nt*Key calls work, but only part of the name
    space is available and any changes written must be held in
    memory.

    CmpMachineHiveList entries marked CM_PHASE_1 are available
    after return from this call, but writes must be held in memory.

    This function will:

        1.  Create the registry worker/lazy-write thread
        2.  Create the registry key object type
        4.  Create the master hive
        5.  Create the \REGISTRY node
        6.  Create a KEY object that refers to \REGISTRY
        7.  Create \REGISTRY\MACHINE node
        8.  Create the SYSTEM hive, fill in with data from loader
        9.  Create the HARDWARE hive, fill in with data from loader
       10.  Create:
                \REGISTRY\MACHINE\SYSTEM
                \REGISTRY\MACHINE\HARDWARE
                Both of which will be link nodes in the master hive.

    NOTE:   We do NOT free allocated pool in failure case.  This is because
            our caller is going to bugcheck anyway, and having the memory
            object to look at is useful.

Arguments:

    LoaderBlock - supplies the LoaderBlock passed in from the OSLoader.
        By looking through the memory descriptor list we can find the
        SYSTEM hive which the OSLoader has placed in memory for us.

Return Value:

    TRUE if all operations were successful, false if any failed.

    Bugchecks when something went wrong (CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,.....)

--*/
{
    HANDLE  key1;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS    status;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    PCMHIVE HardwareHive;

    //
    // Set the mini NT flag if we are booting into Mini NT 
    // environment
    //
    if (InitIsWinPEMode) {
        CmpMiniNTBoot = InitIsWinPEMode;        

        //
        // On Remote boot client share the system hives
        //
        // NOTE : We can't assume exclusive access to WinPE
        // remote boot clients. We don't flush anything to 
        // system hives in WinPE. All the system hives are 
        // loaded in memory in scratch mode
        //
        CmpShareSystemHives = TRUE;
    }

    CM_PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INIT,"CmInitSystem1\n"));

    //
    // Initialize Names of all registry paths.
    // This simply initializes unicode strings so we don't have to bother
    // with it later. This can not fail.
    //
    CmpInitializeRegistryNames();

    //
    // Compute registry global quota
    //
    CmpComputeGlobalQuotaAllowed();

    //
    // Initialize the hive list head
    //
    InitializeListHead(&CmpHiveListHead);
    ExInitializePushLock(&CmpHiveListHeadLock);
    ExInitializePushLock(&CmpLoadHiveLock);

    //
    // Initialize the global registry resource
    //
    ExInitializeResourceLite(&CmpRegistryLock);

    //
    // Initialize the PostList mutex
    //
    ExInitializePushLock(&CmpPostLock);

    //
    // Initialize the Stash Buffer mutex
    //
    ExInitializePushLock(&CmpStashBufferLock);

    //
    // Initialize the cache
    //
    CmpInitializeCache ();

    //
    // Initialize private allocator
    //
    CmpInitCmPrivateAlloc();
    CmpInitCmPrivateDelayAlloc();

    //
    // delay deref kcb
    //
    CmpInitDelayDerefKCBEngine();

    //
    // Initialize callback module
    //
    CmpInitCallback();

	//
	// Self Heal workitem queue
	//
    InitializeListHead(&CmpSelfHealQueueListHead);
    KeInitializeGuardedMutex(&CmpSelfHealQueueLock);

    //
    // start tracking quota allocations
    //
    CM_TRACK_QUOTA_START();

    //
    // Save the current process to allow us to attach to it later.
    //
    CmpSystemProcess = &PsGetCurrentProcess()->Pcb;

    CmpLockRegistryExclusive();

    //
    // Create the Key object type.
    //
    status = CmpCreateObjectTypes();
    if (!NT_SUCCESS(status) ) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmInitSystem1: CmpCreateObjectTypes failed\n"));
        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,1,status,0); // could not register with object manager
    }


    //
    // Create the master hive and initialize it.
    //
    status = CmpInitializeHive(&CmpMasterHive,
                HINIT_CREATE,
                HIVE_VOLATILE,
                HFILE_TYPE_PRIMARY,     // i.e. no logging, no alterate
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                0);
    if (!NT_SUCCESS(status)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmInitSystem1: CmpInitializeHive(master) failed\n"));

        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,2,status,0); // could not initialize master hive
    }

    //
    // try to allocate a stash buffer.  if we can't get 1 page this
    // early on, we're in deep trouble, so punt.
    //
    CmpStashBuffer = ExAllocatePoolWithTag(PagedPool, PAGE_SIZE,CM_STASHBUFFER_TAG);
    if (CmpStashBuffer == NULL) {
        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,3,0,0); // odds against this are huge
    }
    CmpStashBufferSize = PAGE_SIZE;

    //
    // Create the \REGISTRY node
    //
    if (!CmpCreateRegistryRoot()) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmInitSystem1: CmpCreateRegistryRoot failed\n"));
        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,4,0,0); // could not create root of the registry
    }

    //
    // --- 6. Create \REGISTRY\MACHINE and \REGISTRY\USER nodes ---
    //

    //
    // Get default security descriptor for the nodes we will create.
    //
    SecurityDescriptor = CmpHiveRootSecurityDescriptor();

    InitializeObjectAttributes(
        &ObjectAttributes,
        &CmRegistryMachineName,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        SecurityDescriptor
        );

    if (!NT_SUCCESS(status = NtCreateKey(
                        &key1,
                        KEY_READ | KEY_WRITE,
                        &ObjectAttributes,
                        0,
                        (PUNICODE_STRING)&nullclass,
                        0,
                        NULL
        )))
    {
        ExFreePool(SecurityDescriptor);
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmInitSystem1: NtCreateKey(MACHINE) failed\n"));
        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,5,status,0); // could not create HKLM
    }

    NtClose(key1);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &CmRegistryUserName,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        SecurityDescriptor
        );

    if (!NT_SUCCESS(status = NtCreateKey(
                        &key1,
                        KEY_READ | KEY_WRITE,
                        &ObjectAttributes,
                        0,
                        (PUNICODE_STRING)&nullclass,
                        0,
                        NULL
        )))
    {
        ExFreePool(SecurityDescriptor);
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmInitSystem1: NtCreateKey(USER) failed\n"));
        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,6,status,0); // could not create HKUSER
    }

    NtClose(key1);


    //
    // --- 7. Create the SYSTEM hive, fill in with data from loader ---
    //
    if (!CmpInitializeSystemHive(LoaderBlock)) {
        ExFreePool(SecurityDescriptor);

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpInitSystem1: "));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"Hive allocation failure for SYSTEM\n"));

        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,7,0,0); // could not create SystemHive
    }

    //
    // Create the symbolic link \Registry\Machine\System\CurrentControlSet
    //
    status = CmpCreateControlSet(LoaderBlock);
    if (!NT_SUCCESS(status)) {
        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,8,status,0); // could not create CurrentControlSet
    }

    //
    // --- 8. Create the HARDWARE hive, fill in with data from loader ---
    //
    status = CmpInitializeHive(&HardwareHive,
                HINIT_CREATE,
                HIVE_VOLATILE,
                HFILE_TYPE_PRIMARY,     // i.e. no log, no alternate
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                0);
    if (!NT_SUCCESS(status)) {
        ExFreePool(SecurityDescriptor);

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpInitSystem1: "));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"Could not initialize HARDWARE hive\n"));

        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,11,status,0); // could not initialize hardware hive
    }

    //
    // Allocate the root node
    //
    status = CmpLinkHiveToMaster(
            &CmRegistryMachineHardwareName,
            NULL,
            HardwareHive,
            TRUE,
            SecurityDescriptor
            );
    if ( status != STATUS_SUCCESS )
    {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmInitSystem1: CmpLinkHiveToMaster(Hardware) failed\n"));
        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,12,status,0); // could not link hardware hive to master hive
    }
    CmpAddToHiveFileList(HardwareHive);

    ExFreePool(SecurityDescriptor);

    CmpMachineHiveList[0].CmHive = HardwareHive;

    //
    // put loader configuration tree data to our hardware registry.
    //
    status = CmpInitializeHardwareConfiguration(LoaderBlock);

    if (!NT_SUCCESS(status)) {
        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,13,status,0); // could not initialize hardware configuration
    }

    CmpNoMasterCreates = TRUE;
    CmpUnlockRegistry();

    //
    // put machine dependent configuration data to our hardware registry.
    //
    status = CmpInitializeMachineDependentConfiguration(LoaderBlock);
    if (!NT_SUCCESS(status)) {
        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,14,status,0); // could not open CurrentControlSet\\Control
    }

    //
    // Write system start options to registry
    //
    status = CmpSetSystemValues(LoaderBlock);
    if (!NT_SUCCESS(status)) {
        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,15,status,0);
    }

    ExFreePool(CmpLoadOptions.Buffer);

    //
    // Write Network LoaderBlock values to registry
    //
    if ( (LoaderBlock->Extension->Size >=
            RTL_SIZEOF_THROUGH_FIELD(LOADER_PARAMETER_EXTENSION, NetworkLoaderBlock)) &&
         (LoaderBlock->Extension->NetworkLoaderBlock != NULL) ) {
        status = CmpSetNetworkValue(LoaderBlock->Extension->NetworkLoaderBlock);
        if (!NT_SUCCESS(status)) {
            CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM1,16,status,0);
        }
    }
    
    return TRUE;
}

//
// All parallel threads will get this shared, and CmpInitializeHiveList will wait for it exclusive
//
KEVENT  CmpLoadWorkerEvent;
LONG   CmpLoadWorkerIncrement = 0;
KEVENT  CmpLoadWorkerDebugEvent;

VOID
CmpInitializeHiveList(
    VOID
    )
/*++

Routine Description:

    This function is called to map hive files to hives.  It both
    maps existing hives to files, and creates new hives from files.

    It operates on files in "\SYSTEMROOT\CONFIG".

    NOTE:   MUST run in the context of the process that the CmpWorker
            thread runs in.  Caller is expected to arrange this.

    NOTE:   Will bugcheck on failure.

Arguments:

Return Value:

    NONE.

--*/
{
    #define MAX_NAME    128
    HANDLE  Thread;
    NTSTATUS Status;

    UCHAR   FileBuffer[MAX_NAME];
    UCHAR   RegBuffer[MAX_NAME];

    UNICODE_STRING TempName;
    UNICODE_STRING FileName;
    UNICODE_STRING RegName;

    USHORT  FileStart;
    USHORT  RegStart;
    ULONG   i;
    PSECURITY_DESCRIPTOR SecurityDescriptor;

    
    CM_PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INIT,"CmpInitializeHiveList\n"));

    CmpNoWrite = FALSE;

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

    FileName.MaximumLength = MAX_NAME;
    FileName.Length = 0;
    FileName.Buffer = (PWSTR)&(FileBuffer[0]);

    RegName.MaximumLength = MAX_NAME;
    RegName.Length = 0;
    RegName.Buffer = (PWSTR)&(RegBuffer[0]);

    RtlInitUnicodeString(
        &TempName,
        INIT_SYSTEMROOT_HIVEPATH
        );
    RtlAppendStringToString((PSTRING)&FileName, (PSTRING)&TempName);
    FileStart = FileName.Length;

    RtlInitUnicodeString(
        &TempName,
        INIT_REGISTRY_MASTERPATH
        );
    RtlAppendStringToString((PSTRING)&RegName, (PSTRING)&TempName);
    RegStart = RegName.Length;

    //
    // Initialize the synchronization event
    //
    KeInitializeEvent (&CmpLoadWorkerEvent, SynchronizationEvent, FALSE);
    KeInitializeEvent (&CmpLoadWorkerDebugEvent, SynchronizationEvent, FALSE);
    
    CmpSpecialBootCondition = TRUE;

    SecurityDescriptor = CmpHiveRootSecurityDescriptor();

    if (CmpShareSystemHives) {
        for (i = 0; i < CM_NUMBER_OF_MACHINE_HIVES; i++) {
            if (CmpMachineHiveList[i].Name) {
                CmpMachineHiveList[i].HHiveFlags |= HIVE_VOLATILE;
            }
        }
    }        

    for (i = 0; i < CM_NUMBER_OF_MACHINE_HIVES; i++) {
        ASSERT( CmpMachineHiveList[i].Name != NULL );
        //
        // just spawn the Threads to load the hives in parallel
        //
        Status = PsCreateSystemThread(
            &Thread,
            THREAD_ALL_ACCESS,
            NULL,
            0,
            NULL,
            CmpLoadHiveThread,
            (PVOID)(ULONG_PTR)(ULONG)i
            );

        if (NT_SUCCESS(Status)) {
            ZwClose(Thread);
        } else {
            //
            // cannot spawn thread; Fatal error
            //
            CM_BUGCHECK(BAD_SYSTEM_CONFIG_INFO,BAD_HIVE_LIST,3,i,Status);
        }
    }
    ASSERT( CmpMachineHiveList[i].Name == NULL );

    KeWaitForSingleObject( &CmpLoadWorkerEvent,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );
    
    CmpSpecialBootCondition = FALSE;
    ASSERT( CmpLoadWorkerIncrement == CM_NUMBER_OF_MACHINE_HIVES );
    //
    // Now add all hives to the hivelist
    //
    for (i = 0; i < CM_NUMBER_OF_MACHINE_HIVES; i++) {        
        ASSERT( CmpMachineHiveList[i].ThreadFinished == TRUE );
        ASSERT( CmpMachineHiveList[i].ThreadStarted == TRUE );

        if (CmpMachineHiveList[i].CmHive == NULL) {
            
            ASSERT( CmpMachineHiveList[i].CmHive2 != NULL );

            //
            // Compute the name of the file, and the name to link to in
            // the registry.
            //

            // REGISTRY

            RegName.Length = RegStart;
            RtlInitUnicodeString(
                &TempName,
                CmpMachineHiveList[i].BaseName
                );
            RtlAppendStringToString((PSTRING)&RegName, (PSTRING)&TempName);

            // REGISTRY\MACHINE or REGISTRY\USER

            if (RegName.Buffer[ (RegName.Length / sizeof( WCHAR )) - 1 ] == '\\') {
                RtlInitUnicodeString(
                    &TempName,
                    CmpMachineHiveList[i].Name
                    );
                RtlAppendStringToString((PSTRING)&RegName, (PSTRING)&TempName);
            }

            // REGISTRY\[MACHINE|USER]\HIVE

            // <sysroot>\config


            //
            // Link hive into master hive
            //
            Status = CmpLinkHiveToMaster(
                    &RegName,
                    NULL,
                    CmpMachineHiveList[i].CmHive2,
                    CmpMachineHiveList[i].Allocate,
                    SecurityDescriptor
                    );
            if ( Status != STATUS_SUCCESS)
            {

                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpInitializeHiveList: "));
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpLinkHiveToMaster failed\n"));
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"\ti=%d s='%ws'\n", i, CmpMachineHiveList[i]));

                CM_BUGCHECK(CONFIG_LIST_FAILED,BAD_CORE_HIVE,Status,i,&RegName);
            }

			if( CmpMachineHiveList[i].Allocate == TRUE ) {
				HvSyncHive((PHHIVE)(CmpMachineHiveList[i].CmHive2));
			}
           
        } else {
            //
            // do nothing here as all of it has been done in separate thread.
            //
        }

        if( CmpMachineHiveList[i].CmHive2 != NULL ) {
            CmpAddToHiveFileList(CmpMachineHiveList[i].CmHive2);
        }

    }   // for

    ExFreePool(SecurityDescriptor);

    //
    // Create symbolic link from SECURITY hive into SAM hive.
    //
    CmpLinkKeyToHive(
        L"\\Registry\\Machine\\Security\\SAM",
        L"\\Registry\\Machine\\SAM\\SAM"
        );

    //
    // Create symbolic link from S-1-5-18 to .Default 
    //
    CmpNoMasterCreates = FALSE;     
    CmpLinkKeyToHive(
        L"\\Registry\\User\\S-1-5-18",
        L"\\Registry\\User\\.Default"
        );
    CmpNoMasterCreates = TRUE;     

    //
    // Create predefined handles.
    //
    CmpCreatePerfKeys();

    return;
}

NTSTATUS
CmpCreateObjectTypes(
    VOID
    )
/*++

Routine Description:

    Create the Key object type

Arguments:

    NONE.

Return Value:

    Status of the ObCreateType call

--*/
{
   NTSTATUS Status;
   OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
   UNICODE_STRING TypeName;

   //
   // Structure that describes the mapping of generic access rights to object
   // specific access rights for registry key objects.
   //

   GENERIC_MAPPING CmpKeyMapping = {
      KEY_READ,
      KEY_WRITE,
      KEY_EXECUTE,
      KEY_ALL_ACCESS
   };

    CM_PAGED_CODE();
    //
    // --- Create the registry key object type ---
    //

    //
    // Initialize string descriptor.
    //

    RtlInitUnicodeString(&TypeName, L"Key");

    //
    // Create key object type descriptor.
    //

    RtlZeroMemory(&ObjectTypeInitializer, sizeof(ObjectTypeInitializer));
    ObjectTypeInitializer.Length = sizeof(ObjectTypeInitializer);
    ObjectTypeInitializer.InvalidAttributes = CMP_KEY_INVALID_ATTRIBUTES;
    ObjectTypeInitializer.GenericMapping = CmpKeyMapping;
    ObjectTypeInitializer.ValidAccessMask = KEY_ALL_ACCESS;
    ObjectTypeInitializer.DefaultPagedPoolCharge = sizeof(CM_KEY_BODY);
    ObjectTypeInitializer.SecurityRequired = TRUE;
    ObjectTypeInitializer.PoolType = PagedPool;
    ObjectTypeInitializer.MaintainHandleCount = FALSE;
    ObjectTypeInitializer.UseDefaultObject = TRUE;

    ObjectTypeInitializer.DumpProcedure = NULL;
    ObjectTypeInitializer.OpenProcedure = NULL;
    ObjectTypeInitializer.CloseProcedure = CmpCloseKeyObject;
    ObjectTypeInitializer.DeleteProcedure = CmpDeleteKeyObject;
    ObjectTypeInitializer.ParseProcedure = CmpParseKey;
    ObjectTypeInitializer.SecurityProcedure = CmpSecurityMethod;
    ObjectTypeInitializer.QueryNameProcedure = CmpQueryKeyName;

    Status = ObCreateObjectType(
                &TypeName,
                &ObjectTypeInitializer,
                (PSECURITY_DESCRIPTOR)NULL,
                &CmpKeyObjectType
                );


    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpCreateObjectTypes: "));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"ObCreateObjectType(Key) failed %08lx\n", Status));
    }

    return Status;
}



BOOLEAN
CmpCreateRegistryRoot(
    VOID
    )
/*++

Routine Description:

    Manually create \REGISTRY in the master hive, create a key
    object to refer to it, and insert the key object into
    the root (\) of the object space.

Arguments:

    None

Return Value:

    TRUE == success, FALSE == failure

--*/
{
    NTSTATUS                Status;
    PVOID                   ObjectPointer;
    PCM_KEY_BODY            Object;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    PCM_KEY_CONTROL_BLOCK   kcb;
    HCELL_INDEX             RootCellIndex;
    PSECURITY_DESCRIPTOR    SecurityDescriptor;
    PCM_KEY_NODE            TempNode;

    CM_PAGED_CODE();
    //
    // --- Create hive entry for \REGISTRY ---
    //

    if (!CmpCreateRootNode(
            &(CmpMasterHive->Hive), L"REGISTRY", &RootCellIndex))
    {
        return FALSE;
    }

    //
    // --- Create a KEY object that refers to \REGISTRY ---
    //


    //
    // Create the object manager object
    //

    //
    // WARNING: \\REGISTRY is not in pool, so if anybody ever tries to
    //          free it, we are in deep trouble.  On the other hand,
    //          this implies somebody has removed \\REGISTRY from the
    //          root, so we're in trouble anyway.
    //

    SecurityDescriptor = CmpHiveRootSecurityDescriptor();

    InitializeObjectAttributes(
        &ObjectAttributes,
        &CmRegistryRootName,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        SecurityDescriptor
        );


    Status = ObCreateObject(
        KernelMode,
        CmpKeyObjectType,
        &ObjectAttributes,
        UserMode,
        NULL,                   // Parse context
        sizeof(CM_KEY_BODY),
        0,
        0,
        (PVOID *)&Object
        );

    ExFreePool(SecurityDescriptor);

    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpCreateRegistryRoot: "));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"ObCreateObject(\\REGISTRY) failed %08lx\n", Status));
        return FALSE;
    }

    ASSERT( (&CmpMasterHive->Hive)->ReleaseCellRoutine == NULL );
    TempNode = (PCM_KEY_NODE)HvGetCell(&CmpMasterHive->Hive,RootCellIndex);
    if( TempNode == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        return FALSE;
    }
    //
    // Create the key control block
    //
    kcb = CmpCreateKeyControlBlock(
            &(CmpMasterHive->Hive),
            RootCellIndex,
            TempNode,
            NULL,
            0,
            &CmRegistryRootName
            );

    if (kcb==NULL) {
        return(FALSE);
    }

    //
    // Initialize the type specific body
    //
    Object->Type = KEY_BODY_TYPE;
    Object->KeyControlBlock = kcb;
    Object->NotifyBlock = NULL;
    Object->ProcessID = PsGetCurrentProcessId();
    EnlistKeyBodyWithKCB(Object,0);

    //
    // Put the object in the root directory
    //
    Status = ObInsertObject(
                Object,
                NULL,
                (ACCESS_MASK)0,
                0,
                NULL,
                &CmpRegistryRootHandle
                );

    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpCreateRegistryRoot: "));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"ObInsertObject(\\REGISTRY) failed %08lx\n", Status));
        return FALSE;
    }

    //
    // We cannot make the root permanent because registry objects in
    // general are not allowed to be.  (They're stable via virtue of being
    // stored in the registry, not the object manager.)  But we never
    // ever want the root to go away.  So reference it.
    //
    if (! NT_SUCCESS(Status = ObReferenceObjectByHandle(
                        CmpRegistryRootHandle,
                        KEY_READ,
                        NULL,
                        KernelMode,
                        &ObjectPointer,
                        NULL
                        )))
    {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpCreateRegistryRoot: "));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"ObReferenceObjectByHandle failed %08lx\n", Status));
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
CmpCreateRootNode(
    IN PHHIVE   Hive,
    IN PWSTR    Name,
    OUT PHCELL_INDEX RootCellIndex
    )
/*++

Routine Description:

    Manually create the root node of a hive.

Arguments:

    Hive - pointer to a Hive (Hv level) control structure

    Name - pointer to a unicode name string

    RootCellIndex - supplies pointer to a variable to receive
                    the cell index of the created node.

Return Value:

    TRUE == success, FALSE == failure

--*/
{
    UNICODE_STRING temp;
    PCELL_DATA CellData;
    CM_KEY_REFERENCE Key;
    LARGE_INTEGER systemtime;

    CM_PAGED_CODE();
    //
    // Allocate the node.
    //
    RtlInitUnicodeString(&temp, Name);
    *RootCellIndex = HvAllocateCell(
                Hive,
                CmpHKeyNodeSize(Hive, &temp),
                Stable,
                HCELL_NIL
                );
    if (*RootCellIndex == HCELL_NIL) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpCreateRootNode: HvAllocateCell failed\n"));
        return FALSE;
    }

    Hive->BaseBlock->RootCell = *RootCellIndex;

    CellData = HvGetCell(Hive, *RootCellIndex);
    if( CellData == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        return FALSE;
    }

    //
    // Initialize the node
    //
    CellData->u.KeyNode.Signature = CM_KEY_NODE_SIGNATURE;
    CellData->u.KeyNode.Flags = KEY_HIVE_ENTRY | KEY_NO_DELETE;
    KeQuerySystemTime(&systemtime);
    CellData->u.KeyNode.LastWriteTime = systemtime;
//    CellData->u.KeyNode.TitleIndex = 0;
    CellData->u.KeyNode.Parent = HCELL_NIL;

    CellData->u.KeyNode.SubKeyCounts[Stable] = 0;
    CellData->u.KeyNode.SubKeyCounts[Volatile] = 0;
    CellData->u.KeyNode.SubKeyLists[Stable] = HCELL_NIL;
    CellData->u.KeyNode.SubKeyLists[Volatile] = HCELL_NIL;

    CellData->u.KeyNode.ValueList.Count = 0;
    CellData->u.KeyNode.ValueList.List = HCELL_NIL;
    CellData->u.KeyNode.Security = HCELL_NIL;
    CellData->u.KeyNode.Class = HCELL_NIL;
    CellData->u.KeyNode.ClassLength = 0;

    CellData->u.KeyNode.MaxValueDataLen = 0;
    CellData->u.KeyNode.MaxNameLen = 0;
    CellData->u.KeyNode.MaxValueNameLen = 0;
    CellData->u.KeyNode.MaxClassLen = 0;

    CellData->u.KeyNode.NameLength = CmpCopyName(Hive,
                                                 CellData->u.KeyNode.Name,
                                                 &temp);
    if (CellData->u.KeyNode.NameLength < temp.Length) {
        CellData->u.KeyNode.Flags |= KEY_COMP_NAME;
    }

    Key.KeyHive = Hive;
    Key.KeyCell = *RootCellIndex;

    HvReleaseCell(Hive, *RootCellIndex);

    return TRUE;
}


NTSTATUS
CmpLinkHiveToMaster(
    PUNICODE_STRING LinkName,
    HANDLE RootDirectory,
    PCMHIVE CmHive,
    BOOLEAN Allocate,
    PSECURITY_DESCRIPTOR SecurityDescriptor
    )
/*++

Routine Description:

    The existing, "free floating" hive CmHive describes is linked into
    the name space at the node named by LinkName.  The node will be created.
    The hive is assumed to already have an appropriate root node.

Arguments:

    LinkName - supplies a pointer to a unicode string which describes where
                in the registry name space the hive is to be linked.
                All components but the last must exist.  The last must not.

    RootDirectory - Supplies the handle the LinkName is relative to.

    CmHive - pointer to a CMHIVE structure describing the hive to link in.

    Allocate - TRUE indicates that the root cell is to be created
               FALSE indicates the root cell already exists.

    SecurityDescriptor - supplies a pointer to the security descriptor to
               be placed on the hive root.

Return Value:

    TRUE == success, FALSE == failure

--*/
{
    OBJECT_ATTRIBUTES   ObjectAttributes;
    HANDLE              KeyHandle;
    CM_PARSE_CONTEXT    ParseContext;
    NTSTATUS            Status;
    PCM_KEY_BODY        KeyBody;

    CM_PAGED_CODE();

    //
    // Fill in special ParseContext to indicate that we are creating
    // a link node and opening or creating a root node.
    //
    ParseContext.TitleIndex = 0;
    ParseContext.Class.Length = 0;
    ParseContext.Class.MaximumLength = 0;
    ParseContext.Class.Buffer = NULL;
    ParseContext.CreateOptions = 0;
    ParseContext.CreateLink = TRUE;
    ParseContext.ChildHive.KeyHive = &CmHive->Hive;
    ParseContext.CreateOperation = TRUE;
    ParseContext.OriginatingPoint = NULL;
    if (Allocate) {
        //
        // Creating a new root node
        //
        ParseContext.ChildHive.KeyCell = HCELL_NIL;
    } else {
        //
        // Opening an existing root node
        //
        ParseContext.ChildHive.KeyCell = CmHive->Hive.BaseBlock->RootCell;
    }

    //
    // Create a path to the hive
    //
    InitializeObjectAttributes(
        &ObjectAttributes,
        LinkName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        (HANDLE)RootDirectory,
        SecurityDescriptor
        );

    Status = ObOpenObjectByName( &ObjectAttributes,
                                 CmpKeyObjectType,
                                 KernelMode,
                                 NULL,
                                 KEY_READ | KEY_WRITE,
                                 (PVOID)&ParseContext,
                                 &KeyHandle );

    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpLinkHiveToMaster: "));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"ObOpenObjectByName() failed %08lx\n", Status));
        return Status;
    }

    //
    // mark hive as "clean" 
    //
    CmHive->Hive.DirtyFlag = FALSE;

    //
    // Report the notification event
    //
    Status = ObReferenceObjectByHandle(KeyHandle,
                                       0,
                                       CmpKeyObjectType,
                                       KernelMode,
                                       (PVOID *)&KeyBody,
                                       NULL);
    ASSERT(NT_SUCCESS(Status));
    if (NT_SUCCESS(Status)) {
        CmpReportNotify(KeyBody->KeyControlBlock,
                        KeyBody->KeyControlBlock->KeyHive,
                        KeyBody->KeyControlBlock->KeyCell,
                        REG_NOTIFY_CHANGE_NAME);

        ObDereferenceObject((PVOID)KeyBody);
    }

    ZwClose(KeyHandle);
    return STATUS_SUCCESS;
}


NTSTATUS
CmpInterlockedFunction (
    PWCHAR RegistryValueKey,
    VOID (*InterlockedFunction)(VOID)
    )
/*++

Routine Description:

    This routine guards calling the InterlockedFunction in the
    passed RegistryValueKey.

    The RegistryValueKey will record the status of the first
    call to the InterlockedFunction.  If the system crashes
    during this call then ValueKey will be left in a state
    where the InterlockedFunction will not be called on subsequent
    attempts.

Arguments:

    RegistryValueKey - ValueKey name for Control\Session Manager
    InterlockedFunction - Function to call

Return Value:

    STATUS_SUCCESS  - The interlocked function was successfully called


--*/
{
    OBJECT_ATTRIBUTES   objectAttributes;
    HANDLE              hControl, hSession;
    UNICODE_STRING      Name;
    UCHAR               Buffer [sizeof(KEY_VALUE_PARTIAL_INFORMATION)+sizeof(ULONG)];
    ULONG               length, Value;
    NTSTATUS            status;

    CM_PAGED_CODE();

    //
    // Open CurrentControlSet
    //

    InitializeObjectAttributes (
        &objectAttributes,
        &CmRegistryMachineSystemCurrentControlSet,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtOpenKey (&hControl, KEY_READ | KEY_WRITE, &objectAttributes);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Open Control\Session Manager
    //

    RtlInitUnicodeString (&Name, CmpControlSessionManager);
    InitializeObjectAttributes (
        &objectAttributes,
        &Name,
        OBJ_CASE_INSENSITIVE,
        hControl,
        NULL
        );

    status = NtOpenKey (&hSession, KEY_READ | KEY_WRITE, &objectAttributes );
    NtClose (hControl);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Read ValueKey to interlock operation with
    //

    RtlInitUnicodeString (&Name, RegistryValueKey);
    status = NtQueryValueKey (hSession,
                              &Name,
                              KeyValuePartialInformation,
                              Buffer,
                              sizeof (Buffer),
                              &length );

    Value = 0;
    if (NT_SUCCESS(status)) {
        Value = ((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data[0];
    }

    //
    // Value 0  - Before InterlockedFunction
    //       1  - In the middle of InterlockedFunction
    //       2  - After InterlockedFunction
    //
    // If the value is a 0, then we haven't tried calling this
    // interlocked function, set the value to a 1 and try it.
    //
    // If the value is a 1, then we crased during an execution
    // of the interlocked function last time, don't try it again.
    //
    // If the value is a 2, then we called the interlocked function
    // before and it worked.  Call it again this time.
    //

    if (Value != 1) {

        if (Value != 2) {
            //
            // This interlocked function is not known to work.  Write
            // a 1 to this value so we can detect if we crash during
            // this call.
            //

            Value = 1;
            NtSetValueKey (hSession, &Name, 0L, REG_DWORD, &Value, sizeof (Value));
            NtFlushKey    (hSession);   // wait until it's on the disk
        }

        InterlockedFunction();

        if (Value != 2) {
            //
            // The worker function didn't crash - update the value for
            // this interlocked function to 2.
            //

            Value = 2;
            NtSetValueKey (hSession, &Name, 0L, REG_DWORD, &Value, sizeof (Value));
        }

    } else {
        status = STATUS_UNSUCCESSFUL;
    }

    NtClose (hSession);
    return status;
}

VOID
CmpConfigureProcessors (
    VOID
    )

/*++

Routine Description:

    Set each processor to it's optimal settings for NT.

--*/

{

#if defined(_X86_)

    ULONG   i;

    CM_PAGED_CODE();

    //
    // Set each processor into its best NT configuration
    //

    for (i=0; i < (ULONG)KeNumberProcessors; i++) {
        KeSetSystemAffinityThread(AFFINITY_MASK(i));
        KeOptimizeProcessorControlState ();
    }

    //
    // Restore threads affinity
    //

    KeRevertToUserAffinityThread();

#endif

    return;
}

BOOLEAN
CmpInitializeSystemHive(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    Initializes the SYSTEM hive based on the raw hive image passed in
    from the OS Loader.

Arguments:

    LoaderBlock - Supplies a pointer to the Loader Block passed in by
        the OS Loader.

Return Value:

    TRUE - it worked

    FALSE - it failed

--*/

{
    PCMHIVE SystemHive;
    PVOID HiveImageBase;
    BOOLEAN Allocate=FALSE;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    NTSTATUS Status;
    STRING  TempString;


    CM_PAGED_CODE();

    //
    // capture tail of boot.ini line (load options, portable)
    //
    RtlInitAnsiString(
        &TempString,
        LoaderBlock->LoadOptions
        );

    CmpLoadOptions.Length = 0;
    CmpLoadOptions.MaximumLength = (TempString.Length+1)*sizeof(WCHAR);
    CmpLoadOptions.Buffer = ExAllocatePool(
                                PagedPool, (TempString.Length+1)*sizeof(WCHAR));

    if (CmpLoadOptions.Buffer == NULL) {
        CM_BUGCHECK(BAD_SYSTEM_CONFIG_INFO,BAD_SYSTEM_HIVE,1,LoaderBlock,0);
    }
    RtlAnsiStringToUnicodeString(
        &CmpLoadOptions,
        &TempString,
        FALSE
        );
    CmpLoadOptions.Buffer[TempString.Length] = UNICODE_NULL;
    CmpLoadOptions.Length += sizeof(WCHAR);


    //
    // move the loaded registry into the real registry
    //
    HiveImageBase = LoaderBlock->RegistryBase;

    //
    // We need to initialize the system hive as NO_LAZY_FLUSH
    //  - this is just temporary, until we get a chance to open the primary
    // file for the hive. Failure to do so, will result in loss of data on the
    // LazyFlush worker (see CmpFileWrite, the
    //          if (FileHandle == NULL) {
    //              return TRUE;
    //          }
    // test. This might be a problem in 5.0 too, if system crashes between the
    // LazyFlush reported the hive as saved and the moment we actually open the
    // file and save it again
    //
    if (HiveImageBase == NULL) {
        //
        // No memory descriptor for the hive, so we must recreate it.
        //
        Status = CmpInitializeHive(&SystemHive,
                    HINIT_CREATE,
                    HIVE_NOLAZYFLUSH,
                    HFILE_TYPE_LOG,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &CmpSystemFileName,
                    0);
        if (!NT_SUCCESS(Status)) {

            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpInitializeSystemHive: "));
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"Couldn't initialize newly allocated SYSTEM hive\n"));

            return(FALSE);
        }
        Allocate = TRUE;

    } else {

        //
        // There is a memory image for the hive, copy it and make it active
        //
        Status = CmpInitializeHive(&SystemHive,
                    HINIT_MEMORY,
                    HIVE_NOLAZYFLUSH,
                    HFILE_TYPE_LOG,
                    HiveImageBase,
                    NULL,
                    NULL,
                    NULL,
                    &CmpSystemFileName,
                    CM_CHECK_REGISTRY_SYSTEM_CLEAN);
        if (!NT_SUCCESS(Status)) {

            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpInitializeSystemHive: "));
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"Couldn't initialize OS Loader-loaded SYSTEM hive\n"));

            CM_BUGCHECK(BAD_SYSTEM_CONFIG_INFO,BAD_SYSTEM_HIVE,2,SystemHive,Status);
        }

        Allocate = FALSE;

        //
        // Mark the system hive as volatile, while in MiniNT boot
        // case
        //
        if (CmpShareSystemHives) {
            SystemHive->Hive.HiveFlags = HIVE_VOLATILE;
        }
    }

    CmpBootType = SystemHive->Hive.BaseBlock->BootType;

    if( !CmSelfHeal ) {

        CmpSelfHeal = FALSE;

        if(CmpBootType & HBOOT_SELFHEAL)  {
            //
            // self healing disabled; but loader has detected corrupted system hive
            //
            CM_BUGCHECK(BAD_SYSTEM_CONFIG_INFO,BAD_SYSTEM_HIVE,3,SystemHive,0);
        }
    }

    //
    // Create the link node
    //
    SecurityDescriptor = CmpHiveRootSecurityDescriptor();

    Status = CmpLinkHiveToMaster(&CmRegistryMachineSystemName,
                                 NULL,
                                 SystemHive,
                                 Allocate,
                                 SecurityDescriptor);
    ExFreePool(SecurityDescriptor);

    if (!NT_SUCCESS(Status)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmInitSystem1: CmpLinkHiveToMaster(Hardware) failed\n"));

        return(FALSE);
    }

    CmpMachineHiveList[SYSTEM_HIVE_INDEX].CmHive = SystemHive;

    return(TRUE);
}


PHANDLE
CmGetSystemDriverList(
    VOID
    )

/*++

Routine Description:

    Traverses the current SERVICES subtree and creates the list of drivers
    to be loaded during Phase 1 initialization.

Arguments:

    None

Return Value:

    A pointer to an array of handles, each of which refers to a key in
    the \Services section of the control set.  The caller will traverse
    this array and load and initialize the drivers described by the keys.

    The last key will be NULL.  The array is allocated in Pool and should
    be freed by the caller.

--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE SystemHandle;
    UNICODE_STRING Name;
    NTSTATUS Status;
    PCM_KEY_BODY KeyBody;
    LIST_ENTRY DriverList;
    PHHIVE Hive;
    HCELL_INDEX RootCell;
    HCELL_INDEX ControlCell;
    ULONG DriverCount;
    PLIST_ENTRY Current;
    PHANDLE Handle;
    PBOOT_DRIVER_LIST_ENTRY DriverEntry;
    BOOLEAN Success;
    BOOLEAN AutoSelect;

    CM_PAGED_CODE();
    InitializeListHead(&DriverList);
    RtlInitUnicodeString(&Name,
                         L"\\Registry\\Machine\\System");

    InitializeObjectAttributes(&ObjectAttributes,
                               &Name,
                               OBJ_CASE_INSENSITIVE,
                               (HANDLE)NULL,
                               NULL);
    Status = NtOpenKey(&SystemHandle,
                       KEY_READ,
                       &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmGetSystemDriverList couldn't open registry key %wZ\n",&Name));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM:     status %08lx\n", Status));

        return(NULL);
    }


    Status = ObReferenceObjectByHandle( SystemHandle,
                                        KEY_QUERY_VALUE,
                                        CmpKeyObjectType,
                                        KernelMode,
                                        (PVOID *)(&KeyBody),
                                        NULL );
    if (!NT_SUCCESS(Status)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmGetSystemDriverList couldn't dereference System handle\n"));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM:     status %08lx\n", Status));

        NtClose(SystemHandle);
        return(NULL);
    }

    CmpLockRegistryExclusive();

    Hive = KeyBody->KeyControlBlock->KeyHive;
    RootCell = KeyBody->KeyControlBlock->KeyCell;

    //
    // Now we have found out the PHHIVE and HCELL_INDEX of the root of the
    // SYSTEM hive, we can use all the same code that the OS Loader does.
    //

    RtlInitUnicodeString(&Name, L"Current");
    ControlCell = CmpFindControlSet(Hive,
                                    RootCell,
                                    &Name,
                                    &AutoSelect);
    if (ControlCell == HCELL_NIL) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmGetSystemDriverList couldn't find control set\n"));

        CmpUnlockRegistry();
        ObDereferenceObject((PVOID)KeyBody);
        NtClose(SystemHandle);
        return(NULL);
    }

    Success = CmpFindDrivers(Hive,
                             ControlCell,
                             SystemLoad,
                             NULL,
                             &DriverList);


    if (!Success) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmGetSystemDriverList couldn't find any valid drivers\n"));

        CmpFreeDriverList(Hive, &DriverList);
        CmpUnlockRegistry();
        ObDereferenceObject((PVOID)KeyBody);
        NtClose(SystemHandle);
        return(NULL);
    }

    if (!CmpSortDriverList(Hive,
                           ControlCell,
                           &DriverList)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmGetSystemDriverList couldn't sort driver list\n"));

        CmpFreeDriverList(Hive, &DriverList);
        CmpUnlockRegistry();
        ObDereferenceObject((PVOID)KeyBody);
        NtClose(SystemHandle);
        return(NULL);
    }

    if (!CmpResolveDriverDependencies(&DriverList)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmGetSystemDriverList couldn't resolve driver dependencies\n"));

        CmpFreeDriverList(Hive, &DriverList);
        CmpUnlockRegistry();
        ObDereferenceObject((PVOID)KeyBody);
        NtClose(SystemHandle);
        return(NULL);
    }
    CmpUnlockRegistry();
    ObDereferenceObject((PVOID)KeyBody);
    NtClose(SystemHandle);

    //
    // We now have a fully sorted and ordered list of drivers to be loaded
    // by IoInit.
    //

    //
    // Count the nodes in the list.
    //
    Current = DriverList.Flink;
    DriverCount = 0;
    while (Current != &DriverList) {
        ++DriverCount;
        Current = Current->Flink;
    }

    Handle = (PHANDLE)ExAllocatePool(NonPagedPool,
                                     (DriverCount+1) * sizeof(HANDLE));

    if (Handle == NULL) {
        CM_BUGCHECK(CONFIG_INITIALIZATION_FAILED,INIT_SYSTEM_DRIVER_LIST,1,0,0); // odds against this are huge
    }

    //
    // Walk the list, opening each registry key and adding it to the
    // table of handles.
    //
    Current = DriverList.Flink;
    DriverCount = 0;
    while (Current != &DriverList) {
        DriverEntry = CONTAINING_RECORD(Current,
                                        BOOT_DRIVER_LIST_ENTRY,
                                        Link);

        InitializeObjectAttributes(&ObjectAttributes,
                                   &DriverEntry->RegistryPath,
                                   OBJ_CASE_INSENSITIVE,
                                   (HANDLE)NULL,
                                   NULL);

        Status = NtOpenKey(Handle+DriverCount,
                           KEY_READ | KEY_WRITE,
                           &ObjectAttributes);
        if (!NT_SUCCESS(Status)) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmGetSystemDriverList couldn't open driver "));
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"key %wZ\n", &DriverEntry->RegistryPath));
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"    status %08lx\n",Status));
        } else {
            ++DriverCount;
        }
        Current = Current->Flink;
    }
    Handle[DriverCount] = NULL;

    CmpFreeDriverList(Hive, &DriverList);

    return(Handle);
}


VOID
CmpFreeDriverList(
    IN PHHIVE Hive,
    IN PLIST_ENTRY DriverList
    )

/*++

Routine Description:

    Walks down the driver list, freeing each node in it.

    Note that this calls the hive's free routine pointer to free the memory.

Arguments:

    Hive - Supplies  a pointer to the hive control structure.

    DriverList - Supplies a pointer to the head of the Driver List.  Note
            that the head of the list is not actually freed, only all the
            entries in the list.

Return Value:

    None.

--*/

{
    PLIST_ENTRY         Next;
    PLIST_ENTRY         Current;
    PBOOT_DRIVER_NODE   DriverNode;

    CM_PAGED_CODE();
    Current = DriverList->Flink;
    while (Current != DriverList) {
        Next = Current->Flink;
        DriverNode = (PBOOT_DRIVER_NODE)Current;
        if( DriverNode->Name.Buffer != NULL ){
            (Hive->Free)(DriverNode->Name.Buffer,DriverNode->Name.Length);
        }
        if( DriverNode->ListEntry.RegistryPath.Buffer != NULL ){
            (Hive->Free)(DriverNode->ListEntry.RegistryPath.Buffer,DriverNode->ListEntry.RegistryPath.MaximumLength);
        }
        if( DriverNode->ListEntry.FilePath.Buffer != NULL ){
            (Hive->Free)(DriverNode->ListEntry.FilePath.Buffer,DriverNode->ListEntry.FilePath.MaximumLength);
        }
        (Hive->Free)((PVOID)Current, sizeof(BOOT_DRIVER_NODE));
        Current = Next;
    }
}


NTSTATUS
CmpInitHiveFromFile(
    IN PUNICODE_STRING FileName,
    IN ULONG HiveFlags,
    OUT PCMHIVE *CmHive,
    IN OUT PBOOLEAN Allocate,
    IN  ULONG       CheckFlags
    )

/*++

Routine Description:

    This routine opens a file and log, allocates a CMHIVE, and initializes
    it.

Arguments:

    FileName - Supplies name of file to be loaded.

    HiveFlags - Supplies hive flags to be passed to CmpInitializeHive

    CmHive   - Returns pointer to initialized hive (if successful)

    Allocate - IN: if TRUE ok to allocate, if FALSE hive must exist
                    (but .log may get created)
               OUT: TRUE if actually created hive, FALSE if existed before

Return Value:

    NTSTATUS

--*/

{
    PCMHIVE         NewHive;
    ULONG           Disposition;
    ULONG           SecondaryDisposition;
    HANDLE          PrimaryHandle;
    HANDLE          LogHandle;
    NTSTATUS        Status;
    ULONG           FileType;
    ULONG           Operation;
    PVOID           HiveData = NULL;
    BOOLEAN         NoBuffering = FALSE;

    CM_PAGED_CODE();

RetryNoBuffering:

    *CmHive = NULL;

    Status = CmpOpenHiveFiles(FileName,
                              L".LOG",
                              &PrimaryHandle,
                              &LogHandle,
                              &Disposition,
                              &SecondaryDisposition,
                              *Allocate,
                              FALSE,
                              NoBuffering,
                              NULL);

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    if (LogHandle == NULL) {
        FileType = HFILE_TYPE_PRIMARY;
    } else {
        FileType = HFILE_TYPE_LOG;
    }

    if (Disposition == FILE_CREATED) {
        Operation = HINIT_CREATE;
        *Allocate = TRUE;
    } else {
        if( NoBuffering == TRUE ) {
            Operation = HINIT_FILE;
        } else {
            Operation = HINIT_MAPFILE;
        }
        *Allocate = FALSE;
    }

    if (CmpShareSystemHives) {
        FileType = HFILE_TYPE_PRIMARY;

        if (LogHandle) {
            ZwClose(LogHandle);
            LogHandle = NULL;
        }
    }

    if( HvShutdownComplete == TRUE ) {
        ZwClose(PrimaryHandle);
        if (LogHandle != NULL) {
            ZwClose(LogHandle);
        }
        return STATUS_TOO_LATE;        
    }

    Status = CmpInitializeHive(&NewHive,
                                Operation,
                                HiveFlags,
                                FileType,
                                HiveData,
                                PrimaryHandle,
                                LogHandle,
                                NULL,
                                FileName,
                                CheckFlags
                                );

    if (!NT_SUCCESS(Status)) {
        CmpTrackHiveClose = TRUE;
        ZwClose(PrimaryHandle);
        CmpTrackHiveClose = FALSE;
        if (LogHandle != NULL) {
            ZwClose(LogHandle);
        }

        if( Status == STATUS_RETRY ) {
            if( NoBuffering == FALSE ) {
                NoBuffering = TRUE;
                goto RetryNoBuffering;
            }
        }
        return(Status);
    } else {
        *CmHive = NewHive;

        //
        // mark handles as protected. If other kernel component tries to close them ==> bugcheck.
        //
        CmpSetHandleProtection(PrimaryHandle,TRUE);
        if (LogHandle != NULL) {
            CmpSetHandleProtection(LogHandle,TRUE);
        }
        
        //
        // Capture the file name; in case we need it later for double load check
        //
        (*CmHive)->FileUserName.Buffer = ExAllocatePoolWithTag(PagedPool,
                                                            FileName->Length,
                                                            CM_NAME_TAG | PROTECTED_POOL);

        if ((*CmHive)->FileUserName.Buffer) {

            RtlCopyMemory((*CmHive)->FileUserName.Buffer,
                          FileName->Buffer,
                          FileName->Length);

            (*CmHive)->FileUserName.Length = FileName->Length;
            (*CmHive)->FileUserName.MaximumLength = FileName->Length;

        } 
        if(((PHHIVE)(*CmHive))->BaseBlock->BootType & HBOOT_SELFHEAL) {
            //
            // Warn the user;
            //
            CmpRaiseSelfHealWarning(&((*CmHive)->FileUserName));
        }
        return(STATUS_SUCCESS);
    }
}


NTSTATUS
CmpAddDockingInfo (
    IN HANDLE Key,
    IN PROFILE_PARAMETER_BLOCK * ProfileBlock
    )
/*++

Routine Description:

    Write DockID SerialNumber DockState and Capabilities into the given
    registry key.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING name;
    ULONG value;

    CM_PAGED_CODE ();

    value = ProfileBlock->DockingState;
    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_DOCKING_STATE);
    status = NtSetValueKey (Key,
                            &name,
                            0,
                            REG_DWORD,
                            &value,
                            sizeof (value));

    if (!NT_SUCCESS (status)) {
        return status;
    }

    value = ProfileBlock->Capabilities;
    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_CAPABILITIES);
    status = NtSetValueKey (Key,
                            &name,
                            0,
                            REG_DWORD,
                            &value,
                            sizeof (value));

    if (!NT_SUCCESS (status)) {
        return status;
    }

    value = ProfileBlock->DockID;
    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_DOCKID);
    status = NtSetValueKey (Key,
                            &name,
                            0,
                            REG_DWORD,
                            &value,
                            sizeof (value));

    if (!NT_SUCCESS (status)) {
        return status;
    }

    value = ProfileBlock->SerialNumber;
    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_SERIAL_NUMBER);
    status = NtSetValueKey (Key,
                            &name,
                            0,
                            REG_DWORD,
                            &value,
                            sizeof (value));

    if (!NT_SUCCESS (status)) {
        return status;
    }

    return status;
}


NTSTATUS
CmpAddAliasEntry (
    IN HANDLE IDConfigDB,
    IN PROFILE_PARAMETER_BLOCK * ProfileBlock,
    IN ULONG  ProfileNumber
    )
/*++
 *
Routine Description:
    Create an alias entry in the IDConfigDB database for the given
    hardware profile.

    Create the "Alias" key if it does not exist.

Parameters:

    IDConfigDB - Pointer to "..\CurrentControlSet\Control\IDConfigDB"

    ProfileBlock - Description of the current Docking information

    ProfileNumber -

--*/
{
    OBJECT_ATTRIBUTES attributes;
    NTSTATUS        status = STATUS_SUCCESS;
    CHAR            asciiBuffer [128];
    WCHAR           unicodeBuffer [128];
    ANSI_STRING     ansiString;
    UNICODE_STRING  name;
    HANDLE          aliasKey = NULL;
    HANDLE          aliasEntry = NULL;
    ULONG           value;
    ULONG           disposition;
    ULONG           aliasNumber = 0;

    CM_PAGED_CODE ();

    //
    // Find the Alias Key or Create it if it does not already exist.
    //
    RtlInitUnicodeString (&name,CM_HARDWARE_PROFILE_STR_ALIAS);

    InitializeObjectAttributes (&attributes,
                                &name,
                                OBJ_CASE_INSENSITIVE,
                                IDConfigDB,
                                NULL);

    status = NtOpenKey (&aliasKey,
                        KEY_READ | KEY_WRITE,
                        &attributes);

    if (STATUS_OBJECT_NAME_NOT_FOUND == status) {
        status = NtCreateKey (&aliasKey,
                              KEY_READ | KEY_WRITE,
                              &attributes,
                              0, // no title
                              NULL, // no class
                              0, // no options
                              &disposition);
    }

    if (!NT_SUCCESS (status)) {
        aliasKey = NULL;
        goto Exit;
    }

    //
    // Create an entry key
    //

    while (aliasNumber < 200) {
        aliasNumber++;

        sprintf(asciiBuffer, "%04d", aliasNumber);

        RtlInitAnsiString(&ansiString, asciiBuffer);
        name.MaximumLength = sizeof(unicodeBuffer);
        name.Buffer = unicodeBuffer;
        status = RtlAnsiStringToUnicodeString(&name,
                                              &ansiString,
                                              FALSE);
        ASSERT (STATUS_SUCCESS == status);

        InitializeObjectAttributes(&attributes,
                                   &name,
                                   OBJ_CASE_INSENSITIVE,
                                   aliasKey,
                                   NULL);

        status = NtOpenKey (&aliasEntry,
                            KEY_READ | KEY_WRITE,
                            &attributes);

        if (NT_SUCCESS (status)) {
            NtClose (aliasEntry);

        } else if (STATUS_OBJECT_NAME_NOT_FOUND == status) {
            status = STATUS_SUCCESS;
            break;

        } else {
            break;
        }

    }
    if (!NT_SUCCESS (status)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: cmpCreateAliasEntry error finding new set %08lx\n",status));

        aliasEntry = 0;
        goto Exit;
    }

    status = NtCreateKey (&aliasEntry,
                          KEY_READ | KEY_WRITE,
                          &attributes,
                          0,
                          NULL,
                          0,
                          &disposition);

    if (!NT_SUCCESS (status)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: cmpCreateAliasEntry error creating new set %08lx\n",status));

        aliasEntry = 0;
        goto Exit;
    }

    //
    // Write the standard goo
    //
    CmpAddDockingInfo (aliasEntry, ProfileBlock);

    //
    // Write the Profile Number
    //
    value = ProfileNumber;
    RtlInitUnicodeString (&name, CM_HARDWARE_PROFILE_STR_PROFILE_NUMBER);
    status = NtSetValueKey (aliasEntry,
                            &name,
                            0,
                            REG_DWORD,
                            &value,
                            sizeof (value));

Exit:

    if (aliasKey) {
        NtClose (aliasKey);
    }

    if (aliasEntry) {
        NtClose (aliasEntry);
    }

    return status;
}


NTSTATUS
CmpHwprofileDefaultSelect (
    IN  PCM_HARDWARE_PROFILE_LIST ProfileList,
    OUT PULONG ProfileIndexToUse,
    IN  PVOID Context
    )
{
    UNREFERENCED_PARAMETER (ProfileList);
    UNREFERENCED_PARAMETER (Context);

    * ProfileIndexToUse = 0;

    return STATUS_SUCCESS;
}




NTSTATUS
CmpCreateControlSet(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This routine sets up the symbolic links from

        \Registry\Machine\System\CurrentControlSet to
        \Registry\Machine\System\ControlSetNNN

        \Registry\Machine\System\CurrentControlSet\Hardware Profiles\Current to
        \Registry\Machine\System\ControlSetNNN\Hardware Profiles\NNNN

    based on the value of \Registry\Machine\System\Select:Current. and
                          \Registry\Machine\System\ControlSetNNN\Control\IDConfigDB:CurrentConfig

Arguments:

    None

Return Value:

    status

--*/

{
    UNICODE_STRING IDConfigDBName;
    UNICODE_STRING SelectName;
    UNICODE_STRING CurrentName;
    OBJECT_ATTRIBUTES Attributes;
    HANDLE SelectHandle;
    HANDLE CurrentHandle;
    HANDLE IDConfigDB = NULL;
    HANDLE CurrentProfile = NULL;
    HANDLE ParentOfProfile = NULL;
    CHAR AsciiBuffer[128];
    WCHAR UnicodeBuffer[128];
    UCHAR ValueBuffer[128];
    ULONG ControlSet;
    ULONG HWProfile;
    PKEY_VALUE_FULL_INFORMATION Value;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    ULONG ResultLength;
    ULONG Disposition;
    BOOLEAN signalAcpiEvent = FALSE;

    CM_PAGED_CODE();

    RtlInitUnicodeString(&SelectName, L"\\Registry\\Machine\\System\\Select");
    InitializeObjectAttributes(&Attributes,
                               &SelectName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    Status = NtOpenKey(&SelectHandle,
                       KEY_READ,
                       &Attributes);
    if (!NT_SUCCESS(Status)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCreateControlSet: Couldn't open Select node %08lx\n",Status));

        return(Status);
    }

    RtlInitUnicodeString(&CurrentName, L"Current");
    Status = NtQueryValueKey(SelectHandle,
                             &CurrentName,
                             KeyValueFullInformation,
                             ValueBuffer,
                             sizeof(ValueBuffer),
                             &ResultLength);
    NtClose(SelectHandle);
    if (!NT_SUCCESS(Status)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCreateControlSet: Couldn't query Select value %08lx\n",Status));

        return(Status);
    }
    Value = (PKEY_VALUE_FULL_INFORMATION)ValueBuffer;
    ControlSet = *(PULONG)((PUCHAR)Value + Value->DataOffset);

    RtlInitUnicodeString(&CurrentName, L"\\Registry\\Machine\\System\\CurrentControlSet");
    InitializeObjectAttributes(&Attributes,
                               &CurrentName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    Status = NtCreateKey(&CurrentHandle,
                         KEY_CREATE_LINK,
                         &Attributes,
                         0,
                         NULL,
                         REG_OPTION_VOLATILE | REG_OPTION_CREATE_LINK,
                         &Disposition);
    if (!NT_SUCCESS(Status)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCreateControlSet: couldn't create CurrentControlSet %08lx\n",Status));

        return(Status);
    }

    //
    // Check to make sure that the key was created, not just opened.  Since
    // this key is always created volatile, it should never be present in
    // the hive when we boot.
    //
    ASSERT(Disposition == REG_CREATED_NEW_KEY);

    //
    // Create symbolic link for current hardware profile.
    //
    sprintf(AsciiBuffer, "\\Registry\\Machine\\System\\ControlSet%03d", ControlSet);
    RtlInitAnsiString(&AnsiString, AsciiBuffer);

    CurrentName.MaximumLength = sizeof(UnicodeBuffer);
    CurrentName.Buffer = UnicodeBuffer;
    Status = RtlAnsiStringToUnicodeString(&CurrentName,
                                          &AnsiString,
                                          FALSE);
    Status = NtSetValueKey(CurrentHandle,
                           &CmSymbolicLinkValueName,
                           0,
                           REG_LINK,
                           CurrentName.Buffer,
                           CurrentName.Length);

    if (!NT_SUCCESS(Status)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCreateControlSet: couldn't create symbolic link "));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"to %wZ\n",&CurrentName));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"    Status=%08lx\n",Status));

        NtClose(CurrentHandle);

        return(Status);
    }

    //
    // Determine the Current Hardware Profile Number
    //
    RtlInitUnicodeString(&IDConfigDBName, L"Control\\IDConfigDB");
    InitializeObjectAttributes(&Attributes,
                               &IDConfigDBName,
                               OBJ_CASE_INSENSITIVE,
                               CurrentHandle,
                               NULL);
    Status = NtOpenKey(&IDConfigDB,
                       KEY_READ,
                       &Attributes);
    NtClose(CurrentHandle);

    if (!NT_SUCCESS(Status)) {
        IDConfigDB = 0;
        goto Cleanup;
    }

    RtlInitUnicodeString(&CurrentName, L"CurrentConfig");
    Status = NtQueryValueKey(IDConfigDB,
                             &CurrentName,
                             KeyValueFullInformation,
                             ValueBuffer,
                             sizeof(ValueBuffer),
                             &ResultLength);

    if (!NT_SUCCESS(Status) ||
        (((PKEY_VALUE_FULL_INFORMATION)ValueBuffer)->Type != REG_DWORD)) {

        goto Cleanup;
    }

    Value = (PKEY_VALUE_FULL_INFORMATION)ValueBuffer;
    HWProfile = *(PULONG)((PUCHAR)Value + Value->DataOffset);
    //
    // We know now the config set that the user selected.
    // namely: HWProfile.
    //

    RtlInitUnicodeString(
              &CurrentName,
              L"\\Registry\\Machine\\System\\CurrentControlSet\\Hardware Profiles");
    InitializeObjectAttributes(&Attributes,
                               &CurrentName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    Status = NtOpenKey(&ParentOfProfile,
                       KEY_READ,
                       &Attributes);

    if (!NT_SUCCESS (Status)) {
        ParentOfProfile = 0;
        goto Cleanup;
    }

    sprintf(AsciiBuffer, "%04d",HWProfile);
    RtlInitAnsiString(&AnsiString, AsciiBuffer);
    CurrentName.MaximumLength = sizeof(UnicodeBuffer);
    CurrentName.Buffer = UnicodeBuffer;
    Status = RtlAnsiStringToUnicodeString(&CurrentName,
                                          &AnsiString,
                                          FALSE);
    ASSERT (STATUS_SUCCESS == Status);

    InitializeObjectAttributes(&Attributes,
                               &CurrentName,
                               OBJ_CASE_INSENSITIVE,
                               ParentOfProfile,
                               NULL);

    Status = NtOpenKey (&CurrentProfile,
                        KEY_READ | KEY_WRITE,
                        &Attributes);

    if (!NT_SUCCESS (Status)) {
        CurrentProfile = 0;
        goto Cleanup;
    }

    //
    // We need to determine if Value was selected by exact match
    // (TRUE_MATCH) or because the profile selected was aliasable.
    //
    // If aliasable we need to manufacture another alias entry in the
    // alias table.
    //
    // If the profile information is there and not failed then we should
    // mark the Docking state information:
    // (DockID, SerialNumber, DockState, and Capabilities)
    //

    if (NULL != LoaderBlock->Extension) {
        PLOADER_PARAMETER_EXTENSION extension;
        extension = LoaderBlock->Extension;
        switch (extension->Profile.Status) {
        case HW_PROFILE_STATUS_PRISTINE_MATCH:
            //
            // If the selected profile is pristine then we need to clone.
            //
            Status = CmpCloneHwProfile (IDConfigDB,
                                        ParentOfProfile,
                                        CurrentProfile,
                                        HWProfile,
                                        extension->Profile.DockingState,
                                        &CurrentProfile,
                                        &HWProfile);
            if (!NT_SUCCESS (Status)) {
                CurrentProfile = 0;
                goto Cleanup;
            }

            RtlInitUnicodeString(&CurrentName, L"CurrentConfig");
            Status = NtSetValueKey (IDConfigDB,
                                    &CurrentName,
                                    0,
                                    REG_DWORD,
                                    &HWProfile,
                                    sizeof (HWProfile));
            if (!NT_SUCCESS (Status)) {
                goto Cleanup;
            }

            //
            // Fall through
            //
        case HW_PROFILE_STATUS_ALIAS_MATCH:
            //
            // Create the alias entry for this profile.
            //

            Status = CmpAddAliasEntry (IDConfigDB,
                                       &extension->Profile,
                                       HWProfile);

            //
            // Fall through
            //
        case HW_PROFILE_STATUS_TRUE_MATCH:
            //
            // Write DockID, SerialNumber, DockState, and Caps into the current
            // Hardware profile.
            //

            RtlInitUnicodeString (&CurrentName,
                                  CM_HARDWARE_PROFILE_STR_CURRENT_DOCK_INFO);

            InitializeObjectAttributes (&Attributes,
                                        &CurrentName,
                                        OBJ_CASE_INSENSITIVE,
                                        IDConfigDB,
                                        NULL);

            Status = NtCreateKey (&CurrentHandle,
                                  KEY_READ | KEY_WRITE,
                                  &Attributes,
                                  0,
                                  NULL,
                                  REG_OPTION_VOLATILE,
                                  &Disposition);

            ASSERT (STATUS_SUCCESS == Status);

            Status = CmpAddDockingInfo (CurrentHandle, &extension->Profile);

            NtClose(CurrentHandle);

            if (HW_PROFILE_DOCKSTATE_UNDOCKED == extension->Profile.DockingState) {
                signalAcpiEvent = TRUE;
            }

            break;


        case HW_PROFILE_STATUS_SUCCESS:
        case HW_PROFILE_STATUS_FAILURE:
            break;

        default:
            ASSERTMSG ("Invalid Profile status state", FALSE);
        }
    }

    //
    // Create the symbolic link.
    //
    RtlInitUnicodeString(&CurrentName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Hardware Profiles\\Current");
    InitializeObjectAttributes(&Attributes,
                               &CurrentName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    Status = NtCreateKey(&CurrentHandle,
                         KEY_CREATE_LINK,
                         &Attributes,
                         0,
                         NULL,
                         REG_OPTION_VOLATILE | REG_OPTION_CREATE_LINK,
                         &Disposition);
    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCreateControlSet: couldn't create Hardware Profile\\Current %08lx\n",Status));
    } else {
        ASSERT(Disposition == REG_CREATED_NEW_KEY);

        sprintf(AsciiBuffer, "\\Registry\\Machine\\System\\CurrentControlSet\\Hardware Profiles\\%04d",HWProfile);
        RtlInitAnsiString(&AnsiString, AsciiBuffer);
        CurrentName.MaximumLength = sizeof(UnicodeBuffer);
        CurrentName.Buffer = UnicodeBuffer;
        Status = RtlAnsiStringToUnicodeString(&CurrentName,
                                              &AnsiString,
                                              FALSE);
        ASSERT (STATUS_SUCCESS == Status);

        Status = NtSetValueKey(CurrentHandle,
                               &CmSymbolicLinkValueName,
                               0,
                               REG_LINK,
                               CurrentName.Buffer,
                               CurrentName.Length);

        NtClose(CurrentHandle);

        if (!NT_SUCCESS(Status)) {

            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCreateControlSet: couldn't create symbolic link "));
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"to %wZ\n",&CurrentName));
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"    Status=%08lx\n",Status));

        }
    }

    if (signalAcpiEvent) {
        //
        // We are booting in the undocked state.
        // This is interesting because our buddies in PnP cannot tell
        // us when we are booting without a dock.  They can only tell
        // us when they see a hot undock.
        //
        // Therefore in the interest of matching a boot undocked with
        // a hot undock, we need to simulate an acpi undock event.
        //

        PROFILE_ACPI_DOCKING_STATE newDockState;
        HANDLE profile;
        BOOLEAN changed;

        newDockState.DockingState = HW_PROFILE_DOCKSTATE_UNDOCKED;
        newDockState.SerialLength = 2;
        newDockState.SerialNumber[0] = L'\0';

        Status = CmSetAcpiHwProfile (&newDockState,
                                     CmpHwprofileDefaultSelect,
                                     NULL,
                                     &profile,
                                     &changed);

        ASSERT (NT_SUCCESS (Status));
        NtClose (profile);
    }


Cleanup:
    if (IDConfigDB) {
        NtClose (IDConfigDB);
    }
    if (CurrentProfile) {
        NtClose (CurrentProfile);
    }
    if (ParentOfProfile) {
        NtClose (ParentOfProfile);
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
CmpCloneControlSet(
    VOID
    )

/*++

Routine Description:

    First, create a new hive, \registry\machine\clone, which will be
    HIVE_VOLATILE.

    Second, link \Registry\Machine\System\Clone to it.

    Third, tree copy \Registry\Machine\System\CurrentControlSet into
    \Registry\Machine\System\Clone (and thus into the clone hive.)

    When the service controller is done with the clone hive, it can
    simply NtUnloadKey it to free its storage.

Arguments:

    None.  \Registry\Machine\System\CurrentControlSet must already exist.

Return Value:

    NTSTATUS

--*/

{
    UNICODE_STRING Current;
    UNICODE_STRING Clone;
    HANDLE CurrentHandle;
    HANDLE CloneHandle;
    OBJECT_ATTRIBUTES Attributes;
    NTSTATUS Status;
    PCM_KEY_BODY CurrentKey;
    PCM_KEY_BODY CloneKey;
    ULONG Disposition;
    PSECURITY_DESCRIPTOR Security;
    ULONG SecurityLength;

    CM_PAGED_CODE();

    RtlInitUnicodeString(&Current,
                         L"\\Registry\\Machine\\System\\CurrentControlSet");
    RtlInitUnicodeString(&Clone,
                         L"\\Registry\\Machine\\System\\Clone");

    InitializeObjectAttributes(&Attributes,
                               &Current,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    Status = NtOpenKey(&CurrentHandle,
                       KEY_READ,
                       &Attributes);
    if (!NT_SUCCESS(Status)) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCloneControlSet couldn't open CurrentControlSet %08lx\n",Status));

        return(Status);
    }

    //
    // Get the security descriptor from the key so we can create the clone
    // tree with the correct ACL.
    //
    Status = NtQuerySecurityObject(CurrentHandle,
                                   DACL_SECURITY_INFORMATION,
                                   NULL,
                                   0,
                                   &SecurityLength);
    if (Status==STATUS_BUFFER_TOO_SMALL) {
        Security=ExAllocatePool(PagedPool,SecurityLength);
        if (Security!=NULL) {
            Status = NtQuerySecurityObject(CurrentHandle,
                                           DACL_SECURITY_INFORMATION,
                                           Security,
                                           SecurityLength,
                                           &SecurityLength);
            if (!NT_SUCCESS(Status)) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCloneControlSet - NtQuerySecurityObject failed %08lx\n",Status));
                ExFreePool(Security);
                Security=NULL;
            }
        }
    } else {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCloneControlSet - NtQuerySecurityObject returned %08lx\n",Status));
        Security=NULL;
    }

    InitializeObjectAttributes(&Attributes,
                               &Clone,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               Security);
    Status = NtCreateKey(&CloneHandle,
                         KEY_READ | KEY_WRITE,
                         &Attributes,
                         0,
                         NULL,
                         REG_OPTION_VOLATILE,
                         &Disposition);
    if (Security!=NULL) {
        ExFreePool(Security);
    }
    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCloneControlSet couldn't create Clone %08lx\n",Status));
        NtClose(CurrentHandle);
        return(Status);
    }

    //
    // Check to make sure the key was created.  If it already exists,
    // something is wrong.
    //
    if (Disposition != REG_CREATED_NEW_KEY) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCloneControlSet: Clone tree already exists!\n"));

        //
        // WARNNOTE:
        //      If somebody somehow managed to create a key in our way,
        //      they'll thwart last known good.  Tough luck.  Claim it worked and go on.
        //
        Status = STATUS_SUCCESS;
        goto Exit;
    }

    Status = ObReferenceObjectByHandle(CurrentHandle,
                                       KEY_READ,
                                       CmpKeyObjectType,
                                       KernelMode,
                                       (PVOID *)(&CurrentKey),
                                       NULL);
    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCloneControlSet: couldn't reference CurrentHandle %08lx\n",Status));
        goto Exit;
    }

    Status = ObReferenceObjectByHandle(CloneHandle,
                                       KEY_WRITE,
                                       CmpKeyObjectType,
                                       KernelMode,
                                       (PVOID *)(&CloneKey),
                                       NULL);
    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCloneControlSet: couldn't reference CurrentHandle %08lx\n",Status));
        ObDereferenceObject((PVOID)CurrentKey);
        goto Exit;
    }

    CmpLockRegistryExclusive();

    if (CmpCopyTree(CurrentKey->KeyControlBlock->KeyHive,
                    CurrentKey->KeyControlBlock->KeyCell,
                    CloneKey->KeyControlBlock->KeyHive,
                    CloneKey->KeyControlBlock->KeyCell)) {
        //
        // Set the max subkey name property for the new target key.
        //
        CmpRebuildKcbCache(CloneKey->KeyControlBlock);
        Status = STATUS_SUCCESS;
    } else {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpCloneControlSet: tree copy failed.\n"));
        Status = STATUS_REGISTRY_CORRUPT;
    }

    CmpUnlockRegistry();

    ObDereferenceObject((PVOID)CurrentKey);
    ObDereferenceObject((PVOID)CloneKey);

Exit:
    NtClose(CurrentHandle);
    NtClose(CloneHandle);
    return(Status);

}

NTSTATUS
CmpSaveBootControlSet(USHORT ControlSetNum)
/*++

Routine Description:

   This routine is responsible for saving the control set
   used to accomplish the latest boot into a different control
   set (presumably so that the different control set may be
   marked as the LKG control set).

   This routine is called from NtInitializeRegistry when
   a boot is accepted via that routine.

Arguments:

   ControlSetNum - The number of the control set that will
                   be used to save the boot control set.

Return Value:

   NTSTATUS result code from call, among the following:

      STATUS_SUCCESS - everything worked perfectly
      STATUS_REGISTRY_CORRUPT - could not save the boot control set,
                                it is likely that the copy or sync
                                operation used for this save failed
                                and some part of the boot control
                                set was not saved.
--*/
{
   UNICODE_STRING SavedBoot;
   HANDLE BootHandle, SavedBootHandle;
   OBJECT_ATTRIBUTES Attributes;
   NTSTATUS Status;
   PCM_KEY_BODY BootKey, SavedBootKey;
   ULONG Disposition;
   PSECURITY_DESCRIPTOR Security;
   ULONG SecurityLength;
   BOOLEAN CopyRet;
   WCHAR Buffer[128];

   //
   // Figure out where the boot control set is
   //
   InitializeObjectAttributes(&Attributes,
                              &CmRegistryMachineSystemCurrentControlSet,
                              OBJ_CASE_INSENSITIVE,
                              NULL,
                              NULL);

   //
   // Open the boot control set
   //

   Status = NtOpenKey(&BootHandle,
                      KEY_READ,
                      &Attributes);


   if (!NT_SUCCESS(Status)) return(Status);

   //
   // We may be saving the boot control set into a brand new
   // tree that we will create. If this is true, then we will
   // need to create the root node of this tree below
   // and give it the right security descriptor. So, we fish
   // the security descriptor out of the root node of the
   // boot control set tree.
   //

   Status = NtQuerySecurityObject(BootHandle,
                                  DACL_SECURITY_INFORMATION,
                                  NULL,
                                  0,
                                  &SecurityLength);


   if (Status==STATUS_BUFFER_TOO_SMALL) {

      Security=ExAllocatePool(PagedPool,SecurityLength);

      if (Security!=NULL) {

         Status = NtQuerySecurityObject(BootHandle,
                                        DACL_SECURITY_INFORMATION,
                                        Security,
                                        SecurityLength,
                                        &SecurityLength);


         if (!NT_SUCCESS(Status)) {
            ExFreePool(Security);
            Security=NULL;
         }
      }

   } else {
      Security=NULL;
   }

   //
   // Now, create the path of the control set we will be saving to
   //

   swprintf(Buffer, L"\\Registry\\Machine\\System\\ControlSet%03d", ControlSetNum);

   RtlInitUnicodeString(&SavedBoot,
                        Buffer);

   //
   // Open/Create the control set to which we are saving
   //

   InitializeObjectAttributes(&Attributes,
                              &SavedBoot,
                              OBJ_CASE_INSENSITIVE,
                              NULL,
                              Security);

   Status = NtCreateKey(&SavedBootHandle,
                        KEY_READ | KEY_WRITE,
                        &Attributes,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        &Disposition);


   if (Security) ExFreePool(Security);

   if (!NT_SUCCESS(Status)) {
      NtClose(BootHandle);
      return(Status);
   }

   //
   // Get the key objects for out two controls
   //

   Status = ObReferenceObjectByHandle(BootHandle,
                                      KEY_READ,
                                      CmpKeyObjectType,
                                      KernelMode,
                                      (PVOID *)(&BootKey),
                                      NULL);

   if (!NT_SUCCESS(Status)) goto Exit;

   Status = ObReferenceObjectByHandle(SavedBootHandle,
                                      KEY_WRITE,
                                      CmpKeyObjectType,
                                      KernelMode,
                                      (PVOID *)(&SavedBootKey),
                                      NULL);


   if (!NT_SUCCESS(Status)) {
      ObDereferenceObject((PVOID)BootKey);
      goto Exit;
   }

   //
   // Lock the registry and do the actual saving
   //

   CmpLockRegistryExclusive();

   if (Disposition == REG_CREATED_NEW_KEY) {
       PCM_KEY_NODE Node;

      //
      // If we are saving to a control set that we have just
      // created, it is most efficient to just copy
      // the boot control set tree into the new control set.
      //

      //
      // N.B. We copy the volatile keys only if we are using
      //      a clone and thus our boot control set tree is
      //      composed only of volatile keys.
      //

      CopyRet = CmpCopyTreeEx(BootKey->KeyControlBlock->KeyHive,
                              BootKey->KeyControlBlock->KeyCell,
                              SavedBootKey->KeyControlBlock->KeyHive,
                              SavedBootKey->KeyControlBlock->KeyCell,
                              FALSE);

        //
        // Set the max subkey name property for the new target key.
        //
        Node = (PCM_KEY_NODE)HvGetCell(BootKey->KeyControlBlock->KeyHive,BootKey->KeyControlBlock->KeyCell);
        if( Node ) {
            ULONG       MaxNameLen = Node->MaxNameLen;
            HvReleaseCell(BootKey->KeyControlBlock->KeyHive,BootKey->KeyControlBlock->KeyCell);
            Node = (PCM_KEY_NODE)HvGetCell(SavedBootKey->KeyControlBlock->KeyHive,SavedBootKey->KeyControlBlock->KeyCell);
            if( Node ) {
                if ( HvMarkCellDirty(SavedBootKey->KeyControlBlock->KeyHive,SavedBootKey->KeyControlBlock->KeyCell,FALSE) ) {
                    Node->MaxNameLen = MaxNameLen;
                }
                HvReleaseCell(SavedBootKey->KeyControlBlock->KeyHive,SavedBootKey->KeyControlBlock->KeyCell);
            }
        }

      CmpRebuildKcbCache(SavedBootKey->KeyControlBlock);
   } else {

      //
      // If we are saving to a control set that already exists
      // then its likely that this control set is nearly identical
      // to the boot control set (control sets don't change much
      // between boots).
      //
      // Furthermore, the control set we are saving to must be old
      // and hence has not been modified at all since it ceased
      // being a current control set.
      //
      // Thus, it is most efficient for us to simply synchronize
      // the target control set with the boot control set.
      //

      //
      // N.B. We sync the volatile keys only if we are using
      //      a clone for the same reasons as stated above.
      //

      CopyRet = CmpSyncTrees(BootKey->KeyControlBlock->KeyHive,
                             BootKey->KeyControlBlock->KeyCell,
                             SavedBootKey->KeyControlBlock->KeyHive,
                             SavedBootKey->KeyControlBlock->KeyCell,
                             FALSE);
      CmpRebuildKcbCache(SavedBootKey->KeyControlBlock);
   }

   //
   // Check if the Copy/Sync succeeded and adjust our return code
   // accordingly.
   //

   if (CopyRet) {
      Status = STATUS_SUCCESS;
   } else {
      Status = STATUS_REGISTRY_CORRUPT;
   }

   //
   // All done. Clean up.
   //

   CmpUnlockRegistry();

   ObDereferenceObject((PVOID)BootKey);
   ObDereferenceObject((PVOID)SavedBootKey);

Exit:

   NtClose(BootHandle);
   NtClose(SavedBootHandle);

   return(Status);

}

NTSTATUS
CmpDeleteCloneTree()
/*++

Routine Description:

   Deletes the cloned CurrentControlSet by unloading the CLONE hive.

Arguments:

   NONE.

Return Value:

   NTSTATUS return from NtUnloadKey.

--*/
{
   OBJECT_ATTRIBUTES   Obja;

   InitializeObjectAttributes(
       &Obja,
       &CmRegistrySystemCloneName,
       OBJ_CASE_INSENSITIVE,
       (HANDLE)NULL,
       NULL);

   return NtUnloadKey(&Obja);
}


VOID
CmBootLastKnownGood(
    __in ULONG ErrorLevel
    )

/*++

Routine Description:

    This function is called to indicate a failure during the boot process.
    The actual result is based on the value of ErrorLevel:

        IGNORE - Will return, boot should proceed
        NORMAL - Will return, boot should proceed

        SEVERE - If not booting LastKnownGood, will switch to LastKnownGood
                 and reboot the system.

                 If already booting LastKnownGood, will return.  Boot should
                 proceed.

        CRITICAL - If not booting LastKnownGood, will switch to LastKnownGood
                 and reboot the system.

                 If already booting LastKnownGood, will bugcheck.

Arguments:

    ErrorLevel - Supplies the severity level of the failure

Return Value:

    None.  If it returns, boot should proceed.  May cause the system to
    reboot.

--*/

{
    ARC_STATUS Status;

    CM_PAGED_CODE();

    if (CmFirstTime != TRUE) {

        //
        // NtInitializeRegistry has been called, so handling
        // driver errors is not a task for ScReg.
        // Treat all errors as Normal
        //
        return;
    }

    switch (ErrorLevel) {
        case NormalError:
        case IgnoreError:
            break;

        case SevereError:
            if (CmIsLastKnownGoodBoot()) {
                break;
            } else {
                Status = HalSetEnvironmentVariable("LastKnownGood", "TRUE");
                if (Status == ESUCCESS) {
                    HalReturnToFirmware(HalRebootRoutine);
                }
            }
            break;

        case CriticalError:
            if (CmIsLastKnownGoodBoot()) {
                CM_BUGCHECK( CRITICAL_SERVICE_FAILED, BAD_LAST_KNOWN_GOOD, 1, 0, 0 );
            } else {
                Status = HalSetEnvironmentVariable("LastKnownGood", "TRUE");
                if (Status == ESUCCESS) {
                    HalReturnToFirmware(HalRebootRoutine);
                } else {
                    CM_BUGCHECK( SET_ENV_VAR_FAILED, BAD_LAST_KNOWN_GOOD, 2, 0, 0 );
                }
            }
            break;
    }
    return;
}


BOOLEAN
CmIsLastKnownGoodBoot(
    VOID
    )

/*++

Routine Description:

    Determines whether the current system boot is a LastKnownGood boot or
    not.  It does this by comparing the following two values:

        \registry\machine\system\select:Current
        \registry\machine\system\select:LastKnownGood

    If both of these values refer to the same control set, and this control
    set is different from:

        \registry\machine\system\select:Default

    we are booting LastKnownGood.

Arguments:

    None.

Return Value:

    TRUE  - Booting LastKnownGood
    FALSE - Not booting LastKnownGood

--*/

{
    NTSTATUS Status;
    ULONG Default = 0;//prefast initialization
    ULONG Current = 0;//prefast initialization
    ULONG LKG = 0; //prefast initialization
    RTL_QUERY_REGISTRY_TABLE QueryTable[] = {
        {NULL,      RTL_QUERY_REGISTRY_DIRECT,
         L"Current", &Current,
         REG_DWORD, (PVOID)&Current, 0 },
        {NULL,      RTL_QUERY_REGISTRY_DIRECT,
         L"LastKnownGood", &LKG,
         REG_DWORD, (PVOID)&LKG, 0 },
        {NULL,      RTL_QUERY_REGISTRY_DIRECT,
         L"Default", &Default,
         REG_DWORD, (PVOID)&Default, 0 },
        {NULL,      0,
         NULL, NULL,
         REG_NONE, NULL, 0 }
    };

    CM_PAGED_CODE();

    Status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                    L"\\Registry\\Machine\\System\\Select",
                                    QueryTable,
                                    NULL,
                                    NULL);
    //
    // If this failed, something is severely wrong.
    //

    ASSERT(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INIT,"CmIsLastKnownGoodBoot: RtlQueryRegistryValues "));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INIT,"failed, Status %08lx\n", Status));
        return(FALSE);
    }

    if ((LKG == Current) && (Current != Default)){
        return(TRUE);
    } else {
        return(FALSE);
    }
}

BOOLEAN
CmpLinkKeyToHive(
    PWSTR   KeyPath,
    PWSTR   HivePath
    )

/*++

Routine Description:

    Creates a symbolic link at KeyPath that points to HivePath.

Arguments:

    KeyPath - pointer to unicode string with name of key
              (e.g. L"\\Registry\\Machine\\Security\\SAM")

    HivePath - pointer to unicode string with name of hive root
               (e.g. L"\\Registry\\Machine\\SAM\\SAM")

Return Value:

    TRUE if links were successfully created, FALSE otherwise

--*/

{
    UNICODE_STRING KeyName;
    UNICODE_STRING LinkName;
    OBJECT_ATTRIBUTES Attributes;
    HANDLE LinkHandle;
    ULONG Disposition;
    NTSTATUS Status;

    CM_PAGED_CODE();

    //
    // Create link for CLONE hive
    //

    RtlInitUnicodeString(&KeyName, KeyPath);
    InitializeObjectAttributes(&Attributes,
                               &KeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    Status = NtCreateKey(&LinkHandle,
                         KEY_CREATE_LINK,
                         &Attributes,
                         0,
                         NULL,
                         REG_OPTION_VOLATILE | REG_OPTION_CREATE_LINK,
                         &Disposition);
    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpLinkKeyToHive: couldn't create %S\n", &KeyName));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"    Status = %08lx\n",Status));
        return(FALSE);
    }

    //
    // Check to make sure that the key was created, not just opened.  Since
    // this key is always created volatile, it should never be present in
    // the hive when we boot.
    //
    if (Disposition != REG_CREATED_NEW_KEY) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpLinkKeyToHive: %S already exists!\n", &KeyName));
        NtClose(LinkHandle);
        return(FALSE);
    }

    RtlInitUnicodeString(&LinkName, HivePath);
    Status = NtSetValueKey(LinkHandle,
                           &CmSymbolicLinkValueName,
                           0,
                           REG_LINK,
                           LinkName.Buffer,
                           LinkName.Length);
    NtClose(LinkHandle);
    if (!NT_SUCCESS(Status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CM: CmpLinkKeyToHive: couldn't create symbolic link for %S\n", HivePath));
        return(FALSE);
    }

    return(TRUE);
}

VOID
CmpCreatePerfKeys(
    VOID
    )

/*++

Routine Description:

    Creates predefined keys for the performance text to support old apps on 1.0a

Arguments:

    None.

Return Value:

    None.

--*/

{
    HANDLE Perflib;
    NTSTATUS Status;
    WCHAR LanguageId[4];
    OBJECT_ATTRIBUTES Attributes;
    UNICODE_STRING String;
    USHORT Language;
    LONG i;
    WCHAR c;
    extern PWCHAR CmpRegistryPerflibString;

    RtlInitUnicodeString(&String, CmpRegistryPerflibString);

    InitializeObjectAttributes(&Attributes,
                               &String,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    Status = NtOpenKey(&Perflib,
                       KEY_WRITE,
                       &Attributes);
    if (!NT_SUCCESS(Status)) {
        return;
    }


    //
    // Always create the predefined keys for the english language
    //
    CmpCreatePredefined(Perflib,
                        L"009",
                        HKEY_PERFORMANCE_TEXT);

    //
    // If the default language is not english, create a predefined key for
    // that, too.
    //
    if (PsDefaultSystemLocaleId != 0x00000409) {
        Language = LANGIDFROMLCID(PsDefaultUILanguageId) & 0xff;
        LanguageId[3] = L'\0';
        for (i=2;i>=0;i--) {
            c = Language % 16;
            if (c>9) {
                LanguageId[i]= c+L'A'-10;
            } else {
                LanguageId[i]= c+L'0';
            }
            Language = Language >> 4;
        }
        CmpCreatePredefined(Perflib,
                            LanguageId,
                            HKEY_PERFORMANCE_NLSTEXT);
    }
}


VOID
CmpCreatePredefined(
    IN HANDLE Root,
    IN PWSTR KeyName,
    IN HANDLE PredefinedHandle
    )

/*++

Routine Description:

    Creates a special key that will always return the given predefined handle
    instead of a real handle.

Arguments:

    Root - supplies the handle the keyname is relative to

    KeyName - supplies the name of the key.

    PredefinedHandle - supplies the predefined handle to be returned when this
        key is opened.

Return Value:

    None.

--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    CM_PARSE_CONTEXT ParseContext;
    NTSTATUS Status;
    UNICODE_STRING Name;
    HANDLE Handle;

    ParseContext.Class.Length = 0;
    ParseContext.Class.Buffer = NULL;

    ParseContext.TitleIndex = 0;
    ParseContext.CreateOptions = REG_OPTION_VOLATILE | REG_OPTION_PREDEF_HANDLE;
    ParseContext.Disposition = 0;
    ParseContext.CreateLink = FALSE;
    ParseContext.PredefinedHandle = PredefinedHandle;
    ParseContext.CreateOperation = TRUE;
    ParseContext.OriginatingPoint = NULL;

    RtlInitUnicodeString(&Name, KeyName);
    InitializeObjectAttributes(&ObjectAttributes,
                               &Name,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               Root,
                               NULL);

    Status = ObOpenObjectByName(&ObjectAttributes,
                                CmpKeyObjectType,
                                KernelMode,
                                NULL,
                                KEY_READ,
                                (PVOID)&ParseContext,
                                &Handle);
                                
    ASSERT(CmpMiniNTBoot || NT_SUCCESS(Status));

    if (NT_SUCCESS(Status))
        ZwClose(Handle);
}

BOOLEAN   CmpSystemHiveConversionFailed = FALSE;

NTSTATUS
CmpSetupPrivateWrite(
    PCMHIVE             CmHive
    )
/*++

Routine Description:

	Converts the primary file to private write stream

Arguments:

    CmHive - hive to convert, typically SYSTEM

Return Value:

    NONE; bugchecks if something wrong

--*/
{   
    ULONG       FileOffset;
    ULONG       Data;
	NTSTATUS	Status;

	CM_PAGED_CODE()

    //
    //  We need to issue a read from the file, to trigger the cache initialization
    //
    FileOffset = 0;
    if ( ! (((PHHIVE)CmHive)->FileRead)(
                    (PHHIVE)CmHive,
                    HFILE_TYPE_PRIMARY,
                    &FileOffset,
                    (PVOID)&Data,
                    sizeof(ULONG)
                    )
       )
    {
        return STATUS_REGISTRY_IO_FAILED;
    }

    //
    // Acquire the file object for the primary; This should be called AFTER the
    // cache has been initialized.
    //
    Status = CmpAcquireFileObjectForFile(CmHive,CmHive->FileHandles[HFILE_TYPE_PRIMARY],&(CmHive->FileObject));
    if( !NT_SUCCESS(Status) ) {
		return Status;
    }

    //
    // set the getCell and releaseCell routines to the right one(s)
    //
    CmHive->Hive.GetCellRoutine = HvpGetCellMapped;
    CmHive->Hive.ReleaseCellRoutine = HvpReleaseCellMapped;

	return STATUS_SUCCESS;
}

//
// This thread is used to load the machine hives in parallel 
//
extern  ULONG   CmpCheckHiveIndex;

VOID
CmpLoadHiveThread(
    IN PVOID StartContext
    )
/*++

Routine Description:
    
    Loads the hive at index StartContext in CmpMachineHiveList

    Warning. We need to protect when enlisting the hives in CmpHiveListHead !!!

Arguments:

Return Value:

--*/
{
    UCHAR   FileBuffer[MAX_NAME];
    UCHAR   RegBuffer[MAX_NAME];

    UNICODE_STRING TempName;
    UNICODE_STRING FileName;
    UNICODE_STRING RegName;

    USHORT  FileStart;
    USHORT  RegStart;
    ULONG   i;
    PCMHIVE CmHive;
    HANDLE  PrimaryHandle;
    HANDLE  LogHandle;
    ULONG   PrimaryDisposition;
    ULONG   SecondaryDisposition;
    ULONG   Length;
    NTSTATUS Status = STATUS_SUCCESS;

    PVOID   ErrorParameters;
    ULONG   ErrorResponse;
    ULONG   ClusterSize;
    ULONG   LocalWorkerIncrement;

    CM_PAGED_CODE();

    i = (ULONG)(ULONG_PTR)StartContext;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INIT,"CmpLoadHiveThread %i ... starting\n",i));

    ASSERT( CmpMachineHiveList[i].Name != NULL );

    if( i == CmpCheckHiveIndex ) {
        //
        // we want to hold this thread until all the others finish, so we have a chance to debug it.
        // last one that finishes will wake us
        //
        KeWaitForSingleObject( &CmpLoadWorkerDebugEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );
        ASSERT( CmpLoadWorkerIncrement == (CM_NUMBER_OF_MACHINE_HIVES - 1) );
        DbgBreakPoint();
    }
    //
    // signal that we have started
    //
    CmpMachineHiveList[i].ThreadStarted = TRUE;

    FileName.MaximumLength = MAX_NAME;
    FileName.Length = 0;
    FileName.Buffer = (PWSTR)&(FileBuffer[0]);

    RegName.MaximumLength = MAX_NAME;
    RegName.Length = 0;
    RegName.Buffer = (PWSTR)&(RegBuffer[0]);

    RtlInitUnicodeString(
        &TempName,
        INIT_SYSTEMROOT_HIVEPATH
        );
    RtlAppendStringToString((PSTRING)&FileName, (PSTRING)&TempName);
    FileStart = FileName.Length;

    RtlInitUnicodeString(
        &TempName,
        INIT_REGISTRY_MASTERPATH
        );
    RtlAppendStringToString((PSTRING)&RegName, (PSTRING)&TempName);
    RegStart = RegName.Length;

    //
    // Compute the name of the file, and the name to link to in
    // the registry.
    //

    // REGISTRY

    RegName.Length = RegStart;
    RtlInitUnicodeString(
        &TempName,
        CmpMachineHiveList[i].BaseName
        );
    RtlAppendStringToString((PSTRING)&RegName, (PSTRING)&TempName);

    // REGISTRY\MACHINE or REGISTRY\USER

    if (RegName.Buffer[ (RegName.Length / sizeof( WCHAR )) - 1 ] == '\\') {
        RtlInitUnicodeString(
            &TempName,
            CmpMachineHiveList[i].Name
            );
        RtlAppendStringToString((PSTRING)&RegName, (PSTRING)&TempName);
    }

    // REGISTRY\[MACHINE|USER]\HIVE

    // <sysroot>\config

    RtlInitUnicodeString(
        &TempName,
        CmpMachineHiveList[i].Name
        );
    FileName.Length = FileStart;
    RtlAppendStringToString((PSTRING)&FileName, (PSTRING)&TempName);

    // <sysroot>\config\hive


    if (CmpMachineHiveList[i].CmHive == NULL) {

        //
        // Hive has not been initialized in any way.
        //

        CmpMachineHiveList[i].Allocate = TRUE;
        Status = CmpInitHiveFromFile(&FileName,
                                     CmpMachineHiveList[i].HHiveFlags,
                                     &CmHive,
                                     &(CmpMachineHiveList[i].Allocate),
                                     CM_CHECK_REGISTRY_CHECK_CLEAN
                                     );

        if ( (!NT_SUCCESS(Status)) ||
             (!CmpShareSystemHives && (CmHive->FileHandles[HFILE_TYPE_LOG] == NULL)) )
        {
            ErrorParameters = &FileName;
            ExRaiseHardError(
                STATUS_CANNOT_LOAD_REGISTRY_FILE,
                1,
                1,
                (PULONG_PTR)&ErrorParameters,
                OptionOk,
                &ErrorResponse
                );

        }

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INIT,"CmpInitializeHiveList:\n"));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INIT,"\tCmHive for '%ws' @", CmpMachineHiveList[i]));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INIT,"%08lx", CmHive));

        CmHive->Flags = CmpMachineHiveList[i].CmHiveFlags;
        CmpMachineHiveList[i].CmHive2 = CmHive;
        
    } else {

        CmHive = CmpMachineHiveList[i].CmHive;

        if (!(CmHive->Hive.HiveFlags & HIVE_VOLATILE)) {

            //
            // CmHive already exists.  It is not an entirely volatile
            // hive (we do nothing for those.)
            //
            // First, open the files (Primary and Alternate) that
            // back the hive.  Stuff their handles into the CmHive
            // object.  Force the size of the files to match the
            // in memory images.  Call HvSyncHive to write changes
            // out to disk.
            //
			BOOLEAN	NoBufering = FALSE; // first try to open it cached;

retryNoBufering:

            Status = CmpOpenHiveFiles(&FileName,
                                      L".LOG",
                                      &PrimaryHandle,
                                      &LogHandle,
                                      &PrimaryDisposition,
                                      &SecondaryDisposition,
                                      TRUE,
                                      TRUE,
                                      NoBufering,
                                      &ClusterSize);

            if ( ( ! NT_SUCCESS(Status)) ||
                 (LogHandle == NULL) )
            {
fatal:
                ErrorParameters = &FileName;
                ExRaiseHardError(
                    STATUS_CANNOT_LOAD_REGISTRY_FILE,
                    1,
                    1,
                    (PULONG_PTR)&ErrorParameters,
                    OptionOk,
                    &ErrorResponse
                    );

                //
                // WARNNOTE
                // We've just told the user that something essential,
                // like the SYSTEM hive, is hosed.  Don't try to run,
                // we just risk destroying user data.  Punt.
                //
                CM_BUGCHECK(BAD_SYSTEM_CONFIG_INFO,BAD_HIVE_LIST,0,i,Status);
            }

            CmHive->FileHandles[HFILE_TYPE_LOG] = LogHandle;
            CmHive->FileHandles[HFILE_TYPE_PRIMARY] = PrimaryHandle;

			if( NoBufering == FALSE ) {
				//
				// initialize cache and mark the stream as PRIVATE_WRITE;
				// next flush will do the actual conversion
				//
				Status = CmpSetupPrivateWrite(CmHive);
			}

			if( !NT_SUCCESS(Status) ) {
				if( (NoBufering == TRUE) || (Status != STATUS_RETRY) ) {
					//
					// we have tried both ways and it didn't work; bad luck
					//
					goto fatal;
				}

                DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Failed to convert SYSTEM hive to mapped (0x%lx) ... loading it in paged pool\n",Status);

				//
				// close handle and make another attempt to open them without buffering
				//
				CmpTrackHiveClose = TRUE;
				ZwClose(PrimaryHandle);
				CmpTrackHiveClose = FALSE;
				ZwClose(LogHandle);
				NoBufering = TRUE;

				goto retryNoBufering;
			}

            //
            // now that we successfully opened the hive files, clear off the lazy flush flag
            //
            ASSERT( CmHive->Hive.HiveFlags & HIVE_NOLAZYFLUSH );
            CmHive->Hive.HiveFlags &= (~HIVE_NOLAZYFLUSH);

            Length = CmHive->Hive.Storage[Stable].Length + HBLOCK_SIZE;

            //
            // When an in-memory hive is opened with no backing
            // file, ClusterSize is assumed to be 1.  When the file
            // is opened later (for the SYSTEM hive) we need
            // to update this field in the hive if we are
            // booting from media where the cluster size > 1
            //
            if (CmHive->Hive.Cluster != ClusterSize) {
                //
                // The cluster size is different than previous assumed.
                // Since a cluster in the dirty vector must be either
                // completely dirty or completely clean, go through the
                // dirty vector and mark all clusters that contain a dirty
                // logical sector as completely dirty.
                //
                PRTL_BITMAP  BitMap;
                ULONG        Index;

                BitMap = &(CmHive->Hive.DirtyVector);
                for (Index = 0;
                     Index < CmHive->Hive.DirtyVector.SizeOfBitMap;
                     Index += ClusterSize)
                {
                    if (!RtlAreBitsClear (BitMap, Index, ClusterSize)) {
                        RtlSetBits (BitMap, Index, ClusterSize);
                    }
                }
                //
                // Update DirtyCount and Cluster
                //
                CmHive->Hive.DirtyCount = RtlNumberOfSetBits(&CmHive->Hive.DirtyVector);
                CmHive->Hive.Cluster = ClusterSize;
            }

            if (!CmpFileSetSize(
                    (PHHIVE)CmHive, HFILE_TYPE_PRIMARY, Length,Length) 
               )
            {
                //
                // WARNNOTE
                // Data written into the system hive since boot
                // cannot be written out, punt.
                //
                CmpCannotWriteConfiguration = TRUE;
            }

            ASSERT(FIELD_OFFSET(CMHIVE, Hive) == 0);

            if( CmHive->Hive.BaseBlock->BootRecover != 0 ) {
                //
                // boot loader recovered the hive; we need to flush it all to the disk
                // mark everything dirty; the next flush will do take care of the rest
                //
                PRTL_BITMAP  BitMap;
                BitMap = &(CmHive->Hive.DirtyVector);
                RtlSetAllBits(BitMap);
                CmHive->Hive.DirtyCount = BitMap->SizeOfBitMap;
                //
                // we only need to flush the hive when the loader has recovered it
                //
                HvSyncHive((PHHIVE)CmHive);
                
            }

            CmpMachineHiveList[i].CmHive2 = CmHive;

            ASSERT( CmpMachineHiveList[i].CmHive == CmpMachineHiveList[i].CmHive2 );

            if( CmpCannotWriteConfiguration ) {
                //
                // The system disk is full; Give user a chance to log-on and make room
                //
                CmpDiskFullWarning();
            } 

            //
            // copy the full file name for the conversion worker thread 
            //
            SystemHiveFullPathName.MaximumLength = MAX_NAME;
            SystemHiveFullPathName.Length = 0;
            SystemHiveFullPathName.Buffer = (PWSTR)&(SystemHiveFullPathBuffer[0]);
            RtlAppendStringToString((PSTRING)&SystemHiveFullPathName, (PSTRING)&FileName);
        } else if (CmpMiniNTBoot) {
            //
            // copy the full file name for the conversion worker thread 
            //
            SystemHiveFullPathName.MaximumLength = MAX_NAME;
            SystemHiveFullPathName.Length = 0;
            SystemHiveFullPathName.Buffer = (PWSTR)&(SystemHiveFullPathBuffer[0]);
            RtlAppendStringToString((PSTRING)&SystemHiveFullPathName, (PSTRING)&FileName);
        }                
        if(i == SYSTEM_HIVE_INDEX) {
            //
            // marks the System\Select!Current value dirty so we preserve what was set by the loader.
            //
            CmpMarkCurrentValueDirty((PHHIVE)CmHive,CmHive->Hive.BaseBlock->RootCell);
        }
    }

    CmpMachineHiveList[i].ThreadFinished = TRUE;

    LocalWorkerIncrement = InterlockedIncrement (&CmpLoadWorkerIncrement);
    if ( LocalWorkerIncrement == CM_NUMBER_OF_MACHINE_HIVES ) {
        //
        // this was the last thread (the lazyest); signal the main thread
        //
        KeSetEvent (&CmpLoadWorkerEvent, 0, FALSE);
    }

    if ( (LocalWorkerIncrement == (CM_NUMBER_OF_MACHINE_HIVES -1)) && // there is one more thread
         (CmpCheckHiveIndex < CM_NUMBER_OF_MACHINE_HIVES ) // which is waiting to be debugged
        ) {
        //
        // wake up the thread to be debugged
        //
        KeSetEvent (&CmpLoadWorkerDebugEvent, 0, FALSE);
    }

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INIT,"CmpLoadHiveThread %i ... terminating\n",i));
    PsTerminateSystemThread(Status);
}


NTSTATUS
CmpSetNetworkValue(
    IN PNETWORK_LOADER_BLOCK NetworkLoaderBlock
    )
/*++

Routine Description:

    This function will save the information in the Network Loader
    Block to the registry.

Arguments:
    NetworkLoaderBlock - Supplies a pointer to the network loader block 
                         that was created by the OS Loader.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING string;
    HANDLE handle;
    ULONG disposition;


    ASSERT( NetworkLoaderBlock != NULL );
    ASSERT( NetworkLoaderBlock->DHCPServerACKLength > 0 );


    RtlInitUnicodeString( &string, L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\PXE" );

    InitializeObjectAttributes(
        &objectAttributes,
        &string,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtCreateKey(&handle,
                         KEY_ALL_ACCESS,
                         &objectAttributes,
                         0,
                         (PUNICODE_STRING)NULL,
                         0,
                         &disposition
                         );
    if ( !NT_SUCCESS(status) ) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL, "CmpSetNetworkValue: Unable to open PXE key: %x\n", status ));
        goto Error;
    }

    RtlInitUnicodeString( &string, L"DHCPServerACK" );

    status = NtSetValueKey(handle,
                           &string,
                           0,
                           REG_BINARY,
                           NetworkLoaderBlock->DHCPServerACK,
                           NetworkLoaderBlock->DHCPServerACKLength
                           );
    if ( !NT_SUCCESS(status) ) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL, "CmpSetNetworkValue: Unable to set DHCPServerACK key: %x\n", status ));
        goto Error;
    }

    RtlInitUnicodeString( &string, L"BootServerReply" );

    status = NtSetValueKey(handle,
                           &string,
                           0,
                           REG_BINARY,
                           NetworkLoaderBlock->BootServerReplyPacket,
                           NetworkLoaderBlock->BootServerReplyPacketLength                           
                           );
    if ( !NT_SUCCESS(status) ) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL, "CmpSetNetworkValue: Unable to set BootServerReplyPacket key: %x\n", status ));
        goto Error;
    }

    status = STATUS_SUCCESS;

Cleanup:
    NtClose( handle );
    
    return status;

Error:
    goto Cleanup;
}



NTSTATUS
CmpSetSystemValues(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This function will save the system start information to 
    the registry.

Arguments:
    LoaderBlock -  Supplies a pointer to the loader block.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING string;
    UNICODE_STRING value;
    HANDLE handle;


    ASSERT( LoaderBlock != NULL );


    value.Buffer = NULL;

    //
    // Open the control key
    //

    RtlInitUnicodeString( &string, L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control" );

    InitializeObjectAttributes(
        &objectAttributes,
        &string,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtOpenKey(
                       &handle,
                       KEY_ALL_ACCESS,
                       &objectAttributes
                      );
    if ( !NT_SUCCESS(status) ) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpSetSystemValues: Unable to Open Control Key: %x\n", status ));
        goto Error;
    }

    //
    // Set the System start options key
    //

    RtlInitUnicodeString( &string, L"SystemStartOptions" );

    status = NtSetValueKey  (
                            handle,
                            &string,
                            0,
                            REG_SZ,
                            CmpLoadOptions.Buffer,
                            CmpLoadOptions.Length
                            );
    if ( !NT_SUCCESS(status) ) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpSetSystemValue: Unable to set SystemStartOptions key: %x\n", status ));
        goto Error;
    }

    //
    // Set the System Boot Device
    //

    RtlInitUnicodeString( &string, L"SystemBootDevice" );
    RtlCreateUnicodeStringFromAsciiz( &value, LoaderBlock->ArcBootDeviceName );

    status = NtSetValueKey(handle,
                           &string,
                           0,
                           REG_SZ,
                           value.Buffer,
                           value.Length + sizeof(WCHAR)
                           );
    if ( !NT_SUCCESS(status) ) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpSetSystemValue: Unable to set SystemBootDevice key: %x\n", status ));
        goto Error;
    }

    status = STATUS_SUCCESS;

Cleanup:
    if ( value.Buffer ) {
        RtlFreeUnicodeString(&value);
    }

    NtClose( handle );
    
    return status;

Error:
    goto Cleanup;
}

VOID
CmpMarkCurrentValueDirty(
                         IN PHHIVE SystemHive,
                         IN HCELL_INDEX RootCell
                         )
{
    PCM_KEY_NODE    Node;
    HCELL_INDEX     Select;
    UNICODE_STRING  Name;
    HCELL_INDEX     ValueCell;

    CM_PAGED_CODE();

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
    //
    // Find \SYSTEM\SELECT node.
    //
    Node = (PCM_KEY_NODE)HvGetCell(SystemHive,RootCell);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return;
    }
    RtlInitUnicodeString(&Name, L"select");
    Select = CmpFindSubKeyByName(SystemHive,
                                Node,
                                &Name);
    HvReleaseCell(SystemHive,RootCell);
    if (Select == HCELL_NIL) {
        return;
    }
    Node = (PCM_KEY_NODE)HvGetCell(SystemHive,Select);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return;
    }

    RtlInitUnicodeString(&Name, L"Current");
    ValueCell = CmpFindValueByName(SystemHive,
                                   Node,
                                   &Name);
    HvReleaseCell(SystemHive,Select);
    if (ValueCell != HCELL_NIL) {
        HvMarkCellDirty(SystemHive, ValueCell,FALSE);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmsubs2.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmsubs2.c

Abstract:

    This module various support routines for the configuration manager.

    The routines in this module are independent enough to be linked into
    any other program.  The routines in cmsubs.c are not.

--*/

#include    "cmp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpQueryKeyData)
#pragma alloc_text(PAGE,CmpQueryKeyDataFromCache)
#pragma alloc_text(PAGE,CmpQueryKeyValueData)
#endif

//
// Define alignment macro.
//

#define ALIGN_OFFSET(Offset) (ULONG) \
        ((((ULONG)(Offset) + sizeof(ULONG)-1)) & (~(sizeof(ULONG) - 1)))

#define ALIGN_OFFSET64(Offset) (ULONG) \
        ((((ULONG)(Offset) + sizeof(ULONGLONG)-1)) & (~(sizeof(ULONGLONG) - 1)))

//
// Data transfer workers
//


NTSTATUS
CmpQueryKeyData(
    PHHIVE                  Hive,
    PCM_KEY_NODE            Node,
    KEY_INFORMATION_CLASS   KeyInformationClass,
    PVOID                   KeyInformation,
    ULONG                   Length,
    PULONG                  ResultLength
    )
/*++

Routine Description:

    Do the actual copy of data for a key into caller's buffer.

    If KeyInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

Arguments:

    Hive - supplies a pointer to the hive control structure for the hive

    Node - Supplies pointer to node whose subkeys are to be found

    KeyInformationClass - Specifies the type of information returned in
        Buffer.  One of the following types:

        KeyBasicInformation - return last write time, title index, and name.
            (see KEY_BASIC_INFORMATION structure)

        KeyNodeInformation - return last write time, title index, name, class.
            (see KEY_NODE_INFORMATION structure)

    KeyInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyInformation in bytes.

    ResultLength - Number of bytes actually written into KeyInformation.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PCELL_DATA          pclass;
    ULONG               requiredlength;
    LONG                leftlength;
    ULONG               offset;
    ULONG               minimumlength;
    PKEY_INFORMATION    pbuffer;
    USHORT              NameLength;

    pbuffer = (PKEY_INFORMATION)KeyInformation;
    NameLength = CmpHKeyNameLen(Node);

    switch (KeyInformationClass) {

    case KeyBasicInformation:

        //
        // LastWriteTime, TitleIndex, NameLength, Name
        //

        requiredlength = FIELD_OFFSET(KEY_BASIC_INFORMATION, Name) +
                         NameLength;

        minimumlength = FIELD_OFFSET(KEY_BASIC_INFORMATION, Name);

        *ResultLength = requiredlength;

        status = STATUS_SUCCESS;

        if (Length < minimumlength) {

            status = STATUS_BUFFER_TOO_SMALL;

        } else {

            pbuffer->KeyBasicInformation.LastWriteTime =
                Node->LastWriteTime;

            pbuffer->KeyBasicInformation.TitleIndex = 0;

            pbuffer->KeyBasicInformation.NameLength =
                NameLength;

            leftlength = Length - minimumlength;

            requiredlength = NameLength;

            if (leftlength < (LONG)requiredlength) {
                requiredlength = leftlength;
                status = STATUS_BUFFER_OVERFLOW;
            }

            if (Node->Flags & KEY_COMP_NAME) {
                CmpCopyCompressedName(pbuffer->KeyBasicInformation.Name,
                                      leftlength,
                                      Node->Name,
                                      Node->NameLength);
            } else {
                RtlCopyMemory(
                    &(pbuffer->KeyBasicInformation.Name[0]),
                    &(Node->Name[0]),
                    requiredlength
                    );
            }
        }

        break;


    case KeyNodeInformation:
        //
        // LastWriteTime, TitleIndex, ClassOffset, ClassLength
        // NameLength, Name, Class
        //
        requiredlength = FIELD_OFFSET(KEY_NODE_INFORMATION, Name) +
                         NameLength +
                         Node->ClassLength;

        minimumlength = FIELD_OFFSET(KEY_NODE_INFORMATION, Name);

        *ResultLength = requiredlength;

        status = STATUS_SUCCESS;

        if (Length < minimumlength) {

            status = STATUS_BUFFER_TOO_SMALL;

        } else {

            pbuffer->KeyNodeInformation.LastWriteTime =
                Node->LastWriteTime;

            pbuffer->KeyNodeInformation.TitleIndex = 0;

            pbuffer->KeyNodeInformation.ClassLength =
                Node->ClassLength;

            pbuffer->KeyNodeInformation.NameLength =
                NameLength;

            leftlength = Length - minimumlength;
            requiredlength = NameLength;

            if (leftlength < (LONG)requiredlength) {
                requiredlength = leftlength;
                status = STATUS_BUFFER_OVERFLOW;
            }

            if (Node->Flags & KEY_COMP_NAME) {
                CmpCopyCompressedName(pbuffer->KeyNodeInformation.Name,
                                      leftlength,
                                      Node->Name,
                                      Node->NameLength);
            } else {
                RtlCopyMemory(
                    &(pbuffer->KeyNodeInformation.Name[0]),
                    &(Node->Name[0]),
                    requiredlength
                    );
            }

            if (Node->ClassLength > 0) {

                offset = FIELD_OFFSET(KEY_NODE_INFORMATION, Name) +
                            NameLength;
                offset = ALIGN_OFFSET(offset);

                pbuffer->KeyNodeInformation.ClassOffset = offset;

                pclass = HvGetCell(Hive, Node->Class);
                if( pclass == NULL ) {
                    //
                    // we couldn't map this cell
                    //
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                pbuffer = (PKEY_INFORMATION)((PUCHAR)pbuffer + offset);

                leftlength = (((LONG)Length - (LONG)offset) < 0) ?
                                    0 :
                                    Length - offset;

                requiredlength = Node->ClassLength;

                if (leftlength < (LONG)requiredlength) {
                    requiredlength = leftlength;
                    status = STATUS_BUFFER_OVERFLOW;
                }

                RtlCopyMemory(
                    pbuffer,
                    pclass,
                    requiredlength
                    );

                HvReleaseCell(Hive,Node->Class);

            } else {
                pbuffer->KeyNodeInformation.ClassOffset = (ULONG)-1;
            }
        }

        break;


    case KeyFullInformation:
        //
        // LastWriteTime, TitleIndex, ClassOffset, ClassLength,
        // SubKeys, MaxNameLen, MaxClassLen, Values, MaxValueNameLen,
        // MaxValueDataLen, Class
        //
        requiredlength = FIELD_OFFSET(KEY_FULL_INFORMATION, Class) +
                         Node->ClassLength;

        minimumlength = FIELD_OFFSET(KEY_FULL_INFORMATION, Class);

        *ResultLength = requiredlength;

        status = STATUS_SUCCESS;

        if (Length < minimumlength) {

            status = STATUS_BUFFER_TOO_SMALL;

        } else {

            pbuffer->KeyFullInformation.LastWriteTime =
                Node->LastWriteTime;

            pbuffer->KeyFullInformation.TitleIndex = 0;

            pbuffer->KeyFullInformation.ClassLength =
                Node->ClassLength;

            if (Node->ClassLength > 0) {

                pbuffer->KeyFullInformation.ClassOffset =
                        FIELD_OFFSET(KEY_FULL_INFORMATION, Class);

                pclass = HvGetCell(Hive, Node->Class);
                if( pclass == NULL ) {
                    //
                    // we couldn't map this cell
                    //
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                leftlength = Length - minimumlength;
                requiredlength = Node->ClassLength;

                if (leftlength < (LONG)requiredlength) {
                    requiredlength = leftlength;
                    status = STATUS_BUFFER_OVERFLOW;
                }

                RtlCopyMemory(
                    &(pbuffer->KeyFullInformation.Class[0]),
                    pclass,
                    requiredlength
                    );

                HvReleaseCell(Hive,Node->Class);

            } else {
                pbuffer->KeyFullInformation.ClassOffset = (ULONG)-1;
            }

            pbuffer->KeyFullInformation.SubKeys =
                Node->SubKeyCounts[Stable] +
                Node->SubKeyCounts[Volatile];

            pbuffer->KeyFullInformation.Values =
                Node->ValueList.Count;

            pbuffer->KeyFullInformation.MaxNameLen =
                Node->MaxNameLen;

            pbuffer->KeyFullInformation.MaxClassLen =
                Node->MaxClassLen;

            pbuffer->KeyFullInformation.MaxValueNameLen =
                Node->MaxValueNameLen;

            pbuffer->KeyFullInformation.MaxValueDataLen =
                Node->MaxValueDataLen;

        }

        break;


    default:
        status = STATUS_INVALID_PARAMETER;
        break;
    }

    return status;
}

NTSTATUS
CmpQueryKeyDataFromCache(
    PCM_KEY_CONTROL_BLOCK   Kcb,
    KEY_INFORMATION_CLASS   KeyInformationClass,
    PVOID                   KeyInformation,
    ULONG                   Length,
    PULONG                  ResultLength
    )
/*++

Routine Description:

    Do the actual copy of data for a key into caller's buffer.

    If KeyInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

    Works only for the information cached into kcb. I.e. KeyBasicInformation
    and KeyCachedInfo


Arguments:

    Kcb - Supplies pointer to the kcb to be queried

    KeyInformationClass - Specifies the type of information returned in
        Buffer.  One of the following types:

        KeyBasicInformation - return last write time, title index, and name.
            (see KEY_BASIC_INFORMATION structure)

        KeyCachedInformation - return last write time, title index, name ....
            (see KEY_CACHED_INFORMATION structure)

    KeyInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyInformation in bytes.

    ResultLength - Number of bytes actually written into KeyInformation.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PKEY_INFORMATION    pbuffer;
    ULONG               requiredlength;
    USHORT              NameLength;
    PCM_KEY_NODE        Node; // this is to be used only in case of cache incoherency

    CM_PAGED_CODE();

    //
    // we cannot afford to return the kcb NameBlock as the key name
    // for KeyBasicInformation as there are lots of callers expecting
    // the name to be case-sensitive; KeyCachedInformation is new
    // and used only by the Win32 layer, which is not case sensitive
    // Note: future clients of KeyCachedInformation must be made aware 
    // that name is NOT case-sensitive
    //
    ASSERT( KeyInformationClass == KeyCachedInformation );

    // 
    // we are going to need the nameblock; if it is NULL, bail out
    //
    if( Kcb->NameBlock == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pbuffer = (PKEY_INFORMATION)KeyInformation;
    
    if (Kcb->NameBlock->Compressed) {
        NameLength = CmpCompressedNameSize(Kcb->NameBlock->Name,Kcb->NameBlock->NameLength);
    } else {
        NameLength = Kcb->NameBlock->NameLength;
    }
    
    // Assume success
    status = STATUS_SUCCESS;

    switch (KeyInformationClass) {

    case KeyCachedInformation:

        //
        // LastWriteTime, TitleIndex, 
        // SubKeys, MaxNameLen, Values, MaxValueNameLen,
        // MaxValueDataLen, Name
        //
        requiredlength = sizeof(KEY_CACHED_INFORMATION);

        *ResultLength = requiredlength;

        if (Length < requiredlength) {

            status = STATUS_BUFFER_TOO_SMALL;

        } else {

            pbuffer->KeyCachedInformation.LastWriteTime = Kcb->KcbLastWriteTime;

            pbuffer->KeyCachedInformation.TitleIndex = 0;

            pbuffer->KeyCachedInformation.NameLength = NameLength;

            pbuffer->KeyCachedInformation.Values = Kcb->ValueCache.Count;
            
            pbuffer->KeyCachedInformation.MaxNameLen = Kcb->KcbMaxNameLen;
            
            pbuffer->KeyCachedInformation.MaxValueNameLen = Kcb->KcbMaxValueNameLen;
            
            pbuffer->KeyCachedInformation.MaxValueDataLen = Kcb->KcbMaxValueDataLen;

            if( !(Kcb->ExtFlags & CM_KCB_INVALID_CACHED_INFO) ) {
                // there is some cached info
                if( Kcb->ExtFlags & CM_KCB_NO_SUBKEY ) {
                    pbuffer->KeyCachedInformation.SubKeys = 0;
                } else if( Kcb->ExtFlags & CM_KCB_SUBKEY_ONE ) {
                    pbuffer->KeyCachedInformation.SubKeys = 1;
                } else if( Kcb->ExtFlags & CM_KCB_SUBKEY_HINT ) {
                    pbuffer->KeyCachedInformation.SubKeys = Kcb->IndexHint->Count;
                } else {
                    pbuffer->KeyCachedInformation.SubKeys = Kcb->SubKeyCount;
                }
            } else {
                //
                // kcb cache is not coherent; get the info from knode
                // 
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"Kcb cache incoherency detected, kcb = %p\n",Kcb));

                Node = (PCM_KEY_NODE)HvGetCell(Kcb->KeyHive,Kcb->KeyCell);
                if( Node == NULL ) {
                    //
                    // couldn't map view for this cell
                    //
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                pbuffer->KeyCachedInformation.SubKeys = Node->SubKeyCounts[Stable] + Node->SubKeyCounts[Volatile];
                HvReleaseCell(Kcb->KeyHive,Kcb->KeyCell);

            }

        }

        break;

    default:
        status = STATUS_INVALID_PARAMETER;
        break;
    }

    return status;
}

VALUE_SEARCH_RETURN_TYPE
CmpQueryKeyValueData(
    PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    PPCM_CACHED_VALUE   ContainingList,
    PCM_KEY_VALUE       ValueKey,
    BOOLEAN             ValueCached,
    KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    PVOID               KeyValueInformation,
    ULONG               Length,
    PULONG              ResultLength,
    NTSTATUS            *status
    )
/*++

Routine Description:

    Do the actual copy of data for a key value into caller's buffer.

    If KeyValueInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

Arguments:

    Hive - supplies a pointer to the hive control structure for the hive

    Cell - supplies index of node to whose sub keys are to be found

    KeyValueInformationClass - Specifies the type of information returned in
        KeyValueInformation.  One of the following types:

    KeyValueInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyInformation in bytes.

    ResultLength - Number of bytes actually written into KeyInformation.

Return Value:

    NTSTATUS

--*/
{
    PKEY_VALUE_INFORMATION pbuffer;
    PCELL_DATA  pcell;
    LONG        leftlength;
    ULONG       requiredlength;
    ULONG       minimumlength;
    ULONG       offset;
    ULONG       base;
    ULONG       realsize;
    PUCHAR      datapointer;
    BOOLEAN     small;
    USHORT      NameLength;
    BOOLEAN     BufferAllocated = FALSE;
    HCELL_INDEX CellToRelease = HCELL_NIL;
    PHHIVE      Hive;
    VALUE_SEARCH_RETURN_TYPE SearchValue = SearchSuccess;

    Hive = KeyControlBlock->KeyHive;
    pbuffer = (PKEY_VALUE_INFORMATION)KeyValueInformation;

    pcell = (PCELL_DATA) ValueKey;
    NameLength = CmpValueNameLen(&pcell->u.KeyValue);

    switch (KeyValueInformationClass) {

    case KeyValueBasicInformation:

        //
        // TitleIndex, Type, NameLength, Name
        //
        requiredlength = FIELD_OFFSET(KEY_VALUE_BASIC_INFORMATION, Name) +
                         NameLength;

        minimumlength = FIELD_OFFSET(KEY_VALUE_BASIC_INFORMATION, Name);

        *ResultLength = requiredlength;

        *status = STATUS_SUCCESS;

        if (Length < minimumlength) {

            *status = STATUS_BUFFER_TOO_SMALL;

        } else {

            pbuffer->KeyValueBasicInformation.TitleIndex = 0;

            pbuffer->KeyValueBasicInformation.Type =
                pcell->u.KeyValue.Type;

            pbuffer->KeyValueBasicInformation.NameLength =
                NameLength;

            leftlength = Length - minimumlength;
            requiredlength = NameLength;

            if (leftlength < (LONG)requiredlength) {
                requiredlength = leftlength;
                *status = STATUS_BUFFER_OVERFLOW;
            }

            if (pcell->u.KeyValue.Flags & VALUE_COMP_NAME) {
                CmpCopyCompressedName(pbuffer->KeyValueBasicInformation.Name,
                                      requiredlength,
                                      pcell->u.KeyValue.Name,
                                      pcell->u.KeyValue.NameLength);
            } else {
                RtlCopyMemory(&(pbuffer->KeyValueBasicInformation.Name[0]),
                              &(pcell->u.KeyValue.Name[0]),
                              requiredlength);
            }
        }

        break;



    case KeyValueFullInformation:
    case KeyValueFullInformationAlign64:

        //
        // TitleIndex, Type, DataOffset, DataLength, NameLength,
        // Name, Data
        //
        small = CmpIsHKeyValueSmall(realsize, pcell->u.KeyValue.DataLength);

        requiredlength = FIELD_OFFSET(KEY_VALUE_FULL_INFORMATION, Name) +
                         NameLength +
                         realsize;

        minimumlength = FIELD_OFFSET(KEY_VALUE_FULL_INFORMATION, Name);
        offset = 0;
        if (realsize > 0) {
            base = requiredlength - realsize;

#if defined(_WIN64)

            offset = ALIGN_OFFSET64(base);

#else

            if (KeyValueInformationClass == KeyValueFullInformationAlign64) {
                offset = ALIGN_OFFSET64(base);

            } else {
                offset = ALIGN_OFFSET(base);
            }

#endif

            if (offset > base) {
                requiredlength += (offset - base);
            }

#if DBG && defined(_WIN64)

            //
            // Some clients will have passed in a structure that they "know"
            // will be exactly the right size.  The fact that alignment
            // has changed on NT64 may cause these clients to have problems.
            //
            // The solution is to fix the client, but print out some debug
            // spew here if it looks like this is the case.  This problem
            // isn't particularly easy to spot from the client end.
            //

            if((KeyValueInformationClass == KeyValueFullInformation) &&
                (Length != minimumlength) &&
                (requiredlength > Length) &&
                ((requiredlength - Length) <=
                                (ALIGN_OFFSET64(base) - ALIGN_OFFSET(base)))) {

                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"ntos/config-64 KeyValueFullInformation: "
                                                                 "Possible client buffer size problem.\n"));

                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"    Required size = %d\n", requiredlength));
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"    Supplied size = %d\n", Length));
            }

#endif

        }

        *ResultLength = requiredlength;

        *status = STATUS_SUCCESS;

        if (Length < minimumlength) {

            *status = STATUS_BUFFER_TOO_SMALL;

        } else {

            pbuffer->KeyValueFullInformation.TitleIndex = 0;

            pbuffer->KeyValueFullInformation.Type =
                pcell->u.KeyValue.Type;

            pbuffer->KeyValueFullInformation.DataLength =
                realsize;

            pbuffer->KeyValueFullInformation.NameLength =
                NameLength;

            leftlength = Length - minimumlength;
            requiredlength = NameLength;

            if (leftlength < (LONG)requiredlength) {
                requiredlength = leftlength;
                *status = STATUS_BUFFER_OVERFLOW;
            }

            if (pcell->u.KeyValue.Flags & VALUE_COMP_NAME) {
                CmpCopyCompressedName(pbuffer->KeyValueFullInformation.Name,
                                      requiredlength,
                                      pcell->u.KeyValue.Name,
                                      pcell->u.KeyValue.NameLength);
            } else {
                RtlCopyMemory(
                    &(pbuffer->KeyValueFullInformation.Name[0]),
                    &(pcell->u.KeyValue.Name[0]),
                    requiredlength
                    );
            }

            if (realsize > 0) {

                if (small == TRUE) {
                    datapointer = (PUCHAR)(&(pcell->u.KeyValue.Data));
                } else {
                    SearchValue = CmpGetValueDataFromCache(KeyControlBlock, ContainingList, pcell, ValueCached,&datapointer,&BufferAllocated,&CellToRelease);
                    if( SearchValue != SearchSuccess ) {
                        ASSERT( datapointer == NULL );
                        ASSERT( BufferAllocated == FALSE );
                        *status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                pbuffer->KeyValueFullInformation.DataOffset = offset;

                leftlength = (((LONG)Length - (LONG)offset) < 0) ?
                                    0 :
                                    Length - offset;

                requiredlength = realsize;

                if (leftlength < (LONG)requiredlength) {
                    requiredlength = leftlength;
                    *status = STATUS_BUFFER_OVERFLOW;
                }

                ASSERT((small ? (requiredlength <= CM_KEY_VALUE_SMALL) : TRUE));

                if( datapointer != NULL ) {
                    try {
                        RtlCopyMemory(
                            ((PUCHAR)pbuffer + offset),
                            datapointer,
                            requiredlength
                            );
                    } finally {
                        if( BufferAllocated == TRUE ) {
                            ExFreePool(datapointer);
                        }
                        if( CellToRelease != HCELL_NIL ) {
                            HvReleaseCell(Hive,CellToRelease);
                        }
                    }
                }

            } else {
                pbuffer->KeyValueFullInformation.DataOffset = (ULONG)-1;
            }
        }

        break;


    case KeyValuePartialInformation:

        //
        // TitleIndex, Type, DataLength, Data
        //
        small = CmpIsHKeyValueSmall(realsize, pcell->u.KeyValue.DataLength);
        requiredlength = FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) +
                         realsize;

        minimumlength = FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);

        *ResultLength = requiredlength;

        *status = STATUS_SUCCESS;

        if (Length < minimumlength) {

            *status = STATUS_BUFFER_TOO_SMALL;

        } else {

            pbuffer->KeyValuePartialInformation.TitleIndex = 0;

            pbuffer->KeyValuePartialInformation.Type =
                pcell->u.KeyValue.Type;

            pbuffer->KeyValuePartialInformation.DataLength =
                realsize;

            leftlength = Length - minimumlength;
            requiredlength = realsize;

            if (leftlength < (LONG)requiredlength) {
                requiredlength = leftlength;
                *status = STATUS_BUFFER_OVERFLOW;
            }

            if (realsize > 0) {

                if (small == TRUE) {
                    datapointer = (PUCHAR)(&(pcell->u.KeyValue.Data));
                } else {
                    SearchValue = CmpGetValueDataFromCache(KeyControlBlock, ContainingList, pcell, ValueCached,&datapointer,&BufferAllocated,&CellToRelease);
                    if( SearchValue != SearchSuccess ) {
                        ASSERT( datapointer == NULL );
                        ASSERT( BufferAllocated == FALSE );
                        *status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                ASSERT((small ? (requiredlength <= CM_KEY_VALUE_SMALL) : TRUE));

                if( datapointer != NULL ) {
                    try {
                        RtlCopyMemory((PUCHAR)&(pbuffer->KeyValuePartialInformation.Data[0]),
                                      datapointer,
                                      requiredlength);
                    } finally {
                        if( BufferAllocated == TRUE ) {
                            ExFreePool(datapointer);
                        }
                        if(CellToRelease != HCELL_NIL) {
                            HvReleaseCell(Hive,CellToRelease);
                        }
                    }
                }
            }
        }

        break;
    case KeyValuePartialInformationAlign64:

        //
        // TitleIndex, Type, DataLength, Data
        //
        small = CmpIsHKeyValueSmall(realsize, pcell->u.KeyValue.DataLength);
        requiredlength = FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION_ALIGN64, Data) +
                         realsize;

        minimumlength = FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION_ALIGN64, Data);

        *ResultLength = requiredlength;

        *status = STATUS_SUCCESS;

        if (Length < minimumlength) {

            *status = STATUS_BUFFER_TOO_SMALL;

        } else {

            pbuffer->KeyValuePartialInformationAlign64.Type =
                pcell->u.KeyValue.Type;

            pbuffer->KeyValuePartialInformationAlign64.DataLength =
                realsize;

            leftlength = Length - minimumlength;
            requiredlength = realsize;

            if (leftlength < (LONG)requiredlength) {
                requiredlength = leftlength;
                *status = STATUS_BUFFER_OVERFLOW;
            }

            if (realsize > 0) {

                if (small == TRUE) {
                    datapointer = (PUCHAR)(&(pcell->u.KeyValue.Data));
                } else {
                    SearchValue = CmpGetValueDataFromCache(KeyControlBlock, ContainingList, pcell, ValueCached,&datapointer,&BufferAllocated,&CellToRelease);
                    if( SearchValue != SearchSuccess ) {
                        ASSERT( datapointer == NULL );
                        ASSERT( BufferAllocated == FALSE );
                        *status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                ASSERT((small ? (requiredlength <= CM_KEY_VALUE_SMALL) : TRUE));
                if( datapointer != NULL ) {
                    try {
                        RtlCopyMemory((PUCHAR)&(pbuffer->KeyValuePartialInformationAlign64.Data[0]),
                                      datapointer,
                                      requiredlength);
                    } finally {
                        if( BufferAllocated == TRUE ) {
                            ExFreePool(datapointer);
                        }
                        if(CellToRelease != HCELL_NIL) {
                            HvReleaseCell(Hive,CellToRelease);
                        }
                    }
                }
            }
        }

        break;

    default:
        *status = STATUS_INVALID_PARAMETER;
        break;
    }
    return SearchValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmvalue.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmvalue.c

Abstract:

    This module contains cm routines for operating on (sorted) 
    value list. Insertion, Deletion,Searching  ...

    Routines to deal with a KeyValue data; whether it is small,
    big - new hives format - , or normal

--*/

#include    "cmp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpFindValueByName)
#pragma alloc_text(PAGE,CmpFindNameInList)
#pragma alloc_text(PAGE,CmpAddValueToList)
#pragma alloc_text(PAGE,CmpRemoveValueFromList)
#pragma alloc_text(PAGE,CmpGetValueData)
#pragma alloc_text(PAGE,CmpMarkValueDataDirty)
#pragma alloc_text(PAGE,CmpFreeValue)
#pragma alloc_text(PAGE,CmpSetValueDataNew)
#pragma alloc_text(PAGE,CmpSetValueDataExisting)
#pragma alloc_text(PAGE,CmpFreeValueData)
#pragma alloc_text(PAGE,CmpValueToData)
#endif

HCELL_INDEX
CmpFindValueByName(
    PHHIVE Hive,
    PCM_KEY_NODE KeyNode,
    PUNICODE_STRING Name
    )
/*++

Routine Description:

    Underlying CmpFindNameInList was changed to return an error code;
    Had to make it a function instead of a macro

Arguments:

    Hive - pointer to hive control structure for hive of interest


Return Value:


  HCELL_INDEX or HCELL_NIL on error
--*/
{                                                                                   
    HCELL_INDEX CellIndex;                                                          

    CM_PAGED_CODE();
    
    if( CmpFindNameInList(Hive,&((KeyNode)->ValueList),Name,NULL,&CellIndex) == FALSE ) {  
        //
        // above should set this right
        //
        ASSERT( CellIndex == HCELL_NIL );
    }                                                                               
    return CellIndex;
}

BOOLEAN
CmpFindNameInList(
    IN PHHIVE  Hive,
    IN PCHILD_LIST ChildList,
    IN PUNICODE_STRING Name,
    IN OPTIONAL PULONG ChildIndex,
    OUT PHCELL_INDEX    CellIndex
    )
/*++

Routine Description:

    Find a child object in an object list. Child List must be sorted
    based on the name. (for new hives format)

Arguments:

    Hive - pointer to hive control structure for hive of interest

    List - pointer to mapped in list structure

    Count - number of elements in list structure

    Name - name of child object to find

    ChildIndex - pointer to variable to receive index for child; 

    CellIndex - pointer to receive the index of the child.
                On return, this is:
                    HCELL_INDEX for the found cell
                    HCELL_NIL if not found


Return Value:

    TRUE - success
    FALSE - error, insufficient resources

Notes:
    
    ChildIndex is always filled with the position where Name should be in the list.
    The difference whether Name is in the list or not is made upon CellIndex
        - CellIndex == HCELL_NIL ==> Name not found in the list
        - CellIndex <> HCELL_NIL ==> Name already exists in the list

--*/
{
    PCM_KEY_VALUE   pchild;
    UNICODE_STRING  Candidate;
    LONG            Result;
    PCELL_DATA      List = NULL;
    ULONG           Current;
    HCELL_INDEX     CellToRelease = HCELL_NIL;
    BOOLEAN         ReturnValue = FALSE;

    CM_PAGED_CODE();
    
    if (ChildList->Count != 0) {
        List = (PCELL_DATA)HvGetCell(Hive,ChildList->List);
        if( List == NULL ) {
            //
            // we could not map the view containing the cell
            //
            *CellIndex = HCELL_NIL;
            return FALSE;
        }

        //
        // old plain hive; simulate a for
        //
        Current = 0;
    
        while( TRUE ) {

            if( CellToRelease != HCELL_NIL ) {
                HvReleaseCell(Hive,CellToRelease);
                CellToRelease = HCELL_NIL;
            }
            pchild = (PCM_KEY_VALUE)HvGetCell(Hive, List->u.KeyList[Current]);
            if( pchild == NULL ) {
                //
                // we could not map the view containing the cell
                //
                *CellIndex = HCELL_NIL;
                ReturnValue = FALSE;
                goto JustReturn;
            }
            CellToRelease = List->u.KeyList[Current];

            if (pchild->Flags & VALUE_COMP_NAME) {
                Result = CmpCompareCompressedName(Name,
                                                   pchild->Name,
                                                   pchild->NameLength,
                                                   0);
            } else {
                Candidate.Length = pchild->NameLength;
                Candidate.MaximumLength = Candidate.Length;
                Candidate.Buffer = pchild->Name;
                Result = RtlCompareUnicodeString(Name,
                                                   &Candidate,
                                                   TRUE);
            }

            if (Result == 0) {
                //
                // Success, return data to caller and exit
                //

                if (ARGUMENT_PRESENT(ChildIndex)) {
                    *ChildIndex = Current;
                }
                *CellIndex = List->u.KeyList[Current];
                ReturnValue = TRUE;
                goto JustReturn;
            }
            //
            // compute the next index to try: old'n plain hive; go on
			//
            Current++;
            if( Current == ChildList->Count ) {
                //
                // we've reached the end of the list
                //
                if (ARGUMENT_PRESENT(ChildIndex)) {
                    *ChildIndex = Current;
                }
                //
                // nicely return
                //
                *CellIndex = HCELL_NIL;
                ReturnValue = TRUE;
                goto JustReturn;
            }
        }
    }
    //
    // in the new design we shouldn't get here; we should exit the while loop with return
    //
    ASSERT( ChildList->Count == 0 );    

    // add it first; as it's the only one
    if (ARGUMENT_PRESENT(ChildIndex)) {
        *ChildIndex = 0;
    }
    *CellIndex = HCELL_NIL;
    return TRUE;

JustReturn:
    if( List != NULL ) {
        HvReleaseCell(Hive,ChildList->List);
    }
    if( CellToRelease != HCELL_NIL ) {
        HvReleaseCell(Hive,CellToRelease);
    }
    return ReturnValue;

}

BOOLEAN
CmpGetValueData(IN PHHIVE Hive,
                IN PCM_KEY_VALUE Value,
                OUT PULONG realsize,
                IN OUT PVOID *Buffer, 
                OUT PBOOLEAN Allocated,
                OUT PHCELL_INDEX CellToRelease
               )
/*++

Routine Description:

    Retrieves the real valueData, given the key value.
    

Arguments:

    Hive - pointer to hive control structure for hive of interest

    Value - CM_KEY_VALUE to retrieve the data for.

    realsize - the actual size of the data (in bytes)

    Buffer - pointer to the data; if the cell is a BIG_CELL
            we should allocate a buffer 

    Allocated - here we signal the caller that he has to free the 
            buffer on return;
            TRUE - a new buffer was allocated to gather together the BIG_CELL data
            FALSE - Buffer points directly in the hive, the caller shouldn't free it

    CellToRelease - Cell to release after finishing work with Buffer

Return Value:

    TRUE - success

    FALSE - not enough resources available; (to map a cell or to allocate the buffer)

Notes:
    
    The caller is responsible to remove the buffer, when Allocated is set on TRUE on return;

--*/
{
   
    CM_PAGED_CODE();

    ASSERT_KEY_VALUE(Value);
    //
    // normally we don't allocate buffer
    //
    *Allocated = FALSE;
    *Buffer = NULL;
    *CellToRelease = HCELL_NIL;

    //
    // check for small values
    //
    if( CmpIsHKeyValueSmall(*realsize, Value->DataLength) == TRUE ) {
        //
        // data is stored inside the cell
        //
        *Buffer = &Value->Data;
        return TRUE;
    }

    //
    // check for big values
    //
    if( CmpIsHKeyValueBig(Hive,*realsize) == TRUE ) {
        //
        //
        //
        PCM_BIG_DATA    BigData = NULL;
        PUCHAR          WorkBuffer = NULL;
        ULONG           Length;
        USHORT          i;
        PUCHAR          PartialData;
        PHCELL_INDEX    Plist = NULL;
        BOOLEAN         bRet = TRUE;
        
        try {
            BigData = (PCM_BIG_DATA)HvGetCell(Hive,Value->Data);
            if( BigData == NULL ) {
                //
                // cannot map view containing the cell; bail out
                //
                bRet = FALSE;
                leave;
            }

            ASSERT_BIG_DATA(BigData);

            Plist = (PHCELL_INDEX)HvGetCell(Hive,BigData->List);
            if( Plist == NULL ) {
                //
                // cannot map view containing the cell; bail out
                //
                bRet = FALSE;
                leave;
            }

            Length = Value->DataLength;
            //
            // sanity check
            //
            ASSERT( Length <= (ULONG)(BigData->Count * CM_KEY_VALUE_BIG) );

            //
            // allocate a buffer to merge bring all the pieces together
            //
            WorkBuffer = (PUCHAR)ExAllocatePoolWithTag(PagedPool, Length, CM_POOL_TAG);
            if( WorkBuffer == NULL ){
                bRet = FALSE;
                leave;
            }
        
            for(i=0;i<BigData->Count;i++) {
                //
                // sanity check
                //
                ASSERT( Length > 0 );

                PartialData = (PUCHAR)HvGetCell(Hive,Plist[i]);
                if( PartialData == NULL ){
                    //
                    // cannot map view containing the cell; bail out
                    //
                    ExFreePool(WorkBuffer);
                    bRet = FALSE;
                    leave;
                }
            
                //
                // copy this piece of data to the work buffer
                //
                RtlCopyMemory(WorkBuffer + CM_KEY_VALUE_BIG*i,PartialData,(Length>CM_KEY_VALUE_BIG)?CM_KEY_VALUE_BIG:Length);
                HvReleaseCell(Hive,Plist[i]);

                //
                // adjust the data still to copy.
                // All cells in Plist should be of size CM_KEY_VALUE_BIG, except the last one, which is the remaining
                //
                Length -= CM_KEY_VALUE_BIG;
            }
        } finally {
            if( BigData != NULL ) {
                HvReleaseCell(Hive,Value->Data);
                if( Plist != NULL ) {
                    HvReleaseCell(Hive,BigData->List);
                }
            }
        }
        if( !bRet ) {
            return FALSE;
        }
        //
        // if we are here; we successfuly have copied all data into WorkBuffer.
        // update the return buffer and return; Caller is responsible to free the return buffer
        // We signal the caller by setting Allocated on TRUE
        //
        *Buffer = WorkBuffer;
        *Allocated = TRUE;
        return TRUE;
    }

    //
    // normal, old plain case
    //
    *Buffer = HvGetCell(Hive,Value->Data);
    if( *Buffer == NULL ) {
        //
        // insufficient resources to map the view containing this cell
        //
        return FALSE;
    }
    //
    // signal to the caller to release this cell after finishing with buffer
    //
    *CellToRelease = Value->Data;
    
    return TRUE;
}
               
PCELL_DATA 
CmpValueToData(IN PHHIVE Hive,
               IN PCM_KEY_VALUE Value,
               OUT PULONG realsize
               )              
/*++

Routine Description:

    Retrieves the real valueData, given the key value.

Arguments:

    Hive - pointer to hive control structure for hive of interest

    Value - CM_KEY_VALUE to retrieve the data for.

    realsize - the actual size of the data (in bytes)


Return Value:

    pointer to the value data; NULL if any error (insufficient resources)

Notes:
    
    This function doesn't support big cells; It is intended to be called just
    by the loader, which doesn't store large data. It'll bugcheck if big cell
    is queried.

--*/
{
    PCELL_DATA  Buffer;
    BOOLEAN     BufferAllocated;
    HCELL_INDEX CellToRelease;

    CM_PAGED_CODE();

    ASSERT( Hive->ReleaseCellRoutine == NULL );

    if( CmpGetValueData(Hive,Value,realsize,&Buffer,&BufferAllocated,&CellToRelease) == FALSE ) {
        //
        // insufficient resources; return NULL
        //
        ASSERT( BufferAllocated == FALSE );
        ASSERT( Buffer == NULL );
        return NULL;
    }
    
    //
    // we specifically ignore CellToRelease as this is not a mapped view
    //
    if( BufferAllocated == TRUE ) {
        //
        // this function is not intended for big cells;
        //
        ExFreePool( Buffer );
        CM_BUGCHECK( REGISTRY_ERROR,BIG_CELL_ERROR,0,Hive,Value);
    }
    
    //
    // success
    //
    return Buffer;
}


NTSTATUS
CmpAddValueToList(
    IN PHHIVE  Hive,
    IN HCELL_INDEX ValueCell,
    IN ULONG Index,
    IN ULONG Type,
    IN OUT PCHILD_LIST ChildList
    )
/*++

Routine Description:

    Adds a value to the value list, keeping the list sorted 
    (for new hives format)

Arguments:

    Hive - pointer to hive control structure for hive of interest

    ValueCell - value index

    Index - index at which to add the value 

    ChildList - pointer to the list of values


Return Value:

    STATUS_SUCCESS - success

    STATUS_INSUFFICIENT_RESOURCES - an error occured

--*/
{
    HCELL_INDEX     NewCell;
    ULONG           count;
    ULONG           AllocateSize;
    ULONG           i;
    PCELL_DATA      pdata;

    CM_PAGED_CODE();

    //
    // we have the lock exclusive or nobody is operating inside this hive
    //
    ASSERT_HIVE_FLUSHER_LOCKED((PCMHIVE)Hive);

    //
    // sanity check for index range
    //
    ASSERT( (((LONG)Index) >= 0) && (Index <= ChildList->Count) );

    count = ChildList->Count;
    count++;
    if (count > 1) {

        ASSERT_CELL_DIRTY(Hive,ChildList->List);

        if (count < CM_MAX_REASONABLE_VALUES) {

            //
            // A reasonable number of values, allocate just enough
            // space.
            //

            AllocateSize = count * sizeof(HCELL_INDEX);
        } else {

            //
            // An excessive number of values, pad the allocation out
            // to avoid fragmentation. (if there's this many values,
            // there'll probably be more pretty soon)
            //
            AllocateSize = ROUND_UP(count, CM_MAX_REASONABLE_VALUES) * sizeof(HCELL_INDEX);
            if (AllocateSize > HBLOCK_SIZE) {
                AllocateSize = ROUND_UP(AllocateSize, HBLOCK_SIZE);
            }
        }

        NewCell = HvReallocateCell(
                        Hive,
                        ChildList->List,
                        AllocateSize
                        );
    } else {
        NewCell = HvAllocateCell(Hive, sizeof(HCELL_INDEX), Type,ValueCell);
    }

    //
    // put ourselves on the list
    //
    if (NewCell != HCELL_NIL) {
        // sanity
        ChildList->List = NewCell;

        pdata = HvGetCell(Hive, NewCell);
        if( pdata == NULL ) {
            //
            // we couldn't map a view for the bin containing this cell
            //

            //
            // normally this shouldn't happen as we just allocated ValueCell
            // i.e. the bin containing NewCell should be mapped in memory at this point.
            //
            ASSERT( FALSE );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        
        //
        // make room for the new cell; move values in the reverse order !
        // adding at the end makes this a nop
        //
        for( i = count - 1; i > Index; i-- ) {
            pdata->u.KeyList[i] = pdata->u.KeyList[i-1];
        }
        pdata->u.KeyList[Index] = ValueCell;
        ChildList->Count = count;

        HvReleaseCell(Hive,NewCell);
        // sanity
        ASSERT_CELL_DIRTY(Hive,ValueCell);

    } else {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
CmpRemoveValueFromList(
    IN PHHIVE  Hive,
    IN ULONG Index,
    IN OUT PCHILD_LIST ChildList
    )
/*++

Routine Description:

    Removes the value at the specified index from the value list

Arguments:

    Hive - pointer to hive control structure for hive of interest

    Index - index at which to add the value 

    ChildList - pointer to the list of values

Return Value:

    STATUS_SUCCESS - success

    STATUS_INSUFFICIENT_RESOURCES - an error occured

Notes:
    
    The caller is responsible for freeing the removed value

--*/
{
    ULONG       newcount;
    HCELL_INDEX newcell;

    CM_PAGED_CODE();

    //
    // sanity check for index range
    //
    ASSERT( (((LONG)Index) >= 0) && (Index <= ChildList->Count) );

    newcount = ChildList->Count - 1;

    if (newcount > 0) {
        PCELL_DATA pvector;

        //
        // more than one entry list, squeeze
        //
        pvector = HvGetCell(Hive, ChildList->List);
        if( pvector == NULL ) {
            //
            // we couldn't map a view for the bin containing this cell
            //
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        // sanity
        ASSERT_CELL_DIRTY(Hive,ChildList->List);
        ASSERT_CELL_DIRTY(Hive,pvector->u.KeyList[Index]);

        for ( ; Index < newcount; Index++) {
            pvector->u.KeyList[ Index ] = pvector->u.KeyList[ Index + 1 ];
        }

        newcell = HvReallocateCell(
                    Hive,
                    ChildList->List,
                    newcount * sizeof(HCELL_INDEX)
                    );
        ASSERT(newcell != HCELL_NIL);
        HvReleaseCell(Hive,ChildList->List);
        ChildList->List = newcell;

    } else {

        //
        // list is empty, free it
        //
        HvFreeCell(Hive, ChildList->List);
        ChildList->List = HCELL_NIL;
    }
    ChildList->Count = newcount;

    return STATUS_SUCCESS;
}


BOOLEAN
CmpMarkValueDataDirty(  IN PHHIVE Hive,
                        IN PCM_KEY_VALUE Value
                      )
/*++

Routine Description:

    Marks the cell(s) storing the value data as dirty;
    Knows how to deal with bigcells

Arguments:

    Hive - pointer to hive control structure for hive of interest

    Value - CM_KEY_VALUE to retrieve the data for.

Return Value:

    TRUE - success
    FALSE - failure to mark all the cells involved; 

--*/
{
    ULONG   realsize;

    CM_PAGED_CODE();

    //
    // we have the lock exclusive or nobody is operating inside this hive
    //
    ASSERT_HIVE_FLUSHER_LOCKED((PCMHIVE)Hive);

    ASSERT_KEY_VALUE(Value);

    if( Value->Data != HCELL_NIL ) {
        //
        // Could be that value was just partially initialized (CmpSetValueKeyNew case)
        //
        //
        // check for small values
        //
        if( CmpIsHKeyValueSmall(realsize, Value->DataLength) == TRUE ) {
            //
            // data is stored inside the cell
            //
            return TRUE;
        }

        //
        // check for big values
        //
        if( CmpIsHKeyValueBig(Hive,realsize) == TRUE ) {
            //
            //
            //
            PCM_BIG_DATA    BigData;
            PHCELL_INDEX    Plist;
            USHORT          i;
        
            BigData = (PCM_BIG_DATA)HvGetCell(Hive,Value->Data);
            if( BigData == NULL ) {
                //
                // cannot map view containing the cell; bail out
                //
                return FALSE;
            }

            ASSERT_BIG_DATA(BigData);

            if( BigData->List != HCELL_NIL ) {
                Plist = (PHCELL_INDEX)HvGetCell(Hive,BigData->List);
                if( Plist == NULL ) {
                    //
                    // cannot map view containing the cell; bail out
                    //
                    HvReleaseCell(Hive,Value->Data);
                    return FALSE;
                }


                for(i=0;i<BigData->Count;i++) {
                    //
                    // mark this chunk dirty
                    //
                    if( Plist[i] != HCELL_NIL ) {
                        if (! HvMarkCellDirty(Hive, Plist[i],FALSE)) {
                            HvReleaseCell(Hive,Value->Data);
                            HvReleaseCell(Hive,BigData->List);
                            return FALSE;
                        }
                    }
                }
                //
                // mark the list as dirty
                //
                if (! HvMarkCellDirty(Hive, BigData->List,FALSE)) {
                    HvReleaseCell(Hive,Value->Data);
                    HvReleaseCell(Hive,BigData->List);
                    return FALSE;
                }
                //
                // we can safely remove it here as it is now dirty/pinned
                //
                HvReleaseCell(Hive,BigData->List);
            }
            //
            // we don't need this cell anymore
            //
            HvReleaseCell(Hive,Value->Data);
            //
            // fall through to mark the cell itself as dirty
            //
        }

        //
        // Data is a HCELL_INDEX; mark it dirty
        //
        if (! HvMarkCellDirty(Hive, Value->Data,FALSE)) {
            return FALSE;
        }
    }
    
    return TRUE;
}

BOOLEAN
CmpFreeValueData(
    PHHIVE      Hive,
    HCELL_INDEX DataCell,
    ULONG       DataLength
    )
/*++

Routine Description:

    Free the Value Data DataCell carries with.

Arguments:

    Hive - supplies a pointer to the hive control structure for the hive

    DataCell - supplies index of value who's data to free

    DataLength - length of the data; used to detect the type of the cell

Return Value:

    TRUE: Success
    FALSE: Error
  
Notes:
    
      Knows how to deal with big cell(s)

--*/
{
    ULONG           realsize;

    CM_PAGED_CODE();

    //
    // check for small values
    //
    if( CmpIsHKeyValueSmall(realsize, DataLength) == TRUE ) {
        //
        // data is stored inside the cell; this is a nop
        //
    } else {
        //
        // Could be that value was just partially initialized (CmpSetValueKeyNew case)
        //
        if( DataCell == HCELL_NIL ) {
            return TRUE;
        }

        ASSERT(HvIsCellAllocated(Hive,DataCell));
        //
        // check for big values
        //
        if( CmpIsHKeyValueBig(Hive,realsize) == TRUE ) {
            //
            //
            //
            PCM_BIG_DATA    BigData;
            PHCELL_INDEX    Plist;
            USHORT          i;

            BigData = (PCM_BIG_DATA)HvGetCell(Hive,DataCell);
            if( BigData == NULL ) {
                //
                // cannot map view containing the cell; bail out
                // 
                // This shouldn't happen as this cell is marked dirty by
                // this time (i.e. its view is pinned in memory)
                //
                ASSERT( FALSE );
                return FALSE;
            }

            ASSERT_BIG_DATA(BigData);

            if( BigData->List != HCELL_NIL ) {
                Plist = (PHCELL_INDEX)HvGetCell(Hive,BigData->List);
                if( Plist == NULL ) {
                    //
                    // cannot map view containing the cell; bail out
                    //
                    // 
                    // This shouldn't happen as this cell is marked dirty by
                    // this time (i.e. its view is pinned in memory)
                    //
                    ASSERT( FALSE );
                    HvReleaseCell(Hive,DataCell);
                    return FALSE;
                }

                for(i=0;i<BigData->Count;i++) {
                    //
                    // mark this chunk dirty
                    //
                    if( Plist[i] != HCELL_NIL ) {
                        HvFreeCell(Hive, Plist[i]);
                    }
                }
                HvReleaseCell(Hive,BigData->List);
                //
                // mark the list as dirty
                //
                HvFreeCell(Hive, BigData->List);
            }
            //
            // fall through to free the cell data itself
            //
            HvReleaseCell(Hive,DataCell);
        }
        //
        // normal case free the Data cell
        //
        HvFreeCell(Hive, DataCell);
    }
    
    return TRUE;
}


BOOLEAN
CmpFreeValue(
    PHHIVE Hive,
    HCELL_INDEX Cell
    )
/*++

Routine Description:

    Free the value entry Hive.Cell refers to, including
    its name and data cells.

Arguments:

    Hive - supplies a pointer to the hive control structure for the hive

    Cell - supplies index of value to delete

Return Value:

    TRUE: Success
    FALSE: Error
  

--*/
{
    PCM_KEY_VALUE   Value;

    CM_PAGED_CODE();

    //
    // map in the cell
    //
    Value = (PCM_KEY_VALUE)HvGetCell(Hive, Cell);
    if( Value == NULL ) {
        //
        // we couldn't map the bin containing this cell
        // sorry we cannot free value
        // 
        // This shouldn't happen as the value is marked dirty by
        // this time (i.e. its view is pinned in memory)
        //
        ASSERT( FALSE );
        return FALSE;
    }

    if( CmpFreeValueData(Hive,Value->Data,Value->DataLength) == FALSE ) {
        HvReleaseCell(Hive,Cell);
        return FALSE;
    }

    HvReleaseCell(Hive,Cell);
    //
    // free the cell itself
    //
    HvFreeCell(Hive, Cell);

    return TRUE;
}

NTSTATUS
CmpSetValueDataNew(
    IN PHHIVE           Hive,
    IN PVOID            Data,
    IN ULONG            DataSize,
    IN ULONG            StorageType,
    IN HCELL_INDEX      ValueCell,
    OUT PHCELL_INDEX    DataCell
    )
/*++

Routine Description:

    Allocates a new cell (or big data cell) to accommodate DataSize;
    Initialize and copy information from Data to the new cell;

Arguments:

    Hive - supplies a pointer to the hive control structure for the hive
    
    Data - data buffer (possibly from user-mode)

    DataSize - size of the buffer

    StorageType - Stable or Volatile

    ValueCell - The value setting the data for (locality purposes).

    DataCell - return value:HCELL_INDEX of the new cell; HCELL_NIL on some error

Return Value:

    Status of the operation (STATUS_SUCCESS or the exception code - if any)

Notes:
        
      Knows how to deal with big cell(s)
      Data buffer comes from user mode, so it should be guarded by a try-except

--*/
{
    PCELL_DATA          pdata;
    HV_TRACK_CELL_REF   CellRef = {0};
    
    CM_PAGED_CODE();

    ASSERT_HIVE_FLUSHER_LOCKED((PCMHIVE)Hive);

    //
    // bogus args; we don't deal with small values here!
    //
    ASSERT(DataSize > CM_KEY_VALUE_SMALL);

    if( CmpIsHKeyValueBig(Hive,DataSize) == TRUE ) {
        //
        // request for a big data value
        //
        PCM_BIG_DATA    BigData = NULL;
        USHORT          Count;
        PHCELL_INDEX    Plist = NULL;
        NTSTATUS        status = STATUS_INSUFFICIENT_RESOURCES;

        //
        // allocate the embedding cell
        //
        *DataCell = HvAllocateCell(Hive, sizeof(CM_BIG_DATA), StorageType,ValueCell);
        if (*DataCell == HCELL_NIL) {
            return status;
        }
        
        //
        // init the BIG_DATA cell
        //
        BigData = (PCM_BIG_DATA)HvGetCell(Hive,*DataCell);
        if( BigData == NULL) {
            //
            // couldn't map view for this cell
            // this shouldn't happen as we just allocated this cell 
            // (i.e. its view should be pinned in memory)
            //
            ASSERT( FALSE );
            goto Cleanup;
        }

        if( !HvTrackCellRef(&CellRef,Hive,*DataCell) ) {
            goto Cleanup;
        }

        BigData->Signature = CM_BIG_DATA_SIGNATURE;
        BigData->Count = 0;
        BigData->List = HCELL_NIL;

        //
        // Compute the number of cells needed
        //
        Count = (USHORT)((DataSize + CM_KEY_VALUE_BIG - 1) / CM_KEY_VALUE_BIG);

        //
        // allocate the embedded list
        //
        BigData->List = HvAllocateCell(Hive, Count * sizeof(HCELL_INDEX), StorageType,*DataCell);
        if( BigData->List == HCELL_NIL ) {
            goto Cleanup;
        }

        Plist = (PHCELL_INDEX)HvGetCell(Hive,BigData->List);
        if( Plist == NULL ) {
            //
            // cannot map view containing the cell; bail out
            //
            // 
            // This shouldn't happen as this cell is marked dirty by
            // this time (i.e. its view is pinned in memory)
            //
            ASSERT( FALSE );
            goto Cleanup;
        }

        if( !HvTrackCellRef(&CellRef,Hive,BigData->List) ) {
            goto Cleanup;
        }

        //
        // allocate each chunk and copy the data; if we fail part through, we'll free the already allocated values
        //
        for( ;BigData->Count < Count;(BigData->Count)++) {
            //
            // allocate this chunk
            //
            Plist[BigData->Count] = HvAllocateCell(Hive, CM_KEY_VALUE_BIG, StorageType,BigData->List);
            if( Plist[BigData->Count] == HCELL_NIL ) {
                goto Cleanup;
            }
            pdata = HvGetCell(Hive,Plist[BigData->Count]);
            if( pdata == NULL ) {
                //
                // cannot map view containing the cell; bail out
                //
                // 
                // This shouldn't happen as this cell is marked dirty by
                // this time (i.e. its view is pinned in memory)
                //
                ASSERT( FALSE );
                goto Cleanup;
            }

            if( !HvTrackCellRef(&CellRef,Hive,Plist[BigData->Count]) ) {
                goto Cleanup;
            }

            //
            // now, copy this chunk data
            //
            try {

                RtlCopyMemory(pdata, (PUCHAR)Data, (DataSize>CM_KEY_VALUE_BIG)?CM_KEY_VALUE_BIG:DataSize);

            } except (EXCEPTION_EXECUTE_HANDLER) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!CmpSetValueDataNew: code:%08lx\n", GetExceptionCode()));

                status = GetExceptionCode();
                goto Cleanup;
            }
            
            //
            // update the data pointer and the remaining size
            //
            Data = (PVOID)((PCHAR)Data + CM_KEY_VALUE_BIG);
            DataSize -= CM_KEY_VALUE_BIG;

        }
        
        ASSERT( Count == BigData->Count );
        HvReleaseFreeCellRefArray(&CellRef);
        return STATUS_SUCCESS;

Cleanup:
        //
        // free what we already allocated
        //
        if( BigData != NULL) {
            if( Plist != NULL ) {
                for(;BigData->Count;BigData->Count--) {
                    if( Plist[BigData->Count] != HCELL_NIL ) {
                        HvFreeCell(Hive, Plist[BigData->Count]);
                    }
                }
            } else {
                ASSERT( BigData->Count == 0 );
            }

            if( BigData->List != HCELL_NIL ) {
                HvFreeCell(Hive, BigData->List);
            }
        }

        HvFreeCell(Hive, *DataCell);
        *DataCell = HCELL_NIL;
        HvReleaseFreeCellRefArray(&CellRef);
        return status;
    } else {
        //
        // normal old'n plain value
        //
        *DataCell = HvAllocateCell(Hive, DataSize, StorageType,ValueCell);
        if (*DataCell == HCELL_NIL) {
            HvReleaseFreeCellRefArray(&CellRef);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        pdata = HvGetCell(Hive, *DataCell);
        if( pdata == NULL ) {
            //
            // we couldn't map a view for the bin containing this cell
            //

            //
            // normally this shouldn't happen as we just allocated ValueCell
            // i.e. the bin containing DataCell should be mapped in memory at this point.
            //
            ASSERT( FALSE );
            if (*DataCell != HCELL_NIL) {
                HvFreeCell(Hive, *DataCell);
                *DataCell = HCELL_NIL;
            }
            HvReleaseFreeCellRefArray(&CellRef);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        if( !HvTrackCellRef(&CellRef,Hive,*DataCell) ) {
            HvReleaseFreeCellRefArray(&CellRef);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        //
        // copy the actual data, guarding the buffer as it may be a user-mode buffer
        //
        try {

            RtlCopyMemory(pdata, Data, DataSize);

        } except (EXCEPTION_EXECUTE_HANDLER) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!CmpSetValueDataNew: code:%08lx\n", GetExceptionCode()));

            //
            // We have bombed out loading user data, clean up and exit.
            //
            if (*DataCell != HCELL_NIL) {
                HvFreeCell(Hive, *DataCell);
                *DataCell = HCELL_NIL;
            }
            HvReleaseFreeCellRefArray(&CellRef);
            return GetExceptionCode();
        }
    }

    HvReleaseFreeCellRefArray(&CellRef);
    return STATUS_SUCCESS;
}

NTSTATUS
CmpSetValueDataExisting(
    IN PHHIVE           Hive,
    IN PVOID            Data,
    IN ULONG            DataSize,
    IN ULONG            StorageType,
    IN HCELL_INDEX      OldDataCell
    )
/*++

Routine Description:

    Grows an existing big data cell and copies the new data into it.

Arguments:

    Hive - supplies a pointer to the hive control structure for the hive
    
    Data - data buffer (possibly from user-mode)

    DataSize - size of the buffer

    StorageType - Stable or Volatile

    OldDataCell - old big data cell
      
    NewDataCell - return value:HCELL_INDEX of the new cell; HCELL_NIL on some error

Return Value:

    Status of the operation (STATUS_SUCCESS or the exception code - if any)

Notes:
        
      Knows how to deal with big cell(s)
      Data buffer is secured by the time this function is called

--*/
{
    PCELL_DATA      pdata;
    PCM_BIG_DATA    BigData = NULL;
    USHORT          NewCount,i;
    PHCELL_INDEX    Plist = NULL;
    HCELL_INDEX     NewList;
    HV_TRACK_CELL_REF   CellRef = {0};
    NTSTATUS        Status;

    CM_PAGED_CODE();

    //
    // bogus args; we deal only with big data cells!
    //
    ASSERT(DataSize > CM_KEY_VALUE_BIG );

    
    BigData = (PCM_BIG_DATA)HvGetCell(Hive,OldDataCell);
    if( BigData == NULL) {
        //
        // couldn't map view for this cell
        // this shouldn't happen as we just marked it as dirty
        // (i.e. its view should be pinned in memory)
        //
        ASSERT( FALSE );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if( !HvTrackCellRef(&CellRef,Hive,OldDataCell) ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT_BIG_DATA(BigData);


    
    Plist = (PHCELL_INDEX)HvGetCell(Hive,BigData->List);
    if( Plist == NULL ) {
        //
        // cannot map view containing the cell; bail out
        // this shouldn't happen as we just marked it as dirty
        // (i.e. its view should be pinned in memory)
        //
        ASSERT(FALSE);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if( !HvTrackCellRef(&CellRef,Hive,BigData->List) ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    //
    // what's the new size?
    //
    NewCount = (USHORT)((DataSize + CM_KEY_VALUE_BIG - 1) / CM_KEY_VALUE_BIG);

    if( NewCount > BigData->Count ) {
        //
        // grow the list and allocate additional cells to it
        //
        NewList = HvReallocateCell(Hive,BigData->List,NewCount * sizeof(HCELL_INDEX));
        if( NewList == HCELL_NIL ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit;
        }

        //
        // we can now safely alter the list; if allocating the additional cells below fails
        // we'll end up with some wasted space, but we'll be safe
        //
        BigData->List = NewList;

        //
        // read the new list
        //
        Plist = (PHCELL_INDEX)HvGetCell(Hive,NewList);
        if( Plist == NULL ) {
            //
            // cannot map view containing the cell; bail out
            // this shouldn't happen as we just reallocated the cell
            // (i.e. its view should be pinned in memory)
            //
            ASSERT(FALSE);
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit;
        }

        if( !HvTrackCellRef(&CellRef,Hive,NewList) ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit;
        }

        for(i= BigData->Count;i<NewCount;i++) {
            Plist[i] = HvAllocateCell(Hive, CM_KEY_VALUE_BIG, StorageType,NewList);
            if( Plist[i] == HCELL_NIL ) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto ErrorExit;
            }
        }
    } else if( NewCount < BigData->Count ) {
        //
        // shrink the list and free additional unnecessary cells
        //
        for(i=NewCount;i<BigData->Count;i++) {
            //
            // this CANNOT fail as the cell is already marked dirty (i.e. pinned in memory).
            //
            HvFreeCell(Hive,Plist[i]);
        }
        //
        // this WON'T fail, 'cause it's a shrink
        //
        NewList = HvReallocateCell(Hive,BigData->List,NewCount * sizeof(HCELL_INDEX));
        if( NewList == HCELL_NIL ) {
            ASSERT( FALSE );
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit;
        }

        //
        // read the new list (in the current implementation we don't shrink cells, 
        // so this is not really needed - just to be consistent)
        //
        Plist = (PHCELL_INDEX)HvGetCell(Hive,NewList);
        if( Plist == NULL ) {
            //
            // cannot map view containing the cell; bail out
            // this shouldn't happen as we just reallocated the cell
            // (i.e. its view should be pinned in memory)
            //
            ASSERT(FALSE);
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit;
        }

        if( !HvTrackCellRef(&CellRef,Hive,NewList) ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit;
        }

        //
        // we can now safely alter the list
        //
        BigData->List = NewList;
    }

    //
    // if we came to this point, we have successfully grown the list and 
    // allocated the additional space; nothing should go wrong further
    //

    //
    // go on and fill in the data onto the (new) big data cell
    //
    for( i=0;i<NewCount;i++) {
        pdata = HvGetCell(Hive,Plist[i]);
        if( pdata == NULL ) {
            //
            // cannot map view containing the cell; bail out
            //
            // 
            // This shouldn't happen as this cell is marked dirty by
            // this time - or is a new allocated cell 
            // (i.e. its view is pinned in memory)
            //
            ASSERT( FALSE );
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit;
        }

        //
        // now, copy this chunk data
        //
        try {
            RtlCopyMemory(pdata, (PUCHAR)Data, (DataSize>CM_KEY_VALUE_BIG)?CM_KEY_VALUE_BIG:DataSize);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
            goto ErrorExit;
        }

        //
        // update the data pointer and the remaining size
        //
        Data = (PVOID)((PCHAR)Data + CM_KEY_VALUE_BIG);
        DataSize -= CM_KEY_VALUE_BIG;
        HvReleaseCell(Hive,Plist[i]);
    }
    

    BigData->Count = NewCount;
    HvReleaseFreeCellRefArray(&CellRef);
    return STATUS_SUCCESS;

ErrorExit:
    HvReleaseFreeCellRefArray(&CellRef);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmtredel.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmtredel.c

Abstract:

    This file contains code for CmpDeleteTree, and support.

--*/

#include    "cmp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpDeleteTree)
#pragma alloc_text(PAGE,CmpFreeKeyByCell)
#pragma alloc_text(PAGE,CmpMarkKeyDirty)
#endif

//
// Routine to actually call to do a tree delete
//

VOID
CmpDeleteTree(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    )
/*++

Routine Description:

    Delete all child subkeys, recursively, of Hive.Cell.  Delete all
    value entries of Hive.Cell.  Do NOT delete Hive.Cell itself.

    NOTE:   If this call fails part way through, it will NOT undo
            any successfully completed deletes.

    NOTE:   This algorithm can deal with a hive of any depth, at the
            cost of some "redundent" scaning and mapping.

Arguments:

    Hive - pointer to hive control structure for hive to delete from

    Cell - index of cell at root of tree to delete

Return Value:

    BOOLEAN - Result code from call, among the following:
        TRUE - it worked
        FALSE - the tree delete was not completed (though more than 0
                keys may have been deleted)

--*/
{
    ULONG  count;
    HCELL_INDEX ptr1;
    HCELL_INDEX ptr2;
    HCELL_INDEX parent;
    PCM_KEY_NODE Node;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"CmpDeleteTree:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tHive=%p Cell=%08lx\n",Hive,Cell));

    //
    // we have the lock exclusive or nobody is operating inside this hive
    //
    ASSERT_CM_EXCLUSIVE_HIVE_ACCESS(Hive);

    ptr1 = Cell;

    while(TRUE) {

        Node = (PCM_KEY_NODE)HvGetCell(Hive, ptr1);
        if( Node == NULL ) {
            //
            // we couldn't map the bin containing this cell
            // bad luck! we cannot delete this tree
            //
            return;
        }
        count = Node->SubKeyCounts[Stable] +
                Node->SubKeyCounts[Volatile];
        parent = Node->Parent;

        if (count > 0) {                // ptr1->count > 0?

            //
            // subkeys exist, find and delete them
            //
            ptr2 = CmpFindSubKeyByNumber(Hive, Node, 0);
            
            //
            // release the cell here as we are overriding node
            //
            HvReleaseCell(Hive, ptr1);

            if( ptr2 == HCELL_NIL ) {
                //
                // we couldn't map view inside
                // bad luck! we cannot delete this tree
                //
                return;
            }

            Node = (PCM_KEY_NODE)HvGetCell(Hive, ptr2);
            if( Node == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // bad luck! we cannot delete this tree
                //
                return;
            }
            count = Node->SubKeyCounts[Stable] +
                    Node->SubKeyCounts[Volatile];

            //
            // release the cell here as we don't need it anymore
            //
            HvReleaseCell(Hive, ptr2);
            if (count > 0) {            // ptr2->count > 0?

                //
                // subkey has subkeys, descend to next level
                //
                ptr1 = ptr2;
                continue;

            } else {

                //
                // have found leaf, delete it
                //
                CmpFreeKeyByCell(Hive, ptr2, TRUE);
                continue;
            }

        } else {
            //
            // release the cell here as we don't need it anymore
            //
            HvReleaseCell(Hive, ptr1);

            //
            // no more subkeys at this level, we are now a leaf.
            //
            if (ptr1 != Cell) {

                //
                // we are not at the root cell, so ascend to parent
                //
                ptr1 = parent;          // ptr1 = ptr1->parent
                continue;

            } else {

                //
                // we are at the root cell, we are done
                //
                return;
            }
        } // outer if
    } // while
}


NTSTATUS
CmpFreeKeyByCell(
    PHHIVE Hive,
    HCELL_INDEX Cell,
    BOOLEAN Unlink
    )
/*++

Routine Description:

    Actually free the storage for the specified cell.  We will first
    remove it from its parent's child key list, then free all of its
    values, then the key body itself.

Arguments:

    Hive - pointer to hive control structure for hive of interest

    Cell - index for cell to free storage for (the target)

    Unlink - if TRUE, target cell will be removed from parent cell's
             subkeylist, if FALSE, it will NOT be.

Return Value:

    NONE.

--*/
{
    PCELL_DATA  ptarget;
    PCELL_DATA  pparent;
    PCELL_DATA  plist;
    ULONG       i;

    //
    // we have the lock exclusive or nobody is operating inside this hive
    //
    ASSERT_HIVE_FLUSHER_LOCKED((PCMHIVE)Hive);

    //
    // Mark dirty everything that we might touch
    //
    if (! CmpMarkKeyDirty(Hive, Cell
#if DBG
		,TRUE
#endif //DBG
		)) {
        return STATUS_NO_LOG_SPACE;
    }

    //
    // Map in the target
    //
    ptarget = HvGetCell(Hive, Cell);
    if( ptarget == NULL ) {
        //
        // we couldn't map the bin containing this cell
        // we shouldn't hit this as we just marked the cell dirty
        //
        ASSERT( FALSE );
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // release the cell here as it is dirty(pinned); it cannot go anywhere
    //
    HvReleaseCell(Hive, Cell);

    ASSERT((ptarget->u.KeyNode.SubKeyCounts[Stable] +
            ptarget->u.KeyNode.SubKeyCounts[Volatile]) == 0);


    if (Unlink == TRUE) {
        BOOLEAN Success;

        Success = CmpRemoveSubKey(Hive, ptarget->u.KeyNode.Parent, Cell);
        if (!Success) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        pparent = HvGetCell(Hive, ptarget->u.KeyNode.Parent);
        if( pparent == NULL ) {
            //
            // we couldn't map the bin containing this cell
            // we shouldn't hit this as we just marked the cell dirty
            //
            ASSERT( FALSE );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        
        //
        // release the cell here as it is dirty(pinned); it cannot go anywhere
        //
        HvReleaseCell(Hive, ptarget->u.KeyNode.Parent);

        if ( (pparent->u.KeyNode.SubKeyCounts[Stable] +
              pparent->u.KeyNode.SubKeyCounts[Volatile]) == 0)
        {
            pparent->u.KeyNode.MaxNameLen = 0;
            pparent->u.KeyNode.MaxClassLen = 0;
        }
    }

    //
    // Target is now an unreferenced key, free it's actual storage
    //

    //
    // Free misc stuff
    //
    if (!(ptarget->u.KeyNode.Flags & KEY_HIVE_EXIT) &&
        !(ptarget->u.KeyNode.Flags & KEY_PREDEF_HANDLE) ) {

        //
        // First, free the value entries
        //
        if (ptarget->u.KeyNode.ValueList.Count > 0) {

            // target list
            plist = HvGetCell(Hive, ptarget->u.KeyNode.ValueList.List);
            if( plist == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // we shouldn't hit this as we just marked the cell dirty
                //
                ASSERT( FALSE );
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            //
            // release the cell here as it is dirty(pinned); it cannot go anywhere
            //
            HvReleaseCell(Hive, ptarget->u.KeyNode.ValueList.List);

            for (i = 0; i < ptarget->u.KeyNode.ValueList.Count; i++) {
                // 
                // even if we cannot free the value here, we ignore it.
                // nothing bad happens (just some leaks)
                //
                if( CmpFreeValue(Hive, plist->u.KeyList[i]) == FALSE ) {
                    //
                    // we couldn't map view inside call above
                    // this shouldn't happen as we just marked the values dirty
                    // (i.e. they should be PINNED into memory by now)
                    //
                    ASSERT( FALSE );
                }
            }

            HvFreeCell(Hive, ptarget->u.KeyNode.ValueList.List);
        }

        //
        // Free the security descriptor
        //
        CmLockHiveSecurityExclusive((PCMHIVE)Hive);
        CmpFreeSecurityDescriptor(Hive, Cell);
        CmUnlockHiveSecurity((PCMHIVE)Hive);
    }

    //
    // Free the key body itself, and Class data.
    //
    if( CmpFreeKeyBody(Hive, Cell) == FALSE ) {
        //
        // couldn't map view inside
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    return STATUS_SUCCESS;
}


BOOLEAN
CmpMarkKeyDirty(
    PHHIVE Hive,
    HCELL_INDEX Cell
#if DBG
	, 
	BOOLEAN CheckNoSubkeys
#endif
    )
/*++

Routine Description:

    Mark all of the cells related to a key being deleted dirty.
    Includes the parent, the parent's child list, the key body,
    class, security, all value entry bodies, and all of their data cells.

Arguments:

    Hive - pointer to hive control structure for hive of interest

    Cell - index for cell holding keybody to make dirty

Return Value:

    TRUE - it worked

    FALSE - some error, most likely cannot get log space

--*/
{
    PCELL_DATA  ptarget;
    PCELL_DATA  plist;
    PCELL_DATA  security;
    PCELL_DATA  pvalue;
    ULONG       i;

    //
    // we have the lock exclusive or nobody is operating inside this hive
    //
    ASSERT_HIVE_FLUSHER_LOCKED((PCMHIVE)Hive);

    //
    // Map in the target
    //
    ptarget = HvGetCell(Hive, Cell);
    if( ptarget == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        return FALSE;
    }

#if DBG
	if(CheckNoSubkeys == TRUE) {
		ASSERT(ptarget->u.KeyNode.SubKeyCounts[Stable] == 0);
		ASSERT(ptarget->u.KeyNode.SubKeyCounts[Volatile] == 0);
	}
#endif //DBG

    if (ptarget->u.KeyNode.Flags & KEY_HIVE_EXIT) {

        //
        // If this is a link node, we are done.  Link nodes never have
        // classes, values, subkeys, or security descriptors.  Since
        // they always reside in the master hive, they're always volatile.
        //
        HvReleaseCell(Hive, Cell);
        return(TRUE);
    }

    //
    // mark cell itself
    //
    if (! HvMarkCellDirty(Hive, Cell, FALSE)) {
        HvReleaseCell(Hive, Cell);
        return FALSE;
    }
    //
    // we can safely release it here, as it is now dirty/pinned
    //
    HvReleaseCell(Hive, Cell);

    //
    // Mark the class
    //
    if (ptarget->u.KeyNode.Class != HCELL_NIL) {
        if (! HvMarkCellDirty(Hive, ptarget->u.KeyNode.Class, FALSE)) {
            return FALSE;
        }
    }

    //
    // Mark security
    //
    if (ptarget->u.KeyNode.Security != HCELL_NIL) {
        if (! HvMarkCellDirty(Hive, ptarget->u.KeyNode.Security, FALSE)) {
            return FALSE;
        }

        security = HvGetCell(Hive, ptarget->u.KeyNode.Security);
        if( security == NULL ) {
            //
            // we couldn't map the bin containing this cell
            // we shouldn't hit this as we just marked the cell dirty
            // (i.e. dirty == PINNED in memory)
            //
            ASSERT( FALSE );
            return FALSE;
        }

        //
        // we can safely release it here, as it is now dirty/pinned
        //
        HvReleaseCell(Hive, ptarget->u.KeyNode.Security);

        if (! (HvMarkCellDirty(Hive, security->u.KeySecurity.Flink, FALSE) &&
               HvMarkCellDirty(Hive, security->u.KeySecurity.Blink, FALSE)))
        {
            return FALSE;
        }
    }

    //
    // Mark the value entries and their data
    //
    if ( !(ptarget->u.KeyNode.Flags & KEY_PREDEF_HANDLE) && 
		  (ptarget->u.KeyNode.ValueList.Count > 0) 
	   ) {

        // target list
        if (! HvMarkCellDirty(Hive, ptarget->u.KeyNode.ValueList.List, FALSE)) {
            return FALSE;
        }
        plist = HvGetCell(Hive, ptarget->u.KeyNode.ValueList.List);
        if( plist == NULL ) {
            //
            // we couldn't map the bin containing this cell
            // we shouldn't hit this as we just marked the cell dirty
            // (i.e. dirty == PINNED in memory)
            //
            ASSERT( FALSE );
            return FALSE;
        }

        //
        // we can safely release it here, as it is now dirty/pinned
        //
        HvReleaseCell(Hive, ptarget->u.KeyNode.ValueList.List);

        for (i = 0; i < ptarget->u.KeyNode.ValueList.Count; i++) {
            if (! HvMarkCellDirty(Hive, plist->u.KeyList[i], FALSE)) {
                return FALSE;
            }

            pvalue = HvGetCell(Hive, plist->u.KeyList[i]);
            if( pvalue == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // we shouldn't hit this as we just marked the cell dirty
                // (i.e. dirty == PINNED in memory)
                //
                ASSERT( FALSE );
                return FALSE;
            }

            //
            // we can safely release it here, as it is now dirty/pinned
            //
            HvReleaseCell(Hive,plist->u.KeyList[i]);

            if( !CmpMarkValueDataDirty(Hive,&(pvalue->u.KeyValue)) ) {
                return FALSE;
            }
        }
    }

    if (ptarget->u.KeyNode.Flags & KEY_HIVE_ENTRY) {

        //
        // if this is an entry node, we are done.  our parent will
        // be in the master hive (and thus volatile)
        //
        return TRUE;
    }

    //
    // Mark the parent's Subkey list
    //
    if (! CmpMarkIndexDirty(Hive, ptarget->u.KeyNode.Parent, Cell)) {
        return FALSE;
    }

    //
    // Mark the parent
    //
    if (! HvMarkCellDirty(Hive, ptarget->u.KeyNode.Parent, FALSE)) {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmtree.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmtree.c

Abstract:

    This module contains cm routines that understand the structure
    of the registry tree.

--*/

#include    "cmp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpGetValueListFromCache)
#pragma alloc_text(PAGE,CmpGetValueKeyFromCache)
#pragma alloc_text(PAGE,CmpFindValueByNameFromCache)
#pragma alloc_text(PAGE,CmpGetValueDataFromCache)
#endif


VALUE_SEARCH_RETURN_TYPE
CmpGetValueListFromCache(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    OUT PCELL_DATA          *List,
    OUT BOOLEAN             *IndexCached,
    OUT PHCELL_INDEX        ValueListToRelease
)
/*++

Routine Description:

    Get the Valve Index Array.  Check if it is already cached, if not, cache it and return
    the cached entry.

Arguments:

    Hive - pointer to hive control structure for hive of interest

    ChildList - pointer/index to the Value Index array

    IndexCached - Indicating whether Value Index list is cached or not.

Return Value:

    Pointer to the Valve Index Array.

    NULL when we could not map view 

--*/
{
    HCELL_INDEX             CellToRelease;
    PCACHED_CHILD_LIST      ChildList;
    PHHIVE                  Hive;
#ifndef _WIN64
    ULONG                   AllocSize;
    PCM_CACHED_VALUE_INDEX  CachedValueIndex;
    ULONG                   i;
#endif
    ASSERT_KCB_LOCKED(KeyControlBlock);

    Hive = KeyControlBlock->KeyHive;
    ChildList = &(KeyControlBlock->ValueCache);
    *ValueListToRelease = HCELL_NIL;

#ifndef _WIN64
    *IndexCached = TRUE;
    if (CMP_IS_CELL_CACHED(ChildList->ValueList)) {
        //
        // The entry is already cached.
        //
        *List = CMP_GET_CACHED_CELLDATA(ChildList->ValueList);
    } else {
        //
        // The entry is not cached.  The element contains the hive index.
        // ensure exclusive lock.
        //
        if( (CmpIsKCBLockedExclusive(KeyControlBlock) == FALSE) &&
            (CmpTryConvertKCBLockSharedToExclusive(KeyControlBlock) == FALSE) ) {
            //
            // need to upgrade lock to exclusive
            //
            return SearchNeedExclusiveLock;
        }

        CellToRelease = CMP_GET_CACHED_CELL_INDEX(ChildList->ValueList);
        *List = (PCELL_DATA) HvGetCell(Hive, CellToRelease);
        if( *List == NULL ) {
            //
            // we couldn't map a view for this cell
            //
            *IndexCached = FALSE; 
            return SearchFail;
        }

        //
        // Allocate a PagedPool to cache the value index cell.
        //

        AllocSize = ChildList->Count * sizeof(ULONG_PTR) + FIELD_OFFSET(CM_CACHED_VALUE_INDEX, Data);
        CachedValueIndex = (PCM_CACHED_VALUE_INDEX) ExAllocatePoolWithTag(PagedPool, AllocSize, CM_CACHE_VALUE_INDEX_TAG);

        if (CachedValueIndex) {

            CachedValueIndex->CellIndex = CMP_GET_CACHED_CELL_INDEX(ChildList->ValueList);
#pragma prefast(suppress:12009, "no overflow")
            for (i=0; i<ChildList->Count; i++) {
                CachedValueIndex->Data.List[i] = (ULONG_PTR) (*List)->u.KeyList[i];
            }

            ChildList->ValueList = CMP_MARK_CELL_CACHED(CachedValueIndex);

            // Trying to catch the BAD guy who writes over our pool.
            CmpMakeSpecialPoolReadOnly( CachedValueIndex );

            //
            // Now we have the stuff cached, use the cache data.
            //
            *List = CMP_GET_CACHED_CELLDATA(ChildList->ValueList);
        } else {
            //
            // If the allocation fails, just do not cache it. continue.
            //
            *IndexCached = FALSE; 
        }
        *ValueListToRelease = CellToRelease;
    }
#else
    CellToRelease = CMP_GET_CACHED_CELL_INDEX(ChildList->ValueList);
    *List = (PCELL_DATA) HvGetCell(Hive, CellToRelease);
    *IndexCached = FALSE;
    if( *List == NULL ) {
        //
        // we couldn't map a view for this cell
        // OBS: we can drop this as we return List anyway; just for clarity
        //
        return SearchFail;
    }
    *ValueListToRelease = CellToRelease;
#endif

    return SearchSuccess;
}

VALUE_SEARCH_RETURN_TYPE
CmpGetValueKeyFromCache(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    IN PCELL_DATA           List,
    IN ULONG                Index,
    OUT PPCM_CACHED_VALUE   *ContainingList,
    OUT PCM_KEY_VALUE       *Value,
    IN BOOLEAN              IndexCached,
    OUT BOOLEAN             *ValueCached,
    OUT PHCELL_INDEX        CellToRelease
)
/*++

Routine Description:

    Get the Valve Node.  Check if it is already cached, if not but the index is cached, 
    cache and return the value node.

Arguments:

    Hive - pointer to hive control structure for hive of interest.

    List - pointer to the Value Index Array (of ULONG_PTR if cached and ULONG if non-cached)

    Index - Index in the Value index array

    ContainlingList - The address of the entry that will receive the found cached value.

    IndexCached - Indicate if the index list is cached.  If not, everything is from the
                  original registry data.

    ValueCached - Indicating whether Value is cached or not.

Return Value:

    Pointer to the Value Node.

    NULL when we couldn't map a view 
--*/
{
    PULONG_PTR          CachedList;
    ULONG               AllocSize;
    ULONG               CopySize;
    PCM_CACHED_VALUE    CachedValue;
    PHHIVE              Hive;

    *CellToRelease = HCELL_NIL;
    Hive = KeyControlBlock->KeyHive;
    *Value = NULL;
    if (IndexCached) {
        //
        // The index array is cached, so List is pointing to an array of ULONG_PTR.
        // Use CachedList.
        //
        CachedList = (PULONG_PTR) List;
        *ValueCached = TRUE;
        if (CMP_IS_CELL_CACHED(CachedList[Index])) {
            *Value = CMP_GET_CACHED_KEYVALUE(CachedList[Index]);
            *ContainingList = &((PCM_CACHED_VALUE) CachedList[Index]);
        } else {
            //
            // ensure exclusive lock.
            //
            if( (CmpIsKCBLockedExclusive(KeyControlBlock) == FALSE) &&
                (CmpTryConvertKCBLockSharedToExclusive(KeyControlBlock) == FALSE) ) {
                //
                // need to upgrade lock to exclusive
                //
                return SearchNeedExclusiveLock;
            }
            *Value = (PCM_KEY_VALUE) HvGetCell(Hive, List->u.KeyList[Index]);
            if( *Value == NULL ) {
                //
                // we couldn't map a view for this cell
                // just return NULL; the caller must handle it gracefully
                //
                return SearchFail;
            }
            *CellToRelease = List->u.KeyList[Index];

            //
            // Allocate a PagedPool to cache the value node.
            //
            CopySize = (ULONG) HvGetCellSize(Hive, *Value);
            AllocSize = CopySize + FIELD_OFFSET(CM_CACHED_VALUE, KeyValue);
            
            CachedValue = (PCM_CACHED_VALUE) ExAllocatePoolWithTag(PagedPool, AllocSize, CM_CACHE_VALUE_TAG);

            if (CachedValue) {
                //
                // Set the information for later use if we need to cache data as well.
                //
                if ((*Value)->Flags & VALUE_COMP_NAME) {
                    CachedValue->HashKey = CmpComputeHashKeyForCompressedName(0,(*Value)->Name,(*Value)->NameLength);
                } else {
                    UNICODE_STRING TmpStr;
                    TmpStr.Length = (*Value)->NameLength;
                    TmpStr.Buffer = (*Value)->Name;
                    CachedValue->HashKey = CmpComputeHashKey(0,&TmpStr
#if DBG
                                                             , TRUE
#endif
                        );
                }
                CachedValue->DataCacheType = CM_CACHE_DATA_NOT_CACHED;
                CachedValue->ValueKeySize = (USHORT) CopySize;

                RtlCopyMemory((PVOID)&(CachedValue->KeyValue), *Value, CopySize);


                // Trying to catch the BAD guy who writes over our pool.
                CmpMakeSpecialPoolReadWrite( CMP_GET_CACHED_ADDRESS(CachedList) );

                CachedList[Index] = CMP_MARK_CELL_CACHED(CachedValue);

                // Trying to catch the BAD guy who writes over our pool.
                CmpMakeSpecialPoolReadOnly( CMP_GET_CACHED_ADDRESS(CachedList) );


                // Trying to catch the BAD guy who writes over our pool.
                CmpMakeSpecialPoolReadOnly(CachedValue);

                *ContainingList = &((PCM_CACHED_VALUE) CachedList[Index]);
                //
                // Now we have the stuff cached, use the cache data.
                //
                (*Value) = CMP_GET_CACHED_KEYVALUE(CachedValue);
            } else {
                //
                // If the allocation fails, just do not cache it. continue.
                //
                *ValueCached = FALSE;
            }
        }
    } else {
        //
        // The Valve Index Array is from the registry hive, just get the cell and move on.
        //
        (*Value) = (PCM_KEY_VALUE) HvGetCell(Hive, List->u.KeyList[Index]);
        *ValueCached = FALSE;
        if( *Value == NULL ) {
            //
            // we couldn't map a view for this cell
            // just return NULL; the caller must handle it gracefully
            // OBS: we may remove this as we return pchild anyway; just for clarity
            //
            return SearchFail;
        }
        *CellToRelease = List->u.KeyList[Index];
    }
    return SearchSuccess;
}

VALUE_SEARCH_RETURN_TYPE
CmpFindValueByNameFromCache(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    IN PUNICODE_STRING      Name,
    OUT PPCM_CACHED_VALUE   *ContainingList,
    OUT ULONG               *Index,
    OUT PCM_KEY_VALUE       *Value,
    OUT BOOLEAN             *ValueCached,
    OUT PHCELL_INDEX        CellToRelease
    )
/*++

Routine Description:

    Find a value node given a value list array and a value name.  It sequentially walk
    through each value node to look for a match.  If the array and 
    value nodes touched are not already cached, cache them.

Arguments:

    Hive - pointer to hive control structure for hive of interest

    ChildList - pointer/index to the Value Index array

    Name - name of value to find

    ContainlingList - The address of the entry that will receive the found cached value.

    Index - pointer to variable to receive index for child
    
    ValueCached - Indicate if the value node is cached.

Return Value:

    HCELL_INDEX for the found cell
    HCELL_NIL if not found


Notes:
    
    New hives (Minor >= 4) have ValueList sorted; this implies ValueCache is sorted too;
    So, we can do a binary search here!

--*/
{
    UNICODE_STRING      Candidate;
    LONG                Result;
    PCELL_DATA          List;
    BOOLEAN             IndexCached;
    ULONG               Current;
    HCELL_INDEX         ValueListToRelease = HCELL_NIL;
    ULONG               HashKey = 0;
    PHHIVE              Hive = KeyControlBlock->KeyHive;
    PCACHED_CHILD_LIST  ChildList = &(KeyControlBlock->ValueCache);
    VALUE_SEARCH_RETURN_TYPE    ret = SearchFail;

    ASSERT_KCB_LOCKED(KeyControlBlock);

    *CellToRelease = HCELL_NIL;
    *Value = NULL;

    if (ChildList->Count != 0) {
        ret = CmpGetValueListFromCache(KeyControlBlock,&List, &IndexCached,&ValueListToRelease);
        if( ret != SearchSuccess ) {
            //
            // retry with exclusive lock, since we need to update the cache
            // or fail altogether
            //
            ASSERT( (ret == SearchFail) || (CmpIsKCBLockedExclusive(KeyControlBlock) == FALSE) );    
            ASSERT( ValueListToRelease == HCELL_NIL );    
            return ret;
        } 
        
        if( IndexCached ) {
            try {
                HashKey = CmpComputeHashKey(0,Name
#if DBG
                                            , TRUE
#endif
                    );
            } except (EXCEPTION_EXECUTE_HANDLER) {
                ret = SearchFail;
                goto Exit;
            }
        }
        //
        // old plain hive; simulate a for
        //
        Current = 0;

        while( TRUE ) {
            if( *CellToRelease != HCELL_NIL ) {
                HvReleaseCell(Hive,*CellToRelease);
                *CellToRelease = HCELL_NIL;
            }
            ret =  CmpGetValueKeyFromCache(KeyControlBlock, List, Current, ContainingList, Value, IndexCached, ValueCached, CellToRelease);
            if( ret != SearchSuccess ) {
                //
                // retry with exclusive lock, since we need to update the cache
                // or fail altogether
                //
                ASSERT( (ret == SearchFail) || (CmpIsKCBLockedExclusive(KeyControlBlock) == FALSE) );    
                ASSERT( *CellToRelease == HCELL_NIL );    
                return ret;
            } 

            //
            // only compare names when hash matches.
            //
            if( IndexCached && (*ValueCached) && (HashKey != ((PCM_CACHED_VALUE)((CMP_GET_CACHED_ADDRESS(**ContainingList))))->HashKey) ) {
                //
                // no hash match; skip it
                //
#if DBG
                try {
                    //
                    // Name has user-mode buffer.
                    //

                    if ((*Value)->Flags & VALUE_COMP_NAME) {
                        Result = CmpCompareCompressedName(  Name,
                                                            (*Value)->Name,
                                                            (*Value)->NameLength,
                                                            0);
                    } else {
                        Candidate.Length = (*Value)->NameLength;
                        Candidate.MaximumLength = Candidate.Length;
                        Candidate.Buffer = (*Value)->Name;
                        Result = RtlCompareUnicodeString(   Name,
                                                            &Candidate,
                                                            TRUE);
                    }


                } except (EXCEPTION_EXECUTE_HANDLER) {
                    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"CmpFindValueByNameFromCache: code:%08lx\n", GetExceptionCode()));
                    //
                    // the caller will bail out. Some ,alicious caller altered the Name buffer since we probed it.
                    //
                    *Value = NULL;
                    ret = SearchFail;
                    goto Exit;
                }
                ASSERT( Result != 0 );
#endif
                Result = 1;
            } else {
                try {
                    //
                    // Name has user-mode buffer.
                    //

                    if( (*Value)->Flags & VALUE_COMP_NAME) {
                        Result = CmpCompareCompressedName(  Name,
                                                            (*Value)->Name,
                                                            (*Value)->NameLength,
                                                            0);
                    } else {
                        Candidate.Length = (*Value)->NameLength;
                        Candidate.MaximumLength = Candidate.Length;
                        Candidate.Buffer = (*Value)->Name;
                        Result = RtlCompareUnicodeString(   Name,
                                                            &Candidate,
                                                            TRUE);
                    }


                } except (EXCEPTION_EXECUTE_HANDLER) {
                    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"CmpFindValueByNameFromCache: code:%08lx\n", GetExceptionCode()));
                    //
                    // the caller will bail out. Some ,alicious caller altered the Name buffer since we probed it.
                    //
                    *Value = NULL;
                    ret = SearchFail;
                    goto Exit;
                }
            }
            if (Result == 0) {
                //
                // Success, fill the index, return data to caller and exit
                //
                *Index = Current;
                ret = SearchSuccess;
                goto Exit;
            }

            //
            // compute the next index to try: old'n plain hive; go on
			//
            Current++;
            if( Current == ChildList->Count ) {
                //
                // we've reached the end of the list; nicely return
                //
                (*Value) = NULL;
                ret = SearchFail;
                goto Exit;
            }

        } // while(TRUE)
    }

    //
    // in the new design we shouldn't get here; we should exit the while loop with return
    //
    ASSERT( ChildList->Count == 0 );    

Exit:
    if( ValueListToRelease != HCELL_NIL ) {
        HvReleaseCell(Hive,ValueListToRelease);
    }
    return ret;
}

VALUE_SEARCH_RETURN_TYPE
CmpGetValueDataFromCache(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    IN PPCM_CACHED_VALUE    ContainingList,
    IN PCELL_DATA           ValueKey,
    IN BOOLEAN              ValueCached,
    OUT PUCHAR              *DataPointer,
    OUT PBOOLEAN            Allocated,
    OUT PHCELL_INDEX        CellToRelease
)
/*++

Routine Description:

    Get the cached Value Data given a value node.

Arguments:

    Hive - pointer to hive control structure for hive of interest

    ContainingList - Address that stores the allocation address of the value node.
                     We need to update this when we do a re-allocate to cache
                     both value key and value data.

    ValueKey - pointer to the Value Key

    ValueCached - Indicating whether Value key is cached or not.

    DataPointer - out param to receive a pointer to the data

    Allocated - out param telling if the caller should free the DataPointer

Return Value:

    TRUE - data was retrieved
    FALSE - some error (STATUS_INSUFFICIENT_RESOURCES) occured

Note:
    
    The caller is responsible for freeing the DataPointer when we signal it to him
    by setting Allocated on TRUE;

    Also we must be sure that MAXIMUM_CACHED_DATA is smaller than CM_KEY_VALUE_BIG
--*/
{
    //
    // Cache the data if needed.
    //
    PCM_CACHED_VALUE OldEntry;
    PCM_CACHED_VALUE NewEntry;
    PUCHAR      Cacheddatapointer;
    ULONG       AllocSize;
    ULONG       CopySize;
    ULONG       DataSize;
    PHHIVE      Hive;

    ASSERT( MAXIMUM_CACHED_DATA < CM_KEY_VALUE_BIG );

    //
    // this routine should not be called for small data
    //
    ASSERT( (ValueKey->u.KeyValue.DataLength & CM_KEY_VALUE_SPECIAL_SIZE) == 0 );

    ASSERT_KCB_LOCKED(KeyControlBlock);
    
    Hive = KeyControlBlock->KeyHive;
    //
    // init out params
    //
    *DataPointer = NULL;
    *Allocated = FALSE;
    *CellToRelease = HCELL_NIL;

    if (ValueCached) {
        OldEntry = (PCM_CACHED_VALUE) CMP_GET_CACHED_ADDRESS(*ContainingList);
        if (OldEntry->DataCacheType == CM_CACHE_DATA_CACHED) {
            //
            // Data is already cached, use it.
            //
            *DataPointer = (PUCHAR) ((ULONG_PTR) ValueKey + OldEntry->ValueKeySize);
        } else {
            //
            // ensure exclusive lock.
            //
            if( (CmpIsKCBLockedExclusive(KeyControlBlock) == FALSE) &&
                (CmpTryConvertKCBLockSharedToExclusive(KeyControlBlock) == FALSE) ) {
                //
                // need to upgrade lock to exclusive
                //
                return SearchNeedExclusiveLock;
            }
            if ((OldEntry->DataCacheType == CM_CACHE_DATA_TOO_BIG) ||
                (ValueKey->u.KeyValue.DataLength > MAXIMUM_CACHED_DATA ) 
               ){
                //
                // Mark the type and do not cache it.
                //
                OldEntry->DataCacheType = CM_CACHE_DATA_TOO_BIG;

                //
                // Data is too big to warrant caching, get it from the registry; 
                // - regardless of the size; we might be forced to allocate a buffer
                //
                if( CmpGetValueData(Hive,&(ValueKey->u.KeyValue),&DataSize,DataPointer,Allocated,CellToRelease) == FALSE ) {
                    //
                    // insufficient resources; return NULL
                    //
                    ASSERT( *Allocated == FALSE );
                    ASSERT( *DataPointer == NULL );
                    return SearchFail;
                }

            } else {
                //
                // consistency check
                //
                ASSERT(OldEntry->DataCacheType == CM_CACHE_DATA_NOT_CACHED);

                //
                // Value data is not cached.
                // Check the size of value data, if it is smaller than MAXIMUM_CACHED_DATA, cache it.
                //
                // Anyway, the data is for sure not stored in a big data cell (see test above)
                //
                //
                *DataPointer = (PUCHAR)HvGetCell(Hive, ValueKey->u.KeyValue.Data);
                if( *DataPointer == NULL ) {
                    //
                    // we couldn't map this cell
                    // the caller must handle this gracefully !
                    //
                    return SearchFail;
                }
                //
                // inform the caller it has to release this cell
                //
                *CellToRelease = ValueKey->u.KeyValue.Data;
                
                //
                // copy only valid data; cell might be bigger
                //
                DataSize = (ULONG)ValueKey->u.KeyValue.DataLength;

                //
                // consistency check
                //
                ASSERT(DataSize <= MAXIMUM_CACHED_DATA);

                //
                // Data is not cached and now we are going to do it.
                // Reallocate a new cached entry for both value key and value data.
                //
                CopySize = DataSize + OldEntry->ValueKeySize;
                AllocSize = CopySize + FIELD_OFFSET(CM_CACHED_VALUE, KeyValue);

                NewEntry = (PCM_CACHED_VALUE) ExAllocatePoolWithTag(PagedPool, AllocSize, CM_CACHE_VALUE_DATA_TAG);

                if (NewEntry) {
                    //
                    // Now fill the data to the new cached entry
                    //
                    NewEntry->HashKey = OldEntry->HashKey;
                    NewEntry->DataCacheType = CM_CACHE_DATA_CACHED;
                    NewEntry->ValueKeySize = OldEntry->ValueKeySize;

                    RtlCopyMemory((PVOID)&(NewEntry->KeyValue),
                                  (PVOID)&(OldEntry->KeyValue),
                                  NewEntry->ValueKeySize);

                    Cacheddatapointer = (PUCHAR) ((ULONG_PTR) &(NewEntry->KeyValue) + OldEntry->ValueKeySize);
                    RtlCopyMemory(Cacheddatapointer, *DataPointer, DataSize);

                    // Trying to catch the BAD guy who writes over our pool.
                    CmpMakeSpecialPoolReadWrite( OldEntry );

                    *ContainingList = (PCM_CACHED_VALUE) CMP_MARK_CELL_CACHED(NewEntry);

                    // Trying to catch the BAD guy who writes over our pool.
                    CmpMakeSpecialPoolReadOnly( NewEntry );

                    //
                    // Free the old entry
                    //
                    ExFreePool(OldEntry);

                } 
            }
        }
    } else {
        if( CmpGetValueData(Hive,&(ValueKey->u.KeyValue),&DataSize,DataPointer,Allocated,CellToRelease) == FALSE ) {
            //
            // insufficient resources; return NULL
            //
            ASSERT( *Allocated == FALSE );
            ASSERT( *DataPointer == NULL );
            return SearchFail;
        }
    }

    return SearchSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmwmi.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmwmi.c

Abstract:

    This module contains support for tracing registry system calls 

--*/

#include    "cmp.h"
#pragma hdrstop
#include    <evntrace.h>

VOID
CmpWmiDumpKcbTable(
    VOID
);

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif
PCM_TRACE_NOTIFY_ROUTINE CmpTraceRoutine = NULL;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmSetTraceNotifyRoutine)
#pragma alloc_text(PAGE,CmpWmiDumpKcbTable)
#pragma alloc_text(PAGE,CmpWmiDumpKcb)
#endif


NTSTATUS
CmSetTraceNotifyRoutine(
    __in_opt PCM_TRACE_NOTIFY_ROUTINE NotifyRoutine,
    __in BOOLEAN Remove
    )
{
    if(Remove) {
        CmpTraceRoutine = NULL;
    } else {
        CmpTraceRoutine = NotifyRoutine;

        //
        // dump active kcbs to WMI
        //
        CmpWmiDumpKcbTable();
    }
    return STATUS_SUCCESS;
}

VOID
CmpWmiDumpKcbTable(
    VOID
)
/*++

Routine Description:

    Sends all kcbs addresses and names from the HashTable to WMI.

Arguments:

    none

Return Value:
    
    none

--*/
{
    ULONG                       i;
    PCM_KEY_HASH                Current;
    PCM_KEY_CONTROL_BLOCK       kcb;
    PUNICODE_STRING             KeyName;
    PCM_TRACE_NOTIFY_ROUTINE    TraceRoutine = CmpTraceRoutine;

    CM_PAGED_CODE();

    if( TraceRoutine == NULL ) {
        return;
    }

    CmpLockRegistry();

    for (i=0; i<CmpHashTableSize; i++) {
        CmpLockHashEntryByIndexShared(i);
        Current = CmpCacheTable[i].Entry;
        while (Current) {
            kcb = CONTAINING_RECORD(Current, CM_KEY_CONTROL_BLOCK, KeyHash);
            KeyName = CmpConstructName(kcb);
            if(KeyName != NULL) {
                (*TraceRoutine)(STATUS_SUCCESS,
                                kcb, 
                                0, 
                                0,
                                KeyName,
                                EVENT_TRACE_TYPE_REGKCBDMP);
	     
                ExFreePoolWithTag(KeyName, CM_NAME_TAG | PROTECTED_POOL);
            }
            Current = Current->NextHash;
        }
        CmpUnlockHashEntryByIndex(i);
    }

    CmpUnlockRegistry();
}

VOID
CmpWmiDumpKcb(
    PCM_KEY_CONTROL_BLOCK       kcb
)
/*++

Routine Description:

    dumps a single kcb

Arguments:

    none

Return Value:
    
    none

--*/
{
    PCM_TRACE_NOTIFY_ROUTINE    TraceRoutine = CmpTraceRoutine;
    PUNICODE_STRING             KeyName;

    CM_PAGED_CODE();

    if( TraceRoutine == NULL ) {
        return;
    }

    KeyName = CmpConstructName(kcb);
    if(KeyName != NULL) {
        (*TraceRoutine)(STATUS_SUCCESS,
                        kcb, 
                        0, 
                        0,
                        KeyName,
                        EVENT_TRACE_TYPE_REGKCBDMP);
 
        ExFreePoolWithTag(KeyName, CM_NAME_TAG | PROTECTED_POOL);
    }
}


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmtrecpy.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmtrecpy.c

Abstract:

    This file contains code for CmpCopyTree, misc copy utility routines.

Revision History:

    Added support for synchronizing two trees.

--*/

#include    "cmp.h"

//
// stack used for directing nesting of tree copy.  gets us off
// the kernel stack and thus allows for VERY deep nesting
//

#define CMP_INITIAL_STACK_SIZE  1024        // ENTRIES

typedef struct {
    HCELL_INDEX SourceCell;
    HCELL_INDEX TargetCell;
    ULONG       i;
} CMP_COPY_STACK_ENTRY, *PCMP_COPY_STACK_ENTRY;

BOOLEAN
CmpCopySyncTree2(
    PCMP_COPY_STACK_ENTRY   CmpCopyStack,
    ULONG                   CmpCopyStackSize,
    ULONG                   CmpCopyStackTop,
    PHHIVE                  CmpSourceHive,
    PHHIVE                  CmpTargetHive,
    BOOLEAN                 CopyVolatile,
    CMP_COPY_TYPE           CopyType
    );

BOOLEAN
CmpFreeKeyValues(
    PHHIVE Hive,
    HCELL_INDEX Cell,
    PCM_KEY_NODE Node
    );

BOOLEAN
CmpSyncKeyValues(
    PHHIVE  SourceHive,
    HCELL_INDEX SourceKeyCell,
    PCM_KEY_NODE SourceKeyNode,
    PHHIVE  TargetHive,
    HCELL_INDEX TargetKeyCell,
    PCM_KEY_NODE TargetKeyNode
    );

BOOLEAN
CmpMergeKeyValues(
    PHHIVE  SourceHive,
    HCELL_INDEX SourceKeyCell,
    PCM_KEY_NODE SourceKeyNode,
    PHHIVE  TargetHive,
    HCELL_INDEX TargetKeyCell,
    PCM_KEY_NODE TargetKeyNode
    );


BOOLEAN
CmpSyncSubKeysAfterDelete(
                          PHHIVE SourceHive,
                          PCM_KEY_NODE SourceCell,
                          PHHIVE TargetHive,
                          PCM_KEY_NODE TargetCell, 
                          WCHAR *NameBuffer);

BOOLEAN
CmpMarkKeyValuesDirty(
    PHHIVE Hive,
    HCELL_INDEX Cell,
    PCM_KEY_NODE Node
    );

BOOLEAN
CmpMarkKeyParentDirty(
    PHHIVE Hive,
    HCELL_INDEX Cell
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpCopySyncTree)
#pragma alloc_text(PAGE,CmpCopySyncTree2)
#pragma alloc_text(PAGE,CmpCopyKeyPartial)
#pragma alloc_text(PAGE,CmpCopyValue)
#pragma alloc_text(PAGE,CmpCopyCell)
#pragma alloc_text(PAGE,CmpFreeKeyValues)
#pragma alloc_text(PAGE,CmpSyncKeyValues)
#pragma alloc_text(PAGE,CmpMergeKeyValues)
#pragma alloc_text(PAGE,CmpInitializeKeyNameString)
#pragma alloc_text(PAGE,CmpInitializeValueNameString)
#pragma alloc_text(PAGE,CmpSyncSubKeysAfterDelete)
#pragma alloc_text(PAGE,CmpMarkKeyValuesDirty)
#pragma alloc_text(PAGE,CmpMarkKeyParentDirty)
#endif

//
// Routine to actually call to do a tree copy (or sync)
//

BOOLEAN
CmpCopySyncTree(
    PHHIVE          SourceHive,
    HCELL_INDEX     SourceCell,
    PHHIVE          TargetHive,
    HCELL_INDEX     TargetCell,
    BOOLEAN         CopyVolatile,
    CMP_COPY_TYPE   CopyType
    )
/*++

Routine Description:

    This routine can perform two distinct (yet similar) tasks:
    a tree copy or a tree synchronization (sync). Which task
    is performed is determined by the TreeSync parameter.
    
    For both operations:
    --------------------
    
    The source root key and target root key must exist in advance.
    These root nodes and their value entries will NOT be copied/synced.                
    
    NOTE:   Volatile keys are only copied/synced if the CopyVolatile
            parameter is set to true.

    
    For a tree copy:
    ----------------
    
    A tree is copied from source to destination. The subkeys
    of the source root key and the full trees under those
    subkeys will be copied to a new tree at target root key.
                           
    NOTE:   If this call fails part way through, it will NOT undo
            any successfully completed key copies, thus a partial
            tree copy CAN occur.
            
    For a tree sync:
    ----------------
    
    The target tree is synchronized with the source tree. It is 
    assumed that for a certain period of the time the target tree
    has remained unmodified while modifications may have been made
    to the source tree. During a sync, any such modifications
    to the source tree are made to the target tree. Thus, at the
    end of a successful sync, the target tree is identical to the
    source tree.
    
    Since only things that have changed in the source tree 
    are modified in the target tree, a sync operation is far
    more efficient than the delete/copy operations necessary
    to accomplish the same results.
    
    NOTE: It is assumed that no open handles are held
          on any target tree keys. Registry in-memory data
          structures may be corrupted if this is not true.
        
Arguments:

    SourceHive - pointer to hive control structure for source

    SourceCell - index of cell at root of tree to copy/sync

    TargetHive - pointer to hive control structure for target

    TargetCell - pointer to cell at root of target tree
    
    CopyVolatile - indicates whether volatile keys should be
                   copied/synced.
                   
    CopyType - indicates the type of the copy operation:
                Copy  - A copy is requested
                Sync  - A sync is requested
                Merge - A merge is requested i.e.:
                    1. the target nodes that are not present on the source tree are not
                    deleted.
                    2. the target nodes that are present in the source tree gets overrided
                    no matter what the LastWriteTime value is.
Return Value:

    BOOLEAN - Result code from call, among the following:
        TRUE - it worked
        FALSE - the tree copy/sync was not completed (though more than 0
                keys may have been copied/synced)

--*/
{
    BOOLEAN result;
    PCMP_COPY_STACK_ENTRY   CmpCopyStack;
    PRELEASE_CELL_ROUTINE   TargetReleaseCellRoutine;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"CmpCopyTree:\n"));

    CmpCopyStack = ExAllocatePool(
                        PagedPool,
                        sizeof(CMP_COPY_STACK_ENTRY)*CMP_INITIAL_STACK_SIZE
                        );
    if (CmpCopyStack == NULL) {
        return FALSE;
    }
    CmpCopyStack[0].SourceCell = SourceCell;
    CmpCopyStack[0].TargetCell = TargetCell;

    //
    // the target is something temporary (in memory and local var)
    // So, we just set the release routines to NULL and restore after
    // the copy is complete; this saves some pain
    //
    TargetReleaseCellRoutine = TargetHive->ReleaseCellRoutine;
    TargetHive->ReleaseCellRoutine = NULL;

    result = CmpCopySyncTree2(
                CmpCopyStack,
                CMP_INITIAL_STACK_SIZE,
                0,
                SourceHive,
                TargetHive,
                CopyVolatile,
                CopyType
                );

    TargetHive->ReleaseCellRoutine = TargetReleaseCellRoutine;

    ExFreePool(CmpCopyStack);
    return result;
}


//
// Helper
//

BOOLEAN
CmpCopySyncTree2(
    PCMP_COPY_STACK_ENTRY   CmpCopyStack,
    ULONG                   CmpCopyStackSize,
    ULONG                   CmpCopyStackTop,
    PHHIVE                  CmpSourceHive,
    PHHIVE                  CmpTargetHive,
    BOOLEAN                 CopyVolatile,
    CMP_COPY_TYPE           CopyType
    )
/*++

Routine Description:

   This is a helper routine for CmpCopySyncTree. It accomplishes
   the functionality described by that routine in a "virtually"
   recursive manner which frees this routine from the limitations
   of the Kernel stack.
   
   This routine should not be called directly. Use CmpCopySyncTree!.
      
Arguments:

    (All of these are "virtual globals")

    CmpCopyStack - "global" pointer to stack for frames

    CmpCopyStackSize - allocateed size of stack

    CmpCopyStackTop - current top

    CmpSourceHive, CmpTargetHive - source and target hives
    
    CopyVolatile, CopyType - same as CmpCopySyncTree.


Return Value:

    BOOLEAN - Result code from call, among the following:
        TRUE - it worked
        FALSE - the tree copy/sync was not completed (though more than 0
                keys may have been copied/synced)

--*/
{
    PCMP_COPY_STACK_ENTRY   Frame;
    HCELL_INDEX             SourceChild;
    HCELL_INDEX             NewSubKey;

    BOOLEAN                 Ret = FALSE, SyncNeedsTreeCopy = FALSE;
    UNICODE_STRING          KeyName;
    PCM_KEY_NODE            SourceChildCell, TargetChildCell;       
    PCM_KEY_NODE            SourceCell, TargetCell, TempNode;
    ULONG                   SyncTreeCopyStackStart = CmpCopyStackTop - 1;
    WCHAR                   *NameBuffer = NULL;
    
    // A merge is a particular case of a sync !!!
    BOOLEAN                 TreeSync = (CopyType == Sync || CopyType == Merge)?TRUE:FALSE;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"CmpCopyTree2:\n"));

    if (TreeSync) {

       //
       // The sync operation involves some work with key names, 
       // so we must allocate a buffer used for key name decompression.
       //

       NameBuffer = ExAllocatePool(PagedPool, REG_MAX_KEY_NAME_LENGTH);
       if(!NameBuffer) return FALSE;

    } 

    //
    // outer loop, apply to entire tree, emulate recursion here
    // jump to here is a virtual call
    //
    Outer: while (TRUE) {

        Frame = &(CmpCopyStack[CmpCopyStackTop]);

        Frame->i = 0;
                        
    //
    // inner loop, applies to one key
    // jump to here is a virtual return
    //
        Inner: while (TRUE) {

            SourceCell = (PCM_KEY_NODE)HvGetCell(CmpSourceHive, Frame->SourceCell);
            if( SourceCell == NULL ) {
                //
                // we couldn't map the bin containing this cell
                //
                goto CopyEnd;
            }

            SourceChild = CmpFindSubKeyByNumber(CmpSourceHive,
                                                SourceCell,
                                                Frame->i);
            (Frame->i)++;

            if ((SourceChild == HCELL_NIL) || (!CopyVolatile &&
                                               (HvGetCellType(SourceChild) == Volatile))) {

                //
                // we've stepped through all the children (or we are only
                // interested in stable children and have just stepped through
                // the stable children and into the volatile ones)
                //                
                
                if(TreeSync && (CopyType != Merge))
                { 
                   //
                   // If we are here during a sync, that means most of sync operations
                   // applied to the current SourceCell have been completed.
                   // That is, we have:
                   //   1) Synchronized SourceCell's values with its counterpart in the
                   //      target tree.
                   //   2) Synchronized any new SourceCell subkeys (subkeys present
                   //      in SourceCell but not its counterpart) by creating
                   //      and copying them to the proper place in the target tree.
                   //
                   // What this means is that SourceCell's counterpart in the target tree
                   // (TargetCell) now has at least as many subkeys as SourceCell.
                   //
                   // This implies that if TargetCell now has more subkeys that SourceCell
                   // than some subkeys of TargetCell are not present in the source tree
                   // (probably because those keys were deleted from the source tree 
                   //  during the period between the previous sync and now).
                   //
                   // If such keys exist, then they must be delete them from TargetCell
                   // in order to complete the sync. We do this below.
                   //

                   TargetCell = (PCM_KEY_NODE)HvGetCell(CmpTargetHive, Frame->TargetCell);
                    if( TargetCell == NULL ) {
                        //
                        // we couldn't map the bin containing this cell
                        //
                        HvReleaseCell(CmpSourceHive, Frame->SourceCell);
                        goto CopyEnd;
                    }

                   //
                   // Does TargetCell have more subkeys than SourceCell?
                   //

                   if((TargetCell->SubKeyCounts[Stable] + 
                       TargetCell->SubKeyCounts[Volatile]) >

                      (SourceCell->SubKeyCounts[Stable] + 

                       // We only count the volatile keys if we are actually
                       // syncing them. Note, however, that we always use
                       // the volatile counts in TargetCell since we may
                       // be syncing to a volatile tree where all keys are volatile.
                       
                       (CopyVolatile ? SourceCell->SubKeyCounts[Volatile] : 0)))  
                           
                   {
                      //
                      // Delete what should be deleted from TargetCell
                      //

                      CmpSyncSubKeysAfterDelete(CmpSourceHive,
                                                SourceCell, 
                                                CmpTargetHive,
                                                TargetCell,
                                                NameBuffer);
                   }                                      
                   //
                   // release target cell as we don't need it anymore
                   //
                   HvReleaseCell(CmpTargetHive, Frame->TargetCell);
                }
                //
                // release the source cell
                //
                HvReleaseCell(CmpSourceHive, Frame->SourceCell);
                break;
            } else {
                //
                // release the source cell
                //
                HvReleaseCell(CmpSourceHive, Frame->SourceCell);
            }
                                                
            if (TreeSync) {

               //
               // For a sync, we want to check if the current child (subkey)
               // of SourceCell is also a child of TargetCell - i.e. if
               // the subkey in question has a counterpart in the target tree.
               //
               // There is no guarantee that the counterpart's index number
               // will be the same so we must perform this check using
               // the subkey name.
               //

               //
               // Get the name of the current child
               //
                     
               SourceChildCell = (PCM_KEY_NODE)HvGetCell(CmpSourceHive,                                                               
                                                         SourceChild);                                         
                     
                if( SourceChildCell == NULL ) {
                    //
                    // we couldn't map the bin containing this cell
                    //
                    goto CopyEnd;
                }
               CmpInitializeKeyNameString(SourceChildCell,
                                          &KeyName, 
                                          NameBuffer);                     

               //
               // Try to find the current child's counterpart in
               // in the target tree using the child's name.
               //
                     
                TempNode = (PCM_KEY_NODE)HvGetCell(CmpTargetHive,Frame->TargetCell);
                if( TempNode == NULL ) {
                    //
                    // we couldn't map the bin containing this cell
                    //
                    HvReleaseCell(CmpSourceHive,SourceChild);                                         
                    goto CopyEnd;
                }

               NewSubKey = CmpFindSubKeyByName(CmpTargetHive,
                                               TempNode,
                                               &KeyName);
                                   
               // release the temporary node
               HvReleaseCell(CmpTargetHive,Frame->TargetCell);
                     
               if (NewSubKey != HCELL_NIL) {

                  //
                  // Found it, the current child (subkey) has a counterpart
                  // in the target tree. Thus, we just need to check if 
                  // the counterpart's values are out of date and should
                  // be updated.
                  //

                  TargetChildCell = (PCM_KEY_NODE)HvGetCell(CmpTargetHive,
                                                            NewSubKey);
                    if( TargetChildCell == NULL ) {
                        //
                        // we couldn't map the bin containing this cell
                        //
                        HvReleaseCell(CmpSourceHive,SourceChild);                                         
                        goto CopyEnd;
                    }
                        
                  //
                  // Check if the current subkey has been modified
                  // more recently than its target tree counterpart.
                  // When we are doing a tree merge, always override the target.
                  //
                        
                  if ( (CopyType == Merge) ||
                      ((TargetChildCell->LastWriteTime.QuadPart) < 
                      (SourceChildCell->LastWriteTime.QuadPart))) {

                     //
                     // The counterpart is out of date. Its values
                     // must be synchronized with the current subkey.
                     //

                     //
                     // Sync up the key's values, sd, & class                     
                     //

                     if(CopyType == Merge) {
                         if(!CmpMergeKeyValues(CmpSourceHive, SourceChild, SourceChildCell,
                                              CmpTargetHive, NewSubKey, TargetChildCell)) {
                            HvReleaseCell(CmpSourceHive,SourceChild);                                         
                            HvReleaseCell(CmpTargetHive,NewSubKey);
                            goto CopyEnd;                              
                         }
                     } else {
                         if(!CmpSyncKeyValues(CmpSourceHive, SourceChild, SourceChildCell,
                                              CmpTargetHive, NewSubKey, TargetChildCell)) {
                            HvReleaseCell(CmpSourceHive,SourceChild);                                         
                            HvReleaseCell(CmpTargetHive,NewSubKey);
                            goto CopyEnd;                              
                        }
                     }

                     //
                     // Sync the timestamps so that we don't do this again.
                     //

                     TargetChildCell->LastWriteTime.QuadPart =
                        SourceChildCell->LastWriteTime.QuadPart;
                        
                  }
                           
                  //
                  // If we are here, then the current subkey's target
                  // tree counterpart has been synchronized (or did not need
                  // to be). Transfer control to the code that will apply
                  // this function "recursively" to the current subkey in order
                  // to continue the sync.
                  //

                  HvReleaseCell(CmpSourceHive,SourceChild);                                         
                  HvReleaseCell(CmpTargetHive,NewSubKey);
                  goto NewKeyCreated;
                     
               }   

               //
               // If we are here, it means that the current child (subkey)
               // does not have a counterpart in the target tree. This means
               // we have encountered a new subkey in the source tree and must
               // create it in the target tree. 
               //
               // The standard copy code below will create this subkey. However,
               // we must also make sure that the tree under this subkey is properly
               // copied from source to target. The most efficient way of doing
               // this is to temporarily forget that we are in a sync operation
               // and merely perform a copy until the desired result is achieved.
               // 

               //
               // Indicate that we will just copy and not sync for a while
               //
                                             
               SyncNeedsTreeCopy = TRUE;                                          
               //
               // release this cell as we don't need it anymore
               //
               HvReleaseCell(CmpSourceHive,SourceChild);                                         
            }

            NewSubKey = CmpCopyKeyPartial(
                                          CmpSourceHive,
                                          SourceChild,
                                          CmpTargetHive,
                                          Frame->TargetCell,
                                          TRUE
                                          );

                
            if (NewSubKey == HCELL_NIL) {
               
               goto CopyEnd;
            }
                
            if ( !  CmpAddSubKey(
                                 CmpTargetHive,
                                 Frame->TargetCell,
                                 NewSubKey
                                 )
                 ) {

               goto CopyEnd;
            }

            //
            // Sync up the MaxNameLen field in the parent
            //
            {
                PCM_KEY_NODE    TargetNodeParent, TargetNodeSon;
                USHORT          NameLength;
                TargetNodeParent = (PCM_KEY_NODE)HvGetCell(CmpTargetHive,Frame->TargetCell);
                if( TargetNodeParent == NULL ) {
                    goto CopyEnd;
                }
                //
                // make sure it's dirty as we are going to alter it.
                //
                if (! HvMarkCellDirty(CmpTargetHive,Frame->TargetCell,FALSE)) {
                    HvReleaseCell(CmpTargetHive,Frame->TargetCell);
                    goto CopyEnd;
                }

                TargetNodeSon = (PCM_KEY_NODE)HvGetCell(CmpTargetHive,NewSubKey);
                if( TargetNodeSon == NULL ) {
                    HvReleaseCell(CmpTargetHive,Frame->TargetCell);
                    goto CopyEnd;
                }

                NameLength = TargetNodeSon->NameLength;
                if( TargetNodeSon->Flags & KEY_COMP_NAME ) {
                    NameLength *= sizeof(WCHAR);
                }
                if (TargetNodeParent->MaxNameLen < NameLength) {
                    TargetNodeParent->MaxNameLen = NameLength;
                }
                
                HvReleaseCell(CmpTargetHive,NewSubKey);
                HvReleaseCell(CmpTargetHive,Frame->TargetCell);
            }

            //
            // Check if the sync operation determined that this
            // subtree should be copied
            //
                
            if(TreeSync && SyncNeedsTreeCopy) {

               //
               // We have just created a new key in the target tree
               // with the above code. However, since this is a sync,
               // the parent of that new key has not been created by our
               // code and thus may not have been modified at all before
               // the creation of the new key. But this parent now 
               // has a new child, and must therefore be marked as dirty.
               //
                   
               if (! CmpMarkKeyParentDirty(CmpTargetHive, NewSubKey)) {

                  goto CopyEnd;
               }
                   
               //
               // Record the stack level where we start the copy 
               // (and temporarily abandon the sync)
               // so that we can return to the sync operation when this
               // stack level is reached again (i.e. when the tree
               // under the current subkey is fully copied)
               //

               SyncTreeCopyStackStart = CmpCopyStackTop;

               //
               // Pretend that this is not a sync in order
               // to simply start copying
               //

               TreeSync = FALSE;
            }

NewKeyCreated:
                    
                    //
                    // We succeeded in copying/syncing the subkey, apply
                    // ourselves to it
                    //
                    CmpCopyStackTop++;

                    if (CmpCopyStackTop >= CmpCopyStackSize) {

                        //
                        // if we're here, it means that the tree
                        // we're trying to copy is more than 1024
                        // COMPONENTS deep (from 2048 to 256k bytes)
                        // we could grow the stack, but this is pretty
                        // severe, so return FALSE and fail the copy
                        //
                        
                        goto CopyEnd;
                    }

                    CmpCopyStack[CmpCopyStackTop].SourceCell =
                            SourceChild;

                    CmpCopyStack[CmpCopyStackTop].TargetCell =
                            NewSubKey;

                    goto Outer;

                    
        } // Inner: while

        if (CmpCopyStackTop == 0) {            
            Ret = TRUE;
            goto CopyEnd;
        }

        CmpCopyStackTop--;
        Frame = &(CmpCopyStack[CmpCopyStackTop]);

        //
        // We have just completed working at a certain stack level.
        // This is a good time to check if we need to resume a temporarily
        // suspended sync operation.
        //

        if(SyncNeedsTreeCopy && (CmpCopyStackTop == SyncTreeCopyStackStart))
        {
           //
           // We've been copying a tree for a sync. But now, that tree is fully
           // copied. So, let's resume the sync once again.
           //

           TreeSync = TRUE;               
           SyncNeedsTreeCopy = FALSE;
        }


        goto Inner;

    } // Outer: while

CopyEnd:

   if (NameBuffer) ExFreePool(NameBuffer);
   return Ret;
}


HCELL_INDEX
CmpCopyKeyPartial(
    PHHIVE  SourceHive,
    HCELL_INDEX SourceKeyCell,
    PHHIVE  TargetHive,
    HCELL_INDEX Parent,
    BOOLEAN CopyValues
    )
/*++

Routine Description:

    Copy a key body and all of its values, but NOT its subkeylist or
    subkey entries.  SubKeyList.Count will be set to 0.

Arguments:

    SourceHive - pointer to hive control structure for source

    SourceKeyCell - value entry being copied

    TargetHive - pointer to hive control structure for target

    Parent - parent value to set into newly created key body

    CopyValues - if FALSE value entries will not be copied, if TRUE, they will

Return Value:

    HCELL_INDEX - Cell of body of new key entry, or HCELL_NIL
        if some error.

--*/
{
    NTSTATUS                status;
    HCELL_INDEX             newkey = HCELL_NIL;
    HCELL_INDEX             newclass = HCELL_NIL;
    HCELL_INDEX             newsecurity = HCELL_NIL;
    HCELL_INDEX             newlist = HCELL_NIL;
    HCELL_INDEX             newvalue;
    BOOLEAN                 success = FALSE;
    ULONG                   i,Index;
    PCELL_DATA              psrckey = NULL;
    PCM_KEY_NODE            ptarkey = NULL;
    PCELL_DATA              psrclist = NULL;
    PCELL_DATA              ptarlist;
    HCELL_INDEX             security;
    HCELL_INDEX             class;
    ULONG                   classlength;
    ULONG                   count;
    ULONG                   Type;
    PCM_KEY_VALUE           pvalue;
#if DBG
    WCHAR                   *NameBuffer = NULL;
    UNICODE_STRING          ValueName;
    HCELL_INDEX             child;
#endif
    PSECURITY_DESCRIPTOR    SrcSecurityDescriptor;


    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"CmpCopyKeyPartial:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tSHive=%p SCell=%08lx\n",SourceHive,SourceKeyCell));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tTHive=%p\n",TargetHive));

#if DBG    
	NameBuffer = ExAllocatePool(PagedPool, REG_MAX_KEY_VALUE_NAME_LENGTH);
    if(!NameBuffer) {
        return HCELL_NIL;
    }
#endif //DBG
    //
    // get description of source
    //
    if (Parent == HCELL_NIL) {
        //
        // This is a root node we are creating, so don't make it volatile.
        //
        Type = Stable;
    } else {
        Type = HvGetCellType(Parent);
    }
    psrckey = HvGetCell(SourceHive, SourceKeyCell);
    if( psrckey == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        goto DoFinally;
    }
    security = psrckey->u.KeyNode.Security;
    class = psrckey->u.KeyNode.Class;
    classlength = psrckey->u.KeyNode.ClassLength;

    //
    // Allocate and copy the body
    //
    newkey = CmpCopyCell(SourceHive, SourceKeyCell, TargetHive, Type);
    if (newkey == HCELL_NIL) {
        goto DoFinally;
    }
    //
    // this cell was just allocated so it should be pinned; it's OK to release it here
    // as the view is not going anywhere
    //
    ASSERT_CELL_DIRTY(TargetHive, newkey);
    //
    // Allocate and copy class
    //
    if (classlength > 0) {
        newclass = CmpCopyCell(SourceHive, class, TargetHive, Type);
        if (newclass == HCELL_NIL) {
            goto DoFinally;
        }
    }

    //
    // Fill in the target body
    //
    ptarkey = (PCM_KEY_NODE)HvGetCell(TargetHive, newkey);
    if( ptarkey == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        goto DoFinally;
    }

    ptarkey->Class = newclass;
    ptarkey->Security = HCELL_NIL;
    ptarkey->SubKeyLists[Stable] = HCELL_NIL;
    ptarkey->SubKeyCounts[Stable] = 0;
	ptarkey->SubKeyCounts[Volatile] = 0;
	ptarkey->SubKeyLists[Volatile] = HCELL_NIL;
    ptarkey->Parent = Parent;
    
    ptarkey->Flags = (psrckey->u.KeyNode.Flags & KEY_COMP_NAME);
    if (Parent == HCELL_NIL) {
        ptarkey->Flags |= KEY_HIVE_ENTRY + KEY_NO_DELETE;
    }

    //
    // Allocate and copy security
    //
    // Use the hash Luke !!!
    //
    CmLockHiveSecurityShared((PCMHIVE)SourceHive);
    if( CmpFindSecurityCellCacheIndex ((PCMHIVE)SourceHive,security,&Index) == FALSE ) {
        CmUnlockHiveSecurity((PCMHIVE)SourceHive);
        goto DoFinally;
    }

    SrcSecurityDescriptor = &(((PCMHIVE)SourceHive)->SecurityCache[Index].CachedSecurity->Descriptor);
    CmUnlockHiveSecurity((PCMHIVE)SourceHive);

    CmLockHiveSecurityExclusive((PCMHIVE)TargetHive);
    status = CmpAssignSecurityDescriptor(TargetHive,
                                         newkey,
                                         ptarkey,
                                         SrcSecurityDescriptor);
    CmUnlockHiveSecurity((PCMHIVE)TargetHive);

    if (!NT_SUCCESS(status)) {
        goto DoFinally;
    }

    //
    // Set up the value list
    //
    count = psrckey->u.KeyNode.ValueList.Count;

    //
    // initialize an Empty ValueList
    //
    ptarkey->ValueList.List = HCELL_NIL;
    ptarkey->ValueList.Count = 0;

    if ((count == 0) || (CopyValues == FALSE)) {
        success = TRUE;
    } else {

        psrclist = HvGetCell(SourceHive, psrckey->u.KeyNode.ValueList.List);
        if( psrclist == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            goto DoFinally;
        }


        //
        // Copy the values
        //
        for (i = 0; i < count; i++) {

            newvalue = CmpCopyValue(
                            SourceHive,
                            psrclist->u.KeyList[i],
                            TargetHive,
                            Type
                            );

            if (newvalue == HCELL_NIL) {
                //
                // for cleanup purposes
                //
                newlist = ptarkey->ValueList.List;
                goto DoFinally;
            }

            pvalue = (PCM_KEY_VALUE)HvGetCell(TargetHive, newvalue);
            if( pvalue == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // this shouldn't happen as we just allocated the cell
                // (i.e. the bin containing it should be PINNED into memory by now )
                //
                ASSERT( FALSE );
                //
                // for cleanup purposes
                //
                newlist = ptarkey->ValueList.List;
                goto DoFinally;
            }
            //
            // this cell was just allocated so it should be pinned; it's OK to release it here
            // as the view is not going anywhere
            //
            ASSERT_CELL_DIRTY(TargetHive, newvalue);
            HvReleaseCell(TargetHive, newvalue);

#if DBG
            //
            // get the name
            //
            CmpInitializeValueNameString(pvalue,&ValueName,NameBuffer);


            //
            // find out the index where we should insert this 
            // this is a special treatment for the case when we copy form and old hive (not sorted)
            // into a new format one (sorted)
            //
            if( CmpFindNameInList(TargetHive,&(ptarkey->ValueList),&ValueName,&Index,&child) == FALSE ) {
                //
                // we couldn't map a view inside the above call
                //
                //
                // for cleanup purposes
                //
                newlist = ptarkey->ValueList.List;
                goto DoFinally;
            }

            //
            // the value is not present in the list; we're about to add it!
            //
            ASSERT( child == HCELL_NIL );
            
            //
            // sanity validation : insert at the end
            //
            ASSERT( Index == i );

#endif //DBG

            if( !NT_SUCCESS( CmpAddValueToList(TargetHive,newvalue,i,Type,&(ptarkey->ValueList)) ) ) {
                //
                // for cleanup purposes
                //
                newlist = ptarkey->ValueList.List;
                if( newlist != HCELL_NIL ) {
                    ASSERT( i > 0 );
                    //
                    // free already copied values
                    //
                    ptarlist = HvGetCell(TargetHive, newlist);
                    if( ptarlist == NULL ) {
                        //
                        // we couldn't map the bin containing this cell
                        // this shouldn't fail as we just allocated this cell
                        // (i.e. the bin should be PINNED into memory at this point)
                        //
                        ASSERT( FALSE );
                        goto DoFinally;
                    }
                    //
                    // this cell was just allocated so it should be pinned; it's OK to release it here
                    // as the view is not going anywhere
                    //
                    ASSERT_CELL_DIRTY(TargetHive, newlist);
                    HvReleaseCell(TargetHive, newlist);

                    for (; i > 0; i--) {
                        HvFreeCell(
                            TargetHive,
                            ptarlist->u.KeyList[i - 1]
                            );
                    }
                } else {
                    ASSERT( i == 0 );
                }

                goto DoFinally;
            }
            
        }
        success = TRUE;
    }

DoFinally:
    
#if DBG
    ASSERT( NameBuffer != NULL );
    ExFreePool(NameBuffer);
#endif //DBG
    
    if( psrclist != NULL ) {
        ASSERT(psrckey!= NULL ); 
        HvReleaseCell(SourceHive, psrckey->u.KeyNode.ValueList.List);
    }

    if( psrckey != NULL ) {
        HvReleaseCell(SourceHive, SourceKeyCell);
    }

    if( ptarkey != NULL ) {
		ASSERT( newkey != HCELL_NIL );
        HvReleaseCell(TargetHive, newkey);
    }
    
    if (success == FALSE) {
        if (newlist != HCELL_NIL) {
            HvFreeCell(TargetHive, newlist);
        }

        if (newsecurity != HCELL_NIL) {
            HvFreeCell(TargetHive, newsecurity);
        }

        if (newclass != HCELL_NIL) {
            HvFreeCell(TargetHive, newclass);
        }

        if (newkey != HCELL_NIL) {
            HvFreeCell(TargetHive, newkey);
        }

        return HCELL_NIL;

    } else {

        return newkey;
    }
}


HCELL_INDEX
CmpCopyValue(
    PHHIVE  SourceHive,
    HCELL_INDEX SourceValueCell,
    PHHIVE  TargetHive,
    HSTORAGE_TYPE   Type
    )
/*++

Routine Description:

    Copy a value entry.  Copies the body of a value entry and the
    data.  Returns cell of new value entry.

Arguments:

    SourceHive - pointer to hive control structure for source

    SourceValueCell - value entry being copied

    TargetHive - pointer to hive control structure for target

    Type - storage type to allocate for target (stable or volatile)

Return Value:

    HCELL_INDEX - Cell of body of new value entry, or HCELL_NIL
        if some error.

--*/
{
    HCELL_INDEX newvalue;
    HCELL_INDEX newdata;
    PCELL_DATA  pvalue;
    ULONG       datalength;
    HCELL_INDEX olddata;
    ULONG       tempdata;
    BOOLEAN     small;
    HCELL_INDEX CellToRelease = HCELL_NIL;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"CmpCopyValue:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tSHive=%p SCell=%08lx\n",SourceHive,SourceValueCell));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tTargetHive=%p\n",TargetHive));

    //
    // get source data
    //
    pvalue = HvGetCell(SourceHive, SourceValueCell);
    if( pvalue == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        return HCELL_NIL;
    }
    small = CmpIsHKeyValueSmall(datalength, pvalue->u.KeyValue.DataLength);
    olddata = pvalue->u.KeyValue.Data;

    //
    // Copy body
    //
    newvalue = CmpCopyCell(SourceHive, SourceValueCell, TargetHive, Type);
    if (newvalue == HCELL_NIL) {
        HvReleaseCell(SourceHive, SourceValueCell);
        return HCELL_NIL;
    }

    //
    // Copy data (if any)
    //
    if (datalength > 0) {

        if (datalength > CM_KEY_VALUE_SMALL) {

            if( (CmpIsHKeyValueBig(SourceHive,datalength) == TRUE) ||
                (CmpIsHKeyValueBig(TargetHive,datalength) == TRUE)
                ) {
                PCELL_DATA  Buffer;
                BOOLEAN     BufferAllocated;
                HCELL_INDEX CellToRelease2 = HCELL_NIL;
                //
                // get the data from source, regardless of the size
                //
                if( CmpGetValueData(SourceHive,&(pvalue->u.KeyValue),&datalength,&Buffer,&BufferAllocated,&CellToRelease2) == FALSE ) {
                    //
                    // insufficient resources; return NULL
                    //
                    ASSERT( BufferAllocated == FALSE );
                    ASSERT( Buffer == NULL );
                    HvFreeCell(TargetHive, newvalue);
                    HvReleaseCell(SourceHive, SourceValueCell);
                    return HCELL_NIL;
                }
                //
                // we ignore celltorelease because we have specifically set the release routine to NULL
                //

                //
                // allocate a new value data in the target hive (regardless of the size)
                // and copy the data onto it.
                //
                if( !NT_SUCCESS(CmpSetValueDataNew(TargetHive,Buffer,datalength,Type,newvalue,&newdata)) ) {
                    //
                    // We have bombed out loading user data, clean up and exit.
                    //
                    if( BufferAllocated == TRUE ) {
                        ExFreePool( Buffer );
                    }
                    HvFreeCell(TargetHive, newvalue);
                    HvReleaseCell(SourceHive, SourceValueCell);
                    if( CellToRelease2 != HCELL_NIL ) {
                        HvReleaseCell(SourceHive, CellToRelease2);
                    }
                    return HCELL_NIL;
                }

                //
                // free the source buffer
                //
                if( BufferAllocated == TRUE ) {
                    ExFreePool( Buffer );
                }
                if( CellToRelease2 != HCELL_NIL ) {
                    HvReleaseCell(SourceHive, CellToRelease2);
                }

            } else {
                //
                // there's data, normal size, or none of the hives support 
                // bigdata cells, so do standard copy
                //
                newdata = CmpCopyCell(SourceHive, olddata, TargetHive, Type);
            }

            if (newdata == HCELL_NIL) {
                HvFreeCell(TargetHive, newvalue);
                HvReleaseCell(SourceHive, SourceValueCell);
                return HCELL_NIL;
            }

            pvalue = HvGetCell(TargetHive, newvalue);
            if( pvalue == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // this shouldn't happen as we just allocated the cell
                // (i.e. it should be PINNED into memory at this point)
                //
                ASSERT( FALSE );
                HvFreeCell(TargetHive, newvalue);
                HvReleaseCell(SourceHive, SourceValueCell);
                CmpFreeValueData(TargetHive,newdata,datalength);
                return HCELL_NIL;
            }

            pvalue->u.KeyValue.Data = newdata;
            pvalue->u.KeyValue.DataLength = datalength;
            HvReleaseCell(TargetHive, newvalue);

        } else {

            //
            // the data is small, but may be stored in either large or
            // small format for historical reasons
            //
            if (small) {

                //
                // data is already small, so just do a body to body copy
                //
                tempdata = pvalue->u.KeyValue.Data;

            } else {

                //
                // data is stored externally in old cell, will be internal in new
                //
                CellToRelease = pvalue->u.KeyValue.Data;
                pvalue = HvGetCell(SourceHive, pvalue->u.KeyValue.Data);
                if( pvalue == NULL ) {
                    //
                    // we couldn't map the bin containing this cell
                    //
                    HvFreeCell(TargetHive, newvalue);
                    HvReleaseCell(SourceHive, SourceValueCell);
                    return HCELL_NIL;
                }
                tempdata = *((PULONG)pvalue);
            }
            pvalue = HvGetCell(TargetHive, newvalue);
            if( pvalue == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // this shouldn't happen as we just allocated the cell
                // (i.e. it should be PINNED into memory at this point)
                //
                ASSERT( FALSE );
                HvFreeCell(TargetHive, newvalue);
                HvReleaseCell(SourceHive, SourceValueCell);
                if( CellToRelease != HCELL_NIL ) {
                    HvReleaseCell(SourceHive, CellToRelease);
                }
                return HCELL_NIL;
            }
            pvalue->u.KeyValue.Data = tempdata;
            pvalue->u.KeyValue.DataLength =
                datalength + CM_KEY_VALUE_SPECIAL_SIZE;

            HvReleaseCell(TargetHive, newvalue);
            if( CellToRelease != HCELL_NIL ) {
                HvReleaseCell(SourceHive, CellToRelease);
            }
        }
    }

    HvReleaseCell(SourceHive, SourceValueCell);
    return newvalue;
}

HCELL_INDEX
CmpCopyCell(
    PHHIVE  SourceHive,
    HCELL_INDEX SourceCell,
    PHHIVE  TargetHive,
    HSTORAGE_TYPE   Type
    )
/*++

Routine Description:

    Copy SourceHive.SourceCell to TargetHive.TargetCell.

Arguments:

    SourceHive - pointer to hive control structure for source

    SourceCell - index of cell to copy from

    TargetHive - pointer to hive control structure for target

    Type - storage type (stable or volatile) of new cell

Return Value:

    HCELL_INDEX of new cell, or HCELL_NIL if failure.

--*/
{
    PVOID   psource;
    PVOID   ptarget;
    ULONG   size;
    HCELL_INDEX newcell;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"CmpCopyCell:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tSourceHive=%p SourceCell=%08lx\n",SourceHive,SourceCell));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_SAVRES,"\tTargetHive=%p\n",TargetHive));

    psource = HvGetCell(SourceHive, SourceCell);
    if( psource == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        return HCELL_NIL;
    }

    size = HvGetCellSize(SourceHive, psource);

    newcell = HvAllocateCell(TargetHive, size, Type,HCELL_NIL);
    if (newcell == HCELL_NIL) {
        HvReleaseCell(SourceHive, SourceCell);
        return HCELL_NIL;
    }

    ptarget = HvGetCell(TargetHive, newcell);
    if( ptarget == NULL ) {
        //
        // we couldn't map the bin containing this cell
        // this shouldn't happen as we just allocated the cell
        // (i.e. it should be PINNED into memory at this point)
        //
        ASSERT( FALSE );
        HvFreeCell(TargetHive, newcell);
        HvReleaseCell(SourceHive, SourceCell);
        return HCELL_NIL;
    }

   
    RtlCopyMemory(ptarget, psource, size);

    HvReleaseCell(SourceHive, SourceCell);
    HvReleaseCell(TargetHive, newcell);

    return newcell;
}

BOOLEAN
CmpFreeKeyValues(
    PHHIVE Hive,
    HCELL_INDEX Cell,
    PCM_KEY_NODE Node
    )
/*++

Routine Description:

   Free the cells associated with the value entries, the security descriptor,
   and the class of a particular key.   

Arguments:

   Hive        - The hive of the key in question
   Cell        - The cell of the key in question
   Node        - The key body of the key in question

Return Value:

   TRUE if successful, FALSE otherwise.

--*/
{    
    PCELL_DATA  plist;
    ULONG       i;

    //
    // Mark all the value-related cells dirty 
    //

    if (! CmpMarkKeyValuesDirty(Hive, Cell, Node)) {
        return FALSE;
    }
    
    //
    // Link nodes don't have things that we need to free
    //

    if (!(Node->Flags & KEY_HIVE_EXIT)) {

        //
        // First, free the value entries
        //
        if (Node->ValueList.Count > 0) {

            // Get value list
            plist = HvGetCell(Hive, Node->ValueList.List);
            if( plist == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // this shouldn't happen as we just marked the cell dirty
                // (i.e. it should be PINNED into memory at this point)
                //
                ASSERT( FALSE );
                return FALSE;
            }

            // Free each value
            for (i = 0; i < Node->ValueList.Count; i++) {
                if( CmpFreeValue(Hive, plist->u.KeyList[i]) == FALSE ) {
                    //
                    // we couldn't map view inside call above
                    // this shouldn't happen as we just marked the values dirty
                    // (i.e. they should be PINNED into memory at this point)
                    //
                    ASSERT( FALSE );
                    HvReleaseCell(Hive, Node->ValueList.List);
                    return FALSE;
                }
            }

            HvReleaseCell(Hive, Node->ValueList.List);
            // Free the value list
            HvFreeCell(Hive, Node->ValueList.List);
        }

        //
        // Make this key value-less
        //

        Node->ValueList.List = HCELL_NIL;
        Node->ValueList.Count = 0;

        //
        // Free the Class information
        //

        if (Node->ClassLength > 0) {
            HvFreeCell(Hive, Node->Class);
            Node->Class = HCELL_NIL;
            Node->ClassLength = 0;
        }
        
    }

    return TRUE;
}

BOOLEAN
CmpMergeKeyValues(
    PHHIVE  SourceHive,
    HCELL_INDEX SourceKeyCell,
    PCM_KEY_NODE SourceKeyNode,
    PHHIVE  TargetHive,
    HCELL_INDEX TargetKeyCell,
    PCM_KEY_NODE TargetKeyNode
    )
/*++

Routine Description:
    Merges the values from the two key-nodes provided.
    Rules for the merge:
    1. The target values are not touched!
    2. Only values from the source that are not present in the 
    target are taken into account by this routine. They are added
    to the target node value list "as they are".

Arguments:

   SourceHive     - Hive of the source key
   SourceKeyCell  - The source key's cell
   SourceKeyNode  - The source key's body
   
   TargetHive     - Hive of the target key
   TargetKeyCell  - The target key's cell
   TargetKeyNode  - The target key's body

Return Value:

   TRUE of successful, FALSE otherwise.

--*/
{
    BOOLEAN         success = FALSE;    
    PCELL_DATA      psrclist;
    HCELL_INDEX         newvalue, child;    
    ULONG           i, count, Type, ChildIndex;
    PCM_KEY_VALUE   poldvalue;
    WCHAR           *NameBuffer = NULL;
    UNICODE_STRING  ValueName;
    HV_TRACK_CELL_REF   OuterCellRef = {0};
    HV_TRACK_CELL_REF   InnerCellRef = {0};

    ASSERT( TargetHive->ReleaseCellRoutine == NULL );

    if(TargetKeyNode->MaxValueNameLen < SourceKeyNode->MaxValueNameLen) {
        TargetKeyNode->MaxValueNameLen = SourceKeyNode->MaxValueNameLen;
    }

    if(TargetKeyNode->MaxValueDataLen < SourceKeyNode->MaxValueDataLen) {
        TargetKeyNode->MaxValueDataLen = SourceKeyNode->MaxValueDataLen;
    }

    if(TargetKeyNode->ValueList.Count == 0) {
        //
        // No Values in Target, do a sync
        //
        return CmpSyncKeyValues(SourceHive, SourceKeyCell, SourceKeyNode, TargetHive, TargetKeyCell, TargetKeyNode);
    }

    //
    // Set up the value list
    //
    count = SourceKeyNode->ValueList.Count;

    if (count == 0) {
        // No values in source, no update to the list needed.
        success = TRUE;
    } else {        

        NameBuffer = ExAllocatePool(PagedPool, REG_MAX_KEY_VALUE_NAME_LENGTH);
        if(!NameBuffer) return FALSE;

        //
        // The type of the new cells will be the same as that
        // of the target cell.
        //

        Type = HvGetCellType(TargetKeyCell);    

        //
        // Reallocate the value list for target to fit the new size
        // Worst case: all values from the source node will be added 
        // to the target node
        //

        psrclist = HvGetCell(SourceHive, SourceKeyNode->ValueList.List);
        if( psrclist == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            goto EndValueMerge;
        }
        if( !HvTrackCellRef(&OuterCellRef,SourceHive,SourceKeyNode->ValueList.List) ) {
            goto EndValueMerge;
        }

        //
        // Copy the values
        //
        for (i = 0; i < count; i++) {

            poldvalue = (PCM_KEY_VALUE)HvGetCell(SourceHive, psrclist->u.KeyList[i]);
            if( poldvalue == NULL ) {
                //
                // we couldn't map the bin containing this cell
                //
                goto EndValueMerge;
            }
            if( !HvTrackCellRef(&InnerCellRef,SourceHive,psrclist->u.KeyList[i]) ) {
                goto EndValueMerge;
            }
            
            //
            // get the name
            //
            CmpInitializeValueNameString(poldvalue,&ValueName,NameBuffer);


            //
            // check if this particular values doesn't exist in the target node already
            //
            if( CmpFindNameInList(TargetHive,&(TargetKeyNode->ValueList),&ValueName,&ChildIndex,&child) == FALSE ) {
                //
                // we couldn't map a view inside the above call
                //
                goto EndValueMerge;
            }

            if( child == HCELL_NIL ) {
                //
                // sanity validation : insert at the end
                //
                ASSERT( ChildIndex == TargetKeyNode->ValueList.Count );

                //
                // No, it doesn't, so add it
                //
                newvalue = CmpCopyValue(
                                SourceHive,
                                psrclist->u.KeyList[i],
                                TargetHive,
                                Type
                                );

                if (newvalue == HCELL_NIL) {
                    goto EndValueMerge;
                }

                if( !NT_SUCCESS( CmpAddValueToList(TargetHive,newvalue,ChildIndex,Type,&(TargetKeyNode->ValueList)) ) ) {
                    goto EndValueMerge;
                }
            }
            //
            // don't accumulate huge chunks
            //
            if( (i%9) == 0 ) {
                HvReleaseFreeCellRefArray(&InnerCellRef);
            }
        }

        success = TRUE;
    }

EndValueMerge:
    //
    // let go of those refcounts
    //
    HvReleaseFreeCellRefArray(&InnerCellRef);
    HvReleaseFreeCellRefArray(&OuterCellRef);

    if (NameBuffer) ExFreePool(NameBuffer);
    return success;
}
    
BOOLEAN
CmpSyncKeyValues(
    PHHIVE  SourceHive,
    HCELL_INDEX SourceKeyCell,
    PCM_KEY_NODE SourceKeyNode,
    PHHIVE  TargetHive,
    HCELL_INDEX TargetKeyCell,
    PCM_KEY_NODE TargetKeyNode
    )
/*++

Routine Description:

    Synchronizes the value entries, security descriptor, and class of a 
    target key with that of a source key - ensuring that the keys are 
    identical with respect to the synchronized information.

Arguments:

   SourceHive     - Hive of the source key
   SourceKeyCell  - The source key's cell
   SourceKeyNode  - The source key's body
   
   TargetHive     - Hive of the target key
   TargetKeyCell  - The target key's cell
   TargetKeyNode  - The target key's body

Return Value:

   TRUE of successful, FALSE otherwise.

--*/
{
    NTSTATUS                status;    
    BOOLEAN                 success = FALSE;    
    PCELL_DATA              psrclist, ptarlist;
    HCELL_INDEX             newvalue, newlist = HCELL_NIL, newclass = HCELL_NIL;    
    ULONG                   i, count, Type, Index;
    PCM_KEY_VALUE           pvalue;
    HV_TRACK_CELL_REF       CellRef = {0};//this will come in handy
#if DBG
    WCHAR                   *NameBuffer = NULL;
    UNICODE_STRING          ValueName;
	HCELL_INDEX				child;
#endif //DBG

    PSECURITY_DESCRIPTOR    SrcSecurityDescriptor;
    HCELL_INDEX             OldSecurity,NewSecurity;    
    
    UNREFERENCED_PARAMETER (SourceKeyCell);

    //
    // nobody is operating on the target hive
    //
    ASSERT( TargetHive->ReleaseCellRoutine == NULL );

    //
    // First, free the target key's values, sd, and class info.
    //

    if(!CmpFreeKeyValues(TargetHive, TargetKeyCell, TargetKeyNode))
       return FALSE;

#if DBG
    NameBuffer = ExAllocatePool(PagedPool, REG_MAX_KEY_VALUE_NAME_LENGTH);
    if(!NameBuffer) {
        return FALSE;
    }
#endif //DBG    
    //
    // Now, copy the values, class, & sd from the source cell
    //

    //
    // The type of the new cells will be the same as that
    // of the target cell.
    //

    Type = HvGetCellType(TargetKeyCell);    
    
    //
    // Allocate and copy class
    //
    if ((SourceKeyNode->ClassLength > 0) && (SourceKeyNode->Class != HCELL_NIL)) {
        newclass = CmpCopyCell(SourceHive, SourceKeyNode->Class, TargetHive, Type);
        if (newclass == HCELL_NIL) {
            goto EndValueSync;
        }
        
        // only if class is valid. Otherwise remains 0 (set by CmpFreeKeyValues)
        TargetKeyNode->ClassLength = SourceKeyNode->ClassLength;
    }

    //
    // Associate the new class with the target key
    // and prepare and security descriptor assignment.
    //

    TargetKeyNode->Class = newclass;

    //
    // Allocate and assign security
    //
    //
    // Use the hash Luke !!!
    //
    CmLockHiveSecurityShared((PCMHIVE)SourceHive);
    if( CmpFindSecurityCellCacheIndex ((PCMHIVE)SourceHive,SourceKeyNode->Security,&Index) == FALSE ) {
        CmUnlockHiveSecurity((PCMHIVE)SourceHive);
        goto EndValueSync;
    }


    SrcSecurityDescriptor = &(((PCMHIVE)SourceHive)->SecurityCache[Index].CachedSecurity->Descriptor);
    CmUnlockHiveSecurity((PCMHIVE)SourceHive);


    //
    // store it for later in case of error recovery
    //
    OldSecurity = TargetKeyNode->Security;
    TargetKeyNode->Security = HCELL_NIL;

    CmLockHiveSecurityExclusive((PCMHIVE)TargetHive);
    status = CmpAssignSecurityDescriptor(TargetHive,
                                         TargetKeyCell,
                                         TargetKeyNode,
                                         SrcSecurityDescriptor);
    if (!NT_SUCCESS(status)) {
        TargetKeyNode->Security = OldSecurity;
        CmUnlockHiveSecurity((PCMHIVE)TargetHive);
        goto EndValueSync;
    }

    NewSecurity = TargetKeyNode->Security;
    TargetKeyNode->Security = OldSecurity;
    if ((TargetKeyNode->Flags & KEY_HIVE_ENTRY) && ( NewSecurity != OldSecurity) ) {
        //
        // we need to play it safe here so we don't blow away the security list for entire hive.
        //
        PCM_KEY_SECURITY    NewSec;
        PCM_KEY_SECURITY    OldSec;
        PCM_KEY_SECURITY    LastSec;
        HCELL_INDEX         LastSecCell;

        NewSec = (PCM_KEY_SECURITY)HvGetCell(TargetHive,NewSecurity);
        if( NewSec == NULL ) {
            //
            // could not map view
            //
            CmUnlockHiveSecurity((PCMHIVE)TargetHive);
            goto EndValueSync;
        }

        OldSec = (PCM_KEY_SECURITY)HvGetCell(TargetHive,OldSecurity);
        if( OldSec == NULL ) {
            //
            // could not map view
            //
            HvReleaseCell(TargetHive,NewSecurity);
            CmUnlockHiveSecurity((PCMHIVE)TargetHive);
            goto EndValueSync;
        }

        LastSecCell = OldSec->Blink;
        LastSec = (PCM_KEY_SECURITY)HvGetCell(TargetHive,LastSecCell);
        if( LastSec == NULL ) {
            //
            // could not map view
            //
            HvReleaseCell(TargetHive,OldSecurity);
            HvReleaseCell(TargetHive,NewSecurity);
            CmUnlockHiveSecurity((PCMHIVE)TargetHive);
            goto EndValueSync;
        }

        if( !HvMarkCellDirty(TargetHive,OldSecurity,FALSE) ||
            !HvMarkCellDirty(TargetHive,LastSecCell,FALSE) ) {
            //
            // no log space
            //
            HvReleaseCell(TargetHive,LastSecCell);
            HvReleaseCell(TargetHive,OldSecurity);
            HvReleaseCell(TargetHive,NewSecurity);
            CmUnlockHiveSecurity((PCMHIVE)TargetHive);
            goto EndValueSync;
        }
        
        //
        // link old list to new security
        //
        NewSec->Flink = OldSecurity;
        NewSec->Blink = LastSecCell;
        OldSec->Blink = NewSecurity;
        LastSec->Flink = NewSecurity;

        HvReleaseCell(TargetHive,LastSecCell);
        HvReleaseCell(TargetHive,OldSecurity);
        HvReleaseCell(TargetHive,NewSecurity);

    }
    //
    // we need to play it safe here, to make sure we never end up having a key
    // with a NIL security cell
    //
    CmpFreeSecurityDescriptor(TargetHive, TargetKeyCell);
    CmUnlockHiveSecurity((PCMHIVE)TargetHive);
    TargetKeyNode->Security = NewSecurity;
    
    //
    // Set up the value list
    //
    count = SourceKeyNode->ValueList.Count;

    //
    // target ValueList is an emptylist; we shall add values to it.
    //
    TargetKeyNode->ValueList.List = HCELL_NIL;
    TargetKeyNode->ValueList.Count = 0;

	//
	// after sync we'll have the values from source
	//
	TargetKeyNode->MaxValueNameLen = SourceKeyNode->MaxValueNameLen;
	TargetKeyNode->MaxValueDataLen = SourceKeyNode->MaxValueDataLen;

    if (count == 0) {

        // No values in source, no list needed.

        success = TRUE;
    } else {        

        //
        // Do not allocate space for ValueList; CmpAddValueToList will do it
        //

        psrclist = HvGetCell(SourceHive, SourceKeyNode->ValueList.List);
        if( (psrclist == NULL) || !HvTrackCellRef(&CellRef,SourceHive, SourceKeyNode->ValueList.List) ) {
            //
            // we couldn't map the bin containing this cell
            //
            goto EndValueSync;
        }


        //
        // Copy the values
        //
        for (i = 0; i < count; i++) {

            newvalue = CmpCopyValue(
                            SourceHive,
                            psrclist->u.KeyList[i],
                            TargetHive,
                            Type
                            );

            if (newvalue == HCELL_NIL) {
                //
                // for cleanup purposes
                //
                newlist = TargetKeyNode->ValueList.List;
                goto EndValueSync;
            }

            pvalue = (PCM_KEY_VALUE)HvGetCell(TargetHive, newvalue);
            if( (pvalue == NULL) || !HvTrackCellRef(&CellRef,TargetHive, newvalue) ) {
                //
                // we couldn't map the bin containing this cell
                // this shouldn't happen as we just allocated the cell
                // (i.e. the bin containing it should be PINNED into memory by now )
                //
                ASSERT( FALSE );
                //
                // for cleanup purposes
                //
                newlist = TargetKeyNode->ValueList.List;
                goto EndValueSync;
            }

#if DBG            
            //
            // get the name
            //
            CmpInitializeValueNameString(pvalue,&ValueName,NameBuffer);


            //
            // find out the index where we should insert this 
            // this is a special treatment for the case when we copy form and old hive (not sorted)
            // into a new format one (sorted)
            //
            if( CmpFindNameInList(TargetHive,&(TargetKeyNode->ValueList),&ValueName,&Index,&child) == FALSE ) {
                //
                // we couldn't map a view inside the above call
                //
                //
                // for cleanup purposes
                //
                newlist = TargetKeyNode->ValueList.List;
                goto EndValueSync;
            }

            //
            // the value is not present in the list; we're about to add it!
            //
            ASSERT( child == HCELL_NIL );
            
            //
            // sanity validation : insert at the end
            //
            ASSERT( Index == i );
#endif //DBG            

            if( !NT_SUCCESS( CmpAddValueToList(TargetHive,newvalue,i,Type,&(TargetKeyNode->ValueList)) ) ) {
                //
                // for cleanup purposes
                //
                newlist = TargetKeyNode->ValueList.List;

                if( newlist != HCELL_NIL ) {
                    //
                    // Delete all the copied values on an error.
                    //
                    ptarlist = HvGetCell(TargetHive, newlist);
                    if( (ptarlist == NULL) || !HvTrackCellRef(&CellRef,TargetHive, newlist) ) {
                        //
                        // we couldn't map the bin containing this cell
                        // this shouldn't fail as we just allocated this cell
                        // (i.e. the bin should be PINNED into memory at this point)
                        //
                        ASSERT( FALSE );
                        goto EndValueSync;
                    }
                    for (; i > 0; i--) {
                        HvFreeCell(
                            TargetHive,
                            ptarlist->u.KeyList[i - 1]
                            );
                    }
                }
                goto EndValueSync;
            }

        }

        success = TRUE;
    }

EndValueSync:

#if DBG
    ASSERT( NameBuffer != NULL );
    ExFreePool(NameBuffer);
#endif //DBG

    HvReleaseFreeCellRefArray(&CellRef);
    if (success == FALSE) {

        // Clean-up on failure

        if (newlist != HCELL_NIL) {
            HvFreeCell(TargetHive, newlist);
        }

        if (newclass != HCELL_NIL) {
            HvFreeCell(TargetHive, newclass);
        }

    }

    return success;
}

VOID 
CmpInitializeKeyNameString(PCM_KEY_NODE Cell, 
                           PUNICODE_STRING KeyName,
                           WCHAR *NameBuffer
                           )
/*++

Routine Description:

   Initializes a UNICODE_STRING with the name of a given key.
   
   N.B. The initialized string's buffer is not meant
         to be modified.   

Arguments:

   Cell       - The body of the key in question
   KeyName    - The UNICODE_STRING to initialize
   NameBuffer - A buffer REG_MAX_KEY_NAME_LENGTH bytes in size 
                that will possibly be used as the UNICODE_STRING's 
                buffer.

Return Value:

   NONE.

--*/
{                        
   // is the name stored in compressed form?

   if(Cell->Flags & KEY_COMP_NAME) {

      // Name is compressed. 

      // Get the uncompressed length.
                        
      KeyName->Length = CmpCompressedNameSize(Cell->Name,
                                              Cell->NameLength);
                        
      // Decompress the name into a buffer.

      CmpCopyCompressedName(NameBuffer, 
                            REG_MAX_KEY_NAME_LENGTH,
                            Cell->Name,                                            
                            Cell->NameLength);

      //
      // Use the decompression buffer as the string buffer
      //
                        
      KeyName->Buffer = NameBuffer;      
      KeyName->MaximumLength = REG_MAX_KEY_NAME_LENGTH;

   } else {

      //
      // Name is not compressed. Just use the name string 
      // from the key buffer as the string buffer.
      //
                        
      KeyName->Length = Cell->NameLength;                        
      KeyName->Buffer = Cell->Name;
      KeyName->MaximumLength = (USHORT)Cell->MaxNameLen;
                     
   }                                             
}

VOID 
CmpInitializeValueNameString(PCM_KEY_VALUE Cell, 
                             PUNICODE_STRING ValueName,
                             WCHAR *NameBuffer
                             )
/*++
Routine Description:

   Initializes a UNICODE_STRING with the name of a given value key.
   
   N.B. The initialized string's buffer is not meant
         to be modified.   

Arguments:

   Cell       - The value key in question
   ValueName    - The UNICODE_STRING to initialize
   NameBuffer - A buffer REG_MAX_KEY_NAME_LENGTH bytes in size 
                that will possibly be used as the UNICODE_STRING's 
                buffer.

Return Value:

   NONE.
--*/

{                        
   // is the name stored in compressed form?

   if(Cell->Flags & VALUE_COMP_NAME) {

      // Name is compressed. 

      // Get the uncompressed length.
                        
      ValueName->Length = CmpCompressedNameSize(Cell->Name,
                                              Cell->NameLength);
                        
      // Decompress the name into a buffer.

      CmpCopyCompressedName(NameBuffer, 
                            REG_MAX_KEY_VALUE_NAME_LENGTH,
                            Cell->Name,                                            
                            Cell->NameLength);

      //
      // Use the decompression buffer as the string buffer
      //
                        
      ValueName->Buffer = NameBuffer;      
      ValueName->MaximumLength = REG_MAX_KEY_VALUE_NAME_LENGTH;

   } else {

      //
      // Name is not compressed. Just use the name string 
      // from the ValueName buffer as the string buffer.
      //
                        
      ValueName->Length = Cell->NameLength;                        
      ValueName->Buffer = Cell->Name;
      ValueName->MaximumLength = ValueName->Length;
                     
   }                                             
}

BOOLEAN
CmpSyncSubKeysAfterDelete(PHHIVE SourceHive,
                          PCM_KEY_NODE SourceCell,
                          PHHIVE TargetHive,
                          PCM_KEY_NODE TargetCell,
                          WCHAR *NameBuffer)
/*++

Routine Description:

   This routine makes sure that any subkeys present in the target key
   but not present in the source key are deleted from the target key
   along with any trees under those subkeys.
   
   This routine is useful for synchronizing key deletion changes
   in a source cell with a target cell. It is used in this way
   from CmpCopySyncTree.
   
   NOTE: It is assumed that no open handles are held for the keys
         being deleted. If this is not so, registry in-memory
         data structures may become corrupted.
   
Arguments:

   SourceHive  - The hive of the source key
   SourceCell  - The body of the source key
   TargetHive  - The hive of the target key
   TargetCell  - The body of the target key
   NameBuffer  - A buffer REG_MAX_KEY_NAME_LENGTH bytes in size

Return Value:

   TRUE if successful, FALSE otherwise.

--*/
{
   HCELL_INDEX TargetSubKey, SourceSubKey;
   ULONG i = 0;   
   PCM_KEY_NODE SubKeyCell;
   UNICODE_STRING SubKeyName;

   //
   // Run through all of the target cell's subkeys
   //

   while((TargetSubKey = CmpFindSubKeyByNumber(
                                               TargetHive,
                                               TargetCell,
                                               i)) != HCELL_NIL)
   {
      
      //
      // Check if the current subkey has a counterpart
      // subkey of the source cell.
      // (Note that we use similar techniques as in the code
      //  of CmpCopySyncTree2)
      //

      SubKeyCell = (PCM_KEY_NODE)HvGetCell(TargetHive, TargetSubKey);
        if( SubKeyCell == NULL ) {
            //
            // we couldn't map the bin containing this cell
            //
            return FALSE;
        }

      CmpInitializeKeyNameString(SubKeyCell,
                                 &SubKeyName,
                                 NameBuffer);

      SourceSubKey = CmpFindSubKeyByName(SourceHive, 
                                         SourceCell,
                                         &SubKeyName);

      if(SourceSubKey == HCELL_NIL)
      { 
         //
         // The current subkey has no counterpart, 
         // it must therefore be deleted from the target cell.
         //

         if(SubKeyCell->SubKeyCounts[Stable] + SubKeyCell->SubKeyCounts[Volatile])
         {
            // The subkey we are deleting has subkeys - use delete tree to get rid of them            

            CmpDeleteTree(TargetHive, TargetSubKey);
         }
      
         //
         // release this cell as we don't need it anymore
         //
         HvReleaseCell(TargetHive, TargetSubKey);
         
         // The subkey we are deleting is now a leaf (or has always been one), 
         // just delete it.

         if(!NT_SUCCESS(CmpFreeKeyByCell(TargetHive, TargetSubKey, TRUE)))
         {
            return FALSE;
         }
         
         //
         // We have deleted a subkey, so *i* does not need to get incremented
         // here because it now refers to the next subkey.
         //         
      }
      else
      {
         //
         // Counterpart found. No deletion necessary. Move on to the next subkey
         //

         i++;

         //
         // release this cell as we don't need it anymore
         //
         HvReleaseCell(TargetHive, TargetSubKey);

      }
   }
         
   return TRUE;
}

BOOLEAN
CmpMarkKeyValuesDirty(
    PHHIVE Hive,
    HCELL_INDEX Cell,
    PCM_KEY_NODE Node
    )
/*++

Routine Description:

   
   Marks the cells associated with a key's value entries, security descriptor,
   and class information as dirty.
                        
Arguments:

   Hive     - The hive of the key in question
   Cell     - The cell of the key in question
   Node     - The body of the key in question


Return Value:

   TRUE if successful, FALSE otherwise.
   
   A failure probably indicates that no log space was available.

--*/
{    
    PCELL_DATA  plist, security, pvalue;
    ULONG       i;
    BOOLEAN     Result = TRUE;
    HV_TRACK_CELL_REF               CellRef = {0};

    if (Node->Flags & KEY_HIVE_EXIT) {

        //
        // If this is a link node, we are done.  Link nodes never have
        // classes, values, subkeys, or security descriptors.  Since
        // they always reside in the master hive, they're always volatile.
        //
        return(TRUE);
    }

    //
    // mark cell itself
    //
    if (! HvMarkCellDirty(Hive, Cell,FALSE)) {
        return FALSE;
    }

    //
    // Mark the class
    //
    if (Node->Class != HCELL_NIL) {
        if (! HvMarkCellDirty(Hive, Node->Class,FALSE)) {
            return FALSE;
        }
    }

    //
    // Mark security
    //
    if (Node->Security != HCELL_NIL) {
        if (! HvMarkCellDirty(Hive, Node->Security,FALSE)) {
            return FALSE;
        }

        security = HvGetCell(Hive, Node->Security);
        if( security == NULL ) {
            //
            // we couldn't map the bin containing this cell
            // this shouldn't happen as we just marked the cell dirty
            // (dirty == PINNED in memory).
            //
            ASSERT( FALSE );
            return FALSE;
        }
        if (! (HvMarkCellDirty(Hive, security->u.KeySecurity.Flink,FALSE) &&
               HvMarkCellDirty(Hive, security->u.KeySecurity.Blink,FALSE)))
        {
            HvReleaseCell(Hive, Node->Security);
            return FALSE;
        }
        HvReleaseCell(Hive, Node->Security);
    }

    //
    // Mark the value entries and their data
    //
    if (Node->ValueList.Count > 0) {

        // Value list
        if (! HvMarkCellDirty(Hive, Node->ValueList.List,FALSE)) {
            Result = FALSE;
            goto Exit;
        }
        plist = HvGetCell(Hive, Node->ValueList.List);
        if( plist == NULL ) {
            //
            // we couldn't map the bin containing this cell
            // this shouldn't happen as we just marked the cell dirty
            // (dirty == PINNED in memory).
            //
            ASSERT( FALSE );
            Result = FALSE;
            goto Exit;
        }
        if( !HvTrackCellRef(&CellRef,Hive, Node->ValueList.List) ) {
            Result = FALSE;
            goto Exit;
        }

        for (i = 0; i < Node->ValueList.Count; i++) {
            if (! HvMarkCellDirty(Hive, plist->u.KeyList[i],FALSE)) {
                Result = FALSE;
                goto Exit;
            }

            pvalue = HvGetCell(Hive, plist->u.KeyList[i]);
            if( pvalue == NULL ) {
                //
                // we couldn't map the bin containing this cell
                // this shouldn't happen as we just marked the cell dirty
                // (dirty == PINNED in memory).
                //
                ASSERT( FALSE );
                Result = FALSE;
                goto Exit;
            }
            if( !HvTrackCellRef(&CellRef,Hive, plist->u.KeyList[i]) ) {
                Result = FALSE;
                goto Exit;
            }
            
            if( !CmpMarkValueDataDirty(Hive,&(pvalue->u.KeyValue)) ) {
                Result = FALSE;
                goto Exit;
            }
            
        }
    }
Exit:
    HvReleaseFreeCellRefArray(&CellRef);
    return Result;
}

BOOLEAN
CmpMarkKeyParentDirty(
    PHHIVE Hive,
    HCELL_INDEX Cell
    )
/*++

Routine Description:

   Marks the parent of a given key and the parent's subkey list as dirty.
   
Arguments:

   Hive     - The hive of the key in question.
   Cell     - The cell of the key in question.


Return Value:

   TRUE if successful, FALSE otherwise.
   
   A failure probably indicates that no log space was available.

--*/
{

    PCELL_DATA ptarget;

    ASSERT_CM_EXCLUSIVE_HIVE_ACCESS(Hive);

    //
    // Map in the target
    //
    ptarget = HvGetCell(Hive, Cell);    
    if( ptarget == NULL ) {
        //
        // we couldn't map the bin containing this cell
        //
        return FALSE;
    }


    if (ptarget->u.KeyNode.Flags & KEY_HIVE_ENTRY) {

        //
        // if this is an entry node, we are done.  our parent will
        // be in the master hive (and thus volatile)
        //
        return TRUE;
    }

    //
    // Mark the parent's Subkey list
    //
    if (! CmpMarkIndexDirty(Hive, ptarget->u.KeyNode.Parent, Cell)) {
        return FALSE;
    }

    //
    // Mark the parent
    //
    if (! HvMarkCellDirty(Hive, ptarget->u.KeyNode.Parent, FALSE)) {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmwrapr.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmwrapr.c

Abstract:

    This module contains the source for wrapper routines called by the
    hive code, which in turn call the appropriate NT routines.

--*/

#include    "cmp.h"

VOID
CmpUnmapCmViewSurroundingOffset(
        IN  PCMHIVE             CmHive,
        IN  ULONG               FileOffset
        );

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif
ULONG perftouchbuffer = 0;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpAllocate)
#ifdef POOL_TAGGING
#pragma alloc_text(PAGE,CmpAllocateTag)
#endif
#pragma alloc_text(PAGE,CmpFree)
#pragma alloc_text(PAGE,CmpDoFileSetSize)
#pragma alloc_text(PAGE,CmpCreateEvent)
#pragma alloc_text(PAGE,CmpFileRead)
#pragma alloc_text(PAGE,CmpFileWrite)
#pragma alloc_text(PAGE,CmpFileFlush)
#pragma alloc_text(PAGE,CmpFileWriteThroughCache)
#endif

extern BOOLEAN CmpNoWrite;


//
// never read more than 64k, neither the filesystem nor some disk drivers
// like it much.
//
#define MAX_FILE_IO 0x10000

#define CmpIoFileRead       1
#define CmpIoFileWrite      2
#define CmpIoFileSetSize    3
#define CmpIoFileFlush      4

extern struct {
    ULONG       Action;
    HANDLE      Handle;
    NTSTATUS    Status;
} CmRegistryIODebug;

extern BOOLEAN CmpFlushOnLockRelease;

//
// Storage management
//

PVOID
CmpAllocate(
    ULONG   Size,
    BOOLEAN UseForIo,
    ULONG   Tag
    )
/*++

Routine Description:

    This routine makes more memory available to a hive.

    It is environment specific.

Arguments:

    Size - amount of space caller wants

    UseForIo - TRUE if object allocated will be target of I/O,
               FALSE if not.

Return Value:

    NULL if failure, address of allocated block if not.

--*/
{
    PVOID   result;
    ULONG   pooltype;

#if DBG
    PVOID   Caller;
    PVOID   CallerCaller;
    RtlGetCallersAddress(&Caller, &CallerCaller);
#endif

    if (CmpClaimGlobalQuota(Size) == FALSE) {
        return NULL;
    }

    pooltype = (UseForIo) ? PagedPoolCacheAligned : PagedPool;
    result = ExAllocatePoolWithTag(
                pooltype,
                Size,
                Tag
                );

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_POOL,"**CmpAllocate: allocate:%08lx, ", Size));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_POOL,"type:%d, at:%08lx  ", PagedPool, result));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_POOL,"c:%p  cc:%p\n", Caller, CallerCaller));

    if (result == NULL) {
        CmpReleaseGlobalQuota(Size);
    }

    return result;
}

#ifdef POOL_TAGGING
PVOID
CmpAllocateTag(
    ULONG   Size,
    BOOLEAN UseForIo,
    ULONG   Tag
    )
/*++

Routine Description:

    This routine makes more memory available to a hive.

    It is environment specific.

Arguments:

    Size - amount of space caller wants

    UseForIo - TRUE if object allocated will be target of I/O,
               FALSE if not.

Return Value:

    NULL if failure, address of allocated block if not.

--*/
{
    PVOID   result;
    ULONG   pooltype;

#if DBG
    PVOID   Caller;
    PVOID   CallerCaller;
    RtlGetCallersAddress(&Caller, &CallerCaller);
#endif

    if (CmpClaimGlobalQuota(Size) == FALSE) {
        return NULL;
    }

    pooltype = (UseForIo) ? PagedPoolCacheAligned : PagedPool;
    result = ExAllocatePoolWithTag(
                pooltype,
                Size,
                Tag
                );

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_POOL,"**CmpAllocate: allocate:%08lx, ", Size));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_POOL,"type:%d, at:%08lx  ", PagedPool, result));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_POOL,"c:%p  cc:%p\n", Caller, CallerCaller));

    if (result == NULL) {
        CmpReleaseGlobalQuota(Size);
    }
    return result;
}
#endif


VOID
CmpFree(
    PVOID   MemoryBlock,
    ULONG   GlobalQuotaSize
    )
/*++

Routine Description:

    This routine frees memory that has been allocated by the registry.

    It is environment specific


Arguments:

    MemoryBlock - supplies address of memory object to free

    GlobalQuotaSize - amount of global quota to release

Return Value:

    NONE

--*/
{
#if DBG
    PVOID   Caller;
    PVOID   CallerCaller;
    RtlGetCallersAddress(&Caller, &CallerCaller);
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_POOL,"**FREEING:%08lx c,cc:%p,%p\n", MemoryBlock, Caller, CallerCaller));
#endif
    ASSERT(GlobalQuotaSize > 0);
    CmpReleaseGlobalQuota(GlobalQuotaSize);
    ExFreePool(MemoryBlock);
    return;
}


NTSTATUS
CmpDoFileSetSize(
    PHHIVE      Hive,
    ULONG       FileType,
    ULONG       FileSize,
    ULONG       OldFileSize
    )
/*++

Routine Description:

    This routine sets the size of a file.  It must not return until
    the size is guaranteed.

    It is environment specific.

    Must be running in the context of the cmp worker thread.

Arguments:

    Hive - Hive we are doing I/O for

    FileType - which supporting file to use

    FileSize - 32 bit value to set the file's size to

    OldFileSize - old file size, in order to determine if this is a shrink;
                - ignored if file type is not primary, or hive doesn't use 
                the mapped views technique

Return Value:

    FALSE if failure
    TRUE if success

--*/
{
    PCMHIVE                         CmHive;
    HANDLE                          FileHandle;
    NTSTATUS                        Status;
    FILE_END_OF_FILE_INFORMATION    FileInfo;
    IO_STATUS_BLOCK                 IoStatus;
    BOOLEAN                         oldFlag;
    LARGE_INTEGER                   FileOffset;         // where the mapping starts

    ASSERT(FIELD_OFFSET(CMHIVE, Hive) == 0);

    CmHive = (PCMHIVE)Hive;
    FileHandle = CmHive->FileHandles[FileType];
    if (FileHandle == NULL) {
        return TRUE;
    }

    //
    // disable hard error popups, to avoid self deadlock on bogus devices
    //
    oldFlag = IoSetThreadHardErrorMode(FALSE);

    FileInfo.EndOfFile.HighPart = 0L;
    if( FileType == HFILE_TYPE_PRIMARY ) {
        FileInfo.EndOfFile.LowPart  = ROUND_UP(FileSize, CM_FILE_GROW_INCREMENT);
    } else {
        FileInfo.EndOfFile.LowPart  = FileSize;
    }

    ASSERT_PASSIVE_LEVEL();

    Status = ZwSetInformationFile(
                FileHandle,
                &IoStatus,
                (PVOID)&FileInfo,
                sizeof(FILE_END_OF_FILE_INFORMATION),
                FileEndOfFileInformation
                );

    if (NT_SUCCESS(Status)) {
        ASSERT(IoStatus.Status == Status);
    } else {
        
        //
        // set debugging info
        //
        CmRegistryIODebug.Action = CmpIoFileSetSize;
        CmRegistryIODebug.Handle = FileHandle;
        CmRegistryIODebug.Status = Status;
#if DBG
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"CmpFileSetSize:\tHandle=%08lx  OldLength = %08lx NewLength=%08lx  \n", 
                                                        FileHandle, OldFileSize, FileSize);
#endif
        if( (Status == STATUS_DISK_FULL) && ExIsResourceAcquiredExclusiveLite(&CmpRegistryLock) ) {
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"Disk is full while attempting to grow file %lx; will flush upon lock release\n",FileHandle);
            CmpFlushOnLockRelease = TRUE;;
        }
    }

    //
    // restore hard error popups mode
    //
    IoSetThreadHardErrorMode(oldFlag);
    

    //
    // purge
    //
    if( HiveWritesThroughCache(Hive,FileType) && (OldFileSize > FileSize)) {
        //
        // first we have to unmap any possible mapped views in the last 256K window
        // to avoid deadlock on CcWaitOnActiveCount inside CcPurgeCacheSection call below
        //
        ULONG   Offset = FileSize & (~(_256K - 1));
        //
        // we are not allowed to shrink in shared mode.
        //
	    ASSERT_HIVE_WRITER_LOCK_OWNED((PCMHIVE)Hive);

        while( Offset < OldFileSize ) {
            CmpUnmapCmViewSurroundingOffset((PCMHIVE)Hive,Offset);
            Offset += CM_VIEW_SIZE;
        }

        //
        // we need to take extra precaution here and unmap the very last view too
        //
        
        FileOffset.HighPart = 0;
        FileOffset.LowPart = FileSize;
        //
        // This is a shrink; Inform cache manager of the change of the size
        //
        CcPurgeCacheSection( ((PCMHIVE)Hive)->FileObject->SectionObjectPointer, (PLARGE_INTEGER)(((ULONG_PTR)(&FileOffset)) + 1), 
                            OldFileSize - FileSize, FALSE );

        //
        // Flush out this view to clear out the Cc dirty hints
        //
        CcFlushCache( ((PCMHIVE)Hive)->FileObject->SectionObjectPointer, (PLARGE_INTEGER)(((ULONG_PTR)(&FileOffset)) + 1),/*we are private writers*/
                            OldFileSize - FileSize,NULL);

    }
    
    return Status;
}

NTSTATUS
CmpCreateEvent(
    IN EVENT_TYPE  eventType,
    OUT PHANDLE eventHandle,
    OUT PKEVENT *event
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES obja;

    InitializeObjectAttributes( &obja, NULL, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL );
    status = ZwCreateEvent(
        eventHandle,
        EVENT_ALL_ACCESS,
        &obja,
        eventType,
        FALSE);
    
    if (!NT_SUCCESS(status)) {
        return status;
    }
    
    status = ObReferenceObjectByHandle(
        *eventHandle,
        EVENT_ALL_ACCESS,
        NULL,
        KernelMode,
        event,
        NULL);
    
    if (!NT_SUCCESS(status)) {
        ZwClose(*eventHandle);
        return status;
    }
    return status;
}

BOOLEAN
CmpFileRead (
    PHHIVE      Hive,
    ULONG       FileType,
    PULONG      FileOffset,
    PVOID       DataBuffer,
    ULONG       DataLength
    )
/*++

Routine Description:

    This routine reads in a buffer from a file.

    It is environment specific.

    NOTE:   We assume the handle is opened for asynchronous access,
            and that we, and not the IO system, are keeping the
            offset pointer.

    NOTE:   Only 32bit offsets are supported, even though the underlying
            IO system on NT supports 64 bit offsets.

Arguments:

    Hive - Hive we are doing I/O for

    FileType - which supporting file to use

    FileOffset - pointer to variable providing 32bit offset on input,
                 and receiving new 32bit offset on output.

    DataBuffer - pointer to buffer

    DataLength - length of buffer

Return Value:

    FALSE if failure
    TRUE if success

--*/
{
    NTSTATUS status;
    LARGE_INTEGER   Offset;
    IO_STATUS_BLOCK IoStatus;
    PCMHIVE CmHive;
    HANDLE  FileHandle;
    ULONG LengthToRead;
    HANDLE eventHandle = NULL;
    PKEVENT eventObject = NULL;

    ASSERT(FIELD_OFFSET(CMHIVE, Hive) == 0);
    CmHive = (PCMHIVE)Hive;
    FileHandle = CmHive->FileHandles[FileType];
    if (FileHandle == NULL) {
        return TRUE;
    }

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"CmpFileRead:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"\tHandle=%08lx  Offset=%08lx  ", FileHandle, *FileOffset));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"Buffer=%p  Length=%08lx\n", DataBuffer, DataLength));

    //
    // Detect attempt to read off end of 2gig file (this should be irrelevant)
    //
    if ((0xffffffff - *FileOffset) < DataLength) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpFileRead: runoff\n"));
        return FALSE;
    }

    status = CmpCreateEvent(
        SynchronizationEvent,
        &eventHandle,
        &eventObject);
    if (!NT_SUCCESS(status))
        return FALSE;

    //
    // We'd really like to just call the filesystems and have them do
    // the right thing.  But the filesystem will attempt to lock our
    // entire buffer into memory, and that may fail for large requests.
    // So we split our reads into 64k chunks and call the filesystem for
    // each one.
    //
    ASSERT_PASSIVE_LEVEL();
    while (DataLength > 0) {

        //
        // Convert ULONG to Large
        //
        Offset.LowPart = *FileOffset;
        Offset.HighPart = 0L;

        //
        // trim request down if necessary.
        //
        if (DataLength > MAX_FILE_IO) {
            LengthToRead = MAX_FILE_IO;
        } else {
            LengthToRead = DataLength;
        }

        status = ZwReadFile(
                    FileHandle,
                    eventHandle,
                    NULL,               // apcroutine
                    NULL,               // apccontext
                    &IoStatus,
                    DataBuffer,
                    LengthToRead,
                    &Offset,
                    NULL                // key
                    );

        if (STATUS_PENDING == status) {
            status = KeWaitForSingleObject(eventObject, Executive,
                                           KernelMode, FALSE, NULL);
            ASSERT(STATUS_SUCCESS == status);
            status = IoStatus.Status;
        }

        //
        // adjust offsets
        //
        *FileOffset = Offset.LowPart + LengthToRead;
        DataLength -= LengthToRead;
        DataBuffer = (PVOID)((PCHAR)DataBuffer + LengthToRead);

        if (NT_SUCCESS(status)) {
            ASSERT(IoStatus.Status == status);
            if (IoStatus.Information != LengthToRead) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpFileRead:\n\t"));
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"Failure1: status = %08lx  ", status));
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"IoInformation = %08lx\n", IoStatus.Information));
                ObDereferenceObject(eventObject);
                ZwClose(eventHandle);
                CmRegistryIODebug.Action = CmpIoFileRead;
                CmRegistryIODebug.Handle = FileHandle;
#if defined(_WIN64)
                CmRegistryIODebug.Status = (ULONG)IoStatus.Information - LengthToRead;
#else
                CmRegistryIODebug.Status = (ULONG)&IoStatus;
#endif
                return FALSE;
            }
        } else {
            //
            // set debugging info
            //
            CmRegistryIODebug.Action = CmpIoFileRead;
            CmRegistryIODebug.Handle = FileHandle;
            CmRegistryIODebug.Status = status;
#if DBG
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"CmpFileRead:\tFailure2: status = %08lx  IoStatus = %08lx\n", status, IoStatus.Status);
#endif

            ObDereferenceObject(eventObject);
            ZwClose(eventHandle);
            return FALSE;
        }

    }
    ObDereferenceObject(eventObject);
    ZwClose(eventHandle);
    return TRUE;
}

BOOLEAN
CmpFileWriteThroughCache(
    PHHIVE              Hive,
    ULONG               FileType,
    PCMP_OFFSET_ARRAY   offsetArray,
    ULONG               offsetArrayCount
    )
/*++

Routine Description:

    This is routine writes dirty ranges of data using Cc mapped views.
    The benefit is that writes don't go through Cc Lazy Writer, so there 
    is no danger to be throttled or deferred.

    It also flushes the cache for the written ranges, guaranteeing that 
    the data was commited to the disk upon return.

Arguments:

    Hive - Hive we are doing I/O for

    FileType - which supporting file to use

    offsetArray - array of structures where each structure holds a 32bit offset
                  into the Hive file and pointer the a buffer written to that
                  file offset.

    offsetArrayCount - number of elements in the offsetArray.

Return Value:

    FALSE if failure
    TRUE if success

Note:

    This routine is intended to deal only with paged bins (i.e. bins crossing the 
    CM_VIEW_SIZE boundary or bins that were added after the last sync)

Assumption:

    We work on the assumption that the data to be written at one iteration never spans 
    over the CM_VIEW_SIZE boundary. HvpFindNextDirtyBlock takes care of that !!! 
--*/
{
    ULONG           i;
    PVOID           DataBuffer;
    ULONG           DataLength;
    ULONG           FileOffset;
    PCMHIVE         CmHive;
    PVOID           Bcb;
    PVOID           FileBuffer;
    LARGE_INTEGER   Offset;
    IO_STATUS_BLOCK IoStatus;

    ASSERT_PASSIVE_LEVEL();

#if !DBG
    UNREFERENCED_PARAMETER (FileType);
#endif

    CmHive = (PCMHIVE)CONTAINING_RECORD(Hive, CMHIVE, Hive);

    ASSERT( ((FileType == HFILE_TYPE_EXTERNAL) && (CmHive->FileObject != NULL)) || HiveWritesThroughCache(Hive,FileType) );

    Offset.HighPart = 0;
    //
    // iterate through the array of data
    //
    for(i=0;i<offsetArrayCount;i++) {
        DataBuffer =  offsetArray[i].DataBuffer;
        DataLength =  offsetArray[i].DataLength;
        FileOffset = offsetArray[i].FileOffset;
        //
        // data should never span over CM_VIEW_SIZE boundary
        //
        ASSERT( (FileOffset & (~(CM_VIEW_SIZE - 1))) == ((FileOffset + DataLength - 1) & (~(CM_VIEW_SIZE - 1))) );

        //
        // unmap any possible mapped view that could overlap with this range ; not needed !!!!
        //

        //
        // map and pin data
        //
        Offset.LowPart = FileOffset;
        try {
            if( !CcPinRead (CmHive->FileObject,&Offset,DataLength,PIN_WAIT,&Bcb,&FileBuffer) ) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpFileWriteThroughCache - could not pin read view i= %lu\n",i));
#if DBG
                DbgBreakPoint();
#endif //DBG
                return FALSE;        
            }
            //
            // copy data to pinned view; we need to do it inside try except, to protect against devices/volumes
            // dismounting from under us.
            //
            RtlCopyMemory(FileBuffer,DataBuffer, DataLength);

        } except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // in low-memory scenarios, CcPinRead throws a STATUS_INSUFFICIENT_RESOURCES
            // We want to catch this and treat as a  "not enough resources" problem, 
            // rather than letting it to surface the kernel call
            //
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpFileWriteThroughCache : CcPinRead has raised :%08lx\n",GetExceptionCode()));
            return FALSE;
        }

        //
        // dirty, unpin and flush
        //
        CcSetDirtyPinnedData (Bcb,NULL);
        CcUnpinData( Bcb );
        CcFlushCache (CmHive->FileObject->SectionObjectPointer,(PLARGE_INTEGER)(((ULONG_PTR)(&Offset)) + 1)/*we are private writers*/,DataLength,&IoStatus);
        if(!NT_SUCCESS(IoStatus.Status) ) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOLEAN
CmpFileWrite(
    PHHIVE              Hive,
    ULONG               FileType,
    PCMP_OFFSET_ARRAY   offsetArray,
    ULONG               offsetArrayCount,
    PULONG              FileOffset
    )
/*++

Routine Description:

    This routine writes an array of buffers out to a file.

    It is environment specific.

    NOTE:   We assume the handle is opened for asynchronous access,
            and that we, and not the IO system, are keeping the
            offset pointer.

    NOTE:   Only 32bit offsets are supported, even though the underlying
            IO system on NT supports 64 bit offsets.

Arguments:

    Hive - Hive we are doing I/O for

    FileType - which supporting file to use

    offsetArray - array of structures where each structure holds a 32bit offset
                  into the Hive file and pointer the a buffer written to that
                  file offset.

    offsetArrayCount - number of elements in the offsetArray.

    FileOffset - returns the file offset after the last write to the file.

Return Value:

    FALSE if failure
    TRUE if success

--*/
{
    NTSTATUS        status;
    LARGE_INTEGER   Offset;
    PCMHIVE         CmHive;
    HANDLE          FileHandle;
    ULONG           LengthToWrite;
    LONG            WaitBufferCount = 0;
    LONG            idx;
    ULONG           arrayCount = 0;
    PVOID           DataBuffer = NULL;      // W4 only
    ULONG           DataLength;
    BOOLEAN         ret_val = TRUE;
    PCM_WRITE_BLOCK WriteBlock = NULL;

    if (CmpNoWrite) {
        return TRUE;
    }

    ASSERT(FIELD_OFFSET(CMHIVE, Hive) == 0);
    CmHive = (PCMHIVE)Hive;
    FileHandle = CmHive->FileHandles[FileType];
    if (FileHandle == NULL) {
        return TRUE;
    }

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"CmpFileWrite:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"\tHandle=%08lx  ", FileHandle));

    //
    // decide whether we wait for IOs to complete or just issue them and
    // rely on the CcFlushCache to do the job
    //
    
    // Bring pages being written into memory first to allow disk to write
    // buffer contiguously.
    try {
        for (idx = 0; (ULONG) idx < offsetArrayCount; idx++) {
            char * start = offsetArray[idx].DataBuffer;
            char * end = (char *) start + offsetArray[idx].DataLength;
            while (start < end) {
                // perftouchbuffer globally declared so that compiler won't try
                // to remove it and this loop (if its smart enough?).
                perftouchbuffer += (ULONG) *start;
                start += PAGE_SIZE;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // we might get STATUS_IN_PAGE_ERROR 
        //
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpFileWrite has raised :%08lx\n",GetExceptionCode()));
        return FALSE;
    }

    WriteBlock = (PCM_WRITE_BLOCK)ExAllocatePool(NonPagedPool,sizeof(CM_WRITE_BLOCK));
    if( WriteBlock == NULL ) {
        return FALSE;
    }

    for (idx = 0; idx < MAXIMUM_WAIT_OBJECTS; idx++) {
        WriteBlock->EventHandles[idx] = NULL;
#if DBG
        WriteBlock->EventObjects[idx] = NULL;
#endif
    }
    //
    // We'd really like to just call the filesystems and have them do
    // the right thing.  But the filesystem will attempt to lock our
    // entire buffer into memory, and that may fail for large requests.
    // So we split our reads into 64k chunks and call the filesystem for
    // each one.
    //
    ASSERT_PASSIVE_LEVEL();
    arrayCount = 0;
    DataLength = 0;
    // This outer loop is hit more than once if the MAXIMUM_WAIT_OBJECTS limit
    // is hit before the offset array is drained.
    while (arrayCount < offsetArrayCount) {
        WaitBufferCount = 0;

        // This loop fills the wait buffer.
        while ((arrayCount < offsetArrayCount) &&
               (WaitBufferCount < MAXIMUM_WAIT_OBJECTS)) {

            // If data length isn't zero than the wait buffer filled before the
            // buffer in the last offsetArray element was sent to write file.
            if (DataLength == 0) {
                *FileOffset = offsetArray[arrayCount].FileOffset;
                DataBuffer =  offsetArray[arrayCount].DataBuffer;
                DataLength =  offsetArray[arrayCount].DataLength;
                //
                // Detect attempt to read off end of 2gig file
                // (this should be irrelevant)
                //
                if ((0xffffffff - *FileOffset) < DataLength) {
                    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpFileWrite: runoff\n"));
                    status = STATUS_INVALID_PARAMETER_5;
                    goto Error_Exit;
                }
            }
            // else still more to write out of last buffer.

            while ((DataLength > 0) && (WaitBufferCount < MAXIMUM_WAIT_OBJECTS)) {

                //
                // Convert ULONG to Large
                //
                Offset.LowPart = *FileOffset;
                Offset.HighPart = 0L;

                //
                // trim request down if necessary.
                //
                if (DataLength > MAX_FILE_IO) {
                    LengthToWrite = MAX_FILE_IO;
                } else {
                    LengthToWrite = DataLength;
                }

                // Previously created events are reused.
                if (WriteBlock->EventHandles[WaitBufferCount] == NULL) {
                    status = CmpCreateEvent(SynchronizationEvent,
                                            &(WriteBlock->EventHandles[WaitBufferCount]),
                                            &(WriteBlock->EventObjects[WaitBufferCount]));
                    if (!NT_SUCCESS(status)) {
                        // Make sure we don't try to clean this up.
                        WriteBlock->EventHandles[WaitBufferCount] = NULL;
                        goto Error_Exit;
                    }
                    CmpSetHandleProtection(WriteBlock->EventHandles[WaitBufferCount],TRUE);
                }
                
                status = ZwWriteFile(FileHandle,
                                     WriteBlock->EventHandles[WaitBufferCount],
                                     NULL,               // apcroutine
                                     NULL,               // apccontext
                                     &(WriteBlock->IoStatus[WaitBufferCount]),
                                     DataBuffer,
                                     LengthToWrite,
                                     &Offset,
                                     NULL);
                        
                if (!NT_SUCCESS(status)) {
                    goto Error_Exit;
                } 

                WaitBufferCount++;
                
                //
                // adjust offsets
                //
                *FileOffset = Offset.LowPart + LengthToWrite;
                DataLength -= LengthToWrite;
                DataBuffer = (PVOID)((PCHAR)DataBuffer + LengthToWrite);
            } // while (DataLength > 0 && WaitBufferCount < MAXIMUM_WAIT_OBJECTS)
            
            arrayCount++;
            
        } // while (arrayCount < offsetArrayCount && 
          //        WaitBufferCount < MAXIMUM_WAIT_OBJECTS)

        status = KeWaitForMultipleObjects(WaitBufferCount, 
                                          WriteBlock->EventObjects,
                                          WaitAll,
                                          Executive,
                                          KernelMode, 
                                          FALSE, 
                                          NULL,
                                          WriteBlock->WaitBlockArray);
    
        if (!NT_SUCCESS(status))
            goto Error_Exit;
    
        for (idx = 0; idx < WaitBufferCount; idx++) {
            if (!NT_SUCCESS(WriteBlock->IoStatus[idx].Status)) {
                status = WriteBlock->IoStatus[idx].Status;
                ret_val = FALSE;
                goto Done;
            }
        }
        
        // There may still be more to do if the last element held a big buffer
        // and the wait buffer filled before it was all sent to the file.
        if (DataLength > 0) {
            arrayCount--;
        }

    } // while (arrayCount < offsetArrayCount)

    ret_val = TRUE;

    goto Done;
Error_Exit:
    //
    // set debugging info
    //
    CmRegistryIODebug.Action = CmpIoFileWrite;
    CmRegistryIODebug.Handle = FileHandle;
    CmRegistryIODebug.Status = status;
#if DBG
    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"CmpFileWrite: error exiting %d\n", status);
#endif
    //
    // if WaitBufferCount > 0 then we have successfully issued
    // some I/Os, but not all of them. This is an error, but we
    // cannot return from this routine until all the successfully
    // issued I/Os have completed.
    //
    if (WaitBufferCount > 0) {
        //
        // only if we decided that we want to wait for the write to complete 
        // (log files and hives not using the mapped views technique)
        //
        status = KeWaitForMultipleObjects(WaitBufferCount, 
                                          WriteBlock->EventObjects,
                                          WaitAll,
                                          Executive,
                                          KernelMode, 
                                          FALSE, 
                                          NULL,
                                          WriteBlock->WaitBlockArray);
    }


    ret_val = FALSE;
Done:
    idx = 0;
    // Clean up open event handles and objects.
    while ((idx < MAXIMUM_WAIT_OBJECTS) && (WriteBlock->EventHandles[idx] != NULL)) {
        ASSERT( WriteBlock->EventObjects[idx] );
        ObDereferenceObject(WriteBlock->EventObjects[idx]);
        CmCloseHandle(WriteBlock->EventHandles[idx]);
        idx++;
    }

    if( WriteBlock != NULL ) {
        ExFreePool(WriteBlock);
    }

    return ret_val;
}

BOOLEAN
CmpFileFlush (
    PHHIVE          Hive,
    ULONG           FileType,
    PLARGE_INTEGER  FileOffset,
    ULONG           Length
    )
/*++

Routine Description:

    This routine performs a flush on a file handle.

Arguments:

    Hive - Hive we are doing I/O for

    FileType - which supporting file to use

    FileOffset - If this parameter is supplied (not NULL), then only the
                 byte range specified by FileOffset and Length are flushed.

    Length - Defines the length of the byte range to flush, starting at
             FileOffset.  This parameter is ignored if FileOffset is
             specified as NULL.
    

Return Value:

    FALSE if failure
    TRUE if success

Note: 
    
    FileOffset and Length are only taken into account when FileType == HFILE_TYPE_PRIMARY
    and the hive uses the mapped-views method.
--*/
{
    NTSTATUS        status;
    IO_STATUS_BLOCK IoStatus;
    PCMHIVE         CmHive;
    HANDLE          FileHandle;

    ASSERT(FIELD_OFFSET(CMHIVE, Hive) == 0);
    CmHive = (PCMHIVE)Hive;
    FileHandle = CmHive->FileHandles[FileType];
    if (FileHandle == NULL) {
        return TRUE;
    }

    if (CmpNoWrite) {
        return TRUE;
    }

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"CmpFileFlush:\n\tHandle = %08lx\n", FileHandle));

    ASSERT_PASSIVE_LEVEL();


    if( HiveWritesThroughCache(Hive,FileType) == TRUE ) {       
        //
        // OK, we need to flush using CcFlushCache
        //
        CcFlushCache (CmHive->FileObject->SectionObjectPointer,(PLARGE_INTEGER)((ULONG_PTR)FileOffset + 1)/*we are private writers*/,Length,&IoStatus);
        status = IoStatus.Status;
	    if( !NT_SUCCESS(status) ) {
			goto Error;
		}
    } 
    //
    // we have to do that regardless, to make sure the disk cache makes it to the disk.
    //
    status = ZwFlushBuffersFile(
                FileHandle,
                &IoStatus
                );

    if (NT_SUCCESS(status)) {
        ASSERT(IoStatus.Status == status);
        return TRUE;
    } else {
Error:
        //
        // set debugging info
        //
        CmRegistryIODebug.Action = CmpIoFileFlush;
        CmRegistryIODebug.Handle = FileHandle;
        CmRegistryIODebug.Status = status;

#if DBG
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"CmpFileFlush:\tFailure1: status = %08lx  IoStatus = %08lx\n",status,IoStatus.Status);
#endif
        return FALSE;
    }
}

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmworker.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmworker.c

Abstract:

    This module contains support for the worker thread of the registry.
    The worker thread (actually an executive worker thread is used) is
    required for operations that must take place in the context of the
    system process.  (particularly file I/O)

--*/

#include    "cmp.h"

extern  LIST_ENTRY  CmpHiveListHead;

VOID
CmpInitializeHiveList(
    VOID
    );

//
// ----- LAZY FLUSH CONTROL -----
//
// LAZY_FLUSH_INTERVAL_IN_SECONDS controls how many seconds will elapse
// between when the hive is marked dirty and when the lazy flush worker
// thread is queued to write the data to disk.
//
ULONG CmpLazyFlushIntervalInSeconds = 5;
//
// number of hive flushed at one time (default to all system hive + 2 = current logged on user hives)
//
ULONG CmpLazyFlushHiveCount = 7;

//
// LAZY_FLUSH_TIMEOUT_IN_SECONDS controls how long the lazy flush worker
// thread will wait for the registry lock before giving up and queueing
// the lazy flush timer again.
//
#define LAZY_FLUSH_TIMEOUT_IN_SECONDS 1

//
// force enable lazy flusher 10 mins after boot, regardless
//
#define ENABLE_LAZY_FLUSH_INTERVAL_IN_SECONDS   600

PKPROCESS   CmpSystemProcess;
KTIMER      CmpLazyFlushTimer;
KDPC        CmpLazyFlushDpc;
WORK_QUEUE_ITEM CmpLazyWorkItem;

KTIMER      CmpEnableLazyFlushTimer;
KDPC        CmpEnableLazyFlushDpc;

BOOLEAN CmpLazyFlushPending = FALSE;
BOOLEAN CmpForceForceFlush = FALSE;
BOOLEAN CmpHoldLazyFlush = TRUE;
BOOLEAN CmpDontGrowLogFile = FALSE;

extern BOOLEAN CmpNoWrite;
extern BOOLEAN CmpWasSetupBoot;
extern BOOLEAN HvShutdownComplete;
extern BOOLEAN CmpProfileLoaded;

//
// Indicate whether the "disk full" popup has been triggered yet or not.
//
extern BOOLEAN CmpDiskFullWorkerPopupDisplayed;

//
// set to true if disk full when trying to save the changes made between system hive loading and registry initialization
//
extern BOOLEAN CmpCannotWriteConfiguration;
extern UNICODE_STRING SystemHiveFullPathName;
extern HIVE_LIST_ENTRY CmpMachineHiveList[];
extern BOOLEAN  CmpTrackHiveClose;

#if DBG
PKTHREAD    CmpCallerThread = NULL;
#endif


VOID
CmpLazyFlushWorker(
    IN PVOID Parameter
    );

VOID
CmpLazyFlushDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
CmpEnableLazyFlushDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
CmpDiskFullWarningWorker(
    IN PVOID WorkItem
    );

VOID
CmpDiskFullWarning(
    VOID
    );

BOOLEAN
CmpDoFlushNextHive(
    BOOLEAN     ForceFlush,
    PBOOLEAN    PostWarning,
    PULONG      DirtyCount
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpLazyFlush)
#pragma alloc_text(PAGE,CmpLazyFlushWorker)
#pragma alloc_text(PAGE,CmpDiskFullWarningWorker)
#pragma alloc_text(PAGE,CmpDiskFullWarning)
#pragma alloc_text(PAGE,CmpCmdHiveClose)
#pragma alloc_text(PAGE,CmpCmdInit)
#pragma alloc_text(PAGE,CmpCmdRenameHive)
#pragma alloc_text(PAGE,CmpCmdHiveOpen)
#pragma alloc_text(PAGE,CmSetLazyFlushState)
#endif

VOID 
CmpCmdHiveClose(
                     PCMHIVE    CmHive
                     )
/*++

Routine Description:

    Closes all the file handles for the specified hive
Arguments:

    CmHive - the hive to close

Return Value:
    none
--*/
{
    ULONG                   i;
    IO_STATUS_BLOCK         IoStatusBlock;
    FILE_BASIC_INFORMATION  BasicInfo;
    LARGE_INTEGER           systemtime;
    BOOLEAN                 oldFlag;

    CM_PAGED_CODE();

    //
    // disable hard error popups, to workaround ObAttachProcessStack 
    //
    oldFlag = IoSetThreadHardErrorMode(FALSE);

    //
    // Close the files associated with this hive.
    //
    ASSERT_CM_LOCK_OWNED_EXCLUSIVE_OR_HIVE_LOADING(CmHive);

    for (i=0; i<HFILE_TYPE_MAX; i++) {
        if (CmHive->FileHandles[i] != NULL) {
            //
            // attempt to set change the last write time (profile guys are relying on it!)
            //
            if( i == HFILE_TYPE_PRIMARY ) {
                if( NT_SUCCESS(ZwQueryInformationFile(
                                        CmHive->FileHandles[i],
                                        &IoStatusBlock,
                                        &BasicInfo,
                                        sizeof(BasicInfo),
                                        FileBasicInformation) ) ) {

                    KeQuerySystemTime(&systemtime);

                    if( CmHive->Hive.DirtyFlag ) {
                        BasicInfo.LastWriteTime  = systemtime;
                    }
                    BasicInfo.LastAccessTime = systemtime;

                    ZwSetInformationFile(
                        CmHive->FileHandles[i],
                        &IoStatusBlock,
                        &BasicInfo,
                        sizeof(BasicInfo),
                        FileBasicInformation
                        );
                }

                CmpTrackHiveClose = TRUE;
                CmCloseHandle(CmHive->FileHandles[i]);
                CmpTrackHiveClose = FALSE;
                
            } else {
                CmCloseHandle(CmHive->FileHandles[i]);
            }
            
            CmHive->FileHandles[i] = NULL;
        }
    }
    //
    // restore hard error popups mode
    //
    IoSetThreadHardErrorMode(oldFlag);
}

VOID 
CmpCmdInit(
           BOOLEAN SetupBoot
            )
/*++

Routine Description:

    Initializes cm globals and flushes all hives to the disk.

Arguments:

    SetupBoot - whether the boot is from setup or a regular boot

Return Value:
    none
--*/
{
    LARGE_INTEGER   DueTime;

    CM_PAGED_CODE();

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();
    //
    // Initialize lazy flush timer and DPC
    //
    KeInitializeDpc(&CmpLazyFlushDpc,
                    CmpLazyFlushDpcRoutine,
                    NULL);

    KeInitializeTimer(&CmpLazyFlushTimer);

    ExInitializeWorkItem(&CmpLazyWorkItem, CmpLazyFlushWorker, NULL);

    //
    // the one to force activate lazy flush 10 mins after boot.
    // arm the timer as well
    //
    KeInitializeDpc(&CmpEnableLazyFlushDpc,
                    CmpEnableLazyFlushDpcRoutine,
                    NULL);
    KeInitializeTimer(&CmpEnableLazyFlushTimer);
    DueTime.QuadPart = Int32x32To64(ENABLE_LAZY_FLUSH_INTERVAL_IN_SECONDS,
                                    - SECOND_MULT);

    KeSetTimer(&CmpEnableLazyFlushTimer,
               DueTime,
               &CmpEnableLazyFlushDpc);

    CmpNoWrite = CmpMiniNTBoot;

    CmpWasSetupBoot = SetupBoot;
    
    if (SetupBoot == FALSE) {
        CmpInitializeHiveList();
    } 
   
    //
    // Since we are done with initialization, 
    // disable the hive sharing
    // 
    if (CmpMiniNTBoot && CmpShareSystemHives) {
        CmpShareSystemHives = FALSE;
    }    
}


NTSTATUS 
CmpCmdRenameHive(
            PCMHIVE                     CmHive,
            POBJECT_NAME_INFORMATION    OldName,
            PUNICODE_STRING             NewName,
            ULONG                       NameInfoLength
            )
/*++

Routine Description:

    rename a cmhive's primary handle

    replaces old REG_CMD_RENAME_HIVE worker case

Arguments:

    CmHive - hive to rename
    
    OldName - old name information

    NewName - the new name for the file

    NameInfoLength - sizeof name information structure

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                    Status;
    HANDLE                      Handle;
    PFILE_RENAME_INFORMATION    RenameInfo;
    IO_STATUS_BLOCK IoStatusBlock;

    CM_PAGED_CODE();

    //
    // Rename a CmHive's primary handle
    //
    Handle = CmHive->FileHandles[HFILE_TYPE_PRIMARY];
    if (OldName != NULL) {
        ASSERT_PASSIVE_LEVEL();
        Status = ZwQueryObject(Handle,
                               ObjectNameInformation,
                               OldName,
                               NameInfoLength,
                               &NameInfoLength);
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    RenameInfo = ExAllocatePool(PagedPool,
                                sizeof(FILE_RENAME_INFORMATION) + NewName->Length);
    if (RenameInfo == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RenameInfo->ReplaceIfExists = FALSE;
    RenameInfo->RootDirectory = NULL;
    RenameInfo->FileNameLength = NewName->Length;
    RtlCopyMemory(RenameInfo->FileName,
                  NewName->Buffer,
                  NewName->Length);

    Status = ZwSetInformationFile(Handle,
                                  &IoStatusBlock,
                                  (PVOID)RenameInfo,
                                  sizeof(FILE_RENAME_INFORMATION) +
                                  NewName->Length,
                                  FileRenameInformation);
    ExFreePool(RenameInfo);

    return Status;
}

NTSTATUS 
CmpCmdHiveOpen(
            POBJECT_ATTRIBUTES          FileAttributes,
            PSECURITY_CLIENT_CONTEXT    ImpersonationContext,
            PBOOLEAN                    Allocate,
            PCMHIVE                     *NewHive,
		    ULONG						CheckFlags
            )
/*++

Routine Description:


    replaces old REG_CMD_HIVE_OPEN worker case

Arguments:


Return Value:

    NTSTATUS

--*/
{
    PUNICODE_STRING FileName;
    NTSTATUS        Status;
    HANDLE          NullHandle;

    CM_PAGED_CODE();

    //
    // Open the file.
    //
    FileName = FileAttributes->ObjectName;

    Status = CmpInitHiveFromFile(FileName,
                                 0,
                                 NewHive,
                                 Allocate,
								 CheckFlags);
    //
    // NT Servers will return STATUS_ACCESS_DENIED. Netware 3.1x
    // servers could return any of the other error codes if the GUEST
    // account is disabled.
    //
    if (((Status == STATUS_ACCESS_DENIED) ||
         (Status == STATUS_NO_SUCH_USER) ||
         (Status == STATUS_WRONG_PASSWORD) ||
         (Status == STATUS_ACCOUNT_EXPIRED) ||
         (Status == STATUS_ACCOUNT_DISABLED) ||
         (Status == STATUS_ACCOUNT_RESTRICTION)) &&
        (ImpersonationContext != NULL)) {
        //
        // Impersonate the caller and try it again.  This
        // lets us open hives on a remote machine.
        //
        Status = SeImpersonateClientEx(
                        ImpersonationContext,
                        NULL);

        if ( NT_SUCCESS( Status ) ) {

            Status = CmpInitHiveFromFile(FileName,
                                         0,
                                         NewHive,
                                         Allocate,
										 CheckFlags);
            NullHandle = NULL;

            PsRevertToSelf();
        }
    }
    
    return Status;
}


VOID
CmpLazyFlush(
    VOID
    )

/*++

Routine Description:

    This routine resets the registry timer to go off at a specified interval
    in the future (LAZY_FLUSH_INTERVAL_IN_SECONDS).

Arguments:

    None

Return Value:

    None.

--*/

{
    LARGE_INTEGER DueTime;

    CM_PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"CmpLazyFlush: setting lazy flush timer\n"));
    if ((!CmpNoWrite) && (!CmpHoldLazyFlush)) {

        DueTime.QuadPart = Int32x32To64(CmpLazyFlushIntervalInSeconds,
                                        - SECOND_MULT);

        //
        // Indicate relative time
        //

        KeSetTimer(&CmpLazyFlushTimer,
                   DueTime,
                   &CmpLazyFlushDpc);

    }


}

VOID
CmpEnableLazyFlushDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

{
    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (DeferredContext);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);

    CmpHoldLazyFlush = FALSE;
}

VOID
CmpLazyFlushDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This is the DPC routine triggered by the lazy flush timer.  All it does
    is queue a work item to an executive worker thread.  The work item will
    do the actual lazy flush to disk.

Arguments:

    Dpc - Supplies a pointer to the DPC object.

    DeferredContext - not used

    SystemArgument1 - not used

    SystemArgument2 - not used

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (DeferredContext);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"CmpLazyFlushDpc: queuing lazy flush work item\n"));

    if ((!CmpLazyFlushPending) && (!CmpHoldLazyFlush)) {
        CmpLazyFlushPending = TRUE;
        ExQueueWorkItem(&CmpLazyWorkItem, DelayedWorkQueue);
    }

}

ULONG   CmpLazyFlushCount = 1;

VOID
CmpLazyFlushWorker(
    IN PVOID Parameter
    )

/*++

Routine Description:

    Worker routine called to do a lazy flush.  Called by an executive worker
    thread in the system process.  

Arguments:

    Parameter - not used.

Return Value:

    None.

--*/

{
    BOOLEAN Result = TRUE;
    BOOLEAN ForceFlush;
    BOOLEAN PostNewWorker = FALSE;
    ULONG   DirtyCount = 0;

    CM_PAGED_CODE();

    UNREFERENCED_PARAMETER (Parameter);

    if( CmpHoldLazyFlush ) {
        //
        // lazy flush mode is disabled
        //
        return;
    }

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"CmpLazyFlushWorker: flushing hives\n"));

    ForceFlush = CmpForceForceFlush;
    if(ForceFlush == TRUE) {
        //
        // something bad happened and we may need to fix hive's use count
        //
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"CmpLazyFlushWorker: Force Flush - getting the reglock exclusive\n"));
        CmpLockRegistryExclusive();
    } else {
        CmpLockRegistry();
        ENTER_FLUSH_MODE();
    }
    if (!HvShutdownComplete) {
        //
        // no loads/unloads while flush in progress
        //
        LOCK_HIVE_LOAD();
        PostNewWorker = CmpDoFlushNextHive(ForceFlush,&Result,&DirtyCount);
        UNLOCK_HIVE_LOAD();

        if( !PostNewWorker ) {
            //
            // we have completed a sweep through the entire list of hives
            //
            InterlockedIncrement( (PLONG)&CmpLazyFlushCount );
        }
    } else {
        CmpForceForceFlush = FALSE;
    }

    if( ForceFlush == FALSE ) {
        EXIT_FLUSH_MODE();
    }

    CmpLazyFlushPending = FALSE;
    CmpUnlockRegistry();

    if( CmpCannotWriteConfiguration ) {
        //
        // Disk full; system hive has not been saved at initialization
        //
        if(!Result) {
            //
            // All hives were saved; No need for disk full warning anymore
            //
            CmpCannotWriteConfiguration = FALSE;
        } else {
            //
            // Issue another hard error (if not already displayed) and postpone a lazy flush operation
            //
            CmpDiskFullWarning();
            CmpLazyFlush();
        }
    }
    //
    // if we have not yet flushed the whole list; or there are still hives dirty from the curently ended iteration.
    //
    if( PostNewWorker || (DirtyCount != 0) ) {
        //
        // post a new worker to flush the next hive
        //
        CmpLazyFlush();
    }

}

VOID
CmpDiskFullWarningWorker(
    IN PVOID WorkItem
    )

/*++

Routine Description:

    Displays hard error popup that indicates the disk is full.

Arguments:

    WorkItem - Supplies pointer to the work item. This routine will
               free the work item.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    ULONG Response;

    ExFreePool(WorkItem);

    Status = ExRaiseHardError(STATUS_DISK_FULL,
                              0,
                              0,
                              NULL,
                              OptionOk,
                              &Response);
}



VOID
CmpDiskFullWarning(
    VOID
    )
/*++

Routine Description:

    Raises a hard error of type STATUS_DISK_FULL if wasn't already raised

Arguments:

    None

Return Value:

    None

--*/
{
    PWORK_QUEUE_ITEM WorkItem;

    if( (!CmpDiskFullWorkerPopupDisplayed) && (CmpCannotWriteConfiguration) && (ExReadyForErrors) && (CmpProfileLoaded) ) {

        //
        // Queue work item to display popup
        //
        WorkItem = ExAllocatePool(NonPagedPool, sizeof(WORK_QUEUE_ITEM));
        if (WorkItem != NULL) {

            CmpDiskFullWorkerPopupDisplayed = TRUE;
            ExInitializeWorkItem(WorkItem,
                                 CmpDiskFullWarningWorker,
                                 WorkItem);
            ExQueueWorkItem(WorkItem, DelayedWorkQueue);
        }
    }
}

VOID
CmpShutdownWorkers(
    VOID
    )
/*++

Routine Description:

    Shuts down the lazy flush worker (by killing the timer)

Arguments:

    None

Return Value:

    None

--*/
{
    CM_PAGED_CODE();

    KeCancelTimer(&CmpLazyFlushTimer);
}

VOID
CmSetLazyFlushState(__in BOOLEAN Enable)
/*++

Routine Description:
    
    Enables/Disables the lazy flusher; Designed for the standby/resume case, where 
    we we don't want the lazy flush to fire off, blocking registry writers until the 
    disk wakes up.

Arguments:

    Enable - TRUE = enable; FALSE = disable

Return Value:

    None.

--*/
{
    CM_PAGED_CODE();

    CmpDontGrowLogFile = CmpHoldLazyFlush = !Enable;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmwrapr2.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmwrapr2.c

Abstract:

    This module contains the source for wrapper routines called by the
    hive code, which in turn call the appropriate NT routines.  But not
    callable from user mode.

--*/

#include    "cmp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpFileSetSize)
#endif

extern  KEVENT StartRegistryCommand;
extern  KEVENT EndRegistryCommand;

//
// Write-Control:
//  CmpNoWrite is initially true.  When set this way write and flush
//  do nothing, simply returning success.  When cleared to FALSE, I/O
//  is enabled.  This change is made after the I/O system is started
//  AND autocheck (chkdsk) has done its thing.
//

extern  BOOLEAN CmpNoWrite;


BOOLEAN
CmpFileSetSize(
    PHHIVE      Hive,
    ULONG       FileType,
    ULONG       FileSize,
    ULONG       OldFileSize
    )
/*++

Routine Description:

    This routine sets the size of a file.  It must not return until
    the size is guaranteed, therefore, it does a flush.

    It is environment specific.

    This routine will force execution to the correct thread context.

Arguments:

    Hive - Hive we are doing I/O for

    FileType - which supporting file to use

    FileSize - 32 bit value to set the file's size to

Return Value:

    FALSE if failure
    TRUE if success

--*/
{
    NTSTATUS    status;

    ASSERT(FIELD_OFFSET(CMHIVE, Hive) == 0);

    ASSERT_HIVE_WRITER_LOCK_OWNED((PCMHIVE)Hive);

    //
    // Call the worker to do real work for us.
    //
    status = CmpDoFileSetSize(Hive,FileType,FileSize,OldFileSize);
    
    if (!NT_SUCCESS(status)) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmpFileSetSize:\n\t"));
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"Failure: status = %08lx ", status));
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\hivebin.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    hivebin.c

Abstract:

    This module implements HvpAddBin - used to grow a hive.

--*/

#include    "cmp.h"

//
// Private function prototypes
//
BOOLEAN
HvpCoalesceDiscardedBins(
    IN PHHIVE Hive,
    IN ULONG NeededSize,
    IN HSTORAGE_TYPE Type
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HvpAddBin)
#pragma alloc_text(PAGE,HvpCoalesceDiscardedBins)
#endif


PHBIN
HvpAddBin(
    IN PHHIVE  Hive,
    IN ULONG   NewSize,
    IN HSTORAGE_TYPE   Type
    )
/*++

Routine Description:

    Grows either the Stable or Volatile storage of a hive by adding
    a new bin.  Bin will be allocated space in Stable store (e.g. file)
    if Type == Stable.  Memory image will be allocated and initialized.
    Map will be grown and filled in to describe the new bin.
    
      
WARNING:
    When adding a new bin, if the CM_VIEW_SIZE boundary is crossed:
    - add a free bin with the remaining space to the first CM_VIEW_SIZE barrier
    - from the next CM_VIEW_SIZE window, add a new bin of the desired size.

    Of course, this applies only to stable storage.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    NewSize - size of the object caller wishes to put in the hive.  New
                bin will be at least large enough to hold this.

    Type - Stable or Volatile

Return Value:

    Pointer to the new BIN if we succeeded, NULL if we failed.

--*/
{
    BOOLEAN         UseForIo;
    PHBIN           NewBin;
    PHBIN           RemainingBin;
    ULONG           OldLength;
    ULONG           NewLength;
    ULONG           CheckLength;
    ULONG           OldMap;
    ULONG           NewMap;
    ULONG           OldTable;
    ULONG           NewTable;
    PHMAP_DIRECTORY Dir = NULL;
    PHMAP_TABLE     newt = NULL;
    PHMAP_ENTRY     Me;
    PHCELL          t;
    ULONG           i;
    ULONG           j;
    PULONG          NewVector = NULL;
    PLIST_ENTRY     Entry;
    PFREE_HBIN      FreeBin = NULL;
    ULONG           TotalDiscardedSize;
    PCMHIVE			CmHive;

    CM_PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"HvpAddBin:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"\tHive=%p NewSize=%08lx\n",Hive,NewSize));

    CmHive = (PCMHIVE)CONTAINING_RECORD(Hive, CMHIVE, Hive);

    ASSERT_HIVE_WRITER_LOCK_OWNED(CmHive);

    // need to hold this, so no flush of partial data occurs
    ASSERT_HIVE_FLUSHER_LOCKED(CmHive);

    RemainingBin = NULL;

    //
    //  Round size up to account for bin overhead.  Caller should
    //  have accounted for cell overhead.
    //
    NewSize += sizeof(HBIN);
    if ((NewSize < HCELL_BIG_ROUND) &&
        ((NewSize % HBLOCK_SIZE) > HBIN_THRESHOLD)) {
        NewSize += HBLOCK_SIZE;
    }

    //
    // Try not to create HBINs smaller than the page size of the machine
    //  (it is not illegal to have bins smaller than the page size, but it
    //  is less efficient)
    //
    NewSize = ROUND_UP(NewSize, ((HBLOCK_SIZE >= PAGE_SIZE) ? HBLOCK_SIZE : PAGE_SIZE));

    //
    // see if there's a discarded HBIN of the right size
    //
    TotalDiscardedSize = 0;

Retry:

    Entry = Hive->Storage[Type].FreeBins.Flink;
    while (Entry != &Hive->Storage[Type].FreeBins) {
        FreeBin = CONTAINING_RECORD(Entry,
                                    FREE_HBIN,
                                    ListEntry);
        TotalDiscardedSize += FreeBin->Size;
        if ((FreeBin->Size >= NewSize) && ((CmHive->GrowOnlyMode == FALSE) || (Type == Volatile)) ) {

            if (!HvMarkDirty(Hive,
                             FreeBin->FileOffset + (Type * HCELL_TYPE_MASK),
                             FreeBin->Size,TRUE)) {
                goto ErrorExit1;
            }
            NewSize = FreeBin->Size;
            ASSERT_LISTENTRY(&FreeBin->ListEntry);
            RemoveEntryList(&FreeBin->ListEntry);

            if ( FreeBin->Flags & FREE_HBIN_DISCARDABLE ) {
                //
                // HBIN is still in memory, don't need any more allocs, just
                // fill in the block addresses.
                //
                Me = NULL;
                for (i=0;i<NewSize;i+=HBLOCK_SIZE) {
                    Me = HvpGetCellMap(Hive, FreeBin->FileOffset+i+(Type*HCELL_TYPE_MASK));
                    VALIDATE_CELL_MAP(__LINE__,Me,Hive,FreeBin->FileOffset+i+(Type*HCELL_TYPE_MASK));
                    Me->BlockAddress = HBIN_BASE(Me->BinAddress)+i;
                    Me->BinAddress &= ~HMAP_DISCARDABLE;
                    // we cannot have the FREE_BIN_DISCARDABLE flag set 
                    // and FREE_HBIN_INVIEW not set on a mapped bin.
                    ASSERT( Me->BinAddress & HMAP_INPAGEDPOOL );
                    // we don't need to set it to NULL - just for debug purposes
                    ASSERT( (Me->CmView = NULL) == NULL );
                }
                (Hive->Free)(FreeBin, sizeof(FREE_HBIN));
#if DBG 
                {
                    UNICODE_STRING  HiveName;
                    RtlInitUnicodeString(&HiveName, (PCWSTR)Hive->BaseBlock->FileName);
                    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"HvpAddBin for (%p) (%.*S) reusing FreeBin %p at FileOffset %lx; Type = %lu\n",
                        Hive,HiveName.Length / sizeof(WCHAR),HiveName.Buffer,HBIN_BASE(Me->BinAddress),((PHBIN)HBIN_BASE(Me->BinAddress))->FileOffset,(ULONG)Type));
                }
#endif
                return (PHBIN)HBIN_BASE(Me->BinAddress);
            }
            break;
        }
        Entry = Entry->Flink;
    }

    if ((Entry == &Hive->Storage[Type].FreeBins) &&
        (TotalDiscardedSize >= NewSize)) {
        //
        // No sufficiently large discarded bin was found,
        // but the total discarded space is large enough.
        // Attempt to coalesce adjacent discarded bins into
        // a larger bin and retry.
        //
        if (HvpCoalesceDiscardedBins(Hive, NewSize, Type)) {
            goto Retry;
        }
    }

    //
    // we need these sooner to do the computations in case we allocate a new bin
    //
    OldLength = Hive->Storage[Type].Length;
    CheckLength = OldLength;
    //
    //  Attempt to allocate the bin.
    //
    UseForIo = (BOOLEAN)((Type == Stable) ? TRUE : FALSE);
    if (Entry != &Hive->Storage[Type].FreeBins) {
        if( Type == Volatile ) {
            //
            // old plain method for volatile storage
            //
            //
            // Note we use ExAllocatePool directly here to avoid
            // charging quota for this bin again. When a bin
            // is discarded, its quota is not returned. This prevents
            // sparse hives from requiring more quota after
            // a reboot than on a running system.
            //
            NewBin = ExAllocatePoolWithTag((UseForIo) ? PagedPoolCacheAligned : PagedPool,
                                           NewSize,
                                           CM_HVBIN_TAG);
            if (NewBin == NULL) {
                InsertHeadList(&Hive->Storage[Type].FreeBins, Entry);
                goto ErrorExit1;
            }
            //
            // make sure we don't leak whatever is in the kernel pool out of the box (roaming).
            //
            RtlZeroMemory(NewBin,NewSize);
        } else {
            //
            // for Stable, map the view containing the bin in memory
            // and fix the map
            //

            Me = HvpGetCellMap(Hive, FreeBin->FileOffset);
            VALIDATE_CELL_MAP(__LINE__,Me,Hive,FreeBin->FileOffset);

    
            if( Me->BinAddress & HMAP_INPAGEDPOOL ) {
                ASSERT( (Me->BinAddress & HMAP_INVIEW) == 0 );
                //
                // bin is in paged pool; allocate backing store
                //
                NewBin = (Hive->Allocate)(NewSize, UseForIo,CM_FIND_LEAK_TAG15);
                if (NewBin == NULL) {
                    InsertHeadList(&Hive->Storage[Type].FreeBins, Entry);
                    goto ErrorExit1;
                }
                //
                // make sure we don't leak whatever is in the kernel pool out of the box (roaming).
                //
                RtlZeroMemory(NewBin,NewSize);
            } else {
                //
                // The view containing this bin has been unmapped; map it again
                //
                if( (Me->BinAddress & HMAP_INVIEW) == 0 ) {
                    ASSERT( (Me->BinAddress & HMAP_INPAGEDPOOL) == 0 );
                    //
                    // map the bin
                    //
                    if( !NT_SUCCESS(CmpMapThisBin((PCMHIVE)Hive,FreeBin->FileOffset,TRUE)) ) {
                        InsertHeadList(&Hive->Storage[Type].FreeBins, Entry);
                        return NULL;
                    }
                }

                ASSERT( Me->BinAddress & HMAP_INVIEW );
                NewBin = (PHBIN)HBIN_BASE(Me->BinAddress);
            }
        }
       
    } else {

        //
        // this is a totally new bin. Allocate it from paged pool
        //
        NewBin = (Hive->Allocate)(NewSize, UseForIo,CM_FIND_LEAK_TAG16);
        if (NewBin == NULL) {
            goto ErrorExit1;
        }
        //
        // make sure we don't leak whatever is in the kernel pool out of the box (roaming).
        //
        RtlZeroMemory(NewBin,NewSize);
    }

    //
    // Init the bin
    //
    NewBin->Signature = HBIN_SIGNATURE;
    NewBin->Size = NewSize;
    NewBin->Spare = 0;

    t = (PHCELL)((PUCHAR)NewBin + sizeof(HBIN));
    t->Size = NewSize - sizeof(HBIN);
    if (USE_OLD_CELL(Hive)) {
        t->u.OldCell.Last = (ULONG)HBIN_NIL;
    }

    if (Entry != &Hive->Storage[Type].FreeBins) {
        //
        // found a discarded HBIN we can use, just fill in the map and we
        // are done.
        //
        for (i=0;i<NewSize;i+=HBLOCK_SIZE) {
            Me = HvpGetCellMap(Hive, FreeBin->FileOffset+i+(Type*HCELL_TYPE_MASK));
            VALIDATE_CELL_MAP(__LINE__,Me,Hive,FreeBin->FileOffset+i+(Type*HCELL_TYPE_MASK));
            Me->BlockAddress = (ULONG_PTR)NewBin + i;
            //
            //  make sure to preserve the following flags:
            // HMAP_INVIEW|HMAP_INPAGEDPOOL
            //  and to clear the flag
            // HMAP_DISCARDABLE
            //
                        
            Me->BinAddress = (ULONG_PTR)((ULONG_PTR)NewBin | (Me->BinAddress&(HMAP_INVIEW|HMAP_INPAGEDPOOL)));
            Me->BinAddress &= ~HMAP_DISCARDABLE;
            if (i==0) {
                Me->BinAddress |= HMAP_NEWALLOC;
                Me->MemAlloc = NewSize;
            } else {
                Me->MemAlloc = 0;
            }

        }

        NewBin->FileOffset = FreeBin->FileOffset;

        (Hive->Free)(FreeBin, sizeof(FREE_HBIN));

#if DBG
        {
            UNICODE_STRING  HiveName;
            RtlInitUnicodeString(&HiveName, (PCWSTR)Hive->BaseBlock->FileName);
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"HvpAddBin for (%p) (%.*S) reusing FreeBin %p at FileOffset %lx; Type = %lu\n",
                Hive,HiveName.Length / sizeof(WCHAR),HiveName.Buffer,NewBin,NewBin->FileOffset,(ULONG)Type));
        }
#endif

        return(NewBin);
    }


    //
    // Compute map growth needed, grow the map
    //

    if( (HvpCheckViewBoundary(CheckLength,CheckLength + NewSize - 1) == FALSE) &&
        (NewSize < CM_VIEW_SIZE)    // don't bother if we attempt to allocate a cell bigger then the view size
                                    // it'll cross the boundary anyway.
        ) {
        //
        // the bin to be allocated doesn't fit into the remaining 
        // of this CM_VIEW_SIZE window. Allocate it from the next CM_VIEW_SIZE window
        // and add the remaining of this to the free bin list
        //
        CheckLength += (NewSize+HBLOCK_SIZE);
        CheckLength &= (~(CM_VIEW_SIZE - 1));
        CheckLength -= HBLOCK_SIZE;
        
#if DBG
        {
            UNICODE_STRING  HiveName;
            RtlInitUnicodeString(&HiveName, (PCWSTR)Hive->BaseBlock->FileName);
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"HvpAddBin for (%p) (%.*S) crossing boundary at %lx Size %lx, newoffset= %lx\n",Hive,HiveName.Length / sizeof(WCHAR),HiveName.Buffer,OldLength,NewSize,CheckLength));
        }
#endif
    }

    NewLength = CheckLength + NewSize;
    NewBin->FileOffset = CheckLength;

    if( CmpCanGrowSystemHive(Hive,NewLength) == FALSE ) {
        //
        // we have reached the hard quota limit on the system hive
        //
        goto ErrorExit2;
    }

    ASSERT((OldLength % HBLOCK_SIZE) == 0);
    ASSERT((CheckLength % HBLOCK_SIZE) == 0);
    ASSERT((NewLength % HBLOCK_SIZE) == 0);

    if (OldLength == 0) {
        //
        // Need to create the first table
        //
        newt = (PVOID)((Hive->Allocate)(sizeof(HMAP_TABLE), FALSE,CM_FIND_LEAK_TAG17));
        if (newt == NULL) {
            goto ErrorExit2;
        }
        RtlZeroMemory(newt, sizeof(HMAP_TABLE));
        Hive->Storage[Type].SmallDir = newt;
        Hive->Storage[Type].Map = (PHMAP_DIRECTORY)&(Hive->Storage[Type].SmallDir);
    }

    if (OldLength > 0) {
        OldMap = (OldLength-1) / HBLOCK_SIZE;
    } else {
        OldMap = 0;
    }
    NewMap = (NewLength-1) / HBLOCK_SIZE;

    OldTable = OldMap / HTABLE_SLOTS;
    NewTable = NewMap / HTABLE_SLOTS;

#if DBG
    if( Type == Stable ) {
        UNICODE_STRING  HiveName;
        RtlInitUnicodeString(&HiveName, (PCWSTR)Hive->BaseBlock->FileName);
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"HvpAddBin for (%p) (%.*S) Adding new bin %p at FileOffset %lx; Type = %lu\n",Hive,HiveName.Length / sizeof(WCHAR),HiveName.Buffer,NewBin,NewBin->FileOffset,(ULONG)Type));
    }
#endif

    if (NewTable != OldTable) {

        //
        // Need some new Tables
        //
        if (OldTable == 0) {

            //
            // We can get here even if the real directory has already been created.
            // This can happen if we create the directory then fail on something 
            // later. So we need to handle the case where a directory already exists.
            //
            if (Hive->Storage[Type].Map == (PHMAP_DIRECTORY)&Hive->Storage[Type].SmallDir) {
                ASSERT(Hive->Storage[Type].SmallDir != NULL);

                //
                // Need a real directory
                //
                Dir = (Hive->Allocate)(sizeof(HMAP_DIRECTORY), FALSE,CM_FIND_LEAK_TAG18);
                if (Dir == NULL) {
                    goto ErrorExit2;
                }
                RtlZeroMemory(Dir, sizeof(HMAP_DIRECTORY));
    
                Dir->Directory[0] = Hive->Storage[Type].SmallDir;
                Hive->Storage[Type].SmallDir = NULL;
    
                Hive->Storage[Type].Map = Dir;
            } else {
                ASSERT(Hive->Storage[Type].SmallDir == NULL);
            }

        }
        Dir = Hive->Storage[Type].Map;

        //
        // Fill in directory with new tables
        //
        if (HvpAllocateMap(Hive, Dir, OldTable+1, NewTable) ==  FALSE) {
            goto ErrorExit3;
        }
    }

    //
    // If Type == Stable, and the hive is not marked WholeHiveVolatile,
    // grow the file, the log, and the DirtyVector
    //
    if( !NT_SUCCESS(HvpAdjustHiveFreeDisplay(Hive,NewLength,Type)) ) {
        goto ErrorExit3;
    }

    Hive->Storage[Type].Length = NewLength;
    if ((Type == Stable) && (!(Hive->HiveFlags & HIVE_VOLATILE))) {

        //
        // Grow the dirtyvector
        //
        NewVector = (PULONG)(Hive->Allocate)(ROUND_UP(NewMap+1,sizeof(ULONG)), TRUE,CM_FIND_LEAK_TAG19);
        if (NewVector == NULL) {
            goto ErrorExit3;
        }

        RtlZeroMemory(NewVector, NewMap+1);

        if (Hive->DirtyVector.Buffer != NULL) {

            RtlCopyMemory(
                (PVOID)NewVector,
                (PVOID)Hive->DirtyVector.Buffer,
                OldMap+1
                );
            (Hive->Free)(Hive->DirtyVector.Buffer, Hive->DirtyAlloc);
        }

        RtlInitializeBitMap(
            &(Hive->DirtyVector),
            NewVector,
            NewLength / HSECTOR_SIZE
            );
        Hive->DirtyAlloc = ROUND_UP(NewMap+1,sizeof(ULONG));

        //
        // Grow the log
        //
        if ( ! (HvpGrowLog2(Hive, NewSize))) {
            goto ErrorExit4;
        }

        //
        // Grow the primary
        //
        if ( !  (Hive->FileSetSize)(
                    Hive,
                    HFILE_TYPE_PRIMARY,
                    NewLength+HBLOCK_SIZE,
                    OldLength+HBLOCK_SIZE
                    ) )
        {
            goto ErrorExit4;
        }

        //
        // Mark new bin dirty so all control structures get written at next sync
        //
        ASSERT( ((NewLength - OldLength) % HBLOCK_SIZE) == 0 );
        if ( ! HvMarkDirty(Hive, OldLength,NewLength - OldLength,FALSE)) {
            //
            // we have grown the hive, so the new bins are in paged pool !!!
            //
            goto ErrorExit4;
        }
    } 

    //
    // Add the remaining to the free bin list
    //
    if( CheckLength != OldLength ) {
        //
        // Allocate the bin from pagedpool (first flush will update the file image and free the memory)
        //
        RemainingBin = (Hive->Allocate)(CheckLength - OldLength, UseForIo,CM_FIND_LEAK_TAG20);
        if (RemainingBin == NULL) {
            goto ErrorExit4;
        }
        //
        // make sure we don't leak whatever is in the kernel pool out of the box (roaming).
        //
        RtlZeroMemory(RemainingBin,CheckLength - OldLength);

        RemainingBin->Signature = HBIN_SIGNATURE;
        RemainingBin->Size = CheckLength - OldLength;
        RemainingBin->FileOffset = OldLength;
        RemainingBin->Spare = 0;

        t = (PHCELL)((PUCHAR)RemainingBin + sizeof(HBIN));
        t->Size = RemainingBin->Size - sizeof(HBIN);
        if (USE_OLD_CELL(Hive)) {
            t->u.OldCell.Last = (ULONG)HBIN_NIL;
        }

        //
        // add the free bin to the free bin list and update the map.
        //
        FreeBin = (Hive->Allocate)(sizeof(FREE_HBIN), FALSE,CM_FIND_LEAK_TAG21);
        if (FreeBin == NULL) {
            goto ErrorExit5;
        }
        
        FreeBin->Size = CheckLength - OldLength;
        FreeBin->FileOffset = OldLength;
        FreeBin->Flags = FREE_HBIN_DISCARDABLE;

        InsertHeadList(&Hive->Storage[Type].FreeBins, &FreeBin->ListEntry);
        
        ASSERT_LISTENTRY(&FreeBin->ListEntry);
        ASSERT_LISTENTRY(FreeBin->ListEntry.Flink);

        for (i = OldLength; i < CheckLength; i += HBLOCK_SIZE) {
            Me = HvpGetCellMap(Hive, i + (Type*HCELL_TYPE_MASK));
            VALIDATE_CELL_MAP(__LINE__,Me,Hive,i + (Type*HCELL_TYPE_MASK));

            Me->BinAddress = (ULONG_PTR)RemainingBin | HMAP_DISCARDABLE | HMAP_INPAGEDPOOL;
            if( i == OldLength ) {
                Me->BinAddress |= HMAP_NEWALLOC;
                Me->MemAlloc = CheckLength - OldLength;
            } else {
                Me->MemAlloc = 0;
            }
            Me->BlockAddress = (ULONG_PTR)FreeBin;

            // we don't need to set it to NULL - just for debug purposes
            ASSERT( (Me->CmView = NULL) == NULL );
        }

#if DBG
        {
            if( Type == Stable ) {
                UNICODE_STRING  HiveName;
                RtlInitUnicodeString(&HiveName, (PCWSTR)Hive->BaseBlock->FileName);
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"HvpAddBin for (%p) (%.*S) adding bin starting at %lx size %lx to FreeBinList\n",Hive,HiveName.Length / sizeof(WCHAR),HiveName.Buffer,FreeBin->FileOffset,FreeBin->Size));
            }
        }
#endif
    }
    //
    // Fill in the map, mark new allocation.
    //
    j = 0;
    for (i = CheckLength; i < NewLength; i += HBLOCK_SIZE) {
        Me = HvpGetCellMap(Hive, i + (Type*HCELL_TYPE_MASK));
        VALIDATE_CELL_MAP(__LINE__,Me,Hive,i + (Type*HCELL_TYPE_MASK));
        Me->BlockAddress = (ULONG_PTR)NewBin + j;
        Me->BinAddress = (ULONG_PTR)NewBin;
        Me->BinAddress |= HMAP_INPAGEDPOOL;
        // we don't need to set it to NULL - just for debug purposes
        ASSERT( (Me->CmView = NULL) == NULL );

        if (j == 0) {
            //
            // First block of allocation, mark it.
            //
            Me->BinAddress |= HMAP_NEWALLOC;
            Me->MemAlloc = NewSize;
        } else {
            Me->MemAlloc = 0;
        }
        j += HBLOCK_SIZE;
    }

    if( Type == Stable) {
        CmpUpdateSystemHiveHysteresis(Hive,NewLength,OldLength);
    }
    return NewBin;

ErrorExit5:
    if( RemainingBin != NULL ){
        (Hive->Free)(RemainingBin, RemainingBin->Size);
    }
ErrorExit4:
    if((Type == Stable) && (!(Hive->HiveFlags & HIVE_VOLATILE))) {
        RtlInitializeBitMap(&Hive->DirtyVector,
                            NewVector,
                            OldLength / HSECTOR_SIZE);
        Hive->DirtyCount = RtlNumberOfSetBits(&Hive->DirtyVector);
    }
ErrorExit3:
    Hive->Storage[Type].Length = OldLength;
    HvpFreeMap(Hive, Dir, OldTable+1, NewTable);

ErrorExit2:
    (Hive->Free)(NewBin, NewSize);
    if( newt != NULL ) {
        (Hive->Free)(newt,sizeof(HMAP_TABLE));    
    }

ErrorExit1:
    return NULL;
}

BOOLEAN
HvpCoalesceDiscardedBins(
    IN PHHIVE Hive,
    IN ULONG NeededSize,
    IN HSTORAGE_TYPE Type
    )

/*++

Routine Description:

    Walks through the list of discarded bins and attempts to
    coalesce adjacent discarded bins into one larger bin in
    order to satisfy an allocation request.

    It doesn't coalesce bins over the CM_VIEW_SIZE boundary.

    It doesn't coalesce bins from paged pool with bins mapped in
    system cache views.

Arguments:

    Hive - Supplies pointer to hive control block.

    NeededSize - Supplies size of allocation needed.

    Type - Stable or Volatile

Return Value:

    TRUE - A bin of the desired size was created.

    FALSE - No bin of the desired size could be created.

--*/

{
    PLIST_ENTRY List;
    PFREE_HBIN FreeBin;
    PFREE_HBIN PreviousFreeBin;
    PFREE_HBIN NextFreeBin;
    PHMAP_ENTRY Map;
    PHMAP_ENTRY PreviousMap;
    PHMAP_ENTRY NextMap;
    ULONG MapBlock;

    ASSERT_HIVE_WRITER_LOCK_OWNED((PCMHIVE)Hive);

    List = Hive->Storage[Type].FreeBins.Flink;

    while (List != &Hive->Storage[Type].FreeBins) {
        FreeBin = CONTAINING_RECORD(List, FREE_HBIN, ListEntry);

        if ((FreeBin->Flags & FREE_HBIN_DISCARDABLE)==0) {

            Map = HvpGetCellMap(Hive, FreeBin->FileOffset);
            VALIDATE_CELL_MAP(__LINE__,Map,Hive,FreeBin->FileOffset);

            //
            // Scan backwards, coalescing previous discarded bins
            //
            while (FreeBin->FileOffset > 0) {
                PreviousMap = HvpGetCellMap(Hive, FreeBin->FileOffset - HBLOCK_SIZE);
                VALIDATE_CELL_MAP(__LINE__,PreviousMap,Hive,FreeBin->FileOffset - HBLOCK_SIZE);
                if( (BIN_MAP_ALLOCATION_TYPE(Map) != BIN_MAP_ALLOCATION_TYPE(PreviousMap)) || // different allocation type
                    ((PreviousMap->BinAddress & HMAP_DISCARDABLE) == 0) // previous bin is not discardable
                    ){
                    break;
                }
                
                PreviousFreeBin = (PFREE_HBIN)PreviousMap->BlockAddress;

                if (PreviousFreeBin->Flags & FREE_HBIN_DISCARDABLE) {
                    //
                    // this bin has not yet been discarded; can't coalesce with it.
                    //
                    break;
                }
                
                if( HvpCheckViewBoundary(PreviousFreeBin->FileOffset,PreviousFreeBin->FileOffset + PreviousFreeBin->Size + FreeBin->Size - 1) == FALSE ) {
                    //
                    // don't coalesce bins over the CM_VIEW_SIZE boundary
                    //
                    // substract 1 because addresses are from 0 to size - 1 !!!
                    //
                    break;
                }

                
                RemoveEntryList(&PreviousFreeBin->ListEntry);

                //
                // Fill in all the old map entries with the new one.
                //
                for (MapBlock = 0; MapBlock < PreviousFreeBin->Size; MapBlock += HBLOCK_SIZE) {
                    PreviousMap = HvpGetCellMap(Hive, PreviousFreeBin->FileOffset + MapBlock);
                    VALIDATE_CELL_MAP(__LINE__,PreviousMap,Hive,PreviousFreeBin->FileOffset + MapBlock);
                    PreviousMap->BlockAddress = (ULONG_PTR)FreeBin;
                }

                FreeBin->FileOffset = PreviousFreeBin->FileOffset;
                FreeBin->Size += PreviousFreeBin->Size;
                (Hive->Free)(PreviousFreeBin, sizeof(FREE_HBIN));
            }

            //
            // Scan forwards, coalescing subsequent discarded bins
            //
            while ((FreeBin->FileOffset + FreeBin->Size) < Hive->Storage[Type].Length) {
                NextMap = HvpGetCellMap(Hive, FreeBin->FileOffset + FreeBin->Size);
                VALIDATE_CELL_MAP(__LINE__,NextMap,Hive,FreeBin->FileOffset + FreeBin->Size);
                if( (BIN_MAP_ALLOCATION_TYPE(Map) != BIN_MAP_ALLOCATION_TYPE(NextMap)) || // different allocation type
                    ((NextMap->BinAddress & HMAP_DISCARDABLE) == 0) // previous bin is not discardable
                    ){
                    break;
                }
                NextFreeBin = (PFREE_HBIN)NextMap->BlockAddress;

                if (NextFreeBin->Flags & FREE_HBIN_DISCARDABLE) {
                    //
                    // this bin has not yet been discarded; can't coalesce with it.
                    //
                    break;
                }

                if( HvpCheckViewBoundary(FreeBin->FileOffset,FreeBin->FileOffset + FreeBin->Size + NextFreeBin->Size - 1) == FALSE ) {
                    //
                    // don't coalesce bins over the CM_VIEW_SIZE boundary
                    //
                    // substract 1 because addresses are from 0 to size - 1 !!!
                    //
                    break;
                }
                RemoveEntryList(&NextFreeBin->ListEntry);

                //
                // Fill in all the old map entries with the new one.
                //
                for (MapBlock = 0; MapBlock < NextFreeBin->Size; MapBlock += HBLOCK_SIZE) {
                    NextMap = HvpGetCellMap(Hive, NextFreeBin->FileOffset + MapBlock);
                    VALIDATE_CELL_MAP(__LINE__,NextMap,Hive,NextFreeBin->FileOffset + MapBlock);
                    NextMap->BlockAddress = (ULONG_PTR)FreeBin;
                }

                FreeBin->Size += NextFreeBin->Size;
                (Hive->Free)(NextFreeBin, sizeof(FREE_HBIN));
            }
            if (FreeBin->Size >= NeededSize) {
                return(TRUE);
            }
        }
        List=List->Flink;
    }
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\hivechek.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    hivechek.c

Abstract:

    This module implements consistency checking for hives.

--*/

#include    "cmp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HvCheckHive)
#pragma alloc_text(PAGE,HvCheckBin)
#endif

//
// debug structures
//
extern struct {
    PHHIVE      Hive;
    ULONG       Status;
    ULONG       Space;
    HCELL_INDEX MapPoint;
    PHBIN       BinPoint;
} HvCheckHiveDebug;

extern struct {
    PHBIN       Bin;
    ULONG       Status;
    PHCELL      CellPoint;
} HvCheckBinDebug;


#if DBG
ULONG HvHiveChecking=0;
#endif

ULONG
HvCheckHive(
    PHHIVE  Hive,
    PULONG  Storage OPTIONAL
    )
/*++

Routine Description:

    Check the consistency of a hive.  Apply CheckBin to bins, make sure
    all pointers in the cell map point to correct places.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest.

    Storage - supplies adddress of ULONG to receive size of allocated user data

Return Value:

    0 if Hive is OK.  Error return indicator if not.  Error value
    comes from one of the check procedures.

    RANGE:  2000 - 2999

--*/
{
    HCELL_INDEX p;
    ULONG       Length;
    ULONG       localstorage = 0;
    PHMAP_ENTRY t;
    PHBIN       Bin = NULL;
    ULONG   i;
    ULONG   rc;
    PFREE_HBIN  FreeBin;

    HvCheckHiveDebug.Hive = Hive;
    HvCheckHiveDebug.Status = 0;
    HvCheckHiveDebug.Space = (ULONG)-1;
    HvCheckHiveDebug.MapPoint = HCELL_NIL;
    HvCheckHiveDebug.BinPoint = 0;

    p = 0;

    //
    // we need to make sure all the cell's data is faulted in inside a 
    // try/except block, as the IO to fault the data in can throw exceptions
    // STATUS_INSUFFICIENT_RESOURCES, in particular
    //

    try {
        //
        // one pass for Stable space, one pass for Volatile
        //
        for (i = 0; i <= Volatile; i++) {
            Length = Hive->Storage[i].Length;

            //
            // for each bin in the space
            //
            while (p < Length) {
                t = HvpGetCellMap(Hive, p);
                if (t == NULL) {
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvCheckHive:"));
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tBin@:%p invalid\n", Bin));
                    HvCheckHiveDebug.Status = 2005;
                    HvCheckHiveDebug.Space = i;
                    HvCheckHiveDebug.MapPoint = p;
                    return 2005;
                }

            
                if( (t->BinAddress & (HMAP_INPAGEDPOOL|HMAP_INVIEW)) == 0) {
                    //
                    // view is not mapped, neither in paged pool
                    // try to map it.
                    //
                
                    // volatile info is always in paged pool
                    ASSERT( i == Stable );

                    if( !NT_SUCCESS(CmpMapThisBin((PCMHIVE)Hive,p,FALSE)) ) {
                        //
                        // we cannot map this bin due to insufficient resources. 
                        //
                        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvCheckHive:"));
                        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tinsufficient resources while mapping Bin@:%p\n", Bin));
                        HvCheckHiveDebug.Status = 2006;
                        HvCheckHiveDebug.Space = i;
                        HvCheckHiveDebug.MapPoint = p;
                        return 2010;
                    }
                }

                if ((t->BinAddress & HMAP_DISCARDABLE) == 0) {

                    Bin = (PHBIN)HBIN_BASE(t->BinAddress);

                    //
                    // bin header valid?
                    //
                    if ( (Bin->Size > Length)                           ||
                         (Bin->Signature != HBIN_SIGNATURE)             ||
                         (Bin->FileOffset != p)
                       )
                    {
                        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvCheckHive:"));
                        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tBin@:%p invalid\n", Bin));
                        HvCheckHiveDebug.Status = 2010;
                        HvCheckHiveDebug.Space = i;
                        HvCheckHiveDebug.MapPoint = p;
                        HvCheckHiveDebug.BinPoint = Bin;
                        return 2010;
                    }

                    //
                    // structure inside the bin valid?
                    //
                    rc = HvCheckBin(Hive, Bin, &localstorage);
                    if (rc != 0) {
                        HvCheckHiveDebug.Status = rc;
                        HvCheckHiveDebug.Space = i;
                        HvCheckHiveDebug.MapPoint = p;
                        HvCheckHiveDebug.BinPoint = Bin;
                        return rc;
                    }

                    p = (ULONG)p + Bin->Size;

                } else {
                    //
                    // Bin is not present, skip it and advance to the next one.
                    //
                    FreeBin = (PFREE_HBIN)t->BlockAddress;
                    p+=FreeBin->Size;
                }
            }

            p = 0x80000000;     // Beginning of Volatile space
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        HvCheckHiveDebug.Status = 2015;
        HvCheckHiveDebug.Space = GetExceptionCode();
        return HvCheckHiveDebug.Status;
    }

    if (ARGUMENT_PRESENT(Storage)) {
        *Storage = localstorage;
    }
    return 0;
}


ULONG
HvCheckBin(
    PHHIVE  Hive,
    PHBIN   Bin,
    PULONG  Storage
    )
/*++

Routine Description:

    Step through all of the cells in the bin.  Make sure that
    they are consistent with each other, and with the bin header.

Arguments:

    Hive - pointer to the hive control structure

    Bin - pointer to bin to check

    Storage - pointer to a ulong to get allocated user data size

Return Value:

    0 if Bin is OK.  Number of test in procedure that failed if not.

    RANGE:  1 - 1999

--*/
{
    PHCELL  p;
    PHCELL  np;
    PHCELL  lp;
    ULONG   freespace = 0L;
    ULONG   allocated = 0L;
    ULONG   userallocated = 0L;

    HvCheckBinDebug.Bin = Bin;
    HvCheckBinDebug.Status = 0;
    HvCheckBinDebug.CellPoint = 0;

    //
    // Scan all the cells in the bin, total free and allocated, check
    // for impossible pointers.
    //
    p = (PHCELL)((PUCHAR)Bin + sizeof(HBIN));
    lp = p;

    // The way allocated and freespace are computed implies the following invariants:
    // 1. allocated + freespace = p + p->Size - (Bin + sizeof(HBIN)). This is because p->Size is added either to allocated or to freespace.
    //    So, assuming that allocated > Bin->Size , then
    //              ==> p + p->Size - (Bin + sizeof(HBIN)) > Bin->Size.
    //              ==> p + p->Size > Bin + Bin->Size + sizeof(HBIN)
    //              ==> p + p->Size > Bin + Bin->Size
    //      This proves that the test "NeverFail 1" (see below) will never fail, because when something is wrong, the test above it (namely "Fail 1") will fail 
    //      and the function will exit.
    //
    //    The same logic applies to the test "NeverFail 2", so it can be removed also.
    //
    // 2. The new value of p is always calculated as p = p + p->Size. By the time this is done, the new value of p (ie. p + p->Size) is already checked against 
    //      Bin + Bin->Size (see tests "Fail 1" and "Fail 2"). So, if p > Bin + Bin->Size, either "Fail 1" or "Fail 2" will fail before assigning the new bogus value 
    //      to p. Therefore, the only possible path to exit the while loop (except a return 20 or return 40), is when p == Bin + Bin->Size.
    //      ==> test "NeverFail 3" can be removed as it will never fail !
    //
    // 3. Considering 1 (where p + p->Size became p) 
    //              ==> allocated + freespace =  p - (Bin + sizeof(HBIN))
    //    But, Considering 2 (above), when the while loop exits, p = Bin + Bin->Size
    //              ==> allocated + freespace = Bin + Bin->Size - (Bin + sizeof(HBIN))
    //              ==> allocated + freespace + sizeof(HBIN) = Bin->Size
    //       This proves that test "NeverFail 4" (see below) will never fail as the expression tested is always true (if the flow of execution reaches the test point).
    //

    while (p < (PHCELL)((PUCHAR)Bin + Bin->Size)) {

        //
        // Check last pointer
        //
        if (USE_OLD_CELL(Hive)) {
            if (lp == p) {
                if (p->u.OldCell.Last != HBIN_NIL) {
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvCheckBin 20: First cell has wrong last pointer\n"));
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Bin = %p\n", Bin));
                    HvCheckBinDebug.Status = 20;
                    HvCheckBinDebug.CellPoint = p;
                    return 20;
                }
            } else {
                if ((PHCELL)(p->u.OldCell.Last + (PUCHAR)Bin) != lp) {
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvCheckBin 30: incorrect last pointer\n"));
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Bin = %p\n", Bin));
                    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"p = %p\n", (ULONG_PTR)p));
                    HvCheckBinDebug.Status = 30;
                    HvCheckBinDebug.CellPoint = p;
                    return 30;
                }
            }
        }

        
        //
        // Check size
        //
        if (p->Size < 0) {

            //
            // allocated cell
            //

            // Fail 1
            // This test will always fail prior to the failure of the below test
            //
            if ( ((ULONG)(p->Size * -1) > Bin->Size)        ||
#pragma prefast(suppress:12004, "no overflow.")
                 ( (PHCELL)((p->Size * -1) + (PUCHAR)p) >
                   (PHCELL)((PUCHAR)Bin + Bin->Size) )
               )
            {
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvCheckBin 40: impossible allocation\n"));
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Bin = %p\n", Bin));
                HvCheckBinDebug.Status = 40;
                HvCheckBinDebug.CellPoint = p;
                return 40;
            }
    
            allocated += (p->Size * -1);
            if (USE_OLD_CELL(Hive)) {
                userallocated += (p->Size * -1) - FIELD_OFFSET(HCELL, u.OldCell.u.UserData);
            } else {
                userallocated += (p->Size * -1) - FIELD_OFFSET(HCELL, u.NewCell.u.UserData);
            }

            np = (PHCELL)((PUCHAR)p + (p->Size * -1));

        } else {

            //
            // free cell
            //

            // Fail 2
            // This test will always fail prior to the failure of the below test
            //
            if ( ((ULONG)p->Size > Bin->Size)               ||
                 ( (PHCELL)(p->Size + (PUCHAR)p) >
                   (PHCELL)((PUCHAR)Bin + Bin->Size) ) ||
                 (p->Size == 0) )
            {
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvCheckBin 60: impossible free block\n"));
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Bin = %p\n", Bin));
                HvCheckBinDebug.Status = 60;
                HvCheckBinDebug.CellPoint = p;
                return 60;
            }
    
            freespace = freespace + p->Size;
            np = (PHCELL)((PUCHAR)p + p->Size);
        }

        lp = p;
        p = np;
    }

    if (ARGUMENT_PRESENT(Storage)) {
        *Storage += userallocated;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\hivecell.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    hivecell.c

Abstract:

    This module implements hive cell procedures.

Revision History:
    Requests for cells bigger than 1K are doubled. This way 
    we avoid fragmentation and we make the value-growing 
    process more flexible.

    At boot time, order the free cells list ascending.

--*/

#include    "cmp.h"

//
// Private procedures
//
HCELL_INDEX
HvpDoAllocateCell(
    PHHIVE          Hive,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type,
    HCELL_INDEX     Vicinity
    );


BOOLEAN
HvpIsFreeNeighbor(
    PHHIVE  Hive,
    PHBIN   Bin,
    PHCELL  FreeCell,
    PHCELL  *FreeNeighbor,
    HSTORAGE_TYPE Type
    );

VOID
HvpDelistBinFreeCells(
    PHHIVE  Hive,
    PHBIN   Bin,
    HSTORAGE_TYPE Type
    );

#define SIXTEEN_K   0x4000

//  Double requests bigger  than 1KB                       
//  CmpSetValueKeyExisting  always allocates a bigger data 
//  value cell  exactly the required size. This creates    
//  problems when somebody  slowly grows a value one DWORD 
//  at a time to  some enormous size. An easy fix for this 
//  would be to set a  certain threshold (like 1K). Once a 
//  value size  crosses that threshold, allocate a new cell
//  that is twice  the old size. So the actual allocated   
//  size  would grow to 1k, then 2k, 4k, 8k, 16k, 32k,etc. 
//  This will reduce the fragmentation.                    
//
// Note:
//  For 5.1, this needs to be coherent with CM_KEY_VALUE_BIG
// 
//


#define HvpAdjustCellSize(Size)                                         \
    {                                                                   \
        ULONG   onek = SIXTEEN_K;                                       \
        ULONG   Limit = 0;                                              \
                                                                        \
        while( Size > onek ) {                                          \
            onek<<=1;                                                   \
            Limit++;                                                    \
        }                                                               \
                                                                        \
        Size = Limit?onek:Size;                                         \
    }   

extern  BOOLEAN HvShutdownComplete;     // Set to true after shutdown
                                        // to disable any further I/O


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HvpGetHCell)
#pragma alloc_text(PAGE,HvpGetCellMapped)
#pragma alloc_text(PAGE,HvpReleaseCellMapped)
#pragma alloc_text(PAGE,HvpGetCellPaged)
#pragma alloc_text(PAGE,HvpGetCellFlat)
#pragma alloc_text(PAGE,HvpGetCellMap)
#pragma alloc_text(PAGE,HvGetCellSize)
#pragma alloc_text(PAGE,HvAllocateCell)
#pragma alloc_text(PAGE,HvpDoAllocateCell)
#pragma alloc_text(PAGE,HvFreeCell)
#pragma alloc_text(PAGE,HvpIsFreeNeighbor)
#pragma alloc_text(PAGE,HvpEnlistFreeCell)
#pragma alloc_text(PAGE,HvpDelistFreeCell)
#pragma alloc_text(PAGE,HvReallocateCell)
#pragma alloc_text(PAGE,HvIsCellAllocated)
#pragma alloc_text(PAGE,HvpDelistBinFreeCells)
#pragma alloc_text(PAGE,HvDuplicateCell)
#pragma alloc_text(PAGE,HvAutoCompressCheck)
#pragma alloc_text(PAGE,HvShiftCell)

#pragma alloc_text(PAGE,HvReleaseFreeCellRefArray)
#pragma alloc_text(PAGE,HvTrackCellRef)

#endif

PHCELL
HvpGetHCell(PHHIVE      Hive,
            HCELL_INDEX Cell
            )
/*++

Routine Description:

    Had to make it a function instead of a macro, because HvGetCell
    might fail now.

Arguments:

Return Value:

--*/
{                                                   
    PCELL_DATA pcell;                               
    pcell = HvGetCell(Hive,Cell);                   
    if( pcell == NULL ) {
        //
        // we couldn't map view for this cell
        //
        return NULL;
    }

    return 
        ( USE_OLD_CELL(Hive) ?                      
          CONTAINING_RECORD(pcell,                  
                            HCELL,                  
                            u.OldCell.u.UserData) : 
          CONTAINING_RECORD(pcell,                  
                            HCELL,                  
                            u.NewCell.u.UserData)); 
}

//
//  Cell Procedures
//


VOID
HvpReleaseCellMapped(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    )
/*++

Routine Description:

    This routine should never be called directly, always call it
    via the HvReleaseCell() macro.
    
    This routine is intended to work with mapped hives. It is intended
    to prevent views that are still in use to get unmapped

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - supplies HCELL_INDEX of cell to return address for

Return Value:
    
      none

--*/
{
    ULONG           Type;
    ULONG           Table;
    ULONG           Block;
    ULONG           Offset;
    PHMAP_ENTRY     Map;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"HvpReleaseCellMapped:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"\tHive=%p Cell=%08lx\n",Hive,Cell));
    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Cell != HCELL_NIL);
    ASSERT(Hive->Flat == FALSE);
    ASSERT((Cell & (HCELL_PAD(Hive)-1))==0);
    ASSERT_CM_LOCK_OWNED_OR_HIVE_LOADING(Hive);
    #if DBG
        if (HvGetCellType(Cell) == Stable) {
            ASSERT(Cell >= sizeof(HBIN));
        } else {
            ASSERT(Cell >= (HCELL_TYPE_MASK + sizeof(HBIN)));
        }
    #endif

    if( HvShutdownComplete == TRUE ) {
        //
        // at shutdown we need to unmap all views
        //
#if DBG
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpReleaseCellMapped called after shutdown for Hive = %p Cell = %lx\n",Hive,(ULONG)Cell));
#endif
        return;
    }

    Type = HvGetCellType(Cell);
    Table = (Cell & HCELL_TABLE_MASK) >> HCELL_TABLE_SHIFT;
    Block = (Cell & HCELL_BLOCK_MASK) >> HCELL_BLOCK_SHIFT;
    Offset = (Cell & HCELL_OFFSET_MASK);

    ASSERT((Cell - (Type * HCELL_TYPE_MASK)) < Hive->Storage[Type].Length);

    // lock hive views before extracting data
    CmLockHiveViews ((PCMHIVE)Hive);
    Map = &((Hive->Storage[Type].Map)->Directory[Table]->Table[Block]);

    if( Map->BinAddress & HMAP_INVIEW ) {
        PCM_VIEW_OF_FILE CmView;
        CmView = Map->CmView;
        ASSERT( CmView != NULL );
        ASSERT( CmView->ViewAddress != NULL );
        ASSERT( CmView->UseCount != 0 );

        ASSERT( CmView->UseCount != 0 );

        CmView->UseCount--;
    } else {
        //
        // Bin is in memory (allocated from paged pool) ==> do nothing
        // 
        ASSERT( Map->BinAddress & HMAP_INPAGEDPOOL );
    }

    ASSERT( ((PCMHIVE)Hive)->UseCount != 0 );

    ((PCMHIVE)Hive)->UseCount--;
    CmLogCellDeRef(Hive,Cell);

    CmUnlockHiveViews ((PCMHIVE)Hive);
    
    ASSERT( HBIN_BASE(Map->BinAddress) != 0);
}


struct _CELL_DATA *
HvpGetCellMapped(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    )
/*++

Routine Description:

    This routine should never be called directly, always call it
    via the HvGetCell() macro.
    
    This routine is intended to work with mapped hives.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - supplies HCELL_INDEX of cell to return address for

Return Value:

    Address of Cell in memory.  Assert or BugCheck if error.

--*/
{
    ULONG           Type;
    ULONG           Table;
    ULONG           Block;
    ULONG           Offset;
    PHCELL          pcell;
    PHMAP_ENTRY     Map;
    LONG            Size;
    PUCHAR          FaultAddress;
    PUCHAR          EndOfCell;
    UCHAR           TmpChar;
    PHBIN           Bin;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"HvGetCellPaged:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"\tHive=%p Cell=%08lx\n",Hive,Cell));
    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Cell != HCELL_NIL);
    ASSERT(Hive->Flat == FALSE);
    ASSERT((Cell & (HCELL_PAD(Hive)-1))==0);
    ASSERT_CM_LOCK_OWNED_OR_HIVE_LOADING(Hive);

    if( HvShutdownComplete == TRUE ) {
        //
        // at shutdown we need to unmap all views
        //
#if DBG
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpGetCellMapped called after shutdown for Hive = %p Cell = %lx\n",Hive,(ULONG)Cell));
#endif
        return NULL;
    }

    Type = HvGetCellType(Cell);
    Table = (Cell & HCELL_TABLE_MASK) >> HCELL_TABLE_SHIFT;
    Block = (Cell & HCELL_BLOCK_MASK) >> HCELL_BLOCK_SHIFT;
    Offset = (Cell & HCELL_OFFSET_MASK);

    ASSERT((Cell - (Type * HCELL_TYPE_MASK)) < Hive->Storage[Type].Length);

    CmLockHiveViews ((PCMHIVE)Hive);

    Map = &((Hive->Storage[Type].Map)->Directory[Table]->Table[Block]);

    if( Map->BinAddress & HMAP_INPAGEDPOOL ) {
        //
        // Bin is in memory (allocated from paged pool) ==> do nothing
        // 
    } else {
        PCM_VIEW_OF_FILE CmView;
        //
        // bin is either mapped, or invalid
        //
        ASSERT( Type == Stable );

        if( (Map->BinAddress & HMAP_INVIEW) == 0 ) {
            //
            // map the bin
            //
            if( !NT_SUCCESS (CmpMapCmView((PCMHIVE)Hive,Cell/*+HBLOCK_SIZE*/,&CmView,TRUE) ) ) {
                //
                // caller of HvGetCell should raise an STATUS_INSUFFICIENT_RESOURCES 
                // error as a result of this.!!!!
                //
                CmUnlockHiveViews ((PCMHIVE)Hive);
                return NULL;
            }
            
#if DBG
            if(CmView != Map->CmView) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmView = %p Map->CmView = %p\n",CmView,Map->CmView));
            }
#endif

            ASSERT( CmView == Map->CmView );
        } else {
            CmView = Map->CmView;
        }
        
        //
        // touch the view
        //
        CmpTouchView((PCMHIVE)Hive,CmView,(ULONG)Cell);
        //
        // don't hurt ourselves if not necessary
        //
        if(Hive->ReleaseCellRoutine) CmView->UseCount++;
    }

    //
    // don't hurt ourselves if not necessary
    //
    if(Hive->ReleaseCellRoutine) {
        ((PCMHIVE)Hive)->UseCount++;
        CmLogCellRef(Hive,Cell);
    }
    CmUnlockHiveViews ((PCMHIVE)Hive);
    
    ASSERT( HBIN_BASE(Map->BinAddress) != 0);
    ASSERT((Map->BinAddress & HMAP_DISCARDABLE) == 0);

    pcell = (PHCELL)((ULONG_PTR)(Map->BlockAddress) + Offset);

    PERFINFO_HIVECELL_REFERENCE_PAGED(Hive, pcell, Cell, Type, Map);

    //
    // we need to make sure all the cell's data is faulted in inside a 
    // try/except block, as the IO to fault the data in can throw exceptions
    // STATUS_INSUFFICIENT_RESOURCES, in particular
    //

    try {
        //
        // this will fault in the first page containing the data
        //
        Size = pcell->Size;
        if( Size < 0 ) {
            Size *= -1;
        }
        //
        // check for bogus size
        //
        Bin = (PHBIN)HBIN_BASE(Map->BinAddress);
        if ( (Offset + (ULONG)Size) > Bin->Size ) {
            //
            // runs off bin; disallow access to this cell
            //
            //
            // restore the usecounts
            //
            CmLockHiveViews ((PCMHIVE)Hive);
            if( (Map->BinAddress & HMAP_INPAGEDPOOL) == 0 ) {
                ASSERT( Map->CmView != NULL );
                if(Hive->ReleaseCellRoutine) Map->CmView->UseCount--;
            }
            if(Hive->ReleaseCellRoutine) {
                ((PCMHIVE)Hive)->UseCount--;
                CmLogCellDeRef(Hive,Cell);
            }
            CmUnlockHiveViews ((PCMHIVE)Hive);

            return NULL;

        }

        //
        // Now stand here like a man and fault in all pages storing cell's data
        //
#pragma prefast(suppress:12008, "no overflow.")
        EndOfCell = (PUCHAR)((PUCHAR)pcell + Size);
        FaultAddress = (PUCHAR)((PUCHAR)(Map->BlockAddress) + ROUND_UP(Offset,PAGE_SIZE)); 

        while( FaultAddress < EndOfCell ) {
            TmpChar = *FaultAddress;
            FaultAddress += PAGE_SIZE;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpGetCellMapped: exception thrown while faulting in data, code:%08lx\n", GetExceptionCode()));

        //
        // restore the usecounts
        //
        CmLockHiveViews ((PCMHIVE)Hive);
        if( (Map->BinAddress & HMAP_INPAGEDPOOL) == 0 ) {
            ASSERT( Map->CmView != NULL );
            if(Hive->ReleaseCellRoutine) Map->CmView->UseCount--;
        }
        if(Hive->ReleaseCellRoutine) {
            ((PCMHIVE)Hive)->UseCount--;
            CmLogCellDeRef(Hive,Cell);
        }
        CmUnlockHiveViews ((PCMHIVE)Hive);

        return NULL;
    }

    if (USE_OLD_CELL(Hive)) {
        return (struct _CELL_DATA *)&(pcell->u.OldCell.u.UserData);
    } else {
        return (struct _CELL_DATA *)&(pcell->u.NewCell.u.UserData);
    }
}

struct _CELL_DATA *
HvpGetCellPaged(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    )
/*++

Routine Description:

    Returns the memory address for the specified Cell.  Will never
    return failure, but may assert.  Use HvIsCellAllocated to check
    validity of Cell.

    This routine should never be called directly, always call it
    via the HvGetCell() macro.

    This routine provides GetCell support for hives with full maps.
    It is the normal version of the routine.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - supplies HCELL_INDEX of cell to return address for

Return Value:

    Address of Cell in memory.  Assert or BugCheck if error.

--*/
{
    ULONG           Type;
    ULONG           Table;
    ULONG           Block;
    ULONG           Offset;
    PHCELL          pcell;
    PHMAP_ENTRY     Map;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"HvGetCellPaged:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"\tHive=%p Cell=%08lx\n",Hive,Cell));
    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Cell != HCELL_NIL);
    ASSERT(Hive->Flat == FALSE);
    ASSERT((Cell & (HCELL_PAD(Hive)-1))==0);
    ASSERT_CM_LOCK_OWNED_OR_HIVE_LOADING(Hive);
    #if DBG
        if (HvGetCellType(Cell) == Stable) {
            ASSERT(Cell >= sizeof(HBIN));
        } else {
            ASSERT(Cell >= (HCELL_TYPE_MASK + sizeof(HBIN)));
        }
    #endif

    if( HvShutdownComplete == TRUE ) {
        //
        // at shutdown we need to unmap all views
        //
#if DBG
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpGetCellPaged called after shutdown for Hive = %p Cell = %lx\n",Hive,(ULONG)Cell));
#endif
        return NULL;
    }

    Type = HvGetCellType(Cell);
    Table = (Cell & HCELL_TABLE_MASK) >> HCELL_TABLE_SHIFT;
    Block = (Cell & HCELL_BLOCK_MASK) >> HCELL_BLOCK_SHIFT;
    Offset = (Cell & HCELL_OFFSET_MASK);

    ASSERT((Cell - (Type * HCELL_TYPE_MASK)) < Hive->Storage[Type].Length);

    Map = &((Hive->Storage[Type].Map)->Directory[Table]->Table[Block]);
    //
    // it is ilegal to call this routine for mapped hives
    //
    ASSERT( Map->BinAddress & HMAP_INPAGEDPOOL );

    ASSERT( HBIN_BASE(Map->BinAddress) != 0);
    ASSERT((Map->BinAddress & HMAP_DISCARDABLE) == 0);

    pcell = (PHCELL)((ULONG_PTR)(Map->BlockAddress) + Offset);

    PERFINFO_HIVECELL_REFERENCE_PAGED(Hive, pcell, Cell, Type, Map);

    if (USE_OLD_CELL(Hive)) {
        return (struct _CELL_DATA *)&(pcell->u.OldCell.u.UserData);
    } else {
        return (struct _CELL_DATA *)&(pcell->u.NewCell.u.UserData);
    }
}

VOID
HvpEnlistFreeCell(
    PHHIVE          Hive,
    HCELL_INDEX     Cell,
    ULONG           Size,
    HSTORAGE_TYPE   Type,
    BOOLEAN         CoalesceForward
    )
/*++

Routine Description:

    Puts the newly freed cell on the appropriate list.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - supplies index of cell to enlist

    Size - size of cell

    Type - indicates whether Stable or Volatile storage is desired.

    CoalesceForward - indicates whether we can coalesce forward or not.
        For the case where we have not finished scanning the hive and
        enlisting free cells, we do not want to coalesce forward.

Return Value:

    NONE.

--*/
{
    PHMAP_ENTRY Map;
    PHCELL      pcell;
    PHCELL      FirstCell;
    ULONG       Index;
    PHBIN       Bin;
    HCELL_INDEX FreeCell;
    PFREE_HBIN  FreeBin;
    PHBIN       FirstBin;
    PHBIN       LastBin;
    ULONG       FreeOffset;

    HvpComputeIndex(Index, Size);

    ASSERT_HIVE_WRITER_LOCK_OWNED((PCMHIVE)Hive);
    ASSERT_HIVE_FLUSHER_LOCKED((PCMHIVE)Hive);
    
    //
    // the HvpGetHCell call below touches the view containing the cell, 
    // and makes sure the CM_VIEW_SIZE window is mapped in the system cache
    //
    pcell = HvpGetHCell(Hive, Cell);
    if( pcell == NULL ) {
        //
        // we couldn't map view for this cell
        // this shouldn't happen as the cell here is already marked dirty
        // or it's entire bin is mapped 
        //
        ASSERT( FALSE);
        return;
    }

  
    ASSERT(pcell->Size > 0);
    ASSERT(Size == (ULONG)pcell->Size);


    //
    // Check to see if this is the first cell in the bin and if the entire
    // bin consists just of this cell.
    //

    Map = HvpGetCellMap(Hive, Cell);
    VALIDATE_CELL_MAP(__LINE__,Map,Hive,Cell);
    ASSERT_BIN_VALID(Map);

    Bin = (PHBIN)HBIN_BASE(Map->BinAddress);
    if ((pcell == (PHCELL)(Bin + 1)) &&
        (Size == Bin->Size-sizeof(HBIN))) {

        //
        // We have a bin that is entirely free.  But we cannot do anything with it
        // unless the memalloc that contains the bin is entirely free.  Walk the
        // bins backwards until we find the first one in the alloc, then walk forwards
        // until we find the last one.  If any of the other bins in the memalloc
        // are not free, bail out.
        //
        FirstBin = Bin;
        while ( HvpGetBinMemAlloc(Hive,FirstBin,Type) == 0) {
            Map=HvpGetCellMap(Hive,(FirstBin->FileOffset - HBLOCK_SIZE) +
                                   (Type * HCELL_TYPE_MASK));
            VALIDATE_CELL_MAP(__LINE__,Map,Hive,(FirstBin->FileOffset - HBLOCK_SIZE) +(Type * HCELL_TYPE_MASK));
            ASSERT_BIN_VALID(Map);
            FirstBin = (PHBIN)HBIN_BASE(Map->BinAddress);
            FirstCell = (PHCELL)(FirstBin+1);
            if ((ULONG)(FirstCell->Size) != FirstBin->Size-sizeof(HBIN)) {
                //
                // The first cell in the bin is either allocated, or not the only
                // cell in the HBIN.  We cannot free any HBINs.
                //
                goto Done;
            }
        }

        //
        // We can never discard the first bin of a hive as that always gets marked dirty
        // and written out.
        //
        if (FirstBin->FileOffset == 0) {
            goto Done;
        }

        LastBin = Bin;
        while (LastBin->FileOffset+LastBin->Size < FirstBin->FileOffset + HvpGetBinMemAlloc(Hive,FirstBin,Type)) {
            if (!CoalesceForward) {
                //
                // We are at the end of what's been built up. Just return and this
                // will get freed up when the next HBIN is added.
                //
                goto Done;
            }
            Map = HvpGetCellMap(Hive, (LastBin->FileOffset+LastBin->Size) +
                                      (Type * HCELL_TYPE_MASK));
            VALIDATE_CELL_MAP(__LINE__,Map,Hive,(LastBin->FileOffset+LastBin->Size) + (Type * HCELL_TYPE_MASK));

            ASSERT(Map->BinAddress != 0);

            LastBin = (PHBIN)HBIN_BASE(Map->BinAddress);
            FirstCell = (PHCELL)(LastBin + 1);
            if ((ULONG)(FirstCell->Size) != LastBin->Size-sizeof(HBIN)) {
                //
                // The first cell in the bin is either allocated, or not the only
                // cell in the HBIN.  We cannot free any HBINs.
                //
                goto Done;
            }
        }

        //
        // All the bins in this alloc are freed.  Coalesce all the bins into
        // one alloc-sized bin, then either discard the bin or mark it as
        // discardable.
        //
        if (FirstBin->Size != HvpGetBinMemAlloc(Hive,FirstBin,Type)) {
            //
            // Mark the first HBLOCK of the first HBIN dirty, since
            // we will need to update the on disk field for the bin size
            //
            if (!HvMarkDirty(Hive,
                             FirstBin->FileOffset + (Type * HCELL_TYPE_MASK),
                             sizeof(HBIN) + sizeof(HCELL),FALSE)) {
                goto Done;
            }

        }


        FreeBin = (Hive->Allocate)(sizeof(FREE_HBIN), FALSE,CM_FIND_LEAK_TAG7);
        if (FreeBin == NULL) {
            goto Done;
        }

        //
        // Walk through the bins and delist each free cell
        //
        Bin = FirstBin;
        do {
            FirstCell = (PHCELL)(Bin+1);
            HvpDelistFreeCell(Hive, Bin->FileOffset + (ULONG)((PUCHAR)FirstCell - (PUCHAR)Bin) + (Type*HCELL_TYPE_MASK), Type);
            if (Bin==LastBin) {
                break;
            }
            Map = HvpGetCellMap(Hive, (Bin->FileOffset+Bin->Size)+
                                      (Type * HCELL_TYPE_MASK));
            VALIDATE_CELL_MAP(__LINE__,Map,Hive,(Bin->FileOffset+Bin->Size)+(Type * HCELL_TYPE_MASK));
            Bin = (PHBIN)HBIN_BASE(Map->BinAddress);

        } while ( TRUE );

        //
        // Coalesce them all into one bin.
        //
        FirstBin->Size = HvpGetBinMemAlloc(Hive,FirstBin,Type);

        FreeBin->Size = FirstBin->Size;
        FreeBin->FileOffset = FirstBin->FileOffset;
        FirstCell = (PHCELL)(FirstBin+1);
        FirstCell->Size = FirstBin->Size - sizeof(HBIN);
        if (USE_OLD_CELL(Hive)) {
            FirstCell->u.OldCell.Last = (ULONG)HBIN_NIL;
        }

        InsertHeadList(&Hive->Storage[Type].FreeBins, &FreeBin->ListEntry);
        ASSERT_LISTENTRY(&FreeBin->ListEntry);
        ASSERT_LISTENTRY(FreeBin->ListEntry.Flink);

        FreeCell = FirstBin->FileOffset+(Type*HCELL_TYPE_MASK);
        Map = HvpGetCellMap(Hive, FreeCell);
        VALIDATE_CELL_MAP(__LINE__,Map,Hive,FreeCell);
        if( Map->BinAddress & HMAP_INPAGEDPOOL ) {
            //
            // the bin is allocated from paged pool; 
            // mark the free bin as not discarded; paged pool will be freed when the bin is 
            // discarded
            //
            FreeBin->Flags = FREE_HBIN_DISCARDABLE;
        } else {
            //
            // bin is not allocated from paged pool; mark it as already discarded
            //
            FreeBin->Flags = 0;
        }

        FreeOffset = 0;
        while (FreeOffset < FirstBin->Size) {
            Map = HvpGetCellMap(Hive, FreeCell);
            VALIDATE_CELL_MAP(__LINE__,Map,Hive,FreeCell);
            //
            // adjust the bin address, but make sure to preserve the mapping flags
            // i.e. : if the view containing this bin is mapped into memory, add the flag
            //
            if (Map->BinAddress & HMAP_NEWALLOC) {
                Map->BinAddress = (ULONG_PTR)FirstBin | HMAP_DISCARDABLE | HMAP_NEWALLOC | BIN_MAP_ALLOCATION_TYPE(Map);
            } else {
                Map->BinAddress = (ULONG_PTR)FirstBin | HMAP_DISCARDABLE | BIN_MAP_ALLOCATION_TYPE(Map);
            }
            Map->BlockAddress = (ULONG_PTR)FreeBin;
            FreeCell += HBLOCK_SIZE;
            FreeOffset += HBLOCK_SIZE;
        }
		//
		// don't change the hints, we haven't added any free cell !!!
		//
        HvReleaseCell(Hive,Cell);
		return;
    }


Done:
    HvpAddFreeCellHint(Hive,Cell,Index,Type);
    HvReleaseCell(Hive,Cell);
    return;
}

VOID
HvpDelistFreeCell(
    PHHIVE  Hive,
    HCELL_INDEX  Cell,
    HSTORAGE_TYPE Type
    )
/*++

Routine Description:

    Updates the FreeSummary and FreeDisplay at the index corresponding to this cell

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - supplies the cell index for the free cell to delist

    Type - Stable vs. Volatile

Return Value:

    NONE.

--*/
{
    PHCELL      pcell;
    ULONG       Index;
    
    ASSERT_HIVE_WRITER_LOCK_OWNED((PCMHIVE)Hive);
    ASSERT_HIVE_FLUSHER_LOCKED((PCMHIVE)Hive);

    pcell = HvpGetHCell(Hive, Cell);
    if( pcell == NULL ) {
        //
        // we couldn't map view for this cell
        // this shouldn't happen as the cell here is already marked dirty
        // or it's entire bin is mapped 
        //
        ASSERT( FALSE);
        return;
    }

    ASSERT(pcell->Size > 0);

    HvpComputeIndex(Index, pcell->Size);

    HvpRemoveFreeCellHint(Hive,Cell,Index,Type);
   
    HvReleaseCell(Hive,Cell);
    return;
}

HCELL_INDEX
HvAllocateCell(
    PHHIVE          Hive,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type,
    HCELL_INDEX     Vicinity 
    )
/*++

Routine Description:

    Allocates the space and the cell index for a new cell.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    NewSize - size in bytes of the cell to allocate

    Type - indicates whether Stable or Volatile storage is desired.

Return Value:

    New HCELL_INDEX if success, HCELL_NIL if failure.

--*/
{
    HCELL_INDEX NewCell;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"HvAllocateCell:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"\tHive=%p NewSize=%08lx\n",Hive,NewSize));
    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Hive->ReadOnly == FALSE);

    //
    // we have the lock exclusive or nobody is operating inside this hive
    //

    //
    // Make room for overhead fields and round up to HCELL_PAD boundary
    //
    if (USE_OLD_CELL(Hive)) {
        NewSize += FIELD_OFFSET(HCELL, u.OldCell.u.UserData);
    } else {
        NewSize += FIELD_OFFSET(HCELL, u.NewCell.u.UserData);
    }
    NewSize = ROUND_UP(NewSize, HCELL_PAD(Hive));

    // 
    // Adjust the size (an easy fix for granularity)
    //
    HvpAdjustCellSize(NewSize);
    //
    // reject impossible/unreasonable values
    //
    if (NewSize > HSANE_CELL_MAX) {
        return HCELL_NIL;
    }

    //
    // Do the actual storage allocation
    //
    NewCell = HvpDoAllocateCell(Hive, NewSize, Type, Vicinity);

#if DBG
    if (NewCell != HCELL_NIL) {
        ASSERT(HvIsCellAllocated(Hive, NewCell));
    }
#endif


    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"\tNewCell=%08lx\n", NewCell));
    return NewCell;
}

HCELL_INDEX
HvpDoAllocateCell(
    PHHIVE          Hive,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type,
    HCELL_INDEX     Vicinity
    )
/*++

Routine Description:

    Allocates space in the hive.  Does not affect cell map in any way.

    If Vicinity is not NIL, it defines the "window" where the new cell
    to be allocated (if one free is found). The window is ensured by 
    looking for a free cell of the desired size:

    1st - in the same CM_VIEW_SIZE window with the Vicinity cell.

Abstract:

    This first version allocates a new bin if a cell free cell big enough 
    cannot be found in the specified window. 
    
Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    NewSize - size in bytes of the cell to allocate

    Type - indicates whether Stable or Volatile storage is desired.
    
    Vicinity - the starting cell which defines the vicinity of the new 
                allocated cell.

Return Value:

    HCELL_INDEX of new cell, HCELL_NIL if failure

--*/
{
    ULONG       Index;
    HCELL_INDEX cell;
    PHCELL      pcell;
    HCELL_INDEX tcell;
    PHCELL      ptcell;
    PHBIN       Bin;
    PHMAP_ENTRY Me;
    ULONG       offset;
    PHCELL      next;
    ULONG       MinFreeSize;


    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"HvDoAllocateCell:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"\tHive=%p NewSize=%08lx Type=%08lx\n",Hive,NewSize,Type));
    ASSERT(Hive->ReadOnly == FALSE);

    //
    // we have the lock exclusive or nobody is operating inside this hive
    //
    ASSERT_HIVE_FLUSHER_LOCKED((PCMHIVE)Hive);

    //
    // Compute Index into Display
    //
    HvpComputeIndex(Index, NewSize);

#if DBG
    {
        UNICODE_STRING  HiveName;
        RtlInitUnicodeString(&HiveName, (PCWSTR)Hive->BaseBlock->FileName);
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FREECELL,"[HvpDoAllocateCell] CellSize = %lu Vicinity = %lx :: Hive (%p) (%.*S)  ...\n",
            NewSize,Vicinity,Hive,HiveName.Length / sizeof(WCHAR),HiveName.Buffer));
    }
#endif
    // no two guys in here at the same time for the same hive
    CmpLockHiveWriter((PCMHIVE)Hive);

    cell = HvpFindFreeCell(Hive,Index,NewSize,Type,Vicinity);
    if( cell != HCELL_NIL ) {
        //
        // found it !
        //
        pcell = HvpGetHCell(Hive, cell);
        if( pcell == NULL ) {
            //
            // we couldn't map view for this cell
            // this shouldn't happen as the cell here is already marked dirty
            // or it's entire bin is mapped 
            //
            ASSERT( FALSE);
            CmpUnlockHiveWriter((PCMHIVE)Hive);
            return HCELL_NIL;
        }
        
        // we are safe to release the cell here as the view is pinned
        HvReleaseCell(Hive,cell);

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FREECELL," found cell at index = %lx size = %lu \n",cell,pcell->Size));
        goto UseIt;
    } else {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FREECELL," not found\n"));
        //
        // No suitable cells were found on any free list.
        //
        // Either there is no large enough cell, or we
        // have no free cells left at all.  In either case, allocate a
        // new bin, with a new free cell certain to be large enough in
        // it, and use that cell.
        //

        //
        // Attempt to create a new bin
        //
        if ((Bin = HvpAddBin(Hive, NewSize, Type)) != NULL) {

            //
            // It worked.  Use single large cell in Bin.
            //
            DHvCheckBin(Hive,Bin);
            cell = (Bin->FileOffset) + sizeof(HBIN) + (Type*HCELL_TYPE_MASK);
            pcell = HvpGetHCell(Hive, cell);
            if( pcell == NULL ) {
                //
                // we couldn't map view for this cell
                // this shouldn't happen as the entire bin is mapped 
                //
                ASSERT( FALSE);
                CmpUnlockHiveWriter((PCMHIVE)Hive);
                return HCELL_NIL;
            }

            // we are safe to release the cell here as the view is pinned
            HvReleaseCell(Hive,cell);

        } else {
            CmpUnlockHiveWriter((PCMHIVE)Hive);
            return HCELL_NIL;
        }
    }

UseIt:

    //
    // cell refers to a free cell we have pulled from its list
    // if it is too big, give the residue back
    // ("too big" means there is at least one HCELL of extra space)
    // always mark it allocated
    // return it as our function value
    //

    ASSERT(pcell->Size > 0);
    if (USE_OLD_CELL(Hive)) {
        MinFreeSize = FIELD_OFFSET(HCELL, u.OldCell.u.Next) + sizeof(HCELL_INDEX);
    } else {
        MinFreeSize = FIELD_OFFSET(HCELL, u.NewCell.u.Next) + sizeof(HCELL_INDEX);
    }
    if ((NewSize + MinFreeSize) <= (ULONG)pcell->Size) {

        //
        // Crack the cell, use part we need, put rest on
        // free list.
        //

        Me = HvpGetCellMap(Hive, cell);
        VALIDATE_CELL_MAP(__LINE__,Me,Hive,cell);
        //
        // at this point we are sure that the bin is in memory ??????
        //
        Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
        offset = (ULONG)((ULONG_PTR)pcell - (ULONG_PTR)Bin);

        ptcell = (PHCELL)((PUCHAR)pcell + NewSize);
        if (USE_OLD_CELL(Hive)) {
            ptcell->u.OldCell.Last = offset;
        }
        ptcell->Size = pcell->Size - NewSize;

        if ((offset + pcell->Size) < Bin->Size) {
#pragma prefast(suppress:12008, "no overflow.")
            next = (PHCELL)((PUCHAR)pcell + pcell->Size);
            if (USE_OLD_CELL(Hive)) {
                next->u.OldCell.Last = offset + NewSize;
            }
        }

        pcell->Size = NewSize;
        tcell = (HCELL_INDEX)((ULONG)cell + NewSize);

        HvpEnlistFreeCell(Hive, tcell, ptcell->Size, Type, TRUE);
    }

    //
    // return the cell we found.
    //
#if DBG
    if (USE_OLD_CELL(Hive)) {
        RtlFillMemory(
            &(pcell->u.OldCell.u.UserData),
            (pcell->Size - FIELD_OFFSET(HCELL, u.OldCell.u.UserData)),
            HCELL_ALLOCATE_FILL
            );
    } else {
        RtlFillMemory(
            &(pcell->u.NewCell.u.UserData),
            (pcell->Size - FIELD_OFFSET(HCELL, u.NewCell.u.UserData)),
            HCELL_ALLOCATE_FILL
            );
    }
#endif
    pcell->Size *= -1;

    CmpUnlockHiveWriter((PCMHIVE)Hive);
    return cell;
}


//
// Procedure used for checking only  (used in production systems, so
//  must always be here.)
//
BOOLEAN
HvIsCellAllocated(
    PHHIVE Hive,
    HCELL_INDEX Cell
    )
/*++

Routine Description:

    Report whether the requested cell is allocated or not.

Arguments:

    Hive - containing Hive.

    Cell - cel of interest

Return Value:

    TRUE if allocated, FALSE if not.

--*/
{
    ULONG   Type;
    PHCELL  Address;
    PHCELL  Below;
    PHMAP_ENTRY Me;
    PHBIN   Bin;
    ULONG   Offset;
    LONG    Size;
    BOOLEAN bRet = TRUE;


    ASSERT(Hive->Signature == HHIVE_SIGNATURE);

    if (Hive->Flat == TRUE) {
        return TRUE;
    }

    Type = HvGetCellType(Cell);

    if ( ((Cell & ~HCELL_TYPE_MASK) > Hive->Storage[Type].Length) || // off end
         (Cell % HCELL_PAD(Hive) != 0)                    // wrong alignment
       )
    {
        return FALSE;
    }

    Me = HvpGetCellMap(Hive, Cell);
    if (Me == NULL) {
        return FALSE;
    }
    if( Me->BinAddress & HMAP_DISCARDABLE ) {
        return FALSE;
    }

    //
    // this will bring the CM_VIEW_SIZE window mapping the bin in memory
    //
    Address = HvpGetHCell(Hive, Cell);
    if( Address == NULL ) {
        //
        // we couldn't map view for this cell
        //
        return FALSE;
    }

    try {
        Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
        Offset = (ULONG)((ULONG_PTR)Address - (ULONG_PTR)Bin);
        Size = Address->Size * -1;

        if ( (Address->Size >= 0) ||                    // not allocated
             ((Offset + (ULONG)Size) > Bin->Size) ||    // runs off bin, or too big
             (Offset < sizeof(HBIN))                    // pts into bin header
           )
        {
            bRet = FALSE;
            leave;

        }

        if (USE_OLD_CELL(Hive)) {
            if (Address->u.OldCell.Last != HBIN_NIL) {

                if (Address->u.OldCell.Last > Bin->Size) {            // bogus back pointer
                    bRet = FALSE;
                    leave;
                }

                Below = (PHCELL)((PUCHAR)Bin + Address->u.OldCell.Last);
                Size = (Below->Size < 0) ?
                            Below->Size * -1 :
                            Below->Size;

                if ( ((ULONG_PTR)Below + Size) != (ULONG_PTR)Address ) {    // no pt back
                    bRet = FALSE;
                    leave;
                }
            }
        }
    } finally {
        HvReleaseCell(Hive,Cell);
    }

    return bRet;
}

VOID
HvpDelistBinFreeCells(
    PHHIVE  Hive,
    PHBIN   Bin,
    HSTORAGE_TYPE Type
    )
/*++

Routine Description:

    If we are here, the hive needs recovery.

    Walks through the entire bin and removes its free cells from the list.
    If the bin is marked as free, it just delist it from the freebins list.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Bin - supplies a pointer to the HBIN of interest

    Type - Stable vs. Volatile

Return Value:

    NONE.

--*/
{
    HCELL_INDEX     Cell;
    PHMAP_ENTRY     Map;
    PFREE_HBIN      FreeBin;
    PLIST_ENTRY     Entry;
    ULONG           i;
    ULONG           BinIndex;

    Cell = Bin->FileOffset+(Type*HCELL_TYPE_MASK);
    Map = HvpGetCellMap(Hive, Cell);
    VALIDATE_CELL_MAP(__LINE__,Map,Hive,Cell);

    //
    // When loading, bins are always in separate chunks (each bin in it's owns chunk)
    //
    ASSERT( HBIN_BASE(Map->BinAddress) == (ULONG_PTR)Bin );
    ASSERT( Map->BinAddress & HMAP_NEWALLOC );
    
    if( Map->BinAddress & HMAP_DISCARDABLE ) {
        //
        // The bin has been added to the freebins list
        // we have to take it out. No free cell from this bin is on the 
        // freecells list, so we don't have to delist them.
        //

        Entry = Hive->Storage[Type].FreeBins.Flink;
        while (Entry != &Hive->Storage[Type].FreeBins) {
            FreeBin = CONTAINING_RECORD(Entry,
                                        FREE_HBIN,
                                        ListEntry);

            
            if( FreeBin->FileOffset == Bin->FileOffset ){
                //
                // that's the bin we're looking for
                //
                
                // sanity checks
                ASSERT( FreeBin->Size == Bin->Size );
                ASSERT_LISTENTRY(&FreeBin->ListEntry);
                
                RemoveEntryList(&FreeBin->ListEntry);
                (Hive->Free)(FreeBin, sizeof(FREE_HBIN));
                //
                // the bin is not discardable anymore
                //
                Map->BinAddress &= (~HMAP_DISCARDABLE);
                return;
            }

            // advance to the new bin
            Entry = Entry->Flink;
        }

        // we shouldn't get here
        CM_BUGCHECK(REGISTRY_ERROR,BAD_FREE_BINS_LIST,1,(ULONG)Cell,(ULONG_PTR)Map);
        return;
    }

    //
    // as for the new way of dealing with free cells, all we have to do 
    // is to clear the bits in the FreeDisplay
    //
    BinIndex = Bin->FileOffset / HBLOCK_SIZE;
    for (i = 0; i < HHIVE_FREE_DISPLAY_SIZE; i++) {
        RtlClearBits (&(Hive->Storage[Type].FreeDisplay[i].Display), BinIndex, Bin->Size / HBLOCK_SIZE);
        if( RtlNumberOfSetBits(&(Hive->Storage[Type].FreeDisplay[i].Display) ) == 0 ) {
            //
            // entire bitmap is 0 (i.e. no other free cells of this size)
            //
            Hive->Storage[Type].FreeSummary &= (~(1 << i));
        }
    }

    return;
}

struct _CELL_DATA *
HvpGetCellFlat(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    )
/*++

Routine Description:

    Returns the memory address for the specified Cell.  Will never
    return failure, but may assert.  Use HvIsCellAllocated to check
    validity of Cell.

    This routine should never be called directly, always call it
    via the HvGetCell() macro.

    This routine provides GetCell support for read only hives with
    single allocation flat images.  Such hives do not have cell
    maps ("page tables"), instead, we compute addresses by
    arithmetic against the base image address.

    Such hives cannot have volatile cells.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - supplies HCELL_INDEX of cell to return address for

Return Value:

    Address of Cell in memory.  Assert or BugCheck if error.

--*/
{
    PUCHAR          base;
    PHCELL          pcell;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"HvGetCellFlat:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"\tHive=%p Cell=%08lx\n",Hive,Cell));
    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Cell != HCELL_NIL);
    ASSERT(Hive->Flat == TRUE);
    ASSERT(HvGetCellType(Cell) == Stable);
    ASSERT(Cell >= sizeof(HBIN));
    ASSERT(Cell < Hive->BaseBlock->Length);
    ASSERT((Cell & 0x7)==0);

    //
    // Address is base of Hive image + Cell
    //
    base = (PUCHAR)(Hive->BaseBlock) + HBLOCK_SIZE;
    pcell = (PHCELL)(base + Cell);

    PERFINFO_HIVECELL_REFERENCE_FLAT(Hive, pcell, Cell);

    if (USE_OLD_CELL(Hive)) {
        return (struct _CELL_DATA *)&(pcell->u.OldCell.u.UserData);
    } else {
        return (struct _CELL_DATA *)&(pcell->u.NewCell.u.UserData);
    }
}

PHMAP_ENTRY
HvpGetCellMap(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    )
/*++

Routine Description:

    Returns the address of the HMAP_ENTRY for the cell.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - supplies HCELL_INDEX of cell to return map entry address for

Return Value:

    Address of MAP_ENTRY in memory.  NULL if no such cell or other error.

--*/
{
    ULONG           Type;
    ULONG           Table;
    ULONG           Block;
    PHMAP_TABLE     ptab;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"HvpGetCellMapPaged:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"\tHive=%p Cell=%08lx\n",Hive,Cell));
    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Hive->Flat == FALSE);
    ASSERT((Cell & (HCELL_PAD(Hive)-1))==0);

    Type = HvGetCellType(Cell);
    Table = (Cell & HCELL_TABLE_MASK) >> HCELL_TABLE_SHIFT;
    Block = (Cell & HCELL_BLOCK_MASK) >> HCELL_BLOCK_SHIFT;

    if ((Cell - (Type * HCELL_TYPE_MASK)) >= Hive->Storage[Type].Length) {
        return NULL;
    }

    ptab = (Hive->Storage[Type].Map)->Directory[Table];
    return &(ptab->Table[Block]);
}


LONG
HvGetCellSize(
    IN PHHIVE   Hive,
    IN PVOID    Address
    )
/*++

Routine Description:

    Returns the size of the specified Cell, based on its MEMORY
    ADDRESS.  Must always call HvGetCell first to get that
    address.

    NOTE:   This should be a macro if speed is issue.

    NOTE:   If you pass in some random pointer, you will get some
            random answer.  Only pass in valid Cell addresses.

Arguments:

    Hive - supplies hive control structure for the given cell

    Address - address in memory of the cell, returned by HvGetCell()

Return Value:

    Allocated size in bytes of the cell.

    If Negative, Cell is free, or Address is bogus.

--*/
{
    LONG    size;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"HvGetCellSize:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"\tAddress=%p\n", Address));

    if (USE_OLD_CELL(Hive)) {
        size = ( (CONTAINING_RECORD(Address, HCELL, u.OldCell.u.UserData))->Size ) * -1;
        size -= FIELD_OFFSET(HCELL, u.OldCell.u.UserData);
    } else {
        size = ( (CONTAINING_RECORD(Address, HCELL, u.NewCell.u.UserData))->Size ) * -1;
        size -= FIELD_OFFSET(HCELL, u.NewCell.u.UserData);
    }
    return size;
}

VOID
HvFreeCell(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    )
/*++

Routine Description:


    Frees the storage for a cell.

    NOTE:   CALLER is expected to mark relevant data dirty, so as to
            allow this call to always succeed.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - HCELL_INDEX of Cell to free.

Return Value:

    FALSE - failed, presumably for want of log space.

    TRUE - it worked

--*/
{
    PHBIN           Bin;
    PHCELL          tmp;
    HCELL_INDEX     newfreecell;
    PHCELL          freebase;
    ULONG           savesize;
    PHCELL          neighbor;
    ULONG           Type;
    PHMAP_ENTRY     Me;


    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"HvFreeCell:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"\tHive=%p Cell=%08lx\n",Hive,Cell));
    ASSERT(Hive->ReadOnly == FALSE);

    //
    // we have the lock exclusive or nobody is operating inside this hive
    //
    ASSERT_HIVE_FLUSHER_LOCKED((PCMHIVE)Hive);

    //
    // We should hit this if there is any bogus code path where data is modified
    // but not marked as dirty; We could run into a lot of problems if this ASSERT
    // ever fires !!!
    //
    ASSERT_CELL_DIRTY(Hive,Cell);

    // no two guys in here at the same time for the same hive
    CmpLockHiveWriter((PCMHIVE)Hive);

    //
    // Get sizes and addresses
    //
    Me = HvpGetCellMap(Hive, Cell);
    VALIDATE_CELL_MAP(__LINE__,Me,Hive,Cell);
    Type = HvGetCellType(Cell);

    Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
    //
    // at this point, bin should be valid (either in memory or in the paged pool)
    //
    ASSERT_BIN_VALID(Me);

    DHvCheckBin(Hive,Bin);
    freebase = HvpGetHCell(Hive, Cell);
    if( freebase == NULL ) {
        //
        // we couldn't map view for this cell
        // this shouldn't happen as the cell here is already marked dirty
        // or it's entire bin is mapped 
        //
        ASSERT( FALSE);
        CmpUnlockHiveWriter((PCMHIVE)Hive);
        return;
    }

    // release the cell right here as the view is pinned
    HvReleaseCell(Hive,Cell);

    //
    // go do actual frees, cannot fail from this point on
    //
    ASSERT(freebase->Size < 0);
    freebase->Size *= -1;

    savesize = freebase->Size;

    //
    // Look for free neighbors and coalesce them.  We will never travel
    // around this loop more than twice.
    //
    while (
        HvpIsFreeNeighbor(
            Hive,
            Bin,
            freebase,
            &neighbor,
            Type
            ) == TRUE
        )
    {

        if (neighbor > freebase) {

            //
            // Neighboring free cell is immediately above us in memory.
            //
            if (USE_OLD_CELL(Hive)) {
                tmp = (PHCELL)((PUCHAR)neighbor + neighbor->Size);
                if ( ((ULONG)((ULONG_PTR)tmp - (ULONG_PTR)Bin)) < Bin->Size) {
                        tmp->u.OldCell.Last = (ULONG)((ULONG_PTR)freebase - (ULONG_PTR)Bin);
                }
            }
            freebase->Size += neighbor->Size;

        } else {

            //
            // Neighboring free cell is immediately below us in memory.
            //

            if (USE_OLD_CELL(Hive)) {
                tmp = (PHCELL)((PUCHAR)freebase + freebase->Size);
                if ( ((ULONG)((ULONG_PTR)tmp - (ULONG_PTR)Bin)) < Bin->Size ) {
                    tmp->u.OldCell.Last = (ULONG)((ULONG_PTR)neighbor - (ULONG_PTR)Bin);
                }
            }
            neighbor->Size += freebase->Size;
            freebase = neighbor;
        }
    }

    //
    // freebase now points to the biggest free cell we could make, none
    // of which is on the free list.  So put it on the list.
    //
    newfreecell = (Bin->FileOffset) +
               ((ULONG)((ULONG_PTR)freebase - (ULONG_PTR)Bin)) +
               (Type*HCELL_TYPE_MASK);

#if DBG
    //
    // entire bin is in memory; no problem to call HvpGetHCell
    //
    ASSERT(HvpGetHCell(Hive, newfreecell) == freebase);
    HvReleaseCell(Hive,newfreecell);

    if (USE_OLD_CELL(Hive)) {
        RtlFillMemory(
            &(freebase->u.OldCell.u.UserData),
            (freebase->Size - FIELD_OFFSET(HCELL, u.OldCell.u.UserData)),
            HCELL_FREE_FILL
            );
    } else {
        RtlFillMemory(
            &(freebase->u.NewCell.u.UserData),
            (freebase->Size - FIELD_OFFSET(HCELL, u.NewCell.u.UserData)),
            HCELL_FREE_FILL
            );
    }
#endif

    HvpEnlistFreeCell(Hive, newfreecell, freebase->Size, Type, TRUE);

    CmpUnlockHiveWriter((PCMHIVE)Hive);
    return;
}

BOOLEAN
HvpIsFreeNeighbor(
    PHHIVE  Hive,
    PHBIN   Bin,
    PHCELL  FreeCell,
    PHCELL  *FreeNeighbor,
    HSTORAGE_TYPE   Type
    )
/*++

Routine Description:

    Reports on whether FreeCell has at least one free neighbor and
    if so where.  Free neighbor will be cut out of the free list.

Arguments:

    Hive - hive we're working on

    Bin - pointer to the storage bin

    FreeCell - supplies a pointer to a cell that has been freed, or
                the result of a coalesce.

    FreeNeighbor - supplies a pointer to a variable to receive the address
                    of a free neigbhor of FreeCell, if such exists

    Type - storage type of the cell

Return Value:

    TRUE if a free neighbor was found, else false.


--*/
{
    PHCELL      ptcell;
    HCELL_INDEX cellindex;
    ULONG       CellOffset;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"HvpIsFreeNeighbor:\n\tBin=%p",Bin));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"FreeCell=%08lx\n", FreeCell));
    ASSERT(Hive->ReadOnly == FALSE);

    ASSERT_HIVE_WRITER_LOCK_OWNED((PCMHIVE)Hive);
    //
    // Neighbor above us?
    //
    *FreeNeighbor = NULL;
    cellindex = HCELL_NIL;

    ptcell = (PHCELL)((PUCHAR)FreeCell + FreeCell->Size);
    ASSERT( ((ULONG)((ULONG_PTR)ptcell - (ULONG_PTR)Bin)) <= Bin->Size);
    if (((ULONG)((ULONG_PTR)ptcell - (ULONG_PTR)Bin)) < Bin->Size) {
        if (ptcell->Size > 0) {
            *FreeNeighbor = ptcell;
            goto FoundNeighbor;
        }
    }

    //
    // Neighbor below us?
    //
    if (USE_OLD_CELL(Hive)) {
        if (FreeCell->u.OldCell.Last != HBIN_NIL) {
            ptcell = (PHCELL)((PUCHAR)Bin + FreeCell->u.OldCell.Last);
            if (ptcell->Size > 0) {
                *FreeNeighbor = ptcell;
                goto FoundNeighbor;
            }
        }
    } else {
        ptcell = (PHCELL)(Bin+1);
        while (ptcell < FreeCell) {

            //
            // scan through the cells from the start of the bin looking for neighbor.
            //
            if (ptcell->Size > 0) {

                if ((PHCELL)((PUCHAR)ptcell + ptcell->Size) == FreeCell) {
                    *FreeNeighbor = ptcell;
                    //
                    // Try and mark it dirty, since we will be changing
                    // the size field.  If this fails, ignore
                    // the free neighbor, we will not fail the free
                    // just because we couldn't mark the cell dirty
                    // so it could be coalesced.
                    //
                    // Note we only bother doing this for new hives,
                    // for old format hives we always mark the whole
                    // bin dirty.
                    //
                    if ((Type == Volatile) ||
                        (HvMarkCellDirty(Hive, (ULONG)((ULONG_PTR)ptcell-(ULONG_PTR)Bin) + Bin->FileOffset,TRUE))) {
                        goto FoundNeighbor;
                    } else {
                        return(FALSE);
                    }

                } else {
                    ptcell = (PHCELL)((PUCHAR)ptcell + ptcell->Size);
                }
            } else {
                ptcell = (PHCELL)((PUCHAR)ptcell - ptcell->Size);
            }
        }
    }

    return(FALSE);

FoundNeighbor:

    CellOffset = (ULONG)((PUCHAR)ptcell - (PUCHAR)Bin);
    cellindex = Bin->FileOffset + CellOffset + (Type*HCELL_TYPE_MASK);
    HvpDelistFreeCell(Hive, cellindex, Type);
    return TRUE;
}

HCELL_INDEX
HvReallocateCell(
    PHHIVE  Hive,
    HCELL_INDEX Cell,
    ULONG    NewSize
    )
/*++

Routine Description:

    Grows or shrinks a cell.

    NOTE:

        MUST NOT FAIL if the cell is being made smaller.  Can be
        a noop, but must work.

    WARNING:

        If the cell is grown, it will get a NEW and DIFFERENT HCELL_INDEX!!!

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - supplies index of cell to grow or shrink

    NewSize - desired size of cell  (this is an absolute size, not an
            increment or decrement.)

Return Value:

    New HCELL_INDEX for cell, or HCELL_NIL if failure.

    If return is HCELL_NIL, either old cell did not exist, or it did exist
    and we could not make a new one.  In either case, nothing has changed.

    If return is NOT HCELL_NIL, then it is the HCELL_INDEX for the Cell,
    which very probably moved.

--*/
{
    PUCHAR      oldaddress;
    LONG        oldsize;
    ULONG       oldalloc;
    HCELL_INDEX NewCell;            // return value
    PUCHAR      newaddress;
    ULONG       Type;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"HvReallocateCell:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"\tHive=%p  Cell=%08lx  NewSize=%08lx\n",Hive,Cell,NewSize));
    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Hive->ReadOnly == FALSE);

    //
    // Make room for overhead fields and round up to HCELL_PAD boundary
    //
    if (USE_OLD_CELL(Hive)) {
        NewSize += FIELD_OFFSET(HCELL, u.OldCell.u.UserData);
    } else {
        NewSize += FIELD_OFFSET(HCELL, u.NewCell.u.UserData);
    }
    NewSize = ROUND_UP(NewSize, HCELL_PAD(Hive));

    // 
    // Adjust the size (an easy fix for granularity)
    //
    HvpAdjustCellSize(NewSize);

    //
    // reject impossible/unreasonable values
    //
    if (NewSize > HSANE_CELL_MAX) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"\tNewSize=%08lx\n", NewSize));
        return HCELL_NIL;
    }

    //
    // Get sizes and addresses
    //
    oldaddress = (PUCHAR)HvGetCell(Hive, Cell);
    if( oldaddress == NULL ) {
        //
        // we couldn't map a view for this cell
        // caller should handle this as STATUS_INSUFFICIENT_RESOURCES
        //
        return HCELL_NIL;
    }

    oldsize = HvGetCellSize(Hive, oldaddress);
    ASSERT(oldsize > 0);
    if (USE_OLD_CELL(Hive)) {
        oldalloc = (ULONG)(oldsize + FIELD_OFFSET(HCELL, u.OldCell.u.UserData));
    } else {
        oldalloc = (ULONG)(oldsize + FIELD_OFFSET(HCELL, u.NewCell.u.UserData));
    }
    Type = HvGetCellType(Cell);

#if DBG
    // no two guys in here at the same time for the same hive
    CmpLockHiveWriter((PCMHIVE)Hive);
    DHvCheckHive(Hive);
    CmpUnlockHiveWriter((PCMHIVE)Hive);
#endif 

    if (NewSize == oldalloc) {

        //
        // This is a noop, return the same cell
        //
        NewCell = Cell;

    } else if (NewSize < oldalloc) {

        //
        // This is a shrink.
        //
        NewCell = Cell;

    } else {

        //
        // This is a grow.
        //

        //
        // Allocate a new block of memory to hold the cell
        //

        if ((NewCell = HvpDoAllocateCell(Hive, NewSize, Type,HCELL_NIL)) == HCELL_NIL) {
            HvReleaseCell(Hive,Cell);
            return HCELL_NIL;
        }
        ASSERT(HvIsCellAllocated(Hive, NewCell));
        newaddress = (PUCHAR)HvGetCell(Hive, NewCell);
        if( newaddress == NULL ) {
            //
            // we couldn't map a view for this cell
            // this shouldn't happen as we just allocated this cell
            // (i.e. it's containing bin should be PINNED into memory)
            //
            ASSERT( FALSE );
            HvReleaseCell(Hive,Cell);
            return HCELL_NIL;
        }

        //
        // oldaddress points to the old data block for the cell,
        // newaddress points to the new data block, copy the data
        //
        RtlMoveMemory(newaddress, oldaddress, oldsize);

        HvReleaseCell(Hive,NewCell);
        //
        // Free the old block of memory
        //
        HvFreeCell(Hive, Cell);
    }

    HvReleaseCell(Hive,Cell);

#if DBG
    // no two guys in here at the same time for the same hive
    CmpLockHiveWriter((PCMHIVE)Hive);
    DHvCheckHive(Hive);
    CmpUnlockHiveWriter((PCMHIVE)Hive);
#endif 
    return NewCell;
}

HCELL_INDEX
HvDuplicateCell(    
                    PHHIVE          Hive,
                    HCELL_INDEX     Cell,
                    HSTORAGE_TYPE   Type,
                    BOOLEAN         CopyData
                )
/*++

Routine Description:

    Makes an identical copy of the given Cell in the specified storagetype

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - cell to duplicate

    Type - destination storage

    CopyData - if TRUE, data is copied, otherwise UserData is zeroed out

Return Value:

    New HCELL_INDEX for cell, or HCELL_NIL if failure.

    If return is HCELL_NIL, either old cell did not exist, or it did exist
    and we could not make a new one.  In either case, nothing has changed.

    If return is NOT HCELL_NIL, then it is the HCELL_INDEX for the Cell,
    which very probably moved.

--*/
{
    PUCHAR          CellAddress;
    PUCHAR          NewCellAddress;
    LONG            Size;
    HCELL_INDEX     NewCell;

    CM_PAGED_CODE();

    ASSERT_CM_LOCK_OWNED();

    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Hive->ReadOnly == FALSE);
    ASSERT(HvIsCellAllocated(Hive, Cell));

    //
    // Get sizes and addresses
    //
    CellAddress = (PUCHAR)HvGetCell(Hive, Cell);
    if( CellAddress == NULL ) {
        //
        // we couldn't map a view for this cell
        //
        return HCELL_NIL;
    }

    // release the cell here as we are holding the reglock exclusive
    HvReleaseCell(Hive,Cell);

    Size = HvGetCellSize(Hive, CellAddress);

    NewCell = HvAllocateCell(Hive,Size,Type,((HSTORAGE_TYPE)HvGetCellType(Cell) == Type)?Cell:HCELL_NIL);
    if( NewCell == HCELL_NIL ) {
        return HCELL_NIL;
    }

    NewCellAddress = (PUCHAR)HvGetCell(Hive, NewCell);
    if( NewCellAddress == NULL ) {
        //
        // we couldn't map the bin containing this cell
        // this shouldn't happen as we just allocated this cell
        // (i.e. it should be PINNED into memory at this point)
        //
        ASSERT( FALSE );
        HvFreeCell(Hive, NewCell);
        return HCELL_NIL;
    }

    // release the cell here as we are holding the reglock exclusive
    HvReleaseCell(Hive,NewCell);

    ASSERT( HvGetCellSize(Hive, NewCellAddress) >= Size );
    
    //
    // copy/initialize user data
    //
    if( CopyData == TRUE ) {
        RtlCopyMemory(NewCellAddress,CellAddress,Size);
    } else {
        RtlZeroMemory(NewCellAddress, Size);
    }
    
    return NewCell;
}

BOOLEAN HvAutoCompressCheck(PHHIVE Hive)
/*++

Routine Description:

    Checks the hive for the compression 

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

Return Value:

    TRUE/FALSE

--*/
{
    PCMHIVE     CmHive;    
    ULONG       CompressLevel;
    PLIST_ENTRY AnchorAddr;
    PFREE_HBIN  FreeBin;
    ULONG       FreeSpace;

    CM_PAGED_CODE();

    ASSERT_CM_EXCLUSIVE_HIVE_ACCESS(Hive);
    
    CmHive = CONTAINING_RECORD(Hive, CMHIVE, Hive);

    if( CmHive->FileHandles[HFILE_TYPE_PRIMARY] == NULL ) {
        //
        // compress already scheduled or hive doesn't really have stable storage; bail out quickly
        //
        return FALSE;
    }

    if( IsListEmpty(&(Hive->Storage[Stable].FreeBins)) ) {
        //
        // no free bins; no worth bothering
        //
        return FALSE;
    }

    //
    // iterate through the free bins and see how much space is wasted
    //
    FreeSpace = 0;
	AnchorAddr = &(Hive->Storage[Stable].FreeBins);
	FreeBin = (PFREE_HBIN)(Hive->Storage[Stable].FreeBins.Flink);

	while ( FreeBin != (PFREE_HBIN)AnchorAddr ) {
        FreeBin = CONTAINING_RECORD(FreeBin,
                                    FREE_HBIN,
                                    ListEntry);

        FreeSpace += FreeBin->Size;

        //
        // skip to the next element
        //
        FreeBin = (PFREE_HBIN)(FreeBin->ListEntry.Flink);
	}
    CompressLevel = CM_HIVE_COMPRESS_LEVEL * (Hive->Storage[Stable].Length / 100);
    
    if( FreeSpace < CompressLevel ) {
        // disable temporary so we can test the system hive.
        return FALSE;
    }

    return TRUE;
}

HCELL_INDEX
HvShiftCell(PHHIVE Hive,HCELL_INDEX Cell)
{
    PHMAP_ENTRY t;
    PHBIN       Bin;
    
    ASSERT( HvGetCellType(Cell) == Stable );
    
    t = HvpGetCellMap(Hive, Cell);
    ASSERT( t->BinAddress & HMAP_INPAGEDPOOL );

    Bin = (PHBIN)HBIN_BASE(t->BinAddress);
    ASSERT( Bin->Signature == HBIN_SIGNATURE );
    
    return Cell - Bin->Spare;
}

//
// helper for get/release pairs
//
BOOLEAN HvTrackCellRef(PHV_TRACK_CELL_REF   CellRef,
                       PHHIVE               Hive,
                       HCELL_INDEX          Cell)
/*++

Routine Description:

    helper to track cell references; autogrowing array
    to be called after a successful HvGetCell

Arguments:

Return Value:

    TRUE/FALSE

--*/
{
    CM_PAGED_CODE();

    ASSERT( CellRef );
    ASSERT( Hive );
    ASSERT( Cell != HCELL_NIL );

    if( CellRef->StaticCount < STATIC_CELL_PAIR_COUNT ) {
        //
        // fast path
        //
        CellRef->StaticArray[CellRef->StaticCount].Hive = Hive;
        CellRef->StaticArray[CellRef->StaticCount].Cell = Cell;
        CellRef->StaticCount++;
        return TRUE;
    }
    
    if( CellRef->Max == 0 ) {
        //
        // first call; allocate an initial array of 10 elements
        //
        ASSERT(CellRef->CellArray == NULL);
        ASSERT(CellRef->Count == 0);
        
        CellRef->CellArray = (PHV_HIVE_CELL_PAIR)ExAllocatePool(PagedPool,10*sizeof(HV_HIVE_CELL_PAIR));
        if( CellRef->CellArray == NULL ) {
            //
            // need to release this one as it was already referred.
            //
            HvReleaseCell(Hive,Cell);
            return FALSE;
        }
        CellRef->Max = 10;
    }

    ASSERT( CellRef->CellArray );
    
    if( CellRef->Count == CellRef->Max ) {
        //
        // we need to grow the array; do it in 10 elements chunks
        //
        PHV_HIVE_CELL_PAIR NewArray = (PHV_HIVE_CELL_PAIR)ExAllocatePool(PagedPool,(CellRef->Max + 10)*sizeof(HV_HIVE_CELL_PAIR));
        if( NewArray == NULL ) {
            //
            // need to release this one as it was already referred.
            //
            HvReleaseCell(Hive,Cell);
            return FALSE;
        }
        //
        // copy existing; update counts; free old
        //
        RtlCopyMemory(NewArray,CellRef->CellArray,CellRef->Max * sizeof(HV_HIVE_CELL_PAIR));
        ExFreePool(CellRef->CellArray);
        CellRef->CellArray = NewArray;
        CellRef->Max += 10;
    }

    ASSERT( CellRef->Count < CellRef->Max );
    //
    // we can now add the (hive,cell) to the array
    //
    CellRef->CellArray[CellRef->Count].Hive = Hive;
    CellRef->CellArray[CellRef->Count].Cell = Cell;
    CellRef->Count++;

    return TRUE;
}

VOID
HvReleaseFreeCellRefArray(PHV_TRACK_CELL_REF   CellRef)
{
    USHORT  i;

    CM_PAGED_CODE();

    ASSERT( CellRef );

    if( CellRef->StaticCount > 0 ) { 
        ASSERT( CellRef->StaticCount <= STATIC_CELL_PAIR_COUNT );
        for(i =0; i < CellRef->StaticCount;i++) {
            HvReleaseCell(CellRef->StaticArray[i].Hive,CellRef->StaticArray[i].Cell);
        }
        //
        // make it reusable
        //
        CellRef->StaticCount = 0;
    }
#if DBG
    else {
        ASSERT(CellRef->CellArray == NULL);
    }
#endif

    if( CellRef->Count > 0 ) {
        ASSERT(CellRef->CellArray != NULL);
        for(i =0; i< CellRef->Count;i++) {
            HvReleaseCell(CellRef->CellArray[i].Hive,CellRef->CellArray[i].Cell);
        }
        ExFreePool(CellRef->CellArray);
        //
        // make it reusable
        //
        CellRef->Count = CellRef->Max = 0;
        CellRef->CellArray = NULL;
    } 
#if DBG
    else {
        ASSERT(CellRef->CellArray == NULL);
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\hive.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    hive.h

Abstract:

    This module contains the private (internal) header file for the
    direct memory loaded hive manager.

--*/

#ifndef _HIVE_
#define _HIVE_

#include "hivedata.h"

#if DBG

extern ULONG HvHiveChecking;

#define DHvCheckHive(a) if(HvHiveChecking) ASSERT(HvCheckHive(a,NULL) == 0)
#define DHvCheckBin(h,a)  if(HvHiveChecking) ASSERT(HvCheckBin(h,a,NULL) == 0)

#else
#define DHvCheckHive(a)
#define DHvCheckBin(h,a)
#endif

#define ROUND_UP(a, b)  \
    ( ((ULONG)(a) + (ULONG)(b) - 1) & ~((ULONG)(b) - 1) )


//
// tombstone for an HBIN that is not resident in memory.  This list is searched
// before any new HBIN is added.
//

#define ASSERT_LISTENTRY(ListEntry) \
    ASSERT((ListEntry)->Flink->Blink==ListEntry); \
    ASSERT((ListEntry)->Blink->Flink==ListEntry);

//
// ===== Hive Private Procedure Prototypes =====
//
PHBIN
HvpAddBin(
    PHHIVE          Hive,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type
    );

PHMAP_ENTRY
HvpGetCellMap(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    );

VOID
HvpFreeMap(
    PHHIVE          Hive,
    PHMAP_DIRECTORY Dir,
    ULONG           Start,
    ULONG           End
    );

BOOLEAN
HvpAllocateMap(
    PHHIVE          Hive,
    PHMAP_DIRECTORY Dir,
    ULONG           Start,
    ULONG           End
    );

BOOLEAN
HvpGrowLog1(
    PHHIVE  Hive,
    ULONG   Count
    );

BOOLEAN
HvpGrowLog2(
    PHHIVE  Hive,
    ULONG   Size
    );

ULONG
HvpHeaderCheckSum(
    PHBASE_BLOCK    BaseBlock
    );

NTSTATUS
HvpBuildMap(
    PHHIVE  Hive,
    PVOID   Image
    );

NTSTATUS
HvpBuildMapAndCopy(
    PHHIVE  Hive,
    PVOID   Image
    );

NTSTATUS
HvpInitMap(
    PHHIVE  Hive
    );

VOID
HvpCleanMap(
    PHHIVE  Hive
    );

NTSTATUS
HvpEnlistBinInMap(
    PHHIVE  Hive,
    ULONG   Length,
    PHBIN   Bin,
    ULONG   Offset,
    PVOID CmView OPTIONAL
    );

VOID
HvpFreeAllocatedBins(
    PHHIVE Hive
    );

BOOLEAN
HvpDoWriteHive(
    PHHIVE          Hive,
    ULONG           FileType
    );

struct _CELL_DATA *
HvpGetCellFlat(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    );

struct _CELL_DATA *
HvpGetCellPaged(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    );

struct _CELL_DATA *
HvpGetCellMapped(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    );

VOID
HvpReleaseCellMapped(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    );

VOID
HvpEnlistFreeCell(
    PHHIVE  Hive,
    HCELL_INDEX Cell,
    ULONG      Size,
    HSTORAGE_TYPE   Type,
    BOOLEAN CoalesceForward
    );

BOOLEAN
HvpEnlistFreeCells(
    PHHIVE  Hive,
    PHBIN   Bin,
    ULONG   BinOffset
    );


VOID
HvpDelistFreeCell(
    PHHIVE  Hive,
    HCELL_INDEX  Cell,
    HSTORAGE_TYPE Type
    );

//
// ===== Hive Public Procedure Prototypes =====
//
#define HINIT_CREATE            0
#define HINIT_MEMORY            1
#define HINIT_FILE              2
#define HINIT_MEMORY_INPLACE    3
#define HINIT_FLAT              4
#define HINIT_MAPFILE           5

#define HIVE_VOLATILE                   1
#define HIVE_NOLAZYFLUSH                2
#define HIVE_HAS_BEEN_REPLACED          4
#define HIVE_HAS_BEEN_FREED             8
#define HIVE_IS_UNLOADING               0x20

NTSTATUS
HvInitializeHive(
    PHHIVE                  Hive,
    ULONG                   OperationType,
    ULONG                   HiveFlags,
    ULONG                   FileTypes,
    PVOID                   HiveData OPTIONAL,
    PALLOCATE_ROUTINE       AllocateRoutine,
    PFREE_ROUTINE           FreeRoutine,
    PFILE_SET_SIZE_ROUTINE  FileSetSizeRoutine,
    PFILE_WRITE_ROUTINE     FileWriteRoutine,
    PFILE_READ_ROUTINE      FileReadRoutine,
    PFILE_FLUSH_ROUTINE     FileFlushRoutine,
    ULONG                   Cluster,
    PUNICODE_STRING         FileName
    );

BOOLEAN
HvSyncHive(
    PHHIVE  Hive
    );

NTSTATUS
HvWriteHive(
    PHHIVE  Hive,
	BOOLEAN	DontGrow,
	BOOLEAN	WriteThroughCache,
    BOOLEAN CrashSafe
    );

NTSTATUS
HvLoadHive(
    PHHIVE  Hive
    );

NTSTATUS
HvMapHive(
    PHHIVE  Hive
    );

VOID
HvRefreshHive(
    PHHIVE  Hive
    );

NTSTATUS
HvReadInMemoryHive(
    PHHIVE  Hive,
    PVOID   *HiveImage
    );

ULONG
HvCheckHive(
    PHHIVE  Hive,
    PULONG  Storage OPTIONAL
    );

ULONG
HvCheckBin(
    PHHIVE  Hive,
    PHBIN   Bin,
    PULONG  Storage
    );

ULONG 
HvpGetBinMemAlloc(
                IN PHHIVE           Hive,
                PHBIN               Bin,
                IN HSTORAGE_TYPE    Type
                );

BOOLEAN
HvMarkCellDirty(
    PHHIVE      Hive,
    HCELL_INDEX Cell,
    BOOLEAN     LockHeld
    );

#if DBG
BOOLEAN
HvIsCellDirty(
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell
    );

#define ASSERT_CELL_DIRTY(_Hive_,_Cell_) ASSERT(HvIsCellDirty(_Hive_,_Cell_) == TRUE)

#else
#define ASSERT_CELL_DIRTY(_Hive_,_Cell_) // nothing
#endif //DBG

BOOLEAN
HvMarkDirty(
    PHHIVE      Hive,
    HCELL_INDEX Start,
    ULONG       Length,
    BOOLEAN     DirtyAndPin
    );

//
// IMPORTANT:
//      Every call to HvGetCell should be matched with a call to HvReleaseCell;
//      HvReleaseCell is only valid for mapped hives.
//
#define HvGetCell(Hive, Cell)       (((Hive)->GetCellRoutine)(Hive, Cell))
#define HvReleaseCell(Hive, Cell)   if((Hive)->ReleaseCellRoutine) ((Hive)->ReleaseCellRoutine)(Hive, Cell)

PHCELL
HvpGetHCell(PHHIVE      Hive,
            HCELL_INDEX Cell
            );

LONG
HvGetCellSize(
    PHHIVE      Hive,
    PVOID       Address
    );

HCELL_INDEX
HvAllocateCell(
    PHHIVE          Hive,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type,
    HCELL_INDEX     Vicinity 
    );

VOID
HvFreeCell(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    );

HCELL_INDEX
HvReallocateCell(
    PHHIVE      Hive,
    HCELL_INDEX Cell,
    ULONG       NewSize
    );

BOOLEAN
HvIsCellAllocated(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    );

VOID
HvFreeHive(
    PHHIVE Hive
    );

VOID
HvFreeHivePartial(
    PHHIVE      Hive,
    HCELL_INDEX Start,
    HSTORAGE_TYPE Type
    );

#define CmpFindFirstSetRight KiFindFirstSetRight
#define CmpFindFirstSetLeft KiFindFirstSetLeft

#define HvpComputeIndex(Index, Size)                                    \
    {                                                                   \
        Index = (Size >> HHIVE_FREE_DISPLAY_SHIFT) - 1;                 \
        if (Index >= HHIVE_LINEAR_INDEX ) {                             \
                                                                        \
            /*                                                          \
            ** Too big for the linear lists, compute the exponential    \
            ** list. Shift the index to make sure we cover the whole    \
            ** range.                                                   \
            */                                                          \
            Index >>= 4;                                                \
                                                                        \
            if (Index > 255) {                                          \
                /*                                                      \
                ** Too big for all the lists, use the last index.       \
                */                                                      \
                Index = HHIVE_FREE_DISPLAY_SIZE-1;                      \
            } else {                                                    \
                Index = CmpFindFirstSetLeft[Index] +                    \
                        HHIVE_LINEAR_INDEX;                             \
            }                                                           \
        }                                                               \
    }

VOID
HvpFreeHiveFreeDisplay(
    IN PHHIVE           Hive
    );

NTSTATUS
HvpAdjustHiveFreeDisplay(
    IN PHHIVE           Hive,
    IN ULONG            HiveLength,
    IN HSTORAGE_TYPE    Type
    );

VOID
HvpAddFreeCellHint(
    PHHIVE          Hive,
    HCELL_INDEX     Cell,
    ULONG           Index,
    HSTORAGE_TYPE   Type
    );

VOID
HvpRemoveFreeCellHint(
    PHHIVE          Hive,
    HCELL_INDEX     Cell,
    ULONG           Index,
    HSTORAGE_TYPE   Type
    );

HCELL_INDEX
HvpFindFreeCell(
    PHHIVE          Hive,
    ULONG           Index,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type,
    HCELL_INDEX     Vicinity 
    );

BOOLEAN
HvpCheckViewBoundary(
                     IN ULONG Start,
                     IN ULONG End
    );

VOID
HvpDropPagedBins(
    PHHIVE  Hive
#if DBG
    ,
    IN BOOLEAN  Check
#endif
    );

VOID
HvpDropAllPagedBins(
    IN PHHIVE   Hive
    );

BOOLEAN
HvpWriteLog(
    PHHIVE          Hive
    );


BOOLEAN
HvHiveWillShrink(
                    IN PHHIVE Hive
                    );

BOOLEAN HvAutoCompressCheck(PHHIVE Hive);

NTSTATUS
HvCloneHive(PHHIVE  SourceHive,
            PHHIVE  DestHive,
            PULONG  NewLength
            );

NTSTATUS 
HvShrinkHive(PHHIVE  Hive,
             ULONG   NewLength
            );

HCELL_INDEX
HvShiftCell(PHHIVE Hive,HCELL_INDEX Cell);

HCELL_INDEX
HvDuplicateCell(    
                    PHHIVE          Hive,
                    HCELL_INDEX     Cell,
                    HSTORAGE_TYPE   Type,
                    BOOLEAN         CopyData
                );

typedef struct _HV_HIVE_CELL_PAIR {
    PHHIVE      Hive;
    HCELL_INDEX Cell;
} HV_HIVE_CELL_PAIR,*PHV_HIVE_CELL_PAIR;

#define STATIC_CELL_PAIR_COUNT    4

typedef struct _HV_TRACK_CELL_REF {
    USHORT              Count;
    USHORT              Max;
    PHV_HIVE_CELL_PAIR  CellArray;
    HV_HIVE_CELL_PAIR   StaticArray[STATIC_CELL_PAIR_COUNT];
    USHORT              StaticCount;
} HV_TRACK_CELL_REF,*PHV_TRACK_CELL_REF;

BOOLEAN HvTrackCellRef(PHV_TRACK_CELL_REF   CellRef,
                       PHHIVE               Hive,
                       HCELL_INDEX          Cell);

VOID
HvReleaseFreeCellRefArray(PHV_TRACK_CELL_REF   CellRef);

#endif // _HIVE_
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\hivefree.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    hivefree.c

Abstract:

    Hive free code


Revision History:

    Implementation of bin-size chunk loading of hives.

--*/

#include "cmp.h"

#define LogHiveFree(_hive_) //nothing

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HvFreeHive)
#pragma alloc_text(PAGE,HvFreeHivePartial)
#endif

VOID
HvFreeHive(
    PHHIVE Hive
    )
/*++

Routine Description:

    Free all of the pieces of a hive.

Arguments:

    Hive - supplies a pointer to hive control structure for hive to free.
            this structure itself will NOT be freed, but everything it
            points to will.

Return Value:

    NONE.

--*/
{
    PHMAP_DIRECTORY Dir;
    PHMAP_ENTRY     Me;
    HCELL_INDEX     Address;
    ULONG           Type;
    ULONG           Length;
    PHBIN           Bin;
    ULONG           Tables;
    PFREE_HBIN      FreeBin;

    ASSERT(Hive->Flat == FALSE);
    ASSERT(Hive->ReadOnly == FALSE);
    ASSERT(Stable == 0);
    ASSERT(Volatile == 1);

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"HvFreeHive(%ws) :\n", Hive->BaseBlock->FileName));
    //
    // Iterate through both types of storage
    //
    for (Type = 0; Type <= Volatile; Type++) {

        Address = HCELL_TYPE_MASK * Type;
        Length = Hive->Storage[Type].Length + (HCELL_TYPE_MASK * Type);

        if( Hive->Storage[Type].Map && (Length > (HCELL_TYPE_MASK * Type)) ) {

            //
            // Sweep through bin set
            //
            do {
                Me = HvpGetCellMap(Hive, Address);
                VALIDATE_CELL_MAP(__LINE__,Me,Hive,Address);
                    if (Me->BinAddress & HMAP_DISCARDABLE) {
                        //
                        // hbin is either discarded or discardable, check the tombstone
                        //
                        FreeBin = (PFREE_HBIN)Me->BlockAddress;
                        Address += FreeBin->Size;
                        if (FreeBin->Flags & FREE_HBIN_DISCARDABLE) {
                            CmpFree((PHBIN)HBIN_BASE(Me->BinAddress), FreeBin->Size);
                        } else if(Me->BinAddress & HMAP_INPAGEDPOOL) {
                            //
                            // The bin has been freed, but quota is still charged.
                            // Since the hive is being freed, the quota must be
                            // returned here.
                            //
                            CmpReleaseGlobalQuota(FreeBin->Size);
                        }

                        CmpFree(FreeBin, sizeof(FREE_HBIN));
                    } else {
                        if( Me->BinAddress & HMAP_INPAGEDPOOL ) {
                            ASSERT( Me->BinAddress & HMAP_INPAGEDPOOL );

                            Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
                            Address += HvpGetBinMemAlloc(Hive,Bin,Type);
#if DBG
                            if( Type == Stable ) {
                                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"HvFreeHive: BinAddress = 0x%p\t Size = 0x%lx\n", Bin, HvpGetBinMemAlloc(Hive,Bin,Type)));
                            }
#endif

                            //
                            // free the actual bin only if it is allocated from paged pool
                            //
                            if(HvpGetBinMemAlloc(Hive,Bin,Type)) {
                                CmpFree(Bin, HvpGetBinMemAlloc(Hive,Bin,Type));
                            }
                        } else {
                            //
                            // bin was mapped into view; advance carefully
                            //
                            Address += HBLOCK_SIZE;
                        }

                    }
            } while (Address < Length);

            //
            // Free map table storage
            //
            ASSERT(Hive->Storage[Type].Length != (HCELL_TYPE_MASK * Type));
            Tables = (((Hive->Storage[Type].Length) / HBLOCK_SIZE)-1) / HTABLE_SLOTS;
            Dir = Hive->Storage[Type].Map;
            HvpFreeMap(Hive, Dir, 0, Tables);

            if (Tables > 0) {
                CmpFree(Hive->Storage[Type].Map, sizeof(HMAP_DIRECTORY));  // free dir if it exists
            }
        }
        Hive->Storage[Type].Length = 0;
    }

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"\n"));
    //
    // Free the base block
    //
    (Hive->Free)(Hive->BaseBlock,Hive->BaseBlockAlloc);
    Hive->BaseBlock = NULL;
    
    //
    // Free the dirty vector
    //
    if (Hive->DirtyVector.Buffer != NULL) {
        CmpFree((PVOID)(Hive->DirtyVector.Buffer), Hive->DirtyAlloc);
    }

    HvpFreeHiveFreeDisplay(Hive);
    LogHiveFree(Hive);
    return;
}

VOID
HvFreeHivePartial(
    PHHIVE      Hive,
    HCELL_INDEX Start,
    HSTORAGE_TYPE Type
    )
/*++

Routine Description:

    Free the memory and associated maps for the end of a hive
    starting at Start.  The baseblock, hive, etc will not be touched.

Arguments:

    Hive - supplies a pointer to hive control structure for hive to
            partially free.

    Start - HCELL_INDEX of first bin to free, will free from this
            bin (inclusive) to the end of the hives stable storage.

    Type - Type of storage (Stable or Volatile) to be freed.

Return Value:

    NONE.

--*/
{
    PHMAP_DIRECTORY Dir;
    PHMAP_ENTRY     Me;
    HCELL_INDEX     Address;
    ULONG           StartTable;
    ULONG           Length;
    PHBIN           Bin;
    ULONG           Tables;
    ULONG           FirstBit;
    ULONG           LastBit;
    PFREE_HBIN      FreeBin;

    ASSERT(Hive->Flat == FALSE);
    ASSERT(Hive->ReadOnly == FALSE);

    Address = Start;
    Length = Hive->Storage[Type].Length;
    ASSERT(Address <= Length);

    if (Address == Length) {
        return;
    }

    //
    // Sweep through bin set
    //
    do {
        Me = HvpGetCellMap(Hive, Address + (Type*HCELL_TYPE_MASK));
        VALIDATE_CELL_MAP(__LINE__,Me,Hive,Address + (Type*HCELL_TYPE_MASK));
        if (Me->BinAddress & HMAP_DISCARDABLE) {
            FreeBin = (PFREE_HBIN)Me->BlockAddress;
            if (FreeBin->Flags & FREE_HBIN_DISCARDABLE) {
                CmpFree((PVOID)HBIN_BASE(Me->BinAddress), FreeBin->Size);
            } else {
                //
                // The bin has been freed, but quota is still charged.
                // Since the file will now shrink, the quota must be
                // returned here.
                //
                if( Me->BinAddress & HMAP_INPAGEDPOOL) {
                    //
                    // we charge quota only for bins in paged-pool
                    //
                    CmpReleaseGlobalQuota(FreeBin->Size);
                }
            }
            RemoveEntryList(&FreeBin->ListEntry);
            Address += FreeBin->Size;
            CmpFree(FreeBin, sizeof(FREE_HBIN));

        } else {
            Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
            Address += HvpGetBinMemAlloc(Hive,Bin,Type);
            
            if( Me->BinAddress & HMAP_INPAGEDPOOL && HvpGetBinMemAlloc(Hive,Bin,Type) ) {
                //
                // free the bin only if it is allocated from paged pool
                //
                CmpFree(Bin, HvpGetBinMemAlloc(Hive,Bin,Type));
            }
        }
    } while (Address < Length);

    //
    // Free map table storage
    //
    Tables = (((Hive->Storage[Type].Length) / HBLOCK_SIZE) - 1) / HTABLE_SLOTS;
    Dir = Hive->Storage[Type].Map;
    if (Start > 0) {
        StartTable = ((Start-1) / HBLOCK_SIZE) / HTABLE_SLOTS;
    } else {
        StartTable = (ULONG)-1;
    }
    HvpFreeMap(Hive, Dir, StartTable+1, Tables);

    //
    // update hysteresis (eventually queue work item)
    //
    if( Type == Stable) {
        CmpUpdateSystemHiveHysteresis(Hive,(Start&(~HCELL_TYPE_MASK)),Hive->Storage[Type].Length);
    }

    Hive->Storage[Type].Length = (Start&(~HCELL_TYPE_MASK));

    if (Type==Stable) {
        //
        // Clear dirty vector for data past Hive->Storage[Stable].Length
        //
        FirstBit = Start / HSECTOR_SIZE;
        LastBit = Hive->DirtyVector.SizeOfBitMap;
        ASSERT(Hive->DirtyCount == RtlNumberOfSetBits(&Hive->DirtyVector));
        RtlClearBits(&Hive->DirtyVector, FirstBit, LastBit-FirstBit);
        Hive->DirtyCount = RtlNumberOfSetBits(&Hive->DirtyVector);
    }

    HvpAdjustHiveFreeDisplay(Hive,Hive->Storage[Type].Length,Type);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\hiveinit.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    hiveinit.c

Abstract:

    Hive initialization code.

Revision History:

    Implementation of bin-size chunk loading of hives.

--*/

#include    "cmp.h"

VOID
HvpFillFileName(
    PHBASE_BLOCK            BaseBlock,
    PUNICODE_STRING         FileName
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HvInitializeHive)
#pragma alloc_text(PAGE,HvpFillFileName)
#pragma alloc_text(PAGE,HvpFreeAllocatedBins)
#endif

// Modified functions
VOID
HvpFreeAllocatedBins(
    PHHIVE Hive
    )
/*++

Routine Description:

    Free all the bins allocated for the specified hive.
    It applies only to stable storage. Not all bins are allocated.
    Those that are not allocated have BinAddress set to 0
    
Arguments:

    Hive - supplies a pointer to hive control structure for hive who's bin to free.

Return Value:

    NONE.

--*/
{
    ULONG           Length;
    PHBIN           Bin;
    ULONG           MapSlots;
    ULONG           Tables;
    PHMAP_ENTRY     Me;
    PHMAP_TABLE     Tab;
    ULONG           i;
    ULONG           j;

    //
    // calculate the number of tables in the map
    //
    Length = Hive->Storage[Stable].Length;
    MapSlots = Length / HBLOCK_SIZE;
    if( MapSlots > 0 ) {
        Tables = (MapSlots-1) / HTABLE_SLOTS;
    } else {
        Tables = 0;
    }

    if( Hive->Storage[Stable].Map ) {
        //
        // iterate through the directory 
        //
        for (i = 0; i <= Tables; i++) {
            Tab = Hive->Storage[Stable].Map->Directory[i];

            ASSERT(Tab);
            
            //
            // iterate through the slots in the directory
            //
            for(j=0;j<HTABLE_SLOTS;j++) {
                Me = &(Tab->Table[j]);
                //
                // BinAddress non-zero means allocated bin
                //
                if( Me->BinAddress ) {
                    //
                    // a bin is freed if it is a new alloc AND it resides in paged pool
                    //
                    if( (Me->BinAddress & HMAP_NEWALLOC) && (Me->BinAddress & HMAP_INPAGEDPOOL) ) {
                        Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
                        (Hive->Free)(Bin, HvpGetBinMemAlloc(Hive,Bin,Stable));
                    }
                    
                    Me->BinAddress = 0;
                }
            }
        }
    }
   
}

NTSTATUS
HvInitializeHive(
    PHHIVE                  Hive,
    ULONG                   OperationType,
    ULONG                   HiveFlags,
    ULONG                   FileType,
    PVOID                   HiveData OPTIONAL,
    PALLOCATE_ROUTINE       AllocateRoutine,
    PFREE_ROUTINE           FreeRoutine,
    PFILE_SET_SIZE_ROUTINE  FileSetSizeRoutine,
    PFILE_WRITE_ROUTINE     FileWriteRoutine,
    PFILE_READ_ROUTINE      FileReadRoutine,
    PFILE_FLUSH_ROUTINE     FileFlushRoutine,
    ULONG                   Cluster,
    PUNICODE_STRING         FileName OPTIONAL
    )
/*++

Routine Description:

    Initialize a hive.

    Core HHive fields are always initializeed.

    File calls WILL be made BEFORE this call returns.

    Caller is expected to create/open files and store file handles
    in a way that can be derived from the hive pointer.

    Three kinds of initialization can be done, selected by OperationType:

        HINIT_CREATE

            Create a new hive from scratch.  Will have 0 storage.
            [Used to do things like create HARDWARE hive and for parts
             of SaveKey and RestoreKey]


        HINIT_MEMORY_INPLACE

            Build a hive control structure which allows read only
            access to a contiguous in-memory image of a hive.
            No part of the image will be copied, but a map will
            be made.
            [Used by osloader.]


        HINIT_FLAT

            Support very limited (read-only, no checking code) operation
            against a hive image.


        HINIT_MEMORY

            Create a new hive, using a hive image already in memory,
            at address supplied by pointer HiveData.  The data will
            be copied.  Caller is expected to free HiveData.
            [Used for SYSTEM hive]


        HINIT_FILE

            Create a hive, reading its data from a file.  Recovery processing
            via log file will be done if a log is available.  If a log
            is recovered, flush and clear operation will proceed.


        HINIT_MAPFILE

            Create a hive, reading its data from a file.  Data reading is
            done by mapping views of the file in the system cache.
            

  NOTE:   The HHive is not a completely opaque structure, because it
            is really only used by a limited set of code.  Do not assume
            that only this routine sets all of these values.


Arguments:

    Hive - supplies a pointer to hive control structure to be initialized
            to describe this hive.

    OperationType - specifies whether to create a new hive from scratch,
            from a memory image, or by reading a file from disk.

    HiveFlags - HIVE_VOLATILE - Entire hive is to be volatile, regardless
                                   of the types of cells allocated
                HIVE_NO_LAZY_FLUSH - Data in this hive is never written
                                   to disk except by an explicit FlushKey

    FileType - HFILE_TYPE_*, HFILE_TYPE_LOG set up for logging support respectively.

    HiveData - if present, supplies a pointer to an in memory image of
            from which to init the hive.  Only useful when OperationType
            is set to HINIT_MEMORY.

    AllocateRoutine - supplies a pointer to routine called to allocate
                        memory.  WILL be called before this routine returns.

    FreeRoutine - supplies a pointer to routine called to free memory.
                   CAN be called before this routine returns.

    FileSetSizeRoutine - supplies a pointer to a routine used to set the
                         size of a file. CAN be called before this
                         routine returns.

    FileWriteRoutine - supplies a pointer to routine called to write memory
                        to a file.

    FileReadRoutine - supplies a pointer to routine called to read from
                        a file into memory. CAN be called before this
                        routine returns.

    FileFlushRoutine - supplies a pointer to routine called to flush a file.

    Cluster - clustering factor in HSECTOR_SIZE units.  (i.e.  Size of
            physical sector in media / HSECTOR_SIZE.  1 for 512 byte
            physical sectors (or smaller), 2 for 1024, 4 for 2048, etc.
            (Numbers greater than 8 won't work.)

    FileName - some path like "...\system32\config\system", last
                32 or so characters will be copied into baseblock
                (and thus to disk) as a debugging aid.  May be null.


Return Value:

    NTSTATUS code.

--*/
{
    BOOLEAN         UseForIo;
    PHBASE_BLOCK    BaseBlock = NULL;
    NTSTATUS        Status;
    ULONG           i;
    ULONG           Alignment;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INIT,"HvInitializeHive:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_INIT,"\tHive=%p\n", Hive));

    //
    // reject invalid parameter combinations
    //
    if ( (! ARGUMENT_PRESENT(HiveData)) &&
         ((OperationType == HINIT_MEMORY) ||
          (OperationType == HINIT_FLAT) ||
          (OperationType == HINIT_MEMORY_INPLACE))
       )
    {
        return STATUS_INVALID_PARAMETER;
    }

    if ( ! ((OperationType == HINIT_CREATE) ||
            (OperationType == HINIT_MEMORY) ||
            (OperationType == HINIT_MEMORY_INPLACE) ||
            (OperationType == HINIT_FLAT) ||
            (OperationType == HINIT_FILE) ||
            (OperationType == HINIT_MAPFILE))
       )
    {
        return STATUS_INVALID_PARAMETER;
    }


    //
    // static and global control values
    //
    Hive->Signature = HHIVE_SIGNATURE;

    Hive->Allocate = AllocateRoutine;
    Hive->Free = FreeRoutine;
    Hive->FileSetSize = FileSetSizeRoutine;
    Hive->FileWrite = FileWriteRoutine;
    Hive->FileRead = FileReadRoutine;
    Hive->FileFlush = FileFlushRoutine;

    Hive->Log = (BOOLEAN)((FileType == HFILE_TYPE_LOG) ? TRUE : FALSE);

    if (Hive->Log  && (HiveFlags & HIVE_VOLATILE)) {
        return STATUS_INVALID_PARAMETER;
    }

    Hive->HiveFlags = HiveFlags;

    if ((Cluster == 0) || (Cluster > HSECTOR_COUNT)) {
        return STATUS_INVALID_PARAMETER;
    }
    Hive->Cluster = Cluster;

    Hive->RefreshCount = 0;

    Hive->StorageTypeCount = HTYPE_COUNT;


    Hive->Storage[Volatile].Length = 0;
    Hive->Storage[Volatile].Map = NULL;
    Hive->Storage[Volatile].SmallDir = NULL;
    Hive->Storage[Volatile].Guard = (ULONG)-1;
    Hive->Storage[Volatile].FreeSummary = 0;
    InitializeListHead(&Hive->Storage[Volatile].FreeBins);
    for (i = 0; i < HHIVE_FREE_DISPLAY_SIZE; i++) {
        RtlInitializeBitMap(&(Hive->Storage[Volatile].FreeDisplay[i].Display), NULL, 0);
        Hive->Storage[Volatile].FreeDisplay[i].RealVectorSize = 0;
    }

    Hive->Storage[Stable].Length = 0;
    Hive->Storage[Stable].Map = NULL;
    Hive->Storage[Stable].SmallDir = NULL;
    Hive->Storage[Stable].Guard = (ULONG)-1;
    Hive->Storage[Stable].FreeSummary = 0;
    InitializeListHead(&Hive->Storage[Stable].FreeBins);
    for (i = 0; i < HHIVE_FREE_DISPLAY_SIZE; i++) {
        RtlInitializeBitMap(&(Hive->Storage[Stable].FreeDisplay[i].Display), NULL, 0);
        Hive->Storage[Stable].FreeDisplay[i].RealVectorSize = 0;
    }

    RtlInitializeBitMap(&(Hive->DirtyVector), NULL, 0);
    Hive->DirtyCount = 0;
    Hive->DirtyAlloc = 0;
    Hive->DirtyFlag = FALSE;
    Hive->LogSize = 0;
    Hive->BaseBlockAlloc = sizeof(HBASE_BLOCK);

    Hive->GetCellRoutine = HvpGetCellPaged;
    Hive->ReleaseCellRoutine = NULL;
    Hive->Flat = FALSE;
    Hive->ReadOnly = FALSE;
    UseForIo = (BOOLEAN)!(Hive->HiveFlags & HIVE_VOLATILE);

    //
    // new create case
    //
    if (OperationType == HINIT_CREATE) {

        BaseBlock = (PHBASE_BLOCK)((Hive->Allocate)(Hive->BaseBlockAlloc, UseForIo,CM_FIND_LEAK_TAG11));
        if (BaseBlock == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        //
        // Make sure the buffer we got back is cluster-aligned. If not, try
        // harder to get an aligned buffer.
        //
        Alignment = Cluster * HSECTOR_SIZE - 1;
        if (((ULONG_PTR)BaseBlock & Alignment) != 0) {
            (Hive->Free)(BaseBlock, Hive->BaseBlockAlloc);
            BaseBlock = (PHBASE_BLOCK)((Hive->Allocate)(PAGE_SIZE, TRUE,CM_FIND_LEAK_TAG12));
            if (BaseBlock == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            Hive->BaseBlockAlloc = PAGE_SIZE;
        }

        BaseBlock->Signature = HBASE_BLOCK_SIGNATURE;
        BaseBlock->Sequence1 = 1;
        BaseBlock->Sequence2 = 1;
        BaseBlock->TimeStamp.HighPart = 0;
        BaseBlock->TimeStamp.LowPart = 0;
        BaseBlock->Major = HSYS_MAJOR;
        BaseBlock->Minor = HSYS_MINOR;
        BaseBlock->Type = HFILE_TYPE_PRIMARY;
        BaseBlock->Format = HBASE_FORMAT_MEMORY;
        BaseBlock->RootCell = HCELL_NIL;
        BaseBlock->Length = 0;
        BaseBlock->Cluster = Cluster;
        BaseBlock->CheckSum = 0;
        HvpFillFileName(BaseBlock, FileName);
        Hive->BaseBlock = BaseBlock;
        Hive->Version = HSYS_MINOR;
        Hive->BaseBlock->BootType = 0;

        return STATUS_SUCCESS;
    }

    //
    // flat image case
    //
    if (OperationType == HINIT_FLAT) {
        Hive->BaseBlock = (PHBASE_BLOCK)HiveData;
        Hive->Version = Hive->BaseBlock->Minor;
        Hive->Flat = TRUE;
        Hive->ReadOnly = TRUE;
        Hive->GetCellRoutine = HvpGetCellFlat;
        Hive->Storage[Stable].Length = Hive->BaseBlock->Length;
        Hive->StorageTypeCount = 1;
        Hive->BaseBlock->BootType = 0;

        return STATUS_SUCCESS;
    }

    //
    // readonly image case
    //
    if (OperationType == HINIT_MEMORY_INPLACE) {
        BaseBlock = (PHBASE_BLOCK)HiveData;

        if ( (BaseBlock->Signature != HBASE_BLOCK_SIGNATURE)    ||
             (BaseBlock->Type != HFILE_TYPE_PRIMARY)            ||
             (BaseBlock->Major != HSYS_MAJOR)                   ||
             (BaseBlock->Minor > HSYS_MINOR_SUPPORTED)          ||
             (BaseBlock->Format != HBASE_FORMAT_MEMORY)         ||
             (BaseBlock->Sequence1 != BaseBlock->Sequence2)     ||
             (HvpHeaderCheckSum(BaseBlock) !=
              (BaseBlock->CheckSum))
           )
        {
            return STATUS_REGISTRY_CORRUPT;
        }

        Hive->BaseBlock = BaseBlock;
        Hive->Version = BaseBlock->Minor;
        Hive->ReadOnly = TRUE;
        Hive->StorageTypeCount = 1;
        Hive->BaseBlock->BootType = 0;
        Status = HvpAdjustHiveFreeDisplay(Hive,BaseBlock->Length,Stable);
        if( !NT_SUCCESS(Status) ) {
            return Status;
        }

        if ( !NT_SUCCESS(HvpBuildMap(
                            Hive,
                            (PUCHAR)HiveData + HBLOCK_SIZE
                            )))
        {
            return STATUS_REGISTRY_CORRUPT;
        }

        return(STATUS_SUCCESS);
    }

    //
    // memory copy case
    //
    if (OperationType == HINIT_MEMORY) {
        BaseBlock = (PHBASE_BLOCK)HiveData;

        if ( (BaseBlock->Signature != HBASE_BLOCK_SIGNATURE)    ||
             (BaseBlock->Type != HFILE_TYPE_PRIMARY)            ||
             (BaseBlock->Format != HBASE_FORMAT_MEMORY)         ||
             (BaseBlock->Major != HSYS_MAJOR)                   ||
             (BaseBlock->Minor > HSYS_MINOR_SUPPORTED)          ||
             (HvpHeaderCheckSum(BaseBlock) !=
              (BaseBlock->CheckSum))
           )
        {
            return STATUS_REGISTRY_CORRUPT;
        }

        Hive->BaseBlock = (PHBASE_BLOCK)((Hive->Allocate)(Hive->BaseBlockAlloc, UseForIo,CM_FIND_LEAK_TAG13));
        if (Hive->BaseBlock==NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        //
        // Make sure the buffer we got back is cluster-aligned. If not, try
        // harder to get an aligned buffer.
        //
        Alignment = Cluster * HSECTOR_SIZE - 1;
        if (((ULONG_PTR)Hive->BaseBlock & Alignment) != 0) {
            (Hive->Free)(Hive->BaseBlock, Hive->BaseBlockAlloc);
            Hive->BaseBlock = (PHBASE_BLOCK)((Hive->Allocate)(PAGE_SIZE, TRUE,CM_FIND_LEAK_TAG14));
            if (Hive->BaseBlock == NULL) {
                return (STATUS_INSUFFICIENT_RESOURCES);
            }
            Hive->BaseBlockAlloc = PAGE_SIZE;
        }
        RtlCopyMemory(Hive->BaseBlock, BaseBlock, HSECTOR_SIZE);
        Hive->BaseBlock->BootRecover = BaseBlock->BootRecover;
        Hive->BaseBlock->BootType = BaseBlock->BootType;

        Hive->Version = Hive->BaseBlock->Minor;

        Status = HvpAdjustHiveFreeDisplay(Hive,BaseBlock->Length,Stable);
        if( !NT_SUCCESS(Status) ) {
            (Hive->Free)(Hive->BaseBlock, Hive->BaseBlockAlloc);
            Hive->BaseBlock = NULL;
            return Status;
        }

        if ( !NT_SUCCESS(HvpBuildMapAndCopy(Hive,
                                            (PUCHAR)HiveData + HBLOCK_SIZE))) {

            (Hive->Free)(Hive->BaseBlock, Hive->BaseBlockAlloc);
            Hive->BaseBlock = NULL;
            return STATUS_REGISTRY_CORRUPT;
        }

        HvpFillFileName(Hive->BaseBlock, FileName);
        
      
        return(STATUS_SUCCESS);
    }

    //
    // file read case
    //
    if (OperationType == HINIT_FILE) {

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"HvInitializeHive(%wZ,HINIT_FILE) :\n", FileName));
        //
        // get the file image (possible recovered via log) into memory
        //
        Status = HvLoadHive(Hive);
        if ((Status != STATUS_SUCCESS) && (Status != STATUS_REGISTRY_RECOVERED)) {
            return Status;
        }

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"\n"));
        
        if (Status == STATUS_REGISTRY_RECOVERED) {

            //
            // We have a good hive, with a log, and a dirty map,
            // all set up.  Only problem is that we need to flush
            // the file so the log can be cleared and new writes
            // posted against the hive.  Since we know we have
            // a good log in hand, we just write the hive image.
            //
            if ( ! HvpDoWriteHive(Hive, HFILE_TYPE_PRIMARY)) {
                //
                // Clean up the bins already allocated 
                //
                HvpFreeAllocatedBins( Hive );

                return STATUS_REGISTRY_IO_FAILED;
            }

            //
            // If we get here, we have recovered the hive, and
            // written it out to disk correctly.  So we clear
            // the log here.
            //
            RtlClearAllBits(&(Hive->DirtyVector));
            Hive->DirtyCount = 0;
            (Hive->FileSetSize)(Hive, HFILE_TYPE_LOG, 0,0);
            Hive->LogSize = 0;
        }

        //
        // slam debug name data into base block
        //
        HvpFillFileName(Hive->BaseBlock, FileName);

        return STATUS_SUCCESS;
    }

    //
    // file map case
    //
    if (OperationType == HINIT_MAPFILE) {

        Hive->GetCellRoutine = HvpGetCellMapped;
        Hive->ReleaseCellRoutine = HvpReleaseCellMapped;

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"HvInitializeHive(%wZ,HINIT_MAPFILE) :\n", FileName));

        Status = HvMapHive(Hive);
        if ((Status != STATUS_SUCCESS) && (Status != STATUS_REGISTRY_RECOVERED)) {
            return Status;
        }

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"\n"));
        
        if (Status == STATUS_REGISTRY_RECOVERED) {

            //
            // We have a good hive, with a log, and a dirty map,
            // all set up.  Only problem is that we need to flush
            // the file so the log can be cleared and new writes
            // posted against the hive.  Since we know we have
            // a good log in hand, we just write the hive image.
            //
            if ( ! HvpDoWriteHive(Hive, HFILE_TYPE_PRIMARY)) {
                //
                // Clean up the bins already allocated 
                //
                HvpFreeAllocatedBins( Hive );

                return STATUS_REGISTRY_IO_FAILED;
            }

            //
            // If we get here, we have recovered the hive, and
            // written it out to disk correctly.  So we clear
            // the log here.
            //
            RtlClearAllBits(&(Hive->DirtyVector));
            Hive->DirtyCount = 0;
            (Hive->FileSetSize)(Hive, HFILE_TYPE_LOG, 0,0);
            Hive->LogSize = 0;
        }

        //
        // slam debug name data into base block
        //
        HvpFillFileName(Hive->BaseBlock, FileName);

        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

VOID
HvpFillFileName(
    PHBASE_BLOCK            BaseBlock,
    PUNICODE_STRING         FileName
    )
/*++

Routine Description:

    Zero out the filename portion of the base block.
    If FileName is not NULL, copy last 64 bytes into name tail
        field of base block

Arguments:

    BaseBlock - supplies pointer to a base block

    FileName - supplies pointer to a unicode STRING

Return Value:

    None.

--*/
{
    ULONG   offset;
    ULONG   length;
    PUCHAR  sptr;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"HvpFillFileName: %wZ\n", FileName));

    RtlZeroMemory((PVOID)&(BaseBlock->FileName[0]), HBASE_NAME_ALLOC);

    if (FileName == NULL) {
        return;
    }

    //
    // Account for 0 at the end, so we have nice debug spews
    //
    if (FileName->Length < HBASE_NAME_ALLOC) {
        offset = 0;
        length = FileName->Length;
    } else {
        offset = FileName->Length - HBASE_NAME_ALLOC + sizeof(WCHAR);
        length = HBASE_NAME_ALLOC - sizeof(WCHAR);
    }

    sptr = (PUCHAR)&(FileName->Buffer[0]);
    RtlCopyMemory(
        (PVOID)&(BaseBlock->FileName[0]),
        (PVOID)&(sptr[offset]),
        length
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\hivehint.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    hivehint.c

Abstract:

    This module contains free space display support.

--*/

#include "cmp.h"

NTSTATUS
HvpAdjustBitmap(
    IN PHHIVE               Hive,
    IN ULONG                HiveLength,
    IN OUT PFREE_DISPLAY    FreeDisplay
    );

HCELL_INDEX
HvpFindFreeCellInBin(
    PHHIVE          Hive,
    ULONG           Index,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type,
    PHBIN           Bin
    );

HCELL_INDEX
HvpFindFreeCellInThisViewWindow(
    PHHIVE          Hive,
    ULONG           Index,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type,
    HCELL_INDEX     Vicinity 
    );

HCELL_INDEX
HvpScanForFreeCellInViewWindow(
    PHHIVE          Hive,
    ULONG           Index,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type,
    HCELL_INDEX     FileOffsetStart
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HvpAdjustHiveFreeDisplay)
#pragma alloc_text(PAGE,HvpFreeHiveFreeDisplay)
#pragma alloc_text(PAGE,HvpAdjustBitmap)
#pragma alloc_text(PAGE,HvpAddFreeCellHint)
#pragma alloc_text(PAGE,HvpRemoveFreeCellHint)
#pragma alloc_text(PAGE,HvpFindFreeCellInBin)
#pragma alloc_text(PAGE,HvpFindFreeCellInThisViewWindow)
#pragma alloc_text(PAGE,HvpScanForFreeCellInViewWindow)
#pragma alloc_text(PAGE,HvpCheckViewBoundary)
#pragma alloc_text(PAGE,HvpFindFreeCell)
#endif

NTSTATUS
HvpAdjustHiveFreeDisplay(
    IN PHHIVE           Hive,
    IN ULONG            HiveLength,
    IN HSTORAGE_TYPE    Type
    )
/*++

Routine Description:

    calls HvpAdjustBitmap for all bitmap sizes 

    !!! - to be called when the size of the hive changes (shrink or grow case).

Arguments:

    Hive - used for quota tracking.

    HiveLength - the new length of the hive.
    
    Type - Stable or Volatile.

Return Value:

    NTSTATUS code.

--*/
{
    ULONG       i;
    NTSTATUS    Status;

    CM_PAGED_CODE();

    for (i = 0; i < HHIVE_FREE_DISPLAY_SIZE; i++) {
        Status = HvpAdjustBitmap(Hive,HiveLength,&(Hive->Storage[Type].FreeDisplay[i]) );
        if( !NT_SUCCESS(Status) ){
            return Status;
        }
    }
    
    return STATUS_SUCCESS;
}

#define ROUND_UP_NOZERO(a, b)   (a)?ROUND_UP(a,b):(b)
#define ROUND_INCREMENTS        0x100

VOID
HvpFreeHiveFreeDisplay(
    IN PHHIVE           Hive
    )
/*++

Routine Description:

    Frees the storage allocated for the free display bitmaps

Arguments:

    Hive - used for quota tracking.

Return Value:

    NTSTATUS code.

--*/
{
    ULONG       i,j;

    CM_PAGED_CODE();

    for( i=Stable;i<=Volatile;i++) {
        for (j = 0; j < HHIVE_FREE_DISPLAY_SIZE; j++) {
            if( Hive->Storage[i].FreeDisplay[j].Display.Buffer != NULL ) {
                ASSERT( Hive->Storage[i].FreeDisplay[j].RealVectorSize );
                (Hive->Free)(Hive->Storage[i].FreeDisplay[j].Display.Buffer, 
                             Hive->Storage[i].FreeDisplay[j].RealVectorSize);
                RtlInitializeBitMap(&(Hive->Storage[i].FreeDisplay[j].Display), NULL, 0);
                Hive->Storage[i].FreeDisplay[j].RealVectorSize = 0;
            }
        }
    }
    
    return;
}

NTSTATUS
HvpAdjustBitmap(
    IN PHHIVE               Hive,
    IN ULONG                HiveLength,
    IN OUT PFREE_DISPLAY    FreeDisplay
    )
/*++

Routine Description:

    When the length of the hive grows/shrinks, adjust the bitmap accordingly.
    - allocates a bitmap buffer large enough.
    - copies the relevant information from the old bitmap.

Arguments:

    Hive - used for quota tracking.

    HiveLength - the new length of the hive.
    
    Bitmap - bitmap to operate on.

Return Value:

    NTSTATUS code.

--*/
{
    ULONG       VectorSize;
    ULONG       NewBufferSize;
    ULONG       OldBufferSize;
    PULONG      Vector;
    PULONG      OldVector;
    ULONG       OldVectorSize;
    PRTL_BITMAP Bitmap;

    CM_PAGED_CODE();

    Bitmap = &(FreeDisplay->Display);

    VectorSize = HiveLength / HBLOCK_SIZE;  // Vector size == bits

    NewBufferSize = ROUND_UP_NOZERO( (VectorSize + 7) / 8,ROUND_INCREMENTS);             // BufferSize == Bytes

    if( Bitmap->SizeOfBitMap == 0 ) {
        OldBufferSize = 0;
    } else {
        OldBufferSize = ROUND_UP_NOZERO( (Bitmap->SizeOfBitMap + 7) / 8, ROUND_INCREMENTS);
    }
    
    if( NewBufferSize <= FreeDisplay->RealVectorSize ) {
        //
        // We don't shrink the vector; next time we grow, we'll perform 
        // the adjustments
        //


        //
        // Clear all the unused bits and return;
        //
        // we don't really need to do this as nobody will write in here
        // we'll drop it in the final implementation
        //
        OldVectorSize = Bitmap->SizeOfBitMap;
        //
        // set the new size
        //
        RtlInitializeBitMap(Bitmap,Bitmap->Buffer,VectorSize);
        if( OldVectorSize < VectorSize ) {
            RtlClearBits (Bitmap,OldVectorSize,VectorSize - OldVectorSize);
        }
        return STATUS_SUCCESS;
    }
    //
    // else, the bitmap has enlarged. Allocate a new buffer and copy the bits already set.
    //
    Vector = (PULONG)((Hive->Allocate)(NewBufferSize, TRUE,CM_FIND_LEAK_TAG39));
    if (Vector == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    FreeDisplay->RealVectorSize = NewBufferSize;

    OldVector = Bitmap->Buffer;
    RtlZeroMemory(Vector,NewBufferSize);
    RtlInitializeBitMap(Bitmap, Vector, VectorSize);

    if( OldVector != NULL ) {
        //
        // copy the already set bits
        //
        RtlCopyMemory (Vector,OldVector,OldBufferSize);

        //
        // Free the old vector
        //
        (Hive->Free)(OldVector, OldBufferSize);
    }

    return STATUS_SUCCESS;
}

VOID
HvpAddFreeCellHint(
    PHHIVE          Hive,
    HCELL_INDEX     Cell,
    ULONG           Index,
    HSTORAGE_TYPE   Type
    )
/*++

Routine Description:

    Sets the corresponding bit in the bitmap

Arguments:

    Hive - hive operating on

    Cell - free cell
    
    Index - index in FreeDisplay (based on the free cell size)

    Type - storage type (Stable or Volatile)

Return Value:

    VOID

--*/
{
    ULONG           BinIndex;
    PHMAP_ENTRY     Me;
    PHBIN           Bin;

    CM_PAGED_CODE();

    ASSERT_HIVE_WRITER_LOCK_OWNED((PCMHIVE)Hive);
    ASSERT_HIVE_FLUSHER_LOCKED((PCMHIVE)Hive);

    Me = HvpGetCellMap(Hive, Cell);
    VALIDATE_CELL_MAP(__LINE__,Me,Hive,Cell);

    Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
    //
    // compute the bin index and for the beginning of the bin
    //
    BinIndex = Bin->FileOffset / HBLOCK_SIZE;
    
    RtlSetBits (&(Hive->Storage[Type].FreeDisplay[Index].Display), BinIndex, Bin->Size / HBLOCK_SIZE);

    Hive->Storage[Type].FreeSummary |= (1 << Index);
}

VOID
HvpRemoveFreeCellHint(
    PHHIVE          Hive,
    HCELL_INDEX     Cell,
    ULONG           Index,
    HSTORAGE_TYPE   Type
    )
/*++

Routine Description:

    Clears the corresponding bit in the bitmap

Arguments:

    Hive - hive operating on

    Cell - free cell
    
    Index - index in FreeDisplay (based on the free cell size)

    Type - storage type (Stable or Volatile)

Return Value:

    VOID

--*/
{
    ULONG           BinIndex;
    ULONG           TempIndex;
    PHMAP_ENTRY     Me;
    PHBIN           Bin;
    ULONG           CellOffset;
    ULONG           Size;
    PHCELL          p;
    BOOLEAN         CellFound = FALSE;

    CM_PAGED_CODE();

    ASSERT_HIVE_WRITER_LOCK_OWNED((PCMHIVE)Hive);
    ASSERT_HIVE_FLUSHER_LOCKED((PCMHIVE)Hive);

    Me = HvpGetCellMap(Hive, Cell);
    VALIDATE_CELL_MAP(__LINE__,Me,Hive,Cell);

    Bin = (PHBIN)HBIN_BASE(Me->BinAddress);

    CellOffset = Bin->FileOffset + sizeof(HBIN);

    
    //
    // we ned to be protected against exception raised by the FS while faulting in data
    //
    try {

        //
        // There is a chance we can find a suitable free cell
        //

        p = (PHCELL)((PUCHAR)Bin + sizeof(HBIN));

        while (p < (PHCELL)((PUCHAR)Bin + Bin->Size)) {

            //
            // if free cell, check it out, add it to free list for hive
            //
            if (p->Size >= 0) {

                Size = (ULONG)p->Size;

                HvpComputeIndex(TempIndex, Size);
                if ((Index == TempIndex) && (CellOffset != (Cell&(~HCELL_TYPE_MASK)) )) {
                    //
                    // there is at least one free cell of this size (this one)
                    // different than the one being delisted
                    //
                    CellFound = TRUE;
                    break;
                }

            } else {
                //
                // used cell
                //
                Size = (ULONG)(p->Size * -1);

            }

            ASSERT( ((LONG)Size) >= 0);
            p = (PHCELL)((PUCHAR)p + Size);
            CellOffset += Size;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpRemoveFreeCellHint: exception thrown ehile faulting in data, code:%08lx\n", GetExceptionCode()));
        //
        // better not use cells in this range rather than leaving false hints
        //
        CellFound = FALSE;
    }
    
    if( CellFound == FALSE ) {
        //
        // no cell with this index was found
        // compute the bin index and for the beginning of the bin
        //
        BinIndex = Bin->FileOffset / HBLOCK_SIZE;
    
        RtlClearBits (&(Hive->Storage[Type].FreeDisplay[Index].Display), BinIndex, Bin->Size / HBLOCK_SIZE);
    }

    if( RtlNumberOfSetBits(&(Hive->Storage[Type].FreeDisplay[Index].Display) ) != 0 ) {
        //
        // there are still some other free cells of this size
        //
        Hive->Storage[Type].FreeSummary |= (1 << Index);
    } else {
        //
        // entire bitmap is 0 (i.e. no other free cells of this size)
        //
        Hive->Storage[Type].FreeSummary &= (~(1 << Index));
    }
}

HCELL_INDEX
HvpFindFreeCellInBin(
    PHHIVE          Hive,
    ULONG           Index,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type,
    PHBIN           Bin 
    )
/*++

Routine Description:

    Lookup for a free cell with the size NewSize in this particular bin

Arguments:

    Hive - target hive.

    Index - index in FreeDisplay (based on the free cell size)

    NewSize - desired size

    Type - storage type (Stable or Volatile)

    Bin - Bin in question

Return Value:

    A free cellindex with a size bigger than NewSize, or HCELL_NIL

--*/
{

    ULONG           BinIndex;
    ULONG           CellOffset;
    PHCELL          p;
    ULONG           BinOffset;
    ULONG           Size;
    HCELL_INDEX     cellindex;
    ULONG           FoundCellIndex;

    CM_PAGED_CODE();

    ASSERT_HIVE_WRITER_LOCK_OWNED((PCMHIVE)Hive);

    BinOffset = Bin->FileOffset;
    BinIndex = BinOffset/HBLOCK_SIZE;

    if( RtlCheckBit(&(Hive->Storage[Type].FreeDisplay[Index].Display), BinIndex) == 0 ) {
        //
        // no hint for this bin
        //
        return HCELL_NIL;
    }

    CellOffset = sizeof(HBIN);
    
    //
    // we ned to be protected against exception raised by the FS while faulting in data
    //
    try {

        //
        // There is a chance we can find a suitable free cell
        //
        p = (PHCELL)((PUCHAR)Bin + sizeof(HBIN));

        while (p < (PHCELL)((PUCHAR)Bin + Bin->Size)) {

            //
            // if free cell, check it out, add it to free list for hive
            //
            if (p->Size >= 0) {

                Size = (ULONG)p->Size;

                //
                // cell is free, and is not obviously corrupt, add to free list
                //
                CellOffset = (ULONG)((PUCHAR)p - (PUCHAR)Bin);
                cellindex = BinOffset + CellOffset + (Type*HCELL_TYPE_MASK);

                if (NewSize <= (ULONG)Size) {
                    //
                    // Found a big enough cell.
                    //
                    HvpComputeIndex(FoundCellIndex, Size);
                    if( Index == FoundCellIndex ) {
                        //
                        // and enlisted at the same index (we want to avoid fragmentation if possible!)
                        //

                        if (! HvMarkCellDirty(Hive, cellindex,TRUE)) {
                            return HCELL_NIL;
                        }

                        HvpDelistFreeCell(Hive, cellindex, Type);

                        ASSERT(p->Size > 0);
                        ASSERT(NewSize <= (ULONG)p->Size);
                        return cellindex;
                    }
                }

            } else {
                //
                // used cell
                //
                Size = (ULONG)(p->Size * -1);

            }

            ASSERT( ((LONG)Size) >= 0);
            p = (PHCELL)((PUCHAR)p + Size);
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpFindFreeCellInBin: exception thrown ehile faulting in data, code:%08lx\n", GetExceptionCode()));
        return HCELL_NIL;
    }

    //
    // no free cell matching this size on this bin ; We did all this work for nothing!
    //
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FREECELL,"[HvpFindFreeCellInBin] (Offset,Size) = (%lx,%lx) ==> No Match\n",BinOffset,Bin->Size));
    return HCELL_NIL;
}

HCELL_INDEX
HvpScanForFreeCellInViewWindow(
    PHHIVE          Hive,
    ULONG           Index,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type,
    HCELL_INDEX     FileOffsetStart
    )
/*++

Routine Description:

    Lookup for a free cell with the size NewSize in the CM_VIEW_SIZE window defined by
    Vicinity. 

    If it doesn't find a free cell for the specifed index, tries with the 


Arguments:

    Hive - target hive.

    Index - index in FreeDisplay (based on the free cell size)

    NewSize - desired size

    Type - storage type (Stable or Volatile)

    Vicinity - defines the window; it is never HCELL_NIL !!!

Return Value:

    A free cellindex with a size bigger than NewSize, or HCELL_NIL

Note:

    Vicinity is a physical file offset at this point. we need to 
    convert it to a logical one prior to accessing the map
--*/
{
    ULONG           FileOffsetEnd;
    HCELL_INDEX     Cell;
    PHMAP_ENTRY     Me;
    PHBIN           Bin;
    PFREE_HBIN      FreeBin;
    ULONG           BinFileOffset;
    ULONG           BinSize;
    PCM_VIEW_OF_FILE    CmView;

    CM_PAGED_CODE();

    FileOffsetEnd = FileOffsetStart + CM_VIEW_SIZE;
    FileOffsetEnd -= HBLOCK_SIZE;
    if( FileOffsetStart != 0 ) {
        FileOffsetStart -= HBLOCK_SIZE;
    }
    if( FileOffsetEnd > Hive->Storage[Type].Length ) {
        FileOffsetEnd = Hive->Storage[Type].Length;
    }

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FREECELL,"\t[HvpScanForFreeCellInViewWindow] (Start,End) = (%lx,%lx) Size = %lx\n",FileOffsetStart,FileOffsetEnd,Hive->Storage[Type].Length));

    //
    // sanity ASSERT
    //
    ASSERT( FileOffsetStart < FileOffsetEnd );


    //
    // the caller already checked for this; remember, hints are for real!
    //
    ASSERT( !RtlAreBitsClear( &(Hive->Storage[Type].FreeDisplay[Index].Display),
                                FileOffsetStart/HBLOCK_SIZE,(FileOffsetEnd - FileOffsetStart) / HBLOCK_SIZE) );
    
    while( FileOffsetStart < FileOffsetEnd ) {
        Cell = FileOffsetStart + (Type*HCELL_TYPE_MASK);
        Me = HvpGetCellMap(Hive, Cell);
        VALIDATE_CELL_MAP(__LINE__,Me,Hive,Cell);
        CmView = NULL;

        //
        // skip discarded bins
        //
        if(Me->BinAddress & HMAP_DISCARDABLE) {
            FreeBin = (PFREE_HBIN)Me->BlockAddress;
            if( FreeBin->FileOffset == FileOffsetStart ) {
                FileOffsetStart += FreeBin->Size;
            } else {
                //
                // the bin does not start in this window;
                // skip to the next bin in this window
                //
                FileOffsetStart = FreeBin->FileOffset + FreeBin->Size;
            }
            continue;
        }

        //
        // this will add a reference on the view so it doesn't get away from under us.
        //
        CmLockHiveViews(Hive);
        if((Me->BinAddress & (HMAP_INVIEW|HMAP_INPAGEDPOOL)) == 0) {
            //
            // bin is not mapped, map it now!!!
            // do not touch the view as we may iterate through 
            // the hole hive; this will keep the view for this window
            // mapped, as we hold the registry lock exclusive
            //
            if( !NT_SUCCESS(CmpMapThisBin((PCMHIVE)Hive,Cell,FALSE)) ) {
                //
                // cannot map bin due to insufficient resources
                //
                CmUnlockHiveViews(Hive);
                return HCELL_NIL;
            }
            ASSERT( Me->BinAddress & HMAP_INVIEW );
            ASSERT( Me->CmView != NULL );
            //
            // this will prevent the view from going away while we are working on the bin
            //
            CmpReferenceHiveView((PCMHIVE)Hive,(CmView = Me->CmView));
        }
        CmUnlockHiveViews(Hive);

        Bin = (PHBIN)HBIN_BASE(Me->BinAddress);

        //
        // we need to protect against in-page-errors thrown by mm while faulting in data
        //
        try {
        BinFileOffset = Bin->FileOffset;
        BinSize = Bin->Size;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpScanForFreeCellInViewWindow: exception thrown while faulting in data, code:%08lx\n", GetExceptionCode()));
            CmpDereferenceHiveViewWithLock((PCMHIVE)Hive,CmView);
            return HCELL_NIL;
        }

        if( BinFileOffset == FileOffsetStart ) {

            Cell = HvpFindFreeCellInBin(Hive,Index,NewSize,Type,Bin);
            if( Cell != HCELL_NIL ) {
                //found it!
                CmpDereferenceHiveViewWithLock((PCMHIVE)Hive,CmView);
                return Cell;
            }
                
            FileOffsetStart += BinSize;
        } else {
            //
            // bin does not start in this CM_VIEW_SIZE window; skip to the next bin in this window
            //
            FileOffsetStart = BinFileOffset + BinSize;
        }
        CmpDereferenceHiveViewWithLock((PCMHIVE)Hive,CmView);
    }

    //
    // no free cell matching this size on the CM_VIEW_SIZE window ; We did all this work for nothing!
    //
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FREECELL,"[HvpScanForFreeCellInViewWindow] (Start,End) = (%lx,%lx) ==> No Match\n",FileOffsetStart,FileOffsetEnd));
    return HCELL_NIL;
}

HCELL_INDEX
HvpFindFreeCellInThisViewWindow(
    PHHIVE          Hive,
    ULONG           Index,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type,
    HCELL_INDEX     Vicinity
    )
/*++

Routine Description:

    Lookup for a free cell with the size NewSize in the window defined by
    Vicinity. 

    If it doesn't find a free cell for the specifed index, tries with the 


Arguments:

    Hive - target hive.

    Index - index in FreeDisplay (based on the free cell size)

    NewSize - desired size

    Type - storage type (Stable or Volatile)

    Vicinity - defines the window; it is never HCELL_NIL !!!

Return Value:

    A free cellindex with a size bigger than NewSize, or HCELL_NIL

Note:

    Vicinity is a logical file offset at this point. This function
    converts it to a physical one, and HvpScanForFindFreeCellInViewWindow
    converts it back to logical prior to getting the cell map.

--*/
{
    HCELL_INDEX     Cell;
    ULONG           FileOffsetStart;
    ULONG           FileOffsetEnd;
    ULONG           VicinityViewOffset;
    ULONG           Summary;
    ULONG           Offset;
    ULONG           RunLength;

    CM_PAGED_CODE();

    ASSERT( Vicinity != HCELL_NIL );

    VicinityViewOffset = ((Vicinity&(~HCELL_TYPE_MASK)) + HBLOCK_SIZE) & (~(CM_VIEW_SIZE - 1));
    FileOffsetStart = VicinityViewOffset & (~(CM_VIEW_SIZE - 1));

    FileOffsetEnd = FileOffsetStart + CM_VIEW_SIZE;
    if( FileOffsetEnd > (Hive->Storage[Type].Length + HBLOCK_SIZE) ) {
        FileOffsetEnd = Hive->Storage[Type].Length + HBLOCK_SIZE;
    }

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FREECELL,"[HvpFindFreeCellInThisViewWindow] Vicinity = %lx (Start,End) = (%lx,%lx) Size = %lx\n",Vicinity,FileOffsetStart,FileOffsetEnd,Hive->Storage[Type].Length));

    //
    // sanity assert
    //
    ASSERT( FileOffsetStart < FileOffsetEnd );
    
    //
    // at this point the offset is physical (file-oriented, i.e. it is
    // translated with HBLOCK_SIZE; HvpScanForFreeCellInViewWindow will do the 
    // reverse computation to adjust the offset)
    //

    //
    // Compute Summary vector of Display entries that are non null
    //
    Summary = Hive->Storage[Type].FreeSummary;
    Summary = Summary & ~((1 << Index) - 1);
    //
    // We now have a summary of lists that are non-null and may
    // contain entries large enough to satisfy the request.
    // Iterate through the list and pull the first cell that is
    // big enough.  If no cells are big enough, advance to the
    // next non-null list.
    //
    ASSERT(HHIVE_FREE_DISPLAY_SIZE == 24);

    Offset = FileOffsetStart?(FileOffsetStart-HBLOCK_SIZE):0;
    RunLength = FileOffsetEnd - FileOffsetStart;
    if( FileOffsetStart == 0 ) {
        //
        // first run is one block shorter !
        //
        RunLength -= HBLOCK_SIZE;
    }
    Offset /= HBLOCK_SIZE;
    RunLength /= HBLOCK_SIZE;

    while (Summary != 0) {
        if (Summary & 0xff) {
            Index = CmpFindFirstSetRight[Summary & 0xff];
        } else if (Summary & 0xff00) {
            Index = CmpFindFirstSetRight[(Summary & 0xff00) >> 8] + 8;
        } else  {
            ASSERT(Summary & 0xff0000);
            Index = CmpFindFirstSetRight[(Summary & 0xff0000) >> 16] + 16;
        }

        //
        // we go down this path only if we have any hints
        //
        if( !RtlAreBitsClear( &(Hive->Storage[Type].FreeDisplay[Index].Display),Offset,RunLength) ) {

            //
            // we have a reason to scan this view
            //
            Cell = HvpScanForFreeCellInViewWindow(Hive,Index,NewSize,Type,VicinityViewOffset);
            if( Cell != HCELL_NIL ) {
                // found it
                return Cell;
            }

            //
            // if we got here, the hints are invalid
            //
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FREECELL,"[HvpFindFreeCellInThisViewWindow] (Start,End) = (%lx,%lx) Offset = %lx RunLength = %lx\n",FileOffsetStart,FileOffsetEnd,Offset,RunLength));

        }
        //
        // No suitable cell was found of this size.
        // Clear the bit in the summary and try the
        // next biggest size
        //
        ASSERT(Summary & (1 << Index));
        Summary = Summary & ~(1 << Index);
    }
    
    return HCELL_NIL;
}

HCELL_INDEX
HvpFindFreeCell(
    PHHIVE          Hive,
    ULONG           Index,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type,
    HCELL_INDEX     Vicinity 
    )
/*++

Routine Description:

    Lookup for a free cell. First try is in the CM_VIEW_SIZE window defined 
    by Vicinity. If no free cell is found in this window (or vicinity 
    if NIL), entire hive is searched (window by window).

Arguments:

    Hive - target hive.

    Index - index in FreeDisplay (based on the free cell size)

    NewSize - desired size

    Type - storage type (Stable or Volatile)

    Vicinity - defines the window.

Return Value:

    A free cellindex with a size bigger than NewSize, or HCELL_NIL

Optimization:

    When Vicinity is HCELL_NIL or if a cell is not found in the same window
    as the vicinity, we don't really care where the cell gets allocated.
    So, rather than iterating the whole hive, is a good idea to search first 
    in the pinned view list, then in the mapped view list, and at the end
    in the rest of unmapped views.

--*/
{
    HCELL_INDEX         Cell = HCELL_NIL;
    ULONG               FileOffset = 0;
    PCMHIVE             CmHive;

    CM_PAGED_CODE();

    CmHive = (PCMHIVE)CONTAINING_RECORD(Hive, CMHIVE, Hive);

    ASSERT_HIVE_WRITER_LOCK_OWNED(CmHive);
    ASSERT_HIVE_FLUSHER_LOCKED(CmHive);
#if DBG
    {
        UNICODE_STRING  HiveName;
        RtlInitUnicodeString(&HiveName, (PCWSTR)Hive->BaseBlock->FileName);
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FREECELL,"[HvpFindFreeCell] CellSize = %lu Vicinity = %lx :: Hive (%p) (%.*S)  ...",NewSize,Vicinity,Hive,HiveName.Length / sizeof(WCHAR),HiveName.Buffer));
    }
#endif

    //
    // Vicinity should have the same storage as the new cell !
    //
    ASSERT( (Vicinity == HCELL_NIL) || (HvGetCellType(Vicinity) == (ULONG)Type) );
    
    //
    // we have the lock exclusive or nobody is operating inside this hive
    //
    ASSERT_HIVE_WRITER_LOCK_OWNED((PCMHIVE)Hive);

    if( (Vicinity != HCELL_NIL) &&  (CmHive->GrowOnlyMode == FALSE) ) {
        //
        // try first in this window
        //
        Cell = HvpFindFreeCellInThisViewWindow(Hive,Index,NewSize,Type,Vicinity);
    }

    if( Cell != HCELL_NIL ) {
        //
        // found it!!!
        //
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FREECELL,"found cell %lx \n",Cell));
        return Cell;
    } 

    //
    // We have to search the entire hive
    //

    while( FileOffset < Hive->Storage[Type].Length ) {
        //
        // don't search again in the vicinity window
        // we already did it once
        //
		if( ( ((CmHive->GrowOnlyMode == FALSE) || (Type == Volatile)) && 
			  ((Vicinity == HCELL_NIL) || (HvpCheckViewBoundary(FileOffset,Vicinity&(~HCELL_TYPE_MASK)) == FALSE)) )  || 
            ( (CmHive->GrowOnlyMode == TRUE) && (FileOffset >= CmHive->GrowOffset) )
          ) {
            //
            // search in this window
            //
            Cell = FileOffset + (Type*HCELL_TYPE_MASK);
            Cell = HvpFindFreeCellInThisViewWindow(Hive,Index,NewSize,Type,Cell);
            if( Cell != HCELL_NIL ) {
                //
                // found it!
                //
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FREECELL,"found cell %lx \n",Cell));
                return Cell;
            }
        }
        
        //
        // advance to the new window
        //
        if( FileOffset == 0) {
            // account for the base block
            FileOffset += (CM_VIEW_SIZE - HBLOCK_SIZE);
        } else {
            FileOffset += CM_VIEW_SIZE;
        }
    }

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FREECELL,"No cell found.\n"));

    return HCELL_NIL;
}


BOOLEAN
HvpCheckViewBoundary(
                     IN ULONG Start,
                     IN ULONG End
    )
/*++

Routine Description:

    Checks if addresses are in the same CM_VIEW_SIZE boundary.
    We may convert this function to a macro for performance 
    reasons

Arguments:

    Start - starting address

    End - ending address

Return Value:

    TRUE - yes, addresses are in the same view

    FALSE - no, addresses are NOT in the same view

--*/
{
    CM_PAGED_CODE();
    //
    // account for the header
    //
    Start += HBLOCK_SIZE;
    End += HBLOCK_SIZE;
    
    //
    // truncate to the CM_VIEW_SIZE segment
    //
    Start &= (~(CM_VIEW_SIZE - 1));
    End &= (~(CM_VIEW_SIZE - 1));

    if( Start != End ){
        return FALSE;
    } 
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\hivesync.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    hivesync.c

Abstract:

    This module implements procedures to write dirty parts of a hive's
    stable store to backing media.

--*/

#include    "cmp.h"

#define ONE_K   1024

extern  BOOLEAN HvShutdownComplete;     // Set to true after shutdown
                                        // to disable any further I/O


extern	BOOLEAN CmpDontGrowLogFile;

extern  PUCHAR      CmpStashBuffer;
extern  ULONG       CmpStashBufferSize;
extern  BOOLEAN     CmpFlushOnLockRelease;
extern  LONG        CmRegistryLogSizeLimit;
extern HIVE_LIST_ENTRY CmpMachineHiveList[];

VOID
CmpFreeCmView (
        PCM_VIEW_OF_FILE  CmView
                             );

VOID
CmpUnmapCmViewSurroundingOffset(
        IN  PCMHIVE             CmHive,
        IN  ULONG               FileOffset
        );

#if DBG
#define DumpDirtyVector(BitMap)                                         \
        {                                                               \
            ULONG BitMapSize;                                           \
            PUCHAR BitBuffer;                                           \
            ULONG i;                                                    \
            UCHAR Byte;                                                 \
                                                                        \
            BitMapSize = ((BitMap)->SizeOfBitMap) / 8;                    \
            BitBuffer = (PUCHAR)((BitMap)->Buffer);                       \
            for (i = 0; i < BitMapSize; i++) {                          \
                if ((i % 8) == 0) {                                     \
                    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"\n\t");                                  \
                }                                                       \
                Byte = BitBuffer[i];                                    \
                DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"%02x ", Byte);                               \
            }                                                           \
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"\n");                                            \
        }
#else
#define DumpDirtyVector(BitMap)
#endif

//
// Private prototypes
//

BOOLEAN
HvpFindNextDirtyBlock(
    PHHIVE          Hive,
    PRTL_BITMAP     BitMap,
    PULONG          Current,
    PUCHAR          *Address,
    PULONG          Length,
    PULONG          Offset
    );

VOID
HvpTruncateBins(
    PHHIVE  Hive
    );

VOID
HvRefreshHive(
    PHHIVE  Hive
    );

VOID
HvpFlushMappedData(
    IN PHHIVE           Hive,
    IN OUT PRTL_BITMAP  DirtyVector
    );

VOID
CmpUnmapCmView(
    IN PCMHIVE              CmHive,
    IN PCM_VIEW_OF_FILE     CmView,
    IN BOOLEAN              MapIsValid,
    IN BOOLEAN              MoveToEnd
    );

VOID
CmpLogError(IN NTSTATUS         NtStatusCode);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HvMarkCellDirty)

#if DBG
#pragma alloc_text(PAGE,HvIsCellDirty)
#endif //DBG

#pragma alloc_text(PAGE,HvMarkDirty)
#pragma alloc_text(PAGE,HvpGrowLog1)
#pragma alloc_text(PAGE,HvpGrowLog2)
#pragma alloc_text(PAGE,HvSyncHive)
#pragma alloc_text(PAGE,HvpDoWriteHive)
#pragma alloc_text(PAGE,HvpWriteLog)
#pragma alloc_text(PAGE,HvpFindNextDirtyBlock)
#pragma alloc_text(PAGE,HvWriteHive)
#pragma alloc_text(PAGE,HvRefreshHive)
#pragma alloc_text(PAGE,HvHiveWillShrink)
#pragma alloc_text(PAGE,HvpTruncateBins)
#pragma alloc_text(PAGE,HvpDropPagedBins)
#pragma alloc_text(PAGE,HvpDropAllPagedBins)
#pragma alloc_text(PAGE,HvpFlushMappedData)
#endif

BOOLEAN
HvMarkCellDirty(
    PHHIVE      Hive,
    HCELL_INDEX Cell,
    BOOLEAN     LockHeld
    )
/*++

Routine Description:

    Marks the data for the specified cell dirty.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - hcell_index of cell that is being edited

Return Value:

    TRUE - it worked

    FALSE - could not allocate log space, failure!

--*/
{
    ULONG       Type;
    ULONG       Size;
    PHCELL      pCell;
    PHMAP_ENTRY Me;
    HCELL_INDEX Base;
    PHBIN       Bin;
    PCMHIVE     CmHive;
#if DBG
    ULONG       DirtyCount;
#endif
    BOOLEAN     Result;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"HvMarkCellDirty:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"Hive:%p Cell:%08lx\n", Hive, Cell));

    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Hive->ReadOnly == FALSE);
    //
    // we have the lock exclusive or nobody is operating inside this hive
    //
    ASSERT_HIVE_FLUSHER_LOCKED((PCMHIVE)Hive);

    Type = HvGetCellType(Cell);
    CmHive = (PCMHIVE)Hive;

    if ( (Hive->HiveFlags & HIVE_VOLATILE) ||
         (Type == Volatile) )
    {
        return TRUE;
    }

    if( !LockHeld ) {
        // no two guys in here at the same time for the same hive
        CmpLockHiveWriter(CmHive);
    }

#if DBG
    DirtyCount = RtlNumberOfSetBits(&Hive->DirtyVector);
    ASSERT(DirtyCount == Hive->DirtyCount);
#endif

    //
    // this call will make sure the view containing the bin is maped in the system cache
    //
    pCell = HvpGetHCell(Hive,Cell);
    if( pCell == NULL ) {
        //
        // we couldn't map view for this cell
        // we will fail to make the cell dirty.
        //
        if( !LockHeld ) {
            CmpUnlockHiveWriter(CmHive);
        }
        return FALSE;
    }
    

    Me = HvpGetCellMap(Hive, Cell);
    VALIDATE_CELL_MAP(__LINE__,Me,Hive,Cell);
#if DBG
    Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
    ASSERT(Bin->Signature == HBIN_SIGNATURE);
#endif

    CmLockHiveViews(Hive);
    if( Me->BinAddress & HMAP_INVIEW ) {
        //
        // bin is mapped. Pin the view into memory
        //
        ASSERT( Me->CmView != NULL );

        if( IsListEmpty(&(Me->CmView->PinViewList)) == TRUE ) {
            //
            // the view is not already pinned.  pin it
            //
            ASSERT_VIEW_MAPPED( Me->CmView );
            if( !NT_SUCCESS(CmpPinCmView ((PCMHIVE)CmHive,Me->CmView)) ) {
                //
                // couldn't pin view- some obscure error down in CcPinMappedData;
                // this will be treated as STATUS_NO_LOG_SPACE
                //
                CmUnlockHiveViews(Hive);
                if( !LockHeld ) {
                    CmpUnlockHiveWriter(CmHive);
                }
                HvReleaseCell(Hive,Cell);
                return FALSE;
            }
        } else {
            //
            // view is already pinned; do nothing
            //
            ASSERT_VIEW_PINNED( Me->CmView );
        }
    }
    CmUnlockHiveViews(Hive);

    HvReleaseCell(Hive,Cell);
    //
    // If it's an old format hive, mark the entire
    // bin dirty, because the Last backpointers are
    // such a pain to deal with in the partial
    // alloc and free-coalescing cases.
    //

    if (USE_OLD_CELL(Hive)) {
        Me = HvpGetCellMap(Hive, Cell);
        VALIDATE_CELL_MAP(__LINE__,Me,Hive,Cell);
        Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
        Base = Bin->FileOffset;
        Size = Bin->Size;
        Result = HvMarkDirty(Hive, Base, Size,FALSE);
    } else {
        if (pCell->Size < 0) {
            Size = -pCell->Size;
        } else {
            Size = pCell->Size;
        }
        ASSERT(Size < Bin->Size);
        Result = HvMarkDirty(Hive, Cell-FIELD_OFFSET(HCELL,u.NewCell), Size,FALSE);
    }
    if( !LockHeld ) {
        CmpUnlockHiveWriter(CmHive);
    }
    if( Result ) {
        Hive->DirtyFlag = TRUE;
    }

    return Result;
}

BOOLEAN
HvMarkDirty(
    PHHIVE      Hive,
    HCELL_INDEX Start,
    ULONG       Length,
    BOOLEAN     DirtyAndPin
    )
/*++

Routine Description:

    Marks the relevant parts of a hive dirty, so that they will
    be flushed to backing store.

    If Hive->Cluster is not 1, then adjacent all logical sectors
    in the given cluster will be forced dirty (and log space
    allocated for them.)  This must be done here rather than in
    HvSyncHive so that we can know how much to grow the log.

    This is a noop for Volatile address range.

    NOTE:   Range will not be marked dirty if operation fails.

    ATTENTION:  This routine assumes that no more than a bin is marked 
                dirty at the time.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Start - supplies a hive virtual address (i.e., an HCELL_INDEX or
             like form address) of the start of the area to mark dirty.

    Length - inclusive length in bytes of area to mark dirty.

    DirtyAndPin - indicates whether we should also pin the bin marked as dirty in memory


Return Value:

    TRUE - it worked

    FALSE - could not allocate log space, failure!

--*/
{
    ULONG       Type;
    PRTL_BITMAP BitMap;
    ULONG       First;
    ULONG       Last;
    ULONG       EndOfFile;
    ULONG       i;
    ULONG       Cluster;
    ULONG       OriginalDirtyCount;
    ULONG       DirtySectors;
    BOOLEAN     Result = TRUE;
    PHMAP_ENTRY Map;
    ULONG       AdjustedFirst;
    ULONG       AdjustedLast;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"HvMarkDirty:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"Hive:%p Start:%08lx Length:%08lx\n", Hive, Start, Length));


    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Hive->ReadOnly == FALSE);
    ASSERT(Hive->DirtyCount == RtlNumberOfSetBits(&Hive->DirtyVector));

    Type = HvGetCellType(Start);

    if ( (Hive->HiveFlags & HIVE_VOLATILE) ||
         (Type == Volatile) )
    {
        return TRUE;
    }

    ASSERT_HIVE_WRITER_LOCK_OWNED((PCMHIVE)Hive);
    ASSERT_HIVE_FLUSHER_LOCKED((PCMHIVE)Hive);

    BitMap = &(Hive->DirtyVector);
    OriginalDirtyCount = Hive->DirtyCount;

    if( (DirtyAndPin == TRUE) && (((PCMHIVE)Hive)->FileObject != NULL) ) {
        Map = HvpGetCellMap(Hive, Start);
        VALIDATE_CELL_MAP(__LINE__,Map,Hive,Start);

        CmLockHiveViews(Hive);
        if( (Map->BinAddress & (HMAP_INPAGEDPOOL|HMAP_INVIEW)) == 0){
            PCM_VIEW_OF_FILE CmView;
            //
            // bin is neither in paged pool, nor in a mapped view
            //
            if( !NT_SUCCESS (CmpMapCmView((PCMHIVE)Hive,Start,&CmView,TRUE) ) ) {
                CmUnlockHiveViews(Hive);
                return FALSE;
            }
            
#if DBG            
            if(CmView != Map->CmView) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"CmView = %p Map->CmView = %p\n",CmView,Map->CmView));
            }
#endif
            ASSERT( CmView == Map->CmView );
            
        }

        if( Map->BinAddress & HMAP_INVIEW ) {
            //
            // bin is mapped. Pin the view into memory
            //
            ASSERT( Map->CmView != NULL );

            if( IsListEmpty(&(Map->CmView->PinViewList)) == TRUE ) {
                //
                // the view is not already pinned.  pin it
                //
                ASSERT_VIEW_MAPPED( Map->CmView );
                if( !NT_SUCCESS(CmpPinCmView ((PCMHIVE)Hive,Map->CmView)) ) {
                    //
                    // couldn't pin view- some obscure error down in CcPinMappedData;
                    // this will be treated as STATUS_NO_LOG_SPACE
                    //
                    CmUnlockHiveViews(Hive);
                    return FALSE;
                }
            } else {
                //
                // view is already pinned; do nothing
                //
                ASSERT_VIEW_PINNED( Map->CmView );
            }
        }
        CmUnlockHiveViews(Hive);
    }

    AdjustedFirst = First = Start / HSECTOR_SIZE;
    AdjustedLast = Last = (Start + Length - 1) / HSECTOR_SIZE;

    Cluster = Hive->Cluster;
    if (Cluster > 1) {

        //
        // Force Start down to base of cluster
        // Force End up to top of cluster
        //
        AdjustedFirst = AdjustedFirst & ~(Cluster - 1);
        AdjustedLast = ROUND_UP(AdjustedLast+1, Cluster) - 1;
    }

    //
    // we need to mark all page(s) dirty, so we don't conflict with cache manager
    //
    ASSERT( PAGE_SIZE >= HSECTOR_SIZE );
    ASSERT( (PAGE_SIZE % HSECTOR_SIZE) == 0 );
    
    //
    // adjust the range to fit an entire page
    // make sure we account for the first HBLOCK at the beginning of the hive
    //
    AdjustedFirst = (AdjustedFirst + HSECTOR_COUNT) & ~(HSECTOR_PER_PAGE_COUNT - 1);
    AdjustedLast = ROUND_UP(AdjustedLast + HSECTOR_COUNT + 1, HSECTOR_PER_PAGE_COUNT) - 1;
    
    AdjustedLast -= HSECTOR_COUNT;
    if( AdjustedFirst ) {
        AdjustedFirst -= HSECTOR_COUNT;
    }
    //
    // when the PAGE_SIZE > HBLOCK_SIZE and the length of the hive does not round at PAGE_SIZE boundary
    //
    EndOfFile = Hive->Storage[Stable].Length / HSECTOR_SIZE;
    if (AdjustedLast >= EndOfFile) {
        AdjustedLast = EndOfFile-1;
    }

    //
    // make sure that between first and last all bins are valid (either pinned
    // or allocated from paged pool).
    //
    ASSERT( First >= AdjustedFirst );
    ASSERT( Last <= AdjustedLast );

    //
    // adjust First and Last at HBLOCK_SIZE boundaries
    //
    First = First & ~(HSECTOR_COUNT - 1);
    Last = ROUND_UP(Last+1, HSECTOR_COUNT) - 1;

    //
    // sanity asserts; these prove we can skip HSECTOR_COUNT at one time below 
    //
    ASSERT( First >= AdjustedFirst );
    ASSERT( Last <= AdjustedLast );
    ASSERT( (First % HSECTOR_COUNT) == 0 );
    ASSERT( (AdjustedFirst % HSECTOR_COUNT) == 0 );
    ASSERT( ((Last+1) % HSECTOR_COUNT) == 0 );
    ASSERT( ((AdjustedLast +1) % HSECTOR_COUNT) == 0 );
    ASSERT( ((First - AdjustedFirst) % HSECTOR_COUNT) == 0 );
    ASSERT( ((AdjustedLast - Last) % HSECTOR_COUNT) == 0 );

    //
    // when we exit this loop; First is always a valid bin/sector
    //
    while( First > AdjustedFirst ) {
        //
        // map-in this address, and if is valid, decrement First, else break out of the loop
        //
        First -= HSECTOR_COUNT;
        Map = HvpGetCellMap(Hive, First*HSECTOR_SIZE);
        if( BIN_MAP_ALLOCATION_TYPE(Map) == 0 ) {
            //
            // bin is not valid! bail out.
            //
            First += HSECTOR_COUNT;
            break;
        }
        CmLockHiveViews(Hive);
        if( Map->BinAddress & HMAP_INVIEW ) {
            //
            // previous bin mapped in view ==> view needs to be pinned
            //
            ASSERT( Map->CmView );
            if( IsListEmpty(&(Map->CmView->PinViewList) ) == TRUE ) {
                //
                // bin not pinned. bail out.
                //
                First += HSECTOR_COUNT;
                CmUnlockHiveViews(Hive);
                break;
            }
        }
        CmUnlockHiveViews(Hive);
    }

    //
    // when we exit this loop; Last is always a valid bin/sector
    //
    while( Last < AdjustedLast ) {
        //
        // map-in this address, and if is valid, increment Last, else break out of the loop
        //
        Last += HSECTOR_COUNT;
        Map = HvpGetCellMap(Hive, Last*HSECTOR_SIZE);
        if( BIN_MAP_ALLOCATION_TYPE(Map) == 0 ) {
            //
            // bin is not valid. bail out.
            //
            Last -= HSECTOR_COUNT;
            break;
        }
        CmLockHiveViews(Hive);
        if( Map->BinAddress & HMAP_INVIEW ) {
            //
            // previous bin mapped in view ==> view needs to be pinned
            //
            ASSERT( Map->CmView );
            if( IsListEmpty(&(Map->CmView->PinViewList) ) == TRUE ) {
                //
                // bin not pinned. bail out.
                //
                Last -= HSECTOR_COUNT;
                CmUnlockHiveViews(Hive);
                break;
            }
        }
        CmUnlockHiveViews(Hive);
    }

    //
    // Try and grow the log enough to accommodate all the dirty sectors.
    //
    DirtySectors = 0;
    for (i = First; i <= Last; i++) {
        if (RtlCheckBit(BitMap, i)==0) {
            ++DirtySectors;
        }
    }
    if (DirtySectors != 0) {
        if (HvpGrowLog1(Hive, DirtySectors) == FALSE) {
            return(FALSE);
        }
    
        if ((OriginalDirtyCount == 0) && (First != 0)) {
            Result = HvMarkDirty(Hive, 0, sizeof(HBIN),TRUE);  // force header of 1st bin dirty
            if (Result==FALSE) {
                return(FALSE);
            }
        }
    
        //
        // Log has been successfully grown, go ahead
        // and set the dirty bits.
        //
        ASSERT(Hive->DirtyCount == RtlNumberOfSetBits(&Hive->DirtyVector));
        ASSERT( First <= Last );
        if( First <= Last ) {
            Hive->DirtyCount += DirtySectors;
            RtlSetBits(BitMap, First, Last-First+1);
        }
    }

    // mark this bin as writable
    HvpMarkBinReadWrite(Hive,Start);
        
    if (!(Hive->HiveFlags & HIVE_NOLAZYFLUSH)) {
        CmpLazyFlush();
    }

    ASSERT(Hive->DirtyCount == RtlNumberOfSetBits(&Hive->DirtyVector));
    return(TRUE);
}

BOOLEAN
HvpGrowLog1(
    PHHIVE  Hive,
    ULONG   Count
    )
/*++

Routine Description:

    Adjust the log for growth in the number of sectors of dirty
    data that are desired.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Count - number of additional logical sectors of log space needed

Return Value:

    TRUE - it worked

    FALSE - could not allocate log space, failure!

--*/
{
    ULONG   ClusterSize;
    ULONG   RequiredSize;
    ULONG   tmp;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"HvpGrowLog1:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"Hive:%p Count:%08lx\n", Hive, Count));

    ASSERT(Hive->ReadOnly == FALSE);
    ASSERT(Hive->DirtyCount == RtlNumberOfSetBits(&Hive->DirtyVector));

    //
    // If logging is off, tell caller world is OK.
    //
    if( (Hive->Log == FALSE) || CmpDontGrowLogFile) {
        return TRUE;
    }

    ClusterSize = Hive->Cluster * HSECTOR_SIZE;

    tmp = Hive->DirtyVector.SizeOfBitMap / 8;   // bytes
    tmp += sizeof(ULONG);                       // signature

    RequiredSize =
        ClusterSize  +                                  // 1 cluster for header
        ROUND_UP(tmp, ClusterSize) +
        ((Hive->DirtyCount + Count) * HSECTOR_SIZE);

    RequiredSize = ROUND_UP(RequiredSize, HLOG_GROW);

    ASSERT(Hive->DirtyCount == RtlNumberOfSetBits(&Hive->DirtyVector));

    if ( ! (Hive->FileSetSize)(Hive, HFILE_TYPE_LOG, RequiredSize,Hive->LogSize)) {
        return FALSE;
    }

    if( CmRegistryLogSizeLimit > 0 ) {
        //
        // see if log is too big and set flush on lock release
        //
        ASSERT_HIVE_FLUSHER_LOCKED((PCMHIVE)Hive);

        if( RequiredSize >= (ULONG)(CmRegistryLogSizeLimit * ONE_K) ) {
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"LogFile for hive %p is %lx; will flush upon lock release\n",Hive,RequiredSize);
            CmpFlushOnLockRelease = TRUE;
        }
    }

    Hive->LogSize = RequiredSize;
    ASSERT(Hive->DirtyCount == RtlNumberOfSetBits(&Hive->DirtyVector));
    return TRUE;
}


VOID
HvRefreshHive(
    PHHIVE  Hive
    )
/*++

Routine Description:

    Undo the last sync.  
    
    The story behind the scene:

    1. remove all discardable bins from FreeBins list. they'll be 
        enlisted afterwards with the right (accurate) values.
    2. read the base block, and eventually free the tail of the hive
    3. unpin and purge all pinned views; also clear the free cell
        hint for mapped bins.
    4. remap views purged at 3 and reenlist the bins inside. this 
        will fix free bins discarded at 1.
    5. iterate through the map; read and reenlist all bins that are 
        in paged-pool (and dirty)

      
    All I/O is done via HFILE_TYPE_PRIMARY.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest.

Return Value:

    NONE. Either works or BugChecks.

Comments:

    In the new implementation, bins are not discarded anymore. Step 1.
    above is not needed anymore.
    
    Discardable bins with FREE_HBIN_DISCARDABLE flag set fall into one 
    of the categories:
    1. new bins (at the end of the hive) which didn't get a chance to 
    be saved yet. HvFreeHivePartial will take care of them.
    2. bins inside the hive allocated from paged pool and discarded.
    This can only happen for bins that are crossing the CM_VIEW_SIZE boundary.
    We will take care of them at step 5

    Discardable bins with FREE_HBIN_DISCARDABLE flag NOT set are free bins
    which came from mapped views. Step 3 will remove them from the FreeBins 
    list and step 4 will reenlist the ones that are still free after remapping

--*/
{
    HCELL_INDEX         RootCell;
    PCM_KEY_NODE        RootNode;
    HCELL_INDEX         LinkCell;
    PFREE_HBIN          FreeBin;
    ULONG               Offset;
    ULONG               FileOffset;
    PCM_VIEW_OF_FILE    CmView;
    PCMHIVE             CmHive;
    ULONG               FileOffsetStart;
    ULONG               FileOffsetEnd;
    PHMAP_ENTRY         Me;
    ULONG               i;
    PHBIN               Bin;
    ULONG               BinSize;
    ULONG               Current;
    PRTL_BITMAP         BitMap;
    PUCHAR              Address;
    BOOLEAN             rc;
    ULONG               ReadLength;
    HCELL_INDEX         p;
    PHMAP_ENTRY         t;
    ULONG               checkstatus;
    ULONG               OldFileLength;
    LIST_ENTRY          PinViewListHead;
    ULONG               Size;
    LARGE_INTEGER       PurgeOffset;
    
    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

    //
    // noop or assert on various uninteresting or bogus conditions
    //
    if (Hive->DirtyCount == 0) {
        return;
    }
    ASSERT(Hive->HiveFlags & HIVE_NOLAZYFLUSH);
    ASSERT(Hive->Storage[Volatile].Length == 0);

    //
    // be sure the hive is not already trash
    //
    checkstatus = HvCheckHive(Hive, NULL);
    if (checkstatus != 0) {
        CM_BUGCHECK(REGISTRY_ERROR,REFRESH_HIVE,1,Hive,checkstatus);
    }

    // store it for the shrink/grow at the end.
    OldFileLength = Hive->Storage[Stable].Length + HBLOCK_SIZE;
    //
    // Capture the LinkCell backpointer in the hive's root cell. We need this in case
    // the first bin is overwritten with what was on disk.
    //
    RootCell = Hive->BaseBlock->RootCell;
    RootNode = (PCM_KEY_NODE)HvGetCell(Hive, RootCell);
    if( RootNode == NULL ) {
        //
        // we couldn't map a view for this cell
        // we're low on resources, so we couldn't refresh the hive.
        //
        return;
    }

    // release the cell here as we are holding the reglock exclusive
    HvReleaseCell(Hive,RootCell);

    LinkCell = RootNode->Parent;

    Hive->RefreshCount++;    


    // 
    // 1. Remove all discardable bins from FreeBins list
    //    - remove the discardable flag from the ones that 
    //      have not yet been discarded 
    //    - for discarded ones, just remove the marker from 
    //      the FreeBins list            
    //
    //

    // Any bins that have been marked as discardable, but not yet flushed to
    // disk, are going to be overwritten with old data.  Bring them back into
    // memory and remove their FREE_HBIN marker from the list. Other bins are 
    // either discarded, or mapped into views
    //

        // not needed anymore...

    //
    // 2. read the base block, and eventually free the tail of the hive
    //
    LOCK_STASH_BUFFER();
    if( CmpStashBufferSize < HBLOCK_SIZE ) {
        PUCHAR TempBuffer =  ExAllocatePoolWithTag(PagedPool, ROUND_UP(HBLOCK_SIZE,PAGE_SIZE),CM_STASHBUFFER_TAG);
        if (TempBuffer == NULL) {
            UNLOCK_STASH_BUFFER();
            return;
        }
        if( CmpStashBuffer != NULL ) {
            ExFreePool( CmpStashBuffer );
        }
        CmpStashBuffer = TempBuffer;
        CmpStashBufferSize = ROUND_UP(HBLOCK_SIZE,PAGE_SIZE);

    }

    //
    // OverRead base block.
    //
    Offset = 0;
    if ( (Hive->FileRead)(
            Hive,
            HFILE_TYPE_PRIMARY,
            &Offset,
            CmpStashBuffer,
            HBLOCK_SIZE
            ) != TRUE)
    {
        UNLOCK_STASH_BUFFER();
        return;
    }

    //
    // RootCell cannot be changed through a refresh operation
    // 
    if( RootCell != ((PHBASE_BLOCK)CmpStashBuffer)->RootCell ) {
        UNLOCK_STASH_BUFFER();
        return;
    }
    RtlCopyMemory(Hive->BaseBlock,CmpStashBuffer,HBLOCK_SIZE);
    UNLOCK_STASH_BUFFER();


    //
    // only adjust if the hive is shrinking
    //
    if( Hive->BaseBlock->Length < Hive->Storage[Stable].Length ) {
        HCELL_INDEX         TailStart;
        ULONG               Start;
        ULONG               End;
        ULONG               BitLength;

        TailStart = (HCELL_INDEX)(Hive->BaseBlock->Length);
        //
        // Free "tail" memory and maps for it, update hive size pointers
        //
        HvFreeHivePartial(Hive, TailStart, Stable);

        //
        // Clear dirty vector for data past Hive->BaseBlock->Length
        //
        Start = Hive->BaseBlock->Length / HSECTOR_SIZE;
        End = Hive->DirtyVector.SizeOfBitMap;
        BitLength = End - Start;

        RtlClearBits(&(Hive->DirtyVector), Start, BitLength);

    }    
    
    HvpAdjustHiveFreeDisplay(Hive,Hive->BaseBlock->Length,Stable);

    //
    // 3. unpin and purge all pinned views; also clear the free cell
    //  hint for mapped bins.
    //
    CmHive = (PCMHIVE)Hive;

    InitializeListHead(&PinViewListHead);
    //
    // for each pinned view
    //
    while(IsListEmpty(&(CmHive->PinViewListHead)) == FALSE) {
        //
        // Remove the first view from the pin view list
        //
        CmView = (PCM_VIEW_OF_FILE)RemoveHeadList(&(CmHive->PinViewListHead));
        CmView = CONTAINING_RECORD( CmView,
                                    CM_VIEW_OF_FILE,
                                    PinViewList);
        
        //
        // the real file offset starts after the header
        // 
        FileOffsetStart = CmView->FileOffset;
        FileOffsetEnd = FileOffsetStart + CmView->Size;
        
        FileOffsetEnd -= HBLOCK_SIZE;

        if( FileOffsetStart != 0 ) {
            //
            // just at the beginning of the file, subtract the header
            //
            FileOffsetStart -= HBLOCK_SIZE;
        } 
        
        FileOffset = FileOffsetStart;

        //
        // now, for every block in this range which is mapped in view
        // clear the dirty bit, and the free cell hint
        //
        while(FileOffset < FileOffsetEnd) {
            Me = HvpGetCellMap(Hive, FileOffset);
            VALIDATE_CELL_MAP(__LINE__,Me,Hive,FileOffset);
            Bin = (PHBIN)HBIN_BASE(Me->BinAddress);

            //
            // ignore the bins loaded into paged pool; we'll deal with them later on
            //
            if( Me->BinAddress & HMAP_INVIEW ) {
                if( Me->BinAddress & HMAP_DISCARDABLE ) {
                    FreeBin = (PFREE_HBIN)Me->BlockAddress;
                    
                    // free bins comming from mapped views are not discardable
                    ASSERT( (FreeBin->Flags & FREE_HBIN_DISCARDABLE) == 0 );

                    //
                    // go and clear the discardable flag for all blocks of this bin
                    //
                    for( i=FileOffset;i<FileOffset+FreeBin->Size;i+=HBLOCK_SIZE) {
                        Me = HvpGetCellMap(Hive, i);
                        VALIDATE_CELL_MAP(__LINE__,Me,Hive,i);
                        Me->BinAddress &= ~HMAP_DISCARDABLE;
                    }

                    //
                    // get rid of the entry from FreeBins list
                    // it'll be added again after sync is done if bin is still 
                    // discardable
                    //
                    FreeBin = (PFREE_HBIN)Me->BlockAddress;
                    ASSERT(FreeBin->FileOffset == FileOffset);
                    RemoveEntryList(&FreeBin->ListEntry);
                    BinSize = FreeBin->Size;

                    (Hive->Free)(FreeBin, sizeof(FREE_HBIN));

                } else {
                    //
                    // bin is mapped in view. Then, this should be the beginning of the bin
                    //
                    ASSERT(Bin->Signature == HBIN_SIGNATURE);
                    ASSERT(Bin->FileOffset == FileOffset);


                    BinSize = Bin->Size;
                }
                //
                // clear of the dirty bits for this bin
                //
                RtlClearBits(&Hive->DirtyVector,FileOffset/HSECTOR_SIZE,BinSize/HSECTOR_SIZE);

                //
                // now clear the free cell hint for this bin
                //
                for( i=0;i<HHIVE_FREE_DISPLAY_SIZE;i++) {
    
                    RtlClearBits (&(Hive->Storage[Stable].FreeDisplay[i].Display), FileOffset / HBLOCK_SIZE, BinSize / HBLOCK_SIZE);

                    if( RtlNumberOfSetBits(&(Hive->Storage[Stable].FreeDisplay[i].Display) ) != 0 ) {
                        //
                        // there are still some other free cells of this size
                        //
                        Hive->Storage[Stable].FreeSummary |= (1 << i);
                    } else {
                        //
                        // entire bitmap is 0 (i.e. no other free cells of this size)
                        //
                        Hive->Storage[Stable].FreeSummary &= (~(1 << i));
                    }
                }
            } else {
                //
                // bin in paged pool
                //
                ASSERT( Me->BinAddress & HMAP_INPAGEDPOOL );
                if( Me->BinAddress & HMAP_DISCARDABLE ) {

                    FreeBin = (PFREE_HBIN)Me->BlockAddress;
                    ASSERT(FreeBin->FileOffset == FileOffset);
                    BinSize = FreeBin->Size;
                } else {
                    //
                    // Then, this should be the beginning of the bin
                    //
                    ASSERT(Bin->Signature == HBIN_SIGNATURE);
                    ASSERT(Bin->FileOffset == FileOffset);

                    BinSize = Bin->Size;
                }
            }

            FileOffset += BinSize;

        } // while (FileOffset<FileOffsetEnd)
        
        //
        // Just unmap the view, without marking the data dirty; We'll flush cache after we finish 
        // unpinning and unmapping all necessary views
        //
        ASSERT( CmView->UseCount == 0 );

        // store this for later
        FileOffset = CmView->FileOffset;
        Size = CmView->Size;

        CmpUnmapCmView (CmHive,CmView,TRUE,TRUE);

        //
        // we use the PinViewList member of these views to keep track of all pinned 
        // views that need to be remapped after the purge
        //
        InsertTailList(
            &PinViewListHead,
            &(CmView->PinViewList)
            );

        //
        // remove the view from the LRU list
        //
        RemoveEntryList(&(CmView->LRUViewList));

        //
        // store the FileOffset and address so we know what to map afterwards
        //
        CmView->FileOffset = FileOffset;
        CmView->Size = Size;

        //
        // now we need to make sure the 256K window surrounding this offset is not 
        // mapped in any way
        //
        FileOffset = FileOffset & (~(_256K - 1));
        Size = FileOffset + _256K;
        Size = (Size > OldFileLength)?OldFileLength:Size;

        //
        // we are not allowed to purge in shared mode.
        //

        while( FileOffset < Size ) {
            CmpUnmapCmViewSurroundingOffset((PCMHIVE)Hive,FileOffset);
            FileOffset += CM_VIEW_SIZE;
        }

    } // while IsListEmpty(&(CmHive->PinViewListHead))

    //
    // Now we need to purge the the previously pinned views
    //
    PurgeOffset.HighPart = 0;
    CmView = (PCM_VIEW_OF_FILE)PinViewListHead.Flink;
    while( CmHive->PinnedViews ) {
        ASSERT( CmView != (PCM_VIEW_OF_FILE)(&(PinViewListHead)) );

        CmView = CONTAINING_RECORD( CmView,
                                    CM_VIEW_OF_FILE,
                                    PinViewList);
        //
        // now purge as a private writer
        //
        PurgeOffset.LowPart = CmView->FileOffset;
        CcPurgeCacheSection(CmHive->FileObject->SectionObjectPointer,(PLARGE_INTEGER)(((ULONG_PTR)(&PurgeOffset)) + 1)/*we are private writers*/,
                                    CmView->Size,FALSE);
        //
        // advance to the next view
        //
        CmView = (PCM_VIEW_OF_FILE)(CmView->PinViewList.Flink);
        CmHive->PinnedViews--;
    }
    
    ASSERT( ((PCMHIVE)CmHive)->PinnedViews == 0 );

    //
    // 4.remap views purged at 3 and reenlist the bins inside. this 
    // will fix free bins discarded at 1.
    //
    while(IsListEmpty(&PinViewListHead) == FALSE) {
        //
        // Remove the first view from the pin view list
        //
        CmView = (PCM_VIEW_OF_FILE)RemoveHeadList(&PinViewListHead);
        CmView = CONTAINING_RECORD( CmView,
                                    CM_VIEW_OF_FILE,
                                    PinViewList);
        
        //
        // the real file offset starts after the header
        // 
        FileOffsetStart = CmView->FileOffset;
        FileOffsetEnd = FileOffsetStart + CmView->Size;
        
        FileOffsetEnd -= HBLOCK_SIZE;

        if( FileOffsetStart != 0 ) {
            //
            // just at the beginning of the file, subtract the header
            //
            FileOffsetStart -= HBLOCK_SIZE;
        } 
        if( FileOffsetEnd > Hive->BaseBlock->Length ) {
            FileOffsetEnd = Hive->BaseBlock->Length;
        }

        //
        // be sure to free this view as nobody is using it anymore
        //
#if DBG
        CmView->FileOffset = CmView->Size = 0;
        InitializeListHead(&(CmView->PinViewList));
        InitializeListHead(&(CmView->LRUViewList));
#endif
        CmpFreeCmView (CmView);

        if( FileOffsetStart >= FileOffsetEnd ) {
            continue;
        }

        //
        // remap it with the right data
        //
        if( !NT_SUCCESS(CmpMapCmView(CmHive,FileOffsetStart,&CmView,TRUE) ) ) {
            //
            // this is bad. We have altered the hive and now we have no way of restoring it
            // bugcheck!
            //
            CM_BUGCHECK(REGISTRY_ERROR,REFRESH_HIVE,3,CmHive,FileOffsetStart);
        }

        //
        // touch the view
        //
        CmpTouchView((PCMHIVE)Hive,CmView,FileOffsetStart);

        FileOffset = FileOffsetStart;

        while(FileOffset < FileOffsetEnd) {
            Me = HvpGetCellMap(Hive, FileOffset);
            VALIDATE_CELL_MAP(__LINE__,Me,Hive,FileOffset);
            Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
            
            //
            // ignore paged bins
            //
            if( Me->BinAddress & HMAP_INVIEW ) {
                ASSERT(Bin->Signature == HBIN_SIGNATURE);
                ASSERT(Bin->FileOffset == FileOffset);

                // enlisting freecells will fix the free bins problem too
                if ( ! HvpEnlistFreeCells(Hive, Bin, Bin->FileOffset) ) {
                    CM_BUGCHECK(REGISTRY_ERROR,REFRESH_HIVE,4,Bin,Bin->FileOffset);
                }
                FileOffset += Bin->Size;
            } else {
                FileOffset += HBLOCK_SIZE;            
            }
        }

    } // while (IsListEmpty(&PinViewListHead))
    
    // 5. iterate through the map; read and reenlist all bins that are 
    //   in paged-pool (and dirty)

    //
    // Scan dirty blocks.  Read contiguous blocks off disk into hive.
    // Stop when we get to reduced length.
    //
    BitMap = &(Hive->DirtyVector);
    Current = 0;
    while (HvpFindNextDirtyBlock(
                Hive,
                &Hive->DirtyVector,
                &Current, &Address,
                &ReadLength,
                &Offset
                ))
    {
        ASSERT(Offset < (Hive->BaseBlock->Length + sizeof(HBASE_BLOCK)));
        rc = (Hive->FileRead)(
                Hive,
                HFILE_TYPE_PRIMARY,
                &Offset,
                (PVOID)Address,
                ReadLength
                );
        if (rc == FALSE) {
            CM_BUGCHECK(REGISTRY_ERROR,REFRESH_HIVE,5,Offset,Address);
        }
    }

    //
    // If we read the start of any HBINs into memory, it is likely
    // their MemAlloc fields are invalid.  Walk through the HBINs
    // and write valid MemAlloc values for any HBINs whose first
    // sector was reread.
    //
    // HvpFindNextDirtyBlock knows how to deal with free bins. If we 
    // reread a free bin, we need to delist it from the list first and 
    // reenlist it again (it may not be free on the disk)
    //

    p=0;
    while (p < Hive->Storage[Stable].Length) {
        t = HvpGetCellMap(Hive, p);
        VALIDATE_CELL_MAP(__LINE__,t,Hive,p);
        Bin = (PHBIN)HBIN_BASE(t->BlockAddress);

        if (RtlCheckBit(&Hive->DirtyVector, p / HSECTOR_SIZE)==1) {
        
            if ((t->BinAddress & HMAP_DISCARDABLE) != 0) {
                //
                // this was a free bin. It may not be a free bin on the disk
                //
                FreeBin = (PFREE_HBIN)t->BlockAddress;

                // free bins comming from paged pool are always discardable
                ASSERT( FreeBin->Flags & FREE_HBIN_DISCARDABLE );

                // if the bin has been discarded since the last save, all bin should be dirty!!!
                ASSERT(FreeBin->FileOffset == p);

                //
                // go and clear the discardable flag for all blocks of this bin
                //
                for( i=0;i<FreeBin->Size;i+=HBLOCK_SIZE) {
                    Me = HvpGetCellMap(Hive, p + i);
                    VALIDATE_CELL_MAP(__LINE__,Me,Hive,p+i);
                    Me->BlockAddress = HBIN_BASE(Me->BinAddress)+i;
                    Me->BinAddress &= ~HMAP_DISCARDABLE;
                }
                Bin = (PHBIN)HBIN_BASE(t->BlockAddress);
                //
                // get rid of the entry from FreeBins list
                // it'll be added again after sync is done if bin is still 
                // discardable
                //
                RemoveEntryList(&FreeBin->ListEntry);
                (Hive->Free)(FreeBin, sizeof(FREE_HBIN));

            }
            //
            // only paged bins should be dirty at this time
            //
            ASSERT( t->BinAddress & HMAP_INPAGEDPOOL );

            //
            // The first sector in the HBIN is dirty.
            //
            // Reset the BinAddress to the Block address to cover
            // the case where a few smaller bins have been coalesced
            // into a larger bin. We want the smaller bins back now.
            //
            t->BinAddress = HBIN_FLAGS(t->BinAddress) | t->BlockAddress;

            // Check the map to see if this is the start
            // of a memory allocation or not.
            //

            if (t->BinAddress & HMAP_NEWALLOC) {
                //
                // Walk through the map to determine the length
                // of the allocation.
                //
                PULONG BinAlloc = &(t->MemAlloc);
                *BinAlloc = 0;

                do {
                    t = HvpGetCellMap(Hive, p + (*BinAlloc) + HBLOCK_SIZE);
                    (*BinAlloc) += HBLOCK_SIZE;
                    if (p + (*BinAlloc) == Hive->Storage[Stable].Length) {
                        //
                        // Reached the end of the hive.
                        //
                        break;
                    }
                    VALIDATE_CELL_MAP(__LINE__,t,Hive,p + (*BinAlloc));
                } while ( (t->BinAddress & HMAP_NEWALLOC) == 0);

                //
                // this will reenlist the bin if free
                //
                if ( ! HvpEnlistFreeCells(Hive, Bin, Bin->FileOffset)) {
                    CM_BUGCHECK(REGISTRY_ERROR,REFRESH_HIVE,6,Bin,Bin->FileOffset);
                }
            } else {
                t->MemAlloc = 0;
            }

            RtlClearBits(&Hive->DirtyVector,Bin->FileOffset/HSECTOR_SIZE,Bin->Size/HSECTOR_SIZE);
            p = Bin->FileOffset + Bin->Size;
            
        } else {
            //
            // we do that to avoid touching bins that may not be mapped
            //
            p += HBLOCK_SIZE;
        }

    }

    //
    // be sure we haven't filled memory with trash
    //
    checkstatus = HvCheckHive(Hive, NULL);
    if (checkstatus != 0) {
        CM_BUGCHECK(REGISTRY_ERROR,REFRESH_HIVE,7,Hive,checkstatus);
    }

    //
    // Finally we need to rewrite the parent field in the root hcell. This is
    // patched in at hive load time so the correct value could have just been
    // overwritten with whatever happened to be on disk.
    //
    RootNode = (PCM_KEY_NODE)HvGetCell(Hive, RootCell);
    if( RootNode == NULL ) {
        //
        // we couldn't map a view for this cell
        // there is nothing we can do here, other than pray for this not to happen
        //
        CM_BUGCHECK(REGISTRY_ERROR,REFRESH_HIVE,8,Hive,RootCell);
        return;
    }

    // release the cell here as we are holding the reglock exclusive
    HvReleaseCell(Hive,RootCell);

    RootNode->Parent = LinkCell;
    RootNode->Flags |= KEY_HIVE_ENTRY | KEY_NO_DELETE;


    //
    // all bits in the dirty vector should be clean by now
    //
    ASSERT( RtlNumberOfSetBits( &(Hive->DirtyVector) ) == 0 );
    Hive->DirtyCount = 0;

    //
    // Adjust the file size, if this fails, ignore it, since it just
    // means the file is too big. Do it here, where we are sure we have 
    // no pinned data whatsoever.
    //
    (Hive->FileSetSize)(
        Hive,
        HFILE_TYPE_PRIMARY,
        (Hive->BaseBlock->Length + HBLOCK_SIZE),
        OldFileLength
        );

    //
    // be sure there are no security cells thrown away in the cache
    //
    if( !CmpRebuildSecurityCache((PCMHIVE)Hive) ) {
        CM_BUGCHECK(REGISTRY_ERROR,REFRESH_HIVE,9,Hive,0);
    }

    //
    // be sure the structure of the thing is OK after all this
    //
    checkstatus = CmCheckRegistry((PCMHIVE)Hive, CM_CHECK_REGISTRY_FORCE_CLEAN);
    if (checkstatus != 0) {
        CM_BUGCHECK(REGISTRY_ERROR,REFRESH_HIVE,10,Hive,checkstatus);
    }

    return;
}

#if DBG
BOOLEAN
HvIsCellDirty(
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell
    )

/*++

Routine Description:

    Given a hive and a cell, checks whether the corresponding sector
    is marked as dirty. 

    NOTE: This function assumes the view containing the bin is 
    mapped into system space.

Arguments:

    Hive - Supplies a pointer to the hive control structure

    Cell - Supplies the HCELL_INDEX of the Cell.

Return Value:

    TRUE - Data is marked as dirty.

    FALSE - Data is NOT marked as dirty.

--*/

{
    ULONG       Type;
    PRTL_BITMAP Bitmap;
    ULONG       Offset;
    BOOLEAN     Result;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"HvIsCellDirty:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"Hive:%p Cell:%08lx\n", Hive, Cell));

    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Hive->ReadOnly == FALSE);

    Type = HvGetCellType(Cell);

    if ( (Hive->HiveFlags & HIVE_VOLATILE) ||
         (Type == Volatile) )
    {
        //
        // we don't care as we are never going to save this data
        //
        return TRUE;
    }

    // no two guys in here at the same time for the same hive
    CmpLockHiveWriter((PCMHIVE)Hive);

    Bitmap = &(Hive->DirtyVector);

    Offset = Cell / HSECTOR_SIZE;

    Result = (RtlCheckBit(Bitmap, Offset) == 1) ? TRUE : FALSE;

    CmpUnlockHiveWriter((PCMHIVE)Hive);

    return Result;
}
#endif

BOOLEAN
HvpGrowLog2(
    PHHIVE  Hive,
    ULONG   Size
    )
/*++

Routine Description:

    Adjust the log for growth in the size of the hive, in particular,
    account for the increased space needed for a bigger dirty vector.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Size - proposed growth in size in bytes.

Return Value:

    TRUE - it worked

    FALSE - could not allocate log space, failure!

--*/
{
    ULONG   ClusterSize;
    ULONG   RequiredSize;
    ULONG   DirtyBytes;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"HvpGrowLog2:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"Hive:%p Size:%08lx\n", Hive, Size));

    ASSERT(Hive->ReadOnly == FALSE);
    ASSERT(Hive->DirtyCount == RtlNumberOfSetBits(&Hive->DirtyVector));


    //
    // If logging is off, tell caller world is OK.
    //
    if (Hive->Log == FALSE) {
        return TRUE;
    }

    ASSERT( (Size % HSECTOR_SIZE) == 0 );

    ClusterSize = Hive->Cluster * HSECTOR_SIZE;

    ASSERT( (((Hive->Storage[Stable].Length + Size) / HSECTOR_SIZE) % 8) == 0);

    DirtyBytes = (Hive->DirtyVector.SizeOfBitMap / 8) +
                    ((Size / HSECTOR_SIZE) / 8) +
                    sizeof(ULONG);                      // signature
    DirtyBytes = ROUND_UP(DirtyBytes, ClusterSize);

    RequiredSize =
        ClusterSize  +                                  // 1 cluster for header
        (Hive->DirtyCount * HSECTOR_SIZE) +
        DirtyBytes;

    RequiredSize = ROUND_UP(RequiredSize, HLOG_GROW);

    ASSERT(Hive->DirtyCount == RtlNumberOfSetBits(&Hive->DirtyVector));

    if ( ! (Hive->FileSetSize)(Hive, HFILE_TYPE_LOG, RequiredSize,Hive->LogSize)) {
        return FALSE;
    }

    if( CmRegistryLogSizeLimit > 0 ) {
        //
        // see if log is too big and set flush on lock release
        //
        ASSERT_HIVE_FLUSHER_LOCKED((PCMHIVE)Hive);

        if( RequiredSize >= (ULONG)(CmRegistryLogSizeLimit * ONE_K) ) {
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"LogFile for hive %p is %lx; will flush upon lock release\n",Hive,RequiredSize);
            CmpFlushOnLockRelease = TRUE;;
        }
    }

    Hive->LogSize = RequiredSize;
    ASSERT(Hive->DirtyCount == RtlNumberOfSetBits(&Hive->DirtyVector));
    return TRUE;
}

BOOLEAN
HvSyncHive(
    PHHIVE  Hive
    )
/*++

Routine Description:

    Force backing store to match the memory image of the Stable
    part of the hive's space.

    Logs, primary, and alternate data can be written.  Primary is
    always written.  Normally either a log or an alternate, but
    not both, will also be written.

    It is possible to write only the primary.

    All dirty bits will be set clear.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

Return Value:

    TRUE - it worked

    FALSE - some failure.

--*/
{
    BOOLEAN oldFlag;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"HvSyncHive:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"Hive:%p\n", Hive));

    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Hive->ReadOnly == FALSE);

    //
    // Punt if post shutdown
    //
    if (HvShutdownComplete) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"HvSyncHive:  Attempt to sync AFTER SHUTDOWN\n"));
        return FALSE;
    }

    //
    // If nothing dirty, do nothing
    //
    if (Hive->DirtyCount == 0) {
        return TRUE;
    }

    //
    // Discard the write(s) to system hives if needed
    //
    if (CmpMiniNTBoot) {        
        ULONG Index;
        PCMHIVE CurrentHive = (PCMHIVE)Hive;
        BOOLEAN SkipWrite = FALSE;
        
        for (Index = 0; Index < CM_NUMBER_OF_MACHINE_HIVES; Index++) {
            if ((CmpMachineHiveList[Index].Name != NULL) &&
                ((CmpMachineHiveList[Index].CmHive == CurrentHive) ||
                 (CmpMachineHiveList[Index].CmHive2 == CurrentHive))) {
                SkipWrite = TRUE;                 

                break;
            }
        }

        if (SkipWrite) {
            return TRUE;
        }
    }

    HvpTruncateBins(Hive);

    //
    // If hive is volatile, do nothing
    //
    if (Hive->HiveFlags & HIVE_VOLATILE) {
        return TRUE;
    }

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"\tDirtyCount:%08lx\n", Hive->DirtyCount));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"\tDirtyVector:"));

    //
    // disable hard error popups, to avoid self deadlock on bogus devices
    //
    oldFlag = IoSetThreadHardErrorMode(FALSE);

    //
    // Write a log.
    //
    if (Hive->Log == TRUE) {
        if (HvpWriteLog(Hive) == FALSE) {
            IoSetThreadHardErrorMode(oldFlag);
            CmpLogError(STATUS_REGISTRY_IO_FAILED);
            return FALSE;
        }
    }

    //
    // Write the primary
    //
    if (HvpDoWriteHive(Hive, HFILE_TYPE_PRIMARY) == FALSE) {
        IoSetThreadHardErrorMode(oldFlag);
        CmpLogError(STATUS_REGISTRY_IO_FAILED);
        return FALSE;
    }

    //
    // restore hard error popups mode
    //
    IoSetThreadHardErrorMode(oldFlag);

    //
    // Free bins allocated from page-pool at the end of the hive. 
    // These bins were allocated as a temporary till the hive would be saved
    //
    HvpDropPagedBins(Hive
#if DBG
        , TRUE
#endif
        );

    //
    // Clear the dirty map
    //
    RtlClearAllBits(&(Hive->DirtyVector));
    Hive->DirtyCount = 0;

    return TRUE;
}

//
// Code for syncing a hive to backing store
//
VOID
HvpFlushMappedData(
    IN PHHIVE           Hive,
    IN OUT PRTL_BITMAP  DirtyVector
    )
/*++

Routine Description:

    This functions will flush all pinned views for the specified hive.
    It will clean the bits in the DirtyVector for the blocks that are 
    flushed.

    Additionally, it sets the timestamp on the first bin. 

    It iterates through the pinned view list, and unpin all of them.

Arguments:

    Hive - pointer to Hive for which dirty data is to be written.

    DirtyVector - copy of the DirtyVector for the hive

Return Value:

    TRUE - it worked

    FALSE - it failed

--*/
{
    PCMHIVE             CmHive;
    ULONG               FileOffsetStart;
    ULONG               FileOffsetEnd;
    PCM_VIEW_OF_FILE    CmView;
    PHMAP_ENTRY         Me;
    PHBIN               Bin;
    PFREE_HBIN          FreeBin;

    PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"[HvpFlushMappedData] (Entry) DirtyVector:"));

    CmHive = (PCMHIVE)Hive;

    //
    // for each pinned view
    //
    while(IsListEmpty(&(CmHive->PinViewListHead)) == FALSE) {
        //
        // Remove the first view from the pin view list
        //
        CmView = (PCM_VIEW_OF_FILE)RemoveHeadList(&(CmHive->PinViewListHead));
        CmView = CONTAINING_RECORD( CmView,
                                    CM_VIEW_OF_FILE,
                                    PinViewList);

        //
        // the real file offset starts after the header
        // 
        FileOffsetStart = CmView->FileOffset;
        FileOffsetEnd = FileOffsetStart + CmView->Size;
        
        FileOffsetEnd -= HBLOCK_SIZE;

        if( FileOffsetStart != 0 ) {
            //
            // just at the beginning of the file, subtract the header
            //
            FileOffsetStart -= HBLOCK_SIZE;
        } 
        
        if( (FileOffsetEnd / HSECTOR_SIZE) > DirtyVector->SizeOfBitMap ) {
            //
            // Cc has mapped more than its valid
            //
            ASSERT( (FileOffsetEnd % HSECTOR_SIZE) == 0 );
            FileOffsetEnd = DirtyVector->SizeOfBitMap * HSECTOR_SIZE;
        }

        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"[HvpFlushMappedData] CmView %p mapping from %lx to %lx\n",CmView,FileOffsetStart,FileOffsetEnd));

        //
        // now, for every block in this range which is mapped in view
        // clear the dirty bit
        //
        while(FileOffsetStart < FileOffsetEnd) {
            if( FileOffsetStart >= Hive->Storage[Stable].Length ) {
                //
                // This mean the hive has shrunk during the HvpTruncateBins call
                // all we have to do is clear the dirty bits and bail out
                //
                RtlClearBits(DirtyVector,FileOffsetStart/HSECTOR_SIZE,(FileOffsetEnd - FileOffsetStart)/HSECTOR_SIZE);
                break;
            }

            Me = HvpGetCellMap(Hive, FileOffsetStart);
            VALIDATE_CELL_MAP(__LINE__,Me,Hive,FileOffsetStart);
            Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
            
            if( Me->BinAddress & HMAP_DISCARDABLE ) {
                FreeBin = (PFREE_HBIN)Me->BlockAddress;
                //
                // update the file offset
                //
                FileOffsetStart = FreeBin->FileOffset + FreeBin->Size;

                //
                // bin is discardable, or discarded; still, if it was mapped,
                // clear of the dirty bits
                //
                if( Me->BinAddress & HMAP_INVIEW ) {
                    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"[HvpFlushMappedData] Clearing DISCARDABLE %lu Bits starting at %lu\n",
                        FreeBin->Size/HSECTOR_SIZE,FreeBin->FileOffset/HSECTOR_SIZE));
                    RtlClearBits(DirtyVector,FreeBin->FileOffset/HSECTOR_SIZE,FreeBin->Size/HSECTOR_SIZE);
                }
            } else {
                if( Me->BinAddress & HMAP_INVIEW ) {
                    //
                    // bin is mapped in view. Then, this should be the beginning of the bin
                    //
                    ASSERT(Bin->Signature == HBIN_SIGNATURE);
                    ASSERT(Bin->FileOffset == FileOffsetStart);

                    //
                    // clear the dirty bits for this bin as dirty blocks will
                    // be saved while unpinning the view
                    //
                    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"[HvpFlushMappedData] Clearing %lu Bits starting at %lu\n",
                        Bin->Size/HSECTOR_SIZE,Bin->FileOffset/HSECTOR_SIZE));
                    RtlClearBits(DirtyVector,Bin->FileOffset/HSECTOR_SIZE,Bin->Size/HSECTOR_SIZE);
    
                    FileOffsetStart += Bin->Size;
                } else {
                    //
                    // bin is in paged pool. This should be the beginning too
                    //
                    
                    //
                    // we could fall into cross boundary problem here; advance carefully
                    // (two day spent on this problem !!!)
                    //
                    ASSERT(Bin->Signature == HBIN_SIGNATURE);
                    FileOffsetStart += HBLOCK_SIZE;
                }
            }

        } // while (FileOffsetStart<FileOffsetEnd)
        
        //
        // UnPin the view; this will flush all dirty blocks to the backing storage
        //
        CmpUnPinCmView (CmHive,CmView,FALSE,TRUE);
    } // while (IsListEmpty)
    
}

BOOLEAN
HvpDoWriteHive(
    PHHIVE          Hive,
    ULONG           FileType
    )
/*++

Routine Description:

    Write dirty parts of the hive out to either its primary or alternate
    file.  Write the header, flush, write all data, flush, update header,
    flush.  Assume either logging or primary/alternate pairs used.

    NOTE:   TimeStamp is not set, assumption is that HvpWriteLog set
            that.  It is only used for checking if Logs correspond anyway.

Arguments:

    Hive - pointer to Hive for which dirty data is to be written.

    FileType - indicated whether primary or alternate file should be written.

Return Value:

    TRUE - it worked

    FALSE - it failed

--*/
{
    PHBASE_BLOCK        BaseBlock;
    ULONG               Offset;
    PUCHAR              Address;
    ULONG               Length;
    BOOLEAN             rc;
    ULONG               Current;
    PRTL_BITMAP         BitMap;
    PHMAP_ENTRY         Me;
    PHBIN               Bin;
    BOOLEAN             ShrinkHive;
    PCMP_OFFSET_ARRAY   offsetArray;
    CMP_OFFSET_ARRAY    offsetElement;
    ULONG               Count;
    ULONG               SetBitCount;
    PULONG              CopyDirtyVector;
    ULONG               CopyDirtyVectorSize;
    RTL_BITMAP          CopyBitMap;
    LARGE_INTEGER       FileOffset;
    ULONG               OldFileSize;
    BOOLEAN             GrowHive = FALSE;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"HvpDoWriteHive:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"Hive:%p FileType:%08lx\n", Hive, FileType));

    ASSERT_HIVE_FLUSHER_LOCKED_EXCLUSIVE((PCMHIVE)Hive);

    if (Hive->DirtyCount == 0) {
        return TRUE;
    }

    FileOffset.HighPart = FileOffset.LowPart =0;
    //
    // flush first, so that the filesystem structures get written to
    // disk if we have grown the file.
    //
    if ( (((PCMHIVE)Hive)->FileHandles[HFILE_TYPE_PRIMARY] == NULL) || 
        !(Hive->FileFlush)(Hive, FileType,NULL,Hive->Storage[Stable].Length+HBLOCK_SIZE) ) {
#if DBG
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpDoWriteHive[1]: Failed to flush hive %p\n", Hive);
#endif
        return(FALSE);
    }

    BaseBlock = Hive->BaseBlock;

    //
    // we should never come to this
    //
    ASSERT( Hive->Storage[Stable].Length != 0 );
    ASSERT( Hive->BaseBlock->RootCell != HCELL_NIL );

    OldFileSize = BaseBlock->Length;
    if (BaseBlock->Length > Hive->Storage[Stable].Length) {
        ShrinkHive = TRUE;
    } else {
        ShrinkHive = FALSE;
        if( BaseBlock->Length < Hive->Storage[Stable].Length ) {
            GrowHive = TRUE;
        }
    }

    //
    // --- Write out header first time, flush ---
    //
    ASSERT(BaseBlock->Signature == HBASE_BLOCK_SIGNATURE);
    ASSERT(BaseBlock->Major == HSYS_MAJOR);
    ASSERT(BaseBlock->Format == HBASE_FORMAT_MEMORY);
    ASSERT(Hive->ReadOnly == FALSE);


    if (BaseBlock->Sequence1 != BaseBlock->Sequence2) {

        //
        // Some previous log attempt failed, or this hive needs to
        // be recovered, so punt.
        //
#if DBG
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpDoWriteHive[2,%s]: Invalid sequence number for hive%p\n", "Primary",Hive);
#endif
        return FALSE;
    }

    BaseBlock->Length = Hive->Storage[Stable].Length;

    BaseBlock->Sequence1++;
    BaseBlock->Type = HFILE_TYPE_PRIMARY;
    BaseBlock->Cluster = Hive->Cluster;
    BaseBlock->CheckSum = HvpHeaderCheckSum(BaseBlock);

    Offset = 0;
    offsetElement.FileOffset = Offset;
    offsetElement.DataBuffer = (PVOID) BaseBlock;
    offsetElement.DataLength = HSECTOR_SIZE * Hive->Cluster;
    if( HiveWritesThroughCache(Hive,FileType) == TRUE ) {
        //
        // if we use Cc, do the write with the pin interface
        //
        rc = CmpFileWriteThroughCache(  Hive,
                                        FileType,
                                        &offsetElement,
                                        1);
    } else {
        rc = (Hive->FileWrite)(
                Hive,
                FileType,
                &offsetElement,
                1,
                &Offset
                );
    }


    if (rc == FALSE) {
#if DBG
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpDoWriteHive[3,%s]: Failed to write header for hive%p\n", "Primary",Hive);
#endif
        return FALSE;
    }

    if ( ! (Hive->FileFlush)(Hive, FileType,&FileOffset,offsetElement.DataLength)) {
#if DBG
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpDoWriteHive[4,%s]: Failed to flush header for hive%p\n", "Primary",Hive);
#endif
        return FALSE;
    }
    Offset = ROUND_UP(Offset, HBLOCK_SIZE);

    //
    // --- Write out dirty data (only if there is any) ---
    //

    if (Hive->DirtyVector.Buffer != NULL) {
        //
        // First sector of first bin will always be dirty, write it out
        // with the TimeStamp value overlaid on its Link field.
        //
        BitMap = &(Hive->DirtyVector);

        //
        // make a copy of the dirty vector; we don't want to alter the 
        // original dirty vector in case things go wrong
        //
        CopyDirtyVectorSize = BitMap->SizeOfBitMap / 8;
        CopyDirtyVector = (Hive->Allocate)(ROUND_UP(CopyDirtyVectorSize,sizeof(ULONG)), FALSE,CM_FIND_LEAK_TAG38);
        if (CopyDirtyVector == NULL) {
#if DBG
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpDoWriteHive[5,%s]: Failed to allocate CopyDirtyVectorfor hive%p\n", "Primary",Hive);
#endif
            return FALSE;
        }
        RtlCopyMemory(CopyDirtyVector,BitMap->Buffer,CopyDirtyVectorSize);
        RtlInitializeBitMap (&CopyBitMap,CopyDirtyVector,BitMap->SizeOfBitMap);
    
        ASSERT(RtlCheckBit(BitMap, 0) == 1);
        ASSERT(RtlCheckBit(BitMap, (Hive->Cluster - 1)) == 1);
        ASSERT(sizeof(LIST_ENTRY) >= sizeof(LARGE_INTEGER));
        Me = HvpGetCellMap(Hive, 0);
        VALIDATE_CELL_MAP(__LINE__,Me,Hive,0);
        if( (Me->BinAddress & (HMAP_INPAGEDPOOL|HMAP_INVIEW)) == 0 ) {
            //
            // first view is not mapped
            //
            //
            // fatal error: Dirty Data is not pinned !!!!
            //
            CM_BUGCHECK(REGISTRY_ERROR,FATAL_MAPPING_ERROR,3,0,Me);
        }
        Address = (PUCHAR)Me->BlockAddress;
        Bin = (PHBIN)Address;
        Bin->TimeStamp = BaseBlock->TimeStamp;

        //
        // flush first the mapped data
        //
        try {
            HvpFlushMappedData(Hive,&CopyBitMap);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // in-page exception while flushing the mapped data; this is due to the map_no_read scheme.
            //
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpDoWriteHive : HvpFlushMappedData has raised :%08lx\n",GetExceptionCode()));
            return FALSE;
        }

        //
        // Write out the rest of the dirty data
        //
        Current = 0;        

        SetBitCount = RtlNumberOfSetBits(&CopyBitMap);
        if( SetBitCount > 0 ) {
            //
            // we still have some dirty data
            // this must reside in paged-pool bins
            // save it in the old-fashioned way (non-cached)
            //
            offsetArray =(PCMP_OFFSET_ARRAY)ExAllocatePool(PagedPool,sizeof(CMP_OFFSET_ARRAY) * SetBitCount);
            if (offsetArray == NULL) {
                CmpFree(CopyDirtyVector, ROUND_UP(CopyDirtyVectorSize,sizeof(ULONG)));
#if DBG
                DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpDoWriteHive[8,%s]: Failed to allocate offsetArray for hive%p\n", "Primary",Hive);
#endif
                return FALSE;
            }
            Count = 0;

            while (HvpFindNextDirtyBlock(
                        Hive,
                        &CopyBitMap,
                        &Current,
                        &Address,
                        &Length,
                        &Offset
                        ) == TRUE)
            {
                // Gather data into array.
                ASSERT(Count < SetBitCount);
                offsetArray[Count].FileOffset = Offset;
                offsetArray[Count].DataBuffer = Address;
                offsetArray[Count].DataLength = Length;
                Offset += Length;
                ASSERT((Offset % (Hive->Cluster * HSECTOR_SIZE)) == 0);
                Count++;
            }

            if( HiveWritesThroughCache(Hive,FileType) == TRUE ) {
                //
                // if we use Cc, do the write with the pin interface
                //
                rc = CmpFileWriteThroughCache(  Hive,
                                                FileType,
                                                offsetArray,
                                                Count);
            } else {
                //
                // for primary file, issue all IOs at the same time.
                //
                rc = (Hive->FileWrite)(
                                        Hive,
                                        FileType,
                                        offsetArray,
                                        Count,
                                        &Offset             // Just an OUT parameter which returns the point
                                                            // in the file after the last write.
                                        );
            }

            ExFreePool(offsetArray);
            if (rc == FALSE) {
                CmpFree(CopyDirtyVector, ROUND_UP(CopyDirtyVectorSize,sizeof(ULONG)));
#if DBG
                DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpDoWriteHive[10,%s]: Failed to write dirty run for hive%p\n", "Primary",Hive);
#endif
                return FALSE;
            }
        }
        //
        // first bin header must be saved !
        //
        ASSERT(RtlCheckBit(BitMap, 0) == 1);
        ASSERT(RtlCheckBit(BitMap, (Hive->Cluster - 1)) == 1);

        CmpFree(CopyDirtyVector, ROUND_UP(CopyDirtyVectorSize,sizeof(ULONG)));
    }

    if ( ! (Hive->FileFlush)(Hive, FileType,NULL,Hive->Storage[Stable].Length+HBLOCK_SIZE)) {
#if DBG
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpDoWriteHive[11,%s]: Failed to flush hive%p\n", "Primary",Hive);
#endif
        return FALSE;
    }

    if ( GrowHive && HiveWritesThroughCache(Hive,FileType) ) {
        IO_STATUS_BLOCK IoStatus;
        if(!NT_SUCCESS(ZwFlushBuffersFile(((PCMHIVE)Hive)->FileHandles[FileType],&IoStatus))) {
#if DBG
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpDoWriteHive[12,%s]: CcSetValidDataFailed for hive %p\n", Hive, "Primary");
#endif
            return FALSE;
        }
    }

    //
    // --- Write header again to report completion ---
    //
    BaseBlock->Sequence2++;
    BaseBlock->CheckSum = HvpHeaderCheckSum(BaseBlock);
    Offset = 0;

    offsetElement.FileOffset = Offset;
    offsetElement.DataBuffer = (PVOID) BaseBlock;
    offsetElement.DataLength = HSECTOR_SIZE * Hive->Cluster;
    if( HiveWritesThroughCache(Hive,FileType) == TRUE ) {
        //
        // if we use Cc, do the write with the pin interface
        //
        rc = CmpFileWriteThroughCache(  Hive,
                                        FileType,
                                        &offsetElement,
                                        1);
    } else {
        rc = (Hive->FileWrite)(
                    Hive,
                    FileType,
                    &offsetElement,
                    1,
                    &Offset
                    );
    }
    if (rc == FALSE) {
#if DBG
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpDoWriteHive[13,%s]: Failed to write header for hive%p\n","Primary",Hive);
#endif
        return FALSE;
    }

    if (ShrinkHive) {
        //
        // Hive has shrunk, give up the excess space.
        //
        CmpDoFileSetSize(Hive, FileType, Hive->Storage[Stable].Length + HBLOCK_SIZE,OldFileSize + HBLOCK_SIZE);
    }

    //
    // make sure data hits the disk.
    //
    if ( ! (Hive->FileFlush)(Hive, FileType,&FileOffset,offsetElement.DataLength)) {
#if DBG
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvpDoWriteHive[14,%s]: Failed to flush hive%p\n", "Primary",Hive);
#endif
        return FALSE;
    }

    if ((Hive->Log) &&
        (Hive->LogSize > HLOG_MINSIZE(Hive))) {
        //
        // Shrink log back down, reserve at least two clusters
        // worth of space so that if all the disk space is
        // consumed, there will still be enough space prereserved
        // to allow a minimum of registry operations so the user
        // can log on.
        //
        CmpDoFileSetSize(Hive, HFILE_TYPE_LOG, HLOG_MINSIZE(Hive),Hive->LogSize);
        Hive->LogSize = HLOG_MINSIZE(Hive);
    }

#if DBG
    {
        NTSTATUS                        Status;
        FILE_END_OF_FILE_INFORMATION    FileInfo;
        IO_STATUS_BLOCK                 IoStatus;

        Status = NtQueryInformationFile(
                    ((PCMHIVE)Hive)->FileHandles[HFILE_TYPE_PRIMARY],
                    &IoStatus,
                    (PVOID)&FileInfo,
                    sizeof(FILE_END_OF_FILE_INFORMATION),
                    FileEndOfFileInformation
                    );

        if (NT_SUCCESS(Status)) {
            ASSERT(IoStatus.Status == Status);
            ASSERT( FileInfo.EndOfFile.LowPart == (Hive->Storage[Stable].Length + HBLOCK_SIZE));
        } 
    }
#endif //DBG

    return TRUE;
}

//
// Code for tracking modifications and ensuring adequate log space
//
BOOLEAN
HvpWriteLog(
    PHHIVE          Hive
    )
/*++

Routine Description:

    Write a header, the DirtyVector, and all the dirty data into
    the log file.  Do flushes at the right places.  Update the header.

Arguments:

    Hive - pointer to Hive for which dirty data is to be logged.

Return Value:

    TRUE - it worked

    FALSE - it failed

--*/
{
    PHBASE_BLOCK    BaseBlock;
    ULONG           Offset;
    PUCHAR          Address;
    ULONG           Length;
    BOOLEAN         rc;
    ULONG           Current;
    ULONG           junk;
    ULONG           ClusterSize;
    ULONG           HeaderLength;
    PRTL_BITMAP     BitMap;
    ULONG           DirtyVectorSignature = HLOG_DV_SIGNATURE;
    LARGE_INTEGER   systemtime;
    PCMP_OFFSET_ARRAY offsetArray;
    CMP_OFFSET_ARRAY offsetElement;
    ULONG Count;
    ULONG SetBitCount;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"HvpWriteLog:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"Hive:%p\n", Hive));

    ClusterSize = Hive->Cluster * HSECTOR_SIZE;
    //
    // make sure the log size accommodates the dirty data we are about to write.
    //
    {
        ULONG	tmp;
        ULONG	RequiredSize;

        tmp = Hive->DirtyVector.SizeOfBitMap / 8;   // bytes
        tmp += sizeof(ULONG);                       // signature

        RequiredSize =
        ClusterSize  +                                  // 1 cluster for header
        ROUND_UP(tmp, ClusterSize) +
        ((Hive->DirtyCount) * HSECTOR_SIZE);

        RequiredSize = ROUND_UP(RequiredSize, HLOG_GROW);

        ASSERT(Hive->DirtyCount == RtlNumberOfSetBits(&Hive->DirtyVector));

        if( Hive->LogSize >= RequiredSize ) {
            //
            // this is a noop. log is already big enough
            //
            NOTHING;
        } else {

            if( !NT_SUCCESS(CmpDoFileSetSize(Hive, HFILE_TYPE_LOG, RequiredSize,Hive->LogSize)) ) {
                return FALSE;
            }
            Hive->LogSize = RequiredSize;
        }
    }

    BitMap = &Hive->DirtyVector;
    //
    // --- Write out header first time, flush ---
    //
    BaseBlock = Hive->BaseBlock;
    ASSERT(BaseBlock->Signature == HBASE_BLOCK_SIGNATURE);
    ASSERT(BaseBlock->Major == HSYS_MAJOR);
    ASSERT(BaseBlock->Format == HBASE_FORMAT_MEMORY);
    ASSERT(Hive->ReadOnly == FALSE);


    if (BaseBlock->Sequence1 != BaseBlock->Sequence2) {

        //
        // Some previous log attempt failed, or this hive needs to
        // be recovered, so punt.
        //
        return FALSE;
    }

    BaseBlock->Sequence1++;
    KeQuerySystemTime(&systemtime);
    BaseBlock->TimeStamp = systemtime;

    BaseBlock->Type = HFILE_TYPE_LOG;
    HeaderLength = ROUND_UP(HLOG_HEADER_SIZE, ClusterSize);
    BaseBlock->Cluster = Hive->Cluster;

    BaseBlock->CheckSum = HvpHeaderCheckSum(BaseBlock);

    Offset = 0;
    offsetElement.FileOffset = Offset;
    offsetElement.DataBuffer = (PVOID) BaseBlock;
    offsetElement.DataLength = HSECTOR_SIZE * Hive->Cluster;
    rc = (Hive->FileWrite)(
            Hive,
            HFILE_TYPE_LOG,
            &offsetElement,
            1,
            &Offset
            );
    if (rc == FALSE) {
        return FALSE;
    }
    Offset = ROUND_UP(Offset, HeaderLength);
    if ( ! (Hive->FileFlush)(Hive, HFILE_TYPE_LOG,NULL,0)) {
        return FALSE;
    }

    //
    // --- Write out dirty vector ---
    //
    //
    // try to allocate a stash buffer. if we fail. we fail to save the hive
    // only save what is relevant 
    //
    Length = (Hive->Storage[Stable].Length / HSECTOR_SIZE) / 8;

    LOCK_STASH_BUFFER();
    if( CmpStashBufferSize < (Length + sizeof(DirtyVectorSignature)) ) {
        PUCHAR TempBuffer =  ExAllocatePoolWithTag(PagedPool, ROUND_UP((Length + sizeof(DirtyVectorSignature)),PAGE_SIZE),CM_STASHBUFFER_TAG);
        if (TempBuffer == NULL) {
            UNLOCK_STASH_BUFFER();
            return FALSE;
        }
        if( CmpStashBuffer != NULL ) {
            ExFreePool( CmpStashBuffer );
        }
        CmpStashBuffer = TempBuffer;
        CmpStashBufferSize = ROUND_UP((Length + sizeof(DirtyVectorSignature)),PAGE_SIZE);

    }
    
    ASSERT(sizeof(ULONG) == sizeof(DirtyVectorSignature));  // See GrowLog1 above


    //
    // signature
    //
    (*((ULONG *)CmpStashBuffer)) = DirtyVectorSignature;

    //
    // dirty vector content
    //
    Address = (PUCHAR)(Hive->DirtyVector.Buffer);
    RtlCopyMemory(CmpStashBuffer + sizeof(DirtyVectorSignature),Address,Length);
    
    offsetElement.FileOffset = Offset;
    offsetElement.DataBuffer = (PVOID)CmpStashBuffer;
    offsetElement.DataLength = ROUND_UP((Length + sizeof(DirtyVectorSignature)),ClusterSize);
    rc = (Hive->FileWrite)(
            Hive,
            HFILE_TYPE_LOG,
            &offsetElement,
            1,
            &Offset
            );

    UNLOCK_STASH_BUFFER();

    if (rc == FALSE) {
        return FALSE;
    }

#if !defined(_WIN64)
    ASSERT( (Offset % ClusterSize) == 0 );
#endif

    //
    // --- Write out body of log ---
    //
    SetBitCount = RtlNumberOfSetBits(BitMap);
    offsetArray =
        (PCMP_OFFSET_ARRAY)
        ExAllocatePool(PagedPool,
                       sizeof(CMP_OFFSET_ARRAY) * SetBitCount);
    if (offsetArray == NULL) {
        return FALSE;
    }
    Count = 0;

    Current = 0;
    while (HvpFindNextDirtyBlock(
                Hive,
                BitMap,
                &Current,
                &Address,
                &Length,
                &junk
                ) == TRUE)
    {
        // Gather data into array.
        ASSERT(Count < SetBitCount);
        offsetArray[Count].FileOffset = Offset;
        offsetArray[Count].DataBuffer = Address;
        offsetArray[Count].DataLength = Length;
        Offset += Length;
        Count++;
        ASSERT((Offset % ClusterSize) == 0);
    }

        rc = (Hive->FileWrite)(
                Hive,
                HFILE_TYPE_LOG,
        offsetArray,
        Count,
        &Offset             // Just an OUT parameter which returns the point
                            // in the file after the last write.
                );
    ExFreePool(offsetArray);
        if (rc == FALSE) {
            return FALSE;
        }

    if ( ! (Hive->FileFlush)(Hive, HFILE_TYPE_LOG,NULL,0)) {
        return FALSE;
    }

    //
    // --- Write header again to report completion ---
    //

    //
    // -- we need to save the new length, in case the hive was grown.
    //
    Length = BaseBlock->Length;
    if( Length < Hive->Storage[Stable].Length ) {
        BaseBlock->Length = Hive->Storage[Stable].Length;
    }
    BaseBlock->Sequence2++;
    BaseBlock->CheckSum = HvpHeaderCheckSum(BaseBlock);
    Offset = 0;
    offsetElement.FileOffset = Offset;
    offsetElement.DataBuffer = (PVOID) BaseBlock;
    offsetElement.DataLength = HSECTOR_SIZE * Hive->Cluster;
    rc = (Hive->FileWrite)(
            Hive,
            HFILE_TYPE_LOG,
            &offsetElement,
            1,
            &Offset
            );
    //
    // restore the original length
    //
    BaseBlock->Length = Length;
    if (rc == FALSE) {
        return FALSE;
    }
    if ( ! (Hive->FileFlush)(Hive, HFILE_TYPE_LOG,NULL,0)) {
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
HvpFindNextDirtyBlock(
    PHHIVE          Hive,
    PRTL_BITMAP     BitMap,
    PULONG          Current,
    PUCHAR          *Address,
    PULONG          Length,
    PULONG          Offset
    )
/*++

Routine Description:

    This routine finds and reports the largest run of dirty logical
    sectors in the hive, which are contiguous in memory and on disk.

Arguments:

    Hive - pointer to Hive of interest.

    BitMap - supplies a pointer to a bitmap structure, which
                describes what is dirty.

    Current - supplies a pointer to a variable that tracks position
                in the bitmap.  It is a bitnumber.  It is updated by
                this call.

    Address - supplies a pointer to a variable to receive a pointer
                to the area in memory to be written out.

    Length - supplies a pointer to a variable to receive the length
                of the region to read/write

    Offset - supplies a pointer to a variable to receive the offset
                in the backing file to which the data should be written.
                (not valid for log files)

Return Value:

    TRUE - more to write, ret values good

    FALSE - all data has been written

--*/
{
    ULONG       i;
    ULONG       EndOfBitMap;
    ULONG       Start;
    ULONG       End;
    HCELL_INDEX FileBaseAddress;
    HCELL_INDEX FileEndAddress;
    PHMAP_ENTRY Me;
    PUCHAR      Block;
    PUCHAR      StartBlock;
    PUCHAR      NextBlock;
    ULONG       RunSpan;
    ULONG       RunLength;
    ULONG       FileLength;
    PFREE_HBIN  FreeBin;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"HvpFindNextDirtyBlock:\n\t"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"Hive:%p Current:%08lx\n", Hive, *Current));


    EndOfBitMap = BitMap->SizeOfBitMap;

    if (*Current >= EndOfBitMap) {
        return FALSE;
    }

    //
    // Find next run of set bits
    //
    for (i = *Current; i < EndOfBitMap; i++) {
        if (RtlCheckBit(BitMap, i) == 1) {
            break;
        }
    }
    Start = i;

    for ( ; i < EndOfBitMap; i++) {
        if (RtlCheckBit(BitMap, i) == 0) {
            break;
        }
        if( HvpCheckViewBoundary(Start*HSECTOR_SIZE,i*HSECTOR_SIZE) == FALSE ) {
            break;
        }
    }
    End = i;
    

    //
    // Compute hive virtual addresses, beginning file address, memory address
    //
    FileBaseAddress = Start * HSECTOR_SIZE;
    FileEndAddress = End * HSECTOR_SIZE;
    FileLength = FileEndAddress - FileBaseAddress;
    if (FileLength == 0) {
        *Address = NULL;
        *Current = 0xffffffff;
        *Length = 0;
        return FALSE;
    }
    Me = HvpGetCellMap(Hive, FileBaseAddress);
    VALIDATE_CELL_MAP(__LINE__,Me,Hive,FileBaseAddress);

    if( (Me->BinAddress & (HMAP_INPAGEDPOOL|HMAP_INVIEW)) == 0 ) {
        //
        // this is really bad, bugcheck!!!
        //
#if DBG
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"FileAddress = %lx, Map = %lx",FileBaseAddress,Me);
#endif
        CM_BUGCHECK(REGISTRY_ERROR,FATAL_MAPPING_ERROR,1,FileBaseAddress,Me);

    }

    ASSERT_BIN_VALID(Me);

    if (Me->BinAddress & HMAP_DISCARDABLE) {
        FreeBin = (PFREE_HBIN)Me->BlockAddress;
        StartBlock = (PUCHAR)(HBIN_BASE(Me->BinAddress) + FileBaseAddress - FreeBin->FileOffset );
    } else {
        StartBlock = (PUCHAR)Me->BlockAddress;
    }

    Block = StartBlock;
    ASSERT(((PHBIN)HBIN_BASE(Me->BinAddress))->Signature == HBIN_SIGNATURE);
    *Address = Block + (FileBaseAddress & HCELL_OFFSET_MASK);

    *Offset = FileBaseAddress + HBLOCK_SIZE;

    //
    // Build up length.  First, account for sectors in first block.
    //
    RunSpan = HSECTOR_COUNT - (Start % HSECTOR_COUNT);

    if ((End - Start) <= RunSpan) {

        //
        // Entire length is in first block, return it
        //
        *Length = FileLength;
        *Current = End;
        return TRUE;

    } else {

        RunLength = RunSpan * HSECTOR_SIZE;
        FileBaseAddress = ROUND_UP(FileBaseAddress+1, HBLOCK_SIZE);

    }

    //
    // Scan forward through blocks, filling up length as we go.
    //
    // NOTE:    This loop grows forward 1 block at time.  If we were
    //          really clever we'd fill forward a bin at time, since
    //          bins are always contiguous.  But most bins will be
    //          one block long anyway, so we won't bother for now.
    //
    while (RunLength < FileLength) {

        Me = HvpGetCellMap(Hive, FileBaseAddress);
        VALIDATE_CELL_MAP(__LINE__,Me,Hive,FileBaseAddress);

        if( (Me->BinAddress & (HMAP_INPAGEDPOOL|HMAP_INVIEW)) == 0 ) {
            //
            // this is really bad, bugcheck!!!
            //
#if DBG
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"FileAddress = %lx, Map = %lx",FileBaseAddress,Me);
#endif
            CM_BUGCHECK(REGISTRY_ERROR,FATAL_MAPPING_ERROR,2,FileBaseAddress,Me);

        }

        ASSERT(((PHBIN)HBIN_BASE(Me->BinAddress))->Signature == HBIN_SIGNATURE);

        if (Me->BinAddress & HMAP_DISCARDABLE) {
            FreeBin = (PFREE_HBIN)Me->BlockAddress;
            NextBlock = (PUCHAR)(HBIN_BASE(Me->BinAddress) + FileBaseAddress - FreeBin->FileOffset );
        } else {
            NextBlock = (PUCHAR)Me->BlockAddress;
        }

        if ( (NextBlock - Block) != HBLOCK_SIZE) {

            //
            // We've hit a discontinuity in memory.  RunLength is
            // as long as it's going to get.
            //
            break;
        }


        if ((FileEndAddress - FileBaseAddress) <= HBLOCK_SIZE) {

            //
            // We've reached the tail block, all is contiguous,
            // fill up to end and return.
            //
            *Length = FileLength;
            *Current = End;
            return TRUE;
        }

        //
        // Just another contiguous block, fill forward
        //
        RunLength += HBLOCK_SIZE;
        RunSpan += HSECTOR_COUNT;
        FileBaseAddress += HBLOCK_SIZE;
        Block = NextBlock;
    }

    //
    // We either hit a discontinuity, OR, we're at the end of the range
    // we're trying to fill.  In either case, return.
    //
    *Length = RunLength;
    *Current = Start + RunSpan;
    return TRUE;
}


BOOLEAN
HvHiveWillShrink(
                    IN PHHIVE Hive
                    )
/*++

Routine Description:

    Applies to stable storage only. Helps determining whether the hive 
    will shrink on first flush

--*/
{
    PHMAP_ENTRY Map;
    ULONG NewLength;
    ULONG OldLength;

    OldLength = Hive->BaseBlock->Length;
    NewLength = Hive->Storage[Stable].Length;
    
    if( OldLength > NewLength ) {
        return TRUE;
    }

    if( NewLength > 0 ) {
        ASSERT( (NewLength % HBLOCK_SIZE) == 0);
        Map = HvpGetCellMap(Hive, (NewLength - HBLOCK_SIZE));
        VALIDATE_CELL_MAP(__LINE__,Map,Hive,(NewLength - HBLOCK_SIZE));
        if (Map->BinAddress & HMAP_DISCARDABLE) {
            return TRUE;
        } 
    }
    return FALSE;
}

VOID
HvpTruncateBins(
    IN PHHIVE Hive
    )

/*++

Routine Description:

    Attempts to shrink the hive by truncating any bins that are discardable at
    the end of the hive.  Applies to both stable and volatile storage.

Arguments:

    Hive - Supplies the hive to be truncated.

Return Value:

    None.

--*/

{
    HSTORAGE_TYPE i;
    PHMAP_ENTRY Map;
    ULONG NewLength;
    PFREE_HBIN FreeBin;

    //
    // stable and volatile
    //
    for (i=0;i<HTYPE_COUNT;i++) {

        //
        // find the last in-use bin in the hive
        //
        NewLength = Hive->Storage[i].Length;

        while (NewLength > 0) {
            Map = HvpGetCellMap(Hive, (NewLength - HBLOCK_SIZE) + (i*HCELL_TYPE_MASK));
            VALIDATE_CELL_MAP(__LINE__,Map,Hive,(NewLength - HBLOCK_SIZE) + (i*HCELL_TYPE_MASK));
            if (Map->BinAddress & HMAP_DISCARDABLE) {
                FreeBin = (PFREE_HBIN)Map->BlockAddress;
                NewLength = FreeBin->FileOffset;
            } else {
                break;
            }
        }

        if (NewLength < Hive->Storage[i].Length) {
            //
            // There are some free bins to truncate.
            //
            HvFreeHivePartial(Hive, NewLength, i);
        }
    }
}

VOID
HvpDropPagedBins(
    IN PHHIVE   Hive
#if DBG
    ,
    IN BOOLEAN  Check
#endif
    )

/*++

Routine Description:

    Frees all bins allocated from page pool, which are at 
    the end of the hive, then update their map (clears the
    HMAP_INPAGEDPOOL flag). Next attempt to read from those 
    bins will map a view for them. Checks for CM_VIEW_SIZE boundary,
    before freeing a bin.

    It also tags each start of the bin with HMAP_NEWALLOC; This will 
    allow us to use MAP_NO_READ flag in CcMapData (now that we enabled
    MNW feature for registry streams, we know that Mm will fault only one 
    page at the time for these kind of streams)

    Applies only to permanent storage.

Arguments:

    Hive - Supplies the hive to operate on..

    Check - debug only, beginning of the bin should already tagged as 
            HMAP_NEWALLOC

Return Value:

    None.

--*/

{
    ULONG_PTR   Address;
    LONG        Length;
    LONG        Offset;
    PHMAP_ENTRY Me;
    PHBIN       Bin;
    PFREE_HBIN  FreeBin;
    BOOLEAN     UnMap = FALSE;

    PAGED_CODE();

    if( (Hive->Storage[Stable].Length == 0) ||  // empty hive
        (((PCMHIVE)Hive)->FileObject == NULL)     // or hive not using the mapped views technique
        ) {
        return;
    }

    CmLockHiveViews((PCMHIVE)Hive);
    
    if( ((PCMHIVE)Hive)->UseCount != 0 ) {
        //
        // this is not a good time to do that
        //
        CmUnlockHiveViews((PCMHIVE)Hive);
        return;
    }
    //
    // start at the end of the hive
    //
    Length = Hive->Storage[Stable].Length - HBLOCK_SIZE;

    while(Length >= 0) {
        //
        // get the bin
        //
        Me = HvpGetCellMap(Hive, Length);
        VALIDATE_CELL_MAP(__LINE__,Me,Hive,Length);

        if( !(Me->BinAddress & HMAP_INPAGEDPOOL) ) {
            //
            // bail out; we are interested only in bins allocated from paged pool
            //
            break;
        }

        if(Me->BinAddress & HMAP_DISCARDABLE) {
            //
            // bin is discardable, skip it !
            //
            FreeBin = (PFREE_HBIN)Me->BlockAddress;
            Length = FreeBin->FileOffset - HBLOCK_SIZE;
            continue;
        }

        Address = HBIN_BASE(Me->BinAddress);
        Bin = (PHBIN)Address;

        // sanity
        ASSERT( Bin->Signature == HBIN_SIGNATURE );

        //
        // advance (backward) to the previous bin
        //
        Length = Bin->FileOffset - HBLOCK_SIZE;

        //
        // finally, see if we can free it;
        // 
        if( HvpCheckViewBoundary(Bin->FileOffset,Bin->FileOffset + Bin->Size - 1) ) {
            //
            // free its storage and mark the map accordingly;
            // next attempt to read a cell from this bin will map a view.
            //
            Offset = Bin->FileOffset;
            while( Offset < (LONG)(Bin->FileOffset + Bin->Size) ) {
                Me = HvpGetCellMap(Hive, Offset);
                VALIDATE_CELL_MAP(__LINE__,Me,Hive,Offset);
                ASSERT_BIN_INPAGEDPOOL(Me);
                //
                // clear off the HMAP_INPAGEDPOOL flag
                //
                Me->BinAddress &= ~HMAP_INPAGEDPOOL;
                if( (ULONG)Offset == Bin->FileOffset ) {
#if DBG
                    if( Check == TRUE ) {
                        // should already be tagged
                        ASSERT( Me->BinAddress & HMAP_NEWALLOC );
                    }
#endif
                    //
                    // tag it as a new alloc, so we can rely on this flag in CmpMapCmView
                    //
                    Me->BinAddress |= HMAP_NEWALLOC;
                } else {
                    //
                    // remove the NEWALLOC flag (if any), so we can rely on this flag in CmpMapCmView
                    //
                    Me->BinAddress &= ~HMAP_NEWALLOC;
                }

                // advance to the next HBLOCK_SIZE of this bin
                Offset += HBLOCK_SIZE;
            }
            //
            // free the bin
            //
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"Dropping temporary bin (from paged pool) at offset %lx size %lx\n",Bin->FileOffset,Bin->Size));
            if( HvpGetBinMemAlloc(Hive,Bin,Stable) ) {
                CmpFree(Bin, HvpGetBinMemAlloc(Hive,Bin,Stable));
            }
            UnMap = TRUE;

        } else {
            //
            // this bin has a good reason to reside in page-pool (it's crossing the boundaries).
            // leave it like that !
            //
            NOTHING;
        }
    
    }

    if( UnMap == TRUE ) {
        //
        // unmap the last view, to make sure the map will be updated
        //

        ASSERT( Length >= -HBLOCK_SIZE );

        Offset = (Length + HBLOCK_SIZE) & (~(CM_VIEW_SIZE - 1));
        if( Offset != 0 ) {
            //
            // account for the header
            //
            Offset -= HBLOCK_SIZE;
        }
        Length = Hive->Storage[Stable].Length;
        while( Offset < Length ) {
            Me = HvpGetCellMap(Hive, Offset);
            VALIDATE_CELL_MAP(__LINE__,Me,Hive,Offset);

            if( Me->BinAddress & HMAP_INVIEW ) {
                //
                // get this view and unmap it; then bail out.
                //
                CmpUnmapCmView( (PCMHIVE)Hive,Me->CmView,TRUE,TRUE);
                break;
            }

            // next, please ?
            Offset += HBLOCK_SIZE;
        }
    }
    
    CmUnlockHiveViews((PCMHIVE)Hive);
}

VOID
HvpDropAllPagedBins(
    IN PHHIVE   Hive
    )

/*++

Routine Description:

        Works as HvpDropPagedBins, only that it iterates through
        the entire hive. No views are mapped at this point.

Arguments:

    Hive - Supplies the hive to operate on..


Return Value:

    None.

--*/

{
    ULONG_PTR   Address;
    ULONG       Length;
    ULONG       Offset;
    PHMAP_ENTRY Me;
    PHBIN       Bin;
    PFREE_HBIN  FreeBin;

    PAGED_CODE();

    if( (Hive->Storage[Stable].Length == 0) ||  // empty hive
        (((PCMHIVE)Hive)->FileObject == NULL)     // or hive not using the mapped views technique
        ) {
        return;
    }
        ASSERT( (((PCMHIVE)Hive)->MappedViews == 0) && (((PCMHIVE)Hive)->PinnedViews == 0) && (((PCMHIVE)Hive)->UseCount == 0) );

    //
    // start at the end of the hive
    //
    Length = Hive->Storage[Stable].Length - HBLOCK_SIZE;
    Offset = 0;

    while( Offset < Length ) {
        //
        // get the bin
        //
        Me = HvpGetCellMap(Hive, Offset);
        VALIDATE_CELL_MAP(__LINE__,Me,Hive,Offset);

        ASSERT( Me->BinAddress & HMAP_INPAGEDPOOL );

        if(Me->BinAddress & HMAP_DISCARDABLE) {
            //
            // bin is discardable, skip it !
            //
            FreeBin = (PFREE_HBIN)Me->BlockAddress;
                        ASSERT( Offset == FreeBin->FileOffset );
            Offset += FreeBin->Size;
            continue;
        }

        Address = HBIN_BASE(Me->BinAddress);
        Bin = (PHBIN)Address;

        // sanity
        ASSERT( Bin->Signature == HBIN_SIGNATURE );

        //
        // finally, see if we can free it;
        // 
        if( HvpCheckViewBoundary(Bin->FileOffset,Bin->FileOffset + Bin->Size - 1) ) {
            //
            // free its storage and mark the map accordingly;
            // next attempt to read a cell from this bin will map a view.
            //
            Offset = Bin->FileOffset;
            while( Offset < (Bin->FileOffset + Bin->Size) ) {
                Me = HvpGetCellMap(Hive, Offset);
                VALIDATE_CELL_MAP(__LINE__,Me,Hive,Offset);
                ASSERT_BIN_INPAGEDPOOL(Me);
                //
                // clear off the HMAP_INPAGEDPOOL flag
                //
                Me->BinAddress &= ~HMAP_INPAGEDPOOL;
                if( (ULONG)Offset == Bin->FileOffset ) {
                    //
                    // tag it as a new alloc, so we can rely on this flag in CmpMapCmView
                    //
                    Me->BinAddress |= HMAP_NEWALLOC;
                } else {
                    //
                    // remove the NEWALLOC flag (if any), so we can rely on this flag in CmpMapCmView
                    //
                    Me->BinAddress &= ~HMAP_NEWALLOC;
                }

                // advance to the next HBLOCK_SIZE of this bin
                Offset += HBLOCK_SIZE;
            }
            //
            // free the bin
            //
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"Dropping temporary bin (from paged pool) at offset %lx size %lx\n",Bin->FileOffset,Bin->Size));
            if( HvpGetBinMemAlloc(Hive,Bin,Stable) ) {
                CmpFree(Bin, HvpGetBinMemAlloc(Hive,Bin,Stable));
            }

        } else {
            //
            // this bin has a good reason to reside in page-pool (it's crossing the boundaries).
            // leave it like that !
            //
                        Offset += Bin->Size;
        }
    }
}


NTSTATUS
HvWriteHive(
    PHHIVE          Hive,
    BOOLEAN         DontGrow,
    BOOLEAN         WriteThroughCache,
    BOOLEAN         CrashSafe
    )
/*++

Routine Description:

    Write the hive out.  Write only to the Primary file, neither
    logs nor alternates will be updated.  The hive will be written
    to the HFILE_TYPE_EXTERNAL handle.

    Intended for use in applications like SaveKey.

    Only Stable storage will be written (as for any hive.)

    Presumption is that layer above has set HFILE_TYPE_EXTERNAL
    handle to point to correct place.

    Applying this call to an active hive will generally hose integrity
    measures.

    HOW IT WORKS:

        Saves the BaseBlock.

        Iterates through the entire hive and save it bin by bin

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest.

        DontGrow - we know that the file is big enough, don't attempt to grow it.

Return Value:

    Status.

--*/
{
    PHBASE_BLOCK    BaseBlock;
    NTSTATUS        status;
    ULONG           Offset;
    PHBIN           Bin = NULL;
    PFREE_HBIN      FreeBin = NULL;
    ULONG           BinSize;
    PVOID           Address;
    ULONG           BinOffset;
    ULONG           Length;
    CMP_OFFSET_ARRAY offsetElement;
    PHMAP_ENTRY     Me;
    PHCELL          FirstCell;
    BOOLEAN         rc;
    PCM_VIEW_OF_FILE CmView = NULL;


    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"HvWriteHive: \n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_IO,"\tHive = %p\n"));
    ASSERT(Hive->Signature == HHIVE_SIGNATURE);
    ASSERT(Hive->ReadOnly == FALSE);


    //
    // Punt if post shutdown
    //
    if (HvShutdownComplete) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"HvWriteHive: Attempt to write hive AFTER SHUTDOWN\n"));
        return STATUS_REGISTRY_IO_FAILED;
    }

    Length = Hive->Storage[Stable].Length;

    //
    // we should never come to this
    //
    ASSERT( Length != 0 );
    ASSERT( Hive->BaseBlock->RootCell != HCELL_NIL );


    if( !DontGrow ){
                
        //
        // Ensure the file can be made big enough, then do the deed
        //
        status = CmpDoFileSetSize(Hive,
                                  HFILE_TYPE_EXTERNAL,
                                  Length + HBLOCK_SIZE,
                                  0);

        if (!NT_SUCCESS(status)) {
            return status;
        }
    }
    BaseBlock = Hive->BaseBlock;
    //
    // --- Write out header first time ---
    //
    ASSERT(BaseBlock->Signature == HBASE_BLOCK_SIGNATURE);
    ASSERT(BaseBlock->Major == HSYS_MAJOR);
    ASSERT(BaseBlock->Format == HBASE_FORMAT_MEMORY);
    ASSERT(Hive->ReadOnly == FALSE);


    if (BaseBlock->Sequence1 != BaseBlock->Sequence2) {

        //
        // Some previous log attempt failed, or this hive needs to
        // be recovered, so punt.
        //
        return STATUS_REGISTRY_IO_FAILED;
    }

    if( CrashSafe ) {
        //
        // change sequence numbers, in case we experience a machine crash
        //
        BaseBlock->Sequence1++;
    }
    BaseBlock->Length = Length;
    BaseBlock->CheckSum = HvpHeaderCheckSum(BaseBlock);

    Offset = 0;
    offsetElement.FileOffset = Offset;
    offsetElement.DataBuffer = (PVOID) BaseBlock;
    offsetElement.DataLength = HSECTOR_SIZE * Hive->Cluster;

    if(WriteThroughCache) {
        //
        // if we use Cc, do the write with the pin interface
        //
        rc = CmpFileWriteThroughCache(  Hive,
                                        HFILE_TYPE_EXTERNAL,
                                        &offsetElement,
                                        1);
                Offset += offsetElement.DataLength;
    } else {
        rc = (Hive->FileWrite)( Hive,
                                HFILE_TYPE_EXTERNAL,
                                &offsetElement,
                                1,
                                &Offset );
    }

    if (rc == FALSE) {
        return STATUS_REGISTRY_IO_FAILED;
    }
    if ( ! (Hive->FileFlush)(Hive, HFILE_TYPE_EXTERNAL,NULL,0)) {
        return STATUS_REGISTRY_IO_FAILED;
    }
    Offset = ROUND_UP(Offset, HBLOCK_SIZE);

    //
    // --- Write out data (ALL !!!) ---
    //
    BinOffset = 0;
    while (BinOffset < Hive->Storage[Stable].Length) {
        //
        // we need to grab the viewlock here to protect against a racing HvGetCell
        //
        CmLockHiveViews ((PCMHIVE)Hive);
        Me = HvpGetCellMap(Hive, BinOffset);
       
        if( (Me->BinAddress & (HMAP_INPAGEDPOOL|HMAP_INVIEW)) == 0) {
            //
            // view is not mapped, neither in paged pool try to map it.
                        //
            if( !NT_SUCCESS(CmpMapThisBin((PCMHIVE)Hive,BinOffset,TRUE)) ) {
                CmUnlockHiveViews ((PCMHIVE)Hive);
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto ErrorExit;
            }
        }
        //
        // reference the view so it doesn't go away from under us;
        // first remove any old ref
        //
        if( Me->BinAddress & HMAP_INVIEW ) {
            CmpDereferenceHiveView((PCMHIVE)Hive,CmView);
            CmpReferenceHiveView((PCMHIVE)Hive,CmView = Me->CmView);
        }
        CmUnlockHiveViews ((PCMHIVE)Hive);

        if( Me->BinAddress & HMAP_DISCARDABLE ) {
            //
            // bin is discardable. If it is not discarded yet, save it as it is
            // else, allocate, initialize and save a fake bin
            //
            FreeBin = (PFREE_HBIN)Me->BlockAddress;
            BinSize = FreeBin->Size;
            if( FreeBin->Flags & FREE_HBIN_DISCARDABLE ){ 
                //
                // HBIN still in memory
                //
                Address = (PVOID)HBIN_BASE(Me->BinAddress);
            } else {
                //
                // HBIN discarded, we have to allocate a new bin and mark it as a 
                // BIG free cell
                //
                // don't charge quota for it as we will give it back
                Bin = (PHBIN)ExAllocatePoolWithTag(PagedPool, BinSize, CM_HVBIN_TAG);
                if( Bin == NULL ){
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto ErrorExit;
                }
                //
                // make sure we don't leak whatever is in the kernel pool out of the box (roaming).
                //
                RtlZeroMemory(Bin,BinSize);
                //
                // Initialize the bin
                //
                Bin->Signature = HBIN_SIGNATURE;
                Bin->FileOffset = BinOffset;
                Bin->Size = BinSize;
                FirstCell = (PHCELL)(Bin+1);
                FirstCell->Size = BinSize - sizeof(HBIN);
                if (USE_OLD_CELL(Hive)) {
                    FirstCell->u.OldCell.Last = (ULONG)HBIN_NIL;
                }
                Address = (PVOID)Bin;
            }
        } else {
            Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
            ASSERT( Bin->Signature == HBIN_SIGNATURE );
            ASSERT( Bin->FileOffset == BinOffset );
            Address = (PVOID)Bin;
            try {
                BinSize = Bin->Size;
            } except (EXCEPTION_EXECUTE_HANDLER) {
                //
                // in low-memory scenarios or disk error, touching the bin may throw STATUS_IN_PAGE_ERROR
                //
                status = GetExceptionCode();
                goto ErrorExit;
            }
        }

        //
        // write the bin to the file
        //
        offsetElement.FileOffset = Offset;
        offsetElement.DataBuffer = Address;
        offsetElement.DataLength = BinSize;

        if(WriteThroughCache) {
            
            //
            // if we use Cc, do the write with the pin interface
            // Take extra care not to cross the view boundaries
            //

            if( HvpCheckViewBoundary(Offset - HBLOCK_SIZE,Offset - HBLOCK_SIZE + BinSize - 1) ) {
                rc = CmpFileWriteThroughCache( Hive,
                                               HFILE_TYPE_EXTERNAL,
                                               &offsetElement,
                                               1);
            } else {
                //
                // write one HBLOCK_SIZE at a time.
                //
                ULONG   ToWrite = BinSize;
                offsetElement.DataLength = HBLOCK_SIZE;
                while( ToWrite > 0 ) {
                    rc = CmpFileWriteThroughCache( Hive,
                                                   HFILE_TYPE_EXTERNAL,
                                                   &offsetElement,
                                                   1);
                    if( rc == FALSE ) {
                        status = STATUS_REGISTRY_IO_FAILED;
                        goto ErrorExit;
                    }
                   
                    ToWrite -= HBLOCK_SIZE;
                    offsetElement.DataBuffer = (PUCHAR)offsetElement.DataBuffer + HBLOCK_SIZE;
                    offsetElement.FileOffset += HBLOCK_SIZE;
                }
            }
            Offset += BinSize;
        } else {
            rc = (Hive->FileWrite)( Hive,
                                    HFILE_TYPE_EXTERNAL,
                                    &offsetElement,
                                    1,
                                    &Offset );
        }
        if (rc == FALSE) {
            status = STATUS_REGISTRY_IO_FAILED;
            goto ErrorExit;
        }

        if( Me->BinAddress & HMAP_DISCARDABLE ) {
            if( (FreeBin->Flags & FREE_HBIN_DISCARDABLE) == 0){ 
                ASSERT( FreeBin == (PFREE_HBIN)Me->BlockAddress );
                ASSERT( Bin );
                //
                // give back the paged pool used
                //
                ExFreePool(Bin);
            }
        }

        //
        // advance to the next bin
        //
        BinOffset += BinSize;

    }
    //
    // let go last view referenced (if any)
    //
    CmpDereferenceHiveViewWithLock((PCMHIVE)Hive,CmView);

    if ( ! (Hive->FileFlush)(Hive, HFILE_TYPE_EXTERNAL,NULL,0)) {
        return STATUS_REGISTRY_IO_FAILED;
    }

    if( CrashSafe ) {
        //
        // change sequence numbers, in case we experience a machine crash
        //
        BaseBlock->Sequence2++;
        BaseBlock->CheckSum = HvpHeaderCheckSum(BaseBlock);

        ASSERT( BaseBlock->Sequence1 == BaseBlock->Sequence2 );

        Offset = 0;
        offsetElement.FileOffset = Offset;
        offsetElement.DataBuffer = (PVOID) BaseBlock;
        offsetElement.DataLength = HSECTOR_SIZE * Hive->Cluster;
        if(WriteThroughCache) {
            //
            // if we use Cc, do the write with the pin interface
            //
            rc = CmpFileWriteThroughCache( Hive,
                                           HFILE_TYPE_EXTERNAL,
                                           &offsetElement,
                                           1);
                    Offset += offsetElement.DataLength;
        } else {
            rc = (Hive->FileWrite)( Hive,
                                    HFILE_TYPE_EXTERNAL,
                                    &offsetElement,
                                    1,
                                    &Offset );
        }

        if (rc == FALSE) {
            return STATUS_REGISTRY_IO_FAILED;
        }
        if ( ! (Hive->FileFlush)(Hive, HFILE_TYPE_EXTERNAL,NULL,0)) {
            return STATUS_REGISTRY_IO_FAILED;
        }
        if( DontGrow ){
            //
            // file has shrunk
            //
            CmpDoFileSetSize(Hive,HFILE_TYPE_EXTERNAL,Length + HBLOCK_SIZE,0);
        }
    }

    // it seems like everything went OK
    return STATUS_SUCCESS;
ErrorExit:
    CmpDereferenceHiveViewWithLock((PCMHIVE)Hive,CmView);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\hivesum.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    hivesum.c

Abstract:

    Hive header checksum module.

--*/

#include    "cmp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HvpHeaderCheckSum)
#endif

ULONG
HvpHeaderCheckSum(
    PHBASE_BLOCK    BaseBlock
    )
/*++

Routine Description:

    Compute the checksum for a hive disk header.

Arguments:

    BaseBlock - supplies pointer to the header to checksum

Return Value:

    the check sum.

--*/
{
    ULONG   sum;
    ULONG   i;

    sum = 0;
    for (i = 0; i < 127; i++) {
        sum ^= ((PULONG)BaseBlock)[i];
    }
    if (sum == (ULONG)-1) {
        sum = (ULONG)-2;
    }
    if (sum == 0) {
        sum = 1;
    }
    return sum;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\hiveload.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    hiveload.c

Abstract:

    This module implements procedures to read a hive into memory, applying
    logs, etc.

    NOTE:   Alternate image loading is not supported here, that is
            done by the boot loader.

Revision History:

    Implementation of bin-size chunk loading of hives.

    64K IO reads when loading the hive

--*/

#include    "cmp.h"

typedef enum _RESULT {
    NotHive,
    Fail,
    NoMemory,
    HiveSuccess,
    RecoverHeader,
    RecoverData,
    SelfHeal
} RESULT;

RESULT
HvpGetHiveHeader(
    PHHIVE          Hive,
    PHBASE_BLOCK    *BaseBlock,
    PLARGE_INTEGER  TimeStamp
    );

RESULT
HvpGetLogHeader(
    PHHIVE          Hive,
    PHBASE_BLOCK    *BaseBlock,
    PLARGE_INTEGER  TimeStamp
    );

RESULT
HvpRecoverData(
    PHHIVE          Hive
    );

NTSTATUS
HvpReadFileImageAndBuildMap(
                            PHHIVE  Hive,
                            ULONG   Length
                            );

NTSTATUS
HvpMapFileImageAndBuildMap(
                            PHHIVE  Hive,
                            ULONG   Length
                            );

VOID
HvpDelistBinFreeCells(
    PHHIVE  Hive,
    PHBIN   Bin,
    HSTORAGE_TYPE Type
    );

NTSTATUS
HvpRecoverWholeHive(PHHIVE  Hive,
                    ULONG   FileOffset);
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HvMapHive)
#pragma alloc_text(PAGE,HvLoadHive)
#pragma alloc_text(PAGE,HvpGetHiveHeader)
#pragma alloc_text(PAGE,HvpGetLogHeader)
#pragma alloc_text(PAGE,HvpRecoverData)
#pragma alloc_text(PAGE,HvpReadFileImageAndBuildMap)
#pragma alloc_text(PAGE,HvpMapFileImageAndBuildMap)
#pragma alloc_text(PAGE,HvpRecoverWholeHive)
#pragma alloc_text(PAGE,HvCloneHive)
#pragma alloc_text(PAGE,HvShrinkHive)
#endif

extern  PUCHAR      CmpStashBuffer;
extern  ULONG       CmpStashBufferSize;

extern struct {
    PHHIVE      Hive;
    ULONG       Status;
    ULONG       Space;
    HCELL_INDEX MapPoint;
    PHBIN       BinPoint;
} HvCheckHiveDebug;

extern struct {
    PHHIVE      Hive;
    ULONG       FileOffset;
    ULONG       FailPoint; // look in HvpRecoverData for exact point of failure
} HvRecoverDataDebug;

NTSTATUS
HvMapHive(
    PHHIVE  Hive
    )
/*++

Routine Description:

    Hive must be fully initialized, in particular, file handles
    must be set up.  This routine is not intended for loading hives
    from images already in memory.

    This routine will apply whatever fixes are available for errors
    in the hive image.  In particular, if a log exists, and is applicable,
    this routine will automatically apply it.

    The difference from HvLoadHive is that this routine is NOT loading the 
    hive into memory. It instead maps view of the hive in memory and does 
    the bin enlisting and hive checking stuff.

    If errors are detected, the memory hive-loading is performed, log is applied
    and then bins are discarded.

    ALGORITHM:

        call HvpGetHiveHeader()

        if (NoMemory or NoHive)
            return failure

        if (RecoverData or RecoverHeader) and (no log)
            return failure

        if (RecoverHeader)
            call HvpGetLogHeader
            if (fail)
                return failure
            fix up baseblock

        Read Data

        if (RecoverData or RecoverHeader)
            HvpRecoverData
            return STATUS_REGISTRY_RECOVERED

        clean up sequence numbers

        return success OR STATUS_REGISTRY_RECOVERED

    If STATUS_REGISTRY_RECOVERED is returned, then

        If (Log) was used, DirtyVector and DirtyCount are set,
            caller is expected to flush the changes (using a
            NEW log file)

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    TailDisplay - array containing the tail ends of the free cell lists - optional

Return Value:

    STATUS:

        STATUS_INSUFFICIENT_RESOURCES   - memory alloc failure, etc
        STATUS_NOT_REGISTRY_FILE        - bad signatures and the like
        STATUS_REGISTRY_CORRUPT         - bad signatures in the log,
                                          bad stuff in both in alternate,
                                          inconsistent log

        STATUS_REGISTRY_IO_FAILED       - data read failed

        STATUS_RECOVERED                - successfully recovered the hive,
                                          a semi-flush of logged data
                                          is necessary.

        STATUS_SUCCESS                  - it worked, no recovery needed

--*/
{
    PHBASE_BLOCK    BaseBlock;
    ULONG           result1;
    ULONG           result2;
    NTSTATUS        status;
    LARGE_INTEGER   TimeStamp;

#if DBG
    UNICODE_STRING  HiveName;
#endif

    ASSERT(Hive->Signature == HHIVE_SIGNATURE);

    BaseBlock = NULL;
    result1 = HvpGetHiveHeader(Hive, &BaseBlock, &TimeStamp);

    //
    // bomb out for total errors
    //
    if (result1 == NoMemory) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit1;
    }
    if (result1 == NotHive) {
        status = STATUS_NOT_REGISTRY_FILE;
        goto Exit1;
    }

    //
    // if recovery needed, and no log, bomb out
    //
    if ( ((result1 == RecoverData) ||
          (result1 == RecoverHeader))  &&
          (Hive->Log == FALSE) )
    {
        status = STATUS_REGISTRY_CORRUPT;
        goto Exit1;
    }

    //
    // need to recover header using log, so try to get it from log
    //
    if (result1 == RecoverHeader) {
        result2 = HvpGetLogHeader(Hive, &BaseBlock, &TimeStamp);
        if (result2 == NoMemory) {
            status =  STATUS_INSUFFICIENT_RESOURCES;
            goto Exit1;
        }
        if (result2 == Fail) {
            status = STATUS_REGISTRY_CORRUPT;
            goto Exit1;
        }
        BaseBlock->Type = HFILE_TYPE_PRIMARY;
        if( result2 == SelfHeal ) {
            //
            // tag as self heal so we can fire a warning later on.
            //
            BaseBlock->BootType = HBOOT_SELFHEAL;
        } else {
            BaseBlock->BootType = 0;
        }
    } else {
        BaseBlock->BootType = 0;
    }

    Hive->BaseBlock = BaseBlock;
    Hive->Version = Hive->BaseBlock->Minor;

#if DBG
    RtlInitUnicodeString(&HiveName, (PCWSTR)Hive->BaseBlock->FileName);
#endif

    status = HvpAdjustHiveFreeDisplay(Hive,BaseBlock->Length,Stable);
    if( !NT_SUCCESS(status) ) {
        goto Exit1;
    }

    //
    // at this point, we have a sane baseblock.  we know for sure that the 
    // pimary registry file is valid, so we don't need any data recovery
    //

#if DBG
    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"Aquiring FileObject for hive (%p) (%.*S) ...",Hive,HiveName.Length / sizeof(WCHAR),HiveName.Buffer));
#endif
    status = CmpAcquireFileObjectForFile((PCMHIVE)Hive,((PCMHIVE)Hive)->FileHandles[HFILE_TYPE_PRIMARY],&(((PCMHIVE)Hive)->FileObject));
#if DBG
    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL," Status = %lx\n",status));
    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"Initializing HiveViewList for hive (%p) (%.*S) \n\n",Hive,HiveName.Length / sizeof(WCHAR),HiveName.Buffer));
#endif

    if( !NT_SUCCESS(status) ) {
        //
        // if status is STATUS_RETRY, top level routine will try to load it in the old fashioned way
        //
        goto Exit1;
    }

    CmpPrefetchHiveFile( ((PCMHIVE)Hive)->FileObject,BaseBlock->Length);

    //
    // we need to make sure all the cell's data is faulted in inside a 
    // try/except block, as the IO to fault the data in can throw exceptions
    // STATUS_INSUFFICIENT_RESOURCES, in particular
    //

    try {

        status = HvpMapFileImageAndBuildMap(Hive,BaseBlock->Length);

        //
        // if STATUS_REGISTRY_CORRUPT and RecoverData don't bail out, keep recovering
        //
        if( !NT_SUCCESS(status) ) {
            //
            // need recovery but none available (RecoverHeader implies recover data).
            //
            if( (status !=  STATUS_REGISTRY_CORRUPT) && (status !=  STATUS_REGISTRY_RECOVERED) ) {
                goto Exit2;
            }
            if( (status == STATUS_REGISTRY_CORRUPT) && (result1 != RecoverData) && (result1 != RecoverHeader) ) {
                goto Exit2;
            }
            //
            // in case the above call returns STATUS_REGISTRY_RECOVERED, we should be sefl healing the hive
            //
            ASSERT( (status != STATUS_REGISTRY_RECOVERED) || CmDoSelfHeal() );
        }
    
        //
        // apply data recovery if we need it
        //
        if ( (result1 == RecoverHeader) ||      // -> implies recover data
             (result1 == RecoverData) )
        {
            result2 = HvpRecoverData(Hive);
            if (result2 == NoMemory) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto Exit2;
            }
            if (result2 == Fail) {
                status = STATUS_REGISTRY_CORRUPT;
                goto Exit2;
            }
            status = STATUS_REGISTRY_RECOVERED;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"HvMapHive: exception thrown ehile faulting in data, code:%08lx\n", GetExceptionCode()));
        status = GetExceptionCode();
        goto Exit2;
    }

    BaseBlock->Sequence2 = BaseBlock->Sequence1;
    return status;


Exit2:
    //
    // Clean up the bins already allocated 
    //
    HvpFreeAllocatedBins( Hive );

    //
    // Clean up the directory table
    //
    HvpCleanMap( Hive );

Exit1:
    if (BaseBlock != NULL) {
        (Hive->Free)(BaseBlock, Hive->BaseBlockAlloc);
    }

    Hive->BaseBlock = NULL;
    Hive->DirtyCount = 0;
    return status;
}

//
// This routine loads the hive into paged pool. We might not need it anymore!
// Support will be dropped as we see fit.
//
NTSTATUS
HvLoadHive(
    PHHIVE  Hive
    )
/*++

Routine Description:

    Hive must be fully initialized, in particular, file handles
    must be set up.  This routine is not intended for loading hives
    from images already in memory.

    This routine will apply whatever fixes are available for errors
    in the hive image.  In particular, if a log exists, and is applicable,
    this routine will automatically apply it.

    ALGORITHM:

        call HvpGetHiveHeader()

        if (NoMemory or NoHive)
            return failure

        if (RecoverData or RecoverHeader) and (no log)
            return failure

        if (RecoverHeader)
            call HvpGetLogHeader
            if (fail)
                return failure
            fix up baseblock

        Read Data

        if (RecoverData or RecoverHeader)
            HvpRecoverData
            return STATUS_REGISTRY_RECOVERED

        clean up sequence numbers

        return success OR STATUS_REGISTRY_RECOVERED

    If STATUS_REGISTRY_RECOVERED is returned, then

        If (Log) was used, DirtyVector and DirtyCount are set,
            caller is expected to flush the changes (using a
            NEW log file)

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    TailDisplay - array containing the tail ends of the free cell lists - optional

Return Value:

    STATUS:

        STATUS_INSUFFICIENT_RESOURCES   - memory alloc failure, etc
        STATUS_NOT_REGISTRY_FILE        - bad signatures and the like
        STATUS_REGISTRY_CORRUPT         - bad signatures in the log,
                                          bad stuff in both in alternate,
                                          inconsistent log

        STATUS_REGISTRY_IO_FAILED       - data read failed

        STATUS_RECOVERED                - successfully recovered the hive,
                                          a semi-flush of logged data
                                          is necessary.

        STATUS_SUCCESS                  - it worked, no recovery needed

--*/
{
    PHBASE_BLOCK    BaseBlock;
    ULONG           result1;
    ULONG           result2;
    NTSTATUS        status;
    LARGE_INTEGER   TimeStamp;
    ASSERT(Hive->Signature == HHIVE_SIGNATURE);

    BaseBlock = NULL;
    result1 = HvpGetHiveHeader(Hive, &BaseBlock, &TimeStamp);

    //
    // bomb out for total errors
    //
    if (result1 == NoMemory) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit1;
    }
    if (result1 == NotHive) {
        status = STATUS_NOT_REGISTRY_FILE;
        goto Exit1;
    }

    //
    // if recovery needed, and no log, bomb out
    //
    if ( ((result1 == RecoverData) ||
          (result1 == RecoverHeader))  &&
          (Hive->Log == FALSE) )
    {
        status = STATUS_REGISTRY_CORRUPT;
        goto Exit1;
    }

    //
    // need to recover header using log, so try to get it from log
    //
    if (result1 == RecoverHeader) {
        result2 = HvpGetLogHeader(Hive, &BaseBlock, &TimeStamp);
        if (result2 == NoMemory) {
            status =  STATUS_INSUFFICIENT_RESOURCES;
            goto Exit1;
        }
        if (result2 == Fail) {
            status = STATUS_REGISTRY_CORRUPT;
            goto Exit1;
        }
        BaseBlock->Type = HFILE_TYPE_PRIMARY;
        if( result2 == SelfHeal ) {
            //
            // tag as self heal so we can fire a warning later on.
            //
            BaseBlock->BootType = HBOOT_SELFHEAL;
        } else {
            BaseBlock->BootType = 0;
        }
    } else {
        BaseBlock->BootType = 0;
    }
    Hive->BaseBlock = BaseBlock;
    Hive->Version = Hive->BaseBlock->Minor;

    status = HvpAdjustHiveFreeDisplay(Hive,BaseBlock->Length,Stable);
    if( !NT_SUCCESS(status) ) {
        goto Exit1;
    }
    //
    // at this point, we have a sane baseblock.  we may or may not still
    // need to apply data recovery
    //
    status = HvpReadFileImageAndBuildMap(Hive,BaseBlock->Length);
    
    
    //
    // if STATUS_REGISTRY_CORRUPT and RecoverData don't bail out, keep recovering
    //
    if( !NT_SUCCESS(status) ) {
        //
        // need recovery but none available (RecoverHeader implies recover data).
        //
        if( (status !=  STATUS_REGISTRY_CORRUPT) && (status !=  STATUS_REGISTRY_RECOVERED) ) {
            goto Exit2;
        }
        if( (status == STATUS_REGISTRY_CORRUPT) && (result1 != RecoverData) && (result1 != RecoverHeader) ) {
            goto Exit2;
        }
        //
        // in case the above call returns STATUS_REGISTRY_RECOVERED, we should be self healing the hive
        //
        ASSERT( (status != STATUS_REGISTRY_RECOVERED) || CmDoSelfHeal() );
    }
    
    //
    // apply data recovery if we need it
    //
    if ( (result1 == RecoverHeader) ||      // -> implies recover data
         (result1 == RecoverData) )
    {
        result2 = HvpRecoverData(Hive);
        if (result2 == NoMemory) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit2;
        }
        if (result2 == Fail) {
            status = STATUS_REGISTRY_CORRUPT;
            goto Exit2;
        }
        status = STATUS_REGISTRY_RECOVERED;
    }

    BaseBlock->Sequence2 = BaseBlock->Sequence1;
    return status;


Exit2:
    //
    // Clean up the bins already allocated 
    //
    HvpFreeAllocatedBins( Hive );

    //
    // Clean up the directory table
    //
    HvpCleanMap( Hive );

Exit1:
    if (BaseBlock != NULL) {
        (Hive->Free)(BaseBlock, Hive->BaseBlockAlloc);
    }

    Hive->BaseBlock = NULL;
    Hive->DirtyCount = 0;
    return status;
}

NTSTATUS
HvpReadFileImageAndBuildMap(
                            PHHIVE  Hive,
                            ULONG   Length
                            )

/*++

Routine Description:

    Read the hive from the file and allocate storage for the hive
    image in chunks of HBINs. Build the hive map "on the fly".
        Optimized to read chunks of 64K from the file.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Length - the length of the hive, in bytes

    TailDisplay - array containing the tail ends of the free cell lists - optional

Return Value:

    STATUS:

        STATUS_INSUFFICIENT_RESOURCES   - memory alloc failure, etc

        STATUS_REGISTRY_IO_FAILED       - data read failed

        STATUS_REGISTRY_CORRUPT         - base block is corrupt

        STATUS_SUCCESS                  - it worked

--*/
{
    ULONG           FileOffset;
    NTSTATUS        Status = STATUS_SUCCESS;
    PHBIN           Bin;                        // current bin
    ULONG           BinSize = 0;        // size of the current bin
    ULONG           BinOffset = 0;      // current offset inside current bin
    ULONG           BinFileOffset;  // physical offset of the bin in the file (used for consistency checking)
    ULONG           BinDataInBuffer;// the amount of data needed to be copied in the current bin available in the buffer
    ULONG           BinDataNeeded;  // 
    PUCHAR                      IOBuffer;
    ULONG           IOBufferSize;       // valid data in IOBuffer (only at the end of the file this is different than IO_BUFFER_SIZE)
    ULONG           IOBufferOffset;     // current offset inside IOBuffer
    NTSTATUS        Status2 = STATUS_SUCCESS; // used to force recoverData upon exit
    BOOLEAN         MarkBinDirty;

    //
    // Init the map
    //
    Status = HvpInitMap(Hive);

    if( !NT_SUCCESS(Status) ) {
        //
        // return failure 
        //
        return Status;
    }

    //
    // Allocate a IO_BUFFER_SIZE for I/O operations from paged pool. 
	// It will be freed at the end of the function.
    //
    IOBuffer = (PUCHAR)ExAllocatePool(PagedPool, IO_BUFFER_SIZE);
    if (IOBuffer == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        HvpCleanMap( Hive );
        return Status;
    }

    //
    // Start right after the hive header
    //
    FileOffset = HBLOCK_SIZE;
    BinFileOffset = FileOffset;
    Bin = NULL;

    //
    // outer loop : reads IO_BUFFER_SIZE chunks from the file
    //
    while( FileOffset < (Length + HBLOCK_SIZE) ) {
        //
        // we are at the beginning of the IO buffer
        //
        IOBufferOffset = 0;

        //
        // the buffer size will be either IO_BufferSize, or the amount 
        // uread from the file (when this is smaller than IO_BUFFER_SIZE)
        //
        IOBufferSize = Length + HBLOCK_SIZE - FileOffset;
        IOBufferSize = ( IOBufferSize > IO_BUFFER_SIZE ) ? IO_BUFFER_SIZE : IOBufferSize;
        
        ASSERT( (IOBufferSize % HBLOCK_SIZE) == 0 );
        
        //
        // read data from the file
        //
        if ( ! (Hive->FileRead)(
                        Hive,
                        HFILE_TYPE_PRIMARY,
                        &FileOffset,
                        (PVOID)IOBuffer,
                        IOBufferSize
                        )
           )
        {
            Status = STATUS_REGISTRY_IO_FAILED;
            goto ErrorExit;
        }
        
        //
        // inner loop: breaks the buffer into bins
        //
        while( IOBufferOffset < IOBufferSize ) {

            MarkBinDirty = FALSE;
            if( Bin == NULL ) {
                //
                // this is the beginning of a new bin
                // perform bin validation and allocate the bin
                //
                // temporary bin points to the current location inside the buffer
                Bin = (PHBIN)(IOBuffer + IOBufferOffset);
                //
                // Check the validity of the bin header
                //
                BinSize = Bin->Size;
                if ( (BinSize > Length)                         ||
                     (BinSize < HBLOCK_SIZE)                    ||
                     (Bin->Signature != HBIN_SIGNATURE)         ||
                     (Bin->FileOffset != (BinFileOffset - HBLOCK_SIZE) )) {
                    //
                    // Bin is bogus
                    //
                    Bin = (PHBIN)(Hive->Allocate)(HBLOCK_SIZE, TRUE,CM_FIND_LEAK_TAG30);
                    if (Bin == NULL) {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto ErrorExit;
                    }
                    //
                    // copy the data already read in the first HBLOCK of the bin
                    //
                    RtlCopyMemory(Bin,(IOBuffer + IOBufferOffset), HBLOCK_SIZE);
                    
                    Status2 = STATUS_REGISTRY_CORRUPT;
                    HvCheckHiveDebug.Hive = Hive;
                    HvCheckHiveDebug.Status = 0xA001;
                    HvCheckHiveDebug.Space = Length;
                    HvCheckHiveDebug.MapPoint = BinFileOffset - HBLOCK_SIZE;
                    HvCheckHiveDebug.BinPoint = Bin;
            
                    //goto ErrorExit;
                    //
                    // DO NOT EXIT; Fix this bin header and go on. RecoverData should fix it.
                    // If not, CmCheckRegistry called later will prevent loading of an invalid hive
                    //
                    // NOTE: Still, mess the signature, to make sure that if this particular bin doesn't get recovered, 
                    //       we'll fail the hive loading request.
                    //
                    if( CmDoSelfHeal() ) {
                        //
                        // put the correct signature, fileoffset and binsize in place;
                        // HvEnlistBinInMap will take care of the cells consistency.
                        //
                        Bin->Signature = HBIN_SIGNATURE;
                        Bin->FileOffset = BinFileOffset - HBLOCK_SIZE;
                        if ( ((Bin->FileOffset + BinSize) > Length)   ||
                             (BinSize < HBLOCK_SIZE)            ||
                             (BinSize % HBLOCK_SIZE) ) {
                            BinSize = Bin->Size = HBLOCK_SIZE;
                        }
                        //
                        // signal back to the caller that we have altered the hive.
                        //
                        Status2 = STATUS_REGISTRY_RECOVERED;
                        CmMarkSelfHeal(Hive);
                        //
                        // mark the bin dirty after enlisting.
                        //
                        MarkBinDirty = TRUE;
                    } else {
                        Bin->Signature = 0; //TRICK!!!!
                        BinSize = Bin->Size = HBLOCK_SIZE;
                        Bin->FileOffset = BinOffset;
                        //
                        // simulate as the entire bin is a used cell
                        //
                        ((PHCELL)((PUCHAR)Bin + sizeof(HBIN)))->Size = sizeof(HBIN) - BinSize; //TRICK!!!!
                    }
                    //
                    // Now that we have the entire bin in memory, Enlist It!
                    //
                    Status = HvpEnlistBinInMap(Hive, Length, Bin, BinFileOffset - HBLOCK_SIZE, NULL);

                    if( CmDoSelfHeal() && ((Status == STATUS_REGISTRY_RECOVERED) || MarkBinDirty) ) {
                        //
                        // self heal: enlist fixed the bin
                        //
                        Status2 = STATUS_REGISTRY_RECOVERED;
                        Status = STATUS_SUCCESS;
                        CmMarkSelfHeal(Hive);
                        //
                        // we are in self-heal mode and we have changed data in the bin; mark it all dirty.
                        //
                        HvMarkDirty(Hive,BinOffset,BinSize,TRUE);
                        HvMarkDirty(Hive, 0, sizeof(HBIN),TRUE);  // force header of 1st bin dirty
                    }

                    if( !NT_SUCCESS(Status) ) {
                        goto ErrorExit;
                    }
                    
                    //
                    // Adjust the offsets
                    //
                    BinFileOffset += Bin->Size;
                    IOBufferOffset += Bin->Size;
                    
                    //
                    // another bin is on his way 
                    //
                    Bin = NULL;
                } else {
                    //
                    // bin is valid; allocate a pool chunk of the right size
                    //
                    Bin = (PHBIN)(Hive->Allocate)(BinSize, TRUE,CM_FIND_LEAK_TAG31);
                    if (Bin == NULL) {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto ErrorExit;
                    }
            
                    //
                    // the chunk is allocated; set the offset inside the bin and continue
                    // the next iteration of the inner loop will start by copying data in this bin
                    //
                    BinOffset = 0;
                }
            } else {
                //
                // if we are here, the bin is allocated, the BinSize and BinOffset are set
                // We have to calculate how much for this bin is available in the buffer,
                // and copy it. If we finished with this bin, enlist it and mark the beginning of a new one
                //
                ASSERT( Bin != NULL );
                BinDataInBuffer = (IOBufferSize - IOBufferOffset);
                BinDataNeeded = (BinSize - BinOffset);
                
                if( BinDataInBuffer >= BinDataNeeded ) {
                    //
                    // we have available more than what we need; Finish the bin
                    //
                    RtlCopyMemory(((PUCHAR)Bin + BinOffset),(IOBuffer + IOBufferOffset), BinDataNeeded);
                    //
                    // enlist it
                    //
                    Status = HvpEnlistBinInMap(Hive, Length, Bin, BinFileOffset - HBLOCK_SIZE, NULL);

                    if( CmDoSelfHeal() && (Status == STATUS_REGISTRY_RECOVERED) ) {
                        //
                        // self heal: enlist fixed the bin
                        //
                        Status2 = STATUS_REGISTRY_RECOVERED;
                        Status = STATUS_SUCCESS;
                        CmMarkSelfHeal(Hive);
                        //
                        // we are in self-heal mode and we have changed data in the bin; mark it all dirty.
                        //
                        HvMarkDirty(Hive,BinOffset,BinSize,TRUE);
                        HvMarkDirty(Hive, 0, sizeof(HBIN),TRUE);  // force header of 1st bin dirty
                    }

                    if( !NT_SUCCESS(Status) ) {
                        goto ErrorExit;
                    }
                    //
                    // Adjust the offsets
                    //
                    BinFileOffset += BinSize;
                    IOBufferOffset += BinDataNeeded;
                    //
                    // mark the beginning of a new bin
                    //
                    Bin = NULL;
                } else {
                    //
                    // we do not have all bin data in the buffer
                    // copy what we can 
                    //
                    RtlCopyMemory(((PUCHAR)Bin + BinOffset),(IOBuffer + IOBufferOffset), BinDataInBuffer);
                    
                    //
                    // adjust the offsets; this should be the last iteration of the inner loop
                    //
                    BinOffset += BinDataInBuffer;
                    IOBufferOffset += BinDataInBuffer;

                    // 
                    // if we are here, the buffer must have been exhausted  
                    //
                    ASSERT( IOBufferOffset == IOBufferSize );
                }
            }
        }
    }

    //
    // if we got here, we shouldn't have a bin under construction
    //
    ASSERT( Bin == NULL );

    //
    // Free the buffer used for I/O operations
    //
    ExFreePool(IOBuffer);

    Status = NT_SUCCESS(Status)?Status2:Status;

    return Status;

ErrorExit:
    //
    // Free the buffer used for I/O operations
    //
    ExFreePool(IOBuffer);

    return Status;
}

RESULT
HvpGetHiveHeader(
    PHHIVE          Hive,
    PHBASE_BLOCK    *BaseBlock,
    PLARGE_INTEGER  TimeStamp
    )
/*++

Routine Description:

    Examine the base block sector and possibly the first sector of
    the first bin, and decide what (if any) recovery needs to be applied
    based on what we find there.

    ALGORITHM:

        read BaseBlock from offset 0
        if ( (I/O error)    OR
             (checksum wrong) )
        {
            read bin block from offset HBLOCK_SIZE (4k)
            if (2nd I/O error)
                return NotHive
            }
            check bin sign., offset.
            if (OK)
                return RecoverHeader, TimeStamp=from Link field
            } else {
                return NotHive
            }
        }

        if (wrong type or signature or version or format)
            return NotHive
        }

        if (seq1 != seq2) {
            return RecoverData, TimeStamp=BaseBlock->TimeStamp, valid BaseBlock
        }

        return ReadData, valid BaseBlock

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    BaseBlock - supplies pointer to variable to receive pointer to
            HBASE_BLOCK, if we can successfully read one.

    TimeStamp - pointer to variable to receive time stamp (serial number)
            of hive, be it from the baseblock or from the Link field
            of the first bin.

Return Value:

    RESULT code

--*/
{
    PHBASE_BLOCK    buffer;
    BOOLEAN         rc;
    ULONG           FileOffset;
    ULONG           Alignment;

    ASSERT(sizeof(HBASE_BLOCK) >= (HSECTOR_SIZE * Hive->Cluster));

    //
    // allocate buffer to hold base block
    //
    *BaseBlock = NULL;
    buffer = (PHBASE_BLOCK)((Hive->Allocate)(Hive->BaseBlockAlloc, TRUE,CM_FIND_LEAK_TAG32));
    if (buffer == NULL) {
        return NoMemory;
    }
    //
    // Make sure the buffer we got back is cluster-aligned. If not, try
    // harder to get an aligned buffer.
    //
    Alignment = Hive->Cluster * HSECTOR_SIZE - 1;
    if (((ULONG_PTR)buffer & Alignment) != 0) {
        (Hive->Free)(buffer, Hive->BaseBlockAlloc);
        buffer = (PHBASE_BLOCK)((Hive->Allocate)(PAGE_SIZE, TRUE,CM_FIND_LEAK_TAG33));
        if (buffer == NULL) {
            return NoMemory;
        }
        Hive->BaseBlockAlloc = PAGE_SIZE;
    }
    RtlZeroMemory((PVOID)buffer, sizeof(HBASE_BLOCK));

    //
    // attempt to read base block
    //
    FileOffset = 0;
    rc = (Hive->FileRead)(Hive,
                          HFILE_TYPE_PRIMARY,
                          &FileOffset,
                          (PVOID)buffer,
                          HSECTOR_SIZE * Hive->Cluster);

    if ( (rc == FALSE)  ||
         (HvpHeaderCheckSum(buffer) != buffer->CheckSum)) {
        //
        // base block is toast, try the first block in the first bin
        //
        FileOffset = HBLOCK_SIZE;
        rc = (Hive->FileRead)(Hive,
                              HFILE_TYPE_PRIMARY,
                              &FileOffset,
                              (PVOID)buffer,
                              HSECTOR_SIZE * Hive->Cluster);

        if ( (rc == FALSE) ||
             ( ((PHBIN)buffer)->Signature != HBIN_SIGNATURE)           ||
             ( ((PHBIN)buffer)->FileOffset != 0)
           )
        {
            //
            // the bin is toast too, punt
            //
            (Hive->Free)(buffer, Hive->BaseBlockAlloc);
            return NotHive;
        }

        //
        // base block is bogus, but bin is OK, so tell caller
        // to look for a log file and apply recovery
        //
        *TimeStamp = ((PHBIN)buffer)->TimeStamp;
        (Hive->Free)(buffer, Hive->BaseBlockAlloc);
        return RecoverHeader;
    }

    //
    // base block read OK, but is it valid?
    //
    if ( (buffer->Signature != HBASE_BLOCK_SIGNATURE)   ||
         (buffer->Type != HFILE_TYPE_PRIMARY)           ||
         (buffer->Major != HSYS_MAJOR)                  ||
         (buffer->Minor > HSYS_MINOR_SUPPORTED)         ||
         ((buffer->Major == 1) && (buffer->Minor == 0)) ||
         (buffer->Format != HBASE_FORMAT_MEMORY)
       )
    {
        //
        // file is simply not a valid hive
        //
        (Hive->Free)(buffer, Hive->BaseBlockAlloc);
        return NotHive;
    }

    //
    // see if recovery is necessary
    //
    *BaseBlock = buffer;
    *TimeStamp = buffer->TimeStamp;
    if ( (buffer->Sequence1 != buffer->Sequence2) ) {
        return RecoverData;
    }

    return HiveSuccess;
}

RESULT
HvpGetLogHeader(
    PHHIVE          Hive,
    PHBASE_BLOCK    *BaseBlock,
    PLARGE_INTEGER  TimeStamp
    )
/*++

Routine Description:

    Read and validate log file header.  Return it if it's valid.

    ALGORITHM:

        read header
        if ( (I/O error) or
           (wrong signature,
            wrong type,
            seq mismatch
            wrong checksum,
            wrong timestamp
           )
            return Fail
        }
        return baseblock, OK

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    BaseBlock - supplies pointer to variable to receive pointer to
            HBASE_BLOCK, if we can successfully read one.

    TimeStamp - pointer to variable holding TimeStamp, which must
            match the one in the log file.

Return Value:

    RESULT

--*/
{
    PHBASE_BLOCK    buffer;
    BOOLEAN         rc;
    ULONG           FileOffset;

    ASSERT(sizeof(HBASE_BLOCK) == HBLOCK_SIZE);
    ASSERT(sizeof(HBASE_BLOCK) >= (HSECTOR_SIZE * Hive->Cluster));

    //
    // allocate buffer to hold base block
    //
    *BaseBlock = NULL;
    buffer = (PHBASE_BLOCK)((Hive->Allocate)(Hive->BaseBlockAlloc, TRUE,CM_FIND_LEAK_TAG34));
    if (buffer == NULL) {
        return NoMemory;
    }
    RtlZeroMemory((PVOID)buffer, HSECTOR_SIZE);

    //
    // attempt to read base block
    //
    FileOffset = 0;
    rc = (Hive->FileRead)(Hive,
                          HFILE_TYPE_LOG,
                          &FileOffset,
                          (PVOID)buffer,
                          HSECTOR_SIZE * Hive->Cluster);

    if ( (rc == FALSE)                                              ||
         (buffer->Signature != HBASE_BLOCK_SIGNATURE)               ||
         (buffer->Type != HFILE_TYPE_LOG)                           ||
         (buffer->Sequence1 != buffer->Sequence2)                   ||
         (HvpHeaderCheckSum(buffer) != buffer->CheckSum)            ||
         (TimeStamp->LowPart != buffer->TimeStamp.LowPart)          ||
         (TimeStamp->HighPart != buffer->TimeStamp.HighPart)) {
        
        if( CmDoSelfHeal() ) {
            //
            // We are in self healing mode; Fix the header and go on
            //
            FILE_FS_SIZE_INFORMATION        FsSizeInformation;
            IO_STATUS_BLOCK                 IoStatusBlock;
            FILE_END_OF_FILE_INFORMATION    FileInfo;
            ULONG                           Cluster;
            NTSTATUS                        Status;

            Status = ZwQueryVolumeInformationFile(
                        ((PCMHIVE)Hive)->FileHandles[HFILE_TYPE_PRIMARY],
                        &IoStatusBlock,
                        &FsSizeInformation,
                        sizeof(FILE_FS_SIZE_INFORMATION),
                        FileFsSizeInformation
                        );
            if (!NT_SUCCESS(Status)) {
                Cluster = 1;
            } else if (FsSizeInformation.BytesPerSector > HBLOCK_SIZE) {
                (Hive->Free)(buffer, Hive->BaseBlockAlloc);
                return Fail;
            }
            Cluster = FsSizeInformation.BytesPerSector / HSECTOR_SIZE;
            Cluster = (Cluster < 1) ? 1 : Cluster;

            Status = ZwQueryInformationFile(
                        ((PCMHIVE)Hive)->FileHandles[HFILE_TYPE_PRIMARY],
                        &IoStatusBlock,
                        (PVOID)&FileInfo,
                        sizeof(FILE_END_OF_FILE_INFORMATION),
                        FileEndOfFileInformation
                        );

            if(!NT_SUCCESS(Status)) {
                (Hive->Free)(buffer, Hive->BaseBlockAlloc);
                return Fail;
            } 
            buffer->Signature = HBASE_BLOCK_SIGNATURE;
            buffer->Sequence1 = buffer->Sequence2 = 1;
            buffer->Cluster = Cluster;
            buffer->Length = FileInfo.EndOfFile.LowPart - HBLOCK_SIZE;
            buffer->CheckSum = HvpHeaderCheckSum(buffer);
            *BaseBlock = buffer;
            return SelfHeal;
        } else {
            //
            // Log is unreadable, invalid, or doesn't apply the right hive
            //
            (Hive->Free)(buffer, Hive->BaseBlockAlloc);
            return Fail;
        }
    }

    *BaseBlock = buffer;
    return HiveSuccess;
}

NTSTATUS
HvpMapFileImageAndBuildMap(
                            PHHIVE  Hive,
                            ULONG   Length
                            )

/*++

Routine Description:

    map views of the file in memory and initialize the bin map.


    we are based on the assumption that no bin is crossing the CM_VIEW_SIZE boundary.
    asserts and validation code should be added later on this matter.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Length - the length of the hive, in bytes

Return Value:

    STATUS:

        STATUS_INSUFFICIENT_RESOURCES   - memory alloc failure, etc

        STATUS_REGISTRY_IO_FAILED       - data read failed

        STATUS_REGISTRY_CORRUPT         - base block is corrupt

        STATUS_SUCCESS                  - it worked

--*/
{
    NTSTATUS            Status = STATUS_SUCCESS;
    ULONG               FileOffset = 0;
    ULONG               BinOffset = 0;
    PCM_VIEW_OF_FILE    CmView;
    PHMAP_ENTRY         Me;
    PHBIN               Bin;                        // current bin
    ULONG               BinSize;                    // size of the current bin
    NTSTATUS            Status2 = STATUS_SUCCESS;   // used to force recoverData upon exit
    BOOLEAN             MarkBinDirty;

    //
    // Init the map
    //
    Status = HvpInitMap(Hive);

    if( !NT_SUCCESS(Status) ) {
        //
        // return failure 
        //
        return Status;
    }

    //
    // mark all entries in the map as invalid
    // 
    // (moved this in HvpAllocateMap).
    //
    while( BinOffset < Length) {
        Status = CmpMapCmView((PCMHIVE)Hive,BinOffset,&CmView,FALSE/*map not initialized yet*/);
        if( !NT_SUCCESS(Status) ) {
            goto ErrorExit;
        }

        //
        // touch the view
        //
        CmpTouchView((PCMHIVE)Hive,CmView,BinOffset);
        
        //
        // iterate through the map (starting with this offset)
        // the stop condition is when we get an invalid bin
        // (valid bins should be mapped in view)
        //
        while((Me = HvpGetCellMap(Hive, BinOffset)) != NULL) {
            //
            // attention here ! Bins crossing the CM_VIEW_SIZE boundary 
            // should be allocated from paged pool !!!!!
            //
            if( (Me->BinAddress & HMAP_INVIEW) == 0 ) {
                //
                // we have reached the end of the view
                //
                break;
            }
            
            Bin = (PHBIN)Me->BlockAddress;
            MarkBinDirty = FALSE;
            //
            // we should be here at the beginning of a new bin
            //
            BinSize = Bin->Size;
            if ( (BinSize > Length)                         ||
                 (BinSize < HBLOCK_SIZE)                    ||
                 (Bin->Signature != HBIN_SIGNATURE)         ||
                 (Bin->FileOffset != BinOffset ) ) {
                    //
                    // Bin is bogus
                    //
                    Status2 = STATUS_REGISTRY_CORRUPT;
                    HvCheckHiveDebug.Hive = Hive;
                    HvCheckHiveDebug.Status = 0xA001;
                    HvCheckHiveDebug.Space = Length;
                    HvCheckHiveDebug.MapPoint = BinOffset;
                    HvCheckHiveDebug.BinPoint = Bin;
            
                    //goto ErrorExit;
                    //
                    // DO NOT EXIT; Fix this bin header and go on. RecoverData should fix it.
                    // If not, CmCheckRegistry called later will prevent loading of an invalid hive
                    //
                    // NOTE: Still, mess the signature, to make sure that if this particular bin doesn't get recovered, 
                    //       we'll fail the hive loading request.
                    //
                    if( CmDoSelfHeal() ) {
                        //
                        // put the correct signature, fileoffset and binsize in place;
                        // HvEnlistBinInMap will take care of the cells consistency.
                        //
                        Bin->Signature = HBIN_SIGNATURE;
                        Bin->FileOffset = BinOffset;
                        if ( ((BinOffset + BinSize) > Length)   ||
                             (BinSize < HBLOCK_SIZE)            ||
                             (BinSize % HBLOCK_SIZE) ) {
                            BinSize = Bin->Size = HBLOCK_SIZE;
                        }
                        //
                        // signal back to the caller that we have altered the hive.
                        //
                        Status2 = STATUS_REGISTRY_RECOVERED;
                        CmMarkSelfHeal(Hive);
                        //
                        // remember to mark the bin dirty after we enlist it
                        //
                        MarkBinDirty = TRUE;
                    } else {
                        Bin->Signature = 0; //TRICK!!!!
                        BinSize = Bin->Size = HBLOCK_SIZE;
                        Bin->FileOffset = BinOffset;
                        //
                        // simulate as the entire bin is a used cell
                        //
                        ((PHCELL)((PUCHAR)Bin + sizeof(HBIN)))->Size = sizeof(HBIN) - BinSize; //TRICK!!!!
                    }
            }

            //
            // Bins crossing the CM_VIEW_SIZE boundary problem.
            // We fix it here, by loading the entire bin 
            // into paged pool
            //
            if( HvpCheckViewBoundary(BinOffset,BinOffset+BinSize-1) == FALSE ) {
                //
                // it is ilegal to fall through here if we did the trick above.
                //
                ASSERT( Bin->Signature == HBIN_SIGNATURE );
                //
                // load it in the old fashioned way (into paged pool)
                //
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"HvpMapFileImageAndBuildMap: Bin crossing CM_VIEW_SIZE boundary at BinOffset = %lx BinSize = %lx\n",BinOffset,BinSize));
                // first, allocate the bin
                Bin = (PHBIN)(Hive->Allocate)(BinSize, TRUE,CM_FIND_LEAK_TAG35);
                if (Bin == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto ErrorExit;
                }

                //
                // read data from the file
                //
                FileOffset = BinOffset + HBLOCK_SIZE;
                if ( ! (Hive->FileRead)(
                                Hive,
                                HFILE_TYPE_PRIMARY,
                                &FileOffset,
                                (PVOID)Bin,
                                BinSize
                                )
                   )
                {
                    (Hive->Free)(Bin, BinSize);
                    Status = STATUS_REGISTRY_IO_FAILED;
                    goto ErrorExit;
                }
                
                ASSERT( (FileOffset - HBLOCK_SIZE) == (BinOffset + BinSize) );
                //
                // enlist the bin as in paged pool
                //
                Status = HvpEnlistBinInMap(Hive, Length, Bin, BinOffset, NULL);
            } else {
                //
                // Now that we have the entire bin mapped in memory, Enlist It!
                //
                Status = HvpEnlistBinInMap(Hive, Length, Bin, BinOffset, CmView);
            }

            //
            // account for self healing
            //
            if( CmDoSelfHeal() && ((Status == STATUS_REGISTRY_RECOVERED) || MarkBinDirty) ) {
                Status2 = STATUS_REGISTRY_RECOVERED;
                Status = STATUS_SUCCESS;
                CmMarkSelfHeal(Hive);
                //
                // we are in self-heal mode and we have changed data in the bin; mark it all dirty.
                //
                HvMarkDirty(Hive,BinOffset,BinSize,TRUE);
                HvMarkDirty(Hive, 0, sizeof(HBIN),TRUE);  // force header of 1st bin dirty
            }
            
            //
            // advance to the new bin
            //
            BinOffset += BinSize;


            if( !NT_SUCCESS(Status) ) {
                goto ErrorExit;
            }
        }
        
    }
    
    Status = NT_SUCCESS(Status)?Status2:Status;

    return Status;

ErrorExit:
    //
    // DO NOT Clean up the directory table, as we may want to recover the hive
    //
    //if( Status != STATUS_REGISTRY_CORRUPT ) {
    //        HvpFreeAllocatedBins( Hive );
    //    HvpCleanMap( Hive );
    //}

    return Status;

}

RESULT
HvpRecoverData(
    PHHIVE          Hive
    )
/*++

Routine Description:

    Apply the corrections in the log file to the hive memory image.

    ALGORITHM:

        compute size of dirty vector
        read in dirty vector
        if (i/o error)
            return Fail

        skip first cluster of data (already processed as log)
        sweep vector, looking for runs of bits
            address of first bit is used to compute memory offset
            length of run is length of block to read
            assert always a cluster multiple
            file offset kept by running counter
            read
            if (i/o error)
                return fail

        return success

    NOTE:  This routine works with hives mapped OR loaded into paged pool

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest


Return Value:

    RESULT

--*/
{
    ULONG               Cluster;
    ULONG               ClusterSize;
    ULONG               HeaderLength;
    ULONG               VectorSize;
    PULONG              Vector;
    ULONG               FileOffset;
    ULONG               SavedOffset;
    BOOLEAN             rc;
    ULONG               Current;
    ULONG               Start;
    ULONG               End;
    ULONG               Address;
    PUCHAR              MemoryBlock;
    RTL_BITMAP          BitMap;
    ULONG               Length;
    ULONG               DirtyVectorSignature = 0;
    ULONG               RequestedReadBufferSize;
    ULONG               i;
    PHMAP_ENTRY         Me;
    PHBIN               Bin;
    PHBIN               NewBin;
    PUCHAR              SectorImage;
    PUCHAR              Source;
    PHBIN               SourceBin;
    ULONG               SectorOffsetInBin;
    ULONG               SectorOffsetInBlock;
    ULONG               BlockOffsetInBin;
    ULONG               NumberOfSectors;
    PCM_VIEW_OF_FILE    CmView;
    NTSTATUS            Status;

    //
    // compute size of dirty vector, read and check signature, read vector
    //
    Cluster = Hive->Cluster;
    ClusterSize = Cluster * HSECTOR_SIZE;
    HeaderLength = ROUND_UP(HLOG_HEADER_SIZE, ClusterSize);
    Length = Hive->BaseBlock->Length;
    VectorSize = (Length / HSECTOR_SIZE) / 8;       // VectorSize == Bytes
    FileOffset = ROUND_UP(HLOG_HEADER_SIZE, HeaderLength);
    HvRecoverDataDebug.Hive = Hive;
    HvRecoverDataDebug.FailPoint = 0;
    if( Length == 0 ) {
        return HiveSuccess;
    }

    //
    // we need to align the reads at sector size too
    //
    RequestedReadBufferSize = VectorSize + sizeof(DirtyVectorSignature);

    LOCK_STASH_BUFFER();
    if( CmpStashBufferSize < RequestedReadBufferSize ) {
        PUCHAR TempBuffer =  ExAllocatePoolWithTag(PagedPool, ROUND_UP(RequestedReadBufferSize,PAGE_SIZE),CM_STASHBUFFER_TAG);
        if (TempBuffer == NULL) {
            HvRecoverDataDebug.FailPoint = 1;
            UNLOCK_STASH_BUFFER();
            return Fail;
        }
        if( CmpStashBuffer != NULL ) {
            ExFreePool( CmpStashBuffer );
        }
        CmpStashBuffer = TempBuffer;
        CmpStashBufferSize = ROUND_UP(RequestedReadBufferSize,PAGE_SIZE);

    }

    
    //
    // get the signature and dirty vector at one time
    //
    RequestedReadBufferSize = ROUND_UP(RequestedReadBufferSize,ClusterSize);
    ASSERT( RequestedReadBufferSize <= CmpStashBufferSize);
    ASSERT( (RequestedReadBufferSize % HSECTOR_SIZE) == 0 );

    rc = (Hive->FileRead)(
            Hive,
            HFILE_TYPE_LOG,
            &FileOffset,
            (PVOID)CmpStashBuffer,
            RequestedReadBufferSize
            );
    if (rc == FALSE) {
        HvRecoverDataDebug.FailPoint = 2;
        UNLOCK_STASH_BUFFER();
        if( CmDoSelfHeal() ) {
            //
            // .LOG is bad too. attempt to load at the extent of some data loss.
            //
            CmMarkSelfHeal(Hive);
            return SelfHeal;
        } else {
            return Fail;
        }
    }
    
    //
    // check the signature
    //
    DirtyVectorSignature = *((ULONG *)CmpStashBuffer);
    if (DirtyVectorSignature != HLOG_DV_SIGNATURE) {
        UNLOCK_STASH_BUFFER();
        HvRecoverDataDebug.FailPoint = 3;
        if( CmDoSelfHeal() ) {
            //
            // .LOG is bad too. attempt to load at the extent of some data loss.
            //
            CmMarkSelfHeal(Hive);
            return SelfHeal;
        } else {
            return Fail;
        }
    }

    //
    // get the actual vector
    //
    Vector = (PULONG)((Hive->Allocate)(ROUND_UP(VectorSize,sizeof(ULONG)), TRUE,CM_FIND_LEAK_TAG36));
    if (Vector == NULL) {
        UNLOCK_STASH_BUFFER();
        HvRecoverDataDebug.FailPoint = 4;
        return NoMemory;
    }
    RtlCopyMemory(Vector,CmpStashBuffer + sizeof(DirtyVectorSignature),VectorSize); 

    UNLOCK_STASH_BUFFER();

    FileOffset = ROUND_UP(FileOffset, ClusterSize);


    //
    // step through the dirty map, reading in the corresponding file bytes
    //
    Current = 0;
    VectorSize = VectorSize * 8;        // VectorSize == bits

    RtlInitializeBitMap(&BitMap, Vector, VectorSize);
    if( RtlNumberOfSetBits(&BitMap) == VectorSize ) {
        //
        // the entire hive is marked as dirty; easier to start from scratch
        //
        if( !NT_SUCCESS(HvpRecoverWholeHive(Hive,FileOffset)) ) {
            goto ErrorExit;
        }
        goto Done;
    }


    while (Current < VectorSize) {

        //
        // find next contiguous block of entries to read in
        //
        for (i = Current; i < VectorSize; i++) {
            if (RtlCheckBit(&BitMap, i) == 1) {
                break;
            }
        }
        Start = i;

        for ( ; i < VectorSize; i++) {
            if (RtlCheckBit(&BitMap, i) == 0) {
                break;
            }
        }
        End = i;
        Current = End;

        //
        // Start == number of 1st sector, End == number of Last sector + 1
        //
        Length = (End - Start) * HSECTOR_SIZE;

        if( 0 == Length ) {
            // no more dirty blocks.
            break;
        }
        //
        // allocate a buffer to read the whole run from the file; This is a temporary
        // block that'll be freed immediately, so don't charge quota for it.
        //
        MemoryBlock = (PUCHAR)ExAllocatePoolWithTag(PagedPool, Length, CM_POOL_TAG);
        if( MemoryBlock == NULL ) {        
            HvRecoverDataDebug.FailPoint = 5;
            goto ErrorExit;
        }

        //
        // Currently the read routine may update the passed file offset even if the log file 
        // is damaged (truncated) such that the read fails. Thus we will cache the file offset
        // we attempted to read.
        //
        SavedOffset = FileOffset;
        
        rc = (Hive->FileRead)(
                Hive,
                HFILE_TYPE_LOG,
                &FileOffset,
                (PVOID)MemoryBlock,
                Length
                );

        ASSERT((FileOffset % ClusterSize) == 0);
        if (rc == FALSE) {
            ExFreePool(MemoryBlock);
            HvRecoverDataDebug.FailPoint = 6;
            HvRecoverDataDebug.FileOffset = SavedOffset;
            if( CmDoSelfHeal() ) {
                //
                // .LOG is bad too. attempt to load at the extent of some data loss.
                //
                CmMarkSelfHeal(Hive);

                //
                // Clear off what we have missed. Note that "FileOffset" does not correspond to the 
                // actual hive sectors but only the location of the said sectors in the log file. In 
                // particular, regardless of where the sectors belong in the hive they are all located
                // contiguously in the log file. In other words, "Start" marks the beginning of the 
                // sectors we were attempting to restore.
                //
                RtlClearBits(&BitMap, Start, (Hive->BaseBlock->Length/HSECTOR_SIZE)-Start);
                goto Done;
            } else {
                goto ErrorExit;
            }
        }
        
        Source = MemoryBlock;
        //
        // copy recovered data in the right locations inside the in-memory bins
        //
        while( Start < End ) {
            Address = Start * HSECTOR_SIZE;
        
            Me = HvpGetCellMap(Hive, Address);
            VALIDATE_CELL_MAP(__LINE__,Me,Hive,Address);
            if( (Me->BinAddress & (HMAP_INVIEW|HMAP_INPAGEDPOOL)) == 0 ) {
                //
                // bin is not in memory, neither in paged pool ==> map it
                //
                if( !NT_SUCCESS(CmpMapThisBin((PCMHIVE)Hive,Address,FALSE)) ) {
                    ExFreePool(MemoryBlock);
                    HvRecoverDataDebug.FailPoint = 7;
                    HvRecoverDataDebug.FileOffset = Address;
                    goto ErrorExit;
                }
            }

            if( Me->BinAddress & HMAP_INVIEW ) {
                //
                // pin the view (if not already pinned), as changes have 
                // to be flushed to the disk.
                //
                ASSERT( Me->CmView != NULL );

                if( IsListEmpty(&(Me->CmView->PinViewList)) == TRUE ) {
                    //
                    // the view is not already pinned.  pin it
                    //
                    ASSERT_VIEW_MAPPED( Me->CmView );
                    if( !NT_SUCCESS(CmpPinCmView ((PCMHIVE)Hive,Me->CmView)) ) {
                        //
                        // could not pin view
                        //
                        ExFreePool(MemoryBlock);
                        HvRecoverDataDebug.FailPoint = 10;
                        HvRecoverDataDebug.FileOffset = Address;
                        goto ErrorExit;
                    }
                } else {
                    //
                    // view is already pinned; do nothing
                    //
                    ASSERT_VIEW_PINNED( Me->CmView );
                }
                CmView = Me->CmView;
            } else {
                CmView = NULL;
            }
    
            Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
            //
            // compute the memory address where data should be copied
            //
            SectorOffsetInBin = Address - Bin->FileOffset;
            
            if( ( SectorOffsetInBin == 0 ) && ( ((PHBIN)Source)->Size > Bin->Size ) ){
                //
                // Bin in the log file is bigger than the one in memory;
                // two or more bins must have been coalesced
                //
                ASSERT( Me->BinAddress & HMAP_NEWALLOC );
                
                SourceBin = (PHBIN)Source;

                //
                // new bin must have the right offset
                //
                ASSERT(Address == SourceBin->FileOffset);
                ASSERT( SourceBin->Signature == HBIN_SIGNATURE );
                //
                // entire bin should be dirty
                //
                ASSERT( (SourceBin->FileOffset + SourceBin->Size) <= End * HSECTOR_SIZE );

                if( Me->BinAddress & HMAP_INPAGEDPOOL ) {
                   
                    //
                    // Allocate the right size for the new bin
                    //
                    NewBin = (PHBIN)(Hive->Allocate)(SourceBin->Size, TRUE,CM_FIND_LEAK_TAG37);
                    if (NewBin == NULL) {
                        HvRecoverDataDebug.FailPoint = 8;
                        goto ErrorExit;
                    }
                } else {
                    //
                    // bin is mapped in the system cache
                    //
                    ASSERT( Me->BinAddress & HMAP_INVIEW );
                    NewBin = Bin;
                }
                
                //
                // Copy the old data into the new bin and free old bins
                //
                while(Bin->FileOffset < (Address + SourceBin->Size)) {
                
                    //
                    // Delist this bin free cells
                    //
                    HvpDelistBinFreeCells(Hive,Bin,Stable);

                    if( Me->BinAddress & HMAP_INPAGEDPOOL ) {
                        RtlCopyMemory((PUCHAR)NewBin + (Bin->FileOffset - Address),Bin, Bin->Size);
                    }


                    //
                    // Advance to the new bin
                    //
                    if( (Bin->FileOffset + Bin->Size) < Hive->BaseBlock->Length ) {
                        ULONG   LocalFileOffset = Bin->FileOffset;
                        ULONG   LocalBinSize = Bin->Size;

                        if( Me->BinAddress & HMAP_INPAGEDPOOL ) {
                            //
                            // Free the old bin
                            //
                            (Hive->Free)(Bin, Bin->Size);
                        }

                        Me = HvpGetCellMap(Hive, LocalFileOffset + LocalBinSize);
                        VALIDATE_CELL_MAP(__LINE__,Me,Hive,LocalFileOffset + LocalBinSize);

                        //
                        // the new address must be the beginning of a new allocation
                        //
                        ASSERT( Me->BinAddress & HMAP_NEWALLOC );
            
                        Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
                    } else {
                        //
                        // we are at the end of the hive here; just break out of the loop
                        //
                        ASSERT( (Address + SourceBin->Size) == Hive->BaseBlock->Length );
                        ASSERT( (Bin->FileOffset + Bin->Size) == Hive->BaseBlock->Length );
                        
                        //
                        // Free the old bin
                        //
                        if( Me->BinAddress & HMAP_INPAGEDPOOL ) {
                            (Hive->Free)(Bin, Bin->Size);
                        }
                        
                        //
                        // debug purposes only
                        //
                        ASSERT( (Bin = NULL) == NULL );

                        // bail out of while loop
                        break;
                    }

                }    

#if DBG
                //
                // validation: bin size increase must come from coalescing of former bins
                // (i.e. bins are never split!!!)
                //
                if( Bin != NULL ) {
                    ASSERT( Bin->FileOffset == (Address + SourceBin->Size));
                } 
#endif
                //
                // Now overwrite the modified data !
                //
                
                while( (Address < (SourceBin->FileOffset + SourceBin->Size)) && (Start < End) ) {
                    RtlCopyMemory((PUCHAR)NewBin + (Address - SourceBin->FileOffset),Source, HSECTOR_SIZE);
                    
                    // 
                    // skip to the next sector
                    //
                    Start++;
                    Source += HSECTOR_SIZE;
                    Address += HSECTOR_SIZE;
                }

                //
                // first sector of the new bin is always restored from the log file!
                //
                ASSERT(NewBin->FileOffset == SourceBin->FileOffset);
                ASSERT(NewBin->Size == SourceBin->Size);

            } else {
                //
                // Normal case: sector recovery somewhere in the middle of the bin
                //

                //
                // Offset should fall within bin memory layout
                //
                ASSERT( SectorOffsetInBin < Bin->Size );
            
                if(Me->BinAddress & HMAP_DISCARDABLE) {
                    //
                    // bin is free (discarded); That means it is entirely present in the log file.
                    //
                    ASSERT( SectorOffsetInBin == 0 );
                    SectorImage = (PUCHAR)Bin;
                } else {
                    BlockOffsetInBin = (ULONG)((PUCHAR)Me->BlockAddress - (PUCHAR)Bin);
                    SectorOffsetInBlock = SectorOffsetInBin - BlockOffsetInBin;
            
                    //
                    // sanity check; address should  be the same relative to either beginning of the bin or beginning of the block
                    //
                    ASSERT(((PUCHAR)Me->BlockAddress + SectorOffsetInBlock) == ((PUCHAR)Bin + SectorOffsetInBin));
                    SectorImage = (PUCHAR)((PUCHAR)Me->BlockAddress + SectorOffsetInBlock);
                }

                DbgPrint("HvpRecoverData: SectorOffsetInBin = %lx,SectorImage = %p, Bin = %p, Source = %p\n",
                    SectorOffsetInBin,SectorImage,Bin,Source);
                if( SectorImage == (PUCHAR)Bin ) {
                    //
                    // we are at the beginning of a bin. Check the validity of the data in the .LOG
                    //
                    PHBIN   LogBin = (PHBIN)Source;
                    if ( (LogBin->Size < HBLOCK_SIZE)               ||
                         (LogBin->Signature != HBIN_SIGNATURE)      ||
                         (Bin->FileOffset != LogBin->FileOffset ) ) {

                        //
                        // Bin in .LOG is not valid. All we can do now is throw it away and hope the self healing process 
                        // will successfully recover the hive.
                        //
                        if( CmDoSelfHeal() ) {
                            CmMarkSelfHeal(Hive);
                            ExFreePool(MemoryBlock);
                            // clear off the remaining dirty bits
                            RtlClearBits(&BitMap,Bin->FileOffset/HSECTOR_SIZE,
                                                (Hive->BaseBlock->Length - Bin->FileOffset)/HSECTOR_SIZE);
                            goto Done;
                        }
                    }

                }
                //
                // Delist this bin free cells
                //
                HvpDelistBinFreeCells(Hive,Bin,Stable);

                //
                // both source and destination should be valid at this point
                //
                ASSERT( SectorImage < ((PUCHAR)Bin + Bin->Size) );
                ASSERT( Source < (MemoryBlock + Length) );

                NumberOfSectors = 0;
                while( ( (SectorImage + (NumberOfSectors * HSECTOR_SIZE)) < (PUCHAR)((PUCHAR)Bin + Bin->Size) ) &&
                        ( (Start + NumberOfSectors ) < End )    ) {
                    //
                    // we are still inside the same bin;
                    // deal with all sectors inside the same bin at once
                    //
                    NumberOfSectors++;
                }

                //
                // finally, copy the memory
                //
                RtlCopyMemory(SectorImage,Source, NumberOfSectors * HSECTOR_SIZE);

                NewBin = Bin;

                //
                // skip to the next sector
                //
                Start += NumberOfSectors;
                Source += NumberOfSectors * HSECTOR_SIZE;

            }

            //
            // rebuild the map anyway
            //
            Status = HvpEnlistBinInMap(Hive, Hive->BaseBlock->Length, NewBin, NewBin->FileOffset, CmView);
            if( !NT_SUCCESS(Status) ) {
                HvRecoverDataDebug.FailPoint = 9;
                HvRecoverDataDebug.FileOffset = NewBin->FileOffset;
                if( CmDoSelfHeal() && (Status == STATUS_REGISTRY_RECOVERED) ) {
                    //
                    // .LOG is bad too, but enlisting fixed the bin
                    //
                    CmMarkSelfHeal(Hive);
                } else {
                    goto ErrorExit;
                }
                goto ErrorExit;
            }
        }
    
        //
        // get rid of the temporary pool
        //
        ExFreePool(MemoryBlock);
    }

Done:
    //
    // put correct dirty vector in Hive so that recovered data
    // can be correctly flushed
    //
    if (Hive->DirtyVector.Buffer != NULL) {
        Hive->Free((PVOID)(Hive->DirtyVector.Buffer), Hive->DirtyAlloc);
    }
    RtlInitializeBitMap(&(Hive->DirtyVector), Vector, VectorSize);
    Hive->DirtyCount = RtlNumberOfSetBits(&Hive->DirtyVector);
    Hive->DirtyAlloc = ROUND_UP(VectorSize/8,sizeof(ULONG));
    HvMarkDirty(Hive, 0, sizeof(HBIN),TRUE);  // force header of 1st bin dirty
    return HiveSuccess;

ErrorExit:
    //
    // free the dirty vector and return failure
    //
    (Hive->Free)(Vector, ROUND_UP(VectorSize/8,sizeof(ULONG)));
    return Fail;
}

NTSTATUS
HvpRecoverWholeHive(PHHIVE  Hive,
                    ULONG   FileOffset
                    ) 
/*++

Routine Description:

    We have the whole hive inside the log. Redo the mapping and copy from the log 
    to the actual storage.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest
    
    FileOffset - where the actual hive data starts in the log file.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            Status = STATUS_SUCCESS;
    ULONG               BinOffset = 0;
    PCM_VIEW_OF_FILE    CmView = NULL;
    BOOLEAN             rc;
    PHMAP_ENTRY         Me;
    PHBIN               Bin;                        // current bin
    PHBIN               LogBin;
    ULONG               LogBinSize;                 // size of the current bin
    ULONG               Length;
    LOGICAL             MappedHive;
    PFREE_HBIN          FreeBin;
    ULONG               i;
    PCM_VIEW_OF_FILE    EnlistCmView;
    
    //
    // free the bins that may have been allocated from paged pool.
    //
    HvpFreeAllocatedBins( Hive );
    CmpDestroyHiveViewList((PCMHIVE)Hive);

    //
    // free all free bins.
    //
    while( !IsListEmpty(&(Hive->Storage[Stable].FreeBins)) ) {
        FreeBin = (PFREE_HBIN)RemoveHeadList(&(Hive->Storage[Stable].FreeBins));
        FreeBin = CONTAINING_RECORD(FreeBin,
                                    FREE_HBIN,
                                    ListEntry);
        (Hive->Free)(FreeBin, sizeof(FREE_HBIN));
    }
    //
    // invalidate all free cell hints;
    //
    Hive->Storage[Stable].FreeSummary = 0;
    for (i = 0; i < HHIVE_FREE_DISPLAY_SIZE; i++) {
        RtlClearAllBits(&(Hive->Storage[Stable].FreeDisplay[i].Display));
    }


    //
    // we'll use CmpStashBuffer to read from the log.
    //
    MappedHive = ( ((PCMHIVE)Hive)->FileObject != NULL );
    Length = Hive->BaseBlock->Length;
    BinOffset = 0;

    while( BinOffset < Length) {
        Me = HvpGetCellMap(Hive, BinOffset);
        if( MappedHive && !(Me->BinAddress & HMAP_INVIEW) ) {
            //
            // first, pin the old view (if any)
            //
            if( CmView ) {
                //
                // pin the view (is already marked dirty)
                //
                if( IsListEmpty(&(CmView->PinViewList)) == TRUE ) {
                    //
                    // the view is not already pinned.  pin it
                    //
                    ASSERT_VIEW_MAPPED( CmView );
                    Status = CmpPinCmView ((PCMHIVE)Hive,CmView);
                    if( !NT_SUCCESS(Status)) {
                        //
                        // could not pin view
                        //
                        HvRecoverDataDebug.FailPoint = 13;
                        HvRecoverDataDebug.FileOffset = FileOffset;
                        return Status;
                    }
                } else {
                    //
                    // view is already pinned; do nothing
                    //
                    ASSERT_VIEW_PINNED( CmView );
                }
            }

            Status = CmpMapCmView((PCMHIVE)Hive,BinOffset,&CmView,FALSE/*map not initialized yet*/);
            if( !NT_SUCCESS(Status) ) {
                HvRecoverDataDebug.FailPoint = 10;
                HvRecoverDataDebug.FileOffset = FileOffset;
                return Status;
            }
        }

        rc = (Hive->FileRead)(
                Hive,
                HFILE_TYPE_LOG,
                &FileOffset,
                (PVOID)CmpStashBuffer,
                HBLOCK_SIZE
                );
        if (rc == FALSE) {
            HvRecoverDataDebug.FailPoint = 11;
            HvRecoverDataDebug.FileOffset = FileOffset;
            return STATUS_REGISTRY_IO_FAILED;
        }
        LogBin = (PHBIN)CmpStashBuffer;
        LogBinSize = LogBin->Size;
        if( (LogBin->Signature != HBIN_SIGNATURE) ||
            (LogBin->FileOffset != BinOffset) ) {
            HvRecoverDataDebug.FailPoint = 17;
            HvRecoverDataDebug.FileOffset = FileOffset;
            return STATUS_REGISTRY_IO_FAILED;
        }
        

        //
        // Bins crossing the CM_VIEW_SIZE boundary problem.
        // We fix it here, by loading the entire bin 
        // into paged pool
        //
        FileOffset -= HBLOCK_SIZE;
        if( (!MappedHive) || (HvpCheckViewBoundary(BinOffset,BinOffset+LogBinSize-1) == FALSE) ) {
            //
            // load it in the old fashioned way (into paged pool)
            //

            // first, allocate the bin
            Bin = (PHBIN)(Hive->Allocate)(LogBinSize, TRUE,CM_FIND_LEAK_TAG35);
            if (Bin == NULL) {
                HvRecoverDataDebug.FailPoint = 12;
                HvRecoverDataDebug.FileOffset = FileOffset;
                return  STATUS_INSUFFICIENT_RESOURCES;
            }

            //
            // this will enlist the bin as in paged pool
            //
            EnlistCmView = NULL;
        } else {
            ASSERT(Me->BinAddress & HMAP_INVIEW);
            ASSERT(Me->CmView == CmView );
            Bin = (PHBIN)Me->BlockAddress;

            EnlistCmView = CmView;
        }
        //
        // read data from the file
        //
        if ( ! (Hive->FileRead)(
                        Hive,
                        HFILE_TYPE_LOG,
                        &FileOffset,
                        (PVOID)Bin,
                        LogBinSize
                        )
           )
        {
            HvRecoverDataDebug.FailPoint = 14;
            HvRecoverDataDebug.FileOffset = FileOffset;
            return STATUS_REGISTRY_IO_FAILED;
        }
        //
        // enlist the bin;
        //
        Status = HvpEnlistBinInMap(Hive, Length, Bin, BinOffset, CmView);

        if( !NT_SUCCESS(Status) ) {
            HvRecoverDataDebug.FailPoint = 15;
            HvRecoverDataDebug.FileOffset = FileOffset;
            return Status;
        }

        //
        // advance to the new bin
        //
        BinOffset += LogBinSize;
    }

    if( CmView ) {
        //
        // pin the view (is already marked dirty)
        //
        if( IsListEmpty(&(CmView->PinViewList)) == TRUE ) {
            //
            // the view is not already pinned.  pin it
            //
            ASSERT_VIEW_MAPPED( CmView );
            Status = CmpPinCmView ((PCMHIVE)Hive,CmView);
            if( !NT_SUCCESS(Status)) {
                //
                // could not pin view
                //
                HvRecoverDataDebug.FailPoint = 16;
                HvRecoverDataDebug.FileOffset = FileOffset;
                return Status;
            }
        } else {
            //
            // view is already pinned; do nothing
            //
            ASSERT_VIEW_PINNED( CmView );
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS 
HvCloneHive(PHHIVE  SourceHive,
            PHHIVE  DestHive,
            PULONG  NewLength
            )
/*++

Routine Description:

    Duplicates the bins from the source hive to the destination hive.
    Allocates the map, and recomputes the PhysicalOffset for each bin.
    It does not touch the freedisplay.
  
      
Arguments:

    SourceHive - 

    DestHive - 

Return Value:

    NTSTATUS

--*/
{
    ULONG           Length;
    NTSTATUS        Status;
    ULONG           MapSlots;
    ULONG           Tables;
    PHMAP_TABLE     t = NULL;
    PHMAP_DIRECTORY d = NULL;
    ULONG           FileOffset;
    ULONG           ShiftOffset;
    PHMAP_ENTRY     Me;
    PFREE_HBIN      FreeBin;
    ULONG           BinSize;
    PHBIN           Bin,NewBin;
    
    Length = DestHive->BaseBlock->Length = SourceHive->BaseBlock->Length;

    //
    // Compute size of data region to be mapped
    //
    if ((Length % HBLOCK_SIZE) != 0 ) {
        Status = STATUS_REGISTRY_CORRUPT;
        goto ErrorExit;
    }
    MapSlots = Length / HBLOCK_SIZE;
    if( MapSlots > 0 ) {
        Tables = (MapSlots-1) / HTABLE_SLOTS;
    } else {
        Tables = 0;
    }

    DestHive->Storage[Stable].Length = Length;

    //
    // allocate and build structure for map
    //
    if (Tables == 0) {

        //
        // Just 1 table, no need for directory
        //
        t = (DestHive->Allocate)(sizeof(HMAP_TABLE), FALSE,CM_FIND_LEAK_TAG23);
        if (t == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit;
        }
        RtlZeroMemory(t, sizeof(HMAP_TABLE));
        DestHive->Storage[Stable].Map =
            (PHMAP_DIRECTORY)&(DestHive->Storage[Stable].SmallDir);
        DestHive->Storage[Stable].SmallDir = t;

    } else {

        //
        // Need directory and multiple tables
        //
        d = (PHMAP_DIRECTORY)(DestHive->Allocate)(sizeof(HMAP_DIRECTORY), FALSE,CM_FIND_LEAK_TAG24);
        if (d == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit;
        }
        RtlZeroMemory(d, sizeof(HMAP_DIRECTORY));

        //
        // Allocate tables and fill in dir
        //
        if (HvpAllocateMap(DestHive, d, 0, Tables) == FALSE) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit;
        }
        DestHive->Storage[Stable].Map = d;
        DestHive->Storage[Stable].SmallDir = 0;
    }

    //
    // Now we have to allocate the memory for the HBINs and fill in
    // the map appropriately.  We'll keep track of the freebins 
    // and update the Spare field in each bin accordingly.
    //
    // temporary mark the hive as read only, so we won't enlist the free cells
    DestHive->ReadOnly = TRUE;
    FileOffset = ShiftOffset = 0;
    while(FileOffset < Length) {
        Me = HvpGetCellMap(SourceHive, FileOffset);
       
        if( (Me->BinAddress & (HMAP_INPAGEDPOOL|HMAP_INVIEW)) == 0) {
            //
            // view is not mapped, neither in paged pool
            // try to map it.
            //
            // do not touch the view as we have no interest in it afterwards
            //
            if( !NT_SUCCESS(CmpMapThisBin((PCMHIVE)SourceHive,FileOffset,FALSE)) ) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto ErrorExit;
            }
        }

        if( Me->BinAddress & HMAP_DISCARDABLE ) {
            //
            // bin is discardable. If it is not discarded yet, save it as it is
            // else, allocate, initialize and save a fake bin
            //
            FreeBin = (PFREE_HBIN)Me->BlockAddress;
            BinSize = FreeBin->Size;
            //
            // all we need to do here is to keep track of shifting offset
            //
            ShiftOffset += BinSize;

            //
            // we leave "holes" (map filled with 0); we'll detect them later and shrink the map.
            // 
               
        } else {
        //
        // we need to make sure all the cell's data is faulted in inside a 
        // try/except block, as the IO to fault the data in can throw exceptions
        // STATUS_INSUFFICIENT_RESOURCES, in particular
        //
            try {

                Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
                ASSERT( Bin->Signature == HBIN_SIGNATURE );
                ASSERT( Bin->FileOffset == FileOffset );
                BinSize = Bin->Size;
                //
                // Allocate the new bin
                //
                NewBin = (PHBIN)(DestHive->Allocate)(BinSize, TRUE,CM_FIND_LEAK_TAG35);
                if (NewBin == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto ErrorExit;
                }
                //
                // copy data over the new bin and update the Spare field
                //
                RtlCopyMemory(NewBin,Bin,BinSize);
                NewBin->Spare = ShiftOffset;
                Status = HvpEnlistBinInMap(DestHive, Length, NewBin, FileOffset, NULL);
                if( !NT_SUCCESS(Status) ) {
                    goto ErrorExit;
                }

            } except (EXCEPTION_EXECUTE_HANDLER) {
                Status = GetExceptionCode();
                goto ErrorExit;
            }
        }

        FileOffset += BinSize;
    }

    DestHive->ReadOnly = FALSE;
    *NewLength = Length - ShiftOffset;
    return STATUS_SUCCESS;

ErrorExit:
    return Status;
}


NTSTATUS 
HvShrinkHive(PHHIVE  Hive,
             ULONG   NewLength
            )
/*++

Routine Description:

    Initialize free display and move free bins at the end.
    Renlist all bins. Update/shrink the map and the length of the hive.
      
Arguments:

    Hive - 

    NewLength - 

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        Status;
    ULONG           Offset;
    ULONG           Length;
    PHMAP_ENTRY     Me;
    PHBIN           Bin;
    ULONG           OldTable;
    ULONG           NewTable;

    PAGED_CODE();

    Status = HvpAdjustHiveFreeDisplay(Hive,NewLength,Stable);
    if( !NT_SUCCESS(Status) ) {
        goto ErrorExit;
    }

    //
    // iterate through the map and move bins toward the beginning.
    //
    Offset = 0;
    Length = Hive->BaseBlock->Length;
    while( Offset < Length ) {
        Me = HvpGetCellMap(Hive, Offset);
       
        if( Me->BinAddress & HMAP_INPAGEDPOOL ) {
            //
            // we only care about bins in paged pool
            //
            Bin = (PHBIN)HBIN_BASE(Me->BinAddress);
            ASSERT( Bin->Signature == HBIN_SIGNATURE );
            ASSERT( Bin->FileOffset == Offset );
            //
            // shift the bin and enlist it again.
            //
            Bin->FileOffset -= Bin->Spare;
            Status = HvpEnlistBinInMap(Hive, Length, Bin, Bin->FileOffset, NULL);
            if( !NT_SUCCESS(Status) ) {
                goto ErrorExit;
            }
            Offset += Bin->Size;

        } else {
            //
            // advance carefully.
            //
            Offset += HBLOCK_SIZE;
        }
    }
    
    //
    // now shrink the map and update the length
    //
    OldTable = ( (Length-1) / HBLOCK_SIZE ) / HTABLE_SLOTS;
    NewTable = ( (NewLength-1) / HBLOCK_SIZE ) / HTABLE_SLOTS;
    ASSERT( OldTable >= NewTable );
    HvpFreeMap(Hive, Hive->Storage[Stable].Map, NewTable+1, OldTable);
    Hive->Storage[Stable].Length = NewLength;
    Hive->BaseBlock->Length = NewLength;

ErrorExit:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\dbgk\dbgkobj.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    dbgkobj.c

Abstract:

    This module houses routines to handle the debug object

--*/

#include "dbgkp.h"

#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DbgkInitialize)
#pragma alloc_text(PAGE, NtCreateDebugObject)
#pragma alloc_text(PAGE, NtDebugActiveProcess)
#pragma alloc_text(PAGE, NtRemoveProcessDebug)
#pragma alloc_text(PAGE, NtWaitForDebugEvent)
#pragma alloc_text(PAGE, NtDebugContinue)
#pragma alloc_text(PAGE, NtSetInformationDebugObject)
#pragma alloc_text(PAGE, DbgkpDeleteObject)
#pragma alloc_text(PAGE, DbgkpCloseObject)
#pragma alloc_text(PAGE, DbgkCopyProcessDebugPort)
#pragma alloc_text(PAGE, DbgkOpenProcessDebugPort)
#pragma alloc_text(PAGE, DbgkpSetProcessDebugObject)
#pragma alloc_text(PAGE, DbgkpQueueMessage)
#pragma alloc_text(PAGE, DbgkpOpenHandles)
#pragma alloc_text(PAGE, DbgkClearProcessDebugObject)
#pragma alloc_text(PAGE, DbgkpConvertKernelToUserStateChange)
#pragma alloc_text(PAGE, DbgkpMarkProcessPeb)
#pragma alloc_text(PAGE, DbgkpFreeDebugEvent)
#pragma alloc_text(PAGE, DbgkpPostFakeProcessCreateMessages)
#pragma alloc_text(PAGE, DbgkpPostFakeModuleMessages)
#pragma alloc_text(PAGE, DbgkpPostFakeThreadMessages)
#pragma alloc_text(PAGE, DbgkpWakeTarget)
#pragma alloc_text(PAGE, DbgkpPostAdditionalThreadMessages)
#endif

//
// Non-pageable data
//

//
// This mutex protects the debug port object of processes.
//
FAST_MUTEX DbgkpProcessDebugPortMutex;

//
// Pageable data
//

//#ifdef ALLOC_PRAGMA
//#pragma data_seg("PAGEDATA")
//#endif

POBJECT_TYPE DbgkDebugObjectType = NULL;


//#ifdef ALLOC_PRAGMA
//#pragma data_seg()
//#endif

NTSTATUS
DbgkInitialize (
    VOID
    )
/*++

Routine Description:

    Initialize the debug system

Arguments:

    None

Return Value:

    NTSTATUS - Status of operation

--*/
{
    NTSTATUS Status;
    UNICODE_STRING Name;
    OBJECT_TYPE_INITIALIZER oti = {0};
    GENERIC_MAPPING GenericMapping = {STANDARD_RIGHTS_READ | DEBUG_READ_EVENT,
                                      STANDARD_RIGHTS_WRITE | DEBUG_PROCESS_ASSIGN,
                                      STANDARD_RIGHTS_EXECUTE | SYNCHRONIZE,
                                      DEBUG_ALL_ACCESS};


    PAGED_CODE ();

    ExInitializeFastMutex (&DbgkpProcessDebugPortMutex);

    RtlInitUnicodeString (&Name, L"DebugObject");

    oti.Length                    = sizeof (oti);
    oti.SecurityRequired          = TRUE;
    oti.InvalidAttributes         = 0;
    oti.PoolType                  = NonPagedPool;
    oti.DeleteProcedure           = DbgkpDeleteObject;
    oti.CloseProcedure            = DbgkpCloseObject;
    oti.ValidAccessMask           = DEBUG_ALL_ACCESS;
    oti.GenericMapping            = GenericMapping;
    oti.DefaultPagedPoolCharge    = 0;
    oti.DefaultNonPagedPoolCharge = 0;

    Status = ObCreateObjectType (&Name, &oti, NULL, &DbgkDebugObjectType);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }
    return Status;
}

VOID
DbgkpDeleteObject (
    IN  PVOID   Object
    )
/*++

Routine Description:

    Called by the object manager when the last reference to the object goes away.

Arguments:

    Object - Debug object being deleted

Return Value:

    None.

--*/
{
#if DBG
    PDEBUG_OBJECT DebugObject;
#endif

    PAGED_CODE();

#if DBG
    DebugObject = Object;

    ASSERT (IsListEmpty (&DebugObject->EventList));
#else
    UNREFERENCED_PARAMETER(Object);
#endif
}

VOID
DbgkpMarkProcessPeb (
    PEPROCESS Process
    )
/*++

Routine Description:

    This routine writes the debug variable in the PEB

Arguments:

    Process - Process that needs its PEB modified

Return Value:

    None.

--*/
{
    KAPC_STATE ApcState;

    PAGED_CODE ();

    //
    // Acquire process rundown protection as we are about to look at the processes address space
    //
    if (ExAcquireRundownProtection (&Process->RundownProtect)) {

        if (Process->Peb != NULL) {
            KeStackAttachProcess(&Process->Pcb, &ApcState);


            ExAcquireFastMutex (&DbgkpProcessDebugPortMutex);

            try {
                Process->Peb->BeingDebugged = (BOOLEAN)(Process->DebugPort != NULL ? TRUE : FALSE);
#if defined(_WIN64)
                if (Process->Wow64Process != NULL) {
                    PPEB32 Peb32 = (PPEB32)Process->Wow64Process->Wow64;
                    if (Peb32 != NULL) {
                        Peb32->BeingDebugged = Process->Peb->BeingDebugged;
                    }
                }
#endif
            } except (EXCEPTION_EXECUTE_HANDLER) {
            }
            ExReleaseFastMutex (&DbgkpProcessDebugPortMutex);

            KeUnstackDetachProcess(&ApcState);

        }

        ExReleaseRundownProtection (&Process->RundownProtect);
    }
}

VOID
DbgkpWakeTarget (
    IN PDEBUG_EVENT DebugEvent
    )
{
    PETHREAD Thread;

    Thread = DebugEvent->Thread;

    if ((DebugEvent->Flags&DEBUG_EVENT_SUSPEND) != 0) {
        PsResumeThread (DebugEvent->Thread, NULL);
    }

    if (DebugEvent->Flags&DEBUG_EVENT_RELEASE) {
        ExReleaseRundownProtection (&Thread->RundownProtect);
    }

    //
    // If we have an actual thread waiting then wake it up else free the memory.
    //
    if ((DebugEvent->Flags&DEBUG_EVENT_NOWAIT) == 0) {
        KeSetEvent (&DebugEvent->ContinueEvent, 0, FALSE); // Wake up waiting process
    } else {
        DbgkpFreeDebugEvent (DebugEvent);
    }
}

VOID
DbgkpCloseObject (
    IN PEPROCESS Process,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG_PTR ProcessHandleCount,
    IN ULONG_PTR SystemHandleCount
    )
/*++

Routine Description:

    Called by the object manager when a handle is closed to the object.

Arguments:

    Process - Process doing the close
    Object - Debug object being deleted
    GrantedAccess - Access ranted for this handle
    ProcessHandleCount - Unused and unmaintained by OB
    SystemHandleCount - Current handle count for this object

Return Value:

    None.

--*/
{
    PDEBUG_OBJECT DebugObject = Object;
    PDEBUG_EVENT DebugEvent;
    PLIST_ENTRY ListPtr;
    BOOLEAN Deref;

    PAGED_CODE ();

    UNREFERENCED_PARAMETER (GrantedAccess);
    UNREFERENCED_PARAMETER (ProcessHandleCount);

    //
    // If this isn't the last handle then do nothing.
    //
    if (SystemHandleCount > 1) {
        return;
    }

    ExAcquireFastMutex (&DebugObject->Mutex);

    //
    // Mark this object as going away and wake up any processes that are waiting.
    //
    DebugObject->Flags |= DEBUG_OBJECT_DELETE_PENDING;

    //
    // Remove any events and queue them to a temporary queue
    //
    ListPtr = DebugObject->EventList.Flink;
    InitializeListHead (&DebugObject->EventList);

    ExReleaseFastMutex (&DebugObject->Mutex);

    //
    // Wake anyone waiting. They need to leave this object alone now as its deleting
    //
    KeSetEvent (&DebugObject->EventsPresent, 0, FALSE);

    //
    // Loop over all processes and remove the debug port from any that still have it.
    // Debug port propagation was disabled by setting the delete pending flag above so we only have to do this
    // once. No more refs can appear now.
    //
    for (Process = PsGetNextProcess (NULL);
         Process != NULL;
         Process = PsGetNextProcess (Process)) {

        if (Process->DebugPort == DebugObject) {
            Deref = FALSE;
            ExAcquireFastMutex (&DbgkpProcessDebugPortMutex);
            if (Process->DebugPort == DebugObject) {
                Process->DebugPort = NULL;
                Deref = TRUE;
            }
            ExReleaseFastMutex (&DbgkpProcessDebugPortMutex);


            if (Deref) {
                DbgkpMarkProcessPeb (Process);
                //
                // If the caller wanted process deletion on debugger dying (old interface) then kill off the process.
                //
                if (DebugObject->Flags&DEBUG_OBJECT_KILL_ON_CLOSE) {
                    PsTerminateProcess (Process, STATUS_DEBUGGER_INACTIVE);
                }
                ObDereferenceObject (DebugObject);
            }
        }
    }
    //
    // Wake up all the removed threads.
    //
    while (ListPtr != &DebugObject->EventList) {
        DebugEvent = CONTAINING_RECORD (ListPtr, DEBUG_EVENT, EventList);
        ListPtr = ListPtr->Flink;
        DebugEvent->Status = STATUS_DEBUGGER_INACTIVE;
        DbgkpWakeTarget (DebugEvent);
    }

}

VOID
DbgkCopyProcessDebugPort (
    IN PEPROCESS TargetProcess,
    IN PEPROCESS SourceProcess
    )
/*++

Routine Description:

    Copies a debug port from one process to another.

Arguments:

    TargetProcess - Process to move port to
    sourceProcess - Process to move port from

Return Value:

    None

--*/
{
    PDEBUG_OBJECT DebugObject;

    PAGED_CODE ();

    TargetProcess->DebugPort = NULL; // New process. Needs no locks.

    if (SourceProcess->DebugPort != NULL) {
        ExAcquireFastMutex (&DbgkpProcessDebugPortMutex);
        DebugObject = SourceProcess->DebugPort;
        if (DebugObject != NULL && (SourceProcess->Flags&PS_PROCESS_FLAGS_NO_DEBUG_INHERIT) == 0) {
            //
            // We must not propagate a debug port thats got no handles left.
            //
            ExAcquireFastMutex (&DebugObject->Mutex);

            //
            // If the object is delete pending then don't propagate this object.
            //
            if ((DebugObject->Flags&DEBUG_OBJECT_DELETE_PENDING) == 0) {
                ObReferenceObject (DebugObject);
                TargetProcess->DebugPort = DebugObject;
            }

            ExReleaseFastMutex (&DebugObject->Mutex);
        }
        ExReleaseFastMutex (&DbgkpProcessDebugPortMutex);
    }
}

NTSTATUS
DbgkOpenProcessDebugPort (
    IN PEPROCESS Process,
    IN KPROCESSOR_MODE PreviousMode,
    OUT HANDLE *pHandle
    )
/*++

Routine Description:

    References the target processes debug port.

Arguments:

    Process - Process to reference debug port

Return Value:

    PDEBUG_OBJECT - Referenced object or NULL

--*/
{
    PDEBUG_OBJECT DebugObject;
    NTSTATUS Status;

    PAGED_CODE ();

    Status = STATUS_PORT_NOT_SET;
    if (Process->DebugPort != NULL) {
        ExAcquireFastMutex (&DbgkpProcessDebugPortMutex);
        DebugObject = Process->DebugPort;
        if (DebugObject != NULL) {
            ObReferenceObject (DebugObject);
        }
        ExReleaseFastMutex (&DbgkpProcessDebugPortMutex);

        if (DebugObject != NULL) {
            Status = ObOpenObjectByPointer (DebugObject,
                                            0,
                                            NULL,
                                            MAXIMUM_ALLOWED,
                                            DbgkDebugObjectType,
                                            PreviousMode,
                                            pHandle);
            if (!NT_SUCCESS (Status)) {
                ObDereferenceObject (DebugObject);
            }
        }
    }
    return Status;

}

NTSTATUS
NtCreateDebugObject (
    OUT PHANDLE DebugObjectHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG Flags
    )
/*++

Routine Description:

    Creates a new debug object that maintains the context for a single debug session. Multiple processes may be
    associated with a single debug object.

Arguments:

    DebugObjectHandle - Pointer to a handle to recive the output objects handle
    DesiredAccess     - Required handle access
    ObjectAttributes  - Standard object attributes structure
    Flags             - Only one flag DEBUG_KILL_ON_CLOSE

Return Value:

    NTSTATUS - Status of call.

--*/
{
    NTSTATUS Status;
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    PDEBUG_OBJECT DebugObject;

    PAGED_CODE();

    //
    // Get previous processor mode and probe output arguments if necessary.
    // Zero the handle for error paths.
    //

    PreviousMode = KeGetPreviousMode();

    try {
        if (PreviousMode != KernelMode) {
            ProbeForWriteHandle (DebugObjectHandle);
        }
        *DebugObjectHandle = NULL;

    } except (ExSystemExceptionFilter ()) { // If previous mode is kernel then don't handle the exception
        return GetExceptionCode ();
    }

    if (Flags & ~DEBUG_KILL_ON_CLOSE) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Create a new debug object and initialize it.
    //

    Status = ObCreateObject (PreviousMode,
                             DbgkDebugObjectType,
                             ObjectAttributes,
                             PreviousMode,
                             NULL,
                             sizeof (DEBUG_OBJECT),
                             0,
                             0,
                             &DebugObject);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    ExInitializeFastMutex (&DebugObject->Mutex);
    InitializeListHead (&DebugObject->EventList);
    KeInitializeEvent (&DebugObject->EventsPresent, NotificationEvent, FALSE);

    if (Flags & DEBUG_KILL_ON_CLOSE) {
        DebugObject->Flags = DEBUG_OBJECT_KILL_ON_CLOSE;
    } else {
        DebugObject->Flags = 0;
    }

    //
    // Insert the object into the handle table
    //
    Status = ObInsertObject (DebugObject,
                             NULL,
                             DesiredAccess,
                             0,
                             NULL,
                             &Handle);


    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    try {
        *DebugObjectHandle = Handle;
    } except (ExSystemExceptionFilter ()) {
        //
        // The caller changed the page protection or deleted the memory for the handle.
        // No point closing the handle as process rundown will do that and we don't know its still the same handle
        //
        Status = GetExceptionCode ();
    }

    return Status;
}

VOID
DbgkpFreeDebugEvent (
    IN PDEBUG_EVENT DebugEvent
    )
{
    NTSTATUS Status;

    PAGED_CODE ();

    switch (DebugEvent->ApiMsg.ApiNumber) {
        case DbgKmCreateProcessApi :
            if (DebugEvent->ApiMsg.u.CreateProcessInfo.FileHandle != NULL) {
                Status = ObCloseHandle (DebugEvent->ApiMsg.u.CreateProcessInfo.FileHandle, KernelMode);
            }
            break;

        case DbgKmLoadDllApi :
            if (DebugEvent->ApiMsg.u.LoadDll.FileHandle != NULL) {
                Status = ObCloseHandle (DebugEvent->ApiMsg.u.LoadDll.FileHandle, KernelMode);
            }
            break;

    }
    ObDereferenceObject (DebugEvent->Process);
    ObDereferenceObject (DebugEvent->Thread);
    ExFreePool (DebugEvent);
}


NTSTATUS
DbgkpQueueMessage (
    IN PEPROCESS Process,
    IN PETHREAD Thread,
    IN OUT PDBGKM_APIMSG ApiMsg,
    IN ULONG Flags,
    IN PDEBUG_OBJECT TargetDebugObject
    )
/*++

Routine Description:

    Queues a debug message to the port for a user mode debugger to get.

Arguments:

    Process           - Process being debugged
    Thread            - Thread making call
    ApiMsg            - Message being sent and received
    NoWait            - Don't wait for a response. Buffer message and return.
    TargetDebugObject - Port to queue nowait messages to

Return Value:

    NTSTATUS - Status of call.

--*/
{
    PDEBUG_EVENT DebugEvent;
    DEBUG_EVENT StaticDebugEvent;
    PDEBUG_OBJECT DebugObject;
    NTSTATUS Status;

    PAGED_CODE ();

    if (Flags&DEBUG_EVENT_NOWAIT) {
        DebugEvent = ExAllocatePoolWithQuotaTag (NonPagedPool|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
                                                 sizeof (*DebugEvent),
                                                 'EgbD');
        if (DebugEvent == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        DebugEvent->Flags = Flags|DEBUG_EVENT_INACTIVE;
        ObReferenceObject (Process);
        ObReferenceObject (Thread);
        DebugEvent->BackoutThread = PsGetCurrentThread ();
        DebugObject = TargetDebugObject;
    } else {
        DebugEvent = &StaticDebugEvent;
        DebugEvent->Flags = Flags;

        ExAcquireFastMutex (&DbgkpProcessDebugPortMutex);

        DebugObject = Process->DebugPort;

        //
        // See if this create message has already been sent.
        //
        if (ApiMsg->ApiNumber == DbgKmCreateThreadApi ||
            ApiMsg->ApiNumber == DbgKmCreateProcessApi) {
            if (Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_SKIP_CREATION_MSG) {
                DebugObject = NULL;
            }
        }

        //
        // See if this exit message is for a thread that never had a create
        //
        if (ApiMsg->ApiNumber == DbgKmExitThreadApi ||
            ApiMsg->ApiNumber == DbgKmExitProcessApi) {
            if (Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_SKIP_TERMINATION_MSG) {
                DebugObject = NULL;
            }
        }
    }

    KeInitializeEvent (&DebugEvent->ContinueEvent, SynchronizationEvent, FALSE);

    DebugEvent->Process = Process;
    DebugEvent->Thread = Thread;
    DebugEvent->ApiMsg = *ApiMsg;
    DebugEvent->ClientId = Thread->Cid;

    if (DebugObject == NULL) {
        Status = STATUS_PORT_NOT_SET;
    } else {

        //
        // We must not use a debug port thats got no handles left.
        //
        ExAcquireFastMutex (&DebugObject->Mutex);

        //
        // If the object is delete pending then don't use this object.
        //
        if ((DebugObject->Flags&DEBUG_OBJECT_DELETE_PENDING) == 0) {
            InsertTailList (&DebugObject->EventList, &DebugEvent->EventList);
            //
            // Set the event to say there is an unread event in the object
            //
            if ((Flags&DEBUG_EVENT_NOWAIT) == 0) {
                KeSetEvent (&DebugObject->EventsPresent, 0, FALSE);
            }
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_DEBUGGER_INACTIVE;
        }

        ExReleaseFastMutex (&DebugObject->Mutex);
    }


    if ((Flags&DEBUG_EVENT_NOWAIT) == 0) {
        ExReleaseFastMutex (&DbgkpProcessDebugPortMutex);

        if (NT_SUCCESS (Status)) {
            KeWaitForSingleObject (&DebugEvent->ContinueEvent,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL);

            Status = DebugEvent->Status;
            *ApiMsg = DebugEvent->ApiMsg;
        }
    } else {
        if (!NT_SUCCESS (Status)) {
            ObDereferenceObject (Process);
            ObDereferenceObject (Thread);
            ExFreePool (DebugEvent);
        }
    }

    return Status;
}

NTSTATUS
DbgkClearProcessDebugObject (
    IN PEPROCESS Process,
    IN PDEBUG_OBJECT SourceDebugObject
    )
/*++

Routine Description:

    Remove a debug object from a process.

Arguments:

    Process           - Process to be debugged
    sourceDebugObject - Debug object to detach

Return Value:

    NTSTATUS - Status of call.

--*/
{
    NTSTATUS Status;
    PDEBUG_OBJECT DebugObject;
    PDEBUG_EVENT DebugEvent;
    LIST_ENTRY TempList;
    PLIST_ENTRY Entry;

    PAGED_CODE ();

    ExAcquireFastMutex (&DbgkpProcessDebugPortMutex);

    DebugObject = Process->DebugPort;
    if (DebugObject == NULL || (DebugObject != SourceDebugObject && SourceDebugObject != NULL)) {
        DebugObject = NULL;
        Status = STATUS_PORT_NOT_SET;
    } else {
        Process->DebugPort = NULL;
        Status = STATUS_SUCCESS;
    }
    ExReleaseFastMutex (&DbgkpProcessDebugPortMutex);

    if (NT_SUCCESS (Status)) {
        DbgkpMarkProcessPeb (Process);
    }

    //
    // Remove any events for this process and wake up the threads.
    //
    if (DebugObject) {
        //
        // Remove any events and queue them to a temporary queue
        //
        InitializeListHead (&TempList);

        ExAcquireFastMutex (&DebugObject->Mutex);
        for (Entry = DebugObject->EventList.Flink;
             Entry != &DebugObject->EventList;
             ) {

            DebugEvent = CONTAINING_RECORD (Entry, DEBUG_EVENT, EventList);
            Entry = Entry->Flink;
            if (DebugEvent->Process == Process) {
                RemoveEntryList (&DebugEvent->EventList);
                InsertTailList (&TempList, &DebugEvent->EventList);
            }
        }
        ExReleaseFastMutex (&DebugObject->Mutex);

        ObDereferenceObject (DebugObject);

        //
        // Wake up all the removed threads.
        //
        while (!IsListEmpty (&TempList)) {
            Entry = RemoveHeadList (&TempList);
            DebugEvent = CONTAINING_RECORD (Entry, DEBUG_EVENT, EventList);
            DebugEvent->Status = STATUS_DEBUGGER_INACTIVE;
            DbgkpWakeTarget (DebugEvent);
        }
    }

    return Status;
}


NTSTATUS
DbgkpSetProcessDebugObject (
    IN PEPROCESS Process,
    IN PDEBUG_OBJECT DebugObject,
    IN NTSTATUS MsgStatus,
    IN PETHREAD LastThread
    )
/*++

Routine Description:

    Attach a debug object to a process.

Arguments:

    Process     - Process to be debugged
    DebugObject - Debug object to attach
    MsgStatus   - Status from queing the messages
    LastThread  - Last thread seen in attach loop.

Return Value:

    NTSTATUS - Status of call.

--*/
{
    NTSTATUS Status;
    PETHREAD ThisThread;
    LIST_ENTRY TempList;
    PLIST_ENTRY Entry;
    PDEBUG_EVENT DebugEvent;
    BOOLEAN First;
    PETHREAD Thread;
    BOOLEAN GlobalHeld;
    PETHREAD FirstThread;

    PAGED_CODE ();

    ThisThread = PsGetCurrentThread ();

    InitializeListHead (&TempList);

    First = TRUE;
    GlobalHeld = FALSE;

    if (!NT_SUCCESS (MsgStatus)) {
        LastThread = NULL;
        Status = MsgStatus;
    } else {
        Status = STATUS_SUCCESS;
    }

    //
    // Pick up any threads we missed
    //
    if (NT_SUCCESS (Status)) {

        while (1) {
            //
            // Acquire the debug port mutex so we know that any new threads will
            // have to wait to behind us.
            //
            GlobalHeld = TRUE;

            ExAcquireFastMutex (&DbgkpProcessDebugPortMutex);

            //
            // If the port has been set then exit now.
            //
            if (Process->DebugPort != NULL) {
                Status = STATUS_PORT_ALREADY_SET;
                break;
            }
            //
            // Assign the debug port to the process to pick up any new threads
            //
            Process->DebugPort = DebugObject;

            //
            // Reference the last thread so we can deref outside the lock
            //
            ObReferenceObject (LastThread);

            //
            // Search forward for new threads
            //
            Thread = PsGetNextProcessThread (Process, LastThread);
            if (Thread != NULL) {

                //
                // Remove the debug port from the process as we are
                // about to drop the lock
                //
                Process->DebugPort = NULL;

                ExReleaseFastMutex (&DbgkpProcessDebugPortMutex);

                GlobalHeld = FALSE;

                ObDereferenceObject (LastThread);

                //
                // Queue any new thread messages and repeat.
                //

                Status = DbgkpPostFakeThreadMessages (Process,
                                                      DebugObject,
                                                      Thread,
                                                      &FirstThread,
                                                      &LastThread);
                if (!NT_SUCCESS (Status)) {
                    LastThread = NULL;
                    break;
                }
                ObDereferenceObject (FirstThread);
            } else {
                break;
            }
        }
    }

    //
    // Lock the debug object so we can check its deleted status
    //
    ExAcquireFastMutex (&DebugObject->Mutex);

    //
    // We must not propagate a debug port thats got no handles left.
    //

    if (NT_SUCCESS (Status)) {
        if ((DebugObject->Flags&DEBUG_OBJECT_DELETE_PENDING) == 0) {
            PS_SET_BITS (&Process->Flags, PS_PROCESS_FLAGS_NO_DEBUG_INHERIT|PS_PROCESS_FLAGS_CREATE_REPORTED);
            ObReferenceObject (DebugObject);
        } else {
            Process->DebugPort = NULL;
            Status = STATUS_DEBUGGER_INACTIVE;
        }
    }

    for (Entry = DebugObject->EventList.Flink;
         Entry != &DebugObject->EventList;
         ) {

        DebugEvent = CONTAINING_RECORD (Entry, DEBUG_EVENT, EventList);
        Entry = Entry->Flink;

        if ((DebugEvent->Flags&DEBUG_EVENT_INACTIVE) != 0 && DebugEvent->BackoutThread == ThisThread) {
            Thread = DebugEvent->Thread;

            //
            // If the thread has not been inserted by CreateThread yet then don't
            // create a handle. We skip system threads here also
            //
            if (NT_SUCCESS (Status) && Thread->GrantedAccess != 0 && !IS_SYSTEM_THREAD (Thread)) {
                //
                // If we could not acquire rundown protection on this
                // thread then we need to suppress its exit message.
                //
                if ((DebugEvent->Flags&DEBUG_EVENT_PROTECT_FAILED) != 0) {
                    PS_SET_BITS (&Thread->CrossThreadFlags,
                                 PS_CROSS_THREAD_FLAGS_SKIP_TERMINATION_MSG);
                    RemoveEntryList (&DebugEvent->EventList);
                    InsertTailList (&TempList, &DebugEvent->EventList);
                } else {
                    if (First) {
                         DebugEvent->Flags &= ~DEBUG_EVENT_INACTIVE;
                        KeSetEvent (&DebugObject->EventsPresent, 0, FALSE);
                        First = FALSE;
                    }
                    DebugEvent->BackoutThread = NULL;
                    PS_SET_BITS (&Thread->CrossThreadFlags,
                                 PS_CROSS_THREAD_FLAGS_SKIP_CREATION_MSG);

                }
            } else {
                RemoveEntryList (&DebugEvent->EventList);
                InsertTailList (&TempList, &DebugEvent->EventList);
            }

            if (DebugEvent->Flags&DEBUG_EVENT_RELEASE) {
                DebugEvent->Flags &= ~DEBUG_EVENT_RELEASE;
                ExReleaseRundownProtection (&Thread->RundownProtect);
            }

        }
    }

    ExReleaseFastMutex (&DebugObject->Mutex);

    if (GlobalHeld) {
        ExReleaseFastMutex (&DbgkpProcessDebugPortMutex);
    }

    if (LastThread != NULL) {
        ObDereferenceObject (LastThread);
    }

    while (!IsListEmpty (&TempList)) {
        Entry = RemoveHeadList (&TempList);
        DebugEvent = CONTAINING_RECORD (Entry, DEBUG_EVENT, EventList);
        DbgkpWakeTarget (DebugEvent);
    }

    if (NT_SUCCESS (Status)) {
        DbgkpMarkProcessPeb (Process);
    }

    return Status;
}

NTSTATUS
DbgkpPostFakeThreadMessages (
    IN PEPROCESS Process,
    IN PDEBUG_OBJECT DebugObject,
    IN PETHREAD StartThread,
    OUT PETHREAD *pFirstThread,
    OUT PETHREAD *pLastThread
    )
/*++

Routine Description:

    This routine posts the faked initial process create, thread create messages

Arguments:

    Process      - Process to be debugged
    DebugObject  - Debug object to queue messages to
    StartThread  - Thread to start search from
    pFirstThread - First thread found in the list
    pLastThread  - Last thread found in the list

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    PETHREAD Thread, FirstThread, LastThread;
    DBGKM_APIMSG ApiMsg;
    BOOLEAN First = TRUE;
    BOOLEAN IsFirstThread;
    PIMAGE_NT_HEADERS NtHeaders;
    ULONG Flags;
    NTSTATUS Status1;

    PAGED_CODE ();

    LastThread = FirstThread = NULL;

    Status = STATUS_UNSUCCESSFUL;

    if (StartThread != NULL) {
        First = FALSE;
        FirstThread = StartThread;
        ObReferenceObject (FirstThread);
    } else {
        StartThread = PsGetNextProcessThread (Process, NULL);
        First = TRUE;
    }

    for (Thread = StartThread;
         Thread != NULL;
         Thread = PsGetNextProcessThread (Process, Thread)) {

        Flags = DEBUG_EVENT_NOWAIT;

        //
        // Keep a track ont he last thread we have seen.
        // We use this as a starting point for new threads after we
        // really attach so we can pick up any new threads.
        //
        if (LastThread != NULL) {
            ObDereferenceObject (LastThread);
        }
        LastThread = Thread;
        ObReferenceObject (LastThread);

        //
        // Acquire rundown protection of the thread.
        // This stops the thread exiting so we know it can't send
        // it's termination message
        //
        if (ExAcquireRundownProtection (&Thread->RundownProtect)) {
            Flags |= DEBUG_EVENT_RELEASE;

            //
            // Suspend the thread if we can for the debugger
            // We don't suspend terminating threads as we will not be giving details
            // of these to the debugger.
            //

            if (!IS_SYSTEM_THREAD (Thread)) {
                Status1 = PsSuspendThread (Thread, NULL);
                if (NT_SUCCESS (Status1)) {
                    Flags |= DEBUG_EVENT_SUSPEND;
                }
            }
        } else {
            //
            // Rundown protection failed for this thread.
            // This means the thread is exiting. We will mark this thread
            // later so it doesn't sent a thread termination message.
            // We can't do this now because this attach might fail.
            //
            Flags |= DEBUG_EVENT_PROTECT_FAILED;
        }

        RtlZeroMemory (&ApiMsg, sizeof (ApiMsg));

        if (First && (Flags&DEBUG_EVENT_PROTECT_FAILED) == 0 &&
            !IS_SYSTEM_THREAD (Thread) && Thread->GrantedAccess != 0) {
            IsFirstThread = TRUE;
        } else {
            IsFirstThread = FALSE;
        }

        if (IsFirstThread) {
            ApiMsg.ApiNumber = DbgKmCreateProcessApi;
            if (Process->SectionObject != NULL) { // system process doesn't have one of these!
                ApiMsg.u.CreateProcessInfo.FileHandle  = DbgkpSectionToFileHandle (Process->SectionObject);
            } else {
                ApiMsg.u.CreateProcessInfo.FileHandle = NULL;
            }
            ApiMsg.u.CreateProcessInfo.BaseOfImage = Process->SectionBaseAddress;
            try {
                NtHeaders = RtlImageNtHeader(Process->SectionBaseAddress);
                if (NtHeaders) {
                    ApiMsg.u.CreateProcessInfo.InitialThread.StartAddress = NULL; // Filling this in breaks MSDEV!
//                        (PVOID)(NtHeaders->OptionalHeader.ImageBase + NtHeaders->OptionalHeader.AddressOfEntryPoint);
                    ApiMsg.u.CreateProcessInfo.DebugInfoFileOffset = NtHeaders->FileHeader.PointerToSymbolTable;
                    ApiMsg.u.CreateProcessInfo.DebugInfoSize       = NtHeaders->FileHeader.NumberOfSymbols;
                }
            } except (EXCEPTION_EXECUTE_HANDLER) {
                ApiMsg.u.CreateProcessInfo.InitialThread.StartAddress = NULL;
                ApiMsg.u.CreateProcessInfo.DebugInfoFileOffset = 0;
                ApiMsg.u.CreateProcessInfo.DebugInfoSize = 0;
            }
        } else {
            ApiMsg.ApiNumber = DbgKmCreateThreadApi;
            ApiMsg.u.CreateThread.StartAddress = Thread->StartAddress;
        }
        Status = DbgkpQueueMessage (Process,
                                    Thread,
                                    &ApiMsg,
                                    Flags,
                                    DebugObject);
        if (!NT_SUCCESS (Status)) {
            if (Flags&DEBUG_EVENT_SUSPEND) {
                PsResumeThread (Thread, NULL);
            }
            if (Flags&DEBUG_EVENT_RELEASE) {
                ExReleaseRundownProtection (&Thread->RundownProtect);
            }
            if (ApiMsg.ApiNumber == DbgKmCreateProcessApi && ApiMsg.u.CreateProcessInfo.FileHandle != NULL) {
                ObCloseHandle (ApiMsg.u.CreateProcessInfo.FileHandle, KernelMode);
            }
            PsQuitNextProcessThread (Thread);
            break;
        } else if (IsFirstThread) {
            First = FALSE;
            ObReferenceObject (Thread);
            FirstThread = Thread;
        }
    }


    if (!NT_SUCCESS (Status)) {
        if (FirstThread) {
            ObDereferenceObject (FirstThread);
        }
        if (LastThread != NULL) {
            ObDereferenceObject (LastThread);
        }
    } else {
        if (FirstThread) {
            *pFirstThread = FirstThread;
            *pLastThread = LastThread;
        } else {
            Status = STATUS_UNSUCCESSFUL;
        }
    }
    return Status;
}

NTSTATUS
DbgkpPostFakeModuleMessages (
    IN PEPROCESS Process,
    IN PETHREAD Thread,
    IN PDEBUG_OBJECT DebugObject)
/*++

Routine Description:

    This routine posts the faked module load messages when we debug an active process.

Arguments:

    ProcessHandle     - Handle to a process to be debugged
    DebugObjectHandle - Handle to a debug object

Return Value:

    None.

--*/
{
    PPEB Peb = Process->Peb;
    PPEB_LDR_DATA Ldr;
    PLIST_ENTRY LdrHead, LdrNext;
    PLDR_DATA_TABLE_ENTRY LdrEntry;
    DBGKM_APIMSG ApiMsg;
    ULONG i;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING Name;
    PIMAGE_NT_HEADERS NtHeaders;
    NTSTATUS Status;
    IO_STATUS_BLOCK iosb;

    PAGED_CODE ();

    if (Peb == NULL) {
        return STATUS_SUCCESS;
    }

    try {
        Ldr = Peb->Ldr;

        LdrHead = &Ldr->InLoadOrderModuleList;

        ProbeForReadSmallStructure (LdrHead, sizeof (LIST_ENTRY), sizeof (UCHAR));
        for (LdrNext = LdrHead->Flink, i = 0;
             LdrNext != LdrHead && i < 500;
             LdrNext = LdrNext->Flink, i++) {

            //
            // First image got send with process create message
            //
            if (i > 0) {
                RtlZeroMemory (&ApiMsg, sizeof (ApiMsg));

                LdrEntry = CONTAINING_RECORD (LdrNext, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
                ProbeForReadSmallStructure (LdrEntry, sizeof (LDR_DATA_TABLE_ENTRY), sizeof (UCHAR));

                ApiMsg.ApiNumber = DbgKmLoadDllApi;
                ApiMsg.u.LoadDll.BaseOfDll = LdrEntry->DllBase;
                ApiMsg.u.LoadDll.NamePointer = NULL;

                ProbeForReadSmallStructure (ApiMsg.u.LoadDll.BaseOfDll, sizeof (IMAGE_DOS_HEADER), sizeof (UCHAR));

                NtHeaders = RtlImageNtHeader (ApiMsg.u.LoadDll.BaseOfDll);
                if (NtHeaders) {
                    ApiMsg.u.LoadDll.DebugInfoFileOffset = NtHeaders->FileHeader.PointerToSymbolTable;
                    ApiMsg.u.LoadDll.DebugInfoSize = NtHeaders->FileHeader.NumberOfSymbols;
                }
                Status = MmGetFileNameForAddress (NtHeaders, &Name);
                if (NT_SUCCESS (Status)) {
                    InitializeObjectAttributes (&oa,
                                                &Name,
                                                OBJ_FORCE_ACCESS_CHECK|OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                                NULL,
                                                NULL);

                    Status = ZwOpenFile (&ApiMsg.u.LoadDll.FileHandle,
                                         GENERIC_READ|SYNCHRONIZE,
                                         &oa,
                                         &iosb,
                                         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                         FILE_SYNCHRONOUS_IO_NONALERT);
                    if (!NT_SUCCESS (Status)) {
                        ApiMsg.u.LoadDll.FileHandle = NULL;
                    }
                    ExFreePool (Name.Buffer);
                }
                Status = DbgkpQueueMessage (Process,
                                            Thread,
                                            &ApiMsg,
                                            DEBUG_EVENT_NOWAIT,
                                            DebugObject);
                if (!NT_SUCCESS (Status) && ApiMsg.u.LoadDll.FileHandle != NULL) {
                    ObCloseHandle (ApiMsg.u.LoadDll.FileHandle, KernelMode);
                }

            }
            ProbeForReadSmallStructure (LdrNext, sizeof (LIST_ENTRY), sizeof (UCHAR));
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
    }

#if defined(_WIN64)
    if (Process->Wow64Process != NULL && Process->Wow64Process->Wow64 != NULL) {
        PPEB32 Peb32;
        PPEB_LDR_DATA32 Ldr32;
        PLIST_ENTRY32 LdrHead32, LdrNext32;
        PLDR_DATA_TABLE_ENTRY32 LdrEntry32;
        PWCHAR pSys;

        Peb32 = (PPEB32)Process->Wow64Process->Wow64;

        try {
            Ldr32 = (PVOID) UlongToPtr(Peb32->Ldr);

            LdrHead32 = &Ldr32->InLoadOrderModuleList;

            ProbeForReadSmallStructure (LdrHead32, sizeof (LIST_ENTRY32), sizeof (UCHAR));
            for (LdrNext32 = (PVOID) UlongToPtr(LdrHead32->Flink), i = 0;
                 LdrNext32 != LdrHead32 && i < 500;
                 LdrNext32 = (PVOID) UlongToPtr(LdrNext32->Flink), i++) {

                if (i > 0) {
                    RtlZeroMemory (&ApiMsg, sizeof (ApiMsg));

                    LdrEntry32 = CONTAINING_RECORD (LdrNext32, LDR_DATA_TABLE_ENTRY32, InLoadOrderLinks);
                    ProbeForReadSmallStructure (LdrEntry32, sizeof (LDR_DATA_TABLE_ENTRY32), sizeof (UCHAR));

                    ApiMsg.ApiNumber = DbgKmLoadDllApi;
                    ApiMsg.u.LoadDll.BaseOfDll = (PVOID) UlongToPtr(LdrEntry32->DllBase);
                    ApiMsg.u.LoadDll.NamePointer = NULL;

                    ProbeForReadSmallStructure (ApiMsg.u.LoadDll.BaseOfDll, sizeof (IMAGE_DOS_HEADER), sizeof (UCHAR));

                    NtHeaders = RtlImageNtHeader(ApiMsg.u.LoadDll.BaseOfDll);
                    if (NtHeaders) {
                        ApiMsg.u.LoadDll.DebugInfoFileOffset = NtHeaders->FileHeader.PointerToSymbolTable;
                        ApiMsg.u.LoadDll.DebugInfoSize = NtHeaders->FileHeader.NumberOfSymbols;
                    }

                    Status = MmGetFileNameForAddress (NtHeaders, &Name);
                    if (NT_SUCCESS (Status)) {
                        ASSERT (sizeof (L"SYSTEM32") == sizeof (WOW64_SYSTEM_DIRECTORY_U));
                        pSys = wcsstr (Name.Buffer, L"\\SYSTEM32\\");
                        if (pSys != NULL) {
                            RtlCopyMemory (pSys+1,
                                           WOW64_SYSTEM_DIRECTORY_U,
                                           sizeof(WOW64_SYSTEM_DIRECTORY_U) - sizeof(UNICODE_NULL));
                        }

                        InitializeObjectAttributes (&oa,
                                                    &Name,
                                                    OBJ_FORCE_ACCESS_CHECK|OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                                    NULL,
                                                    NULL);

                        Status = ZwOpenFile (&ApiMsg.u.LoadDll.FileHandle,
                                             GENERIC_READ|SYNCHRONIZE,
                                             &oa,
                                             &iosb,
                                             FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                             FILE_SYNCHRONOUS_IO_NONALERT);
                        if (!NT_SUCCESS (Status)) {
                            ApiMsg.u.LoadDll.FileHandle = NULL;
                        }
                        ExFreePool (Name.Buffer);
                    }

                    Status = DbgkpQueueMessage (Process,
                                                Thread,
                                                &ApiMsg,
                                                DEBUG_EVENT_NOWAIT,
                                                DebugObject);
                    if (!NT_SUCCESS (Status) && ApiMsg.u.LoadDll.FileHandle != NULL) {
                        ObCloseHandle (ApiMsg.u.LoadDll.FileHandle, KernelMode);
                    }
                }

                ProbeForReadSmallStructure (LdrNext32, sizeof (LIST_ENTRY32), sizeof (UCHAR));
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
        }
    }

#endif
    return STATUS_SUCCESS;
}

NTSTATUS
DbgkpPostFakeProcessCreateMessages (
    IN PEPROCESS Process,
    IN PDEBUG_OBJECT DebugObject,
    IN PETHREAD *pLastThread
    )
/*++

Routine Description:

    This routine posts the faked initial process create, thread create and mudule load messages

Arguments:

    ProcessHandle     - Handle to a process to be debugged
    DebugObjectHandle - Handle to a debug object

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    KAPC_STATE ApcState;
    PETHREAD Thread;
    PETHREAD LastThread;

    PAGED_CODE ();

    //
    // Attach to the process so we can touch its address space
    //
    KeStackAttachProcess(&Process->Pcb, &ApcState);

    Status = DbgkpPostFakeThreadMessages (Process,
                                          DebugObject,
                                          NULL,
                                          &Thread,
                                          &LastThread);

    if (NT_SUCCESS (Status)) {
        Status = DbgkpPostFakeModuleMessages (Process, Thread, DebugObject);
        if (!NT_SUCCESS (Status)) {
            ObDereferenceObject (LastThread);
            LastThread = NULL;
        }
        ObDereferenceObject (Thread);
    } else {
        LastThread = NULL;
    }

    KeUnstackDetachProcess(&ApcState);

    *pLastThread = LastThread;

    return Status;
}

NTSTATUS
NtDebugActiveProcess (
    IN HANDLE ProcessHandle,
    IN HANDLE DebugObjectHandle
    )
/*++

Routine Description:

    Attach a debug object to a process.

Arguments:

    ProcessHandle     - Handle to a process to be debugged
    DebugObjectHandle - Handle to a debug object

Return Value:

    NTSTATUS - Status of call.

--*/
{
    NTSTATUS Status;
    KPROCESSOR_MODE PreviousMode;
    PDEBUG_OBJECT DebugObject;
    PEPROCESS Process;
    PETHREAD LastThread;

    PAGED_CODE ();

    PreviousMode = KeGetPreviousMode();

    Status = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_PORT,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Don't let us debug ourselves or the system process.
    //
    if (Process == PsGetCurrentProcess () || Process == PsInitialSystemProcess) {
        ObDereferenceObject (Process);
        return STATUS_ACCESS_DENIED;
    }


    Status = ObReferenceObjectByHandle (DebugObjectHandle,
                                        DEBUG_PROCESS_ASSIGN,
                                        DbgkDebugObjectType,
                                        PreviousMode,
                                        &DebugObject,
                                        NULL);

    if (NT_SUCCESS (Status)) {
        //
        // We will be touching process address space. Block process rundown.
        //
        if (ExAcquireRundownProtection (&Process->RundownProtect)) {

            //
            // Post the fake process create messages etc.
            //
            Status = DbgkpPostFakeProcessCreateMessages (Process,
                                                         DebugObject,
                                                         &LastThread);

            //
            // Set the debug port. If this fails it will remove any faked messages.
            //
            Status = DbgkpSetProcessDebugObject (Process,
                                                 DebugObject,
                                                 Status,
                                                 LastThread);

            ExReleaseRundownProtection (&Process->RundownProtect);
        } else {
            Status = STATUS_PROCESS_IS_TERMINATING;
        }

        ObDereferenceObject (DebugObject);
    }
    ObDereferenceObject (Process);

    return Status;
}

NTSTATUS
NtRemoveProcessDebug (
    IN HANDLE ProcessHandle,
    IN HANDLE DebugObjectHandle
    )
/*++

Routine Description:

    Remove a debug object from a process.

Arguments:

    ProcessHandle - Handle to a process currently being debugged

Return Value:

    NTSTATUS - Status of call.

--*/
{
    NTSTATUS Status;
    KPROCESSOR_MODE PreviousMode;
    PDEBUG_OBJECT DebugObject;
    PEPROCESS Process;

    PAGED_CODE ();

    PreviousMode = KeGetPreviousMode();

    Status = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_PORT,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }
    Status = ObReferenceObjectByHandle (DebugObjectHandle,
                                        DEBUG_PROCESS_ASSIGN,
                                        DbgkDebugObjectType,
                                        PreviousMode,
                                        &DebugObject,
                                        NULL);
    if (NT_SUCCESS (Status)) {
        Status = DbgkClearProcessDebugObject (Process,
                                               DebugObject);
        ObDereferenceObject (DebugObject);
    }

    ObDereferenceObject (Process);
    return Status;
}

VOID
DbgkpOpenHandles (
    PDBGUI_WAIT_STATE_CHANGE WaitStateChange,
    PEPROCESS Process,
    PETHREAD Thread
    )
/*++

Routine Description:

    Opens up process, thread and filehandles if need be for some of the requests

Arguments:

    WaitStateChange - User mode format change block
    Process - Pointer to target process
    Thread - Pointer to target thread

Return Value:

    None

--*/
{
    NTSTATUS Status;
    PEPROCESS CurrentProcess;
    HANDLE OldHandle;

    PAGED_CODE ();

    switch (WaitStateChange->NewState) {
        case DbgCreateThreadStateChange :
            //
            // We have the right to open up any thread in the process if we are allowed to debug it.
            // Use kernel mode here so we are always granted it regardless of protection.
            //
            Status = ObOpenObjectByPointer (Thread,
                                            0,
                                            NULL,
                                            THREAD_GET_CONTEXT | THREAD_SET_CONTEXT | THREAD_SUSPEND_RESUME | \
                                               THREAD_QUERY_INFORMATION | THREAD_SET_INFORMATION | THREAD_TERMINATE |
                                               READ_CONTROL | SYNCHRONIZE,
                                            PsThreadType,
                                            KernelMode,
                                            &WaitStateChange->StateInfo.CreateThread.HandleToThread);
            if (!NT_SUCCESS (Status)) {
                WaitStateChange->StateInfo.CreateThread.HandleToThread = NULL;
            }
            break;

        case DbgCreateProcessStateChange :

            Status = ObOpenObjectByPointer (Thread,
                                            0,
                                            NULL,
                                            THREAD_GET_CONTEXT | THREAD_SET_CONTEXT | THREAD_SUSPEND_RESUME | \
                                               THREAD_QUERY_INFORMATION | THREAD_SET_INFORMATION | THREAD_TERMINATE |
                                               READ_CONTROL | SYNCHRONIZE,
                                            PsThreadType,
                                            KernelMode,
                                            &WaitStateChange->StateInfo.CreateProcessInfo.HandleToThread);
            if (!NT_SUCCESS (Status)) {
                WaitStateChange->StateInfo.CreateProcessInfo.HandleToThread = NULL;
            }
            Status = ObOpenObjectByPointer (Process,
                                            0,
                                            NULL,
                                            PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION |
                                               PROCESS_DUP_HANDLE | PROCESS_QUERY_INFORMATION | PROCESS_SET_INFORMATION |
                                               PROCESS_CREATE_THREAD | PROCESS_TERMINATE |
                                               READ_CONTROL | SYNCHRONIZE,
                                            PsProcessType,
                                            KernelMode,
                                            &WaitStateChange->StateInfo.CreateProcessInfo.HandleToProcess);
            if (!NT_SUCCESS (Status)) {
                WaitStateChange->StateInfo.CreateProcessInfo.HandleToProcess = NULL;
            }

            OldHandle = WaitStateChange->StateInfo.CreateProcessInfo.NewProcess.FileHandle;
            if (OldHandle != NULL) {
                CurrentProcess = PsGetCurrentProcess ();
                Status = ObDuplicateObject (CurrentProcess,
                                            OldHandle,
                                            CurrentProcess,
                                            &WaitStateChange->StateInfo.CreateProcessInfo.NewProcess.FileHandle,
                                            0,
                                            0,
                                            DUPLICATE_SAME_ACCESS,
                                            KernelMode);
                if (!NT_SUCCESS (Status)) {
                    WaitStateChange->StateInfo.CreateProcessInfo.NewProcess.FileHandle = NULL;
                }
                ObCloseHandle (OldHandle, KernelMode);
            }
            break;

        case DbgLoadDllStateChange :

            OldHandle = WaitStateChange->StateInfo.LoadDll.FileHandle;
            if (OldHandle != NULL) {
                CurrentProcess = PsGetCurrentProcess ();
                Status = ObDuplicateObject (CurrentProcess,
                                            OldHandle,
                                            CurrentProcess,
                                            &WaitStateChange->StateInfo.LoadDll.FileHandle,
                                            0,
                                            0,
                                            DUPLICATE_SAME_ACCESS,
                                            KernelMode);
                if (!NT_SUCCESS (Status)) {
                    WaitStateChange->StateInfo.LoadDll.FileHandle = NULL;
                }
                ObCloseHandle (OldHandle, KernelMode);
            }

            break;

        default :
            break;
    }
}

VOID
DbgkpConvertKernelToUserStateChange (
     PDBGUI_WAIT_STATE_CHANGE WaitStateChange,
     PDEBUG_EVENT DebugEvent)
/*++

Routine Description:

    Converts a kernel message to one the user expects

Arguments:

    WaitStateChange - User mode format
    DebugEvent      - Debug event block to copy from

Return Value:

    None

--*/
{

    PAGED_CODE ();

    WaitStateChange->AppClientId = DebugEvent->ClientId;
    switch (DebugEvent->ApiMsg.ApiNumber) {
        case DbgKmExceptionApi :

            switch (DebugEvent->ApiMsg.u.Exception.ExceptionRecord.ExceptionCode) {
                case STATUS_BREAKPOINT :
                    WaitStateChange->NewState = DbgBreakpointStateChange;
                    break;

                case STATUS_SINGLE_STEP :
                    WaitStateChange->NewState = DbgSingleStepStateChange;
                    break;

                default :
                    WaitStateChange->NewState = DbgExceptionStateChange;
                    break;
            }
            WaitStateChange->StateInfo.Exception = DebugEvent->ApiMsg.u.Exception;
            break;

        case DbgKmCreateThreadApi :
            WaitStateChange->NewState = DbgCreateThreadStateChange;
            WaitStateChange->StateInfo.CreateThread.NewThread = DebugEvent->ApiMsg.u.CreateThread;
            break;

        case DbgKmCreateProcessApi :
            WaitStateChange->NewState = DbgCreateProcessStateChange;
            WaitStateChange->StateInfo.CreateProcessInfo.NewProcess = DebugEvent->ApiMsg.u.CreateProcessInfo;
            //
            // clear out the handle in the message as we will close this when we duplicate.
            //
            DebugEvent->ApiMsg.u.CreateProcessInfo.FileHandle = NULL;
            break;

        case DbgKmExitThreadApi :
            WaitStateChange->NewState = DbgExitThreadStateChange;
            WaitStateChange->StateInfo.ExitThread = DebugEvent->ApiMsg.u.ExitThread;
            break;

        case DbgKmExitProcessApi :
            WaitStateChange->NewState = DbgExitProcessStateChange;
            WaitStateChange->StateInfo.ExitProcess = DebugEvent->ApiMsg.u.ExitProcess;
            break;

        case DbgKmLoadDllApi :
            WaitStateChange->NewState = DbgLoadDllStateChange;
            WaitStateChange->StateInfo.LoadDll = DebugEvent->ApiMsg.u.LoadDll;
            //
            // clear out the handle in the message as we will close this when we duplicate.
            //
            DebugEvent->ApiMsg.u.LoadDll.FileHandle = NULL;
            break;

        case DbgKmUnloadDllApi :
            WaitStateChange->NewState = DbgUnloadDllStateChange;
            WaitStateChange->StateInfo.UnloadDll = DebugEvent->ApiMsg.u.UnloadDll;
            break;

        default :
            ASSERT (FALSE);
    }
}

NTSTATUS
NtWaitForDebugEvent (
    IN HANDLE DebugObjectHandle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL,
    OUT PDBGUI_WAIT_STATE_CHANGE WaitStateChange
    )
/*++

Routine Description:

    Waits for a debug event and returns it to the user if one arrives

Arguments:

    DebugObjectHandle - Handle to a debug object
    Alertable - TRUE is the wait is to be alertable
    Timeout - Operation timeout value
    WaitStateChange - Returned debug event

Return Value:

    Status of operation

--*/
{
    NTSTATUS Status;
    KPROCESSOR_MODE PreviousMode;
    PDEBUG_OBJECT DebugObject;
    LARGE_INTEGER Tmo = {0};
    LARGE_INTEGER StartTime = {0};
    DBGUI_WAIT_STATE_CHANGE tWaitStateChange = {0};
    PEPROCESS Process;
    PETHREAD Thread;
    PLIST_ENTRY Entry, Entry2;
    PDEBUG_EVENT DebugEvent, DebugEvent2;
    BOOLEAN GotEvent;

    PAGED_CODE ();

    PreviousMode = KeGetPreviousMode();

    try {
        if (ARGUMENT_PRESENT (Timeout)) {
            if (PreviousMode != KernelMode) {
                ProbeForReadSmallStructure (Timeout, sizeof (*Timeout), sizeof (UCHAR));
            }
            Tmo = *Timeout;
            Timeout = &Tmo;
            KeQuerySystemTime (&StartTime);
        }
        if (PreviousMode != KernelMode) {
            ProbeForWriteSmallStructure (WaitStateChange, sizeof (*WaitStateChange), sizeof (UCHAR));
        }

    } except (ExSystemExceptionFilter ()) { // If previous mode is kernel then don't handle the exception
        return GetExceptionCode ();
    }


    Status = ObReferenceObjectByHandle (DebugObjectHandle,
                                        DEBUG_READ_EVENT,
                                        DbgkDebugObjectType,
                                        PreviousMode,
                                        &DebugObject,
                                        NULL);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    Process = NULL;
    Thread = NULL;

    while (1) {
        Status = KeWaitForSingleObject (&DebugObject->EventsPresent,
                                        Executive,
                                        PreviousMode,
                                        Alertable,
                                        Timeout);
        if (!NT_SUCCESS (Status) || Status == STATUS_TIMEOUT || Status == STATUS_ALERTED || Status == STATUS_USER_APC) {
            break;
        }

        GotEvent = FALSE;

        DebugEvent = NULL;

        ExAcquireFastMutex (&DebugObject->Mutex);

        //
        // If the object is delete pending then return an error.
        //
        if ((DebugObject->Flags&DEBUG_OBJECT_DELETE_PENDING) == 0) {


            for (Entry = DebugObject->EventList.Flink;
                 Entry != &DebugObject->EventList;
                 Entry = Entry->Flink) {

                DebugEvent = CONTAINING_RECORD (Entry, DEBUG_EVENT, EventList);

                //
                // If this event has not been given back to the user yet and is not
                // inactive then pass it back.
                // We check to see if we have any other outstanding messages for this
                // thread as this confuses VC. You can only get multiple events
                // for the same thread for the attach faked messages.
                //
                if ((DebugEvent->Flags&(DEBUG_EVENT_READ|DEBUG_EVENT_INACTIVE)) == 0) {
                    GotEvent = TRUE;
                    for (Entry2 = DebugObject->EventList.Flink;
                         Entry2 != Entry;
                         Entry2 = Entry2->Flink) {

                        DebugEvent2 = CONTAINING_RECORD (Entry2, DEBUG_EVENT, EventList);

                        if (DebugEvent->ClientId.UniqueProcess == DebugEvent2->ClientId.UniqueProcess) {
                            //
                            // This event has the same process as an earlier event. Mark it as inactive.
                            //
                            DebugEvent->Flags |= DEBUG_EVENT_INACTIVE;
                            DebugEvent->BackoutThread = NULL;
                            GotEvent = FALSE;
                            break;
                        }
                    }
                    if (GotEvent) {
                        break;
                    }
                }
            }

            if (GotEvent) {
                Process = DebugEvent->Process;
                Thread = DebugEvent->Thread;
                ObReferenceObject (Thread);
                ObReferenceObject (Process);
                DbgkpConvertKernelToUserStateChange (&tWaitStateChange, DebugEvent);
                DebugEvent->Flags |= DEBUG_EVENT_READ;
            } else {
                //
                // No unread events there. Clear the event.
                //
                KeClearEvent (&DebugObject->EventsPresent);
            }
            Status = STATUS_SUCCESS;

        } else {
            Status = STATUS_DEBUGGER_INACTIVE;
        }

        ExReleaseFastMutex (&DebugObject->Mutex);

        if (NT_SUCCESS (Status)) {
            //
            // If we woke up and found nothing
            //
            if (GotEvent == FALSE) {
                //
                // If timeout is a delta time then adjust it for the wait so far.
                //
                if (Tmo.QuadPart < 0) {
                    LARGE_INTEGER NewTime;
                    KeQuerySystemTime (&NewTime);
                    Tmo.QuadPart = Tmo.QuadPart + (NewTime.QuadPart - StartTime.QuadPart);
                    StartTime = NewTime;
                    if (Tmo.QuadPart >= 0) {
                        Status = STATUS_TIMEOUT;
                        break;
                    }
                }
            } else {
                //
                // Fixup needed handles. The caller could have guessed the thread id etc by now and made the target thread
                // continue. This isn't a problem as we won't do anything damaging to the system in this case. The caller
                // won't get the correct results but they set out to break us.
                //
                DbgkpOpenHandles (&tWaitStateChange, Process, Thread);
                ObDereferenceObject (Thread);
                ObDereferenceObject (Process);
                break;
            }
        } else {
            break;
        }
    }

    ObDereferenceObject (DebugObject);

    try {
        *WaitStateChange = tWaitStateChange;
    } except (ExSystemExceptionFilter ()) { // If previous mode is kernel then don't handle the exception
        Status = GetExceptionCode ();
    }
    return Status;
}

NTSTATUS
NtDebugContinue (
    IN HANDLE DebugObjectHandle,
    IN PCLIENT_ID ClientId,
    IN NTSTATUS ContinueStatus
    )
/*++

Routine Description:

    Continues a stalled debugged thread

Arguments:

    DebugObjectHandle - Handle to a debug object
    ClientId - ClientId of thread tro continue
    ContinueStatus - Status of continue

Return Value:

    Status of operation

--*/
{
    NTSTATUS Status;
    PDEBUG_OBJECT DebugObject;
    PDEBUG_EVENT DebugEvent, FoundDebugEvent;
    KPROCESSOR_MODE PreviousMode;
    CLIENT_ID Clid;
    PLIST_ENTRY Entry;
    BOOLEAN GotEvent;

    PreviousMode = KeGetPreviousMode();

    try {
        if (PreviousMode != KernelMode) {
            ProbeForReadSmallStructure (ClientId, sizeof (*ClientId), sizeof (UCHAR));
        }
        Clid = *ClientId;

    } except (ExSystemExceptionFilter ()) { // If previous mode is kernel then don't handle the exception
        return GetExceptionCode ();
    }

    switch (ContinueStatus) {
        case DBG_EXCEPTION_HANDLED :
        case DBG_EXCEPTION_NOT_HANDLED :
        case DBG_TERMINATE_THREAD :
        case DBG_TERMINATE_PROCESS :
        case DBG_CONTINUE :
            break;
        default :
            return STATUS_INVALID_PARAMETER;
    }

    Status = ObReferenceObjectByHandle (DebugObjectHandle,
                                        DEBUG_READ_EVENT,
                                        DbgkDebugObjectType,
                                        PreviousMode,
                                        &DebugObject,
                                        NULL);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    GotEvent = FALSE;
    FoundDebugEvent = NULL;

    ExAcquireFastMutex (&DebugObject->Mutex);

    for (Entry = DebugObject->EventList.Flink;
         Entry != &DebugObject->EventList;
         Entry = Entry->Flink) {

        DebugEvent = CONTAINING_RECORD (Entry, DEBUG_EVENT, EventList);

        //
        // Make sure the client ID matches and that the debugger saw all the events.
        // We don't allow the caller to start a thread that it never saw a message for.
        //
        if (DebugEvent->ClientId.UniqueProcess == Clid.UniqueProcess) {
            if (!GotEvent) {
                if (DebugEvent->ClientId.UniqueThread == Clid.UniqueThread &&
                    (DebugEvent->Flags&DEBUG_EVENT_READ) != 0) {
                    RemoveEntryList (Entry);
                    FoundDebugEvent = DebugEvent;
                    GotEvent = TRUE;
                }
            } else {
                //
                // VC breaks if it sees more than one event at a time
                // for the same process.
                //
                DebugEvent->Flags &= ~DEBUG_EVENT_INACTIVE;
                KeSetEvent (&DebugObject->EventsPresent, 0, FALSE);
                break;
            }
        }
    }

    ExReleaseFastMutex (&DebugObject->Mutex);

    ObDereferenceObject (DebugObject);

    if (GotEvent) {
        FoundDebugEvent->ApiMsg.ReturnedStatus = ContinueStatus;
        FoundDebugEvent->Status = STATUS_SUCCESS;
        DbgkpWakeTarget (FoundDebugEvent);
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}

NTSTATUS
NtSetInformationDebugObject (
    IN HANDLE DebugObjectHandle,
    IN DEBUGOBJECTINFOCLASS DebugObjectInformationClass,
    IN PVOID DebugInformation,
    IN ULONG DebugInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )
/*++

Routine Description:

    This function sets the state of a debug object.

Arguments:

    ProcessHandle - Supplies a handle to a process object.

    ProcessInformationClass - Supplies the class of information being
        set.

    ProcessInformation - Supplies a pointer to a record that contains the
        information to set.

    ProcessInformationLength - Supplies the length of the record that contains
        the information to set.

Return Value:

    NTSTATUS - Status of call

--*/
{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PDEBUG_OBJECT DebugObject;
    ULONG Flags;

    PreviousMode = KeGetPreviousMode();

    try {
        if (PreviousMode != KernelMode) {
            ProbeForRead (DebugInformation,
                          DebugInformationLength,
                          sizeof (ULONG));
            if (ARGUMENT_PRESENT (ReturnLength)) {
                ProbeForWriteUlong (ReturnLength);
            }
        }
        if (ARGUMENT_PRESENT (ReturnLength)) {
            *ReturnLength = 0;
        }

        switch (DebugObjectInformationClass) {
            case DebugObjectFlags : {

                if (DebugInformationLength != sizeof (ULONG)) {
                    if (ARGUMENT_PRESENT (ReturnLength)) {
                        *ReturnLength = sizeof (ULONG);
                    }
                    return STATUS_INFO_LENGTH_MISMATCH;
                }
                Flags = *(PULONG) DebugInformation;

                break;
            }
            default : {
                return STATUS_INVALID_PARAMETER;
            }
        }
    } except (ExSystemExceptionFilter ()) {
        return GetExceptionCode ();
    }


    switch (DebugObjectInformationClass) {
        case DebugObjectFlags : {
            if (Flags & ~DEBUG_KILL_ON_CLOSE) {
                return STATUS_INVALID_PARAMETER;
            }
            Status = ObReferenceObjectByHandle (DebugObjectHandle,
                                                DEBUG_SET_INFORMATION,
                                                DbgkDebugObjectType,
                                                PreviousMode,
                                                &DebugObject,
                                                NULL);

            if (!NT_SUCCESS (Status)) {
                return Status;
            }
            ExAcquireFastMutex (&DebugObject->Mutex);

            if (Flags&DEBUG_KILL_ON_CLOSE) {
                DebugObject->Flags |= DEBUG_OBJECT_KILL_ON_CLOSE;
            } else {
                DebugObject->Flags &= ~DEBUG_OBJECT_KILL_ON_CLOSE;
            }

            ExReleaseFastMutex (&DebugObject->Mutex);

            ObDereferenceObject (DebugObject);
        }
    }
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\hivemap.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    hivemap.c

Abstract:

    This module implements HvpBuildMap - used to build the initial map for a hive

Revision History:

    Implementation of bin-size chunk loading of hives.

--*/

#include    "cmp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HvpBuildMap)
#pragma alloc_text(PAGE,HvpFreeMap)
#pragma alloc_text(PAGE,HvpAllocateMap)
#pragma alloc_text(PAGE,HvpBuildMapAndCopy)
#pragma alloc_text(PAGE,HvpEnlistFreeCells)
#pragma alloc_text(PAGE,HvpInitMap)
#pragma alloc_text(PAGE,HvpCleanMap)
#pragma alloc_text(PAGE,HvpEnlistBinInMap)
#pragma alloc_text(PAGE,HvpGetBinMemAlloc)
#endif

extern struct {
    PHHIVE      Hive;
    ULONG       Status;
    ULONG       Space;
    HCELL_INDEX MapPoint;
    PHBIN       BinPoint;
} HvCheckHiveDebug;

NTSTATUS
HvpBuildMapAndCopy(
    PHHIVE  Hive,
    PVOID   Image
    )
/*++

Routine Description:

    Creates the map for the Stable storage of the hive, and inits
    the map for the volatile storage.

    Following fields in hive must already be filled in:

         Allocate, Free

    Will initialize Storage structure of HHIVE.

    This function is called for the HINIT_MEMORY case. The hive is guaranteed
    to be in paged-pool. More than that, the hive image is contiguous. 
    It'll then copy from that image to the new paged-pool allocations.

Arguments:

    Hive - Pointer to hive control structure to build map for.

    Image - pointer to flat memory image of original hive.

Return Value:

    TRUE - it worked
    FALSE - either hive is corrupt or no memory for map

--*/
{
    PHBASE_BLOCK    BaseBlock;
    ULONG           Length;
    ULONG           MapSlots;
    ULONG           Tables;
    PHMAP_TABLE     t = NULL;
    PHMAP_DIRECTORY d = NULL;
    PHBIN           Bin;
    PHBIN           CurrentBin;
    ULONG           Offset;
    ULONG_PTR       Address;
    PHMAP_ENTRY     Me;
    NTSTATUS        Status;
    PULONG          Vector;


    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"HvpBuildMap:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"\tHive=%p",Hive));


    //
    // Compute size of data region to be mapped
    //
    BaseBlock = Hive->BaseBlock;
    Length = BaseBlock->Length;
    if ((Length % HBLOCK_SIZE) != 0 ) {
        Status = STATUS_REGISTRY_CORRUPT;
        goto ErrorExit1;
    }
    MapSlots = Length / HBLOCK_SIZE;
    if( MapSlots > 0 ) {
        Tables = (MapSlots-1) / HTABLE_SLOTS;
    } else {
        Tables = 0;
    }

    Hive->Storage[Stable].Length = Length;

    //
    // allocate dirty vector if one is not already present (from HvpRecoverData)
    //

    if (Hive->DirtyVector.Buffer == NULL) {
        Vector = (PULONG)((Hive->Allocate)(ROUND_UP(Length/HSECTOR_SIZE/8,sizeof(ULONG)), TRUE,CM_FIND_LEAK_TAG22));
        if (Vector == NULL) {
            Status = STATUS_NO_MEMORY;
            goto ErrorExit1;
        }
        RtlZeroMemory(Vector, Length / HSECTOR_SIZE / 8);
        RtlInitializeBitMap(&Hive->DirtyVector, Vector, Length / HSECTOR_SIZE);
        Hive->DirtyAlloc = ROUND_UP(Length/HSECTOR_SIZE/8,sizeof(ULONG));
    }

    //
    // allocate and build structure for map
    //
    if (Tables == 0) {

        //
        // Just 1 table, no need for directory
        //
        t = (Hive->Allocate)(sizeof(HMAP_TABLE), FALSE,CM_FIND_LEAK_TAG23);
        if (t == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit1;
        }
        RtlZeroMemory(t, sizeof(HMAP_TABLE));
        Hive->Storage[Stable].Map =
            (PHMAP_DIRECTORY)&(Hive->Storage[Stable].SmallDir);
        Hive->Storage[Stable].SmallDir = t;

    } else {

        //
        // Need directory and multiple tables
        //
        d = (PHMAP_DIRECTORY)(Hive->Allocate)(sizeof(HMAP_DIRECTORY), FALSE,CM_FIND_LEAK_TAG24);
        if (d == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit1;
        }
        RtlZeroMemory(d, sizeof(HMAP_DIRECTORY));

        //
        // Allocate tables and fill in dir
        //
        if (HvpAllocateMap(Hive, d, 0, Tables) == FALSE) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit2;
        }
        Hive->Storage[Stable].Map = d;
        Hive->Storage[Stable].SmallDir = 0;
    }

    //
    // Now we have to allocate the memory for the HBINs and fill in
    // the map appropriately.  We are careful never to allocate less
    // than a page to avoid fragmenting pool.  As long as the page
    // size is a multiple of HBLOCK_SIZE (a fairly good assumption as
    // long as HBLOCK_SIZE is 4k) this strategy will prevent pool
    // fragmentation.
    //
    // If we come across an HBIN that is entirely composed of a freed
    // HCELL, then we do not allocate memory, but mark its HBLOCKs in
    // the map as not present.  HvAllocateCell will allocate memory for
    // the bin when it is needed.
    //
    Offset = 0;
    Bin = (PHBIN)Image;

    while (Bin < (PHBIN)((PUCHAR)(Image) + Length)) {

        if ( (Bin->Size > (Length-Offset))      ||
             (Bin->Signature != HBIN_SIGNATURE) ||
             (Bin->FileOffset != Offset)
           )
        {
            //
            // Bin is bogus
            //
            Status = STATUS_REGISTRY_CORRUPT;
            goto ErrorExit2;
        }

        CurrentBin = (PHBIN)(Hive->Allocate)(Bin->Size, FALSE,CM_FIND_LEAK_TAG25);
        if (CurrentBin==NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit2;
        }
        RtlCopyMemory(CurrentBin,
                      (PUCHAR)Image+Offset,
                      Bin->Size);

        //
        // create map entries for each block/page in bin
        //
        Address = (ULONG_PTR)CurrentBin;
        do {
            Me = HvpGetCellMap(Hive, Offset);
            VALIDATE_CELL_MAP(__LINE__,Me,Hive,Offset);
            Me->BlockAddress = Address;
            Me->BinAddress = (ULONG_PTR)CurrentBin;

            if (Address == (ULONG_PTR)CurrentBin) {
                Me->BinAddress |= HMAP_NEWALLOC;
                Me->MemAlloc = CurrentBin->Size;
            } else {
                Me->MemAlloc = 0;
            }

            Me->BinAddress |= HMAP_INPAGEDPOOL;
            // we don't need to set this - just for debug purposes
            ASSERT( (Me->CmView = NULL) == NULL );

            Address += HBLOCK_SIZE;
            Offset += HBLOCK_SIZE;
        } while ( Address < ((ULONG_PTR)CurrentBin + CurrentBin->Size ));

        if (Hive->ReadOnly == FALSE) {

            //
            // add free cells in the bin to the appropriate free lists
            //
            if ( ! HvpEnlistFreeCells(Hive,
                                      CurrentBin,
                                      CurrentBin->FileOffset
                                      )) {
                Status = STATUS_REGISTRY_CORRUPT;
                goto ErrorExit2;
            }
        }

        Bin = (PHBIN)((ULONG_PTR)Bin + Bin->Size);
    }

    return STATUS_SUCCESS;


ErrorExit2:
    if (d != NULL) {

        //
        // directory was built and allocated, so clean it up
        //

        HvpFreeMap(Hive, d, 0, Tables);
        (Hive->Free)(d, sizeof(HMAP_DIRECTORY));
    }

ErrorExit1:
    return Status;
}

NTSTATUS
HvpInitMap(
    PHHIVE  Hive
    )
/*++

Routine Description:

    Initialize the map for the Stable Volatile storage of the hive.

    Following fields in hive must already be filled in:

         Allocate, Free

    Will initialize Storage structure of HHIVE.

Arguments:

    Hive - Pointer to hive control structure to build map for.

Return Value:

    STATUS_SUCCESS - it worked
    STATUS_xxx - the erroneous status

--*/
{
    PHBASE_BLOCK    BaseBlock;
    ULONG           Length;
    ULONG           MapSlots;
    ULONG           Tables;
    PHMAP_TABLE     t = NULL;
    PHMAP_DIRECTORY d = NULL;
    NTSTATUS        Status;
    PULONG          Vector = NULL;

    
#if DBG
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"HvpInitMap:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"\tHive=%p",Hive));
#endif

    //
    // Compute size of data region to be mapped
    //
    BaseBlock = Hive->BaseBlock;
    Length = BaseBlock->Length;
    if ((Length % HBLOCK_SIZE) != 0) {
        Status = STATUS_REGISTRY_CORRUPT;
        goto ErrorExit1;
    }
    MapSlots = Length / HBLOCK_SIZE;
    if( MapSlots > 0 ) {
        Tables = (MapSlots-1) / HTABLE_SLOTS;
    } else {
        Tables = 0;
    }

    Hive->Storage[Stable].Length = Length;

    //
    // allocate dirty vector if one is not already present (from HvpRecoverData)
    //

    if (Hive->DirtyVector.Buffer == NULL) {
        Vector = (PULONG)((Hive->Allocate)(ROUND_UP(Length/HSECTOR_SIZE/8,sizeof(ULONG)), TRUE,CM_FIND_LEAK_TAG27));
        if (Vector == NULL) {
            Status = STATUS_NO_MEMORY;
            goto ErrorExit1;
        }
        RtlZeroMemory(Vector, Length / HSECTOR_SIZE / 8);
        RtlInitializeBitMap(&Hive->DirtyVector, Vector, Length / HSECTOR_SIZE);
        Hive->DirtyAlloc = ROUND_UP(Length/HSECTOR_SIZE/8,sizeof(ULONG));
    }

    //
    // allocate and build structure for map
    //
    if (Tables == 0) {

        //
        // Just 1 table, no need for directory
        //
        t = (Hive->Allocate)(sizeof(HMAP_TABLE), FALSE,CM_FIND_LEAK_TAG26);
        if (t == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit1;
        }
        RtlZeroMemory(t, sizeof(HMAP_TABLE));
        Hive->Storage[Stable].Map =
            (PHMAP_DIRECTORY)&(Hive->Storage[Stable].SmallDir);
        Hive->Storage[Stable].SmallDir = t;

    } else {

        //
        // Need directory and multiple tables
        //
        d = (PHMAP_DIRECTORY)(Hive->Allocate)(sizeof(HMAP_DIRECTORY), FALSE,CM_FIND_LEAK_TAG28);
        if (d == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit1;
        }
        RtlZeroMemory(d, sizeof(HMAP_DIRECTORY));

        //
        // Allocate tables and fill in dir
        //
        if (HvpAllocateMap(Hive, d, 0, Tables) == FALSE) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorExit2;
        }
        Hive->Storage[Stable].Map = d;
        Hive->Storage[Stable].SmallDir = 0;
    }

    return STATUS_SUCCESS;

ErrorExit2:
    if (d != NULL) {

        //
        // directory was built and allocated, so clean it up
        //

        HvpFreeMap(Hive, d, 0, Tables);
        (Hive->Free)(d, sizeof(HMAP_DIRECTORY));
    }

ErrorExit1:
    if( Vector ) {
        (Hive->Free)(Vector, ROUND_UP(Length/HSECTOR_SIZE/8,sizeof(ULONG)));
        Hive->DirtyVector.Buffer = NULL;
    }
    return Status;
}

NTSTATUS
HvpEnlistBinInMap(
    PHHIVE  Hive,
    ULONG   Length,
    PHBIN   Bin,
    ULONG   Offset,
    PVOID CmView OPTIONAL
    )
/*++

Routine Description:

    Creates map entries and enlist free cells for the specified bin 

Arguments:

    Hive - Pointer to hive control structure containing the target map

    Length - the Length of the hive image

    Bin - the bin to be enlisted

    Offset - the offset within the hive file

    CmView - pointer to the mapped view of the bin. If NULL, the bin resides in paged pool

Return Value:

    STATUS_SUCCESS - it worked
    STATUS_REGISTRY_CORRUPT - the bin is inconsistent
    STATUS_REGISTRY_RECOVERED - if we have fixed the bin on-the-fly (self heal feature).

--*/
{
    NTSTATUS        Status = STATUS_SUCCESS;
    ULONG           BinOffset;
    ULONG_PTR       Address;
    PHMAP_ENTRY     Me;

#if DBG
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"HvpEnlistBinInMap:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"\tHive=%p\t Offset=%08lx",Hive,Offset));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BIN_MAP,"HvpEnlistBinInMap: BinAddress = 0x%p\t Size = 0x%lx\n", Bin, Bin->Size));
#endif

    //
    // create map entries for each block/page in bin
    //
    BinOffset = Offset;
    for (Address = (ULONG_PTR)Bin;
         Address < ((ULONG_PTR)Bin + Bin->Size);
         Address += HBLOCK_SIZE
        )
    {
        Me = HvpGetCellMap(Hive, Offset);
        VALIDATE_CELL_MAP(__LINE__,Me,Hive,Offset);
        Me->BlockAddress = Address;
        Me->BinAddress = (ULONG_PTR)Bin;
        if (Offset == BinOffset) {
            Me->BinAddress |= HMAP_NEWALLOC;
            Me->MemAlloc = Bin->Size;
        } else {
            Me->MemAlloc = 0;
        }
        
        //
        // take care here
        // 
        if( CmView == NULL ) {
            Me->BinAddress |= HMAP_INPAGEDPOOL;
            // we don't need to set this - just for debug purposes
            ASSERT( (Me->CmView = NULL) == NULL );
        } else {
            Me->BinAddress |= HMAP_INVIEW;
        }
        
        Offset += HBLOCK_SIZE;
    }

    if (Hive->ReadOnly == FALSE) {

        //
        // add free cells in the bin to the appropriate free lists
        //
        if ( ! HvpEnlistFreeCells(Hive, Bin, BinOffset)) {
            HvCheckHiveDebug.Hive = Hive;
            HvCheckHiveDebug.Status = 0xA002;
            HvCheckHiveDebug.Space = Length;
            HvCheckHiveDebug.MapPoint = BinOffset;
            HvCheckHiveDebug.BinPoint = Bin;
            if( CmDoSelfHeal() ) {
                Status = STATUS_REGISTRY_RECOVERED;
            } else {
                Status = STATUS_REGISTRY_CORRUPT;
                goto ErrorExit;
            }
        }

    }

    //
    // logical consistency check
    //
    ASSERT(Offset == (BinOffset + Bin->Size));

ErrorExit:
    return Status;
}

NTSTATUS
HvpBuildMap(
    PHHIVE  Hive,
    PVOID   Image
    )
/*++

Routine Description:

    Creates the map for the Stable storage of the hive, and inits
    the map for the volatile storage.

    Following fields in hive must already be filled in:

         Allocate, Free

    Will initialize Storage structure of HHIVE.

Arguments:

    Hive - Pointer to hive control structure to build map for.

    Image - pointer to in memory image of the hive

Return Value:

    TRUE - it worked
    FALSE - either hive is corrupt or no memory for map

--*/
{
    PHBIN           Bin;
    ULONG           Offset;
    NTSTATUS        Status;
    ULONG           Length;


#if DBG
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"HvpBuildMap:\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_HIVE,"\tHive=%p",Hive));
#endif

    //
    // Init the map
    //
    Status = HvpInitMap(Hive);

    if( !NT_SUCCESS(Status) ) {
        //
        // just return failure; HvpInitMap took care of cleanup
        //
        return Status;
    }

    //
    // Fill in the map
    //
    Offset = 0;
    Bin = (PHBIN)Image;
    Length = Hive->Storage[Stable].Length;

    while (Bin < (PHBIN)((PUCHAR)(Image) + Length)) {

        //
        // Check the validity of the bin header
        //
        if ( (Bin->Size > Length)                       ||
             (Bin->Size < HBLOCK_SIZE)                  ||
             (Bin->Signature != HBIN_SIGNATURE)         ||
             (Bin->FileOffset != Offset)) {
            //
            // Bin is bogus
            //
            HvCheckHiveDebug.Hive = Hive;
            HvCheckHiveDebug.Status = 0xA001;
            HvCheckHiveDebug.Space = Length;
            HvCheckHiveDebug.MapPoint = Offset;
            HvCheckHiveDebug.BinPoint = Bin;
            //
            // for the loader.
            //
            if( CmDoSelfHeal() ) {
                //
                // put the correct signature, fileoffset and binsize in place;
                // HvEnlistBinInMap will take care of the cells consistency.
                //
                Bin->Signature = HBIN_SIGNATURE;
                Bin->FileOffset = Offset;
                if ( ((Offset + Bin->Size) > Length)   ||
                     (Bin->Size < HBLOCK_SIZE)            ||
                     (Bin->Size % HBLOCK_SIZE) ) {
                    Bin->Size = HBLOCK_SIZE;
                }
                //
                // signal back to the caller that we have altered the hive.
                //
                CmMarkSelfHeal(Hive);
            } else {
                Status = STATUS_REGISTRY_CORRUPT;
                goto ErrorExit;
            }
        }

        //
        // enlist this bin
        //
        Status = HvpEnlistBinInMap(Hive, Length, Bin, Offset, NULL);
        //
        // for the loader.
        //
        if( CmDoSelfHeal() && (Status == STATUS_REGISTRY_RECOVERED) ) {
            CmMarkSelfHeal(Hive);
            Status = STATUS_SUCCESS;
        }

        if( !NT_SUCCESS(Status) ) {
            goto ErrorExit;
        }

        //
        // the next bin
        //
        Offset += Bin->Size;

        Bin = (PHBIN)((ULONG_PTR)Bin + Bin->Size);
    }

    return STATUS_SUCCESS;


ErrorExit:
    //
    // Clean up the directory table
    //
    HvpCleanMap( Hive );

    return Status;
}

BOOLEAN
HvpEnlistFreeCells(
    PHHIVE  Hive,
    PHBIN   Bin,
    ULONG   BinOffset
    )
/*++

Routine Description:

    Scan through the cells in the bin, locating the free ones.
    Enlist them in the hive's free list set.

    N.B.    Bin MUST already be mapped when this is called.

Arguments:

    Hive - pointer to hive control structure map is being built for

    Bin - pointer to bin to enlist cells from

    BinOffset - offset of Bin in image

Return Value:

    FALSE - registry is corrupt

    TRUE - it worked

--*/
{
    PHCELL          p;
    ULONG           celloffset;
    ULONG           size;
    HCELL_INDEX     cellindex;
    BOOLEAN         Result = TRUE;

    //
    // Scan all the cells in the bin, total free and allocated, check
    // for impossible pointers.
    //
    celloffset = sizeof(HBIN);
    p = (PHCELL)((PUCHAR)Bin + sizeof(HBIN));

    while (p < (PHCELL)((PUCHAR)Bin + Bin->Size)) {

        //
        // if free cell, check it out, add it to free list for hive
        //
        if (p->Size >= 0) {

            size = (ULONG)p->Size;

            if ( (size > Bin->Size)               ||
                 ( (PHCELL)(size + (PUCHAR)p) >
                   (PHCELL)((PUCHAR)Bin + Bin->Size) ) ||
                 ((size % HCELL_PAD(Hive)) != 0) ||
                 (size == 0) )
            {
                Result = FALSE;
                if( CmDoSelfHeal() ) {
                    //
                    // self heal mode; enlist the remaining of the bin as free
                    // also zero it out so any references into the tampered area will be
                    // detected and fixed by the logical check later on
                    //
                    p->Size = (LONG)((PUCHAR)((PUCHAR)Bin + Bin->Size) - (PUCHAR)p);
                    RtlZeroMemory((PUCHAR)p + sizeof(ULONG),p->Size - sizeof(ULONG));
                    size = (ULONG)p->Size;
                    CmMarkSelfHeal(Hive);
                } else {
                    goto Exit;
                }
            }


            //
            // cell is free, and is not obviously corrupt, add to free list
            //
            celloffset = (ULONG)((PUCHAR)p - (PUCHAR)Bin);
            cellindex = BinOffset + celloffset;

            //
            // Enlist this free cell, but do not coalesce with the next free cell
            // as we haven't gotten that far yet.
            //
            HvpEnlistFreeCell(Hive, cellindex, size, Stable, FALSE);

        } else {

            size = (ULONG)(p->Size * -1);

            if ( (size > Bin->Size)               ||
                 ( (PHCELL)(size + (PUCHAR)p) >
                   (PHCELL)((PUCHAR)Bin + Bin->Size) ) ||
                 ((size % HCELL_PAD(Hive)) != 0) ||
                 (size == 0) )
            {
                Result = FALSE;
                if( CmDoSelfHeal() ) {
                    //
                    // Self heal mode; we have no other way than to enlist this cell as a free cell
                    //
                    p->Size = (LONG)((PUCHAR)((PUCHAR)Bin + Bin->Size) - (PUCHAR)p);
                    RtlZeroMemory((PUCHAR)p + sizeof(ULONG),p->Size - sizeof(ULONG));
                    size = (ULONG)p->Size;

                    celloffset = (ULONG)((PUCHAR)p - (PUCHAR)Bin);
                    cellindex = BinOffset + celloffset;

                    HvpEnlistFreeCell(Hive, cellindex, size, Stable, FALSE);
                    CmMarkSelfHeal(Hive);
                } else {
                    goto Exit;
                }
            }

        }

        ASSERT( ((LONG)size) >= 0);
        p = (PHCELL)((PUCHAR)p + size);
    }

Exit:
    return Result;
}

VOID
HvpCleanMap(
    PHHIVE  Hive
    )
/*++

Routine Description:

    Cleans all the map allocations for the stable storage

  Arguments:

    Hive - Pointer to hive control structure to build map for.

Return Value:

    None
--*/
{
    ULONG           Length;
    ULONG           MapSlots;
    ULONG           Tables;
    PHMAP_DIRECTORY d = NULL;

    //
    // Free DirtyVector if any.
    //
    if( Hive->DirtyVector.Buffer != NULL ) {
        (Hive->Free)(Hive->DirtyVector.Buffer, ROUND_UP(Hive->Storage[Stable].Length/HSECTOR_SIZE/8,sizeof(ULONG)));
        Hive->DirtyVector.Buffer = NULL;
        Hive->DirtyAlloc = 0;
    }
    //
    // Compute MapSlots and Tables based on the Length
    //
    Length = Hive->Storage[Stable].Length;
    MapSlots = Length / HBLOCK_SIZE;
    if( MapSlots > 0 ) {
        Tables = (MapSlots-1) / HTABLE_SLOTS;
    } else {
        Tables = 0;
    }

    if( Hive->Storage[Stable].SmallDir == 0 ) {
        //
        // directory was built and allocated, so clean it up
        //

        d = Hive->Storage[Stable].Map;
        if( d != NULL ) {
            HvpFreeMap(Hive, d, 0, Tables);
            (Hive->Free)(d, sizeof(HMAP_DIRECTORY));
        }
    } else {
        //
        // no directory, just a smalldir
        //
        (Hive->Free)(Hive->Storage[Stable].SmallDir, sizeof(HMAP_TABLE));
    }
    
    Hive->Storage[Stable].SmallDir = NULL;
    Hive->Storage[Stable].Map = NULL;

}

VOID
HvpFreeMap(
    PHHIVE          Hive,
    PHMAP_DIRECTORY Dir,
    ULONG           Start,
    ULONG           End
    )
/*++

Routine Description:

    Sweeps through the directory Dir points to and frees Tables.
    Will free Start-th through End-th entries, INCLUSIVE.

Arguments:

    Hive - supplies pointer to hive control block of interest

    Dir - supplies address of an HMAP_DIRECTORY structure

    Start - index of first map table pointer to clean up

    End - index of last map table pointer to clean up

Return Value:

    NONE.

--*/
{
    ULONG   i;
    
    if( Dir == NULL ) {
        return;
    }

    if (End >= HDIRECTORY_SLOTS) {
        End = HDIRECTORY_SLOTS - 1;
    }

    for (i = Start; i <= End; i++) {
        if (Dir->Directory[i] != NULL) {
            (Hive->Free)(Dir->Directory[i], sizeof(HMAP_TABLE));
            Dir->Directory[i] = NULL;
        }
    }
    return;
}

BOOLEAN
HvpAllocateMap(
    PHHIVE          Hive,
    PHMAP_DIRECTORY Dir,
    ULONG           Start,
    ULONG           End
    )
/*++

Routine Description:

    Sweeps through the directory Dir points to and allocates Tables.
    Will allocate Start-th through End-th entries, INCLUSIVE.

    Does NOT clean up when out of memory, call HvpFreeMap to do that.
Arguments:

    Hive - supplies pointer to hive control block of interest

    Dir - supplies address of an HMAP_DIRECTORY structure

    Start - index of first map table pointer to allocate for

    End - index of last map table pointer to allocate for

Return Value:

    TRUE - it worked

    FALSE - insufficient memory

--*/
{
    ULONG   i,j;
    PHMAP_TABLE t;

    for (i = Start; i <= End; i++) {
        ASSERT(Dir->Directory[i] == NULL);
        t = (PHMAP_TABLE)((Hive->Allocate)(sizeof(HMAP_TABLE), FALSE,CM_FIND_LEAK_TAG29));
        if (t == NULL) {
            return FALSE;
        }
        // the zero memory stuff can be removed
        RtlZeroMemory(t, sizeof(HMAP_TABLE));
        for(j=0;j<HTABLE_SLOTS;j++) {
            //
            // Invalidate the entry
            //
            t->Table[j].BinAddress = 0;
            // we don't need to set this - just for debug purposes
            ASSERT( (t->Table[j].CmView = NULL) == NULL );
        }

        Dir->Directory[i] = t;
    }
    return TRUE;
}

ULONG 
HvpGetBinMemAlloc(
                IN PHHIVE           Hive,
                PHBIN               Bin,
                IN HSTORAGE_TYPE    Type
                        )
/*++

Routine Description:

    Returns the bin MemAlloc (formerly kept right in the bin) by looking at
    the map. We need this to avoid touching the bins only to set their MemAlloc.
    
      
Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Bin - The bin in question

    Type - Stable or Volatile

Return Value:

    Pointer to the new BIN if we succeeded, NULL if we failed.

--*/
{
    PHMAP_ENTRY     Map;
    HCELL_INDEX     Cell;

#if DBG
    ULONG           i;
    PHMAP_ENTRY     Me;
#endif

    PAGED_CODE();

    ASSERT( Bin->Signature == HBIN_SIGNATURE );
    
    Cell = Bin->FileOffset + (Type * HCELL_TYPE_MASK);

    Map = HvpGetCellMap(Hive, Cell);
    VALIDATE_CELL_MAP(__LINE__,Map,Hive,Cell);

#if DBG
    //
    // some validation code
    //
    for( i=0;i<Bin->Size;i+=HBLOCK_SIZE) {
        Cell = Bin->FileOffset + i + (Type * HCELL_TYPE_MASK);
        Me = HvpGetCellMap(Hive, Cell);
        VALIDATE_CELL_MAP(__LINE__,Me,Hive,Cell);

        if( i == 0 ) {
            ASSERT( Me->MemAlloc != 0 );
        } else {
            ASSERT( Me->MemAlloc == 0 );
        }
    }
#endif

    return Map->MemAlloc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\dbgk\dbgkp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    dbgkp.h

Abstract:

    This header file describes private data structures and functions
    that make up the kernel mode portion of the Dbg subsystem.

--*/

#ifndef _DBGKP_
#define _DBGKP_

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4324)   // alignment sensitive to declspec
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses

#include "ntos.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include <zwapi.h>
#include <string.h>
#if defined(_WIN64)
#include <wow64t.h>
#endif

#define DEBUG_EVENT_READ            (0x01)  // Event had been seen by win32 app
#define DEBUG_EVENT_NOWAIT          (0x02)  // No waiter one this. Just free the pool
#define DEBUG_EVENT_INACTIVE        (0x04)  // The message is in inactive. It may be activated or deleted later
#define DEBUG_EVENT_RELEASE         (0x08)  // Release rundown protection on this thread
#define DEBUG_EVENT_PROTECT_FAILED  (0x10)  // Rundown protection failed to be acquired on this thread
#define DEBUG_EVENT_SUSPEND         (0x20)  // Resume thread on continue


#define DBGKP_FIELD_FROM_IMAGE_OPTIONAL_HEADER(hdrs,field) \
            ((hdrs)->OptionalHeader.##field)

typedef struct _DEBUG_EVENT {
    LIST_ENTRY EventList;      // Queued to event object through this
    KEVENT ContinueEvent;
    CLIENT_ID ClientId;
    PEPROCESS Process;         // Waiting process
    PETHREAD Thread;           // Waiting thread
    NTSTATUS Status;           // Status of operation
    ULONG Flags;
    PETHREAD BackoutThread;    // Backout key for faked messages
    DBGKM_APIMSG ApiMsg;       // Message being sent
} DEBUG_EVENT, *PDEBUG_EVENT;


NTSTATUS
DbgkpSendApiMessage(
    IN OUT PDBGKM_APIMSG ApiMsg,
    IN BOOLEAN SuspendProcess
    );

BOOLEAN
DbgkpSuspendProcess(
    VOID
    );

VOID
DbgkpResumeProcess(
    VOID
    );

HANDLE
DbgkpSectionToFileHandle(
    IN PVOID SectionObject
    );

VOID
DbgkpDeleteObject (
    IN  PVOID   Object
    );

VOID
DbgkpCloseObject (
    IN PEPROCESS Process,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG_PTR ProcessHandleCount,
    IN ULONG_PTR SystemHandleCount
    );

NTSTATUS
DbgkpQueueMessage (
    IN PEPROCESS Process,
    IN PETHREAD Thread,
    IN OUT PDBGKM_APIMSG ApiMsg,
    IN ULONG Flags,
    IN PDEBUG_OBJECT TargetDebugObject
    );

VOID
DbgkpOpenHandles (
    PDBGUI_WAIT_STATE_CHANGE WaitStateChange,
    PEPROCESS Process,
    PETHREAD Thread
    );

VOID
DbgkpMarkProcessPeb (
    PEPROCESS Process
    );

VOID
DbgkpConvertKernelToUserStateChange (
    IN OUT PDBGUI_WAIT_STATE_CHANGE WaitStateChange,
    IN PDEBUG_EVENT DebugEvent
    );

NTSTATUS
DbgkpSendApiMessageLpc(
    IN OUT PDBGKM_APIMSG ApiMsg,
    IN PVOID Port,
    IN BOOLEAN SuspendProcess
    );

VOID
DbgkpFreeDebugEvent (
    IN PDEBUG_EVENT DebugEvent
    );

NTSTATUS
DbgkpPostFakeProcessCreateMessages (
    IN PEPROCESS Process,
    IN PDEBUG_OBJECT DebugObject,
    IN PETHREAD *pLastThread
    );

NTSTATUS
DbgkpPostFakeModuleMessages (
    IN PEPROCESS Process,
    IN PETHREAD Thread,
    IN PDEBUG_OBJECT DebugObject
    );

NTSTATUS
DbgkpPostFakeThreadMessages (
    IN PEPROCESS Process,
    IN PDEBUG_OBJECT DebugObject,
    IN PETHREAD StartThread,
    OUT PETHREAD *pFirstThread,
    OUT PETHREAD *pLastThread
    );

NTSTATUS
DbgkpPostAdditionalThreadMessages (
    IN PEPROCESS Process,
    IN PDEBUG_OBJECT DebugObject,
    IN PETHREAD LastThread
    );

VOID
DbgkpWakeTarget (
    IN PDEBUG_EVENT DebugEvent
    );

NTSTATUS
DbgkpSetProcessDebugObject (
    IN PEPROCESS Process,
    IN PDEBUG_OBJECT DebugObject,
    IN NTSTATUS MsgStatus,
    IN PETHREAD LastThread
    );



#endif // _DBGKP_
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\ntapi.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    ntapi.c

Abstract:

    This module contains the NT level entry points for the registry.

--*/

#include "cmp.h"
#include "safeboot.h"
#include <evntrace.h>

extern POBJECT_TYPE ExEventObjectType;

extern POBJECT_TYPE CmpKeyObjectType;

extern BOOLEAN CmFirstTime;
extern BOOLEAN CmBootAcceptFirstTime;
extern BOOLEAN CmpHoldLazyFlush;
extern BOOLEAN CmpCannotWriteConfiguration;

extern BOOLEAN CmpTraceFlag;

extern BOOLEAN HvShutdownComplete;

//
// Nt API helper routines
//
NTSTATUS
CmpNameFromAttributes(
    IN POBJECT_ATTRIBUTES Attributes,
    KPROCESSOR_MODE PreviousMode,
    OUT PUNICODE_STRING FullName
    );

ULONG
CmpKeyInfoProbeAlingment(
                             IN KEY_INFORMATION_CLASS KeyInformationClass
                        );


#ifdef POOL_TAGGING

#define ALLOCATE_WITH_QUOTA(a,b,c) ExAllocatePoolWithQuotaTag((a)|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,b,c)

#else

#define ALLOCATE_WITH_QUOTA(a,b,c) ExAllocatePoolWithQuota((a)|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,b)

#endif

#if DBG

ULONG
CmpExceptionFilter(
    IN PEXCEPTION_POINTERS ExceptionPointers
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmpExceptionFilter)
#endif
#else

#define CmpExceptionFilter(x) EXCEPTION_EXECUTE_HANDLER

#endif

VOID
CmpDummyApc(
    struct _KAPC *Apc,
    PVOID *SystemArgument1,
    PVOID *SystemArgument2
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NtCreateKey)
#pragma alloc_text(PAGE,NtDeleteKey)
#pragma alloc_text(PAGE,NtDeleteValueKey)
#pragma alloc_text(PAGE,NtEnumerateKey)
#pragma alloc_text(PAGE,NtEnumerateValueKey)
#pragma alloc_text(PAGE,NtFlushKey)
#pragma alloc_text(PAGE,NtInitializeRegistry)
#pragma alloc_text(PAGE,NtNotifyChangeKey)
#pragma alloc_text(PAGE,NtNotifyChangeMultipleKeys)
#pragma alloc_text(PAGE,NtOpenKey)
#pragma alloc_text(PAGE,NtQueryKey)
#pragma alloc_text(PAGE,NtQueryValueKey)
#pragma alloc_text(PAGE,NtQueryMultipleValueKey)
#pragma alloc_text(PAGE,NtRestoreKey)
#pragma alloc_text(PAGE,NtSaveKey)
#pragma alloc_text(PAGE,NtSaveKeyEx)
#pragma alloc_text(PAGE,NtSaveMergedKeys)
#pragma alloc_text(PAGE,NtSetValueKey)
#pragma alloc_text(PAGE,NtLoadKey)
#pragma alloc_text(PAGE,NtLoadKey2)
#pragma alloc_text(PAGE,NtLoadKeyEx)
#pragma alloc_text(PAGE,NtUnloadKey)
#pragma alloc_text(PAGE,NtUnloadKey2)
#pragma alloc_text(PAGE,NtUnloadKeyEx)
#pragma alloc_text(PAGE,NtSetInformationKey)
#pragma alloc_text(PAGE,NtReplaceKey)
#pragma alloc_text(PAGE,NtRenameKey)
#pragma alloc_text(PAGE,NtQueryOpenSubKeys)
#pragma alloc_text(PAGE,NtQueryOpenSubKeysEx)

#pragma alloc_text(PAGE,NtLockRegistryKey)

#pragma alloc_text(PAGE,CmpNameFromAttributes)
#pragma alloc_text(PAGE,CmpAllocatePostBlock)
#pragma alloc_text(PAGE,CmpFreePostBlock)
#pragma alloc_text(PAGE,CmpKeyInfoProbeAlingment)

#pragma alloc_text(PAGE,NtCompactKeys)
#pragma alloc_text(PAGE,NtCompressKey)
#endif

//
// Nt level registry API calls
//

NTSTATUS
NtCreateKey(
    __out PHANDLE KeyHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __reserved ULONG TitleIndex,
    __in_opt PUNICODE_STRING Class,
    __in ULONG CreateOptions,
    __out_opt PULONG Disposition
    )
/*++

Routine Description:

    An existing registry key may be opened, or a new one created,
    with NtCreateKey.

    If the specified key does not exist, an attempt is made to create it.
    For the create attempt to succeed, the new node must be a direct
    child of the node referred to by KeyHandle.  If the node exists,
    it is opened.  Its value is not affected in any way.

    Share access is computed from desired access.

    NOTE:

        If CreateOptions has REG_OPTION_BACKUP_RESTORE set, then
        DesiredAccess will be ignored.  If the caller has the
        privilege SeBackupPrivilege asserted, a handle with
        KEY_READ | ACCESS_SYSTEM_SECURITY will be returned.
        If SeRestorePrivilege, then same but KEY_WRITE rather
        than KEY_READ.  If both, then both access sets.  If neither
        privilege is asserted, then the call will fail.

Arguments:

    KeyHandle - Receives a Handle which is used to access the
        specified key in the Registration Database.

    DesiredAccess - Specifies the access rights desired.

    ObjectAttributes - Specifies the attributes of the key being opened.
        Note that a key name must be specified.  If a Root Directory is
        specified, the name is relative to the root.  The name of the
        object must be within the name space allocated to the Registry,
        that is, all names beginning "\Registry".  RootHandle, if
        present, must be a handle to "\", or "\Registry", or a key
        under "\Registry".

        RootHandle must have been opened for KEY_CREATE_SUB_KEY access
        if a new node is to be created.

        NOTE:   Object manager will capture and probe this argument.

    TitleIndex - Specifies the index of the localized alias for
        the name of the key.  The title index specifies the index of
        the localized alias for the name.  Ignored if the key
        already exists.

    Class - Specifies the object class of the key.  (To the registry
        this is just a string.)  Ignored if NULL.

    CreateOptions - Optional control values:

        REG_OPTION_VOLATILE - Object is not to be stored across boots.

    Disposition - This optional parameter is a pointer to a variable
        that will receive a value indicating whether a new Registry
        key was created or an existing one opened:

        REG_CREATED_NEW_KEY - A new Registry Key was created
        REG_OPENED_EXISTING_KEY - An existing Registry Key was opened

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    KPROCESSOR_MODE     mode;
    CM_PARSE_CONTEXT    ParseContext;
    PCM_KEY_BODY        KeyBody;
    HANDLE              Handle = 0;
    UNICODE_STRING      CapturedObjectName = {0};

    // Start registry call tracing
    StartWmiCmTrace();

#if !defined(BUILD_WOW6432)
    DesiredAccess &= (~KEY_WOW64_RES); // filter out wow64 specific access
#endif

    CM_PAGED_CODE();

    UNREFERENCED_PARAMETER (TitleIndex);

    if ( HvShutdownComplete == TRUE ) {
        //
        // It is forbidden to wite to the registry after it has been shutdown
        //
        if (PoCleanShutdownEnabled() & PO_CLEAN_SHUTDOWN_REGISTRY){
            //
            // if in clean shutdown mode all processes should have been killed and all drivers unloaded at this point
            //
            CM_BUGCHECK(REGISTRY_ERROR,INVALID_WRITE_OPERATION,1,ObjectAttributes,0);
        }
#if DBG
        {
            PUCHAR  ImageName = PsGetCurrentProcessImageFileName();
            if ( !ImageName ) {
                ImageName = (PUCHAR)"Unknown";
            }
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\n\nProcess.Thread : %p.%p (%s) is trying to create key: \n",
                                                    PsGetCurrentProcessId(), PsGetCurrentThreadId(),ImageName);
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\tObjectAttributes = %p\n",ObjectAttributes);
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"The caller should not rely on data written to the registry after shutdown...\n");
        }
#endif
        return STATUS_TOO_LATE;
    }

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtCreateKey\n"));

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tDesiredAccess=%08lx ", DesiredAccess));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tCreateOptions=%08lx\n", CreateOptions));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tObjectAttributes=%p\n", ObjectAttributes));

    mode = KeGetPreviousMode();

    try {

        ParseContext.Class.Length = 0;
        ParseContext.Class.Buffer = NULL;

        if (mode == UserMode) {
            PUNICODE_STRING SafeObjectName;

            if (ARGUMENT_PRESENT(Class)) {
                ProbeAndReadUnicodeStringEx(&ParseContext.Class,Class);
                ProbeForRead(
                    ParseContext.Class.Buffer,
                    ParseContext.Class.Length,
                    sizeof(WCHAR)
                    );
            }
            ProbeAndZeroHandle(KeyHandle);

            if (ARGUMENT_PRESENT(Disposition)) {
                ProbeForWriteUlong(Disposition);
            }

            //
            // probe the ObjectAttributes as we shall use it for tracing
            //
            ProbeForReadSmallStructure( ObjectAttributes,
                                        sizeof(OBJECT_ATTRIBUTES),
                                        PROBE_ALIGNMENT(OBJECT_ATTRIBUTES) );
            SafeObjectName = ObjectAttributes->ObjectName;
            ProbeAndReadUnicodeStringEx(&CapturedObjectName,SafeObjectName);
            ProbeForRead(
                CapturedObjectName.Buffer,
                CapturedObjectName.Length,
                sizeof(WCHAR)
                );
        } else {

            if (ARGUMENT_PRESENT(Class)) {
                ParseContext.Class = *Class;
            }
            CapturedObjectName = *(ObjectAttributes->ObjectName);
        }

        //
        // be sure nobody will hurt himself when adding new options
        //
        ASSERT( (REG_LEGAL_OPTION & REG_OPTION_PREDEF_HANDLE) == 0 );

        if ((CreateOptions & (REG_LEGAL_OPTION | REG_OPTION_PREDEF_HANDLE)) != CreateOptions) {

            // End registry call tracing
            EndWmiCmTrace(STATUS_INVALID_PARAMETER,0,&CapturedObjectName,EVENT_TRACE_TYPE_REGCREATE);

            return STATUS_INVALID_PARAMETER;
        }

        // hook it for WMI
        HookKcbFromHandleForWmiCmTrace(ObjectAttributes->RootDirectory);

        ParseContext.TitleIndex = 0;
        ParseContext.CreateOptions = CreateOptions;
        ParseContext.Disposition = 0L;
        ParseContext.CreateLink = FALSE;
        ParseContext.PredefinedHandle = NULL;
        ParseContext.CreateOperation = TRUE;
        ParseContext.OriginatingPoint = NULL;

        status = ObOpenObjectByName(
                    ObjectAttributes,
                    CmpKeyObjectType,
                    mode,
                    NULL,
                    DesiredAccess,
                    (PVOID)&ParseContext,
                    &Handle
                    );

        if (status==STATUS_PREDEFINED_HANDLE) {
            status = ObReferenceObjectByHandle(Handle,
                                               0,
                                               CmpKeyObjectType,
                                               KernelMode,
                                               (PVOID *)(&KeyBody),
                                               NULL);
            if (NT_SUCCESS(status)) {
                HANDLE TempHandle;

                //
                // Make sure we do the dereference and close before accessing
                // user space as the reference might fault.
                //
                TempHandle = (HANDLE)LongToHandle(KeyBody->Type);
                ObDereferenceObject((PVOID)KeyBody);
                NtClose(Handle);
                Handle = *KeyHandle = TempHandle;
                status = STATUS_SUCCESS;
            }
        } else
        if (NT_SUCCESS(status)) {
            *KeyHandle = Handle;
            // need to do this only on clean shutdown
            CmpAddKeyTracker(Handle,mode);
        }

        if (ARGUMENT_PRESENT(Disposition)) {
            *Disposition = ParseContext.Disposition;
        }

    } except (CmpExceptionFilter(GetExceptionInformation())) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtCreateKey: code:%08lx\n", GetExceptionCode()));
        CapturedObjectName.Length = 0;
        CapturedObjectName.Buffer = NULL;
        status = GetExceptionCode();
    }

    // End registry call tracing
    EndWmiCmTrace(status,0,&CapturedObjectName,EVENT_TRACE_TYPE_REGCREATE);

    return  status;
}

extern PCM_KEY_BODY ExpControlKey[2];

//
// WARNING: This should be the same as the one defined in obp.h
//          Remove this one when object manager guys will export
//          this via ob.h
//
#define OBJ_AUDIT_OBJECT_CLOSE 0x00000004L

NTSTATUS
NtDeleteKey(
    __in HANDLE KeyHandle
    )
/*++

Routine Description:

    A registry key may be marked for delete, causing it to be removed
    from the system.  It will remain in the name space until the last
    handle to it is closed.

Arguments:

    KeyHandle - Specifies the handle of the Key to delete, must have
        been opened for DELETE access.

Return Value:

    NTSTATUS

--*/
{
    PCM_KEY_BODY                KeyBody;
    NTSTATUS                    status;
    OBJECT_HANDLE_INFORMATION   HandleInfo;

    // Start registry call tracing
    StartWmiCmTrace();

    CM_PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtDeleteKey\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tKeyHandle=%08lx\n", KeyHandle));

    status = ObReferenceObjectByHandle(KeyHandle,
                                       DELETE,
                                       CmpKeyObjectType,
                                       KeGetPreviousMode(),
                                       (PVOID *)(&KeyBody),
                                       &HandleInfo);

    if (NT_SUCCESS(status)) {

        if ( CmAreCallbacksRegistered() ) {
            REG_DELETE_KEY_INFORMATION DeleteInfo;
        
            DeleteInfo.Object = KeyBody;
            status = CmpCallCallBacks(RegNtPreDeleteKey,&DeleteInfo,TRUE,RegNtPostDeleteKey,KeyBody);
            if ( !NT_SUCCESS(status) ) {
                ObDereferenceObject((PVOID)KeyBody);
                return status;
            }
        }
        //
        // hook the kcb for WMI
        //
        HookKcbForWmiCmTrace(KeyBody);

        //
        // Delete key (if safe to do so)
        //
        if ( (ExpControlKey[0] && KeyBody->KeyControlBlock == ExpControlKey[0]->KeyControlBlock) ||
             (ExpControlKey[1] && KeyBody->KeyControlBlock == ExpControlKey[1]->KeyControlBlock) ) {
            
            status = STATUS_SUCCESS;
        } else {
            if ( CmIsKcbReadOnly(KeyBody->KeyControlBlock) ||
                 CmIsKcbReadOnly(KeyBody->KeyControlBlock->ParentKcb) ) {
                //
                // key is protected
                //
                status = STATUS_ACCESS_DENIED;
            } else {
                BEGIN_LOCK_CHECKPOINT;
                status = CmDeleteKey(KeyBody);
                END_LOCK_CHECKPOINT;
            }

            if (NT_SUCCESS(status)) {
                //
                // Audit the deletion
                //

                if ( HandleInfo.HandleAttributes & OBJ_AUDIT_OBJECT_CLOSE ) {
                    SeDeleteObjectAuditAlarm(KeyBody,
                                             KeyHandle );
                }
            }

        }

        // 
        // just a notification; disregard the return status
        //
        CmPostCallbackNotification(RegNtPostDeleteKey,KeyBody,status);

        ObDereferenceObject((PVOID)KeyBody);
    }

    // End registry call tracing
    EndWmiCmTrace(status,0,NULL,EVENT_TRACE_TYPE_REGDELETE);

    return status;
}


NTSTATUS
NtDeleteValueKey(
    __in HANDLE KeyHandle,
    __in PUNICODE_STRING ValueName
    )
/*++

Routine Description:

    One of the value entries of a registry key may be removed with this
    call.  To remove the entire key, call NtDeleteKey.

    The value entry with ValueName matching ValueName is removed from the key.
    If no such entry exists, an error is returned.

Arguments:

    KeyHandle - Specifies the handle of the key containing the value
        entry of interest.  Must have been opened for KEY_SET_VALUE access.

    ValueName - The name of the value to be deleted.  NULL is a legal name.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    PCM_KEY_BODY    KeyBody;
    KPROCESSOR_MODE mode;
    UNICODE_STRING  LocalValueName = {0};

    // Start registry call tracing
    StartWmiCmTrace();

    CM_PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtDeleteValueKey\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tKeyHandle=%08lx\n", KeyHandle));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tValueName='%wZ'\n", ValueName));

    mode = KeGetPreviousMode();

    status = ObReferenceObjectByHandle(
                KeyHandle,
                KEY_SET_VALUE,
                CmpKeyObjectType,
                mode,
                (PVOID *)(&KeyBody),
                NULL
                );

    if (NT_SUCCESS(status)) {

        //
        // hook the kcb for WMI
        //
        HookKcbForWmiCmTrace(KeyBody);

        try {
            if (mode == UserMode) {
                ProbeAndReadUnicodeStringEx(&LocalValueName,ValueName);
                ProbeForRead(
                    LocalValueName.Buffer,
                    LocalValueName.Length,
                    sizeof(WCHAR)
                    );
            } else {
                LocalValueName = *ValueName;
            }

            //
            // Length needs to be even multiple of the size of UNICODE char
            //
            if ((LocalValueName.Length & (sizeof(WCHAR) - 1)) != 0) {
                //
                // adjust normalize length so wmi can log value name correctly.
                //
                status = STATUS_INVALID_PARAMETER;
            } else if ( CmIsKcbReadOnly(KeyBody->KeyControlBlock) ) {
                //
                // key is protected
                //
                status = STATUS_ACCESS_DENIED;
            } else {
                if ( CmAreCallbacksRegistered() ) {
                    REG_DELETE_VALUE_KEY_INFORMATION DeleteInfo;
            
                    DeleteInfo.Object = KeyBody;
                    DeleteInfo.ValueName = &LocalValueName;
                    status = CmpCallCallBacks(RegNtPreDeleteValueKey,&DeleteInfo,TRUE,RegNtPostDeleteValueKey,KeyBody);
                }

                if ( NT_SUCCESS(status) ) {
                    BEGIN_LOCK_CHECKPOINT;
                    status = CmDeleteValueKey(
                                KeyBody->KeyControlBlock,
                                LocalValueName
                                );
                    END_LOCK_CHECKPOINT;
                    // 
                    // just a notification; disregard the return status
                    //
                    CmPostCallbackNotification(RegNtPostDeleteValueKey,KeyBody,status);
                }
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtDeleteValueKey: code:%08lx\n", GetExceptionCode()));
            LocalValueName.Length = 0;
            LocalValueName.Buffer = NULL;
            status = GetExceptionCode();
        }

        ObDereferenceObject((PVOID)KeyBody);
    } 

    // End registry call tracing
    EndWmiCmTrace(status,0,&LocalValueName,EVENT_TRACE_TYPE_REGDELETEVALUE);

    return status;
}


NTSTATUS
NtEnumerateKey(
    __in HANDLE KeyHandle,
    __in ULONG Index,
    __in KEY_INFORMATION_CLASS KeyInformationClass,
    __out_bcount_opt(Length) PVOID KeyInformation,
    __in ULONG Length,
    __out PULONG ResultLength
    )
/*++

Routine Description:

    The sub keys of an open key may be enumerated with NtEnumerateKey.

    NtEnumerateKey returns the name of the Index'th sub key of the open
    key specified by KeyHandle.  The value STATUS_NO_MORE_ENTRIES will be
    returned if value of Index is larger than the number of sub keys.

    Note that Index is simply a way to select among child keys.  Two calls
    to NtEnumerateKey with the same Index are NOT guaranteed to return
    the same results.

    If KeyInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

Arguments:

    KeyHandle - Handle of the key whose sub keys are to be enumerated.  Must
        be open for KEY_ENUMERATE_SUB_KEY access.

    Index - Specifies the (0-based) number of the sub key to be returned.

    KeyInformationClass - Specifies the type of information returned in
        Buffer.  One of the following types:

        KeyBasicInformation - return last write time, title index, and name.
            (see KEY_BASIC_INFORMATION structure)

        KeyNodeInformation - return last write time, title index, name, class.
            (see KEY_NODE_INFORMATION structure)

    KeyInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyInformation in bytes.

    ResultLength - Number of bytes actually written into KeyInformation.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PCM_KEY_BODY   KeyBody;
    KPROCESSOR_MODE mode;

    // Start registry call tracing
    StartWmiCmTrace();

    CM_PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtEnumerateKey\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tKeyHandle=%08lx Index=%08lx\n", KeyHandle, Index));

    if ((KeyInformationClass != KeyBasicInformation) &&
        (KeyInformationClass != KeyNodeInformation)  &&
        (KeyInformationClass != KeyFullInformation))
    {
        //
        // hook the kcb for WMI
        //
        HookKcbFromHandleForWmiCmTrace(KeyHandle);

        // End registry call tracing
        EndWmiCmTrace(STATUS_INVALID_PARAMETER,Index,NULL,EVENT_TRACE_TYPE_REGENUMERATEKEY);

        return STATUS_INVALID_PARAMETER;
    }

    mode = KeGetPreviousMode();

    status = ObReferenceObjectByHandle(
                KeyHandle,
                KEY_ENUMERATE_SUB_KEYS,
                CmpKeyObjectType,
                mode,
                (PVOID *)(&KeyBody),
                NULL
                );

    if (NT_SUCCESS(status)) {
        //
        // hook the kcb for WMI
        //
        HookKcbForWmiCmTrace(KeyBody);

        try {
            if (mode == UserMode) {
                ProbeForWrite(
                    KeyInformation,
                    Length,
                    sizeof(ULONG)
                    );
                ProbeForWriteUlong(ResultLength);
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtEnumerateKey: code:%08lx\n", GetExceptionCode()));
            status = GetExceptionCode();
        }

        if (NT_SUCCESS(status)) {

            if( CmAreCallbacksRegistered() ) {
                REG_ENUMERATE_KEY_INFORMATION   EnumerateInfo;

                EnumerateInfo.Object = KeyBody;
                EnumerateInfo.Index = Index;
                EnumerateInfo.KeyInformationClass = KeyInformationClass;
                EnumerateInfo.KeyInformation = KeyInformation;
                EnumerateInfo.Length = Length;
                EnumerateInfo.ResultLength = ResultLength;
        
                status = CmpCallCallBacks(RegNtPreEnumerateKey,&EnumerateInfo,TRUE,RegNtPostEnumerateKey,KeyBody);
            }

            if (NT_SUCCESS(status)) {
                //
                // CmEnumerateKey is protected to user mode buffer exceptions
                // all other exceptions are cm internals and should result in a bugcheck
                //
                BEGIN_LOCK_CHECKPOINT;
                status = CmEnumerateKey(
                            KeyBody->KeyControlBlock,
                            Index,
                            KeyInformationClass,
                            KeyInformation,
                            Length,
                            ResultLength
                            );
                END_LOCK_CHECKPOINT;
                // 
                // just a notification; disregard the return status
                //
                CmPostCallbackNotification(RegNtPostEnumerateKey,KeyBody,status);
            }
        }


        ObDereferenceObject((PVOID)KeyBody);
    }

    // End registry call tracing
    EndWmiCmTrace(status,Index,NULL,EVENT_TRACE_TYPE_REGENUMERATEKEY);

    return status;
}


NTSTATUS
NtEnumerateValueKey(
    __in HANDLE KeyHandle,
    __in ULONG Index,
    __in KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    __out_bcount_opt(Length) PVOID KeyValueInformation,
    __in ULONG Length,
    __out PULONG ResultLength
    )
/*++

Routine Description:

    The value entries of an open key may be enumerated
    with NtEnumerateValueKey.

    NtEnumerateValueKey returns the name of the Index'th value
    entry of the open key specified by KeyHandle.  The value
    STATUS_NO_MORE_ENTRIES will be returned if value of Index is
    larger than the number of sub keys.

    Note that Index is simply a way to select among value
    entries.  Two calls to NtEnumerateValueKey with the same Index
    are NOT guaranteed to return the same results.

    If KeyValueInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

Arguments:

    KeyHandle - Handle of the key whose value entries are to be enumerated.
        Must have been opened with KEY_QUERY_VALUE access.

    Index - Specifies the (0-based) number of the sub key to be returned.

    KeyValueInformationClass - Specifies the type of information returned
    in Buffer. One of the following types:

        KeyValueBasicInformation - return time of last write,
            title index, and name.  (See KEY_VALUE_BASIC_INFORMATION)

        KeyValueFullInformation - return time of last write,
            title index, name, class.  (See KEY_VALUE_FULL_INFORMATION)

    KeyValueInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyValueInformation in bytes.

    ResultLength - Number of bytes actually written into KeyValueInformation.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PCM_KEY_BODY   KeyBody;
    KPROCESSOR_MODE mode;

    // Start registry call tracing
    StartWmiCmTrace();

    CM_PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtEnumerateValueKey\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tKeyHandle=%08lx Index=%08lx\n", KeyHandle, Index));

    if ((KeyValueInformationClass != KeyValueBasicInformation) &&
        (KeyValueInformationClass != KeyValueFullInformation)  &&
        (KeyValueInformationClass != KeyValuePartialInformation))
    {
        //
        // hook the kcb for WMI
        //
        HookKcbFromHandleForWmiCmTrace(KeyHandle);

        // End registry call tracing
        EndWmiCmTrace(STATUS_INVALID_PARAMETER,Index,NULL,EVENT_TRACE_TYPE_REGENUMERATEVALUEKEY);

        return STATUS_INVALID_PARAMETER;
    }

    mode = KeGetPreviousMode();

    status = ObReferenceObjectByHandle(
                KeyHandle,
                KEY_QUERY_VALUE,
                CmpKeyObjectType,
                mode,
                (PVOID *)(&KeyBody),
                NULL
                );

    if (NT_SUCCESS(status)) {
        //
        // hook the kcb for WMI
        //
        HookKcbForWmiCmTrace(KeyBody);


        try {
            if (mode == UserMode) {
                ProbeForWrite(
                    KeyValueInformation,
                    Length,
                    sizeof(ULONG)
                    );
                ProbeForWriteUlong(ResultLength);
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtEnumerateValueKey: code:%08lx\n", GetExceptionCode()));
            status = GetExceptionCode();
        }

        if (NT_SUCCESS(status)) {
            if ( CmAreCallbacksRegistered() ) {
                REG_ENUMERATE_VALUE_KEY_INFORMATION   EnumerateValueInfo;
                
                EnumerateValueInfo.Object = KeyBody;
                EnumerateValueInfo.Index = Index;
                EnumerateValueInfo.KeyValueInformationClass = KeyValueInformationClass;
                EnumerateValueInfo.KeyValueInformation = KeyValueInformation;
                EnumerateValueInfo.Length = Length;
                EnumerateValueInfo.ResultLength = ResultLength;
        
                status = CmpCallCallBacks(RegNtPreEnumerateValueKey,&EnumerateValueInfo,TRUE,RegNtPostEnumerateValueKey,KeyBody);
            }

            if (NT_SUCCESS(status)) {
                //
                // CmEnumerateValueKey is protected to user mode buffer exceptions
                // all other exceptions are cm internals and should result in a bugcheck
                //
                BEGIN_LOCK_CHECKPOINT;
                status = CmEnumerateValueKey(
                            KeyBody->KeyControlBlock,
                            Index,
                            KeyValueInformationClass,
                            KeyValueInformation,
                            Length,
                            ResultLength
                            );
                END_LOCK_CHECKPOINT;
                // 
                // just a notification; disregard the return status
                //
                CmPostCallbackNotification(RegNtPostEnumerateValueKey,KeyBody,status);
            }
        }

        ObDereferenceObject((PVOID)KeyBody);
    }


    // End registry call tracing
    EndWmiCmTrace(status,Index,NULL,EVENT_TRACE_TYPE_REGENUMERATEVALUEKEY);

    return status;
}


NTSTATUS
NtFlushKey(
    __in HANDLE KeyHandle
    )
/*++

Routine Description:

    Changes made by NtCreateKey or NtSetKey may be flushed to disk with
    NtFlushKey.

    NtFlushKey will not return to its caller until any changed data
    associated with KeyHandle has been written to permanent store.

    WARNING: NtFlushKey will flush the entire registry tree, and thus will
    burn cycles and I/O.

Arguments:

    KeyHandle - Handle of open key to be flushed.

Return Value:

    NTSTATUS

--*/
{
    PCM_KEY_BODY   KeyBody;
    NTSTATUS    status;

    // Start registry call tracing
    StartWmiCmTrace();

    CM_PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtFlushKey\n"));

    status = ObReferenceObjectByHandle(
                KeyHandle,
                0,
                CmpKeyObjectType,
                KeGetPreviousMode(),
                (PVOID *)(&KeyBody),
                NULL
                );

    if (NT_SUCCESS(status)) {
        //
        // hook the kcb for WMI
        //
        HookKcbForWmiCmTrace(KeyBody);

        BEGIN_LOCK_CHECKPOINT;
        CmpLockRegistry();
        CmpLockKCBShared(KeyBody->KeyControlBlock);

        if (KeyBody->KeyControlBlock->Delete) {
            status = STATUS_KEY_DELETED;
        } else {
            //
            // call the worker to do the flush
            //
            status = CmFlushKey(KeyBody->KeyControlBlock,FALSE);
        }

        CmpUnlockKCB(KeyBody->KeyControlBlock);
        CmpUnlockRegistry();
        END_LOCK_CHECKPOINT;

        ObDereferenceObject((PVOID)KeyBody);
    }


    // End registry call tracing
    EndWmiCmTrace(status,0,NULL,EVENT_TRACE_TYPE_REGFLUSH);

    return status;
}


NTSTATUS
NtInitializeRegistry(
    __in USHORT BootCondition
    )
/*++

Routine Description:

    This routine is called in 2 situations:

    1) It is called from SM after autocheck (chkdsk) has
    run and the paging files have been opened.  It's function is
    to bind in memory hives to their files, and to open any other
    files yet to be used.

    2) It is called from SC after the current boot has been accepted
    and the control set used for the boot process should be saved
    as the LKG control set.

    After this routine accomplishes the work of situation #1 and
      #2, further requests for such work will not be carried out.

Arguments:

    BootCondition -

         REG_INIT_BOOT_SM -     The routine has been called from SM
                                in situation #1.

         REG_INIT_BOOT_SETUP -  The routine has been called to perform
                                situation #1 work but has been called
                                from setup and needs to do some special
                                work.

        REG_INIT_BOOT_ACCEPTED_BASE + Num
                        (where 0 < Num < 1000) - The routine has been called
                                                 in situation #2. "Num" is the
                                                 number of the control set
                                                 to which the boot control set
                                                 should be saved.

Return Value:

    NTSTATUS - Result code from call, among the following:

        STATUS_SUCCESS - it worked
        STATUS_ACCESS_DENIED - the routine has already done the work
                               requested and will not do it again.

--*/
{
    BOOLEAN     SetupBoot;
    NTSTATUS    Status;

    CM_PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtInitializeRegistry()\n"));

    //
    // Force previous mode to be KernelMode
    //
    if (KeGetPreviousMode() == UserMode) {
        return ZwInitializeRegistry(BootCondition);
    } else {
        //
        // Check for a valid BootCondition value
        //

        if (BootCondition > REG_INIT_MAX_VALID_CONDITION)
           return STATUS_INVALID_PARAMETER;

        //
        // Check for a Boot acceptance
        //

        if ((BootCondition >= REG_INIT_BOOT_ACCEPTED_BASE) &&
            (BootCondition <= REG_INIT_BOOT_ACCEPTED_MAX))
        {
           //
           // Make sure the Boot can be accepted only once
           //

           if (!CmBootAcceptFirstTime)
              return STATUS_ACCESS_DENIED;

           CmBootAcceptFirstTime = FALSE;

           //
           // Calculate the control set we want to save
           // the boot control set to
           //

           BootCondition -= REG_INIT_BOOT_ACCEPTED_BASE;

           if (BootCondition)
           {
                //
                // OK, this is a good boot for the purposes of LKG, and we have
                // a valid control set number passed into us. We save off our
                // control set and then notify everyone who wants to do post
                // WinLogon work.
                //
                // Note that none of this happens during Safe Mode boot!
                //
                Status = CmpSaveBootControlSet(BootCondition);

                //
                // Mark the boot good for the Hal. This lets the Hal do things
                // like optimize reboot performance.
                //
                HalEndOfBoot();

                //
                // Notify prefetcher of boot progress.
                //
                CcPfBeginBootPhase(PfBootAcceptedRegistryInitPhase);

                //
                // inform the user in the event one of the system core hives have been self healed
                //
                CmpRaiseSelfHealWarningForSystemHives();
                //
                // enable lazy flusher 
                //
                CmpHoldLazyFlush = FALSE;
                CmpLazyFlush();

                return Status;

           }
           else
           {
              //
              // 0 passed in as a control set number.
              // That is not valid, fail.
              //

              return STATUS_INVALID_PARAMETER;
           }
        }

        // called from setup?

        SetupBoot = (BootCondition == REG_INIT_BOOT_SETUP ? TRUE : FALSE);

        //
        // Fail if not first time called for situation #1 work.
        //

        if (CmFirstTime != TRUE) {
            return STATUS_ACCESS_DENIED;
        }
        CmFirstTime = FALSE;

        //
        // Notify WMI.
        //
        WmiBootPhase1();

        //
        // Notify prefetcher of boot progress.
        //

        CcPfBeginBootPhase(PfSMRegistryInitPhase);

        //
        // Call the worker to init cm globals
        //

        CmpLockRegistryExclusive();

        CmpCmdInit(SetupBoot);

        CmpSetVersionData();

        CmpUnlockRegistry();
    
        //
        // Notify PO that the volumes are usabled
        //
        PoInitHiberServices(SetupBoot);

        if (!SetupBoot) {
            IopCopyBootLogRegistryToFile();
        }

        return STATUS_SUCCESS;
    }
}

NTSTATUS
NtNotifyChangeKey(
    __in HANDLE KeyHandle,
    __in_opt HANDLE Event,
    __in_opt PIO_APC_ROUTINE ApcRoutine,
    __in_opt PVOID ApcContext,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in ULONG CompletionFilter,
    __in BOOLEAN WatchTree,
    __out_bcount_opt(BufferSize) PVOID Buffer,
    __in ULONG BufferSize,
    __in BOOLEAN Asynchronous
    )
/*++

Routine Description:

    Notification of key creation, deletion, and modification may be
    obtained by calling NtNotifyChangeKey.

    NtNotifyChangeKey monitors changes to a key - if the key or
    subtree specified by KeyHandle are modified, the service notifies
    its caller.  It also returns the name(s) of the key(s) that changed.
    All names are specified relative to the key that the handle represents
    (therefore a NULL name represents that key).  The service completes
    once the key or subtree has been modified based on the supplied
    CompletionFilter.  The service is a "single shot" and therefore
    needs to be reinvoked to watch the key for further changes.

    The operation of this service begins by opening a key for KEY_NOTIFY
    access.  Once the handle is returned, the NtNotifyChangeKey service
    may be invoked to begin watching the values and subkeys of the
    specified key for changes.  The first time the service is invoked,
    the BufferSize parameter supplies not only the size of the user's
    Buffer, but also the size of the buffer that will be used by the
    Registry to store names of keys that have changed.  Likewise, the
    CompletionFilter and WatchTree parameters on the first call indicate
    how notification should operate for all calls using the supplied
    KeyHandle.   These two parameters are ignored on subsequent calls
    to the API with the same instance of KeyHandle.

    Once a modification is made that should be reported, the Registry will
    complete the service.  The names of the files that have changed since
    the last time the service was called will be placed into the caller's
    output Buffer.  The Information field of IoStatusBlock will contain
    the number of bytes placed in Buffer, or zero if too many keys have
    changed since the last time the service was called, in which case
    the application must Query and Enumerate the key and sub keys to
    discover changes.  The Status field of IoStatusBlock will contain
    the actual status of the call.

    If Asynchronous is TRUE, then Event, if specified, will be set to
    the Signaled state.  If no Event parameter was specified, then
    KeyHandle will be set to the Signaled state.  If an ApcRoutine
    was specified, it is invoked with the ApcContext and the address of the
    IoStatusBlock as its arguments.  If Asynchronous is FALSE, Event,
    ApcRoutine, and ApcContext are ignored.

    This service requires KEY_NOTIFY access to the key that was
    actually modified

    The notify "session" is terminated by closing KeyHandle.

Arguments:

    KeyHandle-- Supplies a handle to an open key.  This handle is
        effectively the notify handle, because only one set of
        notify parameters may be set against it.

    Event - An optional handle to an event to be set to the
        Signaled state when the operation completes.

    ApcRoutine - An optional procedure to be invoked once the
        operation completes.  For more information about this
        parameter see the NtReadFile system service description.

        If PreviousMode == Kernel, this parameter is an optional
        pointer to a WORK_QUEUE_ITEM to be queued when the notify
        is signaled.

    ApcContext - A pointer to pass as an argument to the ApcRoutine,
        if one was specified, when the operation completes.  This
        argument is required if an ApcRoutine was specified.

        If PreviousMode == Kernel, this parameter is an optional
        WORK_QUEUE_TYPE describing the queue to be used. This argument
        is required if an ApcRoutine was specified.

    IoStatusBlock - A variable to receive the final completion status.
        For more information about this parameter see the NtCreateFile
        system service description.

    CompletionFilter -- Specifies a set of flags that indicate the
        types of operations on the key or its value that cause the
        call to complete.  The following are valid flags for this parameter:

        REG_NOTIFY_CHANGE_NAME -- Specifies that the call should be
            completed if a subkey is added or deleted.

        REG_NOTIFY_CHANGE_ATTRIBUTES -- Specifies that the call should
            be completed if the attributes (e.g.: ACL) of the key or
            any subkey are changed.

        REG_NOTIFY_CHANGE_LAST_SET -- Specifies that the call should be
            completed if the lastWriteTime of the key or any of its
            subkeys is changed.  (Ie. if the value of the key or any
            subkey is changed).

        REG_NOTIFY_CHANGE_SECURITY -- Specifies that the call should be
            completed if the security information (e.g. ACL) on the key
            or any subkey is changed.

    WatchTree -- A BOOLEAN value that, if TRUE, specifies that all
        changes in the subtree of this key should also be reported.
        If FALSE, only changes to this key, its value, and its immediate
        subkeys (but not their values nor their subkeys) are reported.

    Buffer -- A variable to receive the name(s) of the key(s) that
        changed.  See REG_NOTIFY_INFORMATION.

    BufferSize -- Specifies the length of Buffer.

    Asynchronous  -- If FALSE, call will not return until
        complete (synchronous) if TRUE, call may return STATUS_PENDING.

Obs:
    Since NtNotifyChangeMultipleKeys, this routine is kept only for backwards compatibility

Return Value:

    NTSTATUS

--*/
{
    CM_PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtNotifyChangeKey\n"));

    // Just call the wiser routine
    return NtNotifyChangeMultipleKeys(
                                        KeyHandle,
                                        0,
                                        NULL,
                                        Event,
                                        ApcRoutine,
                                        ApcContext,
                                        IoStatusBlock,
                                        CompletionFilter,
                                        WatchTree,
                                        Buffer,
                                        BufferSize,
                                        Asynchronous
                                    );

}

NTSTATUS
NtNotifyChangeMultipleKeys(
    __in HANDLE MasterKeyHandle,
    __in_opt ULONG Count,
    __in_ecount_opt(Count) OBJECT_ATTRIBUTES SlaveObjects[],
    __in_opt HANDLE Event,
    __in_opt PIO_APC_ROUTINE ApcRoutine,
    __in_opt PVOID ApcContext,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in ULONG CompletionFilter,
    __in BOOLEAN WatchTree,
    __out_bcount_opt(BufferSize) PVOID Buffer,
    __in ULONG BufferSize,
    __in BOOLEAN Asynchronous
    )
/*++

Routine Description:

    Notificaion of creation, deletion and modification on multiple keys
    may be obtained with NtNotifyChangeMultipleKeys.

    NtNotifyMultipleKeys monitors changes to any of the MasterKeyHandle
    or one of SlaveObjects and/or their subtrees, whichever occurs first.
    When an event on these keys is triggered, the notification is considered
    fulfilled, and has to be "armed" again, in order to watch for further
    changes.

    The mechanism is similar to the one described in NtNotifyChangeKey.

    The MasterKeyHandle key, give the caller control over the lifetime
    of the notification. The notification will live as long as the caller
    keeps the MasterKeyHandle open, or an event is triggered.

    The caller doesn't have to open the SlaveKeys. He will provide the
    routine with an array of OBJECT_ATTRIBUTES, describing the slave objects.
    The routine will open the objects, and ensure keep a reference on them
    until the back-end side will close them.

    The notify "session" is terminated by closing MasterKeyHandle.

Obs:
    For the time being, the routine supports only one slave object. When more
    than one slave object is provided, the routine will signal an error of
    STATUS_INVALID_PARAMETER.
    However, the interface is designed for future enhancements (taking an
    array of slave objects), that may be provided with future versions(w2001).

    When no slave object is supplied (i.e. Count == 0) we have the identical
    behavior as for NtNotifyChangeKey.

Arguments:

    MasterKeyHandle - Supplies a handle to an open key.  This handle is
        the "master handle". It has control overthe lifetime of the
        notification.

    Count - Number of slave objects. For the time being, this should be 1

    SlaveObjects - Array of slave objects. Only the attributes of the
        objects are provided, so the caller doesn't have to take care
        of them.

    Event,ApcRoutine,ApcContext,IoStatusBlock,CompletionFilter,WatchTree,
    Buffer,BufferSize,Asynchronous - same as for NtNotifyChangeKey

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    NTSTATUS            WaitStatus;
    KPROCESSOR_MODE     PreviousMode;
    PCM_KEY_BODY        MasterKeyBody;
    PCM_KEY_BODY        SlaveKeyBody;
    PKEVENT             UserEvent=NULL;
    PCM_POST_BLOCK      MasterPostBlock;
    PCM_POST_BLOCK      SlavePostBlock = NULL;
    KIRQL               OldIrql;
    HANDLE              SlaveKeyHandle;
    POST_BLOCK_TYPE     PostType = PostSynchronous;
    BOOLEAN             SlavePresent = FALSE;  // assume that we are in the NtNotifyChangeKey case
#if defined(_WIN64)
    BOOLEAN             UseIosb32=FALSE; // If the caller is a 32bit process on Win64 and previous mode
                                            // is user mode, use a 32bit IoSb.
#endif
    ULONG               HiveLockState = 0;  // 0 - none
                                            // 1 - master only
                                            // 2 - master, then slave
                                            // 3 - slave, then master

    PCMHIVE             SlaveHive = 0;
    ULONG               ConvKey1 = 0;
    ULONG               ConvKey2 = 0;

    CM_PAGED_CODE();

    BEGIN_LOCK_CHECKPOINT;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtNotifyChangeMultipleKeys\n"));

    if ( HvShutdownComplete == TRUE ) {
        //
        // too late to do registry operations.
        //
        return STATUS_TOO_LATE;
    }

    if (Count > 1) {
        //
        // This version supports only one slave object
        //
        return STATUS_INVALID_PARAMETER;
    }

    if (Count == 1) {
        //
        // We have one slave, so we are in the NtNotifyChangeMultipleKeys case
        //
        SlavePresent = TRUE;
    }

#if DBG
    if (SlavePresent) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"NtNotifyChangeMultipleKeys(%d,slave = %p, Asynchronous = %d)\n",MasterKeyHandle,SlaveObjects,(int)Asynchronous));
    }
#endif

    //
    // Threads that are attached give us real grief, so disallow it.
    //
    if (KeIsAttachedProcess()) {
        CM_BUGCHECK(REGISTRY_ERROR,BAD_NOTIFY_CONTEXT,1,0,0);
    }

    //
    // Probe user buffer parameters.
    //
    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {

#if defined(_WIN64)
        // Process is 32bit if Wow64 is not NULL.
        UseIosb32 = (PsGetCurrentProcess()->Wow64Process != NULL ? TRUE : FALSE);
#endif

        try {

            ProbeForWrite(
                IoStatusBlock,
#if defined(_WIN64)
                UseIosb32 ? sizeof(IO_STATUS_BLOCK32) : sizeof(IO_STATUS_BLOCK),
#else
                sizeof(IO_STATUS_BLOCK),
#endif
                sizeof(ULONG)
                );


            ProbeForWrite(Buffer, BufferSize, sizeof(ULONG));

            //
            // Initialize IOSB
            //

            CmpSetIoStatus(IoStatusBlock, STATUS_PENDING, 0, UseIosb32);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtChangeNotifyMultipleKeys: code:%08lx\n", GetExceptionCode()));
            return GetExceptionCode();
        }
        if (Asynchronous) {
            PostType = PostAsyncUser;
        }
    } else {
        if (Asynchronous) {
            PostType = PostAsyncKernel;
            if ( Count > 0 ) {
                //
                // we don't allow multiple asynchronous kernel notifications
                //
                return STATUS_INVALID_PARAMETER;
            }
        }
    }

    //
    // Check filter
    //
    if (CompletionFilter != (CompletionFilter & REG_LEGAL_CHANGE_FILTER)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Reference the Master Key handle
    //
    status = ObReferenceObjectByHandle(
                MasterKeyHandle,
                KEY_NOTIFY,
                CmpKeyObjectType,
                PreviousMode,
                (PVOID *)(&MasterKeyBody),
                NULL
                );
    if (!NT_SUCCESS(status)) {
        return status;
    }

    SlaveKeyBody = NULL;

    if (SlavePresent) {
        //
        // Open the slave object and add a reference to it.
        //
        try {
            OBJECT_ATTRIBUTES   CapturedAttributes;
            UNICODE_STRING      CapturedObjectName;

            if (PreviousMode == UserMode) {
                //
                // probe and capture the ObjectAttributes as we shall use it for opening the kernel handle
                //
                CapturedAttributes = ProbeAndReadStructure( SlaveObjects, OBJECT_ATTRIBUTES );

                ProbeAndReadUnicodeStringEx(&CapturedObjectName,CapturedAttributes.ObjectName);

                ProbeForRead(
                    CapturedObjectName.Buffer,
                    CapturedObjectName.Length,
                    sizeof(WCHAR)
                    );
                CapturedAttributes.ObjectName = &CapturedObjectName; 
            } else {
                CapturedAttributes = *SlaveObjects;
            }

            //
            // we open a private kernel mode handle just to take a reference on the object.
            //
            CapturedAttributes.Attributes |= OBJ_KERNEL_HANDLE;
            status = ObOpenObjectByName(&CapturedAttributes,
                                        CmpKeyObjectType,
                                        KernelMode,
                                        NULL,
                                        KEY_NOTIFY,
                                        NULL,
                                        &SlaveKeyHandle);
            if (NT_SUCCESS(status)) {
                status = ObReferenceObjectByHandle(SlaveKeyHandle,
                                                   KEY_NOTIFY,
                                                   CmpKeyObjectType,
                                                   KernelMode,
                                                   (PVOID *)&SlaveKeyBody,
                                                   NULL);
                ZwClose(SlaveKeyHandle);

            }

        } except (CmpExceptionFilter(GetExceptionInformation())) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtNotifyChangeMultipleKeys: code:%08lx\n", GetExceptionCode()));
            status = GetExceptionCode();
        }

        if (!NT_SUCCESS(status)) {
            ObDereferenceObject(MasterKeyBody);
            return status;
        }

        //
        // Reject calls setting with keys on the same hive as they could lead to obscure deadlocks
        //
        if ( MasterKeyBody->KeyControlBlock->KeyHive == SlaveKeyBody->KeyControlBlock->KeyHive ) {
            ObDereferenceObject(SlaveKeyBody);
            ObDereferenceObject(MasterKeyBody);
            return STATUS_INVALID_PARAMETER;
        }
    }


    //
    // Allocate master and slave post blocks, and init it.  Do NOT put it on the chain,
    // CmNotifyChangeKey will do that while holding a mutex.
    //
    // WARNING: PostBlocks MUST BE ALLOCATED from Pool, since back side
    //          of Notify will free it!
    //

    MasterPostBlock = CmpAllocateMasterPostBlock(PostType);
    if (MasterPostBlock == NULL) {
        if (SlavePresent) {
            ObDereferenceObject(SlaveKeyBody);
        }
        ObDereferenceObject(MasterKeyBody);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

#if DBG
    MasterPostBlock->TraceIntoDebugger = TRUE;
#endif

    if (SlavePresent) {
        SlavePostBlock = CmpAllocateSlavePostBlock(PostType,SlaveKeyBody,MasterPostBlock);
        if (SlavePostBlock == NULL) {
            ObDereferenceObject(SlaveKeyBody);
            ObDereferenceObject(MasterKeyBody);
            CmpFreePostBlock(MasterPostBlock);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

#if DBG
        SlavePostBlock->TraceIntoDebugger = TRUE;
#endif
    }

    if ((PostType == PostAsyncUser) ||
        (PostType == PostAsyncKernel)) {

        //
        // If event is present, reference it, save its address, and set
        // it to the not signaled state.
        //
        if (ARGUMENT_PRESENT(Event)) {
            status = ObReferenceObjectByHandle(
                            Event,
                            EVENT_MODIFY_STATE,
                            ExEventObjectType,
                            PreviousMode,
                            (PVOID *)(&UserEvent),
                            NULL
                            );
            if (!NT_SUCCESS(status)) {
                if (SlavePresent) {
                    CmpFreePostBlock(SlavePostBlock);
                    // SlaveKeyBody is dereferenced in CmpFreePostBlock(SlavePostBlock)
                }
                CmpFreePostBlock(MasterPostBlock);
                ObDereferenceObject(MasterKeyBody);
                return status;
            } else {
                KeClearEvent(UserEvent);
            }
        }

        if (PostType == PostAsyncUser) {
            KPROCESSOR_MODE     ApcMode;

            MasterPostBlock->u->AsyncUser.IoStatusBlock = IoStatusBlock;
            MasterPostBlock->u->AsyncUser.UserEvent = UserEvent;
            //
            // Initialize APC.  May or may not be a user apc, will always
            // be a kernel apc.
            //
            ApcMode = PreviousMode;
            if ( ApcRoutine == NULL ) {
                ApcRoutine = (PIO_APC_ROUTINE)CmpDummyApc;
                ApcMode = KernelMode;
            }
            KeInitializeApc(MasterPostBlock->u->AsyncUser.Apc,
                            KeGetCurrentThread(),
                            CurrentApcEnvironment,
                            (PKKERNEL_ROUTINE)CmpPostApc,
                            (PKRUNDOWN_ROUTINE)CmpPostApcRunDown,
                            (PKNORMAL_ROUTINE)ApcRoutine,
                            ApcMode,
                            ApcContext);
        } else {
            MasterPostBlock->u->AsyncKernel.Event = UserEvent;
            MasterPostBlock->u->AsyncKernel.WorkItem = (PWORK_QUEUE_ITEM)(ULONG_PTR)ApcRoutine;
            MasterPostBlock->u->AsyncKernel.QueueType = (WORK_QUEUE_TYPE)((ULONG_PTR)ApcContext);
        }
    }

    //
    // Exclusively lock the registry; We want nobody to mess with it while we are doing the
    // post/notify list manipulation; 
    //
    ConvKey2 = ConvKey1 = MasterKeyBody->KeyControlBlock->ConvKey;
    if ( SlavePresent ) {
        ConvKey2 = SlaveKeyBody->KeyControlBlock->ConvKey;
    }
    CmpLockRegistry();
    CmpLockTwoHashEntriesShared(ConvKey1,ConvKey2);

    if ( MasterKeyBody->KeyControlBlock->Delete ||
         (SlavePresent && SlaveKeyBody->KeyControlBlock->Delete) ) {
        CmpUnlockTwoHashEntries(ConvKey1,ConvKey2);
        CmpUnlockRegistry();
        if (UserEvent != NULL) {
            ObDereferenceObject(UserEvent);
        }

        if (SlavePresent) {
            CmpFreePostBlock(SlavePostBlock);
            // SlaveKeyBody is dereferenced in CmpFreePostBlock(SlavePostBlock)
        }
        CmpFreePostBlock(MasterPostBlock);
        ObDereferenceObject(MasterKeyBody);
        return STATUS_KEY_DELETED;
    }
    if ((!SlavePresent) || (MasterKeyBody->KeyControlBlock->KeyHive == SlaveKeyBody->KeyControlBlock->KeyHive)) {
        CmLockHive((PCMHIVE)(MasterKeyBody->KeyControlBlock->KeyHive));
        HiveLockState = 1;
    } else if (MasterKeyBody->KeyControlBlock->KeyHive < SlaveKeyBody->KeyControlBlock->KeyHive)  {
        CmLockHive((PCMHIVE)(MasterKeyBody->KeyControlBlock->KeyHive));
        CmLockHive((PCMHIVE)(SlaveKeyBody->KeyControlBlock->KeyHive));
        HiveLockState = 2;
        SlaveHive = (PCMHIVE)(SlaveKeyBody->KeyControlBlock->KeyHive);
    } else {
        CmLockHive((PCMHIVE)(SlaveKeyBody->KeyControlBlock->KeyHive));
        CmLockHive((PCMHIVE)(MasterKeyBody->KeyControlBlock->KeyHive));
        HiveLockState = 3;
        SlaveHive = (PCMHIVE)(SlaveKeyBody->KeyControlBlock->KeyHive);
    }

    LOCK_POST_LIST();

    //
    // Call worker for master
    //
    status = CmpNotifyChangeKey(
                MasterKeyBody,
                MasterPostBlock,
                CompletionFilter,
                WatchTree,
                Buffer,
                BufferSize,
                MasterPostBlock
                );
    if (!NT_SUCCESS(status)) {
        //
        // it didn't work, clean up for error path
        //
        UNLOCK_POST_LIST();
        if ( HiveLockState == 1 ) {
            CmUnlockHive((PCMHIVE)(MasterKeyBody->KeyControlBlock->KeyHive));
        } else if ( HiveLockState == 2 )  {
            CmUnlockHive(SlaveHive);
            CmUnlockHive((PCMHIVE)(MasterKeyBody->KeyControlBlock->KeyHive));
        } else if ( HiveLockState == 3 ) {
            CmUnlockHive((PCMHIVE)(MasterKeyBody->KeyControlBlock->KeyHive));
            CmUnlockHive(SlaveHive);
        }
        CmpUnlockTwoHashEntries(ConvKey1,ConvKey2);
        CmpUnlockRegistry();
        if (UserEvent != NULL) {
            ObDereferenceObject(UserEvent);
        }

        if (SlavePresent) {
            CmpFreePostBlock(SlavePostBlock);
            // SlaveKeyBody is dereferenced in CmpFreePostBlock(SlavePostBlock)
        }
        // MasterPostBlock if freed by CmpNotifyChangeKey !!!
        ObDereferenceObject(MasterKeyBody);
        return status;

    }

    ASSERT(status == STATUS_PENDING || status == STATUS_SUCCESS);

    if (SlavePresent) {
        if ( status == STATUS_SUCCESS ) {
            //
            // The notify has already been triggered for the master, there is no point to set one for the slave too
            // Clean up the mess we made for the slave object and signal as there is no slave present
            //
            CmpFreePostBlock(SlavePostBlock);
            SlavePresent = FALSE;
        } else {
            //
            // Call worker for slave
            //
            status = CmpNotifyChangeKey(
                        SlaveKeyBody,
                        SlavePostBlock,
                        CompletionFilter,
                        WatchTree,
                        Buffer,
                        BufferSize,
                        MasterPostBlock
                        );
            if (!NT_SUCCESS(status)) {
                //
                // if we are here, the slave key has been deleted in between or there was no memory available to allocate
                // a notify block for the slave key. We do the cleanup here since we already hold the registry lock
                // exclusively and we don't want to give a anybody else a chance to trigger the notification on master post
                // (otherwise we could end up freeing it twice). The master post block and the user event are cleaned later,
                // covering both single and multiple notifications cases
                //

                // Use Cmp variant to protect for multiple deletion of the same object
                CmpRemoveEntryList(&(MasterPostBlock->NotifyList));

                KeRaiseIrql(APC_LEVEL, &OldIrql);
                // Use Cmp variant to protect for multiple deletion of the same object
                CmpRemoveEntryList(&(MasterPostBlock->ThreadList));
                KeLowerIrql(OldIrql);
            }
        }
    }

    //
    // postblocks are now on various lists, so we can die without losing them
    //
    UNLOCK_POST_LIST();
    if ( HiveLockState == 1 ) {
        CmUnlockHive((PCMHIVE)(MasterKeyBody->KeyControlBlock->KeyHive));
    } else if ( HiveLockState == 2 )  {
        CmUnlockHive(SlaveHive);
        CmUnlockHive((PCMHIVE)(MasterKeyBody->KeyControlBlock->KeyHive));
    } else if ( HiveLockState == 3 ) {
        CmUnlockHive((PCMHIVE)(MasterKeyBody->KeyControlBlock->KeyHive));
        CmUnlockHive(SlaveHive);
    }
    CmpUnlockTwoHashEntries(ConvKey1,ConvKey2);
    CmpUnlockRegistry();

    if (NT_SUCCESS(status)) {
        //
        // success.  wait for event if sync.
        // do NOT deref User event, back side of notify will do that.
        //
        ASSERT(status == STATUS_PENDING || status == STATUS_SUCCESS);

        if (PostType == PostSynchronous) {
            WaitStatus = KeWaitForSingleObject(MasterPostBlock->u->Sync.SystemEvent,
                                               Executive,
                                               PreviousMode,
                                               TRUE,
                                               NULL);


            if ((WaitStatus==STATUS_ALERTED) || (WaitStatus == STATUS_USER_APC)) {

                //
                // The wait was aborted, clean up and return.
                //
                // 1. Remove the PostBlocks from the notify list.  This
                //    is normally done by the back end of notify, but
                //    we have to do it here since the back end is not
                //    involved.
                // 2. Delist and free the post blocks
                //
                CmpLockRegistry();

                //
                // Acquire exclusive access over the postlist(s)
                //
                LOCK_POST_LIST();

                KeRaiseIrql(APC_LEVEL, &OldIrql);
                if (SlavePresent) {
                    if (SlavePostBlock->NotifyList.Flink != NULL) {
                        // Use Cmp variant to protect for multiple deletion of the same object
                        CmpRemoveEntryList(&(SlavePostBlock->NotifyList));
                    }
                    // Use Cmp variant to protect for multiple deletion of the same object
                    CmpRemoveEntryList(&(SlavePostBlock->ThreadList));
                }

                if (MasterPostBlock->NotifyList.Flink != NULL) {
                    // Use Cmp variant to protect for multiple deletion of the same object
                    CmpRemoveEntryList(&(MasterPostBlock->NotifyList));
                }
                // Use Cmp variant to protect for multiple deletion of the same object
                CmpRemoveEntryList(&(MasterPostBlock->ThreadList));
                KeLowerIrql(OldIrql);

                UNLOCK_POST_LIST();
                CmpUnlockRegistry();

                if (SlavePresent) {
                    CmpFreePostBlock(SlavePostBlock);
                }
                CmpFreePostBlock(MasterPostBlock);

                status = WaitStatus;

            } else {
                //
                // The wait was satisfied, which means the back end has
                // already removed the postblock from the notify list.
                // We just have to delist and free the post block.
                //

                //
                // Acquire the registry lock exclusive to enter the post block rule prerequisites
                //
                CmpLockRegistry();

                //
                // Acquire exclusive access over the postlist(s)
                //
                LOCK_POST_LIST();

                KeRaiseIrql(APC_LEVEL, &OldIrql);
                if (SlavePresent) {
                    if (SlavePostBlock->NotifyList.Flink != NULL) {
                        // Use Cmp variant to protect for multiple deletion of the same object
                        CmpRemoveEntryList(&(SlavePostBlock->NotifyList));
                    }
                    // Use Cmp variant to protect for multiple deletion of the same object
                    CmpRemoveEntryList(&(SlavePostBlock->ThreadList));
                }

                if (MasterPostBlock->NotifyList.Flink != NULL) {
                    // Use Cmp variant to protect for multiple deletion of the same object
                    CmpRemoveEntryList(&(MasterPostBlock->NotifyList));
                }

                // Use Cmp variant to protect for multiple deletion of the same object
                CmpRemoveEntryList(&(MasterPostBlock->ThreadList));
                KeLowerIrql(OldIrql);

                UNLOCK_POST_LIST();
                CmpUnlockRegistry();

                status = MasterPostBlock->u->Sync.Status;

                try {
                    CmpSetIoStatus(IoStatusBlock, status, 0, UseIosb32);
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    status = GetExceptionCode();
                }

                if (SlavePresent) {
                    CmpFreePostBlock(SlavePostBlock);
                }
                CmpFreePostBlock(MasterPostBlock);
            }
        }

    } else {
        CmpFreePostBlock(MasterPostBlock);
        //
        // it didn't work, clean up for error path
        //
        if (UserEvent != NULL) {
            ObDereferenceObject(UserEvent);
        }
    }

    ObDereferenceObject(MasterKeyBody);
    //
    // Don't dereference SlaveKeyBody as back-end routine will do that
    //

    END_LOCK_CHECKPOINT;

    return status;
}

NTSTATUS
NtOpenKey(
    __out PHANDLE KeyHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes
    )
/*++

Routine Description:

    A registry key which already exists may be opened with NtOpenKey.

    Share access is computed from desired access.

Arguments:

    KeyHandle - Receives a  Handle which is used to access the
        specified key in the Registration Database.

    DesiredAccess - Specifies the access rights desired.

    ObjectAttributes - Specifies the attributes of the key being opened.
        Note that a key name must be specified.  If a Root Directory
        is specified, the name is relative to the root.  The name of
        the object must be within the name space allocated to the
        Registry, that is, all names beginning "\Registry".  RootHandle,
        if present, must be a handle to "\", or "\Registry", or a
        key under "\Registry".  If the specified key does not exist, or
        access requested is not allowed, the operation will fail.

        NOTE:   Object manager will capture and probe this argument.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    KPROCESSOR_MODE     mode;
    PCM_KEY_BODY        KeyBody;
    HANDLE              Handle =0;
    UNICODE_STRING      CapturedObjectName = {0};
    CM_PARSE_CONTEXT    ParseContext;

    // Start registry call tracing
    StartWmiCmTrace();

#if !defined(BUILD_WOW6432)
    DesiredAccess &= (~KEY_WOW64_RES); // filter out wow64 specific access
#endif


    CM_PAGED_CODE();

    if ( HvShutdownComplete == TRUE ) {
        //
        // it is now too late to do registry operations
        //
        return STATUS_TOO_LATE;
    }

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtOpenKey\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tDesiredAccess=%08lx ", DesiredAccess));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tObjectAttributes=%p\n", ObjectAttributes));

    mode = KeGetPreviousMode();

    try {

        if (mode == UserMode) {
            PUNICODE_STRING SafeObjectName;

            ProbeAndZeroHandle(KeyHandle);
            //
            // probe the ObjectAttributes as we shall use it for tracing
            //
            ProbeForReadSmallStructure( ObjectAttributes,
                                        sizeof(OBJECT_ATTRIBUTES),
                                        PROBE_ALIGNMENT(OBJECT_ATTRIBUTES) );
            SafeObjectName = ObjectAttributes->ObjectName;
            ProbeAndReadUnicodeStringEx(&CapturedObjectName,SafeObjectName);
            ProbeForRead(
                CapturedObjectName.Buffer,
                CapturedObjectName.Length,
                sizeof(WCHAR)
                );

        } else {
            CapturedObjectName = *(ObjectAttributes->ObjectName);
        }

        // hook it for WMI
        HookKcbFromHandleForWmiCmTrace(ObjectAttributes->RootDirectory);

    } except (CmpExceptionFilter(GetExceptionInformation())) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtOpenKey: code:%08lx\n", GetExceptionCode()));
        CapturedObjectName.Length = 0;
        CapturedObjectName.Buffer = NULL;
        status = GetExceptionCode();
    }

    if ( NT_SUCCESS(status) ) {
        //
        // this should not be inside the try/except as we captured the buffer
        //
        RtlZeroMemory(&ParseContext,sizeof(CM_PARSE_CONTEXT));
        ParseContext.CreateOperation = FALSE;

        status = ObOpenObjectByName(
                    ObjectAttributes,
                    CmpKeyObjectType,
                    mode,
                    NULL,
                    DesiredAccess,
                    (PVOID)&ParseContext,
                    &Handle
                    );
        //
        // protect against attacks to KeyHandle usermode pointer
        //
        try {
            if (status==STATUS_PREDEFINED_HANDLE) {
                status = ObReferenceObjectByHandle( Handle,
                                                    0,
                                                    CmpKeyObjectType,
                                                    KernelMode,
                                                    (PVOID *)(&KeyBody),
                                                    NULL);
                if (NT_SUCCESS(status)) {
                    *KeyHandle = (HANDLE)LongToHandle(KeyBody->Type);
                    ObDereferenceObject((PVOID)KeyBody);
                    //
                    // disallow attempts to return NULL handles
                    //
                    if ( *KeyHandle ) {
                        status = STATUS_SUCCESS;
                    } else {
                        status = STATUS_OBJECT_NAME_NOT_FOUND;
                    }
                }
                NtClose(Handle);
                
            } else if (NT_SUCCESS(status)) {
                *KeyHandle = Handle;
                // need to do this only on clean shutdown
                CmpAddKeyTracker(Handle,mode);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtOpenKey: code:%08lx\n", GetExceptionCode()));
            status = GetExceptionCode();
        }
    }

    // End registry call tracing
    EndWmiCmTrace(status,0,&CapturedObjectName,EVENT_TRACE_TYPE_REGOPEN);

    return  status;
}


NTSTATUS
NtQueryKey(
    __in HANDLE KeyHandle,
    __in KEY_INFORMATION_CLASS KeyInformationClass,
    __out_bcount_opt(Length) PVOID KeyInformation,
    __in ULONG Length,
    __out PULONG ResultLength
    )
/*++

Routine Description:

    Data about the class of a key, and the numbers and sizes of its
    children and value entries may be queried with NtQueryKey.

    If KeyValueInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

    NOTE: The returned lengths are guaranteed to be at least as
          long as the described values, but may be longer in
          some circumstances.

Arguments:

    KeyHandle - Handle of the key to query data for.  Must have been
        opened for KEY_QUERY_KEY access.

    KeyInformationClass - Specifies the type of information
        returned in Buffer.  One of the following types:

        KeyBasicInformation - return last write time, title index, and name.
            (See KEY_BASIC_INFORMATION)

        KeyNodeInformation - return last write time, title index, name, class.
            (See KEY_NODE_INFORMATION)

        KeyFullInformation - return all data except for name and security.
            (See KEY_FULL_INFORMATION)

    KeyInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyInformation in bytes.

    ResultLength - Number of bytes actually written into KeyInformation.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PCM_KEY_BODY   KeyBody;
    KPROCESSOR_MODE mode;

    // Start registry call tracing
    StartWmiCmTrace();

    CM_PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtQueryKey\n"));

    if ((KeyInformationClass != KeyBasicInformation) &&
        (KeyInformationClass != KeyNodeInformation)  &&
        (KeyInformationClass != KeyFullInformation)  &&
        (KeyInformationClass != KeyNameInformation) &&
        (KeyInformationClass != KeyCachedInformation) &&
        (KeyInformationClass != KeyFlagsInformation)
        )
    {
        // hook it for WMI
        HookKcbFromHandleForWmiCmTrace(KeyHandle);

        // End registry call tracing
        EndWmiCmTrace(STATUS_INVALID_PARAMETER,KeyInformationClass,NULL,EVENT_TRACE_TYPE_REGQUERY);

        return STATUS_INVALID_PARAMETER;
    }

    mode = KeGetPreviousMode();

    if ( KeyInformationClass == KeyNameInformation ) {
        //
        // special case: name information is available regardless of the access level
        // you have on the key  (provided that you have some ...)
        //

        OBJECT_HANDLE_INFORMATION HandleInfo;

        // reference with "no access required"
        status = ObReferenceObjectByHandle(
                KeyHandle,
                0,
                CmpKeyObjectType,
                mode,
                (PVOID *)(&KeyBody),
                &HandleInfo
                );
        if ( NT_SUCCESS(status) ) {
            if ( HandleInfo.GrantedAccess == 0 ) {
                //
                // no access is granted on the handle; bad luck!
                //
                ObDereferenceObject((PVOID)KeyBody);

                status = STATUS_ACCESS_DENIED;
            }
        }
    } else {
        status = ObReferenceObjectByHandle(
                KeyHandle,
                KEY_QUERY_VALUE,
                CmpKeyObjectType,
                mode,
                (PVOID *)(&KeyBody),
                NULL
                );
    }

    if (NT_SUCCESS(status)) {
        //
        // hook the kcb for WMI
        //
        HookKcbForWmiCmTrace(KeyBody);

        try {
            if (mode == UserMode) {
                ProbeForWrite(
                    KeyInformation,
                    Length,
                    CmpKeyInfoProbeAlingment(KeyInformationClass)
                    );
                ProbeForWriteUlong(ResultLength);
            }

			if (NT_SUCCESS(status)) {
                if ( CmAreCallbacksRegistered() ) {
                    REG_QUERY_KEY_INFORMATION QueryKeyInfo;
            
                    QueryKeyInfo.Object = KeyBody;
                    QueryKeyInfo.KeyInformationClass = KeyInformationClass;
                    QueryKeyInfo.KeyInformation = KeyInformation;
                    QueryKeyInfo.Length = Length;
                    QueryKeyInfo.ResultLength = ResultLength;

                    status = CmpCallCallBacks(RegNtPreQueryKey,&QueryKeyInfo,TRUE,RegNtPostQueryKey,KeyBody);
                }
    			if (NT_SUCCESS(status)) {
				    //
				    // CmQueryKey is writting to user-mode buffer
				    //
				    status = CmQueryKey(
							    KeyBody->KeyControlBlock,
							    KeyInformationClass,
							    KeyInformation,
							    Length,
							    ResultLength
							    );
                    // 
                    // just a notification; disregard the return status
                    //
                    CmPostCallbackNotification(RegNtPostQueryKey,KeyBody,status);
                }
			}
        } except (EXCEPTION_EXECUTE_HANDLER) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtQueryKey: code:%08lx\n", GetExceptionCode()));
            status = GetExceptionCode();
        }

        ObDereferenceObject((PVOID)KeyBody);
    }


    // End registry call tracing
    EndWmiCmTrace(status,KeyInformationClass,NULL,EVENT_TRACE_TYPE_REGQUERY);

    return status;
}


NTSTATUS
NtQueryValueKey(
    __in HANDLE KeyHandle,
    __in PUNICODE_STRING ValueName,
    __in KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    __out_bcount_opt(Length) PVOID KeyValueInformation,
    __in ULONG Length,
    __out PULONG ResultLength
    )
/*++

Routine Description:

    The ValueName, TitleIndex, Type, and Data for any one of a key's
    value entries may be queried with NtQueryValueKey.

    If KeyValueInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

Arguments:

    KeyHandle - Handle of the key whose value entries are to be
        enumerated.  Must be open for KEY_QUERY_VALUE access.

    ValueName  - The name of the value entry to return data for.

    KeyValueInformationClass - Specifies the type of information
        returned in KeyValueInformation.  One of the following types:

        KeyValueBasicInformation - return time of last write, title
            index, and name.  (See KEY_VALUE_BASIC_INFORMATION)

        KeyValueFullInformation - return time of last write, title
            index, name, class.  (See KEY_VALUE_FULL_INFORMATION)

    KeyValueInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyValueInformation in bytes.

    ResultLength - Number of bytes actually written into KeyValueInformation.

Return Value:

    NTSTATUS

    NOTE: The IopQueryRegsitryValues() routine in the IO system assumes
         STATUS_OBJECT_NAME_NOT_FOUND is returned if the value being queried
         for does not exist.

--*/
{
    NTSTATUS    status;
    PCM_KEY_BODY   KeyBody;
    KPROCESSOR_MODE mode;
    UNICODE_STRING LocalValueName = {0};

    // Start registry call tracing
    StartWmiCmTrace();

    CM_PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtQueryValueKey\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tKeyHandle=%08lx\n", KeyHandle));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tValueName='%wZ'\n", ValueName));

    if ((KeyValueInformationClass != KeyValueBasicInformation) &&
        (KeyValueInformationClass != KeyValueFullInformation)  &&
        (KeyValueInformationClass != KeyValueFullInformationAlign64)  &&
        (KeyValueInformationClass != KeyValuePartialInformationAlign64)  &&
        (KeyValueInformationClass != KeyValuePartialInformation))
    {
        // hook it for WMI
        HookKcbFromHandleForWmiCmTrace(KeyHandle);

        // End registry call tracing
        EndWmiCmTrace(STATUS_INVALID_PARAMETER,KeyValueInformationClass,NULL,EVENT_TRACE_TYPE_REGQUERYVALUE);

        return STATUS_INVALID_PARAMETER;
    }

    mode = KeGetPreviousMode();

    status = ObReferenceObjectByHandle(
                KeyHandle,
                KEY_QUERY_VALUE,
                CmpKeyObjectType,
                mode,
                (PVOID *)(&KeyBody),
                NULL
                );

    if (NT_SUCCESS(status)) {
        //
        // hook the kcb for WMI
        //
        HookKcbForWmiCmTrace(KeyBody);

        try {
            if (mode == UserMode) {
                ProbeAndReadUnicodeStringEx(&LocalValueName,ValueName);
                ProbeForRead(LocalValueName.Buffer,
                             LocalValueName.Length,
                             sizeof(WCHAR));

                //
                // We only probe the output buffer for Read to avoid touching
                // all the pages. Some people like to pass in gigantic buffers
                // Just In Case. The actual copy into the buffer is done under
                // an exception handler.
                //

                ProbeForRead(KeyValueInformation,
                             Length,
                             sizeof(ULONG));
                ProbeForWriteUlong(ResultLength);
            } else {
                LocalValueName = *ValueName;
            }
            //
            // Length needs to be even multiple of the size of UNICODE char
            //
            if ((LocalValueName.Length & (sizeof(WCHAR) - 1)) != 0) {
                //
                // adjust normalize length so wmi can log value name correctly.
                //
                status = STATUS_INVALID_PARAMETER;
            } else {
                //
                // do NOT allow trailing NULLs at the end of the ValueName.
                //
                while( (LocalValueName.Length > 0) && (LocalValueName.Buffer[LocalValueName.Length/sizeof(WCHAR)-1] == UNICODE_NULL) ) {
                    LocalValueName.Length -= sizeof(WCHAR);
                }
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtQueryValueKey: code:%08lx\n", GetExceptionCode()));
            LocalValueName.Length = 0;
            LocalValueName.Buffer = NULL;
            status = GetExceptionCode();
        }
        //
        // CmQueryValueKey is protected to user mode buffer exceptions
        // all other exceptions are cm internals and should result in a bugcheck
        //
        if (NT_SUCCESS(status)) {
            if ( CmAreCallbacksRegistered() ) {
                REG_QUERY_VALUE_KEY_INFORMATION QueryValueKeyInfo;
        
                QueryValueKeyInfo.Object = KeyBody;
                QueryValueKeyInfo.ValueName = &LocalValueName;
                QueryValueKeyInfo.KeyValueInformationClass = KeyValueInformationClass;
                QueryValueKeyInfo.KeyValueInformation = KeyValueInformation;
                QueryValueKeyInfo.Length = Length;
                QueryValueKeyInfo.ResultLength = ResultLength;

                status = CmpCallCallBacks(RegNtPreQueryValueKey,&QueryValueKeyInfo,TRUE,RegNtPostQueryValueKey,KeyBody);
            }
            if (NT_SUCCESS(status)) {
                BEGIN_LOCK_CHECKPOINT;
                status = CmQueryValueKey(KeyBody->KeyControlBlock,
                                         LocalValueName,
                                         KeyValueInformationClass,
                                         KeyValueInformation,
                                         Length,
                                         ResultLength);
                END_LOCK_CHECKPOINT;
                // 
                // just a notification; disregard the return status
                //
                CmPostCallbackNotification(RegNtPostQueryValueKey,KeyBody,status);

            }
        }

        ObDereferenceObject((PVOID)KeyBody);
    } 

    // End registry call tracing
    EndWmiCmTrace(status,KeyValueInformationClass,&LocalValueName,EVENT_TRACE_TYPE_REGQUERYVALUE);

    return status;
}


NTSTATUS
NtRestoreKey(
    __in HANDLE KeyHandle,
    __in HANDLE FileHandle,
    __in ULONG Flags
    )
/*++

Routine Description:

    A file in the format created by NtSaveKey may be loaded into
    the system's active registry with NtRestoreKey.  An entire subtree
    is created in the active registry as a result.  All of the
    data for the new sub-tree, including such things as security
    descriptors, will be read from the source file.  The data will
    not be interpreted in any way.

    This call (unlike NtLoadKey, see below) copies the data.  The
    system will NOT be using the source file after the call returns.

    If the flag REG_WHOLE_HIVE_VOLATILE is specified, a new hive
    can be created.  It will be a memory only copy.  The restore
    must be done to the root of a hive (e.g. \registry\user\<name>)

    If the flag is NOT set, then the target of the restore must
    be an existing hive.  The restore can be done to an arbitrary
    location within an existing hive.

    Caller must have SeRestorePrivilege privilege.

    If the flag REG_REFRESH_HIVE is set (must be only flag) then the
    the Hive will be restored to its state as of the last flush.

    The hive must be marked NOLAZY_FLUSH, and the caller must have
    TCB privilege, and the handle must point to the root of the hive.
    If the refresh fails, the hive will be corrupt, and the system
    will bugcheck.  Notifies are flushed.  The hive file will be resized,
    the log will not.  If there is any volatile space in the hive
    being refreshed, STATUS_UNSUCCESSFUL will be returned.  (It's much
    too obscure a failure to warrant a new error code.)

    If the flag REG_FORCE_RESTORE is set, the restore operation is done
    even if the KeyHandle has open subkeys by other applications

Arguments:

    KeyHandle - refers to the Key in the registry which is to be the
                root of the new tree read from the disk.  This key
                will be replaced.

    FileHandle - refers to file to restore from, must have read access.

    Flags   - If REG_WHOLE_HIVE_VOLATILE is set, then the copy will
              exist only in memory, and disappear when the machine
              is rebooted.  No hive file will be created on disk.

              Normally, a hive file will be created on disk.

Return Value:

    NTSTATUS


--*/
{
    NTSTATUS    status;
    PCM_KEY_BODY   KeyBody;
    KPROCESSOR_MODE mode;

    CM_PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtRestoreKey\n"));

    mode = KeGetPreviousMode();
    //
    // Check to see if the caller has the privilege to make this call.
    //
    if (!SeSinglePrivilegeCheck(SeRestorePrivilege, mode)) {
        return(STATUS_PRIVILEGE_NOT_HELD);
    }

    //
    // Force previous mode to be KernelMode so we can call filesystems
    //

    if (mode == UserMode) {
        return ZwRestoreKey(KeyHandle, FileHandle, Flags);
    } else {

        status = ObReferenceObjectByHandle(
                    KeyHandle,
                    0,
                    CmpKeyObjectType,
                    mode,
                    (PVOID *)(&KeyBody),
                    NULL
                    );

        if (NT_SUCCESS(status)) {


            if ( CmIsKcbReadOnly(KeyBody->KeyControlBlock) ) {
                //
                // key is protected
                //
                status = STATUS_ACCESS_DENIED;
            } else {
                BEGIN_LOCK_CHECKPOINT;
                status = CmRestoreKey(
                            KeyBody->KeyControlBlock,
                            FileHandle,
                            Flags
                            );
                END_LOCK_CHECKPOINT;
            }

            ObDereferenceObject((PVOID)KeyBody);
        }
    }


    return status;
}

NTSTATUS
NtSaveKey(
    __in HANDLE KeyHandle,
    __in HANDLE FileHandle
    )
/*++

Routine Description:

    A subtree of the active registry may be written to a file in a
    format suitable for use with NtRestoreKey.  All of the data in the
    subtree, including such things as security descriptors will be written
    out.

    Caller must have SeBackupPrivilege privilege.

    This function will always save the hive in HSYS_MINOR format. For saving
    in other format (latest - 1.5) NtSaveKeyEx  is provided.

Arguments:

    KeyHandle - refers to the Key in the registry which is the
                root of the tree to be written to disk.  The specified
                node will be included in the data written out.

    FileHandle - a file handle with write access to the target file
                 of interest.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PCM_KEY_BODY   KeyBody;
    KPROCESSOR_MODE mode;

    CM_PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtSaveKey\n"));

    mode = KeGetPreviousMode();

    //
    // Check to see if the caller has the privilege to make this call.
    //
    if (!SeSinglePrivilegeCheck(SeBackupPrivilege, mode)) {
        return(STATUS_PRIVILEGE_NOT_HELD);
    }

    //
    // Force previous mode to be KernelMode
    //

    if (mode == UserMode) {
        return ZwSaveKey(KeyHandle, FileHandle);
    } else {

        status = ObReferenceObjectByHandle(
                    KeyHandle,
                    0,
                    CmpKeyObjectType,
                    mode,
                    (PVOID *)(&KeyBody),
                    NULL
                    );

        if (NT_SUCCESS(status)) {

            BEGIN_LOCK_CHECKPOINT;
			status = CmSaveKey(
                        KeyBody->KeyControlBlock,
                        FileHandle,
                        HSYS_MINOR
                        );
            END_LOCK_CHECKPOINT;
            ObDereferenceObject((PVOID)KeyBody);
        }
    }


    return status;
}

NTSTATUS
NtSaveKeyEx(
    __in HANDLE   KeyHandle,
    __in HANDLE   FileHandle,
    __in ULONG    Format
    )
/*++

Routine Description:

    A subtree of the active registry may be written to a file in a
    format suitable for use with NtRestoreKey.  All of the data in the
    subtree, including such things as security descriptors will be written
    out.

    Caller must have SeBackupPrivilege privilege.

Arguments:

    KeyHandle - refers to the Key in the registry which is the
                root of the tree to be written to disk.  The specified
                node will be included in the data written out.

    FileHandle - a file handle with write access to the target file
                 of interest.

    Format - specifies whether in which the file will be saved
            Can be:
                HIVE_VERSION_STANDARD ==> 1.3
                HIVE_VERSION_LATEST   ==> 1.4

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    PCM_KEY_BODY    KeyBody;
    KPROCESSOR_MODE mode;
    ULONG           HiveVersion;

    CM_PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtSaveKeyEx\n"));

    mode = KeGetPreviousMode();

    //
    // Check to see if the caller has the privilege to make this call.
    //
    if (!SeSinglePrivilegeCheck(SeBackupPrivilege, mode)) {
        return(STATUS_PRIVILEGE_NOT_HELD);
    }
    //
    // param validation
    //
    if ( (Format != REG_STANDARD_FORMAT) && (Format != REG_LATEST_FORMAT) && (Format != REG_NO_COMPRESSION) ) {
	    return STATUS_INVALID_PARAMETER;
    }

    //
    // Force previous mode to be KernelMode
    //

    if (mode == UserMode) {
        return ZwSaveKeyEx(KeyHandle, FileHandle,Format);
    } else {

        status = ObReferenceObjectByHandle(
                    KeyHandle,
                    0,
                    CmpKeyObjectType,
                    mode,
                    (PVOID *)(&KeyBody),
                    NULL
                    );

        if (NT_SUCCESS(status)) {

            BEGIN_LOCK_CHECKPOINT;
            if ( Format == REG_NO_COMPRESSION ) {
                status = CmDumpKey(
                                    KeyBody->KeyControlBlock,
                                    FileHandle
                );
            } else {
                HiveVersion = HSYS_MINOR;
                if ( Format == REG_LATEST_FORMAT ) {
                    HiveVersion = HSYS_WHISTLER;
                }
                status = CmSaveKey(
                                    KeyBody->KeyControlBlock,
                                    FileHandle,
                                    HiveVersion
                );
            } 
            END_LOCK_CHECKPOINT;

            ObDereferenceObject((PVOID)KeyBody);
        }
    }

    return status;
}


NTSTATUS
NtSaveMergedKeys(
    __in HANDLE HighPrecedenceKeyHandle,
    __in HANDLE LowPrecedenceKeyHandle,
    __in HANDLE FileHandle
    )
/*++

Routine Description:

    Two subtrees of the registry can be merged. The resulting subtree may
    be written to a file in a format suitable for use with NtRestoreKey.
    All of the data in the subtree, including such things as security
    descriptors will be written out.

    Caller must have SeBackupPrivilege privilege.

Arguments:

    HighPrecedenceKeyHandle - refers to the key in the registry which is the
                root of the HighPrecedence tree. I.e., when a key is present in
                both trees headed by the two keys, the key underneath HighPrecedence
                tree will always prevail. The specified
                node will be included in the data written out.

    LowPrecedenceKeyHandle - refers to the key in the registry which is the
                root of the "second choice" tree. Keys from this trees get saved
                when there is no equivalent key in the tree headed by HighPrecedenceKey

    FileHandle - a file handle with write access to the target file
                 of interest.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PCM_KEY_BODY   HighKeyBody;
    PCM_KEY_BODY   LowKeyBody;
    KPROCESSOR_MODE mode;

    CM_PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtSaveMergedKeys\n"));

    mode = KeGetPreviousMode();

    //
    // Check to see if the caller has the privilege to make this call.
    //
    if (!SeSinglePrivilegeCheck(SeBackupPrivilege, mode)) {
        return(STATUS_PRIVILEGE_NOT_HELD);
    }

    //
    // Force previous mode to be KernelMode
    //

    if (mode == UserMode) {
        return ZwSaveMergedKeys(HighPrecedenceKeyHandle, LowPrecedenceKeyHandle, FileHandle);
    } else {

        status = ObReferenceObjectByHandle(
                    HighPrecedenceKeyHandle,
                    0,
                    CmpKeyObjectType,
                    mode,
                    (PVOID *)(&HighKeyBody),
                    NULL
                    );

        if (NT_SUCCESS(status)) {

            status = ObReferenceObjectByHandle(
                        LowPrecedenceKeyHandle,
                        0,
                        CmpKeyObjectType,
                        mode,
                        (PVOID *)(&LowKeyBody),
                        NULL
                        );

            if (NT_SUCCESS(status)) {

                BEGIN_LOCK_CHECKPOINT;
                status = CmSaveMergedKeys(
                            HighKeyBody->KeyControlBlock,
                            LowKeyBody->KeyControlBlock,
                            FileHandle
                            );
                END_LOCK_CHECKPOINT;

                ObDereferenceObject((PVOID)LowKeyBody);
            }

            ObDereferenceObject((PVOID)HighKeyBody);
        }

    }

    return status;
}

NTSTATUS
NtSetValueKey(
    __in HANDLE KeyHandle,
    __in PUNICODE_STRING ValueName,
    __in_opt ULONG TitleIndex,
    __in ULONG Type,
    __in_bcount_opt(DataSize) PVOID Data,
    __in ULONG DataSize
    )
/*++

Routine Description:

    A value entry may be created or replaced with NtSetValueKey.

    If a value entry with a Value ID (i.e. name) matching the
    one specified by ValueName exists, it is deleted and replaced
    with the one specified.  If no such value entry exists, a new
    one is created.  NULL is a legal Value ID.  While Value IDs must
    be unique within any given key, the same Value ID may appear
    in many different keys.

Arguments:

    KeyHandle - Handle of the key whose for which a value entry is
        to be set.  Must be opened for KEY_SET_VALUE access.

    ValueName - The unique (relative to the containing key) name
        of the value entry.  May be NULL.

    TitleIndex - Supplies the title index for ValueName.  The title
        index specifies the index of the localized alias for the ValueName.

    Type - The integer type number of the value entry.

    Data - Pointer to buffer with actual data for the value entry.

    DataSize - Size of Data buffer.


Return Value:

    NTSTATUS

--*/
{
    NTSTATUS    status;
    PCM_KEY_BODY   KeyBody;
    KPROCESSOR_MODE mode;
    UNICODE_STRING LocalValueName = {0};
    PWSTR CapturedName=NULL;

    // Start registry call tracing
    StartWmiCmTrace();

    CM_PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtSetValueKey\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tKeyHandle=%08lx\n", KeyHandle));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tValueName='%wZ'n", ValueName));

    mode = KeGetPreviousMode();

    status = ObReferenceObjectByHandle(
                KeyHandle,
                KEY_SET_VALUE,
                CmpKeyObjectType,
                mode,
                (PVOID *)(&KeyBody),
                NULL
                );

    if (NT_SUCCESS(status)) {
        //
        // hook the kcb for WMI
        //
        HookKcbForWmiCmTrace(KeyBody);

        if (mode == UserMode) {
            try {
                ProbeAndReadUnicodeStringEx(&LocalValueName,ValueName);
                ProbeForRead(Data,
                             DataSize,
                             sizeof(UCHAR));

                //
                // Capture the name buffer. Note that a zero-length name is valid, that is the
                // "Default" value.
                //
                if (LocalValueName.Length > 0) {
                    ProbeForRead(LocalValueName.Buffer,
                                 LocalValueName.Length,
                                 sizeof(WCHAR));
                    CapturedName = ExAllocatePoolWithQuotaTag(PagedPool, LocalValueName.Length, 'nVmC');
                    if (CapturedName == NULL) {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        goto Exit;
                    }
                    RtlCopyMemory(CapturedName, LocalValueName.Buffer, LocalValueName.Length);
                } else {
                    CapturedName = NULL;
                }
                LocalValueName.Buffer = CapturedName;

            } except (CmpExceptionFilter(GetExceptionInformation())) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtSetValueKey: code:%08lx [1]\n", GetExceptionCode()));
                //
                // send empty string to wmi trace
                //
                LocalValueName.Length = 0;
                LocalValueName.Buffer = NULL;
                status = GetExceptionCode();
                goto Exit;
            }
        } else {
            LocalValueName = *ValueName;
            CapturedName = NULL;
        }

        //
        // Sanity check for ValueName length
        //
        if ( (LocalValueName.Length > REG_MAX_KEY_VALUE_NAME_LENGTH) ||      // unreasonable name length
             ((LocalValueName.Length & (sizeof(WCHAR) - 1)) != 0)    ||      // length is not multiple of sizeof UNICODE char
             (DataSize > 0x80000000)) {                                      // unreasonable data size 
            status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
        //
        // do NOT allow trailing NULLs at the end of the ValueName
        //
        while( (LocalValueName.Length > 0) && (LocalValueName.Buffer[LocalValueName.Length/sizeof(WCHAR)-1] == UNICODE_NULL) ) {
            LocalValueName.Length -= sizeof(WCHAR);
        }

        if ( CmIsKcbReadOnly(KeyBody->KeyControlBlock) ) {
            //
            // key is protected
            //
            status = STATUS_ACCESS_DENIED;
        } else {
            if ( CmAreCallbacksRegistered() ) {
                REG_SET_VALUE_KEY_INFORMATION SetValueInfo;
        
                SetValueInfo.Object = KeyBody;
                SetValueInfo.ValueName = &LocalValueName;
                SetValueInfo.TitleIndex = TitleIndex;
                SetValueInfo.Type = Type;
                SetValueInfo.Data = Data;
                SetValueInfo.DataSize = DataSize;
                status = CmpCallCallBacks(RegNtPreSetValueKey,&SetValueInfo,TRUE,RegNtPostSetValueKey,KeyBody);
            }

            if ( NT_SUCCESS(status) ) {
                BEGIN_LOCK_CHECKPOINT;
                status = CmSetValueKey(KeyBody->KeyControlBlock,
                                       &LocalValueName,
                                       Type,
                                       Data,
                                       DataSize);
                END_LOCK_CHECKPOINT;
                // 
                // just a notification; disregard the return status
                //
                CmPostCallbackNotification(RegNtPostSetValueKey,KeyBody,status);
            }
        }

Exit:
        // End registry call tracing
        EndWmiCmTrace(status,0,&LocalValueName,EVENT_TRACE_TYPE_REGSETVALUE);

        if (CapturedName != NULL) {
            ExFreePool(CapturedName);
        }

        ObDereferenceObject((PVOID)KeyBody);
    }


    return status;
}

NTSTATUS
NtLoadKey(
    __in POBJECT_ATTRIBUTES TargetKey,
    __in POBJECT_ATTRIBUTES SourceFile
    )

/*++

Routine Description:

    A hive (file in the format created by NtSaveKey) may be linked
    into the active registry with this call.  UNLIKE NtRestoreKey,
    the file specified to NtLoadKey will become the actual backing
    store of part of the registry (that is, it will NOT be copied.)

    The file may have an associated .log file.

    If the hive file is marked as needing a .log file, and one is
    not present, the call will fail.

    The name specified by SourceFile must be such that ".log" can
    be appended to it to generate the name of the log file.  Thus,
    on FAT file systems, the hive file may not have an extension.

    Caller must have SeRestorePrivilege privilege.

    This call is used by logon to make the user's profile available
    in the registry.  It is not intended for use doing backup,
    restore, etc.  Use NtRestoreKey for that.

Arguments:

    TargetKey - specifies the path to a key to link the hive to.
                path must be of the form "\registry\user\<username>"

    SourceFile - specifies a file.  while file could be remote,
                that is strongly discouraged.

Return Value:

    NTSTATUS

--*/

{
    return(NtLoadKeyEx(TargetKey, SourceFile, 0, NULL));
}

NTSTATUS
NtLoadKey2(
    __in POBJECT_ATTRIBUTES   TargetKey,
    __in POBJECT_ATTRIBUTES   SourceFile,
    __in ULONG                Flags
    )

/*++

Routine Description:

    A hive (file in the format created by NtSaveKey) may be linked
    into the active registry with this call.  UNLIKE NtRestoreKey,
    the file specified to NtLoadKey will become the actual backing
    store of part of the registry (that is, it will NOT be copied.)

    The file may have an associated .log file.

    If the hive file is marked as needing a .log file, and one is
    not present, the call will fail.

    The name specified by SourceFile must be such that ".log" can
    be appended to it to generate the name of the log file.  Thus,
    on FAT file systems, the hive file may not have an extension.

    Caller must have SeRestorePrivilege privilege.

    This call is used by logon to make the user's profile available
    in the registry.  It is not intended for use doing backup,
    restore, etc.  Use NtRestoreKey for that.

Arguments:

    TargetKey - specifies the path to a key to link the hive to.
                path must be of the form "\registry\user\<username>"

    SourceFile - specifies a file.  while file could be remote,
                that is strongly discouraged.

    Flags - specifies any flags that should be used for the load operation.
            The only valid flag is REG_NO_LAZY_FLUSH.


Return Value:

    NTSTATUS

--*/

{
    return(NtLoadKeyEx(TargetKey, SourceFile, Flags, NULL));
}

NTSTATUS
NtLoadKeyEx(
    __in POBJECT_ATTRIBUTES   TargetKey,
    __in POBJECT_ATTRIBUTES   SourceFile,
    __in ULONG                Flags,
    __in_opt HANDLE         TrustClassKey 
    )

/*++

Routine Description:

    A hive (file in the format created by NtSaveKey) may be linked
    into the active registry with this call.  UNLIKE NtRestoreKey,
    the file specified to NtLoadKey will become the actual backing
    store of part of the registry (that is, it will NOT be copied.)

    The file may have an associated .log file.

    If the hive file is marked as needing a .log file, and one is
    not present, the call will fail.

    The name specified by SourceFile must be such that ".log" can
    be appended to it to generate the name of the log file.  Thus,
    on FAT file systems, the hive file may not have an extension.

    Caller must have SeRestorePrivilege privilege.

    This call is used by logon to make the user's profile available
    in the registry.  It is not intended for use doing backup,
    restore, etc.  Use NtRestoreKey for that.

    This API allows for establiching 'classes of trust' within the 
    UNTRUSTED name space.

Arguments:

    TargetKey - specifies the path to a key to link the hive to.
                path must be of the form "\registry\user\<username>"

    SourceFile - specifies a file.  while file could be remote,
                that is strongly discouraged.

    Flags - specifies any flags that should be used for the load operation.
            The only valid flag is REG_NO_LAZY_FLUSH.

    TrustClassKey - new hives that is loaded will be put in the same trust 
            class with the hive represented by TrustClassKey 

Return Value:

    NTSTATUS

--*/
{
    OBJECT_ATTRIBUTES   File;
    OBJECT_ATTRIBUTES   Key;
    KPROCESSOR_MODE     PreviousMode;
    UNICODE_STRING      CapturedKeyName;
    UNICODE_STRING      FileName;
    USHORT              Maximum;
    NTSTATUS            Status;
    PWSTR               KeyBuffer;
    PCM_KEY_BODY        KeyBody = NULL;

    CM_PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtLoadKey\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tTargetKey = %p\n", TargetKey));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tSourceFile= %p\n", SourceFile));
    //
    // Check for illegal flags
    //
    if (Flags & ~REG_NO_LAZY_FLUSH) {
        return(STATUS_INVALID_PARAMETER);
    }

    FileName.Buffer = NULL;
    KeyBuffer = NULL;

    //
    // The way we do this is a cronk, but at least it's the same cronk we
    // use for all the registry I/O.
    //
    // The file needs to be opened in the worker thread's context, since
    // the resulting handle must be valid when we poke him to go read/write
    // from.  So we just capture the object attributes for the hive file
    // here, then poke the worker thread to go do the rest of the work.
    //

    PreviousMode = KeGetPreviousMode();

    //
    // Check to see if the caller has the privilege to make this call.
    //
    if (!SeSinglePrivilegeCheck(SeRestorePrivilege, PreviousMode)) {
        return(STATUS_PRIVILEGE_NOT_HELD);
    }

    //
    // CmpNameFromAttributes will probe and capture as necessary.
    //
    KeEnterCriticalRegion();
    Status = CmpNameFromAttributes(SourceFile,
                                   PreviousMode,
                                   &FileName);
    if (!NT_SUCCESS(Status)) {
        KeLeaveCriticalRegion();
        return(Status);
    }

    try {

        //
        // Probe the object attributes if necessary.
        //
        if (PreviousMode == UserMode) {
            ProbeForReadSmallStructure(TargetKey,
                                       sizeof(OBJECT_ATTRIBUTES),
                                       sizeof(ULONG));
        }

        //
        // Capture the object attributes.
        //
        Key  = *TargetKey;

        //
        // Capture the object name.
        //

        if (PreviousMode == UserMode) {
            ProbeAndReadUnicodeStringEx(&CapturedKeyName,Key.ObjectName);
            ProbeForRead(CapturedKeyName.Buffer,
                         CapturedKeyName.Length,
                         sizeof(WCHAR));
        } else {
            CapturedKeyName = *(TargetKey->ObjectName);
        }

        File.ObjectName = &FileName;
        File.SecurityDescriptor = NULL;

        Maximum = (USHORT)(CapturedKeyName.Length);

        KeyBuffer = ALLOCATE_WITH_QUOTA(PagedPool, Maximum, CM_POOL_TAG);

        if (KeyBuffer == NULL) {
            ExFreePool(FileName.Buffer);
            KeLeaveCriticalRegion();
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlCopyMemory(KeyBuffer, CapturedKeyName.Buffer, Maximum);
        CapturedKeyName.Length = Maximum;
        CapturedKeyName.Buffer = KeyBuffer;

        Key.ObjectName = &CapturedKeyName;
        Key.SecurityDescriptor = NULL;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtLoadKey: code:%08lx\n", GetExceptionCode()));
        Status = GetExceptionCode();

    }
    if ( ARGUMENT_PRESENT(TrustClassKey) && NT_SUCCESS(Status) ) {
        Status = ObReferenceObjectByHandle( TrustClassKey,
                                            0,
                                            CmpKeyObjectType,
                                            PreviousMode,
                                            (PVOID *)(&KeyBody),
                                            NULL);
    }

    //
    // Clean up if there was an exception while probing and copying user data
    //
    if (!NT_SUCCESS(Status)) {
        if ( KeyBody != NULL ) {
            ObDereferenceObject((PVOID)KeyBody);
        }
        if (FileName.Buffer != NULL) {
            ExFreePool(FileName.Buffer);
        }
        if (KeyBuffer != NULL) {
            ExFreePool(KeyBuffer);
        }
        KeLeaveCriticalRegion();
        return(Status);
    }

    BEGIN_LOCK_CHECKPOINT;
    Status = CmLoadKey(&Key, &File, Flags,KeyBody);
    END_LOCK_CHECKPOINT;

    if ( KeyBody != NULL ) {
        ObDereferenceObject((PVOID)KeyBody);
    }
    ExFreePool(FileName.Buffer);
    ExFreePool(KeyBuffer);

    KeLeaveCriticalRegion();

    return(Status);
}

NTSTATUS
NtUnloadKey(
    __in POBJECT_ATTRIBUTES TargetKey
    )
/*++

Routine Description:

    Drop a subtree (hive) out of the registry.

    Will fail if applied to anything other than the root of a hive.

    Cannot be applied to core system hives (HARDWARE, SYSTEM, etc.)

    Can be applied to user hives loaded via NtRestoreKey or NtLoadKey.

    If there are handles open to the hive being dropped, this call
    will fail.  Terminate relevant processes so that handles are
    closed.

    This call will flush the hive being dropped.

    Caller must have SeRestorePrivilege privilege.

Arguments:

    TargetKey - specifies the path to a key to link the hive to.
                path must be of the form "\registry\user\<username>"

Return Value:

    NTSTATUS

--*/
{
    return NtUnloadKey2(TargetKey, 0);
}

NTSTATUS
NtUnloadKey2(
    __in POBJECT_ATTRIBUTES   TargetKey,
    __in ULONG                Flags
    )
/*++

Routine Description:

    Same as NtUnloadKey. Does force unload when needed

Arguments:

    TargetKey - specifies the path to a key to link the hive to.
                path must be of the form "\registry\user\<username>"

    Flags - controls force unload. If 0, the same as NtUnloadKey.
            if REG_FORCE_UNLOAD the hive is unloaded even if there are open
            subkeys inside of it.

            Anything different than REG_FORCE_UNLOAD is ignored

Return Value:

    NTSTATUS

--*/
{
    HANDLE              KeyHandle;
    NTSTATUS            Status;
    PCM_KEY_BODY        KeyBody = NULL;
    KPROCESSOR_MODE     PreviousMode;
    CM_PARSE_CONTEXT    ParseContext;
    OBJECT_ATTRIBUTES   CapturedAttributes;
    UNICODE_STRING      CapturedObjectName;

    CM_PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtUnloadKey\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tTargetKey ='%p'\n", TargetKey));

    PreviousMode = KeGetPreviousMode();

    if (!SeSinglePrivilegeCheck(SeRestorePrivilege, PreviousMode)) {
        return(STATUS_PRIVILEGE_NOT_HELD);
    }

    ParseContext.TitleIndex = 0;
    ParseContext.Class.Length = 0;
    ParseContext.Class.Buffer = NULL;
    ParseContext.CreateOptions = REG_OPTION_BACKUP_RESTORE;
    ParseContext.Disposition = 0L;
    ParseContext.CreateLink = FALSE;
    ParseContext.PredefinedHandle = NULL;
    ParseContext.CreateOperation = TRUE;
    ParseContext.OriginatingPoint = NULL;

    try {
        if (PreviousMode == UserMode) {
            //
            // probe and capture the ObjectAttributes as we shall use it for opening the kernel handle
            //
            CapturedAttributes = ProbeAndReadStructure( TargetKey, OBJECT_ATTRIBUTES );

            ProbeAndReadUnicodeStringEx(&CapturedObjectName,CapturedAttributes.ObjectName);

            ProbeForRead(
                CapturedObjectName.Buffer,
                CapturedObjectName.Length,
                sizeof(WCHAR)
                );
            CapturedAttributes.ObjectName = &CapturedObjectName; 
        } else {
            CapturedAttributes = *TargetKey;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtUnloadKey: code:%08lx\n", GetExceptionCode()));
        return GetExceptionCode();
    }
    //
    // we open a private kernel mode handle just to take a reference on the object.
    //
    CapturedAttributes.Attributes |= OBJ_KERNEL_HANDLE;

    Status = ObOpenObjectByName(&CapturedAttributes,
                                CmpKeyObjectType,
                                KernelMode,
                                NULL,
                                KEY_WRITE,
                                &ParseContext,
                                &KeyHandle);
    if (NT_SUCCESS(Status)) {
        Status = ObReferenceObjectByHandle(KeyHandle,
                                           KEY_WRITE,
                                           CmpKeyObjectType,
                                           KernelMode,
                                           (PVOID *)&KeyBody,
                                           NULL);
        ZwClose(KeyHandle);
    }

    if (NT_SUCCESS(Status)) {
        ULONG   ConvKey1 = 0;
        ULONG   ConvKey2 = 0;
        ULONG   UnloadControlFlags = 0;

        BEGIN_LOCK_CHECKPOINT;
        if ( Flags == REG_FORCE_UNLOAD ) {
            CmpLockRegistryExclusive();

            UnloadControlFlags |= CM_UNLOAD_REG_LOCKED_EX;
        } else {
            //
            // we only need it shared for the regular (not force unload) path
            // plus this guys and his parent
            //
            // only one hive unloading at a time (so we don't race with a load on the same hive)
            //
            //
            CmpLockRegistry();
            LOCK_HIVE_LOAD();

            ConvKey1 = ConvKey2 = KeyBody->KeyControlBlock->ConvKey;
            if ( KeyBody->KeyControlBlock->ParentKcb != NULL ) {
                ConvKey2 = KeyBody->KeyControlBlock->ParentKcb->ConvKey;
            }
            CmpLockTwoHashEntriesExclusive(ConvKey1,ConvKey2);
            UnloadControlFlags |= CM_UNLOAD_KCB_LOCKED;
        }

        if ( KeyBody->KeyControlBlock->Delete ) {
            Status = STATUS_KEY_DELETED;
        } else {

            if ( !IsHiveFrozen((PCMHIVE)(KeyBody->KeyControlBlock->KeyHive)) ) {
                //
                // Report the notify here, because the KCB won't be around later.
                //
                CmpReportNotify(KeyBody->KeyControlBlock,
                                KeyBody->KeyControlBlock->KeyHive,
                                KeyBody->KeyControlBlock->KeyCell,
                                REG_NOTIFY_CHANGE_LAST_SET);

                //
                // post any waiting notifies
                //
                CmpFlushNotify(KeyBody,(Flags == REG_FORCE_UNLOAD)?TRUE:FALSE);

                if ( CmIsKcbReadOnly(KeyBody->KeyControlBlock) ) {
                    //
                    // key is protected
                    //
                    Status = STATUS_ACCESS_DENIED;
                } else {
                    BOOLEAN TryAgain = (Flags != REG_FORCE_UNLOAD)?TRUE:FALSE;
TryExclusive:
                    Status = CmUnloadKey(KeyBody->KeyControlBlock, Flags,UnloadControlFlags);
                    if ((Status == STATUS_CANNOT_DELETE) && TryAgain) {
                        //
                        // ok; it didn't work; this might be because we couldn't safely lock all hash entries
                        // we'll have to take the perf hit and try with exclusive lock
                        //
                        ASSERT(Flags != REG_FORCE_UNLOAD);
                        CmpUnlockTwoHashEntries(ConvKey1,ConvKey2); 
                        UNLOCK_HIVE_LOAD();
                        CmpUnlockRegistry();
                        CmpLockRegistryExclusive();
                        LOCK_HIVE_LOAD();
                        CmpLockTwoHashEntriesExclusive(ConvKey1,ConvKey2);// just for completness
                        TryAgain = FALSE;
                        UnloadControlFlags |= CM_UNLOAD_REG_LOCKED_EX;
                        if ( (!(KeyBody->KeyControlBlock->Delete)) &&
                            (!IsHiveFrozen((PCMHIVE)(KeyBody->KeyControlBlock->KeyHive))) &&
                            (!CmIsKcbReadOnly(KeyBody->KeyControlBlock)) ) {
                            goto TryExclusive;
                        }
                        //
                        // let it fall through
                        //
                    }
                }
            } else {
                //
                // don't let them hurt themselves by calling it twice
                //
                Status = STATUS_TOO_LATE;
            }
        }

        // only if not success, otherwise CmUnloadKey already took care of it.
        if ( Status != STATUS_SUCCESS ) {
            if (Flags != REG_FORCE_UNLOAD) {
                CmpUnlockTwoHashEntries(ConvKey1,ConvKey2);
                UNLOCK_HIVE_LOAD();
            } 
            CmpUnlockRegistry();
        }
        END_LOCK_CHECKPOINT;

        ObDereferenceObject((PVOID)KeyBody);
    }

    return(Status);
}

NTSTATUS
NtUnloadKeyEx(
    __in POBJECT_ATTRIBUTES TargetKey,
    __in_opt HANDLE Event
    )
/*++

Routine Description:

    Drop a subtree (hive) out of the registry.

    Will fail if applied to anything other than the root of a hive.

    Cannot be applied to core system hives (HARDWARE, SYSTEM, etc.)

    Can be applied to user hives loaded via NtRestoreKey or NtLoadKey.

    If there are handles open to the hive being dropped, the hive will be
    frozen and all calls to CmDeleteKey will be watched as when the last handle
    inside this hive is closed, the hive will be unloaded.

    Caller must have SeRestorePrivilege privilege.

Arguments:

    TargetKey - specifies the path to a key to link the hive to.
                path must be of the form "\registry\user\<username>"

Return Value:

    STATUS_SUCCESS - hive successfully unloaded - no late-unloading needed

    STATUS_PENDING - hive has been frozen and the event (if any) will be signaled
                     when the hive unloads

    <other> - an error occured, no action

--*/
{
    HANDLE              KeyHandle;
    NTSTATUS            Status;
    PCM_KEY_BODY        KeyBody = NULL;
    KPROCESSOR_MODE     PreviousMode;
    CM_PARSE_CONTEXT    ParseContext;
    PKEVENT             UserEvent = NULL;
    OBJECT_ATTRIBUTES   CapturedAttributes;
    UNICODE_STRING      CapturedObjectName;

    CM_PAGED_CODE();


    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtUnloadKeyEx\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tTargetKey = %p \tEvent = %p\n", TargetKey,Event));

    PreviousMode = KeGetPreviousMode();

    if (!SeSinglePrivilegeCheck(SeRestorePrivilege, PreviousMode)) {
        return(STATUS_PRIVILEGE_NOT_HELD);
    }

    ParseContext.TitleIndex = 0;
    ParseContext.Class.Length = 0;
    ParseContext.Class.Buffer = NULL;
    ParseContext.CreateOptions = REG_OPTION_BACKUP_RESTORE;
    ParseContext.Disposition = 0L;
    ParseContext.CreateLink = FALSE;
    ParseContext.PredefinedHandle = NULL;
    ParseContext.CreateOperation = TRUE;
    ParseContext.OriginatingPoint = NULL;

     try {
        if (PreviousMode == UserMode) {
            //
            // probe and capture the ObjectAttributes as we shall use it for opening the kernel handle
            //
            CapturedAttributes = ProbeAndReadStructure( TargetKey, OBJECT_ATTRIBUTES );

            ProbeAndReadUnicodeStringEx(&CapturedObjectName,CapturedAttributes.ObjectName);

            ProbeForRead(
                CapturedObjectName.Buffer,
                CapturedObjectName.Length,
                sizeof(WCHAR)
                );
            CapturedAttributes.ObjectName = &CapturedObjectName; 
        } else {
            CapturedAttributes = *TargetKey;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtUnloadKey: code:%08lx\n", GetExceptionCode()));
        return GetExceptionCode();
    }
    //
    // we open a private kernel mode handle just to take a reference on the object.
    //
    CapturedAttributes.Attributes |= OBJ_KERNEL_HANDLE;

    Status = ObOpenObjectByName(&CapturedAttributes,
                                CmpKeyObjectType,
                                KernelMode,
                                NULL,
                                KEY_WRITE,
                                &ParseContext,
                                &KeyHandle);
    if (NT_SUCCESS(Status)) {
        Status = ObReferenceObjectByHandle(KeyHandle,
                                           KEY_WRITE,
                                           CmpKeyObjectType,
                                           KernelMode,
                                           (PVOID *)&KeyBody,
                                           NULL);
        ZwClose(KeyHandle);

        if (ARGUMENT_PRESENT(Event)) {
            Status = ObReferenceObjectByHandle(
                            Event,
                            EVENT_MODIFY_STATE,
                            ExEventObjectType,
                            PreviousMode,
                            (PVOID *)(&UserEvent),
                            NULL
                            );
            if (NT_SUCCESS(Status)) {
                KeClearEvent(UserEvent);
            }
            else {
                ObDereferenceObject((PVOID)KeyBody);
            }
        }
    }

    if (NT_SUCCESS(Status)) {
        BEGIN_LOCK_CHECKPOINT;
        CmpLockRegistryExclusive();

        if ( KeyBody->KeyControlBlock->Delete ) {
            Status = STATUS_KEY_DELETED;
        } else {

            //
            // Report the notify here, because the KCB won't be around later.
            //

            CmpReportNotify(KeyBody->KeyControlBlock,
                            KeyBody->KeyControlBlock->KeyHive,
                            KeyBody->KeyControlBlock->KeyCell,
                            REG_NOTIFY_CHANGE_LAST_SET);

            //
            // post any waiting notifies
            //
            CmpFlushNotify(KeyBody,TRUE);

            if ( CmIsKcbReadOnly(KeyBody->KeyControlBlock) ) {
                //
                // key is protected
                //
                Status = STATUS_ACCESS_DENIED;
            } else {
                Status = CmUnloadKeyEx(KeyBody->KeyControlBlock,UserEvent);
            }
        }

        if ( Status != STATUS_SUCCESS ) {
            CmpUnlockRegistry();
        }

        END_LOCK_CHECKPOINT;

        //
        // if hive was successfully unloaded (or something wrong happened,
        // we need to deref user event otherwise the back-end routine will deref it after signaling
        //
        if ( (Status != STATUS_PENDING) && (UserEvent != NULL) ) {
            ObDereferenceObject(UserEvent);
        }

        ObDereferenceObject((PVOID)KeyBody);
    }

    return(Status);
}

NTSTATUS
NtSetInformationKey(
    __in HANDLE KeyHandle,
    __in KEY_SET_INFORMATION_CLASS KeySetInformationClass,
    __in_bcount(KeySetInformationLength) PVOID KeySetInformation,
    __in ULONG KeySetInformationLength
    )
{
    NTSTATUS        status = STATUS_UNSUCCESSFUL;
    PCM_KEY_BODY    KeyBody;
    KPROCESSOR_MODE mode;
    LARGE_INTEGER   LocalWriteTime;
    ULONG           LocalUserFlags = 0;

    // Start registry call tracing
    StartWmiCmTrace();

    CM_PAGED_CODE();

    BEGIN_LOCK_CHECKPOINT;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtSetInformationKey\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tKeyHandle=%08lx\n", KeyHandle));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tInfoClass=%08x\n", KeySetInformationClass));

    mode = KeGetPreviousMode();

    //
    // check arg validity and probe
    //
    switch (KeySetInformationClass) {
    case KeyWriteTimeInformation:
        if (KeySetInformationLength != sizeof( KEY_WRITE_TIME_INFORMATION )) {
            // hook it for WMI
            HookKcbFromHandleForWmiCmTrace(KeyHandle);

            // End registry call tracing
            EndWmiCmTrace(STATUS_INFO_LENGTH_MISMATCH,0,NULL,EVENT_TRACE_TYPE_REGSETINFORMATION);

            return STATUS_INFO_LENGTH_MISMATCH;
        }
        try {
            if (mode == UserMode) {
                LocalWriteTime = ProbeAndReadLargeInteger(
                    (PLARGE_INTEGER) KeySetInformation );
            } else {
                LocalWriteTime = *(PLARGE_INTEGER)KeySetInformation;
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtSetInformationKey: code:%08lx\n", GetExceptionCode()));
            return GetExceptionCode();
        }
        break;

    case KeyUserFlagsInformation:
        if (KeySetInformationLength != sizeof( KEY_USER_FLAGS_INFORMATION )) {

            // hook it for WMI
            HookKcbFromHandleForWmiCmTrace(KeyHandle);

            // End registry call tracing
            EndWmiCmTrace(STATUS_INFO_LENGTH_MISMATCH,0,NULL,EVENT_TRACE_TYPE_REGSETINFORMATION);

            return STATUS_INFO_LENGTH_MISMATCH;
        }
        try {

            if (mode == UserMode) {
                LocalUserFlags = ProbeAndReadUlong( (PULONG) KeySetInformation );
            } else {
                LocalUserFlags = *(PULONG)KeySetInformation;
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtSetInformationKey: code:%08lx\n", GetExceptionCode()));
            return GetExceptionCode();
        }
        break;

    default:

        // hook it for WMI
        HookKcbFromHandleForWmiCmTrace(KeyHandle);
        // End registry call tracing
        EndWmiCmTrace(STATUS_INVALID_INFO_CLASS,0,NULL,EVENT_TRACE_TYPE_REGSETINFORMATION);

        return STATUS_INVALID_INFO_CLASS;
    }

    status = ObReferenceObjectByHandle(
                KeyHandle,
                KEY_SET_VALUE,
                CmpKeyObjectType,
                mode,
                (PVOID *)(&KeyBody),
                NULL
                );

    if (NT_SUCCESS(status)) {
        //
        // hook the kcb for WMI
        //
        HookKcbForWmiCmTrace(KeyBody);

        if ( CmAreCallbacksRegistered() ) {
            REG_SET_INFORMATION_KEY_INFORMATION SetInfo;
        
            SetInfo.Object = KeyBody;
            SetInfo.KeySetInformationClass = KeySetInformationClass;
            SetInfo.KeySetInformation = KeySetInformation;
            SetInfo.KeySetInformationLength = KeySetInformationLength;
            status = CmpCallCallBacks(RegNtPreSetInformationKey,&SetInfo,TRUE,RegNtPostSetInformationKey,KeyBody);
            if ( !NT_SUCCESS(status) ) {
                return status;
            }
        }

        if ( CmIsKcbReadOnly(KeyBody->KeyControlBlock) ) {
            //
            // key is protected
            //
            status = STATUS_ACCESS_DENIED;
        } else {
            switch (KeySetInformationClass) {
                case KeyWriteTimeInformation:
                    if (NT_SUCCESS(status)) {
                        //
                        // not in try ... except! we want to bugcheck here if something wrong in the registry
                        //
                        status = CmSetLastWriteTimeKey(
                                    KeyBody->KeyControlBlock,
                                    &LocalWriteTime
                                    );
                    }

                    break;

                case KeyUserFlagsInformation:
                    if (NT_SUCCESS(status)) {
                        //
                        // not in try ... except! we want to bugcheck here if something wrong in the registry
                        //
                        status = CmSetKeyUserFlags(
                                    KeyBody->KeyControlBlock,
                                    LocalUserFlags
                                    );
                    }

                    break;

                default:
                    // we shouldn't go through here
                    ASSERT( FALSE );
            }
        }

        // 
        // just a notification; disregard the return status
        //
        CmPostCallbackNotification(RegNtPostSetInformationKey,KeyBody,status);

        ObDereferenceObject((PVOID)KeyBody);
    }

    END_LOCK_CHECKPOINT;

    // End registry call tracing
    EndWmiCmTrace(status,0,NULL,EVENT_TRACE_TYPE_REGSETINFORMATION);

    return status;
}


NTSTATUS
NtReplaceKey(
    __in POBJECT_ATTRIBUTES NewFile,
    __in HANDLE             TargetHandle,
    __in POBJECT_ATTRIBUTES OldFile
    )
/*++

Routine Description:

    A hive file may be "replaced" under a running system, such
    that the new file will be the one actually used at next
    boot, with this call.

    This routine will:

        Open newfile, and verify that it is a valid Hive file.

        Rename the Hive file backing TargetHandle to OldFile.
        All handles will remain open, and the system will continue
        to use the file until rebooted.

        Rename newfile to match the name of the hive file
        backing TargetHandle.

    .log and .alt files are ignored

    The system must be rebooted for any useful effect to be seen.

    Caller must have SeRestorePrivilege.

Arguments:

    NewFile - specifies the new file to use.  must not be just
              a handle, since NtReplaceKey will insist on
              opening the file for exclusive access (which it
              will hold until the system is rebooted.)

    TargetHandle - handle to a registry hive root

    OldFile - name of file to apply to current hive, which will
              become old hive

Return Value:

    NTSTATUS

--*/
{
    KPROCESSOR_MODE PreviousMode;
    UNICODE_STRING NewHiveName;
    UNICODE_STRING OldFileName;
    NTSTATUS Status;
    PCM_KEY_BODY KeyBody;

    CM_PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtReplaceKey\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tNewFile =%p\n", NewFile));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tOldFile =%p\n", OldFile));

    PreviousMode = KeGetPreviousMode();

    //
    // Check to see if the caller has the privilege to make this call.
    //
    if (!SeSinglePrivilegeCheck(SeRestorePrivilege, PreviousMode)) {
        return(STATUS_PRIVILEGE_NOT_HELD);
    }

    KeEnterCriticalRegion();
    Status = CmpNameFromAttributes(NewFile,
                                   PreviousMode,
                                   &NewHiveName);
    if (!NT_SUCCESS(Status)) {
        KeLeaveCriticalRegion();
        return(Status);
    }

    Status = CmpNameFromAttributes(OldFile,
                                   PreviousMode,
                                   &OldFileName);
    if (!NT_SUCCESS(Status)) {
        ExFreePool(NewHiveName.Buffer);
        KeLeaveCriticalRegion();
        return(Status);
    }

    Status = ObReferenceObjectByHandle(TargetHandle,
                                       0,
                                       CmpKeyObjectType,
                                       PreviousMode,
                                       (PVOID *)&KeyBody,
                                       NULL);
    if (NT_SUCCESS(Status)) {

        if ( CmIsKcbReadOnly(KeyBody->KeyControlBlock) ) {
            //
            // key is protected
            //
            Status = STATUS_ACCESS_DENIED;
        } else {
            BEGIN_LOCK_CHECKPOINT;
            Status = CmReplaceKey(KeyBody->KeyControlBlock->KeyHive,
                                  KeyBody->KeyControlBlock->KeyCell,
                                  &NewHiveName,
                                  &OldFileName);
            END_LOCK_CHECKPOINT;
        }

        ObDereferenceObject((PVOID)KeyBody);
    }

    ExFreePool(OldFileName.Buffer);
    ExFreePool(NewHiveName.Buffer);
    KeLeaveCriticalRegion();

    return(Status);
}


NTSYSAPI
NTSTATUS
NTAPI
NtQueryMultipleValueKey(
    __in HANDLE KeyHandle,
    __inout_ecount(EntryCount) PKEY_VALUE_ENTRY ValueEntries,
    __in ULONG EntryCount,
    __out_bcount(*BufferLength) PVOID ValueBuffer,
    __inout PULONG BufferLength,
    __out_opt PULONG RequiredBufferLength
    )
/*++

Routine Description:

    Multiple values of any key may be queried atomically with
    this api.

Arguments:

    KeyHandle - Supplies the key to be queried.

    ValueNames - Supplies an array of value names to be queried

    ValueEntries - Returns an array of KEY_VALUE_ENTRY structures, one for each value.

    EntryCount - Supplies the number of entries in the ValueNames and ValueEntries arrays

    ValueBuffer - Returns the value data for each value.

    BufferLength - Supplies the length of the ValueBuffer array in bytes.
                   Returns the length of the ValueBuffer array that was filled in.

    RequiredBufferLength - if present, Returns the length in bytes of the ValueBuffer
                    array required to return all the values of this key.

Return Value:

    NTSTATUS

--*/

{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PCM_KEY_BODY KeyBody;
    ULONG LocalBufferLength;

    // Start registry call tracing
    StartWmiCmTrace();

    CM_PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtQueryMultipleValueKey\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tKeyHandle=%08lx\n", KeyHandle));

    PreviousMode = KeGetPreviousMode();
    Status = ObReferenceObjectByHandle(KeyHandle,
                                       KEY_QUERY_VALUE,
                                       CmpKeyObjectType,
                                       PreviousMode,
                                       (PVOID *)(&KeyBody),
                                       NULL);
    if (NT_SUCCESS(Status)) {
        //
        // hook the kcb for WMI
        //
        HookKcbForWmiCmTrace(KeyBody);

        try {
            if (PreviousMode == UserMode) {
                LocalBufferLength = ProbeAndReadUlong(BufferLength);

                //
                // Probe the output buffers
                //
                // Put an arbitrary 64K limit on the number of entries to
                // prevent bogus apps from passing an EntryCount large enough
                // to overflow the EntryCount * sizeof(KEY_VALUE_ENTRY) calculation.
                //
                if (EntryCount > 0x10000) {
                    ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
                }
                ProbeForWrite(ValueEntries,
                              EntryCount * sizeof(KEY_VALUE_ENTRY),
                              sizeof(ULONG));
                if (ARGUMENT_PRESENT(RequiredBufferLength)) {
                    ProbeForWriteUlong(RequiredBufferLength);
                }

                ProbeForWrite(ValueBuffer,
                              LocalBufferLength,
                              sizeof(ULONG));

            } else {
                LocalBufferLength = *BufferLength;
            }

            if (NT_SUCCESS(Status)) {
                if ( CmAreCallbacksRegistered() ) {
                    REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION QueryMultipleValueInfo;
            
                    QueryMultipleValueInfo.Object = KeyBody;
                    QueryMultipleValueInfo.ValueEntries = ValueEntries;
                    QueryMultipleValueInfo.EntryCount = EntryCount;
                    QueryMultipleValueInfo.ValueBuffer = ValueBuffer;
                    QueryMultipleValueInfo.BufferLength = BufferLength;
                    QueryMultipleValueInfo.RequiredBufferLength = RequiredBufferLength;

                    Status = CmpCallCallBacks(RegNtPreQueryMultipleValueKey,&QueryMultipleValueInfo,TRUE,RegNtPostQueryMultipleValueKey,KeyBody);
                }

                if (NT_SUCCESS(Status)) {
                    // not here because we want to catch user buffer misalignments
                    //BEGIN_LOCK_CHECKPOINT;
                    Status = CmQueryMultipleValueKey(KeyBody->KeyControlBlock,
                                                     ValueEntries,
                                                     EntryCount,
                                                     ValueBuffer,
                                                     &LocalBufferLength,
                                                     RequiredBufferLength);
                    //END_LOCK_CHECKPOINT;
                    // anybody messed with BufferLength in between?
                    *BufferLength = LocalBufferLength;
                    // 
                    // just a notification; disregard the return status
                    //
                    CmPostCallbackNotification(RegNtPostQueryMultipleValueKey,KeyBody,Status);

                }
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtQueryMultipleValueKey: code:%08lx\n",GetExceptionCode()));
            Status = GetExceptionCode();
        }


        ObDereferenceObject((PVOID)KeyBody);
    }

    // End registry call tracing
    EndWmiCmTrace(Status,EntryCount,NULL,EVENT_TRACE_TYPE_REGQUERYMULTIPLEVALUE);

    return(Status);

}

NTSTATUS
CmpNameFromAttributes(
    IN POBJECT_ATTRIBUTES Attributes,
    KPROCESSOR_MODE PreviousMode,
    OUT PUNICODE_STRING FullName
    )

/*++

Routine Description:

    This is a helper routine that converts OBJECT_ATTRIBUTES into a
    full object pathname.  This is needed because we cannot pass handles
    to the worker thread, since it runs in a different process.

    This routine will also probe and capture the attributes based on
    PreviousMode.

    Storage for the string buffer is allocated from paged pool, and should
    be freed by the caller.

Arguments:

    Attributes - Supplies the object attributes to be converted to a pathname

    PreviousMode - Supplies the previous mode.

    Name - Returns the object pathname.

Return Value:

    NTSTATUS

--*/

{
    OBJECT_ATTRIBUTES CapturedAttributes;
    UNICODE_STRING FileName;
    UNICODE_STRING RootName;
    NTSTATUS Status;
    ULONG ObjectNameLength;
    UCHAR ObjectNameInfo[512];
    POBJECT_NAME_INFORMATION ObjectName;
    PWSTR End;
    PUNICODE_STRING CapturedObjectName;
    ULONG   Length;

    CM_PAGED_CODE();
    FullName->Buffer = NULL;            // so we know whether to free it in our exception handler
    try {

        //
        // Probe the object attributes if necessary.
        //
        if (PreviousMode == UserMode) {
            ProbeForReadSmallStructure(Attributes,
                                       sizeof(OBJECT_ATTRIBUTES),
                                       sizeof(ULONG));
            CapturedObjectName = Attributes->ObjectName;
            ProbeAndReadUnicodeStringEx(&FileName,CapturedObjectName);
            ProbeForRead(FileName.Buffer,
                         FileName.Length,
                         sizeof(WCHAR));
        } else {
            FileName = *(Attributes->ObjectName);
        }

        CapturedAttributes = *Attributes;

        if (CapturedAttributes.RootDirectory != NULL) {

            if ((FileName.Buffer != NULL) &&
                (FileName.Length >= sizeof(WCHAR)) &&
                (*(FileName.Buffer) == OBJ_NAME_PATH_SEPARATOR)) {
                return(STATUS_OBJECT_PATH_SYNTAX_BAD);
            }

            //
            // Find the name of the root directory and append the
            // name of the relative object to it.
            //

            Status = ZwQueryObject(CapturedAttributes.RootDirectory,
                                   ObjectNameInformation,
                                   ObjectNameInfo,
                                   sizeof(ObjectNameInfo),
                                   &ObjectNameLength);

            ObjectName = (POBJECT_NAME_INFORMATION)ObjectNameInfo;
            if (!NT_SUCCESS(Status)) {
                return(Status);
            }
            RootName = ObjectName->Name;

            FullName->Length = 0;
            Length = RootName.Length+FileName.Length+sizeof(WCHAR);
            //
            // Overflow test: If Length overflows the USHRT_MAX value
            //                cleanup and return STATUS_OBJECT_PATH_INVALID
            //
            if ( Length>0xFFFF ) {
                return STATUS_OBJECT_PATH_INVALID;
            }

            FullName->MaximumLength = (USHORT)Length;

            FullName->Buffer = ALLOCATE_WITH_QUOTA(PagedPool, FullName->MaximumLength, CM_POOL_TAG);
            if (FullName->Buffer == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            Status = RtlAppendUnicodeStringToString(FullName, &RootName);
            ASSERT(NT_SUCCESS(Status));

            //
            // Append a trailing separator if necessary.
            //
            if ( FullName->Length != 0 ) {
                End = (PWSTR)((PUCHAR)FullName->Buffer + FullName->Length) - 1;
                if (*End != OBJ_NAME_PATH_SEPARATOR) {
                    ++End;
                    *End = OBJ_NAME_PATH_SEPARATOR;
                    FullName->Length += sizeof(WCHAR);
                }
            }

            Status = RtlAppendUnicodeStringToString(FullName, &FileName);
            ASSERT(NT_SUCCESS(Status));

        } else {

            //
            // RootDirectory is NULL, so just use the name.
            //
            FullName->Length = FileName.Length;
            FullName->MaximumLength = FileName.Length;
            FullName->Buffer = ALLOCATE_WITH_QUOTA(PagedPool, FileName.Length, CM_POOL_TAG);
            if (FullName->Buffer == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                RtlCopyMemory(FullName->Buffer,
                              FileName.Buffer,
                              FileName.Length);
                Status = STATUS_SUCCESS;
            }
        }


    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!CmpNameFromAttributes: code %08lx\n", Status));
        if (FullName->Buffer != NULL) {
            ExFreePool(FullName->Buffer);
        }
    }

    return(Status);
}

VOID
CmpFreePostBlock(
    IN PCM_POST_BLOCK PostBlock
    )

/*++

Routine Description:

    Frees the various bits of pool that were allocated for a postblock

Arguments:

    None

Return Value:

    None.

--*/

{

#if DBG
    if (PostBlock->TraceIntoDebugger) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"[CM]CmpFreePostBlock: PostBlock:%p\t", PostBlock));
        if ( PostBlock->NotifyType&REG_NOTIFY_MASTER_POST) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"--MasterBlock\n"));
        } else {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_FLOW,"--SlaveBlock\n"));
        }
    }
#endif

    // Protect for multiple deletion of the same object
    CmpClearListEntry(&(PostBlock->CancelPostList));

    //
    // Cleanup for objects referenced by NtNotifyMultipleKeys
    //
    if (PostBlock->PostKeyBody) {

        //
        // If we have a PostKeyBody, the attached key body must not be NULL
        //
        ASSERT(PostBlock->PostKeyBody->KeyBody);

        //
        // KeyBodyList must be used only in CmpPostBlock implementation for the delayed dereferencing mechanism.
        //
        ASSERT(IsListEmpty(&(PostBlock->PostKeyBody->KeyBodyList)));

        //
        // dereference the actual keybody
        //
        ObDereferenceObjectDeferDelete(PostBlock->PostKeyBody->KeyBody);

        //
        // Free the PostKeyBody structure
        //
        ExFreePool(PostBlock->PostKeyBody);
    }

    if ( IsMasterPostBlock(PostBlock) ) {
        //
        // this members are allocated only for master post blocks
        //
        switch (PostBlockType(PostBlock)) {
            case PostSynchronous:
                ExFreePool(PostBlock->u->Sync.SystemEvent);
                break;
            case PostAsyncUser:
                ExFreePool(PostBlock->u->AsyncUser.Apc);
                break;
            case PostAsyncKernel:
                break;
        }
        ExFreePool(PostBlock->u);
    }

    // and the storage for the Post object
    ExFreePool(PostBlock);
}


PCM_POST_BLOCK
CmpAllocatePostBlock(
    IN POST_BLOCK_TYPE  BlockType,
    IN ULONG            PostFlags,
    IN PCM_KEY_BODY     KeyBody,
    IN PCM_POST_BLOCK   MasterBlock
    )

/*++

Routine Description:

    Allocates a post block from pool.  The non-pageable stuff comes from
    NonPagedPool, the pageable stuff from paged pool.  Quota will be
    charged.

Arguments:

    BlockType  - specifies the type of the post block to be allocated
                i.e. : PostSyncrhronous, PostAsyncUser, PostAsyncKernel

    PostFlags      - specifies the flags to be set on the allocated post block
                valid flags:
                    - REG_NOTIFY_MASTER_POST - the post block to be allocated
                      is a master post block.
    KeyBody     - The Key object to whom this post block is attached. On master blocks
                  this is NULL. When the post object is freed, the KeyBody object is
                  dereferenced (if not NULL - i.e. for slave blocks). This allow us to
                  perform back-end cleanup for "fake-slave" keys opened by NtNotifyMultipleKeys
    MasterBlock - the post block to be allocated is a slave of this master block.
                  valid only when PostFlags ==  REG_NOTIFY_MASTER_POST


Obs: The Sync.SystemEvent and AsyncUser.Apc members are allocated only for master post blocks

Return Value:

    Pointer to the CM_POST_BLOCK if successful

    NULL if there were not enough resources available.

--*/

{
    PCM_POST_BLOCK PostBlock;

    // protection against outrageous calls
    ASSERT( !PostFlags || (!MasterBlock && !KeyBody) );

    PostBlock = ALLOCATE_WITH_QUOTA(PagedPool, sizeof(CM_POST_BLOCK),CM_POSTBLOCK_TAG);
    if (PostBlock==NULL) {
        return(NULL);
    }

#if DBG
    PostBlock->TraceIntoDebugger = FALSE;
#endif

    PostBlock->NotifyType = (ULONG)BlockType;
    PostBlock->NotifyType |= PostFlags;

    if (IsMasterPostBlock(PostBlock)) {
        PostBlock->PostKeyBody = NULL;
        //
        // master post block ==> allocate the storage
        //
        PostBlock->u = ALLOCATE_WITH_QUOTA(NonPagedPool,
                                           sizeof(CM_POST_BLOCK_UNION),
                                           CM_FIND_LEAK_TAG44);
        if (PostBlock->u == NULL) {
            ExFreePool(PostBlock);
            return(NULL);
        }

         switch (BlockType) {
            case PostSynchronous:
                PostBlock->u->Sync.SystemEvent = ALLOCATE_WITH_QUOTA(NonPagedPool,
                                                                    sizeof(KEVENT),
                                                                    CM_POSTEVENT_TAG);
                if (PostBlock->u->Sync.SystemEvent == NULL) {
                    ExFreePool(PostBlock->u);
                    ExFreePool(PostBlock);
                    return(NULL);
                }
                KeInitializeEvent(PostBlock->u->Sync.SystemEvent,
                                  SynchronizationEvent,
                                  FALSE);
                break;
            case PostAsyncUser:
                PostBlock->u->AsyncUser.Apc = ALLOCATE_WITH_QUOTA(NonPagedPool,
                                                             sizeof(KAPC),
                                                             CM_POSTAPC_TAG);
                if (PostBlock->u->AsyncUser.Apc==NULL) {
                    ExFreePool(PostBlock->u);
                    ExFreePool(PostBlock);
                    return(NULL);
                }
                break;
            case PostAsyncKernel:
                RtlZeroMemory(&PostBlock->u->AsyncKernel, sizeof(CM_ASYNC_KERNEL_POST_BLOCK));
                break;
        }
    } else {
        //
        // Slave post block ==> copy storage allocated for the master post block
        //
        PostBlock->u = MasterBlock->u;

        //
        // allocate a PostKeyBody which will hold this KeyBody, and initialize the head of its KeyBodyList
        //
        PostBlock->PostKeyBody = ALLOCATE_WITH_QUOTA(PagedPool| POOL_COLD_ALLOCATION, sizeof(CM_POST_KEY_BODY),CM_FIND_LEAK_TAG45);
        if (PostBlock->PostKeyBody == NULL) {
            ExFreePool(PostBlock);
            return(NULL);
        }
        PostBlock->PostKeyBody->KeyBody = KeyBody;
        InitializeListHead(&(PostBlock->PostKeyBody->KeyBodyList));
    }

    return(PostBlock);
}

#if DBG

LOGICAL CmpExceptionBreak = FALSE;

ULONG
CmpExceptionFilter(
    IN PEXCEPTION_POINTERS ExceptionPointers
    )

/*++

Routine Description:

    Debug code to find registry exceptions that are being swallowed

Return Value:

    EXCEPTION_EXECUTE_HANDLER

--*/

{
    CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CM: Registry exception %lx, ExceptionPointers = %p\n",
            ExceptionPointers->ExceptionRecord->ExceptionCode,
            ExceptionPointers));

    if (CmpExceptionBreak == TRUE) {

        try {
            DbgBreakPoint();
        } except (EXCEPTION_EXECUTE_HANDLER) {

            //
            // no debugger enabled, just keep going
            //

        }
    }

    return(EXCEPTION_EXECUTE_HANDLER);
}

#endif

ULONG   CmpOpenSubKeys;

NTSTATUS
NtQueryOpenSubKeys(
    __in POBJECT_ATTRIBUTES TargetKey,
    __out PULONG  HandleCount
    )
/*++

Routine Description:

    Dumps all the subkeys of the target key that are kept open by some other
    process; Returns the number of open subkeys


Arguments:

    TargetKey - specifies the path to a key to link the hive to.
                path must be of the form "\registry\user\<username>"

Return Value:

    NTSTATUS

--*/
{
    HANDLE              KeyHandle;
    NTSTATUS            Status;
    PCM_KEY_BODY        KeyBody = NULL;
    PHHIVE              Hive;
    HCELL_INDEX         Cell;
    KPROCESSOR_MODE     PreviousMode;
    UNICODE_STRING      HiveName;
    OBJECT_ATTRIBUTES   CapturedAttributes;
    UNICODE_STRING      CapturedObjectName;

    CM_PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtQueryOpenSubKeys\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tTargetKey =%p\n", TargetKey));

    PreviousMode = KeGetPreviousMode();

    try {

        if (PreviousMode == UserMode) {
            ProbeForWriteUlong(HandleCount);
            //
            // probe and capture the ObjectAttributes as we shall use it for opening the kernel handle
            //
            CapturedAttributes = ProbeAndReadStructure( TargetKey, OBJECT_ATTRIBUTES );

            ProbeAndReadUnicodeStringEx(&CapturedObjectName,CapturedAttributes.ObjectName);

            ProbeForRead(
                CapturedObjectName.Buffer,
                CapturedObjectName.Length,
                sizeof(WCHAR)
                );
            CapturedAttributes.ObjectName = &CapturedObjectName; 
        } else {
            CapturedAttributes = *TargetKey;
        }

        //
        // we open a private kernel mode handle just to take a reference on the object.
        //
        CapturedAttributes.Attributes |= OBJ_KERNEL_HANDLE;

        Status = ObOpenObjectByName(&CapturedAttributes,
                                    CmpKeyObjectType,
                                    KernelMode,
                                    NULL,
                                    KEY_READ,
                                    NULL,
                                    &KeyHandle);
        if (NT_SUCCESS(Status)) {
            Status = ObReferenceObjectByHandle(KeyHandle,
                                               KEY_READ,
                                               CmpKeyObjectType,
                                               KernelMode,
                                               (PVOID *)&KeyBody,
                                               NULL);
            ZwClose(KeyHandle);
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtQueryOpenSubKeys: code:%08lx\n", Status));
    }

    if (NT_SUCCESS(Status)) {
        ULONG   ConvKey1 = 0;
        ULONG   ConvKey2 = 0;
        //
        // only lock registry shared and this kcb exclusive
        //
        BEGIN_LOCK_CHECKPOINT;
        CmpLockRegistry();
        ConvKey1 = ConvKey2 = KeyBody->KeyControlBlock->ConvKey;
        if ( KeyBody->KeyControlBlock->ParentKcb != NULL ) {
            ConvKey2 = KeyBody->KeyControlBlock->ParentKcb->ConvKey;
        }
        CmpLockTwoHashEntriesExclusive(ConvKey1,ConvKey2);

        if ( KeyBody->KeyControlBlock->Delete ) {
            CmpUnlockTwoHashEntries(ConvKey1,ConvKey2);
            CmpUnlockRegistry();
            ObDereferenceObject((PVOID)KeyBody);
            return STATUS_KEY_DELETED;
        }

        Hive = KeyBody->KeyControlBlock->KeyHive;
        Cell = KeyBody->KeyControlBlock->KeyCell;

        //
        // Make sure the cell passed in is the root cell of the hive.
        //
        if (Cell != Hive->BaseBlock->RootCell) {
            CmpUnlockTwoHashEntries(ConvKey1,ConvKey2);
            CmpUnlockRegistry();
            ObDereferenceObject((PVOID)KeyBody);
            return(STATUS_INVALID_PARAMETER);
        }

        //
        // Dump the hive name and hive address
        //
        RtlInitUnicodeString(&HiveName, (PCWSTR)Hive->BaseBlock->FileName);
#if DBG
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"\n Subkeys open inside the hive (%p) (%.*S) :\n\n",Hive,HiveName.Length / sizeof(WCHAR),HiveName.Buffer);
#endif

        //
        // dump open subkeys (if any)
        //
        CmpOpenSubKeys = CmpSearchForOpenSubKeys(KeyBody->KeyControlBlock,SearchAndCount,FALSE,NULL);

        CmpUnlockTwoHashEntries(ConvKey1,ConvKey2);
        CmpUnlockRegistry();

        END_LOCK_CHECKPOINT;

        ObDereferenceObject((PVOID)KeyBody);
        try {
            //
            // protect user mode memory
            //
            *HandleCount = CmpOpenSubKeys;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
        }
    }

    return(Status);
}

NTSTATUS
NtQueryOpenSubKeysEx(
    __in POBJECT_ATTRIBUTES   TargetKey,
    __in ULONG                BufferLength,
    __out_bcount(BufferLength) PVOID               Buffer,
    __out PULONG              RequiredSize
    )
/*++

Routine Description:

    Queries for the open subkeys beneath the root of a hive


Arguments:

    TargetKey - specifies the path to a key to link the hive to.
                path must be of the form "\registry\user\<username>"

    BufferLength - size (in bytes) of the buffer passed in

    Buffer - buffer to hold the result (of type KEY_OPEN_SUBKEYS_INFORMATION )

    RequiredSize - buffer size needed to store the entire (PID,keyname) array

Return Value:

    NTSTATUS

--*/
{
    HANDLE                      KeyHandle;
    NTSTATUS                    Status;
    PCM_KEY_BODY                KeyBody = NULL;
    PHHIVE                      Hive;
    HCELL_INDEX                 Cell;
    KPROCESSOR_MODE             PreviousMode;
    OBJECT_ATTRIBUTES           CapturedAttributes;
    UNICODE_STRING              CapturedObjectName;
    QUERY_OPEN_SUBKEYS_CONTEXT  QueryContext = {0};

    CM_PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtQueryOpenSubKeysEx\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tTargetKey =%p\n", TargetKey));

    PreviousMode = KeGetPreviousMode();

    if (!SeSinglePrivilegeCheck(SeRestorePrivilege, PreviousMode)) {
        return(STATUS_PRIVILEGE_NOT_HELD);
    }

    if ( BufferLength < sizeof(ULONG) ) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    try {

        QueryContext.Buffer = Buffer;
        QueryContext.BufferLength = BufferLength;
        if (PreviousMode == UserMode) {
            //
            // probe and capture the ObjectAttributes as we shall use it for opening the kernel handle
            //
            CapturedAttributes = ProbeAndReadStructure( TargetKey, OBJECT_ATTRIBUTES );

            ProbeAndReadUnicodeStringEx(&CapturedObjectName,CapturedAttributes.ObjectName);

            ProbeForRead(
                CapturedObjectName.Buffer,
                CapturedObjectName.Length,
                sizeof(WCHAR)
                );
            CapturedAttributes.ObjectName = &CapturedObjectName; 

            ProbeForWriteUlong(RequiredSize);

            ProbeForWrite(QueryContext.Buffer,
                          BufferLength,
                          sizeof(ULONG));
        } else {
            CapturedAttributes = *TargetKey;
        }
        //
        // set array count to 0 and required size to fixed size of the struct.
        //
        *((PULONG)(QueryContext.Buffer)) = 0;
        QueryContext.UsedLength = QueryContext.RequiredSize = FIELD_OFFSET(KEY_OPEN_SUBKEYS_INFORMATION,KeyArray);
        QueryContext.CurrentNameBuffer = (PUCHAR)QueryContext.Buffer + BufferLength;

        //
        // we open a private kernel mode handle just to take a reference on the object.
        //
        CapturedAttributes.Attributes |= OBJ_KERNEL_HANDLE;

        Status = ObOpenObjectByName(&CapturedAttributes,
                                    CmpKeyObjectType,
                                    KernelMode,
                                    NULL,
                                    KEY_READ,
                                    NULL,
                                    &KeyHandle);
        if (NT_SUCCESS(Status)) {
            Status = ObReferenceObjectByHandle(KeyHandle,
                                               KEY_READ,
                                               CmpKeyObjectType,
                                               KernelMode,
                                               (PVOID *)&KeyBody,
                                               NULL);
            ZwClose(KeyHandle);
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtQueryOpenSubKeys: code:%08lx\n", Status));
    }

    if (NT_SUCCESS(Status)) {
        ULONG   ConvKey1 = 0;
        ULONG   ConvKey2 = 0;
        //
        // only lock registry shared and this kcb exclusive
        //
        BEGIN_LOCK_CHECKPOINT;
        CmpLockRegistry();
        ConvKey1 = ConvKey2 = KeyBody->KeyControlBlock->ConvKey;
        if ( KeyBody->KeyControlBlock->ParentKcb != NULL ) {
            ConvKey2 = KeyBody->KeyControlBlock->ParentKcb->ConvKey;
        }
        CmpLockTwoHashEntriesExclusive(ConvKey1,ConvKey2);

        if ( KeyBody->KeyControlBlock->Delete ) {
            CmpUnlockTwoHashEntries(ConvKey1,ConvKey2);
            CmpUnlockRegistry();
            ObDereferenceObject((PVOID)KeyBody);
            return STATUS_KEY_DELETED;
        }

        Hive = KeyBody->KeyControlBlock->KeyHive;
        Cell = KeyBody->KeyControlBlock->KeyCell;

        //
        // Make sure the cell passed in is the root cell of the hive.
        //
        if (Cell != Hive->BaseBlock->RootCell) {
            CmpUnlockTwoHashEntries(ConvKey1,ConvKey2);
            CmpUnlockRegistry();
            ObDereferenceObject((PVOID)KeyBody);
            return(STATUS_INVALID_PARAMETER);
        }


        //
        // query open subkeys (if any)
        //
		QueryContext.KeyBodyToIgnore = KeyBody;
        QueryContext.StatusCode = STATUS_SUCCESS;
        CmpSearchForOpenSubKeys(KeyBody->KeyControlBlock,SearchAndCount,FALSE,(PVOID)(&QueryContext));
        Status = QueryContext.StatusCode;

        CmpUnlockTwoHashEntries(ConvKey1,ConvKey2);
        CmpUnlockRegistry();

        END_LOCK_CHECKPOINT;

        ObDereferenceObject((PVOID)KeyBody);
        try {
            //
            // protect user mode memory
            //
            *RequiredSize = QueryContext.RequiredSize;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
        }
    }

    return(Status);
}

NTSTATUS
NtRenameKey(
    __in HANDLE           KeyHandle,
    __in PUNICODE_STRING  NewName
    )

/*++

Routine Description:

    Renames the key specified by Handle.

Arguments:

    NewFile - specifies the key to be renamed

    NewName - the new name the key will have if the API succeeds

Return Value:

    NTSTATUS

--*/
{
    UNICODE_STRING  LocalKeyName = {0};
    NTSTATUS        status;
    PCM_KEY_BODY    KeyBody;
    KPROCESSOR_MODE mode;
    WCHAR           *Cp;
    ULONG           i;

    CM_PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtRenameKey\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tKeyHandle=%08lx\n", KeyHandle));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tNewName='%wZ'\n", NewName));

    mode = KeGetPreviousMode();

    //
    // probe/capture args
    //
    try {
        if (mode == UserMode) {
            LocalKeyName = ProbeAndReadUnicodeString(NewName);
            ProbeForRead(
                LocalKeyName.Buffer,
                LocalKeyName.Length,
                sizeof(WCHAR)
                );
        } else {
            LocalKeyName = *NewName;
        }

        //
        // validate new name
        //
        if ( (LocalKeyName.Length > REG_MAX_KEY_NAME_LENGTH) ||
             (LocalKeyName.Length == 0) ||
             ((LocalKeyName.Length & (sizeof(WCHAR) - 1)) != 0) ) {
            return STATUS_INVALID_PARAMETER;
        }

        Cp = LocalKeyName.Buffer;
        for (i=0; i<LocalKeyName.Length; i += sizeof(WCHAR)) {
            if ( *Cp == OBJ_NAME_PATH_SEPARATOR ) {
                return STATUS_INVALID_PARAMETER;
            }
            ++Cp;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!NtRenameKey: code:%08lx\n", GetExceptionCode()));
        return GetExceptionCode();
    }

    status = ObReferenceObjectByHandle(
                KeyHandle,
                KEY_WRITE,
                CmpKeyObjectType,
                mode,
                (PVOID *)(&KeyBody),
                NULL
                );

    if (NT_SUCCESS(status)) {
        if ( CmAreCallbacksRegistered() ) {
            REG_RENAME_KEY_INFORMATION RenameKeyInfo;
    
            RenameKeyInfo.Object = KeyBody;
            RenameKeyInfo.NewName = &LocalKeyName;

            status = CmpCallCallBacks(RegNtPreRenameKey,&RenameKeyInfo,TRUE,RegNtPostRenameKey,KeyBody);
        }
        if ( NT_SUCCESS(status) ) { 
            //
            // we really need exclusive access here
            //
            BEGIN_LOCK_CHECKPOINT;
            CmpLockRegistryExclusive();

            //
            // flush notifications for all open objects on this key
            //
            CmpFlushNotifiesOnKeyBodyList(KeyBody->KeyControlBlock,TRUE);

            if ( CmIsKcbReadOnly(KeyBody->KeyControlBlock) ) {
                //
                // key is protected
                //
                status = STATUS_ACCESS_DENIED;
            } else {
                status = CmRenameKey(KeyBody->KeyControlBlock,LocalKeyName,mode);
            }

            //
            // we need to release just here, after the kcb has been kicked out of cache
            //
            CmpUnlockRegistry();
            END_LOCK_CHECKPOINT;
            // 
            // just a notification; disregard the return status
            //
            CmPostCallbackNotification(RegNtPostRenameKey,KeyBody,status);
        }
        ObDereferenceObject((PVOID)KeyBody);

    }

    return status;
}


ULONG
CmpKeyInfoProbeAlingment(
                             IN KEY_INFORMATION_CLASS KeyInformationClass
                        )
{
    switch(KeyInformationClass)
    {
    case KeyBasicInformation:
        return PROBE_ALIGNMENT(KEY_BASIC_INFORMATION);

    case KeyNodeInformation:
        return PROBE_ALIGNMENT(KEY_NODE_INFORMATION);

    case KeyFullInformation:
        return PROBE_ALIGNMENT(KEY_FULL_INFORMATION);

    case KeyNameInformation:
        return PROBE_ALIGNMENT(KEY_NAME_INFORMATION);

    case KeyCachedInformation:
        return PROBE_ALIGNMENT(KEY_CACHED_INFORMATION);

    case KeyFlagsInformation:
        return PROBE_ALIGNMENT(KEY_FLAGS_INFORMATION);

    default:
        ASSERT(FALSE);
    }

    return PROBE_ALIGNMENT(ULONG);
}

NTSTATUS
NtCompactKeys(
    __in ULONG Count,
    __in_ecount(Count) HANDLE KeyArray[]
            )
/*++

Routine Description:

    Compacts the keys in the given array together, so they will
    end up in the same bin (or adjacent)

Arguments:

    Count - number of keys in the array

    KeyArray - array of keys to be compacted.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS        status = STATUS_SUCCESS;
    NTSTATUS        status2;
    PCM_KEY_BODY    *KeyBodyArray = NULL;
    ULONG           i;
    PHHIVE          KeyHive;
    PCMHIVE         CmHive;
    KPROCESSOR_MODE mode;


    CM_PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtCompactKeys\n"));
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI_ARGS,"\tCount=%08lx\n", Count));


    mode = KeGetPreviousMode();

    //
    // Check to see if the caller has the privilege to make this call.
    //
    if (!SeSinglePrivilegeCheck(SeBackupPrivilege, mode)) {
        return(STATUS_PRIVILEGE_NOT_HELD);
    }

    if ( Count == 0 ) {
        //
        // noop
        //
        return STATUS_SUCCESS;
    }

    if ( Count >= (((ULONG)0xFFFFFFFF)/sizeof(PCM_KEY_BODY)) ) {
        return STATUS_INVALID_PARAMETER;
    }

    if (mode == UserMode) {
        try {
            ProbeForRead(KeyArray,
                         Count * sizeof(HANDLE),
                         sizeof(ULONG));
        } except (EXCEPTION_EXECUTE_HANDLER) {
            status = GetExceptionCode();
            return status;
        }
    }

    KeyBodyArray =  ExAllocatePool(PagedPool,Count * sizeof(PCM_KEY_BODY));

    if ( KeyBodyArray == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // reference each handle and make sure they are inside the same hive
    //
    i = 0;
    try {

        for(;i<Count;i++) {
            status = ObReferenceObjectByHandle(
                        KeyArray[i],
                        KEY_WRITE,
                        CmpKeyObjectType,
                        mode,
                        (PVOID *)(&(KeyBodyArray[i])),
                        NULL
                        );
            if (!NT_SUCCESS(status)) {
                //
                // cleanup
                //
                for(;i;i--) {
                    ObDereferenceObject((PVOID)(KeyBodyArray[i-1]));
                }
                ExFreePool(KeyBodyArray);
                return status;
            }
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        //
        // cleanup
        //
        for(;i;i--) {
            ObDereferenceObject((PVOID)(KeyBodyArray[i-1]));
        }
        ExFreePool(KeyBodyArray);
        return status;

    }

    KeyHive = NULL;
    BEGIN_LOCK_CHECKPOINT;
    CmpLockRegistryExclusive();

    for(i=0;i<Count;i++) {
        if ( (KeyBodyArray[i])->KeyControlBlock->Delete ) {
            status = STATUS_KEY_DELETED;
            goto Exit;
        }
        if ( i > 0 ) {
            if ( KeyHive != (KeyBodyArray[i])->KeyControlBlock->KeyHive ) {
                //
                // not same hive
                //
                status = STATUS_INVALID_PARAMETER;
                goto Exit;
            }
        } else {
            KeyHive = (KeyBodyArray[i])->KeyControlBlock->KeyHive;
        }

    }
    //
    // set the hive into "Grow Only mode"
    //
    CmHive = (PCMHIVE)CONTAINING_RECORD(KeyHive, CMHIVE, Hive);
    CmHive->GrowOnlyMode = TRUE;
    CmHive->GrowOffset = KeyHive->Storage[Stable].Length;

    //
    // truncate to the CM_VIEW_SIZE segment
    //
    CmHive->GrowOffset += HBLOCK_SIZE;
    CmHive->GrowOffset &= (~(CM_VIEW_SIZE - 1));
    if ( CmHive->GrowOffset ) {
        CmHive->GrowOffset -= HBLOCK_SIZE;
    }

    //
    // move each kcb at offset > HiveLength
    //
    for(i=0;i<Count;i++) {
        status2 = CmMoveKey((KeyBodyArray[i])->KeyControlBlock);
        if ( !NT_SUCCESS(status2) && NT_SUCCESS(status)) {
            //
            // record the status and go on with the remaining
            //
            status = status2;
        }
    }

    //
    // reset the "Grow Only mode" to normal
    //
    CmHive->GrowOnlyMode = FALSE;
    CmHive->GrowOffset = 0;

Exit:
    CmpUnlockRegistry();
    END_LOCK_CHECKPOINT;

    //
    // cleanup
    //
    for(i=0;i<Count;i++) {
        ObDereferenceObject((PVOID)(KeyBodyArray[i]));
    }
    ExFreePool(KeyBodyArray);

    return status;
}


NTSTATUS
NtCompressKey(
    __in HANDLE Key
            )
/*++

Routine Description:

    Compresses the specified key (must be the root of a hive),
    by simulating an "in-place" SaveKey.

Arguments:


    Key - root of the hive to be compressed.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    PCM_KEY_BODY    KeyBody;
    KPROCESSOR_MODE mode;


    CM_PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_NTAPI,"NtCompressKey\n"));


    mode = KeGetPreviousMode();
    //
    // Check to see if the caller has the privilege to make this call.
    //
    if (!SeSinglePrivilegeCheck(SeBackupPrivilege, mode)) {
        return(STATUS_PRIVILEGE_NOT_HELD);
    }

    status = ObReferenceObjectByHandle(
                Key,
                KEY_WRITE,
                CmpKeyObjectType,
                